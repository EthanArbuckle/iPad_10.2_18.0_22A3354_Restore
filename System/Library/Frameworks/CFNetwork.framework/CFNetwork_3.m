_QWORD *__copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE64c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[9];
  result[8] = a2[8];
  result[9] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = a2[11];
  result[10] = a2[10];
  result[11] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE64c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = a1 + 32;
  v2 = a1 + 48;
  v3 = a1 + 64;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void ___ZN12HTTPProtocol17askAppSSOForCredsElP15__CFHTTPMessage_block_invoke(_QWORD *a1, std::__shared_weak_count_vtbl *a2, std::__shared_weak_count_vtbl *a3)
{
  NSObject *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  _QWORD v40[5];
  std::__shared_weak_count *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  std::__shared_weak_count_vtbl *v44;
  std::__shared_weak_count *v45;
  std::__shared_weak_count_vtbl *v46;
  std::__shared_weak_count *v47;
  std::__shared_weak_count_vtbl *v48;
  std::__shared_weak_count *v49;
  _BYTE buf[22];
  __int16 v51;
  std::__shared_weak_count_vtbl *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_QWORD *)(a1[4] + 792);
    *(_DWORD *)buf = 138543874;
    *(_QWORD *)&buf[4] = v7;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = a2;
    v51 = 2112;
    v52 = a3;
    _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "%{public}@ received AppSSO headers %@ error %@", buf, 0x20u);
  }
  if (a2)
    a2 = (std::__shared_weak_count_vtbl *)CFRetain(a2);
  *(_QWORD *)buf = a2;
  v8 = (std::__shared_weak_count *)operator new();
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A58;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = a2;
  *(_QWORD *)&buf[8] = v8;
  if (a3)
    a3 = (std::__shared_weak_count_vtbl *)CFRetain(a3);
  v48 = a3;
  v10 = (std::__shared_weak_count *)operator new();
  v10->__shared_owners_ = 0;
  v11 = (unint64_t *)&v10->__shared_owners_;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19B0;
  v10->__shared_weak_owners_ = 0;
  v10[1].__vftable = a3;
  v49 = v10;
  v13 = a1[4];
  v12 = (std::__shared_weak_count *)a1[5];
  v14 = *(_QWORD *)(v13 + 24);
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 3321888768;
  v40[2] = ___ZN12HTTPProtocol17askAppSSOForCredsElP15__CFHTTPMessage_block_invoke_65;
  v40[3] = &__block_descriptor_96_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE64c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE_e5_v8__0l;
  v40[4] = v13;
  v41 = v12;
  if (v12)
  {
    v15 = (unint64_t *)&v12->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = (std::__shared_weak_count *)a1[7];
  v42 = a1[6];
  v43 = v17;
  if (v17)
  {
    v18 = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v44 = a2;
  v45 = v8;
  do
    v20 = __ldxr(p_shared_owners);
  while (__stxr(v20 + 1, p_shared_owners));
  v46 = a3;
  v47 = v10;
  do
    v21 = __ldxr(v11);
  while (__stxr(v21 + 1, v11));
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v14 + 96))(v14, v40);
  v22 = v47;
  if (v47)
  {
    v23 = (unint64_t *)&v47->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v45;
  if (v45)
  {
    v26 = (unint64_t *)&v45->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v43;
  if (v43)
  {
    v29 = (unint64_t *)&v43->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v41;
  if (v41)
  {
    v32 = (unint64_t *)&v41->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = v49;
  if (v49)
  {
    v35 = (unint64_t *)&v49->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v38 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
}

void sub_184075900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  va_list va;
  uint64_t v21;
  va_list va1;

  va_start(va1, a13);
  va_start(va, a13);
  v19 = va_arg(va1, _QWORD);
  v21 = va_arg(va1, _QWORD);
  v17 = v13;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v14);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v16);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol17askAppSSOForCredsElP15__CFHTTPMessage_block_invoke_65(_QWORD *a1)
{
  uint64_t v1;
  __CFHTTPMessage *v2;
  const __CFDictionary *v3;
  void *v4;
  NSObject *v5;
  __CFError *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  const __CFAllocator *v10;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  const void *Value;
  const __CFAllocator *v14;
  __CFArray *v15;
  const __CFAllocator *v16;
  CFDictionaryRef Copy;
  const void *v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  const __CFAllocator *v26;
  __CFDictionary *Mutable;
  __CFError *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  _BOOL4 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  NSObject *size;
  int v40;
  uint64_t v41;
  __int16 v42;
  _BYTE v43[18];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v1 = a1[4];
  v2 = (__CFHTTPMessage *)a1[6];
  v3 = (const __CFDictionary *)a1[8];
  v4 = (void *)a1[10];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_QWORD *)(v1 + 792);
    v40 = 138543874;
    v41 = v7;
    v42 = 2112;
    *(_QWORD *)v43 = v3;
    *(_WORD *)&v43[8] = 2112;
    *(_QWORD *)&v43[10] = v4;
    _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@ handling AppSSO headers %@ error %@", (uint8_t *)&v40, 0x20u);
  }
  v8 = *(_QWORD *)(v1 + 328);
  if (v8 != 0x7FFFFFFFFFFFFFFFLL)
    *(_QWORD *)(v1 + 328) = v8 + 1;
  v9 = (*(unsigned int *)(v1 + 192) | ((unint64_t)*(unsigned __int16 *)(v1 + 196) << 32)) & 0xFDFFFFFFFFFDLL;
  *(_DWORD *)(v1 + 192) &= ~2u;
  *(_WORD *)(v1 + 196) = WORD2(v9);
  if (!v3 || v4)
  {
    if (AppSSO::isPerformDefaultHandlingError((AppSSO *)v4, v6))
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v19 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v20 = *(_QWORD *)(v1 + 792);
        v40 = 138543618;
        v41 = v20;
        v42 = 2112;
        *(_QWORD *)v43 = v2;
        _os_log_impl(&dword_183ECA000, v19, OS_LOG_TYPE_DEFAULT, "%{public}@ AppSSO performing default handling for %@", (uint8_t *)&v40, 0x16u);
      }
      *(_BYTE *)(v1 + 856) = 1;
      if (HTTPProtocol::_CFHTTPProtHasCredentialsForChallenge((HTTPProtocol *)v1, v2))
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v21 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          v22 = *(_QWORD *)(v1 + 792);
          v23 = *(_QWORD *)(v1 + 352);
          v24 = *(_QWORD *)(v1 + 376);
          v40 = 138543874;
          v41 = v22;
          v42 = 2112;
          *(_QWORD *)v43 = v23;
          *(_WORD *)&v43[8] = 2112;
          *(_QWORD *)&v43[10] = v24;
          _os_log_impl(&dword_183ECA000, v21, OS_LOG_TYPE_DEFAULT, "%{public}@ AppSSO default handling has creds %@ challenge %@", (uint8_t *)&v40, 0x20u);
        }
        HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
        (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v1 + 120))(v1, *(_QWORD *)(v1 + 352), *(_QWORD *)(v1 + 376));
      }
      else if (((*(unsigned int *)(v1 + 192) | ((unint64_t)*(unsigned __int16 *)(v1 + 196) << 32)) & 0x100004000000) != 0)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v29 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          v30 = *(_QWORD *)(v1 + 792);
          v40 = 138543362;
          v41 = v30;
          _os_log_impl(&dword_183ECA000, v29, OS_LOG_TYPE_DEFAULT, "%{public}@ AppSSO default handling is waiting for Accounts or Private Acccess Tokens", (uint8_t *)&v40, 0xCu);
        }
        HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
      }
      else
      {
        v31 = *(_QWORD *)(v1 + 376);
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v32 = CFNLog::logger;
        v33 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
        if (v31)
        {
          if (v33)
          {
            v34 = *(_QWORD *)(v1 + 792);
            v35 = *(_QWORD *)(v1 + 376);
            v40 = 138543618;
            v41 = v34;
            v42 = 2112;
            *(_QWORD *)v43 = v35;
            _os_log_impl(&dword_183ECA000, v32, OS_LOG_TYPE_DEFAULT, "%{public}@ AppSSO default handling did not find creds, will send challenge %@", (uint8_t *)&v40, 0x16u);
          }
          HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
          HTTPProtocol::sendDidReceiveAuthChallenge((HTTPProtocol *)v1, *(_CFURLAuthChallenge **)(v1 + 376));
        }
        else
        {
          if (v33)
          {
            v37 = *(_QWORD *)(v1 + 792);
            v38 = *(_DWORD *)(v1 + 732);
            size = *(NSObject **)(v1 + 720);
            if (size)
              size = dispatch_data_get_size(size);
            v40 = 138543874;
            v41 = v37;
            v42 = 1024;
            *(_DWORD *)v43 = v38;
            *(_WORD *)&v43[4] = 2048;
            *(_QWORD *)&v43[6] = size;
            _os_log_impl(&dword_183ECA000, v32, OS_LOG_TYPE_DEFAULT, "%{public}@ AppSSO default deliverying response recorded(%d, %zu)", (uint8_t *)&v40, 0x1Cu);
          }
          HTTPProtocol::performHeaderReadPostProcessing((HTTPProtocol *)v1, v2, 1);
          HTTPProtocol::deliverUnhandledResponse((HTTPProtocol *)v1);
        }
      }
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v25 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v36 = *(_QWORD *)(v1 + 792);
        v40 = 138543874;
        v41 = v36;
        v42 = 2112;
        *(_QWORD *)v43 = v3;
        *(_WORD *)&v43[8] = 2112;
        *(_QWORD *)&v43[10] = v4;
        _os_log_error_impl(&dword_183ECA000, v25, OS_LOG_TYPE_ERROR, "%{public}@ AppSSO received headers %@ error %@ canceling", (uint8_t *)&v40, 0x20u);
      }
      v26 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (v4)
      {
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CB3388], v4);
      }
      else
      {
        Mutable = 0;
      }
      v28 = CFErrorCreate(v26, CFSTR("kCFErrorDomainCFNetwork"), -1012, Mutable);
      URLProtocol::sendDidFail((URLProtocol *)v1, v28);
      if (v28)
        CFRelease(v28);
      if (Mutable)
        CFRelease(Mutable);
    }
  }
  else
  {
    v10 = CFGetAllocator((CFTypeRef)(v1 - 16));
    Count = CFDictionaryGetCount(v3);
    MutableCopy = CFDictionaryCreateMutableCopy(v10, Count, v3);
    Value = CFDictionaryGetValue(v3, &unk_1EDCFD660);
    if (Value)
    {
      v14 = CFGetAllocator((CFTypeRef)(v1 - 16));
      v15 = CFArrayCreateMutable(v14, 1, MEMORY[0x1E0C9B378]);
      CFArrayAppendValue(v15, Value);
      HTTPProtocol::updateCookieStoreDuringHeaderRead((HTTPProtocol *)v1, v15);
      if (v15)
        CFRelease(v15);
    }
    if (MutableCopy)
    {
      CFDictionaryRemoveValue(MutableCopy, &unk_1EDCFD660);
      v16 = CFGetAllocator((CFTypeRef)(v1 - 16));
      Copy = CFDictionaryCreateCopy(v16, MutableCopy);
      v18 = *(const void **)(v1 + 840);
      *(_QWORD *)(v1 + 840) = Copy;
      if (v18)
        CFRelease(v18);
      CFRelease(MutableCopy);
    }
    -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*(_QWORD *)(v1 + 832), 3, 0);
    HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
    HTTPProtocol::createAndOpenStream((HTTPProtocol *)v1, 0);
  }
}

void sub_184075F9C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN12HTTPProtocol30attemptToCacheMovedPermanentlyEP15__CFHTTPMessage23CFURLCacheStoragePolicyPK13_CFURLRequest_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void ___ZN12HTTPProtocol42asynchronouslyHandleHTTPResponseExternallyEP15__CFHTTPMessage_block_invoke(uint64_t a1, char a2, CFTypeRef cf, std::__shared_weak_count_vtbl *a4)
{
  std::__shared_weak_count_vtbl *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  _QWORD v34[5];
  std::__shared_weak_count *v35;
  std::__shared_weak_count_vtbl *v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  char v40;
  std::__shared_weak_count_vtbl *v41;
  std::__shared_weak_count *v42;
  std::__shared_weak_count_vtbl *v43;
  std::__shared_weak_count *v44;

  if (cf)
    v7 = (std::__shared_weak_count_vtbl *)CFRetain(cf);
  else
    v7 = 0;
  v43 = v7;
  v8 = (std::__shared_weak_count *)operator new();
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A58;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = v7;
  v44 = v8;
  if (a4)
    a4 = (std::__shared_weak_count_vtbl *)CFRetain(a4);
  v41 = a4;
  v10 = (std::__shared_weak_count *)operator new();
  v10->__shared_owners_ = 0;
  v11 = (unint64_t *)&v10->__shared_owners_;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A20;
  v10->__shared_weak_owners_ = 0;
  v10[1].__vftable = a4;
  v42 = v10;
  v12 = *(_QWORD *)(a1 + 32);
  v13 = *(_QWORD *)(v12 + 24);
  v34[0] = MEMORY[0x1E0C809B0];
  v34[1] = 3321888768;
  v34[2] = ___ZN12HTTPProtocol42asynchronouslyHandleHTTPResponseExternallyEP15__CFHTTPMessage_block_invoke_2;
  v34[3] = &__block_descriptor_81_e8_32c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE48c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE64c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  v40 = a2;
  v34[4] = v7;
  v35 = v8;
  do
    v14 = __ldxr(p_shared_owners);
  while (__stxr(v14 + 1, p_shared_owners));
  v36 = a4;
  v37 = v10;
  do
    v15 = __ldxr(v11);
  while (__stxr(v15 + 1, v11));
  v16 = *(std::__shared_weak_count **)(a1 + 40);
  v38 = v12;
  v39 = v16;
  if (v16)
  {
    v17 = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 96))(v13, v34);
  v19 = v39;
  if (v39)
  {
    v20 = (unint64_t *)&v39->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v37;
  if (v37)
  {
    v23 = (unint64_t *)&v37->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = v35;
  if (v35)
  {
    v26 = (unint64_t *)&v35->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = v42;
  if (v42)
  {
    v29 = (unint64_t *)&v42->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v44;
  if (v44)
  {
    v32 = (unint64_t *)&v44->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
}

void sub_1840762AC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4 - 80);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4 - 64);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void ___ZN12HTTPProtocol42asynchronouslyHandleHTTPResponseExternallyEP15__CFHTTPMessage_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  const void *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  NSObject *v12;
  CFTypeRef v13;
  const void *v14;
  NSObject *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  const void *v30;
  std::__shared_weak_count *v31;
  uint8_t buf[4];
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 64);
  *(_DWORD *)(v2 + 728) = 3;
  if (*(_BYTE *)(a1 + 80))
  {
    v4 = *(const void **)(a1 + 32);
    v3 = *(std::__shared_weak_count **)(a1 + 40);
    v30 = v4;
    v31 = v3;
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    v8 = *(_QWORD *)(a1 + 48);
    v7 = *(std::__shared_weak_count **)(a1 + 56);
    if (v7)
    {
      v9 = (unint64_t *)&v7->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = *(_DWORD *)(v2 + 192) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)(v2 + 196) << 32);
    *(_DWORD *)(v2 + 192) &= ~2u;
    *(_WORD *)(v2 + 196) = WORD2(v11);
    *(_QWORD *)(v2 + 728) = 1;
    v12 = *(NSObject **)(v2 + 720);
    if (v12)
    {
      dispatch_release(v12);
      *(_QWORD *)(v2 + 720) = 0;
    }
    if (!v8)
    {
      if (v4)
      {
        if (CFDictionaryGetCount((CFDictionaryRef)v4))
        {
          v13 = CFRetain(v4);
          v14 = *(const void **)(v2 + 704);
          *(_QWORD *)(v2 + 704) = v13;
          if (v14)
            CFRelease(v14);
        }
      }
    }
    HTTPProtocol::destroyReadStream((HTTPProtocol *)v2);
    if (v8)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v15 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v16 = *(_QWORD *)(v2 + 792);
        *(_DWORD *)buf = 138543618;
        v33 = v16;
        v34 = 2112;
        v35 = v8;
        _os_log_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEFAULT, "%{public}@ external auth will start new request %@", buf, 0x16u);
      }
      v17 = *(void **)(v2 + 80);
      if (v17)
        objc_msgSend(v17, "set_appleIDContextRedirect:", 1, v8, v7, v30);
      v18 = *(_QWORD *)(v2 + 96);
      if (v18)
      {
        v19 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v18 + 16))(*(_QWORD *)(v2 + 96));
        v20 = (void *)MEMORY[0x186DB8C8C](v19);
        (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(v2 + 96) + 40))(*(_QWORD *)(v2 + 96), v8, 0);
        objc_autoreleasePoolPop(v20);
        (*(void (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18);
      }
    }
    else
    {
      HTTPProtocol::createAndOpenStream((HTTPProtocol *)v2, 0);
    }
    if (v7)
    {
      v26 = (unint64_t *)&v7->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    if (v31)
    {
      v28 = (unint64_t *)&v31->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v21 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v22 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 792);
      *(_DWORD *)buf = 138543362;
      v33 = v22;
      _os_log_impl(&dword_183ECA000, v21, OS_LOG_TYPE_DEFAULT, "%{public}@ authentication client does not want to continue load", buf, 0xCu);
    }
    v23 = *(_QWORD *)(a1 + 64);
    HTTPProtocol::performHeaderReadPostProcessing((HTTPProtocol *)v23, *(__CFHTTPMessage **)(v23 + 712), 1);
    v24 = *(NSObject **)(v23 + 720);
    if (v24)
      HTTPProtocol::bytesAvailable(v23, v24);
    if (*(_DWORD *)(v23 + 732) == 2)
    {
      HTTPProtocol::destroyReadStream((HTTPProtocol *)v23);
      if ((*(_DWORD *)(v23 + 192) & 0x80) == 0)
        HTTPProtocol::endEncountered((HTTPProtocol *)v23);
    }
    *(_QWORD *)(v23 + 728) = 1;
    v25 = *(NSObject **)(v23 + 720);
    if (v25)
    {
      dispatch_release(v25);
      *(_QWORD *)(v23 + 720) = 0;
    }
  }
}

void sub_1840766B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(exception_object);
}

_QWORD *__copy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE48c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE64c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[9];
  result[8] = a2[8];
  result[9] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE48c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE64c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = a1 + 32;
  v2 = a1 + 48;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

uint64_t ___ZN12HTTPProtocol17performHeaderReadEP15__CFHTTPMessage_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 4111;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_2_162(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_10(uint64_t a1)
{
  const __CFAllocator *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = CFGetAllocator((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
  return __cfnCreateCFError(v1, CFSTR("kCFErrorDomainCFNetwork"), -1003, v2, v3, v4, v5, v6, 0);
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_12(uint64_t a1)
{
  const __CFAllocator *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = CFGetAllocator((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
  return __cfnCreateCFError(v1, CFSTR("kCFErrorDomainCFNetwork"), -1003, v2, v3, v4, v5, v6, 0);
}

uint64_t HTTPProtocol::nextTLSFallbackMethod(HTTPProtocol *this)
{
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  const __CFNumber *Value;
  const __CFNumber *v5;
  unsigned int v6;
  SSLProtocol v7;
  unsigned int v8;
  const void *v9;
  uint64_t v10;
  const void *v11;
  int v12;
  uint64_t valuePtr;

  v2 = HTTPProtocol::copySSLPropertiesForStream(this, 0);
  v3 = v2;
  if (v2)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(v2, &unk_1EDCFB3D0);
    v5 = (const __CFNumber *)CFDictionaryGetValue(v3, &unk_1EDCFB398);
    if (Value)
    {
      valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
      LODWORD(v2) = valuePtr;
    }
    else
    {
      LODWORD(v2) = 0;
    }
  }
  else
  {
    v5 = 0;
  }
  v6 = tlsProtocolVersionForSSLProtocol((SSLProtocol)v2, 1);
  if (v5)
  {
    valuePtr = 0;
    CFNumberGetValue(v5, kCFNumberCFIndexType, &valuePtr);
    v7 = (int)valuePtr;
  }
  else
  {
    v7 = kSSLProtocolUnknown;
  }
  v8 = tlsProtocolVersionForSSLProtocol(v7, 0);
  v9 = (const void *)*((_QWORD *)this + 36);
  if (v9)
  {
    if (CFEqual(v9, (CFTypeRef)*MEMORY[0x1E0CD6888]) && v6 <= 0x303 && v8 >= 0x303)
    {
      v10 = *MEMORY[0x1E0CD6848];
      goto LABEL_25;
    }
    v11 = (const void *)*((_QWORD *)this + 36);
    if (v11)
    {
      v12 = CFEqual(v11, (CFTypeRef)*MEMORY[0x1E0CD6848]);
      if (v8 <= 0x300 || v6 >= 0x302 || v12 == 0)
        v10 = 0;
      else
        v10 = *MEMORY[0x1E0CD6870];
      goto LABEL_25;
    }
  }
  v10 = 0;
LABEL_25:
  if (v3)
    CFRelease(v3);
  return v10;
}

void sub_1840769B4(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_3_120(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v2 + 96);
  if (v3)
  {
    v4 = *(unsigned __int8 *)(a1 + 56);
    v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v3 + 16))(*(_QWORD *)(v2 + 96));
    v6 = (void *)MEMORY[0x186DB8C8C](v5);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 96) + 144))(*(_QWORD *)(v2 + 96), v4);
    objc_autoreleasePoolPop(v6);
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  }
  v7 = *(_QWORD *)(a1 + 40);
  *(CFAbsoluteTime *)(v7 + 32) = CFAbsoluteTimeGetCurrent();
}

uint64_t ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_2_114@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 3494;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 3475;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol31handleAlternatePathNotificationE36nw_connection_alternate_path_state_t_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 96);
  if (v2)
  {
    v3 = *(unsigned int *)(a1 + 40);
    v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v2 + 16))(*(_QWORD *)(v1 + 96));
    v5 = (void *)MEMORY[0x186DB8C8C](v4);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 96) + 152))(*(_QWORD *)(v1 + 96), v3);
    objc_autoreleasePoolPop(v5);
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  }
  *(CFAbsoluteTime *)(v1 + 32) = CFAbsoluteTimeGetCurrent();
  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN12HTTPProtocol35handleConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 96);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 40);
    v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v2 + 16))(*(_QWORD *)(v1 + 96));
    v5 = (void *)MEMORY[0x186DB8C8C](v4);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 96) + 136))(*(_QWORD *)(v1 + 96), v3);
    objc_autoreleasePoolPop(v5);
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  }
  *(CFAbsoluteTime *)(v1 + 32) = CFAbsoluteTimeGetCurrent();
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN12HTTPProtocol24postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t *a2)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  v4 = *(_QWORD **)(a1 + 40);
  v5 = (std::__shared_weak_count *)a2[1];
  v21 = *a2;
  v22 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  (*(void (**)(_QWORD *, uint64_t *))(*v4 + 600))(v4, &v21);
  v8 = v22;
  if (v22)
  {
    v9 = (unint64_t *)&v22->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v4[34];
  v12 = (std::__shared_weak_count *)a2[1];
  v19 = *a2;
  v20 = v12;
  if (v12)
  {
    v13 = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v11 + 136))(v11, &v19);
  v15 = v20;
  if (v20)
  {
    v16 = (unint64_t *)&v20->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32));
}

void sub_184076D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  _QWORD v5[5];

  v2 = *(_QWORD *)(a1 + 48);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke_2;
  v5[3] = &unk_1E14FDEB0;
  v3 = *(_QWORD *)(a1 + 32);
  v5[4] = *(_QWORD *)(a1 + 40);
  v4 = (const void *)(v2 - 16);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD *))(*(_QWORD *)v2 + 376))(v2, v3, 0, v5);
  nw_release(*(void **)(a1 + 32));
  CFRelease(v4);
}

uint64_t ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  _QWORD v5[5];

  v3 = a1[5];
  v2 = a1[6];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke_2;
  v5[3] = &unk_1E14F9E00;
  v5[4] = a1[4];
  (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v3 + 368))(v3, v2, v5);
  v4 = (const void *)a1[6];
  if (v4)
    CFRelease(v4);
  CFRelease((CFTypeRef)(v3 - 16));
}

uint64_t ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  _QWORD v5[5];

  v3 = a1[5];
  v2 = a1[6];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke_2;
  v5[3] = &unk_1E14F9E28;
  v5[4] = a1[4];
  (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v3 + 360))(v3, v2, v5);
  v4 = (const void *)a1[6];
  if (v4)
    CFRelease(v4);
  CFRelease((CFTypeRef)(v3 - 16));
}

uint64_t ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN12HTTPProtocol25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = (const void *)(v2 - 16);
  (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v2 + 352))(v2, *(_QWORD *)(a1 + 32), 0, *(_QWORD *)(a1 + 40));
  nw_release(*(void **)(a1 + 32));
  CFRelease(v3);
}

uint64_t ___ZN12HTTPProtocol25canRetryRequestAfterErrorEPK13CFStreamErrorb_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 2130;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol14resetAuthStateEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  __int128 v5;

  _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((std::__shared_weak_count_vtbl **)&v5);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(a1 + 32) + 776, &v5);
  v2 = (std::__shared_weak_count *)*((_QWORD *)&v5 + 1);
  if (*((_QWORD *)&v5 + 1))
  {
    v3 = (unint64_t *)(*((_QWORD *)&v5 + 1) + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

void ___ZN12HTTPProtocol27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  int HasCredentialsForChallenge;
  uint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  __int128 v24;
  uint64_t v25;
  std::__shared_weak_count *v26;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(v2 + 192);
  v4 = v3 | ((unint64_t)*(unsigned __int16 *)(v2 + 196) << 32) | 0x8000000000;
  *(_DWORD *)(v2 + 192) = v3;
  *(_WORD *)(v2 + 196) = WORD2(v4);
  v5 = *(std::__shared_weak_count **)(a1 + 48);
  v25 = *(_QWORD *)(a1 + 40);
  v26 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 600))(v2, &v25);
  v8 = v26;
  if (v26)
  {
    v9 = (unint64_t *)&v26->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if (!*(_QWORD *)(v2 + 776))
  {
    _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((std::__shared_weak_count_vtbl **)&v24);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v2 + 776, &v24);
    v21 = (std::__shared_weak_count *)*((_QWORD *)&v24 + 1);
    if (*((_QWORD *)&v24 + 1))
    {
      v22 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }
  v12 = *(_QWORD *)(a1 + 56);
  v11 = *(_QWORD *)(a1 + 64);
  if (v11)
  {
    v13 = (unint64_t *)(v11 + 8);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  *(_QWORD *)(v2 + 624) = v12;
  v15 = *(std::__shared_weak_count **)(v2 + 632);
  *(_QWORD *)(v2 + 632) = v11;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  HasCredentialsForChallenge = HTTPProtocol::_CFHTTPProtHasCredentialsForChallenge(*(HTTPProtocol **)(a1 + 72), (__CFHTTPMessage *)(*(_QWORD *)(a1 + 88) - 16));
  if ((*(_DWORD *)(v2 + 192) & 0x200000) == 0 && *(_QWORD *)(v2 + 776))
  {
    if (HasCredentialsForChallenge)
    {
      v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 616))(v2);
      v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 648))(v2);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2 + 120))(v2, v19, v20);
    }
    else
    {
      HTTPProtocol::challengeDelegateOrFinishBrokeringProxyAuth((HTTPProtocol *)v2);
    }
  }
}

void sub_184077228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_40c41_ZTSKNSt3__110shared_ptrI12NetworkProxyEE56c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE72c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE88c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;

  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[10];
  result[9] = a2[9];
  result[10] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = a2[12];
  result[11] = a2[11];
  result[12] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c41_ZTSKNSt3__110shared_ptrI12NetworkProxyEE56c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE72c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE88c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = a1 + 40;
  v2 = a1 + 56;
  v3 = a1 + 72;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 88);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void _ApplyOriginalComponents(void *a1, CFTypeRef *a2)
{
  CFTypeRef v3;
  uint64_t v4;
  BOOL v6;
  int v7;
  const void *v8;
  int32x4_t v9;
  int64x2_t v10;
  const __CFString *v11;
  CFStringRef theString2[4];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  CFStringRef theString1[4];
  __int128 v17;
  __int128 v18;
  CFTypeRef cf[2];

  if (!a1)
    return;
  v3 = *a2;
  v4 = objc_msgSend(a1, "cfURL");
  if (!v3 || v4 == 0)
    return;
  v18 = 0u;
  *(_OWORD *)cf = 0u;
  v17 = 0u;
  v15 = 0u;
  memset(theString1, 0, sizeof(theString1));
  v13 = 0u;
  v14 = 0u;
  memset(theString2, 0, sizeof(theString2));
  if (_CFURLCopyComponents() && _CFURLCopyComponents())
  {
    if (cf[0])
      v6 = (_QWORD)v15 == 0;
    else
      v6 = 0;
    v7 = v6;
    if (v6)
      *(_QWORD *)&v15 = CFRetain(cf[0]);
    if (theString1[0])
    {
      if (theString2[0])
      {
        if (theString1[3])
        {
          if (theString2[3])
          {
            if (CFStringCompare(theString1[0], theString2[0], 1uLL) == kCFCompareEqualTo
              && CFStringCompare(theString1[3], theString2[3], 1uLL) == kCFCompareEqualTo)
            {
              v9 = (int32x4_t)vtstq_s64(*(int64x2_t *)&theString1[1], *(int64x2_t *)&theString1[1]);
              *(int32x2_t *)v9.i8 = vmovn_s64((int64x2_t)v9);
              v9.i32[0] = vmovn_s32(v9).u32[0];
              v10 = vceqzq_s64(*(int64x2_t *)&theString2[1]);
              v9.i32[1] = vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v10, v10)).i32[1];
              if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(*(int16x4_t *)v9.i8, 0xFuLL))) & 1) != 0
                && (_QWORD)v17 == (_QWORD)v13)
              {
                theString2[1] = (CFStringRef)CFRetain(theString1[1]);
                v11 = theString1[2];
                if (theString1[2])
                  v11 = (const __CFString *)CFRetain(theString1[2]);
                theString2[2] = v11;
                goto LABEL_24;
              }
            }
          }
        }
      }
    }
    if (v7)
    {
LABEL_24:
      v8 = (const void *)_CFURLCreateFromComponents();
      goto LABEL_26;
    }
  }
  v8 = 0;
LABEL_26:
  _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper((uint64_t)theString2);
  _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper((uint64_t)theString1);
  if (v8)
  {
    CFRetain(v8);
    if (*a2)
      CFRelease(*a2);
    *a2 = v8;
    CFRelease(v8);
  }
}

void sub_1840774A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  const void *v19;

  CFRelease(v19);
  _Unwind_Resume(a1);
}

uint64_t HTTPRequestParserClient::isHeadRequest(HTTPRequestParserClient *this)
{
  uint64_t result;
  uint8_t v3[16];

  result = *((_QWORD *)this + 3);
  if (result)
    return CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo;
  result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT);
  if ((_DWORD)result)
  {
    *(_WORD *)v3 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", v3, 2u);
    result = *((_QWORD *)this + 3);
    if (result)
      return CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo;
  }
  return result;
}

uint64_t ___ZN12HTTPProtocol29validateCachedResponseForLoadEPK20_CFCachedURLResponse_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 755;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

intptr_t ___ZN12HTTPProtocol22copyCookiesForThisTaskEP16NSURLSessionTask_block_invoke(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v3;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void std::deque<SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::pop_front(uint64_t a1)
{
  int64x2_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](*(_QWORD *)(*(_QWORD *)(a1 + 8) + ((*(_QWORD *)(a1 + 32) >> 5) & 0x7FFFFFFFFFFFFF8))+ 16 * *(_QWORD *)(a1 + 32));
  v2 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1841E3870);
  *(int64x2_t *)(a1 + 32) = v2;
  if (v2.i64[0] >= 0x200uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 256;
  }
}

void setTypeProperty<_CFURLAuthChallenge *>(CFTypeRef *a1, CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  if (*a1)
    CFRelease(*a1);
  *a1 = cf;
}

void HTTPProtocol::executePACQuery(HTTPProtocol *this, void *cf, __CFString *a3)
{
  void *v6;
  CFTypeRef v7;
  CFTypeRef v8;
  const void *v9;
  CFStreamClientContext *v10;
  PAC *v11;
  uint64_t v12;
  const void *Username;
  const _CFURLCredential *v14;
  uint64_t v15;
  const void *v16;
  __CFRunLoopSource *v17;
  uint64_t v18;
  CFTypeRef v19;
  const void *v20;
  CFTypeRef v21;
  const void *v22;
  uint64_t v23;
  CFStringRef (__cdecl *v24)(const void *);
  const __CFAllocator *v25;
  CFAbsoluteTime Current;
  __CFRunLoopTimer *v27;
  __CFRunLoop *v28;
  __CFRunLoop *v29;
  const void *v30;
  CFTypeRef v31;
  __CFRunLoop *v32;
  __CFRunLoop *v33;
  __int128 v34;
  CFRunLoopSourceContext context;

  v6 = (void *)*((_QWORD *)this + 11);
  v7 = (CFTypeRef)*((_QWORD *)this + 49);
  if (v7 != cf)
  {
    if (v7)
      CFRelease(v7);
    if (cf)
      v8 = CFRetain(cf);
    else
      v8 = 0;
    *((_QWORD *)this + 49) = v8;
  }
  v9 = *(const void **)(objc_msgSend(v6, "_inner", 0, this, 0, 0, 0) + 8);
  if (a3)
    v11 = (PAC *)a3;
  else
    v11 = (PAC *)cf;
  *((_QWORD *)this + 38) = PAC::CreatePACTicket(v11, v9, 0, 0, (std::__shared_weak_count_vtbl *)HTTPProtocol::_PACExecutionComplete, (void (*)(void *, const __CFArray *, __CFError *))&v34, v10);
  v12 = *((_QWORD *)this + 45);
  if (v12)
  {
    Username = (const void *)CFURLCredentialGetUsername(v12);
    v15 = URLCredential_PasswordBased::safelyCast(*((_QWORD *)this + 45), v14);
    if (v15)
      v16 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 128))(v15);
    else
      v16 = 0;
    v17 = (__CFRunLoopSource *)*((_QWORD *)this + 38);
    memset(&context, 0, sizeof(context));
    CFRunLoopSourceGetContext(v17, &context);
    v18 = *((_QWORD *)context.info + 7);
    if (Username)
      v19 = CFRetain(Username);
    else
      v19 = 0;
    v20 = *(const void **)(v18 + 16);
    *(_QWORD *)(v18 + 16) = v19;
    if (v20)
      CFRelease(v20);
    if (v16)
      v21 = CFRetain(v16);
    else
      v21 = 0;
    v22 = *(const void **)(v18 + 24);
    *(_QWORD *)(v18 + 24) = v21;
    if (v22)
      CFRelease(v22);
    if (v16)
      CFRelease(v16);
  }
  v23 = *((_QWORD *)this + 3);
  if (v23 && *(_DWORD *)(v23 + 40))
  {
    v24 = (CFStringRef (__cdecl *)(const void *))*((_QWORD *)this + 38);
    context.version = MEMORY[0x1E0C809B0];
    context.info = (void *)3221225472;
    context.retain = (const void *(__cdecl *)(const void *))___ZNK17CoreSchedulingSet14scheduleSourceEP17__CFRunLoopSource_block_invoke;
    context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
    context.copyDescription = v24;
    CoreSchedulingSet::applyBlockWithPossibleEmulation(v23, &context);
  }
  else
  {
    context.version = 0;
    memset(&context.retain, 0, 24);
    context.info = this;
    v25 = CFGetAllocator((char *)this - 16);
    Current = CFAbsoluteTimeGetCurrent();
    v27 = CFRunLoopTimerCreate(v25, Current + 60.0, -1.0, 0, 0, (CFRunLoopTimerCallBack)HTTPProtocol::_PacTimerCallback, (CFRunLoopTimerContext *)&context);
    v28 = CFRunLoopGetCurrent();
    CFRunLoopAddTimer(v28, v27, CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"));
    v29 = CFRunLoopGetCurrent();
    CFRunLoopAddSource(v29, *((CFRunLoopSourceRef *)this + 38), CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"));
    v30 = (const void *)*((_QWORD *)this + 38);
    if (v30)
    {
      v31 = CFRetain(v30);
      while (*((_QWORD *)this + 38))
        CFRunLoopRunInMode(CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"), 1.0e10, 1u);
    }
    else
    {
      v31 = 0;
    }
    v32 = CFRunLoopGetCurrent();
    CFRunLoopRemoveTimer(v32, v27, CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"));
    v33 = CFRunLoopGetCurrent();
    CFRunLoopRemoveSource(v33, *((CFRunLoopSourceRef *)this + 38), CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"));
    if (v27)
      CFRelease(v27);
    if (v31)
      CFRelease(v31);
  }
}

void HTTPProtocol::_PacTimerCallback(HTTPProtocol *this, __CFRunLoopTimer *a2, void *a3)
{
  const __CFAllocator *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFError *CFError;
  uint64_t v11;
  uint64_t v12;
  __CFRunLoop *Current;

  v4 = CFGetAllocator((char *)a2 - 16);
  CFError = __cfnCreateCFError(v4, CFSTR("kCFErrorDomainCFNetwork"), 308, v5, v6, v7, v8, v9, 0);
  v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_132, 2);
  if (v11)
  {
    v12 = v11;
    if ((*(unsigned int (**)(uint64_t, const char *, __CFRunLoopTimer *))(*(_QWORD *)v11 + 24))(v11, "Protocol PAC Timeout", a2))
    {
      (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v12 + 48))(v12, "Request", *((_QWORD *)a2 + 11));
      (*(void (**)(uint64_t, const char *, __CFError *))(*(_QWORD *)v12 + 56))(v12, "Error", CFError);
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
    }
  }
  HTTPProtocol::pacExecutionComplete((HTTPProtocol *)a2, 0, CFError);
  if (CFError)
    CFRelease(CFError);
  Current = CFRunLoopGetCurrent();
  CFRunLoopStop(Current);
}

void HTTPProtocol::pacExecutionComplete(HTTPProtocol *this, const __CFArray *a2, CFErrorRef err)
{
  __CFRunLoopSource *v6;
  const void *v7;
  const __CFDictionary *v8;
  const void *Value;
  const void *v10;
  __CFHTTPMessage *v11;
  const __CFAllocator *v12;
  _CFHTTPAuthentication *v13;
  _CFHTTPAuthentication *v14;
  const __CFURL *v15;
  _BOOL4 v16;
  const __CFString *v17;
  SInt32 v18;
  int v19;
  const __CFString *v20;
  _CFHTTPAuthentication *v21;
  CFAllocatorRef v22;
  int v23;
  const __CFArray *v24;
  CFIndex Count;
  CFIndex v26;
  const __CFAllocator *v27;
  __CFArray *Mutable;
  const void *v29;
  const __CFAllocator *v30;
  CFIndex v31;
  uint64_t v32;
  int v33;
  const void *v34;
  CFAllocatorRef v35;
  id v36;
  CFAllocatorRef v37;
  uint64_t v38;
  _CFURLProtectionSpace *v39;
  const _CFURLCredential *v40;
  const void *v41;
  uint64_t v42;
  const _CFURLCredential *v43;
  uint64_t v44;
  const void *v45;
  unsigned __int8 v46;
  int v47;
  const void *v48;
  const __CFDictionary *v49;
  CFRange v50;
  CFRange v51;

  v6 = (__CFRunLoopSource *)*((_QWORD *)this + 38);
  if (v6)
  {
    CFRunLoopSourceInvalidate(v6);
    v7 = (const void *)*((_QWORD *)this + 38);
    if (v7)
      CFRelease(v7);
  }
  *((_QWORD *)this + 38) = 0;
  if (!err)
  {
    v24 = (const __CFArray *)*((_QWORD *)this + 37);
    if (v24)
    {
      Count = CFArrayGetCount(v24);
      v26 = CFArrayGetCount(a2);
      v27 = CFGetAllocator((char *)this - 16);
      Mutable = CFArrayCreateMutable(v27, v26 + Count, MEMORY[0x1E0C9B378]);
      v50.location = 0;
      v50.length = v26;
      CFArrayAppendArray(Mutable, a2, v50);
      v51.location = 0;
      v51.length = Count;
      CFArrayAppendArray(Mutable, *((CFArrayRef *)this + 37), v51);
      v29 = (const void *)*((_QWORD *)this + 37);
      if (v29)
        CFRelease(v29);
    }
    else
    {
      v30 = CFGetAllocator((char *)this - 16);
      v31 = CFArrayGetCount(a2);
      Mutable = CFArrayCreateMutableCopy(v30, v31, a2);
    }
    *((_QWORD *)this + 37) = Mutable;
    if (*((_QWORD *)this + 45))
    {
      v32 = *((_QWORD *)this + 48);
      if (v32)
      {
        if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
          dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
        (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 87) + 56))(*((_QWORD *)this + 87), *((_QWORD *)this + 45), *(_QWORD *)(v32 + 40), *((_QWORD *)this + 10));
      }
    }
LABEL_29:
    HTTPProtocol::createAndOpenStream(this, 0);
    return;
  }
  if (CFErrorGetDomain(err) != CFSTR("kCFErrorDomainCFNetwork") || CFErrorGetCode(err) != 309)
  {
    if (!*((_QWORD *)this + 37))
    {
      URLProtocol::sendDidFail((URLProtocol *)this, err);
      return;
    }
    goto LABEL_29;
  }
  v8 = CFErrorCopyUserInfo(err);
  Value = CFDictionaryGetValue(v8, CFSTR("kCFProxyAutoConfigurationURLKey"));
  v10 = (const void *)*((_QWORD *)this + 48);
  if (v10)
    CFRelease(v10);
  v11 = (__CFHTTPMessage *)CFDictionaryGetValue(v8, CFSTR("kCFProxyAutoConfigurationHTTPResponse"));
  v12 = CFGetAllocator((char *)this - 16);
  v13 = (_CFHTTPAuthentication *)_CFHTTPAuthenticationCreateFromResponseInternal(v12, v11, 0, 1, 0, 0, 0, 0, 0, v46);
  if (!v13)
    goto LABEL_31;
  v14 = v13;
  if (!CFHTTPAuthenticationIsValid(v13, 0))
  {
    CFRelease(v14);
LABEL_31:
    *((_QWORD *)this + 48) = 0;
LABEL_32:
    URLProtocol::sendDidFail((URLProtocol *)this, err);
    goto LABEL_33;
  }
  v48 = Value;
  v49 = v8;
  v15 = CFHTTPMessageCopyRequestURL(v11);
  v16 = connectionTypeFromURL(v15);
  v17 = CFURLCopyHostName(v15);
  v18 = CFURLGetPortNumber(v15);
  if (v16)
    v19 = 443;
  else
    v19 = 80;
  if (v18 != -1)
    v19 = v18;
  v47 = v19;
  v20 = CFHTTPAuthenticationCopyRealm(v14);
  v22 = CFGetAllocator((char *)this - 16);
  if ((v16 - 1) > 3)
    v23 = 1;
  else
    v23 = dword_1841E3AA0[v16 - 1];
  v33 = URLProtectionSpace::authSchemeForAuth(v14, v21);
  v34 = (const void *)CFURLProtectionSpaceCreate((uint64_t)v22, v17, v47, v23, v20, v33);
  if (v15)
    CFRelease(v15);
  if (v17)
    CFRelease(v17);
  if (v20)
    CFRelease(v20);
  v35 = CFGetAllocator((char *)this - 16);
  v36 = CFURLResponseCreateWithHTTPResponse((uint64_t)v35, v48, (uint64_t)v11, 2);
  v37 = CFGetAllocator((char *)this - 16);
  v38 = CFURLAuthChallengeCreate((uint64_t)v37, v34, 0, 0, v36, 0);

  if (v34)
    CFRelease(v34);
  CFRelease(v14);
  *((_QWORD *)this + 48) = v38;
  v8 = v49;
  if (!v38)
    goto LABEL_32;
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v39 = *(_CFURLProtectionSpace **)(v38 + 40);
  v40 = (const _CFURLCredential *)*((_QWORD *)this + 45);
  if (v40)
  {
    HTTPProtocol::RemoveCredentialPasswordForProtectionSpace(this, v40, v39, 1);
    v41 = (const void *)*((_QWORD *)this + 45);
    *((_QWORD *)this + 45) = 0;
    if (v41)
      CFRelease(v41);
  }
  if (*((_QWORD *)this + 48))
  {
    v42 = (*(uint64_t (**)(_QWORD, _CFURLProtectionSpace *, _QWORD))(**((_QWORD **)this + 87) + 80))(*((_QWORD *)this + 87), v39, *((_QWORD *)this + 10));
    *((_QWORD *)this + 45) = v42;
    if (!v42)
      goto LABEL_59;
    v44 = URLCredential_PasswordBased::safelyCast(v42, v43);
    if (!v44 || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v44 + 136))(v44))
    {
      v45 = (const void *)*((_QWORD *)this + 45);
      *((_QWORD *)this + 45) = 0;
      if (!v45)
        goto LABEL_59;
      CFRelease(v45);
    }
  }
  if (*((_QWORD *)this + 45))
  {
    HTTPProtocol::executePACQuery(this, v48, 0);
    goto LABEL_33;
  }
LABEL_59:
  HTTPProtocol::sendDidReceiveAuthChallenge(this, *((_CFURLAuthChallenge **)this + 48));
LABEL_33:
  if (v8)
    CFRelease(v8);
}

uint64_t ___ZN12HTTPProtocol19pacExecutionTimeoutEP16__CFRunLoopTimer_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 3800;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = (const void *)(v2 - 16);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 88))(v2, *(_QWORD *)(a1 + 40));
  CFRelease(v3);
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_7311()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(_QWORD *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_18407801C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t BlockHolderVar<void *>::invoke_initial(_QWORD *a1)
{
  a1[1] = BlockHolderVar<void *>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void std::__shared_ptr_pointer<BlockHolderVar<void *> *,SmartBlockWithArgs<void *>::Deleter,std::allocator<BlockHolderVar<void *>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void ___ZN12HTTPProtocol24handleProxyAuthChallengeEP15__CFHTTPMessagejPK10__CFStringi18SmartBlockWithArgsIJPK16_CFURLCredentialbEE_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  _QWORD *v8;
  char **v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  int64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  char *v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  __int128 v39;
  void *v40;
  __int128 v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  unint64_t v50;
  char *v51;
  uint64_t v52;
  char *v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  void *v59;
  void *v60;
  unint64_t v61;
  char *v62;
  uint64_t v63;
  uint64_t *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  void *v70;
  char *v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  int64_t v81;
  void *v82;
  uint64_t v83;
  unint64_t v84;
  char *v85;
  uint64_t v86;
  char *v87;
  _QWORD *v88;
  char *v89;
  _BYTE *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  char *v96;
  uint64_t v97;
  char *v98;
  uint64_t v99;
  uint64_t v100;
  char *v101;
  uint64_t *v102;
  uint64_t v103;
  uint64_t v104;
  void *v105;
  _QWORD *v106;
  unint64_t *v107;
  unint64_t v108;
  const __CFAllocator *v109;
  const __CFString *v110;
  std::__shared_weak_count *v111;
  CFURLRef v112;
  _OWORD *v113;
  CFArrayRef v114;
  uint64_t v115;
  uint64_t *v116;
  uint64_t v117;
  std::__shared_weak_count *v118;
  unint64_t *v119;
  unint64_t v120;
  void (*v121)(_QWORD *, uint64_t, _QWORD);
  uint64_t v122;
  _QWORD *v123;
  unint64_t *v124;
  unint64_t v125;
  char v126;
  uint64_t v127;
  char v128;
  int v129;
  void *v130;
  uint64_t v131;
  const void *v132;
  NSObject *v133;
  id v134;
  NSObject *v135;
  char v136;
  NSObject *v137;
  uint64_t v138;
  void (*v139)(_QWORD *, _QWORD, _QWORD);
  uint64_t v140;
  _QWORD *v141;
  std::__shared_weak_count *v142;
  unint64_t *v143;
  unint64_t v144;
  std::__shared_weak_count *v145;
  unint64_t *v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  char *v150;
  uint64_t v151;
  char *v152;
  uint64_t *v153;
  uint64_t v154;
  uint64_t v155;
  char *v156;
  uint64_t v157;
  void *v158;
  uint64_t v159;
  uint64_t v160;
  unsigned __int8 v161;
  __int128 v162;
  __int128 v163;
  const void *ValueAtIndex;
  uint64_t v165;
  CFTypeRef cf[2];
  CFTypeRef cfb[2];
  uint64_t cfc;
  CFTypeRef cfd[2];
  const __CFString *cfa;
  CFArrayRef theArray;
  CFStringRef URLString;
  std::__shared_weak_count *v173;
  uint64_t v174;
  std::__shared_weak_count *v175;
  _BYTE buf[22];
  __int16 v177;
  uint64_t v178;
  __int16 v179;
  int v180;
  uint64_t v181;

  v181 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD **)(a1 + 32);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v3 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v46 = v2[99];
    v47 = *(_QWORD *)(a1 + 40);
    v48 = *(_QWORD *)(a1 + 48);
    v49 = *(_DWORD *)(a1 + 112);
    *(_DWORD *)buf = 138544130;
    *(_QWORD *)&buf[4] = v46;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v47;
    v177 = 2112;
    v178 = v48;
    v179 = 1024;
    v180 = v49;
    _os_log_debug_impl(&dword_183ECA000, v3, OS_LOG_TYPE_DEBUG, "%{public}@ handling proxy auth challenge for %@ host %@ port %d", buf, 0x26u);
  }
  v5 = *(_QWORD *)(a1 + 64);
  v4 = *(std::__shared_weak_count **)(a1 + 72);
  v174 = v5;
  v175 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  if (v5)
  {
    *(_QWORD *)(v5 + 8) = BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_normal;
    *(_QWORD *)(v5 + 16) = 0;
  }
  v8 = v2 + 80;
  v9 = (char **)(v2 + 81);
  v10 = (char *)v2[82];
  v11 = (char *)v2[81];
  v12 = v10 - v11;
  if (v10 == v11)
    v13 = 0;
  else
    v13 = 32 * (v10 - v11) - 1;
  v14 = v2[84];
  v15 = v2[85];
  v16 = v15 + v14;
  if (v13 == v15 + v14)
  {
    if (v14 < 0x100)
    {
      v30 = v12 >> 3;
      v31 = (char *)v2[83];
      v32 = (char *)v2[80];
      v33 = v31 - v32;
      if (v12 >> 3 >= (unint64_t)((v31 - v32) >> 3))
      {
        if (v31 == v32)
          v34 = 1;
        else
          v34 = v33 >> 2;
        v35 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v34);
        v37 = v36;
        v38 = &v35[8 * v30];
        *(_QWORD *)&v39 = v35;
        *((_QWORD *)&v39 + 1) = v38;
        *(_OWORD *)cf = v39;
        v40 = operator new(0x1000uLL);
        *(_QWORD *)&v41 = v38;
        *((_QWORD *)&v41 + 1) = &v35[8 * v37];
        if (v30 == v37)
        {
          v42 = 8 * v30;
          *(CFTypeRef *)&v43 = cf[0];
          if (v12 < 1)
          {
            v82 = v40;
            v83 = v42 >> 2;
            if (v10 == v11)
              v84 = 1;
            else
              v84 = v83;
            v85 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v84);
            v38 = &v85[8 * (v84 >> 2)];
            *(_QWORD *)&v43 = v85;
            *((_QWORD *)&v43 + 1) = v38;
            *(_QWORD *)&v41 = v38;
            *((_QWORD *)&v41 + 1) = &v85[8 * v86];
            if (v35)
            {
              v162 = v41;
              *(_OWORD *)cfb = v43;
              operator delete(v35);
              v41 = v162;
              v43 = *(_OWORD *)cfb;
            }
            v40 = v82;
          }
          else
          {
            v44 = v42 >> 3;
            if (v44 >= -1)
              v45 = v44 + 1;
            else
              v45 = v44 + 2;
            v38 -= 8 * (v45 >> 1);
            *(_QWORD *)&v41 = v38;
            *((_QWORD *)&v43 + 1) = v38;
          }
        }
        else
        {
          v43 = *(_OWORD *)cf;
        }
        *(_QWORD *)v38 = v40;
        *(_QWORD *)&v41 = v41 + 8;
        v87 = (char *)v2[82];
        v8 = v2 + 80;
        while (v87 != *v9)
        {
          v88 = (_QWORD *)*((_QWORD *)&v43 + 1);
          if (*((_QWORD *)&v43 + 1) == (_QWORD)v43)
          {
            v90 = (_BYTE *)v41;
            if ((unint64_t)v41 >= *((_QWORD *)&v41 + 1))
            {
              if (*((_QWORD *)&v41 + 1) == *((_QWORD *)&v43 + 1))
                v95 = 1;
              else
                v95 = (uint64_t)(*((_QWORD *)&v41 + 1) - *((_QWORD *)&v43 + 1)) >> 2;
              v96 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v95);
              v89 = &v96[(2 * v95 + 6) & 0xFFFFFFFFFFFFFFF8];
              v98 = v89;
              v99 = v90 - (_BYTE *)v88;
              if (v90 != (_BYTE *)v88)
              {
                v98 = &v89[v99 & 0xFFFFFFFFFFFFFFF8];
                v100 = 8 * (v99 >> 3);
                v101 = &v96[(2 * v95 + 6) & 0xFFFFFFFFFFFFFFF8];
                v102 = v88;
                do
                {
                  v103 = *v102++;
                  *(_QWORD *)v101 = v103;
                  v101 += 8;
                  v100 -= 8;
                }
                while (v100);
              }
              *(_QWORD *)&v43 = v96;
              *((_QWORD *)&v43 + 1) = &v96[(2 * v95 + 6) & 0xFFFFFFFFFFFFFFF8];
              *(_QWORD *)&v41 = v98;
              *((_QWORD *)&v41 + 1) = &v96[8 * v97];
              if (v88)
              {
                v163 = v41;
                *(_OWORD *)cfd = v43;
                operator delete(v88);
                v41 = v163;
                v43 = *(_OWORD *)cfd;
              }
            }
            else
            {
              v91 = (uint64_t)(*((_QWORD *)&v41 + 1) - v41) >> 3;
              if (v91 >= -1)
                v92 = v91 + 1;
              else
                v92 = v91 + 2;
              v93 = v92 >> 1;
              v94 = v41 + 8 * (v92 >> 1);
              v89 = (char *)(v94 - (v41 - *((_QWORD *)&v43 + 1)));
              if ((_QWORD)v41 == *((_QWORD *)&v43 + 1))
              {
                v90 = (_BYTE *)*((_QWORD *)&v43 + 1);
              }
              else
              {
                v165 = *((_QWORD *)&v41 + 1);
                cfc = v43;
                memmove((void *)(v94 - (v41 - *((_QWORD *)&v43 + 1))), *((const void **)&v43 + 1), v41 - *((_QWORD *)&v43 + 1));
                *((_QWORD *)&v41 + 1) = v165;
                *(_QWORD *)&v43 = cfc;
              }
              *((_QWORD *)&v43 + 1) = v89;
              *(_QWORD *)&v41 = &v90[8 * v93];
            }
          }
          else
          {
            v89 = (char *)*((_QWORD *)&v43 + 1);
          }
          v104 = *((_QWORD *)v87 - 1);
          v87 -= 8;
          *((_QWORD *)v89 - 1) = v104;
          *((_QWORD *)&v43 + 1) -= 8;
        }
        v105 = (void *)v2[80];
        *((_OWORD *)v2 + 40) = v43;
        *((_OWORD *)v2 + 41) = v41;
        if (v105)
          operator delete(v105);
        goto LABEL_93;
      }
      if (v31 == v10)
      {
        v60 = operator new(0x1000uLL);
        if (v32 == v11)
        {
          if (v10 == v11)
            v61 = 1;
          else
            v61 = v33 >> 2;
          v62 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v61);
          v11 = &v62[(2 * v61 + 6) & 0xFFFFFFFFFFFFFFF8];
          v64 = (uint64_t *)v2[81];
          v65 = v11;
          v66 = v2[82] - (_QWORD)v64;
          if (v66)
          {
            v65 = &v11[v66 & 0xFFFFFFFFFFFFFFF8];
            v67 = 8 * (v66 >> 3);
            v68 = &v62[(2 * v61 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              v69 = *v64++;
              *(_QWORD *)v68 = v69;
              v68 += 8;
              v67 -= 8;
            }
            while (v67);
          }
          v70 = (void *)v2[80];
          v2[80] = v62;
          v2[81] = v11;
          v2[82] = v65;
          v2[83] = &v62[8 * v63];
          if (v70)
          {
            operator delete(v70);
            v11 = *v9;
          }
        }
        *((_QWORD *)v11 - 1) = v60;
        v71 = (char *)v2[81];
        v2[81] = v71 - 8;
        v72 = *((_QWORD *)v71 - 1);
        v2[81] = v71;
        v73 = (char *)v2[82];
        if (v73 == (char *)v2[83])
        {
          v74 = (uint64_t)&v71[-*v8];
          if ((unint64_t)v71 <= *v8)
          {
            if (v73 == (char *)*v8)
              v149 = 1;
            else
              v149 = (uint64_t)&v73[-*v8] >> 2;
            v150 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v149);
            v152 = &v150[8 * (v149 >> 2)];
            v153 = (uint64_t *)v2[81];
            v73 = v152;
            v154 = v2[82] - (_QWORD)v153;
            if (v154)
            {
              v73 = &v152[v154 & 0xFFFFFFFFFFFFFFF8];
              v155 = 8 * (v154 >> 3);
              v156 = &v150[8 * (v149 >> 2)];
              do
              {
                v157 = *v153++;
                *(_QWORD *)v156 = v157;
                v156 += 8;
                v155 -= 8;
              }
              while (v155);
            }
            v158 = (void *)v2[80];
            v2[80] = v150;
            v2[81] = v152;
            v2[82] = v73;
            v2[83] = &v150[8 * v151];
            if (v158)
            {
              operator delete(v158);
              v73 = (char *)v2[82];
            }
          }
          else
          {
            v75 = v74 >> 3;
            v22 = v74 >> 3 < -1;
            v76 = (v74 >> 3) + 2;
            if (v22)
              v77 = v76;
            else
              v77 = v75 + 1;
            v78 = -(v77 >> 1);
            v79 = v77 >> 1;
            v80 = &v71[-8 * v79];
            v81 = v73 - v71;
            if (v73 != v71)
            {
              memmove(&v71[-8 * v79], v71, v73 - v71);
              v71 = *v9;
            }
            v73 = &v80[v81];
            v2[82] = &v80[v81];
            v2[81] = &v71[8 * v78];
          }
        }
        *(_QWORD *)v73 = v72;
      }
      else
      {
        *(_QWORD *)v10 = operator new(0x1000uLL);
      }
    }
    else
    {
      v2[84] = v14 - 256;
      v19 = *(_QWORD *)v11;
      v17 = v11 + 8;
      v18 = v19;
      v2[81] = v17;
      if ((char *)v2[83] == v10)
      {
        v20 = (uint64_t)&v17[-*v8];
        if ((unint64_t)v17 <= *v8)
        {
          if (v10 == (char *)*v8)
            v50 = 1;
          else
            v50 = (uint64_t)&v10[-*v8] >> 2;
          v51 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v50);
          v53 = &v51[8 * (v50 >> 2)];
          v54 = (uint64_t *)v2[81];
          v10 = v53;
          v55 = v2[82] - (_QWORD)v54;
          if (v55)
          {
            v10 = &v53[v55 & 0xFFFFFFFFFFFFFFF8];
            v56 = 8 * (v55 >> 3);
            v57 = &v51[8 * (v50 >> 2)];
            do
            {
              v58 = *v54++;
              *(_QWORD *)v57 = v58;
              v57 += 8;
              v56 -= 8;
            }
            while (v56);
          }
          v59 = (void *)v2[80];
          v2[80] = v51;
          v2[81] = v53;
          v2[82] = v10;
          v2[83] = &v51[8 * v52];
          if (v59)
          {
            operator delete(v59);
            v10 = (char *)v2[82];
          }
        }
        else
        {
          v21 = v20 >> 3;
          v22 = v20 >> 3 < -1;
          v23 = (v20 >> 3) + 2;
          if (v22)
            v24 = v23;
          else
            v24 = v21 + 1;
          v25 = -(v24 >> 1);
          v26 = v24 >> 1;
          v27 = &v17[-8 * v26];
          v28 = v10 - v17;
          if (v10 == v17)
          {
            v29 = v10;
          }
          else
          {
            memmove(&v17[-8 * v26], v17, v10 - v17);
            v29 = *v9;
          }
          v10 = &v27[v28];
          v2[82] = &v27[v28];
          v2[81] = &v29[8 * v25];
          v8 = v2 + 80;
        }
      }
      *(_QWORD *)v10 = v18;
    }
    v2[82] += 8;
LABEL_93:
    v11 = (char *)v2[81];
    v15 = v2[85];
    v16 = v15 + v2[84];
    v5 = v174;
    v4 = v175;
  }
  v106 = (_QWORD *)(*(_QWORD *)&v11[(v16 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v16);
  *v106 = v5;
  v106[1] = v4;
  if (v4)
  {
    v107 = (unint64_t *)&v4->__shared_owners_;
    do
      v108 = __ldxr(v107);
    while (__stxr(v108 + 1, v107));
    v15 = v2[85];
  }
  v2[85] = v15 + 1;
  v109 = CFGetAllocator(v2 - 2);
  v110 = CFStringCreateWithFormat(v109, 0, CFSTR("https://%@:%d/"), *(_QWORD *)(a1 + 48), *(unsigned __int16 *)(a1 + 112));
  URLString = v110;
  v111 = (std::__shared_weak_count *)operator new();
  v111->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
  v111->__shared_owners_ = 0;
  v111->__shared_weak_owners_ = 0;
  v111[1].__vftable = (std::__shared_weak_count_vtbl *)v110;
  v173 = v111;
  v112 = CFURLCreateWithString(v109, URLString, 0);
  _CFHTTPMessageSetResponseProxyURL(*(_QWORD *)(a1 + 80), v112);
  v113 = _CFHTTPAuthenticationCreateFromResponseInternal(v109, *(CFHTTPMessageRef *)(a1 + 80), 0, 1, 0, 0, 0, 0, 0, v161);
  if (!v113)
    goto LABEL_147;
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  cfa = (const __CFString *)HTTPAuthentication::copyRealm((HTTPAuthentication *)(v113 + 1));
  HTTPAuthentication::buildProtectionSpacesFromAuthSchemes(&theArray, (uint64_t)v113, *(const __CFString **)(a1 + 48), *(_DWORD *)(a1 + 112), 6, cfa);
  v114 = theArray;
  if (!theArray)
  {
    v129 = 0;
    v128 = 1;
    goto LABEL_141;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
  v115 = (*(uint64_t (**)(_QWORD *))(*v2 + 616))(v2);
  if (!v115 || *(_DWORD *)(a1 + 116))
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    if (!HTTPAuthentication::isSecondNTLMTransaction((HTTPAuthentication *)(v113 + 1)))
    {
      v130 = (void *)v2[11];
      if (!v130 || (v131 = objc_msgSend(v130, "cfURL"), (v132 = (const void *)v131) == 0))
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v133 = CFNLog::logger;
        v131 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
        if ((_DWORD)v131)
        {
          v160 = v2[99];
          *(_DWORD *)buf = 138543362;
          *(_QWORD *)&buf[4] = v160;
          _os_log_error_impl(&dword_183ECA000, v133, OS_LOG_TYPE_ERROR, "%{public}@ has no URL for proxy response", buf, 0xCu);
        }
        v132 = 0;
      }
      v134 = CFURLResponseCreateWithHTTPResponse(v131, v132, *(_QWORD *)(a1 + 80), 2);
      v127 = CFURLAuthChallengeCreate((uint64_t)v109, ValueAtIndex, 0, *(unsigned int *)(a1 + 116), v134, 0);
      if (v127)
      {
        if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
          dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
        URLAuthChallenge::setListOfProtectionSpaces((URLAuthChallenge *)(v127 + 16), v114);
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v135 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
        {
          v159 = v2[99];
          *(_DWORD *)buf = 138543618;
          *(_QWORD *)&buf[4] = v159;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v127;
          _os_log_debug_impl(&dword_183ECA000, v135, OS_LOG_TYPE_DEBUG, "%{public}@ sending proxy auth challenge for %@", buf, 0x16u);
        }
        HTTPProtocol::sendDidReceiveAuthChallenge(*(HTTPProtocol **)(a1 + 96), (_CFURLAuthChallenge *)v127);
        CFRelease((CFTypeRef)v127);
        LODWORD(v127) = 1;
      }
      if (v134)
        CFRelease(v134);
      v126 = 1;
      goto LABEL_140;
    }
  }
  v116 = (uint64_t *)(*(_QWORD *)(v2[81] + ((v2[84] >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v2[84]);
  v117 = *v116;
  *(_QWORD *)buf = *v116;
  v118 = (std::__shared_weak_count *)v116[1];
  *(_QWORD *)&buf[8] = v118;
  if (v118)
  {
    v119 = (unint64_t *)&v118->__shared_owners_;
    do
      v120 = __ldxr(v119);
    while (__stxr(v120 + 1, v119));
  }
  if (v117)
  {
    v121 = *(void (**)(_QWORD *, uint64_t, _QWORD))(v117 + 8);
    v122 = *(_QWORD *)(v117 + 16);
    v123 = (_QWORD *)(v117 + (v122 >> 1));
    if ((v122 & 1) != 0)
      v121 = *(void (**)(_QWORD *, uint64_t, _QWORD))(*v123 + v121);
    v121(v123, v115, 0);
  }
  std::deque<SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::pop_front((uint64_t)v8);
  if (v118)
  {
    v124 = (unint64_t *)&v118->__shared_owners_;
    do
      v125 = __ldaxr(v124);
    while (__stlxr(v125 - 1, v124));
    if (!v125)
    {
      ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
      std::__shared_weak_count::__release_weak(v118);
    }
  }
  v126 = 0;
  LODWORD(v127) = 0;
  v128 = 0;
  v129 = 0;
  v114 = theArray;
  if (theArray)
  {
LABEL_140:
    CFRelease(v114);
    v128 = v126;
    v129 = v127;
  }
LABEL_141:
  if (cfa)
    CFRelease(cfa);
  if (v129)
    v136 = 0;
  else
    v136 = v128;
  if ((v136 & 1) != 0)
  {
LABEL_147:
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v137 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v148 = v2[99];
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v148;
      _os_log_error_impl(&dword_183ECA000, v137, OS_LOG_TYPE_ERROR, "%{public}@ Did not challenge delegate for proxy auth", buf, 0xCu);
    }
    v138 = *(_QWORD *)(a1 + 64);
    if (v138)
    {
      v139 = *(void (**)(_QWORD *, _QWORD, _QWORD))(v138 + 8);
      v140 = *(_QWORD *)(v138 + 16);
      v141 = (_QWORD *)(v138 + (v140 >> 1));
      if ((v140 & 1) != 0)
        v139 = *(void (**)(_QWORD *, _QWORD, _QWORD))(*v141 + v139);
      v139(v141, 0, 0);
    }
  }
  if (v112)
    CFRelease(v112);
  v142 = v173;
  if (v173)
  {
    v143 = (unint64_t *)&v173->__shared_owners_;
    do
      v144 = __ldaxr(v143);
    while (__stlxr(v144 - 1, v143));
    if (!v144)
    {
      ((void (*)(std::__shared_weak_count *))v142->__on_zero_shared)(v142);
      std::__shared_weak_count::__release_weak(v142);
    }
  }
  if (v113)
    CFRelease(v113);
  v145 = v175;
  if (v175)
  {
    v146 = (unint64_t *)&v175->__shared_owners_;
    do
      v147 = __ldaxr(v146);
    while (__stlxr(v147 - 1, v146));
    if (!v147)
    {
      ((void (*)(std::__shared_weak_count *))v145->__on_zero_shared)(v145);
      std::__shared_weak_count::__release_weak(v145);
    }
  }
}

void sub_184078C88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *cf, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,char a23)
{
  void *v23;

  operator delete(v23);
  if (cf)
    operator delete(cf);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_48c39_ZTSNSt3__110shared_ptrIK10__CFStringEE64c49_ZTS18SmartBlockWithArgsIJPK16_CFURLCredentialbEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE96c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;

  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[9];
  result[8] = a2[8];
  result[9] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[11];
  result[10] = a2[10];
  result[11] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = a2[13];
  result[12] = a2[12];
  result[13] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_48c39_ZTSNSt3__110shared_ptrIK10__CFStringEE64c49_ZTS18SmartBlockWithArgsIJPK16_CFURLCredentialbEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE96c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = a1 + 48;
  v2 = a1 + 64;
  v3 = a1 + 80;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 96);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

uint64_t BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

void HTTPProtocol::handleInformationalResponse(_QWORD *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  id v11;

  v4 = (void *)a1[10];
  -[__NSCFResumableUploadState processResponse:](objc_msgSend(v4, "resumableUploadState"), (__CFHTTPMessage *)(*(_QWORD *)a2 - 16));
  v5 = objc_msgSend((id)objc_msgSend(v4, "resumableUploadState"), "isResumable");
  if ((_DWORD)v5)
  {
    v6 = a1[104];
    if (v6)
      *(_BYTE *)(v6 + 12) = 1;
  }
  v7 = CFURLResponseCreateWithHTTPResponse(v5, *(const void **)(*(_QWORD *)a2 + 144), *(_QWORD *)a2 - 16, 2);
  v8 = a1[12];
  if (v8)
  {
    v11 = v7;
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
    v10 = (void *)MEMORY[0x186DB8C8C](v9);
    (*(void (**)(_QWORD, id))(*(_QWORD *)a1[12] + 56))(a1[12], v11);
    objc_autoreleasePoolPop(v10);
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 24))(v8);
    v7 = v11;
  }

}

CFTypeRef ___ZN22HTTPProtocolSSLSupport40CreateClientCertChallengeWithHostAndPortEPK10__CFStringlPK9__CFArray_block_invoke(uint64_t a1, uint64_t a2)
{
  URLProtectionSpace *v4;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  if (a2)
    v4 = (URLProtectionSpace *)(a2 + 16);
  else
    v4 = 0;
  return URLProtectionSpace::setDistinguishedNames(v4, *(CFTypeRef *)(a1 + 32));
}

void sub_1840798A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__7431(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__7432(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

CFStringRef CFNAccount::copyDebugDesc(CFNAccount *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CFNAccount@%p> user-name:%@"), this, *((_QWORD *)this + 5));
}

uint64_t CFNAccount::initialize(CFNAccount *this, objc_object *a2)
{
  if (!a2)
    return 0;
  *((_QWORD *)this + 2) = a2;
  return 1;
}

void `non-virtual thunk to'CFNAccount::~CFNAccount(CFNAccount *this)
{
  CFNAccount::~CFNAccount((CFNAccount *)((char *)this - 8));
}

{
  CFNAccount::~CFNAccount((CFNAccount *)((char *)this - 8));
}

void CFNAccount::~CFNAccount(CFNAccount *this)
{
  const void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = &off_1E14E4838;
  *((_QWORD *)this + 1) = &unk_1E14E4888;
  v2 = (const void *)*((_QWORD *)this + 4);
  if (v2)
    CFRelease(v2);
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)

  v4 = (void *)*((_QWORD *)this + 2);
  if (v4)

  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_18407A4FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void *CFNAccount::username(CFNAccount *this)
{
  void *result;

  result = (void *)*((_QWORD *)this + 5);
  if (!result)
  {
    result = (void *)*((_QWORD *)this + 2);
    if (result)
    {
      result = (void *)objc_msgSend(result, "username");
      *((_QWORD *)this + 5) = result;
      if (result)
      {
        CFRetain(result);
        return (void *)*((_QWORD *)this + 5);
      }
    }
    else
    {
      *((_QWORD *)this + 5) = 0;
    }
  }
  return result;
}

void PAC::PACQuery::setStringInDict(xpc_object_t *a1, const char *a2, CFStringRef theString)
{
  uint64_t v5;
  void *ptr;
  UInt8 v7[1024];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (theString)
  {
    v5 = 1023;
    ptr = _CFStringGetOrCreateCString(0, theString, v7, &v5, 0x8000100u);
    xpc_dictionary_set_string(*a1, a2, (const char *)ptr);
    if (ptr)
    {
      if (v7 != ptr)
        CFAllocatorDeallocate(0, ptr);
    }
  }
}

void sub_18407A610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  void *v11;

  if (ptr)
  {
    if (v11 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN3PAC8PACQuery7xpcDictEv_block_invoke()
{
  const char **v0;
  const char *v1;
  __SecTask *v2;
  __SecTask *v3;
  CFTypeRef v4;

  v0 = (const char **)_CFGetProgname();
  v1 = *v0;
  if (!strncmp(*v0, "neagent", 7uLL))
  {
    PAC::PACQuery::xpcDict(void)::prefix = (uint64_t)v1;
  }
  else
  {
    v2 = SecTaskCreateFromSelf((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
    if (v2)
    {
      v3 = v2;
      v4 = SecTaskCopyValueForEntitlement(v2, CFSTR("com.apple.developer.networking.networkextension"), 0);
      if (v4)
      {
        PAC::PACQuery::xpcDict(void)::prefix = (uint64_t)*v0;
        CFRelease(v4);
      }
      CFRelease(v3);
    }
  }
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_xpc_object}*,PAC::PACQuery::xpcDict(void)::$_0,std::allocator<NSObject  {objcproto13OS_xpc_object}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_xpc_object}*,PAC::PACQuery::xpcDict(void)::$_0,std::allocator<NSObject  {objcproto13OS_xpc_object}>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    xpc_release(v1);
}

BOOL HTTPConnectionCache::equals(HTTPConnectionCache *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

void HTTPConnectionCache::logConnectionsAtAPSleep(HTTPConnectionCache *this)
{
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(*((_QWORD *)this + 5) + 32), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTPConnectionCacheEntryWrapper *>::_visit, &__block_literal_global_7465);
}

uint64_t HTTPConnectionCache::purgeIdleConnections(HTTPConnectionCache *this)
{
  uint64_t v1;
  _QWORD v3[5];

  v1 = *((_QWORD *)this + 12);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN19HTTPConnectionCache20purgeIdleConnectionsEv_block_invoke;
  v3[3] = &__block_descriptor_40_e5_v8__0l;
  v3[4] = this;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v1 + 96))(v1, v3);
}

void HTTPConnectionCache::markReusedAfterAPSleepWake(HTTPConnectionCache *this)
{
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(*((_QWORD *)this + 5) + 32), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTPConnectionCacheEntryWrapper *>::_visit, &__block_literal_global_8_7462);
}

uint64_t HTTPConnectionCache::_meta_retain(HTTPConnectionCache *this)
{
  return (*(uint64_t (**)(HTTPConnectionCache *))(*(_QWORD *)this + 40))(this);
}

uint64_t HTTPConnectionCache::_meta_release(HTTPConnectionCache *this)
{
  return (*(uint64_t (**)(HTTPConnectionCache *))(*(_QWORD *)this + 48))(this);
}

void `non-virtual thunk to'HTTPConnectionCache::~HTTPConnectionCache(HTTPConnectionCache *this)
{
  HTTPConnectionCache::~HTTPConnectionCache((HTTPConnectionCache *)((char *)this - 32));
}

void `non-virtual thunk to'HTTPConnectionCache::~HTTPConnectionCache(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 4;
  HTTPConnectionCache::~HTTPConnectionCache((HTTPConnectionCache *)(this - 4));
  CFAllocatorDeallocate(*(this - 3), v2);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,HTTPConnectionCacheEntryWrapper *>::_visit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void ___ZN29HTTPConnectionCacheDictionary26markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;

  v4 = *(_QWORD *)(a3 + 24);
  v3 = *(std::__shared_weak_count **)(a3 + 32);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(*(_QWORD *)(v4 + 96) + 16) - *(_QWORD *)(*(_QWORD *)(v4 + 96) + 8);
  if (v7 >= 1)
  {
    v8 = 0;
    v9 = (unint64_t)v7 >> 4;
    if (v9 <= 1)
      v10 = 1;
    else
      v10 = v9;
    do
    {
      v11 = *(_QWORD *)(*(_QWORD *)(v4 + 96) + 8);
      if (v8 < (*(_QWORD *)(*(_QWORD *)(v4 + 96) + 16) - v11) >> 4)
      {
        v12 = *(_OWORD *)(v11 + 16 * v8);
        v13 = *(std::__shared_weak_count **)(v11 + 16 * v8 + 8);
        if (*((_QWORD *)&v12 + 1))
        {
          v14 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
          do
            v15 = __ldxr(v14);
          while (__stxr(v15 + 1, v14));
        }
        if ((_QWORD)v12)
          (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v12 + 64) + 56) + 160))(*(_QWORD *)(*(_QWORD *)(v12 + 64) + 56));
        if (v13)
        {
          v16 = (unint64_t *)&v13->__shared_owners_;
          do
            v17 = __ldaxr(v16);
          while (__stlxr(v17 - 1, v16));
          if (!v17)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
      }
      ++v8;
    }
    while (v8 != v10);
  }
  if (v3)
  {
    v18 = (unint64_t *)&v3->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_18407A96C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN19HTTPConnectionCache20purgeIdleConnectionsEv_block_invoke(uint64_t a1)
{
  return HTTPConnectionCache::timeoutIdleConnections(*(HTTPConnectionCache **)(a1 + 32));
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,HTTPConnectionCacheEntryWrapper *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA4E8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,HTTPConnectionCacheEntryWrapper *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA4E8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void `non-virtual thunk to'HTTPConnectionCacheDictionary::~HTTPConnectionCacheDictionary(HTTPConnectionCacheDictionary *this)
{
  *((_QWORD *)this - 2) = off_1E14EEC90;
  *(_QWORD *)this = &unk_1E14EECB0;
  *((_QWORD *)this + 1) = &off_1E14EA4E8;
  CFRelease(*((CFTypeRef *)this + 2));
  *(_QWORD *)this = &off_1E14E5838;
}

{
  char *v2;

  *((_QWORD *)this - 2) = off_1E14EEC90;
  v2 = (char *)this - 16;
  *(_QWORD *)this = &unk_1E14EECB0;
  *((_QWORD *)this + 1) = &off_1E14EA4E8;
  CFRelease(*((CFTypeRef *)this + 2));
  *(_QWORD *)this = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 1), v2);
}

void ___ZN29HTTPConnectionCacheDictionary18forgetCacheEntriesEb_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  HTTPConnectionCacheEntry *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v27;
  unint64_t v28;
  HTTPConnectionCacheEntry *v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;

  v5 = *(HTTPConnectionCacheEntry **)(a3 + 24);
  v6 = *(std::__shared_weak_count **)(a3 + 32);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  HTTPConnectionCacheEntry::invalidateUnpurgeableConnections(v5);
  if (v6)
  {
    v9 = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v12 = *(_QWORD *)(a3 + 24);
  v11 = *(std::__shared_weak_count **)(a3 + 32);
  if (v11)
  {
    v13 = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = *(unsigned int *)(v12 + 120);
  if ((int)v15 >= 1)
  {
    do
    {
      if ((((_DWORD)v15 - 1) & 0x80000000) == 0)
      {
        v16 = *(_QWORD *)(*(_QWORD *)(v12 + 104) + 8);
        if ((v15 - 1) <= (unint64_t)((*(_QWORD *)(*(_QWORD *)(v12 + 104) + 16) - v16) >> 4))
        {
          v17 = (uint64_t *)(v16 + 16 * (v15 - 1));
          v19 = *v17;
          v18 = (std::__shared_weak_count *)v17[1];
          if (v18)
          {
            v20 = (unint64_t *)&v18->__shared_owners_;
            do
              v21 = __ldxr(v20);
            while (__stxr(v21 + 1, v20));
          }
          if (v19)
          {
            v23 = *(_QWORD *)(v19 + 16);
            v22 = *(_QWORD *)(v19 + 24);
            if (v22 - v23 >= 1)
            {
              while (v22 != v23)
                v22 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v22 - 16);
              *(_QWORD *)(v19 + 24) = v23;
            }
          }
          if (v18)
          {
            v24 = (unint64_t *)&v18->__shared_owners_;
            do
              v25 = __ldaxr(v24);
            while (__stlxr(v25 - 1, v24));
            if (!v25)
            {
              ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
              std::__shared_weak_count::__release_weak(v18);
            }
          }
        }
      }
    }
    while (v15-- > 1);
  }
  if (v11)
  {
    v27 = (unint64_t *)&v11->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v29 = *(HTTPConnectionCacheEntry **)(a3 + 24);
  v30 = *(std::__shared_weak_count **)(a3 + 32);
  if (v30)
  {
    v31 = (unint64_t *)&v30->__shared_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
  }
  HTTPConnectionCacheEntry::setHasBeenForgotten(v29, *(unsigned __int8 *)(a1 + 32));
  if (v30)
  {
    v33 = (unint64_t *)&v30->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
}

void sub_18407AD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN29HTTPConnectionCacheDictionary23logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;

  v4 = *(_QWORD *)(a3 + 24);
  v3 = *(std::__shared_weak_count **)(a3 + 32);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(*(_QWORD *)(v4 + 96) + 16) - *(_QWORD *)(*(_QWORD *)(v4 + 96) + 8);
  if (v7 >= 1)
  {
    v8 = 0;
    v9 = (unint64_t)v7 >> 4;
    if (v9 <= 1)
      v10 = 1;
    else
      v10 = v9;
    do
    {
      v11 = *(_QWORD *)(*(_QWORD *)(v4 + 96) + 8);
      if (v8 < (*(_QWORD *)(*(_QWORD *)(v4 + 96) + 16) - v11) >> 4)
      {
        v12 = *(_OWORD *)(v11 + 16 * v8);
        v13 = *(std::__shared_weak_count **)(v11 + 16 * v8 + 8);
        if (*((_QWORD *)&v12 + 1))
        {
          v14 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
          do
            v15 = __ldxr(v14);
          while (__stxr(v15 + 1, v14));
        }
        if ((_QWORD)v12)
          (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v12 + 64) + 56) + 432))(*(_QWORD *)(*(_QWORD *)(v12 + 64) + 56));
        if (v13)
        {
          v16 = (unint64_t *)&v13->__shared_owners_;
          do
            v17 = __ldaxr(v16);
          while (__stlxr(v17 - 1, v16));
          if (!v17)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
      }
      ++v8;
    }
    while (v8 != v10);
  }
  if (v3)
  {
    v18 = (unint64_t *)&v3->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_18407AE84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<HTTPConnectionCacheEntry>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0DA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTPConnectionCacheEntry>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0DA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<HTTPConnectionCacheEntry>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void HTTPConnectionCacheEntryWrapper::~HTTPConnectionCacheEntryWrapper(HTTPConnectionCacheEntryWrapper *this)
{
  *(_QWORD *)this = off_1E14EF280;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
}

void HTTPConnectionCacheEntryWrapper::~HTTPConnectionCacheEntryWrapper(CFAllocatorRef *this)
{
  *this = (CFAllocatorRef)off_1E14EF280;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 3));
  CFAllocatorDeallocate(this[1], this);
}

void HTTPConnectionCacheEntry::~HTTPConnectionCacheEntry(HTTPConnectionCacheEntry *this)
{
  HTTPConnectionCacheEntry::~HTTPConnectionCacheEntry(this);
  JUMPOUT(0x186DB748CLL);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;

  *(_QWORD *)this = &off_1E14ECDE0;
  *((_QWORD *)this + 3) = &unk_1E14ECE28;
  v2 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 9);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
    *((_QWORD *)this + 9) = 0;
  }
  v4 = *((_QWORD *)this + 8);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    *((_QWORD *)this + 8) = 0;
  }
  v5 = *((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v7 = *((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  v9 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  CFRelease(*((CFTypeRef *)this + 10));
  v10 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (v10)
    std::__shared_weak_count::__release_weak(v10);
  *((_QWORD *)this + 3) = &off_1E14E5838;
  v11 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
}

__CFString *HTTPConnectionCacheEntry::copyDebugDesc(CFArrayRef *this)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  const __CFString *v4;
  CFTypeRef *v5;
  CFIndex Count;
  CFIndex i;
  Tube **ValueAtIndex;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  uint64_t v19;
  __CFString *v20;
  CFTypeRef *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  CFTypeRef *v37;
  HTTPConnection *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int *v43;
  uint64_t PendingResponseCount;
  const void *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  __CFArray *v48;
  const __CFArray *v49;
  const __CFString *v50;
  uint64_t v51;
  CFTypeRef *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  __int128 v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  CFTypeRef *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  __int128 v68;
  uint64_t v69;
  unint64_t *v70;
  unint64_t v71;
  uint64_t v72;
  const void *v73;
  uint64_t v74;
  std::__shared_weak_count *v75;
  unint64_t *v76;
  unint64_t v77;
  CFTypeRef *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  CFTypeRef *v82;
  std::__shared_weak_count *v83;
  unint64_t *v84;
  unint64_t v85;
  __CFArray *v86;
  const __CFArray *v87;
  unint64_t *v88;
  unint64_t v89;
  const __CFString *v90;
  const __CFString *v92;
  __CFString *v93;
  const __CFString *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  const __CFAllocator *allocator;
  AutoStringArray *v100;
  AutoStringArray *v101;
  CFTypeRef *v102;
  CFTypeRef *v103;
  __int128 v104;
  uint64_t v105;
  int v106;
  CFTypeRef *v107;
  __int128 v108;
  __int128 v109;
  CFTypeRef *v110[2];
  CFRange v111;
  CFRange v112;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  allocator = v2;
  v100 = (AutoStringArray *)this;
  v4 = CFStringCreateWithFormat(v2, 0, CFSTR("<HTTPConnectionCacheEntry@%p>{\n"), this);
  CFStringAppend(Mutable, v4);
  v5 = (CFTypeRef *)operator new();
  *v5 = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
  v103 = v5;
  Count = CFArrayGetCount(this[10]);
  AutoStringArray::addFormat(v5, CFSTR("Pending Tubes: %ld"), Count);
  v93 = Mutable;
  v94 = v4;
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = (Tube **)CFArrayGetValueAtIndex(*((CFArrayRef *)v100 + 10), i);
      v9 = Tube::copyWaiter(ValueAtIndex[14]);
      v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 88))(v9);
      v11 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 32))(v10);
      v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 80))(v9);
      (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v12 + 88))(&v104);
      AuthenticationState::copyDebugSummary((AuthenticationState *)&v109, v104);
      v13 = (std::__shared_weak_count *)*((_QWORD *)&v104 + 1);
      if (*((_QWORD *)&v104 + 1))
      {
        v14 = (unint64_t *)(*((_QWORD *)&v104 + 1) + 8);
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
      v5 = v103;
      v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 80))(v9);
      v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 88))(v9);
      v18 = (const void *)v109;
      AutoStringArray::addFormat(v103, CFSTR("\t[%ld]: Tube(%p) - Waiter(%p) Client(%p) Request(%p, %@) Auth(%@)"), i, ValueAtIndex, v9, v16, v17, v11, (_QWORD)v109);
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
      if (v18)
        CFRelease(v18);
      if (v11)
        CFRelease(v11);
    }
  }
  v19 = *((_QWORD *)v100 + 12);
  if (!v19)
  {
    CFArrayAppendValue((CFMutableArrayRef)*v5, CFSTR("Connections: NULL"));
    v20 = v93;
    goto LABEL_49;
  }
  v20 = v93;
  v21 = (CFTypeRef *)operator new();
  *v21 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
  v110[0] = v21;
  AutoStringArray::addFormat(v21, CFSTR("Connections: %ld"), (uint64_t)(*(_QWORD *)(v19 + 16) - *(_QWORD *)(v19 + 8)) >> 4);
  v22 = *(_QWORD *)(v19 + 16) - *(_QWORD *)(v19 + 8);
  if (v22 < 1)
    goto LABEL_47;
  v23 = 0;
  v24 = (unint64_t)v22 >> 4;
  if (v24 <= 1)
    v25 = 1;
  else
    v25 = v24;
  v97 = v25;
  do
  {
    v26 = *(_QWORD *)(v19 + 8);
    if (v23 >= (*(_QWORD *)(v19 + 16) - v26) >> 4)
    {
      v28 = 0;
      v109 = 0uLL;
LABEL_35:
      AutoStringArray::addFormat(v110[0], CFSTR("\t[%ld]: NULL"), v23);
      if (!v28)
        goto LABEL_45;
LABEL_41:
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v47 = __ldaxr(p_shared_owners);
      while (__stlxr(v47 - 1, p_shared_owners));
      if (!v47)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
      goto LABEL_45;
    }
    v27 = *(_OWORD *)(v26 + 16 * v23);
    v109 = v27;
    v28 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
    if (*((_QWORD *)&v27 + 1))
    {
      v29 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    if (!(_QWORD)v27)
      goto LABEL_35;
    v31 = *(_QWORD *)(v27 + 176);
    v32 = *(std::__shared_weak_count **)(v27 + 184);
    *(_QWORD *)&v104 = v31;
    *((_QWORD *)&v104 + 1) = v32;
    if (v32)
    {
      v33 = (unint64_t *)&v32->__shared_owners_;
      do
        v34 = __ldxr(v33);
      while (__stxr(v34 + 1, v33));
    }
    AuthenticationState::copyDebugSummary((AuthenticationState *)&v108, v31);
    if (v32)
    {
      v35 = (unint64_t *)&v32->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    v37 = v110[0];
    v38 = (HTTPConnection *)v109;
    v39 = *(unsigned int *)(v109 + 240);
    *(_QWORD *)&v104 = 0;
    *((_QWORD *)&v104 + 1) = &v104;
    v105 = 0x2020000000;
    v40 = (*((_QWORD *)v38 + 16) - *((_QWORD *)v38 + 15)) >> 4;
    v106 = v40;
    _Block_object_dispose(&v104, 8);
    *(_QWORD *)&v104 = 0;
    *((_QWORD *)&v104 + 1) = &v104;
    v105 = 0x2020000000;
    v106 = 0;
    v41 = *((_QWORD *)v38 + 18);
    if (v41)
    {
      v42 = (*((_QWORD *)v38 + 16)
           - (_QWORD)HTTPConnection::_onqueue_getTransactionItr(*((_QWORD **)v38 + 15), *((_QWORD **)v38 + 16), v41)) >> 4;
      v43 = (int *)(*((_QWORD *)&v104 + 1) + 24);
    }
    else
    {
      v42 = 0;
      v43 = &v106;
    }
    *v43 = v42;
    _Block_object_dispose(&v104, 8);
    PendingResponseCount = HTTPConnection::getPendingResponseCount(v38);
    v45 = (const void *)v108;
    AutoStringArray::addFormat(v37, CFSTR("\t[%ld]: HTTPConnection(%p) - Pri(%d) QD(%d) Req(%d) Resp(%d) Auth(%@)"), v23, v38, v39, v40, v42, PendingResponseCount, (_QWORD)v108);
    if (v45)
      CFRelease(v45);
    v28 = (std::__shared_weak_count *)*((_QWORD *)&v109 + 1);
    v20 = v93;
    v4 = v94;
    v25 = v97;
    if (*((_QWORD *)&v109 + 1))
      goto LABEL_41;
LABEL_45:
    ++v23;
  }
  while (v23 != v25);
  v21 = v110[0];
LABEL_47:
  v48 = (__CFArray *)*v5;
  v49 = (const __CFArray *)*v21;
  v111.length = CFArrayGetCount(v49);
  v111.location = 0;
  CFArrayAppendArray(v48, v49, v111);
  std::unique_ptr<AutoStringArray>::reset[abi:nn180100](v110);
  v5 = v103;
LABEL_49:
  v50 = CFStringCreateByCombiningStrings(allocator, (CFArrayRef)*v5, CFSTR("\n"));
  CFStringAppend(v20, v50);
  CFStringAppend(v20, CFSTR("\n"));
  v51 = *((_QWORD *)v100 + 13);
  v52 = (CFTypeRef *)operator new();
  *v52 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
  v102 = v52;
  v53 = *(_QWORD *)(v51 + 16) - *(_QWORD *)(v51 + 8);
  v54 = v53 >> 4;
  AutoStringArray::addFormat(v52, CFSTR("Request Priority Levels: %d"), v53 >> 4);
  if (v53 >= 1)
  {
    v92 = v50;
    v95 = v51;
    do
    {
      v55 = v54--;
      v56 = *(_OWORD *)(*(_QWORD *)(v51 + 8) + 16 * v54);
      v108 = v56;
      v57 = (std::__shared_weak_count *)*((_QWORD *)&v56 + 1);
      if (*((_QWORD *)&v56 + 1))
      {
        v58 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
        do
          v59 = __ldxr(v58);
        while (__stxr(v59 + 1, v58));
      }
      v101 = (AutoStringArray *)v102;
      v60 = v56;
      if ((_QWORD)v56)
        v61 = (uint64_t)(*(_QWORD *)(v56 + 24) - *(_QWORD *)(v56 + 16)) >> 4;
      else
        v61 = 0;
      AutoStringArray::addFormat(v102, CFSTR("\tPriority Level [%ld]: RequestQueue(%p) Requests(%ld)"), v54, (_QWORD)v56, v61);
      if (v60)
      {
        v62 = (CFTypeRef *)operator new();
        *v62 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
        v107 = v62;
        v63 = *(_QWORD *)(v60 + 24) - *(_QWORD *)(v60 + 16);
        if (v63 < 1)
          goto LABEL_84;
        v96 = v55;
        v98 = v54;
        v64 = 0;
        v65 = (unint64_t)v63 >> 4;
        v66 = v65 <= 1 ? 1 : v65;
        do
        {
          v67 = *(_QWORD *)(v60 + 16);
          if (v64 >= (*(_QWORD *)(v60 + 24) - v67) >> 4)
          {
            v69 = 0;
            v104 = 0uLL;
          }
          else
          {
            v68 = *(_OWORD *)(v67 + 16 * v64);
            v104 = v68;
            v69 = v68;
            if (*((_QWORD *)&v68 + 1))
            {
              v70 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
              do
                v71 = __ldxr(v70);
              while (__stxr(v71 + 1, v70));
            }
          }
          v72 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v69 + 88))(v69);
          v73 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v72 + 32))(v72);
          v74 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v69 + 80))(v69);
          (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v74 + 88))(&v109);
          AuthenticationState::copyDebugSummary((AuthenticationState *)v110, v109);
          v75 = (std::__shared_weak_count *)*((_QWORD *)&v109 + 1);
          if (*((_QWORD *)&v109 + 1))
          {
            v76 = (unint64_t *)(*((_QWORD *)&v109 + 1) + 8);
            do
              v77 = __ldaxr(v76);
            while (__stlxr(v77 - 1, v76));
            if (!v77)
            {
              ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
              std::__shared_weak_count::__release_weak(v75);
            }
          }
          v78 = v107;
          v79 = v104;
          v80 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v104 + 80))(v104);
          v81 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v79 + 88))(v79);
          v82 = v110[0];
          AutoStringArray::addFormat(v78, CFSTR("\t\t[%ld]: EnqueuedRequest(%p) - Client(%p) Request(%p, %@) Auth(%@)"), v64, v79, v80, v81, v73, v110[0]);
          if (v82)
            CFRelease(v82);
          if (v73)
            CFRelease(v73);
          v83 = (std::__shared_weak_count *)*((_QWORD *)&v104 + 1);
          if (*((_QWORD *)&v104 + 1))
          {
            v84 = (unint64_t *)(*((_QWORD *)&v104 + 1) + 8);
            do
              v85 = __ldaxr(v84);
            while (__stlxr(v85 - 1, v84));
            if (!v85)
            {
              ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
              std::__shared_weak_count::__release_weak(v83);
            }
          }
          ++v64;
        }
        while (v64 != v66);
        v62 = v107;
        v51 = v95;
        v55 = v96;
        v54 = v98;
        if (v107)
        {
LABEL_84:
          v86 = *(__CFArray **)v101;
          v87 = (const __CFArray *)*v62;
          v112.length = CFArrayGetCount(v87);
          v112.location = 0;
          CFArrayAppendArray(v86, v87, v112);
        }
      }
      else
      {
        v107 = 0;
      }
      std::unique_ptr<AutoStringArray>::reset[abi:nn180100](&v107);
      if (v57)
      {
        v88 = (unint64_t *)&v57->__shared_owners_;
        do
          v89 = __ldaxr(v88);
        while (__stlxr(v89 - 1, v88));
        if (!v89)
        {
          ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
          std::__shared_weak_count::__release_weak(v57);
        }
      }
    }
    while (v55 > 1);
    v52 = v102;
    v20 = v93;
    v4 = v94;
    v50 = v92;
  }
  v90 = CFStringCreateByCombiningStrings(allocator, (CFArrayRef)*v52, CFSTR("\n"));
  CFStringAppend(v20, v90);
  CFStringAppend(v20, CFSTR("\n"));
  CFStringAppend(v20, CFSTR("}\n"));
  if (v90)
    CFRelease(v90);
  std::unique_ptr<AutoStringArray>::reset[abi:nn180100](&v102);
  if (v50)
    CFRelease(v50);
  std::unique_ptr<AutoStringArray>::reset[abi:nn180100](&v103);
  if (v4)
    CFRelease(v4);
  return v20;
}

void sub_18407B854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,CFTypeRef *a26)
{
  uint64_t v26;

  std::unique_ptr<AutoStringArray>::reset[abi:nn180100]((CFTypeRef **)(v26 - 112));
  std::unique_ptr<AutoStringArray>::reset[abi:nn180100](&a26);
  if (a19)
    CFRelease(a19);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'HTTPConnectionCacheEntry::~HTTPConnectionCacheEntry(HTTPConnectionCacheEntry *this)
{
  HTTPConnectionCacheEntry::~HTTPConnectionCacheEntry((HTTPConnectionCacheEntry *)((char *)this - 24));
}

{
  HTTPConnectionCacheEntry::~HTTPConnectionCacheEntry((HTTPConnectionCacheEntry *)((char *)this - 24));
  JUMPOUT(0x186DB748CLL);
}

void sub_18407BBDC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;

  v3 = *(_QWORD *)(v1 + 112);
  *(_QWORD *)(v1 + 112) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *(_QWORD *)(v1 + 104);
  *(_QWORD *)(v1 + 104) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *(_QWORD *)(v1 + 96);
  *(_QWORD *)(v1 + 96) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  CFRelease(*(CFTypeRef *)(v1 + 80));
  v6 = *(std::__shared_weak_count **)(v1 + 48);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  v7 = *(std::__shared_weak_count **)(v1 + 16);
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
  _Unwind_Resume(a1);
}

CFTypeRef **std::unique_ptr<AutoStringArray>::reset[abi:nn180100](CFTypeRef **result)
{
  CFTypeRef *v1;

  v1 = *result;
  *result = 0;
  if (v1)
  {
    CFRelease(*v1);
    JUMPOUT(0x186DB748CLL);
  }
  return result;
}

uint64_t HTTPConnectionCacheEntry::hasRequestsEnqueued(HTTPConnectionCacheEntry *this)
{
  char v2;
  uint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  char v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;

  v2 = 0;
  v3 = *((int *)this + 30);
  do
  {
    if (v3-- < 1)
      break;
    if ((v3 & 0x80000000) != 0
      || (v5 = *(_QWORD *)(*((_QWORD *)this + 13) + 8),
          v3 > (unint64_t)((*(_QWORD *)(*((_QWORD *)this + 13) + 16) - v5) >> 4)))
    {
      v6 = 0;
LABEL_6:
      v7 = 1;
      if (v6)
        goto LABEL_7;
      continue;
    }
    v10 = (uint64_t *)(v5 + 16 * v3);
    v11 = *v10;
    v6 = (std::__shared_weak_count *)v10[1];
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    if (!v11 || (uint64_t)(*(_QWORD *)(v11 + 24) - *(_QWORD *)(v11 + 16)) <= 0)
      goto LABEL_6;
    v7 = 0;
    v2 = 1;
    if (v6)
    {
LABEL_7:
      v8 = (unint64_t *)&v6->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  while ((v7 & 1) != 0);
  return v2 & 1;
}

void HTTPConnectionCacheEntry::_removeAllConnections(HTTPConnectionCacheEntry *this, unsigned int a2)
{
  uint64_t v2;
  unint64_t v5;

  v2 = *(_QWORD *)(*((_QWORD *)this + 12) + 16) - *(_QWORD *)(*((_QWORD *)this + 12) + 8);
  if (v2 >= 1)
  {
    v5 = ((unint64_t)v2 >> 4) + 1;
    do
    {
      HTTPConnectionCacheEntry::ConnectionArray::stopAndRemove(*((HTTPConnectionCacheEntry::ConnectionArray **)this + 12), v5 - 2, a2);
      --v5;
    }
    while (v5 > 1);
  }
}

void ___ZN9TCFObjectIN19TransportConnection17RefCountedWrapperEE5ClassEv_block_invoke_7500()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  qmemcpy(&_PNAME<TransportConnection::RefCountedWrapper>::GET(void)::p, "TransportConnection::RefCountedWrapper", 38);
  CFClass::CFClass(v0, (const char *)&_PNAME<TransportConnection::RefCountedWrapper>::GET(void)::p);
  TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::clazz = (uint64_t)v0;
}

void sub_18407BE4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<HTTPTransaction>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0AD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTPTransaction>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0AD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t HTTPTransactionWrapper::copyProperty(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

uint64_t HTTPTransactionWrapper::setProperty(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 56))(*(_QWORD *)(a1 + 32));
}

uint64_t HTTPTransactionWrapper::canScheduleAndOpenWithHandlerAsync(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 80))(*((_QWORD *)this + 4));
}

uint64_t HTTPTransactionWrapper::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 88))(*(_QWORD *)(a1 + 32));
}

uint64_t HTTPTransactionWrapper::closeAndClearHandler(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 96))(*((_QWORD *)this + 4));
}

uint64_t HTTPTransactionWrapper::updateScheduling(HTTPTransactionWrapper *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(_QWORD, const CoreSchedulingSet *))(**((_QWORD **)this + 4) + 104))(*((_QWORD *)this + 4), a2);
}

uint64_t HTTPTransactionWrapper::setPriorityHint(HTTPTransactionWrapper *this, float a2)
{
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4), a2);
}

uint64_t HTTPTransactionWrapper::setBodyStreamBeforeOpening(HTTPTransactionWrapper *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFReadStream *))(**((_QWORD **)this + 4) + 72))(*((_QWORD *)this + 4), a2);
}

uint64_t HTTPTransactionWrapper::rawBytesSent(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 112))(*((_QWORD *)this + 4));
}

uint64_t HTTPTransactionWrapper::rawBytesReceived(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 120))(*((_QWORD *)this + 4));
}

uint64_t HTTPTransactionWrapper::getConnectionIdentifier(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 128))(*((_QWORD *)this + 4));
}

uint64_t HTTPTransactionWrapper::copyTrust(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 136))(*((_QWORD *)this + 4));
}

uint64_t HTTPTransactionWrapper::_conn_no_more_reqests_after_this_one_connectionLost(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 144))(*((_QWORD *)this + 4));
}

void HTTPTransactionWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 152))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_18407C048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTPTransactionWrapper::getProxy(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 160))(*((_QWORD *)this + 4));
}

uint64_t HTTPTransactionWrapper::setTransactionMetrics(HTTPTransactionWrapper *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFN_TransactionMetrics *))(**((_QWORD **)this + 4) + 192))(*((_QWORD *)this + 4), a2);
}

uint64_t HTTPTransactionWrapper::getAuthState(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 168))(*((_QWORD *)this + 4));
}

uint64_t HTTPTransactionWrapper::resetConnAuthState(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 176))(*((_QWORD *)this + 4));
}

uint64_t HTTPTransactionWrapper::_meta_retain(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(HTTPTransactionWrapper *))(*(_QWORD *)this + 40))(this);
}

uint64_t HTTPTransactionWrapper::_meta_release(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(HTTPTransactionWrapper *))(*(_QWORD *)this + 48))(this);
}

void `non-virtual thunk to'HTTPTransactionWrapper::~HTTPTransactionWrapper(HTTPTransactionWrapper *this)
{
  *((_QWORD *)this - 3) = off_1E14EC490;
  *(_QWORD *)this = &unk_1E14EC578;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

{
  char *v2;

  *((_QWORD *)this - 3) = off_1E14EC490;
  v2 = (char *)this - 24;
  *(_QWORD *)this = &unk_1E14EC578;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 2), v2);
}

void `non-virtual thunk to'HTTPTransactionWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 152))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_18407C198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::getAuthState(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 168))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::resetConnAuthState(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 176))(*((_QWORD *)this + 1));
}

void std::vector<std::pair<std::shared_ptr<HTTPConnection>,BOOL>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4 - 24);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ___ZN24HTTPConnectionCacheEntry28_findOrCreateEmptyConnectionENSt3__110shared_ptrINS_15EnqueuedRequestEEEPNS_22ConnectionSearchStatusE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v28;
  unint64_t v29;
  __int128 v30;

  v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)(a1 + 40);
      if (v7)
      {
        v8 = *(_DWORD *)(v7 + 120);
        v9 = (v8 - 1);
        if (v8 >= 1)
        {
          do
          {
            if ((v9 & 0x80000000) == 0)
            {
              v10 = *(_QWORD *)(*(_QWORD *)(v7 + 104) + 8);
              if (v9 <= (unint64_t)((*(_QWORD *)(*(_QWORD *)(v7 + 104) + 16) - v10) >> 4))
              {
                v11 = *(_OWORD *)(v10 + 16 * v9);
                v30 = v11;
                v12 = *(std::__shared_weak_count **)(v10 + 16 * v9 + 8);
                if (*((_QWORD *)&v11 + 1))
                {
                  v13 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
                  do
                    v14 = __ldxr(v13);
                  while (__stxr(v14 + 1, v13));
                }
                if ((_QWORD)v11)
                {
                  v15 = *(_QWORD *)(v11 + 16);
                  if (*(_QWORD *)(v11 + 24) - v15 >= 1)
                  {
                    v16 = 0;
                    do
                    {
                      v17 = *(__n128 *)(v15 + 16 * v16);
                      v18 = *(std::__shared_weak_count **)(v15 + 16 * v16 + 8);
                      if (v17.n128_u64[1])
                      {
                        v19 = (unint64_t *)(v17.n128_u64[1] + 8);
                        do
                          v20 = __ldxr(v19);
                        while (__stxr(v20 + 1, v19));
                      }
                      v21 = (*(uint64_t (**)(unint64_t, __n128))(*(_QWORD *)v17.n128_u64[0] + 80))(v17.n128_u64[0], v17);
                      v22 = v21;
                      if (v21
                        && !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v21 + 176))(v21)
                        && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v22 + 232))(v22))
                      {
                        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v22 + 240))(v22, a2);
                      }
                      if (v18)
                      {
                        p_shared_owners = (unint64_t *)&v18->__shared_owners_;
                        do
                          v24 = __ldaxr(p_shared_owners);
                        while (__stlxr(v24 - 1, p_shared_owners));
                        if (!v24)
                        {
                          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
                          std::__shared_weak_count::__release_weak(v18);
                        }
                      }
                      ++v16;
                      v15 = *(_QWORD *)(v30 + 16);
                    }
                    while (v16 < (*(_QWORD *)(v30 + 24) - v15) >> 4);
                    v12 = (std::__shared_weak_count *)*((_QWORD *)&v30 + 1);
                  }
                }
                if (v12)
                {
                  v25 = (unint64_t *)&v12->__shared_owners_;
                  do
                    v26 = __ldaxr(v25);
                  while (__stlxr(v26 - 1, v25));
                  if (!v26)
                  {
                    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
                    std::__shared_weak_count::__release_weak(v12);
                  }
                }
              }
            }
          }
          while (v9-- > 0);
        }
      }
      v28 = (unint64_t *)&v6->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_18407C48C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTPConnectionCacheEntry::ConnectionArray::~ConnectionArray(HTTPConnectionCacheEntry::ConnectionArray *this)
{
  HTTPConnectionCacheEntry::ConnectionArray::~ConnectionArray(this);
  JUMPOUT(0x186DB748CLL);
}

{
  void **v1;
  _QWORD *v2;
  _QWORD *v3;
  void **v4;
  std::__shared_weak_count *v5;
  _QWORD *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  void **v11;
  NSObject *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  void **v22[5];
  std::__shared_weak_count *v23;

  *(_QWORD *)this = &off_1E14F0140;
  v1 = (void **)((char *)this + 8);
  v2 = (_QWORD *)*((_QWORD *)this + 1);
  v3 = (_QWORD *)*((_QWORD *)this + 2);
  if (v2 != v3)
  {
    v4 = (void **)MEMORY[0x1E0C809B0];
    do
    {
      v6 = (_QWORD *)*v2;
      v5 = (std::__shared_weak_count *)v2[1];
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
      }
      v9 = (std::__shared_weak_count *)v6[6];
      if (v9)
      {
        v10 = std::__shared_weak_count::lock(v9);
        if (v10)
          v11 = (void **)v6[5];
        else
          v11 = 0;
      }
      else
      {
        v11 = 0;
        v10 = 0;
      }
      v12 = v6[7];
      v22[0] = v4;
      v22[1] = (void **)3321888768;
      v22[2] = (void **)___ZN14HTTPConnection31doNotAllowMoreRequests_offqueueEv_block_invoke;
      v22[3] = (void **)&__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e5_v8__0l;
      v22[4] = v11;
      v23 = v10;
      if (v10)
      {
        v13 = (unint64_t *)&v10->__shared_owners_;
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      dispatch_async(v12, v22);
      v15 = v23;
      if (!v23)
        goto LABEL_18;
      v16 = (unint64_t *)&v23->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
        if (v10)
        {
LABEL_19:
          v18 = (unint64_t *)&v10->__shared_owners_;
          do
            v19 = __ldaxr(v18);
          while (__stlxr(v19 - 1, v18));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
      }
      else
      {
LABEL_18:
        if (v10)
          goto LABEL_19;
      }
      if (v5)
      {
        v20 = (unint64_t *)&v5->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
      v2 += 2;
    }
    while (v2 != v3);
  }
  v22[0] = v1;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](v22);
}

CFStringRef HTTPConnectionCacheEntry::EnqueuedRequest::copyDebugDesc(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  const __CFAllocator *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (const __CFAllocator *)*((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 3);
  v4 = *((_QWORD *)this + 5);
  if (!v4)
  {
    v5 = *((_QWORD *)this + 4);
    if (!v5)
      return CFStringCreateWithFormat(v2, 0, CFSTR("<%p client=%p request=%@>"), this, v3, v5);
    goto LABEL_9;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (!*(_BYTE *)(v4 + 40))
  {
    v5 = v4 + 16;
LABEL_9:
    v5 -= 16;
    return CFStringCreateWithFormat(v2, 0, CFSTR("<%p client=%p request=%@>"), this, v3, v5);
  }
  v5 = 0;
  return CFStringCreateWithFormat(v2, 0, CFSTR("<%p client=%p request=%@>"), this, v3, v5);
}

uint64_t HTTPConnectionCacheEntry::EnqueuedRequest::hash(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 5);
  if (!v2)
  {
    v3 = *((_QWORD *)this + 4);
    if (!v3)
      return v3 ^ *((_QWORD *)this + 3);
    goto LABEL_9;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (!*(_BYTE *)(v2 + 40))
  {
    v3 = v2 + 16;
LABEL_9:
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    return v3 ^ *((_QWORD *)this + 3);
  }
  v3 = 0;
  return v3 ^ *((_QWORD *)this + 3);
}

void HTTPConnectionCacheEntry::RequestQueue::~RequestQueue(HTTPConnectionCacheEntry::RequestQueue *this)
{
  void **v2;

  *(_QWORD *)this = &off_1E14F0100;
  v2 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&v2);
  *(_QWORD *)this = &off_1E14E5838;
}

{
  void **v2;

  *(_QWORD *)this = &off_1E14F0100;
  v2 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&v2);
  *(_QWORD *)this = &off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

void HTTPConnectionCacheEntry::RequestQueues::~RequestQueues(HTTPConnectionCacheEntry::RequestQueues *this)
{
  void **v2;

  *(_QWORD *)this = &off_1E14F0120;
  v2 = (void **)((char *)this + 8);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&v2);
  *(_QWORD *)this = &off_1E14E5838;
}

{
  void **v2;

  *(_QWORD *)this = &off_1E14F0120;
  v2 = (void **)((char *)this + 8);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&v2);
  *(_QWORD *)this = &off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<HTTPConnectionCacheEntry::RequestQueue>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0F68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTPConnectionCacheEntry::RequestQueue>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0F68;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<HTTPConnectionCacheEntry::RequestQueue>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_pointer<HTTPConnectionCacheEntry::EnqueuedRequest *,HTTPConnectionCacheEntry::_prepareNewRequest(MetaConnectionCacheClient *,HTTPRequestMessage const*,MetaConnectionOptions)::$_0,std::allocator<HTTPConnectionCacheEntry::EnqueuedRequest>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<HTTPConnection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0980;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTPConnection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0980;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void HTTPConnectionCacheEntry::setHasBeenForgotten(HTTPConnectionCacheEntry *this, unsigned int a2)
{
  const __CFArray *v4;
  CFRange v5;

  *((_BYTE *)this + 32) |= 4u;
  if ((HTTPConnectionCacheEntry::hasRequestsEnqueued(this) & 1) == 0)
  {
    HTTPConnectionCacheEntry::_removeAllConnections(this, a2);
    v4 = (const __CFArray *)*((_QWORD *)this + 10);
    v5.length = CFArrayGetCount(v4);
    v5.location = 0;
    CFArrayApplyFunction(v4, v5, (CFArrayApplierFunction)RetainableTypedArray<Tube *>::_invoke, &__block_literal_global_7536);
    CFArrayRemoveAllValues(*((CFMutableArrayRef *)this + 10));
  }
}

void ___ZN24HTTPConnectionCacheEntry19setHasBeenForgottenEb_block_invoke(int a1, Tube *this)
{
  *((_BYTE *)this + 216) = 0;
  Tube::_onqueue_cancel(this);
}

void HTTPConnectionCacheEntry::invalidateUnpurgeableConnections(HTTPConnectionCacheEntry *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  v1 = *(_QWORD *)(*((_QWORD *)this + 12) + 16) - *(_QWORD *)(*((_QWORD *)this + 12) + 8);
  if (v1 >= 1)
  {
    v3 = 0;
    v4 = (unint64_t)v1 >> 4;
    if (v4 <= 1)
      v5 = 1;
    else
      v5 = v4;
    do
    {
      v6 = *(_QWORD *)(*((_QWORD *)this + 12) + 8);
      if (v3 < (*(_QWORD *)(*((_QWORD *)this + 12) + 16) - v6) >> 4)
      {
        v7 = *(_OWORD *)(v6 + 16 * v3);
        v8 = *(std::__shared_weak_count **)(v6 + 16 * v3 + 8);
        if (v8)
        {
          p_shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            v10 = __ldxr(p_shared_owners);
          while (__stxr(v10 + 1, p_shared_owners));
        }
        if ((_QWORD)v7)
          *(_QWORD *)(v7 + 216) = 0;
        if (v8)
        {
          v11 = (unint64_t *)&v8->__shared_owners_;
          do
            v12 = __ldaxr(v11);
          while (__stlxr(v12 - 1, v11));
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
      ++v3;
    }
    while (v3 != v5);
  }
}

CFStringRef HTTPConnectionCacheKey::copyDebugDesc(HTTPConnectionCacheKey *this)
{
  const __CFAllocator *v2;
  uint64_t v3;
  const __CFString *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFString *v8;
  uint8_t buf[4];
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = *((unsigned int *)this + 15);
  if (v3 >= 5)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67109120;
      v11 = v3;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Unknown connection key type %d", buf, 8u);
    }
    v4 = CFSTR("ERROR - Unkown Type");
  }
  else
  {
    v4 = off_1E14FA040[v3];
  }
  v5 = *((_QWORD *)this + 4);
  v6 = *((unsigned int *)this + 14);
  v7 = *((_QWORD *)this + 11);
  if (v7)
    v8 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  else
    v8 = CFSTR("No");
  return CFStringCreateWithFormat(v2, 0, CFSTR("%@ connection to %@:%d <%@ proxy to %@:%d>"), v4, v5, v6, v8, *((_QWORD *)this + 13), *((unsigned int *)this + 30));
}

_QWORD *HTTPConnectionCacheKey::setMutableProxyThatDoesntAffectHashing(_QWORD *result, uint64_t *a2)
{
  _QWORD *v2;
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  const void *v8;
  __int128 v9;

  v2 = result + 11;
  if (result[11] != *a2)
  {
    v4 = result;
    v9 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(result + 13), &v9);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v9 + 1);
    if (*((_QWORD *)&v9 + 1))
    {
      v6 = (unint64_t *)(*((_QWORD *)&v9 + 1) + 8);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    v8 = (const void *)v4[10];
    v4[10] = 0;
    if (v8)
      CFRelease(v8);
    return std::shared_ptr<__CFString const>::operator=[abi:nn180100](v2, *a2, a2[1]);
  }
  return result;
}

void sub_18407CFB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54)
{
  _QWORD *v54;

  free(a54);
  *v54 = &off_1E14E5838;
  MEMORY[0x186DB748C](v54, 0x91C40C859B4A5);
  _Unwind_Resume(a1);
}

void sub_18407D0DC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  MEMORY[0x186DB748C](v1, 0x91C40C859B4A5);
  _Unwind_Resume(a1);
}

NSString *quoteMaybe(NSString *a1)
{
  if (-[NSString rangeOfCharacterFromSet:](a1, "rangeOfCharacterFromSet:", objc_msgSend(MEMORY[0x1E0CB3500], "whitespaceAndNewlineCharacterSet")) == 0x7FFFFFFFFFFFFFFFLL)return a1;
  else
    return (NSString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("'%@'"), -[NSArray componentsJoinedByString:](-[NSString componentsSeparatedByString:](a1, "componentsSeparatedByString:", CFSTR("'")), "componentsJoinedByString:", CFSTR("'")));
}

CFStringRef HTTPAuthentication::copyDebugDesc(HTTPAuthentication *this)
{
  const __CFDictionary *v2;
  const __CFString *Value;
  const char *v4;
  const char *v5;
  char *v6;
  const __CFAllocator *v7;

  v2 = (const __CFDictionary *)*((_QWORD *)this + 17);
  if (v2)
    Value = (const __CFString *)CFDictionaryGetValue(v2, CFSTR("kCFHTTPAuthenticationPropertyMethod"));
  else
    Value = CFSTR("<undecided>");
  if (*((_DWORD *)this + 24))
    v4 = "Failed";
  else
    v4 = "InProgress";
  if (*((_BYTE *)this + 160))
    v5 = "true";
  else
    v5 = "false";
  v6 = (char *)this - 16;
  v7 = CFGetAllocator(v6);
  return CFStringCreateWithFormat(v7, 0, CFSTR("<CFHTTPAuthentication %p>{state = %s; scheme = %@, forProxy = %s}"),
           v6,
           v4,
           Value,
           v5);
}

void `non-virtual thunk to'HTTPAuthentication::~HTTPAuthentication(HTTPAuthentication *this)
{
  HTTPAuthentication::~HTTPAuthentication((HTTPAuthentication *)((char *)this - 8));
}

{
  HTTPAuthentication::~HTTPAuthentication((HTTPAuthentication *)((char *)this - 8));
}

{
  HTTPAuthentication::~HTTPAuthentication((HTTPAuthentication *)((char *)this - 80));
}

{
  HTTPAuthentication::~HTTPAuthentication((HTTPAuthentication *)((char *)this - 80));
}

void HTTPAuthentication::~HTTPAuthentication(HTTPAuthentication *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  uint64_t i;
  const void *v13;
  const void *v14;
  const void *v15;

  *(_QWORD *)this = &off_1E14E9650;
  *((_QWORD *)this + 1) = &unk_1E14E9698;
  *((_QWORD *)this + 10) = &unk_1E14E96B8;
  v2 = (const void *)*((_QWORD *)this + 29);
  *((_QWORD *)this + 29) = 0;
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 27);
  *((_QWORD *)this + 27) = 0;
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 26);
  *((_QWORD *)this + 26) = 0;
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 25);
  *((_QWORD *)this + 25) = 0;
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 24);
  *((_QWORD *)this + 24) = 0;
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 22);
  *((_QWORD *)this + 22) = 0;
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 21);
  *((_QWORD *)this + 21) = 0;
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = 0;
  if (v9)
    CFRelease(v9);
  v10 = (const void *)*((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = 0;
  if (v10)
    CFRelease(v10);
  v11 = (const void *)*((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v11)
    CFRelease(v11);
  for (i = 128; i != 112; i -= 8)
  {
    v13 = *(const void **)((char *)this + i);
    *(_QWORD *)((char *)this + i) = 0;
    if (v13)
      CFRelease(v13);
  }
  v14 = (const void *)*((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0;
  if (v14)
    CFRelease(v14);
  v15 = (const void *)*((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v15)
    CFRelease(v15);
  *((_QWORD *)this + 10) = &off_1E14E5838;
  *((_QWORD *)this + 1) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 16));
}

void ___ZN18HTTPAuthentication5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFHTTPAuthentication");
  HTTPAuthentication::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_18407E8F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t ___ZN18HTTPAuthentication15isSafariProcessEv_block_invoke()
{
  uint64_t result;
  const char *v1;
  BOOL v2;

  result = _CFGetProgname();
  if (result)
  {
    v1 = *(const char **)result;
    if (*(_QWORD *)result)
    {
      result = strncmp(*(const char **)result, "com.apple.WebKit", 0x10uLL);
      if ((_DWORD)result && (result = strcmp(v1, "MobileSafari"), (_DWORD)result))
      {
        result = strncmp(v1, "com.apple.Safari", 0x10uLL);
        v2 = (_DWORD)result == 0;
      }
      else
      {
        v2 = 1;
      }
      HTTPAuthentication::isSafariProcess(void)::isSafari = v2;
    }
  }
  return result;
}

void HTTPAuthentication::HTTPAuthentication(HTTPAuthentication *this)
{
  *(_QWORD *)this = &off_1E14EFC90;
  *((_QWORD *)this + 1) = &off_1E14E6990;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 16), 0);
  *(_QWORD *)this = &off_1E14E9650;
  *((_QWORD *)this + 1) = &unk_1E14E9698;
  *((_QWORD *)this + 10) = &unk_1E14E96B8;
  *((_QWORD *)this + 29) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_BYTE *)this + 161) = 1;
  *((_BYTE *)this + 225) = 0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
}

uint64_t HTTPAuthentication::_initialize(HTTPAuthentication *this, __CFHTTPMessage *a2, const __CFString *a3, const void *a4, const __CFString *a5, const __CFString *a6, const __CFUUID *a7)
{
  int v10;
  const __CFAllocator *v13;
  CFTypeRef v14;
  const void *v15;
  CFTypeRef v16;
  const void *v17;
  CFTypeRef v18;
  const void *v19;
  CFMutableDictionaryRef v20;
  const void *v21;
  HTTPMessage *v22;
  CFStringRef v23;
  const __CFString *v24;
  CFMutableDictionaryRef Mutable;
  const void *v26;
  __CFDictionary *v27;
  __CFArray *v28;
  const void *v29;
  CFDictionaryValueCallBacks v31;
  CFDictionaryKeyCallBacks keyCallBacks;

  v10 = (int)a3;
  v13 = CFGetAllocator((char *)this - 16);
  memset(&keyCallBacks, 0, sizeof(keyCallBacks));
  *(_OWORD *)&v31.version = xmmword_1E14FA128;
  *(_OWORD *)&v31.release = *(_OWORD *)&off_1E14FA138;
  v31.equal = 0;
  if (a4)
  {
    v14 = CFRetain(a4);
    v15 = (const void *)*((_QWORD *)this + 24);
    *((_QWORD *)this + 24) = v14;
    if (v15)
      CFRelease(v15);
  }
  if (a5)
  {
    v16 = CFRetain(a5);
    v17 = (const void *)*((_QWORD *)this + 25);
    *((_QWORD *)this + 25) = v16;
    if (v17)
      CFRelease(v17);
  }
  if (a6)
  {
    v18 = CFRetain(a6);
    v19 = (const void *)*((_QWORD *)this + 26);
    *((_QWORD *)this + 26) = v18;
    if (v19)
      CFRelease(v19);
  }
  *((_DWORD *)this + 46) = v10;
  if (!*((_QWORD *)this + 19))
  {
    v20 = CFDictionaryCreateMutable(v13, 0, &keyCallBacks, &v31);
    v21 = (const void *)*((_QWORD *)this + 19);
    *((_QWORD *)this + 19) = v20;
    if (v21)
      CFRelease(v21);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (a2)
    v22 = (__CFHTTPMessage *)((char *)a2 + 16);
  else
    v22 = 0;
  v23 = HTTPMessage::copyHeaderFieldValue(v22, 0x15021423u);
  if (v23)
  {
    v24 = v23;
    *((_BYTE *)this + 160) = 0;
  }
  else
  {
    *((_BYTE *)this + 160) = 1;
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v24 = HTTPMessage::copyHeaderFieldValue(v22, 0x13425348u);
    if (!v24)
    {
      *((_QWORD *)this + 11) = 4;
      *((_DWORD *)this + 24) = -1;
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
      return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 16));
    }
  }
  Mutable = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  v26 = (const void *)*((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = Mutable;
  if (v26)
    CFRelease(v26);
  v27 = CFArrayCreateMutable(v13, 0, MEMORY[0x1E0C9B378]);
  v29 = (const void *)*((_QWORD *)this + 29);
  *((_QWORD *)this + 29) = v27;
  if (v29)
  {
    CFRelease(v29);
    v27 = (__CFDictionary *)*((_QWORD *)this + 29);
  }
  if (!HTTPAuthentication::parseHeader(v24, 0, *((void **)this + 18), v27, v28))
  {
    *((_QWORD *)this + 11) = 4;
    *((_DWORD *)this + 24) = -1;
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
  }
  CFRelease(v24);
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 16));
}

uint64_t HTTPAuthentication::initializeSchemes(HTTPAuthentication *this, __CFHTTPMessage *a2, const __CFString *a3)
{
  uint64_t v3;
  char v4;
  char v5;
  int v6;
  int v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFURL *v10;
  CFURLRef v11;
  uint64_t v12;
  pthread_mutex_t *v13;
  const void *v14;
  const void *v15;
  const __CFURL *v16;
  CFTypeRef v17;
  const void *v18;
  CFURLRef v19;
  const __CFURL *v20;
  CFRange v21;
  const __CFAllocator *v22;
  const void *Value;
  char v24;
  const void *v25;
  CFTypeRef v26;
  CFTypeRef v27;
  const void *v28;
  BOOL v29;
  const __CFDictionary *v30;
  const __CFAllocator *v31;
  const __CFString *v32;
  const __CFString *v33;
  __CFString *v34;
  __CFString *v35;
  UInt8 *CString;
  UInt8 *v37;
  UInt8 *v38;
  double v39;
  const char *v40;
  const __CFString *v41;
  UInt8 *v42;
  UInt8 *v43;
  _BOOL4 v44;
  const __CFString *v45;
  UInt8 *v46;
  uint64_t v47;
  uint64_t v48;
  int SvcTicketForHostWithPassword;
  const __CFAllocator *v50;
  const __CFURL *PathComponent;
  CFTypeRef v52;
  const void *v53;
  double v54;
  const void *v55;
  BOOL v56;
  const __CFDictionary *v57;
  const __CFAllocator *v58;
  const __CFURL *v59;
  CFTypeRef v60;
  const void *v61;
  const __CFDictionary *v62;
  const __CFDictionary *v63;
  const __CFString *v64;
  const __CFString *v65;
  CFTypeRef v66;
  CFTypeRef v67;
  const void *v68;
  BOOL v69;
  const __CFString *v70;
  const __CFString *v71;
  const __CFString *v72;
  CFIndex Count;
  uint64_t v74;
  const __CFString *ValueAtIndex;
  CFMutableStringRef MutableCopy;
  CFComparisonResult v77;
  const __CFString *v79;
  const __CFString *v80;
  CFStringRef MD5HashWithString;
  const __CFString *v82;
  const __CFString *v83;
  CFTypeRef v84;
  const __CFString *v85;
  const __CFString *v86;
  CFTypeRef v87;
  const __CFURL *v88;
  CFTypeRef v89;
  const void *v90;
  const __CFDictionary *v91;
  __CFDictionary *v92;
  const void *v93;
  const __CFAllocator *v94;
  const __CFURL *v95;
  CFTypeRef v96;
  const void *v97;
  const void *v98;
  CFTypeRef v99;
  const void *v100;
  CFTypeRef v101;
  char v102;
  const void *v103;
  CFArrayRef theArray;
  const __CFArray *theArraya;
  int v107;
  BOOL v108;
  CFAllocatorRef alloc;
  const __CFAllocator *alloca;
  UInt8 *key;
  __CFString *cf;
  const __CFDictionary *cfa;
  BOOL v114;
  void *v115;
  int v116;
  CFAllocatorRef v117;
  uint64_t v118;
  void *ptr;
  UInt8 v120[1024];
  CFAllocatorRef v121;
  uint64_t v122;
  void *v123;
  UInt8 v124[1024];
  CFRange v125;
  void *v126;
  UInt8 v127[1024];
  CFAllocatorRef v128;
  CFAllocatorRef allocator;
  UInt8 *URLBytes;
  UInt8 v131[1024];
  uint64_t v132;

  v3 = MEMORY[0x1E0C80A78](this);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v3;
  v132 = *MEMORY[0x1E0C80C00];
  v13 = (pthread_mutex_t *)(v3 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
  if (*(_DWORD *)(v12 + 96))
    return pthread_mutex_unlock(v13);
  v14 = *(const void **)(v12 + 136);
  *(_QWORD *)(v12 + 136) = 0;
  if (v14)
    CFRelease(v14);
  *(_BYTE *)(v12 + 225) = v5;
  if (*(_BYTE *)(v12 + 160))
  {
    if (!v11)
      goto LABEL_223;
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (!*((_BYTE *)v11 + 40) || (v15 = (const void *)*((_QWORD *)v11 + 21)) == 0)
    {
      v11 = 0;
      goto LABEL_223;
    }
    v16 = (const __CFURL *)CFRetain(v15);
  }
  else
  {
    v16 = CFHTTPMessageCopyRequestURL(v11);
  }
  v11 = v16;
  if (!v16)
    goto LABEL_223;
  v17 = CFRetain(v16);
  v18 = *(const void **)(v12 + 176);
  *(_QWORD *)(v12 + 176) = v17;
  if (v18)
    CFRelease(v18);
  if (CFURLGetBaseURL(v11))
  {
    v19 = CFURLCopyAbsoluteURL(v11);
    if (v19)
    {
      v20 = v19;
      CFRelease(v11);
      v11 = v20;
    }
  }
  if ((dyld_program_sdk_at_least() & 1) == 0)
  {
    v21 = CFURLGetByteRangeForComponent(v11, kCFURLComponentUserInfo, 0);
    if (v21.location != -1)
    {
      v22 = CFGetAllocator((CFTypeRef)(v12 - 16));
      URLBytes::URLBytes((URLBytes *)&v128, v22, v11);
      memmove(&URLBytes[v21.location], &URLBytes[v21.length + 1 + v21.location], (size_t)v128 + -v21.length - v21.location - 1);
      CFRelease(v11);
      v11 = CFURLCreateWithBytes(v22, URLBytes, (CFIndex)v128 + ~v21.length, 0x201u, 0);
      if (URLBytes != v131)
        CFAllocatorDeallocate(allocator, URLBytes);
    }
  }
  if (*(_BYTE *)(v12 + 225))
  {
    if (v9 && CFStringCompare(v9, (CFStringRef)&gConstantCFStringValueTable[7], 1uLL))
    {
      Value = 0;
      if (!v11)
        goto LABEL_30;
    }
    else
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), &gConstantCFStringValueTable[7]);
      if (!v11)
        goto LABEL_30;
    }
    if (!*(_QWORD *)(v12 + 136))
    {
      if (v9 && CFStringCompare(v9, (CFStringRef)&gConstantCFStringValueTable[7], 1uLL))
        goto LABEL_31;
      if (Value)
        v27 = CFRetain(Value);
      else
        v27 = 0;
      v55 = *(const void **)(v12 + 136);
      *(_QWORD *)(v12 + 136) = v27;
      if (v55)
        CFRelease(v55);
    }
  }
LABEL_30:
  if (!v9)
  {
    v24 = 1;
    goto LABEL_35;
  }
LABEL_31:
  v24 = 0;
  if (CFStringCompare(v9, CFSTR("OAuth"), 1uLL))
  {
    v25 = 0;
    if (!v11)
      goto LABEL_48;
    goto LABEL_36;
  }
LABEL_35:
  v25 = CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), CFSTR("OAuth"));
  if (!v11)
    goto LABEL_48;
LABEL_36:
  if (!*(_QWORD *)(v12 + 136) && ((v24 & 1) != 0 || CFStringCompare(v9, CFSTR("OAuth"), 1uLL) == kCFCompareEqualTo))
  {
    v26 = v25 ? CFRetain(v25) : 0;
    v28 = *(const void **)(v12 + 136);
    *(_QWORD *)(v12 + 136) = v26;
    if (v28)
      CFRelease(v28);
  }
LABEL_48:
  v114 = v9 == 0;
  if (v9)
  {
    if (CFStringCompare(v9, CFSTR("Negotiate"), 1uLL) == kCFCompareEqualTo)
    {
      v30 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), CFSTR("Negotiate"));
      if (v30)
        goto LABEL_56;
    }
    if (CFStringCompare(v9, CFSTR("Kerberos"), 1uLL))
      goto LABEL_51;
  }
  else
  {
    v30 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), CFSTR("Negotiate"));
    if (v30)
      goto LABEL_56;
  }
  v30 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), CFSTR("Kerberos"));
  if (!v30)
    goto LABEL_127;
LABEL_56:
  if (!v11)
    goto LABEL_126;
  if (!*(_BYTE *)(v12 + 160))
  {
    if (HTTPAuthentication::isSafariProcess(void)::onceToken != -1)
      dispatch_once(&HTTPAuthentication::isSafariProcess(void)::onceToken, &__block_literal_global_2_7921);
    if (!HTTPAuthentication::isSafariProcess(void)::isSafari
      && !*(_BYTE *)(v12 + 161)
      && !*(_QWORD *)(v12 + 192)
      && !*(_QWORD *)(v12 + 200)
      && !*(_QWORD *)(v12 + 208))
    {
      *(_BYTE *)(v12 + 224) = 1;
      if (v7)
        goto LABEL_111;
LABEL_126:
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v12 + 144), CFSTR("Negotiate"));
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v12 + 144), CFSTR("Kerberos"));
      goto LABEL_127;
    }
  }
  v31 = CFGetAllocator((CFTypeRef)(v12 - 16));
  v32 = CFURLCopyHostName(v11);
  cf = lowercaseStringCopy(v31, v32);
  v33 = CFURLCopyScheme(v11);
  v34 = lowercaseStringCopy(v31, v33);
  v35 = cf;
  if (cf && v34)
  {
    v116 = 0;
    v115 = 0;
    v107 = *(_DWORD *)(v12 + 184);
    v128 = v31;
    allocator = (CFAllocatorRef)1023;
    CString = _CFStringGetOrCreateCString(v31, cf, v131, (uint64_t *)&allocator, 0x600u);
    theArray = v30;
    URLBytes = CString;
    if (allocator)
      v37 = CString;
    else
      v37 = 0;
    key = v37;
    v125.location = (CFIndex)v31;
    v125.length = 1023;
    v38 = _CFStringGetOrCreateCString(v31, v34, v127, &v125.length, 0x600u);
    v126 = v38;
    if (v125.length)
      v40 = (const char *)v38;
    else
      v40 = 0;
    v41 = *(const __CFString **)(v12 + 192);
    v121 = v31;
    v122 = 1023;
    if (v41)
    {
      v42 = _CFStringGetOrCreateCString(v31, v41, v124, &v122, 0x600u);
      v123 = v42;
      if (v122)
        v43 = v42;
      else
        v43 = 0;
      alloc = (CFAllocatorRef)v43;
    }
    else
    {
      alloc = 0;
      v124[0] = 0;
      v122 = 0;
      v123 = v124;
    }
    v45 = *(const __CFString **)(v12 + 200);
    v117 = v31;
    v118 = 1023;
    if (v45)
    {
      v46 = _CFStringGetOrCreateCString(v31, v45, v120, &v118, 0x600u);
      ptr = v46;
      if (v118)
        v47 = (uint64_t)v46;
      else
        v47 = 0;
    }
    else
    {
      v47 = 0;
      v120[0] = 0;
      v118 = 0;
      ptr = v120;
    }
    v48 = v107 | 0x8000u;
    if (v40 && !strncmp("http", v40, 4uLL))
    {
      v30 = theArray;
      if (!GetSvcTicketForHostWithPassword(v39, (uint64_t)key, (uint64_t)"HTTP", (uint64_t)alloc, v47, (uint64_t)&v116, (uint64_t)&v115, v48, 0, *(_QWORD *)(v12 + 208)))
      {
        v44 = 1;
LABEL_92:
        if (v115)
          free(v115);
        if (ptr && v120 != ptr)
          CFAllocatorDeallocate(v117, ptr);
        if (v123 && v124 != v123)
          CFAllocatorDeallocate(v121, v123);
        if (v126 && v127 != v126)
          CFAllocatorDeallocate((CFAllocatorRef)v125.location, v126);
        if (URLBytes && v131 != URLBytes)
          CFAllocatorDeallocate(v128, URLBytes);
        v35 = cf;
        goto LABEL_107;
      }
      SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(v54, (uint64_t)key, (uint64_t)"http", (uint64_t)alloc, v47, (uint64_t)&v116, (uint64_t)&v115, v48, 0, *(_QWORD *)(v12 + 208));
    }
    else
    {
      SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(v39, (uint64_t)key, (uint64_t)v40, (uint64_t)alloc, v47, (uint64_t)&v116, (uint64_t)&v115, v48, 0, *(_QWORD *)(v12 + 208));
      v30 = theArray;
    }
    v44 = SvcTicketForHostWithPassword == 0;
    if (v7 && SvcTicketForHostWithPassword)
    {
      v44 = 1;
      *(_BYTE *)(v12 + 224) = 1;
    }
    goto LABEL_92;
  }
  v44 = 0;
  if (cf)
LABEL_107:
    CFRelease(v35);
  if (v34)
    CFRelease(v34);
  if (!v44)
    goto LABEL_126;
LABEL_111:
  v50 = CFGetAllocator((CFTypeRef)(v12 - 16));
  if (CFURLHasDirectoryPath(v11))
  {
    HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v30, v11);
  }
  else
  {
    PathComponent = CFURLCreateCopyDeletingLastPathComponent(v50, v11);
    HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v30, PathComponent);
    CFRelease(PathComponent);
  }
  if (!*(_QWORD *)(v12 + 136))
  {
    if (!v9 || CFStringCompare(v9, CFSTR("Negotiate"), 1uLL) == kCFCompareEqualTo)
    {
      v52 = CFRetain(v30);
      v53 = *(const void **)(v12 + 136);
      *(_QWORD *)(v12 + 136) = v52;
      if (v53)
        CFRelease(v53);
      goto LABEL_127;
    }
LABEL_51:
    v29 = v9 == 0;
    goto LABEL_129;
  }
LABEL_127:
  if (!v9)
  {
    v29 = 1;
    goto LABEL_132;
  }
  v29 = 0;
LABEL_129:
  if (CFStringCompare(v9, CFSTR("NTLM"), 1uLL))
  {
    v56 = v9 == 0;
    goto LABEL_143;
  }
LABEL_132:
  v57 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), CFSTR("NTLM"));
  if (v57)
  {
    v58 = CFGetAllocator((CFTypeRef)(v12 - 16));
    if (CFURLHasDirectoryPath(v11))
    {
      HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v57, v11);
    }
    else
    {
      v59 = CFURLCreateCopyDeletingLastPathComponent(v58, v11);
      HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v57, v59);
      CFRelease(v59);
    }
    if (!*(_QWORD *)(v12 + 136) && (v29 || CFStringCompare(v9, CFSTR("NTLM"), 1uLL) == kCFCompareEqualTo))
    {
      v60 = CFRetain(v57);
      v61 = *(const void **)(v12 + 136);
      *(_QWORD *)(v12 + 136) = v60;
      if (v61)
        CFRelease(v61);
    }
  }
  if (!v9)
  {
    v56 = 1;
    goto LABEL_146;
  }
  v56 = 0;
LABEL_143:
  if (CFStringCompare(v9, (CFStringRef)&unk_1EDCF9220, 1uLL))
  {
    v108 = v9 == 0;
    goto LABEL_157;
  }
LABEL_146:
  v62 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), &unk_1EDCF9220);
  v63 = v62;
  if (v62)
  {
    if (v11 && CFDictionaryContainsKey(v62, &unk_1EDCFEF88))
    {
      v64 = (const __CFString *)CFDictionaryGetValue(v63, &unk_1EDCFEF88);
      v66 = AuthStringUtils::_CFStringUnquote(v64, v65);
      CFDictionarySetValue(v63, &unk_1EDCFEF88, v66);
      CFRelease(v66);
      if (!*(_QWORD *)(v12 + 136)
        && (v56 || CFStringCompare(v9, (CFStringRef)&unk_1EDCF9220, 1uLL) == kCFCompareEqualTo))
      {
        v67 = CFRetain(v63);
        v68 = *(const void **)(v12 + 136);
        *(_QWORD *)(v12 + 136) = v67;
        if (v68)
          CFRelease(v68);
      }
    }
    else
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v12 + 144), &unk_1EDCF9220);
    }
  }
  if (!v9)
  {
    v108 = 1;
    goto LABEL_160;
  }
  v108 = 0;
LABEL_157:
  if (CFStringCompare(v9, CFSTR("Digest"), 1uLL))
  {
    v69 = v9 == 0;
    goto LABEL_190;
  }
LABEL_160:
  cfa = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), CFSTR("Digest"));
  if (!cfa)
    goto LABEL_188;
  alloca = CFGetAllocator((CFTypeRef)(v12 - 16));
  if (!v11)
    goto LABEL_187;
  if (!CFDictionaryContainsKey(cfa, &unk_1EDCFEF88))
    goto LABEL_187;
  if (!CFDictionaryContainsKey(cfa, &unk_1EDCFEEA8))
    goto LABEL_187;
  v70 = (const __CFString *)CFDictionaryGetValue(cfa, &unk_1EDCFE770);
  v71 = v70;
  if (v70)
  {
    if (CFStringCompare(v70, (CFStringRef)&unk_1EDCFEDC8, 1uLL)
      && CFStringCompare(v71, (CFStringRef)&unk_1EDCFEE00, 1uLL))
    {
      goto LABEL_187;
    }
  }
  v72 = (const __CFString *)CFDictionaryGetValue(cfa, &unk_1EDCFEF50);
  if (v72)
  {
    theArraya = CFStringCreateArrayBySeparatingStrings(alloca, v72, CFSTR(","));
    Count = CFArrayGetCount(theArraya);
    if (Count < 1)
    {
      CFRelease(theArraya);
    }
    else
    {
      v74 = 1;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArraya, v74 - 1);
        MutableCopy = CFStringCreateMutableCopy(alloca, 0, ValueAtIndex);
        CFStringTrimWhitespace(MutableCopy);
        v77 = CFStringCompare(MutableCopy, CFSTR("auth"), 1uLL);
        if (v77 == kCFCompareEqualTo)
          CFDictionarySetValue(cfa, &unk_1EDCFEF50, MutableCopy);
        CFRelease(MutableCopy);
      }
      while (v74++ < Count && v77 != kCFCompareEqualTo);
      CFRelease(theArraya);
      if (v77 == kCFCompareEqualTo)
        goto LABEL_177;
    }
LABEL_187:
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v12 + 144), CFSTR("Digest"));
    goto LABEL_188;
  }
LABEL_177:
  v79 = CFStringCreateWithFormat(alloca, 0, CFSTR("%lx"), v12);
  MD5HashWithString = HTTPAuthentication::createMD5HashWithString(alloca, v79, v80);
  CFRelease(v79);
  CFDictionarySetValue(cfa, &unk_1EDCFE850, MD5HashWithString);
  CFRelease(MD5HashWithString);
  v82 = (const __CFString *)CFDictionaryGetValue(cfa, &unk_1EDCFEF88);
  v84 = AuthStringUtils::_CFStringUnquote(v82, v83);
  CFDictionarySetValue(cfa, &unk_1EDCFEF88, v84);
  CFRelease(v84);
  v85 = (const __CFString *)CFDictionaryGetValue(cfa, &unk_1EDCFEEA8);
  v87 = AuthStringUtils::_CFStringUnquote(v85, v86);
  CFDictionarySetValue(cfa, &unk_1EDCFEEA8, v87);
  CFRelease(v87);
  AutoScalar::AutoScalar((AutoScalar *)&v128, 0);
  CFDictionarySetValue(cfa, &unk_1EDCFEE38, allocator);
  v128 = (CFAllocatorRef)&off_1E14E47E8;
  if (allocator)
    CFRelease(allocator);
  CFURLGetByteRangeForComponent(v11, kCFURLComponentPath, &v125);
  URLBytes::URLBytes((URLBytes *)&v128, alloca, v11);
  v88 = CFURLCreateWithBytes(alloca, URLBytes, v125.location, 0x201u, 0);
  HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, cfa, v88);
  CFRelease(v88);
  if (!*(_QWORD *)(v12 + 136) && (v108 || CFStringCompare(v9, CFSTR("Digest"), 1uLL) == kCFCompareEqualTo))
  {
    v89 = CFRetain(cfa);
    v90 = *(const void **)(v12 + 136);
    *(_QWORD *)(v12 + 136) = v89;
    if (v90)
      CFRelease(v90);
  }
  if (URLBytes != v131)
    CFAllocatorDeallocate(allocator, URLBytes);
LABEL_188:
  if (v9)
  {
    v69 = 0;
LABEL_190:
    if (CFStringCompare(v9, (CFStringRef)gConstantCFStringValueTable, 1uLL))
      goto LABEL_210;
    goto LABEL_193;
  }
  v69 = 1;
LABEL_193:
  v91 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), gConstantCFStringValueTable);
  v92 = v91;
  if (v91)
  {
    if (v11)
    {
      if (!CFDictionaryContainsKey(v91, &unk_1EDCFEF88))
      {
        v93 = CFURLCopyHostName(v11);
        if (!v93)
          v93 = CFRetain(&unk_1EDCFEF88);
        CFDictionarySetValue(v92, &unk_1EDCFEF88, v93);
        CFRelease(v93);
      }
      if (CFURLHasDirectoryPath(v11))
      {
        HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v92, v11);
      }
      else
      {
        v94 = CFGetAllocator((CFTypeRef)(v12 - 16));
        v95 = CFURLCreateCopyDeletingLastPathComponent(v94, v11);
        HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v92, v95);
        CFRelease(v95);
      }
      if (!*(_QWORD *)(v12 + 136)
        && (v69 || CFStringCompare(v9, (CFStringRef)gConstantCFStringValueTable, 1uLL) == kCFCompareEqualTo))
      {
        v96 = CFRetain(v92);
        v97 = *(const void **)(v12 + 136);
        *(_QWORD *)(v12 + 136) = v96;
        if (v97)
          CFRelease(v97);
      }
    }
    else
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v12 + 144), gConstantCFStringValueTable);
    }
  }
  if (!v9)
  {
    v114 = 1;
LABEL_214:
    v98 = CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), CFSTR("PrivateToken"));
    if (v11)
      goto LABEL_215;
LABEL_223:
    v99 = *(CFTypeRef *)(v12 + 136);
    goto LABEL_224;
  }
  v114 = 0;
LABEL_210:
  if (CFStringCompare(v9, CFSTR("PrivateToken"), 1uLL) == kCFCompareEqualTo)
    goto LABEL_214;
  v98 = 0;
  if (!v11)
    goto LABEL_223;
LABEL_215:
  if (*(_QWORD *)(v12 + 136))
    goto LABEL_228;
  if (!v114 && CFStringCompare(v9, CFSTR("PrivateToken"), 1uLL))
    goto LABEL_223;
  if (v98)
    v99 = CFRetain(v98);
  else
    v99 = 0;
  v100 = *(const void **)(v12 + 136);
  *(_QWORD *)(v12 + 136) = v99;
  if (v100)
  {
    CFRelease(v100);
    goto LABEL_223;
  }
LABEL_224:
  if (!v99 && !*(_DWORD *)(v12 + 96))
  {
    *(_QWORD *)(v12 + 88) = 4;
    *(_DWORD *)(v12 + 96) = -1000;
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v12 + 152));
  }
  if (!v11)
  {
    v101 = 0;
    v102 = 1;
    goto LABEL_230;
  }
LABEL_228:
  v101 = CFRetain(v11);
  v102 = 0;
LABEL_230:
  v103 = *(const void **)(v12 + 168);
  *(_QWORD *)(v12 + 168) = v101;
  if (v103)
    CFRelease(v103);
  if ((v102 & 1) == 0)
    CFRelease(v11);
  return pthread_mutex_unlock(v13);
}

void sub_18407FC54(_Unwind_Exception *a1)
{
  if ((unint64_t *)STACK[0xCC8] != &STACK[0xCD0])
    CFAllocatorDeallocate((CFAllocatorRef)STACK[0xCC0], (void *)STACK[0xCC8]);
  _Unwind_Resume(a1);
}

void URLBytes::URLBytes(URLBytes *this, const __CFAllocator *a2, CFURLRef url)
{
  CFIndex v6;
  CFIndex v7;
  UInt8 *v8;

  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = (char *)this + 24;
  v6 = CFURLGetBytes(url, (UInt8 *)this + 24, 1024);
  *(_QWORD *)this = v6;
  if (v6 == -1)
  {
    v7 = CFURLGetBytes(url, 0, 0);
    *(_QWORD *)this = v7;
    v8 = (UInt8 *)CFAllocatorAllocate(a2, v7, 0);
    *((_QWORD *)this + 2) = v8;
    CFURLGetBytes(url, v8, *(_QWORD *)this);
  }
}

void HTTPAuthentication::parseDomains(HTTPAuthentication *this, CFDictionaryRef theDict, const __CFURL *a3)
{
  const __CFString *Value;
  const __CFString *v7;
  CFTypeID v8;
  const __CFAllocator *v9;
  __CFArray *Mutable;
  AuthStringUtils *v11;
  const unsigned __int8 *v12;
  AuthStringUtils *v13;
  const unsigned __int8 *v14;
  CFURLRef v15;
  const unsigned __int8 *v16;
  const __CFAllocator *v17;
  __CFArray *v18;
  uint64_t v19;
  void *ptr;
  UInt8 v21[1024];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  Value = (const __CFString *)CFDictionaryGetValue(theDict, &unk_1EDCFE888);
  if (Value)
  {
    v7 = Value;
    v8 = CFGetTypeID(Value);
    if (v8 == CFStringGetTypeID())
    {
      v9 = CFGetAllocator((char *)this - 16);
      Mutable = CFArrayCreateMutable(v9, 0, MEMORY[0x1E0C9B378]);
      v19 = 1023;
      v11 = (AuthStringUtils *)_CFStringGetOrCreateCString(v9, v7, v21, &v19, 0x201u);
      ptr = v11;
      v13 = AuthStringUtils::SkipToLWS(v11, v12);
      do
      {
        v15 = CFURLCreateWithBytes(v9, (const UInt8 *)v11, v13 - v11, 0x201u, a3);
        if (v15)
        {
          CFArrayAppendValue(Mutable, v15);
          CFRelease(v15);
        }
        v11 = AuthStringUtils::SkipLWS(v13, v14);
        v13 = AuthStringUtils::SkipToLWS(v11, v16);
      }
      while (v11 != v13);
      CFDictionarySetValue(theDict, &unk_1EDCFE888, Mutable);
      CFRelease(Mutable);
      if (ptr)
      {
        if (v21 != ptr)
          CFAllocatorDeallocate(v9, ptr);
      }
    }
  }
  else
  {
    v17 = CFGetAllocator((char *)this - 16);
    v18 = CFArrayCreateMutable(v17, 0, MEMORY[0x1E0C9B378]);
    CFArrayAppendValue(v18, a3);
    CFDictionarySetValue(theDict, &unk_1EDCFE888, v18);
    CFRelease(v18);
  }
}

void sub_18407FFB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  _Unwind_Resume(exception_object);
}

CFStringRef HTTPAuthentication::createMD5HashWithString(HTTPAuthentication *this, const __CFString *a2, const __CFString *a3)
{
  UInt8 *v4;
  CC_LONG v5;
  uint64_t v6;
  CC_MD5_CTX *p_c;
  unint64_t v8;
  CFStringRef v9;
  unsigned __int8 v11[16];
  CFAllocatorRef allocator;
  uint64_t v13;
  void *ptr;
  UInt8 v15[1028];
  CC_MD5_CTX c;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  allocator = this;
  v13 = 1023;
  if (a2)
  {
    v4 = _CFStringGetOrCreateCString(this, a2, v15, &v13, 0x8000100u);
    v5 = v13;
  }
  else
  {
    v5 = 0;
    v15[0] = 0;
    v13 = 0;
    v4 = v15;
  }
  ptr = v4;
  CC_MD5_Init(&c);
  CC_MD5_Update(&c, v4, v5);
  CC_MD5_Final(v11, &c);
  v6 = 0;
  p_c = &c;
  do
  {
    v8 = v11[v6];
    LOBYTE(p_c->A) = copyHexLog(__CFAllocator const*,unsigned char const*,long)::niceHex[v8 >> 4];
    BYTE1(p_c->A) = copyHexLog(__CFAllocator const*,unsigned char const*,long)::niceHex[v8 & 0xF];
    p_c = (CC_MD5_CTX *)((char *)p_c + 2);
    ++v6;
  }
  while (v6 != 16);
  LOBYTE(p_c->A) = 0;
  v9 = CFStringCreateWithCString(this, (const char *)&c, 0x8000100u);
  if (ptr && v15 != ptr)
    CFAllocatorDeallocate(allocator, ptr);
  return v9;
}

void sub_18408012C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  _Unwind_Resume(exception_object);
}

__CFString *lowercaseStringCopy(const __CFAllocator *a1, CFStringRef theString)
{
  __CFString *MutableCopy;

  if (!theString)
    return 0;
  MutableCopy = CFStringCreateMutableCopy(a1, 0, theString);
  CFStringLowercase(MutableCopy, 0);
  CFRelease(theString);
  return MutableCopy;
}

uint64_t HTTPAuthentication::parseHeader(const __CFString *this, const __CFString *a2, void *cf, __CFDictionary *a4, __CFArray *a5)
{
  UInt8 *v6;
  unint64_t v7;
  const __CFString *v8;
  BOOL v9;
  BOOL v10;
  __CFDictionary *Mutable;
  uint64_t v12;
  AuthStringUtils *v13;
  int v14;
  int v15;
  CFIndex v16;
  const unsigned __int8 *v17;
  CFStringRef v18;
  char v19;
  int v20;
  const __CFString *v21;
  __CFString *v22;
  double v23;
  double v26;
  double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge;
  uint64_t v28;
  unsigned int CanonicalString;
  const __CFString *v30;
  const UInt8 *v31;
  AuthStringUtils *i;
  AuthStringUtils *v33;
  AuthStringUtils *v34;
  unsigned int v35;
  CFStringRef v36;
  __CFString *v37;
  const unsigned __int8 *v39;
  AuthStringUtils *v40;
  int v41;
  uint64_t v42;
  void *value;
  int v46;
  char v48;
  const __CFAllocator *alloc;
  uint8_t buf[8];
  CFAllocatorRef allocator;
  uint64_t v52;
  void *ptr;
  UInt8 v54[1024];
  uint64_t v55;

  v46 = (int)a2;
  v55 = *MEMORY[0x1E0C80C00];
  allocator = CFGetAllocator(cf);
  v52 = 1023;
  alloc = allocator;
  v6 = _CFStringGetOrCreateCString(allocator, this, v54, &v52, 0x201u);
  ptr = v6;
  v7 = *v6;
  if (!*v6)
  {
LABEL_102:
    v42 = 1;
    goto LABEL_103;
  }
  v48 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if (v46)
    Mutable = (__CFDictionary *)cf;
  else
    Mutable = 0;
  v12 = MEMORY[0x1E0C80978];
  value = (void *)*MEMORY[0x1E0C9AE50];
  while (!v10)
  {
    if (v8 && v48)
    {
      if ((_DWORD)v7 != 34)
        break;
    }
    else if ((_DWORD)v7 != 34)
    {
      if ((char)v7 < 32)
        goto LABEL_98;
      v13 = (AuthStringUtils *)v6;
      do
      {
        if (memchr("()<>@,;:\\\"[]?={} \t", v7, 0x13uLL))
          break;
        v41 = *((char *)v13 + 1);
        v13 = (AuthStringUtils *)((char *)v13 + 1);
        LODWORD(v7) = v41;
      }
      while (v41 > 31);
      v16 = v13 - (AuthStringUtils *)v6;
      if (v13 == (AuthStringUtils *)v6)
        goto LABEL_98;
LABEL_19:
      v18 = CFStringCreateWithBytes(alloc, v6, v16, 0x201u, 0);
      v19 = 1;
      if (!v18)
        goto LABEL_98;
      goto LABEL_20;
    }
    v31 = v6 + 1;
    for (i = (AuthStringUtils *)v31; ; i = (AuthStringUtils *)((char *)v33 + 1))
    {
      v33 = AuthStringUtils::SkipLWS(i, (const unsigned __int8 *)v7);
      v34 = v33;
      v35 = *(unsigned __int8 *)v33;
      if (v35 < 0x20 || v35 == 34 && *((_BYTE *)v33 - 1) != 92)
        break;
    }
    v36 = CFStringCreateWithBytes(alloc, v31, v33 - (AuthStringUtils *)v31, 0x201u, 0);
    v18 = v36;
    v19 = 0;
    if (*(_BYTE *)v34 == 34)
      v13 = (AuthStringUtils *)((char *)v34 + 1);
    else
      v13 = v34;
    if (!v36)
      goto LABEL_98;
LABEL_20:
    if (v9)
    {
      v20 = *(unsigned __int8 *)v13;
      if (v20 != 61)
        Mutable = 0;
      if (v46 && v20 != 61)
      {
        CFRelease(v18);
        goto LABEL_98;
      }
    }
    if (Mutable)
    {
      if (v10 || v8)
      {
        if (v8)
        {
          if (v10 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "_CFHTTPAuthenticationParseHeader(): No scheme or not expecting base64", buf, 2u);
          }
          CanonicalString = _findCanonicalString(v8, 0);
          if (CanonicalString == 568)
            v30 = v8;
          else
            v30 = (const __CFString *)&gConstantCFStringValueTable[7 * ((CanonicalString >> 20) & 0x3FF)];
          CFDictionarySetValue(Mutable, v30, v18);
          if ((v19 & 1) == 0)
            CFDictionarySetValue(Mutable, CFSTR("kCFHTTPAuthenticationUsedQuotes"), value);
          CFRelease(v8);
        }
        else
        {
          if (!v10 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "_CFHTTPAuthenticationParseHeader(): Parse error", buf, 2u);
          }
          CFDictionarySetValue(Mutable, &unk_1EDCFE7E0, v18);
        }
        v8 = 0;
      }
      else
      {
        v13 = AuthStringUtils::SkipLWS(v13, v17);
        if (*(_BYTE *)v13 == 61)
        {
          v8 = (const __CFString *)CFRetain(v18);
          v10 = 0;
          v13 = (AuthStringUtils *)((char *)v13 + 1);
        }
        else
        {
          v37 = (__CFString *)AuthStringUtils::_canonicalSchemeName(v18, v21);
          Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
          CFDictionarySetValue(Mutable, CFSTR("kCFHTTPAuthenticationPropertyMethod"), v37);
          CFDictionarySetValue((CFMutableDictionaryRef)cf, v37, Mutable);
          CFRelease(v37);
          CFRelease(Mutable);
          v8 = 0;
          v10 = v37 == CFSTR("Negotiate") || v37 == CFSTR("NTLM");
        }
      }
    }
    else
    {
      if (v8 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "_CFHTTPAuthenticationParseHeader() no key found!", buf, 2u);
      }
      v22 = (__CFString *)AuthStringUtils::_canonicalSchemeName(v18, (const __CFString *)v17);
      Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(Mutable, CFSTR("kCFHTTPAuthenticationPropertyMethod"), v22);
      CFDictionarySetValue((CFMutableDictionaryRef)cf, v22, Mutable);
      v10 = v22 == CFSTR("Negotiate") || v22 == CFSTR("NTLM") || v22 == CFSTR("Nego2");
      gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v23);
      if (objc_opt_class())
      {
        Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v26);
        v48 = -[__CFString isEqualToString:](v22, "isEqualToString:", objc_msgSend(*(id *)(v28 + 2728), "httpAuthenticationScheme", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge));
      }
      if (v48)
        CFArrayAppendValue(a4, Mutable);
      CFRelease(v22);
      CFRelease(Mutable);
    }
    CFRelease(v18);
    v40 = AuthStringUtils::SkipLWS(v13, v39);
    v6 = (UInt8 *)v40;
    v7 = *(unsigned __int8 *)v40;
    if ((_DWORD)v7 == 44)
    {
      if (v8)
        goto LABEL_99;
      v9 = !v10;
      if (v10)
        Mutable = 0;
      v6 = (UInt8 *)AuthStringUtils::SkipLWS((AuthStringUtils *)((char *)v40 + 1), (const unsigned __int8 *)v7);
      v10 = 0;
      v7 = *v6;
      if (!*v6)
        goto LABEL_102;
    }
    else
    {
      v9 = 0;
      if (!*(_BYTE *)v40)
      {
        if (v8)
          goto LABEL_99;
        goto LABEL_102;
      }
    }
  }
  if ((v7 & 0x80) != 0)
    goto LABEL_98;
  v13 = (AuthStringUtils *)v6;
  while (2)
  {
    v14 = *(_DWORD *)(v12 + 4 * v7 + 60) & 0x500;
    if (v10)
    {
      if (!v14 && (v7 > 0x3D || ((1 << v7) & 0x2000880000000000) == 0))
        break;
      goto LABEL_17;
    }
    if (v14 || (v7 - 45) <= 0x32 && ((1 << (v7 - 45)) & 0x4000000010001) != 0)
    {
LABEL_17:
      v15 = *((char *)v13 + 1);
      v13 = (AuthStringUtils *)((char *)v13 + 1);
      LODWORD(v7) = v15;
      if (v15 < 0)
        break;
      continue;
    }
    break;
  }
  v16 = v13 - (AuthStringUtils *)v6;
  if (v13 != (AuthStringUtils *)v6)
    goto LABEL_19;
LABEL_98:
  if (v8)
LABEL_99:
    CFRelease(v8);
  CFDictionaryRemoveAllValues((CFMutableDictionaryRef)cf);
  CFArrayRemoveAllValues(a4);
  v42 = 0;
LABEL_103:
  if (ptr && v54 != ptr)
    CFAllocatorDeallocate(allocator, ptr);
  return v42;
}

void sub_184080804(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,CFAllocatorRef allocator,uint64_t a23,void *ptr)
{
  if (ptr)
  {
    if (a12 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *_AuthConnectionSpecificRetain(const __CFAllocator *a1, _QWORD *a2)
{
  _QWORD *v3;
  CFTypeRef v4;
  CFTypeRef v5;

  v3 = CFAllocatorAllocate(a1, 32, 0);
  *v3 = *a2;
  v4 = (CFTypeRef)a2[2];
  if (v4)
    v4 = CFRetain(v4);
  v3[2] = v4;
  v5 = (CFTypeRef)a2[1];
  if (v5)
    v5 = CFRetain(v5);
  v3[1] = v5;
  return v3;
}

void _AuthConnectionSpecificRelease(CFAllocatorRef allocator, _QWORD *ptr)
{
  const void *v4;
  const void *v5;

  v4 = (const void *)ptr[2];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)ptr[1];
  if (v5)
    CFRelease(v5);
  if (*ptr)
    NtlmGeneratorRelease();
  CFAllocatorDeallocate(allocator, ptr);
}

BOOL HTTPAuthentication::isSecondNTLMTransaction(HTTPAuthentication *this)
{
  pthread_mutex_t *v2;
  const __CFDictionary *v3;
  const __CFString *Value;
  _BOOL8 v5;

  v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  v3 = (const __CFDictionary *)*((_QWORD *)this + 17);
  v5 = v3
    && (Value = (const __CFString *)CFDictionaryGetValue(v3, CFSTR("kCFHTTPAuthenticationPropertyMethod"))) != 0
    && CFStringCompare(Value, CFSTR("NTLM"), 1uLL) == kCFCompareEqualTo
    && CFDictionaryGetValue(*((CFDictionaryRef *)this + 17), &unk_1EDCFE7E0) != 0;
  pthread_mutex_unlock(v2);
  return v5;
}

const void *HTTPAuthentication::getProperty_Locked(HTTPAuthentication *this, CFStringRef theString)
{
  int CanonicalString;
  void *v6;

  CanonicalString = _findCanonicalString(theString, 8u);
  if (CanonicalString == 394646807)
  {
    v6 = &kCFHTTPHeaderProxyAuthenticate;
    if (!*((_BYTE *)this + 160))
      v6 = &kCFHTTPHeaderWWWAuthenticate;
    return *(const void **)v6;
  }
  else if (CanonicalString == 395687215)
  {
    return (const void *)*((_QWORD *)this + 17);
  }
  else if (*((_QWORD *)this + 17))
  {
    return CFDictionaryGetValue(*((CFDictionaryRef *)this + 17), theString);
  }
  else if (CanonicalString == 420558620)
  {
    return (const void *)*((_QWORD *)this + 18);
  }
  else
  {
    return 0;
  }
}

BOOL HTTPAuthentication::requiresAccountDomain(HTTPAuthentication *this)
{
  pthread_mutex_t *v2;
  _BOOL8 v3;

  v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  v3 = HTTPAuthentication::getProperty_Locked(this, CFSTR("kCFHTTPAuthenticationPropertyMethod")) == CFSTR("NTLM");
  pthread_mutex_unlock(v2);
  return v3;
}

const __CFArray *HTTPAuthentication::copyRealm(HTTPAuthentication *this)
{
  pthread_mutex_t *v2;
  const __CFString *Property_Locked;
  const __CFString *v4;
  const __CFAllocator *v5;
  CFStringRef Copy;
  const __CFArray *v7;
  const __CFArray *v9;
  const __CFURL *ValueAtIndex;

  v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  Property_Locked = (const __CFString *)HTTPAuthentication::getProperty_Locked(this, CFSTR("Realm"));
  if (Property_Locked)
  {
    v4 = Property_Locked;
    v5 = CFGetAllocator((char *)this - 16);
    Copy = CFStringCreateCopy(v5, v4);
  }
  else
  {
    v9 = (const __CFArray *)HTTPAuthentication::getProperty_Locked(this, CFSTR("Domain"));
    v7 = v9;
    if (!v9)
      goto LABEL_4;
    if (!CFArrayGetCount(v9))
    {
      v7 = 0;
      goto LABEL_4;
    }
    ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v7, 0);
    Copy = CFURLCopyHostName(ValueAtIndex);
  }
  v7 = (const __CFArray *)Copy;
LABEL_4:
  pthread_mutex_unlock(v2);
  return v7;
}

void *HTTPAuthentication::copyServerSupportedSchemes(HTTPAuthentication *this)
{
  pthread_mutex_t *v2;
  int v3;
  void *v4;
  const __CFAllocator *v5;
  const __CFDictionary *v6;
  CFIndex Count;
  CFIndex v8;
  const void **v9;
  const void *EmptyArray;

  v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  v3 = *((_DWORD *)this + 24);
  pthread_mutex_unlock(v2);
  if (v3)
    return 0;
  pthread_mutex_lock(v2);
  if (*((_QWORD *)this + 18))
  {
    v5 = CFGetAllocator((char *)this - 16);
    v6 = (const __CFDictionary *)*((_QWORD *)this + 18);
    Count = CFDictionaryGetCount(v6);
    if (Count)
    {
      v8 = Count;
      v9 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      CFDictionaryGetKeysAndValues(v6, v9, 0);
      v4 = CFArrayCreate(v5, v9, v8, MEMORY[0x1E0C9B378]);
      free(v9);
    }
    else
    {
      EmptyArray = (const void *)AutoArray::getEmptyArray(0);
      v4 = (void *)CFRetain(EmptyArray);
    }
  }
  else
  {
    v4 = 0;
  }
  pthread_mutex_unlock(v2);
  return v4;
}

CFDictionaryRef HTTPAuthentication::applyHeaderToRequest(CFDictionaryRef *this, __CFHTTPMessage *a2, const void *a3)
{
  pthread_mutex_t *v6;
  CFDictionaryRef v7;
  void *Property_Locked;
  CFStringRef NTLMHeaderForRequest_Mac;
  _BYTE *Value;
  CFStringRef v12;
  int v13;
  HTTPMessage *v14;
  unsigned int v15;
  int v16;

  v6 = (pthread_mutex_t *)(this + 2);
  pthread_mutex_lock((pthread_mutex_t *)(this + 2));
  if (!*((_DWORD *)this + 24))
  {
    Property_Locked = (void *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("kCFHTTPAuthenticationPropertyMethod"));
    if (Property_Locked == &unk_1EDCF9178)
    {
      Value = CFDictionaryGetValue(this[19], a3);
      NTLMHeaderForRequest_Mac = HTTPAuthentication::createNTLMHeaderForRequest_Mac((uint64_t)this, Value, a3);
    }
    else
    {
      if (Property_Locked != &unk_1EDCF9140)
        goto LABEL_2;
      CFDictionaryGetValue(this[19], a3);
      NTLMHeaderForRequest_Mac = HTTPAuthentication::createNegotiateHeaderForRequest_Mac((uint64_t)this);
    }
    v12 = NTLMHeaderForRequest_Mac;
    if (NTLMHeaderForRequest_Mac)
    {
      v13 = *((unsigned __int8 *)this + 160);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      {
        v16 = *((unsigned __int8 *)this + 160);
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        v13 = v16;
      }
      if (a2)
        v14 = (__CFHTTPMessage *)((char *)a2 + 16);
      else
        v14 = 0;
      if (v13)
        v15 = 325219167;
      else
        v15 = 292663967;
      HTTPMessage::setHeaderFieldStringValue(v14, v15, v12);
      CFRelease(v12);
    }
  }
LABEL_2:
  v7 = this[11];
  pthread_mutex_unlock(v6);
  return v7;
}

CFStringRef HTTPAuthentication::createNTLMHeaderForRequest_Mac(uint64_t a1, _BYTE *a2, const void *a3)
{
  const __CFAllocator *v6;
  CFStringRef v7;
  const void *v8;
  int ClientRequest;
  __int128 value;
  CFTypeRef cf[3];
  id v13;

  v6 = CFGetAllocator((CFTypeRef)(a1 - 16));
  if (a2)
  {
    a2[24] = 0;
  }
  else
  {
    v13 = 0;
    value = 0u;
    *(_OWORD *)cf = 0u;
    ClientRequest = NtlmGeneratorCreate();
    if (ClientRequest || (ClientRequest = NtlmCreateClientRequest()) != 0)
    {
      *(_QWORD *)(a1 + 88) = 2;
      *(_DWORD *)(a1 + 96) = ClientRequest;
      CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 152));
      return 0;
    }
    cf[0] = (id)objc_msgSend(v13, "base64EncodedStringWithOptions:", 0);
    CFRelease(v13);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 152), a3, &value);
    CFRelease(cf[0]);
    a2 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 152), a3);
    a2[24] = 1;
  }
  if (!*((_QWORD *)a2 + 2) || !*(_QWORD *)a2 && !*((_QWORD *)a2 + 1))
    return 0;
  v7 = CFStringCreateWithFormat(v6, 0, CFSTR("NTLM %@"), *((_QWORD *)a2 + 2));
  if (!*(_QWORD *)a2)
  {
    v8 = (const void *)*((_QWORD *)a2 + 1);
    if (v8)
    {
      CFRelease(v8);
      *((_QWORD *)a2 + 1) = 0;
    }
  }
  if (!v7)
  {
    *(_QWORD *)(a1 + 88) = 1;
    *(_DWORD *)(a1 + 96) = 12;
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 152));
  }
  return v7;
}

CFStringRef HTTPAuthentication::createNegotiateHeaderForRequest_Mac(uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  __CFHTTPMessage *v3;
  __CFHTTPMessage *v4;
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;
  const void *v8;
  const __CFAllocator *v9;
  const __CFURL *v10;
  const __CFURL *v11;
  const __CFURL *v12;
  const __CFURL *v13;
  const __CFString *v14;
  CFStringRef v15;
  const __CFString *v16;
  __CFString *MutableCopy;
  const __CFString *v18;
  int v19;
  const __CFString *v20;
  _BOOL4 v21;
  CFStringRef v22;
  __CFString *v23;
  UInt8 *CString;
  UInt8 *v25;
  UInt8 *v26;
  double v27;
  char *v28;
  const __CFString *v29;
  UInt8 *v30;
  UInt8 *v31;
  const __CFString *v32;
  UInt8 *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int SvcTicketForHostWithPassword;
  double v41;
  void *v42;
  CFDataRef v43;
  const void *v44;
  id v45;
  CFStringRef v46;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *__s2;
  uint64_t v52;
  _DWORD length[3];
  CFAllocatorRef allocator;
  uint64_t v55;
  void *ptr;
  UInt8 v57[1024];
  CFAllocatorRef v58;
  uint64_t v59;
  UInt8 *v60;
  UInt8 v61[1024];
  CFAllocatorRef v62;
  uint64_t v63;
  UInt8 *v64;
  UInt8 v65[1024];
  __int128 value;
  _OWORD v67[64];
  uint64_t v68;

  v1 = MEMORY[0x1E0C80A78](a1);
  v4 = v3;
  v6 = v5;
  v7 = v1;
  v68 = *MEMORY[0x1E0C80C00];
  if (!v5)
  {
    v8 = v2;
    v67[0] = 0u;
    value = 0u;
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v1 + 152), v2, &value);
    v6 = CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 152), v8);
    v6[24] = 1;
  }
  v9 = CFGetAllocator((CFTypeRef)(v7 - 16));
  if (*(_BYTE *)(v7 + 160))
    v10 = (const __CFURL *)CFRetain(*(CFTypeRef *)(v7 + 168));
  else
    v10 = CFHTTPMessageCopyRequestURL(v4);
  v11 = v10;
  if (!v10)
  {
    v18 = 0;
    v13 = 0;
LABEL_14:
    LOBYTE(v16) = 1;
    goto LABEL_15;
  }
  v12 = CFURLCopyAbsoluteURL(v10);
  v13 = v12;
  if (!v12)
  {
    v18 = 0;
    goto LABEL_14;
  }
  v14 = CFURLCopyHostName(v12);
  v15 = CFURLCopyScheme(v13);
  v16 = v15;
  if (!v14)
  {
    v18 = 0;
    if (!v15)
      goto LABEL_15;
    goto LABEL_26;
  }
  MutableCopy = CFStringCreateMutableCopy(v9, 0, v14);
  v18 = MutableCopy;
  if (!MutableCopy)
  {
    v18 = v14;
    if (v16)
      goto LABEL_26;
LABEL_15:
    v19 = 0;
    v20 = 0;
    v21 = v18 != 0;
    goto LABEL_16;
  }
  CFStringLowercase(MutableCopy, 0);
  CFRelease(v14);
  if (!v16)
    goto LABEL_15;
LABEL_26:
  v23 = CFStringCreateMutableCopy(v9, 0, v16);
  v20 = v23;
  if (v23)
  {
    CFStringLowercase(v23, 0);
    CFRelease(v16);
    if (v18)
      goto LABEL_28;
  }
  else
  {
    v20 = v16;
    if (v18)
    {
LABEL_28:
      memset(length, 0, sizeof(length));
      *(_QWORD *)&value = v9;
      *((_QWORD *)&value + 1) = 1023;
      CString = _CFStringGetOrCreateCString(v9, v18, (UInt8 *)v67 + 8, (uint64_t *)&value + 1, 0x600u);
      *(_QWORD *)&v67[0] = CString;
      if (*((_QWORD *)&value + 1))
        v25 = CString;
      else
        v25 = 0;
      v62 = v9;
      v63 = 1023;
      v26 = _CFStringGetOrCreateCString(v9, v20, v65, &v63, 0x600u);
      v64 = v26;
      if (v63)
        v28 = (char *)v26;
      else
        v28 = 0;
      v29 = *(const __CFString **)(v7 + 192);
      v58 = v9;
      v59 = 1023;
      __s2 = v28;
      if (v29)
      {
        v30 = _CFStringGetOrCreateCString(v9, v29, v61, &v59, 0x600u);
        v60 = v30;
        if (v59)
          v31 = v30;
        else
          v31 = 0;
      }
      else
      {
        v31 = 0;
        v61[0] = 0;
        v59 = 0;
        v60 = v61;
      }
      v32 = *(const __CFString **)(v7 + 200);
      allocator = v9;
      v55 = 1023;
      v50 = (uint64_t)v31;
      v52 = (uint64_t)v25;
      if (v32)
      {
        v33 = _CFStringGetOrCreateCString(v9, v32, v57, &v55, 0x600u);
        ptr = v33;
        if (v55)
          v34 = (uint64_t)v33;
        else
          v34 = 0;
        v35 = (*(_DWORD *)(v7 + 184) + 0x8000);
        if (*(_BYTE *)(v7 + 161) || v34)
          goto LABEL_51;
      }
      else
      {
        v57[0] = 0;
        v55 = 0;
        ptr = v57;
        v35 = (*(_DWORD *)(v7 + 184) + 0x8000);
        if (*(_BYTE *)(v7 + 161))
        {
          v34 = 0;
          goto LABEL_51;
        }
      }
      v34 = 0;
      if (!*(_QWORD *)(v7 + 208))
      {
        v36 = 0;
        goto LABEL_52;
      }
LABEL_51:
      v36 = 1;
      if (*(_BYTE *)(v7 + 160))
        goto LABEL_93;
LABEL_52:
      if (HTTPAuthentication::isSafariProcess(void)::onceToken != -1)
      {
        v48 = v35;
        v49 = v34;
        dispatch_once(&HTTPAuthentication::isSafariProcess(void)::onceToken, &__block_literal_global_2_7921);
        v34 = v49;
        v35 = v48;
      }
      if (((HTTPAuthentication::isSafariProcess(void)::isSafari == 0) & ~v36) != 0)
      {
        SvcTicketForHostWithPassword = -1;
      }
      else
      {
LABEL_93:
        if (__s2 && (v37 = v35, v38 = v34, v39 = strncmp("http", __s2, 4uLL), v34 = v38, v35 = v37, !v39))
        {
          SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(v27, v52, (uint64_t)"HTTP", v50, v38, (uint64_t)length, (uint64_t)&length[1], v37, 0, *(_QWORD *)(v7 + 208));
          if (SvcTicketForHostWithPassword)
            SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(v41, v52, (uint64_t)"http", v50, v38, (uint64_t)length, (uint64_t)&length[1], v37, 0, *(_QWORD *)(v7 + 208));
        }
        else
        {
          SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(v27, v52, (uint64_t)__s2, v50, v34, (uint64_t)length, (uint64_t)&length[1], v35, 0, *(_QWORD *)(v7 + 208));
        }
      }
      v42 = *(void **)&length[1];
      if (!SvcTicketForHostWithPassword && *(_QWORD *)&length[1] && length[0])
      {
        v43 = CFDataCreateWithBytesNoCopy(v9, *(const UInt8 **)&length[1], length[0], (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
        v44 = (const void *)*((_QWORD *)v6 + 2);
        if (v44)
          CFRelease(v44);
        v45 = (id)-[__CFData base64EncodedStringWithOptions:](v43, "base64EncodedStringWithOptions:", 0);
        *((_QWORD *)v6 + 2) = v45;
        if (!v45 || (v46 = CFStringCreateWithFormat(v9, 0, CFSTR("Negotiate %@"), v45)) == 0)
        {
          *(_QWORD *)(v7 + 88) = 1;
          *(_DWORD *)(v7 + 96) = 12;
          CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v7 + 152));
          v46 = 0;
        }
        CFRelease(v43);
      }
      else
      {
        *(_QWORD *)(v7 + 88) = 4;
        *(_DWORD *)(v7 + 96) = -1001;
        CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v7 + 152));
        v46 = 0;
        v22 = 0;
        if (!v42)
          goto LABEL_73;
      }
      free(v42);
      v22 = v46;
LABEL_73:
      if (ptr && v57 != ptr)
        CFAllocatorDeallocate(allocator, ptr);
      if (v60 && v61 != v60)
        CFAllocatorDeallocate(v58, v60);
      if (v64 && v65 != v64)
        CFAllocatorDeallocate(v62, v64);
      if (*(_QWORD *)&v67[0] && (_OWORD *)((char *)v67 + 8) != *(_OWORD **)&v67[0])
        CFAllocatorDeallocate((CFAllocatorRef)value, *(void **)&v67[0]);
      CFRelease(v20);
      CFRelease(v18);
      goto LABEL_86;
    }
  }
  LOBYTE(v16) = 0;
  v21 = 0;
  v19 = 1;
LABEL_16:
  *(_QWORD *)(v7 + 88) = 1;
  *(_DWORD *)(v7 + 96) = 12;
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v7 + 152));
  if (!v19)
  {
    if (!v21)
      goto LABEL_21;
    goto LABEL_20;
  }
  CFRelease(v20);
  if (v21)
LABEL_20:
    CFRelease(v18);
LABEL_21:
  v22 = 0;
  if ((v16 & 1) == 0)
LABEL_86:
    CFRelease(v13);
  if (v11)
    CFRelease(v11);
  return v22;
}

void sub_1840814C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  void *v15;
  void *v16;
  void *v17;

  v15 = (void *)STACK[0x480];
  if (STACK[0x480] && (void *)a12 != v15)
    CFAllocatorDeallocate((CFAllocatorRef)STACK[0x470], v15);
  v16 = (void *)STACK[0x898];
  if (STACK[0x898] && (void *)a13 != v16)
    CFAllocatorDeallocate((CFAllocatorRef)STACK[0x888], v16);
  v17 = (void *)STACK[0xCB0];
  if (STACK[0xCB0])
  {
    if ((void *)a14 != v17)
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0xCA0], v17);
  }
  _Unwind_Resume(a1);
}

const __CFString *HTTPAuthentication::lockAndCopyProperty(HTTPAuthentication *this, const __CFString *a2)
{
  pthread_mutex_t *v4;
  const __CFString *Property_Locked;
  const __CFString *v6;
  CFTypeID v7;
  const __CFAllocator *v8;
  const __CFString *Copy;
  const __CFAllocator *v10;

  v4 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  Property_Locked = (const __CFString *)HTTPAuthentication::getProperty_Locked(this, a2);
  v6 = Property_Locked;
  if (Property_Locked)
  {
    v7 = CFGetTypeID(Property_Locked);
    if (v7 == CFStringGetTypeID())
    {
      v8 = CFGetAllocator(v6);
      Copy = CFStringCreateCopy(v8, v6);
    }
    else if (v7 == CFArrayGetTypeID())
    {
      v10 = CFGetAllocator(v6);
      Copy = (const __CFString *)CFArrayCreateCopy(v10, (CFArrayRef)v6);
    }
    else
    {
      Copy = (const __CFString *)CFRetain(v6);
    }
    v6 = Copy;
  }
  pthread_mutex_unlock(v4);
  return v6;
}

__n128 HTTPAuthentication::applyCredentials_Locked(CFMutableDictionaryRef *this, __CFHTTPMessage *a2, CFDictionaryRef theDict, CFStreamError *a4)
{
  const __CFString *Value;
  const __CFString *v9;
  const __CFString *v10;
  const void *v11;
  _QWORD *v12;
  CFStreamError *v13;
  CFStreamError *v14;
  __n128 *v15;
  __CFString *Property_Locked;
  const __CFString *v17;
  BOOL v18;
  BOOL v19;
  BOOL v20;
  BOOL v21;
  BOOL v22;
  __n128 result;
  int CanonicalString;
  const __CFString *v25;
  const __CFString *v26;
  const __CFString *v27;
  CFStreamError *v28;
  const __CFString *v29;
  const __CFString *v30;
  const __CFDictionary *v31;
  const __CFString *v32;
  const __CFDictionary *v33;
  const __CFAllocator *v34;
  CFStringRef v35;
  CFStringRef v36;
  int v37;
  HTTPMessage *v38;
  unsigned int v39;
  int v40;
  int v41;
  const __CFNumber *number;
  int valuePtr;
  _BYTE v44[16];

  if (theDict)
  {
    Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("kCFHTTPAuthenticationUsername"));
    v9 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("kCFHTTPAuthenticationPassword"));
    v10 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("kCFHTTPAuthenticationAccountDomain"));
    v11 = CFDictionaryGetValue(theDict, CFSTR("kCFHTTPAuthenticationOAuthToken"));
    number = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("kCFHTTPAuthenticationOAuth1PID"));
    v12 = CFDictionaryGetValue(theDict, CFSTR("kCFHTTPAuthenticationOAuth1Account"));
  }
  else
  {
    number = 0;
    v10 = 0;
    Value = 0;
    v9 = 0;
    v11 = 0;
    v12 = 0;
  }
  v13 = (CFStreamError *)v44;
  if (a4)
    v14 = a4;
  else
    v14 = (CFStreamError *)v44;
  v15 = (__n128 *)(this + 11);
  if (!*((_DWORD *)this + 24))
  {
    if (a4)
      v13 = a4;
    v13->error = 0;
    v14->domain = 0;
    Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("kCFHTTPAuthenticationPropertyMethod"));
    v17 = Property_Locked;
    if (!Property_Locked
      || (Property_Locked != CFSTR("Negotiate") ? (v18 = Property_Locked == CFSTR("NTLM")) : (v18 = 1),
          !v18 ? (v19 = Property_Locked == CFSTR("OAuth")) : (v19 = 1),
          !v19 ? (v20 = Property_Locked == CFSTR("PrivateToken")) : (v20 = 1),
          !v20 ? (v21 = Property_Locked == (__CFString *)&gConstantCFStringValueTable[7]) : (v21 = 1),
          !v21))
    {
      if (!Value || Value == CFSTR("Single Sign-On"))
      {
        this[11] = (CFMutableDictionaryRef)4;
        *((_DWORD *)this + 24) = -1001;
        CFDictionaryRemoveAllValues(this[19]);
      }
      if (CFEqual(v17, CFSTR("X-MobileMe-AuthToken")))
        v22 = 0;
      else
        v22 = v9 == 0;
      if (v22)
      {
        this[11] = (CFMutableDictionaryRef)4;
        *((_DWORD *)this + 24) = -1002;
        CFDictionaryRemoveAllValues(this[19]);
      }
    }
    if (!*((_DWORD *)this + 24))
    {
      CanonicalString = _findCanonicalString(v17, 1u);
      if (CanonicalString <= 5316626)
      {
        if (CanonicalString == 40960)
        {
          v40 = HTTPAuthentication::setBasicAuthenticationOnRequest_NoAuthFromResponse(a2, Value, v9, (const __CFString *)*((unsigned __int8 *)this + 160), this + 11, v28);
          goto LABEL_74;
        }
        if (CanonicalString != 1097731)
        {
          if (CanonicalString == 2146311)
          {
            v29 = (const __CFString *)AuthStringUtils::_CFStringQuote(Value, v25);
            if (v29)
            {
              v30 = v29;
              HTTPAuthentication::setDigestAuthenticationOnRequest(this, (char *)a2, v29, v9);
              CFRelease(v30);
              goto LABEL_75;
            }
            this[11] = (CFMutableDictionaryRef)4;
            v41 = -1001;
LABEL_70:
            *((_DWORD *)this + 24) = v41;
            CFDictionaryRemoveAllValues(this[19]);
            goto LABEL_34;
          }
LABEL_67:
          this[11] = (CFMutableDictionaryRef)4;
          v41 = -1000;
          goto LABEL_70;
        }
      }
      else
      {
        if (CanonicalString <= 7381018)
        {
          if (CanonicalString == 5316627)
          {
            HTTPAuthentication::setNegotiateAuthenticationOnRequest((HTTPAuthentication *)this, a2, v26, v27);
            goto LABEL_73;
          }
          if (CanonicalString == 6324248)
          {
            HTTPAuthentication::setNTLMAuthenticationOnRequest(this, a2, Value, v9, v10);
LABEL_73:
            v40 = *((_DWORD *)this + 24) == 0;
LABEL_74:
            if (!v40)
              goto LABEL_34;
LABEL_75:
            _CFHTTPMessageSetAuthentication(a2, this - 2, *((unsigned __int8 *)this + 160));
            goto LABEL_34;
          }
          goto LABEL_67;
        }
        if (CanonicalString != 7381019)
        {
          if (CanonicalString == 9601061)
          {
            v31 = this[17];
            if (v31)
              v32 = (const __CFString *)CFDictionaryGetValue(v31, CFSTR("Realm"));
            else
              v32 = 0;
            HTTPAuthentication::setXMobileMeAuthTokenOnRequest((HTTPAuthentication *)this, (char *)a2, Value, v9, v32);
            goto LABEL_73;
          }
          goto LABEL_67;
        }
      }
      valuePtr = 0;
      v33 = this[17];
      if (v33)
        CFDictionaryGetValue(v33, CFSTR("Realm"));
      if (v11)
      {
        v34 = CFGetAllocator(a2);
        v35 = CFStringCreateWithFormat(v34, 0, CFSTR("Bearer %@"), v11);
        if (v35)
        {
          v36 = v35;
          v37 = *((unsigned __int8 *)this + 160);
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          if (a2)
            v38 = (__CFHTTPMessage *)((char *)a2 + 16);
          else
            v38 = 0;
          if (v37)
            v39 = 325219167;
          else
            v39 = 292663967;
          HTTPMessage::setHeaderFieldStringValue(v38, v39, v36);
          CFRelease(v36);
        }
      }
      if (v12)
      {
        if (CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr))
        {
          HTTPAuthentication::setOAuth1AuthenticationOnRequest((uint64_t)this, a2, v12, valuePtr);
        }
        else
        {
          this[11] = (CFMutableDictionaryRef)4;
          *((_DWORD *)this + 24) = -1001;
          CFDictionaryRemoveAllValues(this[19]);
        }
      }
      goto LABEL_73;
    }
  }
LABEL_34:
  result = *v15;
  *v14 = *(CFStreamError *)v15;
  return result;
}

uint64_t HTTPAuthentication::setBasicAuthenticationOnRequest_NoAuthFromResponse(HTTPAuthentication *this, const __CFString *a2, const __CFString *a3, const __CFString *a4, _QWORD *a5, CFStreamError *a6)
{
  const __CFAllocator *v9;
  CFIndex Length;
  CFIndex v11;
  _QWORD *v12;
  CFIndex MaximumSizeForEncoding;
  CFIndex v14;
  UInt8 *v15;
  CFIndex Bytes;
  CFIndex v17;
  CFIndex v18;
  uint64_t result;
  const void *v20;
  id v21;
  CFStringRef v22;
  HTTPMessage *v23;
  unsigned int v24;
  int v25;
  _BYTE *v26;
  int v28;
  _BYTE v29[16];
  CFIndex usedBufLen;
  CFRange v31;
  CFRange v32;

  v28 = (int)a4;
  v9 = CFGetAllocator(this);
  usedBufLen = 0;
  Length = CFStringGetLength(a2);
  v11 = CFStringGetLength(a3);
  if (a5)
    v12 = a5;
  else
    v12 = v29;
  *v12 = 0;
  v12[1] = 0;
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  v14 = CFStringGetMaximumSizeForEncoding(v11, 0x8000100u) + MaximumSizeForEncoding;
  v15 = (UInt8 *)CFAllocatorAllocate(v9, v14 + 1, 0);
  v31.location = 0;
  v31.length = Length;
  Bytes = CFStringGetBytes(a2, v31, 0x8000100u, 0, 0, v15, v14 + 1, &usedBufLen);
  if (Length <= v14 && Bytes == Length)
  {
    v17 = usedBufLen;
    v15[usedBufLen] = 58;
    v18 = v17 + 1;
    usedBufLen = v17 + 1;
    v32.location = 0;
    v32.length = v11;
    if (CFStringGetBytes(a3, v32, 0x8000100u, 0, 0, &v15[v17 + 1], v14 - v17, &usedBufLen) == v11)
    {
      result = (uint64_t)CFDataCreateWithBytesNoCopy(v9, v15, usedBufLen + v18, v9);
      if (result)
      {
        v20 = (const void *)result;
        v21 = (id)objc_msgSend((id)result, "base64EncodedStringWithOptions:", 0);
        CFRelease(v20);
        if (v21)
        {
          v22 = CFStringCreateWithFormat(v9, 0, CFSTR("Basic %@"), v21);
          CFRelease(v21);
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          if (this)
            v23 = (HTTPAuthentication *)((char *)this + 16);
          else
            v23 = 0;
          if (v28)
            v24 = 325219167;
          else
            v24 = 292663967;
          HTTPMessage::setHeaderFieldStringValue(v23, v24, v22);
          CFRelease(v22);
          return 1;
        }
        else
        {
          return 0;
        }
      }
      return result;
    }
    CFAllocatorDeallocate(v9, v15);
    v25 = -1002;
  }
  else
  {
    CFAllocatorDeallocate(v9, v15);
    v25 = -1001;
  }
  result = 0;
  *v12 = 4;
  v26 = v29;
  if (a5)
    v26 = a5;
  *((_DWORD *)v26 + 2) = v25;
  return result;
}

void HTTPAuthentication::setDigestAuthenticationOnRequest(__CFDictionary **this, char *cf, const __CFString *a3, const __CFString *a4)
{
  const __CFAllocator *v8;
  const __CFString *v9;
  CFTypeRef v10;
  const void *Property_Locked;
  const __CFString *v12;
  const __CFString *v13;
  CFStringRef MD5HashWithString;
  const __CFString *v15;
  const void *v16;
  const void *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFURL *v20;
  CFStringRef v21;
  const __CFString *v22;
  const __CFString *v23;
  CFStringRef v24;
  const __CFNumber *v25;
  __CFDictionary *v26;
  const void *v27;
  uint64_t v28;
  const void *v29;
  const __CFString *v30;
  const __CFString *v31;
  const __CFString *v32;
  CFStringRef v33;
  __CFString *Mutable;
  const __CFURL *v35;
  CFStringRef v36;
  const __CFString *v37;
  const __CFString *v38;
  CFTypeRef v39;
  const __CFString *v40;
  const __CFString *v41;
  CFTypeRef v42;
  const void *v43;
  const void *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  const __CFString *v48;
  const __CFString *v49;
  CFTypeRef v50;
  const __CFNumber *v51;
  int v52;
  HTTPMessage *v53;
  unsigned int v54;
  const void *v55;
  const void *v56;
  const __CFString *v57;
  CFTypeRef cfa;
  void *value;
  unsigned int valuePtr;

  v8 = CFGetAllocator(cf);
  v10 = AuthStringUtils::_CFStringUnquote(a3, v9);
  Property_Locked = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Realm"));
  v12 = CFStringCreateWithFormat(v8, 0, CFSTR("%@:%@:%@"), v10, Property_Locked, a4);
  MD5HashWithString = HTTPAuthentication::createMD5HashWithString(v8, v12, v13);
  CFRelease(v12);
  CFRelease(v10);
  v15 = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Algorithm"));
  if (v15 && CFStringCompare(v15, CFSTR("MD5-sess"), 1uLL) == kCFCompareEqualTo)
  {
    v16 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Nonce"));
    v17 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Cnonce"));
    v18 = CFStringCreateWithFormat(v8, 0, CFSTR("%@:%@:%@"), MD5HashWithString, v16, v17);
    CFRelease(MD5HashWithString);
    MD5HashWithString = HTTPAuthentication::createMD5HashWithString(v8, v18, v19);
    CFRelease(v18);
  }
  cfa = CFHTTPMessageCopyRequestMethod((CFHTTPMessageRef)cf);
  v20 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)cf);
  v21 = HTTPAuthentication::createDigestURI((HTTPAuthentication *)*((unsigned __int8 *)this + 160), v8, v20, &cfa);
  if (v20)
    CFRelease(v20);
  v22 = CFStringCreateWithFormat(v8, 0, CFSTR("%@:%@"), cfa, v21);
  CFRelease(cfa);
  if (v21)
    CFRelease(v21);
  v24 = HTTPAuthentication::createMD5HashWithString(v8, v22, v23);
  CFRelease(v22);
  v57 = a3;
  if (HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Qop")))
  {
    v25 = (const __CFNumber *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Nc"));
    valuePtr = 0;
    CFNumberGetValue(v25, kCFNumberSInt32Type, &valuePtr);
    ++valuePtr;
    v26 = this[17];
    AutoScalar::AutoScalar((AutoScalar *)&cfa, (const __CFAllocator *)valuePtr);
    CFDictionarySetValue(v26, CFSTR("Nc"), value);
    cfa = &off_1E14E47E8;
    if (value)
      CFRelease(value);
    v27 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Nonce"));
    v28 = (int)valuePtr;
    v29 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Cnonce"));
    v56 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Qop"));
    v30 = CFStringCreateWithFormat(v8, 0, CFSTR("%@:%@:%08lx:%@:%@:%@"), MD5HashWithString, v27, v28, v29, v56, v24);
  }
  else
  {
    v55 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Nonce"));
    v30 = CFStringCreateWithFormat(v8, 0, CFSTR("%@:%@:%@"), MD5HashWithString, v55, v24);
  }
  v32 = v30;
  v33 = HTTPAuthentication::createMD5HashWithString(v8, v30, v31);
  CFRelease(v32);
  CFRelease(MD5HashWithString);
  CFRelease(v24);
  Mutable = CFStringCreateMutable(v8, 0);
  v35 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)cf);
  cfa = 0;
  v36 = HTTPAuthentication::createDigestURI((HTTPAuthentication *)*((unsigned __int8 *)this + 160), v8, v35, &cfa);
  if (cfa)
    CFRelease(cfa);
  CFRelease(v35);
  v37 = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Realm"));
  v39 = AuthStringUtils::_CFStringQuote(v37, v38);
  v40 = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Nonce"));
  v42 = AuthStringUtils::_CFStringQuote(v40, v41);
  v43 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("kCFHTTPAuthenticationPropertyMethod"));
  CFStringAppendFormat(Mutable, 0, CFSTR("%@ username=\"%@\", realm=\"%@\", nonce=\"%@\", uri=\"%@\", response=\"%@\""), v43, v57, v39, v42, v36, v33);
  if (v36)
    CFRelease(v36);
  CFRelease(v42);
  CFRelease(v39);
  v44 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Opaque"));
  if (v44)
    CFStringAppendFormat(Mutable, 0, CFSTR(", opaque=\"%@\""), v44);
  v45 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Algorithm"));
  if (v45)
    CFStringAppendFormat(Mutable, 0, CFSTR(", algorithm=\"%@\""), v45);
  v46 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Qop"));
  if (v46)
  {
    v47 = v46;
    valuePtr = 0;
    v48 = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Cnonce"));
    v50 = AuthStringUtils::_CFStringQuote(v48, v49);
    v51 = (const __CFNumber *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, CFSTR("Nc"));
    CFNumberGetValue(v51, kCFNumberSInt32Type, &valuePtr);
    CFStringAppendFormat(Mutable, 0, CFSTR(", cnonce=\"%@\", nc=%08lx, qop=\"%@\""), v50, valuePtr, v47);
    CFRelease(v50);
  }
  CFRelease(v33);
  v52 = *((unsigned __int8 *)this + 160);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (cf)
    v53 = (HTTPMessage *)(cf + 16);
  else
    v53 = 0;
  if (v52)
    v54 = 325219167;
  else
    v54 = 292663967;
  HTTPMessage::setHeaderFieldStringValue(v53, v54, Mutable);
  CFRelease(Mutable);
}

void sub_184082234(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPAuthentication::setNegotiateAuthenticationOnRequest(HTTPAuthentication *this, __CFHTTPMessage *a2, const __CFString *a3, const __CFString *a4)
{
  const __CFURL *v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFURL *v9;
  const __CFURL *v10;
  const __CFURL *v11;
  const __CFURL *v12;
  CFStringRef v13;
  CFStringRef v14;
  CFStringRef v15;

  if (*((_BYTE *)this + 160) && (v6 = (const __CFURL *)*((_QWORD *)this + 21)) != 0)
  {
    v7 = CFURLCopyScheme(v6);
    v8 = v7;
    if (v7)
    {
      if (CFStringCompare(v7, (CFStringRef)&unk_1EDD00AE0, 1uLL) == kCFCompareEqualTo)
      {
        v9 = (const __CFURL *)*((_QWORD *)this + 21);
        if (v9)
        {
          v10 = 0;
          goto LABEL_10;
        }
      }
    }
  }
  else
  {
    v8 = 0;
  }
  v9 = CFHTTPMessageCopyRequestURL(a2);
  if (!v9)
  {
    v10 = 0;
    goto LABEL_18;
  }
  v10 = v9;
LABEL_10:
  v11 = CFURLCopyAbsoluteURL(v9);
  v12 = v11;
  if (v11)
  {
    v13 = CFURLCopyHostName(v11);
    v14 = v13;
    if (v13)
    {
      if (v8)
      {
        CFRelease(v13);
        v15 = v8;
LABEL_16:
        CFRelease(v12);
        v8 = v15;
        goto LABEL_19;
      }
      v15 = CFURLCopyScheme(v12);
      CFRelease(v14);
      if (v15)
        goto LABEL_16;
    }
    CFRelease(v12);
  }
LABEL_18:
  *((_QWORD *)this + 11) = 4;
  *((_DWORD *)this + 24) = -3;
  CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
LABEL_19:
  if (v10)
    CFRelease(v10);
  if (v8)
    CFRelease(v8);
}

void sub_184082390(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;
  const void *v3;
  const void *v4;

  CFRelease(v4);
  CFRelease(v3);
  if (v2)
    CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTPAuthentication::setNTLMAuthenticationOnRequest(CFDictionaryRef *this, __CFHTTPMessage *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  CFIndex Count;
  const __CFAllocator *v11;
  const void **v12;
  void **v13;
  int PasswordHashes;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  const void *v18;
  int ClientResponse;
  void *v20;
  int v21;
  int v22;
  CFDictionaryRef v23;
  CFDictionaryRef v24;
  _QWORD v25[5];
  CFTypeRef cf;
  const __CFDictionary *v27;
  void *values[2];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  Count = CFDictionaryGetCount(this[19]);
  v34 = 0u;
  v35 = 0u;
  v33 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  *(_OWORD *)values = 0u;
  v11 = CFGetAllocator(a2);
  if (!this[15])
  {
    if (!a3 || !a4)
    {
      if (a3)
        v22 = -1002;
      else
        v22 = -1001;
      this[11] = (CFDictionaryRef)4;
      *((_DWORD *)this + 24) = v22;
      CFDictionaryRemoveAllValues(this[19]);
      return;
    }
    v25[0] = MEMORY[0x1E0C809B0];
    v25[1] = 3221225472;
    v25[2] = ___ZN18HTTPAuthentication30setNTLMAuthenticationOnRequestEP15__CFHTTPMessagePK10__CFStringS4_S4__block_invoke;
    v25[3] = &__block_descriptor_40_e37_v24__0____CFString__8____CFString__16l;
    v25[4] = this;
    AuthStringUtils::downLevelLogonName((uint64_t)a5, a3, (uint64_t)v25);
    cf = 0;
    v27 = 0;
    PasswordHashes = NtlmGeneratePasswordHashes();
    if (PasswordHashes)
    {
      this[11] = (CFDictionaryRef)2;
      *((_DWORD *)this + 24) = PasswordHashes;
LABEL_30:
      CFDictionaryRemoveAllValues(this[19]);
      return;
    }
    v23 = this[15];
    this[15] = (CFDictionaryRef)cf;
    if (v23)
      CFRelease(v23);
    v24 = this[16];
    this[16] = v27;
    if (v24)
      CFRelease(v24);
  }
  if (Count < 17)
  {
    v13 = values;
    CFDictionaryGetKeysAndValues(this[19], 0, (const void **)values);
    if (Count < 1)
      return;
    goto LABEL_10;
  }
  v12 = (const void **)CFAllocatorAllocate(v11, 8 * Count, 0);
  if (!v12)
  {
    this[11] = (CFDictionaryRef)1;
    *((_DWORD *)this + 24) = 12;
    goto LABEL_30;
  }
  v13 = (void **)v12;
  CFDictionaryGetKeysAndValues(this[19], 0, v12);
LABEL_10:
  v15 = 0;
  while (1)
  {
    cf = 0;
    v16 = v13[v15];
    if (!*v16)
      break;
    v17 = v16[1];
    if (v17)
    {
      v18 = (const void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", v17, 0);
      ClientResponse = _NtlmCreateClientResponse();
      CFRelease(v18);
      NtlmGeneratorRelease();
      *(_QWORD *)v13[v15] = 0;
      if (ClientResponse)
        goto LABEL_36;
LABEL_14:
      v20 = (void *)cf;
      if (cf)
      {
        if (*((_QWORD *)v13[v15] + 2))
        {
          CFRelease(*((CFTypeRef *)v13[v15] + 2));
          v20 = (void *)cf;
        }
        *((_QWORD *)v13[v15] + 2) = (id)objc_msgSend(v20, "base64EncodedStringWithOptions:", 0);
        CFRelease(cf);
      }
    }
LABEL_20:
    if (Count == ++v15)
      goto LABEL_37;
  }
  if (v16[2] || v16[1])
    goto LABEL_20;
  v21 = NtlmGeneratorCreate();
  if (!v21)
  {
    ClientResponse = NtlmCreateClientRequest();
    if (ClientResponse)
      goto LABEL_36;
    goto LABEL_14;
  }
  ClientResponse = v21;
LABEL_36:
  this[11] = (CFDictionaryRef)2;
  *((_DWORD *)this + 24) = ClientResponse;
  CFDictionaryRemoveAllValues(this[19]);
LABEL_37:
  if (v13 != values)
    CFAllocatorDeallocate(v11, v13);
}

void HTTPAuthentication::setXMobileMeAuthTokenOnRequest(HTTPAuthentication *this, char *cf, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  HTTPProtocol *v10;
  char *v11;
  const __CFAllocator *v12;
  __SecTrust *v13;
  double v14;
  __CFString *XMobileMeAuthTokenForHTTPHeader;
  __CFString *v16;
  int v17;
  HTTPMessage *v18;
  unsigned int v19;

  v10 = (HTTPProtocol *)CFGetAllocator(cf);
  if (cf)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v11 = cf + 16;
    if (cf[40])
      v11 = 0;
  }
  else
  {
    v11 = 0;
  }
  v12 = (const __CFAllocator *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(v11 + 128));
  XMobileMeAuthTokenForHTTPHeader = HTTPAuthentication::createXMobileMeAuthTokenForHTTPHeader(0, v10, v12, (const __CFURL *)a3, a4, a5, *((const __CFString **)this + 27), v13, v14);
  if (XMobileMeAuthTokenForHTTPHeader)
  {
    v16 = XMobileMeAuthTokenForHTTPHeader;
    v17 = *((unsigned __int8 *)this + 160);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (cf)
      v18 = (HTTPMessage *)(cf + 16);
    else
      v18 = 0;
    if (v17)
      v19 = 325219167;
    else
      v19 = 292663967;
    HTTPMessage::setHeaderFieldStringValue(v18, v19, v16);
    CFRelease(v16);
  }
  else
  {
    *((_QWORD *)this + 11) = 4;
    *((_DWORD *)this + 24) = -1001;
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
  }
}

void HTTPAuthentication::setOAuth1AuthenticationOnRequest(uint64_t a1, void *cf, _QWORD *a3, int a4)
{
  const __CFAllocator *v8;
  const void **v9;
  __CFHTTPMessage *v10;
  uint64_t v11;
  void *v12;
  const void *v13;
  uint64_t Instance;
  double v15;
  uint64_t v16;
  CFNumberRef v17;
  NSObject *v18;
  _QWORD *v19;
  _QWORD *v20;
  id v21;
  uint64_t v22;
  void *v23;
  const __CFNumber *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  const __CFDictionary *v30;
  const __CFDictionary *v31;
  NSObject *v32;
  NSObject *v33;
  const char *v34;
  uint8_t *v35;
  uint8_t v36[16];
  uint8_t buf[16];
  __int16 v38;
  __int16 v39;
  uint8_t v40[2];
  int valuePtr;

  valuePtr = a4;
  v8 = CFGetAllocator(cf);
  v9 = (const void **)CFHTTPMessageCopyBody((CFHTTPMessageRef)cf);
  if (v9)
    v10 = CFArrayCreate(v8, v9, 1, MEMORY[0x1E0C9B378]);
  else
    v10 = 0;
  v11 = _constructRequestFromParts((const __CFAllocator *)cf, v10, 0, NSURLRequestUseProtocolCachePolicy, 30.0, 0);
  if (v11)
  {
    v12 = (void *)v11;
    v13 = (const void *)(a1 - 16);
    CFGetAllocator((CFTypeRef)(a1 - 16));
    if (TCFObject<CFNACOAuthSigner>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<CFNACOAuthSigner>::Class(void)::sOnce, &__block_literal_global_69_7984);
    Instance = _CFRuntimeCreateInstance();
    v16 = Instance;
    if (Instance)
    {
      v15 = 0.0;
      *(_OWORD *)(Instance + 16) = 0u;
      v16 = Instance + 16;
      *(_QWORD *)(Instance + 48) = 0;
      *(_OWORD *)(Instance + 32) = 0u;
    }
    *(_QWORD *)v16 = &off_1E14E7E38;
    *(_QWORD *)(v16 + 8) = &unk_1E14E7E88;
    *(_QWORD *)(v16 + 16) = 0;
    *(_QWORD *)(v16 + 24) = 0;
    CFNACOAuthSigner::initialize(v16, a3, v15);
    if (*(_QWORD *)(v16 + 16))
      objc_msgSend(*(id *)(v16 + 16), "setShouldIncludeAppIdInRequest:", 0);
    if (a4 < 1)
      v17 = 0;
    else
      v17 = CFNumberCreate(v8, kCFNumberSInt32Type, &valuePtr);
    CFGetAllocator(v13);
    if (TCFObject<CFNNSURLRequest>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<CFNNSURLRequest>::Class(void)::sOnce, &__block_literal_global_70);
    v19 = (_QWORD *)_CFRuntimeCreateInstance();
    v20 = v19;
    if (v19)
    {
      v19[2] = 0;
      v19[3] = 0;
      v20 = v19 + 2;
      v19[4] = 0;
    }
    *v20 = &off_1E14E73F8;
    v20[1] = &unk_1E14E7440;
    v20[2] = 0;
    v21 = v12;
    v20[2] = v21;
    if (!v21
      || !v17
      || (v22 = objc_msgSend(*(id *)(v16 + 16), "signedURLRequestWithURLRequest:callingPID:timestamp:", v21, v17, 0)) == 0)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v32 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_183ECA000, v32, OS_LOG_TYPE_ERROR, "OAuth signer did not return a signed request.", buf, 2u);
      }
      goto LABEL_53;
    }
    v23 = (void *)v22;
    v24 = v17;
    CFGetAllocator((CFTypeRef)(v16 - 16));
    if (TCFObject<CFNNSURLRequest>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<CFNNSURLRequest>::Class(void)::sOnce, &__block_literal_global_3_11718);
    v25 = (_QWORD *)_CFRuntimeCreateInstance();
    v26 = v25;
    if (v25)
    {
      v25[2] = 0;
      v25[3] = 0;
      v26 = v25 + 2;
      v25[4] = 0;
    }
    *v26 = &off_1E14E73F8;
    v26[1] = &unk_1E14E7440;
    v26[2] = 0;
    v26[2] = v23;
    v27 = v26 - 2;
    if (TCFObject<CFNNSURLRequest>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<CFNNSURLRequest>::Class(void)::sOnce, &__block_literal_global_70);
    v28 = (void *)v26[2];
    if (v28)
    {
      v29 = *(_QWORD *)(objc_msgSend(v28, "_inner") + 56);
      if (v29)
      {
        v30 = CFHTTPMessageCopyAllHeaderFields((CFHTTPMessageRef)(v29 - 16));
        if (v30)
        {
          v31 = v30;
          _CFHTTPMessageSetMultipleHeaderFields((__CFHTTPMessage *)cf, v30);
          CFRelease(v31);
          v17 = v24;
LABEL_52:
          CFRelease(v27);
LABEL_53:
          CFRelease((CFTypeRef)(v16 - 16));
          CFRelease(v12);
          if (v17)
            CFRelease(v17);
          goto LABEL_55;
        }
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v17 = v24;
        v33 = CFNLog::logger;
        if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          goto LABEL_52;
        *(_WORD *)v40 = 0;
        v34 = "unable to extract authorized headers from signed message.";
        v35 = v40;
      }
      else
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v17 = v24;
        v33 = CFNLog::logger;
        if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          goto LABEL_52;
        v39 = 0;
        v34 = "unable to extract signed message from request.";
        v35 = (uint8_t *)&v39;
      }
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v17 = v24;
      v33 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        goto LABEL_52;
      v38 = 0;
      v34 = "unable to extract CF request from Obj-C request.";
      v35 = (uint8_t *)&v38;
    }
    _os_log_error_impl(&dword_183ECA000, v33, OS_LOG_TYPE_ERROR, v34, v35, 2u);
    goto LABEL_52;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v18 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v36 = 0;
    _os_log_error_impl(&dword_183ECA000, v18, OS_LOG_TYPE_ERROR, "failed to create a CF request from an HTTP message.", v36, 2u);
  }
LABEL_55:
  if (v9)
    CFRelease(v9);
  if (v10)
    CFRelease(v10);
}

void ___ZN9TCFObjectI15CFNNSURLRequestE5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  qmemcpy(_PNAME<CFNNSURLRequest>::GET(void)::p, "CFNNSURLRequest", 15);
  CFClass::CFClass(v0, (const char *)_PNAME<CFNNSURLRequest>::GET(void)::p);
  TCFObject<CFNNSURLRequest>::Class(void)::clazz = (uint64_t)v0;
}

void sub_184082E18(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI16CFNACOAuthSignerE5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  _PNAME<CFNACOAuthSigner>::GET(void)::p[0] = *(_OWORD *)"CFNACOAuthSigner>::GET() [OBJTYPE = CFNACOAuthSigner]";
  CFClass::CFClass(v0, (const char *)_PNAME<CFNACOAuthSigner>::GET(void)::p);
  TCFObject<CFNACOAuthSigner>::Class(void)::clazz = (uint64_t)v0;
}

void sub_184082E94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

__CFString *HTTPAuthentication::createXMobileMeAuthTokenForHTTPHeader(HTTPAuthentication *this, HTTPProtocol *a2, const __CFAllocator *a3, const __CFURL *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, __SecTrust *a8, double a9)
{
  uint64_t v9;
  __CFString *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  double v16;
  const void **v17;
  BOOL v18;
  void *v19;
  const __CFAllocator *v20;
  uint64_t v21;
  const __CFAllocator *v22;
  uint64_t v23;
  void *v24;
  void *v25;
  CFDictionaryRef v26;
  double v27;
  uint64_t delayInitStub;
  const void *v29;
  NSObject *v30;
  double v31;
  const __CFDictionary *inited;
  const __CFDictionary *v33;
  const void *Value;
  double v35;
  uint64_t v36;
  const void *v37;
  BOOL v38;
  NSObject *v39;
  NSObject *v40;
  const void *v41;
  const void *v42;
  const __CFString *v43;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  char *v46;
  size_t v47;
  CFDataRef v48;
  CFDataRef v49;
  id v50;
  const void *v51;
  __CFString *Mutable;
  NSObject *v53;
  NSObject *v54;
  const char *v55;
  NSObject *v57;
  CFDataRef v58;
  void *values;
  void *keys[2];

  v10 = 0;
  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  gotLoadHelper_x27__kAOSMMeAuthTokenKey(a9);
  v17 = *(const void ***)(v9 + 2120);
  if (v17)
    v18 = v13 == 0;
  else
    v18 = 1;
  if (v18)
    return v10;
  v19 = v14;
  v20 = v12;
  v21 = v11;
  v22 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (v15)
  {
    gotLoadHelper_x8__kAOSAuthTrustInfoKey(v16);
    v24 = **(void ***)(v23 + 2112);
    values = v25;
    keys[0] = v24;
    v26 = CFDictionaryCreate(v22, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    v26 = 0;
  }
  objc_msgSend(v19, "stringByRemovingPercentEncoding");
  delayInitStub = AOSAccountCreate_delayInitStub(v27);
  if (!delayInitStub)
  {
    v10 = 0;
    if (!v26)
      return v10;
    goto LABEL_58;
  }
  v29 = (const void *)delayInitStub;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v30 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(keys[0]) = 0;
    _os_log_impl(&dword_183ECA000, v30, OS_LOG_TYPE_DEFAULT, "CFNetwork-AOSKit: Reaching out to AOSKit for X-mobile me token", (uint8_t *)keys, 2u);
  }
  inited = (const __CFDictionary *)AOSAccountCopyAuthInfo_delayInitStub(v31);
  if (inited)
  {
    v33 = inited;
    Value = CFDictionaryGetValue(inited, *v17);
    gotLoadHelper_x8__kAOSPersonIDKey(v35);
    v37 = CFDictionaryGetValue(v33, **(const void ***)(v36 + 2128));
    if (Value)
      v38 = v37 == 0;
    else
      v38 = 1;
    if (v38)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v39 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(keys[0]) = 0;
        _os_log_impl(&dword_183ECA000, v39, OS_LOG_TYPE_DEFAULT, "CFNetwork-AOSKit: X-mobile me auth token or authPersonId is not valid", (uint8_t *)keys, 2u);
      }
      v10 = 0;
      goto LABEL_56;
    }
    v41 = v37;
    if (v21)
    {
      v42 = *(const void **)(v21 + 464);
      if (v42)
        CFRelease(v42);
      *(_QWORD *)(v21 + 464) = CFRetain(Value);
    }
    v43 = CFStringCreateWithFormat(v20, 0, CFSTR("%@:%@"), v41, Value);
    Length = CFStringGetLength(v43);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    v46 = (char *)CFAllocatorAllocate(v20, MaximumSizeForEncoding, 0);
    if (CFStringGetCString(v43, v46, MaximumSizeForEncoding, 0x8000100u))
    {
      v47 = strlen(v46);
      v48 = CFDataCreateWithBytesNoCopy(v20, (const UInt8 *)v46, v47, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
      if (v48)
      {
        v49 = v48;
        v50 = (id)-[__CFData base64EncodedStringWithOptions:](v48, "base64EncodedStringWithOptions:", 0);
        v58 = v49;
        if (v50)
        {
          v51 = v50;
          Mutable = CFStringCreateMutable(v20, 0);
          v10 = Mutable;
          if (Mutable)
          {
            CFStringAppendFormat(Mutable, 0, CFSTR("X-MobileMe-AuthToken %@"), v51);
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v53 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(keys[0]) = 0;
              _os_log_impl(&dword_183ECA000, v53, OS_LOG_TYPE_DEFAULT, "CFNetwork-AOSKit: Applied X-mobile me auth to request", (uint8_t *)keys, 2u);
            }
          }
          CFRelease(v51);
        }
        else
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v57 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(keys[0]) = 0;
            _os_log_impl(&dword_183ECA000, v57, OS_LOG_TYPE_DEFAULT, "CFNetwork-AOSKit: Base-64 encoding of token data failed.", (uint8_t *)keys, 2u);
          }
          v10 = 0;
        }
        CFRelease(v58);
        if (!v43)
          goto LABEL_55;
        goto LABEL_54;
      }
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v54 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(keys[0]) = 0;
        v55 = "CFNetwork-AOSKit: unable to allocate CFDataRef to hold raw token data.";
        goto LABEL_52;
      }
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v54 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(keys[0]) = 0;
        v55 = "CFNetwork-AOSKit: unable to convert auth-token to UTF8 string.";
LABEL_52:
        _os_log_impl(&dword_183ECA000, v54, OS_LOG_TYPE_DEFAULT, v55, (uint8_t *)keys, 2u);
      }
    }
    v10 = 0;
    if (!v43)
    {
LABEL_55:
      CFAllocatorDeallocate(v20, v46);
LABEL_56:
      CFRelease(v33);
      goto LABEL_57;
    }
LABEL_54:
    CFRelease(v43);
    goto LABEL_55;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v40 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(keys[0]) = 0;
    _os_log_impl(&dword_183ECA000, v40, OS_LOG_TYPE_DEFAULT, "CFNetwork-AOSKit: Failed to get a X-mobile me token from AOSkit", (uint8_t *)keys, 2u);
  }
  v10 = 0;
LABEL_57:
  CFRelease(v29);
  if (v26)
LABEL_58:
    CFRelease(v26);
  return v10;
}

void ___ZN18HTTPAuthentication30setNTLMAuthenticationOnRequestEP15__CFHTTPMessagePK10__CFStringS4_S4__block_invoke(uint64_t a1, const void *a2, CFTypeRef cf)
{
  uint64_t v4;
  CFTypeRef v5;
  const void *v6;
  CFTypeRef v7;
  const void *v8;

  v4 = *(_QWORD *)(a1 + 32);
  if (cf)
    v5 = CFRetain(cf);
  else
    v5 = 0;
  v6 = *(const void **)(v4 + 104);
  *(_QWORD *)(v4 + 104) = v5;
  if (v6)
    CFRelease(v6);
  if (a2)
    v7 = CFRetain(a2);
  else
    v7 = 0;
  v8 = *(const void **)(v4 + 112);
  *(_QWORD *)(v4 + 112) = v7;
  if (v8)
    CFRelease(v8);
}

CFStringRef HTTPAuthentication::createDigestURI(HTTPAuthentication *this, const __CFAllocator *a2, CFURLRef anURL, CFTypeRef *a4)
{
  const __CFString *v7;
  const __CFString *v8;
  int v9;
  unsigned int v10;
  CFStringRef v11;
  uint64_t v12;
  CFStringRef v13;
  size_t v14;
  CFAllocatorRef allocator;
  uint64_t v17;
  void *ptr;
  char *__s;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!(_BYTE)this)
    goto LABEL_17;
  v7 = CFURLCopyScheme(anURL);
  if (!v7)
  {
LABEL_6:
    v9 = 1;
    goto LABEL_18;
  }
  v8 = v7;
  if (CFStringCompare(v7, (CFStringRef)&unk_1EDD00AE0, 1uLL) && CFStringCompare(v8, CFSTR("wss"), 1uLL))
  {
    CFRelease(v8);
    goto LABEL_6;
  }
  v10 = CFURLGetPortNumber(anURL);
  v11 = CFURLCopyHostName(anURL);
  if (a4)
  {
    if (*a4)
      CFRelease(*a4);
    *a4 = CFRetain(&unk_1EDCFE0A8);
  }
  if (v10 == -1)
    v12 = 443;
  else
    v12 = v10;
  v13 = CFStringCreateWithFormat(a2, 0, CFSTR("%@:%d"), v11, v12);
  if (v11)
    CFRelease(v11);
  CFRelease(v8);
  if (!v13)
  {
LABEL_17:
    v9 = 0;
LABEL_18:
    URLPortion::URLPortion((URLPortion *)&allocator, a2, anURL, v9);
    v14 = strlen(__s);
    v13 = CFStringCreateWithBytes(a2, (const UInt8 *)__s, v14, 0x201u, 0);
    if (ptr != &v17)
      CFAllocatorDeallocate(allocator, ptr);
  }
  return v13;
}

void sub_18408363C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const __CFAllocator *allocator, uint64_t a12)
{
  if ((uint64_t *)STACK[0x218] != &a12)
    CFAllocatorDeallocate(allocator, (void *)STACK[0x218]);
  _Unwind_Resume(a1);
}

void HTTPAuthentication::setSecTrust(HTTPAuthentication *this, CFTypeRef cf)
{
  CFTypeRef v3;
  const void *v4;

  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  v4 = (const void *)*((_QWORD *)this + 27);
  *((_QWORD *)this + 27) = v3;
  if (v4)
    CFRelease(v4);
}

uint64_t HTTPAuthentication::appliesToRequest(HTTPAuthentication *this, __CFHTTPMessage *a2)
{
  HTTPAuthentication *v3;
  int HasPrefix;
  const __CFURL *v6;
  const __CFURL *v7;
  const __CFURL *v8;
  const __CFURL *v9;
  const __CFURL *v10;
  const __CFURL *v11;
  const __CFURL *v12;
  const __CFURL *v13;
  const __CFURL *v14;
  const __CFString *v15;
  const __CFURL *v16;
  const __CFString *v17;
  const void *Property_Locked;
  const __CFString *v19;
  unint64_t Count;
  CFRange v21;
  const void **v22;
  CFURLRef v23;
  CFStringRef v24;
  const __CFString *v25;
  const __CFString *v26;
  BOOL v27;
  BOOL v28;
  char v29;
  CFIndex v30;
  const __CFURL *v31;
  const __CFString *v32;
  const __CFString *v33;
  _BOOL4 v34;
  CFRange v35;
  CFRange v36;
  const __CFAllocator *v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  int v41;
  int v42;
  const void *v43;
  const void *v44;
  const __CFString *v45;
  unint64_t v46;
  CFRange v47;
  const void **v48;
  CFIndex v49;
  const __CFURL *v50;
  const __CFString *v51;
  const __CFString *str;
  const __CFURL *stra;
  const __CFString *theString;
  CFTypeRef v55;
  CFIndex range;
  const void **v57;
  _BYTE v58[248];
  CFIndex v59;
  _QWORD v60[2];
  uint64_t (*v61)(uint64_t);
  void *v62;
  HTTPAuthentication *v63;
  CFRange v64;
  CFRange v65;

  v3 = this;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  v60[0] = MEMORY[0x1E0C809B0];
  v60[1] = 3221225472;
  v61 = ___ZN18HTTPAuthentication16appliesToRequestEP15__CFHTTPMessage_block_invoke;
  v62 = &__block_descriptor_40_e5_v8__0l;
  v63 = v3;
  if (*((_BYTE *)v3 + 160))
  {
    LOBYTE(HasPrefix) = 1;
LABEL_3:
    LOBYTE(v3) = HasPrefix;
    goto LABEL_4;
  }
  if (!dyld_program_sdk_at_least())
  {
    v11 = CFHTTPMessageCopyRequestURL(a2);
    v12 = v11;
    if (!v11)
    {
      LOBYTE(HasPrefix) = 0;
      goto LABEL_3;
    }
    v13 = CFURLCopyAbsoluteURL(v11);
    v14 = v13;
    if (!v13)
    {
      LOBYTE(HasPrefix) = 0;
LABEL_56:
      CFRelease(v12);
      goto LABEL_3;
    }
    if (!*((_QWORD *)v3 + 22))
      goto LABEL_15;
    v15 = CFURLGetString(v13);
    v16 = CFURLCopyAbsoluteURL(*((CFURLRef *)v3 + 22));
    v17 = CFURLGetString(v16);
    HasPrefix = CFStringHasPrefix(v15, v17);
    if (v16)
      CFRelease(v16);
    if (!HasPrefix)
    {
LABEL_15:
      Property_Locked = HTTPAuthentication::getProperty_Locked(v3, CFSTR("Domain"));
      if (Property_Locked)
      {
        v19 = CFURLGetString(v14);
        v55 = CFRetain(Property_Locked);
        Count = CFArrayGetCount((CFArrayRef)Property_Locked);
        v21.length = Count;
        range = Count;
        if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
        {
          v57 = 0;
          goto LABEL_47;
        }
        if (Count > 0x1E)
        {
          v22 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
          v57 = v22;
          if (!v22)
            goto LABEL_47;
          v21.length = range;
        }
        else
        {
          v22 = (const void **)v58;
          v57 = (const void **)v58;
        }
        v21.location = 0;
        CFArrayGetValues((CFArrayRef)Property_Locked, v21, v22);
LABEL_47:
        v59 = 0;
        while (1)
        {
          v30 = v59;
          if (v59 >= range)
            break;
          ++v59;
          v31 = CFURLCopyAbsoluteURL((CFURLRef)v57[v30]);
          v32 = CFURLGetString(v31);
          HasPrefix = CFStringHasPrefix(v19, v32);
          if (v31)
            CFRelease(v31);
          if (HasPrefix)
            goto LABEL_54;
        }
        LOBYTE(HasPrefix) = 0;
LABEL_54:
        CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v55);
        goto LABEL_55;
      }
      LOBYTE(HasPrefix) = 0;
    }
LABEL_55:
    CFRelease(v14);
    goto LABEL_56;
  }
  v6 = CFHTTPMessageCopyRequestURL(a2);
  v7 = v6;
  if (v6)
  {
    v8 = CFURLCopyAbsoluteURL(v6);
    v9 = (const __CFURL *)*((_QWORD *)v3 + 22);
    if (!v9)
    {
      v10 = 0;
LABEL_26:
      LOBYTE(HasPrefix) = 0;
      goto LABEL_27;
    }
  }
  else
  {
    v8 = 0;
    v9 = (const __CFURL *)*((_QWORD *)v3 + 22);
    if (!v9)
    {
      LOBYTE(HasPrefix) = 0;
      v10 = 0;
      goto LABEL_27;
    }
  }
  v23 = CFURLCopyAbsoluteURL(v9);
  v10 = v23;
  if (!v8 || !v23)
    goto LABEL_26;
  v24 = CFURLCopyHostName(v8);
  v25 = CFURLCopyHostName(v10);
  v26 = v25;
  v27 = v24 != 0;
  if (!v24)
  {
    LOBYTE(HasPrefix) = 0;
    goto LABEL_39;
  }
  if (!v25)
  {
    CFRelease(v24);
    LOBYTE(v3) = 0;
    LOBYTE(HasPrefix) = 0;
    v29 = 0;
LABEL_28:
    CFRelease(v10);
    goto LABEL_29;
  }
  if (CFStringCompare(v24, v25, 0))
  {
    v28 = 0;
LABEL_59:
    LOBYTE(HasPrefix) = 0;
    v27 = 0;
    goto LABEL_60;
  }
  if (HTTPAuthentication::isConnectionBasedAuth_unlocked(v3))
  {
    v28 = compareSchemeAndNetLocation(v10, v8);
    goto LABEL_59;
  }
  v33 = CFURLCopyStrictPath(v8, 0);
  theString = CFURLCopyStrictPath(v10, 0);
  HasPrefix = 0;
  v34 = 1;
  if (v33 && theString)
  {
    str = v33;
    v35 = CFStringFind(v33, CFSTR("/"), 4uLL);
    v36 = CFStringFind(theString, CFSTR("/"), 4uLL);
    if (v35.length < 1 || v36.length < 1)
    {
      if (!CFStringGetLength(theString))
      {
LABEL_81:
        v34 = compareSchemeAndNetLocation(v10, v8);
        HasPrefix = v34;
LABEL_83:
        v33 = str;
        goto LABEL_84;
      }
      if (!CFStringGetLength(v33))
      {
LABEL_82:
        HasPrefix = 0;
        v34 = 1;
        goto LABEL_83;
      }
      v42 = CFStringHasPrefix(v33, theString);
LABEL_80:
      if (v42)
        goto LABEL_81;
      goto LABEL_82;
    }
    v37 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v64.location = 0;
    v64.length = v35.location;
    v38 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], str, v64);
    v65.location = 0;
    v65.length = v36.location;
    v39 = CFStringCreateWithSubstring(v37, theString, v65);
    v40 = v39;
    if (v38 && v39)
    {
      v41 = CFStringHasPrefix(v38, v39);
    }
    else
    {
      v41 = 0;
      v42 = 0;
      if (!v38)
        goto LABEL_78;
    }
    v42 = v41;
    CFRelease(v38);
LABEL_78:
    if (v40)
      CFRelease(v40);
    goto LABEL_80;
  }
LABEL_84:
  if (v34 && !HasPrefix)
  {
    v43 = HTTPAuthentication::getProperty_Locked(v3, CFSTR("Domain"));
    LOBYTE(HasPrefix) = 0;
    if (v7)
    {
      v44 = v43;
      if (v43)
      {
        stra = CFURLCopyAbsoluteURL(v7);
        v45 = CFURLGetString(stra);
        v55 = CFRetain(v44);
        v46 = CFArrayGetCount((CFArrayRef)v44);
        v47.length = v46;
        range = v46;
        if (v46 - 1 > 0x1FFFFFFFFFFFFFFDLL)
        {
          v57 = 0;
        }
        else
        {
          if (v46 <= 0x1E)
          {
            v48 = (const void **)v58;
            v57 = (const void **)v58;
LABEL_94:
            v47.location = 0;
            CFArrayGetValues((CFArrayRef)v44, v47, v48);
            goto LABEL_95;
          }
          v48 = (const void **)malloc_type_malloc(8 * v46, 0x89ED541CuLL);
          v57 = v48;
          if (v48)
          {
            v47.length = range;
            goto LABEL_94;
          }
        }
LABEL_95:
        v59 = 0;
        if (v45)
        {
          while (1)
          {
            v49 = v59;
            if (v59 >= range)
              break;
            ++v59;
            v50 = CFURLCopyAbsoluteURL((CFURLRef)v57[v49]);
            v51 = CFURLGetString(v50);
            HasPrefix = CFStringHasPrefix(v45, v51);
            if (v50)
              CFRelease(v50);
            if (HasPrefix)
              goto LABEL_102;
          }
        }
        LOBYTE(HasPrefix) = 0;
LABEL_102:
        if (stra)
          CFRelease(stra);
        CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v55);
      }
    }
  }
  if (theString)
    CFRelease(theString);
  if (v33)
    CFRelease(v33);
LABEL_39:
  v28 = 0;
  LOBYTE(v3) = 0;
  if (v26)
  {
LABEL_60:
    CFRelease(v26);
    LOBYTE(v3) = v28;
  }
  if (v24)
    CFRelease(v24);
  if (v27)
  {
LABEL_27:
    v29 = 1;
    if (!v10)
      goto LABEL_29;
    goto LABEL_28;
  }
  v29 = 0;
  if (v10)
    goto LABEL_28;
LABEL_29:
  if (v8)
    CFRelease(v8);
  if (v7)
    CFRelease(v7);
  if ((v29 & 1) != 0)
    goto LABEL_3;
LABEL_4:
  v61((uint64_t)v60);
  return v3;
}

void sub_184083CC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef a10, CFTypeRef cf, char a12)
{
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  uint64_t v18;

  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a12);
  if (cf)
    CFRelease(cf);
  if (v17)
    CFRelease(v17);
  CFRelease(v16);
  if (v15)
    CFRelease(v15);
  CFRelease(v14);
  if (v13)
    CFRelease(v13);
  if (v12)
    CFRelease(v12);
  (*(void (**)(uint64_t))(v18 - 112))(v18 - 128);
  _Unwind_Resume(a1);
}

uint64_t ___ZN18HTTPAuthentication16appliesToRequestEP15__CFHTTPMessage_block_invoke(uint64_t a1)
{
  return pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)(a1 + 32) + 16));
}

const __CFString *HTTPAuthentication::isConnectionBasedAuth_unlocked(HTTPAuthentication *this)
{
  const __CFString *result;
  int ExactString;

  result = (const __CFString *)HTTPAuthentication::getProperty_Locked(this, CFSTR("kCFHTTPAuthenticationPropertyMethod"));
  if (result)
  {
    ExactString = _findExactString(result, 1u);
    return (const __CFString *)(ExactString == 5316627 || ExactString == 6324248);
  }
  return result;
}

BOOL compareSchemeAndNetLocation(const __CFURL *a1, CFURLRef anURL)
{
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  SInt32 v7;
  SInt32 v8;
  _BOOL8 v9;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;

  v4 = CFURLCopyScheme(anURL);
  v5 = CFURLCopyScheme(a1);
  v6 = v5;
  if (v4)
  {
    if (v5)
    {
      if (CFStringCompare(v4, v5, 1uLL) == kCFCompareEqualTo
        && ((v7 = CFURLGetPortNumber(anURL), v8 = CFURLGetPortNumber(a1), v7 < 1) || v8 < 1 || v7 == v8))
      {
        v11 = CFURLCopyUserName(a1);
        v12 = CFURLCopyUserName(anURL);
        if (areStringsEqual(v11, v12))
        {
          v13 = CFURLCopyPassword(a1);
          v14 = CFURLCopyPassword(anURL);
          v9 = areStringsEqual(v13, v14);
          if (v14)
            CFRelease(v14);
          if (v13)
            CFRelease(v13);
        }
        else
        {
          v9 = 0;
        }
        if (v12)
          CFRelease(v12);
        if (v11)
          CFRelease(v11);
      }
      else
      {
        v9 = 0;
      }
      CFRelease(v6);
    }
    else
    {
      v9 = 0;
    }
  }
  else
  {
    v9 = 0;
    v4 = v5;
    if (!v5)
      return v9;
  }
  CFRelease(v4);
  return v9;
}

void sub_184083F90(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  if (v6)
  {
    CFRelease(v6);
    if (!v5)
    {
LABEL_3:
      if (!v4)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else if (!v5)
  {
    goto LABEL_3;
  }
  CFRelease(v5);
  if (!v4)
  {
LABEL_4:
    if (!v3)
    {
LABEL_10:
      CFRelease(v2);
      CFRelease(v1);
      _Unwind_Resume(a1);
    }
LABEL_9:
    CFRelease(v3);
    goto LABEL_10;
  }
LABEL_8:
  CFRelease(v4);
  if (!v3)
    goto LABEL_10;
  goto LABEL_9;
}

BOOL areStringsEqual(const __CFString *a1, const __CFString *a2)
{
  if (a1 && !a2)
    return 0;
  if (a1 && a2)
    return CFStringCompare(a1, a2, 0) == kCFCompareEqualTo;
  return a1 || a2 == 0;
}

const __CFString *HTTPAuthentication::isConnectionBasedAuth(HTTPAuthentication *this)
{
  pthread_mutex_t *v2;
  const __CFString *v3;

  v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  v3 = HTTPAuthentication::isConnectionBasedAuth_unlocked(this);
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t HTTPAuthentication::updateFromResponse(HTTPAuthentication *this, __CFHTTPMessage *a2, const void *a3)
{
  pthread_mutex_t *v6;
  int ResponseStatusCode;
  __CFString *v8;
  CFStringRef *v9;
  CFStringRef v10;
  const __CFString *v11;
  uint64_t v12;
  CFStringRef *v13;
  CFStringRef v14;
  const __CFAllocator *v15;
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v17;
  __CFDictionary *v18;
  __CFArray *v19;
  int ExactString;
  int v21;
  const __CFDictionary *v22;
  const __CFDictionary *v23;
  const __CFString *v24;
  const __CFString *v25;
  CFTypeRef v26;
  __CFDictionary *v27;
  const void *v28;
  const __CFDictionary *v29;
  const void *v30;
  _QWORD *v31;
  _QWORD *v32;
  const __CFDictionary *v33;
  const __CFString *v34;
  const __CFString *v35;
  const void *v36;
  const void *v37;
  int ClientResponse;
  CFTypeRef v39;
  _QWORD *v40;
  uint64_t v41;
  const void *v42;
  int ClientRequest;
  const __CFString *v44;
  const __CFString *v45;
  CFTypeRef v46;
  __CFDictionary *v47;
  const __CFString *v48;
  const void *v50;
  const void *v51;
  CFTypeRef cf;
  void *value;

  v6 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  if (!*((_DWORD *)this + 24))
  {
    ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(a2);
    if (!*((_QWORD *)this + 17) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(cf) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "_CFHTTPAuthenticationUpdateFromResponse(): authentication context not properly configured", (uint8_t *)&cf, 2u);
    }
    _CFHTTPMessageSetAuthentication(a2, (char *)this - 16, *((unsigned __int8 *)this + 160));
    v8 = (__CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 17), CFSTR("kCFHTTPAuthenticationPropertyMethod"));
    v9 = (CFStringRef *)&kCFHTTPHeaderProxyAuthenticationInfo;
    if (!*((_BYTE *)this + 160))
      v9 = (CFStringRef *)&kCFHTTPHeaderAuthenticationInfo;
    v10 = CFHTTPMessageCopyHeaderFieldValue(a2, *v9);
    if (v10)
    {
      v11 = v10;
      v12 = 1;
      goto LABEL_13;
    }
    v13 = (CFStringRef *)&kCFHTTPHeaderProxyAuthenticate;
    if (!*((_BYTE *)this + 160))
      v13 = (CFStringRef *)&kCFHTTPHeaderWWWAuthenticate;
    v14 = CFHTTPMessageCopyHeaderFieldValue(a2, *v13);
    if (v14)
    {
      v11 = v14;
      v12 = 0;
LABEL_13:
      v15 = CFGetAllocator((char *)this - 16);
      Mutable = CFDictionaryCreateMutable(v15, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
      v17 = CFGetAllocator((char *)this - 16);
      v18 = CFArrayCreateMutable(v17, 0, MEMORY[0x1E0C9B378]);
      if (!HTTPAuthentication::parseHeader(v11, (const __CFString *)v12, Mutable, v18, v19))
      {
        *((_QWORD *)this + 11) = 4;
        v21 = -1;
LABEL_77:
        *((_DWORD *)this + 24) = v21;
        goto LABEL_78;
      }
      ExactString = _findExactString(v8, 1u);
      if (ExactString <= 5316626)
      {
        if (ExactString != 40960)
        {
          if (ExactString != 2146311)
          {
LABEL_48:
            *((_QWORD *)this + 11) = 4;
            v21 = -1000;
            goto LABEL_77;
          }
          v22 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, v8);
          if (v22)
          {
            v23 = v22;
            v24 = (const __CFString *)CFDictionaryGetValue(v22, &unk_1EDCFEE70);
            if (v24)
            {
              v26 = AuthStringUtils::_CFStringUnquote(v24, v25);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 17), &unk_1EDCFEE70, v26);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 17), &unk_1EDCFEEA8, v26);
              CFRelease(v26);
              v27 = (__CFDictionary *)*((_QWORD *)this + 17);
              AutoScalar::AutoScalar((AutoScalar *)&cf, 0);
              CFDictionarySetValue(v27, &unk_1EDCFEE38, value);
              cf = &off_1E14E47E8;
              if (value)
                CFRelease(value);
            }
            v44 = (const __CFString *)CFDictionaryGetValue(v23, &unk_1EDCFEEA8);
            if (v44)
            {
              v46 = AuthStringUtils::_CFStringUnquote(v44, v45);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 17), &unk_1EDCFEEA8, v46);
              CFRelease(v46);
              v47 = (__CFDictionary *)*((_QWORD *)this + 17);
              AutoScalar::AutoScalar((AutoScalar *)&cf, 0);
              CFDictionarySetValue(v47, &unk_1EDCFEE38, value);
              cf = &off_1E14E47E8;
              if (value)
                CFRelease(value);
            }
            v48 = (const __CFString *)CFDictionaryGetValue(v23, &unk_1EDCFEFC0);
            if (v48)
            {
              if (CFStringCompare(v48, (CFStringRef)&unk_1EDCFF030, 1uLL) == kCFCompareEqualTo)
                goto LABEL_79;
            }
          }
        }
        goto LABEL_72;
      }
      switch(ExactString)
      {
        case 5316627:
          v28 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 19), a3);
          v29 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, v8);
          if (!v29 || (v30 = CFDictionaryGetValue(v29, &unk_1EDCFE7E0), !v28) || !v30)
          {
            if (!v28)
              break;
LABEL_72:
            if ((ResponseStatusCode != 407 || !*((_BYTE *)this + 160))
              && (ResponseStatusCode != 401 || *((_BYTE *)this + 160)))
            {
              break;
            }
            goto LABEL_76;
          }
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 17), &unk_1EDCFE7E0, v30);
          break;
        case 6324248:
          v31 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 19), a3);
          if (v31)
          {
            v32 = v31;
            v33 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, v8);
            if (v33)
            {
              v34 = (const __CFString *)CFDictionaryGetValue(v33, &unk_1EDCFE7E0);
              if (v34)
              {
                v35 = v34;
                CFGetAllocator((char *)this - 16);
                v36 = (const void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", v35, 0);
                v37 = (const void *)v32[1];
                if (v37)
                {
                  CFRelease(v37);
                  v32[1] = 0;
                }
                if (*v32)
                {
                  cf = 0;
                  ClientResponse = _NtlmCreateClientResponse();
                  NtlmGeneratorRelease();
                  *v32 = 0;
                  if (ClientResponse)
                  {
                    *((_QWORD *)this + 11) = 2;
                    *((_DWORD *)this + 24) = ClientResponse;
                    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
                    if (cf)
                      CFRelease(cf);
                    if (!v36)
                      break;
                    v39 = v36;
LABEL_47:
                    CFRelease(v39);
                    break;
                  }
                  if (cf)
                  {
                    v50 = (const void *)v32[2];
                    if (v50)
                      CFRelease(v50);
                    CFGetAllocator((char *)this - 16);
                    v32[2] = (id)objc_msgSend((id)cf, "base64EncodedStringWithOptions:", 0);
                    CFRelease(cf);
                  }
                }
                CFRelease(v36);
                v51 = (const void *)v32[1];
                if (v51)
                {
                  CFRelease(v51);
                  v32[1] = 0;
                }
                v32[1] = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v35);
                break;
              }
            }
            if ((ResponseStatusCode != 407 || !*((_BYTE *)this + 160))
              && (ResponseStatusCode != 401 || *((_BYTE *)this + 160))
              || *v32)
            {
              break;
            }
            if (v32[2])
            {
LABEL_76:
              *((_QWORD *)this + 11) = 4;
              v21 = -1001;
              goto LABEL_77;
            }
            v42 = (const void *)v32[1];
            if (v42)
            {
              cf = 0;
              CFRelease(v42);
              v32[1] = 0;
              ClientRequest = NtlmGeneratorCreate();
              if (ClientRequest || (ClientRequest = NtlmCreateClientRequest()) != 0)
              {
                *((_QWORD *)this + 11) = 2;
                *((_DWORD *)this + 24) = ClientRequest;
LABEL_78:
                CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
                break;
              }
              CFGetAllocator((char *)this - 16);
              v32[2] = (id)objc_msgSend((id)cf, "base64EncodedStringWithOptions:", 0);
              v39 = cf;
              goto LABEL_47;
            }
          }
          break;
        case 9601061:
          goto LABEL_72;
        default:
          goto LABEL_48;
      }
LABEL_79:
      CFRelease(Mutable);
      CFRelease(v18);
      CFRelease(v11);
      return pthread_mutex_unlock(v6);
    }
    if (*((_BYTE *)this + 160) && ResponseStatusCode == 407 || !*((_BYTE *)this + 160) && ResponseStatusCode == 401)
    {
      *((_QWORD *)this + 11) = 4;
      *((_DWORD *)this + 24) = -1001;
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
    }
    else if (v8 == CFSTR("NTLM"))
    {
      v40 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 19), a3);
      if (v40)
      {
        if (!*v40 && !v40[1])
        {
          v41 = v40[2];
          if (v41)
          {
            v40[1] = v41;
            v40[2] = 0;
          }
        }
      }
    }
  }
  return pthread_mutex_unlock(v6);
}

void sub_184084744(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

const __CFDictionary *HTTPAuthentication::isKerberosThePreferredAuthScheme(const __CFDictionary *this)
{
  if (this)
  {
    this = (const __CFDictionary *)CFDictionaryGetValue(this, CFSTR("kCFHTTPAuthenticationPropertyMethod"));
    if (this)
      return (const __CFDictionary *)(CFStringCompare((CFStringRef)this, CFSTR("Negotiate"), 1uLL) == kCFCompareEqualTo);
  }
  return this;
}

void HTTPAuthentication::buildProtectionSpacesFromAuthSchemes(CFArrayRef *a1, uint64_t a2, const __CFString *a3, int a4, int a5, const __CFString *a6)
{
  const __CFAllocator *v11;
  const __CFArray *v12;
  const __CFArray *MutableCopy;
  uint64_t Count;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const __CFString *v17;
  int v18;
  const void *v19;
  const __CFArray *cf;
  __CFArray *theArray;
  CFRange v23;

  *a1 = 0;
  if (a2)
  {
    if (a3)
    {
      if (a6)
      {
        v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        if (theArray)
        {
          if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
            dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
          v12 = (const __CFArray *)HTTPAuthentication::copyServerSupportedSchemes((HTTPAuthentication *)(a2 + 16));
          if (v12)
          {
            cf = v12;
            MutableCopy = CFArrayCreateMutableCopy(v11, 0, v12);
            Count = CFArrayGetCount(MutableCopy);
            v23.location = 0;
            v23.length = Count;
            CFArraySortValues(MutableCopy, v23, (CFComparatorFunction)sortArrayBySecurityStrength, 0);
            if (Count >= 1)
            {
              for (i = 0; i != Count; ++i)
              {
                ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, i);
                v18 = URLProtectionSpace::protSpaceAuthSchemeForCFStringRef(ValueAtIndex, v17);
                if (v18 == 12)
                {
                  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
                    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
                  if (*(_BYTE *)(a2 + 241))
                    v18 = 12;
                  else
                    v18 = 1;
                }
                v19 = (const void *)CFURLProtectionSpaceCreate((uint64_t)v11, a3, a4, a5, a6, v18);
                if (v19)
                {
                  CFArrayAppendValue(theArray, v19);
                  CFRelease(v19);
                }
              }
            }
            if (MutableCopy)
              CFRelease(MutableCopy);
            CFRelease(cf);
          }
          if (CFArrayGetCount(theArray) >= 1)
            *a1 = CFArrayCreateCopy(v11, theArray);
          CFRelease(theArray);
        }
      }
    }
  }
}

void sub_1840849AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef a10, _QWORD *a11, CFTypeRef cf)
{
  CFRelease(cf);
  *a11 = 0;
  _Unwind_Resume(a1);
}

uint64_t sortArrayBySecurityStrength(const __CFString *a1, const __CFString *a2, void *a3)
{
  int v4;
  const __CFString *v5;
  int v6;

  v4 = URLProtectionSpace::protSpaceAuthSchemeForCFStringRef(a1, a2);
  v6 = URLProtectionSpace::protSpaceAuthSchemeForCFStringRef(a2, v5);
  if (v4 == v6)
    return 0;
  if (v4 == 11)
    return 1;
  if (v6 == 11 || v4 == 6)
    return -1;
  if (v4 == 2 || v6 == 6)
    return 1;
  if (v6 == 2 || v4 == 5 && v6 == 3)
    return -1;
  return v6 == 5 && v4 == 3;
}

CFMutableDictionaryRef ___ZN23HTTPProxyAuthenticationL17GetProxyAuthCacheEv_block_invoke()
{
  _QWORD *v0;
  const __CFAllocator *v1;
  CFMutableDictionaryRef result;

  v0 = (_QWORD *)operator new();
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *v0 = &off_1E14EA388;
  result = CFDictionaryCreateMutable(v1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v0[1] = result;
  HTTPProxyAuthentication::GetProxyAuthCache(void)::ProxyAuthCache = (uint64_t)v0;
  return result;
}

void sub_184084B20(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t RetainableTypedDict<__CFString const* const,_CFHTTPAuthentication *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA388;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<__CFString const* const,_CFHTTPAuthentication *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA388;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void HTTPProxyAuthentication::SetCachedProxyAuth(HTTPProxyAuthentication *this, const __CFString *a2, _CFHTTPAuthentication *a3)
{
  os_unfair_lock_lock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
  if (a2)
  {
    if (HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken != -1)
      dispatch_once(&HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken, &__block_literal_global_61);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(HTTPProxyAuthentication::GetProxyAuthCache(void)::ProxyAuthCache + 8), this, a2);
  }
  else
  {
    if (HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken != -1)
      dispatch_once(&HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken, &__block_literal_global_61);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(HTTPProxyAuthentication::GetProxyAuthCache(void)::ProxyAuthCache + 8), this);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
}

void sub_184084C68(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
  _Unwind_Resume(a1);
}

void proxyProtectionSpaceFromAuthentication(_CFHTTPAuthentication *a1, const __CFURL *a2, const __CFURL *a3)
{
  const __CFString *v6;
  CFStringRef v7;
  HTTPAuthentication *v8;
  const __CFString *v9;
  SInt32 v10;
  const __CFArray *v11;
  const void *ValueAtIndex;
  CFArrayRef theArray;

  *(_QWORD *)a1 = 0;
  v6 = CFURLCopyHostName(a3);
  v7 = CFURLCopyScheme(a3);
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (a2)
    v8 = (const __CFURL *)((char *)a2 + 16);
  else
    v8 = 0;
  v9 = (const __CFString *)HTTPAuthentication::copyRealm(v8);
  v10 = CFURLGetPortNumber(a3);
  HTTPAuthentication::buildProtectionSpacesFromAuthSchemes(&theArray, (uint64_t)a2, v6, v10, 6, v9);
  v11 = theArray;
  if (theArray)
    CFArrayGetCount(theArray);
  ValueAtIndex = CFArrayGetValueAtIndex(v11, 0);
  if (ValueAtIndex)
    *(_QWORD *)a1 = CFRetain(ValueAtIndex);
  if (v11)
    CFRelease(v11);
  if (v9)
    CFRelease(v9);
  if (v7)
    CFRelease(v7);
  if (v6)
    CFRelease(v6);
}

void sub_184084DA4(_Unwind_Exception *exception_object)
{
  const void *v1;
  _QWORD *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  if (v5)
  {
    CFRelease(v5);
    if (!v4)
    {
LABEL_3:
      if (!v3)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else if (!v4)
  {
    goto LABEL_3;
  }
  CFRelease(v4);
  if (!v3)
  {
LABEL_4:
    if (!v1)
    {
LABEL_10:
      *v2 = 0;
      _Unwind_Resume(exception_object);
    }
LABEL_9:
    CFRelease(v1);
    goto LABEL_10;
  }
LABEL_8:
  CFRelease(v3);
  if (!v1)
    goto LABEL_10;
  goto LABEL_9;
}

__n128 __Block_byref_object_copy__8048(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__8049(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorEU13block_pointerFvP22NetworkProxyCredentialP33NetworkProxyAuthorizationElementsU13block_pointerFvSE_EE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

void HTTPProxyAuthentication::SetCachedProxyCred(const void *a1, const void *a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
  if (a2)
  {
    if (HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken != -1)
      dispatch_once(&HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken, &__block_literal_global_67);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(HTTPProxyAuthentication::GetProxyCredCache(void)::ProxyCredCache + 8), a1, a2);
  }
  else
  {
    if (HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken != -1)
      dispatch_once(&HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken, &__block_literal_global_67);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(HTTPProxyAuthentication::GetProxyCredCache(void)::ProxyCredCache + 8), a1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
}

void sub_184084F00(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
  _Unwind_Resume(a1);
}

uint64_t ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorEU13block_pointerFvP22NetworkProxyCredentialP33NetworkProxyAuthorizationElementsU13block_pointerFvSE_EE_block_invoke_57(uint64_t a1, _QWORD *a2)
{
  NSObject *v4;
  const void *v5;
  uint64_t v6;
  uint64_t Username;
  const _CFURLCredential *v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  CFTypeRef v12;
  _QWORD *v13;
  __int128 v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  NSObject *v19;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  CFStreamError v24;
  _QWORD v25[2];
  _QWORD v26[2];
  _BYTE buf[12];
  __int16 v28;
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v21 = *(_QWORD *)(a1 + 48);
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = v21;
    v28 = 2048;
    v29 = a2;
    _os_log_debug_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEBUG, "UUID %@ fetched proxy cred %p", buf, 0x16u);
    if (!a2)
      goto LABEL_23;
  }
  else if (!a2)
  {
    goto LABEL_23;
  }
  proxyProtectionSpaceFromAuthentication((_CFHTTPAuthentication *)buf, *(const __CFURL **)(a1 + 64), *(const __CFURL **)(a1 + 80));
  v5 = *(const void **)buf;
  HTTPProxyAuthentication::SetCachedProxyCred(*(const void **)buf, a2);
  v6 = a2[4];
  Username = CFURLCredentialGetUsername(v6);
  v9 = URLCredential_PasswordBased::safelyCast(v6, v8);
  if (v9)
  {
    v10 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 128))(v9);
    if (Username)
    {
LABEL_7:
      if (!v10)
        goto LABEL_21;
      v25[0] = CFSTR("kCFHTTPAuthenticationUsername");
      v25[1] = CFSTR("kCFHTTPAuthenticationPassword");
      v26[0] = Username;
      v26[1] = v10;
      v11 = (const void *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v26, v25, 2);
      if (v11)
        v12 = CFRetain(v11);
      else
        v12 = 0;
      v13 = (_QWORD *)operator new();
      *v13 = &off_1E14F1A58;
      v13[1] = 0;
      v13[2] = 0;
      v13[3] = v12;
      *(_QWORD *)&v14 = v12;
      *((_QWORD *)&v14 + 1) = v13;
      v15 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v16 = *(std::__shared_weak_count **)(v15 + 56);
      *(_OWORD *)(v15 + 48) = v14;
      if (v16)
      {
        p_shared_owners = (unint64_t *)&v16->__shared_owners_;
        do
          v18 = __ldaxr(p_shared_owners);
        while (__stlxr(v18 - 1, p_shared_owners));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v5 = *(const void **)buf;
      goto LABEL_20;
    }
  }
  else
  {
    v10 = 0;
    if (Username)
      goto LABEL_7;
  }
  if (v10)
LABEL_20:
    CFRelease(v10);
LABEL_21:
  *(_QWORD *)buf = 0;
  if (v5)
    CFRelease(v5);
LABEL_23:
  v24.domain = 0;
  *(_QWORD *)&v24.error = 0;
  if (CFHTTPMessageApplyCredentialDictionary(*(CFHTTPMessageRef *)(a1 + 88), *(CFHTTPAuthenticationRef *)(a1 + 64), *(CFDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48), &v24))
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v19 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v22 = *(_QWORD *)(a1 + 88);
      v23 = *(_QWORD **)(a1 + 96);
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v22;
      v28 = 2048;
      v29 = v23;
      _os_log_debug_impl(&dword_183ECA000, v19, OS_LOG_TYPE_DEBUG, "Applied proxy credentials dictionary to request %@ handle %p", buf, 0x16u);
    }
    _CFHTTPAuthenticationApplyHeaderToRequest(*(_CFHTTPAuthentication **)(a1 + 64), *(__CFHTTPMessage **)(a1 + 88), *(const void **)(a1 + 96));
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_184085208(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_48c39_ZTSNSt3__110shared_ptrIK10__CFStringEE64c49_ZTSNSt3__110shared_ptrI21_CFHTTPAuthenticationEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[9];
  result[8] = a2[8];
  result[9] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_48c39_ZTSNSt3__110shared_ptrIK10__CFStringEE64c49_ZTSNSt3__110shared_ptrI21_CFHTTPAuthenticationEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 48;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

CFMutableDictionaryRef ___ZN23HTTPProxyAuthenticationL17GetProxyCredCacheEv_block_invoke()
{
  _QWORD *v0;
  const __CFAllocator *v1;
  CFMutableDictionaryRef result;

  v0 = (_QWORD *)operator new();
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *v0 = &off_1E14EA368;
  result = CFDictionaryCreateMutable(v1, 0, MEMORY[0x1E0C9B390], &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
  v0[1] = result;
  HTTPProxyAuthentication::GetProxyCredCache(void)::ProxyCredCache = (uint64_t)v0;
  return result;
}

void sub_184085320(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t RetainableTypedDict<_CFURLProtectionSpace * const,NetworkProxyCredential *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA368;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<_CFURLProtectionSpace * const,NetworkProxyCredential *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA368;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<_CFHTTPAuthentication *,Deleter_CFRelease,std::allocator<_CFHTTPAuthentication>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<_CFHTTPAuthentication *,Deleter_CFRelease,std::allocator<_CFHTTPAuthentication>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorE_block_invoke(uint64_t a1, uint64_t a2, void (**a3)(_QWORD, _QWORD))
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;

  if (a1)
  {
    a3[2](a3, a1);
  }
  else
  {
    SmartBlockWithArgs<NetworkProxyCredential *>::SmartBlockWithArgs(&v7, a3);
    AuthBrokerAgentClient::FetchProxyCredentials(a2, &v7);
    v4 = v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_18408548C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

AuthStringUtils *AuthStringUtils::SkipLWS(AuthStringUtils *this, const unsigned __int8 *a2)
{
  AuthStringUtils *v2;
  int v3;
  int v4;

  v2 = this;
  v3 = *(unsigned __int8 *)this;
  if (*(_BYTE *)this)
  {
    do
    {
      if (!memchr(" \t\r\n", v3, 5uLL))
        break;
      v4 = *((unsigned __int8 *)v2 + 1);
      v2 = (AuthStringUtils *)((char *)v2 + 1);
      v3 = v4;
    }
    while (v4);
  }
  return v2;
}

AuthStringUtils *AuthStringUtils::SkipToLWS(AuthStringUtils *this, const unsigned __int8 *a2)
{
  AuthStringUtils *v2;
  int v3;
  int v4;

  v2 = this;
  v3 = *(unsigned __int8 *)this;
  if (*(_BYTE *)this)
  {
    do
    {
      if (memchr(" \t\r\n", v3, 5uLL))
        break;
      v4 = *((unsigned __int8 *)v2 + 1);
      v2 = (AuthStringUtils *)((char *)v2 + 1);
      v3 = v4;
    }
    while (v4);
  }
  return v2;
}

CFTypeRef AuthStringUtils::_CFStringQuote(const __CFString *this, const __CFString *a2)
{
  CFIndex Length;
  uint64_t v4;
  const __CFAllocator *v5;
  UniChar *v6;
  UniChar *v7;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v10;
  int64_t v11;
  int64_t v12;
  CFIndex v13;
  uint64_t v14;
  uint64_t v15;
  int64_t v16;
  UniChar v17;
  uint64_t v19;
  uint64_t v20;
  int64_t v21;
  int64_t v22;
  BOOL v24;
  void *v26;
  void *v27;
  UniChar buffer[64];
  CFStringRef theString;
  const UniChar *v30;
  const char *v31;
  uint64_t v32;
  int64_t v33;
  int64_t v34;
  int64_t v35;
  CFRange v36;

  Length = CFStringGetLength(this);
  if (!Length)
    return CFRetain(this);
  v4 = Length;
  v5 = CFGetAllocator(this);
  v6 = (UniChar *)CFAllocatorAllocate(v5, 4 * v4, 0);
  if (!v6)
    return 0;
  v7 = v6;
  theString = this;
  v32 = 0;
  v33 = v4;
  CharactersPtr = CFStringGetCharactersPtr(this);
  CStringPtr = 0;
  v30 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(this, 0x600u);
  v34 = 0;
  v35 = 0;
  v31 = CStringPtr;
  if (v4 < 1)
    goto LABEL_44;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 64;
  do
  {
    if ((unint64_t)v12 >= 4)
      v15 = 4;
    else
      v15 = v12;
    v16 = v33;
    if (v33 <= v12)
      goto LABEL_42;
    if (v30)
    {
      v17 = v30[v12 + v32];
    }
    else if (v31)
    {
      v17 = v31[v32 + v12];
    }
    else
    {
      if (v35 <= v12 || v11 > v12)
      {
        v19 = v15 + v10;
        v20 = v14 - v15;
        v21 = v12 - v15;
        v22 = v21 + 64;
        if (v21 + 64 >= v33)
          v22 = v33;
        v34 = v21;
        v35 = v22;
        if (v33 >= v20)
          v16 = v20;
        v36.length = v16 + v19;
        v36.location = v21 + v32;
        CFStringGetCharacters(theString, v36, buffer);
        v11 = v34;
      }
      v17 = buffer[v12 - v11];
    }
    if ((unsigned __int16)(v17 - 256) < 0xFF01u)
    {
LABEL_42:
      v26 = 0;
      goto LABEL_47;
    }
    v24 = (unsigned __int16)(v17 - 14) >= 0x12u && v17 >= 9u && (unsigned __int16)(v17 - 11) >= 2u;
    if (!v24 || v17 == 34 || v17 == 127 || v17 == 92)
      v7[v13++] = 92;
    v7[v13++] = v17;
    ++v12;
    --v10;
    ++v14;
  }
  while (v4 != v12);
  if (v13 == v4)
LABEL_44:
    v27 = (void *)CFRetain(this);
  else
    v27 = (void *)CFStringCreateWithCharacters(v5, v7, v13);
  v26 = v27;
LABEL_47:
  CFAllocatorDeallocate(v5, v7);
  return v26;
}

CFTypeRef AuthStringUtils::_CFStringUnquote(const __CFString *this, const __CFString *a2)
{
  CFIndex Length;
  uint64_t v4;
  const __CFAllocator *v5;
  UniChar *v6;
  UniChar *v7;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v10;
  int64_t v11;
  int v12;
  int64_t v13;
  CFIndex v14;
  uint64_t v15;
  uint64_t v16;
  int64_t v17;
  UniChar v18;
  uint64_t v20;
  uint64_t v21;
  int64_t v22;
  int64_t v23;
  void *v24;
  void *v26;
  UniChar v27[64];
  CFStringRef theString;
  const UniChar *v29;
  const char *v30;
  uint64_t v31;
  int64_t v32;
  int64_t v33;
  int64_t v34;
  CFRange v35;

  Length = CFStringGetLength(this);
  if (!Length)
    return CFRetain(this);
  v4 = Length;
  v5 = CFGetAllocator(this);
  v6 = (UniChar *)CFAllocatorAllocate(v5, 2 * v4, 0);
  if (!v6)
    return 0;
  v7 = v6;
  theString = this;
  v31 = 0;
  v32 = v4;
  CharactersPtr = CFStringGetCharactersPtr(this);
  CStringPtr = 0;
  v29 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(this, 0x600u);
  v33 = 0;
  v34 = 0;
  v30 = CStringPtr;
  if (v4 < 1)
  {
LABEL_33:
    v24 = (void *)CFRetain(this);
    goto LABEL_37;
  }
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 64;
  do
  {
    if ((unint64_t)v13 >= 4)
      v16 = 4;
    else
      v16 = v13;
    v17 = v32;
    if (v32 <= v13)
    {
      v18 = 0;
    }
    else
    {
      if (v29)
      {
        v18 = v29[v13 + v31];
      }
      else if (v30)
      {
        v18 = v30[v31 + v13];
      }
      else
      {
        if (v34 <= v13 || v11 > v13)
        {
          v20 = v16 + v10;
          v21 = v15 - v16;
          v22 = v13 - v16;
          v23 = v22 + 64;
          if (v22 + 64 >= v32)
            v23 = v32;
          v33 = v22;
          v34 = v23;
          if (v32 >= v21)
            v17 = v21;
          v35.length = v17 + v20;
          v35.location = v22 + v31;
          CFStringGetCharacters(theString, v35, v27);
          v11 = v33;
        }
        v18 = v27[v13 - v11];
      }
      if (v18 == 92)
      {
        if (!v12)
        {
          v12 = 1;
          goto LABEL_31;
        }
        v18 = 92;
      }
    }
    v12 = 0;
    v7[v14++] = v18;
LABEL_31:
    ++v13;
    --v10;
    ++v15;
  }
  while (v4 != v13);
  if (v14 == v4)
    goto LABEL_33;
  v24 = (void *)CFStringCreateWithCharacters(v5, v7, v14);
LABEL_37:
  v26 = v24;
  CFAllocatorDeallocate(v5, v7);
  return v26;
}

CFTypeRef AuthStringUtils::_canonicalSchemeName(const __CFString *this, const __CFString *a2)
{
  __CFString *v3;

  v3 = CFSTR("Negotiate");
  if (CFStringCompare(this, CFSTR("Negotiate"), 1uLL))
  {
    v3 = CFSTR("NTLM");
    if (CFStringCompare(this, CFSTR("NTLM"), 1uLL))
    {
      v3 = (__CFString *)gConstantCFStringValueTable;
      if (CFStringCompare(this, (CFStringRef)gConstantCFStringValueTable, 1uLL))
      {
        v3 = CFSTR("Digest");
        if (CFStringCompare(this, CFSTR("Digest"), 1uLL))
        {
          v3 = CFSTR("Nego2");
          if (CFStringCompare(this, CFSTR("Nego2"), 1uLL))
          {
            v3 = (__CFString *)&unk_1EDCF9220;
            if (CFStringCompare(this, (CFStringRef)&unk_1EDCF9220, 1uLL))
            {
              v3 = CFSTR("OAuth");
              if (CFStringCompare(this, CFSTR("OAuth"), 1uLL))
              {
                v3 = CFSTR("PrivateToken");
                if (CFStringCompare(this, CFSTR("PrivateToken"), 1uLL))
                {
                  v3 = (__CFString *)(gConstantCFStringValueTable + 56);
                  if (CFStringCompare(this, (CFStringRef)&gConstantCFStringValueTable[7], 1uLL))
                    v3 = (__CFString *)this;
                }
              }
            }
          }
        }
      }
    }
  }
  if (v3)
    return CFRetain(v3);
  else
    return 0;
}

void AuthStringUtils::downLevelLogonName(uint64_t a1, CFStringRef theString, uint64_t a3)
{
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v6;
  const void *ValueAtIndex;
  const void *v8;

  if (a1)
  {
    (*(void (**)(uint64_t, uint64_t, CFStringRef))(a3 + 16))(a3, a1, theString);
    return;
  }
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theString, CFSTR("\\"));
  v6 = ArrayBySeparatingStrings;
  if (ArrayBySeparatingStrings && CFArrayGetCount(ArrayBySeparatingStrings) == 2)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v6, 0);
    v8 = CFArrayGetValueAtIndex(v6, 1);
    (*(void (**)(uint64_t, const void *, const void *))(a3 + 16))(a3, ValueAtIndex, v8);
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD, CFStringRef))(a3 + 16))(a3, 0, theString);
    if (!v6)
      return;
  }
  CFRelease(v6);
}

void sub_184085BDC(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

BOOL AuthenticationState::applyToRequest(AuthenticationState *this, HTTPRequestMessage *a2, void *a3, char a4)
{
  BOOL v8;
  _BOOL8 v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  char v14;
  _BYTE v15[24];
  _BYTE *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (this)
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  if (*((_QWORD *)this + 13))
    v8 = 0;
  else
    v8 = *((_QWORD *)this + 16) == 0;
  v9 = 0;
  if (a2 && !v8)
  {
    v14 = 1;
    v10 = operator new(0x28uLL);
    *v10 = &unk_1E14F0438;
    v10[1] = a2;
    v10[2] = a3;
    *((_BYTE *)v10 + 24) = a4;
    v10[4] = &v14;
    v16 = v10;
    AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v15);
    v11 = v16;
    if (v16 == v15)
    {
      v12 = 4;
      v11 = v15;
    }
    else
    {
      if (!v16)
      {
LABEL_13:
        v9 = v14 != 0;
        goto LABEL_14;
      }
      v12 = 5;
    }
    (*(void (**)(void))(*v11 + 8 * v12))();
    goto LABEL_13;
  }
LABEL_14:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return v9;
}

void sub_184085D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v13;
  char *v14;
  char *v16;
  uint64_t v17;

  v16 = a13;
  if (a13 == v14)
  {
    v17 = 4;
    v16 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v16 + 8 * v17))();
LABEL_6:
  pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'AuthenticationState::~AuthenticationState(AuthenticationState *this)
{
  AuthenticationState::~AuthenticationState((AuthenticationState *)((char *)this - 88));
}

{
  AuthenticationState::~AuthenticationState((AuthenticationState *)((char *)this - 88));
  JUMPOUT(0x186DB748CLL);
}

void std::__throw_bad_function_call[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_function_call was thrown in -fno-exceptions mode");
  JUMPOUT(0x184085DE4);
}

void std::__function::__func<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &unk_1E14F0438;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &unk_1E14F0438;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, AuthenticationInfo **a3)
{
  AuthenticationInfo *v5;
  BOOL v6;
  int v7;
  BOOL *v8;
  BOOL v9;

  v5 = *a3;
  if (*((_QWORD *)*a3 + 1))
  {
    if (HTTPAuthentication::isConnectionBasedAuth(*((HTTPAuthentication **)*a3 + 1)))
      v6 = *(_BYTE *)(a1 + 24) == 0;
    else
      v6 = 0;
    if (v6)
      return 1;
    v5 = *a3;
  }
  if (AuthenticationInfo::canApplyHeadersToRequest(v5, *(HTTPRequestMessage **)(a1 + 8)))
  {
    v7 = AuthenticationInfo::applyToRequest(*a3, *(HTTPRequestMessage **)(a1 + 8), *(void **)(a1 + 16));
    v8 = *(BOOL **)(a1 + 32);
    if (v7)
      v9 = *v8;
    else
      v9 = 0;
    *v8 = v9;
  }
  return 1;
}

BOOL AuthenticationInfo::canApplyHeadersToRequest(AuthenticationInfo *this, HTTPRequestMessage *a2)
{
  uint64_t v4;
  CFStringRef v5;
  BOOL v6;
  _BOOL8 result;
  BOOL v8;
  CFStringRef theString1;

  if (!a2)
    return 0;
  v4 = *((_QWORD *)this + 6);
  if (v4)
  {
    AuthenticationInfo::_getChallengeAuthScheme((uint64_t)&theString1, v4);
    v5 = theString1;
    if (theString1)
    {
      v6 = CFStringCompare(theString1, CFSTR("Negotiate"), 0x80uLL) != kCFCompareEqualTo;
      CFRelease(v5);
    }
    else
    {
      v6 = 1;
    }
  }
  else
  {
    v6 = HTTPAuthentication::isKerberosThePreferredAuthScheme(*(const __CFDictionary **)(*((_QWORD *)this + 1) + 136)) == 0;
  }
  result = AuthenticationInfo::isValid(*((_QWORD *)this + 1));
  if ((_DWORD)result)
  {
    if (*((_QWORD *)this + 2))
      v8 = 0;
    else
      v8 = v6;
    if (v8)
      return 0;
    return HTTPAuthentication::appliesToRequest(*((HTTPAuthentication **)this + 1), (HTTPRequestMessage *)((char *)a2 - 16)) != 0;
  }
  return result;
}

void sub_184085FB4(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

unint64_t AuthenticationInfo::applyToRequest(AuthenticationInfo *this, HTTPRequestMessage *a2, void *a3)
{
  unint64_t v4;
  __CFHTTPMessage *v6;
  char *v7;
  const __CFAllocator *v8;
  uint64_t v9;
  const void *Username;
  const _CFURLCredential *v11;
  const __CFString *v12;
  uint64_t v13;
  const void *v14;
  CFNumberRef v15;
  const void *v16;
  const void *v17;
  const __CFAllocator *v18;
  uint64_t v19;
  const __CFDictionary *v20;
  int v21;
  CFTypeRef v22;
  const __CFString *cf;
  int valuePtr;
  _QWORD v26[5];
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  void (*v31)(uint64_t);
  uint64_t v32;
  CFTypeRef Mutable;

  v4 = (unint64_t)a2;
  v27 = 0;
  v28 = &v27;
  v29 = 0x3812000000;
  v30 = __Block_byref_object_copy__8091;
  v31 = __Block_byref_object_dispose__8092;
  v32 = 0;
  v6 = (HTTPRequestMessage *)((char *)a2 - 16);
  if (a2)
    v7 = (char *)a2 - 16;
  else
    v7 = 0;
  v8 = CFGetAllocator(v7);
  Mutable = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v4)
    goto LABEL_39;
  if (!v28[6] || !AuthenticationInfo::canApplyHeadersToRequest(this, (HTTPRequestMessage *)v4))
  {
    v4 = 0;
    goto LABEL_39;
  }
  v9 = *((_QWORD *)this + 2);
  if (v9)
  {
    Username = (const void *)CFURLCredentialGetUsername(v9);
    if (Username && (v12 = (const __CFString *)CFRetain(Username)) != 0)
    {
      cf = v12;
      if (HTTPAuthentication::requiresAccountDomain(*((HTTPAuthentication **)this + 1)))
      {
        v26[0] = MEMORY[0x1E0C809B0];
        v26[1] = 3221225472;
        v26[2] = ___ZN18AuthenticationInfo14applyToRequestEP18HTTPRequestMessagePv_block_invoke;
        v26[3] = &unk_1E14FA198;
        v26[4] = &v27;
        AuthStringUtils::downLevelLogonName(0, cf, (uint64_t)v26);
      }
      else
      {
        CFDictionaryAddValue((CFMutableDictionaryRef)v28[6], CFSTR("kCFHTTPAuthenticationUsername"), cf);
      }
    }
    else
    {
      cf = 0;
    }
    v13 = URLCredential_PasswordBased::safelyCast(*((_QWORD *)this + 2), v11);
    if (v13)
    {
      v14 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 128))(v13);
      if (v14)
        CFDictionaryAddValue((CFMutableDictionaryRef)v28[6], CFSTR("kCFHTTPAuthenticationPassword"), v14);
    }
    else
    {
      v14 = 0;
    }
    v17 = (const void *)_CFURLCredentialCopyOAuthToken(*((const _CFURLCredential **)this + 2));
    if (v17)
      CFDictionaryAddValue((CFMutableDictionaryRef)v28[6], CFSTR("kCFHTTPAuthenticationOAuthToken"), v17);
    v16 = (const void *)_CFURLCredentialCopyOAuth1Account(*((const _CFURLCredential **)this + 2));
    if (v16)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)v28[6], CFSTR("kCFHTTPAuthenticationOAuth1Account"), v16);
      valuePtr = 0;
      valuePtr = _CFURLCredentialGetOAuth1PID(*((const _CFURLCredential **)this + 2));
      v18 = CFGetAllocator((CFTypeRef)v28[6]);
      v15 = CFNumberCreate(v18, kCFNumberSInt32Type, &valuePtr);
      if (v15)
        CFDictionaryAddValue((CFMutableDictionaryRef)v28[6], CFSTR("kCFHTTPAuthenticationOAuth1PID"), v15);
    }
    else
    {
      v15 = 0;
    }
    v19 = *((_QWORD *)this + 1);
    v20 = (const __CFDictionary *)v28[6];
    pthread_mutex_lock((pthread_mutex_t *)(v19 + 16));
    HTTPAuthentication::applyCredentials_Locked((CFMutableDictionaryRef *)v19, v6, v20, 0);
    LODWORD(v20) = v21;
    pthread_mutex_unlock((pthread_mutex_t *)(v19 + 16));
    v4 = (_DWORD)v20 != 0;
    if (!a3)
      goto LABEL_29;
    goto LABEL_27;
  }
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v14 = 0;
  cf = 0;
  v4 = 1;
  if (a3)
  {
LABEL_27:
    if ((_DWORD)v4)
      HTTPAuthentication::applyHeaderToRequest(*((CFDictionaryRef **)this + 1), v6, a3);
  }
LABEL_29:
  if (v15)
    CFRelease(v15);
  if (v16)
    CFRelease(v16);
  if (v17)
    CFRelease(v17);
  if (v14)
    CFRelease(v14);
  if (cf)
    CFRelease(cf);
LABEL_39:
  _Block_object_dispose(&v27, 8);
  v22 = Mutable;
  Mutable = 0;
  if (v22)
    CFRelease(v22);
  return v4;
}

void sub_184086338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,CFTypeRef a22)
{
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  CFTypeRef v27;

  if (v25)
  {
    CFRelease(v25);
    if (!v24)
    {
LABEL_3:
      if (!v23)
        goto LABEL_4;
      goto LABEL_13;
    }
  }
  else if (!v24)
  {
    goto LABEL_3;
  }
  CFRelease(v24);
  if (!v23)
  {
LABEL_4:
    if (!v22)
      goto LABEL_6;
    goto LABEL_5;
  }
LABEL_13:
  CFRelease(v23);
  if (!v22)
  {
LABEL_6:
    if (cf)
      CFRelease(cf);
    _Block_object_dispose(&a16, 8);
    v27 = a22;
    a22 = 0;
    if (v27)
      CFRelease(v27);
    _Unwind_Resume(a1);
  }
LABEL_5:
  CFRelease(v22);
  goto LABEL_6;
}

uint64_t __Block_byref_object_copy__8091(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__8092(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  if (v2)
    CFRelease(v2);
}

void ___ZN18AuthenticationInfo14applyToRequestEP18HTTPRequestMessagePv_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), CFSTR("kCFHTTPAuthenticationUsername"), a3);
  if (a2)
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), CFSTR("kCFHTTPAuthenticationAccountDomain"), a2);
}

uint64_t AuthenticationInfo::_getChallengeAuthScheme(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  *(_QWORD *)this = 0;
  if (a2)
  {
    v2 = *(_QWORD *)(a2 + 24);
    if (v2)
    {
      v3 = (_QWORD *)this;
      if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
        dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
      this = *(unsigned int *)(v2 + 72);
      if ((_DWORD)this)
      {
        this = URLProtectionSpace::stringForProtSpaceAuthScheme(this);
        if (this)
          this = (uint64_t)CFRetain((CFTypeRef)this);
        *v3 = this;
      }
    }
  }
  return this;
}

void sub_1840864DC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(a1);
}

BOOL AuthenticationInfo::isValid(_BOOL8 this)
{
  uint64_t v1;
  pthread_mutex_t *v2;

  if (this)
  {
    v1 = this;
    v2 = (pthread_mutex_t *)(this + 16);
    pthread_mutex_lock((pthread_mutex_t *)(this + 16));
    LODWORD(v1) = *(_DWORD *)(v1 + 96);
    pthread_mutex_unlock(v2);
    return (_DWORD)v1 == 0;
  }
  return this;
}

void AuthenticationInfo::_getCredentialUserPrincipal(AuthenticationInfo *this, uint64_t a2)
{
  CFTypeRef v4;

  *(_QWORD *)this = 0;
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    if (*(_DWORD *)(a2 + 48) == 2)
    {
      v4 = (CFTypeRef)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(a2 + 16) + 128))(a2 + 16);
      if (v4)
        v4 = CFRetain(v4);
      *(_QWORD *)this = v4;
    }
  }
}

void sub_18408659C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(a1);
}

void AuthenticationInfo::_getCredentialServicePrincipal(AuthenticationInfo *this, uint64_t a2)
{
  CFTypeRef v4;

  *(_QWORD *)this = 0;
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    if (*(_DWORD *)(a2 + 48) == 2)
    {
      v4 = (CFTypeRef)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(a2 + 16) + 136))(a2 + 16);
      if (v4)
        v4 = CFRetain(v4);
      *(_QWORD *)this = v4;
    }
  }
}

void sub_18408661C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(a1);
}

void AuthenticationInfo::_getCredentialUUID(AuthenticationInfo *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  CFTypeRef v6;
  const void *v7;

  *(_QWORD *)this = 0;
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    if (*(_DWORD *)(a2 + 48) == 2)
    {
      v5 = *(_QWORD *)(a2 + 16);
      v4 = a2 + 16;
      v6 = (CFTypeRef)(*(uint64_t (**)(uint64_t))(v5 + 144))(v4);
      if (v6)
      {
        v7 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 144))(v4);
        v6 = CFRetain(v7);
      }
      *(_QWORD *)this = v6;
    }
  }
}

void sub_1840866AC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(a1);
}

CFIndex AuthenticationInfo::updateCredentialStatus(CFIndex this, HTTPResponseMessage *a2)
{
  uint64_t v2;
  int v3;

  v2 = this;
  if (a2
    && ((this = CFHTTPMessageGetResponseStatusCode((HTTPResponseMessage *)((char *)a2 - 16)), this == 407) || this == 401))
  {
    if (*(_DWORD *)(v2 + 24) == 2)
      v3 = 3;
    else
      v3 = 4;
  }
  else
  {
    v3 = 2;
  }
  *(_DWORD *)(v2 + 24) = v3;
  return this;
}

void std::__shared_ptr_emplace<AuthenticationInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0C20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AuthenticationInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0C20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

_QWORD *std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E14F0630;
  return result;
}

void std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E14F0630;
}

uint64_t std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  if (v3 && *(_BYTE *)(v3 + 224))
  {
    *(_QWORD *)(*(_QWORD *)a3 + 8) = 0;
    CFRelease((CFTypeRef)(v3 - 16));
  }
  return 1;
}

void std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

_BYTE *std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_1E14F05E8;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_1E14F05E8;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

uint64_t std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  if (v3)
    *(_BYTE *)(v3 + 161) = *(_BYTE *)(a1 + 8);
  return 1;
}

uint64_t AuthenticationState::setConnectionType(uint64_t a1, int a2)
{
  if (a1)
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  *(_DWORD *)(*(_QWORD *)(a1 + 144) + 12) = a2;
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
}

BOOL AuthenticationState::updateState(AuthenticationState *this, HTTPResponseMessage *a2, unint64_t a3, const _CFURLCredential *a4, __SecTrust *a5)
{
  _BOOL8 v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  CFTypeRef v17;
  const void *v18;
  CFTypeRef v19;
  const void *v20;
  const __CFString *v21;
  _BOOL4 v22;
  uint64_t v23;
  __CFHTTPMessage *v24;
  uint64_t v25;
  HTTPAuthentication *v26;
  const __CFString *v27;
  uint64_t v28;
  HTTPAuthentication *v29;
  const __CFString *v30;
  HTTPAuthentication *v31;
  const void *v32;
  const __CFUUID *v33;
  HTTPAuthentication *v34;
  const void *v35;
  const __CFUUID *v36;
  const void *v37;
  const __CFString *v38;
  __CFString *v39;
  const __CFUUID *v40;
  const void *v41;
  const __CFString *v42;
  __CFString *v43;
  const __CFUUID *v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  uint64_t v49;
  std::__shared_weak_count *v50;
  __CFString *v51;
  const __CFString *v52;
  unsigned int v53[2];
  CFStringRef theString1;

  if (this)
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v10 = ((unint64_t)a2 | a3) == 0;
  if (!((unint64_t)a2 | a3))
    goto LABEL_25;
  if (a3)
  {
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
    v11 = *(_QWORD *)(a3 + 40);
    if (v11)
    {
      if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
        dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
      v12 = (*(_DWORD *)(v11 + 60) - 5) >= 4 ? 1 : 2;
    }
    else
    {
      v12 = 1;
    }
  }
  else
  {
    v12 = AuthenticationState::_isLikelyForProxy(this, a2) ? 2 : 1;
  }
  if (!AuthenticationState::_haveAuthenticationInfo((uint64_t)this, v12))
  {
LABEL_25:
    if (!this)
      return v10;
    goto LABEL_91;
  }
  AuthenticationState::_authForType(&v49, (uint64_t)this, v12);
  v13 = v49;
  if (*(_QWORD *)(v49 + 8) && *(_QWORD *)(v49 + 32))
  {
    if (a3 && (v14 = (char *)CFRetain((CFTypeRef)a3)) != 0)
    {
      if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
        dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
      v15 = v14 + 16;
    }
    else
    {
      v15 = 0;
    }
    v16 = *(_QWORD *)(v13 + 48);
    *(_QWORD *)(v13 + 48) = v15;
    if (v16)
      CFRelease((CFTypeRef)(v16 - 16));
    if (a4)
      v17 = CFRetain(a4);
    else
      v17 = 0;
    v18 = *(const void **)(v13 + 16);
    *(_QWORD *)(v13 + 16) = v17;
    if (v18)
      CFRelease(v18);
    if (a5)
      v19 = CFRetain(a5);
    else
      v19 = 0;
    v20 = *(const void **)(v13 + 56);
    *(_QWORD *)(v13 + 56) = v19;
    if (v20)
      CFRelease(v20);
    *(_DWORD *)(v13 + 24) = 1;
    AuthenticationInfo::_getChallengeAuthScheme((uint64_t)&theString1, *(_QWORD *)(v13 + 48));
    v21 = theString1;
    if (theString1)
      v22 = CFStringCompare(theString1, CFSTR("Negotiate"), 0x80uLL) == kCFCompareEqualTo;
    else
      v22 = 0;
    v23 = *(_QWORD *)(v13 + 32);
    if (v23)
      v24 = (__CFHTTPMessage *)(v23 - 16);
    else
      v24 = 0;
    if (!v21 || !*(_QWORD *)(v13 + 48))
    {
      v28 = *(_QWORD *)(v13 + 16);
      if (v28)
      {
        v29 = *(HTTPAuthentication **)(v13 + 8);
        if (URLCredential::Class(void)::sOnce_URLCredential != -1)
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
        if (*(_DWORD *)(v28 + 48) == 2)
          v30 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(v28 + 16) + 120))(v28 + 16);
        else
          v30 = 0;
        AuthenticationInfo::_getCredentialUserPrincipal((AuthenticationInfo *)v53, *(_QWORD *)(v13 + 16));
        v41 = *(const void **)v53;
        AuthenticationInfo::_getCredentialServicePrincipal((AuthenticationInfo *)&v52, *(_QWORD *)(v13 + 16));
        v42 = v52;
        AuthenticationInfo::_getCredentialUUID((AuthenticationInfo *)&v51, *(_QWORD *)(v13 + 16));
        v43 = v51;
        HTTPAuthentication::_initialize(v29, v24, v30, v41, v42, v51, v44);
        if (v43)
          CFRelease(v43);
        if (v42)
          CFRelease(v42);
        if (v41)
          CFRelease(v41);
        HTTPAuthentication::initializeSchemes(*(HTTPAuthentication **)(v13 + 8), v24, 0);
      }
      if (!v21)
        goto LABEL_85;
      goto LABEL_84;
    }
    if (v22)
    {
      v26 = *(HTTPAuthentication **)(v13 + 8);
      v25 = *(_QWORD *)(v13 + 16);
      if (!v25)
        goto LABEL_67;
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      if (*(_DWORD *)(v25 + 48) == 2)
        v27 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(v25 + 16) + 120))(v25 + 16);
      else
LABEL_67:
        v27 = 0;
      AuthenticationInfo::_getCredentialUserPrincipal((AuthenticationInfo *)v53, *(_QWORD *)(v13 + 16));
      v32 = *(const void **)v53;
      AuthenticationInfo::_getCredentialServicePrincipal((AuthenticationInfo *)&v52, *(_QWORD *)(v13 + 16));
      v38 = v52;
      AuthenticationInfo::_getCredentialUUID((AuthenticationInfo *)&v51, *(_QWORD *)(v13 + 16));
      v39 = v51;
      HTTPAuthentication::_initialize(v26, v24, v27, v32, v38, v51, v40);
      if (v39)
        CFRelease(v39);
      if (v38)
        CFRelease(v38);
    }
    else
    {
      if (CFStringCompare(v21, CFSTR("X-MobileMe-AuthToken"), 1uLL) == kCFCompareEqualTo
        || CFStringCompare(v21, CFSTR("OAuth"), 1uLL) == kCFCompareEqualTo
        || CFStringCompare(v21, (CFStringRef)&gConstantCFStringValueTable[7], 1uLL) == kCFCompareEqualTo)
      {
        v34 = *(HTTPAuthentication **)(v13 + 8);
        AuthenticationInfo::_getCredentialUserName(v53, *(const _CFURLCredential **)(v13 + 16));
        v35 = *(const void **)v53;
        HTTPAuthentication::_initialize(v34, v24, 0, *(const void **)v53, 0, 0, v36);
        if (v35)
          CFRelease(v35);
        v37 = *(const void **)(v13 + 56);
        if (v37)
          HTTPAuthentication::setSecTrust(*(HTTPAuthentication **)(v13 + 8), v37);
        goto LABEL_74;
      }
      v31 = *(HTTPAuthentication **)(v13 + 8);
      AuthenticationInfo::_getCredentialUserName(v53, *(const _CFURLCredential **)(v13 + 16));
      v32 = *(const void **)v53;
      HTTPAuthentication::_initialize(v31, v24, 0, *(const void **)v53, 0, 0, v33);
    }
    if (v32)
      CFRelease(v32);
LABEL_74:
    HTTPAuthentication::initializeSchemes(*(HTTPAuthentication **)(v13 + 8), v24, v21);
LABEL_84:
    CFRelease(v21);
  }
LABEL_85:
  v45 = v50;
  if (v50)
  {
    p_shared_owners = (unint64_t *)&v50->__shared_owners_;
    do
      v47 = __ldaxr(p_shared_owners);
    while (__stlxr(v47 - 1, p_shared_owners));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  v10 = 1;
LABEL_91:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return v10;
}

void sub_184086DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  const void *v10;
  const void *v11;

  if (v11)
    CFRelease(v11);
  CFRelease(v10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
  _Unwind_Resume(a1);
}

_QWORD *AuthenticationInfo::_getCredentialUserName(_QWORD *this, const _CFURLCredential *a2)
{
  _QWORD *v2;

  *this = 0;
  if (a2)
  {
    v2 = this;
    this = (_QWORD *)URLCredential_PasswordBased::safelyCast((uint64_t)a2, a2);
    if (this)
    {
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 112))(this);
      if (this)
        this = CFRetain(this);
      *v2 = this;
    }
  }
  return this;
}

void sub_184086F48(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(a1);
}

void AuthenticationState::_removeAuthenticationInfo(uint64_t a1, int a2)
{
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t *v6;
  __int128 v7;

  if (a2 == 1)
  {
    v7 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 104, &v7);
    v3 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
    if (!*((_QWORD *)&v7 + 1))
      return;
    v6 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
    do
      v5 = __ldaxr(v6);
    while (__stlxr(v5 - 1, v6));
    goto LABEL_12;
  }
  if (!a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v7) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "assertion failure", (uint8_t *)&v7, 2u);
  }
  v7 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 128, &v7);
  v3 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
  if (*((_QWORD *)&v7 + 1))
  {
    v4 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
LABEL_12:
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void std::__function::__func<AuthenticationState::resetInvalid(void)::$_0,std::allocator<AuthenticationState::resetInvalid(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<AuthenticationState::resetInvalid(void)::$_0,std::allocator<AuthenticationState::resetInvalid(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E14F03F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::resetInvalid(void)::$_0,std::allocator<AuthenticationState::resetInvalid(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F03F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<AuthenticationState::resetInvalid(void)::$_0,std::allocator<AuthenticationState::resetInvalid(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, uint64_t a3)
{
  int v4;
  uint64_t *v5;
  uint64_t v6;
  _DWORD *v7;

  v4 = *a2;
  if (!AuthenticationInfo::isValid(*(_QWORD *)(*(_QWORD *)a3 + 8)))
  {
    v5 = *(uint64_t **)(a1 + 16);
    v6 = *v5;
    v7 = operator new(0x10uLL);
    *(_QWORD *)v7 = v6;
    v7[2] = v4;
    *v5 = (uint64_t)v7;
  }
  return 1;
}

BOOL AuthenticationState::isValid(uint64_t a1, int a2)
{
  _BOOL8 isValid;

  if (a1)
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  isValid = AuthenticationState::_isValid(a1, a2);
  if (a1)
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
  return isValid;
}

void sub_184087154(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

void std::__function::__func<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0,std::allocator<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0,std::allocator<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E14F05A0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0,std::allocator<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F05A0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0,std::allocator<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BOOL8 result;

  result = AuthenticationInfo::isValid(*(_QWORD *)(*(_QWORD *)a3 + 8));
  **(_BYTE **)(a1 + 16) = result;
  return result;
}

uint64_t AuthenticationState::getEndpointCred(AuthenticationState *this, std::__shared_weak_count *a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  if (a2)
  {
    p_shared_owners = (unint64_t *)&a2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  if (this)
  {
    v5 = *((_QWORD *)this + 2);
    if (!a2)
      return v5;
  }
  else
  {
    v5 = 0;
    if (!a2)
      return v5;
  }
  v6 = (unint64_t *)&a2->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))a2->__on_zero_shared)(a2);
    std::__shared_weak_count::__release_weak(a2);
  }
  return v5;
}

void std::__function::__func<AuthenticationState::isConnectionBased(void)::$_0,std::allocator<AuthenticationState::isConnectionBased(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

_QWORD *std::__function::__func<AuthenticationState::isConnectionBased(void)::$_0,std::allocator<AuthenticationState::isConnectionBased(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E14F04C8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<AuthenticationState::isConnectionBased(void)::$_0,std::allocator<AuthenticationState::isConnectionBased(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E14F04C8;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<AuthenticationState::isConnectionBased(void)::$_0,std::allocator<AuthenticationState::isConnectionBased(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  HTTPAuthentication *v4;
  _BOOL4 v5;

  v4 = *(HTTPAuthentication **)(*(_QWORD *)a3 + 8);
  if (v4)
    v5 = HTTPAuthentication::isConnectionBasedAuth(v4) != 0;
  else
    v5 = 0;
  **(_BYTE **)(a1 + 8) = v5;
  return !v5;
}

uint64_t AuthenticationState::getAuth(AuthenticationState *this, int a2)
{
  int v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v10;
  std::__shared_weak_count *v11;

  if (this)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
    if (a2)
      v4 = 2;
    else
      v4 = 1;
    if (!AuthenticationState::_haveAuthenticationInfo((uint64_t)this, v4))
    {
      v5 = 0;
LABEL_17:
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
      return v5;
    }
  }
  else
  {
    if (a2)
      v4 = 2;
    else
      v4 = 1;
    v5 = 0;
    if (!AuthenticationState::_haveAuthenticationInfo(0, v4))
      return v5;
  }
  AuthenticationState::_authForType(&v10, (uint64_t)this, v4);
  v6 = v11;
  v5 = *(_QWORD *)(v10 + 8);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (this)
    goto LABEL_17;
  return v5;
}

void AuthenticationState::copyDebugSummary(AuthenticationState *this, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  const __CFAllocator *v6;
  CFMutableArrayRef *v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2)
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 8));
  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0A60;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v7 = (CFMutableArrayRef *)&v4[1];
  AutoStringArray::addFormat((CFTypeRef *)&v4[1].__vftable, CFSTR("<AuthenticationState@%p>{"), a2);
  do
    v8 = __ldxr(p_shared_owners);
  while (__stxr(v8 + 1, p_shared_owners));
  v12[0] = &off_1E14F0480;
  v12[1] = v4 + 1;
  v12[2] = v4;
  v13 = v12;
  AuthenticationState::_foreachAuthenticationInfo(a2, (uint64_t)v12);
  v9 = v13;
  if (v13 == v12)
  {
    v10 = 4;
    v9 = v12;
    goto LABEL_9;
  }
  if (v13)
  {
    v10 = 5;
LABEL_9:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  CFArrayAppendValue(*v7, CFSTR("}"));
  *(_QWORD *)this = CFStringCreateByCombiningStrings(v6, *v7, CFSTR(" "));
  do
    v11 = __ldaxr(p_shared_owners);
  while (__stlxr(v11 - 1, p_shared_owners));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  if (a2)
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 8));
}

void sub_1840875B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  uint64_t v17;
  char *v18;
  char *v20;
  uint64_t v21;

  v20 = a17;
  if (a17 == v18)
  {
    v21 = 4;
    v20 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  if (v17)
    pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E14F0480;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 1));
  return a1;
}

void std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E14F0480;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 1));
  JUMPOUT(0x186DB748CLL);
}

_QWORD *std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_1E14F0480;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 16);
  *a2 = &off_1E14F0480;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

uint64_t std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::destroy(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 8);
}

void std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::destroy_deallocate(void *a1)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

uint64_t std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  CFTypeRef *v4;
  uint64_t v5;
  _BOOL4 isValid;
  uint64_t v7;
  int v8;
  HTTPAuthentication *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(CFTypeRef **)(a1 + 8);
  v5 = *a3;
  isValid = AuthenticationInfo::isValid(*(_QWORD *)(*a3 + 8));
  v7 = *a3;
  v8 = *(_DWORD *)(*a3 + 24);
  v9 = *(HTTPAuthentication **)(v7 + 8);
  v10 = 78;
  if (v9)
  {
    if (HTTPAuthentication::isConnectionBasedAuth(v9))
      v10 = 89;
    else
      v10 = 78;
  }
  v11 = 78;
  if (v8 == 2)
    v12 = 89;
  else
    v12 = 78;
  if (isValid)
    v11 = 89;
  AutoStringArray::addFormat(v4, CFSTR("<AuthenticationInfo@%p>{%s - Valid(%c) Authenticated(%c) ConnAuth(%c)}"), v5, "Unknown", v11, v12, v10);
  return 1;
}

void std::__shared_ptr_emplace<AutoStringArray>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0A60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AutoStringArray>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0A60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<AutoStringArray>::__on_zero_shared(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 24));
}

void std::__function::__func<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0,std::allocator<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0,std::allocator<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E14F0558;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0,std::allocator<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F0558;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0,std::allocator<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, AuthenticationInfo **a3)
{
  _BOOL4 canApplyHeadersToRequest;

  canApplyHeadersToRequest = AuthenticationInfo::canApplyHeadersToRequest(*a3, *(HTTPRequestMessage **)(a1 + 8));
  **(_BYTE **)(a1 + 16) = canApplyHeadersToRequest;
  return !canApplyHeadersToRequest;
}

_QWORD *std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E14F02D0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 2));
  return a1;
}

void std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func(_QWORD *a1)
{
  *a1 = &off_1E14F02D0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 2));
  JUMPOUT(0x186DB748CLL);
}

char *std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *result;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  result = (char *)operator new(0x20uLL);
  *(_QWORD *)result = &off_1E14F02D0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 24);
  *((_QWORD *)result + 3) = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

uint64_t std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  *(_QWORD *)a2 = &off_1E14F02D0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 24);
  *(_QWORD *)(a2 + 24) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::destroy(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 16);
}

void std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::destroy_deallocate(void *a1)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 16);
  operator delete(a1);
}

uint64_t std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, uint64_t *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;

  v4 = *a2;
  v5 = *a3;
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 144);
  if (AuthenticationInfo::isValid(*(_QWORD *)(*a3 + 8))
    && !HTTPAuthentication::isConnectionBasedAuth(*(HTTPAuthentication **)(v5 + 8))
    && (!*(_BYTE *)(*(_QWORD *)(v5 + 8) + 160) || *(_DWORD *)(v6 + 12) != 3))
  {
    v8 = operator new();
    *(_QWORD *)v8 = &off_1E14E9138;
    *(_QWORD *)(v8 + 8) = 0;
    *(_QWORD *)(v8 + 16) = 0;
    *(_DWORD *)(v8 + 24) = 0;
    *(_OWORD *)(v8 + 32) = 0u;
    *(_OWORD *)(v8 + 48) = 0u;
    v9 = *(_QWORD *)(v5 + 8);
    CFRetain((CFTypeRef)(v9 - 16));
    v10 = *(_QWORD *)(v8 + 8);
    *(_QWORD *)(v8 + 8) = v9;
    if (v10)
      CFRelease((CFTypeRef)(v10 - 16));
    v11 = *(_QWORD *)(v5 + 16);
    if (v11)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      if (*(_DWORD *)(v11 + 52) != 1)
      {
        v12 = *(CFTypeRef *)(v5 + 16);
        if (v12)
          v12 = CFRetain(v12);
        v13 = *(const void **)(v8 + 16);
        *(_QWORD *)(v8 + 16) = v12;
        if (v13)
          CFRelease(v13);
      }
    }
    v14 = *(_QWORD *)(v5 + 48);
    if (v14)
      CFRetain((CFTypeRef)(v14 - 16));
    v15 = *(_QWORD *)(v8 + 48);
    *(_QWORD *)(v8 + 48) = v14;
    if (v15)
      CFRelease((CFTypeRef)(v15 - 16));
    v16 = *(_QWORD *)(a1 + 16);
    v17 = operator new();
    *(_QWORD *)(v17 + 8) = 0;
    v18 = (unint64_t *)(v17 + 8);
    *(_QWORD *)v17 = &off_1E14F16A0;
    *(_QWORD *)(v17 + 16) = 0;
    *(_QWORD *)(v17 + 24) = v8;
    AuthenticationState::_makeAuth(v16, v4, (char *)v8, (char *)v17);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v17 + 16))(v17);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v17);
    }
  }
  return 1;
}

void sub_184087BDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<AuthenticationInfo  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_pointer<AuthenticationInfo  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

BOOL AuthenticationState::incorporate(AuthenticationState *this, AuthenticationState *a2)
{
  pthread_mutex_t *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL8 v13;
  char v15;
  _BYTE v16[24];
  _BYTE *v17;
  _QWORD v18[3];
  _QWORD *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (this)
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  if (!a2)
    __assert_rtn("incorporate", "AuthenticationHelpers.cpp", 731, "other");
  v15 = 0;
  v4 = (pthread_mutex_t *)((char *)a2 + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 8));
  v18[0] = &off_1E14F0240;
  v18[1] = this;
  v18[2] = &v15;
  v19 = v18;
  AuthenticationState::_foreachAuthenticationInfo((uint64_t)a2, (uint64_t)v18);
  v5 = v19;
  if (v19 == v18)
  {
    v6 = 4;
    v5 = v18;
  }
  else
  {
    if (!v19)
      goto LABEL_9;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_9:
  v17 = 0;
  v7 = operator new(0x20uLL);
  *v7 = &off_1E14F0288;
  v7[1] = this;
  v7[2] = a2;
  v7[3] = &v15;
  v17 = v7;
  AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v16);
  v8 = v17;
  if (v17 == v16)
  {
    v9 = 4;
    v8 = v16;
    goto LABEL_13;
  }
  if (v17)
  {
    v9 = 5;
LABEL_13:
    (*(void (**)(void))(*v8 + 8 * v9))();
  }
  if (*((_QWORD *)a2 + 13) || *((_QWORD *)a2 + 16))
  {
    v10 = *((_QWORD *)a2 + 18);
    v11 = operator new();
    *(_QWORD *)v11 = &off_1E14EDAF8;
    *(_BYTE *)(v11 + 8) = *(_BYTE *)(v10 + 8);
    *(_DWORD *)(v11 + 12) = *(_DWORD *)(v10 + 12);
    v12 = *((_QWORD *)this + 18);
    *((_QWORD *)this + 18) = v11;
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
    v13 = v15 != 0;
    pthread_mutex_unlock(v4);
  }
  else
  {
    v13 = v15 != 0;
    pthread_mutex_unlock(v4);
    if (!this)
      return v13;
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return v13;
}

void sub_184087E6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v17;
  pthread_mutex_t *v18;

  pthread_mutex_unlock(v18);
  if (v17)
    pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
  _Unwind_Resume(a1);
}

void std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_1,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_1,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E14F0288;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_1,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F0288;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_1,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2)
{
  if (!AuthenticationState::_haveAuthenticationInfo(*(_QWORD *)(a1 + 16), *a2))
    **(_BYTE **)(a1 + 24) = 1;
  return 1;
}

void std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_0,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_0,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E14F0240;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_0,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F0240;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_0,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, AuthenticationInfo **a3)
{
  int v5;
  uint64_t v6;
  char v7;
  BOOL *v8;
  BOOL v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  AuthenticationInfo *v15;
  std::__shared_weak_count *v16;

  v5 = *a2;
  v6 = *(_QWORD *)(a1 + 8);
  if (!AuthenticationState::_haveAuthenticationInfo(v6, *a2))
  {
    AuthenticationState::_makeAuth(v6, v5, 0, 0);
    AuthenticationState::_authForType(&v15, v6, v5);
    AuthenticationInfo::incorporate(v15, *a3);
    v10 = v16;
    if (!v16)
      return 1;
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    goto LABEL_12;
  }
  AuthenticationState::_authForType(&v15, v6, v5);
  v7 = AuthenticationInfo::incorporate(v15, *a3);
  v8 = *(BOOL **)(a1 + 16);
  v9 = (v7 & 1) != 0 || *v8;
  *v8 = v9;
  v10 = v16;
  if (v16)
  {
    v13 = (unint64_t *)&v16->__shared_owners_;
    do
      v12 = __ldaxr(v13);
    while (__stlxr(v12 - 1, v13));
LABEL_12:
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return 1;
}

void sub_184088128(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t AuthenticationInfo::incorporate(AuthenticationInfo *this, AuthenticationInfo *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef v12;
  const void *v13;
  uint64_t v14;

  if (!a2)
    __assert_rtn("incorporate", "AuthenticationHelpers.cpp", 1684, "other");
  v4 = *((_QWORD *)this + 1);
  v5 = *((_QWORD *)a2 + 1);
  if (v4)
  {
    v5 = v4 != v5;
  }
  else if (v5)
  {
    CFRetain((CFTypeRef)(v5 - 16));
    v6 = *((_QWORD *)this + 1);
    *((_QWORD *)this + 1) = v5;
    if (v6)
      CFRelease((CFTypeRef)(v6 - 16));
    v5 = 0;
  }
  v7 = (const void *)*((_QWORD *)this + 2);
  v8 = (const void *)*((_QWORD *)a2 + 2);
  if (v7)
  {
    if (v7 == v8)
      v5 = v5;
    else
      v5 = 1;
  }
  else if (v8)
  {
    v12 = CFRetain(v8);
    v13 = (const void *)*((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v12;
    if (v13)
      CFRelease(v13);
  }
  v9 = *((_QWORD *)this + 6);
  v10 = *((_QWORD *)a2 + 6);
  if (v9)
  {
    if (v9 == v10)
      return v5;
    else
      return 1;
  }
  else if (v10)
  {
    CFRetain((CFTypeRef)(v10 - 16));
    v14 = *((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = v10;
    if (v14)
      CFRelease((CFTypeRef)(v14 - 16));
  }
  return v5;
}

void std::__function::__func<AuthenticationState::isCompatible(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isCompatible(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<AuthenticationState::isCompatible(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isCompatible(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E14F0318;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::isCompatible(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isCompatible(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F0318;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<AuthenticationState::isCompatible(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isCompatible(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, uint64_t a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  const void *v9;
  BOOL v10;
  HTTPAuthentication *v11;
  unsigned int v12;
  _BOOL4 v13;
  HTTPAuthentication *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t v20;
  std::__shared_weak_count *v21;

  v5 = *a2;
  v6 = *(_QWORD *)(a1 + 8);
  if (!AuthenticationState::_haveAuthenticationInfo(v6, *a2))
    return 1;
  AuthenticationState::_authForType(&v20, v6, v5);
  v7 = v20;
  v8 = *(const void **)(v20 + 16);
  v9 = *(const void **)(*(_QWORD *)a3 + 16);
  if (v8)
    v10 = v9 == 0;
  else
    v10 = 1;
  if (v10 || !CFEqual(v8, v9))
    goto LABEL_15;
  v11 = *(HTTPAuthentication **)(v7 + 8);
  if (!v11)
  {
    v14 = *(HTTPAuthentication **)(*(_QWORD *)a3 + 8);
    if (!v14)
      goto LABEL_22;
    v13 = 0;
LABEL_14:
    if (v13 != (HTTPAuthentication::isConnectionBasedAuth(v14) != 0))
      goto LABEL_15;
LABEL_22:
    v15 = 1;
    goto LABEL_16;
  }
  v12 = HTTPAuthentication::isConnectionBasedAuth(v11);
  v13 = v12 != 0;
  v14 = *(HTTPAuthentication **)(*(_QWORD *)a3 + 8);
  if (v14)
    goto LABEL_14;
  if (!v12)
    goto LABEL_22;
LABEL_15:
  v15 = 0;
  **(_BYTE **)(a1 + 16) = 0;
LABEL_16:
  v16 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  return v15;
}

void sub_18408841C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

BOOL AuthenticationState::isEquivalent(AuthenticationState *this, AuthenticationState *a2)
{
  _BOOL8 v4;
  int v5;
  int v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  char v14;
  _BYTE v15[24];
  _BYTE *v16;
  _BYTE v17[24];
  _BYTE *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (this)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
    v4 = a2 != 0;
    if (a2 == this || !a2)
      goto LABEL_25;
LABEL_6:
    pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 8));
    v14 = 1;
    v5 = *((_QWORD *)this + 13) != 0;
    if (*((_QWORD *)this + 16))
      ++v5;
    v6 = *((_QWORD *)a2 + 13) != 0;
    if (*((_QWORD *)a2 + 16))
      ++v6;
    if (v5 != v6)
      goto LABEL_20;
    v7 = operator new(0x20uLL);
    *v7 = &off_1E14F0360;
    v7[1] = this;
    v7[2] = a2;
    v7[3] = &v14;
    v18 = v7;
    AuthenticationState::_foreachAuthenticationInfo((uint64_t)a2, (uint64_t)v17);
    v8 = v18;
    if (v18 == v17)
    {
      v9 = 4;
      v8 = v17;
    }
    else
    {
      if (!v18)
        goto LABEL_16;
      v9 = 5;
    }
    (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_16:
    if (v14)
    {
      v16 = 0;
      v10 = operator new(0x20uLL);
      *v10 = &off_1E14F03A8;
      v10[1] = this;
      v10[2] = a2;
      v10[3] = &v14;
      v16 = v10;
      AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v15);
      v11 = v16;
      if (v16 == v15)
      {
        v12 = 4;
        v11 = v15;
      }
      else
      {
        if (!v16)
        {
LABEL_23:
          v4 = v14 != 0;
          goto LABEL_24;
        }
        v12 = 5;
      }
      (*(void (**)(void))(*v11 + 8 * v12))();
      goto LABEL_23;
    }
LABEL_20:
    v4 = 0;
LABEL_24:
    pthread_mutex_unlock((pthread_mutex_t *)((char *)a2 + 8));
LABEL_25:
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
    return v4;
  }
  v4 = a2 != 0;
  if (a2)
    goto LABEL_6;
  return v4;
}

void sub_184088628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v17;
  pthread_mutex_t *v18;
  char *v19;
  char *v21;
  uint64_t v22;

  v21 = a13;
  if (a13 == v19)
  {
    v22 = 4;
    v21 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v22 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_6:
  pthread_mutex_unlock(v18);
  pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
  _Unwind_Resume(a1);
}

void std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_1,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_1,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E14F03A8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_1,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F03A8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_1,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2)
{
  _BOOL8 result;

  result = AuthenticationState::_haveAuthenticationInfo(*(_QWORD *)(a1 + 16), *a2);
  if (!result)
    **(_BYTE **)(a1 + 24) = 0;
  return result;
}

void std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E14F0360;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F0360;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, _QWORD *a3)
{
  int v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD *v13;
  std::__shared_weak_count *v14;

  v5 = *a2;
  v6 = *(_QWORD *)(a1 + 8);
  if (AuthenticationState::_haveAuthenticationInfo(v6, *a2))
  {
    AuthenticationState::_authForType(&v13, v6, v5);
    v7 = (_QWORD *)*a3;
    if (*a3 && v13[1] == v7[1] && v13[2] == v7[2] && v13[6] == v7[6])
    {
      v8 = 1;
    }
    else
    {
      v8 = 0;
      **(_BYTE **)(a1 + 24) = 0;
    }
    v9 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  else
  {
    v8 = 0;
    **(_BYTE **)(a1 + 24) = 0;
  }
  return v8;
}

void std::__function::__func<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0,std::allocator<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0,std::allocator<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E14F0510;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0,std::allocator<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F0510;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0,std::allocator<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, uint64_t a3)
{
  HTTPAuthentication *v4;
  int v5;
  uint64_t v6;
  HTTPAuthentication *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v4 = *(HTTPAuthentication **)(*(_QWORD *)a3 + 8);
  if (!v4)
    return 1;
  v5 = *a2;
  v6 = *(_QWORD *)(a1 + 8);
  if (!HTTPAuthentication::isConnectionBasedAuth(v4))
    return 1;
  if (AuthenticationState::_haveAuthenticationInfo(v6, v5))
  {
    AuthenticationState::_authForType(&v13, v6, v5);
    v7 = *(HTTPAuthentication **)(v13 + 8);
    if (v7 && HTTPAuthentication::isConnectionBasedAuth(v7))
    {
      v8 = 1;
    }
    else
    {
      v8 = 0;
      **(_BYTE **)(a1 + 24) = 1;
    }
    v9 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  else
  {
    v8 = 0;
    **(_BYTE **)(a1 + 24) = 1;
  }
  return v8;
}

void sub_184088A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

void __ConditionalConnectionDUETSupport_StartActivity(const __CFDictionary *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v14;
  void *Value;
  NSObject *v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  const __CFAllocator **v27;
  const void *v28;
  const __CFAllocator *v29;
  uint64_t v30;
  CFStringRef v31;
  double v32;
  const __CFAllocator *v33;
  uint64_t v34;
  CFStringRef v35;
  double Helper_x8__OBJC_CLASS____DASActivity;
  double Helper_x8___DASSchedulingPriorityUserInitiated;
  double Helper_x8___DASActivityDurationShort;
  id v39;
  void *v40;
  const __CFBoolean *v41;
  const __CFBoolean *v42;
  const __CFBoolean *v43;
  const __CFBoolean *v44;
  const __CFBoolean *v45;
  _BOOL8 v46;
  const __CFBoolean *v47;
  void *v48;
  int v49;
  int v50;
  double v51;
  double Helper_x8___DASSchedulingPriorityUtility;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  const __CFBoolean *v57;
  double v58;
  _QWORD *v59;
  double v60;
  void *v61;
  _QWORD *v62;
  void *v63;
  _QWORD *v64;
  double v65;
  double Helper_x8___DASActivityTransferSizeGigantic;
  double Helper_x10___DASActivityTransferSizeVeryLarge;
  double Helper_x12___DASActivityTransferSizeLarge;
  unint64_t v69;
  unint64_t v70;
  _QWORD *v71;
  unint64_t v72;
  _QWORD *v73;
  unint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  _QWORD *v77;
  uint64_t v78;
  void *v79;
  _QWORD *v80;
  unint64_t v81;
  double v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  const __CFBoolean *v87;
  NSObject *v88;
  const void *v89;
  const void *v90;
  const void *v91;
  const __CFBoolean *v92;
  NSObject *v93;
  id v94;
  void *v95;
  double v96;
  double v97;
  char v98;
  double v99;
  double Helper_x8__OBJC_CLASS____DASScheduler;
  uint64_t v101;
  uint64_t v102;
  void *v103;
  const __CFString *v104;
  NSObject *v105;
  const __CFString *v106;
  uint64_t v107;
  const __CFDictionary *theDict;
  _QWORD v111[5];
  uint8_t buf[4];
  void *v113;
  __int16 v114;
  const __CFDictionary *v115;
  __int16 v116;
  const __CFString *v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  v14 = (void *)MEMORY[0x186DB8C8C]();
  v111[0] = MEMORY[0x1E0C809B0];
  v111[1] = 3221225472;
  v111[2] = ____ConditionalConnectionDUETSupport_StartActivity_block_invoke;
  v111[3] = &unk_1E14FA1C0;
  v111[4] = a6;
  Value = (void *)CFDictionaryGetValue(a1, &unk_1EDCFB868);
  theDict = (const __CFDictionary *)CFDictionaryGetValue(a1, &unk_1EDCF96F0);
  v107 = a7;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v16 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    v113 = Value;
    v114 = 2112;
    v115 = theDict;
    _os_log_impl(&dword_183ECA000, v16, OS_LOG_TYPE_DEFAULT, "CCDS: requirements %@ DASActivityProperties %@", buf, 0x16u);
  }
  v17 = (void *)objc_msgSend(Value, "objectForKeyedSubscript:", CFSTR("kConditionalConnectionRequirementTimeWindowDelay"));
  v18 = (void *)objc_msgSend(Value, "objectForKeyedSubscript:", CFSTR("kConditionalConnectionRequirementTimeWindowDuration"));
  if (v17)
  {
    v19 = (void *)MEMORY[0x1E0C99D68];
    objc_msgSend(v17, "doubleValue");
    v20 = objc_msgSend(v19, "dateWithTimeIntervalSinceNow:");
  }
  else
  {
    v20 = objc_msgSend(Value, "objectForKeyedSubscript:", CFSTR("kConditionalConnectionRequirementTimeWindowStartTime"));
  }
  v21 = v20;
  v22 = (void *)MEMORY[0x1E0C99D68];
  if (v20)
    v23 = v18 == 0;
  else
    v23 = 1;
  if (v23)
  {
    v21 = objc_msgSend(MEMORY[0x1E0C99D68], "date");
    v24 = objc_msgSend(MEMORY[0x1E0C99D68], "dateWithTimeIntervalSinceNow:", 600.0);
  }
  else
  {
    objc_msgSend(v18, "doubleValue");
    v24 = objc_msgSend(v22, "dateWithTimeInterval:sinceDate:", v21);
  }
  v25 = 0;
  v26 = 0;
  if (a4 && a3 && a2 && v21 && v24)
  {
    v27 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
    if (theDict && (v28 = CFDictionaryGetValue(theDict, CFSTR("kConditionalConnectionActivityName"))) != 0
      || (v28 = CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("kConditionalConnectionActivityName"))) != 0)
    {
      v29 = *v27;
      v30 = getpid();
      v31 = CFStringCreateWithFormat(v29, 0, CFSTR("com.apple.CFNetwork-cc-%d-%lld-%@"), v30, ++__ConditionalConnectionDUETSupport_StartActivity::serialNumber, v28);
    }
    else
    {
      v33 = *v27;
      v34 = getpid();
      v31 = CFStringCreateWithFormat(v33, 0, CFSTR("com.apple.CFNetwork-cc-%d-%lld"), v34, ++__ConditionalConnectionDUETSupport_StartActivity::serialNumber);
    }
    v35 = v31;
    Helper_x8__OBJC_CLASS____DASActivity = gotLoadHelper_x8__OBJC_CLASS____DASActivity(v32);
    Helper_x8___DASSchedulingPriorityUserInitiated = gotLoadHelper_x8___DASSchedulingPriorityUserInitiated(Helper_x8__OBJC_CLASS____DASActivity);
    Helper_x8___DASActivityDurationShort = gotLoadHelper_x8___DASActivityDurationShort(Helper_x8___DASSchedulingPriorityUserInitiated);
    v26 = (void *)objc_msgSend(v39, "activityWithName:priority:duration:startingAfter:startingBefore:", v35, Helper_x8___DASActivityDurationShort);
    if (v35)
      CFRelease(v35);
    objc_msgSend(v26, "setHandlerQueue:", a2);
    objc_msgSend(v26, "setStartHandler:", v111);
    objc_msgSend(v26, "setSuspendHandler:", v107);
    objc_msgSend(v26, "setRequiresNetwork:", 1);
    v40 = (void *)objc_msgSend(Value, "objectForKeyedSubscript:", CFSTR("kConditionalConnectionRequirementDuetPreClearedMode"));
    if (v40)
      objc_msgSend(v26, "setPreClearedMode:", (int)objc_msgSend(v40, "intValue"));
    v41 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("kConditionalConnectionRequirementPowerPluggedIn"));
    if (v41 && CFBooleanGetValue(v41))
      objc_msgSend(v26, "setRequiresPlugin:", 1);
    v42 = (const __CFBoolean *)CFDictionaryGetValue(a1, &unk_1EDCFB788);
    v43 = (const __CFBoolean *)CFDictionaryGetValue(a1, &unk_1EDCFA058);
    v44 = (const __CFBoolean *)CFDictionaryGetValue(a1, &unk_1EDCFBC58);
    v46 = 1;
    if (v42 && !CFBooleanGetValue(v42) || v43 && !CFBooleanGetValue(v43) || v44 && CFBooleanGetValue(v44))
    {
      objc_msgSend(v26, "setRequiresInexpensiveNetworking:", 1);
      v45 = (const __CFBoolean *)CFDictionaryGetValue(a1, &unk_1EDCF9BC0);
      if (!v45 || !CFBooleanGetValue(v45))
        v46 = 0;
    }
    objc_msgSend(v26, "setAllowsCompanionExpensiveNetworking:", v46);
    v47 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("kConditionalConnectionIsDiscretionary"));
    v48 = (void *)CFDictionaryGetValue(a1, &unk_1EDCFA250);
    if (v47)
    {
      v49 = CFBooleanGetValue(v47);
      if (a5)
        *(_BYTE *)(a5 + 25) = v49 != 0;
      if (v49)
      {
        if (!v48)
          goto LABEL_61;
        v50 = objc_msgSend(v48, "intValue");
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v42 = (const __CFBoolean *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          v113 = v26;
          v114 = 1024;
          LODWORD(v115) = v50;
          _os_log_impl(&dword_183ECA000, (os_log_t)v42, OS_LOG_TYPE_DEFAULT, "activity [%p]: poolPriority %d", buf, 0x12u);
        }
        if (v50 > 249)
        {
          if (v50 <= 0x1C2)
          {
            Helper_x8___DASSchedulingPriorityUtility = gotLoadHelper_x8___DASSchedulingPriorityUtility(v51);
            v54 = *(uint64_t **)(v53 + 2576);
LABEL_60:
            v56 = *v54;
LABEL_62:
            objc_msgSend(v26, "setSchedulingPriority:", v56, Helper_x8___DASSchedulingPriorityUtility);
            goto LABEL_63;
          }
LABEL_61:
          v56 = resolveDiscretionaryPriority((const __CFDictionary *)Value);
          goto LABEL_62;
        }
LABEL_59:
        Helper_x8___DASSchedulingPriorityUtility = gotLoadHelper_x8___DASSchedulingPriorityUserInitiatedOvercommit(v51);
        v54 = *(uint64_t **)(v55 + 2560);
        goto LABEL_60;
      }
    }
    else if (a5)
    {
      *(_BYTE *)(a5 + 25) = 0;
    }
    if (v48)
    {
      if ((int)objc_msgSend(v48, "intValue") > 249)
        goto LABEL_63;
    }
    else if (CFDictionaryContainsKey(a1, &unk_1EDCFA218))
    {
LABEL_63:
      if (theDict
        && (v57 = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("kConditionalConnectionIsUpload"))) != 0
        || (v57 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("kConditionalConnectionIsUpload"))) != 0)
      {
        if (CFBooleanGetValue(v57))
          objc_msgSend(v26, "setIsUpload:", 1);
      }
      -[__CFDictionary objectForKeyedSubscript:](theDict, "objectForKeyedSubscript:", CFSTR("kConditionalConnectionRequirementUploadBytes"));
      gotLoadHelper_x22___DASActivityTransferSizeSmall(v58);
      v59 = (_QWORD *)*((_QWORD *)v47 + 307);
      gotLoadHelper_x23___DASActivityTransferSizeVerySmall(v60);
      v62 = (_QWORD *)*((_QWORD *)v42 + 309);
      if (v61)
      {
        v63 = v61;
        objc_msgSend(v26, "isUpload");
      }
      else
      {
        v63 = (void *)objc_msgSend(Value, "objectForKeyedSubscript:", CFSTR("kConditionalConnectionRequirementUploadBytes"));
        if (objc_msgSend(v26, "isUpload"))
          v64 = v59;
        else
          v64 = v62;
        if (!v63)
          goto LABEL_85;
      }
      objc_msgSend(v63, "unsignedLongLongValue");
      Helper_x8___DASActivityTransferSizeGigantic = gotLoadHelper_x8___DASActivityTransferSizeGigantic(v65);
      Helper_x10___DASActivityTransferSizeVeryLarge = gotLoadHelper_x10___DASActivityTransferSizeVeryLarge(Helper_x8___DASActivityTransferSizeGigantic);
      Helper_x12___DASActivityTransferSizeLarge = gotLoadHelper_x12___DASActivityTransferSizeLarge(Helper_x10___DASActivityTransferSizeVeryLarge);
      gotLoadHelper_x14___DASActivityTransferSizeModerate(Helper_x12___DASActivityTransferSizeLarge);
      v76 = *(_QWORD **)(v75 + 2448);
      if (v69 <= 0x19000)
        v77 = v62;
      else
        v77 = v59;
      if (v69 <= 0xA00000)
        v76 = v77;
      if (v69 <= v74)
        v73 = v76;
      if (v69 <= v72)
        v71 = v73;
      if (v69 <= v70)
        v64 = v71;
LABEL_85:
      objc_msgSend(v26, "setUploadSize:", *v64);
      v78 = -[__CFDictionary objectForKeyedSubscript:](theDict, "objectForKeyedSubscript:", CFSTR("kConditionalConnectionRequirementDownloadBytes"));
      if (v78)
      {
        v79 = (void *)v78;
        objc_msgSend(v26, "isUpload");
      }
      else
      {
        v79 = (void *)objc_msgSend(Value, "objectForKeyedSubscript:", CFSTR("kConditionalConnectionRequirementDownloadBytes"));
        if (objc_msgSend(v26, "isUpload"))
          v80 = v62;
        else
          v80 = v59;
        if (!v79)
          goto LABEL_102;
      }
      v81 = objc_msgSend(v79, "unsignedLongLongValue");
      if (v81 <= 0x40000000)
      {
        if (v81 <= 0x1F400000)
        {
          if (v81 <= 0x6400000)
          {
            if (v81 <= 0xA00000)
            {
              if (v81 <= 0x19000)
                v80 = v62;
              else
                v80 = v59;
            }
            else
            {
              gotLoadHelper_x8___DASActivityTransferSizeModerate(v82);
              v80 = *(_QWORD **)(v86 + 2448);
            }
          }
          else
          {
            gotLoadHelper_x8___DASActivityTransferSizeLarge(v82);
            v80 = *(_QWORD **)(v85 + 2440);
          }
        }
        else
        {
          gotLoadHelper_x8___DASActivityTransferSizeVeryLarge(v82);
          v80 = *(_QWORD **)(v84 + 2464);
        }
      }
      else
      {
        gotLoadHelper_x8___DASActivityTransferSizeGigantic(v82);
        v80 = *(_QWORD **)(v83 + 2432);
      }
LABEL_102:
      objc_msgSend(v26, "setDownloadSize:", *v80);
      v87 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("kConditionalConnectionOnBehalfOfPairedDevice"));
      if (v87 && CFBooleanGetValue(v87))
      {
        objc_msgSend(v26, "setTargetDevice:", 1);
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v88 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218242;
          v113 = v26;
          v114 = 2112;
          v115 = (const __CFDictionary *)v26;
          _os_log_impl(&dword_183ECA000, v88, OS_LOG_TYPE_DEFAULT, "activity [%p] %@ is on behalf of a paired device", buf, 0x16u);
        }
      }
      v89 = CFDictionaryGetValue(a1, &unk_1EDCFBFA0);
      if (v89)
      {
        v90 = v89;
        v91 = CFDictionaryGetValue(a1, &unk_1EDCFB718);
        objc_msgSend(v26, "setBundleId:", v90);
        objc_msgSend(v26, "setRelatedApplications:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:", v90, v91, 0));
      }
      v92 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("kConditionalConnectionInTransitionalDiscretionaryPeriod"));
      if (v92 && CFBooleanGetValue(v92))
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v93 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218242;
          v113 = v26;
          v114 = 2112;
          v115 = (const __CFDictionary *)v26;
          _os_log_impl(&dword_183ECA000, v93, OS_LOG_TYPE_DEFAULT, "activity [%p] %@ is in transistional discretionary period", buf, 0x16u);
        }
        objc_msgSend(v26, "setDeferred:", 1);
      }
      if (objc_msgSend(v26, "userInfo"))
        v94 = (id)objc_msgSend((id)objc_msgSend(v26, "userInfo"), "mutableCopy");
      else
        v94 = objc_alloc_init(MEMORY[0x1E0C99E08]);
      v95 = v94;
      objc_msgSend(MEMORY[0x1E0CCEC78], "endpointWithCEndpoint:", a3);
      objc_msgSend(v95, "setObject:forKeyedSubscript:", gotLoadHelper_x8__kNWEndpointKey(v96));
      objc_msgSend(MEMORY[0x1E0CCECA0], "parametersWithCParameters:", a4);
      objc_msgSend(v95, "setObject:forKeyedSubscript:", gotLoadHelper_x8__kNWParametersKey(v97));
      objc_msgSend(v26, "setUserInfo:", v95);

      if (!v26)
        goto LABEL_132;
      v98 = objc_msgSend(v26, "dataBudgetingEnabled");
      if (a5)
        *(_BYTE *)(a5 + 26) = v98;
      Helper_x8__OBJC_CLASS____DASScheduler = gotLoadHelper_x8__OBJC_CLASS____DASScheduler(v99);
      v102 = objc_msgSend(*(id *)(v101 + 2352), "sharedScheduler", Helper_x8__OBJC_CLASS____DASScheduler);
      if (v102)
      {
        v103 = (void *)v102;
        v104 = (const __CFString *)CFDictionaryGetValue(a1, &unk_1EDCFA218);
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v105 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          v106 = CFSTR("none");
          *(_DWORD *)buf = 134218498;
          if (v104)
            v106 = v104;
          v113 = v26;
          v114 = 2112;
          v115 = (const __CFDictionary *)v26;
          v116 = 2112;
          v117 = v106;
          _os_log_impl(&dword_183ECA000, v105, OS_LOG_TYPE_DEFAULT, "activity [%p] %@ submitted to pool %@", buf, 0x20u);
        }
        if (v104)
          objc_msgSend(v103, "submitActivity:inGroupWithName:", v26, v104);
        else
          objc_msgSend(v103, "submitActivity:", v26);
        v25 = 1;
      }
      else
      {
LABEL_132:
        v25 = 0;
      }
      goto LABEL_135;
    }
    goto LABEL_59;
  }
LABEL_135:
  (*(void (**)(uint64_t, uint64_t, void *))(a8 + 16))(a8, v25, v26);
  objc_autoreleasePoolPop(v14);
}

uint64_t resolveDiscretionaryPriority(const __CFDictionary *a1)
{
  const __CFBoolean *Value;
  const __CFBoolean *v3;
  double v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  Value = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("kConditionalConnectionClientOptInDiscretionary"));
  v3 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("kConditionalConnectionRequirementDiscretionaryElevated"));
  if (Value && CFBooleanGetValue(Value))
  {
    gotLoadHelper_x8___DASSchedulingPriorityMaintenance(v4);
    v6 = *(_QWORD *)(v5 + 2536);
  }
  else if (v3 && CFBooleanGetValue(v3))
  {
    gotLoadHelper_x8___DASSchedulingPriorityUtility(v4);
    v6 = *(_QWORD *)(v7 + 2576);
  }
  else
  {
    gotLoadHelper_x8___DASSchedulingPriorityBackground(v4);
    v6 = *(_QWORD *)(v8 + 2512);
  }
  return *(_QWORD *)v6;
}

void __ConditionalConnectionDUETSupport_ReportBytes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  void *v8;
  double v9;
  double Helper_x8__OBJC_CLASS____DASScheduler;
  uint64_t v11;
  void *v12;
  double v13;
  double Helper_x8___DASUpdateActivityCellTransferKey;
  double Helper_x9___DASUpdateActivityWifiTransferKey;
  double Helper_x9___DASUpdateActivityExpensiveTransferKey;
  double Helper_x10___DASUpdateActivityInexpensiveTransferKey;
  double Helper_x10___DASUpdateActivityUploadedBytesKey;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  double Helper_x11___DASUpdateActivityDownloadedBytesKey;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD v31[2];

  v31[1] = *MEMORY[0x1E0C80C00];
  v8 = (void *)MEMORY[0x186DB8C8C]();
  Helper_x8__OBJC_CLASS____DASScheduler = gotLoadHelper_x8__OBJC_CLASS____DASScheduler(v9);
  v12 = (void *)objc_msgSend(*(id *)(v11 + 2352), "sharedScheduler", Helper_x8__OBJC_CLASS____DASScheduler);
  Helper_x8___DASUpdateActivityCellTransferKey = gotLoadHelper_x8___DASUpdateActivityCellTransferKey(v13);
  Helper_x9___DASUpdateActivityWifiTransferKey = gotLoadHelper_x9___DASUpdateActivityWifiTransferKey(Helper_x8___DASUpdateActivityCellTransferKey);
  Helper_x9___DASUpdateActivityExpensiveTransferKey = gotLoadHelper_x9___DASUpdateActivityExpensiveTransferKey(Helper_x9___DASUpdateActivityWifiTransferKey);
  Helper_x10___DASUpdateActivityInexpensiveTransferKey = gotLoadHelper_x10___DASUpdateActivityInexpensiveTransferKey(Helper_x9___DASUpdateActivityExpensiveTransferKey);
  Helper_x10___DASUpdateActivityUploadedBytesKey = gotLoadHelper_x10___DASUpdateActivityUploadedBytesKey(Helper_x10___DASUpdateActivityInexpensiveTransferKey);
  Helper_x11___DASUpdateActivityDownloadedBytesKey = gotLoadHelper_x11___DASUpdateActivityDownloadedBytesKey(Helper_x10___DASUpdateActivityUploadedBytesKey);
  v24 = *(uint64_t **)(v23 + 2600);
  if (!a5)
    v21 = v24;
  v25 = *v21;
  v30 = v19;
  v28 = v20;
  v26 = v25;
  v27 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", a2, Helper_x11___DASUpdateActivityDownloadedBytesKey);
  v29 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v27, &v26, 1);
  v31[0] = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v29, &v28, 1);
  objc_msgSend(v12, "updateActivity:withParameters:", a1, objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v31, &v30, 1));
  objc_autoreleasePoolPop(v8);
}

uint64_t HTTP2Stream::copyTrust(HTTP2Stream *this)
{
  uint64_t v1;
  IOConnWrapper *v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v1 = *((_QWORD *)this + 8);
  if (!v1)
    return 0;
  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v2 = *(IOConnWrapper **)(v1 + 56);
  if (v2)
  {
    v3 = IOConnWrapper::copyProperty(v2, CFSTR("kCFStreamPropertySSLPeerTrust"));
    v6[3] = v3;
  }
  else
  {
    v3 = 0;
  }
  _Block_object_dispose(&v5, 8);
  return v3;
}

void sub_184089BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

id *HTTP2Stream::getHTTPConnectionInfo(HTTP2Stream *this)
{
  uint64_t v1;
  id *result;

  v1 = *((_QWORD *)this + 8);
  result = *(id **)(v1 + 712);
  if (!result)
  {
    result = -[_NSHTTPConnectionInfo initWithHTTPConnectionInfo:queue:]((id *)[_NSHTTPConnectionInfo alloc], (void *)(v1 + 24), *(void **)(v1 + 168));
    *(_QWORD *)(v1 + 712) = result;
  }
  return result;
}

void `non-virtual thunk to'HTTP2Stream::~HTTP2Stream(HTTP2Stream *this)
{
  HTTP2Stream::~HTTP2Stream((HTTP2Stream *)((char *)this - 8));
}

{
  HTTP2Stream::~HTTP2Stream((HTTP2Stream *)((char *)this - 8));
  JUMPOUT(0x186DB748CLL);
}

void `non-virtual thunk to'HTTP2Stream::bufferDataAvailable(uint64_t a1, NSObject *a2)
{
  HTTP2Stream::bufferDataAvailable(a1 - 8, a2);
}

void HTTP2Stream::_onqueue_sendWindowUpdate(HTTP2Stream *this)
{
  uint64_t v2;
  uint64_t v3;
  CFIndex Count;
  unint64_t v5;
  const __CFArray *v6;
  const void *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  const void *ValueAtIndex;
  unint64_t *p_shared_owners;
  unint64_t v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  _BOOL4 v26;
  char v27;
  int v28;
  NSObject *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  const __CFString *v34;
  char *v35;
  char *v36;
  int v37;
  std::__shared_weak_count *v38;
  uint8_t buf[4];
  char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (__CFNGetAutoRcvBufMax::onceToken != -1)
    dispatch_once(&__CFNGetAutoRcvBufMax::onceToken, &__block_literal_global_49);
  v2 = __CFNGetAutoRcvBufMax::value;
  if (__CFNGetAutoRcvBufMax::value != -1 && *((_QWORD *)this + 14) < __CFNGetAutoRcvBufMax::value)
  {
    v3 = *((_QWORD *)this + 8);
    Count = CFArrayGetCount(*(CFArrayRef *)(v3 + 232));
    if (Count)
    {
      v5 = Count;
      v6 = *(const __CFArray **)(v3 + 232);
      if (v5 > 4)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v6, 4);
        v9 = *((_QWORD *)ValueAtIndex + 3);
        v8 = (std::__shared_weak_count *)*((_QWORD *)ValueAtIndex + 4);
        if (v8)
        {
          p_shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            v15 = __ldxr(p_shared_owners);
          while (__stxr(v15 + 1, p_shared_owners));
          do
            v12 = __ldaxr(p_shared_owners);
          while (__stlxr(v12 - 1, p_shared_owners));
LABEL_16:
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
      else
      {
        v7 = CFArrayGetValueAtIndex(v6, v5 - 1);
        v9 = *((_QWORD *)v7 + 3);
        v8 = (std::__shared_weak_count *)*((_QWORD *)v7 + 4);
        if (v8)
        {
          v10 = (unint64_t *)&v8->__shared_owners_;
          do
            v11 = __ldxr(v10);
          while (__stxr(v11 + 1, v10));
          do
            v12 = __ldaxr(v10);
          while (__stlxr(v12 - 1, v10));
          goto LABEL_16;
        }
      }
      if (v9)
      {
        v16 = *(_DWORD *)(v9 + 80);
        if (v16 != -1 && *((_DWORD *)this + 20) <= v16)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v17 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          {
            v36 = (char *)*((_QWORD *)this + 27);
            v37 = *((_DWORD *)this + 20);
            *(_DWORD *)buf = 138543874;
            v40 = v36;
            v41 = 1024;
            v42 = v37;
            v43 = 2048;
            v44 = v2;
            _os_log_debug_impl(&dword_183ECA000, v17, OS_LOG_TYPE_DEBUG, "%{public}@ on stream %d increasing suspension threshold to %ld", buf, 0x1Cu);
          }
          *((_QWORD *)this + 14) = v2;
        }
      }
    }
  }
  v18 = *((_QWORD *)this + 14) - *((_QWORD *)this + 13);
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  v19 = *((_QWORD *)this + 8);
  v38 = 0;
  v20 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
  if (v20 && (v21 = std::__shared_weak_count::lock(v20), (v38 = v21) != 0))
  {
    v22 = v21;
    v23 = *((_QWORD *)this + 35);
    v24 = (unint64_t *)&v21->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
    if (!*(_QWORD *)(v19 + 160))
      goto LABEL_43;
    v26 = v23 == 0;
    v27 = 0;
  }
  else
  {
    if (!*(_QWORD *)(v19 + 160))
      goto LABEL_47;
    v22 = 0;
    v26 = 1;
    v27 = 1;
  }
  v28 = nghttp2_submit_window_update();
  if ((v28 & 0x80000000) == 0)
  {
    if (!*(_BYTE *)(v19 + 81))
      HTTP2Connection::_onqueue_scheduleIO((HTTP2Connection *)v19);
    goto LABEL_42;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v29 = CFNLog::logger;
  if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
LABEL_42:
    if ((v27 & 1) != 0)
      goto LABEL_47;
    goto LABEL_43;
  }
  if (v26)
  {
    v34 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
    v35 = _cfnAutoreleaseInDebug(v34);
  }
  else
  {
    v35 = "";
  }
  *(_DWORD *)buf = 136315394;
  v40 = v35;
  v41 = 1024;
  v42 = v28;
  _os_log_error_impl(&dword_183ECA000, v29, OS_LOG_TYPE_ERROR, "Could not submit window update on [%s], error code: %d", buf, 0x12u);
  if ((v27 & 1) != 0)
    goto LABEL_47;
LABEL_43:
  v30 = (unint64_t *)&v22->__shared_owners_;
  do
    v31 = __ldaxr(v30);
  while (__stlxr(v31 - 1, v30));
  if (!v31)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
LABEL_47:
  if (v38)
  {
    v32 = (unint64_t *)&v38->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  *((_QWORD *)this + 13) += v18;
}

void sub_18408A07C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11HTTP2Stream27_onqueue_notifyStreamClosedEv_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_DWORD *)(v1 + 192))
  {
    *(_QWORD *)(v1 + 184) = 4;
    *(_DWORD *)(v1 + 192) = -4;
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) + 16))();
}

BOOL HTTP2StreamBridge::equals(HTTP2StreamBridge *this, const CFObject *a2)
{
  return *((_QWORD *)this + 3) == *((_QWORD *)a2 + 3);
}

uint64_t HTTP2StreamBridge::hash(HTTP2StreamBridge *this)
{
  return *((_QWORD *)this + 3);
}

const __CFString *HTTP2StreamBridge::copyDebugDesc(HTTP2StreamBridge *this)
{
  return CFSTR("HTTP2MetaNetStreamInfoForwarder");
}

CFNumberRef HTTP2StreamBridge::copyProperty(uint64_t a1, int a2)
{
  return HTTP2Stream::copyProperty(*(_QWORD **)(a1 + 24), a2);
}

uint64_t HTTP2StreamBridge::setProperty(uint64_t a1, int a2, const void *a3)
{
  return HTTP2Stream::setProperty(*(_QWORD *)(a1 + 24), a2, a3);
}

uint64_t HTTP2StreamBridge::canScheduleAndOpenWithHandlerAsync(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 32))(*((_QWORD *)this + 3));
}

uint64_t HTTP2StreamBridge::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24));
}

uint64_t HTTP2StreamBridge::closeAndClearHandler(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 48))(*((_QWORD *)this + 3));
}

uint64_t HTTP2StreamBridge::updateScheduling(HTTP2StreamBridge *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(_QWORD, const CoreSchedulingSet *))(**((_QWORD **)this + 3) + 56))(*((_QWORD *)this + 3), a2);
}

uint64_t HTTP2StreamBridge::setPriorityHint(HTTP2StreamBridge *this, float a2)
{
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 3) + 128))(*((_QWORD *)this + 3), a2);
}

uint64_t HTTP2StreamBridge::setBodyStreamBeforeOpening(HTTP2StreamBridge *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFReadStream *))(**((_QWORD **)this + 3) + 64))(*((_QWORD *)this + 3), a2);
}

uint64_t HTTP2StreamBridge::rawBytesSent(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 72))(*((_QWORD *)this + 3));
}

uint64_t HTTP2StreamBridge::rawBytesReceived(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 80))(*((_QWORD *)this + 3));
}

uint64_t HTTP2StreamBridge::getConnectionIdentifier(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 88))(*((_QWORD *)this + 3));
}

uint64_t HTTP2StreamBridge::copyTrust(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 96))(*((_QWORD *)this + 3));
}

uint64_t HTTP2StreamBridge::_conn_no_more_reqests_after_this_one_connectionLost(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 104))(*((_QWORD *)this + 3));
}

void HTTP2StreamBridge::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *(_QWORD *)(a1 + 24);
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 112))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_18408A294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTP2StreamBridge::getProxy(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 120))(*((_QWORD *)this + 3));
}

uint64_t HTTP2StreamBridge::setTransactionMetrics(HTTP2StreamBridge *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(_QWORD, __CFN_TransactionMetrics *))(**((_QWORD **)this + 3) + 16))(*((_QWORD *)this + 3), a2);
}

uint64_t HTTP2StreamBridge::getHTTPConnectionInfo(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 136))(*((_QWORD *)this + 3));
}

uint64_t HTTP2StreamBridge::getCurrentSuspensionThreshold(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 144))(*((_QWORD *)this + 3));
}

CFTypeRef HTTP2StreamBridge::_meta_retain(HTTP2StreamBridge *this)
{
  return CFRetain((char *)this - 16);
}

void HTTP2StreamBridge::_meta_release(HTTP2StreamBridge *this)
{
  CFRelease((char *)this - 16);
}

void `non-virtual thunk to'HTTP2StreamBridge::~HTTP2StreamBridge(HTTP2StreamBridge *this)
{
  *((_QWORD *)this - 1) = &off_1E14E86B0;
  *(_QWORD *)this = &unk_1E14E8798;
  *((_QWORD *)this + 1) = &unk_1E14E8868;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 16);
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

{
  *((_QWORD *)this - 1) = &off_1E14E86B0;
  *(_QWORD *)this = &unk_1E14E8798;
  *((_QWORD *)this + 1) = &unk_1E14E8868;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 16);
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

{
  *((_QWORD *)this - 2) = &off_1E14E86B0;
  *((_QWORD *)this - 1) = &unk_1E14E8798;
  *(_QWORD *)this = &unk_1E14E8868;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  *(_QWORD *)this = &off_1E14E5838;
}

{
  *((_QWORD *)this - 2) = &off_1E14E86B0;
  *((_QWORD *)this - 1) = &unk_1E14E8798;
  *(_QWORD *)this = &unk_1E14E8868;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  *(_QWORD *)this = &off_1E14E5838;
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::copyTrust(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 96))(*((_QWORD *)this + 2));
}

void `non-virtual thunk to'HTTP2StreamBridge::setProxy(uint64_t a1, uint64_t *a2)
{
  HTTP2StreamBridge::setProxy(a1 - 8, a2);
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::getHTTPConnectionInfo(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 136))(*((_QWORD *)this + 2));
}

void DataBuffer::_flushData(uint64_t *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t);
  unint64_t *p_shared_owners;
  unint64_t v11;

  v3 = (std::__shared_weak_count *)a1[1];
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = *a1;
      if (*a1)
      {
        v8 = *(_QWORD *)(a2 + 24);
        if (v8)
        {
          v9 = *(void (**)(uint64_t))(a2 + 32);
          *(_QWORD *)(a2 + 24) = 0;
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 16))(v7, v8);
          v9(v8);
        }
      }
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_18408A4EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  void (*v10)(uint64_t);

  v10(v9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN10DataBuffer19initializeBufferingEPU28objcproto17OS_dispatch_queue8NSObjectNSt3__18weak_ptrI18DataBufferDelegateEE_block_invoke(_QWORD *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_weak_owners;
  unint64_t v4;
  uint64_t v5[2];

  v1 = a1[4];
  v2 = (std::__shared_weak_count *)a1[6];
  v5[0] = a1[5];
  v5[1] = (uint64_t)v2;
  if (v2)
  {
    p_shared_weak_owners = (unint64_t *)&v2->__shared_weak_owners_;
    do
      v4 = __ldxr(p_shared_weak_owners);
    while (__stxr(v4 + 1, p_shared_weak_owners));
  }
  DataBuffer::_flushData(v5, v1);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void sub_18408A56C(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;

  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_40c43_ZTSNSt3__18weak_ptrI18DataBufferDelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c43_ZTSNSt3__18weak_ptrI18DataBufferDelegateEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void _release_dispatch_safe<NSObject  {objcproto18OS_dispatch_object}*>(dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<nghttp2_nv>>(unint64_t a1)
{
  if (a1 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(40 * a1);
}

uint64_t ___ZN11HTTP2Stream10endHeadersEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 889;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN11HTTP2Stream16didSendRSTStreamEv_block_invoke(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 32);
  if (*(_DWORD *)(v1 + 56) != 2)
    *(_DWORD *)(v1 + 56) = 3;
  return result;
}

uint64_t __copy_helper_block_e8_32c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void HTTP2Stream::didReceiveRSTStream(HTTP2Stream *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  NSObject *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[5];
  std::__shared_weak_count *v14;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
      v4 = *((_QWORD *)this + 35);
    else
      v4 = 0;
  }
  else
  {
    v4 = 0;
    v3 = 0;
  }
  v5 = *((_QWORD *)this + 9);
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3321888768;
  v13[2] = ___ZN11HTTP2Stream19didReceiveRSTStreamEv_block_invoke;
  v13[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
  v13[4] = v4;
  v14 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  dispatch_async(v5, v13);
  v8 = v14;
  if (!v14)
    goto LABEL_13;
  v9 = (unint64_t *)&v14->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if (!v3)
      return;
  }
  else
  {
LABEL_13:
    if (!v3)
      return;
  }
  v11 = (unint64_t *)&v3->__shared_owners_;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void ___ZN11HTTP2Stream19didReceiveRSTStreamEv_block_invoke(uint64_t a1)
{
  HTTP2Stream::closeStreamWithErrorCode(*(HTTP2Stream **)(a1 + 32));
}

void HTTP2Stream::setError(HTTP2Stream *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  NSObject *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD block[6];
  std::__shared_weak_count *v17;
  CFIndex v18;
  uint64_t v19;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
  if (v5)
  {
    v6 = std::__shared_weak_count::lock(v5);
    if (v6)
      v7 = *((_QWORD *)this + 35);
    else
      v7 = 0;
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  v8 = *((_QWORD *)this + 9);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN11HTTP2Stream8setErrorE13CFStreamErrorh_block_invoke;
  block[3] = &__block_descriptor_72_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
  block[4] = this;
  block[5] = v7;
  v17 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v18 = domain;
  v19 = v2;
  dispatch_async(v8, block);
  v11 = v17;
  if (!v17)
    goto LABEL_13;
  v12 = (unint64_t *)&v17->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    if (!v6)
      return;
  }
  else
  {
LABEL_13:
    if (!v6)
      return;
  }
  v14 = (unint64_t *)&v6->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

__n128 ___ZN11HTTP2Stream8setErrorE13CFStreamErrorh_block_invoke(uint64_t a1)
{
  __n128 result;

  result = *(__n128 *)(a1 + 56);
  *(__n128 *)(*(_QWORD *)(a1 + 40) + 184) = result;
  return result;
}

void HTTP2Stream::handle_HTTP_1_1_REQUIRED_error(HTTP2Stream *this)
{
  const __CFURL *v2;
  __CFString *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(*((_QWORD *)this + 5) - 16));
  v3 = (__CFString *)CFURLCopyHostName(v2);
  v4 = *((_QWORD *)this + 2);
  if (v4)
    v5 = v4 - 176;
  else
    v5 = 0;
  v6 = objc_msgSend(*(id *)(v5 + 80), "session");
  if (v6)
    -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:](v6, v3, 80);
  if (v3)
    CFRelease(v3);
  if (v2)
    CFRelease(v2);
}

void sub_18408A998(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<HTTP2Stream *,std::shared_ptr<HTTP2Stream>::__shared_ptr_default_delete<HTTP2Stream,HTTP2Stream>,std::allocator<HTTP2Stream>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t URLCredential::hash(URLCredential *this)
{
  uint64_t result;

  if (*((_BYTE *)this + 48))
    return *((_QWORD *)this + 5);
  *((_BYTE *)this + 48) = 1;
  result = (*(uint64_t (**)(URLCredential *, unint64_t))(*(_QWORD *)this + 96))(this, (8 * *((int *)this + 9)) | ((unint64_t)*((unsigned int *)this + 8) << 6));
  *((_QWORD *)this + 5) = result;
  return result;
}

CFStringRef URLCredential::copyDebugSummary(URLCredential *this)
{
  int v2;
  const char *v3;
  const char *v4;
  const char *v5;
  const __CFAllocator *v6;
  uint64_t v7;

  v2 = *((_DWORD *)this + 9);
  v3 = "session";
  v4 = "Unknown";
  if (v2 == 3)
    v4 = "permanent";
  if (v2 != 2)
    v3 = v4;
  if (v2 == 1)
    v5 = "none";
  else
    v5 = v3;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = *((_QWORD *)this + 7);
  if (!v7)
  {
    v7 = (*(uint64_t (**)(URLCredential *))(*(_QWORD *)this + 104))(this);
    *((_QWORD *)this + 7) = v7;
  }
  return CFStringCreateWithFormat(v6, 0, CFSTR("Name: %@, Persistence: %s"), v7, v5);
}

BOOL URLCredential::initializeFromPropertyList(uint64_t a1, CFDictionaryRef *a2)
{
  _BOOL8 result;
  const __CFNumber *Value;
  uint64_t v6;
  const __CFNumber *v7;
  int v8;
  uint8_t v9[16];

  result = Serializable::initializeFromPropertyList(a1 + 8, a2);
  if (result)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(*a2, CFSTR("credKind"));
    if (Value)
    {
      *(_QWORD *)v9 = 0;
      CFNumberGetValue(Value, kCFNumberCFIndexType, v9);
      v6 = *(_QWORD *)v9;
    }
    else
    {
      v6 = 0;
    }
    if (v6 != *(_DWORD *)(a1 + 32) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v9 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "unarchiving wrong type?", v9, 2u);
    }
    v7 = (const __CFNumber *)CFDictionaryGetValue(*a2, CFSTR("persistence"));
    if (v7)
    {
      *(_QWORD *)v9 = 0;
      CFNumberGetValue(v7, kCFNumberCFIndexType, v9);
      v8 = *(_DWORD *)v9;
    }
    else
    {
      v8 = 0;
    }
    *(_DWORD *)(a1 + 36) = v8;
    return 1;
  }
  return result;
}

uint64_t URLCredential::serializeToPropertyList(URLCredential *this, SerializableArchive **a2)
{
  CFTypeRef v4;
  CFTypeRef v5;
  void (**v7)(AutoScalar *__hidden);
  CFTypeRef cf;

  Serializable::serializeToPropertyList((URLCredential *)((char *)this + 8), a2);
  AutoScalar::AutoScalar((AutoScalar *)&v7, (const __CFAllocator *)*((unsigned int *)this + 8));
  v4 = cf;
  SerializableArchive::assertEmpty(*a2, CFSTR("credKind"));
  if (v4)
    CFDictionarySetValue(*a2, CFSTR("credKind"), v4);
  v7 = &off_1E14E47E8;
  if (cf)
    CFRelease(cf);
  AutoScalar::AutoScalar((AutoScalar *)&v7, (const __CFAllocator *)*((unsigned int *)this + 9));
  v5 = cf;
  SerializableArchive::assertEmpty(*a2, CFSTR("persistence"));
  if (v5)
    CFDictionarySetValue(*a2, CFSTR("persistence"), v5);
  v7 = &off_1E14E47E8;
  if (cf)
    CFRelease(cf);
  return 1;
}

void sub_18408ACB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

BOOL `non-virtual thunk to'URLCredential::initializeFromPropertyList(uint64_t a1, CFDictionaryRef *a2)
{
  return URLCredential::initializeFromPropertyList(a1 - 8, a2);
}

uint64_t `non-virtual thunk to'URLCredential::serializeToPropertyList(URLCredential *this, SerializableArchive **a2)
{
  URLCredential::serializeToPropertyList((URLCredential *)((char *)this - 8), a2);
  return 1;
}

uint64_t Archiver<URLCredential,_CFURLCredential const*>::~Archiver(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    CFRelease(v2);
  return a1;
}

void Archiver<URLCredential,_CFURLCredential const*>::~Archiver(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 8);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t (***URLCredential::createFromPropertyList(URLCredential *this, CFDictionaryRef theDict, const void *a3))(URLCredentialInternetPassword *__hidden this, const CFObject *)
{
  const __CFNumber *Value;
  uint64_t (***v6)(URLCredentialInternetPassword *__hidden, const CFObject *);
  uint64_t Instance;
  uint64_t (**v8)(URLCredentialInternetPassword *__hidden, const CFObject *);
  uint64_t v9;
  uint64_t (**v10)(URLCredentialInternetPassword *__hidden, const CFObject *);
  uint64_t (**v11)(URLCredentialInternetPassword *__hidden, const CFObject *);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeRef v17;
  CFTypeRef cf[2];

  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("credKind"));
  if (!Value)
    return 0;
  cf[0] = 0;
  CFNumberGetValue(Value, kCFNumberCFIndexType, cf);
  v6 = 0;
  switch((unint64_t)cf[0])
  {
    case 0uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      Instance = _CFRuntimeCreateInstance();
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      v6 = (uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *))(Instance + 16);
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_QWORD *)(Instance + 112) = 0;
      *(_DWORD *)(Instance + 48) = 0;
      *(_BYTE *)(Instance + 64) = 0;
      *(_QWORD *)(Instance + 72) = 0;
      *(_QWORD *)(Instance + 56) = 0;
      v8 = &off_1E14EECF8;
      *(_QWORD *)(Instance + 16) = &off_1E14EECF8;
      *(_QWORD *)(Instance + 24) = &unk_1E14EEDA0;
      *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
      *(_QWORD *)(Instance + 40) = &unk_1E14EEDD0;
      *(_BYTE *)(Instance + 104) = 0;
      goto LABEL_27;
    case 1uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      v9 = _CFRuntimeCreateInstance();
      *(_OWORD *)(v9 + 16) = 0u;
      *(_OWORD *)(v9 + 32) = 0u;
      v6 = (uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *))(v9 + 16);
      *(_OWORD *)(v9 + 48) = 0u;
      *(_OWORD *)(v9 + 64) = 0u;
      v10 = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))&gConstantCFStringValueTable[3752];
      *(_DWORD *)(v9 + 48) = 1;
      *(_BYTE *)(v9 + 64) = 0;
      *(_QWORD *)(v9 + 72) = 0;
      *(_QWORD *)(v9 + 80) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      v8 = &off_1E14ED238;
      *(_QWORD *)(v9 + 16) = &off_1E14ED238;
      *(_QWORD *)(v9 + 24) = &unk_1E14ED2B8;
      v11 = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))&unk_1E14ED2E8;
      goto LABEL_19;
    case 2uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      v12 = _CFRuntimeCreateInstance();
      *(_OWORD *)(v12 + 16) = 0u;
      *(_OWORD *)(v12 + 32) = 0u;
      v6 = (uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *))(v12 + 16);
      *(_OWORD *)(v12 + 48) = 0u;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      *(_DWORD *)(v12 + 48) = 2;
      *(_BYTE *)(v12 + 64) = 0;
      *(_QWORD *)(v12 + 72) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      v8 = &off_1E14EE598;
      *(_QWORD *)(v12 + 16) = &off_1E14EE598;
      *(_QWORD *)(v12 + 24) = &unk_1E14EE640;
      *(_QWORD *)(v12 + 32) = &gConstantCFStringValueTable[3752];
      *(_QWORD *)(v12 + 40) = &unk_1E14EE670;
      *(_QWORD *)(v12 + 104) = 0;
      goto LABEL_27;
    case 3uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      v13 = _CFRuntimeCreateInstance();
      *(_OWORD *)(v13 + 16) = 0u;
      *(_OWORD *)(v13 + 32) = 0u;
      v6 = (uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *))(v13 + 16);
      *(_OWORD *)(v13 + 48) = 0u;
      *(_OWORD *)(v13 + 64) = 0u;
      *(_OWORD *)(v13 + 80) = 0u;
      v10 = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))&gConstantCFStringValueTable[3752];
      *(_DWORD *)(v13 + 48) = 3;
      *(_BYTE *)(v13 + 64) = 0;
      *(_QWORD *)(v13 + 72) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      v8 = &off_1E14EF0E8;
      *(_QWORD *)(v13 + 16) = &off_1E14EF0E8;
      *(_QWORD *)(v13 + 24) = &unk_1E14EF178;
      v11 = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))&unk_1E14EF1A8;
      goto LABEL_19;
    case 4uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      v14 = _CFRuntimeCreateInstance();
      *(_OWORD *)(v14 + 16) = 0u;
      *(_OWORD *)(v14 + 32) = 0u;
      v6 = (uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *))(v14 + 16);
      *(_OWORD *)(v14 + 48) = 0u;
      *(_OWORD *)(v14 + 64) = 0u;
      *(_OWORD *)(v14 + 80) = 0u;
      *(_OWORD *)(v14 + 96) = 0u;
      v10 = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))&gConstantCFStringValueTable[3752];
      *(_DWORD *)(v14 + 48) = 4;
      *(_BYTE *)(v14 + 64) = 0;
      *(_QWORD *)(v14 + 72) = 0;
      *(_QWORD *)(v14 + 56) = 0;
      v8 = &off_1E14EF2C8;
      *(_QWORD *)(v14 + 16) = &off_1E14EF2C8;
      *(_QWORD *)(v14 + 24) = &unk_1E14EF370;
      v11 = (uint64_t (**)(URLCredentialInternetPassword *__hidden, const CFObject *))&unk_1E14EF3A0;
LABEL_19:
      v6[2] = v10;
      v6[3] = v11;
      goto LABEL_27;
    case 6uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      v15 = _CFRuntimeCreateInstance();
      *(_OWORD *)(v15 + 16) = 0u;
      *(_OWORD *)(v15 + 32) = 0u;
      v6 = (uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *))(v15 + 16);
      *(_OWORD *)(v15 + 48) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_OWORD *)(v15 + 80) = 0u;
      *(_DWORD *)(v15 + 48) = 6;
      *(_BYTE *)(v15 + 64) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      v8 = &off_1E14EAFB0;
      *(_QWORD *)(v15 + 16) = &off_1E14EAFB0;
      *(_QWORD *)(v15 + 24) = &unk_1E14EB048;
      *(_QWORD *)(v15 + 32) = &gConstantCFStringValueTable[3752];
      *(_QWORD *)(v15 + 40) = &unk_1E14EB078;
      *(_QWORD *)(v15 + 72) = 0;
      *(_QWORD *)(v15 + 80) = 0;
      goto LABEL_26;
    case 7uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      v16 = _CFRuntimeCreateInstance();
      *(_OWORD *)(v16 + 16) = 0u;
      *(_OWORD *)(v16 + 32) = 0u;
      v6 = (uint64_t (***)(URLCredentialInternetPassword *__hidden, const CFObject *))(v16 + 16);
      *(_OWORD *)(v16 + 48) = 0u;
      *(_OWORD *)(v16 + 64) = 0u;
      *(_OWORD *)(v16 + 80) = 0u;
      *(_DWORD *)(v16 + 48) = 7;
      *(_BYTE *)(v16 + 64) = 0;
      *(_QWORD *)(v16 + 72) = 0;
      *(_QWORD *)(v16 + 56) = 0;
      v8 = &off_1E14EAEB0;
      *(_QWORD *)(v16 + 16) = &off_1E14EAEB0;
      *(_QWORD *)(v16 + 24) = &unk_1E14EAF60;
      *(_QWORD *)(v16 + 32) = &gConstantCFStringValueTable[3752];
      *(_QWORD *)(v16 + 40) = &unk_1E14EAF90;
      *(_DWORD *)(v16 + 80) = 0;
      *(_QWORD *)(v16 + 96) = 0;
LABEL_26:
      v6[9] = 0;
LABEL_27:
      cf[1] = this;
      if (theDict)
      {
        v17 = CFRetain(theDict);
        v8 = *v6;
      }
      else
      {
        v17 = 0;
      }
      cf[0] = v17;
      if (!v8[8]((URLCredentialInternetPassword *)v6, (const CFObject *)cf))
      {
        CFRelease(v6 - 2);
        v6 = 0;
      }
      if (cf[0])
        CFRelease(cf[0]);
      break;
    default:
      return v6;
  }
  return v6;
}

void sub_18408B288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t URLCredential_PasswordBased::safelyCast(uint64_t this, const _CFURLCredential *a2)
{
  uint64_t v2;

  if (!this)
    goto LABEL_5;
  v2 = this;
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  this = v2 + 16;
  if (*(_DWORD *)(v2 + 48))
  {
LABEL_5:
    if (*(_DWORD *)(this + 32) != 4)
      return 0;
  }
  return this;
}

uint64_t URLAuthChallenge::equals(URLAuthChallenge *this, const CFObject *a2)
{
  const void *v4;
  const void *v5;
  uint64_t result;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;

  if (*((_QWORD *)this + 5) != *((_QWORD *)a2 + 5))
    return 0;
  v4 = (const void *)*((_QWORD *)this + 3);
  v5 = (const void *)*((_QWORD *)a2 + 3);
  if (v4 == v5 || (result = CFEqual(v4, v5), (_DWORD)result))
  {
    v7 = (const void *)*((_QWORD *)this + 4);
    v8 = (const void *)*((_QWORD *)a2 + 4);
    if (v7 == v8 || (result = CFEqual(v7, v8), (_DWORD)result))
    {
      v9 = (const void *)*((_QWORD *)this + 6);
      v10 = (const void *)*((_QWORD *)a2 + 6);
      if (v9 == v10 || (result = CFEqual(v9, v10), (_DWORD)result))
      {
        v11 = (const void *)*((_QWORD *)this + 7);
        v12 = (const void *)*((_QWORD *)a2 + 7);
        if (v11 == v12 || (result = CFEqual(v11, v12), (_DWORD)result))
        {
          v13 = (const void *)*((_QWORD *)this + 8);
          v14 = (const void *)*((_QWORD *)a2 + 8);
          if (v13 == v14)
            return *((_QWORD *)this + 9) == *((_QWORD *)a2 + 9);
          result = CFEqual(v13, v14);
          if ((_DWORD)result)
            return *((_QWORD *)this + 9) == *((_QWORD *)a2 + 9);
        }
      }
    }
  }
  return result;
}

CFStringRef URLAuthChallenge::copyDebugDesc(URLAuthChallenge *this)
{
  char *v2;
  const __CFAllocator *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFError *Code;
  CFErrorDomain Domain;

  v2 = (char *)this - 16;
  v3 = CFGetAllocator((char *)this - 16);
  v4 = *((_QWORD *)this + 3);
  v5 = *((_QWORD *)this + 4);
  v6 = *((_QWORD *)this + 5);
  v7 = *((_QWORD *)this + 6);
  Code = (__CFError *)*((_QWORD *)this + 7);
  if (Code)
  {
    Domain = CFErrorGetDomain(Code);
    Code = (__CFError *)*((_QWORD *)this + 7);
    if (Code)
      Code = (__CFError *)CFErrorGetCode(Code);
  }
  else
  {
    Domain = CFSTR("none");
  }
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLAuthChallenge %p>{space = %@, proposedCredential = %@, previousFailureCount = %ld, failureResponse = %@, error = %@/%ld}"), v2, v4, v5, v6, v7, Domain, Code);
}

CFStringRef URLAuthChallenge::copyDebugSummary(URLAuthChallenge *this)
{
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  const void *v5;
  const __CFAllocator *v6;
  CFStringRef v7;
  const __CFAllocator *v9;

  v2 = (_QWORD *)*((_QWORD *)this + 3);
  if (v2)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
    v2 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v2[2] + 32))(v2 + 2);
  }
  v3 = (void *)*((_QWORD *)this + 6);
  if (!v3)
  {
    v9 = CFGetAllocator((char *)this - 16);
    v7 = CFStringCreateWithFormat(v9, 0, CFSTR("challenge space %@"), v2);
    if (!v2)
      return v7;
    goto LABEL_9;
  }
  v4 = objc_msgSend(v3, "_inner");
  v5 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v6 = CFGetAllocator((char *)this - 16);
  v7 = CFStringCreateWithFormat(v6, 0, CFSTR("challenge space %@, failing response %@"), v2, v5);
  if (v5)
    CFRelease(v5);
  if (v2)
LABEL_9:
    CFRelease(v2);
  return v7;
}

BOOL URLAuthChallenge::initializeFromPropertyList(URLAuthChallenge *this, CFDictionaryRef *a2)
{
  _BOOL8 result;
  char *v5;
  char *v6;
  const __CFNumber *Value;
  Serializable *v8;
  objc_class *v9;
  CFTypeID TypeID;
  CFTypeID v11;
  Serializable *valuePtr;

  result = Serializable::initializeFromPropertyList((uint64_t)this + 8, a2);
  if (result)
  {
    valuePtr = 0;
    DeserializableArchive::decant((DeserializableArchive *)a2, CFSTR("space"), &valuePtr);
    if (valuePtr)
      v5 = (char *)valuePtr - 24;
    else
      v5 = 0;
    *((_QWORD *)this + 3) = v5;
    valuePtr = 0;
    DeserializableArchive::decant((DeserializableArchive *)a2, CFSTR("proposed"), &valuePtr);
    if (valuePtr)
      v6 = (char *)valuePtr - 24;
    else
      v6 = 0;
    *((_QWORD *)this + 4) = v6;
    Value = (const __CFNumber *)CFDictionaryGetValue(*a2, CFSTR("count"));
    if (Value)
    {
      valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
      v8 = valuePtr;
    }
    else
    {
      v8 = 0;
    }
    *((_QWORD *)this + 5) = v8;
    valuePtr = 0;
    v9 = (objc_class *)objc_opt_class();
    DeserializableArchive::decantClass(a2, CFSTR("response"), v9, (id *)&valuePtr);
    *((_QWORD *)this + 6) = valuePtr;
    valuePtr = 0;
    TypeID = CFErrorGetTypeID();
    DeserializableArchive::decant((DeserializableArchive *)a2, CFSTR("error"), TypeID, (const void **)&valuePtr);
    *((_QWORD *)this + 7) = valuePtr;
    valuePtr = 0;
    v11 = CFArrayGetTypeID();
    DeserializableArchive::decant((DeserializableArchive *)a2, CFSTR("spaces"), v11, (const void **)&valuePtr);
    *((_QWORD *)this + 8) = valuePtr;
    return 1;
  }
  return result;
}

uint64_t URLAuthChallenge::serializeToPropertyList(URLAuthChallenge *this, SerializableArchive **a2)
{
  CFTypeRef v4;
  void (**v6)(AutoScalar *__hidden);
  CFTypeRef cf;

  Serializable::serializeToPropertyList((URLAuthChallenge *)((char *)this + 8), a2);
  SerializableArchive::add(a2, CFSTR("space"), *((_CFURLProtectionSpace **)this + 3));
  SerializableArchive::add(a2, CFSTR("proposed"), *((const _CFURLCredential **)this + 4));
  AutoScalar::AutoScalar((AutoScalar *)&v6, (const __CFAllocator *)*((unsigned int *)this + 10));
  v4 = cf;
  SerializableArchive::assertEmpty(*a2, CFSTR("count"));
  if (v4)
    CFDictionarySetValue(*a2, CFSTR("count"), v4);
  v6 = &off_1E14E47E8;
  if (cf)
    CFRelease(cf);
  SerializableArchive::add(a2, CFSTR("response"), *((void **)this + 6));
  SerializableArchive::add((CFTypeRef *)a2, CFSTR("error"), *((__CFError **)this + 7));
  SerializableArchive::add((CFTypeRef *)a2, CFSTR("spaces"), *((const __CFArray **)this + 8));
  return 1;
}

void sub_18408B7A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void `non-virtual thunk to'URLAuthChallenge::~URLAuthChallenge(URLAuthChallenge *this)
{
  URLAuthChallenge::~URLAuthChallenge((URLAuthChallenge *)((char *)this - 8));
}

{
  URLAuthChallenge::~URLAuthChallenge((URLAuthChallenge *)((char *)this - 8));
}

BOOL `non-virtual thunk to'URLAuthChallenge::initializeFromPropertyList(URLAuthChallenge *this, CFDictionaryRef *a2)
{
  return URLAuthChallenge::initializeFromPropertyList((URLAuthChallenge *)((char *)this - 8), a2);
}

uint64_t `non-virtual thunk to'URLAuthChallenge::serializeToPropertyList(URLAuthChallenge *this, SerializableArchive **a2)
{
  URLAuthChallenge::serializeToPropertyList((URLAuthChallenge *)((char *)this - 8), a2);
  return 1;
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2, _CFURLProtectionSpace *a3)
{
  const __CFAllocator *v6;
  CFTypeRef cf;

  if (a3)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
    SerializableArchive::assertEmpty(*this, a2);
    v6 = CFGetAllocator(*this);
    cf = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if ((*(unsigned int (**)(char *, CFTypeRef *))(*((_QWORD *)a3 + 3) + 24))((char *)a3 + 24, &cf))
      SerializableArchive::add((CFTypeRef *)this, a2, (CFDictionaryRef)cf);
    if (cf)
      CFRelease(cf);
  }
}

void sub_18408B8C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2, const _CFURLCredential *a3)
{
  const __CFAllocator *v6;
  CFTypeRef cf;

  if (a3)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    SerializableArchive::assertEmpty(*this, a2);
    v6 = CFGetAllocator(*this);
    cf = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if ((*(unsigned int (**)(char *, CFTypeRef *))(*((_QWORD *)a3 + 3) + 24))((char *)a3 + 24, &cf))
      SerializableArchive::add((CFTypeRef *)this, a2, (CFDictionaryRef)cf);
    if (cf)
      CFRelease(cf);
  }
}

void sub_18408B9A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

CFTypeRef URLAuthChallenge::setListOfProtectionSpaces(URLAuthChallenge *this, CFTypeRef cf)
{
  const void *v4;
  CFTypeRef result;

  v4 = (const void *)*((_QWORD *)this + 8);
  if (v4)
  {
    *((_QWORD *)this + 8) = 0;
    CFRelease(v4);
  }
  if (cf)
    result = CFRetain(cf);
  else
    result = 0;
  *((_QWORD *)this + 8) = result;
  return result;
}

void NetworkProxyCredential::~NetworkProxyCredential(NetworkProxyCredential *this)
{
  const void *v2;

  *(_QWORD *)this = off_1E14EC648;
  *((_QWORD *)this + 3) = &unk_1E14EC690;
  v2 = (const void *)*((_QWORD *)this + 4);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14EC648;
  *((_QWORD *)this + 3) = &unk_1E14EC690;
  v2 = (const void *)*((_QWORD *)this + 4);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 3) = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

void sub_18408BA4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_18408BAAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void NetworkProxyCredential::copyDebugDesc(CFAllocatorRef *this)
{
  uint64_t v1;
  uint8_t buf[4];
  int v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = *((unsigned int *)this + 10);
  if (v1 >= 3)
  {
    *(_DWORD *)buf = 67109120;
    v3 = v1;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Unknown viability type %d", buf, 8u);
    __break(1u);
  }
  else
  {
    CFStringCreateWithFormat(this[1], 0, CFSTR("<NetworkProxyCredential %p>{viability=%@, cred=%p}"), this, off_1E14FA2F8[v1], this[4]);
  }
}

BOOL NetworkProxyCredential::equals(NetworkProxyCredential *this, const CFAllocatedReferenceCountedObject *a2)
{
  unint64_t v2;
  unint64_t v3;
  _BOOL8 result;
  BOOL v5;

  if (!a2)
    return 0;
  v2 = *((_QWORD *)this + 4);
  v3 = *((_QWORD *)a2 + 4);
  result = (v2 | v3) == 0;
  if (v2)
    v5 = v3 == 0;
  else
    v5 = 1;
  if (!v5)
    return CFEqual((CFTypeRef)v2, (CFTypeRef)v3) != 0;
  return result;
}

uint64_t NetworkProxyCredential::hash(NetworkProxyCredential *this)
{
  return *((_QWORD *)this + 6);
}

void `non-virtual thunk to'NetworkProxyCredential::~NetworkProxyCredential(NetworkProxyCredential *this)
{
  const void *v2;

  *((_QWORD *)this - 3) = off_1E14EC648;
  *(_QWORD *)this = &unk_1E14EC690;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)this = &off_1E14E5838;
}

{
  char *v2;
  const void *v3;

  *((_QWORD *)this - 3) = off_1E14EC648;
  v2 = (char *)this - 24;
  *(_QWORD *)this = &unk_1E14EC690;
  v3 = (const void *)*((_QWORD *)this + 1);
  if (v3)
    CFRelease(v3);
  *(_QWORD *)this = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 2), v2);
}

void sub_18408BC14(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_18408BC78(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void NetworkProxyCredential::NetworkProxyCredential(NetworkProxyCredential *this, const __CFAllocator *a2, CFTypeRef cf)
{
  CFTypeRef v4;

  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14EC648;
  *((_QWORD *)this + 3) = &unk_1E14EC690;
  if (cf)
    v4 = CFRetain(cf);
  else
    v4 = 0;
  *((_QWORD *)this + 4) = v4;
  *((_QWORD *)this + 6) = CFHash(v4);
  *((_DWORD *)this + 10) = 0;
}

void sub_18408BD20(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void NetworkProxyCredential::NetworkProxyCredential(NetworkProxyCredential *this, const __CFAllocator *a2, CFDictionaryRef theDict)
{
  const __CFDictionary *Value;
  const void *v6;
  uint64_t (***v7)(URLCredentialInternetPassword *__hidden, const CFObject *);
  uint64_t (***v8)(URLCredentialInternetPassword *__hidden, const CFObject *);
  const __CFNumber *v9;
  const __CFNumber *v10;
  CFTypeID v11;
  int v12;
  NSObject *v13;
  const void *v14;
  unint64_t valuePtr;
  uint8_t buf[4];
  unint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14EC648;
  *((_QWORD *)this + 3) = &unk_1E14EC690;
  Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("kNetworkProxyCredentialKeyCredential"));
  if (Value)
  {
    v7 = URLCredential::createFromPropertyList(*((URLCredential **)this + 1), Value, v6);
    v8 = v7 - 2;
    if (!v7)
      v8 = 0;
    *((_QWORD *)this + 4) = v8;
  }
  v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("kNetworkProxyCredentialKeyViability"));
  v10 = v9;
  if (v9)
  {
    v11 = CFGetTypeID(v9);
    if (v11 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      CFNumberGetValue(v10, kCFNumberCFIndexType, &valuePtr);
      v12 = valuePtr;
      if (valuePtr > 2)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v13 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134217984;
          v17 = valuePtr;
          _os_log_error_impl(&dword_183ECA000, v13, OS_LOG_TYPE_ERROR, "Archived viability (%ld) outside of expected range", buf, 0xCu);
        }
        v12 = 0;
      }
      *((_DWORD *)this + 10) = v12;
    }
  }
  v14 = (const void *)*((_QWORD *)this + 4);
  if (v14)
    v14 = (const void *)CFHash(v14);
  *((_QWORD *)this + 6) = v14;
}

void sub_18408BEF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

__CFDictionary *NetworkProxyCredential::createSerializedCredential(CFAllocatorRef *this)
{
  __CFDictionary *Mutable;
  uint64_t v3;
  CFTypeRef Archive;
  const void *v5;
  CFNumberRef v6;
  CFNumberRef v7;

  Mutable = CFDictionaryCreateMutable(this[1], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v3 = (uint64_t)this[4];
  if (v3)
  {
    Archive = _CFURLCredentialCreateArchive(this[1], v3);
    if (Archive)
    {
      v5 = Archive;
      CFDictionaryAddValue(Mutable, CFSTR("kNetworkProxyCredentialKeyCredential"), Archive);
      CFRelease(v5);
    }
  }
  v6 = CFNumberCreate(this[1], kCFNumberCFIndexType, this + 5);
  if (v6)
  {
    v7 = v6;
    CFDictionaryAddValue(Mutable, CFSTR("kNetworkProxyCredentialKeyViability"), v6);
    CFRelease(v7);
  }
  return Mutable;
}

void CFNetworkProxyCredentialCreateWithCredential(const __CFAllocator *a1, const void *a2)
{
  _OWORD *v4;

  v4 = CFAllocatorAllocate(a1, 56, 0);
  *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  *((_QWORD *)v4 + 6) = 0;
  NetworkProxyCredential::NetworkProxyCredential((NetworkProxyCredential *)v4, a1, a2);
}

uint64_t CFNetworkProxyCredentialRetain(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  return a1;
}

uint64_t CFNetworkProxyCredentialRelease(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t CFNetworkProxyCredentialEqual(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
}

uint64_t CFNetworkProxyCredentialCopyDebugDescription(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
}

CFDataRef CFNetworkProxyCredentialCreateData(CFAllocatorRef *a1)
{
  __CFDictionary *SerializedCredential;
  __CFDictionary *v3;
  CFDataRef v4;
  CFErrorRef error;

  SerializedCredential = NetworkProxyCredential::createSerializedCredential(a1);
  if (!SerializedCredential)
    return 0;
  v3 = SerializedCredential;
  error = 0;
  v4 = CFPropertyListCreateData(a1[1], SerializedCredential, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  if (error)
    CFRelease(error);
  CFRelease(v3);
  return v4;
}

uint64_t CFNetworkProxyCredentialSetViability(uint64_t result, int a2)
{
  *(_DWORD *)(result + 40) = a2;
  return result;
}

uint64_t CFNetworkProxyCredentialGetCredential(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t URLProtectionSpace::equals(URLProtectionSpace *this, const CFObject *a2)
{
  CFTypeID v4;
  const void *v5;
  const void *v6;
  uint64_t result;
  const __CFString *v8;
  const __CFString *v9;
  NSObject *v10;
  _BOOL4 v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (this == a2)
    return 1;
  v4 = CFGetTypeID((char *)this - 16);
  if (v4 != CFGetTypeID((char *)a2 - 16)
    || *((_QWORD *)this + 3) != *((_QWORD *)a2 + 3)
    || *((_DWORD *)this + 10) != *((_DWORD *)a2 + 10))
  {
    return 0;
  }
  v5 = (const void *)*((_QWORD *)this + 4);
  v6 = (const void *)*((_QWORD *)a2 + 4);
  if (v5)
  {
    if (!v6)
      return 0;
    result = CFEqual(v5, v6);
    if (!(_DWORD)result)
      return result;
  }
  else if (v6)
  {
    return 0;
  }
  v8 = (const __CFString *)*((_QWORD *)this + 6);
  v9 = (const __CFString *)*((_QWORD *)a2 + 6);
  if (v8)
  {
    if (!v9)
      goto LABEL_19;
    if (CFEqual(v8, v9))
      goto LABEL_20;
    if (*((_QWORD *)this + 6))
      goto LABEL_17;
    v9 = (const __CFString *)*((_QWORD *)a2 + 6);
  }
  if (!v9)
    goto LABEL_20;
  if (CFStringGetLength(v9) > 0)
    return 0;
LABEL_17:
  if (!*((_QWORD *)a2 + 6))
  {
    v8 = (const __CFString *)*((_QWORD *)this + 6);
    if (v8)
    {
LABEL_19:
      if (CFStringGetLength(v8) <= 0)
        goto LABEL_20;
      return 0;
    }
  }
LABEL_20:
  if (*((_DWORD *)this + 11) != *((_DWORD *)a2 + 11))
    return 0;
  if (!*((_BYTE *)this + 80) && !*((_BYTE *)a2 + 80))
  {
    v16 = *((_DWORD *)this + 14);
    if (v16 == 1)
      return 1;
    v17 = *((_DWORD *)a2 + 14);
    return v17 == 1 || v16 == v17;
  }
  if (*((_DWORD *)this + 14) == *((_DWORD *)a2 + 14))
    return 1;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v10 = CFNLog::logger;
  v11 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v11)
  {
    v12 = *((_QWORD *)this + 4);
    v13 = *((_DWORD *)this + 14);
    v14 = *((_QWORD *)a2 + 4);
    v15 = *((_DWORD *)a2 + 14);
    v18 = 138413058;
    v19 = v12;
    v20 = 1024;
    v21 = v13;
    v22 = 2112;
    v23 = v14;
    v24 = 1024;
    v25 = v15;
    _os_log_impl(&dword_183ECA000, v10, OS_LOG_TYPE_DEFAULT, "Strict auth scheme mismatch (%@ %d) (%@ %d)", (uint8_t *)&v18, 0x22u);
    return 0;
  }
  return result;
}

uint64_t URLProtectionSpace::hash(URLProtectionSpace *this)
{
  return *((_QWORD *)this + 3);
}

CFStringRef URLProtectionSpace::copyDebugDesc(URLProtectionSpace *this)
{
  char *v2;
  const __CFAllocator *v3;

  v2 = (char *)this - 16;
  v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLProtectionSpace %p>{host = %@, port = %d, realm = %@, serverType = %d, authenticationScheme = %d}"), v2, *((_QWORD *)this + 4), *((unsigned int *)this + 10), *((_QWORD *)this + 6), *((unsigned int *)this + 11), *((unsigned int *)this + 14));
}

CFStringRef URLProtectionSpace::copyDebugSummary(URLProtectionSpace *this)
{
  CFStringRef v2;
  unsigned int v3;
  const char *v4;
  const __CFAllocator *v5;
  uint64_t v6;
  CFStringRef v7;

  v2 = URLProtectionSpace::copyNameForIdentityPreference(this);
  v3 = *((_DWORD *)this + 14) - 1;
  if (v3 > 0xB)
    v4 = "?";
  else
    v4 = off_1E14FA330[v3];
  v5 = CFGetAllocator((char *)this - 16);
  v6 = (*(uint64_t (**)(URLProtectionSpace *))(*(_QWORD *)this + 8))(this);
  v7 = CFStringCreateWithFormat(v5, 0, CFSTR("%@, %s (Hash %lx)"), v2, v4, v6);
  if (v2)
    CFRelease(v2);
  return v7;
}

void `non-virtual thunk to'URLProtectionSpace::~URLProtectionSpace(URLProtectionSpace *this)
{
  URLProtectionSpace::~URLProtectionSpace((URLProtectionSpace *)((char *)this - 8));
}

{
  URLProtectionSpace::~URLProtectionSpace((URLProtectionSpace *)((char *)this - 8));
}

BOOL `non-virtual thunk to'URLProtectionSpace::initializeFromPropertyList(URLProtectionSpace *this, CFDictionaryRef *a2)
{
  return URLProtectionSpace::initializeFromPropertyList((URLProtectionSpace *)((char *)this - 8), a2);
}

uint64_t `non-virtual thunk to'URLProtectionSpace::serializeToPropertyList(URLProtectionSpace *this, SerializableArchive **a2)
{
  URLProtectionSpace::serializeToPropertyList((URLProtectionSpace *)((char *)this - 8), a2);
  return 1;
}

CFStringRef URLProtectionSpace::copyNameForIdentityPreference(URLProtectionSpace *this)
{
  unsigned int v2;
  const __CFString *v3;
  uint64_t v4;
  const __CFString *v5;
  const __CFString *v6;
  int CharacterAtIndex;
  unsigned int v8;
  const __CFAllocator *v9;
  uint64_t v10;

  v2 = *((_DWORD *)this + 11) - 1;
  if (v2 > 7)
  {
    LODWORD(v4) = 0;
    v3 = CFSTR("unknown_scheme");
  }
  else
  {
    v3 = off_1E14FA390[v2];
    LODWORD(v4) = dword_18411E118[v2];
  }
  if (*((_QWORD *)this + 4))
    v5 = (const __CFString *)*((_QWORD *)this + 4);
  else
    v5 = CFSTR("unknown_host");
  if (*((_QWORD *)this + 6))
    v6 = (const __CFString *)*((_QWORD *)this + 6);
  else
    v6 = CFSTR("/");
  CharacterAtIndex = CFStringGetCharacterAtIndex(v6, 0);
  v8 = *((_DWORD *)this + 10);
  if (v8)
    v4 = v8;
  else
    v4 = v4;
  v9 = CFGetAllocator((char *)this - 16);
  v10 = 47;
  if (CharacterAtIndex == 47)
    v10 = 0;
  return CFStringCreateWithFormat(v9, 0, CFSTR("%@://%@:%d%c%@"), v3, v5, v4, v10, v6);
}

uint64_t URLProtectionSpace::getSecAttrProtocol(URLProtectionSpace *this)
{
  uint64_t *v1;
  uint64_t result;

  switch((int)this)
  {
    case 1:
      v1 = (uint64_t *)MEMORY[0x1E0CD6AF0];
      goto LABEL_11;
    case 2:
      v1 = (uint64_t *)MEMORY[0x1E0CD6B00];
      goto LABEL_11;
    case 3:
      v1 = (uint64_t *)MEMORY[0x1E0CD6AD8];
      goto LABEL_11;
    case 4:
      v1 = (uint64_t *)MEMORY[0x1E0CD6AE8];
      goto LABEL_11;
    case 5:
      v1 = (uint64_t *)MEMORY[0x1E0CD6AF8];
      goto LABEL_11;
    case 6:
      v1 = (uint64_t *)MEMORY[0x1E0CD6B08];
      goto LABEL_11;
    case 7:
      v1 = (uint64_t *)MEMORY[0x1E0CD6AE0];
      goto LABEL_11;
    case 8:
      v1 = (uint64_t *)MEMORY[0x1E0CD6B20];
LABEL_11:
      result = *v1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t URLProtectionSpace::stringForProtSpaceAuthScheme(int a1)
{
  uint64_t result;
  uint64_t *v3;

  result = 0;
  switch(a1)
  {
    case 2:
      v3 = (uint64_t *)&kCFHTTPAuthenticationSchemeBasic;
      goto LABEL_10;
    case 3:
      v3 = (uint64_t *)&kCFHTTPAuthenticationSchemeDigest;
      goto LABEL_10;
    case 5:
      v3 = (uint64_t *)&kCFHTTPAuthenticationSchemeNTLM;
      goto LABEL_10;
    case 6:
      v3 = (uint64_t *)&kCFHTTPAuthenticationSchemeNegotiate;
      goto LABEL_10;
    case 9:
      v3 = (uint64_t *)&kCFHTTPAuthenticationSchemeXMobileMeAuthToken;
      goto LABEL_10;
    case 10:
      v3 = &_kCFHTTPAuthenticationSchemeOAuth;
      goto LABEL_10;
    case 11:
      v3 = &_kCFHTTPAuthenticationSchemePrivateAccessToken;
      goto LABEL_10;
    case 12:
      v3 = &_kCFHTTPAuthenticationSchemeOAuthBearerToken;
LABEL_10:
      result = *v3;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t URLProtectionSpace::authSchemeForAuth(URLProtectionSpace *this, _CFHTTPAuthentication *a2)
{
  const __CFString *v2;
  const __CFString *v3;
  int ExactString;

  v2 = CFHTTPAuthenticationCopyMethod(this);
  if (!v2)
    return 1;
  v3 = v2;
  ExactString = _findExactString(v2, 1u);
  CFRelease(v3);
  if (ExactString > 6324247)
  {
    if (ExactString > 8486941)
    {
      if (ExactString != 8486942)
      {
        if (ExactString == 9601061)
          return 9;
        return 1;
      }
      return 11;
    }
    else
    {
      if (ExactString != 6324248)
      {
        if (ExactString == 7381019)
          return 10;
        return 1;
      }
      return 5;
    }
  }
  else if (ExactString > 2146310)
  {
    if (ExactString != 2146311)
    {
      if (ExactString == 5316627)
        return 6;
      return 1;
    }
    return 3;
  }
  else
  {
    if (ExactString != 40960)
    {
      if (ExactString == 1097731)
        return 12;
      return 1;
    }
    return 2;
  }
}

uint64_t URLProtectionSpace::protSpaceAuthSchemeForCFStringRef(const __CFString *this, const __CFString *a2)
{
  int ExactString;

  ExactString = _findExactString(this, 1u);
  if (ExactString > 5316626)
  {
    if (ExactString > 7381018)
    {
      switch(ExactString)
      {
        case 7381019:
          return 10;
        case 8486942:
          return 11;
        case 9601061:
          return 9;
      }
      return 1;
    }
    if (ExactString != 5316627)
    {
      if (ExactString == 6324248)
        return 5;
      return 1;
    }
    return 6;
  }
  if (ExactString <= 2146310)
  {
    if (ExactString == 40960)
      return 2;
    if (ExactString == 1097731)
      return 12;
    return 1;
  }
  if (ExactString == 2146311)
    return 3;
  if (ExactString == 3211275)
    return 6;
  return 1;
}

void TransportConnectionObjCPP::~TransportConnectionObjCPP(TransportConnectionObjCPP *this)
{
  TransportConnectionObjCPP::~TransportConnectionObjCPP(this);
  JUMPOUT(0x186DB748CLL);
}

{
  char *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  __int128 v7;

  *(_QWORD *)this = &off_1E14ED750;
  v2 = (char *)this + 24;
  v7 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 24, &v7);
  v3 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
  if (*((_QWORD *)&v7 + 1))
  {
    v4 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v2);
  *(_QWORD *)this = &off_1E14E5838;
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void TransportConnectionObjCPP::TransportConnectionObjCPP(TransportConnectionObjCPP *this, NSObject *a2)
{
  char *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E14ED750;
  *((_QWORD *)this + 3) = 0;
  v3 = (char *)this + 24;
  *((_QWORD *)this + 4) = 0;
  GlueTubeManager::createTransportConnection((std::__shared_weak_count **)&v7, a2);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v7);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
  if (*((_QWORD *)&v7 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  *((_BYTE *)this + 40) = 0;
  *((_QWORD *)this + 6) = 0;
}

void sub_18408C9E0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  std::__shared_weak_count *v4;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  *v1 = &off_1E14E5838;
  v4 = (std::__shared_weak_count *)v1[2];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  _Unwind_Resume(a1);
}

void ___ZN25TransportConnectionObjCPP4readEjjU13block_pointerFvP11objc_objectb13CFStreamErrorPU32objcproto21OS_nw_content_context8NSObjectE_block_invoke_2(uint64_t a1, uint64_t a2, dispatch_data_t data2, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  NSObject *concat;
  uint64_t v13;
  void (*v14)(_QWORD *, uint64_t, NSObject *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v15;
  _QWORD *v16;

  v11 = *(_QWORD *)(a1 + 32);
  concat = dispatch_data_create_concat(*(dispatch_data_t *)(v11 + 48), data2);
  dispatch_release(*(dispatch_object_t *)(v11 + 48));
  *(_QWORD *)(v11 + 48) = 0;
  v13 = *(_QWORD *)(a1 + 40);
  if (v13)
  {
    v14 = *(void (**)(_QWORD *, uint64_t, NSObject *, uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 8);
    v15 = *(_QWORD *)(v13 + 16);
    v16 = (_QWORD *)(v13 + (v15 >> 1));
    if ((v15 & 1) != 0)
      v14 = *(void (**)(_QWORD *, uint64_t, NSObject *, uint64_t, uint64_t, uint64_t, uint64_t))(*v16 + v14);
    v14(v16, 1, concat, a4, a5, a6, a2);
  }
  dispatch_release(concat);
}

uint64_t __copy_helper_block_e8_40c124_ZTS18SmartBlockWithArgsIJbPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorPU32objcproto21OS_nw_content_contextS0_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c124_ZTS18SmartBlockWithArgsIJbPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorPU32objcproto21OS_nw_content_contextS0_EE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*> *,SmartBlockWithArgs<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::Deleter,std::allocator<BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,CFStreamError> *,SmartBlockWithArgs<BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<BOOL,CFStreamError>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t BlockHolderVar<BOOL,CFStreamError>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

CFStringRef Host::copyDebugDesc(Host *this)
{
  char *v1;
  const __CFAllocator *v2;

  v1 = (char *)this - 16;
  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFHost %p>"), v1);
}

CFTypeRef Host::startInfoResolution(Host *this, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4)
{
  char *v7;
  const void *Value;
  CFTypeRef v9;
  CFTypeID v10;
  int ExactString;
  const __CFString *v13;
  _OWORD *v14;
  HostLookup_Master *v15;
  uint64_t *v16;
  __CFString *v17;
  _OWORD *Instance;
  HostLookup_Master *v19;
  const __CFString *v20;
  __CFString *v21;
  const __CFData *v22;
  _OWORD *v23;
  _OWORD *v24;
  _OWORD *v25;
  CFTypeRef v26;
  CFTypeRef v27;
  __CFString *v28;
  _BOOL4 isDottedIP;
  _OWORD *v30;
  uint64_t v31;
  const void *v32;
  void *v33;
  CFRunLoopRef Current;
  _OWORD *v35;
  __CFString *v36;
  CFTypeRef cf;

  v7 = (char *)this - 16;
  CFRetain((char *)this - 16);
  CFRetain(v7);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2))
    goto LABEL_3;
  if (*((_QWORD *)this + 17))
    goto LABEL_3;
  CFGetAllocator(v7);
  ExactString = _findExactString(a2, 0xAu);
  if (!HostBase::calculateWantsLocked((uint64_t)this, ExactString, (CFIndex *)&v36))
    goto LABEL_3;
  if (ExactString <= 489912819)
  {
    if (ExactString == 485767616 || ExactString == 487766494 || ExactString == 488815081)
    {
      v17 = v36;
      if (v36)
      {
        if (HostLookup::Class(void)::sOnce_HostLookup != -1)
          dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_8707);
        Instance = (_OWORD *)_CFRuntimeCreateInstance();
        v15 = (HostLookup_Master *)Instance;
        if (Instance)
        {
          Instance[1] = 0u;
          v15 = (HostLookup_Master *)(Instance + 1);
          Instance[3] = 0u;
          Instance[4] = 0u;
          Instance[2] = 0u;
        }
        v19 = v15;
        v20 = a2;
        v21 = v17;
        goto LABEL_41;
      }
    }
    goto LABEL_57;
  }
  if (ExactString <= 492935701)
  {
    if (ExactString == 489912820)
    {
      if (HostLookup::Class(void)::sOnce_HostLookup != -1)
        dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_8707);
      v24 = (_OWORD *)_CFRuntimeCreateInstance();
      v15 = (HostLookup_Master *)v24;
      if (v24)
      {
        v24[1] = 0u;
        v15 = (HostLookup_Master *)(v24 + 1);
        v24[3] = 0u;
        v24[4] = 0u;
        v24[2] = 0u;
      }
      v16 = &_kCFHostMasterAddressLookupString;
      goto LABEL_40;
    }
    if (ExactString == 491919885)
    {
      if (HostLookup::Class(void)::sOnce_HostLookup != -1)
        dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_8707);
      v14 = (_OWORD *)_CFRuntimeCreateInstance();
      v15 = (HostLookup_Master *)v14;
      if (v14)
      {
        v14[1] = 0u;
        v15 = (HostLookup_Master *)(v14 + 1);
        v14[3] = 0u;
        v14[4] = 0u;
        v14[2] = 0u;
      }
      v16 = &kCFHostAddressesString;
LABEL_40:
      v20 = (const __CFString *)*v16;
      v21 = v36;
      v19 = v15;
LABEL_41:
      HostLookup_Master::HostLookup_Master(v19, v20, v21, a3);
      goto LABEL_42;
    }
LABEL_57:
    v15 = (HostLookup_Master *)*((_QWORD *)this + 17);
    if (!v15)
      goto LABEL_3;
    goto LABEL_61;
  }
  if (ExactString != 492935702)
  {
    if (ExactString != 494041629)
      goto LABEL_57;
    v22 = (const __CFData *)cf;
    if (cf)
    {
      if (HostLookup::Class(void)::sOnce_HostLookup != -1)
        dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_8707);
      v23 = (_OWORD *)_CFRuntimeCreateInstance();
      v15 = (HostLookup_Master *)v23;
      if (v23)
      {
        v23[1] = 0u;
        v15 = (HostLookup_Master *)(v23 + 1);
        v23[4] = 0u;
        v23[5] = 0u;
        v23[2] = 0u;
        v23[3] = 0u;
      }
      HostLookup_ReachabilityFixed::HostLookup_ReachabilityFixed(v15, v22);
    }
    else
    {
      v28 = v36;
      if (!v36)
        goto LABEL_57;
      isDottedIP = HostLookup_ReachabilityFixed::isDottedIP(v36, v13);
      if (HostLookup::Class(void)::sOnce_HostLookup != -1)
        dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_8707);
      if (isDottedIP)
      {
        v30 = (_OWORD *)_CFRuntimeCreateInstance();
        v15 = (HostLookup_Master *)v30;
        if (v30)
        {
          v30[1] = 0u;
          v15 = (HostLookup_Master *)(v30 + 1);
          v30[4] = 0u;
          v30[5] = 0u;
          v30[2] = 0u;
          v30[3] = 0u;
        }
        HostLookup_ReachabilityFixed::HostLookup_ReachabilityFixed(v15, v28);
      }
      else
      {
        v35 = (_OWORD *)_CFRuntimeCreateInstance();
        v15 = (HostLookup_Master *)v35;
        if (v35)
        {
          v35[1] = 0u;
          v15 = (HostLookup_Master *)(v35 + 1);
          v35[2] = 0u;
          v35[3] = 0u;
        }
        HostLookup_Reachability::HostLookup_Reachability(v15, v28);
      }
    }
LABEL_42:
    *((_QWORD *)this + 17) = v15;
    if (!v15)
      goto LABEL_3;
    goto LABEL_61;
  }
  if (HostLookup::Class(void)::sOnce_HostLookup != -1)
    dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_8707);
  v25 = (_OWORD *)_CFRuntimeCreateInstance();
  v15 = (HostLookup_Master *)v25;
  if (v25)
  {
    v25[1] = 0u;
    v15 = (HostLookup_Master *)(v25 + 1);
    v25[3] = 0u;
    v25[4] = 0u;
    v25[2] = 0u;
  }
  v26 = cf;
  *(_QWORD *)v15 = &off_1E14E4B50;
  *((_QWORD *)v15 + 1) = &unk_1E14E4BA8;
  *((_QWORD *)v15 + 2) = 0;
  *((_QWORD *)v15 + 3) = CFRetain(CFSTR("kCFHostNames"));
  *(_QWORD *)v15 = &off_1E14E80D0;
  *((_QWORD *)v15 + 1) = &unk_1E14E8128;
  if (v26)
    v27 = CFRetain(v26);
  else
    v27 = 0;
  *((_QWORD *)v15 + 5) = v27;
  *((_QWORD *)v15 + 6) = a3;
  *((_QWORD *)this + 17) = v15;
LABEL_61:
  v31 = (*(uint64_t (**)(HostLookup_Master *, Host *))(*(_QWORD *)v15 + 56))(v15, this);
  if (v31)
  {
    v32 = (const void *)v31;
    CFRelease((CFTypeRef)(*((_QWORD *)this + 17) - 16));
    *((_QWORD *)this + 17) = 0;
    HostBase::setInfoLocked((CFMutableDictionaryRef *)this, a2, v32);
  }
  else if (*((_QWORD *)this + 13))
  {
    v33 = *(void **)(*((_QWORD *)this + 17) + 16);
    if (v33)
      _CFTypeScheduleOnMultipleRunLoops(v33, *((const __CFArray **)this + 15));
  }
  else
  {
    HostBase::unlock(this);
    Current = CFRunLoopGetCurrent();
    (*(void (**)(Host *, CFRunLoopRef, const __CFString *))(*(_QWORD *)this + 72))(this, Current, CFSTR("_kCFHostBlockingMode"));
    CFRetain(v7);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    ++*((_QWORD *)this + 2);
    for (; *((_QWORD *)this + 17); ++*((_QWORD *)this + 2))
    {
      HostBase::unlock(this);
      CFRunLoopRunInMode(CFSTR("_kCFHostBlockingMode"), 1.79769313e308, 1u);
      CFRetain(v7);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    }
    HostBase::unlock(this);
    (*(void (**)(Host *, CFRunLoopRef, const __CFString *))(*(_QWORD *)this + 80))(this, Current, CFSTR("_kCFHostBlockingMode"));
    CFRetain(v7);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    ++*((_QWORD *)this + 2);
  }
LABEL_3:
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2);
  v9 = Value;
  if (Value)
  {
    v10 = CFGetTypeID(Value);
    if (v10 == CFErrorGetTypeID())
      v9 = CFRetain(v9);
    else
      v9 = 0;
  }
  HostBase::unlock(this);
  CFRelease(v7);
  return v9;
}

void sub_18408D1AC(_Unwind_Exception *a1)
{
  HostLookup *v1;

  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

void Host::cancelInfoResolution(Host *this, const __CFString *a2)
{
  char **v3;
  char *v4;

  HostBase::cancelInfoResolution(this, a2);
  if (*((_QWORD *)this + 17))
  {
    CFRetain((char *)this - 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    ++*((_QWORD *)this + 2);
    v3 = (char **)*((_QWORD *)this + 17);
    if (v3)
    {
      v4 = v3[2];
      if (v4)
      {
        _CFTypeUnscheduleFromMultipleRunLoops(v4, *((const __CFArray **)this + 15));
        _CFTypeInvalidate(v3[2]);
        CFRelease(v3[2]);
        v3[2] = 0;
        (*((void (**)(char **))*v3 + 8))(v3);
        v3 = (char **)*((_QWORD *)this + 17);
      }
      CFRelease(v3 - 2);
      *((_QWORD *)this + 17) = 0;
    }
    HostBase::unlock(this);
  }
}

uint64_t Host::scheduleWithRunLoop(Host *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t result;
  uint64_t v7;
  void *v8;

  result = HostBase::scheduleWithRunLoop(this, a2, a3);
  if ((_DWORD)result)
  {
    if (*((_QWORD *)this + 17))
    {
      CFRetain((char *)this - 16);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
      ++*((_QWORD *)this + 2);
      v7 = *((_QWORD *)this + 17);
      if (v7)
      {
        v8 = *(void **)(v7 + 16);
        if (v8)
          _CFTypeScheduleOnRunLoop(v8, (uint64_t)a2, (uint64_t)a3);
      }
      HostBase::unlock(this);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFIndex Host::unscheduleFromRunLoop(Host *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFIndex result;
  uint64_t v7;
  void *v8;

  result = HostBase::unscheduleFromRunLoop(this, a2, a3);
  if ((_DWORD)result)
  {
    if (*((_QWORD *)this + 17))
    {
      CFRetain((char *)this - 16);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
      ++*((_QWORD *)this + 2);
      v7 = *((_QWORD *)this + 17);
      if (v7)
      {
        v8 = *(void **)(v7 + 16);
        if (v8)
          _CFTypeUnscheduleFromRunLoop(v8, (uint64_t)a2, (uint64_t)a3);
      }
      HostBase::unlock(this);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void Host::clientAttached(Host *this, int a2)
{
  uint64_t v3;
  void *v4;
  char **v5;
  char *v6;

  if (a2)
  {
    if (!*((_QWORD *)this + 13))
    {
      v3 = *((_QWORD *)this + 17);
      if (v3)
      {
        v4 = *(void **)(v3 + 16);
        if (v4)
          _CFTypeScheduleOnMultipleRunLoops(v4, *((const __CFArray **)this + 15));
      }
    }
  }
  else
  {
    v5 = (char **)*((_QWORD *)this + 17);
    if (v5)
    {
      v6 = v5[2];
      if (v6)
      {
        _CFTypeUnscheduleFromMultipleRunLoops(v6, *((const __CFArray **)this + 15));
        _CFTypeInvalidate(v5[2]);
        CFRelease(v5[2]);
        v5[2] = 0;
        (*((void (**)(char **))*v5 + 8))(v5);
        v5 = (char **)*((_QWORD *)this + 17);
      }
      CFRelease(v5 - 2);
      *((_QWORD *)this + 17) = 0;
    }
  }
}

void `non-virtual thunk to'Host::~Host(Host *this)
{
  Host::~Host((Host *)((char *)this - 8));
}

{
  Host::~Host((Host *)((char *)this - 8));
}

void Host::~Host(Host *this)
{
  char **v2;
  char *v3;

  *(_QWORD *)this = &off_1E14EF768;
  *((_QWORD *)this + 1) = &unk_1E14EF7D8;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  v2 = (char **)*((_QWORD *)this + 17);
  if (v2)
  {
    v3 = v2[2];
    if (v3)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v3, *((const __CFArray **)this + 15));
      _CFTypeInvalidate(v2[2]);
      CFRelease(v2[2]);
      v2[2] = 0;
      (*((void (**)(char **))*v2 + 8))(v2);
      v2 = (char **)*((_QWORD *)this + 17);
    }
    CFRelease(v2 - 2);
    *((_QWORD *)this + 17) = 0;
  }
  HostBase::unlock(this);
  HostBase::~HostBase(this);
}

void sub_18408D4C4(_Unwind_Exception *a1)
{
  HostBase *v1;

  HostBase::~HostBase(v1);
  _Unwind_Resume(a1);
}

void Host::Host(Host *this, const __CFString *a2, const void *a3, ...)
{
  _QWORD *v6;
  va_list va;

  va_start(va, a3);
  HostBase::HostBase(this, 0);
  *v6 = &off_1E14EF768;
  v6[1] = &unk_1E14EF7D8;
  CFRetain(v6 - 2);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  HostBase::setInfoLocked((CFMutableDictionaryRef *)this, a2, a3);
  HostBase::setInfoLocked((CFMutableDictionaryRef *)this, va);
  HostBase::unlock(this);
}

void sub_18408D56C(_Unwind_Exception *a1)
{
  HostBase *v1;

  HostBase::~HostBase(v1);
  _Unwind_Resume(a1);
}

void Host::performCallback(Host *this, const __CFString *a2)
{
  char **v4;
  char *v5;

  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  v4 = (char **)*((_QWORD *)this + 17);
  if (v4)
  {
    v5 = v4[2];
    if (v5)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v5, *((const __CFArray **)this + 15));
      _CFTypeInvalidate(v4[2]);
      CFRelease(v4[2]);
      v4[2] = 0;
      (*((void (**)(char **))*v4 + 8))(v4);
      v4 = (char **)*((_QWORD *)this + 17);
    }
    CFRelease(v4 - 2);
    *((_QWORD *)this + 17) = 0;
  }
  HostBase::unlock(this);
  HostBase::invokeCallback(this, a2);
}

void Host::performCallback(Host *this, const __CFString *a2, const void *a3)
{
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  HostBase::setInfoLocked((CFMutableDictionaryRef *)this, a2, a3);
  HostBase::unlock(this);
  Host::performCallback(this, a2);
}

CFStringRef HostLookup::copyDebugDesc(HostLookup *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<HostLookup@%p> { %p }"), this, *((_QWORD *)this + 2));
}

void HostLookup::prepareLookup(HostLookup *this, Host *a2)
{
  abort();
}

void `non-virtual thunk to'HostLookup::~HostLookup(HostLookup *this)
{
  HostLookup::~HostLookup((HostLookup *)((char *)this - 8));
}

{
  HostLookup::~HostLookup((HostLookup *)((char *)this - 8));
}

void HostLookup::~HostLookup(HostLookup *this)
{
  char *v2;
  const void *v3;

  *(_QWORD *)this = &off_1E14E4B50;
  *((_QWORD *)this + 1) = &unk_1E14E4BA8;
  v2 = (char *)*((_QWORD *)this + 2);
  if (v2)
  {
    _CFTypeInvalidate(v2);
    v3 = (const void *)*((_QWORD *)this + 2);
    if (v3)
      CFRelease(v3);
  }
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_18408D748(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ___ZN10HostLookup5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "HostLookup");
  HostLookup::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_18408D7A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void sub_18408D854(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NSURLStorageURLCacheDB;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_18408E7E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t SQLHostForDeleteCallback(void *a1, int a2, char **a3, char **a4)
{
  id *v6;
  char *v7;
  void *v8;
  const char *v9;
  const __CFString *Property;
  CFURLCacheFS *FS2;
  CFURLCacheFS *v12;

  v6 = a1;
  if (v6)
  {
    if (a2 == 1)
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", *a3, 4);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6[17], "addObject:", v8);
LABEL_8:

      goto LABEL_9;
    }
    if (a2 == 2)
    {
      v7 = *a3;
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", a3[1], 4);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6[17], "addObject:", v8);
      if (v7)
      {
        Property = (const __CFString *)objc_getProperty(v6, v9, 160, 1);
        FS2 = _CFURLCacheCreateFS2(Property);
        v12 = FS2;
        if (FS2)
        {
          _CFURLCacheFSPurgeItemFromFileSystemStore((uint64_t)FS2, v7);
          (*(void (**)(CFURLCacheFS *))(*(_QWORD *)v12 + 8))(v12);
        }
      }
      goto LABEL_8;
    }
  }
LABEL_9:

  return 0;
}

void sub_18408E904(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t SQLdeleteSinceDateCallback(void *a1, int a2, char **a3, char **a4)
{
  void *v6;
  const char *v7;
  void *v8;
  char *v9;
  const __CFString *Property;
  CFURLCacheFS *FS2;
  CFURLCacheFS *v12;

  v6 = a1;
  v8 = v6;
  if (v6)
  {
    if (a2 == 1)
    {
      v9 = *a3;
      if (v9)
      {
        Property = (const __CFString *)objc_getProperty(v6, v7, 160, 1);
        FS2 = _CFURLCacheCreateFS2(Property);
        v12 = FS2;
        if (FS2)
        {
          _CFURLCacheFSPurgeItemFromFileSystemStore((uint64_t)FS2, v9);
          (*(void (**)(CFURLCacheFS *))(*(_QWORD *)v12 + 8))(v12);
        }
      }
    }
  }

  return 0;
}

void sub_18408E9B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __logAppleATSViolation_block_invoke_22(uint64_t a1)
{
  SecTrustReportNetworkingAnalytics();
  xpc_release(*(xpc_object_t *)(a1 + 32));
}

BOOL atsDictionaryClientIDHasPrefix(const __CFDictionary *a1, const __CFString *a2)
{
  const __CFString *Value;
  const __CFString *v4;
  CFTypeID TypeID;
  _BOOL8 result;

  Value = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("_kCFNetworkATSClientID"));
  result = 0;
  if (Value)
  {
    v4 = Value;
    TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(v4))
    {
      if (CFStringHasPrefix(v4, a2))
        return 1;
    }
  }
  return result;
}

uint64_t ___ZL14isMediaProcessv_block_invoke()
{
  uint64_t result;

  result = _CFGetProgname();
  if (result)
  {
    result = *(_QWORD *)result;
    if (result)
    {
      result = strcmp((const char *)result, "mediaserverd");
      isMediaProcess(void)::isMediaProcess = (_DWORD)result == 0;
    }
  }
  return result;
}

uint64_t ___ZL15isWebkitProcessv_block_invoke()
{
  uint64_t result;

  result = _CFGetProgname();
  if (result)
  {
    result = *(_QWORD *)result;
    if (result)
    {
      result = strncmp((const char *)result, "com.apple.WebKit", 0x10uLL);
      isWebkitProcess(void)::isWebkitProcess = (_DWORD)result == 0;
    }
  }
  return result;
}

BOOL StrictSecurityPolicy::clientIsWebKit(StrictSecurityPolicy *this)
{
  if ((_BYTE)this)
    return 1;
  if (isWebkitProcess(void)::onceToken != -1)
    dispatch_once(&isWebkitProcess(void)::onceToken, &__block_literal_global_86_9022);
  return isWebkitProcess(void)::isWebkitProcess != 0;
}

BOOL StrictSecurityPolicy::clientIsMediaserver(StrictSecurityPolicy *this)
{
  if ((_BYTE)this)
    return 1;
  if (isMediaProcess(void)::onceToken != -1)
    dispatch_once(&isMediaProcess(void)::onceToken, &__block_literal_global_88);
  return isMediaProcess(void)::isMediaProcess != 0;
}

CFDataRef ___ZN13ATSTLSCiphers25DefaultNonPFSCipherSuitesEv_block_invoke()
{
  CFDataRef result;

  result = CFDataCreateWithBytesNoCopy(0, kATSv1NonPFSCiphers, 50, 0);
  ATSTLSCiphers::DefaultNonPFSCipherSuites(void)::cipherData = (uint64_t)result;
  return result;
}

void StrictSecurityPolicy::_fallbackToATSMode(StrictSecurityPolicy *this, const char *cStr)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  CFStringRef v6;

  if ((*((_BYTE *)this + 32) & 1) == 0)
    *((_BYTE *)this + 32) |= 1u;
  if (StrictSecurityPolicy::ATSLogLevel(void)::logATSOnce != -1)
    dispatch_once(&StrictSecurityPolicy::ATSLogLevel(void)::logATSOnce, &__block_literal_global_31);
  if (StrictSecurityPolicy::ATSLogLevel(void)::atslogLevel)
  {
    v6 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x600u);
    v3 = (std::__shared_weak_count *)operator new();
    v3->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    v3->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
    v3->__shared_weak_owners_ = 0;
    v3[1].__vftable = (std::__shared_weak_count_vtbl *)v6;
    CFLog();
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_18408ECE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN20StrictSecurityPolicy19parseCIDRExceptionsEv_block_invoke(uint64_t a1, __CFString *cf)
{
  CFTypeID v4;
  const char *v5;
  const char *v6;
  size_t v7;
  int v8;
  char v9;
  int v10;
  int v11;
  unint64_t v12;
  size_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  BOOL v19;
  UInt8 *v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  CFDataRef v24;
  CFDataRef v25;
  __CFDictionary *Mutable;
  _QWORD v27[5];
  UInt8 v28[8];
  _QWORD v29[2];
  int v30;
  UInt8 bytes[8];
  uint64_t v32;
  uint64_t v33;
  int v34;
  void (**__dst)(AutoScalar *__hidden);
  void *value;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID() || CFStringFind(cf, CFSTR("/"), 0).location == -1)
    return;
  *(_QWORD *)bytes = 0;
  v32 = 0;
  v34 = 0;
  v33 = 0;
  v5 = (const char *)-[__CFString UTF8String](cf, "UTF8String");
  if (!v5)
    goto LABEL_75;
  v6 = v5;
  v7 = strlen(v5);
  if (v7)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = v7;
    while (1)
    {
      v14 = v6[v12];
      v15 = (v14 - 47);
      if (v15 > 0x37)
        goto LABEL_21;
      if (((1 << (v14 - 47)) & 0xFC000000FC0000) != 0)
      {
        if (v11 || v13 <= v12)
          goto LABEL_75;
        v11 = 0;
        ++v8;
        goto LABEL_11;
      }
      if (v14 != 47)
        break;
      if (!v12 || v13 <= v12 || v11 && v6[v12 - 1] == 46)
        goto LABEL_75;
      if (v12 >= 3 && v10 && v6[v12 - 1] == 58)
      {
        v13 = v12;
        if (v6[v12 - 2] != 58)
          goto LABEL_75;
      }
      else
      {
        v13 = v12;
      }
LABEL_11:
      if (v7 == ++v12)
        goto LABEL_40;
    }
    if (v15 == 11)
    {
      if (v11 || v13 <= v12)
        goto LABEL_75;
      ++v10;
      if (v12 && v6[v12 - 1] == 58)
      {
        if ((v9 & 1) != 0)
          goto LABEL_75;
        v11 = 0;
        v9 = 1;
      }
      else
      {
        v11 = 0;
      }
      goto LABEL_11;
    }
LABEL_21:
    if (v14 == 46)
    {
      if (v8 | v10 || !v12 || v13 <= v12)
        goto LABEL_75;
      v10 = 0;
      v8 = 0;
      ++v11;
    }
    else if ((v14 - 48) > 9)
    {
      goto LABEL_75;
    }
    goto LABEL_11;
  }
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v13 = 0;
LABEL_40:
  if (v13 >= v7)
    goto LABEL_75;
  *(_QWORD *)bytes = 0;
  v32 = 0;
  v34 = 0;
  v33 = 0;
  v29[0] = 0;
  v29[1] = 0;
  *(_QWORD *)v28 = 0;
  v30 = 0;
  v16 = strtol(&v6[v13 + 1], 0, 0);
  if (v16 < 0)
    goto LABEL_75;
  v17 = v16;
  if (*__error() == 22)
    goto LABEL_75;
  if (v8 | v10)
  {
    if ((unint64_t)v17 <= 0x80)
    {
      *(_WORD *)v28 = 7708;
      *(_WORD *)bytes = 7708;
      if (v13 <= 0x26)
      {
        memcpy(&__dst, v6, v13);
        if (!(v9 & 1 | (v10 > 6)))
        {
          if (v13 - 37 < 0xFFFFFFFFFFFFFFD8)
            goto LABEL_75;
          *((_BYTE *)&__dst + v13) = 58;
          *((_BYTE *)&__dst + v13 + 1) = 58;
          v13 += 2;
        }
        *((_BYTE *)&__dst + v13) = 0;
        if (inet_pton(30, (const char *)&__dst, &v32) == 1)
        {
          v20 = (UInt8 *)v29;
LABEL_62:
          if (v17 >= 1)
          {
            v21 = v17;
            do
            {
              v23 = v21 - 8;
              v22 = (unint64_t)v21 > 8;
              if (v21 >= 8)
                v21 = 8;
              *v20++ = cidrStringToSubnetAndMask(char const*,sockaddr_in_4_6 *,sockaddr_in_4_6 *,unsigned char *)::bb[v21 - 1];
              v21 = v23;
            }
            while (v22);
          }
          v24 = CFDataCreate(0, bytes, 28);
          v25 = CFDataCreate(0, v28, 28);
          Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          CFDictionaryAddValue(Mutable, CFSTR("NSParsedCIDRAddressKey"), v24);
          CFDictionaryAddValue(Mutable, CFSTR("NSParsedCIDRMaskKey"), v25);
          AutoScalar::AutoScalar((AutoScalar *)&__dst, (const __CFAllocator *)v17);
          CFDictionaryAddValue(Mutable, CFSTR("NSParsedCIDRPrefixKey"), value);
          __dst = &off_1E14E47E8;
          if (value)
            CFRelease(value);
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), cf, Mutable);
          if (v24)
            CFRelease(v24);
          if (v25)
            CFRelease(v25);
          if (Mutable)
            CFRelease(Mutable);
          return;
        }
      }
    }
  }
  else if ((unint64_t)v17 <= 0x20)
  {
    *(_WORD *)v28 = 528;
    *(_WORD *)bytes = 528;
    if (v13 <= 0xE)
    {
      memcpy(&__dst, v6, v13);
      if (v11 > 2 || v13 == 14)
      {
        v18 = v13;
      }
      else
      {
        do
        {
          v18 = v13 + 2;
          *(_WORD *)((char *)&__dst + v13) = 12334;
          if (v11 > 1)
            break;
          ++v11;
          v19 = v13 >= 0xC;
          v13 += 2;
        }
        while (!v19);
      }
      *((_BYTE *)&__dst + v18) = 0;
      if (inet_pton(2, (const char *)&__dst, &bytes[4]) == 1)
      {
        v20 = &v28[4];
        goto LABEL_62;
      }
    }
  }
LABEL_75:
  v27[0] = MEMORY[0x1E0C809B0];
  v27[1] = 3221225472;
  v27[2] = ___ZN20StrictSecurityPolicy19parseCIDRExceptionsEv_block_invoke_2;
  v27[3] = &unk_1E14FE118;
  v27[4] = cf;
  if (_ZZZN20StrictSecurityPolicy19parseCIDRExceptionsEvEUb_E9onceToken != -1)
    dispatch_once(&_ZZZN20StrictSecurityPolicy19parseCIDRExceptionsEvEUb_E9onceToken, v27);
}

void sub_18408F1EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void ___ZN20StrictSecurityPolicy19parseCIDRExceptionsEv_block_invoke_2(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = 138543362;
    v5 = v3;
    _os_log_fault_impl(&dword_183ECA000, v2, OS_LOG_TYPE_FAULT, "App Transport Security exception %{public}@ is not a valid CIDR notation.", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t ___ZNK20StrictSecurityPolicy22logInsecureLoadFailureEPK7__CFURL_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 952;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t isLocalIPAddress(CFStringRef theString)
{
  NSObject *host_with_numeric_port;
  const sockaddr *address;
  int sa_family;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  BOOL v9;
  nw_parameters_t v11;
  void *evaluator_for_endpoint;
  void *v13;
  uint64_t is_local;
  const __CFAllocator *allocator;
  uint64_t v17;
  void *ptr;
  UInt8 v19[1024];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v17 = 1023;
  ptr = _CFStringGetOrCreateCString(allocator, theString, v19, &v17, 0x8000100u);
  host_with_numeric_port = nw_endpoint_create_host_with_numeric_port();
  if (nw_endpoint_get_type(host_with_numeric_port) != nw_endpoint_type_address)
    goto LABEL_26;
  address = nw_endpoint_get_address(host_with_numeric_port);
  sa_family = address->sa_family;
  if (sa_family == 30)
  {
    if (address->sa_len < 0x1Cu)
      goto LABEL_26;
    if (*(_DWORD *)&address->sa_data[6])
    {
      if (*(_DWORD *)&address->sa_data[6] == 254)
      {
        if ((*(_DWORD *)&address->sa_data[6] & 0xC000) != 0x8000)
          goto LABEL_26;
      }
      else if ((*(_DWORD *)&address->sa_data[6] & 0xFE) != 0xFC)
      {
        goto LABEL_26;
      }
    }
    else if (*(_DWORD *)&address->sa_data[10]
           || *(_DWORD *)&address[1].sa_len
           || *(_DWORD *)&address[1].sa_data[2] != 0x1000000)
    {
      goto LABEL_26;
    }
LABEL_42:
    is_local = 1;
    if (!host_with_numeric_port)
      goto LABEL_35;
    goto LABEL_34;
  }
  if (sa_family == 2 && address->sa_len >= 0x10u)
  {
    v4 = bswap32(*(_DWORD *)&address->sa_data[2]);
    v5 = v4 & 0xFF000000;
    if ((v4 & 0xFF000000) == 0x7F000000)
      goto LABEL_42;
    v6 = v4 & 0xFFFF0000;
    v7 = v4 & 0xFFF00000;
    v8 = v6 == -1062731776 || v7 == -1408237568;
    v9 = v8 || v6 == -1442971648;
    if (v9 || v5 == 167772160)
      goto LABEL_42;
  }
LABEL_26:
  v11 = nw_parameters_create();
  evaluator_for_endpoint = (void *)nw_path_create_evaluator_for_endpoint();
  v13 = (void *)nw_path_evaluator_copy_path();
  if ((nw_path_is_direct() & 1) != 0)
  {
    is_local = 1;
    if (!v13)
      goto LABEL_29;
    goto LABEL_28;
  }
  is_local = nw_path_is_local();
  if (v13)
LABEL_28:
    nw_release(v13);
LABEL_29:
  if (evaluator_for_endpoint)
    nw_release(evaluator_for_endpoint);
  if (v11)
    nw_release(v11);
  if (host_with_numeric_port)
LABEL_34:
    nw_release(host_with_numeric_port);
LABEL_35:
  if (ptr && v19 != ptr)
    CFAllocatorDeallocate(allocator, ptr);
  return is_local;
}

void sub_18408F55C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  void *v11;
  void *v12;

  if (v12)
    nw_release(v12);
  if (ptr)
  {
    if (v11 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  _Unwind_Resume(exception_object);
}

uint64_t exceptionAllowsInsecureLoad(const __CFDictionary *a1)
{
  const void *Value;
  const void **v3;
  const void *v4;
  CFTypeID v5;
  const void *v6;
  const void *v7;
  CFTypeID v8;
  const void *v9;
  const void *v10;
  CFTypeID v11;
  uint64_t result;
  uint64_t v13;
  CFTypeID v14;
  __int16 v15[8];
  uint8_t v16[16];
  uint8_t v17[16];
  uint8_t buf[16];

  Value = CFDictionaryGetValue(a1, CFSTR("NSExceptionAllowsInsecureHTTPLoads"));
  v3 = (const void **)MEMORY[0x1E0C9AE50];
  if (Value)
  {
    v4 = Value;
    v5 = CFGetTypeID(Value);
    if (v5 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
    }
    if (*v3 == v4)
      return 1;
  }
  v6 = CFDictionaryGetValue(a1, CFSTR("NSThirdPartyExceptionAllowsInsecureHTTPLoads"));
  if (v6)
  {
    v7 = v6;
    v8 = CFGetTypeID(v6);
    if (v8 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v17 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v17, 2u);
    }
    if (*v3 == v7)
      return 1;
  }
  v9 = CFDictionaryGetValue(a1, CFSTR("NSTemporaryExceptionAllowsInsecureHTTPLoads"));
  if (v9)
  {
    v10 = v9;
    v11 = CFGetTypeID(v9);
    if (v11 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v16 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v16, 2u);
    }
    if (*v3 == v10)
      return 1;
  }
  result = (uint64_t)CFDictionaryGetValue(a1, CFSTR("NSTemporaryThirdPartyExceptionAllowsInsecureHTTPLoads"));
  if (result)
  {
    v13 = result;
    v14 = CFGetTypeID((CFTypeRef)result);
    if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      v15[0] = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)v15, 2u);
    }
    return *v3 == (const void *)v13;
  }
  return result;
}

const void *StrictSecurityPolicy::getCIDRException(StrictSecurityPolicy *a1, uint64_t a2, char a3)
{
  void *v4;
  const __CFString *v5;
  const void *Exception;
  _QWORD v8[7];
  char v9;
  _QWORD v10[3];
  char v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x2020000000;
  v11 = 0;
  v4 = (void *)*((_QWORD *)a1 + 3);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN20StrictSecurityPolicy16getCIDRExceptionEPK15sockaddr_in_4_6h_block_invoke;
  v8[3] = &unk_1E14FA4B0;
  v9 = a3;
  v8[5] = &v12;
  v8[6] = a2;
  v8[4] = v10;
  objc_msgSend(v4, "enumerateKeysAndObjectsUsingBlock:", v8);
  v5 = (const __CFString *)v13[3];
  if (v5)
    Exception = StrictSecurityPolicy::getException(a1, v5);
  else
    Exception = 0;
  _Block_object_dispose(v10, 8);
  _Block_object_dispose(&v12, 8);
  return Exception;
}

void sub_18408F8F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

void KerberosAccountBroker::~KerberosAccountBroker(KerberosAccountBroker *this)
{
  uint64_t v2;

  KerberosAccountBroker::~KerberosAccountBroker(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint8_t v2[16];

  *(_QWORD *)this = off_1E14EBF78;
  *((_QWORD *)this + 3) = &unk_1E14EBFC8;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Destroying global Kerberos Account Broker", v2, 2u);
  }
  *((_QWORD *)this + 4) = &off_1E14EA548;
  CFRelease(*((CFTypeRef *)this + 5));
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

CFStringRef KerberosAccountBroker::copyDebugDesc(KerberosAccountBroker *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<KerberosAccountBroker@%p>"), this);
}

BOOL KerberosAccountBroker::initialize(KerberosAccountBroker *this, const __CFString *cf)
{
  const __CFAllocator *v4;
  CFStringRef Copy;
  dispatch_queue_t v6;

  if (cf)
  {
    v4 = CFGetAllocator(cf);
    Copy = CFStringCreateCopy(v4, cf);
  }
  else
  {
    Copy = 0;
  }
  *((_QWORD *)this + 7) = Copy;
  v6 = dispatch_queue_create("com.apple.kerberosaccountbroker.workqueue", 0);
  *((_QWORD *)this + 6) = v6;
  return v6 != 0;
}

void `non-virtual thunk to'KerberosAccountBroker::~KerberosAccountBroker(KerberosAccountBroker *this)
{
  KerberosAccountBroker::~KerberosAccountBroker((KerberosAccountBroker *)((char *)this - 24));
}

void `non-virtual thunk to'KerberosAccountBroker::~KerberosAccountBroker(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  KerberosAccountBroker::~KerberosAccountBroker((KerberosAccountBroker *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

uint64_t RetainableTypedDict<__CFURL const*,KerberosAccountStore *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA548;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<__CFURL const*,KerberosAccountStore *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA548;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

uint64_t KerberosAccountBroker::getKerberosAccountBroker(KerberosAccountBroker *this, NSURLSessionTask *a2)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN21KerberosAccountBroker24getKerberosAccountBrokerEP16NSURLSessionTask_block_invoke;
  block[3] = &unk_1E14FE118;
  block[4] = this;
  if (KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sOnce != -1)
    dispatch_once(&KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sOnce, block);
  return KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sKerberosAccountBroker;
}

void ___ZN21KerberosAccountBroker24getKerberosAccountBrokerEP16NSURLSessionTask_block_invoke(uint64_t a1)
{
  void *v1;
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  const __CFData *Value;
  const void *v5;
  char v6;
  const void *v7;
  KerberosAccountBroker *v8;
  uint64_t v9;
  double v10;
  double Helper_x8__HeimCredSetImpersonateBundle;
  uint64_t v12;
  const void *v13;

  v1 = *(void **)(a1 + 32);
  if (v1)
  {
    v2 = (const __CFDictionary *)objc_msgSend(v1, "_copySocketStreamProperties");
    v3 = v2;
    if (v2)
    {
      Value = (const __CFData *)CFDictionaryGetValue(v2, &unk_1EDCFBF68);
      v5 = CFDictionaryGetValue(v3, &unk_1EDCFBFA0);
      BundleUtilities::effectiveBundleID((BundleUtilities *)&v13, Value, v5);
      v6 = 0;
      v7 = v13;
      goto LABEL_6;
    }
  }
  else
  {
    v3 = 0;
  }
  v7 = 0;
  v6 = 1;
LABEL_6:
  v8 = (KerberosAccountBroker *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 64, 0);
  *((_OWORD *)v8 + 2) = 0u;
  *((_OWORD *)v8 + 3) = 0u;
  *(_OWORD *)v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  KerberosAccountBroker::KerberosAccountBroker(v8);
  KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sKerberosAccountBroker = v9;
  if (!(*(unsigned int (**)(uint64_t, const void *))(*(_QWORD *)v9 + 56))(v9, v7))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sKerberosAccountBroker
                                    + 48))(KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sKerberosAccountBroker);
    KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sKerberosAccountBroker = 0;
    if ((v6 & 1) != 0)
      goto LABEL_13;
    goto LABEL_12;
  }
  Helper_x8__HeimCredSetImpersonateBundle = gotLoadHelper_x8__HeimCredSetImpersonateBundle(v10);
  if (*(_QWORD *)(v12 + 3152))
    HeimCredSetImpersonateBundle_delayInitStub(Helper_x8__HeimCredSetImpersonateBundle);
  if ((v6 & 1) == 0)
LABEL_12:
    CFRelease(v3);
LABEL_13:
  if (v7)
    CFRelease(v7);
}

void sub_18408FE2C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void KerberosAccountBroker::KerberosAccountBroker(KerberosAccountBroker *this)
{
  const __CFAllocator *v2;
  CFMutableDictionaryRef Mutable;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = v2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14EBF78;
  *((_QWORD *)this + 3) = &unk_1E14EBFC8;
  *((_QWORD *)this + 4) = &off_1E14EA548;
  Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = Mutable;
}

void sub_18408FEEC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t KerberosAccountBroker::getKerberosAccountBrokerForApplication(KerberosAccountBroker *this, const __CFData *a2, const __CFString *a3)
{
  _QWORD v4[6];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN21KerberosAccountBroker38getKerberosAccountBrokerForApplicationEPK8__CFDataPK10__CFString_block_invoke;
  v4[3] = &__block_descriptor_48_e5_v8__0l;
  v4[4] = this;
  v4[5] = a2;
  if (KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sOnce != -1)
    dispatch_once(&KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sOnce, v4);
  return KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sKerberosAccountBroker;
}

void ___ZN21KerberosAccountBroker38getKerberosAccountBrokerForApplicationEPK8__CFDataPK10__CFString_block_invoke(uint64_t a1)
{
  const void *v1;
  KerberosAccountBroker *v2;
  uint64_t v3;
  double v4;
  double Helper_x8__HeimCredSetImpersonateBundle;
  uint64_t v6;
  const void *v7;

  BundleUtilities::effectiveBundleID((BundleUtilities *)&v7, *(CFDataRef *)(a1 + 32), *(CFTypeRef *)(a1 + 40));
  v1 = v7;
  v2 = (KerberosAccountBroker *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 64, 0);
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *(_OWORD *)v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  KerberosAccountBroker::KerberosAccountBroker(v2);
  KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sKerberosAccountBroker = v3;
  if ((*(unsigned int (**)(uint64_t, const void *))(*(_QWORD *)v3 + 56))(v3, v1))
  {
    Helper_x8__HeimCredSetImpersonateBundle = gotLoadHelper_x8__HeimCredSetImpersonateBundle(v4);
    if (*(_QWORD *)(v6 + 3152))
      HeimCredSetImpersonateBundle_delayInitStub(Helper_x8__HeimCredSetImpersonateBundle);
    if (v1)
      goto LABEL_5;
  }
  else
  {
    (*(void (**)(uint64_t))(*(_QWORD *)KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sKerberosAccountBroker
                                    + 48))(KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sKerberosAccountBroker);
    KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sKerberosAccountBroker = 0;
    if (v1)
LABEL_5:
      CFRelease(v1);
  }
}

void sub_184090028(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void KerberosAccountBroker::getKerberosCredentialForURL(_QWORD *a1, const void *a2, const void *a3, uint64_t a4)
{
  NSObject *v8;
  _QWORD v9[8];

  (*(void (**)(_QWORD *))(*a1 + 40))(a1);
  if (a3)
    CFRetain(a3);
  if (a2)
    CFRetain(a2);
  v8 = a1[6];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN21KerberosAccountBroker27getKerberosCredentialForURLEPK16_CFURLCredentialPK7__CFURLU13block_pointerFvS2_E_block_invoke;
  v9[3] = &unk_1E14FD590;
  v9[6] = a3;
  v9[7] = a2;
  v9[4] = a4;
  v9[5] = a1;
  dispatch_async(v8, v9);
}

uint64_t ___ZN21KerberosAccountBroker27getKerberosCredentialForURLEPK16_CFURLCredentialPK7__CFURLU13block_pointerFvS2_E_block_invoke(uint64_t a1)
{
  KerberosAccountBroker *v2;
  _OWORD *v3;
  _QWORD *v4;
  const void *v5;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  void *v9;
  NSObject *v10;
  const void *v11;
  const void *v12;
  _QWORD v14[7];
  _QWORD block[7];

  v2 = *(KerberosAccountBroker **)(a1 + 40);
  v3 = KerberosAccountBroker::copyStoreForURL(v2, *(const __CFURL **)(a1 + 48));
  if (v3)
  {
    v4 = v3;
    (*(void (**)(KerberosAccountBroker *))(*(_QWORD *)v2 + 40))(v2);
    v5 = *(const void **)(a1 + 48);
    if (v5)
    {
      CFRetain(v5);
      v6 = *(_QWORD *)(a1 + 48);
    }
    else
    {
      v6 = 0;
    }
    v7 = *(const void **)(a1 + 56);
    v8 = MEMORY[0x1E0C809B0];
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = ___ZN21KerberosAccountBroker27getKerberosCredentialForURLEPK16_CFURLCredentialPK7__CFURLU13block_pointerFvS2_E_block_invoke_2;
    v14[3] = &unk_1E14FA5F0;
    v14[4] = *(_QWORD *)(a1 + 32);
    v14[5] = v2;
    v14[6] = v6;
    (*(void (**)(_QWORD *))(*v4 + 40))(v4);
    if (v7)
      CFRetain(v7);
    v9 = _Block_copy(v14);
    v10 = v4[11];
    block[0] = v8;
    block[1] = 3221225472;
    block[2] = ___ZN20KerberosAccountStore42getKerberosCredentialWithCompletionHandlerEPK16_CFURLCredentialU13block_pointerFvS2_E_block_invoke;
    block[3] = &unk_1E14FDB30;
    block[5] = v4;
    block[6] = v7;
    block[4] = v9;
    dispatch_async(v10, block);
  }
  else
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
  v11 = *(const void **)(a1 + 56);
  if (v11)
    CFRelease(v11);
  v12 = *(const void **)(a1 + 48);
  if (v12)
    CFRelease(v12);
  return (*(uint64_t (**)(KerberosAccountBroker *))(*(_QWORD *)v2 + 48))(v2);
}

_OWORD *KerberosAccountBroker::copyStoreForURL(KerberosAccountBroker *this, const __CFURL *a2)
{
  _OWORD *Value;
  _OWORD *v5;
  _OWORD *v6;
  uint64_t v7;
  int v8;
  int v9;

  Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), a2);
  if (Value)
  {
    v5 = Value;
    (*(void (**)(_OWORD *))(*(_QWORD *)Value + 40))(Value);
  }
  else
  {
    v6 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 104, 0);
    v6[2] = 0u;
    v6[3] = 0u;
    v6[4] = 0u;
    v6[5] = 0u;
    *((_QWORD *)v6 + 12) = 0;
    *v6 = 0u;
    v6[1] = 0u;
    v7 = *((_QWORD *)this + 1);
    *(_QWORD *)v6 = off_1E14EF578;
    *((_QWORD *)v6 + 1) = v7;
    *((_DWORD *)v6 + 4) = 1;
    if (((unint64_t)(v6 + 1) & 3) != 0)
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    v5 = v6;
    *(_QWORD *)v6 = off_1E14EB8E0;
    *((_QWORD *)v6 + 3) = &unk_1E14EB938;
    *((_QWORD *)v6 + 4) = 0;
    v6[3] = 0uLL;
    v6[4] = 0uLL;
    v6[5] = 0uLL;
    *((_QWORD *)v6 + 12) = 0;
    v8 = CFNAccountStore::initialize((CFNAccountStore *)v6, *((const __CFString **)this + 7), 0.0);
    v9 = v8;
    if (a2 && v8)
    {
      *((_QWORD *)v5 + 8) = CFRetain(a2);
      *((_QWORD *)v5 + 7) = CFArrayCreateMutable(*((CFAllocatorRef *)v5 + 1), 0, MEMORY[0x1E0C9B378]);
      *((_QWORD *)v5 + 11) = dispatch_queue_create("com.apple.kerberosaccountstore.lookupqueue", 0);
      *((_QWORD *)v5 + 12) = dispatch_queue_create("com.apple.kerberosaccountstore.credfetchqueue", 0);
    }
    if (*((_QWORD *)v5 + 8) && *((_QWORD *)v5 + 7) && *((_QWORD *)v5 + 11) && *((_QWORD *)v5 + 12) && v9)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 5), a2, v5);
    }
    else
    {
      (*(void (**)(_OWORD *))(*(_QWORD *)v5 + 48))(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t ___ZN21KerberosAccountBroker27getKerberosCredentialForURLEPK16_CFURLCredentialPK7__CFURLU13block_pointerFvS2_E_block_invoke_2(_QWORD *a1)
{
  uint64_t v2;
  const void *v3;

  v2 = a1[5];
  (*(void (**)(void))(a1[4] + 16))();
  v3 = (const void *)a1[6];
  if (v3)
    CFRelease(v3);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void KerberosAccountBroker::clearAccountRefreshState(NSObject **this, const __CFURL *a2)
{
  NSObject *v4;
  _QWORD v5[6];

  if (a2)
  {
    ((void (*)(NSObject **))(*this)[5].isa)(this);
    CFRetain(a2);
    v4 = this[6];
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN21KerberosAccountBroker24clearAccountRefreshStateEPK7__CFURL_block_invoke;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = this;
    v5[5] = a2;
    dispatch_async(v4, v5);
  }
}

uint64_t ___ZN21KerberosAccountBroker24clearAccountRefreshStateEPK7__CFURL_block_invoke(uint64_t a1)
{
  KerberosAccountBroker *v2;
  _OWORD *v3;
  _QWORD *v4;
  NSObject *v5;
  _QWORD block[5];

  v2 = *(KerberosAccountBroker **)(a1 + 32);
  v3 = KerberosAccountBroker::copyStoreForURL(v2, *(const __CFURL **)(a1 + 40));
  if (v3)
  {
    v4 = v3;
    (*(void (**)(_OWORD *))(*(_QWORD *)v3 + 40))(v3);
    v5 = v4[11];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZN20KerberosAccountStore24clearAccountRefreshStateEv_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = v4;
    dispatch_async(v5, block);
    (*(void (**)(_QWORD *))(*v4 + 48))(v4);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
  return (*(uint64_t (**)(KerberosAccountBroker *))(*(_QWORD *)v2 + 48))(v2);
}

void SHTTPConnectionCache::~SHTTPConnectionCache(SHTTPConnectionCache *this)
{
  uint64_t v2;

  SHTTPConnectionCache::~SHTTPConnectionCache(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E14EBB00;
  *((_QWORD *)this + 4) = &unk_1E14EBBC0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 12) + 48))(*((_QWORD *)this + 12));
  *((_QWORD *)this + 13) = 0;
  CFRelease(*((CFTypeRef *)this + 6));
  *((_QWORD *)this + 4) = &off_1E14E5838;
  *(_QWORD *)this = off_1E14EA0F0;

}

BOOL SHTTPConnectionCache::equals(SHTTPConnectionCache *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

uint64_t SHTTPConnectionCache::initWithSchedulingSet(SHTTPConnectionCache *this, const CoreSchedulingSet *a2, STubeManager *a3)
{
  if (a2)
  {
    *((_QWORD *)this + 12) = a2;
    (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 40))(a2);
  }
  else
  {
    *((_QWORD *)this + 12) = CoreSchedulingSet::copyLoaderQueueSet((CoreSchedulingSet *)this);
  }
  *((_QWORD *)this + 13) = a3;
  *((_QWORD *)this + 5) = 0;
  SHTTPConnectionCache::enableTimer(this);
  return (*(uint64_t (**)(SHTTPConnectionCache *))(*(_QWORD *)this + 152))(this);
}

void SHTTPConnectionCache::useFastPathForCacheEntryWithKey(SHTTPConnectionCache *this, const HTTPConnectionCacheKey *value)
{
  uint64_t v4;
  const void *v5;
  const void *v6;

  if (value)
  {
    v4 = *((_QWORD *)this + 5);
    if (v4 && (v5 = CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 32), value)) != 0)
    {
      v6 = v5;
      (*(void (**)(const void *))(*(_QWORD *)v5 + 40))(v5);
      (*(void (**)(const void *))(*(_QWORD *)v6 + 48))(v6);
    }
    else
    {
      CFSetAddValue(*((CFMutableSetRef *)this + 6), value);
    }
  }
}

int *SHTTPConnectionCache::enqueueRequestForProtocol(__CFDictionary *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  const void *v11;
  int *Value;
  int *v13;
  const HTTPConnectionCacheKey *v14;
  int *result;
  uint64_t v16;
  const void *v17;
  uint64_t v18;
  BOOL v19;
  BOOL v20;
  uint64_t v21;
  _OWORD *v22;
  uint64_t v23;
  CFMutableArrayRef *v24;
  _QWORD *v25;
  HTTPNetConnection *v26;
  unsigned int v27;
  _BYTE v28[15];
  int v29;
  _BYTE v30[15];
  char v31;
  int v32;
  unsigned __int8 v33;
  HTTPNetConnection *v34;

  v7 = *(_DWORD *)a4;
  *(_QWORD *)v28 = *(_QWORD *)(a4 + 4);
  *(_QWORD *)&v28[7] = *(_QWORD *)(a4 + 11);
  v8 = *(unsigned __int8 *)(a4 + 19);
  v9 = *(_DWORD *)(a4 + 20);
  SHTTPConnectionCache::ensureEntries(a1);
  v10 = *((_QWORD *)a1 + 5);
  v11 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  Value = (int *)CFDictionaryGetValue(*(CFDictionaryRef *)(v10 + 32), v11);
  if (Value)
  {
    v13 = Value;
    (*(void (**)(int *))(*(_QWORD *)Value + 40))(Value);
  }
  else
  {
    v14 = (const HTTPConnectionCacheKey *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
    result = SHTTPConnectionCache::createEmptyCacheEntry((CFSetRef *)a1, v14);
    if (!result)
      return result;
    v13 = result;
    v16 = *((_QWORD *)a1 + 5);
    v17 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v16 + 32), v17, v13);
  }
  v34 = 0;
  v33 = 0;
  if (!*((_QWORD *)v13 + 27))
    *((_QWORD *)v13 + 27) = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(a3 - 16));
  if (v8)
    *((_BYTE *)v13 + 40) |= 8u;
  v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v18 + 88))(v18) == 2)
  {
    *((_BYTE *)v13 + 40) |= 0x40u;
    v19 = 0;
  }
  else
  {
    v19 = v7 < v13[52];
  }
  v20 = !v19 || v7 < 0;
  *(_QWORD *)v30 = *(_QWORD *)v28;
  *(_QWORD *)&v30[7] = *(_QWORD *)&v28[7];
  if (v20)
    v21 = 0;
  else
    v21 = v7;
  v22 = CFAllocatorAllocate(*((CFAllocatorRef *)v13 + 1), 80, 0);
  *v22 = 0u;
  v22[1] = 0u;
  v22[2] = 0u;
  v22[3] = 0u;
  v22[4] = 0u;
  v23 = *((_QWORD *)v13 + 1);
  v29 = v21;
  v31 = v8;
  v32 = v9;
  SHTTPConnectionCacheEnqueuedRequestInfo::SHTTPConnectionCacheEnqueuedRequestInfo((uint64_t)v22, v23, a2, a3, (__int128 *)&v29);
  v24 = *(CFMutableArrayRef **)(*((_QWORD *)v13 + 11) + 8 * v21);
  if (!v24)
  {
    v25 = (_QWORD *)operator new();
    *v25 = CFArrayCreateMutable(*((CFAllocatorRef *)v13 + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    *(_QWORD *)(*((_QWORD *)v13 + 11) + 8 * v21) = v25;
    v24 = *(CFMutableArrayRef **)(*((_QWORD *)v13 + 11) + 8 * v21);
  }
  CFArrayAppendValue(*v24, v22);
  SHTTPConnectionCacheEntry::findOrCreateEmptyNetConnection((SHTTPConnectionCacheEntry *)v13, &v34, (SHTTPConnectionCacheEnqueuedRequestInfo *)v22, &v33);
  v26 = v34;
  if (v34)
  {
    v27 = v33;
    if (!v33)
      *((_QWORD *)v34 + 37) = 0;
    SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection((CFArrayRef **)v13, v26, v27);
    (*(void (**)(HTTPNetConnection *))(*(_QWORD *)v26 + 48))(v26);
  }
  (*(void (**)(_OWORD *))(*(_QWORD *)v22 + 48))(v22);
  SHTTPConnectionCache::purgeExcessiveConnections(a1);
  SHTTPConnectionCache::enableTimer(a1);
  (*(void (**)(__CFDictionary *))(*(_QWORD *)a1 + 152))(a1);
  return (int *)(*(uint64_t (**)(int *))(*(_QWORD *)v13 + 48))(v13);
}

void sub_1840908D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

uint64_t SHTTPConnectionCache::ingestTube(SHTTPConnectionCache *this, const void **a2)
{
  SHTTPConnectionCacheEntry *Value;
  SHTTPConnectionCacheEntry *v5;
  int *EmptyCacheEntry;

  SHTTPConnectionCache::ensureEntries(this);
  Value = (SHTTPConnectionCacheEntry *)CFDictionaryGetValue(*(CFDictionaryRef *)(*((_QWORD *)this + 5) + 32), a2[12]);
  if (Value)
  {
    v5 = Value;
    (*(void (**)(SHTTPConnectionCacheEntry *))(*(_QWORD *)Value + 40))(Value);
LABEL_5:
    SHTTPConnectionCacheEntry::ingestTube(v5, (HTTPConnectionCacheKey **)a2);
    (*(void (**)(SHTTPConnectionCacheEntry *))(*(_QWORD *)v5 + 48))(v5);
    goto LABEL_6;
  }
  EmptyCacheEntry = SHTTPConnectionCache::createEmptyCacheEntry((CFSetRef *)this, (const HTTPConnectionCacheKey *)a2[12]);
  if (EmptyCacheEntry)
  {
    v5 = (SHTTPConnectionCacheEntry *)EmptyCacheEntry;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*((_QWORD *)this + 5) + 32), a2[12], EmptyCacheEntry);
    goto LABEL_5;
  }
LABEL_6:
  SHTTPConnectionCache::enableTimer(this);
  return (*(uint64_t (**)(SHTTPConnectionCache *))(*(_QWORD *)this + 152))(this);
}

uint64_t SHTTPConnectionCache::getPendingTubeForProtocolWithKey(uint64_t a1, uint64_t a2, void *key)
{
  uint64_t v3;
  const void *Value;
  const void *v7;
  uint64_t v8;

  if (!key)
    return 0;
  v3 = *(_QWORD *)(a1 + 40);
  if (!v3)
    return 0;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 32), key);
  if (!Value)
    return 0;
  v7 = Value;
  (*(void (**)(const void *))(*(_QWORD *)Value + 40))(Value);
  v8 = (*(uint64_t (**)(const void *, uint64_t, void *))(*(_QWORD *)v7 + 80))(v7, a2, key);
  (*(void (**)(const void *))(*(_QWORD *)v7 + 48))(v7);
  return v8;
}

void SHTTPConnectionCache::invalidateAllConnections(SHTTPConnectionCache *this)
{
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(*((_QWORD *)this + 5) + 32), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,SHTTPConnectionCacheEntry *>::_visit, &__block_literal_global_9175);
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(*((_QWORD *)this + 5) + 32));
  CFSetRemoveAllValues(*((CFMutableSetRef *)this + 6));
  HTTPConnectionCache::disableTimer(this);
  HTTPConnectionCache::disableCellTimer(this);
}

__CFDictionary *SHTTPConnectionCache::invalidateUnpurgeableConnectionsForKey(__CFDictionary *this, const HTTPConnectionCacheKey *a2)
{
  __CFDictionary *v3;
  uint64_t v4;

  if (a2)
  {
    v3 = this;
    SHTTPConnectionCache::ensureEntries(this);
    this = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(*((_QWORD *)v3 + 5) + 32), a2);
    if (this)
    {
      v4 = (uint64_t)this;
      (*(void (**)(__CFDictionary *))(*(_QWORD *)this + 40))(this);
      SHTTPConnectionCacheEntry::invalidateUnpurgeableConnections(v4);
      return (__CFDictionary *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    }
  }
  return this;
}

uint64_t SHTTPConnectionCache::purgeIdleConnections(SHTTPConnectionCache *this)
{
  uint64_t v1;
  _QWORD v3[5];

  v1 = *((_QWORD *)this + 12);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN20SHTTPConnectionCache20purgeIdleConnectionsEv_block_invoke;
  v3[3] = &__block_descriptor_40_e5_v8__0l;
  v3[4] = this;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v1 + 96))(v1, v3);
}

void SHTTPConnectionCache::enableCellTimer(SHTTPConnectionCache *this)
{
  NSObject *v2;
  double v3;
  dispatch_time_t v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD v8[5];
  _QWORD handler[5];

  if (!*((_QWORD *)this + 15))
  {
    v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 80))(*((_QWORD *)this + 12));
    v3 = (double)*((int *)this + 21);
    *((_QWORD *)this + 15) = v2;
    v4 = dispatch_time(0, (uint64_t)(v3 * 1000000000.0));
    dispatch_source_set_timer(v2, v4, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
    (*(void (**)(SHTTPConnectionCache *))(*(_QWORD *)this + 40))(this);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 40))(*((_QWORD *)this + 13));
    v5 = MEMORY[0x1E0C809B0];
    v6 = *((_QWORD *)this + 15);
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = ___ZN20SHTTPConnectionCache15enableCellTimerEv_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = this;
    dispatch_source_set_event_handler(v6, handler);
    v7 = *((_QWORD *)this + 15);
    v8[0] = v5;
    v8[1] = 3221225472;
    v8[2] = ___ZN20SHTTPConnectionCache15enableCellTimerEv_block_invoke_2;
    v8[3] = &__block_descriptor_40_e5_v8__0l;
    v8[4] = this;
    dispatch_source_set_cancel_handler(v7, v8);
    dispatch_resume(*((dispatch_object_t *)this + 15));
  }
}

uint64_t SHTTPConnectionCache::_meta_retain(SHTTPConnectionCache *this)
{
  return (*(uint64_t (**)(SHTTPConnectionCache *))(*(_QWORD *)this + 40))(this);
}

uint64_t SHTTPConnectionCache::_meta_release(SHTTPConnectionCache *this)
{
  return (*(uint64_t (**)(SHTTPConnectionCache *))(*(_QWORD *)this + 48))(this);
}

void `non-virtual thunk to'SHTTPConnectionCache::~SHTTPConnectionCache(SHTTPConnectionCache *this)
{
  SHTTPConnectionCache::~SHTTPConnectionCache((SHTTPConnectionCache *)((char *)this - 32));
}

void `non-virtual thunk to'SHTTPConnectionCache::~SHTTPConnectionCache(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 4;
  SHTTPConnectionCache::~SHTTPConnectionCache((SHTTPConnectionCache *)(this - 4));
  CFAllocatorDeallocate(*(this - 3), v2);
}

void sub_184090D48(_Unwind_Exception *a1)
{
  uint64_t v1;

  CFRelease(*(CFTypeRef *)(v1 + 48));
  *(_QWORD *)(v1 + 32) = &off_1E14E5838;
  *(_QWORD *)v1 = off_1E14EA0F0;

  _Unwind_Resume(a1);
}

uint64_t ___ZN20SHTTPConnectionCache15enableCellTimerEv_block_invoke(uint64_t a1)
{
  HTTPConnectionCache *v1;
  uint64_t result;

  v1 = *(HTTPConnectionCache **)(a1 + 32);
  HTTPConnectionCache::disableCellTimer(v1);
  SHTTPConnectionCache::purgeExcessiveConnections(v1);
  result = SHTTPConnectionCache::performIdleSweep(v1);
  if (result)
    return (*(uint64_t (**)(HTTPConnectionCache *))(*(_QWORD *)v1 + 152))(v1);
  return result;
}

uint64_t ___ZN20SHTTPConnectionCache15enableCellTimerEv_block_invoke_2(uint64_t a1)
{
  _QWORD **v1;

  v1 = *(_QWORD ***)(a1 + 32);
  (*(void (**)(_QWORD *))(*v1[13] + 48))(v1[13]);
  return ((uint64_t (*)(_QWORD **))(*v1)[6])(v1);
}

void SHTTPConnectionCache::purgeExcessiveConnections(SHTTPConnectionCache *this)
{
  __CFArray *Mutable;
  uint64_t v3;
  const void **v4;
  const void **v5;
  const void *v6;
  unint64_t Count;
  const void **v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  unint64_t v12;
  double v13;
  double v14;
  uint64_t v15;
  CFIndex i;
  SHTTPConnectionCacheEntry *ValueAtIndex;

  if (!*((_QWORD *)this + 5))
    return;
  Mutable = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  v3 = *((_QWORD *)this + 5);
  v4 = (const void **)operator new();
  v5 = v4;
  v6 = *(const void **)(v3 + 32);
  if (!v6)
  {
    *v4 = 0;
    v4[1] = 0;
    v4[2] = v4 + 3;
    goto LABEL_11;
  }
  *v4 = CFRetain(v6);
  Count = CFDictionaryGetCount((CFDictionaryRef)v6);
  v5[1] = (const void *)Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v5[2] = 0;
    goto LABEL_11;
  }
  if (Count > 0x1E)
  {
    v8 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v5[2] = v8;
    if (!v8)
      goto LABEL_11;
  }
  else
  {
    v8 = v5 + 3;
    v5[2] = v5 + 3;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)v6, 0, v8);
LABEL_11:
  v9 = (uint64_t)v5[1];
  v10 = 0.0;
  if (v9 >= 19)
  {
    v11 = 0;
    v12 = 0;
    do
      v12 += SHTTPConnectionCacheEntry::countConnections(*((SHTTPConnectionCacheEntry **)v5[2] + v11++));
    while (v9 != v11);
    if ((uint64_t)v12 > 72)
    {
      if (v12 <= 0x240)
      {
        v14 = 2.0;
        if (v12 > 0x90)
          v14 = 1.0;
        if (v12 <= 0x120)
          v13 = v14;
        else
          v13 = 0.5;
      }
      else
      {
        v13 = 0.1;
      }
      v15 = 0;
      v10 = CFAbsoluteTimeGetCurrent() - v13;
      do
        CFArrayAppendValue(Mutable, *((const void **)v5[2] + v15++));
      while (v9 != v15);
    }
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v5);
  MEMORY[0x186DB748C]();
  for (i = 0; i < CFArrayGetCount(Mutable); ++i)
  {
    ValueAtIndex = (SHTTPConnectionCacheEntry *)CFArrayGetValueAtIndex(Mutable, i);
    if (ValueAtIndex)
      SHTTPConnectionCacheEntry::purgeIdleConnections(ValueAtIndex, v10, v10);
  }
  CFRelease(Mutable);
}

void sub_184091004(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t SHTTPConnectionCache::performIdleSweep(SHTTPConnectionCache *this)
{
  uint64_t v1;
  __CFArray *Mutable;
  double Current;
  int v5;
  int v6;
  uint64_t v7;
  const void **v8;
  const void **v9;
  const __CFDictionary *v10;
  unint64_t Count;
  const void **v12;
  uint64_t v13;
  CFTypeRef *v14;
  const __CFDictionary *v15;
  unint64_t v16;
  const void **v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  double v21;
  SHTTPConnectionCacheEntry *v22;
  CFIndex v23;
  unint64_t v24;
  CFRange v25;
  const void **v26;
  CFIndex v27;
  uint64_t v28;
  const void *v29;
  uint64_t v30;
  const void *Value;
  CFIndex v32;
  CFIndex i;
  _QWORD *ValueAtIndex;
  uint64_t v35;
  uint64_t v36;
  SHTTPConnectionCacheEntry *v37;
  __CFArray *cf;
  CFTypeRef v40;
  CFIndex range;
  const void **v42;
  _BYTE v43[248];
  CFIndex v44;
  _QWORD v45[6];

  v1 = *((_QWORD *)this + 5);
  if (!v1)
    return 0;
  Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(v1 + 8), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  Current = CFAbsoluteTimeGetCurrent();
  v6 = *((_DWORD *)this + 20);
  v5 = *((_DWORD *)this + 21);
  v7 = *((_QWORD *)this + 5);
  v8 = (const void **)operator new();
  v9 = v8;
  v10 = *(const __CFDictionary **)(v7 + 32);
  if (!v10)
  {
    *v8 = 0;
    v8[1] = 0;
    v8[2] = v8 + 3;
    goto LABEL_11;
  }
  *v8 = CFRetain(*(CFTypeRef *)(v7 + 32));
  Count = CFDictionaryGetCount(v10);
  v9[1] = (const void *)Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v9[2] = 0;
    goto LABEL_11;
  }
  if (Count > 0x1E)
  {
    v12 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v9[2] = v12;
    if (!v12)
      goto LABEL_11;
  }
  else
  {
    v12 = v9 + 3;
    v9[2] = v9 + 3;
  }
  CFDictionaryGetKeysAndValues(v10, v12, 0);
LABEL_11:
  v14 = v9 + 34;
  v15 = *(const __CFDictionary **)(v7 + 32);
  if (!v15)
  {
    *v14 = 0;
    v9[35] = 0;
    v9[36] = v9 + 37;
    goto LABEL_19;
  }
  *v14 = CFRetain(*(CFTypeRef *)(v7 + 32));
  v16 = CFDictionaryGetCount(v15);
  v9[35] = (const void *)v16;
  if (v16 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v9[36] = 0;
    goto LABEL_19;
  }
  if (v16 > 0x1E)
  {
    v17 = (const void **)malloc_type_malloc(8 * v16, 0x89ED541CuLL);
    v9[36] = v17;
    if (!v17)
      goto LABEL_19;
  }
  else
  {
    v17 = v9 + 37;
    v9[36] = v9 + 37;
  }
  CFDictionaryGetKeysAndValues(v15, 0, v17);
LABEL_19:
  v18 = (uint64_t)v9[35];
  if (v18 < 1)
  {
    v13 = 0;
  }
  else
  {
    v19 = 0;
    v13 = 0;
    v20 = Current - (double)v6;
    v21 = Current - (double)v5;
    do
    {
      v22 = (SHTTPConnectionCacheEntry *)*((_QWORD *)v9[36] + v19);
      SHTTPConnectionCacheEntry::purgeIdleConnections(v22, v20, v21);
      v23 = SHTTPConnectionCacheEntry::countConnections(v22);
      if (v23)
        v13 += v23;
      else
        CFArrayAppendValue(Mutable, *((const void **)v9[2] + v19));
      ++v19;
    }
    while (v18 != v19);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)(v9 + 34));
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v9);
  MEMORY[0x186DB748C]();
  cf = Mutable;
  if (Mutable)
  {
    v40 = CFRetain(Mutable);
    v24 = CFArrayGetCount(Mutable);
    v25.length = v24;
    range = v24;
    if (v24 - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v42 = 0;
    }
    else
    {
      if (v24 <= 0x1E)
      {
        v26 = (const void **)v43;
        v42 = (const void **)v43;
LABEL_35:
        v25.location = 0;
        CFArrayGetValues(Mutable, v25, v26);
        goto LABEL_36;
      }
      v26 = (const void **)malloc_type_malloc(8 * v24, 0x89ED541CuLL);
      v42 = v26;
      if (v26)
      {
        v25.length = range;
        goto LABEL_35;
      }
    }
  }
  else
  {
    v40 = 0;
    range = 0;
    v42 = (const void **)v43;
  }
LABEL_36:
  v44 = 0;
  if (range >= 1)
  {
    v27 = 0;
    v28 = MEMORY[0x1E0C809B0];
    do
    {
      v44 = v27 + 1;
      v29 = v42[v27];
      v30 = *((_QWORD *)this + 13);
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v30 + 112), v29);
      if (Value)
      {
        if (Value == *(const void **)(v30 + 80))
        {
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v30 + 112), v29);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v30 + 128), v29);
          if (!STubeManager::_onqueue_getValidAwaitingTubeForKey((CFArrayRef *)v30, (const HTTPConnectionCacheKey *)v29))
          {
            v32 = CFArrayGetCount(*(CFArrayRef *)(v30 + 144));
            if (v32 >= 1)
            {
              for (i = 0; i != v32; ++i)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v30 + 144), i);
                if ((*(unsigned int (**)(_QWORD, const void *))(*(_QWORD *)ValueAtIndex[12] + 24))(ValueAtIndex[12], v29))
                {
                  v35 = ValueAtIndex[14];
                  v45[0] = v28;
                  v45[1] = 3221225472;
                  v45[2] = ___ZN5STube6cancelEv_block_invoke;
                  v45[3] = &__block_descriptor_40_e5_v8__0l;
                  v45[4] = ValueAtIndex;
                  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v35 + 104))(v35, v45);
                }
              }
            }
          }
        }
      }
      v36 = *((_QWORD *)this + 5);
      v37 = (SHTTPConnectionCacheEntry *)CFDictionaryGetValue(*(CFDictionaryRef *)(v36 + 32), v29);
      if (v37)
      {
        SHTTPConnectionCacheEntry::setHasBeenForgotten(v37);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v36 + 32), v29);
      }
      if (CFSetContainsValue(*((CFSetRef *)this + 6), v29))
        CFSetRemoveValue(*((CFMutableSetRef *)this + 6), v29);
      v27 = v44;
    }
    while (v44 < range);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v40);
  CFRelease(cf);
  return v13;
}

void sub_184091494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  const void *v10;

  CFRelease(v10);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20SHTTPConnectionCache20purgeIdleConnectionsEv_block_invoke(uint64_t a1)
{
  return SHTTPConnectionCache::timeoutIdleConnections(*(SHTTPConnectionCache **)(a1 + 32));
}

uint64_t SHTTPConnectionCache::timeoutIdleConnections(SHTTPConnectionCache *this)
{
  uint64_t result;

  HTTPConnectionCache::disableTimer(this);
  SHTTPConnectionCache::purgeExcessiveConnections(this);
  result = SHTTPConnectionCache::performIdleSweep(this);
  if (result)
    return SHTTPConnectionCache::enableTimer(this);
  return result;
}

void SHTTPConnectionCache::enableTimer(SHTTPConnectionCache *this)
{
  NSObject *v2;
  double v3;
  dispatch_time_t v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD v8[5];
  _QWORD handler[5];

  if (!*((_QWORD *)this + 14))
  {
    v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 80))(*((_QWORD *)this + 12));
    v3 = (double)*((int *)this + 20);
    *((_QWORD *)this + 14) = v2;
    v4 = dispatch_time(0, (uint64_t)(v3 * 1000000000.0));
    dispatch_source_set_timer(v2, v4, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    (*(void (**)(SHTTPConnectionCache *))(*(_QWORD *)this + 40))(this);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 40))(*((_QWORD *)this + 13));
    v5 = MEMORY[0x1E0C809B0];
    v6 = *((_QWORD *)this + 14);
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = ___ZN20SHTTPConnectionCache11enableTimerEv_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = this;
    dispatch_source_set_event_handler(v6, handler);
    v7 = *((_QWORD *)this + 14);
    v8[0] = v5;
    v8[1] = 3221225472;
    v8[2] = ___ZN20SHTTPConnectionCache11enableTimerEv_block_invoke_2;
    v8[3] = &__block_descriptor_40_e5_v8__0l;
    v8[4] = this;
    dispatch_source_set_cancel_handler(v7, v8);
    dispatch_resume(*((dispatch_object_t *)this + 14));
  }
}

uint64_t ___ZN20SHTTPConnectionCache11enableTimerEv_block_invoke(uint64_t a1)
{
  return SHTTPConnectionCache::timeoutIdleConnections(*(SHTTPConnectionCache **)(a1 + 32));
}

uint64_t ___ZN20SHTTPConnectionCache11enableTimerEv_block_invoke_2(uint64_t a1)
{
  _QWORD **v1;

  v1 = *(_QWORD ***)(a1 + 32);
  (*(void (**)(_QWORD *))(*v1[13] + 48))(v1[13]);
  return ((uint64_t (*)(_QWORD **))(*v1)[6])(v1);
}

CFMutableDictionaryRef SHTTPConnectionCache::ensureEntries(CFMutableDictionaryRef this)
{
  CFMutableDictionaryRef v1;
  const __CFAllocator *v2;
  _QWORD *v3;

  if (!*((_QWORD *)this + 5))
  {
    v1 = this;
    v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v3 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 40, 0);
    *v3 = off_1E14EF0A8;
    v3[1] = v2;
    v3[2] = &unk_1E14EF0C8;
    v3[3] = &off_1E14EA4C8;
    v3[4] = 0;
    this = CFDictionaryCreateMutable(v2, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
    v3[4] = this;
    *((_QWORD *)v1 + 5) = v3;
  }
  return this;
}

void sub_184091734(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,SHTTPConnectionCacheEntry *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA4C8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,SHTTPConnectionCacheEntry *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA4C8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void SHTTPConnectionCacheDictionary::~SHTTPConnectionCacheDictionary(SHTTPConnectionCacheDictionary *this)
{
  *(_QWORD *)this = off_1E14EF0A8;
  *((_QWORD *)this + 2) = &unk_1E14EF0C8;
  *((_QWORD *)this + 3) = &off_1E14EA4C8;
  CFRelease(*((CFTypeRef *)this + 4));
  *((_QWORD *)this + 2) = &off_1E14E5838;
}

{
  *(_QWORD *)this = off_1E14EF0A8;
  *((_QWORD *)this + 2) = &unk_1E14EF0C8;
  *((_QWORD *)this + 3) = &off_1E14EA4C8;
  CFRelease(*((CFTypeRef *)this + 4));
  *((_QWORD *)this + 2) = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

void `non-virtual thunk to'SHTTPConnectionCacheDictionary::~SHTTPConnectionCacheDictionary(SHTTPConnectionCacheDictionary *this)
{
  *((_QWORD *)this - 2) = off_1E14EF0A8;
  *(_QWORD *)this = &unk_1E14EF0C8;
  *((_QWORD *)this + 1) = &off_1E14EA4C8;
  CFRelease(*((CFTypeRef *)this + 2));
  *(_QWORD *)this = &off_1E14E5838;
}

{
  char *v2;

  *((_QWORD *)this - 2) = off_1E14EF0A8;
  v2 = (char *)this - 16;
  *(_QWORD *)this = &unk_1E14EF0C8;
  *((_QWORD *)this + 1) = &off_1E14EA4C8;
  CFRelease(*((CFTypeRef *)this + 2));
  *(_QWORD *)this = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 1), v2);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,SHTTPConnectionCacheEntry *>::_visit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void ___ZN30SHTTPConnectionCacheDictionary18forgetCacheEntriesEv_block_invoke(int a1, int a2, SHTTPConnectionCacheEntry *this)
{
  uint64_t v4;
  unint64_t v5;
  CFMutableArrayRef *v6;

  SHTTPConnectionCacheEntry::invalidateUnpurgeableConnections((uint64_t)this);
  v4 = *((unsigned int *)this + 52);
  if ((int)v4 >= 1)
  {
    v5 = v4 + 1;
    do
    {
      v6 = *(CFMutableArrayRef **)(*((_QWORD *)this + 11) + 8 * (v5 - 2));
      if (v6 && CFArrayGetCount(*v6) >= 1)
        CFArrayRemoveAllValues(*v6);
      --v5;
    }
    while (v5 > 1);
  }
  SHTTPConnectionCacheEntry::setHasBeenForgotten(this);
}

int *SHTTPConnectionCache::createEmptyCacheEntry(CFSetRef *this, const HTTPConnectionCacheKey *a2)
{
  int v4;
  int *v5;
  const __CFAllocator *v6;
  CFSetRef v7;
  _QWORD *v8;
  _QWORD *v9;
  int v10;
  void *v11;

  v4 = CFSetContainsValue(this[6], a2);
  if (v4)
    CFSetRemoveValue(this[6], a2);
  v5 = (int *)CFAllocatorAllocate(this[1], 256, 0);
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  *((_OWORD *)v5 + 11) = 0u;
  *((_OWORD *)v5 + 12) = 0u;
  *((_OWORD *)v5 + 13) = 0u;
  *((_OWORD *)v5 + 14) = 0u;
  *((_OWORD *)v5 + 15) = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  v6 = this[1];
  v7 = this[12];
  *(_QWORD *)v5 = off_1E14EF578;
  *((_QWORD *)v5 + 1) = v6;
  v5[4] = 1;
  if (((unint64_t)(v5 + 4) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)v5 = off_1E14ED4E8;
  *((_QWORD *)v5 + 3) = &unk_1E14ED550;
  *((_QWORD *)v5 + 28) = this + 7;
  *((_QWORD *)v5 + 29) = CFArrayCreateMutable(v6, 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  *((_QWORD *)v5 + 4) = (*(uint64_t (**)(CFSetRef))(*(_QWORD *)v7 + 88))(v7);
  v8 = (_QWORD *)operator new();
  *v8 = CFArrayCreateMutable(*((CFAllocatorRef *)v5 + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  *((_QWORD *)v5 + 6) = v8;
  v9 = (_QWORD *)operator new();
  *v9 = CFArrayCreateMutable(*((CFAllocatorRef *)v5 + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  *((_QWORD *)v5 + 10) = v9;
  *((_QWORD *)v5 + 30) = v4 == 0;
  *((_BYTE *)v5 + 248) = 1;
  *((_BYTE *)v5 + 40) |= 0x10u;
  *((_QWORD *)v5 + 12) = SHTTPConnectionCacheEntry::authenticatedConnectionCompletedRequest;
  *((_QWORD *)v5 + 13) = SHTTPConnectionCacheEntry::authenticatedConnectionCompletedResponse;
  *((_QWORD *)v5 + 16) = SHTTPConnectionCacheEntry::retainCacheEntry;
  *((_QWORD *)v5 + 17) = SHTTPConnectionCacheEntry::releaseCacheEntry;
  *((_QWORD *)v5 + 14) = SHTTPConnectionCacheEntry::authenticatedConnectionWasLost;
  *((_QWORD *)v5 + 15) = SHTTPConnectionCacheEntry::authenticatedConnectionActivity;
  *((_QWORD *)v5 + 18) = v5;
  *((_QWORD *)v5 + 19) = SHTTPConnectionCacheEntry::connectionCompletedRequest;
  *((_QWORD *)v5 + 20) = SHTTPConnectionCacheEntry::connectionCompletedResponse;
  *((_QWORD *)v5 + 21) = SHTTPConnectionCacheEntry::connectionWasLost;
  *((_QWORD *)v5 + 22) = SHTTPConnectionCacheEntry::connectionActivity;
  *((_QWORD *)v5 + 23) = SHTTPConnectionCacheEntry::retainCacheEntry;
  *((_QWORD *)v5 + 24) = SHTTPConnectionCacheEntry::releaseCacheEntry;
  *((_QWORD *)v5 + 25) = v5;
  v10 = *(_DWORD *)(*((_QWORD *)v5 + 28) + 12);
  v5[52] = v10;
  v11 = CFAllocatorAllocate(*((CFAllocatorRef *)v5 + 1), 8 * (v10 + 1), 0);
  *((_QWORD *)v5 + 11) = v11;
  bzero(v11, 8 * v5[52] + 8);
  return v5;
}

void sub_184091BD0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x186DB748C](v2, 0x20C4093837F09);
  CFRelease(*(CFTypeRef *)(v1 + 232));
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

CFErrorRef HostLookup_Master::prepareLookup(HostLookup_Master *this, Host *a2)
{
  const __CFAllocator *v3;
  const __CFAllocator *v4;
  const __CFString *v5;
  UInt8 *v6;
  uint64_t v7;
  CFErrorRef CFErrorWithStreamError;
  const __CFString *v9;
  mach_port_t v10;
  int v11;
  int v12;
  const void *v13;
  mach_port_t portNum;
  CFMachPortContext allocator[26];
  CFAllocatorRef v17;
  uint64_t v18;
  void *v19;
  UInt8 v20[1024];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 7) = a2;
  CFRetain((char *)a2 - 16);
  v3 = CFGetAllocator((char *)this - 16);
  v4 = v3;
  v5 = (const __CFString *)*((_QWORD *)this + 5);
  v17 = v3;
  v18 = 1023;
  if (v5)
  {
    v6 = _CFStringGetOrCreateCString(v3, v5, v20, &v18, 0x8000100u);
    v7 = v18;
  }
  else
  {
    v7 = 0;
    v20[0] = 0;
    v18 = 0;
    v6 = v20;
  }
  v19 = v6;
  if (v7 != strlen((const char *)v6))
  {
    *(_OWORD *)&allocator[0].version = xmmword_1841E3920;
    CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v4, (int *)allocator);
    goto LABEL_23;
  }
  portNum = 0;
  if (!CFEqual(*((CFTypeRef *)this + 3), &unk_1EDCFF5E0))
    CFEqual(*((CFTypeRef *)this + 3), &unk_1EDCFF618);
  v9 = (const __CFString *)*((_QWORD *)this + 6);
  if (v9)
  {
    allocator[0].version = (CFIndex)v4;
    allocator[0].info = (void *)1023;
    allocator[0].retain = (const void *(__cdecl *)(const void *))_CFStringGetOrCreateCString(v4, v9, (UInt8 *)&allocator[0].release, (uint64_t *)&allocator[0].info, 0x8000100u);
    v10 = _getaddrinfo_interface_async_call();
    portNum = v10;
    if (allocator[0].retain && &allocator[0].release != (void (__cdecl **)(const void *))allocator[0].retain)
      CFAllocatorDeallocate((CFAllocatorRef)allocator[0].version, allocator[0].retain);
    CFErrorWithStreamError = 0;
  }
  else
  {
    v11 = getaddrinfo_async_start();
    if (!v11)
      v11 = -1;
    *(_OWORD *)&allocator[0].version = xmmword_1841E3930;
    LODWORD(allocator[0].info) = v11;
    CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v4, (int *)allocator);
    v10 = 0;
    if (CFErrorWithStreamError)
      goto LABEL_19;
  }
  if (!v10)
  {
    v12 = *__error();
    *(_OWORD *)&allocator[0].version = xmmword_1841E3810;
    LODWORD(allocator[0].info) = v12;
    CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v4, (int *)allocator);
  }
LABEL_19:
  if (!CFErrorWithStreamError)
  {
    allocator[0].version = 0;
    allocator[0].info = this;
    allocator[0].release = 0;
    allocator[0].copyDescription = 0;
    allocator[0].retain = 0;
    v13 = CFMachPortCreateWithPort(v4, portNum, (CFMachPortCallBack)HostLookup_Master::_GetAddrInfoMachPortCallBack, allocator, 0);
    *((_QWORD *)this + 4) = v13;
    if (v13)
      v13 = CFRetain(v13);
    CFErrorWithStreamError = 0;
    *((_QWORD *)this + 2) = v13;
  }
LABEL_23:
  if (v19 && v20 != v19)
    CFAllocatorDeallocate(v17, v19);
  return CFErrorWithStreamError;
}

void sub_184091F24(_Unwind_Exception *a1)
{
  void *v1;
  void *v3;

  v3 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    if (v1 != v3)
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x460], v3);
  }
  _Unwind_Resume(a1);
}

void HostLookup_Master::getAddrInfoCallback(HostLookup_Master *this, int a2, addrinfo *a3)
{
  Host *v6;
  uint64_t v7;
  const __CFAllocator *v8;
  CFErrorRef CFErrorWithStreamError;
  addrinfo *v10;
  sockaddr *ai_addr;
  int sa_family;
  CFDataRef v14;
  const __CFAllocator *v15;
  uint64_t v16;
  int v17;

  v6 = (Host *)*((_QWORD *)this + 7);
  CFRetain((char *)v6 - 16);
  if (a2)
  {
    if (a2 == 11)
    {
      a2 = *__error();
      v7 = 1;
    }
    else
    {
      v7 = 12;
    }
    v16 = v7;
    v17 = a2;
    v15 = CFGetAllocator((char *)v6 - 16);
    CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v15, (int *)&v16);
    Host::performCallback(v6, *((const __CFString **)this + 3), CFErrorWithStreamError);
    if (!CFErrorWithStreamError)
      goto LABEL_18;
  }
  else
  {
    v8 = CFGetAllocator((char *)v6 - 16);
    CFErrorWithStreamError = CFArrayCreateMutable(v8, 0, MEMORY[0x1E0C9B378]);
    if (a3)
    {
      v10 = a3;
      do
      {
        ai_addr = v10->ai_addr;
        sa_family = ai_addr->sa_family;
        if (sa_family == 30 || sa_family == 2)
        {
          v14 = CFDataCreate(v8, &ai_addr->sa_len, ai_addr->sa_len);
          CFArrayAppendValue(CFErrorWithStreamError, v14);
          if (v14)
            CFRelease(v14);
        }
        v10 = v10->ai_next;
      }
      while (v10);
    }
    Host::performCallback(v6, *((const __CFString **)this + 3), CFErrorWithStreamError);
  }
  CFRelease(CFErrorWithStreamError);
LABEL_18:
  if (a3)
    freeaddrinfo(a3);
  CFRelease((char *)v6 - 16);
}

void sub_1840920C8(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t HostLookup_Master::getAddrInfoMachPortCallback(HostLookup_Master *this, CFMachPortRef port, void *a3)
{
  CFMachPortInvalidate(port);
  if (*((CFMachPortRef *)this + 4) == port)
  {
    *((_QWORD *)this + 4) = 0;
    if (port)
      CFRelease(port);
  }
  return getaddrinfo_async_handle_reply();
}

void `non-virtual thunk to'HostLookup_Master::~HostLookup_Master(HostLookup_Master *this)
{
  HostLookup_Master::~HostLookup_Master((HostLookup_Master *)((char *)this - 8));
}

{
  HostLookup_Master::~HostLookup_Master((HostLookup_Master *)((char *)this - 8));
}

void HostLookup_Master::~HostLookup_Master(HostLookup_Master *this)
{
  *(_QWORD *)this = &off_1E14E8F10;
  *((_QWORD *)this + 1) = &unk_1E14E8F78;
  CFRelease((CFTypeRef)(*((_QWORD *)this + 7) - 16));
  HostLookup::~HostLookup(this);
}

void sub_184092180(_Unwind_Exception *a1)
{
  HostLookup *v1;

  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

uint64_t HostLookup_Master::_GetAddrInfoCallBack(HostLookup_Master *this, uint64_t a2, addrinfo *a3, void *a4)
{
  return (*(uint64_t (**)(addrinfo *, HostLookup_Master *, uint64_t))(*(_QWORD *)&a3->ai_flags + 72))(a3, this, a2);
}

uint64_t HostLookup_Master::_GetAddrInfoMachPortCallBack(HostLookup_Master *this, __CFMachPort *a2, void *a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, HostLookup_Master *, __CFMachPort *))(*(_QWORD *)a4 + 80))(a4, this, a2);
}

void HostLookup_Master::HostLookup_Master(HostLookup_Master *this, CFTypeRef cf, const __CFString *a3, const __CFString *a4)
{
  CFTypeRef v7;
  CFTypeRef v8;
  CFTypeRef v9;

  *(_QWORD *)this = &off_1E14E4B50;
  *((_QWORD *)this + 1) = &unk_1E14E4BA8;
  *((_QWORD *)this + 2) = 0;
  if (cf)
    v7 = CFRetain(cf);
  else
    v7 = 0;
  *((_QWORD *)this + 3) = v7;
  *(_QWORD *)this = &off_1E14E8F10;
  *((_QWORD *)this + 1) = &unk_1E14E8F78;
  if (a3)
    v8 = CFRetain(a3);
  else
    v8 = 0;
  *((_QWORD *)this + 5) = v8;
  if (a4)
    v9 = CFRetain(a4);
  else
    v9 = 0;
  *((_QWORD *)this + 6) = v9;
}

void sub_184092264(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

void DispatchHost::GetAddrAsyncHelper::~GetAddrAsyncHelper(DispatchHost::GetAddrAsyncHelper *this)
{
  *(_QWORD *)this = &off_1E14EFEF0;
  CFRelease((CFTypeRef)(*((_QWORD *)this + 1) - 16));
}

{
  *(_QWORD *)this = &off_1E14EFEF0;
  CFRelease((CFTypeRef)(*((_QWORD *)this + 1) - 16));
  JUMPOUT(0x186DB748CLL);
}

CFErrorRef HostLookup_Names::prepareLookup(HostLookup_Names *this, Host *a2)
{
  const __CFAllocator *v3;
  const __CFString *v4;
  mach_port_t v5;
  CFErrorRef result;
  int v7;
  int v8;
  CFMachPortRef v9;
  CFTypeRef v10;
  mach_port_t portNum;
  CFMachPortContext allocator[26];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 4) = a2;
  CFRetain((char *)a2 - 16);
  v3 = CFGetAllocator((char *)this - 16);
  CFDataGetBytePtr(*((CFDataRef *)this + 5));
  portNum = 0;
  v4 = (const __CFString *)*((_QWORD *)this + 6);
  if (v4)
  {
    allocator[0].version = (CFIndex)v3;
    allocator[0].info = (void *)1023;
    allocator[0].retain = (const void *(__cdecl *)(const void *))_CFStringGetOrCreateCString(v3, v4, (UInt8 *)&allocator[0].release, (uint64_t *)&allocator[0].info, 0x8000100u);
    v5 = _getnameinfo_interface_async_call();
    portNum = v5;
    if (allocator[0].retain && &allocator[0].release != (void (__cdecl **)(const void *))allocator[0].retain)
      CFAllocatorDeallocate((CFAllocatorRef)allocator[0].version, allocator[0].retain);
    result = 0;
LABEL_9:
    if (!v5)
    {
      v8 = *__error();
      *(_OWORD *)&allocator[0].version = xmmword_1841E3810;
      LODWORD(allocator[0].info) = v8;
      result = __cfnCreateCFErrorWithStreamError(v3, (int *)allocator);
    }
    goto LABEL_11;
  }
  v7 = getnameinfo_async_start();
  if (!v7)
    v7 = -1;
  *(_OWORD *)&allocator[0].version = xmmword_1841E3930;
  LODWORD(allocator[0].info) = v7;
  result = __cfnCreateCFErrorWithStreamError(v3, (int *)allocator);
  v5 = 0;
  if (!result)
    goto LABEL_9;
LABEL_11:
  if (!result)
  {
    allocator[0].version = 0;
    allocator[0].info = this;
    allocator[0].release = 0;
    allocator[0].copyDescription = 0;
    allocator[0].retain = 0;
    v9 = CFMachPortCreateWithPort(v3, portNum, (CFMachPortCallBack)HostLookup_Names::_GetNameInfoMachPortCallBack, allocator, 0);
    *((_QWORD *)this + 7) = v9;
    if (v9)
      v10 = CFRetain(v9);
    else
      v10 = 0;
    result = 0;
    *((_QWORD *)this + 2) = v10;
  }
  return result;
}

void sub_1840924F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  void *v13;

  if (ptr)
  {
    if (v13 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  _Unwind_Resume(exception_object);
}

void `non-virtual thunk to'HostLookup_Names::~HostLookup_Names(HostLookup_Names *this)
{
  HostLookup_Names::~HostLookup_Names((HostLookup_Names *)((char *)this - 8));
}

{
  HostLookup_Names::~HostLookup_Names((HostLookup_Names *)((char *)this - 8));
}

void HostLookup_Names::~HostLookup_Names(HostLookup_Names *this)
{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = &off_1E14E80D0;
  *((_QWORD *)this + 1) = &unk_1E14E8128;
  v2 = (const void *)*((_QWORD *)this + 5);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 6);
  if (v3)
    CFRelease(v3);
  HostLookup::~HostLookup(this);
}

void sub_184092574(_Unwind_Exception *a1)
{
  HostLookup *v1;

  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

void HostLookup_Names::_GetNameInfoCallBack(HostLookup_Names *this, char *cStr, char *a3, char *a4, void *a5)
{
  unsigned int v8;
  Host *v9;
  const __CFAllocator *v10;
  CFStringRef v11;
  __CFArray *Array;
  uint64_t v13;
  const __CFAllocator *v14;
  CFErrorRef CFErrorWithStreamError;
  _QWORD valuePtr[20];

  valuePtr[19] = *MEMORY[0x1E0C80C00];
  if ((_DWORD)this == 11)
  {
    v8 = *__error();
    v13 = 1;
  }
  else
  {
    v8 = this;
    if (!(_DWORD)this)
    {
      v9 = (Host *)*((_QWORD *)a4 + 4);
      v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v11 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
      Array = cfTypeCreateArray(v10, v11, 0, 0, 0, &off_1E14E4818, v11, 0, 0);
      Host::performCallback(v9, CFSTR("kCFHostNames"), Array);
      if (Array)
        CFRelease(Array);
      AutoString::~AutoString((AutoString *)valuePtr);
      goto LABEL_10;
    }
    v13 = 12;
  }
  v14 = CFGetAllocator(a4 - 16);
  valuePtr[0] = v13;
  valuePtr[1] = v8;
  CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v14, (int *)valuePtr);
  Host::performCallback(*((Host **)a4 + 4), CFSTR("kCFHostNames"), CFErrorWithStreamError);
  if (CFErrorWithStreamError)
    CFRelease(CFErrorWithStreamError);
LABEL_10:
  if (cStr)
    free(cStr);
  if (a3)
    free(a3);
}

void sub_1840926E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  const void *v13;

  if (v13)
    CFRelease(v13);
  AutoString::~AutoString((AutoString *)&a13);
  _Unwind_Resume(a1);
}

uint64_t HostLookup_Names::_GetNameInfoMachPortCallBack(HostLookup_Names *this, __CFMachPort *a2, void *a3, uint64_t a4, void *a5)
{
  CFMachPortInvalidate(this);
  if (*(HostLookup_Names **)(a4 + 56) == this)
  {
    *(_QWORD *)(a4 + 56) = 0;
    if (this)
      CFRelease(this);
  }
  return getnameinfo_async_handle_reply();
}

uint64_t _dispach_HostLookup_Names__GetNameInfoCallBack(unsigned int a1, char *a2, char *a3, void *a4)
{
  const __CFAllocator *v8;
  const __CFAllocator *v9;
  DispatchHost *v10;
  CFStringRef v11;
  __CFArray *Array;
  uint64_t v13;
  CFErrorRef CFErrorWithStreamError;
  _QWORD valuePtr[20];

  valuePtr[19] = *MEMORY[0x1E0C80C00];
  v8 = CFGetAllocator((CFTypeRef)(*((_QWORD *)a4 + 1) - 16));
  v9 = v8;
  if (a1 == 11)
  {
    a1 = *__error();
    v13 = 1;
  }
  else
  {
    if (!a1)
    {
      v10 = (DispatchHost *)*((_QWORD *)a4 + 1);
      v11 = CFStringCreateWithCString(v8, a2, 0x8000100u);
      Array = cfTypeCreateArray(v9, v11, 0, 0, 0, &off_1E14E4818, v11, 0, 0);
      DispatchHost::performCallback(v10, (const __CFString *)&unk_1EDCFF6F8, Array);
      if (Array)
        CFRelease(Array);
      AutoString::~AutoString((AutoString *)valuePtr);
      goto LABEL_10;
    }
    v13 = 12;
  }
  valuePtr[0] = v13;
  valuePtr[1] = a1;
  CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v9, (int *)valuePtr);
  DispatchHost::performCallback(*((DispatchHost **)a4 + 1), (const __CFString *)&unk_1EDCFF6F8, CFErrorWithStreamError);
  if (CFErrorWithStreamError)
    CFRelease(CFErrorWithStreamError);
LABEL_10:
  if (a2)
    free(a2);
  if (a3)
    free(a3);
  return (*(uint64_t (**)(void *))(*(_QWORD *)a4 + 8))(a4);
}

void sub_1840928D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  const void *v13;

  if (v13)
    CFRelease(v13);
  AutoString::~AutoString((AutoString *)&a13);
  _Unwind_Resume(a1);
}

CFErrorRef HostLookup_Reachability::prepareLookup(HostLookup_Reachability *this, Host *a2)
{
  const __CFString *v3;
  const __SCNetworkReachability *Reachability;
  const __SCNetworkReachability *v5;
  const __CFAllocator *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  SCNetworkReachabilityContext context;

  *((_QWORD *)this + 4) = a2;
  CFRetain((char *)a2 - 16);
  Reachability = HostLookup_Reachability::CreateReachability(*((const __CFString **)this + 5), v3);
  if (Reachability)
  {
    v5 = Reachability;
    context.version = 0;
    context.info = this;
    memset(&context.retain, 0, 24);
    SCNetworkReachabilitySetCallback(Reachability, (SCNetworkReachabilityCallBack)HostLookup_Reachability::_ReachabilityCallback, &context);
    *((_QWORD *)this + 2) = CFRetain(v5);
    CFRelease(v5);
    return 0;
  }
  else
  {
    v7 = CFGetAllocator((char *)this - 16);
    return __cfnCreateCFError(v7, CFSTR("kCFErrorDomainCFNetwork"), 1, v8, v9, v10, v11, v12, 0);
  }
}

void `non-virtual thunk to'HostLookup_Reachability::~HostLookup_Reachability(HostLookup_Reachability *this)
{
  HostLookup_Reachability::~HostLookup_Reachability((HostLookup_Reachability *)((char *)this - 8));
}

{
  HostLookup_Reachability::~HostLookup_Reachability((HostLookup_Reachability *)((char *)this - 8));
}

void HostLookup_Reachability::~HostLookup_Reachability(HostLookup_Reachability *this)
{
  const void *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E14ECB68;
  *((_QWORD *)this + 1) = &unk_1E14ECBC0;
  v2 = (const void *)*((_QWORD *)this + 5);
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    CFRelease((CFTypeRef)(v3 - 16));
  HostLookup::~HostLookup(this);
}

void sub_184092A00(_Unwind_Exception *a1)
{
  HostLookup *v1;

  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

SCNetworkReachabilityRef HostLookup_Reachability::CreateReachability(const __CFString *this, const __CFString *a2)
{
  const __CFAllocator *v3;
  const __CFAllocator *v4;
  UInt8 *v5;
  uint64_t v6;
  SCNetworkReachabilityRef v7;
  const __CFAllocator *allocator;
  uint64_t v10;
  void *ptr;
  UInt8 v12[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = CFGetAllocator(this);
  v4 = v3;
  allocator = v3;
  v10 = 1023;
  if (this)
  {
    v5 = _CFStringGetOrCreateCString(v3, this, v12, &v10, 0x8000100u);
    v6 = v10;
  }
  else
  {
    v6 = 0;
    v12[0] = 0;
    v10 = 0;
    v5 = v12;
  }
  ptr = v5;
  if (v6 == strlen((const char *)v5))
  {
    v7 = SCNetworkReachabilityCreateWithName(v4, (const char *)v5);
    v5 = (UInt8 *)ptr;
    if (!ptr)
      return v7;
  }
  else
  {
    v7 = 0;
    if (!v5)
      return v7;
  }
  if (v12 != v5)
    CFAllocatorDeallocate(allocator, v5);
  return v7;
}

void sub_184092B18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  void *v11;

  if (ptr)
  {
    if (v11 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  _Unwind_Resume(exception_object);
}

void HostLookup_Reachability::_ReachabilityCallback(HostLookup_Reachability *this, const __SCNetworkReachability *a2, uint64_t a3, void *a4)
{
  const __CFAllocator *v5;
  CFDataRef v6;
  UInt8 bytes[4];

  *(_DWORD *)bytes = (_DWORD)a2;
  v5 = CFGetAllocator((CFTypeRef)(a3 - 16));
  v6 = CFDataCreate(v5, bytes, 4);
  Host::performCallback(*(Host **)(a3 + 32), (const __CFString *)&unk_1EDCFF730, v6);
  if (v6)
    CFRelease(v6);
}

void HostLookup_Reachability::HostLookup_Reachability(HostLookup_Reachability *this, CFTypeRef cf)
{
  *(_QWORD *)this = &off_1E14E4B50;
  *((_QWORD *)this + 1) = &unk_1E14E4BA8;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = CFRetain(&unk_1EDCFF730);
  *(_QWORD *)this = &off_1E14ECB68;
  *((_QWORD *)this + 1) = &unk_1E14ECBC0;
  *((_QWORD *)this + 5) = CFRetain(cf);
}

void sub_184092C14(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

SCNetworkReachabilityRef HostLookup_Reachability::CreateReachability(HostLookup_Reachability *this, const __CFData *a2)
{
  const __CFAllocator *v3;
  const sockaddr *BytePtr;

  v3 = CFGetAllocator(this);
  BytePtr = (const sockaddr *)CFDataGetBytePtr(this);
  return SCNetworkReachabilityCreateWithAddress(v3, BytePtr);
}

void _distpatch_HostLookup_Reachability__ReachabilityCallback(const __SCNetworkReachability *a1, int a2, char *cf)
{
  const __CFAllocator *v5;
  CFDataRef v6;
  DispatchHost *v7;
  UInt8 bytes[4];

  *(_DWORD *)bytes = a2;
  v5 = CFGetAllocator(cf);
  v6 = CFDataCreate(v5, bytes, 4);
  if (cf)
  {
    if (HostBase::Class(void)::sOnce_HostBase != -1)
      dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
    v7 = (DispatchHost *)(cf + 16);
  }
  else
  {
    v7 = 0;
  }
  DispatchHost::performCallback(v7, (const __CFString *)&unk_1EDCFF730, v6);
  if (v6)
    CFRelease(v6);
  SCNetworkReachabilitySetCallback(a1, 0, 0);
  SCNetworkReachabilitySetDispatchQueue(a1, 0);
  if (a1)
    CFRelease(a1);
}

CFErrorRef HostLookup_Reachability::enqueueWithHost(dispatch_queue_t *this, const __CFString *a2, const __CFString *a3)
{
  const __SCNetworkReachability *Reachability;
  const __SCNetworkReachability *v5;
  const __CFAllocator *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  SCNetworkReachabilityContext context;

  Reachability = HostLookup_Reachability::CreateReachability(a2, a2);
  if (Reachability)
  {
    v5 = Reachability;
    context.version = 0;
    context.info = this - 2;
    context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
    context.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
    context.copyDescription = (CFStringRef (__cdecl *)(const void *))MEMORY[0x1E0C98350];
    SCNetworkReachabilitySetCallback(Reachability, (SCNetworkReachabilityCallBack)_distpatch_HostLookup_Reachability__ReachabilityCallback, &context);
    SCNetworkReachabilitySetDispatchQueue(v5, this[18]);
    return 0;
  }
  else
  {
    v7 = CFGetAllocator(this - 2);
    return __cfnCreateCFError(v7, CFSTR("kCFErrorDomainCFNetwork"), 1, v8, v9, v10, v11, v12, 0);
  }
}

void sub_184092E60(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_184093164(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_184093AC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_184094824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;
  void *v25;
  void *v26;
  void *v27;

  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__9397(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__9398(uint64_t a1)
{

}

void sub_184094AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

CFErrorRef HostLookup_ReachabilityFixed::prepareLookup(HostLookup_ReachabilityFixed *this, Host *a2)
{
  const __CFString *v3;
  const __CFString *v4;
  const __SCNetworkReachability *Reachability;
  HostLookup_Reachability *v6;
  const __SCNetworkReachability *v7;
  const __CFAllocator *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  *((_QWORD *)this + 6) = a2;
  CFRetain((char *)a2 - 16);
  v4 = (const __CFString *)*((_QWORD *)this + 7);
  if (v4)
  {
    Reachability = HostLookup_Reachability::CreateReachability(v4, v3);
  }
  else
  {
    v6 = (HostLookup_Reachability *)*((_QWORD *)this + 8);
    if (!v6)
      goto LABEL_7;
    Reachability = HostLookup_Reachability::CreateReachability(v6, (const __CFData *)v3);
  }
  v7 = Reachability;
  if (Reachability)
  {
    SCNetworkReachabilityGetFlags(Reachability, (SCNetworkReachabilityFlags *)this + 18);
    SCNetworkReachabilitySetCallback(v7, 0, 0);
    CFRelease(v7);
    (*(void (**)(HostLookup_ReachabilityFixed *))(*(_QWORD *)this + 72))(this);
    return 0;
  }
LABEL_7:
  v9 = CFGetAllocator((char *)this - 16);
  return __cfnCreateCFError(v9, CFSTR("kCFErrorDomainCFNetwork"), 1, v10, v11, v12, v13, v14, 0);
}

void HostLookup_ReachabilityFixed::perform(HostLookup_ReachabilityFixed *this)
{
  CFDataRef v2;

  v2 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)this + 72, 4);
  Host::performCallback(*((Host **)this + 6), (const __CFString *)&unk_1EDCFF730, v2);
  if (v2)
    CFRelease(v2);
}

void `non-virtual thunk to'HostLookup_ReachabilityFixed::~HostLookup_ReachabilityFixed(HostLookup_ReachabilityFixed *this)
{
  HostLookup_ReachabilityFixed::~HostLookup_ReachabilityFixed((HostLookup_ReachabilityFixed *)((char *)this - 8));
}

{
  HostLookup_ReachabilityFixed::~HostLookup_ReachabilityFixed((HostLookup_ReachabilityFixed *)((char *)this - 8));
}

void HostLookup_ReachabilityFixed::~HostLookup_ReachabilityFixed(HostLookup_ReachabilityFixed *this)
{
  const void *v2;
  const void *v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E14EE838;
  *((_QWORD *)this + 1) = &unk_1E14EE8A0;
  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 8);
  if (v3)
    CFRelease(v3);
  v4 = *((_QWORD *)this + 6);
  if (v4)
    CFRelease((CFTypeRef)(v4 - 16));
  HostLookup_RunLoopSource::~HostLookup_RunLoopSource(this);
}

void sub_184094C68(_Unwind_Exception *a1)
{
  HostLookup_RunLoopSource *v1;

  HostLookup_RunLoopSource::~HostLookup_RunLoopSource(v1);
  _Unwind_Resume(a1);
}

BOOL HostLookup_ReachabilityFixed::isDottedIP(const __CFString *this, const __CFString *a2)
{
  _BOOL8 v3;
  addrinfo *v5;
  addrinfo v6;
  CFAllocatorRef allocator;
  uint64_t v8;
  void *ptr;
  UInt8 v10[1024];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  allocator = CFGetAllocator(this);
  v8 = 1023;
  ptr = _CFStringGetOrCreateCString(allocator, this, v10, &v8, 0x600u);
  v5 = 0;
  memset(&v6, 0, sizeof(v6));
  v6.ai_flags = 4;
  v3 = 0;
  if (!getaddrinfo((const char *)ptr, 0, &v6, &v5) && v5)
  {
    v3 = v5->ai_addr != 0;
    freeaddrinfo(v5);
  }
  if (ptr && v10 != ptr)
    CFAllocatorDeallocate(allocator, ptr);
  return v3;
}

void sub_184094D64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFAllocatorRef allocator, uint64_t a18, void *ptr)
{
  _Unwind_Resume(exception_object);
}

void HostLookup_ReachabilityFixed::HostLookup_ReachabilityFixed(HostLookup_ReachabilityFixed *this, const __CFString *a2)
{
  _QWORD *v4;

  HostLookup_RunLoopSource::HostLookup_RunLoopSource(this, &unk_1EDCFF730);
  *v4 = &off_1E14EE838;
  v4[1] = &unk_1E14EE8A0;
  *((_QWORD *)this + 7) = CFRetain(a2);
}

void sub_184094DE0(_Unwind_Exception *a1)
{
  HostLookup_RunLoopSource *v1;

  HostLookup_RunLoopSource::~HostLookup_RunLoopSource(v1);
  _Unwind_Resume(a1);
}

void HostLookup_ReachabilityFixed::HostLookup_ReachabilityFixed(HostLookup_ReachabilityFixed *this, const __CFData *a2)
{
  _QWORD *v4;

  HostLookup_RunLoopSource::HostLookup_RunLoopSource(this, &unk_1EDCFF730);
  *v4 = &off_1E14EE838;
  v4[1] = &unk_1E14EE8A0;
  *((_QWORD *)this + 8) = CFRetain(a2);
}

void sub_184094E44(_Unwind_Exception *a1)
{
  HostLookup_RunLoopSource *v1;

  HostLookup_RunLoopSource::~HostLookup_RunLoopSource(v1);
  _Unwind_Resume(a1);
}

CFErrorRef enqueueWithHost(DispatchHost *a1, SCNetworkReachabilityRef target)
{
  const __CFAllocator *v4;
  CFDataRef v5;
  const __CFAllocator *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  SCNetworkReachabilityFlags flags;

  if (target)
  {
    flags = 0;
    SCNetworkReachabilityGetFlags(target, &flags);
    v4 = CFGetAllocator((char *)a1 - 16);
    v5 = CFDataCreate(v4, (const UInt8 *)&flags, 4);
    DispatchHost::performCallback(a1, (const __CFString *)&unk_1EDCFF730, v5);
    if (v5)
      CFRelease(v5);
    CFRelease(target);
    return 0;
  }
  else
  {
    v7 = CFGetAllocator((char *)a1 - 16);
    return __cfnCreateCFError(v7, CFSTR("kCFErrorDomainCFNetwork"), 1, v8, v9, v10, v11, v12, 0);
  }
}

void HostLookup_RunLoopSource::lookupInvalidated(HostLookup_RunLoopSource *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    CFRelease(v2);
}

void HostLookup_RunLoopSource::signal(CFRunLoopSourceRef *this)
{
  __CFRunLoop *v2;

  CFRunLoopSourceSignal(this[4]);
  v2 = this[5];
  if (v2)
    CFRunLoopWakeUp(v2);
}

void HostLookup_RunLoopSource::HostLookup_RunLoopSource(HostLookup_RunLoopSource *this, CFTypeRef cf)
{
  CFTypeRef v3;
  const __CFAllocator *v4;
  const void *v5;
  CFRunLoopSourceContext v6;

  *(_QWORD *)this = &off_1E14E4B50;
  *((_QWORD *)this + 1) = &unk_1E14E4BA8;
  *((_QWORD *)this + 2) = 0;
  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  *((_QWORD *)this + 3) = v3;
  *(_QWORD *)this = &off_1E14ECFA0;
  *((_QWORD *)this + 1) = &unk_1E14ED008;
  v6.version = 0;
  v6.info = (char *)this - 16;
  v6.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  v6.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  v6.copyDescription = (CFStringRef (__cdecl *)(const void *))MEMORY[0x1E0C98350];
  v6.equal = 0;
  v6.hash = 0;
  v6.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))_logSchedule;
  v6.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))_logCancel;
  v6.perform = (void (__cdecl *)(void *))HostLookup_RunLoopSource::_Perform;
  *((_QWORD *)this + 5) = 0;
  v4 = CFGetAllocator((char *)this - 16);
  v5 = CFRunLoopSourceCreate(v4, 0, &v6);
  *((_QWORD *)this + 4) = v5;
  if (v5)
    v5 = CFRetain(v5);
  *((_QWORD *)this + 2) = v5;
}

void sub_184095034(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

CFTypeRef _logSchedule(_QWORD *a1, CFTypeRef cf, const __CFString *a3)
{
  _QWORD *v4;
  CFTypeRef result;

  v4 = a1;
  if (a1)
  {
    if (HostLookup::Class(void)::sOnce_HostLookup != -1)
      dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_8707);
    v4 += 2;
  }
  result = (CFTypeRef)v4[5];
  if (result != cf)
  {
    if (result)
      CFRelease(result);
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    v4[5] = result;
  }
  return result;
}

uint64_t HostLookup_RunLoopSource::_Perform(HostLookup_RunLoopSource *this, void *a2)
{
  if (HostLookup::Class(void)::sOnce_HostLookup != -1)
    dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_8707);
  return (*(uint64_t (**)(char *))(*((_QWORD *)this + 2) + 80))((char *)this + 16);
}

void HostLookup_RunLoopSource::~HostLookup_RunLoopSource(HostLookup_RunLoopSource *this)
{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = &off_1E14ECFA0;
  *((_QWORD *)this + 1) = &unk_1E14ED008;
  v2 = (const void *)*((_QWORD *)this + 4);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    CFRelease(v3);
  HostLookup::~HostLookup(this);
}

void sub_184095174(_Unwind_Exception *a1)
{
  HostLookup *v1;

  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

void URLConnectionInstanceData::~URLConnectionInstanceData(URLConnectionInstanceData *this)
{
  NSObject *v2;

  *(_QWORD *)this = off_1E14ED770;
  *((_QWORD *)this + 2) = &unk_1E14ED798;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    dispatch_release(v2);
    *((_QWORD *)this + 5) = 0;
  }
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = &off_1E14E5838;
}

{
  NSObject *v2;

  *(_QWORD *)this = off_1E14ED770;
  *((_QWORD *)this + 2) = &unk_1E14ED798;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    dispatch_release(v2);
    *((_QWORD *)this + 5) = 0;
  }
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

void `non-virtual thunk to'URLConnectionInstanceData::~URLConnectionInstanceData(URLConnectionInstanceData *this)
{
  NSObject *v2;

  *((_QWORD *)this - 2) = off_1E14ED770;
  *(_QWORD *)this = &unk_1E14ED798;
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    dispatch_release(v2);
    *((_QWORD *)this + 3) = 0;
  }
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E14E5838;
}

{
  char *v2;
  NSObject *v3;

  *((_QWORD *)this - 2) = off_1E14ED770;
  v2 = (char *)this - 16;
  *(_QWORD *)this = &unk_1E14ED798;
  v3 = *((_QWORD *)this + 3);
  if (v3)
  {
    dispatch_release(v3);
    *((_QWORD *)this + 3) = 0;
  }
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 1), v2);
}

CFStringRef URLConnectionClient::copyDebugDesc(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat(this[1], 0, CFSTR("<URLConnectionClient@%p>"), this);
}

CFTypeRef URLConnectionClient::copyDebugSummary(URLConnectionClient *this)
{
  void *v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;

  v1 = (void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 27) + 200))(*((_QWORD *)this + 27));
  if (!v1)
    return CFRetain(CFSTR("no original request"));
  v2 = v1;
  v3 = objc_msgSend(v1, "_inner");
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);

  return (CFTypeRef)v4;
}

BOOL URLConnectionClient::_connectionClientInterface_canUpdateForCFURLDownload(URLConnectionClient *this)
{
  return !*((_QWORD *)this + 24) && *((_QWORD *)this + 28) > 0;
}

void URLConnectionClient::_loaderClientEvent_asyncError(CFAllocatorRef *this, const __CFString *a2, CFIndex a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFErrorRef CFError;

  CFError = __cfnCreateCFError(this[1], a2, a3, a4, a5, a6, a7, a8, 0);
  (*((void (**)(CFAllocatorRef *, CFErrorRef))*this + 31))(this, CFError);
  if (CFError)
    CFRelease(CFError);
}

void URLConnectionClient::_connectionClientInterface_becomeForDownloadIfSafeToDoSo(uint64_t a1, uint64_t a2)
{
  const void *v4;
  __int16 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _QWORD v11[4];
  char v12;
  _QWORD v13[6];
  _QWORD v14[6];
  _QWORD block[6];

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    v4 = *(const void **)(a1 + 176);
    *(_QWORD *)(a1 + 176) = 0;
    *(_QWORD *)(a1 + 184) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 72));
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 288))(a1, a2);
    v5 = *(_WORD *)(a1 + 76);
    if ((v5 & 0x20) == 0)
    {
      *(_WORD *)(a1 + 76) = v5 | 0x20;
      v6 = *(_QWORD *)(a1 + 216);
      v7 = MEMORY[0x1E0C809B0];
      v11[0] = MEMORY[0x1E0C809B0];
      v11[1] = 3221225472;
      v11[2] = ___ZN19URLConnectionClient31forceProtocolToUseLargeDownloadEh_block_invoke;
      v11[3] = &__block_descriptor_33_e29_v16__0__LoaderInterface_____8l;
      v12 = 1;
      CFRetain((CFTypeRef)(v6 - 16));
      v8 = *(_QWORD *)(v6 + 32);
      v13[0] = v7;
      v13[1] = 3221225472;
      v13[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9489;
      v13[3] = &unk_1E14FABB8;
      v13[4] = v11;
      v13[5] = v6;
      v14[0] = v7;
      v14[1] = 3221225472;
      v14[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9490;
      v14[3] = &unk_1E14FDA90;
      v14[4] = v13;
      v14[5] = v8;
      v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v8 + 32) + 64))(*(_QWORD *)(v8 + 32));
      v10 = *(NSObject **)(v8 + 40);
      block[0] = v7;
      block[1] = 3221225472;
      block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
      block[3] = &unk_1E14FDA90;
      block[4] = v14;
      block[5] = v9;
      dispatch_async(v10, block);
      v5 = *(_WORD *)(a1 + 76);
    }
    *(_WORD *)(a1 + 76) = v5 & 0xFFF7;
    if (v4)
    {
      (*(void (**)(uint64_t, const void *, _QWORD))(*(_QWORD *)a1 + 216))(a1, v4, 0);
      CFRelease(v4);
    }
    if ((v5 & 8) != 0)
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 240))(a1);
  }
}

uint64_t URLConnectionClient::_loaderClientEvent_WillSendRequestForRedirection(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  const void *v8;
  CFTypeRef v9;
  CFTypeRef v11;
  CFTypeRef v12;
  _QWORD v13[6];

  if ((*(_WORD *)(a1 + 76) & 8) != 0)
    return (*(uint64_t (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
  if (a2)
  {
    if (a3)
    {
      v8 = *(const void **)(objc_msgSend(a3, "_inner") + 80);
      if (v8)
        v9 = CFRetain(v8);
      else
        v9 = 0;
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 208));
      v11 = *(CFTypeRef *)(a1 + 200);
      if (v11 != v9)
      {
        if (v11)
          CFRelease(v11);
        if (v9)
          v12 = CFRetain(v9);
        else
          v12 = 0;
        *(_QWORD *)(a1 + 200) = v12;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 208));
      if (v9)
        CFRelease(v9);
    }
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = ___ZN19URLConnectionClient48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke;
    v13[3] = &unk_1E14FA960;
    v13[4] = a4;
    v13[5] = a1;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, _QWORD *))(*(_QWORD *)(a1 + 48) + 32))(a1 + 48, a2, a3, v13);
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
    return (*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)a1 + 104))(a1, CFSTR("kCFErrorDomainCFNetwork"), -1002);
  }
}

void URLConnectionClient::_loaderClientEvent_NeedNewBodyStream(URLConnectionClient *this)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFErrorRef CFError;
  _QWORD v10[5];

  if ((*((_WORD *)this + 38) & 8) == 0)
  {
    v2 = (char *)this + 48;
    if ((*(unsigned int (**)(char *))(*((_QWORD *)this + 6) + 16))((char *)this + 48))
    {
      v8 = objc_msgSend(*((id *)this + 11), "currentRequest");
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 3221225472;
      v10[2] = ___ZN19URLConnectionClient36_loaderClientEvent_NeedNewBodyStreamEv_block_invoke;
      v10[3] = &__block_descriptor_40_e25_v16__0____CFReadStream__8l;
      v10[4] = this;
      (*(void (**)(char *, uint64_t, _QWORD *))(*((_QWORD *)this + 6) + 64))(v2, v8, v10);
    }
    else
    {
      CFError = __cfnCreateCFError(*((CFAllocatorRef *)this + 1), CFSTR("kCFErrorDomainCFNetwork"), -1021, v3, v4, v5, v6, v7, 0);
      (*(void (**)(URLConnectionClient *, CFErrorRef))(*(_QWORD *)this + 248))(this, CFError);
      if (CFError)
        CFRelease(CFError);
    }
  }
}

uint64_t URLConnectionClient::_loaderClientEvent_WillSendRequestForEstablishedConnection(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[7];

  if ((*(_WORD *)(a1 + 76) & 8) != 0)
    return (*(uint64_t (**)(uint64_t, _QWORD))(a3 + 16))(a3, 0);
  if (objc_msgSend(*(id *)(a1 + 88), "currentRequest"))
  {
    v6 = objc_msgSend(*(id *)(a1 + 88), "currentRequest");
    if (a2)
      CFRetain(a2);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___ZN19URLConnectionClient58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke;
    v8[3] = &unk_1E14FA938;
    v8[4] = a3;
    v8[5] = a1;
    v8[6] = a2;
    return (*(uint64_t (**)(uint64_t, uint64_t, const void *, _QWORD *))(*(_QWORD *)(a1 + 48) + 40))(a1 + 48, v6, a2, v8);
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD))(a3 + 16))(a3, 0);
    return (*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)a1 + 104))(a1, CFSTR("kCFErrorDomainCFNetwork"), -1002);
  }
}

uint64_t URLConnectionClient::_loaderClientEvent_ConnectionWaiting(uint64_t result)
{
  if ((*(_WORD *)(result + 76) & 8) == 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result + 48) + 48))(result + 48);
  return result;
}

uint64_t URLConnectionClient::_loaderClientEvent_ConditionalRequirementsChanged(uint64_t this)
{
  if ((*(_WORD *)(this + 76) & 8) == 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(this + 48) + 56))(this + 48);
  return this;
}

void URLConnectionClient::_loaderClientEvent_DidReceiveData(URLConnectionClient *this, CFArrayRef theArray, uint64_t a3)
{
  __int16 v4;
  uint64_t TotalSizeOfDataArrayData;
  __CFArray *v7;
  __CFArray *v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __CFArray *v13;
  CFTypeRef *v14;
  uint64_t v15;
  uint64_t v16;
  __int16 v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  CFRange v21;
  CFRange v22;
  CFRange v23;

  v20 = *MEMORY[0x1E0C80C00];
  if (a3)
    __assert_rtn("_loaderClientEvent_DidReceiveData", "URLConnectionClient.cpp", 867, "dispatchData == nullptr");
  v4 = *((_WORD *)this + 38);
  if ((v4 & 8) == 0)
  {
    if ((v4 & 0x80) != 0)
    {
      URLConnectionClient::sniffAndSendDidReceiveResponse(this, theArray);
      v4 = *((_WORD *)this + 38);
    }
    if ((v4 & 4) == 0)
    {
      TotalSizeOfDataArrayData = GetTotalSizeOfDataArrayData(theArray);
      os_unfair_lock_lock((os_unfair_lock_t)this + 18);
      v7 = (__CFArray *)*((_QWORD *)this + 22);
      if (v7)
      {
        v21.length = CFArrayGetCount(theArray);
        v21.location = 0;
        CFArrayAppendArray(v7, theArray, v21);
        *((_QWORD *)this + 23) += TotalSizeOfDataArrayData;
        if (!theArray)
          goto LABEL_23;
      }
      else
      {
        *((_QWORD *)this + 22) = CFArrayCreateMutableCopy(*((CFAllocatorRef *)this + 1), 0, theArray);
        *((_QWORD *)this + 23) = TotalSizeOfDataArrayData;
        if (!theArray)
        {
LABEL_23:
          v17 = *((_WORD *)this + 38);
          if ((v17 & 0x80) != 0
            || (*((_WORD *)this + 38) & 0x200) != 0
            || *((_QWORD *)this + 23) < *((_QWORD *)this + 15))
          {
            os_unfair_lock_unlock((os_unfair_lock_t)this + 18);
          }
          else
          {
            *((_WORD *)this + 38) = v17 | 0x200;
            os_unfair_lock_unlock((os_unfair_lock_t)this + 18);
            (*(void (**)(char *))(*((_QWORD *)this + 6) + 120))((char *)this + 48);
          }
          return;
        }
      }
      v14 = (CFTypeRef *)((char *)this + 144);
      v13 = (__CFArray *)*((_QWORD *)this + 18);
      if (v13)
      {
        v23.length = CFArrayGetCount(theArray);
        v23.location = 0;
        CFArrayAppendArray(v13, theArray, v23);
        v15 = *((_QWORD *)this + 20);
        v16 = *((_QWORD *)this + 19) + TotalSizeOfDataArrayData;
        *((_QWORD *)this + 19) = v16;
        if (v16 > v15)
        {
          CFRelease(*v14);
          *v14 = 0;
          *((_QWORD *)this + 19) = 0;
        }
      }
      goto LABEL_23;
    }
    v8 = (__CFArray *)*((_QWORD *)this + 13);
    if ((v4 & 0x80) != 0)
    {
      if (v8)
      {
        v22.length = CFArrayGetCount(theArray);
        v22.location = 0;
        CFArrayAppendArray(v8, theArray, v22);
      }
      else
      {
        *((_QWORD *)this + 13) = CFArrayCreateMutableCopy(*((CFAllocatorRef *)this + 1), 0, theArray);
      }
    }
    else
    {
      if (v8)
      {
        v8 = (__CFArray *)GetTotalSizeOfDataArrayData(*((const __CFArray **)this + 13));
        (*(void (**)(char *, _QWORD))(*((_QWORD *)this + 6) + 128))((char *)this + 48, *((_QWORD *)this + 13));
        v9 = (const void *)*((_QWORD *)this + 13);
        *((_QWORD *)this + 13) = 0;
        if (v9)
          CFRelease(v9);
      }
      (*(void (**)(char *, CFArrayRef))(*((_QWORD *)this + 6) + 128))((char *)this + 48, theArray);
      v10 = GetTotalSizeOfDataArrayData(theArray);
      v11 = *((_QWORD *)this + 12);
      if ((v11 & 0x8000000000000000) == 0)
      {
        v12 = v11 - ((_QWORD)v8 + v10);
        *((_QWORD *)this + 12) = v12;
        if (v12 < 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          v18 = 134217984;
          v19 = v12;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "delivered more bytes than we thought we should, %ld", (uint8_t *)&v18, 0xCu);
        }
      }
    }
  }
}

uint64_t URLConnectionClient::_loaderClientEvent_DidSendBodyData(uint64_t this, UploadProgressInfo *a2)
{
  UploadProgressInfo v2;

  if ((*(_WORD *)(this + 76) & 8) == 0)
  {
    v2 = *a2;
    return (*(uint64_t (**)(uint64_t, UploadProgressInfo *))(*(_QWORD *)(this + 48) + 144))(this + 48, &v2);
  }
  return this;
}

uint64_t URLConnectionClient::_loaderClientEvent_HandleCacheResponseIsValid(uint64_t this, const _CFCachedURLResponse *a2)
{
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  _QWORD v7[6];
  uint8_t buf[16];

  if ((*(_BYTE *)(this + 76) & 8) != 0)
    return this;
  v3 = this;
  if ((*(_BYTE *)(this + 76) & 4) == 0
    && *(_QWORD *)(this + 112)
    && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "assertion failure", buf, 2u);
  }
  v4 = (void *)CFCachedURLResponseCopyWrappedResponse(a2);
  v5 = v4;
  v6 = *(void **)(v3 + 112);
  if (v6 == v4)
  {

    if (!a2)
      goto LABEL_9;
    goto LABEL_8;
  }

  *(_QWORD *)(v3 + 112) = v5;
  if (a2)
LABEL_8:
    CFRetain(a2);
LABEL_9:
  if ((objc_msgSend(*(id *)(v3 + 88), "_isAVAssetTask") & 1) == 0)
    -[__CFN_TaskMetrics completeWithError:](objc_msgSend(*(id *)(v3 + 88), "_metrics"), 0);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN19URLConnectionClient45_loaderClientEvent_HandleCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke;
  v7[3] = &__block_descriptor_48_e14_v16__0___v___8l;
  v7[4] = v3;
  v7[5] = a2;
  return URLConnectionClient::terminalEvent(v3, (uint64_t)v7);
}

void URLConnectionClient::_loaderClientEvent_DidFailWithError(URLConnectionClient *this, __CFError *a2)
{
  NSObject *v4;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  const void *Value;
  CFTypeRef v8;
  const void *v9;
  const void *v10;
  const __CFURL *v11;
  CFIndex v12;
  uint64_t v13;
  const __CFString *v14;
  const void *v15;
  const void *LocalizedString;
  uint64_t v17;
  const void *v18;
  const void *v19;
  uint64_t v20;
  const void *v21;
  const __CFDictionary *v22;
  const __CFAllocator *v23;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  __CFDictionary *v26;
  CFStringRef v27;
  const __CFAllocator *v28;
  const __CFString *Domain;
  uint64_t v30;
  _QWORD v31[6];
  uint8_t buf[4];
  CFIndex Code;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if ((*((_WORD *)this + 38) & 8) == 0)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      Code = CFErrorGetCode(a2);
      _os_log_error_impl(&dword_183ECA000, v4, OS_LOG_TYPE_ERROR, "NSURLConnection finished with error - code %ld", buf, 0xCu);
    }
    v5 = CFErrorCopyUserInfo(a2);
    if (v5)
    {
      v6 = v5;
      Value = CFDictionaryGetValue(v5, CFSTR("NSErrorPeerAddressKey"));
      if (Value)
      {
        v8 = CFRetain(Value);
        if (v8)
        {
          v9 = v8;
          os_unfair_lock_lock((os_unfair_lock_t)this + 52);
          v10 = (const void *)*((_QWORD *)this + 25);
          if (v10 != v9)
          {
            if (v10)
              CFRelease(v10);
            *((_QWORD *)this + 25) = CFRetain(v9);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)this + 52);
          CFRelease(v9);
        }
      }
      CFRelease(v6);
    }
    if (objc_msgSend(*((id *)this + 11), "currentRequest"))
      v11 = (const __CFURL *)objc_msgSend((id)objc_msgSend(*((id *)this + 11), "currentRequest"), "URL");
    else
      v11 = 0;
    v12 = CFErrorGetCode(a2);
    v13 = v12;
    if (v11)
    {
      v14 = CFURLCopyHostName(v11);
      v15 = _CFNetworkErrorCopyLocalizedDescriptionWithHostname(v13, v14);
      if (v14)
        CFRelease(v14);
    }
    else
    {
      LocalizedString = _CFNetworkErrorGetLocalizedString(v12, 0);
      if (LocalizedString)
        v15 = CFRetain(LocalizedString);
      else
        v15 = 0;
    }
    v17 = (2 * (v11 != 0)) | (v15 != 0);
    v18 = _CFNetworkErrorGetLocalizedString(v13, 2);
    if (v18)
      ++v17;
    v19 = _CFNetworkErrorGetLocalizedString(v13, 3);
    if (v19)
      v20 = v17 + 1;
    else
      v20 = v17;
    if (v20)
    {
      v21 = v19;
      v22 = CFErrorCopyUserInfo(a2);
      v23 = (const __CFAllocator *)*((_QWORD *)this + 1);
      Count = CFDictionaryGetCount(v22);
      MutableCopy = CFDictionaryCreateMutableCopy(v23, Count + v20, v22);
      v26 = MutableCopy;
      if (v11)
      {
        CFDictionaryAddValue(MutableCopy, CFSTR("NSErrorFailingURLKey"), v11);
        v27 = CFURLGetString(v11);
        CFDictionaryAddValue(v26, CFSTR("NSErrorFailingURLStringKey"), v27);
      }
      if (v15)
        CFDictionaryAddValue(v26, (const void *)*MEMORY[0x1E0C9AFE0], v15);
      if (v18)
        CFDictionaryAddValue(v26, (const void *)*MEMORY[0x1E0C9AFE8], v18);
      if (v21)
        CFDictionaryAddValue(v26, (const void *)*MEMORY[0x1E0C9AFF0], v21);
      if (v22)
        CFRelease(v22);
      v28 = (const __CFAllocator *)*((_QWORD *)this + 1);
      Domain = CFErrorGetDomain(a2);
      a2 = CFErrorCreate(v28, Domain, v13, v26);
      if (v26)
        CFRelease(v26);
    }
    else if (a2)
    {
      a2 = (__CFError *)CFRetain(a2);
    }
    v30 = objc_msgSend(*((id *)this + 11), "currentRequest");
    if (v30 && v11 && !*((_QWORD *)this + 14))
      *((_QWORD *)this + 14) = CFURLResponseCreate(v30, v11, 0, -1, 0, 2);
    if ((objc_msgSend(*((id *)this + 11), "_isAVAssetTask") & 1) == 0)
      -[__CFN_TaskMetrics completeWithError:](objc_msgSend(*((id *)this + 11), "_metrics"), a2);
    v31[0] = MEMORY[0x1E0C809B0];
    v31[1] = 3221225472;
    v31[2] = ___ZN19URLConnectionClient35_loaderClientEvent_DidFailWithErrorEP9__CFError_block_invoke;
    v31[3] = &__block_descriptor_48_e14_v16__0___v___8l;
    v31[4] = this;
    v31[5] = a2;
    URLConnectionClient::terminalEvent((uint64_t)this, (uint64_t)v31);
    if (v15)
      CFRelease(v15);
  }
}

void URLConnectionClient::_loaderClientEvent_DidTimeout(URLConnectionClient *this)
{
  os_unfair_lock_s *v2;
  const void *v3;
  CFTypeRef v4;
  const __CFAllocator *v5;
  CFIndex v6;
  const __CFDictionary *v7;
  unint64_t v8;
  uint64_t v9;
  const void *v10;
  CFErrorRef v11;
  int valuePtr;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  if ((*((_WORD *)this + 38) & 8) == 0)
  {
    v2 = (os_unfair_lock_s *)((char *)this + 208);
    os_unfair_lock_lock((os_unfair_lock_t)this + 52);
    v3 = (const void *)*((_QWORD *)this + 25);
    if (v3)
      v4 = CFRetain(v3);
    else
      v4 = 0;
    os_unfair_lock_unlock(v2);
    valuePtr = -2102;
    keys[0] = CFSTR("_kCFStreamErrorDomainKey");
    keys[1] = CFSTR("_kCFStreamErrorCodeKey");
    keys[2] = CFSTR("NSErrorPeerAddressKey");
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &kCFStreamErrorDomainHTTP);
    values[1] = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
    values[2] = (void *)v4;
    if (v4)
      v6 = 3;
    else
      v6 = 2;
    v7 = CFDictionaryCreate(v5, (const void **)keys, (const void **)values, v6, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v8 = 0;
    v9 = 8 * v6;
    do
    {
      v10 = values[v8 / 8];
      if (v10)
        CFRelease(v10);
      v8 += 8;
    }
    while (v9 != v8);
    v11 = CFErrorCreate(*((CFAllocatorRef *)this + 1), CFSTR("kCFErrorDomainCFNetwork"), -1001, v7);
    if (v7)
      CFRelease(v7);
    (*(void (**)(URLConnectionClient *, CFErrorRef))(*(_QWORD *)this + 248))(this, v11);
    if (v11)
      CFRelease(v11);
  }
}

void URLConnectionClient::_loaderClientEvent_capturedSocketStreams(URLConnectionClient *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream)
    CFReadStreamClose(stream);
  if (a3)
    CFWriteStreamClose(a3);
}

uint64_t URLConnectionClient::_loaderClientEvent_captureTransportConnection(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 152))(result, 0);
  return result;
}

BOOL URLConnectionClient::isInvalidatingOrInvalid(URLConnectionClient *this)
{
  return (*((_WORD *)this + 38) & 0x40) != 0
      || (*(unsigned int (**)(URLConnectionClient *))(*(_QWORD *)this + 64))(this) != 0;
}

BOOL `non-virtual thunk to'URLConnectionClient::_connectionClientInterface_canUpdateForCFURLDownload(URLConnectionClient *this)
{
  return !*((_QWORD *)this + 17) && *((_QWORD *)this + 21) > 0;
}

void `non-virtual thunk to'URLConnectionClient::_connectionClientInterface_becomeForDownloadIfSafeToDoSo(uint64_t a1, uint64_t a2)
{
  URLConnectionClient::_connectionClientInterface_becomeForDownloadIfSafeToDoSo(a1 - 56, a2);
}

uint64_t `non-virtual thunk to'URLConnectionClient::_loaderClient_SupportsDispatchData(URLConnectionClient *this)
{
  return 0;
}

uint64_t `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_WillSendRequestForRedirection(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  return URLConnectionClient::_loaderClientEvent_WillSendRequestForRedirection(a1 - 64, a2, a3, a4);
}

uint64_t `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_WillSendRequestForEstablishedConnection(uint64_t a1, const void *a2, uint64_t a3)
{
  return URLConnectionClient::_loaderClientEvent_WillSendRequestForEstablishedConnection(a1 - 64, a2, a3);
}

void `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_NeedNewBodyStream(URLConnectionClient *this)
{
  URLConnectionClient::_loaderClientEvent_NeedNewBodyStream((URLConnectionClient *)((char *)this - 64));
}

void `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidReceiveData(uint64_t a1, const __CFArray *a2, uint64_t a3)
{
  URLConnectionClient::_loaderClientEvent_DidReceiveData((URLConnectionClient *)(a1 - 64), a2, a3);
}

uint64_t `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidSendBodyData(uint64_t this, UploadProgressInfo *a2)
{
  UploadProgressInfo v2;

  if ((*(_WORD *)(this + 12) & 8) == 0)
  {
    v2 = *a2;
    return (*(uint64_t (**)(uint64_t, UploadProgressInfo *))(*(_QWORD *)(this - 16) + 144))(this - 16, &v2);
  }
  return this;
}

uint64_t `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_HandleCacheResponseIsValid(URLConnectionClient *this, const _CFCachedURLResponse *a2)
{
  return URLConnectionClient::_loaderClientEvent_HandleCacheResponseIsValid((uint64_t)this - 64, a2);
}

void `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidFailWithError(URLConnectionClient *this, __CFError *a2)
{
  URLConnectionClient::_loaderClientEvent_DidFailWithError((URLConnectionClient *)((char *)this - 64), a2);
}

void `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidTimeout(URLConnectionClient *this)
{
  URLConnectionClient::_loaderClientEvent_DidTimeout((URLConnectionClient *)((char *)this - 64));
}

uint64_t `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_ConnectionWaiting(uint64_t result)
{
  if ((*(_WORD *)(result + 12) & 8) == 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(result - 16) + 48))(result - 16);
  return result;
}

uint64_t `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_ConditionalRequirementsChanged(uint64_t this)
{
  if ((*(_WORD *)(this + 12) & 8) == 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(this - 16) + 56))(this - 16);
  return this;
}

void `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_asyncError(CFAllocatorRef *this, const __CFString *a2, CFIndex a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  URLConnectionClient::_loaderClientEvent_asyncError(this - 8, a2, a3, a4, a5, a6, a7, a8);
}

void `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_capturedSocketStreams(URLConnectionClient *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream)
    CFReadStreamClose(stream);
  if (a3)
    CFWriteStreamClose(a3);
}

uint64_t `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_captureTransportConnection(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 152))(result, 0);
  return result;
}

void ___ZN19URLConnectionClient41_internal_WillSendRequestPartOnePointFiveEP12NSURLRequest_block_invoke(uint64_t a1, char a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[6];
  char v7;
  _QWORD block[6];

  v2 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN19URLConnectionClient41_internal_WillSendRequestPartOnePointFiveEP12NSURLRequest_block_invoke_2;
  v6[3] = &unk_1E14FA8C0;
  v3 = *(_QWORD *)(a1 + 40);
  v6[4] = *(_QWORD *)(a1 + 32);
  v6[5] = v3;
  v7 = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 32) + 64))(*(_QWORD *)(v3 + 32));
  v5 = *(NSObject **)(v3 + 40);
  block[0] = v2;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void ___ZN19URLConnectionClient41_internal_WillSendRequestPartOnePointFiveEP12NSURLRequest_block_invoke_2(uint64_t a1)
{
  const void *v2;

  URLConnectionClient::_internalEvent_WillSendRequestPartTwo(*(id **)(a1 + 40), *(NSURLRequest **)(a1 + 32), *(_BYTE *)(a1 + 48) == 0);
  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
}

void ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9489(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9490(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN19URLConnectionClient35_loaderClientEvent_DidFailWithErrorEP9__CFError_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) + 88))(*(_QWORD *)(a1 + 32) + 48, *(_QWORD *)(a1 + 40), a2);
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
}

uint64_t URLConnectionClient::sniffAndSendDidReceiveResponse(URLConnectionClient *this, CFArrayRef theArray)
{
  uint64_t result;
  uint64_t v5;
  CFIndex v6;
  const __CFData *ValueAtIndex;
  uint64_t Length;
  CFIndex v9;
  __CFData *v10;
  const UInt8 *BytePtr;
  const __CFData *v12;
  uint64_t v13;
  _OWORD *v14;
  const void *v15;
  uint64_t v16;
  const __CFData *v17;
  uint8_t v18[15];
  char v19;
  uint8_t buf[16];

  if ((*((_WORD *)this + 38) & 0x80) != 0
    && !*((_QWORD *)this + 14)
    && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "sniffForContentTypeWithData(): Already sniffed, or no response to work", buf, 2u);
    if (theArray)
      goto LABEL_5;
LABEL_22:
    v12 = (const __CFData *)*((_QWORD *)this + 21);
    *((_QWORD *)this + 21) = 0;
    if (!v12)
    {
LABEL_29:
      URLResponse::guessMIMEType((URLResponse *)objc_msgSend(*((id *)this + 14), "_inner"), v12);
      if (!URLResponse::getMIMEType((URLResponse *)objc_msgSend(*((id *)this + 14), "_inner"))
        && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v18 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "sniffForContentTypeWithData(): Could not determine a valid content type!", v18, 2u);
      }
      *((_WORD *)this + 38) &= ~0x80u;
      if (v12)
        CFRelease(v12);
      return (*(uint64_t (**)(char *, _QWORD))(*((_QWORD *)this + 6) + 112))((char *)this + 48, *((_QWORD *)this + 14));
    }
LABEL_23:
    v13 = *(_QWORD *)(objc_msgSend(*((id *)this + 14), "_inner") + 88);
    if (v13)
    {
      if (((*(unsigned __int16 *)(v13 + 297) | (*(unsigned __int8 *)(v13 + 299) << 16)) & 0x10000) != 0)
      {
        v14 = CFURLDataDecoderCreateWithResponse(*((const __CFAllocator **)this + 1), *((_CFURLResponse **)this + 14));
        if (v14)
        {
          v15 = v14;
          v19 = 0;
          v16 = CFURLDataDecoderDecodeData((uint64_t)v14, (uint64_t)v12, (uint64_t)&v19);
          if (v16)
          {
            v17 = (const __CFData *)v16;
            CFRelease(v12);
            v12 = v17;
          }
          CFRelease(v15);
        }
      }
    }
    goto LABEL_29;
  }
  if (!theArray)
    goto LABEL_22;
LABEL_5:
  result = CFArrayGetCount(theArray);
  if (result >= 1)
  {
    v5 = result;
    v6 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(theArray, v6);
      Length = CFDataGetLength(ValueAtIndex);
      result = *((_QWORD *)this + 21);
      if (!result && Length >= 512)
        break;
      if (!result)
      {
        result = (uint64_t)CFDataCreateMutable(*((CFAllocatorRef *)this + 1), 512);
        *((_QWORD *)this + 21) = result;
      }
      v9 = CFDataGetLength((CFDataRef)result);
      if (v9 + Length > 512)
        Length = 512 - v9;
      v10 = (__CFData *)*((_QWORD *)this + 21);
      BytePtr = CFDataGetBytePtr(ValueAtIndex);
      CFDataAppendBytes(v10, BytePtr, Length);
      result = CFDataGetLength(*((CFDataRef *)this + 21));
      if (result >= 512)
      {
        v12 = (const __CFData *)*((_QWORD *)this + 21);
        *((_QWORD *)this + 21) = 0;
        goto LABEL_19;
      }
      if (v5 == ++v6)
        return result;
    }
    if (!ValueAtIndex)
      return result;
    result = (uint64_t)CFRetain(ValueAtIndex);
    v12 = (const __CFData *)result;
LABEL_19:
    if (v12)
      goto LABEL_23;
  }
  return result;
}

void ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke_2(uint64_t a1, _CFCachedURLResponse *a2)
{
  uint64_t v3;
  void *v4;
  HTTPMessage *v5;
  CFDataRef v6;
  CFDataRef v7;
  uint64_t v8;
  void *v9;
  CFHashCode v10;
  uint64_t v11;
  size_t v12;
  CFDataRef v13;
  CFDataRef v14;
  NSURLSessionTask *v15;
  NSURLRequest *v16;
  NSURLRequest *v17;
  const void *v18;
  CFTypeRef v19;
  void *v20;
  uint64_t v21;
  _CFURLCache *v22;
  HTTPProtocol *v23;
  _CFURLRequest *v24;
  const void *v25;
  char v26[40];
  _QWORD v27[7];

  v27[6] = *MEMORY[0x1E0C80C00];
  if (!a2)
    return;
  v3 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(a1 + 40))
    goto LABEL_11;
  v4 = (void *)objc_msgSend(*(id *)(v3 + 88), "currentRequest");
  v5 = *(HTTPMessage **)(objc_msgSend(v4, "_inner") + 56);
  if (!v5)
    goto LABEL_11;
  v6 = HTTPMessage::copyBody(v5);
  if (!v6)
    goto LABEL_11;
  v7 = v6;
  v8 = objc_msgSend(v4, "mutableCopy");
  if (!v8)
  {
    CFRelease(v7);
LABEL_11:
    v15 = (NSURLSessionTask *)*(id *)(v3 + 88);
    goto LABEL_12;
  }
  v9 = (void *)v8;
  v10 = CFHash(v7);
  v11 = MEMORY[0x1E0C80A78](v10);
  snprintf(v26, 0x11uLL, "%ld", v11);
  v12 = strlen(v26);
  v13 = CFDataCreate(*(CFAllocatorRef *)(v3 + 8), (const UInt8 *)v26, v12);
  if (v13)
  {
    v14 = v13;
    CFURLRequestSetHTTPRequestBody(v9, (uint64_t)v13);
    v15 = -[NSURLSessionTask initWithOriginalRequest:ident:taskGroup:]([NSURLSessionTask alloc], "initWithOriginalRequest:ident:taskGroup:", v9, 0, objc_msgSend((id)objc_msgSend(*(id *)(v3 + 88), "session"), "defaultTaskGroup"));
    CFRelease(v14);
  }
  else
  {
    v15 = 0;
  }
  CFRelease(v9);
  CFRelease(v7);
  if (!v15)
    goto LABEL_11;
LABEL_12:
  v16 = -[NSURLSessionTask currentRequest](v15, "currentRequest");
  if (v16
    && (v17 = v16, (v18 = *(const void **)(-[NSURLRequest _inner](v16, "_inner") + 224)) != 0)
    && (v19 = CFRetain(v18)) != 0)
  {
    CFRelease(v19);
    if (*(_BYTE *)(v3 + 232))
    {
      v20 = *(void **)(v3 + 88);
      v27[0] = MEMORY[0x1E0C809B0];
      v27[1] = 3221225472;
      v27[2] = ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke_3;
      v27[3] = &unk_1E14FA988;
      v27[4] = v17;
      v27[5] = a2;
      objc_msgSend(v20, "_withXURLCache:", v27);
    }
  }
  else
  {
    v21 = CFURLCacheCopySharedURLCache();
    if (v21)
    {
      v22 = (_CFURLCache *)v21;
      v23 = -[NSURLSessionTask session](v15, "session");
      v24 = -[NSURLSessionTask currentRequest](v15, "currentRequest");
      _CFURLCacheAddCachedResponseForRequestWithSession(v22, v23, a2, v24, v25);
      CFRelease(v22);
    }
  }

}

uint64_t ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke_3(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
}

void ___ZN19URLConnectionClient45_loaderClientEvent_HandleCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) + 104))(*(_QWORD *)(a1 + 32) + 48, *(_QWORD *)(a1 + 40), a2);
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
}

uint64_t GetTotalSizeOfDataArrayData(const __CFArray *a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex v4;
  uint64_t v5;
  const __CFData *ValueAtIndex;

  if (!a1)
    return 0;
  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v3 = Count;
  v4 = 0;
  v5 = 0;
  do
  {
    ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(a1, v4);
    v5 += CFDataGetLength(ValueAtIndex);
    ++v4;
  }
  while (v3 != v4);
  return v5;
}

void ___ZN19URLConnectionClient58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke(_QWORD *a1, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  _QWORD v10[8];
  _QWORD block[6];

  v4 = a1[5];
  if (cf)
    CFRetain(cf);
  v5 = MEMORY[0x1E0C809B0];
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN19URLConnectionClient58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke_2;
  v10[3] = &unk_1E14FA910;
  v6 = a1[4];
  v10[4] = cf;
  v10[5] = v6;
  v7 = a1[6];
  v10[6] = v4;
  v10[7] = v7;
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 32) + 64))(*(_QWORD *)(v4 + 32));
  v9 = *(NSObject **)(v4 + 40);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v10;
  block[5] = v8;
  dispatch_async(v9, block);
}

void ___ZN19URLConnectionClient58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke_2(_QWORD *a1)
{
  const void *v2;
  const void *v3;

  objc_msgSend(*(id *)(a1[6] + 88), "updateCurrentRequest:", a1[4]);
  (*(void (**)(void))(a1[5] + 16))();
  v2 = (const void *)a1[4];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[7];
  if (v3)
    CFRelease(v3);
}

void ___ZN19URLConnectionClient36_loaderClientEvent_NeedNewBodyStreamEv_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[5];
  _QWORD v10[6];
  _QWORD v11[6];
  _QWORD block[6];

  v2 = *(_QWORD *)(a1 + 32);
  if (cf)
  {
    CFRetain(cf);
    v4 = *(_QWORD *)(v2 + 216);
    v5 = MEMORY[0x1E0C809B0];
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = ___ZN19URLConnectionClient36_loaderClientEvent_NeedNewBodyStreamEv_block_invoke_2;
    v9[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
    v9[4] = cf;
    CFRetain((CFTypeRef)(v4 - 16));
    v6 = *(_QWORD *)(v4 + 32);
    v10[0] = v5;
    v10[1] = 3221225472;
    v10[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9489;
    v10[3] = &unk_1E14FABB8;
    v10[4] = v9;
    v10[5] = v4;
    v11[0] = v5;
    v11[1] = 3221225472;
    v11[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9490;
    v11[3] = &unk_1E14FDA90;
    v11[4] = v10;
    v11[5] = v6;
    v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v6 + 32) + 64))(*(_QWORD *)(v6 + 32));
    v8 = *(NSObject **)(v6 + 40);
    block[0] = v5;
    block[1] = 3221225472;
    block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
    block[3] = &unk_1E14FDA90;
    block[4] = v11;
    block[5] = v7;
    dispatch_async(v8, block);
  }
  else
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 216) + 192))(*(_QWORD *)(v2 + 216));
  }
}

void ___ZN19URLConnectionClient36_loaderClientEvent_NeedNewBodyStreamEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 56))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

void ___ZN19URLConnectionClient48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[7];
  _QWORD block[6];

  v4 = *(_QWORD *)(a1 + 40);
  if (cf)
    CFRetain(cf);
  v5 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN19URLConnectionClient48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke_2;
  v9[3] = &unk_1E14FDBE0;
  v6 = *(_QWORD *)(a1 + 32);
  v9[4] = cf;
  v9[5] = v6;
  v9[6] = v4;
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 32) + 64))(*(_QWORD *)(v4 + 32));
  v8 = *(NSObject **)(v4 + 40);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v9;
  block[5] = v7;
  dispatch_async(v8, block);
}

void ___ZN19URLConnectionClient48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke_2(_QWORD *a1)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  int v4;
  uint64_t v5;
  const void *v6;

  v2 = a1[6];
  if (a1[4])
    objc_msgSend(*(id *)(v2 + 88), "updateCurrentRequest:");
  v3 = (os_unfair_lock_s *)(v2 + 128);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 128));
  v4 = *(unsigned __int8 *)(v2 + 132);
  os_unfair_lock_unlock(v3);
  if (v4)
    v5 = 0;
  else
    v5 = a1[4];
  (*(void (**)(_QWORD, uint64_t))(a1[5] + 16))(a1[5], v5);
  v6 = (const void *)a1[4];
  if (v6)
    CFRelease(v6);
}

uint64_t ___ZN19URLConnectionClient31forceProtocolToUseLargeDownloadEh_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 48))(a2, *(unsigned __int8 *)(result + 32));
  return result;
}

uint64_t ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_5(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[7];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_6;
  v5[3] = &unk_1E14FA808;
  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  v5[5] = a2;
  v5[6] = v2;
  v5[4] = v3;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)(v2 + 48) + 96))(v2 + 48, v5);
}

void ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_6(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD v5[4];
  __int128 v6;
  _QWORD block[6];

  v1 = *(_QWORD *)(a1 + 48);
  v2 = MEMORY[0x1E0C809B0];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_7;
  v5[3] = &unk_1E14FB138;
  v6 = *(_OWORD *)(a1 + 32);
  v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 32) + 64))(*(_QWORD *)(v1 + 32));
  v4 = *(NSObject **)(v1 + 40);
  block[0] = v2;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v5;
  block[5] = v3;
  dispatch_async(v4, block);
}

uint64_t ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_7(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

uint64_t ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_4(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 32) + 72))(*(_QWORD *)(v1 + 32));
}

CFStringRef URLConnectionClient_Classic::copyDebugDesc(URLConnectionClient_Classic *this)
{
  const __CFAllocator *v2;
  uint64_t v3;

  v2 = (const __CFAllocator *)*((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 30);
  if (v3)
    v3 = *(_QWORD *)(v3 + 8);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<URLConnectionClient@%p>{ info = %p }"), this, v3);
}

void URLConnectionClient_Classic::_connectionClientInterface_precanonicalizeForSynchronousStart(URLConnectionClient_Classic *this)
{
  void *v2;
  uint64_t *v3;
  id v4;
  const void *v5;
  const void *v6;

  if (objc_msgSend(*((id *)this + 11), "currentRequest"))
  {
    v2 = (void *)*((_QWORD *)this + 11);
    if (v2)
    {
      v3 = (uint64_t *)*((_QWORD *)this + 30);
      if (*v3 >= 1)
      {
        if (v3[5])
        {
          v4 = -[__NSURLSessionLocal _createCanonicalRequestForTask:]((id)objc_msgSend(v2, "session"), *((void **)this + 11));
          if (v4)
          {
            v5 = v4;
            *(_WORD *)((char *)this + 273) = 257;
            *((_QWORD *)this + 35) = 0;
            v6 = (const void *)(*(uint64_t (**)(uint64_t, id, _QWORD, _QWORD))(*((_QWORD *)this + 30) + 40))(*((_QWORD *)this + 27) - 16, v4, 0, *(_QWORD *)(*((_QWORD *)this + 30) + 8));
            *((_QWORD *)this + 35) = -[NSURLRequest _initWithCFURLRequest:]([NSURLRequest alloc], "_initWithCFURLRequest:", v6);
            if (v6)
              CFRelease(v6);
            if ((*((_WORD *)this + 38) & 0x100) != 0)
              *((_BYTE *)this + 274) = (*(uint64_t (**)(uint64_t, _QWORD))(*((_QWORD *)this + 30) + 112))(*((_QWORD *)this + 27) - 16, *(_QWORD *)(*((_QWORD *)this + 30) + 8));
            CFRelease(v5);
          }
        }
      }
    }
  }
}

void URLConnectionClient_Classic::_connectionClientInterface_resumeConnection(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  int os_unfair_lock_opaque_low;
  const void *v4;
  unint64_t Count;
  CFRange v6;
  const void **v7;
  CFIndex v8;
  uint64_t v9;
  CFTypeRef v10;
  CFIndex range;
  const void **v12;
  _BYTE v13[248];
  CFIndex v14;

  v2 = this + 34;
  os_unfair_lock_lock(this + 34);
  os_unfair_lock_opaque_low = LOBYTE(this[35]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2);
  if (!os_unfair_lock_opaque_low)
  {
    v4 = *(const void **)&this[62]._os_unfair_lock_opaque;
    if (v4)
    {
      *(_QWORD *)&this[62]._os_unfair_lock_opaque = 0;
      v10 = CFRetain(v4);
      Count = CFArrayGetCount((CFArrayRef)v4);
      v6.length = Count;
      range = Count;
      if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v12 = 0;
        goto LABEL_10;
      }
      if (Count > 0x1E)
      {
        v7 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
        v12 = v7;
        if (!v7)
          goto LABEL_10;
        v6.length = range;
      }
      else
      {
        v7 = (const void **)v13;
        v12 = (const void **)v13;
      }
      v6.location = 0;
      CFArrayGetValues((CFArrayRef)v4, v6, v7);
LABEL_10:
      v14 = 0;
      while (1)
      {
        v8 = v14;
        if (v14 >= range)
          break;
        ++v14;
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_connectionClientInterface_resumeConnection", (void (**)(_QWORD, _QWORD, _QWORD))v12[v8]);
      }
      v9 = *(_QWORD *)&this[66]._os_unfair_lock_opaque - 1;
      *(_QWORD *)&this[66]._os_unfair_lock_opaque = v9;
      if (!v9)
        (*(void (**)(_QWORD))(**(_QWORD **)&this[8]._os_unfair_lock_opaque + 72))(*(_QWORD *)&this[8]._os_unfair_lock_opaque);
      CFRelease(v4);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v10);
    }
  }
}

void sub_1840975A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

BOOL URLConnectionClient_Classic::_delegate_implements_needNewBodyStream(os_unfair_lock_s *this)
{
  uint64_t v1;
  uint64_t v2;
  _BOOL8 v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  void (*v7)(void);

  v1 = URLConnectionClient_Classic::copyDelegate(this);
  if (!v1)
    return 0;
  v2 = v1;
  if (*(_DWORD *)(v1 + 196))
    v3 = 0;
  else
    v3 = *(_QWORD *)(v1 + 120) != 0;
  v4 = (unsigned int *)(v1 + 192);
  do
  {
    v5 = __ldaxr(v4);
    v6 = v5 - 1;
  }
  while (__stlxr(v6, v4));
  if (!v6)
  {
    if (*(_QWORD *)(v1 + 8))
    {
      v7 = *(void (**)(void))(v1 + 24);
      if (v7)
        v7();
    }
    MEMORY[0x186DB748C](v2, 0x10C0C4063EE03C6);
  }
  return v3;
}

void URLConnectionClient_Classic::_delegate_willSendRequestForRedirection(_QWORD *a1, const void *a2, void *a3, uint64_t a4)
{
  uint64_t v8;
  id v9;
  void (*v10[7])(_QWORD, _QWORD, _QWORD);

  if ((*(unsigned int (**)(_QWORD *))(*a1 + 304))(a1)
    || (v8 = a1[30]) == 0
    || *(_DWORD *)(v8 + 196)
    || !*(_QWORD *)(v8 + 40))
  {
    (*(void (**)(uint64_t, const void *))(a4 + 16))(a4, a2);
  }
  else
  {
    if (a2)
      CFRetain(a2);
    v9 = a3;
    v10[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v10[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v10[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic39_delegate_willSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke;
    v10[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAA58;
    v10[4] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
    v10[5] = (void (*)(_QWORD, _QWORD, _QWORD))a4;
    v10[6] = (void (*)(_QWORD, _QWORD, _QWORD))a3;
    URLConnectionClient_Classic::_withDelegateAsync((uint64_t)a1, (uint64_t)"_delegate_willSendRequestForRedirection", v10);
  }
}

void URLConnectionClient_Classic::_delegate_shouldUseCredentialStorage(uint64_t a1, void (*a2)(_QWORD, _QWORD, _QWORD))
{
  void (*v2[5])(_QWORD, _QWORD, _QWORD);

  v2[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  v2[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
  v2[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic36_delegate_shouldUseCredentialStorageEU13block_pointerFvhE_block_invoke;
  v2[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAAC8;
  v2[4] = a2;
  URLConnectionClient_Classic::_withDelegateAsync(a1, (uint64_t)"_delegate_shouldUseCredentialStorage", v2);
}

void URLConnectionClient_Classic::_delegate_didStopBuffering(URLConnectionClient_Classic *this, const __CFArray *a2)
{
  uint64_t v4;
  void (*v5[6])(_QWORD, _QWORD, _QWORD);

  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(_QWORD *)this + 304))(this))
  {
    v4 = *((_QWORD *)this + 30);
    if (v4)
    {
      if (!*(_DWORD *)(v4 + 196) && *(_QWORD *)(v4 + 64))
      {
        if (a2)
          CFRetain(a2);
        v5[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
        v5[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
        v5[2] = ___ZN27URLConnectionClient_Classic26_delegate_didStopBufferingEPK9__CFArray_block_invoke;
        v5[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_48_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
        v5[4] = (void (*)(_QWORD, _QWORD, _QWORD))this;
        v5[5] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_didStopBuffering", v5);
      }
    }
  }
}

void URLConnectionClient_Classic::_delegate_didReceiveDataArray(URLConnectionClient_Classic *this)
{
  char v2;
  uint64_t v3;
  void (*v4[5])(_QWORD, _QWORD, _QWORD);

  v2 = *((_BYTE *)this + 80);
  if ((v2 & 1) == 0)
  {
    CFLog();
    v2 = *((_BYTE *)this + 80);
  }
  *((_BYTE *)this + 80) = v2 | 2;
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(_QWORD *)this + 304))(this))
  {
    v3 = *((_QWORD *)this + 30);
    if (v3)
    {
      if (!*(_DWORD *)(v3 + 196))
      {
        v4[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
        v4[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
        v4[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic29_delegate_didReceiveDataArrayEv_block_invoke;
        v4[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_40_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
        v4[4] = (void (*)(_QWORD, _QWORD, _QWORD))this;
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_didReceiveDataArray", v4);
      }
    }
  }
}

void URLConnectionClient_Classic::_delegate_didReceiveDataArrayWithDataArray(URLConnectionClient_Classic *this, const __CFArray *a2)
{
  char v4;
  uint64_t v5;
  uint64_t TotalSizeOfDataArrayData;
  void (*v7)(_QWORD, _QWORD, _QWORD);
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  void (*v12[5])(_QWORD, _QWORD, _QWORD);
  _QWORD v13[5];
  _QWORD v14[6];
  _QWORD v15[6];
  _QWORD block[6];

  v4 = *((_BYTE *)this + 80);
  if ((v4 & 1) == 0)
  {
    CFLog();
    v4 = *((_BYTE *)this + 80);
  }
  *((_BYTE *)this + 80) = v4 | 2;
  v5 = *((_QWORD *)this + 27);
  TotalSizeOfDataArrayData = GetTotalSizeOfDataArrayData(a2);
  v7 = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = ___ZN20ClassicURLConnection29informProtocolOfBytesConsumedEx_block_invoke;
  v13[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
  v13[4] = TotalSizeOfDataArrayData;
  CFRetain((CFTypeRef)(v5 - 16));
  v8 = *(_QWORD *)(v5 + 32);
  v14[0] = v7;
  v14[1] = 3221225472;
  v14[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9489;
  v14[3] = &unk_1E14FABB8;
  v14[4] = v13;
  v14[5] = v5;
  v15[0] = v7;
  v15[1] = 3221225472;
  v15[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9490;
  v15[3] = &unk_1E14FDA90;
  v15[4] = v14;
  v15[5] = v8;
  v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v8 + 32) + 64))(*(_QWORD *)(v8 + 32));
  v10 = *(NSObject **)(v8 + 40);
  block[0] = v7;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v15;
  block[5] = v9;
  dispatch_async(v10, block);
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(_QWORD *)this + 304))(this))
  {
    v11 = *((_QWORD *)this + 30);
    if (v11)
    {
      if (!*(_DWORD *)(v11 + 196))
      {
        if (a2)
          CFRetain(a2);
        v12[0] = v7;
        v12[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
        v12[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic42_delegate_didReceiveDataArrayWithDataArrayEPK9__CFArray_block_invoke;
        v12[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_40_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
        v12[4] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_didReceiveDataArrayWithDataArray", v12);
      }
    }
  }
}

void URLConnectionClient_Classic::_delegate_didSendBodyData(URLConnectionClient_Classic *this, UploadProgressInfo *a2)
{
  uint64_t v4;
  void (*v5[4])(_QWORD, _QWORD, _QWORD);
  __int128 v6;
  int64_t var2;

  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(_QWORD *)this + 304))(this))
  {
    v4 = *((_QWORD *)this + 30);
    if (v4)
    {
      if (!*(_DWORD *)(v4 + 196) && *(_QWORD *)(v4 + 104))
      {
        if (*(_QWORD *)v4)
        {
          v5[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
          v5[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
          v5[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic25_delegate_didSendBodyDataE18UploadProgressInfo_block_invoke;
          v5[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_56_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
          v6 = *(_OWORD *)&a2->var0;
          var2 = a2->var2;
          URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_didSendBodyData", v5);
        }
      }
    }
  }
}

void URLConnectionClient_Classic::_delegate_needNewBodyStream(_QWORD *a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  void (*v7[6])(_QWORD, _QWORD, _QWORD);

  if ((*(unsigned int (**)(_QWORD *))(*a1 + 304))(a1)
    || (v6 = a1[30]) == 0
    || *(_DWORD *)(v6 + 196)
    || !*(_QWORD *)(v6 + 120))
  {
    (*(void (**)(uint64_t, _QWORD))(a3 + 16))(a3, 0);
  }
  else
  {
    if (a2)
      CFRetain(a2);
    v7[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v7[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v7[2] = ___ZN27URLConnectionClient_Classic27_delegate_needNewBodyStreamEP12NSURLRequestU13block_pointerFvP14__CFReadStreamE_block_invoke;
    v7[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAAF0;
    v7[4] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
    v7[5] = (void (*)(_QWORD, _QWORD, _QWORD))a3;
    URLConnectionClient_Classic::_withDelegateAsync((uint64_t)a1, (uint64_t)"_delegate_needNewBodyStream", v7);
  }
}

void URLConnectionClient_Classic::_delegate_willSendRequestForEstablishedConnection(_QWORD *a1, const void *a2, const void *a3, uint64_t a4)
{
  uint64_t v8;
  void (*v9[7])(_QWORD, _QWORD, _QWORD);

  if (!(*(unsigned int (**)(_QWORD *))(*a1 + 304))(a1)
    && (v8 = a1[30]) != 0
    && !*(_DWORD *)(v8 + 196)
    && *(_QWORD *)(v8 + 168)
    && *(_QWORD *)v8)
  {
    if (a3)
      CFRetain(a3);
    if (a2)
      CFRetain(a2);
    v9[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v9[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v9[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic49_delegate_willSendRequestForEstablishedConnectionEP12NSURLRequestPK14__CFDictionaryU13block_pointerFvS1_E_block_invoke;
    v9[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAA58;
    v9[5] = (void (*)(_QWORD, _QWORD, _QWORD))a4;
    v9[6] = (void (*)(_QWORD, _QWORD, _QWORD))a3;
    v9[4] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
    URLConnectionClient_Classic::_withDelegateAsync((uint64_t)a1, (uint64_t)"_delegate_willSendRequestForEstablishedConnection", v9);
  }
  else
  {
    (*(void (**)(uint64_t, const void *))(a4 + 16))(a4, a2);
  }
}

void URLConnectionClient_Classic::_delegate_connectionWaiting(URLConnectionClient_Classic *this)
{
  uint64_t v2;

  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(_QWORD *)this + 304))(this))
  {
    v2 = *((_QWORD *)this + 30);
    if (v2)
    {
      if (!*(_DWORD *)(v2 + 196) && *(_QWORD *)(v2 + 184))
      {
        if (*(_QWORD *)v2)
          URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_connectionWaiting", __block_literal_global_9527);
      }
    }
  }
}

void URLConnectionClient_Classic::_delegate_conditionalRequirementsChanged(URLConnectionClient_Classic *this, char a2)
{
  uint64_t v4;
  void (*v5[4])(_QWORD, _QWORD, _QWORD);
  char v6;

  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(_QWORD *)this + 304))(this))
  {
    v4 = *((_QWORD *)this + 30);
    if (v4)
    {
      if (!*(_DWORD *)(v4 + 196) && *(_QWORD *)(v4 + 176))
      {
        if (*(_QWORD *)v4)
        {
          v5[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
          v5[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
          v5[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic40_delegate_conditionalRequirementsChangedEh_block_invoke;
          v5[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_33_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
          v6 = a2;
          URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_conditionalRequirementsChanged", v5);
        }
      }
    }
  }
}

void URLConnectionClient_Classic::_delegate_willCacheResponse(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  void (*v7[7])(_QWORD, _QWORD, _QWORD);

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 304))(a1)
    || (v6 = *(_QWORD *)(a1 + 240)) == 0
    || *(_DWORD *)(v6 + 196)
    || !*(_QWORD *)(v6 + 88))
  {
    (*(void (**)(uint64_t, const void *))(a3 + 16))(a3, a2);
  }
  else
  {
    if (a2)
      CFRetain(a2);
    v7[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v7[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v7[2] = ___ZN27URLConnectionClient_Classic27_delegate_willCacheResponseEPK20_CFCachedURLResponseU13block_pointerFvS2_E_block_invoke;
    v7[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAAA0;
    v7[5] = (void (*)(_QWORD, _QWORD, _QWORD))a1;
    v7[6] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
    v7[4] = (void (*)(_QWORD, _QWORD, _QWORD))a3;
    URLConnectionClient_Classic::_withDelegateAsync(a1, (uint64_t)"_delegate_willCacheResponse", v7);
  }
}

void URLConnectionClient_Classic::_delegate_didFail(void (*a1)(_QWORD, _QWORD, _QWORD), CFTypeRef cf, void (*a3)(_QWORD, _QWORD, _QWORD))
{
  void (*v6[7])(_QWORD, _QWORD, _QWORD);

  if (cf)
    CFRetain(cf);
  v6[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  v6[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
  v6[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic17_delegate_didFailEP9__CFErrorU13block_pointerFvvE_block_invoke;
  v6[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAAA0;
  v6[5] = a1;
  v6[6] = (void (*)(_QWORD, _QWORD, _QWORD))cf;
  v6[4] = a3;
  URLConnectionClient_Classic::_withDelegateAsync((uint64_t)a1, (uint64_t)"_delegate_didFail", v6);
}

void URLConnectionClient_Classic::_delegate_didCancel(uint64_t a1, void (*a2)(_QWORD, _QWORD, _QWORD))
{
  void (*v2[5])(_QWORD, _QWORD, _QWORD);

  v2[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  v2[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
  v2[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic19_delegate_didCancelEU13block_pointerFvvE_block_invoke;
  v2[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAAC8;
  v2[4] = a2;
  URLConnectionClient_Classic::_withDelegateAsync(a1, (uint64_t)"_delegate_didCancel", v2);
}

void URLConnectionClient_Classic::_delegate_cacheTrifecta(uint64_t a1, CFTypeRef cf, void (*a3)(_QWORD, _QWORD, _QWORD))
{
  uint64_t v6;
  void (*v7[7])(_QWORD, _QWORD, _QWORD);

  if (cf)
    CFRetain(cf);
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 304))(a1))
  {
    v6 = *(_QWORD *)(a1 + 240);
    if (v6)
    {
      if (!*(_DWORD *)(v6 + 196))
      {
        v7[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
        v7[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
        v7[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic23_delegate_cacheTrifectaEPK20_CFCachedURLResponseU13block_pointerFvvE_block_invoke;
        v7[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAAA0;
        v7[5] = (void (*)(_QWORD, _QWORD, _QWORD))a1;
        v7[6] = (void (*)(_QWORD, _QWORD, _QWORD))cf;
        v7[4] = a3;
        URLConnectionClient_Classic::_withDelegateAsync(a1, (uint64_t)"_delegate_cacheTrifecta", v7);
      }
    }
  }
}

void `non-virtual thunk to'URLConnectionClient_Classic::~URLConnectionClient_Classic(URLConnectionClient_Classic *this)
{
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 16));
}

{
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 48));
}

{
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 56));
}

{
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 64));
}

void `non-virtual thunk to'URLConnectionClient_Classic::~URLConnectionClient_Classic(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 2;
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)(this - 2));
  CFAllocatorDeallocate(*(this - 1), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 6;
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)(this - 6));
  CFAllocatorDeallocate(*(this - 5), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 7;
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)(this - 7));
  CFAllocatorDeallocate(*(this - 6), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 8;
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)(this - 8));
  CFAllocatorDeallocate(*(this - 7), v2);
}

BOOL `non-virtual thunk to'URLConnectionClient_Classic::_delegate_implements_needNewBodyStream(os_unfair_lock_s *this)
{
  return URLConnectionClient_Classic::_delegate_implements_needNewBodyStream(this - 12);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_willSendRequestForRedirection(uint64_t a1, const void *a2, void *a3, uint64_t a4)
{
  URLConnectionClient_Classic::_delegate_willSendRequestForRedirection((_QWORD *)(a1 - 48), a2, a3, a4);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_willSendRequestForEstablishedConnection(uint64_t a1, const void *a2, const void *a3, uint64_t a4)
{
  URLConnectionClient_Classic::_delegate_willSendRequestForEstablishedConnection((_QWORD *)(a1 - 48), a2, a3, a4);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_connectionWaiting(URLConnectionClient_Classic *this)
{
  URLConnectionClient_Classic::_delegate_connectionWaiting((URLConnectionClient_Classic *)((char *)this - 48));
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_conditionalRequirementsChanged(URLConnectionClient_Classic *this, char a2)
{
  URLConnectionClient_Classic::_delegate_conditionalRequirementsChanged((URLConnectionClient_Classic *)((char *)this - 48), a2);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_needNewBodyStream(uint64_t a1, const void *a2, uint64_t a3)
{
  URLConnectionClient_Classic::_delegate_needNewBodyStream((_QWORD *)(a1 - 48), a2, a3);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_willCacheResponse(uint64_t a1, const void *a2, uint64_t a3)
{
  URLConnectionClient_Classic::_delegate_willCacheResponse(a1 - 48, a2, a3);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_didFail(uint64_t a1, const void *a2, void (*a3)(_QWORD, _QWORD, _QWORD))
{
  URLConnectionClient_Classic::_delegate_didFail((void (*)(_QWORD, _QWORD, _QWORD))(a1 - 48), a2, a3);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_didCancel(uint64_t a1, void (*a2)(_QWORD, _QWORD, _QWORD))
{
  void (*v2[5])(_QWORD, _QWORD, _QWORD);

  v2[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  v2[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
  v2[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic19_delegate_didCancelEU13block_pointerFvvE_block_invoke;
  v2[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAAC8;
  v2[4] = a2;
  URLConnectionClient_Classic::_withDelegateAsync(a1 - 48, (uint64_t)"_delegate_didCancel", v2);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_cacheTrifecta(uint64_t a1, const void *a2, void (*a3)(_QWORD, _QWORD, _QWORD))
{
  URLConnectionClient_Classic::_delegate_cacheTrifecta(a1 - 48, a2, a3);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_didReceiveDataArray(URLConnectionClient_Classic *this)
{
  URLConnectionClient_Classic::_delegate_didReceiveDataArray((URLConnectionClient_Classic *)((char *)this - 48));
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_didReceiveDataArrayWithDataArray(URLConnectionClient_Classic *this, const __CFArray *a2)
{
  URLConnectionClient_Classic::_delegate_didReceiveDataArrayWithDataArray((URLConnectionClient_Classic *)((char *)this - 48), a2);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_didStopBuffering(URLConnectionClient_Classic *this, const __CFArray *a2)
{
  URLConnectionClient_Classic::_delegate_didStopBuffering((URLConnectionClient_Classic *)((char *)this - 48), a2);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_didSendBodyData(URLConnectionClient_Classic *this, UploadProgressInfo *a2)
{
  URLConnectionClient_Classic::_delegate_didSendBodyData((URLConnectionClient_Classic *)((char *)this - 48), a2);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_shouldUseCredentialStorage(uint64_t a1, void (*a2)(_QWORD, _QWORD, _QWORD))
{
  void (*v2[5])(_QWORD, _QWORD, _QWORD);

  v2[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  v2[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
  v2[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic36_delegate_shouldUseCredentialStorageEU13block_pointerFvhE_block_invoke;
  v2[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAAC8;
  v2[4] = a2;
  URLConnectionClient_Classic::_withDelegateAsync(a1 - 48, (uint64_t)"_delegate_shouldUseCredentialStorage", v2);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_connectionClientInterface_resumeConnection(os_unfair_lock_s *this)
{
  URLConnectionClient_Classic::_connectionClientInterface_resumeConnection(this - 14);
}

uint64_t ___ZN27URLConnectionClient_Classic36_delegate_shouldUseCredentialStorageEU13block_pointerFvhE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v6)(uint64_t, _QWORD);
  uint8_t v8[16];

  if (a3)
  {
    v6 = *(void (**)(uint64_t, _QWORD))(a3 + 112);
    if (v6)
    {
      v6(a2, *(_QWORD *)(a3 + 8));
    }
    else
    {
      *(_WORD *)v8 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "not properly vetted!", v8, 2u);
      (*(void (**)(uint64_t, _QWORD))(a3 + 112))(a2, *(_QWORD *)(a3 + 8));
    }
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN27URLConnectionClient_Classic19_delegate_didCancelEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN27URLConnectionClient_Classic23_delegate_cacheTrifectaEPK20_CFCachedURLResponseU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v6;
  const void *v7;
  void *v9;
  uint64_t v10;
  const __CFArray *v11;
  const __CFArray *v12;
  void (*v13)(uint64_t, const __CFArray *, _QWORD);
  __CFData *v14;
  void (*v15)(uint64_t, __CFData *, CFIndex, _QWORD);
  CFIndex Length;

  if (a2)
  {
    v4 = a3;
    if (a3)
    {
      v6 = *(_QWORD **)(a1 + 40);
      if (!(*(unsigned int (**)(_QWORD *))(*v6 + 304))(v6))
      {
        if (*(_QWORD *)(v4 + 48))
        {
          v9 = (void *)CFCachedURLResponseCopyWrappedResponse(*(const _CFCachedURLResponse **)(a1 + 48));
          ++v6[28];
          (*(void (**)(uint64_t, void *, _QWORD))(v4 + 48))(a2, v9, *(_QWORD *)(v4 + 8));
          v10 = v6[28] - 1;
          v6[28] = v10;
          if (v10)
          {

          }
          else
          {
            v4 = v6[30];

            if (!v4)
              goto LABEL_4;
          }
        }
        if ((*(_QWORD *)(v4 + 56) || *(_QWORD *)(v4 + 144))
          && !(*(unsigned int (**)(_QWORD *))(*v6 + 304))(v6))
        {
          v11 = (const __CFArray *)CFCachedURLResponseCopyReceiverDataArray(*(_QWORD *)(a1 + 48));
          if (v11)
          {
            v12 = v11;
            v13 = *(void (**)(uint64_t, const __CFArray *, _QWORD))(v4 + 144);
            if (v13)
            {
              v13(a2, v11, *(_QWORD *)(v4 + 8));
            }
            else
            {
              v14 = CopyAllDataFromDataArray(v11);
              v15 = *(void (**)(uint64_t, __CFData *, CFIndex, _QWORD))(v4 + 56);
              Length = CFDataGetLength(v14);
              v15(a2, v14, Length, *(_QWORD *)(v4 + 8));
              if (v14)
                CFRelease(v14);
            }
            CFRelease(v12);
          }
        }
        if (*(_QWORD *)(v4 + 72) && !(*(unsigned int (**)(_QWORD *))(*v6 + 304))(v6))
          (*(void (**)(uint64_t, _QWORD))(v4 + 72))(a2, *(_QWORD *)(v4 + 8));
      }
    }
  }
LABEL_4:
  v7 = *(const void **)(a1 + 48);
  if (v7)
    CFRelease(v7);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN27URLConnectionClient_Classic17_delegate_didFailEP9__CFErrorU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  void (*v5)(uint64_t, _QWORD, uint64_t);
  uint64_t v7;
  uint64_t v8;
  const void *v9;

  if (a2)
  {
    if (a3)
    {
      v5 = (void (*)(uint64_t, _QWORD, uint64_t))a3[10];
      if (v5)
      {
        if (*a3 < 1)
        {
          v7 = _CFStreamErrorFromCFError(*(__CFError **)(a1 + 48));
          ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))a3[10])(a2, v7, v8, a3[1]);
        }
        else
        {
          v5(a2, *(_QWORD *)(a1 + 48), a3[1]);
        }
      }
    }
  }
  v9 = *(const void **)(a1 + 48);
  if (v9)
    CFRelease(v9);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN27URLConnectionClient_Classic27_delegate_willCacheResponseEPK20_CFCachedURLResponseU13block_pointerFvS2_E_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v4;
  const void *v6;
  const void *v7;

  v4 = 0;
  if (a2)
  {
    if (a3)
    {
      v6 = (const void *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a3 + 88))(a2, *(_QWORD *)(a1 + 48), *(_QWORD *)(a3 + 8));
      v4 = v6;
      if (!*(_QWORD *)a3 && v6 == *(const void **)(a1 + 48) && v6)
        CFRetain(v6);
    }
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v4)
    CFRelease(v4);
  v7 = *(const void **)(a1 + 48);
  if (v7)
    CFRelease(v7);
}

uint64_t ___ZN27URLConnectionClient_Classic40_delegate_conditionalRequirementsChangedEh_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (a3)
      return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a3 + 176))(a2, *(unsigned __int8 *)(result + 32), *(_QWORD *)(a3 + 8));
  }
  return result;
}

uint64_t ___ZN27URLConnectionClient_Classic27_delegate_connectionWaitingEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (a2)
  {
    if (a3)
      return (*(uint64_t (**)(uint64_t, _QWORD))(a3 + 184))(a2, *(_QWORD *)(a3 + 8));
  }
  return result;
}

void ___ZN27URLConnectionClient_Classic49_delegate_willSendRequestForEstablishedConnectionEP12NSURLRequestPK14__CFDictionaryU13block_pointerFvS1_E_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  void (*v4)(uint64_t, uint64_t, uint64_t, _QWORD *, _QWORD);
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  const void *v8;
  _QWORD v9[5];

  if (a2 && a3)
  {
    v4 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD *, _QWORD))(a3 + 168);
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = ___ZN27URLConnectionClient_Classic49_delegate_willSendRequestForEstablishedConnectionEP12NSURLRequestPK14__CFDictionaryU13block_pointerFvS1_E_block_invoke_2;
    v9[3] = &unk_1E14FAA30;
    v5 = a1[4];
    v6 = a1[6];
    v9[4] = a1[5];
    v4(a2, v5, v6, v9, *(_QWORD *)(a3 + 8));
  }
  else
  {
    (*(void (**)(void))(a1[5] + 16))();
  }
  v7 = (const void *)a1[4];
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a1[6];
  if (v8)
    CFRelease(v8);
}

void ___ZN27URLConnectionClient_Classic49_delegate_willSendRequestForEstablishedConnectionEP12NSURLRequestPK14__CFDictionaryU13block_pointerFvS1_E_block_invoke_2(uint64_t a1, uint64_t a2)
{
  id v3;

  v3 = -[NSURLRequest _initWithCFURLRequest:]([NSURLRequest alloc], "_initWithCFURLRequest:", a2);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v3)
    CFRelease(v3);
}

void ___ZN27URLConnectionClient_Classic27_delegate_needNewBodyStreamEP12NSURLRequestU13block_pointerFvP14__CFReadStreamE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v4;
  const void *v5;

  v4 = 0;
  if (a2 && a3)
    v4 = (const void *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a3 + 120))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a3 + 8));
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 32);
  if (v5)
    CFRelease(v5);
}

uint64_t ___ZN20ClassicURLConnection29informProtocolOfBytesConsumedEx_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 152))(a2, *(_QWORD *)(result + 32));
  return result;
}

void ___ZN27URLConnectionClient_Classic42_delegate_didReceiveDataArrayWithDataArrayEPK9__CFArray_block_invoke(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  void (*v6)(uint64_t);
  __CFData *v7;
  void (*v8)(uint64_t, __CFData *, CFIndex, _QWORD);
  CFIndex Length;
  const void *v10;

  if (a2 && a3 && *(_QWORD *)(a1 + 32))
  {
    v6 = (void (*)(uint64_t))a3[18];
    if (v6)
    {
      v6(a2);
    }
    else if (a3[7])
    {
      v7 = CopyAllDataFromDataArray(*(const __CFArray **)(a1 + 32));
      v8 = (void (*)(uint64_t, __CFData *, CFIndex, _QWORD))a3[7];
      Length = CFDataGetLength(v7);
      v8(a2, v7, Length, a3[1]);
      if (v7)
        CFRelease(v7);
    }
    v10 = *(const void **)(a1 + 32);
    if (v10)
      CFRelease(v10);
  }
}

void ___ZN27URLConnectionClient_Classic29_delegate_didReceiveDataArrayEv_block_invoke(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  const __CFArray *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  void (*v13)(uint64_t, const __CFArray *, _QWORD);
  __CFData *v14;
  void (*v15)(uint64_t, __CFData *, CFIndex, _QWORD);
  CFIndex Length;
  _QWORD v17[5];
  _QWORD v18[6];
  _QWORD v19[6];
  _QWORD block[6];

  if (a2)
  {
    if (a3)
    {
      v5 = *(_QWORD *)(a1 + 32);
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 72));
      v6 = *(const __CFArray **)(v5 + 176);
      v7 = *(_QWORD *)(v5 + 184);
      *(_QWORD *)(v5 + 176) = 0;
      *(_QWORD *)(v5 + 184) = 0;
      *(_QWORD *)(v5 + 192) += v7;
      *(_WORD *)(v5 + 76) &= ~0x200u;
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 72));
      v8 = *(_QWORD *)(v5 + 216);
      v9 = MEMORY[0x1E0C809B0];
      v17[0] = MEMORY[0x1E0C809B0];
      v17[1] = 3221225472;
      v17[2] = ___ZN20ClassicURLConnection29informProtocolOfBytesConsumedEx_block_invoke;
      v17[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
      v17[4] = v7;
      CFRetain((CFTypeRef)(v8 - 16));
      v10 = *(_QWORD *)(v8 + 32);
      v18[0] = v9;
      v18[1] = 3221225472;
      v18[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9489;
      v18[3] = &unk_1E14FABB8;
      v18[4] = v17;
      v18[5] = v8;
      v19[0] = v9;
      v19[1] = 3221225472;
      v19[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9490;
      v19[3] = &unk_1E14FDA90;
      v19[4] = v18;
      v19[5] = v10;
      v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v10 + 32) + 64))(*(_QWORD *)(v10 + 32));
      v12 = *(NSObject **)(v10 + 40);
      block[0] = v9;
      block[1] = 3221225472;
      block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
      block[3] = &unk_1E14FDA90;
      block[4] = v19;
      block[5] = v11;
      dispatch_async(v12, block);
      if (v6)
      {
        v13 = (void (*)(uint64_t, const __CFArray *, _QWORD))a3[18];
        if (v13)
        {
          v13(a2, v6, a3[1]);
        }
        else if (a3[7])
        {
          v14 = CopyAllDataFromDataArray(v6);
          v15 = (void (*)(uint64_t, __CFData *, CFIndex, _QWORD))a3[7];
          Length = CFDataGetLength(v14);
          v15(a2, v14, Length, a3[1]);
          if (v14)
            CFRelease(v14);
        }
        CFRelease(v6);
      }
    }
  }
}

void ___ZN27URLConnectionClient_Classic26_delegate_didStopBufferingEPK9__CFArray_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  __CFData *Mutable;
  void (*v8)(uint64_t, __CFData *, CFIndex, _QWORD);
  CFIndex Length;
  const void *v10;

  if (a2 && a3)
  {
    v6 = *(_QWORD *)(a1 + 32);
    Mutable = CopyAllDataFromDataArray(*(const __CFArray **)(a1 + 40));
    if (!Mutable)
      Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(v6 + 8), 0);
    v8 = *(void (**)(uint64_t, __CFData *, CFIndex, _QWORD))(a3 + 64);
    Length = CFDataGetLength(Mutable);
    v8(a2, Mutable, Length, *(_QWORD *)(a3 + 8));
    if (Mutable)
      CFRelease(Mutable);
  }
  v10 = *(const void **)(a1 + 40);
  if (v10)
    CFRelease(v10);
}

void ___ZN27URLConnectionClient_Classic51_delegate_willSendRequestForAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = (const void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
  CFLog();
  if (v1)
    CFRelease(v1);
}

void ___ZN27URLConnectionClient_Classic39_delegate_willSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  void (*v5)(uint64_t, uint64_t, uint64_t, _QWORD *, _QWORD);
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, _QWORD, _QWORD, _QWORD);
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;
  const void *v13;
  _QWORD v14[5];

  if (!a2 || !a3)
    goto LABEL_13;
  v5 = (void (*)(uint64_t, uint64_t, uint64_t, _QWORD *, _QWORD))a3[20];
  if (v5)
  {
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = ___ZN27URLConnectionClient_Classic39_delegate_willSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke_2;
    v14[3] = &unk_1E14FAA30;
    v6 = *(_QWORD *)(a1 + 32);
    v7 = *(_QWORD *)(a1 + 48);
    v14[4] = *(_QWORD *)(a1 + 40);
    v5(a2, v6, v7, v14, a3[1]);
    goto LABEL_14;
  }
  v8 = (uint64_t (*)(uint64_t, _QWORD, _QWORD, _QWORD))a3[5];
  if (v8)
  {
    v9 = (const void *)v8(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 48), a3[1]);
    v10 = v9;
    v11 = *(const void **)(a1 + 32);
    if (!*a3 && v9 && v9 == v11)
    {
      CFRetain(v9);
      v11 = *(const void **)(a1 + 32);
    }
    if (v10 == v11)
    {
      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    }
    else
    {
      v12 = -[NSURLRequest _initWithCFURLRequest:]([NSURLRequest alloc], "_initWithCFURLRequest:", v10);
      (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      if (v12)
        CFRelease(v12);
    }
    if (v10)
      CFRelease(v10);
  }
  else
  {
LABEL_13:
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
LABEL_14:

  v13 = *(const void **)(a1 + 32);
  if (v13)
    CFRelease(v13);
}

void ___ZN27URLConnectionClient_Classic39_delegate_willSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke_2(uint64_t a1, uint64_t a2)
{
  id v3;

  v3 = -[NSURLRequest _initWithCFURLRequest:]([NSURLRequest alloc], "_initWithCFURLRequest:", a2);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v3)
    CFRelease(v3);
}

void ___ZN27URLConnectionClient_Classic25_delegate_willSendRequestEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v4;
  uint64_t v6;
  const void *v7;
  const void *v8;

  v4 = 0;
  if (a2 && a3)
  {
    v4 = *(id *)(a1 + 32);
    v6 = (*(uint64_t (**)(uint64_t, id, _QWORD, _QWORD))(a3 + 40))(a2, v4, *(_QWORD *)(a1 + 48), *(_QWORD *)(a3 + 8));
    v7 = (const void *)v6;
    if (!*(_QWORD *)a3 && (id)v6 == v4)
    {
      if (!v4)
        goto LABEL_10;
      CFRetain(v4);
      goto LABEL_8;
    }
    if (v6)
    {
LABEL_8:
      v4 = -[NSURLRequest _initWithCFURLRequest:]([NSURLRequest alloc], "_initWithCFURLRequest:", v7);
      CFRelease(v7);
      goto LABEL_10;
    }
    v4 = 0;
  }
LABEL_10:
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  if (v4)
    CFRelease(v4);

  v8 = *(const void **)(a1 + 32);
  if (v8)
    CFRelease(v8);
}

void ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_22(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[6];
  std::__shared_weak_count *v14;
  _QWORD block[6];

  v2 = a1[4];
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 288))(v2, 0);
  v3 = MEMORY[0x1E0C809B0];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3321888768;
  v13[2] = ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2;
  v13[3] = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  v5 = a1[5];
  v4 = (std::__shared_weak_count *)a1[6];
  v13[4] = v2;
  v13[5] = v5;
  v14 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 64))(*(_QWORD *)(v2 + 32));
  v9 = *(NSObject **)(v2 + 40);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v13;
  block[5] = v8;
  dispatch_async(v9, block);
  (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 72))(*(_QWORD *)(v2 + 32));
  v10 = v14;
  if (v14)
  {
    v11 = (unint64_t *)&v14->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_18409901C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

CFTypeRef URLConnectionLoader::copyDebugSummary(URLConnectionLoader *this)
{
  void *v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;

  v1 = (void *)(*(uint64_t (**)(InterfaceRequiredForLoader *))(*(_QWORD *)this->var5 + 16))(this->var5);
  if (!v1)
    return CFRetain(CFSTR("no original request"));
  v2 = v1;
  v3 = objc_msgSend(v1, "_inner");
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);

  return (CFTypeRef)v4;
}

uint64_t URLConnectionLoader::_loaderEvent_SuspendProtocolLoad(URLConnectionLoader *this)
{
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)&__block_literal_global_95_9562);
}

uint64_t URLConnectionLoader::_loaderEvent_ResumeProtocolLoad(URLConnectionLoader *this)
{
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)&__block_literal_global_96);
}

uint64_t URLConnectionLoader::_loaderEvent_SetBodyStream(URLConnectionLoader *this, CFTypeRef cf)
{
  _QWORD v5[5];

  if (cf)
    CFRetain(cf);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN19URLConnectionLoader26_loaderEvent_SetBodyStreamEP14__CFReadStream_block_invoke;
  v5[3] = &__block_descriptor_40_e9_v16__0_v8l;
  v5[4] = cf;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)v5);
}

uint64_t URLConnectionLoader::_loaderEvent_DontUseCredentialStorage(URLConnectionLoader *this)
{
  *(_BYTE *)&this->var28 |= 4u;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)&__block_literal_global_78);
}

uint64_t URLConnectionLoader::protocolRetainClient(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(InterfaceRequiredForLoader *))(*(_QWORD *)this->var5 + 64))(this->var5);
}

uint64_t URLConnectionLoader::protocolReleaseClient(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(InterfaceRequiredForLoader *))(*(_QWORD *)this->var5 + 72))(this->var5);
}

uint64_t URLConnectionLoader::protocolCopyDescription(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(InterfaceRequiredForLoader *))(*(_QWORD *)this->var5 + 24))(this->var5);
}

URLConnectionLoader *URLConnectionLoader::protocolDidReceiveInformationalResponse(URLConnectionLoader *this, _CFURLResponse *a2)
{
  URLConnectionLoader *v3;
  RedirectionRecorder *var12;
  _CFURLResponse *v5;
  InterfaceRequiredForLoader *var5;
  _QWORD v7[5];
  uint8_t buf[16];

  if (this->var21)
  {
    v3 = this;
    var12 = this->var12;
    if (var12)
    {
      return (URLConnectionLoader *)(*(uint64_t (**)(RedirectionRecorder *, _CFURLResponse *))(*(_QWORD *)var12 + 96))(var12, a2);
    }
    else
    {
      if (!a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "connDidReceiveInformationalResponse(): NULL response provided!", buf, 2u);
      }
      URLConnectionLoader::touchConnection(v3);
      v5 = a2;
      var5 = v3->var5;
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = ___ZN19URLConnectionLoader39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke;
      v7[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
      v7[4] = a2;
      return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v7);
    }
  }
  return this;
}

URLConnectionLoader *URLConnectionLoader::protocolNeedNewBodyStream(URLConnectionLoader *this)
{
  RedirectionRecorder *var12;

  if (this->var21)
  {
    var12 = this->var12;
    if (var12)
    {
      return (URLConnectionLoader *)(*(uint64_t (**)(RedirectionRecorder *))(*(_QWORD *)var12 + 152))(this->var12);
    }
    else if (!this->var23)
    {
      return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, void *))(*(_QWORD *)this->var5 + 40))(this->var5, &__block_literal_global_77);
    }
  }
  return this;
}

URLConnectionLoader *URLConnectionLoader::protocolNeedNewBodyStreamFromOffset(URLConnectionLoader *this, uint64_t a2)
{
  RedirectionRecorder *var12;
  InterfaceRequiredForLoader *var5;
  _QWORD v4[5];

  if (this->var21)
  {
    var12 = this->var12;
    if (var12)
    {
      return (URLConnectionLoader *)(*(uint64_t (**)(RedirectionRecorder *))(*(_QWORD *)var12 + 160))(this->var12);
    }
    else if (!this->var23)
    {
      var5 = this->var5;
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 3221225472;
      v4[2] = ___ZN19URLConnectionLoader35protocolNeedNewBodyStreamFromOffsetEx_block_invoke;
      v4[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
      v4[4] = a2;
      return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v4);
    }
  }
  return this;
}

_QWORD *URLConnectionLoader::protocolConnectionWaiting(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v4;
  const __CFAllocator *v5;
  const void *v6;
  uint64_t v7;
  _QWORD v8[5];
  void (**v9)(AutoString *__hidden);
  CFStringRef v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (result[18])
  {
    v2 = result;
    if (!result[11])
    {
      result = (_QWORD *)DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_43, 2);
      if (result)
      {
        v4 = result;
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *, const char *, _QWORD))(*result + 16))(result, "Connection Waiting", 0);
        if ((_DWORD)result)
        {
          v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v6 = (const void *)(*(uint64_t (**)(_QWORD *))(*v2 + 24))(v2);
          v9 = &off_1E14E4818;
          v11 = 0;
          v12 = 0;
          v10 = CFStringCreateWithCString(v5, "Loader", 0x8000100u);
          (*(void (**)(_QWORD *, CFStringRef, const void *))(*v4 + 64))(v4, v10, v6);
          AutoString::~AutoString((AutoString *)&v9);
          if (v6)
            CFRelease(v6);
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v4 + 8))(v4);
        }
      }
      if ((v2[25] & 0x10) != 0)
      {
        v7 = v2[4];
        v8[0] = MEMORY[0x1E0C809B0];
        v8[1] = 3221225472;
        v8[2] = ___ZN19URLConnectionLoader25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke_2;
        v8[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
        v8[4] = a2;
        return (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v7 + 40))(v7, v8);
      }
    }
  }
  return result;
}

void sub_1840994CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

URLConnectionLoader *URLConnectionLoader::protocolConditionalRequirementsChanged(URLConnectionLoader *this, int a2)
{
  URLConnectionLoader *v2;
  URLConnectionLoader *v4;
  const char *v5;
  const __CFAllocator *v6;
  const void *v7;
  CFStringRef v8;
  InterfaceRequiredForLoader *var5;
  _QWORD v10[4];
  char v11;
  void (**v12)(AutoString *__hidden);
  CFStringRef v13;
  uint64_t v14;
  uint64_t v15;
  void (**v16)(AutoString *__hidden);
  CFStringRef v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (this->var21)
  {
    v2 = this;
    if (!this->var12)
    {
      this = (URLConnectionLoader *)DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_45_9594, 2);
      if (this)
      {
        v4 = this;
        v5 = a2 ? "true" : "false";
        this = (URLConnectionLoader *)(*((uint64_t (**)(URLConnectionLoader *, const char *, _QWORD))this->var0
                                       + 2))(this, "Condtional Requirements Changed", 0);
        if ((_DWORD)this)
        {
          v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v7 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))v2->var0 + 3))(v2);
          v16 = &off_1E14E4818;
          v18 = 0;
          v19 = 0;
          v17 = CFStringCreateWithCString(v6, "Loader", 0x8000100u);
          (*((void (**)(URLConnectionLoader *, CFStringRef, const void *))v4->var0 + 8))(v4, v17, v7);
          AutoString::~AutoString((AutoString *)&v16);
          v16 = &off_1E14E4818;
          v8 = CFStringCreateWithCString(v6, "satisfied", 0x8000100u);
          v18 = 0;
          v19 = 0;
          v17 = v8;
          v12 = &off_1E14E4818;
          v14 = 0;
          v15 = 0;
          v13 = CFStringCreateWithCString(v6, v5, 0x8000100u);
          (*((void (**)(URLConnectionLoader *, CFStringRef, CFStringRef))v4->var0 + 8))(v4, v17, v13);
          AutoString::~AutoString((AutoString *)&v12);
          AutoString::~AutoString((AutoString *)&v16);
          if (v7)
            CFRelease(v7);
          this = (URLConnectionLoader *)(*((uint64_t (**)(URLConnectionLoader *))v4->var0 + 1))(v4);
        }
      }
      if ((*(_BYTE *)&v2->var28 & 0x20) != 0)
      {
        var5 = v2->var5;
        v10[0] = MEMORY[0x1E0C809B0];
        v10[1] = 3221225472;
        v10[2] = ___ZN19URLConnectionLoader38protocolConditionalRequirementsChangedEh_block_invoke_2;
        v10[3] = &__block_descriptor_33_e35_v16__0__LoaderClientInterface_____8l;
        v11 = a2;
        return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v10);
      }
    }
  }
  return this;
}

void sub_1840996F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  AutoString::~AutoString((AutoString *)&a14);
  AutoString::~AutoString((AutoString *)&a33);
  _Unwind_Resume(a1);
}

uint64_t URLConnectionLoader::protocolAlternatePathAvailable(uint64_t result, int a2)
{
  uint64_t v2;
  _QWORD v3[4];
  int v4;

  if (*(_QWORD *)(result + 144) && !*(_QWORD *)(result + 88) && (*(_BYTE *)(result + 200) & 0x40) != 0)
  {
    v2 = *(_QWORD *)(result + 32);
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = ___ZN19URLConnectionLoader30protocolAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke;
    v3[3] = &__block_descriptor_36_e35_v16__0__LoaderClientInterface_____8l;
    v4 = a2;
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 40))(v2, v3);
  }
  return result;
}

void URLConnectionLoader::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(URLConnectionLoader *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  uint64_t v6;
  uint64_t v7;
  const __CFAllocator *v8;
  const void *v9;
  CFStringRef v10;
  CFStringRef v11;
  CFStringRef v12;
  CFStringRef v13;
  InterfaceRequiredForLoader *var5;
  _QWORD v15[6];
  void (**v16)(AutoString *__hidden);
  CFStringRef v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (this->var21 && a3 && stream && !this->var12)
  {
    v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_52, 2);
    if (v6)
    {
      v7 = v6;
      if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v6 + 16))(v6, "Received socket streams for upgrade", 0))
      {
        v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v9 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))this->var0 + 3))(this);
        v16 = &off_1E14E4818;
        v18 = 0;
        v19 = 0;
        v17 = CFStringCreateWithCString(v8, "Loader", 0x8000100u);
        (*(void (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)v7 + 64))(v7, v17, v9);
        AutoString::~AutoString((AutoString *)&v16);
        v16 = &off_1E14E4818;
        v10 = CFStringCreateWithCString(v8, "ReadStream", 0x8000100u);
        v18 = 0;
        v19 = 0;
        v17 = v10;
        v11 = CFCopyDescription(stream);
        (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v7 + 64))(v7, v17, v11);
        if (v11)
          CFRelease(v11);
        AutoString::~AutoString((AutoString *)&v16);
        v16 = &off_1E14E4818;
        v12 = CFStringCreateWithCString(v8, "WriteStream", 0x8000100u);
        v18 = 0;
        v19 = 0;
        v17 = v12;
        v13 = CFCopyDescription(a3);
        (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v7 + 64))(v7, v17, v13);
        if (v13)
          CFRelease(v13);
        AutoString::~AutoString((AutoString *)&v16);
        if (v9)
          CFRelease(v9);
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      }
    }
    CFRetain(stream);
    CFRetain(a3);
    var5 = this->var5;
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = ___ZN19URLConnectionLoader54protocolReceivedSocketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke_2;
    v15[3] = &__block_descriptor_48_e35_v16__0__LoaderClientInterface_____8l;
    v15[4] = stream;
    v15[5] = a3;
    (*(void (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v15);
  }
  else
  {
    if (stream)
      CFReadStreamClose(stream);
    if (a3)
      CFWriteStreamClose(a3);
  }
}

void sub_184099A3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void URLConnectionLoader::tcpConnectionForUpgradeHeaderAvailable(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  const __CFAllocator *v8;
  const void *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[6];
  std::__shared_weak_count *v18;
  void (**v19)(AutoString *__hidden);
  CFStringRef v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1[18] && !a1[11])
  {
    v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_56_9587, 2);
    if (v6)
    {
      v7 = v6;
      if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v6 + 16))(v6, "Received tcp connection for upgrade", 0))
      {
        v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v9 = (const void *)(*(uint64_t (**)(_QWORD *))(*a1 + 24))(a1);
        v19 = &off_1E14E4818;
        v21 = 0;
        v22 = 0;
        v20 = CFStringCreateWithCString(v8, "Loader", 0x8000100u);
        (*(void (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)v7 + 64))(v7, v20, v9);
        AutoString::~AutoString((AutoString *)&v19);
        if (v9)
          CFRelease(v9);
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      }
    }
    v10 = a1[4];
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 3321888768;
    v17[2] = ___ZN19URLConnectionLoader38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2;
    v17[3] = &unk_1E14F3200;
    v11 = (std::__shared_weak_count *)a2[1];
    v17[5] = *a2;
    v18 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    v17[4] = a3;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v10 + 40))(v10, v17);
    v14 = v18;
    if (v18)
    {
      v15 = (unint64_t *)&v18->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
  else if (*a2)
  {
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 152))(*a2, 0);
  }
}

void sub_184099C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(exception_object);
}

void URLConnectionLoader::_loaderInterface_rejectChallenge(URLConnectionLoader *this, _CFURLAuthChallenge *a2)
{
  uint64_t v4;
  InterfaceRequiredForLoader *var5;
  _QWORD v6[5];
  _QWORD v7[6];

  if (!this->var23)
  {
    v4 = MEMORY[0x1E0C809B0];
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZN19URLConnectionLoader32_loaderInterface_rejectChallengeEP19_CFURLAuthChallenge_block_invoke;
    v7[3] = &__block_descriptor_48_e5_v8__0l;
    v7[4] = this;
    v7[5] = a2;
    __CFNetworkLogForAuthTimeoutIssueSync((uint64_t)v7);
    if (a2)
    {
      if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
        dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
      if (URLAuthChallenge::tryNextProtectionSpace((URLAuthChallenge *)((char *)a2 + 16)))
      {
        CFRetain(a2);
        var5 = this->var5;
        v6[0] = v4;
        v6[1] = 3221225472;
        v6[2] = ___ZN19URLConnectionLoader32_loaderInterface_rejectChallengeEP19_CFURLAuthChallenge_block_invoke_2;
        v6[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
        v6[4] = a2;
        (*(void (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v6);
      }
      else
      {
        (*((void (**)(URLConnectionLoader *, _QWORD, _CFURLAuthChallenge *))this->var0 + 32))(this, 0, a2);
      }
    }
  }
}

void URLConnectionLoader::_loaderInterface_UpdateScheduling(URLConnectionLoader *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  NSObject *v3;
  uint8_t v4[16];

  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v3 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v4 = 0;
    _os_log_error_impl(&dword_183ECA000, v3, OS_LOG_TYPE_ERROR, "Rescheduling the CFNetwork loader is no longer supported", v4, 2u);
  }
}

uint64_t URLConnectionLoader::_loaderInterface_setPriorityHint(URLConnectionLoader *this, float a2, char a3)
{
  _QWORD v4[4];
  float v5;
  char v6;

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN19URLConnectionLoader32_loaderInterface_setPriorityHintEfb_block_invoke;
  v4[3] = &__block_descriptor_37_e9_v16__0_v8l;
  v5 = a2;
  v6 = a3;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)v4);
}

uint64_t URLConnectionLoader::_loaderInterface_setBytesPerSecondLimit(URLConnectionLoader *this, uint64_t a2)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN19URLConnectionLoader39_loaderInterface_setBytesPerSecondLimitEx_block_invoke;
  v3[3] = &__block_descriptor_40_e9_v16__0_v8l;
  v3[4] = a2;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)v3);
}

uint64_t URLConnectionLoader::_loaderInterface_expectedProgressTargetChanged(URLConnectionLoader *this)
{
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)&__block_literal_global_69_9557);
}

void ***URLConnectionLoader::_loaderInterface_retain(URLConnectionLoader *this)
{
  (*(void (**)(InterfaceRequiredForLoader *))(*(_QWORD *)this->var5 + 64))(this->var5);
  return &this->var7;
}

uint64_t URLConnectionLoader::_loaderInterface_release(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(InterfaceRequiredForLoader *))(*(_QWORD *)this->var5 + 72))(this->var5);
}

void `non-virtual thunk to'URLConnectionLoader::~URLConnectionLoader(URLConnectionLoader *this)
{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 16));
}

{
  unint64_t *p_var33;

  p_var33 = &this[-1].var33;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 16));
  CFAllocatorDeallocate(*(CFAllocatorRef *)&this[-1].var34, p_var33);
}

{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 48));
}

{
  char *p_var25;

  p_var25 = (char *)&this[-1].var25;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 48));
  CFAllocatorDeallocate(*(CFAllocatorRef *)&this[-1].var26, p_var25);
}

{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 56));
}

{
  CoreSchedulingSet **p_var24;

  p_var24 = &this[-1].var24;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 56));
  CFAllocatorDeallocate(*(CFAllocatorRef *)&this[-1].var25, p_var24);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::_loaderEvent_SetBodyStream(URLConnectionLoader *this, __CFReadStream *a2)
{
  return URLConnectionLoader::_loaderEvent_SetBodyStream((URLConnectionLoader *)((char *)this - 48), a2);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::_loaderEvent_DontUseCredentialStorage(URLConnectionLoader *this)
{
  LOBYTE(this->var22) |= 4u;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)&__block_literal_global_78);
}

void `non-virtual thunk to'URLConnectionLoader::_loaderInterface_rejectChallenge(URLConnectionLoader *this, _CFURLAuthChallenge *a2)
{
  URLConnectionLoader::_loaderInterface_rejectChallenge((URLConnectionLoader *)((char *)this - 48), a2);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::_loaderInterface_expectedProgressTargetChanged(URLConnectionLoader *this)
{
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)&__block_literal_global_69_9557);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::protocolRetainClient(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)&this[-1].var28 + 64))(*(_QWORD *)&this[-1].var28);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::protocolReleaseClient(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)&this[-1].var28 + 72))(*(_QWORD *)&this[-1].var28);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::protocolCopyDescription(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)&this[-1].var28 + 24))(*(_QWORD *)&this[-1].var28);
}

void `non-virtual thunk to'URLConnectionLoader::protocolWasRedirected(URLConnectionLoader *this, NSURLRequest *a2, _CFURLResponse *a3)
{
  URLConnectionLoader::protocolWasRedirected((URLConnectionLoader *)((char *)this - 56), a2, a3);
}

URLConnectionLoader *`non-virtual thunk to'URLConnectionLoader::protocolCacheResponseIsValid(URLConnectionLoader *this, const _CFCachedURLResponse *a2)
{
  return URLConnectionLoader::protocolCacheResponseIsValid((URLConnectionLoader *)((char *)this - 56), a2);
}

URLConnectionLoader *`non-virtual thunk to'URLConnectionLoader::protocolDidReceiveInformationalResponse(URLConnectionLoader *this, _CFURLResponse *a2)
{
  return URLConnectionLoader::protocolDidReceiveInformationalResponse((URLConnectionLoader *)((char *)this - 56), a2);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::protocolDidReceiveResponse(URLConnectionLoader *this, _CFURLResponse *a2)
{
  return URLConnectionLoader::protocolDidReceiveResponse((URLConnectionLoader *)((char *)this - 56), a2);
}

void `non-virtual thunk to'URLConnectionLoader::protocolDidLoadData(URLConnectionLoader *this, const __CFData *a2, uint64_t a3)
{
  URLConnectionLoader::protocolDidLoadData((URLConnectionLoader *)((char *)this - 56), a2, a3);
}

void `non-virtual thunk to'URLConnectionLoader::protocolDidSendBodyData(URLConnectionLoader *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  URLConnectionLoader::protocolDidSendBodyData((URLConnectionLoader *)((char *)this - 56), a2, a3, a4);
}

RedirectionRecorder *`non-virtual thunk to'URLConnectionLoader::protocolDidFinishLoading(URLConnectionLoader *this)
{
  return URLConnectionLoader::protocolDidFinishLoading((URLConnectionLoader *)((char *)this - 56));
}

URLConnectionLoader *`non-virtual thunk to'URLConnectionLoader::protocolDidFail(URLConnectionLoader *this, __CFError *a2)
{
  return URLConnectionLoader::protocolDidFail((URLConnectionLoader *)((char *)this - 56), a2);
}

URLConnectionLoader *`non-virtual thunk to'URLConnectionLoader::protocolDidReceiveAuthenticationChallenge(URLConnectionLoader *this, _CFURLAuthChallenge *a2)
{
  return URLConnectionLoader::protocolDidReceiveAuthenticationChallenge((URLConnectionLoader *)((char *)this - 56), a2);
}

URLConnectionLoader *`non-virtual thunk to'URLConnectionLoader::protocolNeedNewBodyStream(URLConnectionLoader *this)
{
  return URLConnectionLoader::protocolNeedNewBodyStream((URLConnectionLoader *)((char *)this - 56));
}

URLConnectionLoader *`non-virtual thunk to'URLConnectionLoader::protocolNeedNewBodyStreamFromOffset(URLConnectionLoader *this, uint64_t a2)
{
  return URLConnectionLoader::protocolNeedNewBodyStreamFromOffset((URLConnectionLoader *)((char *)this - 56), a2);
}

void `non-virtual thunk to'URLConnectionLoader::protocolConnectionEstablished(URLConnectionLoader *this, const __CFDictionary *a2)
{
  URLConnectionLoader::protocolConnectionEstablished((URLConnectionLoader *)((char *)this - 56), a2);
}

_QWORD *`non-virtual thunk to'URLConnectionLoader::protocolConnectionWaiting(uint64_t a1, uint64_t a2)
{
  return URLConnectionLoader::protocolConnectionWaiting((_QWORD *)(a1 - 56), a2);
}

URLConnectionLoader *`non-virtual thunk to'URLConnectionLoader::protocolConditionalRequirementsChanged(URLConnectionLoader *this, int a2)
{
  return URLConnectionLoader::protocolConditionalRequirementsChanged((URLConnectionLoader *)((char *)this - 56), a2);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::protocolAlternatePathAvailable(uint64_t a1, int a2)
{
  return URLConnectionLoader::protocolAlternatePathAvailable(a1 - 56, a2);
}

void `non-virtual thunk to'URLConnectionLoader::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(URLConnectionLoader *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  URLConnectionLoader::protocolReceivedSocketStreamsForUpgradeHeaderAvailable((URLConnectionLoader *)((char *)this - 56), a2, a3);
}

void `non-virtual thunk to'URLConnectionLoader::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  URLConnectionLoader::tcpConnectionForUpgradeHeaderAvailable((_QWORD *)(a1 - 56), a2, a3);
}

uint64_t ___ZN19URLConnectionLoader46_loaderInterface_expectedProgressTargetChangedEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 176))(a2);
  return result;
}

void ___ZN19URLConnectionLoader37_loaderEvent_DontUseCredentialStorageEv_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_BYTE *)(a2 + 40) = 0;
}

void ___ZN19URLConnectionLoader32_loaderInterface_rejectChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = (const void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
  CFLog();
  if (v1)
    CFRelease(v1);
}

void ___ZN19URLConnectionLoader32_loaderInterface_rejectChallengeEP19_CFURLAuthChallenge_block_invoke_2(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 40))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

void ___ZN19URLConnectionLoader30_loaderInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = (const void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
  CFLog();
  if (v1)
    CFRelease(v1);
}

uint64_t ___ZN19URLConnectionLoader15touchConnectionEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1894;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN19URLConnectionLoader30_loaderInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1402;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN19URLConnectionLoader51_loaderInterface_performDefaultHandlingForChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = (const void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
  CFLog();
  if (v1)
    CFRelease(v1);
}

void ___ZN19URLConnectionLoader38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  if (a2)
  {
    v2 = (std::__shared_weak_count *)a1[6];
    v8 = a1[5];
    v9 = v2;
    if (v2)
    {
      p_shared_owners = (unint64_t *)&v2->__shared_owners_;
      do
        v4 = __ldxr(p_shared_owners);
      while (__stxr(v4 + 1, p_shared_owners));
    }
    (*(void (**)(uint64_t, uint64_t *, _QWORD))(*(_QWORD *)a2 + 168))(a2, &v8, a1[4]);
    v5 = v9;
    if (v9)
    {
      v6 = (unint64_t *)&v9->__shared_owners_;
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  else
  {
    (*(void (**)(_QWORD))(*(_QWORD *)a1[5] + 152))(a1[5]);
  }
}

void sub_18409A404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN19URLConnectionLoader38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 914;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN19URLConnectionLoader54protocolReceivedSocketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke_2(uint64_t a1, uint64_t a2)
{
  const void *v3;
  const void *v4;

  if (a2)
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  }
  else
  {
    CFReadStreamClose(*(CFReadStreamRef *)(a1 + 32));
    CFWriteStreamClose(*(CFWriteStreamRef *)(a1 + 40));
  }
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
}

uint64_t ___ZN19URLConnectionLoader54protocolReceivedSocketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 884;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN19URLConnectionLoader30protocolAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 144))(a2, *(unsigned int *)(result + 32));
  return result;
}

uint64_t ___ZN19URLConnectionLoader38protocolConditionalRequirementsChangedEh_block_invoke_2(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 136))(a2, *(unsigned __int8 *)(result + 32));
  return result;
}

uint64_t ___ZN19URLConnectionLoader38protocolConditionalRequirementsChangedEh_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 838;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN19URLConnectionLoader25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke_2(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 128))(a2, *(_QWORD *)(result + 32));
  return result;
}

uint64_t ___ZN19URLConnectionLoader25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 813;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN19RedirectionRecorder16playbackMessagesEP17URLProtocolClientPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 24))(*(_QWORD *)(a1 + 48));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

uint64_t ___ZN19URLConnectionLoader29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 768;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN19URLConnectionLoader35protocolNeedNewBodyStreamFromOffsetEx_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 56))(a2, *(_QWORD *)(result + 32));
  return result;
}

uint64_t ___ZN19URLConnectionLoader25protocolNeedNewBodyStreamEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 48))(a2);
  return result;
}

void ___ZN19URLConnectionLoader41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = (const void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
  CFLog();
  if (v1)
    CFRelease(v1);
}

uint64_t ___ZN19URLConnectionLoader41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 537;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t URLConnectionLoader::logTimings(uint64_t a1, uint64_t a2)
{
  const __CFAllocator *v4;
  void (**v6)(AutoString *__hidden);
  CFStringRef v7;
  uint64_t v8;
  uint64_t v9;
  void (**v10)(AutoString *__hidden);
  CFStringRef v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  CFAbsoluteTimeGetCurrent();
  if (*(double *)(a1 + 184) == 0.0)
  {
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v10 = &off_1E14E4818;
    v12 = 0;
    v13 = 0;
    v11 = CFStringCreateWithCString(v4, "init to origin load", 0x8000100u);
    v6 = &off_1E14E4818;
    v8 = 0;
    v9 = 0;
    v7 = CFStringCreateWithCString(v4, "not done", 0x8000100u);
    (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)a2 + 64))(a2, v11, v7);
    AutoString::~AutoString((AutoString *)&v6);
    AutoString::~AutoString((AutoString *)&v10);
  }
  else
  {
    (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a2 + 72))(a2, "init to origin load", CFSTR("%gs"));
  }
  (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a2 + 72))(a2, "total time", CFSTR("%gs"));
  return (*(uint64_t (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a2 + 72))(a2, "total bytes", CFSTR("%llu"));
}

void sub_18409A998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  AutoString::~AutoString((AutoString *)&a10);
  AutoString::~AutoString((AutoString *)&a29);
  _Unwind_Resume(a1);
}

uint64_t ___ZN19URLConnectionLoader15protocolDidFailEP9__CFError_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1118;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN19URLConnectionLoader24protocolDidFinishLoadingEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1070;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN19URLConnectionLoader23protocolDidSendBodyDataExxx_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 729;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN19URLConnectionLoader19protocolDidLoadDataEPK8__CFDatax_block_invoke_32(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  const void *v4;

  if (a2)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 80))(a2, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
  v3 = *(NSObject **)(a1 + 32);
  if (v3)
    dispatch_release(v3);
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
}

uint64_t ___ZN19URLConnectionLoader19protocolDidLoadDataEPK8__CFDatax_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 633;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN19URLConnectionLoader39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 64))(a2, *(_QWORD *)(a1 + 32));

}

BOOL RedirectionRecorder::equals(RedirectionRecorder *this, RedirectionRecorder *a2)
{
  return this == a2;
}

uint64_t RedirectionRecorder::protocolCopyDescription(RedirectionRecorder *this)
{
  return 0;
}

void RedirectionRecorder::protocolWasRedirected(RedirectionRecorder *this, CFTypeRef cf, _CFURLResponse *a3)
{
  _CFURLResponse *v6;
  _QWORD v7[6];

  if (cf)
    CFRetain(cf);
  v6 = a3;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN19RedirectionRecorder21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke;
  v7[3] = &unk_1E14FB070;
  v7[4] = cf;
  v7[5] = a3;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), v7);
}

void RedirectionRecorder::protocolCacheResponseIsValid(RedirectionRecorder *this, CFTypeRef cf)
{
  _QWORD value[5];

  if (cf)
    CFRetain(cf);
  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder28protocolCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = cf;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void RedirectionRecorder::protocolDidReceiveInformationalResponse(RedirectionRecorder *this, _CFURLResponse *a2)
{
  _CFURLResponse *v4;
  _QWORD value[5];

  v4 = a2;
  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void RedirectionRecorder::protocolDidSendBodyData(RedirectionRecorder *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD value[7];

  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder23protocolDidSendBodyDataExxx_block_invoke;
  value[3] = &__block_descriptor_56_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  value[5] = a3;
  value[6] = a4;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void RedirectionRecorder::protocolDidFail(RedirectionRecorder *this, CFTypeRef cf)
{
  _QWORD value[5];

  if (cf)
    CFRetain(cf);
  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder15protocolDidFailEP9__CFError_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = cf;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void RedirectionRecorder::protocolDidReceiveAuthenticationChallenge(RedirectionRecorder *this, CFTypeRef cf)
{
  _QWORD value[5];

  if (cf)
    CFRetain(cf);
  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = cf;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void RedirectionRecorder::protocolNeedNewBodyStream(RedirectionRecorder *this)
{
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), &__block_literal_global_134);
}

void RedirectionRecorder::protocolNeedNewBodyStreamFromOffset(RedirectionRecorder *this, uint64_t a2)
{
  _QWORD value[5];

  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder35protocolNeedNewBodyStreamFromOffsetEx_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void RedirectionRecorder::protocolConnectionEstablished(RedirectionRecorder *this, CFTypeRef cf)
{
  _QWORD value[5];

  if (cf)
    CFRetain(cf);
  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = cf;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void RedirectionRecorder::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(RedirectionRecorder *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream)
    CFReadStreamClose(stream);
  if (a3)
    CFWriteStreamClose(a3);
}

uint64_t RedirectionRecorder::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 152))(result, 0);
  return result;
}

void `non-virtual thunk to'RedirectionRecorder::~RedirectionRecorder(RedirectionRecorder *this)
{
  RedirectionRecorder::~RedirectionRecorder((RedirectionRecorder *)((char *)this - 24));
}

{
  char *v2;

  v2 = (char *)this - 24;
  RedirectionRecorder::~RedirectionRecorder((RedirectionRecorder *)((char *)this - 24));
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 2), v2);
}

{
  RedirectionRecorder::~RedirectionRecorder((RedirectionRecorder *)((char *)this - 32));
}

{
  char *v2;

  v2 = (char *)this - 32;
  RedirectionRecorder::~RedirectionRecorder((RedirectionRecorder *)((char *)this - 32));
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 3), v2);
}

uint64_t `non-virtual thunk to'RedirectionRecorder::protocolCopyDescription(RedirectionRecorder *this)
{
  return 0;
}

void `non-virtual thunk to'RedirectionRecorder::protocolWasRedirected(RedirectionRecorder *this, NSURLRequest *a2, _CFURLResponse *a3)
{
  RedirectionRecorder::protocolWasRedirected((RedirectionRecorder *)((char *)this - 24), a2, a3);
}

void `non-virtual thunk to'RedirectionRecorder::protocolCacheResponseIsValid(RedirectionRecorder *this, const _CFCachedURLResponse *a2)
{
  RedirectionRecorder::protocolCacheResponseIsValid((RedirectionRecorder *)((char *)this - 24), a2);
}

void `non-virtual thunk to'RedirectionRecorder::protocolDidReceiveInformationalResponse(RedirectionRecorder *this, _CFURLResponse *a2)
{
  _CFURLResponse *v4;
  _QWORD value[5];

  v4 = a2;
  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), value);
}

void `non-virtual thunk to'RedirectionRecorder::protocolDidReceiveResponse(RedirectionRecorder *this, _CFURLResponse *a2)
{
  _CFURLResponse *v4;
  _QWORD value[5];

  v4 = a2;
  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder26protocolDidReceiveResponseEP14_CFURLResponse_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), value);
}

void `non-virtual thunk to'RedirectionRecorder::protocolDidLoadData(RedirectionRecorder *this, const __CFData *a2, uint64_t a3)
{
  RedirectionRecorder::protocolDidLoadData((RedirectionRecorder *)((char *)this - 24), a2, a3);
}

void `non-virtual thunk to'RedirectionRecorder::protocolDidSendBodyData(RedirectionRecorder *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD value[7];

  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder23protocolDidSendBodyDataExxx_block_invoke;
  value[3] = &__block_descriptor_56_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  value[5] = a3;
  value[6] = a4;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), value);
}

void `non-virtual thunk to'RedirectionRecorder::protocolDidFinishLoading(RedirectionRecorder *this)
{
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), &__block_literal_global_133);
}

void `non-virtual thunk to'RedirectionRecorder::protocolDidFail(RedirectionRecorder *this, __CFError *a2)
{
  RedirectionRecorder::protocolDidFail((RedirectionRecorder *)((char *)this - 24), a2);
}

void `non-virtual thunk to'RedirectionRecorder::protocolDidReceiveAuthenticationChallenge(RedirectionRecorder *this, _CFURLAuthChallenge *a2)
{
  RedirectionRecorder::protocolDidReceiveAuthenticationChallenge((RedirectionRecorder *)((char *)this - 24), a2);
}

void `non-virtual thunk to'RedirectionRecorder::protocolNeedNewBodyStream(RedirectionRecorder *this)
{
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), &__block_literal_global_134);
}

void `non-virtual thunk to'RedirectionRecorder::protocolNeedNewBodyStreamFromOffset(RedirectionRecorder *this, uint64_t a2)
{
  _QWORD value[5];

  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder35protocolNeedNewBodyStreamFromOffsetEx_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), value);
}

void `non-virtual thunk to'RedirectionRecorder::protocolConnectionEstablished(RedirectionRecorder *this, const __CFDictionary *a2)
{
  RedirectionRecorder::protocolConnectionEstablished((RedirectionRecorder *)((char *)this - 24), a2);
}

void `non-virtual thunk to'RedirectionRecorder::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(RedirectionRecorder *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream)
    CFReadStreamClose(stream);
  if (a3)
    CFWriteStreamClose(a3);
}

uint64_t `non-virtual thunk to'RedirectionRecorder::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 152))(result, 0);
  return result;
}

uint64_t ___ZN19RedirectionRecorder35protocolNeedNewBodyStreamFromOffsetEx_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 120))(a2, *(_QWORD *)(result + 32));
  return result;
}

uint64_t ___ZN19RedirectionRecorder25protocolNeedNewBodyStreamEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 112))(a2);
  return result;
}

void ___ZN19RedirectionRecorder29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 128))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

void ___ZN19RedirectionRecorder41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 104))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

void ___ZN19RedirectionRecorder15protocolDidFailEP9__CFError_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 96))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

void ___ZN19RedirectionRecorder39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 56))(a2, *(_QWORD *)(a1 + 32));

}

void ___ZN19RedirectionRecorder28protocolCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 48))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

void ___ZN19RedirectionRecorder21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

uint64_t ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)a2 + 152))(a2, CFSTR("kCFErrorDomainCFNetwork"), -1007);
  return result;
}

uint64_t ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 484;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN19URLConnectionLoader26_loaderEvent_SetBodyStreamEP14__CFReadStream_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 80))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

uint64_t ___ZN19URLConnectionLoader34_loaderEvent_SetProtocolIsDownloadEh_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 128))(a2, *(unsigned __int8 *)(result + 32));
  return result;
}

uint64_t ___ZN19URLConnectionLoader14performTimeOutEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 120))(a2);
  return result;
}

uint64_t ___ZN19URLConnectionLoader14performTimeOutEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1876;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN19URLConnectionLoader16loadWithWhatToDoEP12NSURLRequestPK20_CFCachedURLResponselNS_8WhatToDoE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, const __CFString *, _QWORD))(*(_QWORD *)a2 + 152))(a2, CFSTR("kCFErrorDomainCFNetwork"), *(_QWORD *)(a1 + 32));
}

uint64_t ___ZN19URLConnectionLoader27_private_ScheduleOriginLoadEP12NSURLRequestPK20_CFCachedURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)a2 + 152))(a2, CFSTR("kCFErrorDomainCFNetwork"), -1002);
  return result;
}

uint64_t ___ZN19URLConnectionLoader16loadWithWhatToDoEP12NSURLRequestPK20_CFCachedURLResponselNS_8WhatToDoE_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1757;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZNK23CoreSchedulingSetOneOff29performAsyncWithTrailingBlockEU13block_pointerFvvE_block_invoke_9666(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

uint64_t URLConnectionLoader_Classic::protocolRetainClient(URLConnectionLoader_Classic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
}

uint64_t URLConnectionLoader_Classic::protocolReleaseClient(URLConnectionLoader_Classic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 72))(*((_QWORD *)this + 4));
}

uint64_t URLConnectionLoader_Classic::protocolCopyDescription(URLConnectionLoader_Classic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 24))(*((_QWORD *)this + 4));
}

void URLConnectionLoader_Classic::protocolDidReceiveInformationalResponse(URLConnectionLoader_Classic *this, _CFURLResponse *a2)
{
  _CFURLResponse *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[6];
  _QWORD block[6];

  v4 = a2;
  v5 = MEMORY[0x1E0C809B0];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN27URLConnectionLoader_Classic39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke;
  v8[3] = &__block_descriptor_48_e5_v8__0l;
  v8[4] = this;
  v8[5] = a2;
  v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v7 = *((_QWORD *)this + 5);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v8;
  block[5] = v6;
  dispatch_async(v7, block);
}

void URLConnectionLoader_Classic::protocolDidSendBodyData(URLConnectionLoader_Classic *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[8];
  _QWORD block[6];

  v5 = MEMORY[0x1E0C809B0];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN27URLConnectionLoader_Classic23protocolDidSendBodyDataExxx_block_invoke;
  v8[3] = &__block_descriptor_64_e5_v8__0l;
  v8[4] = this;
  v8[5] = a2;
  v8[6] = a3;
  v8[7] = a4;
  v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v7 = *((_QWORD *)this + 5);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v8;
  block[5] = v6;
  dispatch_async(v7, block);
}

void URLConnectionLoader_Classic::protocolDidFinishLoading(URLConnectionLoader_Classic *this)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD v5[5];
  _QWORD block[6];

  v2 = MEMORY[0x1E0C809B0];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN27URLConnectionLoader_Classic24protocolDidFinishLoadingEv_block_invoke;
  v5[3] = &__block_descriptor_40_e5_v8__0l;
  v5[4] = this;
  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v4 = *((_QWORD *)this + 5);
  block[0] = v2;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v5;
  block[5] = v3;
  dispatch_async(v4, block);
}

void URLConnectionLoader_Classic::protocolNeedNewBodyStream(URLConnectionLoader_Classic *this)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD v5[5];
  _QWORD block[6];

  v2 = MEMORY[0x1E0C809B0];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN27URLConnectionLoader_Classic25protocolNeedNewBodyStreamEv_block_invoke;
  v5[3] = &__block_descriptor_40_e5_v8__0l;
  v5[4] = this;
  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v4 = *((_QWORD *)this + 5);
  block[0] = v2;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v5;
  block[5] = v3;
  dispatch_async(v4, block);
}

void URLConnectionLoader_Classic::protocolNeedNewBodyStreamFromOffset(URLConnectionLoader_Classic *this, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[6];
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN27URLConnectionLoader_Classic35protocolNeedNewBodyStreamFromOffsetEx_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = this;
  v6[5] = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v5 = *((_QWORD *)this + 5);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void URLConnectionLoader_Classic::protocolConnectionEstablished(URLConnectionLoader_Classic *this, const __CFDictionary *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[6];
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN27URLConnectionLoader_Classic29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = this;
  v6[5] = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v5 = *((_QWORD *)this + 5);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void URLConnectionLoader_Classic::protocolConnectionWaiting(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[6];
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN27URLConnectionLoader_Classic25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = a1;
  v6[5] = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  v5 = *(NSObject **)(a1 + 40);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void URLConnectionLoader_Classic::protocolConditionalRequirementsChanged(URLConnectionLoader_Classic *this, char a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[5];
  char v7;
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN27URLConnectionLoader_Classic38protocolConditionalRequirementsChangedEh_block_invoke;
  v6[3] = &__block_descriptor_41_e5_v8__0l;
  v6[4] = this;
  v7 = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v5 = *((_QWORD *)this + 5);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void URLConnectionLoader_Classic::protocolAlternatePathAvailable(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[5];
  int v7;
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN27URLConnectionLoader_Classic30protocolAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke;
  v6[3] = &__block_descriptor_44_e5_v8__0l;
  v6[4] = a1;
  v7 = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  v5 = *(NSObject **)(a1 + 40);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void URLConnectionLoader_Classic::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(URLConnectionLoader_Classic *this, CFTypeRef cf, CFTypeRef a3)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[7];
  _QWORD block[6];

  if (cf)
    CFRetain(cf);
  if (a3)
    CFRetain(a3);
  v6 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN27URLConnectionLoader_Classic54protocolReceivedSocketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke;
  v9[3] = &__block_descriptor_56_e5_v8__0l;
  v9[4] = this;
  v9[5] = cf;
  v9[6] = a3;
  v7 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v8 = *((_QWORD *)this + 5);
  block[0] = v6;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v9;
  block[5] = v7;
  dispatch_async(v8, block);
}

void URLConnectionLoader_Classic::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[7];
  std::__shared_weak_count *v15;
  _QWORD block[6];

  v4 = MEMORY[0x1E0C809B0];
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3321888768;
  v14[2] = ___ZN27URLConnectionLoader_Classic38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  v14[3] = &unk_1E14F3EF0;
  v6 = *a2;
  v5 = (std::__shared_weak_count *)a2[1];
  v14[5] = a1;
  v14[6] = v6;
  v15 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v14[4] = a3;
  v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  v10 = *(NSObject **)(a1 + 40);
  block[0] = v4;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v14;
  block[5] = v9;
  dispatch_async(v10, block);
  v11 = v15;
  if (v15)
  {
    v12 = (unint64_t *)&v15->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_18409BEA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::~URLConnectionLoader_Classic(URLConnectionLoader_Classic *this)
{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 16));
}

{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 48));
}

{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 56));
}

void `non-virtual thunk to'URLConnectionLoader_Classic::~URLConnectionLoader_Classic(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 2;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)(this - 2));
  CFAllocatorDeallocate(*(this - 1), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 6;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)(this - 6));
  CFAllocatorDeallocate(*(this - 5), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 7;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)(this - 7));
  CFAllocatorDeallocate(*(this - 6), v2);
}

uint64_t `non-virtual thunk to'URLConnectionLoader_Classic::protocolCopyDescription(URLConnectionLoader_Classic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 3) + 24))(*((_QWORD *)this - 3));
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolDidReceiveInformationalResponse(URLConnectionLoader_Classic *this, _CFURLResponse *a2)
{
  URLConnectionLoader_Classic::protocolDidReceiveInformationalResponse((URLConnectionLoader_Classic *)((char *)this - 56), a2);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolNeedNewBodyStream(URLConnectionLoader_Classic *this)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD v5[5];
  _QWORD block[6];

  v2 = MEMORY[0x1E0C809B0];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN27URLConnectionLoader_Classic25protocolNeedNewBodyStreamEv_block_invoke;
  v5[3] = &__block_descriptor_40_e5_v8__0l;
  v5[4] = (char *)this - 56;
  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 3) + 64))(*((_QWORD *)this - 3));
  v4 = *((_QWORD *)this - 2);
  block[0] = v2;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v5;
  block[5] = v3;
  dispatch_async(v4, block);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolNeedNewBodyStreamFromOffset(URLConnectionLoader_Classic *this, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[6];
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN27URLConnectionLoader_Classic35protocolNeedNewBodyStreamFromOffsetEx_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = (char *)this - 56;
  v6[5] = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 3) + 64))(*((_QWORD *)this - 3));
  v5 = *((_QWORD *)this - 2);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolConnectionWaiting(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[6];
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN27URLConnectionLoader_Classic25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = a1 - 56;
  v6[5] = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 - 24) + 64))(*(_QWORD *)(a1 - 24));
  v5 = *(NSObject **)(a1 - 16);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolConditionalRequirementsChanged(URLConnectionLoader_Classic *this, char a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[5];
  char v7;
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN27URLConnectionLoader_Classic38protocolConditionalRequirementsChangedEh_block_invoke;
  v6[3] = &__block_descriptor_41_e5_v8__0l;
  v6[4] = (char *)this - 56;
  v7 = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 3) + 64))(*((_QWORD *)this - 3));
  v5 = *((_QWORD *)this - 2);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolAlternatePathAvailable(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[5];
  int v7;
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN27URLConnectionLoader_Classic30protocolAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke;
  v6[3] = &__block_descriptor_44_e5_v8__0l;
  v6[4] = a1 - 56;
  v7 = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 - 24) + 64))(*(_QWORD *)(a1 - 24));
  v5 = *(NSObject **)(a1 - 16);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(URLConnectionLoader_Classic *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  URLConnectionLoader_Classic::protocolReceivedSocketStreamsForUpgradeHeaderAvailable((URLConnectionLoader_Classic *)((char *)this - 56), a2, a3);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  URLConnectionLoader_Classic::tcpConnectionForUpgradeHeaderAvailable(a1 - 56, a2, a3);
}

uint64_t ___ZN27URLConnectionLoader_Classic30protocolAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke(uint64_t a1)
{
  return URLConnectionLoader::protocolAlternatePathAvailable(*(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 40));
}

void ___ZN27URLConnectionLoader_Classic38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t *a1)
{
  _QWORD *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  _QWORD v8[2];

  v2 = (_QWORD *)a1[5];
  v3 = (std::__shared_weak_count *)a1[7];
  v8[0] = a1[6];
  v8[1] = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  URLConnectionLoader::tcpConnectionForUpgradeHeaderAvailable(v2, v8, a1[4]);
  if (v3)
  {
    v6 = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_18409C394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN27URLConnectionLoader_Classic54protocolReceivedSocketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke(uint64_t a1)
{
  const void *v2;
  const void *v3;

  URLConnectionLoader::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(*(URLConnectionLoader **)(a1 + 32), *(CFReadStreamRef *)(a1 + 40), *(CFWriteStreamRef *)(a1 + 48));
  v2 = *(const void **)(a1 + 40);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 48);
  if (v3)
    CFRelease(v3);
}

void ___ZN27URLConnectionLoader_Classic39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke(uint64_t a1)
{
  URLConnectionLoader::protocolDidReceiveInformationalResponse(*(URLConnectionLoader **)(a1 + 32), *(_CFURLResponse **)(a1 + 40));

}

dispatch_queue_t ___ZN4CFNA20CFNetworkAgentClient23getCFNetworkAgentClientEv_block_invoke()
{
  _QWORD *v0;
  dispatch_queue_t result;

  v0 = (_QWORD *)operator new();
  *v0 = 0;
  v0[1] = 0;
  result = dispatch_queue_create("com.apple.cfnetwork.cfnetworkagentclient", 0);
  v0[2] = result;
  v0[3] = CFNA::CFNetworkAgentClient::CFNetworkAgentClient(void)::$_0::__invoke;
  CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client = (uint64_t)v0;
  return result;
}

void CFNA::CFNetworkAgentClient::CFNetworkAgentClient(void)::$_0::__invoke(dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
}

void CFNA::CFNetworkAgentClient::executeLegacyQuery(CFNA::CFNetworkAgentClient *this, const __CFString *a2, int64_t a3)
{
  std::__shared_weak_count_vtbl *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count_vtbl *v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count_vtbl *v28;
  std::__shared_weak_count *v29;
  std::__shared_weak_count_vtbl *v30;
  std::__shared_weak_count *v31;
  CFAllocatorRef allocator;
  uint64_t v33;
  void *ptr;
  UInt8 v35[1024];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v6 = (std::__shared_weak_count_vtbl *)xpc_dictionary_create(0, 0, 0);
  v30 = v6;
  v7 = (std::__shared_weak_count *)operator new();
  v7->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1BE0;
  v7->__shared_weak_owners_ = 0;
  v7[1].__vftable = v6;
  v31 = v7;
  xpc_dictionary_set_int64(v6, "type", a3);
  v28 = v6;
  v29 = v7;
  do
    v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  allocator = 0;
  v33 = 1023;
  ptr = _CFStringGetOrCreateCString(0, a2, v35, &v33, 0x8000100u);
  xpc_dictionary_set_string(v6, "sig", (const char *)ptr);
  if (ptr && v35 != ptr)
    CFAllocatorDeallocate(allocator, ptr);
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  v11 = (uint64_t)v30;
  v12 = v31;
  v26 = v30;
  v27 = v31;
  if (v31)
  {
    v13 = (unint64_t *)&v31->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  SmartBlockWithArgs<BOOL,NSObject  {objcproto13OS_xpc_object}*>::SmartBlockWithArgs(&v24, 0);
  CFNA::CFNetworkAgentClient::sendMessage((uint64_t)this, v11, v12, a3, &v24);
  v15 = v25;
  if (v25)
  {
    v16 = (unint64_t *)&v25->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v27;
  if (v27)
  {
    v19 = (unint64_t *)&v27->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v31;
  if (v31)
  {
    v22 = (unint64_t *)&v31->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void sub_18409C6E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, CFAllocatorRef allocator, uint64_t a18, void *ptr)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t *SmartBlockWithArgs<BOOL,NSObject  {objcproto13OS_xpc_object}*>::SmartBlockWithArgs(uint64_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  v4[1] = BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_initial;
  v4[2] = 0;
  *v4 = _Block_copy(a2);
  *a1 = (uint64_t)v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F14A8;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a1[1] = (uint64_t)v5;
  if (!a2)
  {
    v6 = *a1;
    *(_QWORD *)(v6 + 8) = BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_reseted;
    *(_QWORD *)(v6 + 16) = 0;
  }
  return a1;
}

void sub_18409C7D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void CFNA::CFNetworkAgentClient::sendMessage(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t *a5)
{
  NSObject *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD v18[7];
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;

  v6 = *(NSObject **)(a1 + 16);
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3321888768;
  v18[2] = ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke;
  v18[3] = &__block_descriptor_80_e8_48c62_ZTSNSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEE64c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE_e5_v8__0l;
  v18[4] = a1;
  v18[5] = a4;
  v18[6] = a2;
  v19 = a3;
  if (a3)
  {
    p_shared_owners = (unint64_t *)&a3->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = (std::__shared_weak_count *)a5[1];
  v20 = *a5;
  v21 = v9;
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  dispatch_async(v6, v18);
  v12 = v21;
  if (v21)
  {
    v13 = (unint64_t *)&v21->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = v19;
  if (v19)
  {
    v16 = (unint64_t *)&v19->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _xpc_connection_s *v3;
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  void *v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  char *v16;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v18;
  uint64_t v19;
  NSObject *v20;
  _QWORD handler[6];
  std::__shared_weak_count *v22;
  uint8_t buf[8];
  _QWORD v24[7];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_xpc_connection_s **)v2;
  if (*(_QWORD *)v2)
    goto LABEL_2;
  v16 = getenv("CFNETWORKAGENT_SERVICE_NAME");
  if (!v16)
    v16 = "com.apple.cfnetwork.cfnetworkagent";
  mach_service = xpc_connection_create_mach_service(v16, *(dispatch_queue_t *)(v2 + 16), 0);
  v18 = *(_xpc_connection_s **)v2;
  *(_QWORD *)v2 = mach_service;
  if (v18)
  {
    (*(void (**)(void))(v2 + 8))();
    mach_service = *(_xpc_connection_s **)v2;
  }
  *(_QWORD *)(v2 + 8) = _ZZZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EEEUb_EN3__28__invokeES7_;
  if (!mach_service)
    goto LABEL_24;
  xpc_connection_set_target_queue(mach_service, *(dispatch_queue_t *)(v2 + 16));
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 3221225472;
  v24[2] = ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke_2;
  v24[3] = &unk_1E14FB180;
  v19 = *(_QWORD *)(a1 + 40);
  v24[5] = v2;
  v24[6] = v19;
  v24[4] = mach_service;
  xpc_connection_set_event_handler(mach_service, v24);
  xpc_connection_resume(mach_service);
  v3 = *(_xpc_connection_s **)v2;
  if (*(_QWORD *)v2)
  {
LABEL_2:
    v4 = *(_QWORD *)(a1 + 40);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v5 = CFNLog::logger;
    v6 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
    if (v4 == 3)
    {
      if (v6)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "Sending CFNA PAC query", buf, 2u);
      }
      v7 = *(void **)(a1 + 48);
      v8 = *(NSObject **)(v2 + 16);
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3321888768;
      handler[2] = ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke_9;
      handler[3] = &__block_descriptor_56_e8_40c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE_e33_v16__0__NSObject_OS_xpc_object__8l;
      v10 = *(_QWORD *)(a1 + 64);
      v9 = *(std::__shared_weak_count **)(a1 + 72);
      handler[4] = v2;
      handler[5] = v10;
      v22 = v9;
      if (v9)
      {
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v12 = __ldxr(p_shared_owners);
        while (__stxr(v12 + 1, p_shared_owners));
      }
      xpc_connection_send_message_with_reply(v3, v7, v8, handler);
      v13 = v22;
      if (v22)
      {
        v14 = (unint64_t *)&v22->__shared_owners_;
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
    }
    else
    {
      if (v6)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "Sending CFNA legacy query", buf, 2u);
      }
      xpc_connection_send_message(v3, *(xpc_object_t *)(a1 + 48));
    }
  }
  else
  {
LABEL_24:
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v20 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_183ECA000, v20, OS_LOG_TYPE_ERROR, "Failed to create CFNA XPC connection", buf, 2u);
    }
  }
}

void sub_18409CBBC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_48c62_ZTSNSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEE64c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[9];
  result[8] = a2[8];
  result[9] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_48c62_ZTSNSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEE64c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 48;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void _ZZZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EEEUb_EN3__28__invokeES7_(xpc_object_t object)
{
  if (object)
    xpc_release(object);
}

uint64_t ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 40);
  result = MEMORY[0x186DB9C40](a2);
  if (result == MEMORY[0x1E0C81310])
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_QWORD *)(a1 + 48);
      if ((unint64_t)(v7 - 1) > 4)
        v8 = "Unknown";
      else
        v8 = off_1E14F6638[v7 - 1];
      v9 = 138412802;
      v10 = a2;
      v11 = 2048;
      v12 = v7;
      v13 = 2080;
      v14 = v8;
      _os_log_error_impl(&dword_183ECA000, v6, OS_LOG_TYPE_ERROR, "Received XPC error %@ for message type %lld %s", (uint8_t *)&v9, 0x20u);
    }
    xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
    result = *(_QWORD *)v4;
    *(_QWORD *)v4 = 0;
    if (result)
      return (*(uint64_t (**)(void))(v4 + 8))();
  }
  return result;
}

void ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke_9(uint64_t a1, void *a2)
{
  uint64_t v4;
  NSObject *v5;
  xpc_connection_t v8;
  int64_t int64;
  uint64_t v10;
  void (*v11)(_QWORD *, uint64_t, void *);
  uint64_t v12;
  _QWORD *v13;
  int64_t v14;
  NSObject *v15;
  int v16;
  int64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v16) = 0;
    _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "Received CFNA PAC response", (uint8_t *)&v16, 2u);
  }
  if (a2 == (void *)MEMORY[0x1E0C81288] || a2 == (void *)MEMORY[0x1E0C81260] || a2 == (void *)MEMORY[0x1E0C81258])
  {
    if (*(_QWORD *)v4)
    {
      xpc_connection_cancel(*(xpc_connection_t *)v4);
      v8 = *(xpc_connection_t *)v4;
      *(_QWORD *)v4 = 0;
      if (v8)
        (*(void (**)(void))(v4 + 8))();
    }
  }
  else
  {
    int64 = xpc_dictionary_get_int64(a2, "type");
    if (int64 == 4)
    {
      v10 = *(_QWORD *)(a1 + 40);
      if (v10)
      {
        v11 = *(void (**)(_QWORD *, uint64_t, void *))(v10 + 8);
        v12 = *(_QWORD *)(v10 + 16);
        v13 = (_QWORD *)(v10 + (v12 >> 1));
        if ((v12 & 1) != 0)
          v11 = *(void (**)(_QWORD *, uint64_t, void *))(*v13 + v11);
        v11(v13, 1, a2);
      }
    }
    else
    {
      v14 = int64;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v15 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v16 = 134217984;
        v17 = v14;
        _os_log_error_impl(&dword_183ECA000, v15, OS_LOG_TYPE_ERROR, "Received unknown CFNA result %lld", (uint8_t *)&v16, 0xCu);
      }
    }
  }
}

uint64_t __copy_helper_block_e8_40c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_initial(_QWORD *a1)
{
  a1[1] = BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*> *,SmartBlockWithArgs<BOOL,NSObject  {objcproto13OS_xpc_object}*>::Deleter,std::allocator<BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*> *,SmartBlockWithArgs<BOOL,NSObject  {objcproto13OS_xpc_object}*>::Deleter,std::allocator<BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  int v5;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if ((uint64_t (*)(_QWORD *))v3 == BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_initial
    && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      (*(void (**)(_QWORD *, _QWORD, _QWORD))(*v7
                                                       + BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_initial))(v7, 0, 0);
    else
      ((void (*)(_QWORD *, _QWORD, _QWORD))BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_initial)(v7, 0, 0);
  }
  _Block_release(*(const void **)v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_xpc_object}*,CFNA::CFNetworkAgentClient::executeLegacyQuery(__CFString const*,long long)::$_0,std::allocator<NSObject  {objcproto13OS_xpc_object}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_xpc_object}*,CFNA::CFNetworkAgentClient::executeLegacyQuery(__CFString const*,long long)::$_0,std::allocator<NSObject  {objcproto13OS_xpc_object}>>::__on_zero_shared(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    xpc_release(v1);
}

void ___ZN4CFNA20CFNetworkAgentClient10executePACENSt3__110shared_ptrIN3PAC8PACQueryEEE_block_invoke(uint64_t a1, int a2, xpc_object_t xdict)
{
  const UInt8 *data;
  unint64_t *v6;
  NSObject *v7;
  CFErrorRef v8;
  NSObject *v9;
  int64_t int64;
  const char *string;
  const __CFString *v12;
  NSObject *v13;
  _QWORD *v14;
  __CFError *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  CFErrorRef v48;
  CFIndex Code;
  std::__shared_weak_count *v50;
  CFErrorRef error;
  std::__shared_weak_count *v52;
  CFErrorRef v53;
  std::__shared_weak_count *v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  size_t length[2];
  _BYTE buf[22];
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v55 = 0;
  v56 = 0;
  v53 = 0;
  v54 = 0;
  if (a2)
  {
    length[0] = 0;
    data = (const UInt8 *)xpc_dictionary_get_data(xdict, "list", length);
    if (data)
    {
      v6 = (unint64_t *)CFDataCreate(0, data, length[0]);
      error = 0;
      *(_QWORD *)buf = CFPropertyListCreateWithData(0, (CFDataRef)v6, 0, 0, &error);
      std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>(&v55, (uint64_t *)buf);
      if (*(_QWORD *)buf)
        CFRelease(*(CFTypeRef *)buf);
      if (error)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v7 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          v48 = error;
          Code = CFErrorGetCode(error);
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)&buf[4] = v48;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = Code;
          _os_log_error_impl(&dword_183ECA000, v7, OS_LOG_TYPE_ERROR, "PAC failed to unpack proxy list from xpc reply %@ [%ld]", buf, 0x16u);
        }
        CFRelease(error);
      }
      if (v6)
      {
        CFRelease(v6);
        v6 = 0;
      }
    }
    else
    {
      int64 = xpc_dictionary_get_int64(xdict, "errCode");
      string = xpc_dictionary_get_string(xdict, "errDomain");
      if (string && (v12 = CFStringCreateWithCString(0, string, 0x8000100u)) != 0)
      {
        v8 = CFErrorCreate(0, v12, int64, 0);
        v6 = (unint64_t *)operator new();
        *v6 = (unint64_t)&off_1E14F19B0;
        v6[1] = 0;
        v6[2] = 0;
        v6[3] = (unint64_t)v8;
        v53 = v8;
        v54 = (std::__shared_weak_count *)v6;
        CFRelease(v12);
        if (v8)
          goto LABEL_27;
      }
      else
      {
        v6 = 0;
      }
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v13 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_183ECA000, v13, OS_LOG_TYPE_ERROR, "PAC failed to unpack error from xpc message", buf, 2u);
      }
    }
    v8 = 0;
  }
  else
  {
    v8 = CFErrorCreate(0, CFSTR("kCFErrorDomainCFNetwork"), 308, 0);
    v6 = (unint64_t *)operator new();
    *v6 = (unint64_t)&off_1E14F19B0;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = (unint64_t)v8;
    v53 = v8;
    v54 = (std::__shared_weak_count *)v6;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v9 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_183ECA000, v9, OS_LOG_TYPE_ERROR, "PAC result block not invoked", buf, 2u);
    }
  }
LABEL_27:
  v14 = *(_QWORD **)(a1 + 32);
  v15 = (__CFError *)v14[9];
  v16 = (std::__shared_weak_count *)v14[10];
  error = v15;
  v52 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
    v14 = *(_QWORD **)(a1 + 32);
  }
  v20 = v14[4];
  v19 = v14[5];
  v21 = v55;
  v50 = v56;
  if (v56)
  {
    v22 = (unint64_t *)&v56->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  if (v6)
  {
    v24 = v6 + 1;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
  if (v15)
  {
    *(_QWORD *)buf = v21;
    *(_QWORD *)&buf[8] = v50;
    if (v50)
    {
      v26 = (unint64_t *)&v50->__shared_owners_;
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    length[0] = (size_t)v8;
    length[1] = (size_t)v6;
    if (v6)
    {
      v28 = v6 + 1;
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }
    BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke((uint64_t)v15, v19, v20, v21, v50, (uint64_t *)length);
    if (v6)
    {
      v30 = v6 + 1;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        (*(void (**)(unint64_t *))(*v6 + 16))(v6);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v6);
      }
    }
    v32 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v33 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
  }
  if (v6)
  {
    v35 = v6 + 1;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      (*(void (**)(unint64_t *, uint64_t, uint64_t))(*v6 + 16))(v6, v19, v20);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v6);
    }
  }
  if (v50)
  {
    v37 = (unint64_t *)&v50->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *, uint64_t, uint64_t))v50->__on_zero_shared)(v50, v19, v20);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  v39 = v52;
  if (v52)
  {
    v40 = (unint64_t *)&v52->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *, uint64_t, uint64_t))v39->__on_zero_shared)(v39, v19, v20);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  v42 = v54;
  if (v54)
  {
    v43 = (unint64_t *)&v54->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *, uint64_t, uint64_t))v42->__on_zero_shared)(v42, v19, v20);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v45 = v56;
  if (v56)
  {
    v46 = (unint64_t *)&v56->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *, uint64_t, uint64_t))v45->__on_zero_shared)(v45, v19, v20);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
}

void sub_18409D63C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c41_ZTSNSt3__110shared_ptrIN3PAC8PACQueryEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c41_ZTSNSt3__110shared_ptrIN3PAC8PACQueryEEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t CFHTTPCookieStorageFlushCookieStores(void)
{
  CFDictionaryRef *v0;
  _QWORD *v1;
  const __CFAllocator *v2;
  uint64_t result;

  pthread_mutex_lock(&sLock);
  v0 = (CFDictionaryRef *)sStorageDict;
  v1 = (_QWORD *)operator new();
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *v1 = &off_1E14EA448;
  v1[1] = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
  sStorageDict = (uint64_t)v1;
  result = pthread_mutex_unlock(&sLock);
  if (v0)
  {
    CFDictionaryApplyFunction(v0[1], (CFDictionaryApplierFunction)RetainableTypedDict<__CFDictionary const*,PrivateHTTPCookieStorage *>::_visit, &__block_literal_global_9725);
    return (*((uint64_t (**)(CFDictionaryRef *))*v0 + 1))(v0);
  }
  return result;
}

void sub_18409D7D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t RetainableTypedDict<__CFDictionary const*,PrivateHTTPCookieStorage *>::_visit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t ___ZL36CFHTTPCookieStorageFlushCookieStoresv_block_invoke(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t result;
  _QWORD v6[5];

  (*(void (**)(_QWORD *))(*a3 + 40))(a3);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZL36CFHTTPCookieStorageFlushCookieStoresv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e5_v8__0l;
  v6[4] = a3;
  v4 = a3[4];
  if (v4)
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  result = (*(uint64_t (**)(_QWORD *, uint64_t, _QWORD *))(*a3 + 152))(a3, 1, v6);
  if (v4)
    return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  return result;
}

void sub_18409D8A4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL36CFHTTPCookieStorageFlushCookieStoresv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

uint64_t RetainableTypedDict<__CFDictionary const*,PrivateHTTPCookieStorage *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA448;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<__CFDictionary const*,PrivateHTTPCookieStorage *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA448;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

_QWORD *_CFHTTPCookieStorageCreateInMemory(__CFAllocator *a1, OpaqueCFHTTPCookieStorage *a2, uint64_t a3)
{
  uint8_t v5[16];

  if (a3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "filter callback no longer supported in this SPI; you should use _CookieStorageCreateInMemory instead anyway.",
      v5,
      2u);
  }
  return _CookieStorageCreateInMemory(a1, a2);
}

char *_CFHTTPCookieStorageCreateWithProperties(const __CFAllocator *a1, const __CFDictionary *a2)
{
  return _CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(a1, a2, 1);
}

void CFHTTPCookieStorageSetCookies(_QWORD *a1, const __CFArray *a2, const void *a3, const void *a4)
{
  PrivateHTTPCookieStorage *v8;
  int CookieAcceptPolicy;
  _BYTE v10[104];

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    objc_msgSend(a1, "setCookies:forURL:mainDocumentURL:", a2, a3, a4);
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    v8 = (PrivateHTTPCookieStorage *)a1[4];
    if (v8)
      CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v8);
    else
      CookieAcceptPolicy = 2;
    HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v10, a3, a4, 0, CookieAcceptPolicy, 2, 0);
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    HTTPCookieStorage::setCookiesWithPolicy((HTTPCookieStorage *)(a1 + 2), a2, (const HTTPCookieStoragePolicy *)v10);
    HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v10);
  }
}

void sub_18409DAF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void CFHTTPCookieStorageDeleteAllCookies(char *a1)
{
  char *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD block[5];

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    objc_msgSend(a1, "removeCookiesSinceDate:", objc_msgSend(MEMORY[0x1E0C99D68], "distantPast"));
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    if (a1)
      v2 = a1 + 16;
    else
      v2 = 0;
    v3 = (_QWORD *)*((_QWORD *)v2 + 2);
    v4 = v3[4];
    if (v4)
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    (*(void (**)(_QWORD *))(*v3 + 136))(v3);
    if (v4)
      pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
    HTTPCookieStorage::notifyObserversOfChanges((HTTPCookieStorage *)v2);
    os_unfair_lock_lock((os_unfair_lock_t)v2 + 30);
    if (*((_QWORD *)v2 + 10))
    {
      v5 = *((_QWORD *)v2 + 14);
      if (v5)
      {
        v6 = *((_QWORD *)v2 + 12);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___ZN17HTTPCookieStorage16deleteAllCookiesEv_block_invoke;
        block[3] = &unk_1E14FDEB0;
        block[4] = v5;
        dispatch_async(v6, block);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)v2 + 30);
  }
}

void sub_18409DC5C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

void _CFHTTPCookieStorageSetCookiesWithResponseHeaderFields(char *cf, __CFURL *a2, __CFDictionary *a3, __CFURL *a4, uint64_t a5)
{
  uint8_t v10[16];
  uint8_t buf[16];

  if (a4 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CoreMedia should be the only caller; they pass NULL here",
      buf,
      2u);
    if (!(_DWORD)a5)
      goto LABEL_6;
  }
  else if (!(_DWORD)a5)
  {
    goto LABEL_6;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v10 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CoreMedia should be the only caller; they pass kCFHTTPCookieStorageAcceptPolicyAlways here",
      v10,
      2u);
  }
LABEL_6:
  older_spi_CFHTTPCookieStorageSetCookiesWithResponseHeaderFields(cf, a2, a3, a4, a5);
}

void older_spi_CFHTTPCookieStorageSetCookiesWithResponseHeaderFields(char *cf, const __CFURL *a2, const __CFDictionary *a3, const __CFURL *a4, uint64_t a5)
{
  const __CFAllocator *v10;
  const __CFArray *v11;
  const __CFArray *v12;
  const __CFAllocator *v13;
  const __CFArray *v14;
  _BYTE v15[104];
  const __CFString *v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    v10 = CFGetAllocator(cf);
    v11 = CFHTTPCookieCreateWithResponseHeaderFields(v10, a3, a2);
    if (!v11)
      return;
    v12 = v11;
    if (CFArrayGetCount(v11) >= 1)
    {
      v16 = CFSTR("HTTPCookiePolicyPropertyCookieAcceptPolicy");
      v17[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a5);
      objc_msgSend(cf, "_setCookies:forURL:mainDocumentURL:policyProperties:", v12, a2, a4, objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v17, &v16, 1));
    }
    goto LABEL_14;
  }
  if (cf)
  {
    if (a2)
    {
      v13 = CFGetAllocator(cf);
      v14 = CFHTTPCookieCreateWithResponseHeaderFields(v13, a3, a2);
      if (v14)
      {
        v12 = v14;
        if (CFArrayGetCount(v14) >= 1)
        {
          HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v15, a2, a4, 0, a5, 1, 0);
          if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
            dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
          HTTPCookieStorage::setCookiesWithPolicy((HTTPCookieStorage *)(cf + 16), v12, (const HTTPCookieStoragePolicy *)v15);
          HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v15);
        }
LABEL_14:
        CFRelease(v12);
      }
    }
  }
}

void sub_18409DF1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)&a9);
  _Unwind_Resume(a1);
}

void CFHTTPCookieStorageAddObserver()
{
  CFLog();
  __break(1u);
}

CFMutableDictionaryRef _initObserverLock(void)
{
  _DWORD *v0;
  _QWORD *v1;
  const __CFAllocator *v2;
  CFMutableDictionaryRef result;

  v0 = (_DWORD *)operator new();
  *v0 = 0;
  gObserverLock = (uint64_t)v0;
  v1 = (_QWORD *)operator new();
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *v1 = &off_1E14EA588;
  result = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v1[1] = result;
  gObserverDict = (uint64_t)v1;
  return result;
}

void sub_18409DFF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_9756(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

CFTypeRef *SourceContext::retain(CFTypeRef *this, const void *a2)
{
  CFRetain(*this);
  this[3] = (char *)this[3] + 1;
  return this;
}

void SourceContext::release(CFTypeRef *this, const void *a2)
{
  uint64_t v3;

  CFRelease(*this);
  v3 = (uint64_t)this[3] - 1;
  this[3] = (CFTypeRef)v3;
  if (!v3)
  {
    CFRelease(*this);
    JUMPOUT(0x186DB748CLL);
  }
}

CFStringRef SourceContext::copyDescription(SourceContext *this, const void *a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("SourceContext{ %@ callback %p(%p) }"), *(_QWORD *)this, *((_QWORD *)this + 1), *((_QWORD *)this + 2));
}

uint64_t SourceContext::perform(SourceContext *this, void *a2)
{
  return (*((uint64_t (**)(_QWORD, _QWORD))this + 1))(*(_QWORD *)this, *((_QWORD *)this + 2));
}

uint64_t RetainableTypedDict<__CFArray const*,__CFRunLoopSource *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA588;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<__CFArray const*,__CFRunLoopSource *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA588;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void CFHTTPCookieStorageRemoveObserver()
{
  CFLog();
  __break(1u);
}

CFMutableArrayRef _CFHTTPCookieStorageCopyCookiesForURLWithMainDocumentURL(_QWORD *a1, const void *a2, const void *a3, const __CFURL *a4)
{
  NSObject *v8;
  CFMutableArrayRef v9;
  PrivateHTTPCookieStorage *v10;
  int CookieAcceptPolicy;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  void (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  uint64_t v18;
  _QWORD v19[6];

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    v13 = 0;
    v14 = &v13;
    v15 = 0x3052000000;
    v16 = __Block_byref_object_copy__9761;
    v17 = __Block_byref_object_dispose__9762;
    v18 = 0;
    v8 = dispatch_semaphore_create(0);
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 3221225472;
    v19[2] = ___CFHTTPCookieStorageCopyCookiesForURLWithMainDocumentURL_block_invoke;
    v19[3] = &unk_1E14FB1A8;
    v19[4] = v8;
    v19[5] = &v13;
    objc_msgSend(a1, "_getCookiesForURL:mainDocumentURL:partition:completionHandler:", a2, a3, 0, v19);
    dispatch_semaphore_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
    v9 = (CFMutableArrayRef)v14[5];
    _Block_object_dispose(&v13, 8);
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    v10 = (PrivateHTTPCookieStorage *)a1[4];
    if (v10)
      CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v10);
    else
      CookieAcceptPolicy = 2;
    HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)&v13, a2, a3, 0, CookieAcceptPolicy, 0, 0);
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    v9 = HTTPCookieStorage::copyCookiesForURLWithMainDocumentURL((HTTPCookieStorage *)(a1 + 2), (const HTTPCookieStoragePolicy *)&v13, a4);
    HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)&v13);
  }
  return v9;
}

void sub_18409E368(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__9761(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__9762(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

const __CFArray *_CFHTTPCookieStorageCopyRequestHeaderFieldsForURL(const __CFAllocator *a1, _QWORD *a2, CFURLRef anURL)
{
  const __CFString *v6;
  const __CFString *v7;
  unsigned int v8;
  const __CFArray *result;
  const __CFArray *v10;
  CFDictionaryRef v11;

  v6 = CFURLCopyScheme(anURL);
  if (v6)
  {
    v7 = v6;
    v8 = 1;
    if (CFStringCompare(v6, (CFStringRef)&unk_1EDD00AE0, 1uLL))
      v8 = CFStringCompare(v7, CFSTR("wss"), 1uLL) == kCFCompareEqualTo;
    CFRelease(v7);
  }
  else
  {
    v8 = 0;
  }
  result = CFHTTPCookieStorageCopyCookiesForURL(a2, anURL, v8);
  if (result)
  {
    v10 = result;
    v11 = CFHTTPCookieCopyRequestHeaderFields(a1, result);
    CFRelease(v10);
    return v11;
  }
  return result;
}

void CFHTTPCookieStorageDeleteCookie(char *a1, OpaqueCFHTTPCookie *a2)
{
  uint64_t v4;
  CompactCookieHeader *v5;
  const char *EnumeratedString;
  const UInt8 *v7;
  const __CFAllocator *v8;
  size_t v9;
  CFStringRef v10;
  HTTPCookieStorage *v11;
  HTTPCookieStorage *v12;
  _BYTE v13[104];

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    objc_msgSend(a1, "deleteCookie:", a2);
  }
  else
  {
    v4 = -[OpaqueCFHTTPCookie _inner](a2, "_inner");
    v5 = (CompactCookieHeader *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
    EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString(v5, 15, 0);
    if (EnumeratedString)
    {
      v7 = (const UInt8 *)EnumeratedString;
      v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v9 = strnlen(EnumeratedString, 0x400uLL);
      v10 = CFStringCreateWithBytes(v8, v7, v9, 0x8000100u, 0);
      HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v13, 0, 0, (uint64_t)v10, 0, 2, 0);
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
      if (a1)
        v11 = (HTTPCookieStorage *)(a1 + 16);
      else
        v11 = 0;
      HTTPCookieStorage::deleteCookie(v11, a2, (const HTTPCookieStoragePolicy *)v13);
      CFRelease(v10);
    }
    else
    {
      HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v13, 0, 0, 0, 0, 2, 0);
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
      if (a1)
        v12 = (HTTPCookieStorage *)(a1 + 16);
      else
        v12 = 0;
      HTTPCookieStorage::deleteCookie(v12, a2, (const HTTPCookieStoragePolicy *)v13);
    }
    HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v13);
  }
}

void sub_18409E650(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void CFHTTPCookieStorageUnscheduleFromRunLoop(uint64_t a1, CFRunLoopRef rl, CFRunLoopMode mode)
{
  NSObject *v6;
  uint64_t v7;
  __CFRunLoopTimer *v8;
  uint64_t v9;
  const void *v10;
  uint8_t v11[16];

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v11 = 0;
      _os_log_error_impl(&dword_183ECA000, v6, OS_LOG_TYPE_ERROR, "CFHTTPCookieStorageUnscheduleFromRunLoop should no longer be called", v11, 2u);
    }
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    if (a1)
      v7 = a1 + 16;
    else
      v7 = 0;
    v8 = *(__CFRunLoopTimer **)(v7 + 32);
    if (v8)
    {
      CFRunLoopRemoveTimer(rl, v8, mode);
      v9 = *(_QWORD *)(v7 + 40) - 1;
      *(_QWORD *)(v7 + 40) = v9;
      if (!v9)
      {
        CFRunLoopTimerInvalidate(*(CFRunLoopTimerRef *)(v7 + 32));
        v10 = *(const void **)(v7 + 32);
        *(_QWORD *)(v7 + 32) = 0;
        if (v10)
          CFRelease(v10);
      }
    }
  }
}

CFStringRef HTTPCookieStorage::copyDebugDesc(HTTPCookieStorage *this)
{
  const void *v2;
  CFStringRef v3;
  const __CFAllocator *v4;
  CFStringRef v5;

  v2 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 16))(*((_QWORD *)this + 2));
  v3 = CFObject::copyDebugDescHeader(this);
  v4 = CFGetAllocator((char *)this - 16);
  v5 = CFStringCreateWithFormat(v4, 0, CFSTR("%@ { %@ }"), v3, v2);
  if (v3)
    CFRelease(v3);
  if (v2)
    CFRelease(v2);
  return v5;
}

void `non-virtual thunk to'HTTPCookieStorage::~HTTPCookieStorage(HTTPCookieStorage *this)
{
  HTTPCookieStorage::~HTTPCookieStorage((HTTPCookieStorage *)((char *)this - 8));
}

{
  HTTPCookieStorage::~HTTPCookieStorage((HTTPCookieStorage *)((char *)this - 8));
}

void logCookie(uint64_t a1, int a2, unsigned int *a3)
{
  const __CFAllocator **v6;
  double v7;
  CFDateRef v8;
  CFDateRef v9;
  const __CFAllocator *v10;
  double v11;
  double v12;
  CFTypeRef v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  const __CFString *v19;
  __CFDictionary *MutableDict;
  char *EnumeratedString;
  const __CFString *v22;
  __CFDictionary *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  const __CFString *v29;
  __CFDictionary *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  const __CFString *v36;
  __CFDictionary *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  const __CFString *v43;
  __CFDictionary *v44;
  const __CFString *v45;
  __CFDictionary *v46;
  const __CFString *v47;
  __CFDictionary *v48;
  const __CFString *v49;
  __CFDictionary *v50;
  __CFDictionary *v51;
  __CFDictionary *v52;
  AutoDict *v53;
  _QWORD v54[2];
  uint64_t v55;
  uint64_t v56;
  char __str[8];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v6 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
  if (*a3 >= 0xC && (a3[2] & 2) != 0)
  {
    v8 = 0;
  }
  else
  {
    v7 = 0.0;
    if (*a3 >= 0x30)
    {
      *(_QWORD *)__str = *((_QWORD *)a3 + 5);
      v7 = floor(*(double *)__str);
    }
    v8 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7);
  }
  if (*a3 > 0x37)
  {
    v11 = *((double *)a3 + 6);
    *(double *)__str = v11;
    v10 = *v6;
    if (floor(v11) == 0.0)
    {
      v9 = 0;
    }
    else
    {
      v12 = 0.0;
      if (*a3 >= 0x38)
      {
        *(double *)__str = v11;
        v12 = floor(v11);
      }
      v9 = CFDateCreate(v10, v12);
    }
  }
  else
  {
    v9 = 0;
    v10 = *v6;
  }
  v54[0] = &off_1E14EFC70;
  if (v10)
    v13 = CFRetain(v10);
  else
    v13 = 0;
  v14 = 0;
  v55 = 0;
  v56 = 0;
  v54[1] = v13;
  if (*a3 >= 0x14)
  {
    v15 = a3[4];
    if ((_DWORD)v15 && (v16 = *a3, v16 > v15))
    {
      v14 = (char *)a3 + v15;
      v17 = (char *)a3 + v16;
      v18 = v14;
      while (*v18)
      {
        if (++v18 >= v17)
          goto LABEL_23;
      }
    }
    else
    {
LABEL_23:
      v14 = 0;
    }
  }
  v19 = autoString(v14);
  MutableDict = AutoDict::getMutableDict((AutoDict *)v54);
  if (v19)
    CFDictionarySetValue(MutableDict, CFSTR("Domain"), v19);
  else
    CFDictionaryRemoveValue(MutableDict, CFSTR("Domain"));
  EnumeratedString = (char *)CompactCookieHeader::getEnumeratedString((CompactCookieHeader *)a3, 15, 0);
  v22 = autoString(EnumeratedString);
  v23 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v22)
    CFDictionarySetValue(v23, CFSTR("Partition"), v22);
  else
    CFDictionaryRemoveValue(v23, CFSTR("Partition"));
  if (*a3 >= 0x18 && (v24 = a3[5], (_DWORD)v24) && (v25 = *a3, v25 > v24))
  {
    v26 = (char *)a3 + v24;
    v27 = (char *)a3 + v25;
    v28 = v26;
    while (*v28)
    {
      if (++v28 >= v27)
        goto LABEL_36;
    }
  }
  else
  {
LABEL_36:
    v26 = 0;
  }
  v29 = autoString(v26);
  v30 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v29)
    CFDictionarySetValue(v30, CFSTR("Name"), v29);
  else
    CFDictionaryRemoveValue(v30, CFSTR("Name"));
  if (*a3 >= 0x1C && (v31 = a3[6], (_DWORD)v31) && (v32 = *a3, v32 > v31))
  {
    v33 = (char *)a3 + v31;
    v34 = (char *)a3 + v32;
    v35 = v33;
    while (*v35)
    {
      if (++v35 >= v34)
        goto LABEL_46;
    }
  }
  else
  {
LABEL_46:
    v33 = 0;
  }
  v36 = autoString(v33);
  v37 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v36)
    CFDictionarySetValue(v37, CFSTR("Path"), v36);
  else
    CFDictionaryRemoveValue(v37, CFSTR("Path"));
  if (__CFNCanLogSensitiveContent::onceToken != -1)
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
  if (__CFNCanLogSensitiveContent::ok)
  {
    if (*a3 >= 0x20 && (v38 = a3[7], (_DWORD)v38) && (v39 = *a3, v39 > v38))
    {
      v40 = (char *)a3 + v38;
      v41 = (char *)a3 + v39;
      v42 = v40;
      while (*v42)
      {
        if (++v42 >= v41)
          goto LABEL_59;
      }
    }
    else
    {
LABEL_59:
      v40 = 0;
    }
    v43 = autoString(v40);
  }
  else
  {
    v43 = CFSTR("<redacted>");
  }
  v44 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v43)
    CFDictionarySetValue(v44, CFSTR("Value"), v43);
  else
    CFDictionaryRemoveValue(v44, CFSTR("Value"));
  if (*a3 >= 0xC && (a3[2] & 2) != 0)
    v45 = CFSTR("YES");
  else
    v45 = CFSTR("NO");
  v46 = AutoDict::getMutableDict((AutoDict *)v54);
  CFDictionarySetValue(v46, CFSTR("Session"), v45);
  if (*a3 >= 0xC && (a3[2] & 1) != 0)
    v47 = CFSTR("YES");
  else
    v47 = CFSTR("NO");
  v48 = AutoDict::getMutableDict((AutoDict *)v54);
  CFDictionarySetValue(v48, CFSTR("Secure"), v47);
  if (*a3 >= 0xC && (a3[2] & 4) != 0)
    v49 = CFSTR("YES");
  else
    v49 = CFSTR("NO");
  v50 = AutoDict::getMutableDict((AutoDict *)v54);
  CFDictionarySetValue(v50, CFSTR("HTTPOnly"), v49);
  v51 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v8)
    CFDictionarySetValue(v51, CFSTR("Expires"), v8);
  else
    CFDictionaryRemoveValue(v51, CFSTR("Expires"));
  v52 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v9)
    CFDictionarySetValue(v52, CFSTR("Created"), v9);
  else
    CFDictionaryRemoveValue(v52, CFSTR("Created"));
  if (v8)
    CFRelease(v8);
  if (v9)
    CFRelease(v9);
  v53 = (AutoDict *)snprintf(__str, 0x100uLL, "Cookie_%d_%p", a2, a3);
  if (!v56 && !v55)
    AutoDict::getEmptyDict(v53);
  (*(void (**)(uint64_t, char *))(*(_QWORD *)a1 + 96))(a1, __str);
  AutoDict::~AutoDict((AutoDict *)v54);
}

void sub_18409ED90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  AutoDict::~AutoDict((AutoDict *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN17HTTPCookieStorage9setCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicyPK9__CFArrayh_block_invoke_10(_QWORD *a1)
{
  void *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v2 = (void *)a1[4];
  result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v9, v14, 16);
  if (result)
  {
    v4 = result;
    v5 = *(_QWORD *)v10;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v10 != v5)
          objc_enumerationMutation(v2);
        v7 = *(_QWORD *)(*((_QWORD *)&v9 + 1) + 8 * v6);
        v8 = a1[6];
        v13 = a1[5];
        (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 16))(v8, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v13, 1), v7);
        ++v6;
      }
      while (v4 != v6);
      result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v9, v14, 16);
      v4 = result;
    }
    while (result);
  }
  return result;
}

void _signalObservers(__CFRunLoopSource *a1, __CFSet *a2)
{
  if (CFRunLoopSourceIsValid(a1))
    CFRunLoopSourceSignal(a1);
  else
    CFSetRemoveValue(a2, a1);
}

uint64_t HTTPCookieStorage::_syncTimerFired(HTTPCookieStorage *this, char *cf, void *a3)
{
  char *v4;
  _QWORD v6[5];

  if (cf)
    CFRetain(cf);
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
  if (cf)
    v4 = cf + 16;
  else
    v4 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN17HTTPCookieStorage15_syncTimerFiredEP16__CFRunLoopTimerPv_block_invoke;
  v6[3] = &__block_descriptor_40_e5_v8__0l;
  v6[4] = cf;
  return HTTPCookieStorage::syncStorageWithCompletion((uint64_t)v4, 0, (uint64_t)v6);
}

void ___ZN17HTTPCookieStorage15_syncTimerFiredEP16__CFRunLoopTimerPv_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void logCookieArray(uint64_t a1, uint64_t a2)
{
  const __CFData *v2;
  const UInt8 *BytePtr;
  unint64_t v5;
  uint64_t v6;
  const __CFData *v7;
  const UInt8 *v8;
  const UInt8 *v9;
  uint64_t v10;
  const UInt8 *v11;
  _QWORD v12[2];
  void (*v13)(uint64_t, unsigned int *);
  void *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD v17[4];
  char v18;

  v17[0] = 0;
  v17[1] = v17;
  v17[2] = 0x2020000000;
  v17[3] = 0;
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v13 = ___ZL14logCookieArrayP17DiagnosticLoggingPK18CompactCookieArray_block_invoke;
  v14 = &unk_1E14FB2D0;
  v15 = v17;
  v16 = a1;
  v2 = *(const __CFData **)(a2 + 16);
  if (v2)
  {
    BytePtr = CFDataGetBytePtr(v2);
    if (BytePtr)
    {
      v5 = *((unsigned int *)BytePtr + 1);
      v18 = 0;
      if ((_DWORD)v5)
      {
        v6 = 2;
        do
        {
          v7 = *(const __CFData **)(a2 + 16);
          if (v7 && CFDataGetBytePtr(v7))
          {
            v8 = CFDataGetBytePtr(*(CFDataRef *)(a2 + 16));
            v9 = *(const UInt8 **)(a2 + 16);
            v10 = *(unsigned int *)&v8[4 * v6];
            if (v9)
              v9 = CFDataGetBytePtr((CFDataRef)v9);
            v11 = &v9[v10];
          }
          else
          {
            v11 = 0;
          }
          ((void (*)(_QWORD *, const UInt8 *, char *))v13)(v12, v11, &v18);
          if (v6 - 1 >= v5)
            break;
          ++v6;
        }
        while (!v18);
      }
    }
  }
  _Block_object_dispose(v17, 8);
}

void sub_18409F0B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZL14logCookieArrayP17DiagnosticLoggingPK18CompactCookieArray_block_invoke(uint64_t a1, unsigned int *a2)
{
  logCookie(*(_QWORD *)(a1 + 40), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2);
  ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t ___ZN17HTTPCookieStorage17copyCookiesForURLERK23HTTPCookieStoragePolicyh_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1159;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

const __CFString *autoString(char *cStr)
{
  CFStringRef v1;

  if (!cStr)
    return CFSTR("NULL");
  v1 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
  return (const __CFString *)CFAutorelease(v1);
}

uint64_t ___ZN17HTTPCookieStorage9setCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicyPK9__CFArrayh_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 236;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

BOOL HTTPCookieStorage::isURLInMainDocumentDomain(HTTPCookieStorage *this, const __CFURL *a2, const __CFURL *a3)
{
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  __CFString *v7;
  __CFString *v8;
  CFIndex location;
  CFIndex Length;
  CFRange v11;
  CFIndex v12;
  CFIndex v13;
  CFIndex v14;
  CFIndex v15;
  const __CFString *v16;
  int v17;
  CFIndex v18;
  _BOOL8 v19;
  const __CFURL *v21;
  const __CFString *v22;
  const __CFString *v23;
  const __CFAllocator *alloc;
  CFRange result;
  CFRange v26;
  CFRange v27;
  CFRange v28;

  v4 = CFURLCopyHostName(this);
  v5 = CFURLCopyHostName(a2);
  if (!((unint64_t)v4 | (unint64_t)v5))
  {
    v4 = (const __CFString *)CFRetain(CFSTR(".^filecookies^"));
    v5 = (const __CFString *)CFRetain(CFSTR(".^filecookies^"));
  }
  v6 = v5;
  if (v4 && v5)
  {
    v7 = copyStringAndLowerCase(v4);
    v8 = copyStringAndLowerCase(v6);
    if (CFStringCompare(v7, v8, 0) == kCFCompareEqualTo)
    {
      v19 = 1;
      if (!v7)
        goto LABEL_31;
      goto LABEL_30;
    }
    v21 = a2;
    alloc = CFGetAllocator(v7);
    CFStringFind(v7, CFSTR("."), 8uLL);
    CFStringFind(v8, CFSTR("."), 8uLL);
    location = CFStringFind(v7, CFSTR("."), 4uLL).location;
    if (location == -1 || (Length = location, location != CFStringGetLength(v7) - 1))
      Length = CFStringGetLength(v7);
    v22 = v6;
    v23 = v4;
    v11 = CFStringFind(v8, CFSTR("."), 4uLL);
    result = v11;
    if (v11.location == -1 || (v12 = v11.location, v11.location != CFStringGetLength(v8) - 1))
      v12 = CFStringGetLength(v8);
    if (Length < 1)
    {
LABEL_23:
      v6 = v22;
      v4 = v23;
    }
    else
    {
      v13 = 0;
      v14 = Length;
      while (1)
      {
        v15 = v12 >= v14 ? v14 : v12;
        v26.location = v13;
        v26.length = v14;
        v16 = CFStringCreateWithSubstring(alloc, v7, v26);
        v27.location = (v12 - v14) & ~((v12 - v14) >> 63);
        v27.length = v15;
        if (CFStringCompareWithOptions(v8, v16, v27, 1uLL) == kCFCompareEqualTo)
          break;
        v28.location = v13;
        v28.length = v14;
        v17 = CFStringFindWithOptions(v7, CFSTR("."), v28, 0, &result);
        v18 = result.location;
        CFRelease(v16);
        if (v17)
          v13 = v18 + 1;
        else
          v13 = -1;
        if (v17)
        {
          v14 = Length + ~v18;
          if (v14 > 0)
            continue;
        }
        goto LABEL_23;
      }
      v6 = v22;
      v4 = v23;
      if (v16)
      {
        v19 = !isTopLevelDomain(v16, 1);
        CFRelease(v16);
        if (!v7)
        {
LABEL_31:
          if (v8)
            CFRelease(v8);
          goto LABEL_33;
        }
LABEL_30:
        CFRelease(v7);
        goto LABEL_31;
      }
    }
    v19 = v21 == 0;
    if (!v7)
      goto LABEL_31;
    goto LABEL_30;
  }
  v19 = 0;
  if (!v5)
  {
    v19 = 0;
    if (!v4)
      return v19;
    goto LABEL_34;
  }
LABEL_33:
  CFRelease(v6);
  if (v4)
LABEL_34:
    CFRelease(v4);
  return v19;
}

void ___ZN17HTTPCookieStorage20setCookiesWithPolicyEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZL36shouldAllowCookieBasedOnCookiePrefixPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicy_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

uint64_t addCookieToSubscriberDictionaryForDomain(NSHTTPCookie *a1, NSMutableDictionary *a2, NSString *a3)
{
  void *v6;
  void *v8;

  v6 = (void *)-[NSMutableDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:");
  if (v6)
    return objc_msgSend(v6, "addObject:", a1);
  v8 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  objc_msgSend(v8, "addObject:", a1);
  return -[NSMutableDictionary setObject:forKeyedSubscript:](a2, "setObject:forKeyedSubscript:", v8, a3);
}

uint64_t ___ZN17HTTPCookieStorage20setCookiesWithPolicyEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke_3(uint64_t a1)
{
  void *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _BYTE v11[128];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v2 = *(void **)(a1 + 32);
  result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v7, v11, 16);
  if (result)
  {
    v4 = result;
    v5 = *(_QWORD *)v8;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v8 != v5)
          objc_enumerationMutation(v2);
        objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v7 + 1) + 8 * v6));
        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
        ++v6;
      }
      while (v4 != v6);
      result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v7, v11, 16);
      v4 = result;
    }
    while (result);
  }
  return result;
}

__CFString *copyStringAndLowerCase(const __CFString *a1)
{
  const __CFAllocator *v2;
  __CFString *MutableCopy;
  const __CFLocale *System;

  v2 = CFGetAllocator(a1);
  MutableCopy = CFStringCreateMutableCopy(v2, 0, a1);
  System = CFLocaleGetSystem();
  CFStringLowercase(MutableCopy, System);
  return MutableCopy;
}

uint64_t ___ZN17HTTPCookieStorage20setCookiesWithPolicyEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 303;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN17HTTPCookieStorage16deleteAllCookiesEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN17HTTPCookieStorage22deleteCookiesSinceDateEPK8__CFDate_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v3;
  os_unfair_lock_s *v4;
  NSMutableDictionary *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  NSHTTPCookie *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t j;
  uint64_t v16;
  NSObject *v17;
  id obj;
  _QWORD block[6];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[128];
  _BYTE v29[128];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 32);
  v4 = (os_unfair_lock_s *)(v3 + 120);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 120));
  if (*(_QWORD *)(v3 + 112))
  {
    v5 = (NSMutableDictionary *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v6 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v24, v29, 16);
    if (v6)
    {
      v7 = v6;
      v8 = *(_QWORD *)v25;
      obj = a2;
      do
      {
        for (i = 0; i != v7; ++i)
        {
          if (*(_QWORD *)v25 != v8)
            objc_enumerationMutation(obj);
          v10 = *(NSHTTPCookie **)(*((_QWORD *)&v24 + 1) + 8 * i);
          v11 = (void *)objc_msgSend(*(id *)(v3 + 80), "objectForKeyedSubscript:", -[NSHTTPCookie domain](v10, "domain"));
          v20 = 0u;
          v21 = 0u;
          v22 = 0u;
          v23 = 0u;
          v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v20, v28, 16);
          if (v12)
          {
            v13 = v12;
            v14 = *(_QWORD *)v21;
            do
            {
              for (j = 0; j != v13; ++j)
              {
                if (*(_QWORD *)v21 != v14)
                  objc_enumerationMutation(v11);
                addCookieToSubscriberDictionaryForDomain(v10, v5, *(NSString **)(*((_QWORD *)&v20 + 1) + 8 * j));
              }
              v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v20, v28, 16);
            }
            while (v13);
          }
        }
        v7 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v24, v29, 16);
      }
      while (v7);
    }
    v4 = (os_unfair_lock_s *)(v3 + 120);
    if (-[NSMutableDictionary count](v5, "count"))
    {
      v16 = *(_QWORD *)(v3 + 112);
      v17 = *(NSObject **)(v3 + 96);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZN17HTTPCookieStorage22deleteCookiesSinceDateEPK8__CFDate_block_invoke_2;
      block[3] = &unk_1E14FDF00;
      block[4] = v5;
      block[5] = v16;
      dispatch_async(v17, block);
    }
  }
  os_unfair_lock_unlock(v4);
}

uint64_t ___ZN17HTTPCookieStorage22deleteCookiesSinceDateEPK8__CFDate_block_invoke_2(uint64_t a1)
{
  void *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _BYTE v11[128];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v2 = *(void **)(a1 + 32);
  result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v7, v11, 16);
  if (result)
  {
    v4 = result;
    v5 = *(_QWORD *)v8;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v8 != v5)
          objc_enumerationMutation(v2);
        objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v7 + 1) + 8 * v6));
        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
        ++v6;
      }
      while (v4 != v6);
      result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v7, v11, 16);
      v4 = result;
    }
    while (result);
  }
  return result;
}

uint64_t _cmp_cookie(void *a1, void *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  CompactCookieHeader *v7;
  uint64_t v8;
  uint64_t v9;
  CompactCookieHeader *v10;
  int **v11;
  int **v12;
  unsigned __int8 *v13;
  int v14;
  int *v15;
  int *v16;
  int v17;
  int v18;
  BOOL EnumeratedTime;
  double v20;
  double v21;
  _BOOL4 v22;
  double v23;
  int EnumeratedBoolean;
  int v25;
  BOOL v26;
  int v27;
  BOOL v28;
  const char *EnumeratedString;
  const char *v30;
  unsigned int v31;
  BOOL v32;
  BOOL v33;
  int v34;
  unsigned int v35;
  unint64_t v36;
  unsigned int v37;
  unint64_t v38;
  unsigned __int16 *v39;
  uint64_t v40;
  int v42;
  unsigned __int16 *v43;
  uint64_t v44;
  int v46;
  BOOL v47;
  _BOOL4 v48;
  int v49;
  int v50;
  uint64_t v51;
  _QWORD *v53;

  v5 = objc_msgSend(a1, "_inner");
  v6 = objc_msgSend(a2, "_inner");
  v7 = (CompactCookieHeader *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  v53 = a3;
  if (v7 == (CompactCookieHeader *)v8 || (v9 = a3[101], v9 < 1))
  {
    v49 = 0;
  }
  else
  {
    v10 = (CompactCookieHeader *)v8;
    v11 = (int **)(a3 + 102);
    v12 = (int **)&a3[v9 + 102];
    v13 = (unsigned __int8 *)(a3 + 121);
    do
    {
      v14 = 0;
      v16 = *v11++;
      v15 = v16;
      LODWORD(v16) = *v13++;
      v17 = (int)v16;
      v18 = v15[3];
      switch(v18)
      {
        case 1:
          EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString(v7, *v15, 0);
          v30 = (const char *)CompactCookieHeader::getEnumeratedString(v10, *v15, 0);
          if (!((unint64_t)EnumeratedString | (unint64_t)v30))
            goto LABEL_23;
          if (EnumeratedString)
            v32 = 1;
          else
            v32 = v30 == 0;
          if (v32)
          {
            if (EnumeratedString)
              v33 = v30 == 0;
            else
              v33 = 0;
            if (v33)
              goto LABEL_7;
            v34 = strcasecmp(EnumeratedString, v30);
            if (v34 < 0)
              v14 = -1;
            else
              v14 = v34 != 0;
          }
          else
          {
            v14 = 1;
          }
          break;
        case 2:
        case 4:
          EnumeratedTime = CompactCookieHeader::getEnumeratedTime(v7, *v15);
          v21 = v20;
          v22 = EnumeratedTime;
          if (EnumeratedTime == CompactCookieHeader::getEnumeratedTime(v10, *v15))
          {
            if (v21 >= v23)
              v14 = v21 > v23;
            else
LABEL_7:
              v14 = -1;
          }
          else if (v22)
          {
            v14 = -1;
          }
          else
          {
            v14 = 1;
          }
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          break;
        case 8:
          if (*(_DWORD *)v7 >= 0x10u)
            v31 = *((_DWORD *)v7 + 3);
          else
            v31 = 0;
          if (*(_DWORD *)v10 >= 0x10u)
            v35 = *((_DWORD *)v10 + 3);
          else
            v35 = 0;
          if (v31 >= v35)
            v36 = v35;
          else
            v36 = v31;
          if (!(_DWORD)v36)
            goto LABEL_66;
          v37 = 56;
          v38 = 1;
          do
          {
            v39 = (unsigned __int16 *)((char *)v7 + v37);
            v40 = *(_DWORD *)v7;
            if (v40 <= v37 || v39 + 1 > (unsigned __int16 *)((char *)v7 + v40))
              v42 = 0;
            else
              v42 = *v39;
            v43 = (unsigned __int16 *)((char *)v10 + v37);
            v44 = *(_DWORD *)v10;
            if (v44 <= v37 || v43 + 1 > (unsigned __int16 *)((char *)v10 + v44))
              v46 = 0;
            else
              v46 = *v43;
            v14 = v42 - v46;
            if (v38 >= v36)
              break;
            ++v38;
            v37 += 2;
          }
          while (!v14);
          if (!v14)
          {
LABEL_66:
            v47 = v31 >= v35;
            v48 = v31 != v35;
            if (v47)
              v14 = v48;
            else
              v14 = -1;
          }
          break;
        default:
          if (v18 == 16)
          {
            EnumeratedBoolean = CompactCookieHeader::getEnumeratedBoolean(v7, *v15);
            v25 = CompactCookieHeader::getEnumeratedBoolean(v10, *v15);
            if (EnumeratedBoolean == v25)
            {
LABEL_23:
              v14 = 0;
            }
            else
            {
              if (EnumeratedBoolean)
                v26 = 1;
              else
                v26 = v25 == 0;
              v27 = !v26;
              if (EnumeratedBoolean)
                v28 = v25 == 0;
              else
                v28 = 0;
              if (v28)
                v14 = -1;
              else
                v14 = v27;
            }
          }
          break;
      }
      if (v17)
        v49 = v14;
      else
        v49 = -v14;
    }
    while (v11 < v12 && !v49);
  }
  if ((v53[100] & 0x20) != 0)
    v50 = -v49;
  else
    v50 = v49;
  if (v49)
    v51 = -1;
  else
    v51 = 0;
  if (v50 < 0)
    return 1;
  else
    return v51;
}

void ___ZN17HTTPCookieStorage20copyCookiesForDomainEPK10__CFString_block_invoke_3(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    CFRelease((CFTypeRef)(v1 - 16));
}

void HTTPCookieStorage::deleteCookie(HTTPCookieStorage *this, OpaqueCFHTTPCookie *a2, const HTTPCookieStoragePolicy *a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  _QWORD block[7];

  v6 = (_QWORD *)*((_QWORD *)this + 2);
  v7 = -[OpaqueCFHTTPCookie _inner](a2, "_inner");
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
  v9 = v6[4];
  if (v9)
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  (*(void (**)(_QWORD *, uint64_t, const HTTPCookieStoragePolicy *))(*v6 + 128))(v6, v8, a3);
  if (v9)
    pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
  HTTPCookieStorage::notifyObserversOfChanges(this);
  os_unfair_lock_lock((os_unfair_lock_t)this + 30);
  if (*((_QWORD *)this + 14))
  {
    v10 = (void *)objc_msgSend(*((id *)this + 10), "objectForKeyedSubscript:", -[OpaqueCFHTTPCookie domain](a2, "domain"));
    if (objc_msgSend(v10, "count"))
    {
      v11 = *((_QWORD *)this + 14);
      v12 = *((_QWORD *)this + 12);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZN17HTTPCookieStorage12deleteCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicy_block_invoke;
      block[3] = &unk_1E14FE070;
      block[5] = a2;
      block[6] = v11;
      block[4] = v10;
      dispatch_async(v12, block);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 30);
}

void sub_18409FE50(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN17HTTPCookieStorage12deleteCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicy_block_invoke(_QWORD *a1)
{
  void *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v2 = (void *)a1[4];
  result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v9, v14, 16);
  if (result)
  {
    v4 = result;
    v5 = *(_QWORD *)v10;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v10 != v5)
          objc_enumerationMutation(v2);
        v7 = *(_QWORD *)(*((_QWORD *)&v9 + 1) + 8 * v6);
        v8 = a1[6];
        v13 = a1[5];
        (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(v8 + 16))(v8, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v13, 1), v7, 0);
        ++v6;
      }
      while (v4 != v6);
      result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v9, v14, 16);
      v4 = result;
    }
    while (result);
  }
  return result;
}

uint64_t PrivateHTTPCookieStorage::copyDebugDesc(PrivateHTTPCookieStorage *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 4);
  if (v2)
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  v3 = (*(uint64_t (**)(PrivateHTTPCookieStorage *))(*(_QWORD *)this + 88))(this);
  if (v2)
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 8));
  return v3;
}

void sub_18409FFE4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

BOOL PrivateHTTPCookieStorage::equals(PrivateHTTPCookieStorage *this, const CFAllocatedReferenceCountedObject *a2)
{
  return a2 == this;
}

uint64_t PrivateHTTPCookieStorage::invalidateLocked(uint64_t this)
{
  *(_BYTE *)(this + 40) = 0;
  return this;
}

void PrivateHTTPCookieStorage::addIdentifierToArchiveInternalLocked(PrivateHTTPCookieStorage *this, __CFArray *a2, const __CFString *a3, const __CFString *a4)
{
  int v4;
  const __CFAllocator *v8;
  uint64_t *v9;
  uint64_t v10;
  const __CFString *v11;
  __CFDictionary *MutableDictionary;

  v4 = (int)a4;
  CFArrayAppendValue(this, &unk_1EDCFCA58);
  v8 = CFGetAllocator(this);
  v9 = (uint64_t *)MEMORY[0x1E0C9AE50];
  if (!v4)
    v9 = (uint64_t *)MEMORY[0x1E0C9AE40];
  v10 = *v9;
  v11 = CFSTR("kCFURLStorageSessionAppIdentifier");
  if (!a2)
    v11 = 0;
  MutableDictionary = cfTypeCreateMutableDictionary(v8, CFSTR("ident"), a3, CFSTR("persistent"), v10, v11, a2, 0, 0);
  CFArrayAppendValue(this, MutableDictionary);
  if (MutableDictionary)
    CFRelease(MutableDictionary);
}

void PrivateHTTPCookieStorage::setCookiesWithPoliciesAppliedCommonImpl(CFAllocatorRef *a1, const void *a2, HTTPCookieStoragePolicy *this, uint64_t a4)
{
  const __CFString *v8;
  const __CFString *v9;
  CFMutableStringRef MutableCopy;
  const char *CStringPtr;
  char *v12;
  CFIndex v13;
  const __CFString *v14;
  double Current;
  uint64_t v16;
  unint64_t v17;
  const __CFData *v18;
  const UInt8 *BytePtr;
  unint64_t v20;
  _BOOL4 v21;
  const __CFData *v22;
  const UInt8 *v23;
  const UInt8 *v24;
  uint64_t v25;
  const UInt8 *v26;
  double v27;
  int v28;
  char *v29;
  char *v30;
  _BOOL4 v31;
  const __CFURL *v32;
  CookieHostName *Name;
  CookieHostName *v34;
  CookieUtils *v35;
  unint64_t Count;
  CFRange v37;
  const void **v38;
  CFIndex v39;
  OpaqueCFHTTPCookie *v40;
  uint64_t v41;
  unsigned int *v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  _BYTE *v46;
  uint64_t v47;
  CompactCookieHeader *v48;
  void *EnumeratedString;
  const __CFString *v50;
  CFIndex v51;
  uint64_t v52;
  CFAbsoluteTime v53;
  const unsigned __int8 *v54;
  uint64_t v55;
  uint64_t v56;
  char *ptr;
  const char *v58;
  CFMutableStringRef cf;
  const void *v60;
  void (**v61)(DomainAndPartition *__hidden);
  CFIndex range;
  const void **v63;
  _BYTE v64[248];
  CFIndex v65;
  void *v66;
  _QWORD v67[3];
  _BYTE v68[256];
  void *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  switch(*((_DWORD *)this + 10))
  {
    case 0xFFFFFFFF:
      *((_DWORD *)this + 10) = 3;
      goto LABEL_52;
    case 1:
      return;
    case 2:
      v8 = CFURLCopyHostName(*((CFURLRef *)this + 2));
      if (!v8)
        goto LABEL_52;
      v9 = v8;
      MutableCopy = CFStringCreateMutableCopy(a1[1], 0, v8);
      CFRelease(v9);
      if (!MutableCopy)
        goto LABEL_52;
      CFStringLowercase(MutableCopy, 0);
      CStringPtr = CFStringGetCStringPtr(MutableCopy, 0x600u);
      v12 = (char *)CStringPtr;
      if (CStringPtr
        || (v13 = CFStringGetLength(MutableCopy) + 1,
            v12 = (char *)CFAllocatorAllocate(a1[1], v13, 0),
            CFStringGetCString(MutableCopy, v12, v13, 0x600u),
            v12))
      {
        v58 = CStringPtr;
        cf = MutableCopy;
        v60 = a2;
        v14 = (const __CFString *)*((_QWORD *)this + 4);
        Current = CFAbsoluteTimeGetCurrent();
        ptr = v12;
        do
        {
          DomainAndPartition::DomainAndPartition(v67, v12, v14, 1, *(uint64_t *)&Current);
          DomainAndPartition::DomainAndPartition((uint64_t)&v61, (uint64_t)v67);
          v16 = (*(uint64_t (**)(uint64_t, void (***)(DomainAndPartition *__hidden), uint64_t))(a4 + 16))(a4, &v61, 1);
          v61 = &off_1E14E9488;
          if (v66 && v66 != v64)
            free(v66);
          if (v16)
          {
            v17 = 0;
            while (1)
            {
              v18 = *(const __CFData **)(v16 + 16);
              if (v18 && (BytePtr = CFDataGetBytePtr(v18)) != 0)
                v20 = *((unsigned int *)BytePtr + 1);
              else
                v20 = 0;
              v21 = v17 >= v20;
              if (v17 >= v20)
                break;
              v22 = *(const __CFData **)(v16 + 16);
              if (v22 && CFDataGetBytePtr(v22))
              {
                v23 = CFDataGetBytePtr(*(CFDataRef *)(v16 + 16));
                v24 = *(const UInt8 **)(v16 + 16);
                v25 = *(unsigned int *)&v23[4 * v17 + 8];
                if (v24)
                  v24 = CFDataGetBytePtr((CFDataRef)v24);
                v26 = &v24[v25];
              }
              else
              {
                v26 = 0;
              }
              if (*(_DWORD *)v26 < 0xCu || (*((_DWORD *)v26 + 2) & 2) == 0)
              {
                v27 = 0.0;
                if (*(_DWORD *)v26 >= 0x30u)
                  v27 = floor(*((double *)v26 + 5));
                ++v17;
                if (Current >= v27)
                  continue;
              }
              v28 = 1;
              goto LABEL_38;
            }
            if (*v12 == 46)
              v30 = v12 + 1;
            else
              v30 = v12;
            v12 = strchr(v30, 46);
            v28 = 0;
LABEL_38:
            CFRelease((CFTypeRef)(v16 - 16));
          }
          else
          {
            if (*v12 == 46)
              v29 = v12 + 1;
            else
              v29 = v12;
            v12 = strchr(v29, 46);
            v28 = 0;
            v21 = 1;
          }
          v67[0] = &off_1E14E9488;
          if (v69 && v69 != v68)
            free(v69);
          if (v12)
            v31 = v21;
          else
            v31 = 0;
        }
        while (v31 && *v12);
        CFRelease(cf);
        a2 = v60;
        if (v58)
        {
          if (v28)
            goto LABEL_54;
          goto LABEL_52;
        }
      }
      else
      {
        CFRelease(MutableCopy);
        v28 = 0;
        ptr = 0;
      }
      CFAllocatorDeallocate(a1[1], ptr);
      if (v28)
        goto LABEL_54;
LABEL_52:
      v32 = (const __CFURL *)*((_QWORD *)this + 3);
      if (v32 && !HTTPCookieStorage::isURLInMainDocumentDomain(*((HTTPCookieStorage **)this + 2), v32, this))
        return;
LABEL_54:
      Name = HTTPCookieStoragePolicy::getName(this);
      if (Name && *((_QWORD *)Name + 2) >= 2uLL)
      {
        v34 = HTTPCookieStoragePolicy::getName(this);
        if (v34 && *((_QWORD *)v34 + 2))
        {
          v35 = (CookieUtils *)(*((_QWORD *)v34 + 1) + 1);
          if (!a2)
          {
LABEL_59:
            v61 = 0;
            range = 0;
            v63 = (const void **)v64;
            goto LABEL_68;
          }
        }
        else
        {
          v35 = 0;
          if (!a2)
            goto LABEL_59;
        }
        v61 = (void (**)(DomainAndPartition *__hidden))CFRetain(a2);
        Count = CFArrayGetCount((CFArrayRef)a2);
        v37.length = Count;
        range = Count;
        if (Count - 1 <= 0x1FFFFFFFFFFFFFFDLL)
        {
          if (Count > 0x1E)
          {
            v38 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
            v63 = v38;
            if (!v38)
              goto LABEL_68;
            v37.length = range;
          }
          else
          {
            v38 = (const void **)v64;
            v63 = (const void **)v64;
          }
          v37.location = 0;
          CFArrayGetValues((CFArrayRef)a2, v37, v38);
          goto LABEL_68;
        }
        v63 = 0;
LABEL_68:
        v65 = 0;
        if (range < 1)
        {
LABEL_94:
          CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v61);
          return;
        }
        v39 = 0;
        while (1)
        {
          v65 = v39 + 1;
          v40 = (OpaqueCFHTTPCookie *)v63[v39];
          if (CFHTTPCookie_domainMatches(v40, *((const __CFURL **)this + 2)))
            break;
LABEL_93:
          v39 = v65;
          if (v65 >= range)
            goto LABEL_94;
        }
        v41 = -[OpaqueCFHTTPCookie _inner](v40, "_inner");
        v42 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v41 + 16))(v41);
        if (*v42 >= 0x14
          && (v43 = v42[4], (_DWORD)v43)
          && (v44 = (char *)v42 + v43, v45 = *v42, v46 = (char *)v42 + v43, v45 > v43))
        {
          while (*v46)
          {
            if (++v46 >= (_BYTE *)v42 + v45)
              goto LABEL_76;
          }
        }
        else
        {
LABEL_76:
          v44 = 0;
        }
        v47 = -[OpaqueCFHTTPCookie _inner](v40, "_inner");
        v48 = (CompactCookieHeader *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v47 + 16))(v47);
        EnumeratedString = (void *)CompactCookieHeader::getEnumeratedString(v48, 15, 0);
        if (!EnumeratedString)
        {
          v50 = (const __CFString *)*((_QWORD *)this + 4);
          if (!v50)
          {
LABEL_81:
            EnumeratedString = 0;
            goto LABEL_82;
          }
          v51 = CFStringGetLength(v50) + 1;
          EnumeratedString = malloc_type_malloc(v51, 0x36D6CAEFuLL);
          if (!CFStringGetCString(*((CFStringRef *)this + 4), (char *)EnumeratedString, v51, 0x8000100u))
          {
            free(EnumeratedString);
            goto LABEL_81;
          }
        }
LABEL_82:
        if (*((_BYTE *)this + 56))
        {
          v52 = *((_QWORD *)this + 8);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          v53 = CFAbsoluteTimeGetCurrent();
          *((CFAbsoluteTime *)this + 8) = v53;
          v52 = *(_QWORD *)&v53;
        }
        DomainAndPartition::DomainAndPartition(v67, v44, (char *)EnumeratedString, *((_QWORD *)this + 7), v52);
        if (v35 == (CookieUtils *)v44 || v35 && v44 && CookieUtils::web_domainMatches_LCC_LCC(v35, v44, v54))
        {
          v55 = -[OpaqueCFHTTPCookie _inner](v40, "_inner");
          v56 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v55 + 16))(v55);
          (*((void (**)(CFAllocatorRef *, uint64_t, HTTPCookieStoragePolicy *))*a1 + 15))(a1, v56, this);
        }
        v67[0] = &off_1E14E9488;
        if (v69)
        {
          if (v69 != v68)
            free(v69);
        }
        goto LABEL_93;
      }
      return;
    case 3:
      goto LABEL_52;
    default:
      goto LABEL_54;
  }
}

void sub_1840A06E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

CookieHostName *HTTPCookieStoragePolicy::getName(HTTPCookieStoragePolicy *this)
{
  CookieHostName *v1;
  const __CFURL *v3;

  v1 = (CookieHostName *)*((_QWORD *)this + 1);
  if (!v1)
  {
    v1 = (CookieHostName *)operator new();
    CFGetAllocator(*((CFTypeRef *)this + 2));
    CookieHostName::CookieHostName(v1, *((CFURLRef *)this + 2), v3);
    *((_QWORD *)this + 1) = v1;
  }
  return v1;
}

void sub_1840A07E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D1C40B840AE13);
  _Unwind_Resume(a1);
}

void sub_1840A0860(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void MemoryCookies::setCookiesForDomain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), *(const void **)(a2 + 312), (const void *)(a3 - 16));
}

void `non-virtual thunk to'MemoryCookies::~MemoryCookies(MemoryCookies *this)
{
  const void *v2;

  *((_QWORD *)this - 2) = off_1E14E6620;
  *(_QWORD *)this = &unk_1E14E6648;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)this = &off_1E14E5838;
}

{
  char *v2;
  const void *v3;

  *((_QWORD *)this - 2) = off_1E14E6620;
  v2 = (char *)this - 16;
  *(_QWORD *)this = &unk_1E14E6648;
  v3 = (const void *)*((_QWORD *)this + 1);
  if (v3)
    CFRelease(v3);
  *(_QWORD *)this = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 1), v2);
}

void sub_1840A08C8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_1840A092C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke(uint64_t a1, CFDictionaryRef theDict)
{
  int Count;
  unint64_t v5;
  const void **v6;
  uint64_t v7;
  int v8;
  const void *v9;
  uint64_t v10;
  const __CFData *v11;
  const UInt8 *BytePtr;
  int v13;
  CFTypeRef v14;
  uint64_t v15;
  const void **v16;
  _BYTE v17[248];
  uint64_t v18;

  Count = CFDictionaryGetCount(theDict);
  if (!theDict)
  {
    v14 = 0;
    v15 = 0;
    v16 = (const void **)v17;
    goto LABEL_9;
  }
  v14 = CFRetain(theDict);
  v5 = CFDictionaryGetCount(theDict);
  v15 = v5;
  if (v5 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v16 = 0;
    goto LABEL_9;
  }
  if (v5 > 0x1E)
  {
    v6 = (const void **)malloc_type_malloc(8 * v5, 0x89ED541CuLL);
    v16 = v6;
    if (!v6)
      goto LABEL_9;
  }
  else
  {
    v6 = (const void **)v17;
    v16 = (const void **)v17;
  }
  CFDictionaryGetKeysAndValues(theDict, 0, v6);
LABEL_9:
  v18 = 0;
  if (v15 < 1)
  {
    v8 = 0;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v18 = v7 + 1;
      v9 = v16[v7];
      if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
        dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
      v10 = (uint64_t)v9 + 16;
      if (!v9)
        v10 = 0;
      v11 = *(const __CFData **)(v10 + 16);
      if (v11 && (BytePtr = CFDataGetBytePtr(v11)) != 0)
        v13 = *((_DWORD *)BytePtr + 1);
      else
        v13 = 0;
      v8 += v13;
      v7 = v18;
    }
    while (v18 < v15);
  }
  snprintf(*(char **)(a1 + 32), *(int *)(a1 + 40), "<%d cookies in %d domains>", v8, Count);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v14);
}

void sub_1840A0AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

uint64_t MemoryCookies::_mergeCookiesFrom(MemoryCookies *this, char *a2, CFDictionaryRef *a3, void *a4)
{
  CompactCookieArray *v7;

  if (a2)
  {
    if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
      dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
    v7 = (CompactCookieArray *)(a2 + 16);
  }
  else
  {
    v7 = 0;
  }
  return MemoryCookies::setCookiesWithPartitionedDomains(a3, (const unsigned __int8 *)this, v7);
}

uint64_t MemoryCookieStorage::wantsSyncTimer(MemoryCookieStorage *this)
{
  return 0;
}

CFStringRef MemoryCookieStorage::copyDebugDescLocked(MemoryCookieStorage *this)
{
  const __CFAllocator *v1;
  uint64_t v2;
  _QWORD v4[5];
  int v5;
  _BYTE v6[1024];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v1 = (const __CFAllocator *)*((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 9);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
  v4[3] = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
  v4[4] = v6;
  v5 = 1024;
  MemoryCookies::withImmutableDomains(v2, (uint64_t)v4);
  return CFStringCreateWithFormat(v1, 0, CFSTR("Memory Cookies: { %p, %s }"), v2, v6);
}

uint64_t MemoryCookieStorage::copyPersistentCookiesLocked(uint64_t a1, uint64_t a2)
{
  _OWORD *v3;
  uint64_t result;

  v3 = MemoryCookies::clone(*(CFAllocatorRef **)(a1 + 72));
  result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 16))(a2, v3);
  if (v3)
    return (*(uint64_t (**)(_OWORD *))(*(_QWORD *)v3 + 8))(v3);
  return result;
}

void MemoryCookieStorage::newCookieArrayEnumeratorLocked(uint64_t a1, CookieSifter *a2, uint64_t a3)
{
  CFContainerEnumeratorBase *v4;

  v4 = (CFContainerEnumeratorBase *)MemoryCookies::newCookieArrayEnumerator(*(MemoryCookies **)(a1 + 72), a2);
  (*(void (**)(uint64_t, CFContainerEnumeratorBase *))(a3 + 16))(a3, v4);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v4);
  JUMPOUT(0x186DB748CLL);
}

uint64_t MemoryCookieStorage::deleteCookieInternalLocked(const HTTPCookieStoragePolicy **this, CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3, const MemoryCookies *a4)
{
  uint64_t result;

  result = PrivateHTTPCookieStorage::allowCookieToBeWrittenConsideringHTTPOnly((PrivateHTTPCookieStorage *)a2, (const CompactCookieHeader *)*((unsigned int *)a3 + 18), this[9], a4);
  if ((_DWORD)result)
    return MemoryCookies::deleteCookie(this[9], a2);
  return result;
}

CFMutableDictionaryRef MemoryCookieStorage::deleteAllCookiesLocked(MemoryCookieStorage *this)
{
  uint64_t v2;
  _OWORD *v3;
  const __CFAllocator *v4;
  CFMutableDictionaryRef result;

  v2 = *((_QWORD *)this + 9);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 32, 0);
  *v3 = 0u;
  v3[1] = 0u;
  v4 = (const __CFAllocator *)*((_QWORD *)this + 1);
  *(_QWORD *)v3 = off_1E14E6620;
  *((_QWORD *)v3 + 1) = v4;
  *((_QWORD *)v3 + 2) = &unk_1E14E6648;
  result = CFDictionaryCreateMutable(v4, 0, &CStringKeyCallbacks::caseInsensitiveCallbacks(void)::sCallbacks, MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)v3 + 3) = result;
  *((_QWORD *)this + 9) = v3;
  return result;
}

void sub_1840A0DF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void MemoryCookieStorage::deleteAllCookiesSinceDateLocked(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  double v5;
  void *v6;
  _QWORD v7[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t);
  void (*v12)(uint64_t);
  uint64_t v13;

  v8 = 0;
  v9 = &v8;
  v10 = 0x3052000000;
  v11 = __Block_byref_object_copy__9916;
  v12 = __Block_byref_object_dispose__9917;
  v13 = 0;
  if (a1[9])
  {
    v5 = MEMORY[0x186DB5F80](a2);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZN19MemoryCookieStorage31deleteAllCookiesSinceDateLockedEPK8__CFDateU13block_pointerFvP7NSArrayE_block_invoke;
    v7[3] = &unk_1E14FB420;
    *(double *)&v7[6] = v5;
    v7[4] = &v8;
    v7[5] = a1;
    (*(void (**)(_QWORD *, _QWORD *))(*a1 + 184))(a1, v7);
    v6 = (void *)v9[5];
    if (v6)
      (*(void (**)(uint64_t, void *))(a3 + 16))(a3, v6);
  }
  _Block_object_dispose(&v8, 8);
}

void sub_1840A0EE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t MemoryCookieStorage::syncStorageWithCompletionLocked(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (a3)
    return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  return result;
}

uint64_t MemoryCookieStorage::addToArchiveInternalLocked(MemoryCookies **this, CFMutableArrayRef theArray)
{
  CFContainerEnumeratorBase *v4;
  const __CFAllocator *v5;
  const __CFAllocator *i;
  uint64_t v7;
  const __CFAllocator *v8;
  CFDataRef Copy;
  uint64_t v10;
  void (**v12)(AutoScalar *__hidden);
  void *value;

  CFArrayAppendValue(theArray, &unk_1EDCFCA90);
  v4 = (CFContainerEnumeratorBase *)MemoryCookies::newCookieArrayEnumerator(this[9], 0);
  v5 = (const __CFAllocator *)*((_QWORD *)v4 + 1);
  AutoScalar::AutoScalar((AutoScalar *)&v12, v5);
  CFArrayAppendValue(theArray, value);
  v12 = &off_1E14E47E8;
  if (value)
    CFRelease(value);
  if ((uint64_t)v5 >= 1)
  {
    for (i = 0; i != v5; i = (const __CFAllocator *)((char *)i + 1))
    {
      v7 = *(_QWORD *)(*((_QWORD *)v4 + 2) + 8 * (_QWORD)i);
      if (v7)
      {
        if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
          dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
        v7 += 16;
      }
      if (*(_QWORD *)(v7 + 16))
      {
        v8 = CFGetAllocator((CFTypeRef)(v7 - 16));
        Copy = CFDataCreateCopy(v8, *(CFDataRef *)(v7 + 16));
      }
      else
      {
        Copy = 0;
      }
      CFArrayAppendValue(theArray, Copy);
      CFRelease(Copy);
    }
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v4);
  return MEMORY[0x186DB748C](v10);
}

void sub_1840A105C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void MemoryCookieStorage::visitCookiesLocked(uint64_t a1, uint64_t a2)
{
  MemoryCookies::visitCookies(*(_QWORD *)(a1 + 72), a2);
}

void MemoryCookieStorage::setCookiesWithPoliciesAppliedLocked(CFAllocatorRef *this, const __CFArray *a2, const HTTPCookieStoragePolicy *a3)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN19MemoryCookieStorage35setCookiesWithPoliciesAppliedLockedEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke;
  v3[3] = &__block_descriptor_40_e116_r__CompactCookieArray___________CFData__332__0_DomainAndPartition_____CFAbsoluteTimeAsSpecified_Cd__256C__Q____8C328l;
  v3[4] = this;
  PrivateHTTPCookieStorage::setCookiesWithPoliciesAppliedCommonImpl(this, a2, a3, (uint64_t)v3);
}

void `non-virtual thunk to'MemoryCookieStorage::~MemoryCookieStorage(MemoryCookieStorage *this)
{
  uint64_t v2;
  PrivateHTTPCookieStorage *v3;

  *(_QWORD *)this = &unk_1E14EA0D0;
  v2 = *((_QWORD *)this + 6);
  *((_QWORD *)this - 3) = off_1E14E9FF8;
  v3 = (MemoryCookieStorage *)((char *)this - 24);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(v3);
}

{
  MemoryCookieStorage::~MemoryCookieStorage((MemoryCookieStorage *)((char *)this - 24));
}

uint64_t ___ZN19MemoryCookieStorage35setCookiesWithPoliciesAppliedLockedEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  void (**v9)(DomainAndPartition *__hidden);
  uint64_t v10;
  void *v11;
  const void *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 72);
  DomainAndPartition::DomainAndPartition((uint64_t)&v9, a2);
  MemoryCookies::copyCookiesInDomain(*(const __CFDictionary **)(v4 + 24), v12, a3);
  v6 = v5;
  v9 = &off_1E14E9488;
  if (v11)
    v7 = v11 == &v10;
  else
    v7 = 1;
  if (!v7)
    free(v11);
  return v6;
}

void sub_1840A11D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t *a45)
{
  BOOL v46;

  if (a45)
    v46 = a45 == &a13;
  else
    v46 = 1;
  if (!v46)
    free(a45);
  _Unwind_Resume(exception_object);
}

void __Block_byref_object_copy__9916(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__9917(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t ___ZN19MemoryCookieStorage31deleteAllCookiesSinceDateLockedEPK8__CFDateU13block_pointerFvP7NSArrayE_block_invoke(uint64_t result, CompactCookieHeader *a2)
{
  uint64_t v3;
  double v4;

  v3 = result;
  v4 = 0.0;
  if (*(_DWORD *)a2 >= 0x38u)
    v4 = floor(*((double *)a2 + 6));
  if (v4 >= *(double *)(result + 48))
  {
    MemoryCookies::deleteCookie(*(MemoryCookies **)(*(_QWORD *)(result + 40) + 72), a2);
    if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 40))
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 40) = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    return objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 40), "addObject:", -[NSHTTPCookie _initWithHeader:]([NSHTTPCookie alloc], "_initWithHeader:", a2));
  }
  return result;
}

void sub_1840A1430(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840A1524(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1840A19B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840A1B20(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840A1C6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1840A1CE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840A2250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1840A23DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1840A2BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1840A3338(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void DiskCookieStorage::Journal::~Journal(DiskCookieStorage::Journal *this)
{
  const void *v1;

  *(_QWORD *)this = off_1E14EFF60;
  v1 = (const void *)*((_QWORD *)this + 2);
  if (v1)
    CFRelease(v1);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14EFF60;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

uint64_t DiskCookieStorage::wantsSyncTimer(DiskCookieStorage *this)
{
  return 1;
}

uint64_t DiskCookieStorage::invalidateLocked(uint64_t this)
{
  *(_BYTE *)(this + 40) = 0;
  return this;
}

CFStringRef DiskCookieStorage::copyDebugDescLocked(DiskCookieStorage *this)
{
  const __CFAllocator *v2;
  const char *v3;
  size_t v4;
  const __CFURL *v5;
  CFStringRef v6;
  uint64_t v7;
  const __CFAllocator *v8;
  double v9;
  const char *v10;
  double v11;
  const char *v12;
  CFStringRef v13;
  _QWORD v15[5];
  int v16;
  char v17[1032];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = (const __CFAllocator *)*((_QWORD *)this + 1);
  v3 = (const char *)(*((_QWORD *)this + 9) + 1);
  v4 = strlen(v3);
  v5 = CFURLCreateFromFileSystemRepresentation(v2, (const UInt8 *)v3, v4, 0);
  v6 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
  if (v5)
    CFRelease(v5);
  v7 = *((_QWORD *)this + 37);
  if (v7)
  {
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
    v15[3] = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
    v15[4] = v17;
    v16 = 1024;
    MemoryCookies::withImmutableDomains(v7, (uint64_t)v15);
  }
  else
  {
    strcpy(v17, "<cookies not yet read>");
  }
  v8 = (const __CFAllocator *)*((_QWORD *)this + 1);
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  v9 = *((double *)this + 12);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 22);
  if (v9 == 0.0)
    v10 = "clean";
  else
    v10 = "dirty";
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  v11 = *((double *)this + 14);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 22);
  v12 = "writing";
  if (v11 == 0.0)
    v12 = "not writing";
  v13 = CFStringCreateWithFormat(v8, 0, CFSTR("Disk Cookies: { %@, %s %s %s }"), v6, v17, v10, v12);
  if (v6)
    CFRelease(v6);
  return v13;
}

uint64_t DiskCookieStorage::copyPersistentCookiesLocked(CFAllocatorRef **a1, uint64_t a2)
{
  _OWORD *v4;
  uint64_t result;

  DiskCookieStorage::rereadFromDiskIfNecessaryLocked((DiskCookieStorage *)a1);
  v4 = MemoryCookies::clone(a1[36]);
  result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 16))(a2, v4);
  if (v4)
    return (*(uint64_t (**)(_OWORD *))(*(_QWORD *)v4 + 8))(v4);
  return result;
}

void DiskCookieStorage::deleteCookieInternalLocked(DiskCookieStorage *this, CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3, const MemoryCookies *a4)
{
  uint64_t v6;
  MemoryCookies *v7;
  MemoryCookies *v8;

  if (PrivateHTTPCookieStorage::allowCookieToBeWrittenConsideringHTTPOnly((PrivateHTTPCookieStorage *)a2, (const CompactCookieHeader *)*((unsigned int *)a3 + 18), *((const HTTPCookieStoragePolicy **)this + 37), a4))
  {
    v6 = *((_QWORD *)this + 38);
    ++*((_QWORD *)this + 39);
    if (v6)
      DiskCookieStorage::Journal::record(v6, 1, (const UInt8 *)a2);
    v7 = (MemoryCookies *)*((_QWORD *)this + 35);
    if (v7)
      MemoryCookies::deleteCookie(v7, a2);
    v8 = (MemoryCookies *)*((_QWORD *)this + 36);
    if (v8)
      MemoryCookies::deleteCookie(v8, a2);
    if (MemoryCookies::deleteCookie(*((MemoryCookies **)this + 37), a2))
      DiskCookieStorage::setDirtyAndNotifyInstantOff((os_unfair_lock_s *)this);
  }
}

void DiskCookieStorage::deleteAllCookiesLocked(DiskCookieStorage *this)
{
  uint64_t v2;
  MemoryCookies *v3;
  MemoryCookies *v4;
  MemoryCookies *v5;
  UInt8 bytes[4];

  v2 = *((_QWORD *)this + 38);
  ++*((_QWORD *)this + 39);
  if (v2)
  {
    *(_DWORD *)bytes = 2;
    CFDataAppendBytes(*(CFMutableDataRef *)(v2 + 16), bytes, 4);
  }
  v3 = (MemoryCookies *)*((_QWORD *)this + 37);
  if (v3)
    MemoryCookies::deleteAllCookies(v3);
  v4 = (MemoryCookies *)*((_QWORD *)this + 36);
  if (v4)
    MemoryCookies::deleteAllCookies(v4);
  v5 = (MemoryCookies *)*((_QWORD *)this + 35);
  if (v5)
    MemoryCookies::deleteAllCookies(v5);
  DiskCookieStorage::setDirtyAndNotifyInstantOff((os_unfair_lock_s *)this);
}

void DiskCookieStorage::deleteAllCookiesSinceDateLocked(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  double v5;
  void *v6;
  _QWORD v7[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t);
  void (*v12)(uint64_t);
  uint64_t v13;

  ++a1[39];
  v5 = MEMORY[0x186DB5F80](a2);
  v8 = 0;
  v9 = &v8;
  v10 = 0x3052000000;
  v11 = __Block_byref_object_copy__10157;
  v12 = __Block_byref_object_dispose__10158;
  v13 = 0;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN17DiskCookieStorage31deleteAllCookiesSinceDateLockedEPK8__CFDateU13block_pointerFvP7NSArrayE_block_invoke;
  v7[3] = &unk_1E14FB420;
  *(double *)&v7[6] = v5;
  v7[4] = &v8;
  v7[5] = a1;
  (*(void (**)(_QWORD *, _QWORD *))(*a1 + 184))(a1, v7);
  v6 = (void *)v9[5];
  if (v6)
    (*(void (**)(uint64_t, void *))(a3 + 16))(a3, v6);
  _Block_object_dispose(&v8, 8);
}

void sub_1840A3800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void DiskCookieStorage::visitCookiesLocked(uint64_t a1, uint64_t a2)
{
  MemoryCookies::visitCookies(*(_QWORD *)(a1 + 296), a2);
}

void DiskCookieStorage::setCookiesWithPoliciesAppliedLocked(CFAllocatorRef *this, const __CFArray *a2, const HTTPCookieStoragePolicy *a3)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN17DiskCookieStorage35setCookiesWithPoliciesAppliedLockedEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke;
  v3[3] = &__block_descriptor_40_e116_r__CompactCookieArray___________CFData__332__0_DomainAndPartition_____CFAbsoluteTimeAsSpecified_Cd__256C__Q____8C328l;
  v3[4] = this;
  PrivateHTTPCookieStorage::setCookiesWithPoliciesAppliedCommonImpl(this, a2, a3, (uint64_t)v3);
}

uint64_t ___ZN17DiskCookieStorage35setCookiesWithPoliciesAppliedLockedEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  void (**v8)(DomainAndPartition *__hidden);
  uint64_t v9;
  void *v10;
  const void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 296);
  if (!v3)
    return 0;
  DomainAndPartition::DomainAndPartition((uint64_t)&v8, a2);
  MemoryCookies::copyCookiesInDomain(*(const __CFDictionary **)(v3 + 24), v11, a3);
  v6 = v5;
  v8 = &off_1E14E9488;
  if (v10 && v10 != &v9)
    free(v10);
  return v6;
}

void sub_1840A392C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t *a45)
{
  if (a45)
  {
    if (a45 != &a13)
      free(a45);
  }
  _Unwind_Resume(exception_object);
}

void DiskCookieStorage::traceError(DiskCookieStorage *this, const TracerData *a2)
{
  uint64_t v4;
  __CFError *v5;
  __CFError *v6;
  CFIndex Code;
  CFErrorDomain Domain;
  CFErrorDomain v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  CFTypeRef v15;
  uint64_t v16;
  size_t v17;
  const __CFURL *v18;
  const __CFURL *v19;
  const __CFURL *PathComponent;
  uint64_t v21;
  int v22;
  const __CFAllocator *v23;
  int *v24;
  CFStringRef v25;
  CFDateRef v26;
  _acl *link_np;
  _acl *v28;
  char *v29;
  char *v30;
  char *v31;
  const char *v32;
  const __CFAllocator *v33;
  CFStringRef v34;
  __CFError *v35;
  CFErrorDomain v36;
  CFIndex v37;
  const __CFString *v38;
  int *v39;
  NSObject *v40;
  CFDateRef v41;
  _acl *v42;
  _acl *v43;
  char *v44;
  char *v45;
  char *v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  uid_t v50;
  gid_t v51;
  uint64_t CString;
  CFStringRef v53;
  stat v54;
  uint8_t buf[4];
  uint64_t v56;
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  uid_t v60;
  __int16 v61;
  gid_t v62;
  __int16 v63;
  uint64_t v64;
  _BYTE v65[152];
  stat v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v4 = DiskCookieStorage::traceError(TracerData const*)::sLastError;
  if (!DiskCookieStorage::traceError(TracerData const*)::sLastError)
    goto LABEL_14;
  if (*(_QWORD *)a2 != *(_QWORD *)DiskCookieStorage::traceError(TracerData const*)::sLastError)
    goto LABEL_12;
  if (*((_DWORD *)a2 + 2) != *(_DWORD *)(DiskCookieStorage::traceError(TracerData const*)::sLastError + 8))
    goto LABEL_12;
  v5 = (__CFError *)*((_QWORD *)a2 + 2);
  v6 = *(__CFError **)(DiskCookieStorage::traceError(TracerData const*)::sLastError + 16);
  if (v5 != v6)
  {
    if (!v5)
      goto LABEL_12;
    if (!v6)
      goto LABEL_12;
    Code = CFErrorGetCode(*((CFErrorRef *)a2 + 2));
    if (Code != CFErrorGetCode(v6))
      goto LABEL_12;
    Domain = CFErrorGetDomain(v5);
    v9 = CFErrorGetDomain(v6);
    if (!CFEqual(Domain, v9))
      goto LABEL_12;
  }
  v10 = *((_QWORD *)a2 + 3);
  if (v10 != *(_QWORD *)(v4 + 24)
    || (v11 = *((unsigned int *)a2 + 8), (_DWORD)v11 != *(_DWORD *)(v4 + 32))
    || (v12 = (const char *)*((_QWORD *)a2 + 5), strcmp(v12, *(const char **)(v4 + 40))))
  {
LABEL_12:
    v13 = DiskCookieStorage::traceError(TracerData const*)::sLastError;
    if (DiskCookieStorage::traceError(TracerData const*)::sLastError)
    {
      TracerData::clearError((TracerData *)DiskCookieStorage::traceError(TracerData const*)::sLastError);
      MEMORY[0x186DB748C](v13, 0x1070C40A8115D6ALL);
    }
LABEL_14:
    v14 = operator new();
    *(_QWORD *)v14 = *(_QWORD *)a2;
    *(_DWORD *)(v14 + 8) = *((_DWORD *)a2 + 2);
    v15 = (CFTypeRef)*((_QWORD *)a2 + 2);
    if (v15)
      v15 = CFRetain(v15);
    v16 = *((_QWORD *)a2 + 3);
    *(_QWORD *)(v14 + 16) = v15;
    *(_QWORD *)(v14 + 24) = v16;
    *(_DWORD *)(v14 + 32) = *((_DWORD *)a2 + 8);
    *(_QWORD *)(v14 + 40) = strdup(*((const char **)a2 + 5));
    DiskCookieStorage::traceError(TracerData const*)::sLastError = v14;
    if (DiskCookieStorage::traceError(TracerData const*)::onceToken != -1)
      dispatch_once(&DiskCookieStorage::traceError(TracerData const*)::onceToken, &__block_literal_global_33_10104);
    v17 = strlen((const char *)(*((_QWORD *)this + 9) + 1));
    v18 = CFURLCreateFromFileSystemRepresentation(*((CFAllocatorRef *)this + 1), (const UInt8 *)(*((_QWORD *)this + 9) + 1), v17, 0);
    if (v18
      && (v19 = v18,
          PathComponent = CFURLCreateCopyDeletingLastPathComponent(*((CFAllocatorRef *)this + 1), v18),
          CFRelease(v19),
          PathComponent))
    {
      v21 = operator new();
      FilePathStorage<unsigned char>::FilePathStorage(v21, PathComponent, *(_DWORD *)(*((_QWORD *)this + 9) + 1028), *(_DWORD *)(*((_QWORD *)this + 9) + 1032), 0);
      CFRelease(PathComponent);
      v22 = stat((const char *)(v21 + 1), &v66);
      v23 = (const __CFAllocator *)*((_QWORD *)this + 1);
      if (v22)
      {
        v24 = __error();
        v25 = CFStringCreateWithFormat(v23, 0, CFSTR("stat failed: errno %d"), *v24);
      }
      else
      {
        v26 = CFDateCreate(*((CFAllocatorRef *)this + 1), (double)v66.st_mtimespec.tv_sec - *MEMORY[0x1E0C9ADF8] + (double)v66.st_mtimespec.tv_nsec / 1000000000.0);
        link_np = acl_get_link_np((const char *)(v21 + 1), ACL_TYPE_EXTENDED);
        v28 = link_np;
        if (link_np)
        {
          v29 = acl_to_text(link_np, 0);
          v30 = v29;
          if (v29)
          {
            v31 = strdup(v29);
            acl_free(v30);
          }
          else
          {
            v31 = 0;
          }
          acl_free(v28);
        }
        else
        {
          v31 = 0;
        }
        v32 = "none";
        if (v31)
          v32 = v31;
        v25 = CFStringCreateWithFormat(*((CFAllocatorRef *)this + 1), 0, CFSTR("modTime: %@ st_uid: %d, st_mode: %o st_flags: 0x%x acl: %s"), v26, v66.st_uid, v66.st_mode, v66.st_flags, v32);
        if (v31)
          free(v31);
        if (v26)
          CFRelease(v26);
      }
      MEMORY[0x186DB748C](v21, 0x1000C4048165BC6);
    }
    else
    {
      v25 = CFSTR("none");
    }
    if (*((_DWORD *)a2 + 2))
    {
      v33 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v34 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("errno %d"), *((unsigned int *)a2 + 2));
    }
    else
    {
      v35 = (__CFError *)*((_QWORD *)a2 + 2);
      if (!v35)
      {
        v38 = (const __CFString *)CFRetain(CFSTR("no error available"));
        v33 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
LABEL_41:
        *(_QWORD *)&v66.st_dev = v33;
        v66.st_ino = 1023;
        if (v38)
        {
          *(_QWORD *)&v66.st_uid = _CFStringGetOrCreateCString(v33, v38, (UInt8 *)&v66.st_rdev, (uint64_t *)&v66.st_ino, 0x8000100u);
          CFRelease(v38);
        }
        else
        {
          LOBYTE(v66.st_rdev) = 0;
          v66.st_ino = 0;
          *(_QWORD *)&v66.st_uid = &v66.st_rdev;
        }
        if (stat((const char *)(*((_QWORD *)this + 9) + 1), &v54))
        {
          v39 = __error();
          AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)v65, *((CFAllocatorRef *)this + 1), CFSTR("{ Can't stat: %s, errno: %d parentInfo: %@ }"), *((_QWORD *)this + 9) + 1, *v39, v25);
          v40 = DiskCookieStorage::traceError(TracerData const*)::l;
          if (!os_log_type_enabled((os_log_t)DiskCookieStorage::traceError(TracerData const*)::l, OS_LOG_TYPE_ERROR))
          {
LABEL_61:
            AutoString::~AutoString((AutoString *)v65);
            if (v25)
              CFRelease(v25);
            if (*(_QWORD *)&v66.st_uid)
            {
              if (&v66.st_rdev != (dev_t *)*(stat **)&v66.st_uid)
                CFAllocatorDeallocate(*(CFAllocatorRef *)&v66.st_dev, *(void **)&v66.st_uid);
            }
            return;
          }
        }
        else
        {
          v41 = CFDateCreate(*((CFAllocatorRef *)this + 1), (double)v54.st_mtimespec.tv_sec- *MEMORY[0x1E0C9ADF8]+ (double)v54.st_mtimespec.tv_nsec / 1000000000.0);
          v42 = acl_get_link_np((const char *)(*((_QWORD *)this + 9) + 1), ACL_TYPE_EXTENDED);
          v43 = v42;
          if (v42)
          {
            v44 = acl_to_text(v42, 0);
            v45 = v44;
            if (v44)
            {
              v46 = strdup(v44);
              acl_free(v45);
            }
            else
            {
              v46 = 0;
            }
            acl_free(v43);
          }
          else
          {
            v46 = 0;
          }
          v47 = "none";
          if (v46)
            v47 = v46;
          AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)v65, *((CFAllocatorRef *)this + 1), CFSTR("{ Target path: %s, modTime: %@, size: %lld, st_uid: %d, st_mode: %o st_flags: 0x%x acl: %s parentInfo: %@ }"), *((_QWORD *)this + 9) + 1, v41, v54.st_size, v54.st_uid, v54.st_mode, v54.st_flags, v47, v25);
          if (v46)
            free(v46);
          if (v41)
            CFRelease(v41);
          v40 = DiskCookieStorage::traceError(TracerData const*)::l;
          if (!os_log_type_enabled((os_log_t)DiskCookieStorage::traceError(TracerData const*)::l, OS_LOG_TYPE_ERROR))
            goto LABEL_61;
        }
        v48 = *((_QWORD *)a2 + 3);
        v49 = *(_QWORD *)&v66.st_uid;
        v50 = geteuid();
        v51 = getegid();
        CString = AutoString::getCString((AutoString *)v65);
        *(_DWORD *)buf = 136316162;
        v56 = v48;
        v57 = 2080;
        v58 = v49;
        v59 = 1024;
        v60 = v50;
        v61 = 1024;
        v62 = v51;
        v63 = 2080;
        v64 = CString;
        _os_log_error_impl(&dword_183ECA000, v40, OS_LOG_TYPE_ERROR, "%s: %s, euid: %d, egid: %d, pathInfo: %s", buf, 0x2Cu);
        goto LABEL_61;
      }
      v36 = CFErrorGetDomain(v35);
      v37 = CFErrorGetCode(*((CFErrorRef *)a2 + 2));
      v33 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v34 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("CFError { %@, %ld }"), v36, v37);
    }
    v38 = v34;
    goto LABEL_41;
  }
  v53 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%s errno %d cferror %@ ep %s line %d path %s"), *(_QWORD *)a2, *((unsigned int *)a2 + 2), *((_QWORD *)a2 + 2), v10, v11, v12);
  if (v53)
    CFRelease(v53);
}

void sub_1840A40DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,CFAllocatorRef allocator,uint64_t a62,void *ptr)
{
  void *v63;

  AutoString::~AutoString((AutoString *)&a42);
  if (ptr)
  {
    if (v63 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  _Unwind_Resume(a1);
}

void TracerData::clearError(TracerData *this)
{
  const void *v2;

  *((_DWORD *)this + 2) = 0;
  v2 = (const void *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  free(*((void **)this + 5));
  *((_QWORD *)this + 5) = 0;
}

os_log_t ___ZN17DiskCookieStorage10traceErrorEPK10TracerData_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.CFNetwork", "DiskCookies");
  DiskCookieStorage::traceError(TracerData const*)::l = (uint64_t)result;
  return result;
}

uint64_t FilePath::FilePath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFAllocator *v5;
  CFStringRef v6;
  const __CFString *v7;
  const __CFURL *v8;

  *(_DWORD *)(a1 + 1028) = 0;
  *(_DWORD *)(a1 + 1028) = *(_DWORD *)(a2 + 1028);
  *(_DWORD *)(a1 + 1032) = *(_DWORD *)(a2 + 1032);
  *(_BYTE *)a1 = 0;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)(a2 + 1));
  v7 = CFStringCreateWithFormat(v5, 0, CFSTR("%@%@"), v6, a3);
  if (v6)
    CFRelease(v6);
  if (v7)
  {
    v8 = CFURLCreateWithFileSystemPath(v5, v7, kCFURLPOSIXPathStyle, 0);
    CFRelease(v7);
    if (v8)
    {
      *(_BYTE *)a1 = CFURLGetFileSystemRepresentation(v8, 1u, (UInt8 *)(a1 + 1), 1024);
      CFRelease(v8);
    }
  }
  return a1;
}

char *TracerData::set(TracerData *this, int a2, CFTypeRef cf, const char *a4, int a5, const char *a6)
{
  const void *v11;
  CFTypeRef v12;
  char *result;

  *((_DWORD *)this + 2) = a2;
  v11 = (const void *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v11)
    CFRelease(v11);
  if (cf)
    v12 = CFRetain(cf);
  else
    v12 = 0;
  *((_QWORD *)this + 2) = v12;
  *((_QWORD *)this + 3) = a4;
  *((_DWORD *)this + 8) = a5;
  free(*((void **)this + 5));
  if (a6)
    result = strdup(a6);
  else
    result = 0;
  *((_QWORD *)this + 5) = result;
  return result;
}

void FilePathStorage<unsigned char>::mkParentDirs(const void *a1, uint64_t a2, uint64_t a3, int *a4)
{
  const __CFAllocator *v8;
  const __CFURL *PathComponent;
  mode_t v10;
  int v11;
  int v12;
  int v13;
  mode_t v14;
  char v15;
  char v16[1031];
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v8 = CFGetAllocator(a1);
  PathComponent = CFURLCreateCopyDeletingLastPathComponent(v8, (CFURLRef)a1);
  FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v15, PathComponent, a2, a3, 0);
  if (v17)
    v10 = 448;
  else
    v10 = 493;
  v11 = mkdir(v16, v10);
  v12 = 0;
  if ((v11 & 0x80000000) == 0)
  {
LABEL_5:
    *a4 = v12;
    goto LABEL_6;
  }
  v13 = *__error();
  *a4 = v13;
  if (v13 == 2)
  {
    FilePathStorage<unsigned char>::mkParentDirs(PathComponent, a2, a3, a4);
    if (v17)
      v14 = 448;
    else
      v14 = 493;
    if (mkdir(v16, v14) < 0)
      v12 = *__error();
    else
      v12 = 0;
    goto LABEL_5;
  }
LABEL_6:
  if (PathComponent)
    CFRelease(PathComponent);
}

uint64_t ___ZN17DiskCookieStorage14writeCompletedERK12FilePathStatPK13MemoryCookies_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 847;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN17DiskCookieStorage31syncStorageWithCompletionLockedEhU13block_pointerFvvE_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 982;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN17DiskCookieStorage31syncStorageWithCompletionLockedEhU13block_pointerFvvE_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 949;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void __Block_byref_object_copy__10157(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__10158(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t ___ZN17DiskCookieStorage31deleteAllCookiesSinceDateLockedEPK8__CFDateU13block_pointerFvP7NSArrayE_block_invoke(uint64_t result, CompactCookieHeader *a2)
{
  uint64_t v3;
  _QWORD *v4;
  double v5;
  uint64_t v6;
  MemoryCookies *v7;
  MemoryCookies *v8;
  MemoryCookies *v9;

  if (a2)
  {
    v3 = result;
    v4 = *(_QWORD **)(result + 40);
    v5 = 0.0;
    if (*(_DWORD *)a2 >= 0x38u)
      v5 = floor(*((double *)a2 + 6));
    if (v5 >= *(double *)(result + 48))
    {
      v6 = v4[38];
      if (v6)
        DiskCookieStorage::Journal::record(v6, 1, (const UInt8 *)a2);
      v7 = (MemoryCookies *)v4[37];
      if (v7)
        MemoryCookies::deleteCookie(v7, a2);
      v8 = (MemoryCookies *)v4[36];
      if (v8)
        MemoryCookies::deleteCookie(v8, a2);
      v9 = (MemoryCookies *)v4[35];
      if (v9)
        MemoryCookies::deleteCookie(v9, a2);
      if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 40))
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 40) = objc_alloc_init(MEMORY[0x1E0C99DE8]);
      return objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 40), "addObject:", -[NSHTTPCookie _initWithHeader:]([NSHTTPCookie alloc], "_initWithHeader:", a2));
    }
  }
  return result;
}

uint64_t ___ZN17DiskCookieStorage10initializeEPK13MemoryCookies_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 255;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void DiskCookieStorage::~DiskCookieStorage(DiskCookieStorage *this)
{
  __CFNotificationCenter *DarwinNotifyCenter;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  const void *v9;

  *(_QWORD *)this = off_1E14E85A8;
  *((_QWORD *)this + 3) = &unk_1E14E8690;
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  if (DarwinNotifyCenter)
    CFNotificationCenterRemoveEveryObserver(DarwinNotifyCenter, this);
  v3 = *((_QWORD *)this + 35);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 36);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 37);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 9);
  if (v6)
    MEMORY[0x186DB748C](v6, 0x1000C4048165BC6);
  *((_QWORD *)this + 9) = 0;
  v7 = *((_QWORD *)this + 38);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = *((_QWORD *)this + 10);
  if (v8)
    dispatch_release(v8);
  v9 = (const void *)*((_QWORD *)this + 41);
  if (v9)
    CFRelease(v9);
  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(this);
}

void sub_1840A47E8(_Unwind_Exception *a1)
{
  PrivateHTTPCookieStorage *v1;

  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN17DiskCookieStorage18requiresJournalingEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1135;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t CFNetworkTrust::strictEvaluate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7;

  v7 = 0;
  if (MEMORY[0x186DB7078](*(_QWORD *)(a1 + 8), &v7))
    return 4294957494;
  else
    return CFNetworkTrust::processStrictEvaluateResult(a1, a2, a3, v7);
}

uint64_t CFNetworkTrust::errorForEvaluationFalure(CFNetworkTrust *this)
{
  int v1;
  int v2;
  int v3;
  unsigned int v4;

  if ((*((_BYTE *)this + 32) & 0x20) != 0)
    return *((unsigned int *)this + 10);
  if ((*((_BYTE *)this + 32) & 0x10) != 0)
    return *((unsigned int *)this + 9);
  if (*((char *)this + 32) < 0)
    v1 = -9815;
  else
    v1 = -9807;
  if ((*((_BYTE *)this + 32) & 0x40) != 0)
    v2 = -9812;
  else
    v2 = v1;
  if ((*((_BYTE *)this + 32) & 4) != 0)
    v3 = -9814;
  else
    v3 = v2;
  if ((*((_BYTE *)this + 32) & 2) != 0)
    v4 = -9843;
  else
    v4 = v3;
  if ((*((_BYTE *)this + 32) & 1) != 0)
    return 4294957483;
  else
    return v4;
}

void *BundleUtilities::effectiveBundleID(BundleUtilities *this, CFDataRef theData, CFTypeRef cf)
{
  double v6;
  __int128 *v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  void *result;
  __CFBundle *MainBundle;
  __CFBundle *v13;
  CFStringRef Identifier;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(uint64_t);
  void *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  *(_QWORD *)this = 0;
  if (theData && (unint64_t)CFDataGetLength(theData) >= 0x20)
  {
    CFDataGetBytePtr(theData);
    v22 = 0;
    gotLoadHelper_x8__CPCopyBundleIdentifierAndTeamFromAuditToken(v6);
    if (*(_QWORD *)(v8 + 560))
    {
      v9 = v7[1];
      v20 = *v7;
      v21 = v9;
      CPCopyBundleIdentifierAndTeamFromAuditToken_delayInitStub(*(double *)&v20);
      v10 = v22;
    }
    else
    {
      v10 = 0;
    }
    v15 = MEMORY[0x1E0C809B0];
    v16 = 3221225472;
    v17 = ___ZN15BundleUtilities17effectiveBundleIDEPK8__CFDataPK10__CFStringb_block_invoke;
    v18 = &__block_descriptor_40_e5_v8__0l;
    v19 = v10;
  }
  if (cf)
  {
    result = (void *)CFRetain(cf);
    *(_QWORD *)this = result;
    if (result)
      return result;
  }
  else
  {
    *(_QWORD *)this = 0;
  }
  MainBundle = CFBundleGetMainBundle();
  result = (void *)CFBundleGetIdentifier(MainBundle);
  if (result)
  {
    v13 = CFBundleGetMainBundle();
    Identifier = CFBundleGetIdentifier(v13);
    result = (void *)CFRetain(Identifier);
  }
  *(_QWORD *)this = result;
  return result;
}

void sub_1840A4A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  _QWORD *v12;

  a12(&a10);
  *v12 = 0;
  _Unwind_Resume(a1);
}

void ___ZN15BundleUtilities17effectiveBundleIDEPK8__CFDataPK10__CFStringb_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

uint64_t _CFNetworkHTTPConnectionCacheGetLimit(int a1)
{
  unsigned int *v2;
  uint64_t result;

  if (mutableGlobalLimits(void)::sOnce != -1)
    dispatch_once(&mutableGlobalLimits(void)::sOnce, &__block_literal_global_10_10234);
  v2 = (unsigned int *)mutableGlobalLimits(void)::gLimits;
  switch(a1)
  {
    case 0:
      goto LABEL_14;
    case 1:
      v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 4);
      goto LABEL_14;
    case 2:
      v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 8);
      goto LABEL_14;
    case 3:
      v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 12);
      goto LABEL_14;
    case 4:
      v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 16);
      goto LABEL_14;
    case 5:
      v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 20);
      goto LABEL_14;
    case 6:
      v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 24);
      goto LABEL_14;
    case 7:
      v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 28);
      goto LABEL_14;
    case 8:
      v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 32);
      goto LABEL_14;
    case 9:
      v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 36);
LABEL_14:
      result = *v2;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

BOOL URLCredentialClientCertificate::equals(URLCredentialClientCertificate *this, const CFObject *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  if (*((_DWORD *)this + 8) != *((_DWORD *)a2 + 8))
    return 0;
  v4 = (*(uint64_t (**)(URLCredentialClientCertificate *))(*(_QWORD *)this + 8))(this);
  if (v4 != (*(uint64_t (**)(const CFObject *))(*(_QWORD *)a2 + 8))(a2)
    || *((_DWORD *)this + 9) != *((_DWORD *)a2 + 9))
  {
    return 0;
  }
  v5 = *((_QWORD *)this + 9);
  v6 = *((_QWORD *)a2 + 9);
  if (!(v5 | v6))
    return 1;
  return (v5 == 0) == (v6 == 0) && CFEqual((CFTypeRef)v5, (CFTypeRef)v6) != 0;
}

CFStringRef URLCredentialClientCertificate::copyDebugDesc(URLCredentialClientCertificate *this)
{
  char *v2;
  const __CFAllocator *v3;

  v2 = (char *)this - 16;
  v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLCredential %p>{ identity = %@, certificate array = %@, persistence = %d}"), v2, *((_QWORD *)this + 9), *((_QWORD *)this + 8), *((unsigned int *)this + 9));
}

uint64_t URLCredentialClientCertificate::copy(URLCredentialClientCertificate *this)
{
  uint64_t Instance;

  CFGetAllocator((char *)this - 16);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 48) = 3;
  *(_QWORD *)(Instance + 24) = &unk_1E14EF178;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EF0E8;
  *(_QWORD *)(Instance + 40) = &unk_1E14EF1A8;
  URLCredentialClientCertificate::initialize(Instance + 16, *((CFTypeRef *)this + 9), *((const __CFArray **)this + 8), *((_DWORD *)this + 9));
  return Instance;
}

BOOL URLCredentialClientCertificate::initializeFromPropertyList(URLCredentialClientCertificate *this, CFDictionaryRef *a2)
{
  _BOOL8 result;
  CFTypeID TypeID;
  void *v6;

  result = URLCredential::initializeFromPropertyList((uint64_t)this, a2);
  if (result)
  {
    v6 = 0;
    TypeID = CFArrayGetTypeID();
    DeserializableArchive::decant(a2, CFSTR("certs"), TypeID, (CFErrorRef *)&v6);
    *((_QWORD *)this + 8) = v6;
    return 1;
  }
  return result;
}

uint64_t URLCredentialClientCertificate::serializeToPropertyList(const __CFArray **this, SerializableArchive **a2)
{
  URLCredential::serializeToPropertyList((URLCredential *)this, a2);
  SerializableArchive::add((CFTypeRef *)a2, CFSTR("certs"), this[8]);
  return 1;
}

uint64_t URLCredentialClientCertificate::calcHash(URLCredentialClientCertificate *this, uint64_t a2)
{
  return a2;
}

CFStringRef URLCredentialClientCertificate::copyStorageNameForCredentialType(URLCredentialClientCertificate *this)
{
  __SecIdentity *v2;
  const __CFArray *v3;
  __SecCertificate *ValueAtIndex;
  CFStringRef v5;
  SecCertificateRef certificateRef;

  certificateRef = 0;
  v2 = (__SecIdentity *)*((_QWORD *)this + 9);
  if (!v2 || SecIdentityCopyCertificate(v2, &certificateRef))
  {
    v3 = (const __CFArray *)*((_QWORD *)this + 8);
    if (!v3)
      return 0;
    ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v3, 0);
    certificateRef = ValueAtIndex;
    if (!ValueAtIndex)
      return 0;
    CFRetain(ValueAtIndex);
  }
  if (!certificateRef)
    return 0;
  v5 = SecCertificateCopySubjectSummary(certificateRef);
  if (certificateRef)
    CFRelease(certificateRef);
  return v5;
}

uint64_t URLCredentialClientCertificate::getCertificateArray(URLCredentialClientCertificate *this)
{
  return *((_QWORD *)this + 8);
}

uint64_t URLCredentialClientCertificate::getCertificateIdentity(URLCredentialClientCertificate *this)
{
  return *((_QWORD *)this + 9);
}

void `non-virtual thunk to'URLCredentialClientCertificate::~URLCredentialClientCertificate(URLCredentialClientCertificate *this)
{
  URLCredentialClientCertificate::~URLCredentialClientCertificate((URLCredentialClientCertificate *)((char *)this - 8));
}

{
  URLCredentialClientCertificate::~URLCredentialClientCertificate((URLCredentialClientCertificate *)((char *)this - 8));
}

{
  URLCredentialClientCertificate::~URLCredentialClientCertificate((URLCredentialClientCertificate *)((char *)this - 24));
}

{
  URLCredentialClientCertificate::~URLCredentialClientCertificate((URLCredentialClientCertificate *)((char *)this - 24));
}

BOOL `non-virtual thunk to'URLCredentialClientCertificate::initializeFromPropertyList(URLCredentialClientCertificate *this, CFDictionaryRef *a2)
{
  return URLCredentialClientCertificate::initializeFromPropertyList((URLCredentialClientCertificate *)((char *)this - 8), a2);
}

uint64_t `non-virtual thunk to'URLCredentialClientCertificate::serializeToPropertyList(const __CFArray **this, SerializableArchive **a2)
{
  URLCredential::serializeToPropertyList((URLCredential *)(this - 1), a2);
  SerializableArchive::add((CFTypeRef *)a2, CFSTR("certs"), this[7]);
  return 1;
}

void URLCredentialClientCertificate::~URLCredentialClientCertificate(URLCredentialClientCertificate *this)
{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = &off_1E14EF0E8;
  *((_QWORD *)this + 1) = &unk_1E14EF178;
  *((_QWORD *)this + 3) = &unk_1E14EF1A8;
  v2 = (const void *)*((_QWORD *)this + 9);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 8);
  if (v3)
    CFRelease(v3);
  URLCredential::~URLCredential(this);
}

void sub_1840A4F88(_Unwind_Exception *a1)
{
  URLCredential *v1;

  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t URLCredentialClientCertificate::initialize(uint64_t a1, CFTypeRef cf, const __CFArray *MutableCopy, int a4)
{
  const void *ValueAtIndex;
  const __CFAllocator *v8;

  *(_DWORD *)(a1 + 36) = a4;
  if (!cf)
    return 0;
  *(_QWORD *)(a1 + 72) = CFRetain(cf);
  if (MutableCopy)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, 0);
    if (CFEqual(ValueAtIndex, cf))
    {
      v8 = CFGetAllocator((CFTypeRef)(a1 - 16));
      MutableCopy = CFArrayCreateMutableCopy(v8, 0, MutableCopy);
      CFArrayRemoveValueAtIndex(MutableCopy, 0);
    }
    else
    {
      MutableCopy = (const __CFArray *)CFRetain(MutableCopy);
    }
  }
  *(_QWORD *)(a1 + 64) = MutableCopy;
  return 1;
}

unint64_t URLCredentialInternetPassword::equals(URLCredentialInternetPassword *this, const CFObject *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t result;
  const __CFDictionary *v8;
  unint64_t v9;
  unint64_t v10;

  if (*((_DWORD *)this + 8) != *((_DWORD *)a2 + 8))
    return 0;
  v4 = (*(uint64_t (**)(URLCredentialInternetPassword *))(*(_QWORD *)this + 8))(this);
  if (v4 != (*(uint64_t (**)(const CFObject *))(*(_QWORD *)a2 + 8))(a2)
    || *((_DWORD *)this + 9) != *((_DWORD *)a2 + 9))
  {
    return 0;
  }
  v5 = *((_QWORD *)this + 8);
  v6 = *((_QWORD *)a2 + 8);
  if (!(v5 | v6))
    goto LABEL_9;
  if ((v5 == 0) != (v6 == 0))
    return 0;
  result = CFEqual((CFTypeRef)v5, (CFTypeRef)v6);
  if ((_DWORD)result)
  {
LABEL_9:
    v8 = (const __CFDictionary *)*((_QWORD *)this + 10);
    if (v8)
    {
LABEL_15:
      if (!URLCredentialInternetPassword::containsSWCACreator(v8)
        || (result = (unint64_t)URLCredentialInternetPassword::containsSWCACreator(*((const __CFDictionary **)a2
                                                                                          + 10)),
            (_DWORD)result))
      {
        if (!URLCredentialInternetPassword::containsSWCACreator(*((const __CFDictionary **)a2 + 10)))
          return 1;
        result = (unint64_t)URLCredentialInternetPassword::containsSWCACreator(*((const __CFDictionary **)this
                                                                                      + 10));
        if ((_DWORD)result)
          return 1;
      }
      return result;
    }
    v9 = *((_QWORD *)this + 9);
    v10 = *((_QWORD *)a2 + 9);
    if (!(v9 | v10))
    {
      v8 = 0;
      goto LABEL_15;
    }
    if ((v9 == 0) != (v10 == 0))
      return 0;
    result = CFEqual((CFTypeRef)v9, (CFTypeRef)v10);
    if ((_DWORD)result)
    {
      v8 = (const __CFDictionary *)*((_QWORD *)this + 10);
      goto LABEL_15;
    }
  }
  return result;
}

CFStringRef URLCredentialInternetPassword::copyDebugDesc(URLCredentialInternetPassword *this)
{
  char *v2;
  const __CFAllocator *v3;

  v2 = (char *)this - 16;
  v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLCredential %p>{username = %@, password = %@, persistence = %d, attributes = %@, identifier = %@}"), v2, *((_QWORD *)this + 8), *((_QWORD *)this + 9), *((unsigned int *)this + 9), *((_QWORD *)this + 10), *((_QWORD *)this + 12));
}

uint64_t URLCredentialInternetPassword::copy(URLCredentialInternetPassword *this)
{
  uint64_t Instance;

  CFGetAllocator((char *)this - 16);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_QWORD *)(Instance + 112) = 0;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 48) = 0;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EECF8;
  *(_QWORD *)(Instance + 24) = &unk_1E14EEDA0;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_QWORD *)(Instance + 40) = &unk_1E14EEDD0;
  *(_BYTE *)(Instance + 104) = 0;
  URLCredentialInternetPassword::initialize(Instance + 16, *((const __CFString **)this + 8), *((const __CFString **)this + 9), *((_DWORD *)this + 9), *((const __CFDictionary **)this + 10));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(Instance + 16) + 88))(Instance + 16, *((_QWORD *)this + 12));
  return Instance;
}

BOOL URLCredentialInternetPassword::initializeFromPropertyList(URLCredentialInternetPassword *this, CFDictionaryRef *a2)
{
  _BOOL8 result;
  const void *Value;
  const void *v6;
  CFTypeID TypeID;
  const void *v8;
  void *v9;

  result = URLCredential::initializeFromPropertyList((uint64_t)this, a2);
  if (result)
  {
    Value = CFDictionaryGetValue(*a2, CFSTR("username"));
    if (Value)
      Value = CFRetain(Value);
    *((_QWORD *)this + 8) = Value;
    v6 = CFDictionaryGetValue(*a2, CFSTR("password"));
    if (v6)
      v6 = CFRetain(v6);
    *((_QWORD *)this + 9) = v6;
    v9 = 0;
    TypeID = CFDictionaryGetTypeID();
    DeserializableArchive::decant(a2, CFSTR("attributes"), TypeID, (CFErrorRef *)&v9);
    *((_QWORD *)this + 10) = v9;
    v8 = CFDictionaryGetValue(*a2, CFSTR("identifier"));
    if (v8)
      v8 = CFRetain(v8);
    *((_QWORD *)this + 12) = v8;
    return 1;
  }
  return result;
}

uint64_t URLCredentialInternetPassword::serializeToPropertyList(CFDictionaryRef *this, SerializableArchive **a2)
{
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;

  URLCredential::serializeToPropertyList((URLCredential *)this, a2);
  v4 = this[8];
  SerializableArchive::assertEmpty(*a2, CFSTR("username"));
  if (v4)
    CFDictionarySetValue(*a2, CFSTR("username"), v4);
  v5 = this[9];
  SerializableArchive::assertEmpty(*a2, CFSTR("password"));
  if (v5)
    CFDictionarySetValue(*a2, CFSTR("password"), v5);
  SerializableArchive::add((CFTypeRef *)a2, CFSTR("attributes"), this[10]);
  v6 = this[12];
  SerializableArchive::assertEmpty(*a2, CFSTR("identifier"));
  if (v6)
    CFDictionarySetValue(*a2, CFSTR("identifier"), v6);
  return 1;
}

uint64_t URLCredentialInternetPassword::setUseSystemKeychain(uint64_t this, char a2)
{
  *(_BYTE *)(this + 88) = a2;
  return this;
}

CFTypeRef URLCredentialInternetPassword::setIdentifier(URLCredentialInternetPassword *this, CFTypeRef cf)
{
  CFTypeRef result;

  if (cf)
    result = CFRetain(cf);
  else
    result = 0;
  *((_QWORD *)this + 12) = result;
  return result;
}

CFHashCode URLCredentialInternetPassword::calcHash(URLCredentialInternetPassword *this, CFHashCode a2)
{
  CFHashCode v2;
  const void *v4;
  const void *v5;

  v2 = a2;
  v4 = (const void *)*((_QWORD *)this + 8);
  if (v4)
    v2 = CFHash(v4) ^ a2;
  v5 = (const void *)*((_QWORD *)this + 9);
  if (v5)
    v2 ^= CFHash(v5);
  return v2;
}

CFTypeRef URLCredentialInternetPassword::copyStorageNameForCredentialType(URLCredentialInternetPassword *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 8);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t URLCredentialInternetPassword::getUserName(URLCredentialInternetPassword *this)
{
  CFTypeID TypeID;

  if (*((_QWORD *)this + 8) && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 8))))
    return *((_QWORD *)this + 8);
  else
    return 0;
}

uint64_t URLCredentialInternetPassword::getPassword(URLCredentialInternetPassword *this)
{
  CFTypeID TypeID;

  if (*((_QWORD *)this + 9) && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 9))))
    return *((_QWORD *)this + 9);
  else
    return 0;
}

CFStringRef URLCredentialInternetPassword::copyPassword(URLCredentialInternetPassword *this)
{
  const __CFAllocator *v2;
  __CFDictionary *MutableCopy;
  __CFDictionary *v4;
  const void *v5;
  const void *v6;
  const void *Value;
  CFStringRef v8;
  const __CFAllocator *v9;
  const UInt8 *BytePtr;
  CFIndex Length;
  const __CFAllocator *v12;
  CFDataRef theData;

  if (!*((_QWORD *)this + 9))
  {
    if (*((_QWORD *)this + 10))
    {
      v2 = CFGetAllocator((char *)this - 16);
      MutableCopy = CFDictionaryCreateMutableCopy(v2, 0, *((CFDictionaryRef *)this + 10));
      if (MutableCopy)
      {
        v4 = MutableCopy;
        v5 = (const void *)*MEMORY[0x1E0C9AE50];
        CFDictionarySetValue(MutableCopy, (const void *)*MEMORY[0x1E0CD7018], (const void *)*MEMORY[0x1E0C9AE50]);
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E0CD6C98], (const void *)*MEMORY[0x1E0CD6CB8]);
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E0CD6F30], (const void *)*MEMORY[0x1E0CD6F40]);
        if (*((_BYTE *)this + 88))
          CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E0CD70C0], v5);
        if (*((_QWORD *)this + 12))
        {
          v6 = (const void *)*MEMORY[0x1E0CD6B50];
          Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 10), (const void *)*MEMORY[0x1E0CD6B50]);
          if (Value)
          {
            v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@ (%@)"), Value, *((_QWORD *)this + 12));
            CFDictionarySetValue(v4, v6, v8);
            CFRelease(v8);
          }
        }
        theData = 0;
        if (!(*((unsigned int (**)(__CFDictionary *, CFDataRef *))&_gFwStubs + 1))(v4, &theData) && theData)
        {
          v9 = CFGetAllocator((char *)this - 16);
          BytePtr = CFDataGetBytePtr(theData);
          Length = CFDataGetLength(theData);
          *((_QWORD *)this + 9) = CFStringCreateWithBytes(v9, BytePtr, Length, 0x8000100u, 0);
          if (theData)
            CFRelease(theData);
        }
        CFRelease(v4);
      }
    }
    if (!*((_QWORD *)this + 9))
      return 0;
  }
  v12 = CFGetAllocator((char *)this - 16);
  return CFStringCreateCopy(v12, *((CFStringRef *)this + 9));
}

BOOL URLCredentialInternetPassword::containsPassword(URLCredentialInternetPassword *this)
{
  return *((_QWORD *)this + 10) || *((_QWORD *)this + 9) != 0;
}

void `non-virtual thunk to'URLCredentialInternetPassword::~URLCredentialInternetPassword(URLCredentialInternetPassword *this)
{
  URLCredentialInternetPassword::~URLCredentialInternetPassword((URLCredentialInternetPassword *)((char *)this - 8));
}

{
  URLCredentialInternetPassword::~URLCredentialInternetPassword((URLCredentialInternetPassword *)((char *)this - 8));
}

{
  URLCredentialInternetPassword::~URLCredentialInternetPassword((URLCredentialInternetPassword *)((char *)this - 24));
}

{
  URLCredentialInternetPassword::~URLCredentialInternetPassword((URLCredentialInternetPassword *)((char *)this - 24));
}

BOOL `non-virtual thunk to'URLCredentialInternetPassword::initializeFromPropertyList(URLCredentialInternetPassword *this, CFDictionaryRef *a2)
{
  return URLCredentialInternetPassword::initializeFromPropertyList((URLCredentialInternetPassword *)((char *)this - 8), a2);
}

uint64_t `non-virtual thunk to'URLCredentialInternetPassword::serializeToPropertyList(CFDictionaryRef *this, SerializableArchive **a2)
{
  URLCredentialInternetPassword::serializeToPropertyList(this - 1, a2);
  return 1;
}

const __CFDictionary *URLCredentialInternetPassword::containsSWCACreator(const __CFDictionary *this)
{
  int valuePtr;

  if (this)
  {
    this = (const __CFDictionary *)CFDictionaryGetValue(this, (const void *)*MEMORY[0x1E0CD6998]);
    if (this)
    {
      valuePtr = 0;
      return (const __CFDictionary *)(CFNumberGetValue(this, kCFNumberSInt32Type, &valuePtr) && valuePtr == 1937204065);
    }
  }
  return this;
}

void ConditionalConnectionSIMScheduler::ConditionalConnectionSIMScheduler(__CFDate const*,__CFNumber const*,__CFNumber const*,NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(void),void({block_pointer})(void))::$_0::__invoke(dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
}

uint64_t ConditionalConnectionSIMScheduler::ConditionalConnectionSIMScheduler(uint64_t a1, uint64_t a2, const __CFNumber *a3, CFNumberRef number, NSObject *a5, const void *a6, const void *a7)
{
  uint64_t *v13;
  uint64_t *v14;
  void *v15;
  uint64_t *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v27;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  v13 = (uint64_t *)(a1 + 56);
  *(_OWORD *)(a1 + 72) = 0u;
  v14 = (uint64_t *)(a1 + 72);
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = _ZN33ConditionalConnectionSIMScheduler6_queueMUlPU28objcproto17OS_dispatch_queue8NSObjectE_8__invokeES2_;
  *(_OWORD *)(a1 + 32) = 0u;
  v15 = (void *)(a1 + 32);
  v16 = (uint64_t *)(a1 + 40);
  *(_OWORD *)(a1 + 16) = 0u;
  *(_WORD *)(a1 + 48) = 0;
  if (!number || (CFNumberGetValue(number, kCFNumberSInt64Type, v16), *v16 <= 3599))
    *v16 = 3600;
  if (a3)
    CFNumberGetValue(a3, kCFNumberSInt64Type, v15);
  if (a2)
    *(double *)(a1 + 24) = MEMORY[0x186DB5F80](a2);
  SmartBlockWithArgs<>::SmartBlockWithArgs((uint64_t *)&v27, a6);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v13, &v27);
  v17 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
  if (*((_QWORD *)&v27 + 1))
  {
    v18 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = *v13;
  if (*v13)
  {
    *(_QWORD *)(v20 + 8) = BlockHolderVar<>::invoke_normal;
    *(_QWORD *)(v20 + 16) = 0;
  }
  SmartBlockWithArgs<>::SmartBlockWithArgs((uint64_t *)&v27, a7);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v14, &v27);
  v21 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
  if (*((_QWORD *)&v27 + 1))
  {
    v22 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = *v14;
  if (*v14)
  {
    *(_QWORD *)(v24 + 8) = BlockHolderVar<>::invoke_normal;
    *(_QWORD *)(v24 + 16) = 0;
  }
  if (!a5)
    __assert_rtn("ConditionalConnectionSIMScheduler", "ConditionalConnectionSIMSupport.cpp", 38, "queue");
  dispatch_retain(a5);
  v25 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 88) = a5;
  if (v25)
    (*(void (**)(void))(a1 + 96))();
  *(_QWORD *)(a1 + 96) = ConditionalConnectionSIMScheduler::ConditionalConnectionSIMScheduler(__CFDate const*,__CFNumber const*,__CFNumber const*,NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(void),void({block_pointer})(void))::$_0::__invoke;
  return a1;
}

void sub_1840A59EC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  std::__shared_weak_count *v6;

  v5 = *(_QWORD *)(v1 + 88);
  *(_QWORD *)(v1 + 88) = 0;
  if (v5)
    (*(void (**)(void))(v1 + 96))();
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  v6 = *(std::__shared_weak_count **)(v1 + 8);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
  _Unwind_Resume(a1);
}

void ConditionalConnectionSIMScheduler::cancel(ConditionalConnectionSIMScheduler *this)
{
  NSObject *v2;

  *((_BYTE *)this + 49) = 1;
  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 2));
    *((_QWORD *)this + 2) = 0;
  }
}

void ConditionalConnectionSIMScheduler::start(ConditionalConnectionSIMScheduler *this)
{
  uint64_t v2;
  dispatch_time_t v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  dispatch_time_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_weak_owners;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  unint64_t v19;
  uint64_t v20;
  _QWORD v21[5];
  std::__shared_weak_count *v22;
  timespec __y;

  if (*((_BYTE *)this + 48))
    return;
  *((_BYTE *)this + 48) = 1;
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    v3 = dispatch_time(0, 1000000000 * v2);
LABEL_11:
    v9 = v3;
    goto LABEL_12;
  }
  v4 = *((double *)this + 3);
  if (v4 != 0.0)
  {
    v5 = v4 - CFAbsoluteTimeGetCurrent();
    v6 = *((double *)this + 3);
    if (v5 < 0.0)
    {
      v6 = v6 - v5;
      *((double *)this + 3) = v6;
      *((_QWORD *)this + 5) += (int)v5;
    }
    __y.tv_sec = 0;
    v7 = modf(v6, (long double *)&__y.tv_sec);
    v8 = *(double *)&__y.tv_sec;
    if (v7 < 0.0)
    {
      v8 = *(double *)&__y.tv_sec + -1.0;
      v7 = v7 + 1.0;
    }
    __y.tv_sec = (uint64_t)(*MEMORY[0x1E0C9ADF8] + v8);
    __y.tv_nsec = (uint64_t)(v7 * 1000000000.0 + 0.5);
    v3 = dispatch_walltime(&__y, 0);
    goto LABEL_11;
  }
  v9 = 0;
LABEL_12:
  if (*((uint64_t *)this + 5) >= 1)
  {
    v10 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
    if (v10 && (v11 = *(_QWORD *)this, (v12 = std::__shared_weak_count::lock(v10)) != 0))
    {
      v13 = v12;
      p_shared_weak_owners = (unint64_t *)&v12->__shared_weak_owners_;
      do
        v15 = __ldxr(p_shared_weak_owners);
      while (__stxr(v15 + 1, p_shared_weak_owners));
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v13);
      }
      v18 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)this + 11));
      *((_QWORD *)this + 2) = v18;
      v21[0] = MEMORY[0x1E0C809B0];
      v21[1] = 3321888768;
      v21[2] = ___ZN33ConditionalConnectionSIMScheduler5startEv_block_invoke;
      v21[3] = &__block_descriptor_48_e8_32c58_ZTSNSt3__18weak_ptrI33ConditionalConnectionSIMSchedulerEE_e5_v8__0l;
      v21[4] = v11;
      v22 = v13;
      do
        v19 = __ldxr(p_shared_weak_owners);
      while (__stxr(v19 + 1, p_shared_weak_owners));
      dispatch_source_set_event_handler(v18, v21);
      dispatch_source_set_timer(*((dispatch_source_t *)this + 2), v9, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      dispatch_activate(*((dispatch_object_t *)this + 2));
      if (v22)
        std::__shared_weak_count::__release_weak(v22);
      std::__shared_weak_count::__release_weak(v13);
    }
    else
    {
      v20 = std::__throw_bad_weak_ptr[abi:nn180100]();
      ___ZN33ConditionalConnectionSIMScheduler5startEv_block_invoke(v20);
    }
  }
}

void ___ZN33ConditionalConnectionSIMScheduler5startEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  NSObject *v10;
  dispatch_time_t v11;
  uint64_t v12;
  void (*v13)(_QWORD *);
  uint64_t v14;
  _QWORD *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  _QWORD v18[5];
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    v21 = v3;
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      v20 = v5;
      if (v5)
      {
        v6 = *(NSObject **)(v5 + 16);
        if (v6)
        {
          v18[0] = MEMORY[0x1E0C809B0];
          v18[1] = 3321888768;
          v18[2] = ___ZN33ConditionalConnectionSIMScheduler5startEv_block_invoke_2;
          v18[3] = &__block_descriptor_48_e8_32c58_ZTSNSt3__18weak_ptrI33ConditionalConnectionSIMSchedulerEE_e5_v8__0l;
          v7 = *(std::__shared_weak_count **)(a1 + 40);
          v18[4] = v5;
          v19 = v7;
          if (v7)
          {
            p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
            do
              v9 = __ldxr(p_shared_weak_owners);
            while (__stxr(v9 + 1, p_shared_weak_owners));
          }
          dispatch_source_set_event_handler(v6, v18);
          v10 = *(NSObject **)(v5 + 16);
          v11 = dispatch_time(0x8000000000000000, 1000000000 * *(_QWORD *)(v5 + 40));
          dispatch_source_set_timer(v10, v11, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
          if (!*(_BYTE *)(v5 + 49))
          {
            v12 = *(_QWORD *)(v5 + 56);
            if (v12)
            {
              v13 = *(void (**)(_QWORD *))(v12 + 8);
              v14 = *(_QWORD *)(v12 + 16);
              v15 = (_QWORD *)(v12 + (v14 >> 1));
              if ((v14 & 1) != 0)
                v13 = *(void (**)(_QWORD *))(*v15 + v13);
              v13(v15);
            }
          }
          if (v19)
            std::__shared_weak_count::__release_weak(v19);
        }
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1840A5DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15)
{
  if (a14)
    std::__shared_weak_count::__release_weak(a14);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c58_ZTSNSt3__18weak_ptrI33ConditionalConnectionSIMSchedulerEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c58_ZTSNSt3__18weak_ptrI33ConditionalConnectionSIMSchedulerEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void ___ZN33ConditionalConnectionSIMScheduler5startEv_block_invoke_2(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(_QWORD *);
  uint64_t v8;
  _QWORD *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        if (!*(_BYTE *)(v5 + 49))
        {
          v6 = *(_QWORD *)(v5 + 72);
          if (v6)
          {
            v7 = *(void (**)(_QWORD *))(v6 + 8);
            v8 = *(_QWORD *)(v6 + 16);
            v9 = (_QWORD *)(v6 + (v8 >> 1));
            if ((v8 & 1) != 0)
              v7 = *(void (**)(_QWORD *))(*v9 + v7);
            v7(v9);
          }
        }
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1840A5ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t URLCredentialKerberosTicket::equals(URLCredentialKerberosTicket *this, const CFObject *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  uint64_t result;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;

  if (*((_DWORD *)this + 8) != *((_DWORD *)a2 + 8))
    return 0;
  v4 = (*(uint64_t (**)(URLCredentialKerberosTicket *))(*(_QWORD *)this + 8))(this);
  if (v4 != (*(uint64_t (**)(const CFObject *))(*(_QWORD *)a2 + 8))(a2)
    || *((_DWORD *)this + 9) != *((_DWORD *)a2 + 9))
  {
    return 0;
  }
  v5 = (const void *)*((_QWORD *)this + 9);
  if (!v5
    || (v6 = (const void *)*((_QWORD *)a2 + 9)) == 0
    || CFEqual(v5, v6)
    || (v12 = (const void *)*((_QWORD *)this + 10)) == 0
    || (v13 = (const void *)*((_QWORD *)a2 + 10)) == 0
    || (result = CFEqual(v12, v13), (_DWORD)result))
  {
    v7 = (const void *)*((_QWORD *)this + 8);
    if (!v7 || (v8 = (const void *)*((_QWORD *)a2 + 8)) == 0 || (result = CFEqual(v7, v8), (_DWORD)result))
    {
      v10 = (const void *)*((_QWORD *)this + 11);
      v11 = (const void *)*((_QWORD *)a2 + 11);
      if (v10)
      {
        if (v11)
        {
          result = CFEqual(v10, v11);
          if (!(_DWORD)result)
            return result;
          return 1;
        }
      }
      else if (!v11)
      {
        return 1;
      }
      return 0;
    }
  }
  return result;
}

CFStringRef URLCredentialKerberosTicket::copyDebugDesc(URLCredentialKerberosTicket *this)
{
  char *v2;
  const __CFAllocator *v3;

  v2 = (char *)this - 16;
  v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLCredential %p>{userPrincipal = %@, hostPrincipal = %@, uuid = %@, kerberosFlags = %@, persistence = %d}"), v2, *((_QWORD *)this + 10), *((_QWORD *)this + 9), *((_QWORD *)this + 11), *((_QWORD *)this + 8), *((unsigned int *)this + 9));
}

uint64_t URLCredentialKerberosTicket::copy(URLCredentialKerberosTicket *this)
{
  uint64_t Instance;

  CFGetAllocator((char *)this - 16);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 48) = 2;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EE598;
  *(_QWORD *)(Instance + 24) = &unk_1E14EE640;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_QWORD *)(Instance + 40) = &unk_1E14EE670;
  *(_QWORD *)(Instance + 104) = 0;
  URLCredentialKerberosTicket::initialize((URLCredentialKerberosTicket *)(Instance + 16), *((const __CFString **)this + 10), *((const __CFString **)this + 9), *((const __CFDictionary **)this + 8), *((const __CFUUID **)this + 11));
  return Instance;
}

BOOL URLCredentialKerberosTicket::initializeFromPropertyList(URLCredentialKerberosTicket *this, CFDictionaryRef *a2)
{
  _BOOL8 result;
  CFTypeID TypeID;
  const void *Value;
  const void *v7;
  const void *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFAllocator *v11;
  void *v12;

  result = URLCredential::initializeFromPropertyList((uint64_t)this, a2);
  if (result)
  {
    v12 = 0;
    TypeID = CFDictionaryGetTypeID();
    DeserializableArchive::decant(a2, CFSTR("flags"), TypeID, (CFErrorRef *)&v12);
    *((_QWORD *)this + 8) = v12;
    Value = CFDictionaryGetValue(*a2, CFSTR("service"));
    if (Value)
      Value = CFRetain(Value);
    *((_QWORD *)this + 9) = Value;
    v7 = CFDictionaryGetValue(*a2, CFSTR("principle"));
    if (v7)
      v7 = CFRetain(v7);
    *((_QWORD *)this + 10) = v7;
    v8 = CFDictionaryGetValue(*a2, CFSTR("uuid"));
    if (v8 && (v9 = (const __CFString *)CFRetain(v8)) != 0)
    {
      v10 = v9;
      v11 = CFGetAllocator((char *)this - 16);
      *((_QWORD *)this + 11) = CFUUIDCreateFromString(v11, v10);
      CFRelease(v10);
    }
    else
    {
      *((_QWORD *)this + 11) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t URLCredentialKerberosTicket::serializeToPropertyList(CFDictionaryRef *this, SerializableArchive **a2)
{
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  const __CFAllocator *v6;
  CFStringRef v7;

  URLCredential::serializeToPropertyList((URLCredential *)this, a2);
  SerializableArchive::add((CFTypeRef *)a2, CFSTR("flags"), this[8]);
  v4 = this[9];
  SerializableArchive::assertEmpty(*a2, CFSTR("service"));
  if (v4)
    CFDictionarySetValue(*a2, CFSTR("service"), v4);
  v5 = this[10];
  SerializableArchive::assertEmpty(*a2, CFSTR("principle"));
  if (v5)
    CFDictionarySetValue(*a2, CFSTR("principle"), v5);
  if (this[11])
  {
    v6 = CFGetAllocator(this - 2);
    v7 = CFUUIDCreateString(v6, this[11]);
    SerializableArchive::assertEmpty(*a2, CFSTR("uuid"));
    if (v7)
    {
      CFDictionarySetValue(*a2, CFSTR("uuid"), v7);
      CFRelease(v7);
    }
  }
  else
  {
    SerializableArchive::assertEmpty(*a2, CFSTR("uuid"));
  }
  return 1;
}

CFHashCode URLCredentialKerberosTicket::calcHash(URLCredentialKerberosTicket *this, uint64_t a2)
{
  uint64_t v2;
  const void *v4;

  v2 = a2;
  v4 = (const void *)*((_QWORD *)this + 9);
  if (v4)
    return CFHash(v4) ^ a2;
  v4 = (const void *)*((_QWORD *)this + 11);
  if (v4)
    return CFHash(v4) ^ a2;
  return v2;
}

CFStringRef URLCredentialKerberosTicket::copyStorageNameForCredentialType(URLCredentialKerberosTicket *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@/%@%@"), *((_QWORD *)this + 10), *((_QWORD *)this + 9), *((_QWORD *)this + 11));
}

uint64_t URLCredentialKerberosTicket::getUserName(URLCredentialKerberosTicket *this)
{
  CFTypeID TypeID;

  if (*((_QWORD *)this + 10) && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 10))))
    return *((_QWORD *)this + 10);
  else
    return 0;
}

const __CFDictionary *URLCredentialKerberosTicket::getFlags(URLCredentialKerberosTicket *this)
{
  const __CFDictionary *result;
  const __CFString *Value;

  result = (const __CFDictionary *)*((_QWORD *)this + 8);
  if (result)
  {
    Value = (const __CFString *)CFDictionaryGetValue(result, CFSTR("kCFURLCredentialKerberosNoUIFlag"));
    if (Value)
      CFStringCompare(Value, CFSTR("TRUE"), 1uLL);
    result = (const __CFDictionary *)*((_QWORD *)this + 8);
    if (result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("kCFURLCredentialKerberosTicketAllowDelegation"));
      if (result)
        return (const __CFDictionary *)((CFStringCompare((CFStringRef)result, CFSTR("TRUE"), 1uLL) == kCFCompareEqualTo) << 15);
    }
  }
  return result;
}

uint64_t URLCredentialKerberosTicket::getUserPrincipal(URLCredentialKerberosTicket *this)
{
  CFTypeID TypeID;

  if (*((_QWORD *)this + 10) && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 10))))
    return *((_QWORD *)this + 10);
  else
    return 0;
}

uint64_t URLCredentialKerberosTicket::getServicePrincipal(URLCredentialKerberosTicket *this)
{
  CFTypeID TypeID;

  if (*((_QWORD *)this + 9) && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 9))))
    return *((_QWORD *)this + 9);
  else
    return 0;
}

uint64_t URLCredentialKerberosTicket::getUUID(URLCredentialKerberosTicket *this)
{
  CFTypeID v2;

  if (*((_QWORD *)this + 11) && (v2 = CFUUIDGetTypeID(), v2 == CFGetTypeID(*((CFTypeRef *)this + 11))))
    return *((_QWORD *)this + 11);
  else
    return 0;
}

void `non-virtual thunk to'URLCredentialKerberosTicket::~URLCredentialKerberosTicket(URLCredentialKerberosTicket *this)
{
  URLCredentialKerberosTicket::~URLCredentialKerberosTicket((URLCredentialKerberosTicket *)((char *)this - 8));
}

{
  URLCredentialKerberosTicket::~URLCredentialKerberosTicket((URLCredentialKerberosTicket *)((char *)this - 8));
}

{
  URLCredentialKerberosTicket::~URLCredentialKerberosTicket((URLCredentialKerberosTicket *)((char *)this - 24));
}

{
  URLCredentialKerberosTicket::~URLCredentialKerberosTicket((URLCredentialKerberosTicket *)((char *)this - 24));
}

BOOL `non-virtual thunk to'URLCredentialKerberosTicket::initializeFromPropertyList(URLCredentialKerberosTicket *this, CFDictionaryRef *a2)
{
  return URLCredentialKerberosTicket::initializeFromPropertyList((URLCredentialKerberosTicket *)((char *)this - 8), a2);
}

uint64_t `non-virtual thunk to'URLCredentialKerberosTicket::serializeToPropertyList(CFDictionaryRef *this, SerializableArchive **a2)
{
  URLCredentialKerberosTicket::serializeToPropertyList(this - 1, a2);
  return 1;
}

void URLCredentialKerberosTicket::~URLCredentialKerberosTicket(URLCredentialKerberosTicket *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  *(_QWORD *)this = &off_1E14EE598;
  *((_QWORD *)this + 1) = &unk_1E14EE640;
  *((_QWORD *)this + 3) = &unk_1E14EE670;
  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 9);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 8);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 11);
  if (v5)
    CFRelease(v5);
  URLCredential::~URLCredential(this);
}

void sub_1840A65A4(_Unwind_Exception *a1)
{
  URLCredential *v1;

  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t URLCredentialKerberosTicket::initialize(URLCredentialKerberosTicket *this, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4, const __CFUUID *a5)
{
  uint64_t v8;
  CFTypeID TypeID;
  CFTypeID v12;
  const __CFAllocator *v13;
  __CFDictionary *MutableCopy;
  const __CFAllocator *v15;
  CFTypeID v16;
  void *values[2];
  void *keys[3];

  v8 = 0;
  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  *((_DWORD *)this + 9) = 2;
  if (a2 && a3)
  {
    TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(a3) || (v12 = CFStringGetTypeID(), v12 != CFGetTypeID(a2)))
    {
      v8 = 0;
      if (a4)
        goto LABEL_7;
LABEL_9:
      keys[0] = CFSTR("kCFURLCredentialKerberosTicketAllowDelegation");
      keys[1] = CFSTR("kCFURLCredentialKerberosNoUIFlag");
      values[0] = CFSTR("TRUE");
      values[1] = CFSTR("TRUE");
      v15 = CFGetAllocator((char *)this - 16);
      MutableCopy = CFDictionaryCreate(v15, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      goto LABEL_10;
    }
    *((_QWORD *)this + 9) = CFRetain(a3);
    *((_QWORD *)this + 10) = CFRetain(a2);
    v8 = 1;
  }
  if (!a4)
    goto LABEL_9;
LABEL_7:
  v13 = CFGetAllocator((char *)this - 16);
  MutableCopy = CFDictionaryCreateMutableCopy(v13, 0, a4);
  CFDictionaryAddValue(MutableCopy, CFSTR("kCFURLCredentialKerberosTicketAllowDelegation"), CFSTR("TRUE"));
  CFDictionaryAddValue(MutableCopy, CFSTR("kCFURLCredentialKerberosNoUIFlag"), CFSTR("TRUE"));
LABEL_10:
  *((_QWORD *)this + 8) = MutableCopy;
  if (a5)
  {
    v16 = CFUUIDGetTypeID();
    if (v16 == CFGetTypeID(a5))
    {
      *((_QWORD *)this + 11) = CFRetain(a5);
      return 1;
    }
  }
  return v8;
}

void ___ZN14ObserverHolder5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFObserverHolder");
  ObserverHolder::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_1840A67A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

BOOL URLCredentialServerTrust::equals(URLCredentialServerTrust *this, const CFObject *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _BOOL8 result;

  if (*((_DWORD *)this + 8) != *((_DWORD *)a2 + 8))
    return 0;
  v4 = (*(uint64_t (**)(URLCredentialServerTrust *))(*(_QWORD *)this + 8))(this);
  if (v4 != (*(uint64_t (**)(const CFObject *))(*(_QWORD *)a2 + 8))(a2)
    || *((_DWORD *)this + 9) != *((_DWORD *)a2 + 9))
  {
    return 0;
  }
  v5 = *((_QWORD *)this + 8);
  v6 = *((_QWORD *)a2 + 8);
  result = (v5 | v6) == 0;
  if (v5)
  {
    if (v6)
      return CFEqual(*((CFTypeRef *)this + 8), (CFTypeRef)v6) != 0;
  }
  return result;
}

CFStringRef URLCredentialServerTrust::copyDebugDesc(URLCredentialServerTrust *this)
{
  char *v1;
  const __CFAllocator *v2;

  v1 = (char *)this - 16;
  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFURLCredential %p>{ accepted server trust }"), v1);
}

uint64_t URLCredentialServerTrust::copy(URLCredentialServerTrust *this)
{
  uint64_t Instance;
  CFTypeRef v3;

  CFGetAllocator((char *)this - 16);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_QWORD *)(Instance + 16) = &off_1E14ED238;
  *(_QWORD *)(Instance + 24) = &unk_1E14ED2B8;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 80) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_QWORD *)(Instance + 40) = &unk_1E14ED2E8;
  v3 = (CFTypeRef)*((_QWORD *)this + 8);
  *(_QWORD *)(Instance + 48) = 0x200000001;
  if (v3)
    v3 = CFRetain(v3);
  *(_QWORD *)(Instance + 80) = v3;
  return Instance;
}

BOOL URLCredentialServerTrust::initializeFromPropertyList(URLCredentialServerTrust *this, CFDictionaryRef *a2)
{
  _BOOL8 result;
  CFTypeID TypeID;
  void *v6;
  void *v7;

  result = URLCredential::initializeFromPropertyList((uint64_t)this, a2);
  if ((_DWORD)result)
  {
    v7 = 0;
    TypeID = SecTrustGetTypeID();
    DeserializableArchive::decant(a2, CFSTR("trust"), TypeID, (CFErrorRef *)&v7);
    v6 = v7;
    *((_QWORD *)this + 8) = v7;
    return v6 != 0;
  }
  return result;
}

uint64_t URLCredentialServerTrust::serializeToPropertyList(__SecTrust **this, SerializableArchive **a2)
{
  URLCredential::serializeToPropertyList((URLCredential *)this, a2);
  SerializableArchive::add((CFTypeRef *)a2, CFSTR("trust"), this[8]);
  return 1;
}

CFHashCode URLCredentialServerTrust::calcHash(URLCredentialServerTrust *this, uint64_t a2)
{
  uint64_t v2;
  const void *v3;

  v2 = a2;
  v3 = (const void *)*((_QWORD *)this + 8);
  if (v3)
    return CFHash(v3) ^ a2;
  return v2;
}

CFStringRef URLCredentialServerTrust::copyStorageNameForCredentialType(SecTrustRef *this)
{
  const __CFArray *v2;
  const __CFArray *v3;
  __SecCertificate *ValueAtIndex;
  CFStringRef v5;

  if (SecTrustGetCertificateCount(this[8]) < 1)
    return 0;
  v2 = SecTrustCopyCertificateChain(this[8]);
  if (!v2)
    return 0;
  v3 = v2;
  if (CFArrayGetCount(v2) >= 1 && (ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v3, 0)) != 0)
    v5 = SecCertificateCopySubjectSummary(ValueAtIndex);
  else
    v5 = 0;
  CFRelease(v3);
  return v5;
}

void sub_1840A6AC8(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'URLCredentialServerTrust::~URLCredentialServerTrust(URLCredentialServerTrust *this)
{
  URLCredentialServerTrust::~URLCredentialServerTrust((URLCredentialServerTrust *)((char *)this - 8));
}

{
  URLCredentialServerTrust::~URLCredentialServerTrust((URLCredentialServerTrust *)((char *)this - 8));
}

{
  URLCredentialServerTrust::~URLCredentialServerTrust((URLCredentialServerTrust *)((char *)this - 24));
}

{
  URLCredentialServerTrust::~URLCredentialServerTrust((URLCredentialServerTrust *)((char *)this - 24));
}

BOOL `non-virtual thunk to'URLCredentialServerTrust::initializeFromPropertyList(URLCredentialServerTrust *this, CFDictionaryRef *a2)
{
  return URLCredentialServerTrust::initializeFromPropertyList((URLCredentialServerTrust *)((char *)this - 8), a2);
}

uint64_t `non-virtual thunk to'URLCredentialServerTrust::serializeToPropertyList(__SecTrust **this, SerializableArchive **a2)
{
  URLCredential::serializeToPropertyList((URLCredential *)(this - 1), a2);
  SerializableArchive::add((CFTypeRef *)a2, CFSTR("trust"), this[7]);
  return 1;
}

CFStringRef HTTPCookie::copyDebugDesc(HTTPCookie *this)
{
  uint64_t v2;
  double *v3;
  const __CFAllocator **v4;
  double v5;
  CFDateRef v6;
  CFDateRef v7;
  const __CFAllocator *v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  char *v13;
  _BYTE *v14;
  const UInt8 *EnumeratedString;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  char *v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE *v28;
  char *v29;
  _BYTE *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  CFStringRef v34;
  CFStringRef v35;
  double v37;

  v2 = (*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  v3 = (double *)v2;
  v4 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
  if (*(_DWORD *)v2 >= 0xCu && (*(_DWORD *)(v2 + 8) & 2) != 0)
  {
    v6 = 0;
  }
  else
  {
    v5 = 0.0;
    if (*(_DWORD *)v2 >= 0x30u)
    {
      v37 = *(double *)(v2 + 40);
      v5 = floor(v37);
    }
    v6 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5);
  }
  if (*(_DWORD *)v3 > 0x37u)
  {
    v37 = v3[6];
    v8 = *v4;
    if (floor(v37) == 0.0)
    {
      v7 = 0;
    }
    else
    {
      v9 = 0.0;
      if (*(_DWORD *)v3 >= 0x38u)
      {
        v37 = v3[6];
        v9 = floor(v37);
      }
      v7 = CFDateCreate(v8, v9);
    }
  }
  else
  {
    v7 = 0;
    v8 = *v4;
  }
  if (*(_DWORD *)v3 >= 0x14u
    && (v10 = *((unsigned int *)v3 + 4), (_DWORD)v10)
    && (v11 = *(unsigned int *)v3, v11 > v10))
  {
    v12 = (char *)v3 + v10;
    v13 = (char *)v3 + v11;
    v14 = v12;
    while (*v14)
    {
      if (++v14 >= v13)
        goto LABEL_20;
    }
  }
  else
  {
LABEL_20:
    v12 = 0;
  }
  EnumeratedString = CompactCookieHeader::getEnumeratedString((CompactCookieHeader *)v3, 15, 0);
  v16 = 0;
  if (*(_DWORD *)v3 >= 0x18u)
  {
    v17 = *((unsigned int *)v3 + 5);
    if ((_DWORD)v17 && (v18 = *(unsigned int *)v3, v18 > v17))
    {
      v16 = (char *)v3 + v17;
      v19 = (char *)v3 + v18;
      v20 = v16;
      while (*v20)
      {
        if (++v20 >= v19)
          goto LABEL_27;
      }
    }
    else
    {
LABEL_27:
      v16 = 0;
    }
  }
  if (*(_DWORD *)v3 >= 0x1Cu
    && (v21 = *((unsigned int *)v3 + 6), (_DWORD)v21)
    && (v22 = *(unsigned int *)v3, v22 > v21))
  {
    v23 = (char *)v3 + v21;
    v24 = (char *)v3 + v22;
    v25 = v23;
    while (*v25)
    {
      if (++v25 >= v24)
        goto LABEL_34;
    }
  }
  else
  {
LABEL_34:
    v23 = 0;
  }
  if (*(_DWORD *)v3 >= 0x20u
    && (v26 = *((unsigned int *)v3 + 7), (_DWORD)v26)
    && (v27 = *(unsigned int *)v3, v27 > v26))
  {
    v28 = (char *)v3 + v26;
    v29 = (char *)v3 + v27;
    v30 = v28;
    while (*v30)
    {
      if (++v30 >= v29)
        goto LABEL_41;
    }
  }
  else
  {
LABEL_41:
    v28 = 0;
  }
  if (*(_DWORD *)v3 >= 0xCu && ((_DWORD)v3[1] & 2) != 0)
    v31 = 89;
  else
    v31 = 110;
  if (*(_DWORD *)v3 >= 0xCu && ((_DWORD)v3[1] & 1) != 0)
    v32 = 89;
  else
    v32 = 110;
  if (*(_DWORD *)v3 >= 0xCu && ((_DWORD)v3[1] & 4) != 0)
    v33 = 89;
  else
    v33 = 110;
  v34 = CFStringCreateWithFormat(v8, 0, CFSTR("<CompactCookieHeader@%p> { domain: %s, partition: %s, name: %s, path: %s, value: %s, session: %c, secure: %c, httponly? %c, expires: %@, created: %@ }"), v3, v12, EnumeratedString, v16, v23, v28, v31, v32, v33, v6, v7, *(_QWORD *)&v37);
  if (v6)
    CFRelease(v6);
  if (v7)
    CFRelease(v7);
  v35 = CFStringCreateWithFormat(v8, 0, CFSTR("<HTTPCookie@%p> { %@ }"), this, v34);
  if (v34)
    CFRelease(v34);
  return v35;
}

BOOL HTTPCookie::equals(HTTPCookie *this, const HTTPCookie *a2)
{
  CompactCookieHeader *v3;
  uint64_t v4;
  CompactCookieHeader *v5;
  CFPropertyListRef v6;
  CFPropertyListRef v7;
  const void *v8;
  unsigned int v9;
  unsigned int v11;
  int v12;
  int v13;
  BOOL v14;
  unint64_t v15;
  const char *EnumeratedString;
  const char *v17;
  BOOL v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int16 *v24;
  uint64_t v25;
  BOOL v26;
  int v27;
  unsigned __int16 *v28;
  uint64_t v29;
  BOOL v30;
  int v31;
  int v32;

  v3 = (CompactCookieHeader *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  v4 = (*((uint64_t (**)(const HTTPCookie *))a2->var0 + 2))(a2);
  if (v3 == (CompactCookieHeader *)v4)
    return 1;
  v5 = (CompactCookieHeader *)v4;
  v6 = CompactCookieHeader::copyExtraInfo(v3, 0);
  v7 = CompactCookieHeader::copyExtraInfo(v5, 0);
  v8 = v7;
  if (*(_DWORD *)v3 >= 8u)
    v9 = *((_DWORD *)v3 + 1);
  else
    v9 = 0;
  if (*(_DWORD *)v5 >= 8u)
    v11 = *((_DWORD *)v5 + 1);
  else
    v11 = 0;
  if (v9 == v11)
  {
    v12 = *(_DWORD *)v3 >= 0xCu ? *((_DWORD *)v3 + 2) & 0x7F : 0;
    v13 = *(_DWORD *)v5 >= 0xCu ? *((_DWORD *)v5 + 2) & 0x7F : 0;
    if (v12 == v13)
    {
      v14 = 0;
      v15 = 0;
      while (((0x602C4uLL >> v15) & 1) != 0)
      {
LABEL_52:
        v14 = v15++ > 0x11;
        if (v15 == 19)
          goto LABEL_53;
      }
      switch(CookieData::sCookieFieldInfo[5 * v15 + 3])
      {
        case 1:
          EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString(v3, v15, 0);
          v17 = (const char *)CompactCookieHeader::getEnumeratedString(v5, v15, 0);
          if (!((unint64_t)EnumeratedString | (unint64_t)v17))
            goto LABEL_52;
          v18 = EnumeratedString != 0;
          if (v17)
          {
            v18 = 0;
            v19 = EnumeratedString == 0;
          }
          else
          {
            v19 = 0;
          }
          if (!v19 && !v18 && !strcmp(EnumeratedString, v17))
            goto LABEL_52;
          goto LABEL_53;
        case 2:
        case 4:
          CompactCookieHeader::getEnumeratedTime(v3, v15);
          CompactCookieHeader::getEnumeratedTime(v5, v15);
          goto LABEL_52;
        case 8:
          if (*(_DWORD *)v3 >= 0x10u)
            v20 = *((unsigned int *)v3 + 3);
          else
            v20 = 0;
          if (*(_DWORD *)v5 >= 0x10u)
            v21 = *((unsigned int *)v5 + 3);
          else
            v21 = 0;
          if (v20 != v21)
            goto LABEL_53;
          if (!v20)
            goto LABEL_52;
          v22 = 0;
          v23 = 2 * v20;
          break;
        default:
          goto LABEL_52;
      }
      while (1)
      {
        v24 = (unsigned __int16 *)((char *)v3 + (v22 + 56));
        v25 = *(_DWORD *)v3;
        v26 = v25 <= (int)v22 + 56 || v24 + 1 > (unsigned __int16 *)((char *)v3 + v25);
        v27 = v26 ? 0 : *v24;
        v28 = (unsigned __int16 *)((char *)v5 + (v22 + 56));
        v29 = *(_DWORD *)v5;
        v30 = v29 <= (int)v22 + 56 || v28 + 1 > (unsigned __int16 *)((char *)v5 + v29);
        v31 = v30 ? 0 : *v28;
        if (v27 != v31)
          break;
        v22 += 2;
        if (v23 == v22)
          goto LABEL_52;
      }
LABEL_53:
      v32 = v14;
      if (!v8)
        goto LABEL_57;
      goto LABEL_56;
    }
  }
  v32 = 0;
  if (v7)
LABEL_56:
    CFRelease(v8);
LABEL_57:
  if (v6)
    CFRelease(v6);
  return v32 != 0;
}

void HetergeneousCFDict::~HetergeneousCFDict(HetergeneousCFDict *this)
{
  AutoDict::~AutoDict(this);
  JUMPOUT(0x186DB748CLL);
}

void `non-virtual thunk to'Throttler::~Throttler(Throttler *this)
{
  Throttler::~Throttler((Throttler *)((char *)this - 24));
}

void `non-virtual thunk to'Throttler::~Throttler(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  Throttler::~Throttler((Throttler *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

uint64_t ___ZN9Throttler10invalidateEU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

uint64_t ___ZN9Throttler19_onqueue_setupTimerEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v1 + 48) = 0;
  result = *(_QWORD *)(v1 + 80);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t ___ZN9Throttler19_onqueue_setupTimerEv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

void Throttler::setMaximumBPSTarget(Throttler *this, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v7[5];
  _QWORD handler[5];

  *((_QWORD *)this + 12) = a2;
  *((CFAbsoluteTime *)this + 5) = CFAbsoluteTimeGetCurrent();
  *((_QWORD *)this + 7) = 0;
  v3 = *((_QWORD *)this + 4);
  if (v3)
    goto LABEL_3;
  *((CFAbsoluteTime *)this + 5) = CFAbsoluteTimeGetCurrent();
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 4) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 9) + 80))(*((_QWORD *)this + 9));
  (*(void (**)(Throttler *))(*(_QWORD *)this + 40))(this);
  v4 = MEMORY[0x1E0C809B0];
  v5 = *((_QWORD *)this + 4);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3221225472;
  handler[2] = ___ZN9Throttler19_onqueue_setupTimerEv_block_invoke;
  handler[3] = &__block_descriptor_40_e5_v8__0l;
  handler[4] = this;
  dispatch_source_set_event_handler(v5, handler);
  v6 = *((_QWORD *)this + 4);
  v7[0] = v4;
  v7[1] = 3221225472;
  v7[2] = ___ZN9Throttler19_onqueue_setupTimerEv_block_invoke_2;
  v7[3] = &__block_descriptor_40_e5_v8__0l;
  v7[4] = this;
  dispatch_source_set_cancel_handler(v6, v7);
  dispatch_source_set_timer(*((dispatch_source_t *)this + 4), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(*((dispatch_object_t *)this + 4));
  v3 = *((_QWORD *)this + 4);
  if (v3)
LABEL_3:
    dispatch_source_set_timer(v3, 0, 0xFFFFFFFFFFFFFFFFLL, 0);
}

void std::__shared_ptr_pointer<Throttler *,Deleter_release<Throttler>,std::allocator<Throttler>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void sub_1840A7460(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1840A7EA8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1840A8054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1840A8BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1840A8C80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__10723(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__10724(uint64_t a1)
{

}

CFStringRef CStringKeyCallbacks::_copyDescription(CStringKeyCallbacks *this, const void *a2)
{
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)this, 0x8000100u);
}

uint64_t _netServiceDispatchCallbackForResolving(__CFNetService *a1, CFStreamError *a2, id *a3)
{
  id Weak;

  if (a3)
    Weak = objc_loadWeak(a3 + 1);
  else
    Weak = 0;
  return -[NSNetService _dispatchCallBackWithError:]((uint64_t)Weak, a2->domain, a2->error);
}

uint64_t _netServiceDispatchCallbackForPublishing(__CFNetService *a1, CFStreamError *a2, id *a3)
{
  id Weak;
  uint64_t error;
  uint64_t result;

  if (a3)
    Weak = objc_loadWeak(a3 + 1);
  else
    Weak = 0;
  error = a2->error;
  if ((_DWORD)error)
    return -[NSNetService _dispatchCallBackWithError:]((uint64_t)Weak, a2->domain, error);
  objc_msgSend(Weak, "delegate");
  result = objc_opt_respondsToSelector();
  if ((result & 1) != 0)
    return objc_msgSend((id)objc_msgSend(Weak, "delegate"), "netServiceDidPublish:", Weak);
  return result;
}

void sub_1840AA460(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void _netServiceMonitorCallBack(__CFNetServiceMonitor *a1, __CFNetService *a2, CFNetServiceMonitorType a3, const __CFData *a4, CFStreamError *a5, id *a6)
{
  id Weak;
  uint64_t v9;
  void *v10;

  if (a6)
    Weak = objc_loadWeak(a6 + 1);
  else
    Weak = 0;
  if (a5->domain != 10 || a5->error != -72005)
  {
    v9 = objc_msgSend(Weak, "delegate");
    if (v9)
    {
      v10 = (void *)v9;
      if ((objc_opt_respondsToSelector() & 1) != 0)
        objc_msgSend(v10, "netService:didUpdateTXTRecordData:", Weak, a4);
    }
  }
}

uint64_t _netServiceBrowserDispatchCallBack(__CFNetServiceBrowser *a1, uint64_t a2, const void *a3, CFStreamError *a4, id *a5)
{
  id Weak;

  if (a5)
    Weak = objc_loadWeak(a5 + 1);
  else
    Weak = 0;
  return objc_msgSend(Weak, "_dispatchCallBack:flags:error:", a3, a2, a4->domain, a4->error);
}

void _CoreLockable::~_CoreLockable(_CoreLockable *this)
{
  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

{
  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  JUMPOUT(0x186DB748CLL);
}

void CoreLockable::~CoreLockable(CoreLockable *this)
{
  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

{
  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  JUMPOUT(0x186DB748CLL);
}

void CoreCondLock::~CoreCondLock(CoreCondLock *this)
{
  CoreCondLock::~CoreCondLock(this);
  JUMPOUT(0x186DB748CLL);
}

{
  *(_QWORD *)this = &off_1E14E57F8;
  pthread_cond_destroy((pthread_cond_t *)((char *)this + 72));
  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

void sub_1840AB2F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)v1 = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(a1);
}

void APSRelayTransaction::~APSRelayTransaction(APSRelayTransaction *this)
{
  APSRelayTransaction::~APSRelayTransaction(this);
  JUMPOUT(0x186DB748CLL);
}

{
  uint64_t v2;
  const void *v3;
  const void *v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;

  *(_QWORD *)this = &off_1E14E9AA8;
  v2 = *((_QWORD *)this + 24);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    *((_QWORD *)this + 24) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 29);
  if (v3)
  {
    _Block_release(v3);
    *((_QWORD *)this + 29) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 27);
  if (v4)
  {
    _Block_release(v4);
    *((_QWORD *)this + 27) = 0;
  }
  v5 = *((_QWORD *)this + 28);
  if (v5)
  {
    dispatch_release(v5);
    *((_QWORD *)this + 28) = 0;
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 264);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 200);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 176);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 160);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 144);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 128);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 64);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 48);
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 5);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
  *(_QWORD *)this = &off_1E14E5838;
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
}

void sub_1840AB414(_Unwind_Exception *a1)
{
  _QWORD *v1;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 33));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 25));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 22));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 20));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 18));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 16));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 8));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 6));
  v3 = (std::__shared_weak_count *)v1[5];
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  *v1 = &off_1E14E5838;
  v4 = (std::__shared_weak_count *)v1[2];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<APSRelayEngine>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0910;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<APSRelayEngine>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0910;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<APSRelayEngine>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void APSRelayTransaction::setBodyStreamBeforeOpening(APSRelayTransaction *this, __CFReadStream *a2)
{
  __CFData *Mutable;
  uint64_t v5;
  CFTypeRef v6;
  const __CFData *v7;
  const __CFData *v8;
  CFTypeRef v9;
  _QWORD *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 v18;
  UInt8 buffer[1024];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    CFReadStreamOpen(a2);
    while (CFReadStreamGetStatus(a2) <= kCFStreamStatusWriting)
    {
      v5 = CFReadStreamRead(a2, buffer, 1024);
      if (v5 < 1)
        break;
      CFDataAppendBytes(Mutable, buffer, v5);
    }
    CFReadStreamClose(a2);
    if (Mutable)
      v6 = CFRetain(Mutable);
    else
      v6 = 0;
    *(_QWORD *)&v18 = v6;
    v14 = (_QWORD *)operator new();
    *v14 = &off_1E14F1908;
    v14[1] = 0;
    v14[2] = 0;
    v14[3] = v6;
    *((_QWORD *)&v18 + 1) = v14;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 160, &v18);
    v15 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
    if (*((_QWORD *)&v18 + 1))
    {
      v16 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
    v7 = CFHTTPMessageCopyBody((CFHTTPMessageRef)(*((_QWORD *)this + 18) - 16));
    if (v7)
    {
      v8 = v7;
      if (CFDataGetLength(v7) >= 1)
      {
        v9 = CFRetain(v8);
        *(_QWORD *)buffer = v9;
        v10 = (_QWORD *)operator new();
        *v10 = &off_1E14F1A90;
        v10[1] = 0;
        v10[2] = 0;
        v10[3] = v9;
        *(_QWORD *)&buffer[8] = v10;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 160, (__int128 *)buffer);
        v11 = *(std::__shared_weak_count **)&buffer[8];
        if (*(_QWORD *)&buffer[8])
        {
          v12 = (unint64_t *)(*(_QWORD *)&buffer[8] + 8);
          do
            v13 = __ldaxr(v12);
          while (__stlxr(v13 - 1, v12));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }
      }
      CFRelease(v8);
    }
  }
}

void sub_1840AB700(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void APSRelayTransaction::scheduleAndOpenWithHandler(APSRelayTransaction *this, const CoreSchedulingSet *a2, void *aBlock, void (**a4)(_QWORD, _QWORD))
{
  int v5;
  NSObject *v8;
  uint64_t v9;
  int v10;
  const __CFData *v11;
  CFIndex Length;
  uint64_t v13;
  int v14;
  double v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_weak_owners;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  HTTPMessage **v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  HTTPMessage *v50;
  const __CFString *v51;
  _BOOL8 v52;
  CFMutableDictionaryRef v53;
  uint64_t v54;
  double v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  void *v62;
  unint64_t *v63;
  unint64_t v64;
  unint64_t *v65;
  unint64_t v66;
  double v67;
  uint64_t v68;
  const void *v69;
  double Current;
  uint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  std::__shared_weak_count *v75;
  unint64_t *v76;
  unint64_t v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  std::__shared_weak_count *v84;
  unint64_t *v85;
  unint64_t v86;
  int v87;
  const char *v88;
  int v89;
  _QWORD v90[6];
  std::__shared_weak_count *v91;
  uint64_t v92;
  std::__shared_weak_count *v93;
  uint64_t v94;
  std::__shared_weak_count *v95;
  uint64_t v96;
  std::__shared_weak_count *v97;
  uint64_t v98;
  std::__shared_weak_count *v99;
  __int128 buf;
  void (*v101)(_QWORD *, void *, void *, uint64_t, void *);
  void *v102;
  _QWORD *v103;
  uint64_t v104;
  uint64_t v105;
  std::__shared_weak_count *v106;
  uint64_t v107;
  std::__shared_weak_count *v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 27))
    __assert_rtn("scheduleAndOpenWithHandler", "APSRelayTransaction.cpp", 169, "!_callbackHandler");
  v5 = *((_DWORD *)this + 20);
  if ((v5 == 0) != (v5 != 5))
    __assert_rtn("scheduleAndOpenWithHandler", "APSRelayTransaction.cpp", 179, "(_state == State::New) || (_state == State::Canceled)");
  if (!v5)
  {
    *((_QWORD *)this + 27) = _Block_copy(aBlock);
    *((_QWORD *)this + 29) = _Block_copy(a4);
    *((_BYTE *)this + 24) |= 1u;
    APSRelayTransaction::_updateScheduling(this, a2, 0);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v8 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *((_QWORD *)this + 33);
      LODWORD(buf) = 138543362;
      *(_QWORD *)((char *)&buf + 4) = v9;
      _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@ now using Connection APSR", (uint8_t *)&buf, 0xCu);
    }
    v10 = *((_DWORD *)this + 20);
    if (v10 != 6)
    {
      if (v10 >= 2)
        __assert_rtn("_changeState", "APSRelayTransaction.cpp", 712, "newState >= _state");
      *((_DWORD *)this + 20) = 1;
    }
    v11 = (const __CFData *)*((_QWORD *)this + 20);
    if (v11)
      Length = CFDataGetLength(v11);
    else
      Length = 0;
    cleanUpRequest((__CFHTTPMessage *)(*((_QWORD *)this + 18) - 16), Length, 1, 0, *((id **)this + 24));
    v13 = *((_QWORD *)this + 24);
    if (v13)
    {
      v14 = objc_msgSend(*(id *)(v13 - 96), "_cachePolicy");
      objc_msgSend(*(id *)(v13 - 96), "_timeoutInterval");
    }
    else
    {
      v14 = 0;
      v15 = 0.0;
    }
    v16 = (void *)_constructRequestFromParts((const __CFAllocator *)(*((_QWORD *)this + 18) - 16), 0, (const __CFArray *)v14, NSURLRequestUseProtocolCachePolicy, v15, 0);
    -[__CFN_TransactionMetrics setTransferredRequest:](*((_QWORD *)this + 35), v16);
    if (v16)
      CFRelease(v16);
    v17 = *((_QWORD *)this + 24);
    if (v17)
      v18 = v17 - 176;
    else
      v18 = 0;
    objc_msgSend(*(id *)(v18 + 80), "_timeoutInterval");
    v20 = *((_QWORD *)this + 6);
    if (!v20)
      __assert_rtn("_startRequest", "APSRelayTransaction.cpp", 403, "_engine");
    v21 = v19;
    v22 = *((_QWORD *)this + 4);
    v23 = (std::__shared_weak_count *)*((_QWORD *)this + 5);
    if (v23)
    {
      p_shared_weak_owners = (unint64_t *)&v23->__shared_weak_owners_;
      do
        v25 = __ldxr(p_shared_weak_owners);
      while (__stxr(v25 + 1, p_shared_weak_owners));
      v20 = *((_QWORD *)this + 6);
    }
    v26 = *((_QWORD *)this + 18);
    v27 = *((_QWORD *)this + 19);
    v98 = v26;
    v99 = (std::__shared_weak_count *)v27;
    if (v27)
    {
      v28 = (unint64_t *)(v27 + 8);
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }
    v30 = *((_QWORD *)this + 21);
    v96 = *((_QWORD *)this + 20);
    v97 = (std::__shared_weak_count *)v30;
    if (v30)
    {
      v31 = (unint64_t *)(v30 + 8);
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
    }
    v33 = (std::__shared_weak_count *)*((_QWORD *)this + 26);
    v94 = *((_QWORD *)this + 25);
    v95 = v33;
    if (v33)
    {
      p_shared_owners = (unint64_t *)&v33->__shared_owners_;
      do
        v35 = __ldxr(p_shared_owners);
      while (__stxr(v35 + 1, p_shared_owners));
    }
    v36 = (std::__shared_weak_count *)*((_QWORD *)this + 34);
    v92 = *((_QWORD *)this + 33);
    v93 = v36;
    if (v36)
    {
      v37 = (unint64_t *)&v36->__shared_owners_;
      do
        v38 = __ldxr(v37);
      while (__stxr(v38 + 1, v37));
    }
    v39 = MEMORY[0x1E0C809B0];
    v90[0] = MEMORY[0x1E0C809B0];
    v90[1] = 3321888768;
    v90[2] = ___ZN19APSRelayTransaction13_startRequestEv_block_invoke;
    v90[3] = &__block_descriptor_56_e8_40c44_ZTSNSt3__18weak_ptrI19APSRelayTransactionEE_e102_v64__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8_24___qi_32q48q56l;
    v90[4] = this;
    v90[5] = v22;
    v91 = v23;
    if (v23)
    {
      v40 = (unint64_t *)&v23->__shared_weak_owners_;
      do
        v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
    }
    v42 = (HTTPMessage **)(v20 + 96);
    if (*(_QWORD *)(v20 + 96))
    {
      v88 = "!_httpRequest";
      v89 = 105;
    }
    else if (*(_QWORD *)(v20 + 64))
    {
      v88 = "!_schedulingSet";
      v89 = 106;
    }
    else
    {
      if (!*(_QWORD *)(v20 + 168))
      {
        std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v20 + 96), v26, v27);
        std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v20 + 112), v96, (uint64_t)v97);
        v43 = v95;
        if (v95)
        {
          v44 = (unint64_t *)&v95->__shared_owners_;
          do
            v45 = __ldxr(v44);
          while (__stxr(v45 + 1, v44));
        }
        v46 = *(std::__shared_weak_count **)(v20 + 72);
        *(_QWORD *)(v20 + 64) = v94;
        *(_QWORD *)(v20 + 72) = v43;
        if (v46)
        {
          v47 = (unint64_t *)&v46->__shared_owners_;
          do
            v48 = __ldaxr(v47);
          while (__stlxr(v48 - 1, v47));
          if (!v48)
          {
            ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
            std::__shared_weak_count::__release_weak(v46);
          }
        }
        v49 = HTTPRequestParserClient::requestURL((HTTPMessage *)((char *)*v42 + 128));
        v50 = *v42;
        v51 = (const __CFString *)*((_QWORD *)*v42 + 19);
        v52 = (v51
            || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
            && (LOWORD(buf) = 0,
                _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", (uint8_t *)&buf, 2u), (v51 = (const __CFString *)*((_QWORD *)v50 + 19)) != 0))&& CFStringCompare(v51, (CFStringRef)&gConstantCFStringValueTable[2611], 0) == kCFCompareEqualTo;
        v53 = HTTPMessage::copyAllHeaderFields(*v42);
        v54 = *(_QWORD *)(v20 + 112);
        gotLoadHelper_x8__OBJC_CLASS___FTURLRequestMessage(v55);
        v57 = (void *)objc_msgSend(objc_alloc(*(Class *)(v56 + 3112)), "initWithURL:type:headers:stringParams:body:", v49, v52, v53, 0, v54);
        *(_QWORD *)(v20 + 152) = v57;
        objc_msgSend(v57, "setUnderlyingService:", *(_QWORD *)(v20 + 48));
        objc_msgSend(*(id *)(v20 + 152), "setTopic:", *(_QWORD *)(v20 + 48));
        objc_msgSend(*(id *)(v20 + 152), "setHttpDoNotDecodeData:", 1);
        if (v53)
          CFRelease(v53);
        v58 = *(_QWORD *)(v20 + 32);
        v59 = *(std::__shared_weak_count **)(v20 + 40);
        if (v59)
        {
          v60 = (unint64_t *)&v59->__shared_weak_owners_;
          do
            v61 = __ldxr(v60);
          while (__stxr(v61 + 1, v60));
        }
        v62 = *(void **)(v20 + 152);
        *(_QWORD *)&buf = v39;
        *((_QWORD *)&buf + 1) = 3321888768;
        v101 = ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke;
        v102 = &unk_1E14F45C0;
        v104 = v20;
        v105 = v58;
        v106 = v59;
        if (v59)
        {
          v63 = (unint64_t *)&v59->__shared_weak_owners_;
          do
            v64 = __ldxr(v63);
          while (__stxr(v64 + 1, v63));
        }
        v107 = v92;
        v108 = v93;
        if (v93)
        {
          v65 = (unint64_t *)&v93->__shared_owners_;
          do
            v66 = __ldxr(v65);
          while (__stxr(v66 + 1, v65));
        }
        v103 = v90;
        objc_msgSend(v62, "setCompletionBlock:", &buf);
        objc_msgSend(*(id *)(v20 + 152), "setTimeout:", v21);
        gotLoadHelper_x8__OBJC_CLASS___FTMessageDelivery_DualMode(v67);
        *(_QWORD *)(v20 + 168) = objc_msgSend(objc_alloc(*(Class *)(v68 + 3080)), "initWithPreferedType:", 2);
        v69 = HTTPMessage::copyHeaderFieldValue(*(HTTPMessage **)(v20 + 96), 0x14C15415u);
        if (!v69)
        {
          pthread_once(&initControl, initializeUserAgentString);
          if (sUserAgentString)
            v69 = CFRetain((CFTypeRef)sUserAgentString);
          else
            v69 = 0;
        }
        objc_msgSend(*(id *)(v20 + 168), "setUserAgent:", v69);
        Current = CFAbsoluteTimeGetCurrent();
        v71 = *(_QWORD *)(v20 + 176);
        if (v71)
          *(double *)(v71 + 176) = Current;
        objc_msgSend(*(id *)(v20 + 168), "sendMessage:", *(_QWORD *)(v20 + 152), Current);
        if (v69)
          CFRelease(v69);
        v72 = v108;
        if (v108)
        {
          v73 = (unint64_t *)&v108->__shared_owners_;
          do
            v74 = __ldaxr(v73);
          while (__stlxr(v74 - 1, v73));
          if (!v74)
          {
            ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
            std::__shared_weak_count::__release_weak(v72);
          }
        }
        if (v106)
          std::__shared_weak_count::__release_weak(v106);
        if (v59)
          std::__shared_weak_count::__release_weak(v59);
        v75 = v93;
        if (v93)
        {
          v76 = (unint64_t *)&v93->__shared_owners_;
          do
            v77 = __ldaxr(v76);
          while (__stlxr(v77 - 1, v76));
          if (!v77)
          {
            ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
            std::__shared_weak_count::__release_weak(v75);
          }
        }
        v78 = v95;
        if (v95)
        {
          v79 = (unint64_t *)&v95->__shared_owners_;
          do
            v80 = __ldaxr(v79);
          while (__stlxr(v80 - 1, v79));
          if (!v80)
          {
            ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
            std::__shared_weak_count::__release_weak(v78);
          }
        }
        v81 = v97;
        if (v97)
        {
          v82 = (unint64_t *)&v97->__shared_owners_;
          do
            v83 = __ldaxr(v82);
          while (__stlxr(v83 - 1, v82));
          if (!v83)
          {
            ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
            std::__shared_weak_count::__release_weak(v81);
          }
        }
        v84 = v99;
        if (v99)
        {
          v85 = (unint64_t *)&v99->__shared_owners_;
          do
            v86 = __ldaxr(v85);
          while (__stlxr(v86 - 1, v85));
          if (!v86)
          {
            ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
            std::__shared_weak_count::__release_weak(v84);
          }
        }
        if (v91)
          std::__shared_weak_count::__release_weak(v91);
        if (v23)
          std::__shared_weak_count::__release_weak(v23);
        v87 = *((_DWORD *)this + 20);
        if (v87 != 6)
        {
          if (v87 >= 3)
            __assert_rtn("_changeState", "APSRelayTransaction.cpp", 712, "newState >= _state");
          *((_DWORD *)this + 20) = 2;
        }
        goto LABEL_112;
      }
      v88 = "!_apsDelivery";
      v89 = 107;
    }
    __assert_rtn("processTransaction", "APSRelayEngine.mm", v89, v88);
  }
LABEL_112:
  if ((*((_BYTE *)this + 24) & 1) != 0)
  {
    *((_BYTE *)this + 240) = v5 == 0;
    APSRelayTransaction::_invokeHandler(this);
  }
  else
  {
    a4[2](a4, 0);
  }
}

void sub_1840ABF9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  std::__shared_weak_count *v32;
  std::__shared_weak_count *v33;
  uint64_t v34;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v34);
  if (a32)
    std::__shared_weak_count::__release_weak(a32);
  if (v33)
    std::__shared_weak_count::__release_weak(v33);
  if (a16)
    std::__shared_weak_count::__release_weak(a16);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a23);
  if (v32)
    std::__shared_weak_count::__release_weak(v32);
  _Unwind_Resume(a1);
}

void APSRelayTransaction::_updateScheduling(APSRelayTransaction *this, const CoreSchedulingSet *a2, int a3)
{
  uint64_t v4;
  char *v5;
  _BOOL4 v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  int v16;
  _BOOL4 v17;
  BOOL v19;
  int v20;
  __int128 v21;

  v5 = (char *)this + 200;
  v4 = *((_QWORD *)this + 25);
  if ((unint64_t)a2 | v4)
  {
    if (a2 && v4)
    {
      if (CoreSchedulingSet::isEqualTo((CoreSchedulingSet *)v4, a2))
        return;
      v4 = *(_QWORD *)v5;
    }
    if (v4)
      v8 = *(_DWORD *)(v4 + 40) != 0;
    else
      v8 = 0;
    v21 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v5, &v21);
    v9 = (std::__shared_weak_count *)*((_QWORD *)&v21 + 1);
    if (*((_QWORD *)&v21 + 1))
    {
      v10 = (unint64_t *)(*((_QWORD *)&v21 + 1) + 8);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    if (a2)
      (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 40))(a2);
    *(_QWORD *)&v21 = a2;
    v12 = (_QWORD *)operator new();
    *v12 = &off_1E14F1668;
    v12[1] = 0;
    v12[2] = 0;
    v12[3] = a2;
    *((_QWORD *)&v21 + 1) = v12;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v5, &v21);
    v13 = (std::__shared_weak_count *)*((_QWORD *)&v21 + 1);
    if (*((_QWORD *)&v21 + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&v21 + 1) + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    if (*(_QWORD *)v5)
    {
      v16 = *(_DWORD *)(*(_QWORD *)v5 + 40);
      v17 = v16 == 0;
      if (v16 && !v8)
        goto LABEL_29;
      v19 = v16 == 0;
      v20 = !v8;
      if (!v19)
        v20 = 1;
      if (((v20 | v17) & 1) == 0)
      {
LABEL_29:
        if (a3)
        {
          if ((*((_BYTE *)this + 24) & 0xC) != 0)
          {
            APSRelayTransaction::_invokeHandler(this);
            *((_BYTE *)this + 24) &= 0xF3u;
          }
        }
      }
    }
  }
}

void APSRelayTransaction::_invokeHandler(APSRelayTransaction *this)
{
  void (**v2)(_QWORD, _QWORD);
  uint64_t v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(void);
  char v8;
  NSObject *v9;

  v2 = (void (**)(_QWORD, _QWORD))*((_QWORD *)this + 29);
  if (v2)
  {
    v3 = *((_QWORD *)this + 25);
    if (v3 && *(_DWORD *)(v3 + 40))
    {
      *((_QWORD *)this + 29) = 0;
      v2[2](v2, *((unsigned __int8 *)this + 240));
      _Block_release(v2);
    }
    else
    {
      *((_BYTE *)this + 24) |= 4u;
    }
  }
  v4 = *((_BYTE *)this + 24);
  if ((v4 & 3) == 1)
  {
    v5 = *((_QWORD *)this + 25);
    if (!v5 || !*(_DWORD *)(v5 + 40))
    {
      v8 = v4 | 8;
LABEL_13:
      *((_BYTE *)this + 24) = v8;
      return;
    }
    v6 = *((_QWORD *)this + 22);
    if (*((int *)this + 20) < 3)
    {
      if (!v6)
        return;
    }
    else if (!v6)
    {
      v7 = *(void (**)(void))(*((_QWORD *)this + 27) + 16);
LABEL_21:
      v7();
      v8 = *((_BYTE *)this + 24) | 2;
      goto LABEL_13;
    }
    v9 = *((_QWORD *)this + 28);
    if (v9)
    {
      *((_QWORD *)this + 28) = 0;
      (*(void (**)(void))(*((_QWORD *)this + 27) + 16))();
      dispatch_release(v9);
      v4 = *((_BYTE *)this + 24);
    }
    if ((v4 & 1) != 0 && *((int *)this + 20) >= 3)
    {
      v7 = *(void (**)(void))(*((_QWORD *)this + 27) + 16);
      goto LABEL_21;
    }
  }
}

void ___ZN19APSRelayTransaction13_startRequestEv_block_invoke(_QWORD *a1, uint64_t *a2, NSObject *a3, CFIndex a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  HTTPResponseMessage **v22;
  const void *v23;
  __CFHTTPMessage *v24;
  CFIndex ResponseStatusCode;
  int hasHeaderField;
  NSObject *v27;
  uint64_t v28;
  int v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  const char *v34;
  int v35;
  std::__shared_weak_count *v36;
  uint8_t buf[4];
  uint64_t v38;
  __int16 v39;
  CFIndex v40;
  __int16 v41;
  int v42;
  uint64_t v43;
  CFStreamError v44;

  v43 = *MEMORY[0x1E0C80C00];
  v8 = a1[4];
  v36 = 0;
  v9 = (std::__shared_weak_count *)a1[6];
  if (!v9)
    goto LABEL_31;
  v36 = std::__shared_weak_count::lock(v9);
  if (!v36)
    goto LABEL_31;
  v16 = a1[5];
  if (!v16)
    goto LABEL_31;
  v17 = *(_QWORD *)(v8 + 256) + a7;
  *(_QWORD *)(v8 + 248) += a6;
  *(_QWORD *)(v8 + 256) = v17;
  v18 = *a2;
  v19 = (std::__shared_weak_count *)a2[1];
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v21 = __ldxr(p_shared_owners);
    while (__stxr(v21 + 1, p_shared_owners));
  }
  if (*(int *)(v16 + 80) <= 3)
  {
    *(_DWORD *)(v16 + 80) = 3;
    if (!(_DWORD)a5)
    {
      if (v18)
      {
        v22 = (HTTPResponseMessage **)(v16 + 176);
        if (*(_QWORD *)(v16 + 176))
        {
          v34 = "!_response";
          v35 = 468;
        }
        else
        {
          std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v16 + 176), v18, (uint64_t)v19);
          v23 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(_QWORD *)(v16 + 144)
                                                                                            + 128));
          HTTPResponseMessage::setResponseURL(*v22, v23, 0);
          if (*v22)
            v24 = (HTTPResponseMessage *)((char *)*v22 - 16);
          else
            v24 = 0;
          ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v24);
          hasHeaderField = HTTPMessage::hasHeaderField((os_unfair_lock_s *)*v22, 0x11D1D2CFu);
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v27 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v28 = *(_QWORD *)(v16 + 264);
            if (hasHeaderField)
              v29 = 75;
            else
              v29 = 85;
            *(_DWORD *)buf = 138543874;
            v38 = v28;
            v39 = 2048;
            v40 = ResponseStatusCode;
            v41 = 1024;
            v42 = v29;
            _os_log_impl(&dword_183ECA000, v27, OS_LOG_TYPE_DEFAULT, "%{public}@ received response, status %ld content %c", buf, 0x1Cu);
          }
          if (!*(_QWORD *)(v16 + 224))
          {
            if (a3)
            {
              *(_QWORD *)(v16 + 224) = a3;
              dispatch_retain(a3);
            }
            APSRelayTransaction::_invokeHandler((APSRelayTransaction *)v16);
            goto LABEL_26;
          }
          v34 = "!_callbackBuffer";
          v35 = 488;
        }
      }
      else
      {
        v34 = "response";
        v35 = 467;
      }
      __assert_rtn("_processResponse", "APSRelayTransaction.cpp", v35, v34);
    }
    v44.domain = a4;
    *(_QWORD *)&v44.error = a5;
    APSRelayTransaction::_handleError((APSRelayTransaction *)v16, v44);
  }
LABEL_26:
  if (v19)
  {
    v30 = (unint64_t *)&v19->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
LABEL_31:
  if (v36)
  {
    v32 = (unint64_t *)&v36->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
}

void sub_1840AC5F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c44_ZTSNSt3__18weak_ptrI19APSRelayTransactionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c44_ZTSNSt3__18weak_ptrI19APSRelayTransactionEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void APSRelayTransaction::_handleError(APSRelayTransaction *this, CFStreamError a2)
{
  int v2;
  int v4;

  v2 = *((_DWORD *)this + 20);
  if (v2 == 6)
    return;
  *(CFStreamError *)((char *)this + 88) = a2;
  if (a2.domain == 1 && a2.error == 89)
  {
    if (v2 < 6)
    {
      v4 = 5;
      goto LABEL_8;
    }
LABEL_12:
    __assert_rtn("_changeState", "APSRelayTransaction.cpp", 712, "newState >= _state");
  }
  if (v2 >= 7)
    goto LABEL_12;
  v4 = 6;
LABEL_8:
  *((_DWORD *)this + 20) = v4;
  APSRelayTransaction::_invokeHandler(this);
  if ((*((_BYTE *)this + 24) & 1) == 0 && (*((_DWORD *)this + 20) & 0xFFFFFFFE) == 2)
    APSRelayEngine::cancel(*((_QWORD *)this + 6));
}

void APSRelayTransaction::closeAndClearHandler(APSRelayTransaction *this)
{
  const void *v2;
  const void *v3;
  int v4;
  CFStreamError v5;

  if ((*((_BYTE *)this + 24) & 1) != 0)
  {
    *((_BYTE *)this + 24) &= ~1u;
    v2 = (const void *)*((_QWORD *)this + 27);
    if (v2)
    {
      _Block_release(v2);
      *((_QWORD *)this + 27) = 0;
    }
    v3 = (const void *)*((_QWORD *)this + 29);
    if (v3)
    {
      _Block_release(v3);
      *((_QWORD *)this + 29) = 0;
    }
    APSRelayTransaction::_updateScheduling(this, 0, 0);
  }
  v4 = *((_DWORD *)this + 20);
  if (v4 <= 1)
    goto LABEL_10;
  if ((v4 - 5) < 2)
    return;
  if (v4 == 2)
  {
LABEL_10:
    v5.domain = 1;
    *(_QWORD *)&v5.error = 89;
    APSRelayTransaction::_handleError(this, v5);
    if ((*((_DWORD *)this + 20) & 0xFFFFFFFE) == 2)
      APSRelayEngine::cancel(*((_QWORD *)this + 6));
  }
  else
  {
    if (v4 >= 5)
      __assert_rtn("_changeState", "APSRelayTransaction.cpp", 712, "newState >= _state");
    *((_DWORD *)this + 20) = 4;
  }
}

BOOL APSRelayTransaction::setProperty(uint64_t a1, int a2, const void *a3)
{
  const __CFString *v5;
  int ExactString;

  v5 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  ExactString = _findExactString(v5, 0);
  if (ExactString == 11870276)
    HTTPMessage::setHeaderFieldStringValue(*(HTTPMessage **)(a1 + 144), 0x1171B29Fu, a3);
  return ExactString == 11870276;
}

void CoreLogger::~CoreLogger(CoreLogger *this)
{
  JUMPOUT(0x186DB748CLL);
}

CFStringRef CompactCookieArray::copyDebugDesc(CompactCookieArray *this)
{
  const __CFAllocator *v2;
  const __CFData *v3;
  const UInt8 *BytePtr;
  uint64_t v5;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = (const __CFData *)*((_QWORD *)this + 2);
  if (v3 && (BytePtr = CFDataGetBytePtr(v3)) != 0)
    v5 = *((unsigned int *)BytePtr + 1);
  else
    v5 = 0;
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CompactCookieArray@%p> { %d cookies }"), this, v5);
}

void `non-virtual thunk to'CompactCookieArray::~CompactCookieArray(CompactCookieArray *this)
{
  CompactCookieArray::~CompactCookieArray((CompactCookieArray *)((char *)this - 8));
}

{
  CompactCookieArray::~CompactCookieArray((CompactCookieArray *)((char *)this - 8));
}

uint64_t _cookie_header_qsort(CompactCookieHeader **a1, CompactCookieHeader **a2)
{
  return cookieHeaderSort(*a1, *a2);
}

CompactCookieArray *CompactCookieArray::makeCompactCookieArray(CompactCookieArray *this, const __CFAllocator *a2, const __CFArray *a3)
{
  _QWORD *Instance;
  CompactCookieArray *v5;
  const __CFAllocator *v6;
  __CFData *Mutable;
  unsigned int Count;
  const void **v9;
  id *v10;
  uint64_t v11;
  uint64_t v12;
  CFMutableDataRef v13;
  CFMutableDataRef v15;
  _OWORD v16[16];
  uint64_t v17;
  CFRange v18;

  v17 = *MEMORY[0x1E0C80C00];
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  v5 = (CompactCookieArray *)Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    v5 = (CompactCookieArray *)(Instance + 2);
    Instance[4] = 0;
  }
  *(_QWORD *)v5 = &off_1E14E92A8;
  *((_QWORD *)v5 + 1) = &unk_1E14E92F0;
  v6 = CFGetAllocator((char *)v5 - 16);
  Mutable = CFDataCreateMutable(v6, 0);
  v15 = Mutable;
  Count = CFArrayGetCount(a2);
  if (Count < 0x21uLL)
    v9 = (const void **)v16;
  else
    v9 = (const void **)operator new[]();
  memset(v16, 0, sizeof(v16));
  v18.location = 0;
  v18.length = Count;
  CFArrayGetValues(a2, v18, v9);
  if (Count)
  {
    v10 = (id *)v9;
    v11 = Count;
    do
    {
      v12 = objc_msgSend(*v10, "_inner");
      *v10++ = (id)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
      --v11;
    }
    while (v11);
  }
  qsort(v9, Count, 8uLL, (int (__cdecl *)(const void *, const void *))_cookie_header_qsort);
  v13 = CookieArrayViewConstructionKit::createArrayView(&v15, (const CompactCookieHeader **)v9, Count);
  if (v9 != (const void **)v16)
    MEMORY[0x186DB7474](v9, 0xC0C80B8AA526DLL);
  *((_QWORD *)v5 + 2) = v13;
  if (Mutable)
    CFRelease(Mutable);
  if (!CompactCookieArray::assertCookiesValid(v5))
  {
    CFRelease((char *)v5 - 16);
    return 0;
  }
  return v5;
}

void sub_1840ACAEC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

void sub_1840ACC10(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_1840ACC6C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*)::SrcDecanter::~SrcDecanter(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14F1DA0;
  free(*(void **)(a1 + 336));
  return a1;
}

void CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*)::SrcDecanter::~SrcDecanter(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14F1DA0;
  free(*(void **)(a1 + 336));
  JUMPOUT(0x186DB748CLL);
}

const UInt8 *CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*)::SrcDecanter::getEnumeratedString(uint64_t a1, int a2)
{
  if (a2 == 15)
    return *(const UInt8 **)(a1 + 336);
  else
    return CompactCookieHeader::getEnumeratedString(*(CompactCookieHeader **)(a1 + 328), a2, 0);
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*)::SrcDecanter::getPortCount(uint64_t a1)
{
  _DWORD *v1;

  v1 = *(_DWORD **)(a1 + 328);
  if (*v1 >= 0x10u)
    return v1[3];
  else
    return 0;
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*)::SrcDecanter::getVersion(uint64_t a1)
{
  _DWORD *v1;

  v1 = *(_DWORD **)(a1 + 328);
  if (*v1 >= 8u)
    return v1[1];
  else
    return 0;
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*)::SrcDecanter::getFlags(uint64_t a1)
{
  _DWORD *v1;

  v1 = *(_DWORD **)(a1 + 328);
  if (*v1 >= 0xCu)
    return v1[2] & 0x7FLL;
  else
    return 0;
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*)::SrcDecanter::getPort(uint64_t a1, int a2)
{
  unsigned int *v2;
  uint64_t v3;
  unsigned __int16 *v4;
  uint64_t v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  BOOL v8;
  BOOL v9;

  v2 = *(unsigned int **)(a1 + 328);
  v3 = (2 * a2 + 56);
  v4 = (unsigned __int16 *)((char *)v2 + v3);
  v5 = *v2;
  v6 = (unsigned __int16 *)((char *)v2 + v5);
  v7 = v4 + 1;
  if (v5 > v3)
  {
    v8 = v7 >= v6;
    v9 = v7 == v6;
  }
  else
  {
    v8 = 1;
    v9 = 0;
  }
  if (!v9 && v8)
    return 0;
  else
    return *v4;
}

BOOL CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*)::SrcDecanter::getExpireTime(uint64_t a1)
{
  _DWORD *v1;

  v1 = *(_DWORD **)(a1 + 328);
  return *v1 < 0xCu || (v1[2] & 2) == 0;
}

double CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*)::SrcDecanter::getCreateTime(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 328);
  if (*(_DWORD *)v1 >= 0x38u)
    return floor(*(double *)(v1 + 48));
  else
    return 0.0;
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*)::SrcDecanter::shouldFreeEnumeratedString()
{
  return 0;
}

void CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::~PropDecanter(_QWORD *a1)
{
  CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::~PropDecanter(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getPort(uint64_t a1, CFIndex idx)
{
  unsigned int v2;
  const __CFArray *v4;
  const __CFString *ValueAtIndex;
  uint64_t v7;
  uint8_t buf[16];

  v2 = idx;
  v4 = *(const __CFArray **)(a1 + 336);
  if (!v4)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "You need a port array to get a port", buf, 2u);
      v4 = *(const __CFArray **)(a1 + 336);
    }
    else
    {
      v4 = 0;
    }
  }
  v7 = 0;
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, v2);
  CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::valueToCFIndex(ValueAtIndex, &v7);
  return (unsigned __int16)v7;
}

uint64_t CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::shouldFreeEnumeratedString()
{
  return 1;
}

CFStringRef CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureOriginURLToDomain(int a1, const __CFString *cf)
{
  CFTypeID v3;
  CFTypeID v5;
  const __CFAllocator *v6;
  const __CFURL *v7;
  CFStringRef v8;

  v3 = CFGetTypeID(cf);
  if (v3 == CFURLGetTypeID())
    return CFURLCopyHostName((CFURLRef)cf);
  v5 = CFGetTypeID(cf);
  if (v5 != CFStringGetTypeID())
    return 0;
  v6 = CFGetAllocator(cf);
  v7 = CFURLCreateWithString(v6, cf, 0);
  v8 = CFURLCopyHostName(v7);
  CFRelease(v7);
  return v8;
}

CFStringRef CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureDomainToOriginURL(uint64_t a1, CFTypeRef cf)
{
  const __CFAllocator *v4;
  char v5;
  const char *v6;

  v4 = CFGetAllocator(cf);
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v6 = "https";
  if ((v5 & 1) == 0)
    v6 = "http";
  return CFStringCreateWithFormat(v4, 0, CFSTR("%s://%@/"), v6, cf);
}

void CoreLoggable::~CoreLoggable(CoreLoggable *this)
{
  this->var0 = (void **)&off_1E14E5838;
}

{
  this->var0 = (void **)&off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

void HTTPConnection::errorOccurred(HTTPConnection *this, CFStreamError a2)
{
  HTTPConnection::_onqueue_errorOccurred(this, a2, 0);
}

uint64_t HTTPConnection::alternatePathAvailable(HTTPConnection *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t *TransactionItr;
  uint64_t v6;
  uint64_t *v7;
  BOOL v8;
  CFStreamError v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t v14;
  _BOOL4 v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CFStreamError v21;

  v21 = (CFStreamError)xmmword_1841E38A0;
  v4 = *((_QWORD *)this + 20);
  if (v4)
  {
    TransactionItr = HTTPConnection::_onqueue_getTransactionItr(*((_QWORD **)this + 15), *((_QWORD **)this + 16), v4);
    v6 = *((_QWORD *)this + 18);
    if (v6)
      v7 = HTTPConnection::_onqueue_getTransactionItr(*((_QWORD **)this + 15), *((_QWORD **)this + 16), v6) + 2;
    else
      v7 = (uint64_t *)*((_QWORD *)this + 16);
    while (1)
    {
      v8 = TransactionItr != v7;
      if (TransactionItr == v7)
      {
LABEL_19:
        v9.domain = v21.domain;
        goto LABEL_20;
      }
      v10 = *TransactionItr;
      v11 = (std::__shared_weak_count *)TransactionItr[1];
      if (v11)
      {
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
      }
      v14 = *(_QWORD *)(v10 + 208);
      if (v14)
      {
        v15 = (*(unsigned int (**)(uint64_t, CFStreamError *, _QWORD))(*(_QWORD *)v14 + 280))(v14, &v21, 0)- 5 < 6;
        if (v11)
          goto LABEL_14;
      }
      else
      {
        v15 = 0;
        if (v11)
        {
LABEL_14:
          v16 = (unint64_t *)&v11->__shared_owners_;
          do
            v17 = __ldaxr(v16);
          while (__stlxr(v17 - 1, v16));
          if (!v17)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }
      }
      TransactionItr += 2 * v15;
      if (!v15)
        goto LABEL_19;
    }
  }
  v8 = 0;
  v9.domain = 4;
LABEL_20:
  *(_QWORD *)&v9.error = *(_QWORD *)&v21.error;
  if ((a2 & 0xFFFFFFFD) != 1 || v8)
  {
    HTTPConnection::_onqueue_doNotAllowMoreRequests(this, v9, 0);
    v18 = *((_QWORD *)this + 20);
    if (v18)
    {
      v19 = *(_QWORD *)(v18 + 208);
      if (v19)
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v19 + 248))(v19, a2);
    }
  }
  else
  {
    HTTPConnection::_onqueue_errorOccurred(this, v9, 0);
  }
  return 1;
}

void sub_1840AD1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'HTTPConnection::~HTTPConnection(HTTPConnection *this)
{
  HTTPConnection::~HTTPConnection((HTTPConnection *)((char *)this - 24));
}

{
  HTTPConnection::~HTTPConnection((HTTPConnection *)((char *)this - 24));
  JUMPOUT(0x186DB748CLL);
}

void HTTPConnection::_onqueue_errorOccurred(HTTPConnection *this, CFStreamError a2, unsigned int a3)
{
  int v3;
  uint64_t v4;
  unsigned int v6;
  CFIndex domain;
  uint64_t *i;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  NSObject *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  HTTPEngine *v25;
  int v26;
  int v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v37;
  std::__shared_weak_count *v38;
  _QWORD block[6];
  std::__shared_weak_count *v40;
  CFIndex v41;
  uint64_t v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  __n128 (*v46)(__n128 *, __n128 *);
  uint64_t (*v47)(uint64_t);
  void *v48;
  uint64_t v49;
  std::__shared_weak_count *v50;

  v3 = *((unsigned __int16 *)this + 16);
  if ((v3 & 0x20) == 0)
  {
    v4 = *(_QWORD *)&a2.error;
    v6 = v3 & 0xFFFFFFFE | (*((unsigned __int8 *)this + 34) << 16);
    *((_BYTE *)this + 34) = BYTE2(v6);
    *((_WORD *)this + 16) = v6 | 0x20;
    *(_QWORD *)&a2.error = *((_QWORD *)this + 20);
    if (*(_QWORD *)&a2.error)
    {
      domain = a2.domain;
      for (i = &HTTPConnection::_onqueue_getTransactionItr(*((_QWORD **)this + 15), *((_QWORD **)this + 16), *(uint64_t *)&a2.error)[2 * a3]; i != *((uint64_t **)this + 16); i += 2)
      {
        v10 = *i;
        v9 = (std::__shared_weak_count *)i[1];
        if (v9)
        {
          p_shared_owners = (unint64_t *)&v9->__shared_owners_;
          do
            v12 = __ldxr(p_shared_owners);
          while (__stxr(v12 + 1, p_shared_owners));
        }
        if (v10 == *((_QWORD *)this + 18))
          *((_WORD *)this + 16) |= 0x800u;
        v43 = 0;
        v44 = (std::__shared_weak_count *)&v43;
        v45 = 0x4012000000;
        v46 = __Block_byref_object_copy__12;
        v47 = __Block_byref_object_dispose__13;
        v48 = &unk_18422E08D;
        v49 = 0;
        v50 = 0;
        v13 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
        if (v13)
        {
          v50 = std::__shared_weak_count::lock(v13);
          if (v50)
            v49 = *((_QWORD *)this + 5);
        }
        v14 = *((_QWORD *)this + 7);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3321888768;
        block[2] = ___ZN14HTTPConnection22_onqueue_errorOccurredE13CFStreamErrorb_block_invoke;
        block[3] = &unk_1E14F4340;
        block[5] = v10;
        v40 = v9;
        if (v9)
        {
          v15 = (unint64_t *)&v9->__shared_owners_;
          do
            v16 = __ldxr(v15);
          while (__stxr(v16 + 1, v15));
        }
        v41 = domain;
        v42 = v4;
        block[4] = &v43;
        dispatch_async(v14, block);
        v17 = v40;
        if (v40)
        {
          v18 = (unint64_t *)&v40->__shared_owners_;
          do
            v19 = __ldaxr(v18);
          while (__stlxr(v19 - 1, v18));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
        _Block_object_dispose(&v43, 8);
        v20 = v50;
        if (!v50)
          goto LABEL_24;
        v21 = (unint64_t *)&v50->__shared_owners_;
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
          if (v9)
          {
LABEL_25:
            v23 = (unint64_t *)&v9->__shared_owners_;
            do
              v24 = __ldaxr(v23);
            while (__stlxr(v24 - 1, v23));
            if (!v24)
            {
              ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
              std::__shared_weak_count::__release_weak(v9);
            }
          }
        }
        else
        {
LABEL_24:
          if (v9)
            goto LABEL_25;
        }
      }
    }
    if (a3)
    {
      HTTPConnection::_onqueue_cleanupEngineWhenPossible(this, 0);
    }
    else
    {
      v25 = (HTTPEngine *)*((_QWORD *)this + 8);
      if (v25)
      {
        v26 = *((unsigned __int16 *)this + 16);
        v27 = v26 | (*((unsigned __int8 *)this + 34) << 16);
        if ((v26 & 0x100) == 0)
        {
          *((_BYTE *)this + 34) = BYTE2(v27);
          *((_WORD *)this + 16) = v27 | 0x100;
          HTTPEngine::_cleanupConnection(v25, 0);
        }
      }
    }
    v43 = 0;
    v44 = 0;
    v28 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
    if (v28)
    {
      v44 = std::__shared_weak_count::lock(v28);
      if (v44)
      {
        v29 = *((_QWORD *)this + 10);
        v43 = v29;
        if (v29)
        {
          std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v37, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v29 + 40))(v29, &v37);
          v30 = v38;
          if (v38)
          {
            v31 = (unint64_t *)&v38->__shared_owners_;
            do
              v32 = __ldaxr(v31);
            while (__stlxr(v32 - 1, v31));
            if (!v32)
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
          }
        }
      }
    }
    v33 = v44;
    if (v44)
    {
      v34 = (unint64_t *)&v44->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
  }
}

void sub_1840AD580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__12(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__13(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN14HTTPConnection31_onqueue_doNotAllowMoreRequestsE13CFStreamErrorb_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  __int128 v5;

  HTTPTransaction::errorOccurred(*(HTTPTransaction **)(a1 + 40), *(CFStreamError *)(a1 + 56));
  v5 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, &v5);
  v2 = (std::__shared_weak_count *)*((_QWORD *)&v5 + 1);
  if (*((_QWORD *)&v5 + 1))
  {
    v3 = (unint64_t *)(*((_QWORD *)&v5 + 1) + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

uint64_t __copy_helper_block_e8_40c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void ___ZN14HTTPConnection22_onqueue_errorOccurredE13CFStreamErrorb_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  __int128 v5;

  HTTPTransaction::errorOccurred(*(HTTPTransaction **)(a1 + 40), *(CFStreamError *)(a1 + 56));
  v5 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, &v5);
  v2 = (std::__shared_weak_count *)*((_QWORD *)&v5 + 1);
  if (*((_QWORD *)&v5 + 1))
  {
    v3 = (unint64_t *)(*((_QWORD *)&v5 + 1) + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

BOOL HTTPConnectionAuthenticator::applyToRequest(HTTPConnectionAuthenticator *this, HTTPRequestMessage *a2, void *a3, _BOOL8 a4)
{
  _BOOL8 v4;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  char v13;
  _BYTE v14[24];
  _BYTE *v15;
  uint64_t v16;

  v4 = a4;
  v16 = *MEMORY[0x1E0C80C00];
  if (this)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
    if (!v4)
      goto LABEL_17;
LABEL_5:
    if (*((_QWORD *)this + 13))
      v8 = 0;
    else
      v8 = *((_QWORD *)this + 16) == 0;
    v4 = 0;
    if (!a2 || v8)
      goto LABEL_17;
    v13 = 1;
    v9 = operator new(0x20uLL);
    *v9 = &off_1E14F0678;
    v9[1] = a2;
    v9[2] = a3;
    v9[3] = &v13;
    v15 = v9;
    AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v14);
    v10 = v15;
    if (v15 == v14)
    {
      v11 = 4;
      v10 = v14;
    }
    else
    {
      if (!v15)
      {
LABEL_16:
        v4 = v13 != 0;
LABEL_17:
        pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
        return v4;
      }
      v11 = 5;
    }
    (*(void (**)(void))(*v10 + 8 * v11))();
    goto LABEL_16;
  }
  if (a4)
    goto LABEL_5;
  return 0;
}

void sub_1840AD850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v13;
  char *v14;
  char *v16;
  uint64_t v17;

  v16 = a13;
  if (a13 == v14)
  {
    v17 = 4;
    v16 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v16 + 8 * v17))();
LABEL_6:
  pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'HTTPConnectionAuthenticator::~HTTPConnectionAuthenticator(HTTPConnectionAuthenticator *this)
{
  HTTPConnectionAuthenticator::~HTTPConnectionAuthenticator((HTTPConnectionAuthenticator *)((char *)this - 88));
}

{
  HTTPConnectionAuthenticator::~HTTPConnectionAuthenticator((HTTPConnectionAuthenticator *)((char *)this - 88));
  JUMPOUT(0x186DB748CLL);
}

void std::__function::__func<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E14F0678;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F0678;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, AuthenticationInfo **a3)
{
  int v5;
  BOOL *v6;
  BOOL v7;

  if (AuthenticationInfo::canApplyHeadersToRequest(*a3, *(HTTPRequestMessage **)(a1 + 8))
    && HTTPAuthentication::isKerberosThePreferredAuthScheme(*(const __CFDictionary **)(*((_QWORD *)*a3 + 1) + 136)))
  {
    v5 = AuthenticationInfo::applyToRequest(*a3, *(HTTPRequestMessage **)(a1 + 8), *(void **)(a1 + 16));
    v6 = *(BOOL **)(a1 + 24);
    if (v5)
      v7 = *v6;
    else
      v7 = 0;
    *v6 = v7;
  }
  return 1;
}

void HTTPConnection::_onqueue_cleanupEngine(HTTPConnection *this)
{
  HTTPEngine *v2;
  int v3;
  int v4;

  v2 = (HTTPEngine *)*((_QWORD *)this + 8);
  if (v2)
  {
    v3 = *((unsigned __int16 *)this + 16);
    v4 = v3 | (*((unsigned __int8 *)this + 34) << 16);
    if ((v3 & 0x100) == 0)
    {
      *((_BYTE *)this + 34) = BYTE2(v4);
      *((_WORD *)this + 16) = v4 | 0x100;
      HTTPEngine::_cleanupConnection(v2, 0);
    }
  }
}

__n128 __Block_byref_object_copy__11566(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__11567(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void std::allocate_shared[abi:nn180100]<HTTPConnectionAuthenticator,std::allocator<HTTPConnectionAuthenticator>,std::weak_ptr<HTTPConnection> &,std::shared_ptr<HTTPEngine> &,void>(std::__shared_weak_count_vtbl **a1, uint64_t a2, std::__shared_weak_count *a3, std::__shared_weak_count_vtbl **a4)
{
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  std::__shared_weak_count_vtbl *v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count_vtbl *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  std::__shared_weak_count *shared_owners;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;

  v8 = (std::__shared_weak_count *)operator new(0x118uLL);
  v9 = v8;
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0E88;
  v11 = (std::__shared_weak_count_vtbl *)&v8[1];
  if (a3)
  {
    p_shared_weak_owners = (unint64_t *)&a3->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
  }
  v15 = *a4;
  v14 = (std::__shared_weak_count *)a4[1];
  if (v14)
  {
    v16 = (unint64_t *)&v14->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  AuthenticationState::AuthenticationState((AuthenticationState *)&v8[1]);
  v9[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14EDD90;
  v9[4].__shared_weak_owners_ = (uint64_t)&unk_1E14EDDC0;
  v9[7].__shared_owners_ = a2;
  v9[7].__shared_weak_owners_ = (uint64_t)a3;
  if (a3)
  {
    v18 = (unint64_t *)&a3->__shared_weak_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v9[8].__vftable = v15;
  v9[8].__shared_owners_ = (uint64_t)v14;
  if (v14)
  {
    v20 = (unint64_t *)&v14->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
    v9[10].std::__shared_count = 0u;
    *(_OWORD *)&v9[10].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v9[8].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v9[9].__shared_owners_ = 0u;
    *(_DWORD *)((char *)&v9[11].__vftable + 7) = 0;
    do
      v22 = __ldaxr(v20);
    while (__stlxr(v22 - 1, v20));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  else
  {
    v9[10].std::__shared_count = 0u;
    *(_OWORD *)&v9[10].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v9[8].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v9[9].__shared_owners_ = 0u;
    *(_DWORD *)((char *)&v9[11].__vftable + 7) = 0;
  }
  if (a3)
    std::__shared_weak_count::__release_weak(a3);
  *a1 = v11;
  a1[1] = (std::__shared_weak_count_vtbl *)v9;
  shared_owners = (std::__shared_weak_count *)v9[4].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1)
      return;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
    v25 = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
    v9[4].__vftable = v11;
    v9[4].__shared_owners_ = (uint64_t)v9;
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  else
  {
    do
      v27 = __ldxr(p_shared_owners);
    while (__stxr(v27 + 1, p_shared_owners));
    v28 = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
    v9[4].__vftable = v11;
    v9[4].__shared_owners_ = (uint64_t)v9;
  }
  do
    v30 = __ldaxr(p_shared_owners);
  while (__stlxr(v30 - 1, p_shared_owners));
  if (!v30)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
}

void sub_1840ADC20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  void *v12;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  if (v10)
    std::__shared_weak_count::__release_weak(v10);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v12);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<HTTPConnectionAuthenticator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0E88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTPConnectionAuthenticator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0E88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t HTTPConnection::getPendingResponseCount(HTTPConnection *this)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  v1 = &v5;
  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v2 = *((_QWORD *)this + 20);
  if (v2)
  {
    v3 = (*((_QWORD *)this + 16)
        - (_QWORD)HTTPConnection::_onqueue_getTransactionItr(*((_QWORD **)this + 15), *((_QWORD **)this + 16), v2)) >> 4;
    v1 = v6;
  }
  else
  {
    v3 = 0;
  }
  *((_DWORD *)v1 + 6) = v3;
  _Block_object_dispose(&v5, 8);
  return v3;
}

void sub_1840ADD08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

void ___ZN14HTTPConnection31doNotAllowMoreRequests_offqueueEv_block_invoke(uint64_t a1)
{
  CFStreamError v1;

  v1.domain = 4;
  *(_QWORD *)&v1.error = 4294967292;
  HTTPConnection::_onqueue_doNotAllowMoreRequests(*(HTTPConnection **)(a1 + 32), v1, 0);
}

void ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke_26(uint64_t a1, dispatch_object_t object, CFStreamError a3, unsigned int a4)
{
  uint64_t v5;
  CFIndex domain;
  CFStreamError v9;

  v5 = *(_QWORD *)&a3.error;
  domain = a3.domain;
  if (!a3.error && (a4 & 1) == 0)
    HTTPConnection::_onqueue_checkAndUpdateLargeDownload(*(_QWORD *)(a1 + 32));
  v9.domain = domain;
  *(_QWORD *)&v9.error = v5;
  HTTPConnection::_onqueue_responseDataArrived(*(HTTPConnection **)(a1 + 32), object, v9, a4);
}

void ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke_29(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  const void *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  const char *v28;
  int v29;
  HTTPResponseMessage *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  _QWORD v35[2];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(std::__shared_weak_count **)(a2 + 8);
  v30 = *(HTTPResponseMessage **)a2;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v33 = 0;
  v34 = 0;
  v6 = *(std::__shared_weak_count **)(v2 + 88);
  if (v6)
  {
    v34 = std::__shared_weak_count::lock(v6);
    if (v34)
    {
      v7 = *(_QWORD *)(v2 + 80);
      v33 = v7;
      if (v7)
      {
        std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v31, *(_QWORD *)(v2 + 8), *(std::__shared_weak_count **)(v2 + 16));
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v7 + 32))(v7, &v31);
        v8 = v32;
        if (v32)
        {
          v9 = (unint64_t *)&v32->__shared_owners_;
          do
            v10 = __ldaxr(v9);
          while (__stlxr(v10 - 1, v9));
          if (!v10)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
    }
  }
  v11 = *(_QWORD *)(v2 + 160);
  if (!v11)
  {
    v28 = "_currentResponse";
    v29 = 1548;
    goto LABEL_47;
  }
  if (!v30)
  {
    v28 = "response";
    v29 = 1551;
LABEL_47:
    __assert_rtn("_onqueue_informationalResponseArrived", "HTTPConnection.cpp", v29, v28);
  }
  if (v3)
  {
    v12 = (unint64_t *)&v3->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = *(_QWORD *)(v11 + 208);
  if (v14)
    v15 = (_QWORD *)(v14 - 176);
  else
    v15 = 0;
  v16 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(_QWORD *)(v11 + 160) + 128));
  HTTPResponseMessage::setResponseURL(v30, v16, 0);
  v35[0] = v30;
  v35[1] = v3;
  if (v3)
  {
    v17 = (unint64_t *)&v3->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  HTTPProtocol::handleInformationalResponse(v15, (uint64_t)v35);
  if (v3)
  {
    v19 = (unint64_t *)&v3->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v3)
  {
    v21 = (unint64_t *)&v3->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v23 = v34;
  if (!v34)
    goto LABEL_37;
  v24 = (unint64_t *)&v34->__shared_owners_;
  do
    v25 = __ldaxr(v24);
  while (__stlxr(v25 - 1, v24));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
    if (!v3)
      return;
  }
  else
  {
LABEL_37:
    if (!v3)
      return;
  }
  v26 = (unint64_t *)&v3->__shared_owners_;
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1840AE004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN14HTTPConnection22_onqueue_requestFinishE13CFStreamError_block_invoke_23(_QWORD *a1)
{
  std::__shared_weak_count *v1;
  uint64_t v2;
  NSObject *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD block[6];
  std::__shared_weak_count *v10;

  block[0] = MEMORY[0x1E0C809B0];
  block[2] = ___ZN14HTTPConnection22_onqueue_requestFinishE13CFStreamError_block_invoke_2;
  block[3] = &unk_1E14F2F40;
  v2 = a1[5];
  v1 = (std::__shared_weak_count *)a1[6];
  v3 = *(NSObject **)(v2 + 56);
  block[1] = 3321888768;
  block[5] = v2;
  v10 = v1;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  block[4] = a1[4];
  dispatch_async(v3, block);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void std::__function::__func<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0,std::allocator<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

_QWORD *std::__function::__func<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0,std::allocator<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E14F06C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0,std::allocator<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E14F06C0;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0,std::allocator<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  HTTPAuthentication *v4;
  uint64_t v6;
  _BOOL8 result;

  v4 = *(HTTPAuthentication **)(*(_QWORD *)a3 + 8);
  if (!v4 || !HTTPAuthentication::isConnectionBasedAuth(v4))
    return **(_BYTE **)(a1 + 8) != 0;
  v6 = *(_QWORD *)(*(_QWORD *)a3 + 16);
  if (v6)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    result = *(_DWORD *)(v6 + 52) != 1;
  }
  else
  {
    result = 0;
  }
  **(_BYTE **)(a1 + 8) = result;
  return result;
}

uint64_t ___ZN14HTTPConnection21_onqueue_requestStartEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 1149;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void ___ZN14HTTPConnection37_onqueue_negotiateAuthenticationStartEv_block_invoke(_QWORD *a1, HTTPMessage **a2, dispatch_object_t object, unsigned int a4, CFStreamError a5)
{
  uint64_t v5;
  CFIndex domain;
  uint64_t v9;
  int v10;
  int v11;
  HTTPConnection *v12;
  HTTPMessage *v13;
  HTTPMessage *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  HTTPMessage *v23[2];
  CFStreamError v24;
  CFStreamError v25;

  v5 = *(_QWORD *)&a5.error;
  domain = a5.domain;
  if (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
  {
    v9 = a1[5];
    v10 = *(unsigned __int16 *)(v9 + 32);
    v9 += 32;
    v11 = *(unsigned __int8 *)(v9 + 2);
    *(_WORD *)v9 = v10 & 0xFBFF;
    *(_BYTE *)(v9 + 2) = (v10 & 0xFFFFFBFF | (v11 << 16)) >> 16;
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
  }
  v12 = (HTTPConnection *)a1[6];
  v14 = *a2;
  v13 = a2[1];
  if (v13)
  {
    v15 = (unint64_t *)((char *)v13 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  if (a5.error != -1002 && a5.error)
  {
    HTTPConnection::_onqueue_errorOccurred(v12, a5, 0);
  }
  else if (object || v14 || a4)
  {
    if (v14)
    {
      HTTPConnection::_onqueue_requestFinish(v12, a5);
      v23[0] = v14;
      v23[1] = v13;
      if (v13)
      {
        v17 = (unint64_t *)((char *)v13 + 8);
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }
      v24.domain = domain;
      *(_QWORD *)&v24.error = v5;
      HTTPConnection::_onqueue_responseHeadersArrived(v12, v23, v24);
      if (v13)
      {
        v19 = (unint64_t *)((char *)v13 + 8);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          (*(void (**)(HTTPMessage *))(*(_QWORD *)v13 + 16))(v13);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v13);
        }
      }
    }
    if (object || a4)
    {
      v25.domain = domain;
      *(_QWORD *)&v25.error = v5;
      HTTPConnection::_onqueue_responseDataArrived(v12, object, v25, a4);
    }
  }
  else
  {
    HTTPConnection::_onqueue_attemptNextRequest(v12);
  }
  if (v13)
  {
    v21 = (unint64_t *)((char *)v13 + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      (*(void (**)(HTTPMessage *))(*(_QWORD *)v13 + 16))(v13);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v13);
    }
  }
}

void sub_1840AE434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t *SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::SmartBlockWithArgs(uint64_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  v4[1] = BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_initial;
  v4[2] = 0;
  *v4 = _Block_copy(a2);
  *a1 = (uint64_t)v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F1278;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a1[1] = (uint64_t)v5;
  if (!a2)
  {
    v6 = *a1;
    *(_QWORD *)(v6 + 8) = BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_reseted;
    *(_QWORD *)(v6 + 16) = 0;
  }
  return a1;
}

void sub_1840AE4FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

uint64_t HTTPConnectionAuthenticator::getConnectionIdentifier(HTTPConnectionAuthenticator *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 20);
  if (!v2)
    return 0;
  v3 = std::__shared_weak_count::lock(v2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = *((_QWORD *)this + 19);
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v4);
  }
  return v5;
}

void SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::operator()(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t *p_shared_owners;
  unint64_t v8;
  void (*v9)(_QWORD *, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v10;
  _QWORD *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v20;
  std::__shared_weak_count *v21;

  if (a1)
  {
    if (a3)
    {
      p_shared_owners = (unint64_t *)&a3->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    v9 = *(void (**)(_QWORD *, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8);
    v10 = *(_QWORD *)(a1 + 16);
    v11 = (_QWORD *)(a1 + (v10 >> 1));
    if ((v10 & 1) != 0)
      v9 = *(void (**)(_QWORD *, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(*v11 + v9);
    v20 = a2;
    v21 = a3;
    if (a3)
    {
      v12 = (unint64_t *)&a3->__shared_owners_;
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    v9(v11, &v20, a4, a5, a6, a7);
    v14 = v21;
    if (v21)
    {
      v15 = (unint64_t *)&v21->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    if (a3)
    {
      v17 = (unint64_t *)&a3->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
        std::__shared_weak_count::__release_weak(a3);
      }
    }
  }
}

void sub_1840AE688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTPConnectionAuthenticator::errorOccurred(HTTPConnectionAuthenticator *this, CFStreamError a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;

  v11 = 0;
  v12 = 0;
  SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::operator()(*((_QWORD *)this + 29), 0, 0, 0, 0, a2.domain, *(uint64_t *)&a2.error);
  SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::SmartBlockWithArgs((uint64_t *)&v10, 0);
  v3 = v10;
  v10 = 0uLL;
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 30);
  *(_OWORD *)((char *)this + 232) = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  v7 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
  if (*((_QWORD *)&v10 + 1))
  {
    v8 = (unint64_t *)(*((_QWORD *)&v10 + 1) + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_1840AE774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN27HTTPConnectionAuthenticator12writeRequestEv_block_invoke(uint64_t a1, CFStreamError a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[6];
  _QWORD v18[5];
  _QWORD v19[3];
  char v20;

  v2 = *(_QWORD *)(a1 + 32);
  if (a2.error)
  {
    HTTPConnectionAuthenticator::errorOccurred(*(HTTPConnectionAuthenticator **)(a1 + 32), a2);
  }
  else
  {
    v19[0] = 0;
    v19[1] = v19;
    v19[2] = 0x2020000000;
    v20 = 0;
    v3 = *(_QWORD *)(v2 + 168);
    v4 = *(_QWORD *)(v2 + 200);
    v5 = *(std::__shared_weak_count **)(v2 + 208);
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    v17[5] = v2;
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = ___ZN27HTTPConnectionAuthenticator12readResponseEv_block_invoke;
    v18[3] = &__block_descriptor_40_e93_v40__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8___qi_24l;
    v18[4] = v2;
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 3221225472;
    v17[2] = ___ZN27HTTPConnectionAuthenticator12readResponseEv_block_invoke_2;
    v17[3] = &unk_1E14FBA50;
    v17[4] = v19;
    HTTPEngine::readResponse(v3, v4, (uint64_t)v5, 0, v18, v17, &__block_literal_global_41_11623);
    if (v5)
    {
      v8 = (unint64_t *)&v5->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    v10 = *(std::__shared_weak_count **)(v2 + 160);
    if (v10)
    {
      v11 = std::__shared_weak_count::lock(v10);
      if (v11)
      {
        v12 = v11;
        v13 = *(_QWORD *)(v2 + 152);
        if (v13)
        {
          v14 = *(_QWORD *)(v13 + 160);
          if (v14)
          {
            if (!HTTPTransaction::requestExpectsResponseBody(*(HTTPTransaction **)(v14 + 160)))
              HTTPEngine::setProperty(*(HTTPEngine **)(v2 + 168), (CFStringRef)&unk_1EDCFE508, (const void *)*MEMORY[0x1E0C9AE50]);
          }
        }
        v15 = (unint64_t *)&v12->__shared_owners_;
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
    }
    if (*(_BYTE *)(v2 + 250))
      *(_DWORD *)(*(_QWORD *)(v2 + 168) + 32) |= 0x400u;
    _Block_object_dispose(v19, 8);
  }
}

void sub_1840AE940(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  uint64_t v2;
  unint64_t *p_shared_owners;
  unint64_t v5;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Block_object_dispose((const void *)(v2 - 48), 8);
  _Unwind_Resume(a1);
}

void ___ZN27HTTPConnectionAuthenticator12readResponseEv_block_invoke(uint64_t a1, uint64_t *a2, CFStreamError a3)
{
  uint64_t v3;
  HTTPResponseMessage *v4;
  int v5;
  void *ConnectionIdentifier;
  int v7;
  HTTPRequestMessage *v8;
  void *v9;
  uint64_t Auth;
  CFIndex v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint8_t v18[16];
  CFStreamError v19;

  v3 = *(_QWORD *)(a1 + 32);
  if (a3.error)
  {
    HTTPConnectionAuthenticator::errorOccurred(*(HTTPConnectionAuthenticator **)(a1 + 32), a3);
    return;
  }
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v3 + 216), *a2, a2[1]);
  v4 = *(HTTPResponseMessage **)(v3 + 216);
  v5 = *((_DWORD *)v4 + 32);
  if (!*(_BYTE *)(v3 + 249) && v5 == 407)
  {
    *(_BYTE *)(v3 + 249) = 1;
LABEL_8:
    ConnectionIdentifier = (void *)HTTPConnectionAuthenticator::getConnectionIdentifier((HTTPConnectionAuthenticator *)v3);
    AuthenticationState::updateWithResponse(v3, v4, ConnectionIdentifier);
    if (*(_BYTE *)(v3 + 249))
      v7 = 2;
    else
      v7 = 1;
    if (AuthenticationState::isValid(v3, v7))
    {
      v8 = *(HTTPRequestMessage **)(v3 + 184);
      v9 = (void *)HTTPConnectionAuthenticator::getConnectionIdentifier((HTTPConnectionAuthenticator *)v3);
      AuthenticationState::applyToRequest((AuthenticationState *)v3, v8, v9, 1);
      return;
    }
    Auth = AuthenticationState::getAuth((AuthenticationState *)v3, *(unsigned __int8 *)(v3 + 249));
    if (Auth)
    {
      v11 = *(_QWORD *)(Auth + 88);
      v12 = *(_QWORD *)(Auth + 96);
      if ((_DWORD)v12)
      {
LABEL_27:
        v19.domain = v11;
        *(_QWORD *)&v19.error = v12;
        HTTPConnectionAuthenticator::errorOccurred((HTTPConnectionAuthenticator *)v3, v19);
        return;
      }
    }
    else
    {
      v11 = 0;
      v12 = 0;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v18 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Auth is not valid but we don't have an error", v18, 2u);
    }
    goto LABEL_27;
  }
  if (v5 == 407 || v5 == 401)
    goto LABEL_8;
  *(_BYTE *)(v3 + 248) = 1;
  v13 = *(std::__shared_weak_count **)(v3 + 224);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::operator()(*(_QWORD *)(v3 + 232), (uint64_t)v4, v13, 0, 0, 0, 0);
  if (v13)
  {
    v16 = (unint64_t *)&v13->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1840AEBA0(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void ___ZN27HTTPConnectionAuthenticator12readResponseEv_block_invoke_2(uint64_t a1, uint64_t a2, CFStreamError a3, char a4)
{
  uint64_t v7;

  v7 = *(_QWORD *)(a1 + 40);
  if (a3.error)
    HTTPConnectionAuthenticator::errorOccurred(*(HTTPConnectionAuthenticator **)(a1 + 40), a3);
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    HTTPEngine::resetResponse(*(HTTPEngine **)(v7 + 168));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  if ((a4 & 1) != 0)
  {
    if (*(_BYTE *)(v7 + 248))
      SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::operator()(*(_QWORD *)(v7 + 232), 0, 0, a2, 1, 0, 0);
    else
      SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::operator()(*(_QWORD *)(v7 + 232), 0, 0, 0, 0, 0, 0);
  }
  else if (*(_BYTE *)(v7 + 248))
  {
    SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::operator()(*(_QWORD *)(v7 + 232), 0, 0, a2, 0, 0, 0);
  }
}

void sub_1840AECD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_initial(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_normal;
  a1[2] = 0;
  v2 = *a1;
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1840AED9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void (*v3)(uint64_t *, uint64_t *);
  BOOL v4;
  int v5;
  _QWORD *v7;
  void (*v8)(uint64_t *, uint64_t *);
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(void (**)(uint64_t *, uint64_t *))(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | (unint64_t)v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if (v3 == BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_initial
    && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      v8 = *(void (**)(uint64_t *, uint64_t *))(*v7
                                                       + BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_initial);
    else
      v8 = BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_initial;
    v13 = 0;
    v14 = 0;
    ((void (*)(_QWORD *, uint64_t *, _QWORD, _QWORD, _QWORD, _QWORD))v8)(v7, &v13, 0, 0, 0, 0);
    v9 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  _Block_release(*(const void **)v1);
  return MEMORY[0x186DB748C](v1, 0x80C40D6874129);
}

void sub_1840AEEC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

void BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_normal(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *a1;
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1840AEF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t ___ZN14HTTPConnection38_onqueue_cleanAbortRequestTransmissionEv_block_invoke(uint64_t a1)
{
  return HTTPConnection::_onqueue_attemptNextRequest(*(HTTPConnection **)(a1 + 32));
}

void std::__function::__func<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0,std::allocator<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

__n128 std::__function::__func<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0,std::allocator<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E14F0708;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0,std::allocator<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E14F0708;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0,std::allocator<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  HTTPAuthentication *v4;

  v4 = *(HTTPAuthentication **)(*(_QWORD *)a3 + 8);
  if (v4 && HTTPAuthentication::isConnectionBasedAuth(v4) && *(_DWORD *)(*(_QWORD *)a3 + 24) != 2)
    **(_BYTE **)(a1 + 16) = 1;
  return **(_BYTE **)(a1 + 16) == 0;
}

id AppSSO::AppSSOLog(AppSSO *this)
{
  if (AppSSO::AppSSOLog(void)::onceToken != -1)
    dispatch_once(&AppSSO::AppSSOLog(void)::onceToken, &__block_literal_global_11642);
  return (id)AppSSO::AppSSOLog(void)::ssoLog;
}

void ___ZN6AppSSO9AppSSOLogEv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.CFNetwork", "AppSSO");
  v1 = (void *)AppSSO::AppSSOLog(void)::ssoLog;
  AppSSO::AppSSOLog(void)::ssoLog = (uint64_t)v0;

}

uint64_t AppSSO::isPerformDefaultHandlingError(AppSSO *this, __CFError *a2)
{
  AppSSO *v2;
  void *v3;
  double v4;
  double Helper_x8__SOErrorDomain;
  uint64_t v6;
  id v7;
  uint64_t v8;

  v2 = this;
  if (-[AppSSO code](v2, "code") == -5)
  {
    -[AppSSO domain](v2, "domain");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    Helper_x8__SOErrorDomain = gotLoadHelper_x8__SOErrorDomain(v4);
    v8 = objc_msgSend(v7, "isEqualToString:", **(_QWORD **)(v6 + 1776), Helper_x8__SOErrorDomain);

  }
  else
  {
    v8 = 0;
  }

  return v8;
}

void sub_1840AF188(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZN6AppSSO11getResponseENSt3__110shared_ptrIK10__CFStringEEPK7__CFURLPK14__CFDictionaryPK8__CFDataSD_18SmartBlockWithArgsIJU8__strongP13NSURLResponseSD_P9__CFErrorEE_block_invoke_5(AppSSO *a1, void *a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  id v10;
  void *v11;
  uint64_t v12;
  id v13;
  void (*v14)(_QWORD *, id, uint64_t, uint64_t);
  uint64_t v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  void *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  AppSSO::AppSSOLog(a1);
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = *((_QWORD *)a1 + 4);
    v17 = 138544130;
    v18 = v9;
    v19 = 2112;
    v20 = a2;
    v21 = 2112;
    v22 = a3;
    v23 = 2112;
    v24 = a4;
    _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "getResponse %{public}@ response=%@ body=%@ error=%@", (uint8_t *)&v17, 0x2Au);
  }

  v10 = a2;
  v11 = v10;
  v12 = *((_QWORD *)a1 + 6);
  if (v12)
  {
    v13 = v10;
    v14 = *(void (**)(_QWORD *, id, uint64_t, uint64_t))(v12 + 8);
    v15 = *(_QWORD *)(v12 + 16);
    v16 = (_QWORD *)(v12 + (v15 >> 1));
    if ((v15 & 1) != 0)
      v14 = *(void (**)(_QWORD *, id, uint64_t, uint64_t))(*v16 + v14);
    v14(v16, v13, a3, a4);

  }
}

void sub_1840AF2C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrIK10__CFStringEE48c76_ZTS18SmartBlockWithArgsIJU8__strongP13NSURLResponsePK8__CFDataP9__CFErrorEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrIK10__CFStringEE48c76_ZTS18SmartBlockWithArgsIJU8__strongP13NSURLResponsePK8__CFDataP9__CFErrorEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void AppSSO::getAuthHeaders(AppSSO *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  uint8_t buf[4];
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (AppSSO::ssoOptionFlag(void)::onceToken != -1)
    dispatch_once(&AppSSO::ssoOptionFlag(void)::onceToken, &__block_literal_global_12_11654);
  if (AppSSO::ssoOptionFlag(void)::flag)
    v14 = 2;
  else
    v14 = 0;
  AppSSO::AppSSOLog(a1);
  v15 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    v16 = *(_QWORD *)a1;
    *(_DWORD *)buf = 138545154;
    v30 = v16;
    v31 = 2048;
    v32 = v14;
    v33 = 2112;
    v34 = a2;
    v35 = 2112;
    v36 = a3;
    v37 = 2048;
    v38 = 401;
    v39 = 2048;
    v40 = a4;
    v41 = 2112;
    v42 = a5;
    v43 = 2112;
    v44 = a6;
    _os_log_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEFAULT, "getAuthHeaders %{public}@ flag %lu url %@ headers %@ code %ld failureCount %ld token %@ bundle %@", buf, 0x52u);
  }

  v17 = (std::__shared_weak_count *)*((_QWORD *)a1 + 1);
  v27 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldxr(p_shared_owners);
    while (__stxr(v19 + 1, p_shared_owners));
  }
  v20 = *(std::__shared_weak_count **)(a7 + 8);
  v28 = v20;
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  appSSO_handleResponseImpersonationCredential_delayInitStub(COERCE_DOUBLE(3321888768));
  if (v28)
  {
    v23 = (unint64_t *)&v28->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  if (v27)
  {
    v25 = (unint64_t *)&v27->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
}

void sub_1840AF5B4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN6AppSSO14getAuthHeadersENSt3__110shared_ptrIK10__CFStringEEPK7__CFURLPK14__CFDictionaryllPK8__CFDataPS3_18SmartBlockWithArgsIJSA_P9__CFErrorEE_block_invoke_9(AppSSO *a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(_QWORD *, uint64_t, uint64_t);
  uint64_t v10;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  AppSSO::AppSSOLog(a1);
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *((_QWORD *)a1 + 4);
    v12 = 138543874;
    v13 = v7;
    v14 = 2112;
    v15 = a2;
    v16 = 2112;
    v17 = a3;
    _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "getAuthHeaders %{public}@ headers=%@ error=%@", (uint8_t *)&v12, 0x20u);
  }

  v8 = *((_QWORD *)a1 + 6);
  if (v8)
  {
    v9 = *(void (**)(_QWORD *, uint64_t, uint64_t))(v8 + 8);
    v10 = *(_QWORD *)(v8 + 16);
    v11 = (_QWORD *)(v8 + (v10 >> 1));
    if ((v10 & 1) != 0)
      v9 = *(void (**)(_QWORD *, uint64_t, uint64_t))(*v11 + v9);
    v9(v11, a2, a3);
  }
}

_QWORD *__copy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrIK10__CFStringEE48c57_ZTS18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrIK10__CFStringEE48c57_ZTS18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void TLSCallbackClientCertificate::~TLSCallbackClientCertificate(TLSCallbackClientCertificate *this)
{
  TLSCallbackClientCertificate::~TLSCallbackClientCertificate(this);
  JUMPOUT(0x186DB748CLL);
}

{
  const void *v2;
  const void *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;

  *(_QWORD *)this = &off_1E14EEA80;
  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
  {
    _Block_release(v2);
    *((_QWORD *)this + 7) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 8);
  if (v3)
  {
    _Block_release(v3);
    *((_QWORD *)this + 8) = 0;
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 88);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 72);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 40);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  *(_QWORD *)this = &off_1E14E5838;
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

void sub_1840AF808(_Unwind_Exception *a1)
{
  _QWORD *v1;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 11));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 9));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 5));
  v3 = (std::__shared_weak_count *)v1[4];
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  *v1 = &off_1E14E5838;
  v4 = (std::__shared_weak_count *)v1[2];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  _Unwind_Resume(a1);
}

uint64_t **std::unique_ptr<std::list<std::shared_ptr<TLSCallbackClientCertificate>>>::reset[abi:nn180100](uint64_t **result, uint64_t *a2)
{
  uint64_t *v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::__list_imp<std::shared_ptr<AuthenticationState>>::clear(v2);
    JUMPOUT(0x186DB748CLL);
  }
  return result;
}

uint64_t **std::unique_ptr<std::list<std::shared_ptr<TLSCallbackServerTrust>>>::reset[abi:nn180100](uint64_t **result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    if (v2[2])
    {
      v3 = *v2;
      v4 = (uint64_t *)v2[1];
      v5 = *v4;
      *(_QWORD *)(v5 + 8) = *(_QWORD *)(*v2 + 8);
      **(_QWORD **)(v3 + 8) = v5;
      v2[2] = 0;
      if (v4 != v2)
      {
        do
        {
          v6 = (uint64_t *)v4[1];
          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v4 + 2));
          operator delete(v4);
          v4 = v6;
        }
        while (v6 != v2);
      }
    }
    JUMPOUT(0x186DB748CLL);
  }
  return result;
}

uint64_t **std::unique_ptr<std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>>::reset[abi:nn180100](uint64_t **result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    if (v2[2])
    {
      v3 = *v2;
      v4 = (uint64_t *)v2[1];
      v5 = *v4;
      *(_QWORD *)(v5 + 8) = *(_QWORD *)(*v2 + 8);
      **(_QWORD **)(v3 + 8) = v5;
      v2[2] = 0;
      if (v4 != v2)
      {
        do
        {
          v6 = (uint64_t *)v4[1];
          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v4 + 4));
          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v4 + 2));
          operator delete(v4);
          v4 = v6;
        }
        while (v6 != v2);
      }
    }
    JUMPOUT(0x186DB748CLL);
  }
  return result;
}

void TLSCallbackClientCertificate::invokeCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_weak_owners;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD v10[6];
  std::__shared_weak_count *v11;

  v3 = *(_QWORD *)(a1 + 24);
  v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v6 = __ldxr(p_shared_weak_owners);
    while (__stxr(v6 + 1, p_shared_weak_owners));
  }
  v7 = *(_QWORD *)(a1 + 56);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3321888768;
  v10[2] = ___ZN28TLSCallbackClientCertificate14invokeCallbackEU13block_pointerFvbE_block_invoke;
  v10[3] = &unk_1E14F3058;
  v10[5] = v3;
  v11 = v4;
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10[4] = a2;
  (*(void (**)(uint64_t, _QWORD *))(v7 + 16))(v7, v10);
  _Block_release(*(const void **)(a1 + 56));
  *(_QWORD *)(a1 + 56) = 0;
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
}

void sub_1840AFAC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  std::__shared_weak_count *v16;

  if (a16)
    std::__shared_weak_count::__release_weak(a16);
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  _Unwind_Resume(exception_object);
}

void ___ZN28TLSCallbackClientCertificate14invokeCallbackEU13block_pointerFvbE_block_invoke(_QWORD *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  std::__shared_weak_count *v8;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  _QWORD *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  _QWORD *v25;
  std::__shared_weak_count *v26;

  v25 = 0;
  v26 = 0;
  v8 = (std::__shared_weak_count *)a1[6];
  if (v8)
  {
    v26 = std::__shared_weak_count::lock(v8);
    if (v26)
    {
      v11 = (_QWORD *)a1[5];
      v25 = v11;
      if (v11)
      {
        std::shared_ptr<__CFString const>::operator=[abi:nn180100](v11 + 9, *a2, a2[1]);
        std::shared_ptr<__CFString const>::operator=[abi:nn180100](v11 + 11, *a3, a3[1]);
        v12 = v11[8];
        v13 = a2[1];
        v23 = *a2;
        v24 = (std::__shared_weak_count *)v13;
        if (v13)
        {
          v14 = (unint64_t *)(v13 + 8);
          do
            v15 = __ldxr(v14);
          while (__stxr(v15 + 1, v14));
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(v12 + 16))(v12, &v23, a4, a5);
        v16 = v24;
        if (v24)
        {
          p_shared_owners = (unint64_t *)&v24->__shared_owners_;
          do
            v18 = __ldaxr(p_shared_owners);
          while (__stlxr(v18 - 1, p_shared_owners));
          if (!v18)
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }
        v19 = v25;
        _Block_release((const void *)v25[8]);
        v19[8] = 0;
      }
    }
  }
  (*(void (**)(_QWORD))(a1[4] + 16))(a1[4]);
  v20 = v26;
  if (v26)
  {
    v21 = (unint64_t *)&v26->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1840AFC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c53_ZTSNSt3__18weak_ptrI28TLSCallbackClientCertificateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_40c53_ZTSNSt3__18weak_ptrI28TLSCallbackClientCertificateEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void ___ZN16TLSCallbackQueue20_doClientCertificateENSt3__110shared_ptrI28TLSCallbackClientCertificateEE_block_invoke(_QWORD *a1, int a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;

  v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      v6 = v5;
      v7 = a1[4];
      if (v7)
      {
        if (a2)
        {
          *(_BYTE *)(v7 + 41) = 0;
          std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*(_QWORD *)(v7 + 48));
        }
        else
        {
          v8 = *(uint64_t **)(v7 + 64);
          v9 = operator new(0x20uLL);
          v10 = a1[7];
          v9[2] = a1[6];
          v9[3] = v10;
          if (v10)
          {
            v11 = (unint64_t *)(v10 + 8);
            do
              v12 = __ldxr(v11);
            while (__stxr(v12 + 1, v11));
          }
          v9[1] = v8;
          v13 = *v8;
          *v9 = *v8;
          *(_QWORD *)(v13 + 8) = v9;
          *v8 = (uint64_t)v9;
          ++v8[2];
          *(_BYTE *)(v7 + 41) = 0;
          std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*(_QWORD *)(v7 + 48));
          TLSCallbackQueue::_invokeNextCallback((TLSCallbackQueue *)v7);
        }
      }
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_1840AFDA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_32c41_ZTSNSt3__18weak_ptrI16TLSCallbackQueueEE48c56_ZTSNSt3__110shared_ptrI28TLSCallbackClientCertificateEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void __destroy_helper_block_e8_32c41_ZTSNSt3__18weak_ptrI16TLSCallbackQueueEE48c56_ZTSNSt3__110shared_ptrI28TLSCallbackClientCertificateEE(uint64_t a1)
{
  std::__shared_weak_count *v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void TLSCallbackQueue::copyCachedPeerCertificates(_QWORD *a1, uint64_t a2, sec_protocol_metadata_t metadataB)
{
  _QWORD *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  NSObject *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  char v15;
  unint64_t *v16;
  unint64_t v17;

  v6 = *(_QWORD **)(*(_QWORD *)(a2 + 56) + 8);
  while (v6 != *(_QWORD **)(a2 + 56))
  {
    v8 = (_QWORD *)v6[2];
    v7 = (std::__shared_weak_count *)v6[3];
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
    }
    v11 = v8[5];
    if (v11 && sec_protocol_metadata_peers_are_equal(v11, metadataB))
    {
      v12 = v8[13];
      *a1 = v8[12];
      a1[1] = v12;
      if (v12)
      {
        v13 = (unint64_t *)(v12 + 8);
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      v15 = 1;
      if (!v7)
        goto LABEL_18;
LABEL_14:
      v16 = (unint64_t *)&v7->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      goto LABEL_18;
    }
    v15 = 0;
    v6 = (_QWORD *)v6[1];
    if (v7)
      goto LABEL_14;
LABEL_18:
    if ((v15 & 1) != 0)
      return;
  }
  *a1 = 0;
  a1[1] = 0;
}

void sub_1840AFF2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

CFStringRef CFNACOAuthSigner::copyDebugDesc(CFNACOAuthSigner *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CFNACOAuthSigner@%p>"), this);
}

void CFNACOAuthSigner::~CFNACOAuthSigner(CFNACOAuthSigner *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E14E7E38;
  *((_QWORD *)this + 1) = &unk_1E14E7E88;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

{
  const void *v2;

  *(_QWORD *)this = &off_1E14E7E38;
  *((_QWORD *)this + 1) = &unk_1E14E7E88;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_1840AFFC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_1840B0018(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t CFNACOAuthSigner::initialize(uint64_t a1, _QWORD *a2, double a3)
{
  uint64_t v3;
  uint64_t result;
  id v7;
  void *v8;
  uint64_t v9;

  gotLoadHelper_x21__OBJC_CLASS___ACOAuthSigner(a3);
  result = objc_opt_class();
  if (result)
  {
    v7 = objc_alloc(*(Class *)(v3 + 744));
    v8 = v7;
    if (a2)
    {
      if (TCFObject<CFNAccount>::Class(void)::sOnce != -1)
        dispatch_once(&TCFObject<CFNAccount>::Class(void)::sOnce, &__block_literal_global_11710);
      *(_QWORD *)(a1 + 16) = objc_msgSend(v8, "initWithAccount:", a2[4]);
      *(_QWORD *)(a1 + 24) = CFRetain(a2);
      return 1;
    }
    else
    {
      v9 = objc_msgSend(v7, "initWithAccount:", MEMORY[0x10]);
      result = 0;
      *(_QWORD *)(a1 + 16) = v9;
    }
  }
  return result;
}

void `non-virtual thunk to'CFNACOAuthSigner::~CFNACOAuthSigner(CFNACOAuthSigner *this)
{
  const void *v2;

  *((_QWORD *)this - 1) = &off_1E14E7E38;
  *(_QWORD *)this = &unk_1E14E7E88;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)this = &off_1E14E5838;
}

{
  const void *v2;

  *((_QWORD *)this - 1) = &off_1E14E7E38;
  *(_QWORD *)this = &unk_1E14E7E88;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)this = &off_1E14E5838;
}

void sub_1840B0120(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_1840B0178(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI10CFNAccountE5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  word_1EDD018D8 = 29806;
  _PNAME<CFNAccount>::GET(void)::p = *(_QWORD *)"CFNAccount>::GET() [OBJTYPE = CFNAccount]";
  CFClass::CFClass(v0, (const char *)&_PNAME<CFNAccount>::GET(void)::p);
  TCFObject<CFNAccount>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840B01E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI15CFNNSURLRequestE5ClassEv_block_invoke_11719()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  qmemcpy(_PNAME<CFNNSURLRequest>::GET(void)::p, "CFNNSURLRequest", 15);
  CFClass::CFClass(v0, (const char *)_PNAME<CFNNSURLRequest>::GET(void)::p);
  TCFObject<CFNNSURLRequest>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840B026C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

BOOL CompactCookieHeader::getEnumeratedTime(_DWORD *a1, int a2)
{
  return a2 == 2 || a2 == 5 && (*a1 < 0xCu || (a1[2] & 2) == 0);
}

uint64_t CompactCookieHeader::getEnumeratedBoolean(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a2 <= 11)
  {
    if (a2 != 3)
    {
      if (a2 == 6)
      {
        if (*a1 >= 0xCu)
          return (a1[2] >> 2) & 1;
        return 0;
      }
      return result;
    }
    if (*a1 >= 0xCu)
      return (a1[2] >> 1) & 1;
    return 0;
  }
  switch(a2)
  {
    case 18:
      if (*a1 >= 0xCu)
        return (a1[2] >> 6) & 1;
      return 0;
    case 17:
      if (*a1 >= 0xCu)
        return (a1[2] >> 5) & 1;
      return 0;
    case 12:
      if (*a1 >= 0xCu)
        return a1[2] & 1;
      return 0;
  }
  return result;
}

void sub_1840B0468(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1840B05E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1840B0764(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  _Unwind_Resume(a1);
}

void sub_1840B08B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  _Unwind_Resume(a1);
}

id destinationURLFragment(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;
  const void *v7;
  id v8;
  CC_LONG v9;
  void *v10;
  uint64_t i;
  unsigned __int8 md[20];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = (void *)MEMORY[0x1E0CB3940];
  objc_msgSend(a1, "URL");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "stringWithFormat:", CFSTR("%@%@"), v3, v5);
  v6 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v7 = (const void *)objc_msgSend(v6, "UTF8String");
  v8 = objc_retainAutorelease(v6);
  v9 = strlen((const char *)objc_msgSend(v8, "UTF8String"));
  CC_SHA1(v7, v9, md);
  objc_msgSend(MEMORY[0x1E0CB37A0], "stringWithCapacity:", 40);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  for (i = 0; i != 8; ++i)
    objc_msgSend(v10, "appendFormat:", CFSTR("%02X"), md[i]);

  return v10;
}

void sub_1840B0AA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CFNetworkWriteStream::~CFNetworkWriteStream(CFNetworkWriteStream *this)
{
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
}

{
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x186DB748CLL);
}

CFStringRef CFNetworkWriteStream::copyDescription(CFNetworkWriteStream *this, CFTypeRef cf)
{
  const __CFAllocator *v3;

  v3 = CFGetAllocator(cf);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFNetworkWriteStream@%p>"), this);
}

uint64_t CFNetworkWriteStream::_streamImpl_Open(CFNetworkWriteStream *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a4 = 0;
  return 0;
}

uint64_t CFNetworkWriteStream::_streamImpl_OpenCompleted(CFNetworkWriteStream *this, __CFWriteStream *a2, CFStreamError *a3)
{
  return 0;
}

uint64_t CFNetworkWriteStream::_streamImpl_Write(CFNetworkWriteStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5)
{
  return -1;
}

uint64_t CFNetworkWriteStream::_streamImpl_CanWrite(CFNetworkWriteStream *this, __CFWriteStream *a2)
{
  return 0;
}

uint64_t CFNetworkWriteStream::_streamImpl_CopyProperty(CFNetworkWriteStream *this, __CFWriteStream *a2, const __CFString *a3)
{
  return 0;
}

uint64_t CFNetworkWriteStream::_streamImpl_SetProperty(CFNetworkWriteStream *this, __CFWriteStream *a2, const __CFString *a3, const void *a4)
{
  return 0;
}

void CFNetworkWriteStream::_writeStreamClientCallBack(CFNetworkWriteStream *this, __CFWriteStream *a2)
{
  abort();
}

uint64_t CFNetworkWriteStream::_createStream(CFNetworkWriteStream *this, uint64_t (**a2)(__CFWriteStream *, CFNetworkWriteStream *), void *a3)
{
  return a2[2]((__CFWriteStream *)a2, this);
}

void CFNetworkWriteStream::httpStreamFinalize(CFNetworkWriteStream *this, __CFWriteStream *a2, void *a3)
{
  const __CFAllocator *v4;

  if (this)
    v4 = CFGetAllocator(this);
  else
    v4 = 0;
  (**(void (***)(__CFWriteStream *))a2)(a2);
  CFAllocatorDeallocate(v4, a2);
}

uint64_t CFNetworkWriteStream::httpStreamCopyDescription(CFNetworkWriteStream *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFWriteStream *, CFNetworkWriteStream *))(*(_QWORD *)a2 + 16))(a2, this);
}

uint64_t CFNetworkWriteStream::httpStreamOpen(CFNetworkWriteStream *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(unsigned __int8 *, CFNetworkWriteStream *, __CFWriteStream *, CFStreamError *))(*(_QWORD *)a4 + 24))(a4, this, a2, a3);
}

uint64_t CFNetworkWriteStream::httpStreamOpenCompleted(CFNetworkWriteStream *this, __CFWriteStream *a2, CFStreamError *a3, void *a4)
{
  return (*(uint64_t (**)(CFStreamError *, CFNetworkWriteStream *, __CFWriteStream *))(a3->domain + 32))(a3, this, a2);
}

uint64_t CFNetworkWriteStream::httpStreamClose(CFNetworkWriteStream *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFWriteStream *, CFNetworkWriteStream *))(*(_QWORD *)a2 + 56))(a2, this);
}

uint64_t CFNetworkWriteStream::httpStreamCopyProperty(CFNetworkWriteStream *this, __CFWriteStream *a2, const __CFString *a3, void *a4)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkWriteStream *, __CFWriteStream *))a3->isa + 8))(a3, this, a2);
}

uint64_t CFNetworkWriteStream::httpStreamSetProperty(CFNetworkWriteStream *this, __CFWriteStream *a2, const __CFString *a3, const void *a4, void *a5)
{
  return (*(uint64_t (**)(const void *, CFNetworkWriteStream *, __CFWriteStream *, const __CFString *))(*(_QWORD *)a4 + 72))(a4, this, a2, a3);
}

uint64_t CFNetworkWriteStream::httpStreamSchedule(CFNetworkWriteStream *this, __CFWriteStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkWriteStream *, __CFWriteStream *, __CFRunLoop *))a4->isa
          + 10))(a4, this, a2, a3);
}

uint64_t CFNetworkWriteStream::httpStreamUnschedule(CFNetworkWriteStream *this, __CFWriteStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkWriteStream *, __CFWriteStream *, __CFRunLoop *))a4->isa
          + 11))(a4, this, a2, a3);
}

void __Block_byref_object_copy__12296(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__12297(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void ConnectionReadAggregator::_timerStart(ConnectionReadAggregator *this)
{
  dispatch_source_t v2;
  NSObject *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  NSObject *v8;
  unint64_t *v9;
  unint64_t v10;
  NSObject *v11;
  dispatch_time_t v12;
  _QWORD v13[5];
  std::__shared_weak_count *v14;

  if (*((_DWORD *)this + 18))
    __assert_rtn("_timerStart", "ConnectionReadAggregator.mm", 303, "_timerState == TimerState::NotSet");
  if (*((double *)this + 11) <= 0.0)
    __assert_rtn("_timerStart", "ConnectionReadAggregator.mm", 304, "_timeout > 0.0");
  if (!*((_QWORD *)this + 8))
  {
    v2 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)this + 5));
    v3 = *((_QWORD *)this + 8);
    *((_QWORD *)this + 8) = v2;
    if (v3)
      dispatch_release(v3);
    v4 = *((_QWORD *)this + 3);
    v5 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
    if (v5)
    {
      p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
      do
        v7 = __ldxr(p_shared_weak_owners);
      while (__stxr(v7 + 1, p_shared_weak_owners));
    }
    v8 = *((_QWORD *)this + 8);
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3321888768;
    v13[2] = ___ZN24ConnectionReadAggregator11_timerStartEv_block_invoke;
    v13[3] = &__block_descriptor_48_e8_32c49_ZTSNSt3__18weak_ptrI24ConnectionReadAggregatorEE_e5_v8__0l;
    v13[4] = v4;
    v14 = v5;
    if (v5)
    {
      v9 = (unint64_t *)&v5->__shared_weak_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    dispatch_source_set_event_handler(v8, v13);
    dispatch_source_set_timer(*((dispatch_source_t *)this + 8), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_resume(*((dispatch_object_t *)this + 8));
    if (v14)
      std::__shared_weak_count::__release_weak(v14);
    if (v5)
      std::__shared_weak_count::__release_weak(v5);
  }
  v11 = *((_QWORD *)this + 8);
  v12 = dispatch_time(0, (uint64_t)(*((double *)this + 11) * 1000000000.0));
  dispatch_source_set_timer(v11, v12, 0xFFFFFFFFFFFFFFFFLL, 0);
  *((_DWORD *)this + 18) = 1;
}

void ___ZN24ConnectionReadAggregator11_timerStartEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  ConnectionReadAggregator *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(ConnectionReadAggregator **)(a1 + 32);
      if (v5 && *((_DWORD *)v5 + 18) == 1)
      {
        *((_QWORD *)v5 + 9) = 0x100000002;
        ConnectionReadAggregator::_evaluate(v5);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1840B24BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c49_ZTSNSt3__18weak_ptrI24ConnectionReadAggregatorEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c49_ZTSNSt3__18weak_ptrI24ConnectionReadAggregatorEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void ReadBuffer::~ReadBuffer(ReadBuffer *this)
{
  id var2;

  this->var0 = (void **)&off_1E14E4BC8;
  var2 = this->var2;
  if (var2)
    CFRelease(var2);
  this->var0 = (void **)&off_1E14E5838;
}

{
  id var2;

  this->var0 = (void **)&off_1E14E4BC8;
  var2 = this->var2;
  if (var2)
    CFRelease(var2);
  this->var0 = (void **)&off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

void sub_1840B2764(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_1840B27C8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

NSObject *ReadBuffer::countOfAvailableBytes(ReadBuffer *this)
{
  NSObject *result;

  result = this->var2;
  if (result)
    result = dispatch_data_get_size(result);
  if (result != this->var3)
    __assert_rtn("countOfAvailableBytes", "HTTPServerNWStream.mm", 41, "(_dataBuffer == NULL? 0 : dispatch_data_get_size(_dataBuffer)) == _dataBufferSize");
  return result;
}

BOOL ___ZN10ReadBuffer11copyOutDataEPhl_block_invoke(_QWORD *a1, int a2, int a3, void *__src, size_t a5)
{
  uint64_t v6;
  size_t v7;

  v6 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  if (a1[5] - v6 >= a5)
    v7 = a5;
  else
    v7 = a1[5] - v6;
  memcpy((void *)(a1[6] + v6), __src, v7);
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += v7;
  return *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) < a1[5];
}

uint64_t PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  return a2;
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#2}::__invoke(int a1, PerSideBase *this)
{
  PerSideBase::_offqueue_finalize(this);
}

CFStringRef PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#3}::__invoke(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<NWStreamPair<%p>::PerSideBase<%s>(%p)"), *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16), a2);
}

BOOL PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFError **,unsigned char *,void *)#1}::__invoke(uint64_t a1, uint64_t *a2, _BYTE *a3, _QWORD *a4)
{
  uint64_t v7;
  NSObject *v9;
  _QWORD block[5];

  if (!a2 || !a3)
    __assert_rtn("_offqueue_open", "HTTPServerNWStream.mm", 244, "error != NULL && openComplete != NULL");
  *a2 = (*(uint64_t (**)(_QWORD *))(*a4 + 32))(a4);
  *a3 = 1;
  v7 = *a2;
  if (!*a2)
  {
    v7 = a4[1];
    if (v7)
    {
      v9 = *(NSObject **)(v7 + 40);
      if (v9)
      {
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___ZN7PerSideIP15__CFWriteStream22CFWriteStreamCallBacksE14_offqueue_openEPP9__CFErrorPh_block_invoke;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = a4;
        dispatch_async(v9, block);
        v7 = *a2;
      }
      else
      {
        v7 = 0;
      }
    }
  }
  return v7 == 0;
}

BOOL PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFError **,void *)#1}::__invoke(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;

  if (!a2)
    __assert_rtn("_offqueue_openCompleted", "HTTPServerNWStream.mm", 260, "error != NULL");
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 32))(a3);
  *a2 = v4;
  return v4 == 0;
}

uint64_t PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#4}::__invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
}

uint64_t PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFString const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 40))(a3);
}

uint64_t PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFString const*,void const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 48))(a4);
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,unsigned long,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a3 + 32) |= a2;
}

uint64_t PerSide_CFWriteStream::fillinCB(CFWriteStreamCallBacks *)::{lambda(__CFWriteStream *,unsigned char const*,long,__CFError **,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t *v13;
  const void *v14;
  uint64_t v15;
  _QWORD block[10];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  void (*v21)(uint64_t, uint64_t);
  void (*v22)(uint64_t);
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;

  if (!a4)
    __assert_rtn("_offqueue_write", "HTTPServerNWStream.mm", 526, "error != NULL");
  v24 = 0;
  v25 = &v24;
  v26 = 0x2020000000;
  v27 = 0;
  v9 = MEMORY[0x1E0C809B0];
  while (1)
  {
    v18 = 0;
    v19 = &v18;
    v20 = 0x3052000000;
    v21 = __Block_byref_object_copy__12394;
    v22 = __Block_byref_object_dispose__12395;
    v23 = 0;
    v10 = *(_QWORD *)(a5 + 8);
    if (v10)
      v11 = *(NSObject **)(v10 + 40);
    else
      v11 = 0;
    block[0] = v9;
    block[1] = 3221225472;
    block[2] = ___ZN21PerSide_CFWriteStream15_offqueue_writeEPKhlPP9__CFError_block_invoke;
    block[3] = &unk_1E14FBC60;
    block[6] = a5;
    block[7] = a4;
    block[4] = &v24;
    block[5] = &v18;
    block[8] = a3;
    block[9] = a2;
    dispatch_sync(v11, block);
    v12 = v19[5];
    if (v12)
    {
      dispatch_semaphore_wait(v12, 0xFFFFFFFFFFFFFFFFLL);
      v13 = v19;
      v14 = (const void *)v19[5];
      if (v14)
      {
        CFRelease(v14);
        v13 = v19;
      }
      v13[5] = 0;
    }
    _Block_object_dispose(&v18, 8);
    v15 = v25[3];
    if (v15)
      break;
    if (*a4)
    {
      v15 = 0;
      break;
    }
  }
  _Block_object_dispose(&v24, 8);
  return v15;
}

void sub_1840B3238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a20, 8);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

uint64_t PerSide_CFWriteStream::fillinCB(CFWriteStreamCallBacks *)::{lambda(__CFWriteStream *,__CFError **,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  _QWORD block[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  if (!a2)
    __assert_rtn("_offqueue_canWrite", "HTTPServerNWStream.mm", 569, "error != NULL");
  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = 0;
  v3 = *(_QWORD *)(a3 + 8);
  if (v3)
    v4 = *(NSObject **)(v3 + 40);
  else
    v4 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN21PerSide_CFWriteStream18_offqueue_canWriteEPP9__CFError_block_invoke;
  block[3] = &unk_1E14FD7A8;
  block[4] = &v8;
  block[5] = a3;
  block[6] = a2;
  dispatch_sync(v4, block);
  v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void __Block_byref_object_copy__12394(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__12395(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void ___ZN21PerSide_CFWriteStream15_offqueue_writeEPKhlPP9__CFError_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  CFErrorRef *v7;
  const void *v8;
  __CFError *v9;
  size_t size;
  NSObject *v11;
  NSObject *v12;
  _QWORD v13[6];

  v2 = *(_QWORD **)(a1 + 48);
  v3 = v2[5];
  if (v3 != 0xFFFF)
  {
    v4 = 0xFFFF - v3;
    if (v4 >= *(_QWORD *)(a1 + 64))
      v4 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
    v2[5] += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v5 = dispatch_data_create(*(const void **)(a1 + 72), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), 0, 0);
    v6 = v2[1];
    if (v6)
    {
      v7 = *(CFErrorRef **)(a1 + 56);
      if (!v7)
        __assert_rtn("-[NWStreamPair _onqueue_writeData:outError:]", "HTTPServerNWStream.mm", 807, "error != NULL");
      v8 = *(const void **)(v6 + 64);
      if (v8)
      {
        v9 = (__CFError *)CFRetain(v8);
        *v7 = v9;
        if (v9)
          goto LABEL_15;
      }
      else
      {
        *v7 = 0;
      }
      if (!*(_BYTE *)(v6 + 81))
      {
        size = dispatch_data_get_size(v5);
        CFRetain((CFTypeRef)v6);
        ++*(_QWORD *)(v6 + 112);
        v11 = *(NSObject **)(v6 + 16);
        v12 = *MEMORY[0x1E0CCECE8];
        v13[0] = MEMORY[0x1E0C809B0];
        v13[1] = 3221225472;
        v13[2] = __44__NWStreamPair__onqueue_writeData_outError___block_invoke;
        v13[3] = &unk_1E14FC990;
        v13[4] = v6;
        v13[5] = size;
        nw_connection_send(v11, v5, v12, 0, v13);
        if (!v5)
          return;
LABEL_16:
        CFRelease(v5);
        return;
      }
      *v7 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 22, 0);
    }
LABEL_15:
    if (!v5)
      return;
    goto LABEL_16;
  }
  **(_QWORD **)(a1 + 56) = (*(uint64_t (**)(_QWORD))(*v2 + 32))(*(_QWORD *)(a1 + 48));
  if (**(_QWORD **)(a1 + 56))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -1;
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = dispatch_semaphore_create(0);
    v2[6] = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
  }
}

void ___ZN7PerSideIP15__CFWriteStream22CFWriteStreamCallBacksE14_offqueue_openEPP9__CFErrorPh_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (v1)
  {
    if (!*(_BYTE *)(v1 + 48))
    {
      *(_BYTE *)(v1 + 48) = 1;
      -[NWStreamPair _onqueue_issue_read](v1);
    }
  }
}

void PerSideBase::_offqueue_finalize(PerSideBase *this)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD v3[6];

  v1 = *((_QWORD *)this + 1);
  if (!v1)
    __assert_rtn("_offqueue_finalize", "HTTPServerNWStream.mm", 203, "_owner != nil");
  *((_QWORD *)this + 1) = 0;
  v2 = *(NSObject **)(v1 + 40);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN11PerSideBase18_offqueue_finalizeEv_block_invoke;
  v3[3] = &unk_1E14FE140;
  v3[4] = v1;
  v3[5] = this;
  dispatch_async(v2, v3);
}

void ___ZN11PerSideBase18_offqueue_finalizeEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 40);
    if (*(_QWORD *)(v2 + 24) == v3)
    {
      if (v3)
        (*(void (**)(_QWORD))(*(_QWORD *)v3 + 8))(*(_QWORD *)(a1 + 40));
      *(_QWORD *)(v2 + 24) = 0;
    }
    if (*(_QWORD *)(v2 + 32) == v3)
    {
      if (v3)
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
      *(_QWORD *)(v2 + 32) = 0;
    }
  }

}

uint64_t PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  return a2;
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#2}::__invoke(int a1, PerSideBase *this)
{
  PerSideBase::_offqueue_finalize(this);
}

CFStringRef PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#3}::__invoke(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<NWStreamPair<%p>::PerSideBase<%s>(%p)"), *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16), a2);
}

BOOL PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFError **,unsigned char *,void *)#1}::__invoke(uint64_t a1, uint64_t *a2, _BYTE *a3, _QWORD *a4)
{
  uint64_t v7;
  NSObject *v9;
  _QWORD block[5];

  if (!a2 || !a3)
    __assert_rtn("_offqueue_open", "HTTPServerNWStream.mm", 244, "error != NULL && openComplete != NULL");
  *a2 = (*(uint64_t (**)(_QWORD *))(*a4 + 32))(a4);
  *a3 = 1;
  v7 = *a2;
  if (!*a2)
  {
    v7 = a4[1];
    if (v7)
    {
      v9 = *(NSObject **)(v7 + 40);
      if (v9)
      {
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___ZN7PerSideIP14__CFReadStream21CFReadStreamCallBacksE14_offqueue_openEPP9__CFErrorPh_block_invoke;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = a4;
        dispatch_async(v9, block);
        v7 = *a2;
      }
      else
      {
        v7 = 0;
      }
    }
  }
  return v7 == 0;
}

BOOL PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFError **,void *)#1}::__invoke(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;

  if (!a2)
    __assert_rtn("_offqueue_openCompleted", "HTTPServerNWStream.mm", 260, "error != NULL");
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 32))(a3);
  *a2 = v4;
  return v4 == 0;
}

uint64_t PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#4}::__invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
}

uint64_t PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFString const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 40))(a3);
}

uint64_t PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFString const*,void const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 48))(a4);
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,unsigned long,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a3 + 32) |= a2;
}

uint64_t PerSide_CFReadStream::fillinCB(CFReadStreamCallBacks *)::{lambda(__CFReadStream *,unsigned char *,long,__CFError **,unsigned char *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _BYTE *a5, uint64_t a6)
{
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t *v14;
  const void *v15;
  uint64_t v16;
  _QWORD v18[11];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t);
  void (*v23)(uint64_t);
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;

  if (!a4 || !a5)
    __assert_rtn("_offqueue_read", "HTTPServerNWStream.mm", 417, "error != NULL && atEOF != NULL");
  v25 = 0;
  v26 = &v25;
  v27 = 0x2020000000;
  v28 = 0;
  while (1)
  {
    v19 = 0;
    v20 = &v19;
    v21 = 0x3052000000;
    v22 = __Block_byref_object_copy__12394;
    v23 = __Block_byref_object_dispose__12395;
    v24 = 0;
    v11 = *(_QWORD *)(a6 + 8);
    if (v11)
      v12 = *(NSObject **)(v11 + 40);
    else
      v12 = 0;
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = ___ZN20PerSide_CFReadStream14_offqueue_readEPhlPP9__CFErrorS0__block_invoke;
    v18[3] = &unk_1E14FBC38;
    v18[6] = a6;
    v18[7] = a2;
    v18[8] = a3;
    v18[9] = a4;
    v18[10] = a5;
    v18[4] = &v25;
    v18[5] = &v19;
    dispatch_sync(v12, v18);
    v13 = v20[5];
    if (v13)
    {
      dispatch_semaphore_wait(v13, 0xFFFFFFFFFFFFFFFFLL);
      v14 = v20;
      v15 = (const void *)v20[5];
      if (v15)
      {
        CFRelease(v15);
        v14 = v20;
      }
      v14[5] = 0;
    }
    _Block_object_dispose(&v19, 8);
    v16 = v26[3];
    if (v16)
      break;
    if (*a4)
    {
      v16 = -1;
      break;
    }
    if (*a5)
    {
      v16 = 0;
      break;
    }
  }
  _Block_object_dispose(&v25, 8);
  return v16;
}

void sub_1840B3A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a20, 8);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

uint64_t PerSide_CFReadStream::fillinCB(CFReadStreamCallBacks *)::{lambda(__CFReadStream *,__CFError **,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  _QWORD block[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  if (!a2)
    __assert_rtn("_offqueue_canRead", "HTTPServerNWStream.mm", 450, "error != NULL");
  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = 0;
  v3 = *(_QWORD *)(a3 + 8);
  if (v3)
    v4 = *(NSObject **)(v3 + 40);
  else
    v4 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN20PerSide_CFReadStream17_offqueue_canReadEPP9__CFError_block_invoke;
  block[3] = &unk_1E14FD7A8;
  block[4] = &v8;
  block[5] = a3;
  block[6] = a2;
  dispatch_sync(v4, block);
  v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void ___ZN20PerSide_CFReadStream14_offqueue_readEPhlPP9__CFErrorS0__block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _BYTE *v4;
  _QWORD *v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeRef v9;
  uint64_t v10;
  NSObject *v11;
  NSObject **v12;
  NSObject *v13;
  size_t size;
  uint64_t *v15;
  size_t v16;
  NSObject *subrange;
  uint64_t v18;
  uint64_t v19;
  _QWORD applier[7];
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;

  v2 = a1[6];
  v3 = *(_QWORD *)(v2 + 8);
  if (!v3)
  {
    v19 = 0;
    goto LABEL_24;
  }
  v5 = (_QWORD *)a1[9];
  v4 = (_BYTE *)a1[10];
  if (v5)
    v6 = v4 == 0;
  else
    v6 = 1;
  if (v6)
    __assert_rtn("-[NWStreamPair _onqueue_readToBuffer:length:outError:outEOF:]", "HTTPServerNWStream.mm", 831, "error != NULL && atEOF != NULL");
  v7 = a1[7];
  v8 = a1[8];
  *v4 = *(_BYTE *)(v3 + 80);
  v9 = *(CFTypeRef *)(v3 + 56);
  if (v9)
    v9 = CFRetain(v9);
  *v5 = v9;
  if (v8)
  {
    v10 = *(_QWORD *)(v3 + 72);
    if (*(_QWORD *)(v10 + 24))
    {
      v21 = 0;
      v22 = &v21;
      v23 = 0x2020000000;
      v24 = 0;
      v12 = (NSObject **)(v10 + 16);
      v11 = *(NSObject **)(v10 + 16);
      applier[0] = MEMORY[0x1E0C809B0];
      applier[1] = 3221225472;
      applier[2] = ___ZN10ReadBuffer11copyOutDataEPhl_block_invoke;
      applier[3] = &unk_1E14FBC10;
      applier[4] = &v21;
      applier[5] = v8;
      applier[6] = v7;
      dispatch_data_apply(v11, applier);
      v13 = *(NSObject **)(v10 + 16);
      size = dispatch_data_get_size(v13);
      if (size != *(_QWORD *)(v10 + 24))
        __assert_rtn("copyOutData", "HTTPServerNWStream.mm", 101, "dispatch_data_get_size(_dataBuffer) == _dataBufferSize");
      v15 = v22;
      v16 = v22[3];
      if (size == v16)
      {
        if (v13)
        {
          CFRelease(v13);
          v15 = v22;
        }
        *v12 = 0;
        *(_QWORD *)(v10 + 24) = 0;
      }
      else
      {
        subrange = dispatch_data_create_subrange(v13, v16, size - v16);
        *v12 = subrange;
        if (v13)
        {
          CFRelease(v13);
          subrange = *v12;
        }
        v15 = v22;
        v18 = *(_QWORD *)(v10 + 24) - v22[3];
        *(_QWORD *)(v10 + 24) = v18;
        if (dispatch_data_get_size(subrange) != v18)
          __assert_rtn("copyOutData", "HTTPServerNWStream.mm", 112, "dispatch_data_get_size(_dataBuffer) == _dataBufferSize");
      }
      v19 = v15[3];
      _Block_object_dispose(&v21, 8);
      if (v19)
        goto LABEL_23;
    }
    else if (*(_QWORD *)(v10 + 16))
    {
      __assert_rtn("copyOutData", "HTTPServerNWStream.mm", 85, "_dataBuffer == NULL");
    }
  }
  v19 = 0;
  if (!*(_BYTE *)(v3 + 80))
  {
    *(_BYTE *)(v3 + 80) = 1;
    *v4 = 1;
  }
LABEL_23:
  -[NWStreamPair _onqueue_issue_read](v3);
LABEL_24:
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v19;
  if (!*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) && !*(_BYTE *)a1[10] && !*(_QWORD *)a1[9])
  {
    *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40) = dispatch_semaphore_create(0);
    *(_QWORD *)(v2 + 40) = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40);
  }
}

void sub_1840B3EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN7PerSideIP14__CFReadStream21CFReadStreamCallBacksE14_offqueue_openEPP9__CFErrorPh_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (v1)
  {
    if (!*(_BYTE *)(v1 + 48))
    {
      *(_BYTE *)(v1 + 48) = 1;
      -[NWStreamPair _onqueue_issue_read](v1);
    }
  }
}

void PerSide_CFWriteStream::~PerSide_CFWriteStream(PerSide_CFWriteStream *this)
{
  PerSide_CFWriteStream::~PerSide_CFWriteStream(this);
  JUMPOUT(0x186DB748CLL);
}

{
  *(_QWORD *)this = &off_1E14EC1C8;
  if (*((_QWORD *)this + 6))
    __assert_rtn("~PerSide_CFWriteStream", "HTTPServerNWStream.mm", 500, "_writeBlockedSemaphore == NULL");
  PerSideBase::~PerSideBase(this);
}

void PerSideBase::_offqueue_close(PerSideBase *this)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD v3[6];

  v1 = *((_QWORD *)this + 1);
  if (v1)
    v2 = *(NSObject **)(v1 + 40);
  else
    v2 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN11PerSideBase15_offqueue_closeEv_block_invoke;
  v3[3] = &unk_1E14FE140;
  v3[4] = v1;
  v3[5] = this;
  dispatch_async(v2, v3);
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::_onqueue_closed(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = 0;
  if (v2)
    CFRelease(v2);
}

CFTypeRef PerSide_CFWriteStream::_onqueue_copyPendingError(PerSide_CFWriteStream *this)
{
  uint64_t v1;
  const void *v2;

  v1 = *((_QWORD *)this + 1);
  if (v1 && (v2 = *(const void **)(v1 + 64)) != 0)
    return CFRetain(v2);
  else
    return 0;
}

CFTypeRef PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::_offqueue_copyProperty(uint64_t a1, const __CFString *a2)
{
  return -[NWStreamPair _offqueue_owner_copyProperty:](*(_QWORD *)(a1 + 8), a2);
}

uint64_t PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::_offqueue_setProperty()
{
  return 0;
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::_offqueue_signalEvent(uint64_t a1, uint64_t a2)
{
  const void *v2;

  v2 = *(const void **)(a1 + 24);
  if (v2)
    PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::signalStream(v2, a2, 0);
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::_offqueue_signalError(uint64_t a1, const void *a2)
{
  const void *v2;

  v2 = *(const void **)(a1 + 24);
  if (v2)
    PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::signalStream(v2, 8, a2);
}

uint64_t *PerSide_CFWriteStream::_onqueue_streamNowScheduled(uint64_t *this)
{
  if (this[5] <= 65534)
    return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t))(*this + 56))(this, 4);
  return this;
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::signalStream(const void *a1, uint64_t a2, const void *a3)
{
  __CFRunLoop *v6;
  const void *v7;
  _QWORD block[7];

  CFRetain(a1);
  if (a3)
    CFRetain(a3);
  v6 = +[NSURLConnection resourceLoaderRunLoop](NSURLConnection, "resourceLoaderRunLoop");
  v7 = (const void *)*MEMORY[0x1E0C9B280];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN7PerSideIP15__CFWriteStream22CFWriteStreamCallBacksE12signalStreamES1_mP9__CFError_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = a1;
  block[5] = a2;
  block[6] = a3;
  CFRunLoopPerformBlock(v6, v7, block);
  CFRunLoopWakeUp(v6);
}

void ___ZN7PerSideIP15__CFWriteStream22CFWriteStreamCallBacksE12signalStreamES1_mP9__CFError_block_invoke(uint64_t a1)
{
  const void *v2;
  const void *v3;

  CFWriteStreamSignalEvent();
  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 48);
  if (v3)
    CFRelease(v3);
}

uint64_t ___ZN11PerSideBase15_offqueue_closeEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v3 = a1 + 32;
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v3 + 8);
  if (v1)
  {
    if (*(_QWORD *)(v1 + 24) == v2)
      *(_BYTE *)(v1 + 82) = 1;
    if (*(_QWORD *)(v1 + 32) == v2)
      *(_BYTE *)(v1 + 81) = 1;
    -[NWStreamPair _onqueue_checkForCompletion](v1);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
}

void sub_1840B42C0(_Unwind_Exception *a1)
{
  PerSideBase *v1;

  PerSideBase::~PerSideBase(v1);
  _Unwind_Resume(a1);
}

void PerSideBase::~PerSideBase(PerSideBase *this)
{
  *(_QWORD *)this = off_1E14E52C8;
  if (*((_QWORD *)this + 1))
    __assert_rtn("~PerSideBase", "HTTPServerNWStream.mm", 186, "_owner == nil");
  *(_QWORD *)this = &off_1E14E5838;
}

void sub_1840B4338(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void PerSide_CFReadStream::~PerSide_CFReadStream(PerSide_CFReadStream *this)
{
  PerSide_CFReadStream::~PerSide_CFReadStream(this);
  JUMPOUT(0x186DB748CLL);
}

{
  *(_QWORD *)this = &off_1E14EB9D0;
  if (*((_QWORD *)this + 5))
    __assert_rtn("~PerSide_CFReadStream", "HTTPServerNWStream.mm", 387, "_readBlockedSemaphore == nil");
  PerSideBase::~PerSideBase(this);
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::_onqueue_closed(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = 0;
  if (v2)
    CFRelease(v2);
}

CFTypeRef PerSide_CFReadStream::_onqueue_copyPendingError(PerSide_CFReadStream *this)
{
  uint64_t v1;
  const void *v2;

  v1 = *((_QWORD *)this + 1);
  if (v1 && (v2 = *(const void **)(v1 + 56)) != 0)
    return CFRetain(v2);
  else
    return 0;
}

CFTypeRef PerSide<__CFReadStream *,CFReadStreamCallBacks>::_offqueue_copyProperty(uint64_t a1, const __CFString *a2)
{
  return -[NWStreamPair _offqueue_owner_copyProperty:](*(_QWORD *)(a1 + 8), a2);
}

uint64_t PerSide<__CFReadStream *,CFReadStreamCallBacks>::_offqueue_setProperty()
{
  return 0;
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::_offqueue_signalEvent(uint64_t a1, uint64_t a2)
{
  const void *v2;

  v2 = *(const void **)(a1 + 24);
  if (v2)
    PerSide<__CFReadStream *,CFReadStreamCallBacks>::signalStream(v2, a2, 0);
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::_offqueue_signalError(uint64_t a1, const void *a2)
{
  const void *v2;

  v2 = *(const void **)(a1 + 24);
  if (v2)
    PerSide<__CFReadStream *,CFReadStreamCallBacks>::signalStream(v2, 8, a2);
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::signalStream(const void *a1, uint64_t a2, const void *a3)
{
  __CFRunLoop *v6;
  const void *v7;
  _QWORD block[7];

  CFRetain(a1);
  if (a3)
    CFRetain(a3);
  v6 = +[NSURLConnection resourceLoaderRunLoop](NSURLConnection, "resourceLoaderRunLoop");
  v7 = (const void *)*MEMORY[0x1E0C9B280];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN7PerSideIP14__CFReadStream21CFReadStreamCallBacksE12signalStreamES1_mP9__CFError_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = a1;
  block[5] = a2;
  block[6] = a3;
  CFRunLoopPerformBlock(v6, v7, block);
  CFRunLoopWakeUp(v6);
}

void ___ZN7PerSideIP14__CFReadStream21CFReadStreamCallBacksE12signalStreamES1_mP9__CFError_block_invoke(uint64_t a1)
{
  const void *v2;
  const void *v3;

  CFReadStreamSignalEvent();
  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 48);
  if (v3)
    CFRelease(v3);
}

void sub_1840B4534(_Unwind_Exception *a1)
{
  PerSideBase *v1;

  PerSideBase::~PerSideBase(v1);
  _Unwind_Resume(a1);
}

void CFNAccountStore::~CFNAccountStore(CFNAccountStore *this)
{
  uint64_t v2;

  CFNAccountStore::~CFNAccountStore(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  void *v2;
  const void *v3;

  *(_QWORD *)this = off_1E14E7380;
  *((_QWORD *)this + 3) = &unk_1E14E73D8;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)

  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

CFStringRef CFNAccountStore::copyDebugDesc(CFNAccountStore *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CFNAccountStore@%p>"), this);
}

uint64_t CFNAccountStore::initialize(CFNAccountStore *this, const __CFString *a2, double a3)
{
  uint64_t result;
  const __CFAllocator *v6;
  CFStringRef Copy;

  gotLoadHelper_x8__OBJC_CLASS___ACAccountStore(a3);
  result = objc_opt_class();
  if (result)
  {
    if (a2)
    {
      v6 = CFGetAllocator(a2);
      Copy = CFStringCreateCopy(v6, a2);
    }
    else
    {
      Copy = 0;
    }
    *((_QWORD *)this + 5) = Copy;
    (*(void (**)(CFNAccountStore *))(*(_QWORD *)this + 64))(this);
    return *((_QWORD *)this + 4) != 0;
  }
  return result;
}

uint64_t CFNAccountStore::initializeACAccountStore(CFNAccountStore *this)
{
  NSObject *v2;
  double v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v6 = *((_QWORD *)this + 5);
    v7 = 138412290;
    v8 = v6;
    _os_log_debug_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEBUG, "SSO Initializing ACAccountStore with effectiveBundleID %@", (uint8_t *)&v7, 0xCu);
  }
  gotLoadHelper_x8__OBJC_CLASS___ACAccountStore(v3);
  result = objc_msgSend(objc_alloc(*(Class *)(v4 + 704)), "initWithEffectiveBundleID:", *((_QWORD *)this + 5));
  *((_QWORD *)this + 4) = result;
  return result;
}

void `non-virtual thunk to'CFNAccountStore::~CFNAccountStore(CFNAccountStore *this)
{
  CFNAccountStore::~CFNAccountStore((CFNAccountStore *)((char *)this - 24));
}

void `non-virtual thunk to'CFNAccountStore::~CFNAccountStore(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  CFNAccountStore::~CFNAccountStore((CFNAccountStore *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_1840B4790(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t ___ZN15CFNAccountStore26renewCredentialsForAccountEP11objc_objectPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvlP9__CFErrorE_block_invoke(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v6;
  NSObject *v7;
  _QWORD block[9];

  v6 = *(_QWORD *)(a1 + 56);
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
  dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  if (a3)
    CFRetain(a3);
  v7 = *(NSObject **)(a1 + 32);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN15CFNAccountStore26renewCredentialsForAccountEP11objc_objectPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvlP9__CFErrorE_block_invoke_2;
  block[3] = &unk_1E14FBC88;
  block[6] = *(_QWORD *)(a1 + 48);
  block[7] = v6;
  block[8] = a2;
  block[4] = a3;
  block[5] = v7;
  dispatch_async(v7, block);

  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
}

uint64_t ___ZN15CFNAccountStore26renewCredentialsForAccountEP11objc_objectPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvlP9__CFErrorE_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  v2 = *(_QWORD *)(a1 + 56);
  (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

uint64_t ___ZN15CFNAccountStore32kerberosAccountsForDomainFromURLEPK7__CFURLPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvPK9__CFArrayP9__CFErrorE_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6;
  _QWORD block[6];
  __int128 v9;
  uint64_t v10;

  v6 = *(_QWORD *)(a1 + 48);
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
  dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  if (a2)
    CFRetain(a2);
  if (a3)
    CFRetain(a3);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN15CFNAccountStore32kerberosAccountsForDomainFromURLEPK7__CFURLPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvPK9__CFArrayP9__CFErrorE_block_invoke_2;
  block[3] = &unk_1E14FCE88;
  v10 = v6;
  block[4] = a2;
  block[5] = a3;
  v9 = *(_OWORD *)(a1 + 32);
  dispatch_async((dispatch_queue_t)v9, block);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
}

uint64_t ___ZN15CFNAccountStore32kerberosAccountsForDomainFromURLEPK7__CFURLPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvPK9__CFArrayP9__CFErrorE_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 64);
  (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 32);
  if (v4)
    CFRelease(v4);
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void BrotliDataDecoder::~BrotliDataDecoder(BrotliDataDecoder *this)
{
  *(_QWORD *)this = &off_1E14E83F0;
  if (*((_BYTE *)this + 48))
    compression_stream_destroy((compression_stream *)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
}

{
  *(_QWORD *)this = &off_1E14E83F0;
  if (*((_BYTE *)this + 48))
    compression_stream_destroy((compression_stream *)((char *)this + 8));
  *(_QWORD *)this = &off_1E14E4DA0;
  JUMPOUT(0x186DB748CLL);
}

void sub_1840B4A1C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void sub_1840B4A84(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void sub_1840B6248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  std::__shared_weak_count *v30;
  void *v32;

  v30[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E5838;
  std::__shared_weak_count::~__shared_weak_count(v30);
  operator delete(v32);
  _Unwind_Resume(a1);
}

void sub_1840B6360(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;
  const void *v3;

  v3 = v2;
  CFRelease(v3);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

void ___ZL28CFNWaitUntilDeviceIsUnlockedv_block_invoke(uint64_t a1, double a2)
{
  NSObject *v3;
  uint8_t v4[16];

  if (MKBDeviceUnlockedSinceBoot_delayInitStub(a2) == 1)
  {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v3 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v4 = 0;
      _os_log_impl(&dword_183ECA000, v3, OS_LOG_TYPE_DEFAULT, "Device is locked - waiting", v4, 2u);
    }
  }
}

uint64_t ___ZL28CFNWaitUntilDeviceIsUnlockedv_block_invoke_347(uint64_t result, int a2)
{
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) == a2)
    return (*(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16))();
  return result;
}

uint64_t ___ZL28CFNWaitUntilDeviceIsUnlockedv_block_invoke_348(uint64_t a1)
{
  uint64_t result;

  result = notify_cancel(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

void _systemPowerNotificationsCallback(os_unfair_lock_s *a1, unsigned int a2, int a3, intptr_t notificationID)
{
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  _QWORD v10[6];

  if (!a1)
    return;
  if (a3 == -536870288)
    goto LABEL_10;
  if (a3 != -536870144)
  {
    if (a3 != -536870272)
      return;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10[0]) = 0;
      _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "kIOMessageSystemWillSleep", (uint8_t *)v10, 2u);
    }
    os_unfair_lock_lock(a1 + 12);
    BYTE1(a1[17]._os_unfair_lock_opaque) = 1;
    os_unfair_lock_unlock(a1 + 12);
LABEL_10:
    if (IOAllowPowerChange(a1[13]._os_unfair_lock_opaque, notificationID))
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v7 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v10[0]) = 0;
        _os_log_error_impl(&dword_183ECA000, v7, OS_LOG_TYPE_ERROR, "IOAllowPowerChange failed!", (uint8_t *)v10, 2u);
      }
    }
    return;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v8 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10[0]) = 0;
    _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "kIOMessageSystemHasPoweredOn", (uint8_t *)v10, 2u);
  }
  v9 = *(NSObject **)&a1[30]._os_unfair_lock_opaque;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = __52__NSURLSession_handleSystemHasPoweredOnNotification__block_invoke;
  v10[3] = &unk_1E14FE118;
  v10[4] = a1;
  dispatch_async(v9, v10);
}

void GlueConnectionEstablishment::needServerTrust()
{
  abort();
}

void GlueConnectionEstablishment::needClientCert()
{
  abort();
}

void GlueConnectionEstablishment::preConnectConfiguration()
{
  abort();
}

void GlueConnectionEstablishment::postConnectConfiguration()
{
  abort();
}

void GlueConnectionEstablishment::connectionWaitingNotification()
{
  abort();
}

void GlueConnectionEstablishment::connectionEstablished(GlueConnectionEstablishment *this, CFStreamError a2)
{
  abort();
}

void ProxyConnectionEstablishment::ssPostProxyConnectionConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void *v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  _QWORD v40[2];
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  std::__shared_weak_count *v44;

  v43 = 0;
  v44 = 0;
  v9 = (void *)tcp_connection_copy_proxy();
  v10 = operator new();
  NetworkProxyConfiguration::NetworkProxyConfiguration(v10, v9);
  nw_release(v9);
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10) & 1) != 0)
  {
    v40[0] = v10;
    v40[1] = a4;
    v41 = 0u;
    v42 = 0u;
    makeProxy<>(&v38, v40);
    v11 = v38;
    v12 = v39;
    v43 = v38;
    v44 = v39;
    if (!v38)
      goto LABEL_15;
    if (a5)
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v38 + 104))(v38, *(unsigned int *)(a5 + 56));
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 88))(v11, *(_QWORD *)(a5 + 32));
      v36 = v11;
      v37 = v12;
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v14 = __ldxr(p_shared_owners);
        while (__stxr(v14 + 1, p_shared_owners));
      }
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)a5 + 56))(a5, &v36);
      v15 = v37;
      if (v37)
      {
        v16 = (unint64_t *)&v37->__shared_owners_;
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
    }
    v18 = v43;
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v43 + 56))(v43) == 3)
      v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 40))(v18);
    else
LABEL_15:
      v19 = 0;
    v20 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
    if (*((_QWORD *)&v42 + 1))
    {
      v21 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = (std::__shared_weak_count *)*((_QWORD *)&v41 + 1);
    if (*((_QWORD *)&v41 + 1))
    {
      v24 = (unint64_t *)(*((_QWORD *)&v41 + 1) + 8);
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    v34 = v43;
    v35 = v44;
    if (v44)
    {
      v26 = (unint64_t *)&v44->__shared_owners_;
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
  }
  else
  {
    v19 = 0;
    v34 = 0;
    v35 = 0;
  }
  (*(void (**)(uint64_t, uint64_t *, uint64_t))(a6 + 16))(a6, &v34, v19);
  v28 = v35;
  if (v35)
  {
    v29 = (unint64_t *)&v35->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  v31 = v44;
  if (v44)
  {
    v32 = (unint64_t *)&v44->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
}

void sub_1840B7598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4 + 32);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4 + 16);
  (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 64);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'ProxyConnectionEstablishment::~ProxyConnectionEstablishment(ProxyConnectionEstablishment *this)
{
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment((ProxyConnectionEstablishment *)((char *)this - 8));
}

{
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment((ProxyConnectionEstablishment *)((char *)this - 8));
  JUMPOUT(0x186DB748CLL);
}

void `non-virtual thunk to'GlueConnectionEstablishment::preConnectConfiguration()
{
  abort();
}

void `non-virtual thunk to'GlueConnectionEstablishment::postConnectConfiguration()
{
  abort();
}

void `non-virtual thunk to'GlueConnectionEstablishment::needServerTrust()
{
  abort();
}

void `non-virtual thunk to'GlueConnectionEstablishment::needClientCert()
{
  abort();
}

void `non-virtual thunk to'GlueConnectionEstablishment::connectionEstablished(GlueConnectionEstablishment *this, CFStreamError a2)
{
  abort();
}

void `non-virtual thunk to'GlueConnectionEstablishment::connectionWaitingNotification()
{
  abort();
}

void makeProxy<>(_QWORD *a1, _QWORD *a2)
{
  int v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  std::__shared_weak_count *v7;
  CFTypeRef v8;
  const void *v9;
  __int128 v10;
  std::__shared_weak_count *v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  uint64_t v24;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v26;
  unint64_t *p_shared_weak_owners;
  unint64_t v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;

  *a1 = 0;
  a1[1] = 0;
  v4 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
  if (v4 == 2)
  {
    v22 = (std::__shared_weak_count *)operator new(0x80uLL);
    v22->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    v22->__shared_weak_owners_ = 0;
    v22->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0868;
    v24 = NetworkProxy::NetworkProxy((uint64_t)&v22[1], a2);
    *(_QWORD *)&v38 = v24;
    *((_QWORD *)&v38 + 1) = v22;
    shared_weak_owners = (std::__shared_weak_count *)v22[1].__shared_weak_owners_;
    if (shared_weak_owners)
    {
      if (shared_weak_owners->__shared_owners_ != -1)
      {
LABEL_41:
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)a1, &v38);
        v33 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
        if (*((_QWORD *)&v38 + 1))
        {
          v34 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
          do
            v35 = __ldaxr(v34);
          while (__stlxr(v35 - 1, v34));
          if (!v35)
          {
            ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
            std::__shared_weak_count::__release_weak(v33);
          }
        }
        return;
      }
      do
        v26 = __ldxr(p_shared_owners);
      while (__stxr(v26 + 1, p_shared_owners));
      p_shared_weak_owners = (unint64_t *)&v22->__shared_weak_owners_;
      do
        v28 = __ldxr(p_shared_weak_owners);
      while (__stxr(v28 + 1, p_shared_weak_owners));
      v22[1].__shared_owners_ = v24;
      v22[1].__shared_weak_owners_ = (uint64_t)v22;
      std::__shared_weak_count::__release_weak(shared_weak_owners);
    }
    else
    {
      do
        v29 = __ldxr(p_shared_owners);
      while (__stxr(v29 + 1, p_shared_owners));
      v30 = (unint64_t *)&v22->__shared_weak_owners_;
      do
        v31 = __ldxr(v30);
      while (__stxr(v31 + 1, v30));
      v22[1].__shared_owners_ = v24;
      v22[1].__shared_weak_owners_ = (uint64_t)v22;
    }
    do
      v32 = __ldaxr(p_shared_owners);
    while (__stlxr(v32 - 1, p_shared_owners));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
    goto LABEL_41;
  }
  if (v4 == 3)
  {
    if (__CFNUseNWHTTPSProxies::useProxyOnce != -1)
      dispatch_once(&__CFNUseNWHTTPSProxies::useProxyOnce, &__block_literal_global_11_4775);
    if (!__CFNUseNWHTTPSProxies::useNWHTTPSProxy)
    {
      v5 = (std::__shared_weak_count *)operator new(0x130uLL);
      v5->__shared_owners_ = 0;
      v6 = (unint64_t *)&v5->__shared_owners_;
      v5->__shared_weak_owners_ = 0;
      v5->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0830;
      v7 = v5 + 1;
      NetworkProxy::NetworkProxy((uint64_t)&v5[1], a2);
      v5[10].__vftable = 0;
      v5[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E5400;
      v5[5].__shared_owners_ = (uint64_t)&unk_1E14E54A8;
      *(_OWORD *)&v5[5].__shared_weak_owners_ = 0u;
      *(_OWORD *)&v5[6].__shared_owners_ = 0u;
      v5[7].std::__shared_count = 0u;
      *(_OWORD *)&v5[7].__shared_weak_owners_ = 0u;
      *(_OWORD *)&v5[8].__shared_owners_ = 0u;
      v5[10].__shared_owners_ = 0;
      v5[10].__shared_weak_owners_ = 0;
      SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::SmartBlockWithArgs((uint64_t *)&v5[11], 0);
      v5[9].__shared_owners_ = 0;
      LODWORD(v5[9].__shared_weak_owners_) = 0;
      v5[11].__shared_weak_owners_ = 0;
      v5[12].__vftable = 0;
      LODWORD(v5[12].__shared_owners_) = 0;
      v8 = (CFTypeRef)a2[1];
      if (v8)
        v8 = CFRetain(v8);
      v9 = (const void *)v5[10].__shared_weak_owners_;
      v5[10].__shared_weak_owners_ = (uint64_t)v8;
      if (v9)
        CFRelease(v9);
      std::shared_ptr<__CFString const>::operator=[abi:nn180100](&v5[6].__shared_owners_, a2[2], a2[3]);
      std::shared_ptr<__CFString const>::operator=[abi:nn180100](&v5[10].__vftable, a2[4], a2[5]);
      v5[9].__vftable = 0;
      *(_QWORD *)&v10 = v5 + 1;
      *((_QWORD *)&v10 + 1) = v5;
      v11 = (std::__shared_weak_count *)v5[1].__shared_weak_owners_;
      if (v11)
      {
        if (v11->__shared_owners_ != -1)
        {
LABEL_23:
          v19 = (std::__shared_weak_count *)a1[1];
          *(_OWORD *)a1 = v10;
          if (v19)
          {
            v20 = (unint64_t *)&v19->__shared_owners_;
            do
              v21 = __ldaxr(v20);
            while (__stlxr(v21 - 1, v20));
            if (!v21)
            {
              ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
              std::__shared_weak_count::__release_weak(v19);
            }
          }
          return;
        }
        do
          v12 = __ldxr(v6);
        while (__stxr(v12 + 1, v6));
        v36 = v10;
        v13 = (unint64_t *)&v5->__shared_weak_owners_;
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
        v5[1].__shared_owners_ = (uint64_t)v7;
        v5[1].__shared_weak_owners_ = (uint64_t)v5;
        std::__shared_weak_count::__release_weak(v11);
        v10 = v36;
      }
      else
      {
        do
          v15 = __ldxr(v6);
        while (__stxr(v15 + 1, v6));
        v16 = (unint64_t *)&v5->__shared_weak_owners_;
        do
          v17 = __ldxr(v16);
        while (__stxr(v17 + 1, v16));
        v5[1].__shared_owners_ = (uint64_t)v7;
        v5[1].__shared_weak_owners_ = (uint64_t)v5;
      }
      do
        v18 = __ldaxr(v6);
      while (__stlxr(v18 - 1, v6));
      if (!v18)
      {
        v37 = v10;
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
        v10 = v37;
      }
      goto LABEL_23;
    }
  }
}

void sub_1840B7A2C(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  NetworkProxy *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *shared_weak_owners;
  void *v11;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7);
  shared_weak_owners = (const void *)v2[10].__shared_weak_owners_;
  v2[10].__shared_weak_owners_ = 0;
  if (shared_weak_owners)
    CFRelease(shared_weak_owners);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&v2[8].__shared_owners_);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&v2[7].__shared_weak_owners_);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&v2[7]);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v6);
  NetworkProxy::~NetworkProxy(v3);
  std::__shared_weak_count::~__shared_weak_count(v2);
  operator delete(v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<NetworkProxy>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0868;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NetworkProxy>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0868;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<NetworkProxy>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<TunnelProxy<HTTPEngine>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0830;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TunnelProxy<HTTPEngine>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0830;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<TunnelProxy<HTTPEngine>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t attempt_count;
  NSObject *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t parent_endpoint_domain;
  uint64_t port;
  uint64_t v14;
  uint64_t v15;
  std::__shared_weak_count_vtbl *v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  uint64_t v20;
  unint64_t v21;
  void (*v22)(_QWORD *, const void *, uint64_t, uint64_t, uint64_t, _BYTE *);
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD v37[7];
  std::__shared_weak_count *v38;
  _QWORD v39[2];
  void (*v40)(uint64_t);
  void *v41;
  NSObject *v42;
  _QWORD v43[2];
  void (*v44)(uint64_t);
  void *v45;
  uint64_t v46;
  std::__shared_weak_count_vtbl *v47;
  std::__shared_weak_count *v48;
  _BYTE buf[22];
  __int16 v50;
  int v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  attempt_count = nw_authentication_challenge_get_attempt_count();
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v36 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 134218498;
    *(_QWORD *)&buf[4] = v36;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = a2;
    v50 = 1024;
    v51 = attempt_count;
    _os_log_debug_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEBUG, "Connection %llu: Received Proxy Challenge %@ %u", buf, 0x1Cu);
  }
  v8 = (const void *)nw_authentication_challenge_copy_http_message();
  if (v8)
  {
    v9 = nw_authentication_challenge_copy_protection_space();
    v10 = MEMORY[0x1E0C809B0];
    v43[0] = MEMORY[0x1E0C809B0];
    v43[1] = 3221225472;
    v44 = ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke_3;
    v45 = &unk_1E14FE118;
    v46 = v9;
    v11 = nw_authentication_protection_space_copy_endpoint();
    v39[0] = v10;
    v39[1] = 3221225472;
    v40 = ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke_2;
    v41 = &unk_1E14FE118;
    v42 = v11;
    parent_endpoint_domain = nw_endpoint_get_parent_endpoint_domain();
    if (!parent_endpoint_domain)
      parent_endpoint_domain = (uint64_t)nw_endpoint_get_hostname(v11);
    port = nw_endpoint_get_port(v11);
    v14 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", parent_endpoint_domain);
    v37[0] = v10;
    v37[1] = 3221225472;
    v37[2] = ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke_3;
    v37[3] = &unk_1E14FC008;
    v15 = *(_QWORD *)(a1 + 32);
    v37[4] = a3;
    v37[5] = v15;
    v16 = (std::__shared_weak_count_vtbl *)operator new();
    v16->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_initial;
    v16->__on_zero_shared = 0;
    v16->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))_Block_copy(v37);
    v37[6] = v16;
    v17 = (std::__shared_weak_count *)operator new();
    v18 = v17;
    v17->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    v17->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1390;
    v17->__shared_weak_owners_ = 0;
    v17[1].__vftable = v16;
    v38 = v17;
    v20 = *(_QWORD *)(a1 + 40);
    if (!v20)
      goto LABEL_26;
    v47 = v16;
    v48 = v17;
    do
      v21 = __ldxr(p_shared_owners);
    while (__stxr(v21 + 1, p_shared_owners));
    v22 = *(void (**)(_QWORD *, const void *, uint64_t, uint64_t, uint64_t, _BYTE *))(v20 + 8);
    v23 = *(_QWORD *)(v20 + 16);
    v24 = (_QWORD *)(v20 + (v23 >> 1));
    if ((v23 & 1) != 0)
      v22 = *(void (**)(_QWORD *, const void *, uint64_t, uint64_t, uint64_t, _BYTE *))(*v24 + v22);
    *(_QWORD *)buf = v16;
    *(_QWORD *)&buf[8] = v18;
    do
      v25 = __ldxr(p_shared_owners);
    while (__stxr(v25 + 1, p_shared_owners));
    v22(v24, v8, attempt_count, v14, port, buf);
    v26 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v27 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v29 = v48;
    if (v48)
    {
      v30 = (unint64_t *)&v48->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    v18 = v38;
    if (v38)
    {
LABEL_26:
      v32 = (unint64_t *)&v18->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    v40((uint64_t)v39);
    v44((uint64_t)v43);
    CFRelease(v8);
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v34 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v35 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 134218242;
      *(_QWORD *)&buf[4] = v35;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = a2;
      _os_log_impl(&dword_183ECA000, v34, OS_LOG_TYPE_DEFAULT, "Connection %llu: Proxy Challenge %@ has no response", buf, 0x16u);
    }
    (*(void (**)(uint64_t, _QWORD, _QWORD))(a3 + 16))(a3, 0, 0);
  }
}

void sub_1840B7F84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, void (*a19)(char *), uint64_t a20,uint64_t a21,char a22,uint64_t a23,void (*a24)(char *),uint64_t a25,uint64_t a26,char a27)
{
  const void *v27;
  uint64_t v28;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v28 - 144);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a27);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  a19(&a17);
  a24(&a22);
  CFRelease(v27);
  _Unwind_Resume(a1);
}

void ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke_3(uint64_t a1)
{
  nw_release(*(void **)(a1 + 32));
}

void ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke_2(uint64_t a1)
{
  nw_release(*(void **)(a1 + 32));
}

void ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke_3(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  const void *v7;
  const __CFString *Username;
  _QWORD *v9;
  uint64_t v10;
  const __CFString *v11;
  char v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE allocator[24];
  UInt8 v19[1024];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v14 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)allocator = 134218498;
    *(_QWORD *)&allocator[4] = v14;
    *(_WORD *)&allocator[12] = 2112;
    *(_QWORD *)&allocator[14] = a2;
    *(_WORD *)&allocator[22] = 1024;
    *(_DWORD *)v19 = a3;
    _os_log_debug_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEBUG, "Connection %llu: Proxy Challenge Handler Complete proxyCred %@ cancel %d", allocator, 0x1Cu);
    if (!a2)
      goto LABEL_26;
  }
  else if (!a2)
  {
    goto LABEL_26;
  }
  v7 = (const void *)nw_authentication_credential_create();
  if (v7)
  {
    Username = (const __CFString *)CFURLCredentialGetUsername(a2);
    v9 = (_QWORD *)MEMORY[0x1E0C9AE00];
    if (Username)
    {
      *(_QWORD *)allocator = *MEMORY[0x1E0C9AE00];
      *(_QWORD *)&allocator[8] = 1023;
      *(_QWORD *)&allocator[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)allocator, Username, v19, (uint64_t *)&allocator[8], 0x8000100u);
      nw_authentication_credential_set_username();
      Username = *(const __CFString **)&allocator[16];
      if (*(_QWORD *)&allocator[16])
      {
        if (v19 != *(UInt8 **)&allocator[16])
          CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
      }
    }
    v10 = URLCredential_PasswordBased::safelyCast(a2, (const _CFURLCredential *)Username);
    if (v10)
    {
      v11 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 128))(v10);
      if (v11)
      {
        *(_QWORD *)allocator = *v9;
        *(_QWORD *)&allocator[8] = 1023;
        *(_QWORD *)&allocator[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)allocator, v11, v19, (uint64_t *)&allocator[8], 0x8000100u);
        nw_authentication_credential_set_password();
        if (*(_QWORD *)&allocator[16] && v19 != *(UInt8 **)&allocator[16])
          CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
        v12 = 0;
        goto LABEL_18;
      }
    }
    else
    {
      v11 = 0;
    }
    v12 = 1;
LABEL_18:
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v13 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v17 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)allocator = 134218498;
      *(_QWORD *)&allocator[4] = v17;
      *(_WORD *)&allocator[12] = 2112;
      *(_QWORD *)&allocator[14] = v7;
      *(_WORD *)&allocator[22] = 1024;
      *(_DWORD *)v19 = a3;
      _os_log_debug_impl(&dword_183ECA000, v13, OS_LOG_TYPE_DEBUG, "Connection %llu: Proxy Challenge invoking completion with cred %@ cancel %d", allocator, 0x1Cu);
    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    if ((v12 & 1) == 0)
      CFRelease(v11);
    CFRelease(v7);
    return;
  }
LABEL_26:
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v15 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v16 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)allocator = 134218240;
    *(_QWORD *)&allocator[4] = v16;
    *(_WORD *)&allocator[12] = 1024;
    *(_DWORD *)&allocator[14] = a3;
    _os_log_debug_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEBUG, "Connection %llu: Proxy Challenge invoking completion with no cred cancel %d", allocator, 0x12u);
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1840B8374(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  const void *v11;
  const void *v12;
  void *v13;

  if (ptr)
  {
    if (v13 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  CFRelease(v12);
  CFRelease(v11);
  _Unwind_Resume(a1);
}

uint64_t BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_initial(_QWORD *a1)
{
  a1[1] = BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void std::__shared_ptr_pointer<BlockHolderVar<_CFURLCredential const*,BOOL> *,SmartBlockWithArgs<_CFURLCredential const*,BOOL>::Deleter,std::allocator<BlockHolderVar<_CFURLCredential const*,BOOL>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<BlockHolderVar<_CFURLCredential const*,BOOL> *,SmartBlockWithArgs<_CFURLCredential const*,BOOL>::Deleter,std::allocator<BlockHolderVar<_CFURLCredential const*,BOOL>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  int v5;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if ((uint64_t (*)(_QWORD *))v3 == BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_initial && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      (*(void (**)(_QWORD *, _QWORD, _QWORD))(*v7
                                                       + BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_initial))(v7, 0, 0);
    else
      ((void (*)(_QWORD *, _QWORD, _QWORD))BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_initial)(v7, 0, 0);
  }
  _Block_release(*(const void **)v1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_nw_parameters}*,Deleter_NWRelease<NSObject  {objcproto16OS_nw_parameters}*>,std::allocator<NSObject  {objcproto16OS_nw_parameters}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void sub_1840BAF60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

__CFString *URLRequest::setTrackerContext(URLRequest *this, __CFString *cf)
{
  __CFString *result;

  result = this->fTrackerContext;
  if (result != cf)
  {
    if (result)
      CFRelease(result);
    if (cf)
      result = (__CFString *)CFRetain(cf);
    else
      result = 0;
    this->fTrackerContext = result;
  }
  return result;
}

void sub_1840BB480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,void (*a21)(char *),uint64_t a22,uint64_t a23,char a24,uint64_t a25,void (*a26)(char *))
{
  uint64_t v26;

  a21(&a19);
  a26(&a24);
  (*(void (**)(uint64_t))(v26 - 128))(v26 - 144);
  _Unwind_Resume(a1);
}

void sub_1840BB85C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *), uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf,CFTypeRef a21,char a22,uint64_t a23,void (*a24)(char *),uint64_t a25,uint64_t a26,char a27,uint64_t a28,void (*a29)(char *),uint64_t a30,uint64_t a31,char a32,uint64_t a33,void (*a34)(char *))
{
  a12(&a10);
  if (cf)
    CFRelease(cf);
  if (a21)
    CFRelease(a21);
  a24(&a22);
  a29(&a27);
  a34(&a32);
  _Unwind_Resume(a1);
}

void sub_1840BBC14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void __Block_byref_object_copy__13473(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__13474(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void SSLDecoder::~SSLDecoder(SSLDecoder *this)
{
  uint64_t v2;

  SSLDecoder::~SSLDecoder(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = off_1E14E4BE8;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 3);
  if (v3)
    CFRelease(v3);
}

void SSLDecoder::processBytes(CFAllocatorRef *this, const __CFData **a2, UInt8 *bytes, size_t length, const char *a5)
{
  CFIndex v10;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  CFDataRef v13;
  const __CFData *v14;
  const UInt8 *BytePtr;
  unint64_t v16;
  const UInt8 *v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  const UInt8 *v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  BOOL v33;
  const char *v34;
  CFMutableArrayRef v35;
  const __CFData **v36;
  const __CFData *v37;
  const __CFData *v38;
  const __CFData *cf;
  const UInt8 *v40;
  CFMutableArrayRef v42;
  CFRange v43;

  if (*a2)
  {
    v10 = CFDataGetLength(*a2);
    Mutable = CFDataCreateMutable(this[1], v10 + length);
    CFDataSetLength(Mutable, v10 + length);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v43.location = 0;
    v43.length = v10;
    CFDataGetBytes(*a2, v43, MutableBytePtr);
    memcpy(&MutableBytePtr[v10], bytes, length);
    v13 = *a2;
    *a2 = 0;
    if (v13)
      CFRelease(v13);
    v14 = Mutable;
    if (!Mutable)
      return;
  }
  else
  {
    v14 = CFDataCreate(this[1], bytes, length);
    if (!v14)
      return;
  }
  BytePtr = CFDataGetBytePtr(v14);
  cf = v14;
  v16 = (unint64_t)&BytePtr[CFDataGetLength(v14)];
  v40 = BytePtr;
  while ((unint64_t)BytePtr < v16)
  {
    v17 = BytePtr + 5;
    if ((unint64_t)(BytePtr + 5) > v16)
      break;
    v18 = *BytePtr;
    v19 = *(unsigned __int16 *)(BytePtr + 1);
    v20 = *(unsigned __int16 *)(BytePtr + 3);
    v21 = __rev16(v20);
    v22 = &v17[v21];
    if ((unint64_t)&v17[v21] > v16)
      break;
    v42 = CFArrayCreateMutable(this[1], 0, MEMORY[0x1E0C9B378]);
    AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("BEGIN SSL RECORD DECODE: %s"), a5);
    v23 = bswap32(v19) >> 16;
    switch(v18)
    {
      case 20:
        AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("%s @ %p, version %2.2x, length %d"), "decodeChangeCiperSpec", BytePtr + 5, v23, v21);
        break;
      case 21:
        AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("%s @ %p, version %2.2x, length %d"), "decodeAlert", BytePtr + 5, v23, v21);
        v24 = BytePtr[5];
        v25 = BytePtr[6];
        v26 = "UNKNOWN";
        if (v25 > 0x45)
        {
          if (BytePtr[6] > 0x59u)
          {
            switch(v25)
            {
              case 'Z':
                v26 = "User cancelled\tfatal";
                break;
              case 'd':
                v26 = "No renegotiation";
                break;
              case 'n':
                v26 = "Unsupported extension";
                break;
            }
          }
          else
          {
            switch(v25)
            {
              case 'F':
                v26 = "Protocol version";
                break;
              case 'G':
                v26 = "Insufficient security";
                break;
              case 'P':
                v26 = "Internal error\tfatal";
                break;
            }
          }
        }
        else
        {
          switch(BytePtr[6])
          {
            case 0x14u:
              v26 = "Bad record MAC";
              break;
            case 0x15u:
              v26 = "Decryption failed";
              break;
            case 0x16u:
              v26 = "Record overflow";
              break;
            case 0x17u:
            case 0x18u:
            case 0x19u:
            case 0x1Au:
            case 0x1Bu:
            case 0x1Cu:
            case 0x1Du:
            case 0x1Fu:
            case 0x20u:
            case 0x21u:
            case 0x22u:
            case 0x23u:
            case 0x24u:
            case 0x25u:
            case 0x26u:
            case 0x27u:
            case 0x34u:
            case 0x35u:
            case 0x36u:
            case 0x37u:
            case 0x38u:
            case 0x39u:
            case 0x3Au:
            case 0x3Bu:
              break;
            case 0x1Eu:
              v26 = "Decompression failure";
              break;
            case 0x28u:
              v26 = "Handshake failure";
              break;
            case 0x29u:
              v26 = "No certificate";
              break;
            case 0x2Au:
              v26 = "Bad certificate";
              break;
            case 0x2Bu:
              v26 = "Unsupported certificate";
              break;
            case 0x2Cu:
              v26 = "Certificate revoked";
              break;
            case 0x2Du:
              v26 = "Certificate expired";
              break;
            case 0x2Eu:
              v26 = "Certificate unknown";
              break;
            case 0x2Fu:
              v26 = "Illegal parameter";
              break;
            case 0x30u:
              v26 = "Unknown CA";
              break;
            case 0x31u:
              v26 = "Access denied";
              break;
            case 0x32u:
              v26 = "Decode error";
              break;
            case 0x33u:
              v26 = "Decrypt error";
              break;
            case 0x3Cu:
              v26 = "Export restriction";
              break;
            default:
              if (BytePtr[6])
              {
                if (v25 == 10)
                  v26 = "Unexpected message";
              }
              else
              {
                v26 = "Close notify";
              }
              break;
          }
        }
        v32 = "UNKNOWN";
        if (v24 == 2)
          v32 = "fatal";
        v33 = v24 == 1;
        v34 = "warning";
        if (!v33)
          v34 = v32;
        AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("Alert %s is %s"), v26, v34);
        break;
      case 22:
        if (v20)
        {
          v27 = 0;
          v28 = v23;
          while (1)
          {
            AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("%s [%d] @ %p, version %2.2x, length %d (0x%x)"), "decodeHandshake", v27, v17, v28, v21, v21);
            v29 = (unsigned __int8 *)(v17 + 4);
            if (v17 + 4 > v22)
            {
              AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("## Only %ld bytes after header, need at least 4"), v22 - v17);
              goto LABEL_64;
            }
            v30 = *v17;
            v31 = __rev16(*((unsigned __int16 *)v17 + 1));
            v17 = &v29[v31];
            if (&v29[v31] > v22)
              break;
            if (v30 >= 0x15 || ((0x11F807u >> v30) & 1) == 0)
            {
              AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("## Unknown msg %d (0x%x) - encrypted?"), v30, v30);
              goto LABEL_64;
            }
            AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("%s (%d, 0x%x), length %d (0x%x)"), off_1E14FC228[v30], v30, v30, v31, v31);
            v27 = (v27 + 1);
            if (v17 >= v22)
              goto LABEL_64;
          }
          AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("## Message %d (0x%x) length %d (0x%x) invalid - encrypted?"), v30, v30, v31, v31);
        }
        break;
      case 23:
        AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("%s @ %p, version %2.2x, length %d (0x%x)"), "decodeApplication", BytePtr + 5, v23, v21, v21);
        break;
      default:
        break;
    }
LABEL_64:
    AutoStringArray::addFormat((CFTypeRef *)&v42, CFSTR("END SSL RECORD DECODE: %s"), a5);
    v35 = v42;
    (*(void (**)(CFAllocatorRef, char *, CFMutableArrayRef))(*(_QWORD *)this[4] + 24))(this[4], (char *)this + 40, v42);
    CFRelease(v35);
    v33 = v22 == BytePtr;
    BytePtr = v22;
    if (v33)
      goto LABEL_68;
  }
  v22 = BytePtr;
LABEL_68:
  if (v22 == v40)
  {
    v38 = cf;
    v37 = (const __CFData *)CFRetain(cf);
    v36 = a2;
  }
  else
  {
    v36 = a2;
    if (v22 == (const UInt8 *)v16)
      v37 = 0;
    else
      v37 = CFDataCreate(this[1], v22, v16 - (_QWORD)v22);
    v38 = cf;
  }
  *v36 = v37;
  CFRelease(v38);
}

void sub_1840BC580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf)
{
  CFRelease(cf);
  _Unwind_Resume(a1);
}

void ChunkedResponseDataCombiner::~ChunkedResponseDataCombiner(ChunkedResponseDataCombiner *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E14EBA28;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E14E5838;
}

{
  const void *v2;

  *(_QWORD *)this = &off_1E14EBA28;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

void sub_1840BC5E0(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_1840BC648(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t ChunkedResponseDataCombiner::canRead(ChunkedResponseDataCombiner *this)
{
  return 1;
}

void ChunkedResponseDataCombiner::read(ResponseDataCombiner *this, uint64_t a2)
{
  int v4;
  _BYTE *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  char *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFReadStream *v18;
  char *v19;
  int v20;
  uint8_t buf[8];
  uint64_t v22;
  _QWORD v23[4];

  if (*(uint64_t *)(a2 + 8) >= 1)
  {
    v4 = 0;
    v5 = (char *)this + 32896;
    v6 = (_QWORD *)(a2 + 24);
    v7 = (_QWORD *)((char *)this + 48);
    v8 = (_QWORD *)((char *)this + 104);
    while (1)
    {
      if (*(_BYTE *)(a2 + 41) || *(_BYTE *)(a2 + 40) || v4 || *v6)
        return;
      switch(*((_DWORD *)this + 10))
      {
        case 0:
          if (*((_QWORD *)this + 1) && *((_QWORD *)this + 2) < *((_QWORD *)this + 3))
          {
            ResponseDataCombiner::readHeaderData((uint64_t)this, a2);
            goto LABEL_39;
          }
          v4 = 0;
          *((_DWORD *)this + 10) = 1;
          goto LABEL_42;
        case 1:
        case 2:
          if (ResponseDataCombiner::canRead(this))
          {
            v9 = *((_QWORD *)this + 13);
            memset(v23, 0, sizeof(v23));
            *(_QWORD *)buf = v9;
            v22 = 0x8000;
            ResponseDataCombiner::readBodyStreamData((uint64_t)this, (uint64_t)buf);
            v10 = v23[0];
            if (!v23[0])
            {
              v5[1] = *((_DWORD *)this + 10) == 1;
              v11 = 5;
              goto LABEL_34;
            }
            if (v23[0] == -1)
            {
              *(_OWORD *)v6 = *(_OWORD *)&v23[1];
              *(_BYTE *)(a2 + 40) = 1;
              v11 = 7;
LABEL_34:
              *((_DWORD *)this + 10) = v11;
              goto LABEL_39;
            }
            *((_QWORD *)this + 14) = 0;
            *((_QWORD *)this + 15) = v10;
            v19 = (char *)*((_QWORD *)this + 6);
            if (*((_DWORD *)this + 10) == 1)
              v20 = snprintf(v19, 0x20uLL, "%X\r\n");
            else
              v20 = snprintf(v19, 0x20uLL, "\r\n%X\r\n");
            *((_QWORD *)this + 7) = 0;
            *((_QWORD *)this + 8) = v20;
            *((_DWORD *)this + 10) = 3;
            *v5 = v23[3];
LABEL_39:
            v4 = 0;
          }
          else
          {
            v18 = (__CFReadStream *)*((_QWORD *)this + 4);
            if (!v18 || CFReadStreamGetStatus(v18) == kCFStreamStatusAtEnd)
            {
              v4 = 0;
              v5[1] = *((_DWORD *)this + 10) == 1;
              goto LABEL_31;
            }
            v4 = 1;
          }
LABEL_42:
          if (*(uint64_t *)(a2 + 8) <= 0)
            return;
          break;
        case 3:
          if (!ChunkedResponseDataCombiner::processBuffer(v7, a2))
            goto LABEL_39;
          v4 = 0;
          v12 = 4;
          goto LABEL_41;
        case 4:
          if (!ChunkedResponseDataCombiner::processBuffer(v8, a2))
            goto LABEL_39;
          v4 = *v5;
          if (*v5)
          {
            v4 = 0;
LABEL_31:
            v12 = 5;
          }
          else
          {
            v12 = 2;
          }
          goto LABEL_41;
        case 5:
          v13 = (char *)*((_QWORD *)this + 6);
          if (v5[1])
            v14 = snprintf(v13, 0x20uLL, "%X\r\n");
          else
            v14 = snprintf(v13, 0x20uLL, "\r\n%X\r\n");
          v4 = 0;
          v15 = *((_QWORD *)this + 6);
          *((_QWORD *)this + 7) = 0;
          *((_QWORD *)this + 8) = v14 + 1;
          *(_BYTE *)(v15 + v14) = 13;
          v16 = *((_QWORD *)this + 6);
          v17 = *((_QWORD *)this + 8);
          *((_QWORD *)this + 8) = v17 + 1;
          *(_BYTE *)(v16 + v17) = 10;
          v12 = 6;
          goto LABEL_41;
        case 6:
          if (!ChunkedResponseDataCombiner::processBuffer(v7, a2))
            goto LABEL_39;
          v4 = 0;
          *(_BYTE *)(a2 + 40) = 1;
          v12 = 7;
LABEL_41:
          *((_DWORD *)this + 10) = v12;
          goto LABEL_42;
        default:
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Illegal state", buf, 2u);
          }
          goto LABEL_39;
      }
    }
  }
}

BOOL ChunkedResponseDataCombiner::processBuffer(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  int64_t v5;
  int64_t v6;
  int64_t v7;
  uint64_t v8;
  int64_t v9;

  v4 = a1[1];
  v5 = a1[2] - v4;
  v6 = *(_QWORD *)(a2 + 8);
  if (v5 > v6)
  {
    *(_BYTE *)(a2 + 41) = 1;
    v5 = v6;
  }
  memcpy(*(void **)a2, (const void *)(*a1 + v4), v5);
  v7 = *(_QWORD *)(a2 + 8) - v5;
  *(_QWORD *)a2 += v5;
  *(_QWORD *)(a2 + 8) = v7;
  *(_QWORD *)(a2 + 16) += v5;
  v8 = a1[2];
  v9 = a1[1] + v5;
  a1[1] = v9;
  return v9 == v8;
}

void PrivateAccessTokens::getPATAuthHeaders(uint64_t a1, const __CFArray *a2, const __CFData *a3, uint64_t a4, const __CFURL *a5, const __CFURL *a6, void *a7, int a8, char a9, char a10, void *a11, uint64_t *a12)
{
  double v12;
  __uint64_t v13;
  void *v14;
  unint64_t v15;
  void *v16;
  CFErrorRef v17;
  uint64_t v18;
  void (*v19)(_QWORD *, _QWORD, CFErrorRef);
  uint64_t v20;
  _QWORD *v21;
  CFIndex Count;
  CFIndex v23;
  BOOL v24;
  int v25;
  const __CFDictionary *ValueAtIndex;
  double v27;
  double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge;
  uint64_t v29;
  PrivateAccessTokens *v30;
  NSString *v31;
  PrivateAccessTokens *v32;
  NSObject *v33;
  double v34;
  uint64_t v35;
  void *v36;
  void *v37;
  char v38;
  char v39;
  int v40;
  int v41;
  void *v42;
  uint64_t v43;
  __CFString *v44;
  void *v45;
  uint64_t v46;
  void *v47;
  BOOL v48;
  double v49;
  NSObject *v50;
  void *v51;
  uint64_t v52;
  double v53;
  uint64_t v54;
  PrivateAccessTokens *v55;
  NSString *v56;
  NSObject *v57;
  double v58;
  double v59;
  uint64_t v60;
  PrivateAccessTokens *v61;
  NSString *v62;
  double v63;
  PrivateAccessTokens *v64;
  void *v65;
  uint64_t v66;
  BOOL v67;
  void *v68;
  std::__shared_weak_count *v69;
  unint64_t *p_shared_owners;
  unint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  NSObject *v75;
  uint64_t v76;
  void (*v77)(_QWORD *, _QWORD, CFErrorRef);
  uint64_t v78;
  _QWORD *v79;
  CFErrorRef v80;
  uint64_t v81;
  void (*v82)(_QWORD *, _QWORD, CFErrorRef);
  uint64_t v83;
  _QWORD *v84;
  uint64_t v85;
  uint64_t v86;
  const void *v87;
  char v88;
  int v89;
  void *v90;
  void *v96;
  id v97;
  id v99;
  NSObject *log;
  char v101;
  _QWORD v103[5];
  std::__shared_weak_count *v104;
  char v105;
  _OWORD v106[2];
  uint8_t buf[32];
  uint64_t v108;
  CFRange v109;

  v108 = *MEMORY[0x1E0C80C00];
  v97 = a7;
  v99 = a11;
  gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v12);
  if (!objc_opt_class())
  {
    v17 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("kCFErrorDomainCFNetwork"), -1000, 0);
    v18 = *a12;
    if (*a12)
    {
      v19 = *(void (**)(_QWORD *, _QWORD, CFErrorRef))(v18 + 8);
      v20 = *(_QWORD *)(v18 + 16);
      v21 = (_QWORD *)(v18 + (v20 >> 1));
      if ((v20 & 1) != 0)
        v19 = *(void (**)(_QWORD *, _QWORD, CFErrorRef))(*v21 + v19);
      v19(v21, 0, v17);
    }
    goto LABEL_92;
  }
  if (v99)
  {
    v13 = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX) / 0x3B9ACA00;
    if (!objc_msgSend(v99, "count"))
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v13);
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v99, "addObject:", v16);
      goto LABEL_11;
    }
    objc_msgSend(v99, "objectAtIndexedSubscript:", 0);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = v13 - objc_msgSend(v14, "unsignedLongLongValue");

    if (v15 >= 0x3D)
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v13);
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v99, "setObject:atIndexedSubscript:", v16, 0);
LABEL_11:

      goto LABEL_12;
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v75 = (id)CFNLog::logger;
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = a1;
      _os_log_error_impl(&dword_183ECA000, v75, OS_LOG_TYPE_ERROR, "%{public}@ too many PAT requests", buf, 0xCu);
    }

    v17 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFErrorDomain)*MEMORY[0x1E0CB32E8], -1013, 0);
    v76 = *a12;
    if (*a12)
    {
      v77 = *(void (**)(_QWORD *, _QWORD, CFErrorRef))(v76 + 8);
      v78 = *(_QWORD *)(v76 + 16);
      v79 = (_QWORD *)(v76 + (v78 >> 1));
      if ((v78 & 1) != 0)
        v77 = *(void (**)(_QWORD *, _QWORD, CFErrorRef))(*v79 + v77);
      v77(v79, 0, v17);
    }
LABEL_92:
    if (v17)
      CFRelease(v17);
    goto LABEL_107;
  }
LABEL_12:
  Count = CFArrayGetCount(a2);
  if (Count < 1)
  {
    v96 = 0;
    goto LABEL_99;
  }
  v23 = 0;
  v96 = 0;
  v90 = 0;
  v88 = 0;
  v101 = 0;
  if (a6)
    v24 = a10 == 0;
  else
    v24 = 1;
  v25 = !v24;
  v89 = v25;
  v87 = (const void *)*MEMORY[0x1E0C9AE50];
  do
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, v23);
    Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v27);
    CFDictionaryGetValue(ValueAtIndex, (const void *)objc_msgSend(*(id *)(v29 + 2728), "challengeAttributeName", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge));
    v30 = (PrivateAccessTokens *)objc_claimAutoreleasedReturnValue();
    v32 = v30;
    if (v30)
    {
      PrivateAccessTokens::decodeBase64URL(v30, v31);
      v33 = objc_claimAutoreleasedReturnValue();
      if (v33)
      {
        gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v34);
        v36 = (void *)objc_msgSend(objc_alloc(*(Class *)(v35 + 2728)), "initWithData:", v33);
        v37 = v36;
        if (!v36)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          log = (id)CFNLog::logger;
          if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = a1;
            *(_WORD *)&buf[12] = 2112;
            *(_QWORD *)&buf[14] = v32;
            _os_log_error_impl(&dword_183ECA000, log, OS_LOG_TYPE_ERROR, "%{public}@ PAT creating challenge failed %@", buf, 0x16u);
          }
          goto LABEL_69;
        }
        v38 = objc_msgSend(v36, "typeRequiresRedemptionNonce");
        if (a8)
          v39 = v38;
        else
          v39 = 0;
        if ((v39 & 1) != 0)
          goto LABEL_70;
        v40 = objc_msgSend(v37, "typeHasAllowedOriginList");
        v41 = a9 ? v40 : 1;
        if (!a10 && !v41)
          goto LABEL_70;
        log = CFURLCopyHostName(a5);
        objc_msgSend(v37, "originNames");
        v42 = (void *)objc_claimAutoreleasedReturnValue();
        v43 = objc_msgSend(v42, "indexOfObject:", log);

        if (v89)
        {
          v44 = (__CFString *)CFURLCopyHostName(a6);
          objc_msgSend(v37, "originNames");
          v45 = (void *)objc_claimAutoreleasedReturnValue();
          v46 = objc_msgSend(v45, "indexOfObject:", v44);

          if (v46 != 0x7FFFFFFFFFFFFFFFLL)
            v43 = v46;

        }
        if (v43 == 0x7FFFFFFFFFFFFFFFLL)
        {
          if ((objc_msgSend(v37, "typeRequiresOriginName") & 1) != 0
            || (objc_msgSend(v37, "originNames"),
                v47 = (void *)objc_claimAutoreleasedReturnValue(),
                v48 = objc_msgSend(v47, "count") == 0,
                v47,
                !v48))
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v50 = (id)CFNLog::logger;
            if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138543618;
              *(_QWORD *)&buf[4] = a1;
              *(_WORD *)&buf[12] = 2112;
              *(_QWORD *)&buf[14] = log;
              _os_log_error_impl(&dword_183ECA000, v50, OS_LOG_TYPE_ERROR, "%{public}@ PAT origin verification failed %@", buf, 0x16u);
            }
LABEL_68:

LABEL_69:
LABEL_70:

            goto LABEL_71;
          }
        }
        else
        {
          objc_msgSend(v37, "originNames");
          v51 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v51, "objectAtIndexedSubscript:", v43);
          v52 = objc_claimAutoreleasedReturnValue();

          v96 = (void *)v52;
        }
        v53 = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v49);
        CFDictionaryGetValue(ValueAtIndex, (const void *)objc_msgSend(*(id *)(v54 + 2728), "tokenKeyAttributeName", v53));
        v55 = (PrivateAccessTokens *)objc_claimAutoreleasedReturnValue();
        v50 = v55;
        if (v55
          && (PrivateAccessTokens::decodeBase64URL(v55, v56),
              (v57 = objc_claimAutoreleasedReturnValue()) != 0))
        {
          v59 = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v58);
          CFDictionaryGetValue(ValueAtIndex, (const void *)objc_msgSend(*(id *)(v60 + 2728), "originNameKeyAttributeName", v59));
          v61 = (PrivateAccessTokens *)objc_claimAutoreleasedReturnValue();
          v64 = v61;
          if (v61)
          {
            PrivateAccessTokens::decodeBase64URL(v61, v62);
            v65 = (void *)objc_claimAutoreleasedReturnValue();
          }
          else
          {
            v65 = 0;
          }
          if (v90)
          {
            objc_msgSend(v90, "addSecondaryChallenge:tokenKey:originNameKey:", v33, v57, v65);
          }
          else
          {
            gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(v63);
            v90 = (void *)objc_msgSend(objc_alloc(*(Class *)(v66 + 2736)), "initWithChallenge:tokenKey:originNameKey:", v33, v57, v65);
          }
          v67 = CFDictionaryGetValue(ValueAtIndex, CFSTR("kCFHTTPAuthenticationUsedQuotes")) == v87;

          v88 |= v67;
        }
        else
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v57 = (id)CFNLog::logger;
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543618;
            *(_QWORD *)&buf[4] = a1;
            *(_WORD *)&buf[12] = 2112;
            *(_QWORD *)&buf[14] = v50;
            _os_log_error_impl(&dword_183ECA000, v57, OS_LOG_TYPE_ERROR, "%{public}@ PAT parsing token key failed %@", buf, 0x16u);
          }
          v101 = 1;
        }

        goto LABEL_68;
      }
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v33 = (id)CFNLog::logger;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543618;
      *(_QWORD *)&buf[4] = a1;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v32;
      _os_log_error_impl(&dword_183ECA000, v33, OS_LOG_TYPE_ERROR, "%{public}@ PAT parsing challenge failed %@", buf, 0x16u);
    }
    v101 = 1;
LABEL_71:

    ++v23;
  }
  while (Count != v23);
  v68 = v90;
  if (v90)
  {
    if (a3)
    {
      memset(buf, 0, sizeof(buf));
      v109.location = 0;
      v109.length = 32;
      CFDataGetBytes(a3, v109, buf);
      v106[0] = *(_OWORD *)buf;
      v106[1] = *(_OWORD *)&buf[16];
      objc_msgSend(v90, "setAuditToken:", v106);
    }
    objc_msgSend(v90, "setBundleID:", a4);
    objc_msgSend(v90, "setSelectedOrigin:", v96);
    v103[0] = MEMORY[0x1E0C809B0];
    v103[1] = 3321888768;
    v103[2] = ___ZN19PrivateAccessTokens17getPATAuthHeadersEPK10__CFStringP9__CFArrayPK8__CFDataS2_PK7__CFURLSA_PU28objcproto17OS_dispatch_queue8NSObjecthhhP14NSMutableArrayIP8NSNumberE18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE_block_invoke;
    v103[3] = &__block_descriptor_49_ea8_32c57_ZTS18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE_e28_v24__0__NSData_8__NSError_16l;
    v105 = v88 & 1;
    v69 = (std::__shared_weak_count *)a12[1];
    v103[4] = *a12;
    v104 = v69;
    if (v69)
    {
      p_shared_owners = (unint64_t *)&v69->__shared_owners_;
      do
        v71 = __ldxr(p_shared_owners);
      while (__stxr(v71 + 1, p_shared_owners));
    }
    objc_msgSend(v90, "fetchTokenWithQueue:completionHandler:", v97, v103);
    v72 = v104;
    if (v104)
    {
      v73 = (unint64_t *)&v104->__shared_owners_;
      do
        v74 = __ldaxr(v73);
      while (__stlxr(v74 - 1, v73));
      if (!v74)
      {
        ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
        std::__shared_weak_count::__release_weak(v72);
      }
    }
    goto LABEL_106;
  }
  if ((v101 & 1) != 0)
  {
    v80 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("kCFErrorDomainCFNetwork"), -1, 0);
    v81 = *a12;
    if (*a12)
    {
      v82 = *(void (**)(_QWORD *, _QWORD, CFErrorRef))(v81 + 8);
      v83 = *(_QWORD *)(v81 + 16);
      v84 = (_QWORD *)(v81 + (v83 >> 1));
      if ((v83 & 1) != 0)
        v82 = *(void (**)(_QWORD *, _QWORD, CFErrorRef))(*v84 + v82);
      goto LABEL_102;
    }
    goto LABEL_103;
  }
LABEL_99:
  v80 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFErrorDomain)*MEMORY[0x1E0CB32E8], -1013, 0);
  v85 = *a12;
  if (*a12)
  {
    v82 = *(void (**)(_QWORD *, _QWORD, CFErrorRef))(v85 + 8);
    v86 = *(_QWORD *)(v85 + 16);
    v84 = (_QWORD *)(v85 + (v86 >> 1));
    if ((v86 & 1) != 0)
      v82 = *(void (**)(_QWORD *, _QWORD, CFErrorRef))(*v84 + v82);
LABEL_102:
    v82(v84, 0, v80);
  }
LABEL_103:
  if (v80)
    CFRelease(v80);
  v68 = 0;
LABEL_106:

LABEL_107:
}

void sub_1840BD3F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,void *a24,uint64_t a25,void *a26,uint64_t a27)
{
  const void *v27;

  if (v27)
    CFRelease(v27);

  _Unwind_Resume(a1);
}

id PrivateAccessTokens::decodeBase64URL(PrivateAccessTokens *this, NSString *a2)
{
  PrivateAccessTokens *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = this;
  -[PrivateAccessTokens stringByReplacingOccurrencesOfString:withString:](v2, "stringByReplacingOccurrencesOfString:withString:", CFSTR("_"), CFSTR("/"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v3, "stringByReplacingOccurrencesOfString:withString:", CFSTR("-"), CFSTR("+"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", v4, 1);
  return v5;
}

void sub_1840BD628(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN19PrivateAccessTokens17getPATAuthHeadersEPK10__CFStringP9__CFArrayPK8__CFDataS2_PK7__CFURLSA_PU28objcproto17OS_dispatch_queue8NSObjecthhhP14NSMutableArrayIP8NSNumberE18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  double v11;
  uint64_t v12;
  void *v13;
  double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge;
  uint64_t v15;
  void *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  void (*v20)(_QWORD *, void *, _QWORD);
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  void (*v24)(_QWORD *, _QWORD, void *);
  uint64_t v25;
  _QWORD *v26;
  const __CFString *v27;
  _QWORD v28[2];

  v28[1] = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  v7 = v6;
  if (!v5 || v6)
  {
    v23 = *(_QWORD *)(a1 + 32);
    if (v23)
    {
      v24 = *(void (**)(_QWORD *, _QWORD, void *))(v23 + 8);
      v25 = *(_QWORD *)(v23 + 16);
      v26 = (_QWORD *)(v23 + (v25 >> 1));
      if ((v25 & 1) != 0)
        v24 = *(void (**)(_QWORD *, _QWORD, void *))(*v26 + v24);
      v24(v26, 0, v7);
    }
  }
  else
  {
    objc_msgSend(v5, "base64EncodedStringWithOptions:", 0);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "stringByReplacingOccurrencesOfString:withString:", CFSTR("/"), CFSTR("_"));
    v9 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v9, "stringByReplacingOccurrencesOfString:withString:", CFSTR("+"), CFSTR("-"));
    v10 = (void *)objc_claimAutoreleasedReturnValue();

    if (*(_BYTE *)(a1 + 48))
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("\"%@\""), v10);
      v12 = objc_claimAutoreleasedReturnValue();

      v10 = (void *)v12;
    }
    v27 = CFSTR("Authorization");
    v13 = (void *)MEMORY[0x1E0CB3940];
    Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v11);
    objc_msgSend(*(id *)(v15 + 2728), "httpAuthenticationScheme", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "stringWithFormat:", CFSTR("%@ token=%@"), v16, v10);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    v28[0] = v17;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v28, &v27, 1);
    v18 = (void *)objc_claimAutoreleasedReturnValue();

    v19 = *(_QWORD *)(a1 + 32);
    if (v19)
    {
      v20 = *(void (**)(_QWORD *, void *, _QWORD))(v19 + 8);
      v21 = *(_QWORD *)(v19 + 16);
      v22 = (_QWORD *)(v19 + (v21 >> 1));
      if ((v21 & 1) != 0)
        v20 = *(void (**)(_QWORD *, void *, _QWORD))(*v22 + v20);
      v20(v22, v18, 0);
    }

  }
}

void sub_1840BD81C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c57_ZTS18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c57_ZTS18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void HTTPServer::State::~State(HTTPServer::State *this)
{
  HTTPServer::State::~State(this);
  JUMPOUT(0x186DB748CLL);
}

{
  *(_QWORD *)this = &off_1E14EFED0;
  CFRelease(*((CFTypeRef *)this + 11));
  CFRelease(*((CFTypeRef *)this + 10));
  CFRelease(*((CFTypeRef *)this + 9));
  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

CFStringRef HTTPServer::copyDebugDesc(HTTPServer *this)
{
  CFStringRef v2;
  CFStringRef v3;
  const __CFAllocator *v4;
  int Count;
  int v6;
  int v7;
  CFStringRef v8;
  char __str[255];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = CFObject::copyDebugDescHeader(this);
  v3 = HTTPServerBase::copyBaseDescription((HTTPServer *)((char *)this + 8));
  v4 = CFGetAllocator((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 160));
  Count = CFArrayGetCount(*((CFArrayRef *)this + 28));
  v6 = CFArrayGetCount(*((CFArrayRef *)this + 29));
  v7 = CFArrayGetCount(*((CFArrayRef *)this + 30));
  snprintf(__str, 0xFFuLL, "%d pending, %d outstanding, %d closed", Count, v6, v7);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 160));
  v8 = CFStringCreateWithFormat(v4, 0, CFSTR("%@ { queues=%s, %@ }"), v2, __str, v3);
  if (v3)
    CFRelease(v3);
  if (v2)
    CFRelease(v2);
  return v8;
}

void HTTPServer::connectionClosed(uint64_t a1, const void *a2)
{
  pthread_mutex_t *v4;
  const __CFArray *v5;
  CFIndex FirstIndexOfValue;
  CFIndex v7;
  CFRange v8;

  v4 = (pthread_mutex_t *)(a1 + 160);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 160));
  v5 = *(const __CFArray **)(a1 + 232);
  v8.length = CFArrayGetCount(v5);
  v8.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v5, v8, a2);
  if (FirstIndexOfValue == -1)
  {
    pthread_mutex_unlock(v4);
  }
  else
  {
    v7 = FirstIndexOfValue;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 240), a2);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 232), v7);
    pthread_mutex_unlock(v4);
    HTTPServerBase::signal((NSObject **)(a1 + 8));
  }
}

CFTypeRef HTTPServer::copyProperty(HTTPServer *this, CFStringRef theString)
{
  int ExactString;
  CFTypeRef *v5;
  CFTypeRef result;

  ExactString = _findExactString(theString, 9u);
  switch(ExactString)
  {
    case 468916449:
      v5 = (CFTypeRef *)((char *)this + 264);
      break;
    case 484678065:
      v5 = (CFTypeRef *)((char *)this + 272);
      break;
    case 483596708:
      v5 = (CFTypeRef *)((char *)this + 248);
      break;
    default:
      return HTTPServerBase::copyProperty((HTTPServer *)((char *)this + 8), theString);
  }
  result = *v5;
  if (*v5)
    return CFRetain(result);
  return result;
}

void HTTPServer::setProperty(HTTPServer *this, CFStringRef theString, const void *a3)
{
  int ExactString;
  const void *v7;
  CFTypeRef v8;
  const void *v9;
  CFTypeRef v10;
  const void *v11;
  const __CFAllocator *v12;
  CFDictionaryRef Copy;

  ExactString = _findExactString(theString, 9u);
  switch(ExactString)
  {
    case 484678065:
      v9 = (const void *)*((_QWORD *)this + 34);
      *((_QWORD *)this + 34) = 0;
      if (v9)
        CFRelease(v9);
      if (a3)
        v10 = CFRetain(a3);
      else
        v10 = 0;
      *((_QWORD *)this + 34) = v10;
      break;
    case 483596708:
      v11 = (const void *)*((_QWORD *)this + 31);
      *((_QWORD *)this + 31) = 0;
      if (v11)
        CFRelease(v11);
      if (a3)
      {
        v12 = CFGetAllocator(a3);
        Copy = CFDictionaryCreateCopy(v12, (CFDictionaryRef)a3);
      }
      else
      {
        Copy = 0;
      }
      *((_QWORD *)this + 31) = Copy;
      break;
    case 468916449:
      v7 = (const void *)*((_QWORD *)this + 33);
      *((_QWORD *)this + 33) = 0;
      if (v7)
        CFRelease(v7);
      if (a3)
        v8 = CFRetain(a3);
      else
        v8 = 0;
      *((_QWORD *)this + 33) = v8;
      break;
    default:
      HTTPServerBase::setProperty((HTTPServer *)((char *)this + 8), theString, a3);
      break;
  }
}

CFTypeRef HTTPServer::retainSelf(HTTPServer *this)
{
  return CFRetain((char *)this - 16);
}

void HTTPServer::releaseSelf(HTTPServer *this)
{
  CFRelease((char *)this - 16);
}

void HTTPServer::signalled_onQueue(HTTPServer *this)
{
  char *v2;
  CFContainerEnumeratorBase *v3;
  CFContainerEnumeratorBase *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  CFContainerEnumeratorBase *v10;
  CFContainerEnumeratorBase *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFIndex Count;
  unsigned int v17;
  CFArrayRef *v18;
  _QWORD v19[7];
  _QWORD v20[7];
  _QWORD aBlock[6];

  v2 = (char *)this + 152;
  v18 = (CFArrayRef *)((char *)this + 224);
  v3 = (CFContainerEnumeratorBase *)HTTPServer::State::enumeratorForAndDrain((uint64_t)this + 152, (CFTypeRef *)this + 28);
  if (v3)
  {
    v4 = v3;
    v5 = *((_QWORD *)v3 + 34);
    if (v5 < *((_QWORD *)v3 + 1))
    {
      v6 = MEMORY[0x1E0C809B0];
      do
      {
        *((_QWORD *)v4 + 34) = v5 + 1;
        v7 = *(_QWORD *)(*((_QWORD *)v4 + 2) + 8 * v5);
        if (v7)
        {
          if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
            dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
          v7 += 16;
        }
        if (*((_QWORD *)this + 17)
          && ((v8 = *((_DWORD *)this + 18), v8 < 2)
           || v8 == 2 && *((_QWORD *)this + 11) && *(_DWORD *)(*((_QWORD *)this + 12) + 40)))
        {
          pthread_mutex_lock((pthread_mutex_t *)((char *)this + 160));
          CFArrayAppendValue(*((CFMutableArrayRef *)this + 29), (const void *)(v7 - 16));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 160));
          (*(void (**)(uint64_t))(*(_QWORD *)(v7 + 8) + 72))(v7 + 8);
          v9 = *(_QWORD *)(v7 + 88);
          v20[0] = v6;
          v20[1] = 3221225472;
          v20[2] = ___ZN10HTTPServer17signalled_onQueueEv_block_invoke;
          v20[3] = &unk_1E14FC3C0;
          v20[5] = this;
          v20[6] = v7;
          v20[4] = v9;
          HTTPServerBase::withClientAsync((_QWORD *)this + 1, (uint64_t)v20);
        }
        else
        {
          aBlock[0] = v6;
          aBlock[1] = 3221225472;
          aBlock[2] = ___ZN20HTTPServerConnection7abandonEv_block_invoke;
          aBlock[3] = &__block_descriptor_40_e5_v8__0l;
          aBlock[4] = v7;
          HTTPServerBase::withWorkQueue((_QWORD *)(v7 + 8), aBlock);
        }
        v5 = *((_QWORD *)v4 + 34);
      }
      while (v5 < *((_QWORD *)v4 + 1));
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v4);
    MEMORY[0x186DB748C]();
  }
  v10 = (CFContainerEnumeratorBase *)HTTPServer::State::enumeratorForAndDrain((uint64_t)v2, (CFTypeRef *)this + 30);
  if (v10)
  {
    v11 = v10;
    v12 = *((_QWORD *)v10 + 34);
    if (v12 < *((_QWORD *)v10 + 1))
    {
      v13 = MEMORY[0x1E0C809B0];
      do
      {
        *((_QWORD *)v11 + 34) = v12 + 1;
        v14 = *(_QWORD *)(*((_QWORD *)v11 + 2) + 8 * v12);
        if (v14)
        {
          if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
            dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
          v14 += 16;
        }
        if (*((_QWORD *)this + 18))
        {
          (*(void (**)(uint64_t))(*(_QWORD *)(v14 + 8) + 72))(v14 + 8);
          v15 = *(_QWORD *)(v14 + 88);
          v19[0] = v13;
          v19[1] = 3221225472;
          v19[2] = ___ZN10HTTPServer17signalled_onQueueEv_block_invoke_3;
          v19[3] = &unk_1E14FC3C0;
          v19[5] = this;
          v19[6] = v14;
          v19[4] = v15;
          HTTPServerBase::withClientAsync((_QWORD *)this + 1, (uint64_t)v19);
        }
        v12 = *((_QWORD *)v11 + 34);
      }
      while (v12 < *((_QWORD *)v11 + 1));
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v11);
    MEMORY[0x186DB748C]();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 160));
  if (CFArrayGetCount(*((CFArrayRef *)this + 30)) || CFArrayGetCount(*v18))
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 160));
  }
  else
  {
    Count = CFArrayGetCount(*((CFArrayRef *)this + 29));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 160));
    if (!Count)
    {
      v17 = *((_DWORD *)this + 18);
      if (v17 >= 2 && (v17 != 2 || !*((_QWORD *)this + 11) || !*(_DWORD *)(*((_QWORD *)this + 12) + 40)))
        HTTPServerBase::deliverTerminalEvent_onQueue((HTTPServer *)((char *)this + 8));
    }
  }
}

uint64_t HTTPServer::setupTLSOnStreams(HTTPServer *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  uint64_t v6;
  const __CFDictionary *v7;
  const void *v8;
  __CFDictionary *MutableDict;
  const void *v10;
  CFTypeRef v11;
  __CFDictionary *v12;
  const void *v13;
  __CFDictionary *v14;
  __CFDictionary *v15;
  AutoDict *v16;
  const __CFDictionary *v17;
  unint64_t Count;
  const void **v19;
  unint64_t v20;
  const void **v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  const void *v25;
  __CFDictionary *v26;
  const void *EmptyDict;
  AutoDict *v28;
  const void *v29;
  const void *Value;
  const void *v31;
  CFTypeID v32;
  CFTypeID v33;
  void (**v35)(AutoScalar *__hidden);
  CFTypeRef propertyValue;
  const void **v37;
  _BYTE v38[248];
  CFTypeRef v39;
  uint64_t v40;
  const void **v41;
  _BYTE v42[256];
  _QWORD v43[2];
  const void *v44;
  const void *v45;

  v6 = (*(uint64_t (**)(HTTPServer *, uint64_t))(*(_QWORD *)this + 64))(this, 0x1EDCFF500);
  if (v6)
  {
    v7 = (const __CFDictionary *)v6;
    v8 = CFGetAllocator((char *)this - 16);
    v43[0] = &off_1E14EFC70;
    if (v8)
      v8 = CFRetain(v8);
    v44 = 0;
    v45 = 0;
    v43[1] = v8;
    MutableDict = AutoDict::getMutableDict((AutoDict *)v43);
    v10 = (const void *)*MEMORY[0x1E0C9AE50];
    if (*MEMORY[0x1E0C9AE50])
      CFDictionarySetValue(MutableDict, &unk_1EDCFC438, (const void *)*MEMORY[0x1E0C9AE50]);
    else
      CFDictionaryRemoveValue(MutableDict, &unk_1EDCFC438);
    v12 = AutoDict::getMutableDict((AutoDict *)v43);
    v13 = (const void *)*MEMORY[0x1E0C9AE40];
    if (*MEMORY[0x1E0C9AE40])
      CFDictionarySetValue(v12, &unk_1EDCFC588, (const void *)*MEMORY[0x1E0C9AE40]);
    else
      CFDictionaryRemoveValue(v12, &unk_1EDCFC588);
    v11 = HTTPServer::copyServerTrustChain(this);
    if (!v11)
    {
LABEL_44:
      Value = CFDictionaryGetValue(v7, CFSTR("kCFHTTPServerRequireClientCertificate"));
      v31 = Value;
      if (Value)
      {
        v32 = CFGetTypeID(Value);
        if (v32 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(v35) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v35, 2u);
        }
        if (v10 == v31)
        {
          AutoScalar::AutoScalar((AutoScalar *)&v35, (const __CFAllocator *)1);
          CFReadStreamSetProperty(a2, (CFStreamPropertyKey)&unk_1EDCFAB80, propertyValue);
          v35 = &off_1E14E47E8;
          if (propertyValue)
            CFRelease(propertyValue);
          AutoScalar::AutoScalar((AutoScalar *)&v35, (const __CFAllocator *)1);
          CFWriteStreamSetProperty(a3, (CFStreamPropertyKey)&unk_1EDCFAB80, propertyValue);
        }
        else
        {
          v33 = CFGetTypeID(v31);
          if (v33 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(v35) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v35, 2u);
          }
          if (v13 != v31)
            goto LABEL_61;
          AutoScalar::AutoScalar((AutoScalar *)&v35, (const __CFAllocator *)2);
          CFReadStreamSetProperty(a2, (CFStreamPropertyKey)&unk_1EDCFAB80, propertyValue);
          v35 = &off_1E14E47E8;
          if (propertyValue)
            CFRelease(propertyValue);
          AutoScalar::AutoScalar((AutoScalar *)&v35, (const __CFAllocator *)2);
          CFWriteStreamSetProperty(a3, (CFStreamPropertyKey)&unk_1EDCFAB80, propertyValue);
        }
        v35 = &off_1E14E47E8;
        if (propertyValue)
          CFRelease(propertyValue);
      }
LABEL_61:
      AutoDict::~AutoDict((AutoDict *)v43);
      CFRelease(v7);
      return (uint64_t)v11;
    }
    v14 = AutoDict::getMutableDict((AutoDict *)v43);
    if (v13)
      CFDictionarySetValue(v14, &unk_1EDCFC588, v13);
    else
      CFDictionaryRemoveValue(v14, &unk_1EDCFC588);
    v15 = AutoDict::getMutableDict((AutoDict *)v43);
    CFDictionarySetValue(v15, &unk_1EDCFC3C8, v11);
    CFRelease(v11);
    v16 = (AutoDict *)CFDictionaryGetValue(v7, CFSTR("kCFHTTPServerStreamSSLSettings"));
    v17 = v16;
    if (!v16)
    {
LABEL_35:
      EmptyDict = v45;
      if (!v45)
      {
        EmptyDict = v44;
        if (!v44)
          EmptyDict = (const void *)AutoDict::getEmptyDict(v16);
      }
      v28 = (AutoDict *)CFReadStreamSetProperty(a2, CFSTR("kCFStreamPropertySSLSettings"), EmptyDict);
      if ((_DWORD)v28)
      {
        v29 = v45;
        if (!v45)
        {
          v29 = v44;
          if (!v44)
            v29 = (const void *)AutoDict::getEmptyDict(v28);
        }
        v11 = (CFTypeRef)CFWriteStreamSetProperty(a3, CFSTR("kCFStreamPropertySSLSettings"), v29);
      }
      else
      {
        v11 = 0;
      }
      goto LABEL_44;
    }
    v35 = (void (**)(AutoScalar *__hidden))CFRetain(v16);
    Count = CFDictionaryGetCount(v17);
    propertyValue = (CFTypeRef)Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v37 = 0;
      goto LABEL_22;
    }
    if (Count > 0x1E)
    {
      v19 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
      v37 = v19;
      if (!v19)
        goto LABEL_22;
    }
    else
    {
      v19 = (const void **)v38;
      v37 = (const void **)v38;
    }
    CFDictionaryGetKeysAndValues(v17, v19, 0);
LABEL_22:
    v39 = CFRetain(v17);
    v20 = CFDictionaryGetCount(v17);
    v40 = v20;
    if (v20 - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v41 = 0;
    }
    else
    {
      if (v20 <= 0x1E)
      {
        v21 = (const void **)v42;
        v41 = (const void **)v42;
LABEL_27:
        CFDictionaryGetKeysAndValues(v17, 0, v21);
        goto LABEL_28;
      }
      v21 = (const void **)malloc_type_malloc(8 * v20, 0x89ED541CuLL);
      v41 = v21;
      if (v21)
        goto LABEL_27;
    }
LABEL_28:
    v22 = v40;
    if (v40 > 0)
    {
      v23 = 0;
      do
      {
        v24 = v37[v23];
        v25 = v41[v23];
        v26 = AutoDict::getMutableDict((AutoDict *)v43);
        if (v25)
          CFDictionarySetValue(v26, v24, v25);
        else
          CFDictionaryRemoveValue(v26, v24);
        ++v23;
      }
      while (v22 != v23);
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v39);
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v35);
    goto LABEL_35;
  }
  return 1;
}

void sub_1840BE4C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  uint64_t v10;

  if (cf)
    CFRelease(cf);
  AutoDict::~AutoDict((AutoDict *)(v10 - 120));
  _Unwind_Resume(a1);
}

uint64_t HTTPServer::invalidateClient(uint64_t this, void *a2)
{
  uint64_t (*v2)(void *);

  v2 = *(uint64_t (**)(void *))(this + 120);
  if (v2)
  {
    *(_QWORD *)(this + 120) = 0;
    if (a2)
      return v2(a2);
  }
  return this;
}

uint64_t HTTPServer::errorClient(uint64_t this, void *a2, __CFError *a3)
{
  uint64_t (*v3)(void *, __CFError *);

  v3 = *(uint64_t (**)(void *, __CFError *))(this + 128);
  if (v3)
  {
    *(_QWORD *)(this + 128) = 0;
    if (a2)
      return v3(a2, a3);
  }
  return this;
}

CFTypeRef `non-virtual thunk to'HTTPServer::copyProperty(HTTPServer *this, const __CFString *a2)
{
  return HTTPServer::copyProperty((HTTPServer *)((char *)this - 8), a2);
}

void `non-virtual thunk to'HTTPServer::setProperty(HTTPServer *this, const __CFString *a2, const void *a3)
{
  HTTPServer::setProperty((HTTPServer *)((char *)this - 8), a2, a3);
}

void `non-virtual thunk to'HTTPServer::signalled_onQueue(HTTPServer *this)
{
  HTTPServer::signalled_onQueue((HTTPServer *)((char *)this - 8));
}

uint64_t `non-virtual thunk to'HTTPServer::invalidateClient(uint64_t this, void *a2)
{
  uint64_t (*v2)(void *);

  v2 = *(uint64_t (**)(void *))(this + 112);
  if (v2)
  {
    *(_QWORD *)(this + 112) = 0;
    if (a2)
      return v2(a2);
  }
  return this;
}

uint64_t `non-virtual thunk to'HTTPServer::errorClient(uint64_t this, void *a2, __CFError *a3)
{
  uint64_t (*v3)(void *, __CFError *);

  v3 = *(uint64_t (**)(void *, __CFError *))(this + 120);
  if (v3)
  {
    *(_QWORD *)(this + 120) = 0;
    if (a2)
      return v3(a2, a3);
  }
  return this;
}

CFTypeRef `non-virtual thunk to'HTTPServer::retainSelf(HTTPServer *this)
{
  return CFRetain((char *)this - 24);
}

void `non-virtual thunk to'HTTPServer::releaseSelf(HTTPServer *this)
{
  CFRelease((char *)this - 24);
}

CFTypeRef HTTPServer::copyServerTrustChain(HTTPServer *this)
{
  CFTypeRef result;
  const __CFDictionary *v3;
  const void *Value;
  const void *v5;
  void *v6;
  const __CFAllocator *v7;
  __CFArray *Mutable;
  const __CFAllocator *v9;
  __CFArray *Array;
  SecPolicyRef BasicX509;
  const __CFArray *v12;
  const __CFArray *v13;
  CFIndex Count;
  SecTrustRef trust;
  SecCertificateRef certificateRef;
  CFRange v17;

  result = (CFTypeRef)*((_QWORD *)this + 32);
  if (result)
    return CFRetain(result);
  v3 = (const __CFDictionary *)*((_QWORD *)this + 31);
  if (v3)
  {
    Value = CFDictionaryGetValue(v3, CFSTR("kCFHTTPServerServerTrustChain"));
    if (Value)
    {
      result = CFRetain(Value);
      *((_QWORD *)this + 32) = result;
      if (result)
        return CFRetain(result);
    }
    else
    {
      *((_QWORD *)this + 32) = 0;
    }
    v5 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 31), CFSTR("kCFHTTPServerServerIdentity"));
    if (v5)
    {
      v6 = (void *)CFRetain(v5);
      if (v6)
        goto LABEL_9;
    }
    if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 31), CFSTR("kCFHTTPServerAllowAnonymousServer")) == (const void *)*MEMORY[0x1E0C9AE50])
    {
      if (HTTPServer::copyServerTrustChain(void)::sOnce != -1)
        dispatch_once(&HTTPServer::copyServerTrustChain(void)::sOnce, &__block_literal_global_5_13647);
      if (HTTPServer::copyServerTrustChain(void)::sOnceIdentity)
      {
        v6 = (void *)CFRetain((CFTypeRef)HTTPServer::copyServerTrustChain(void)::sOnceIdentity);
        if (v6)
        {
LABEL_9:
          v7 = CFGetAllocator((char *)this - 16);
          Mutable = CFArrayCreateMutable(v7, 0, MEMORY[0x1E0C9B378]);
          CFArrayAppendValue(Mutable, v6);
          certificateRef = 0;
          if (!SecIdentityCopyCertificate((SecIdentityRef)v6, &certificateRef))
          {
            trust = 0;
            v9 = CFGetAllocator((char *)this - 16);
            Array = cfTypeCreateArray(v9, certificateRef, 0);
            BasicX509 = SecPolicyCreateBasicX509();
            if (!SecTrustCreateWithCertificates(Array, BasicX509, &trust))
            {
              if (SecTrustEvaluateWithError(trust, 0))
              {
                v12 = SecTrustCopyCertificateChain(trust);
                if (v12)
                {
                  v13 = v12;
                  Count = CFArrayGetCount(v12);
                  if (Count >= 2)
                  {
                    v17.length = Count - 1;
                    v17.location = 1;
                    CFArrayAppendArray(Mutable, v13, v17);
                  }
                  CFRelease(v13);
                }
              }
              if (trust)
                CFRelease(trust);
            }
            if (BasicX509)
              CFRelease(BasicX509);
            if (Array)
              CFRelease(Array);
            if (certificateRef)
              CFRelease(certificateRef);
          }
          *((_QWORD *)this + 32) = Mutable;
          CFRelease(v6);
        }
      }
    }
  }
  result = (CFTypeRef)*((_QWORD *)this + 32);
  if (result)
    return CFRetain(result);
  return result;
}

void sub_1840BE80C(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN10HTTPServer20copyServerTrustChainEv_block_invoke()
{
  uint64_t result;

  result = _CFHTTPServerCreateSelfSignedIdentity((uint64_t)CFSTR("CFNetwork Self Signed Certificate"));
  HTTPServer::copyServerTrustChain(void)::sOnceIdentity = result;
  return result;
}

_QWORD *HTTPServer::State::enumeratorForAndDrain(uint64_t a1, CFTypeRef *a2)
{
  pthread_mutex_t *v3;
  const __CFArray *v4;
  const __CFAllocator *v5;
  CFArrayRef Copy;
  _QWORD *v7;
  unint64_t Count;
  CFRange v9;
  const void **v10;

  v3 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v4 = (const __CFArray *)*a2;
  if (*a2)
  {
    v5 = CFGetAllocator(*a2);
    Copy = CFArrayCreateCopy(v5, v4);
    CFArrayRemoveAllValues((CFMutableArrayRef)*a2);
    pthread_mutex_unlock(v3);
    if (Copy)
    {
      if (!CFArrayGetCount(Copy))
      {
        v7 = 0;
LABEL_15:
        CFRelease(Copy);
        return v7;
      }
      v7 = (_QWORD *)operator new();
      *v7 = CFRetain(Copy);
      Count = CFArrayGetCount(Copy);
      v9.length = Count;
      v7[1] = Count;
      if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v7[2] = 0;
      }
      else
      {
        if (Count <= 0x1E)
        {
          v10 = (const void **)(v7 + 3);
          v7[2] = v7 + 3;
LABEL_13:
          v9.location = 0;
          CFArrayGetValues(Copy, v9, v10);
          goto LABEL_14;
        }
        v10 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
        v7[2] = v10;
        if (v10)
        {
          v9.length = v7[1];
          goto LABEL_13;
        }
      }
LABEL_14:
      v7[34] = 0;
      goto LABEL_15;
    }
  }
  else
  {
    pthread_mutex_unlock(v3);
  }
  return 0;
}

void sub_1840BE96C(_Unwind_Exception *a1)
{
  CFContainerEnumeratorBase *v1;

  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v1);
  MEMORY[0x186DB748C]();
  _Unwind_Resume(a1);
}

void ___ZN10HTTPServer17signalled_onQueueEv_block_invoke(_QWORD *a1, uint64_t a2)
{
  void (*v3)(uint64_t, uint64_t);
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  void *v8;
  _QWORD aBlock[5];
  _QWORD block[6];

  if (a2)
  {
    v3 = *(void (**)(uint64_t, uint64_t))(a1[5] + 136);
    if (v3)
      v3(a2, a1[6] - 16);
  }
  v4 = a1[6];
  v5 = v4 + 8;
  v6 = MEMORY[0x1E0C809B0];
  v7 = a1[4];
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN10HTTPServer17signalled_onQueueEv_block_invoke_2;
  aBlock[3] = &__block_descriptor_40_e5_v8__0l;
  aBlock[4] = v4;
  v8 = _Block_copy(aBlock);
  block[0] = v6;
  block[1] = 3221225472;
  block[2] = ___ZN14HTTPServerBase22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v8;
  block[5] = v5;
  dispatch_async(v7, block);
}

void ___ZN10HTTPServer17signalled_onQueueEv_block_invoke_3(_QWORD *a1, uint64_t a2)
{
  void (*v3)(uint64_t, uint64_t);
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[6];

  if (a2)
  {
    v3 = *(void (**)(uint64_t, uint64_t))(a1[5] + 144);
    if (v3)
      v3(a2, a1[6] - 16);
  }
  v4 = a1[6] + 8;
  v5 = a1[4];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN14HTTPServerBase22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  v6[3] = &unk_1E14FDA90;
  v6[4] = 0;
  v6[5] = v4;
  dispatch_async(v5, v6);
}

uint64_t ___ZN10HTTPServer17signalled_onQueueEv_block_invoke_2(uint64_t a1)
{
  uint64_t result;
  unsigned int v2;

  result = *(_QWORD *)(a1 + 32);
  v2 = *(_DWORD *)(result + 72);
  if (v2 >= 2)
  {
    if (v2 == 2)
    {
      if (!*(_QWORD *)(result + 88))
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 104))(result);
      if (*(_DWORD *)(*(_QWORD *)(result + 96) + 40))
        return result;
    }
    else if (!*(_QWORD *)(result + 88))
    {
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 104))(result);
    }
    if (*(_DWORD *)(*(_QWORD *)(result + 96) + 40))
      return result;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 104))(result);
  }
  return result;
}

void ___ZN10HTTPServer5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "HTTPServer");
  HTTPServer::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_1840BEB80(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t HTTPServer::HTTPServer(uint64_t a1, const void *a2, NSObject *a3)
{
  *(_QWORD *)a1 = &off_1E14EFC90;
  HTTPServerBase::HTTPServerBase(a1 + 8, a2, a3);
  *(_QWORD *)a1 = &off_1E14E4A20;
  *(_QWORD *)(a1 + 8) = &unk_1E14E4AC8;
  *(_QWORD *)(a1 + 56) = &unk_1E14E4B30;
  *(_QWORD *)(a1 + 152) = &off_1E14E6990;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 160), 0);
  *(_QWORD *)(a1 + 152) = &off_1E14EFED0;
  *(_QWORD *)(a1 + 224) = CFArrayCreateMutable((CFAllocatorRef)a2, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(a1 + 232) = CFArrayCreateMutable((CFAllocatorRef)a2, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(a1 + 240) = CFArrayCreateMutable((CFAllocatorRef)a2, 0, MEMORY[0x1E0C9B378]);
  return a1;
}

void sub_1840BEC78(_Unwind_Exception *a1)
{
  HTTPServerBase *v1;
  uint64_t v2;
  pthread_mutex_t *v3;
  uint64_t v4;

  CFRelease(*(CFTypeRef *)(v2 + 232));
  CFRelease(*(CFTypeRef *)(v2 + 224));
  *(_QWORD *)(v2 + 152) = v4;
  pthread_mutex_destroy(v3);
  HTTPServerBase::~HTTPServerBase(v1);
  _Unwind_Resume(a1);
}

void HTTPServer::~HTTPServer(HTTPServer *this)
{
  HTTPServerBase *v2;
  const void *v3;
  const void *v4;

  *(_QWORD *)this = &off_1E14E4A20;
  *((_QWORD *)this + 1) = &unk_1E14E4AC8;
  v2 = (HTTPServer *)((char *)this + 8);
  *((_QWORD *)this + 7) = &unk_1E14E4B30;
  v3 = (const void *)*((_QWORD *)this + 31);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 32);
  if (v4)
    CFRelease(v4);
  HTTPServer::State::~State((HTTPServer *)((char *)this + 152));
  HTTPServerBase::~HTTPServerBase(v2);
}

void sub_1840BED30(_Unwind_Exception *a1)
{
  uint64_t v1;
  HTTPServerBase *v2;

  HTTPServer::State::~State((HTTPServer::State *)(v1 + 152));
  HTTPServerBase::~HTTPServerBase(v2);
  _Unwind_Resume(a1);
}

void HTTPServer::initialize(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  HTTPServerClientOwning::setServerClient(a1 + 8, a2, 0);
  v5 = *a3;
  if (*a3 == 1)
  {
    v6 = *(_OWORD *)a3;
    v7 = *((_OWORD *)a3 + 1);
    *(_QWORD *)(a1 + 144) = a3[4];
    *(_OWORD *)(a1 + 112) = v6;
    *(_OWORD *)(a1 + 128) = v7;
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    v8 = 134217984;
    v9 = v5;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Unknown delegate version %ld", (uint8_t *)&v8, 0xCu);
  }
}

uint64_t HTTPServer::newConnectionWithStreams(NSObject **this, __CFReadStream *a2, __CFWriteStream *a3)
{
  NSObject **v6;
  uint64_t result;
  _OWORD *Instance;
  _QWORD *v9;
  CFAllocatorRef v10;
  __CFReadStream *v11;
  CFTypeRef v12;
  unsigned int v13;
  CFStreamClientContext clientContext;

  v6 = this - 2;
  CFGetAllocator(this - 2);
  result = ((uint64_t (*)(NSObject **, __CFReadStream *, __CFWriteStream *))(*this)[16].isa)(this, a2, a3);
  if ((_DWORD)result)
  {
    if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
      dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
    Instance = (_OWORD *)_CFRuntimeCreateInstance();
    v9 = Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      v9 = Instance + 1;
      Instance[18] = 0u;
      Instance[19] = 0u;
      Instance[16] = 0u;
      Instance[17] = 0u;
      Instance[14] = 0u;
      Instance[15] = 0u;
      Instance[12] = 0u;
      Instance[13] = 0u;
      Instance[10] = 0u;
      Instance[11] = 0u;
      Instance[8] = 0u;
      Instance[9] = 0u;
      Instance[6] = 0u;
      Instance[7] = 0u;
      Instance[4] = 0u;
      Instance[5] = 0u;
      Instance[2] = 0u;
      Instance[3] = 0u;
    }
    *v9 = &off_1E14EFC90;
    v10 = CFGetAllocator(v6);
    HTTPServerBase::HTTPServerBase((uint64_t)(v9 + 1), v10, this[11]);
    *v9 = &off_1E14EB4D8;
    v9[1] = &unk_1E14EB568;
    v9[7] = &unk_1E14EB5D0;
    v9[35] = 0;
    v9[36] = 0;
    v9[20] = this;
    CFRetain(v6);
    if (a2)
      v11 = (__CFReadStream *)CFRetain(a2);
    else
      v11 = 0;
    v9[22] = v11;
    if (a3)
    {
      v12 = CFRetain(a3);
      v11 = (__CFReadStream *)v9[22];
    }
    else
    {
      v12 = 0;
    }
    v9[23] = v12;
    clientContext.version = 0;
    clientContext.info = v9;
    clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
    clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
    CFReadStreamSetClient(v11, 0x1BuLL, (CFReadStreamClientCallBack)_readStreamCallback, &clientContext);
    CFWriteStreamSetClient((CFWriteStreamRef)v9[23], 0x1DuLL, (CFWriteStreamClientCallBack)_writeStreamCallback, &clientContext);
    v13 = *((_DWORD *)this + 18);
    if (v13 < 2 || v13 == 2 && this[11] && LODWORD(this[12][5].isa))
    {
      pthread_mutex_lock((pthread_mutex_t *)(this + 20));
      CFArrayAppendValue((CFMutableArrayRef)this[28], v9 - 2);
      pthread_mutex_unlock((pthread_mutex_t *)(this + 20));
      HTTPServerBase::signal(this + 1);
    }
    else
    {
      clientContext.version = MEMORY[0x1E0C809B0];
      clientContext.info = (void *)3221225472;
      clientContext.retain = (void *(__cdecl *)(void *))___ZN20HTTPServerConnection7abandonEv_block_invoke;
      clientContext.release = (void (__cdecl *)(void *))&__block_descriptor_40_e5_v8__0l;
      clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))v9;
      HTTPServerBase::withWorkQueue(v9 + 1, &clientContext);
    }
    CFRelease(v9 - 2);
    return 1;
  }
  return result;
}

void sub_1840BF07C(_Unwind_Exception *a1)
{
  HTTPServerBase *v1;

  HTTPServerBase::~HTTPServerBase(v1);
  _Unwind_Resume(a1);
}

void HTTPServer::newConnection(NSObject **this, int a2)
{
  const __CFAllocator *v4;
  CFTypeRef *v5;
  CFTypeRef *v6;
  __CFReadStream *v7;
  CFWriteStreamRef v8;
  CFReadStreamRef stream;

  v8 = 0;
  stream = 0;
  v4 = CFGetAllocator(this - 2);
  _CFStreamCreatePairWithNativeSocket(v4, a2, &stream, &v8);
  v5 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
  v6 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
  if (stream)
  {
    CFReadStreamSetProperty(stream, CFSTR("kCFStreamPropertyAutoErrorOnSystemChange"), (CFTypeRef)*MEMORY[0x1E0C9AE40]);
    CFReadStreamSetProperty(stream, CFSTR("kCFStreamPropertyShouldCloseNativeSocket"), *v6);
  }
  if (v8)
  {
    CFWriteStreamSetProperty(v8, CFSTR("kCFStreamPropertyAutoErrorOnSystemChange"), *v5);
    CFWriteStreamSetProperty(v8, CFSTR("kCFStreamPropertyShouldCloseNativeSocket"), *v6);
    v7 = stream;
    if (!stream || !v8)
      goto LABEL_8;
    if (HTTPServer::newConnectionWithStreams(this, stream, v8))
      goto LABEL_12;
  }
  v7 = stream;
LABEL_8:
  if (v7)
    CFReadStreamClose(v7);
  if (v8)
    CFWriteStreamClose(v8);
LABEL_12:
  if (stream)
    CFRelease(stream);
  if (v8)
    CFRelease(v8);
}

void RequestBodyData::~RequestBodyData(RequestBodyData *this)
{
  *(_QWORD *)this = &off_1E14E7BE8;
  *((_QWORD *)this + 3) = &unk_1E14E7C58;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 112);
  RequestBody::~RequestBody((RequestBody *)this);
}

{
  *(_QWORD *)this = &off_1E14E7BE8;
  *((_QWORD *)this + 3) = &unk_1E14E7C58;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 112);
  RequestBody::~RequestBody((RequestBody *)this);
  JUMPOUT(0x186DB748CLL);
}

void RequestBodyData::bodyStartProvidingData(RequestBodyData *a1, void *aBlock)
{
  if (*((_QWORD *)a1 + 10))
    __assert_rtn("bodyStartProvidingData", "HTTPRequestBody.cpp", 201, "!_cb");
  *((_QWORD *)a1 + 10) = _Block_copy(aBlock);
  RequestBodyData::_provideRequestBodyFromData(a1);
}

void RequestBodyData::bodyStopProvidingData(RequestBodyData *this)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD block[5];
  _QWORD v4[6];

  v1 = *((_QWORD *)this + 10);
  if (!v1)
    __assert_rtn("bodyStopProvidingData", "HTTPRequestBody.cpp", 214, "_cb");
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x3052000000;
  v4[3] = __Block_byref_object_copy__13669;
  v4[4] = __Block_byref_object_dispose__13670;
  v4[5] = v1;
  *((_QWORD *)this + 10) = 0;
  v2 = *((_QWORD *)this + 6);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN15RequestBodyData21bodyStopProvidingDataEv_block_invoke;
  block[3] = &unk_1E14FD3D8;
  block[4] = v4;
  dispatch_async(v2, block);
  _Block_object_dispose(v4, 8);
}

uint64_t RequestBodyData::copyProperty(RequestBodyData *this, const __CFString *a2)
{
  return 0;
}

void RequestBodyData::updateScheduling(RequestBody *this, const CoreSchedulingSet *a2, char a3)
{
  RequestBody::updateScheduling(this, a2);
  if ((a3 & 1) == 0)
  {
    if ((*(unsigned int (**)(RequestBody *))(*(_QWORD *)this + 48))(this))
      RequestBodyData::_provideRequestBodyFromData((RequestBodyData *)this);
  }
}

CFIndex RequestBodyData::getExpectedLength(CFDataRef *this)
{
  return CFDataGetLength(this[14]);
}

uint64_t RequestBodyData::errorEncountered(RequestBodyData *this)
{
  return 0;
}

uint64_t RequestBodyData::canProvideData(RequestBodyData *this)
{
  return 1;
}

dispatch_data_t RequestBodyData::provideData(CFDataRef *this, unint64_t a2, BOOL *a3)
{
  unint64_t v6;
  const __CFData *v7;
  CFDataRef v8;
  unint64_t *v9;
  unint64_t v10;
  const UInt8 *BytePtr;
  char *v12;
  NSObject *v13;
  dispatch_data_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  _QWORD destructor[5];
  _QWORD v20[7];
  std::__shared_weak_count *v21;

  v6 = CFDataGetLength(this[14]) - (_QWORD)this[12];
  *a3 = v6 <= a2;
  v20[0] = 0;
  v20[1] = v20;
  v20[2] = 0x4012000000;
  v20[3] = __Block_byref_object_copy__6;
  v20[4] = __Block_byref_object_dispose__7;
  v7 = this[14];
  v8 = this[15];
  v20[5] = &unk_18422E08D;
  v20[6] = v7;
  v21 = (std::__shared_weak_count *)v8;
  if (v8)
  {
    v9 = (unint64_t *)((char *)v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    v7 = this[14];
  }
  BytePtr = CFDataGetBytePtr(v7);
  if (v6 >= a2)
    v6 = a2;
  v12 = (char *)this[12] + (_QWORD)BytePtr;
  v13 = this[6];
  destructor[0] = MEMORY[0x1E0C809B0];
  destructor[1] = 3221225472;
  destructor[2] = ___ZN15RequestBodyData11provideDataEmRb_block_invoke;
  destructor[3] = &unk_1E14FD3D8;
  destructor[4] = v20;
  v14 = dispatch_data_create(v12, v6, v13, destructor);
  RequestBody::_onqueue_updateUploadStatus((RequestBody *)this, v6, *a3);
  _Block_object_dispose(v20, 8);
  v15 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  return v14;
}

void sub_1840BF520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'RequestBodyData::~RequestBodyData(RequestBodyData *this)
{
  RequestBody *v1;

  *((_QWORD *)this - 3) = &off_1E14E7BE8;
  v1 = (RequestBody *)((char *)this - 24);
  *(_QWORD *)this = &unk_1E14E7C58;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 88);
  RequestBody::~RequestBody(v1);
}

{
  RequestBodyData::~RequestBodyData((RequestBodyData *)((char *)this - 24));
}

__n128 __Block_byref_object_copy__6(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__7(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN15RequestBodyData11provideDataEmRb_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *v2;
  unint64_t v3;
  __int128 v4;

  v4 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, &v4);
  v1 = (std::__shared_weak_count *)*((_QWORD *)&v4 + 1);
  if (*((_QWORD *)&v4 + 1))
  {
    v2 = (unint64_t *)(*((_QWORD *)&v4 + 1) + 8);
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 - 1, v2));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void RequestBodyData::_provideRequestBodyFromData(RequestBodyData *this)
{
  const __CFData *v2;
  CFIndex Length;
  unint64_t v4;
  unint64_t v5;
  size_t v6;
  _BOOL4 v8;
  uint64_t v9;
  const __CFData *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  const UInt8 *v14;
  NSObject *v15;
  NSObject *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  NSObject *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  _QWORD block[5];
  std::__shared_weak_count *v36;
  _QWORD destructor[5];
  uint64_t v38;
  std::__shared_weak_count *v39;
  uint64_t v40;
  __n128 (*v41)(__n128 *, __n128 *);
  uint64_t (*v42)(uint64_t);
  void *v43;
  const __CFData *v44;
  std::__shared_weak_count *v45;

  if (*((_QWORD *)this + 10)
    && (*(unsigned int (**)(RequestBodyData *))(*(_QWORD *)this + 48))(this)
    && !*((_BYTE *)this + 104))
  {
    v2 = (const __CFData *)*((_QWORD *)this + 14);
    if (!v2)
      __assert_rtn("_provideRequestBodyFromData", "HTTPRequestBody.cpp", 269, "_data");
    if ((*((_QWORD *)this + 12) & 0x8000000000000000) != 0)
      __assert_rtn("_provideRequestBodyFromData", "HTTPRequestBody.cpp", 270, "_totalBytesSent >= 0");
    Length = CFDataGetLength(v2);
    v4 = *((_QWORD *)this + 11);
    v5 = Length - *((_QWORD *)this + 12);
    if (v4 >= v5)
      v6 = Length - *((_QWORD *)this + 12);
    else
      v6 = *((_QWORD *)this + 11);
    v8 = v5 <= v4 || v6 == 0;
    v9 = MEMORY[0x1E0C809B0];
    if (v6)
    {
      v38 = 0;
      v39 = (std::__shared_weak_count *)&v38;
      v40 = 0x4012000000;
      v41 = __Block_byref_object_copy__6;
      v42 = __Block_byref_object_dispose__7;
      v10 = (const __CFData *)*((_QWORD *)this + 14);
      v11 = (std::__shared_weak_count *)*((_QWORD *)this + 15);
      v43 = &unk_18422E08D;
      v44 = v10;
      v45 = v11;
      if (v11)
      {
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
        v10 = (const __CFData *)*((_QWORD *)this + 14);
      }
      v14 = &CFDataGetBytePtr(v10)[*((_QWORD *)this + 12)];
      v15 = *((_QWORD *)this + 6);
      destructor[0] = v9;
      destructor[1] = 3221225472;
      destructor[2] = ___ZN15RequestBodyData27_provideRequestBodyFromDataEv_block_invoke;
      destructor[3] = &unk_1E14FD3D8;
      destructor[4] = &v38;
      v16 = dispatch_data_create(v14, v6, v15, destructor);
      _Block_object_dispose(&v38, 8);
      v17 = v45;
      if (v45)
      {
        v18 = (unint64_t *)&v45->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
    }
    else
    {
      v16 = 0;
    }
    (*(void (**)(void))(*((_QWORD *)this + 10) + 16))();
    RequestBody::_onqueue_updateUploadStatus((RequestBody *)this, v6, v8);
    if (v16)
      dispatch_release(v16);
    if (v8)
    {
      *((_BYTE *)this + 104) = 1;
    }
    else
    {
      std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v38, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
      v21 = v38;
      v20 = v39;
      if (v39)
      {
        v22 = (unint64_t *)&v39->__shared_owners_;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
        v24 = v39;
        if (v39)
        {
          v25 = (unint64_t *)&v39->__shared_owners_;
          do
            v26 = __ldaxr(v25);
          while (__stlxr(v26 - 1, v25));
          if (!v26)
          {
            ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
            std::__shared_weak_count::__release_weak(v24);
          }
        }
      }
      v27 = *((_QWORD *)this + 6);
      block[0] = v9;
      block[1] = 3321888768;
      block[2] = ___ZN15RequestBodyData27_provideRequestBodyFromDataEv_block_invoke_2;
      block[3] = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15RequestBodyDataEE_e5_v8__0l;
      block[4] = v21;
      v36 = v20;
      if (v20)
      {
        v28 = (unint64_t *)&v20->__shared_owners_;
        do
          v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }
      dispatch_async(v27, block);
      v30 = v36;
      if (v36)
      {
        v31 = (unint64_t *)&v36->__shared_owners_;
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
      if (v20)
      {
        v33 = (unint64_t *)&v20->__shared_owners_;
        do
          v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
    }
  }
}

void sub_1840BF938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v13);
  _Unwind_Resume(a1);
}

void ___ZN15RequestBodyData27_provideRequestBodyFromDataEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *v2;
  unint64_t v3;
  __int128 v4;

  v4 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, &v4);
  v1 = (std::__shared_weak_count *)*((_QWORD *)&v4 + 1);
  if (*((_QWORD *)&v4 + 1))
  {
    v2 = (unint64_t *)(*((_QWORD *)&v4 + 1) + 8);
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 - 1, v2));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t ___ZN15RequestBodyData27_provideRequestBodyFromDataEv_block_invoke_2(uint64_t a1)
{
  return RequestBodyData::_provideRequestBodyFromData(*(RequestBodyData **)(a1 + 32));
}

uint64_t __copy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrI15RequestBodyDataEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrI15RequestBodyDataEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void __Block_byref_object_copy__13669(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 135);
}

void __Block_byref_object_dispose__13670(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 135);
}

void ___ZN15RequestBodyData21bodyStopProvidingDataEv_block_invoke(uint64_t a1)
{
  _Block_release(*(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = 0;
}

void `non-virtual thunk to'RequestBodyStream::~RequestBodyStream(RequestBodyStream *this)
{
  RequestBodyStream::~RequestBodyStream((RequestBodyStream *)((char *)this - 24));
}

{
  RequestBodyStream::~RequestBodyStream((RequestBodyStream *)((char *)this - 24));
  JUMPOUT(0x186DB748CLL);
}

CFTypeRef HTTPServerBase::copyProperty(HTTPServerBase *this, const __CFString *a2)
{
  const __CFDictionary *v2;
  const void *Value;

  v2 = (const __CFDictionary *)*((_QWORD *)this + 9);
  if (v2 && (Value = CFDictionaryGetValue(v2, a2)) != 0)
    return CFRetain(Value);
  else
    return 0;
}

void HTTPServerBase::setProperty(HTTPServerBase *this, const __CFString *key, const void *value)
{
  __CFDictionary *Mutable;

  Mutable = (__CFDictionary *)*((_QWORD *)this + 9);
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 7), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *((_QWORD *)this + 9) = Mutable;
  }
  CFDictionarySetValue(Mutable, key, value);
}

uint64_t HTTPServerBase::HTTPServerBase(uint64_t a1, CFTypeRef cf, NSObject *a3)
{
  CFTypeRef v5;
  CoreSchedulingSet *v6;

  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)a1 = off_1E14E6FE0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = &unk_1E14E7048;
  if (cf)
    v5 = CFRetain(cf);
  else
    v5 = 0;
  *(_QWORD *)(a1 + 56) = v5;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 80) = a3;
  dispatch_retain(a3);
  *(_QWORD *)(a1 + 88) = CoreSchedulingSet::createEmpty(v6);
  *(_DWORD *)(a1 + 64) = 1;
  return a1;
}

void sub_1840BFC1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 48) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void HTTPServerBase::~HTTPServerBase(HTTPServerBase *this)
{
  const void *v2;
  NSObject *v3;
  uint64_t v4;
  const void *v5;

  *(_QWORD *)this = off_1E14E6FE0;
  *((_QWORD *)this + 6) = &unk_1E14E7048;
  HTTPServerClientOwning::setServerClient((uint64_t)this, 0, *((_DWORD **)this + 11));
  v2 = (const void *)*((_QWORD *)this + 9);
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 10);
  if (v3)
  {
    dispatch_release(v3);
    *((_QWORD *)this + 10) = 0;
  }
  v4 = *((_QWORD *)this + 11);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
  v5 = (const void *)*((_QWORD *)this + 12);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 6) = &off_1E14E5838;
}

void sub_1840BFCB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 48) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void HTTPServerBase::schedule(uint64_t a1, CoreSchedulingSet *a2)
{
  CFAllocatedReferenceCountedObject *v4;
  int v5;
  BOOL v6;
  void *v7;
  CFAllocatedReferenceCountedObject *Empty;
  CoreSchedulingSet *v9;
  NSObject *v10;
  _QWORD block[5];
  uint8_t buf[16];

  if (*(int *)(a1 + 64) <= 2)
  {
    v4 = *(CFAllocatedReferenceCountedObject **)(a1 + 88);
    v5 = *((_DWORD *)v4 + 10);
    if ((v5 - 1) < 2)
    {
      if (a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "can't be both queue and runloop based", buf, 2u);
      }
      goto LABEL_17;
    }
    if (v5 == 3)
    {
      if (!a2)
      {
        v9 = (CoreSchedulingSet *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v4 + 48))(*(_QWORD *)(a1 + 88));
        Empty = (CFAllocatedReferenceCountedObject *)CoreSchedulingSet::createEmpty(v9);
        goto LABEL_16;
      }
      if (*((CoreSchedulingSet **)v4 + 7) == a2)
      {
LABEL_17:
        *(_QWORD *)(a1 + 88) = v4;
        *(_DWORD *)(a1 + 64) = 2;
        (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
        v10 = *(NSObject **)(a1 + 80);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___ZN14HTTPServerBase8scheduleEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = a1;
        dispatch_async(v10, block);
        return;
      }
    }
    else
    {
      if (v5)
        v6 = 1;
      else
        v6 = a2 == 0;
      if (v6)
        goto LABEL_17;
    }
    (*(void (**)(_QWORD))(*(_QWORD *)v4 + 48))(*(_QWORD *)(a1 + 88));
    Empty = CoreSchedulingSet::createWithDispatchQueue(a2, v7);
LABEL_16:
    v4 = Empty;
    goto LABEL_17;
  }
}

uint64_t ___ZN14HTTPServerBase8scheduleEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 80))(v1);
}

void HTTPServerBase::schedule(HTTPServerBase *this, __CFRunLoop *a2, const __CFString *a3)
{
  NSObject *v4;
  _QWORD block[5];

  if (*((int *)this + 16) <= 2)
  {
    *((_QWORD *)this + 11) = (*(uint64_t (**)(_QWORD, __CFRunLoop *, const __CFString *))(**((_QWORD **)this + 11)
                                                                                                  + 56))(*((_QWORD *)this + 11), a2, a3);
    *((_DWORD *)this + 16) = 2;
    (*(void (**)(HTTPServerBase *))(*(_QWORD *)this + 72))(this);
    v4 = *((_QWORD *)this + 10);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZN14HTTPServerBase8scheduleEP11__CFRunLoopPK10__CFString_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_async(v4, block);
  }
}

uint64_t ___ZN14HTTPServerBase8scheduleEP11__CFRunLoopPK10__CFString_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 80))(v1);
}

void HTTPServerBase::signal(NSObject **this)
{
  NSObject *v2;
  _QWORD block[5];

  if (this[10])
  {
    if (*((int *)this + 16) <= 4)
    {
      ((void (*)(NSObject **))(*this)[9].isa)(this);
      v2 = this[10];
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZN14HTTPServerBase6signalEv_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = this;
      dispatch_async(v2, block);
    }
  }
}

uint64_t ___ZN14HTTPServerBase6signalEv_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 80))(v1);
}

uint64_t HTTPServerBase::withClientAsync(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  _QWORD v7[6];

  v3 = a1[11];
  if (!v3 || !*(_DWORD *)(v3 + 40))
    return (*(uint64_t (**)(uint64_t, _QWORD))(a2 + 16))(a2, 0);
  (*(void (**)(_QWORD *))(*a1 + 72))(a1);
  v5 = a1[11];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke;
  v7[3] = &unk_1E14FDA90;
  v7[4] = a2;
  v7[5] = a1;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v5 + 96))(v5, v7);
}

void ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  NSObject *v3;
  _QWORD v4[5];
  _QWORD v5[5];

  v1 = MEMORY[0x1E0C809B0];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke_2;
  v5[3] = &unk_1E14FC338;
  v2 = *(_QWORD **)(a1 + 40);
  v5[4] = *(_QWORD *)(a1 + 32);
  HTTPServerClientOwning::withServerClient(v2, (uint64_t)v5);
  v3 = v2[10];
  v4[0] = v1;
  v4[1] = 3221225472;
  v4[2] = ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke_3;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = v2;
  dispatch_async(v3, v4);
}

uint64_t ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 80))(*(_QWORD *)(a1 + 32));
}

void HTTPServerBase::becomeErrored_onQueue(HTTPServerBase *this, CFTypeRef cf)
{
  CFTypeRef v3;

  if (*((int *)this + 16) <= 3)
  {
    *((_DWORD *)this + 16) = 4;
    if (cf)
      v3 = CFRetain(cf);
    else
      v3 = 0;
    *((_QWORD *)this + 12) = v3;
  }
  HTTPServerBase::signal((NSObject **)this);
}

void HTTPServerBase::deliverTerminalEvent_onQueue(HTTPServerBase *this)
{
  int v1;
  uint64_t v3;
  NSObject *v4;
  _QWORD block[5];
  _QWORD v6[5];
  int v7;

  v1 = *((_DWORD *)this + 16);
  if (v1 <= 4)
  {
    *((_DWORD *)this + 16) = 5;
    v3 = MEMORY[0x1E0C809B0];
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN14HTTPServerBase28deliverTerminalEvent_onQueueEv_block_invoke;
    v6[3] = &__block_descriptor_44_e9_v16__0_v8l;
    v6[4] = this;
    v7 = v1;
    HTTPServerBase::withClientAsync(this, (uint64_t)v6);
    (*(void (**)(HTTPServerBase *))(*(_QWORD *)this + 72))(this);
    v4 = *((_QWORD *)this + 10);
    block[0] = v3;
    block[1] = 3221225472;
    block[2] = ___ZN14HTTPServerBase28deliverTerminalEvent_onQueueEv_block_invoke_2;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_async(v4, block);
  }
}

uint64_t ___ZN14HTTPServerBase28deliverTerminalEvent_onQueueEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 80))(v1);
}

CFStringRef HTTPServerBase::copyBaseDescription(HTTPServerBase *this)
{
  uint64_t v1;
  const char *v2;

  v1 = *((_QWORD *)this + 10);
  v2 = "no";
  if (v1 && *(_DWORD *)(*((_QWORD *)this + 11) + 40))
    v2 = "yes";
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("valid=%s, ss=%@"), v2, v1);
}

void HTTPServerBase::withWorkQueue(_QWORD *a1, void *aBlock)
{
  void *v3;
  NSObject *v4;
  _QWORD v5[6];

  v3 = _Block_copy(aBlock);
  (*(void (**)(_QWORD *))(*a1 + 72))(a1);
  v4 = a1[10];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN14HTTPServerBase13withWorkQueueEU13block_pointerFvvE_block_invoke;
  v5[3] = &unk_1E14FDA90;
  v5[4] = v3;
  v5[5] = a1;
  dispatch_async(v4, v5);
}

uint64_t ___ZN14HTTPServerBase13withWorkQueueEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  _Block_release(*(const void **)(a1 + 32));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 80))(v2);
}

uint64_t ___ZN14HTTPServerBase22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v4 = a1 + 32;
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v4 + 8);
  if (v2)
  {
    (*(void (**)(void))(v2 + 16))();
    _Block_release(*(const void **)(a1 + 32));
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 80))(v3);
}

void HTTPServerConnection::RRQueue::~RRQueue(HTTPServerConnection::RRQueue *this)
{
  uint64_t v2;

  HTTPServerConnection::RRQueue::~RRQueue(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E14F0078;
  v2 = *((_QWORD *)this + 2);
  if (v2)
    CFRelease((CFTypeRef)(v2 - 16));
  v3 = *((_QWORD *)this + 3);
  if (v3)
    CFRelease((CFTypeRef)(v3 - 16));
}

void HTTPServerConnection::PendingQueue::~PendingQueue(HTTPServerConnection::PendingQueue *this)
{
  *(_QWORD *)this = off_1E14F0018;
  *((_QWORD *)this + 4) = 0;
  HTTPServerConnection::RRQueue::~RRQueue(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E14F0018;
  *((_QWORD *)this + 4) = 0;
  HTTPServerConnection::RRQueue::~RRQueue(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

void HTTPServerConnection::ActiveResponseInfo::~ActiveResponseInfo(HTTPServerConnection::ActiveResponseInfo *this)
{
  uint64_t v2;

  HTTPServerConnection::ActiveResponseInfo::~ActiveResponseInfo(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  __CFReadStream *v2;
  HTTPServerRequest *v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = off_1E14F0058;
  v2 = (__CFReadStream *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 4) = 0;
    if (*((_BYTE *)this + 40))
    {
      CFReadStreamSetClient(v2, 0, 0, 0);
      CFReadStreamClose(v2);
      *((_BYTE *)this + 40) = 0;
    }
    CFRelease(v2);
  }
  v3 = (HTTPServerRequest *)*((_QWORD *)this + 2);
  if (v3)
  {
    HTTPServerRequest::loseConnectionReferenceAndTerminateReads(v3);
    v4 = *((_QWORD *)this + 2);
    if (v4)
    {
      CFRelease((CFTypeRef)(v4 - 16));
      *((_QWORD *)this + 2) = 0;
    }
  }
  v5 = *((_QWORD *)this + 3);
  if (v5)
  {
    CFRelease((CFTypeRef)(v5 - 16));
    *((_QWORD *)this + 3) = 0;
  }
  HTTPServerConnection::RRQueue::~RRQueue(this);
}

void sub_1840C058C(_Unwind_Exception *a1)
{
  HTTPServerConnection::RRQueue *v1;

  HTTPServerConnection::RRQueue::~RRQueue(v1);
  _Unwind_Resume(a1);
}

CFStringRef HTTPServerConnection::copyDebugDesc(HTTPServerConnection *this)
{
  CFStringRef v2;
  CFStringRef v3;
  const __CFAllocator *v4;
  CFStringRef v5;
  CFStringRef v6;
  uint64_t v7;
  CFStringRef v8;
  const __CFAllocator *v9;
  CFStringRef v10;

  v2 = CFObject::copyDebugDescHeader(this);
  v3 = HTTPServerBase::copyBaseDescription((HTTPServerConnection *)((char *)this + 8));
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@"), *((_QWORD *)this + 22));
  v6 = CFStringCreateWithFormat(v4, 0, CFSTR("%@"), *((_QWORD *)this + 23));
  v7 = *((_QWORD *)this + 31);
  if (v7)
    v7 = *(_QWORD *)(v7 + 32);
  v8 = CFStringCreateWithFormat(v4, 0, CFSTR("%@"), v7);
  v9 = CFGetAllocator((char *)this - 16);
  v10 = CFStringCreateWithFormat(v9, 0, CFSTR("%@ { socket rs=%@, socket ws=%@, response rs=%@, %@ }"), v2, v5, v6, v8, v3);
  if (v8)
    CFRelease(v8);
  if (v6)
    CFRelease(v6);
  if (v5)
    CFRelease(v5);
  if (v3)
    CFRelease(v3);
  if (v2)
    CFRelease(v2);
  return v10;
}

CFNumberRef HTTPServerConnection::copyProperty(HTTPServerConnection *this, CFStringRef theString)
{
  int ExactString;
  __CFReadStream *v5;
  const __CFString *v6;
  const __CFAllocator *v7;
  __CFReadStream *v9;
  void *v10;
  const __CFData *v11;
  const __CFData *v12;
  const __CFAllocator *v13;
  uint64_t v14;
  uint64_t v15;
  __CFReadStream *v16;
  __CFWriteStream *v17;
  socklen_t length;
  int length_4;
  sockaddr v20;
  uint64_t v21;
  CFRange v22;

  v21 = *MEMORY[0x1E0C80C00];
  ExactString = _findExactString(theString, 9u);
  if (ExactString <= 465795250)
  {
    if (ExactString == 463755406)
    {
      v5 = (__CFReadStream *)*((_QWORD *)this + 22);
      if (v5)
      {
        v6 = CFSTR("kCFStreamPropertySSLPeerTrust");
        return (CFNumberRef)CFReadStreamCopyProperty(v5, v6);
      }
      return 0;
    }
    if (ExactString == 464820384)
    {
      v7 = CFGetAllocator((char *)this - 16);
      return CFNumberCreate(v7, kCFNumberCFIndexType, (char *)this + 272);
    }
    goto LABEL_21;
  }
  if (ExactString != 465795251)
  {
    if (ExactString != 467908818)
    {
      if (ExactString == 466884801)
      {
        v5 = (__CFReadStream *)*((_QWORD *)this + 22);
        if (v5)
        {
          v6 = CFSTR("kCFStreamPropertySSLPeerCertificates");
          return (CFNumberRef)CFReadStreamCopyProperty(v5, v6);
        }
        return 0;
      }
LABEL_21:
      v10 = (void *)HTTPServerBase::copyProperty((HTTPServerConnection *)((char *)this + 8), theString);
      if (v10)
        return (CFNumberRef)v10;
      v15 = *((_QWORD *)this + 20);
      if (v15)
      {
        v10 = (void *)(*(uint64_t (**)(uint64_t, CFStringRef))(*(_QWORD *)v15 + 64))(v15, theString);
        if (v10)
          return (CFNumberRef)v10;
      }
      v16 = (__CFReadStream *)*((_QWORD *)this + 22);
      if (v16)
      {
        v10 = (void *)CFReadStreamCopyProperty(v16, theString);
        if (v10)
          return (CFNumberRef)v10;
      }
      v17 = (__CFWriteStream *)*((_QWORD *)this + 23);
      if (v17)
        return (CFNumberRef)CFWriteStreamCopyProperty(v17, theString);
      return 0;
    }
    v14 = *((_QWORD *)this + 20);
    if (v14)
      return (CFNumberRef)CFRetain((CFTypeRef)(v14 - 16));
    return 0;
  }
  v9 = (__CFReadStream *)*((_QWORD *)this + 22);
  if (!v9)
    return 0;
  v10 = (void *)CFReadStreamCopyProperty(v9, (CFStreamPropertyKey)&unk_1EDCFA9C0);
  if (!v10)
  {
    v11 = (const __CFData *)CFReadStreamCopyProperty(*((CFReadStreamRef *)this + 22), CFSTR("kCFStreamPropertySocketNativeHandle"));
    if (v11)
    {
      v12 = v11;
      if (CFDataGetLength(v11) == 4)
      {
        length_4 = 0;
        v22.location = 0;
        v22.length = 4;
        CFDataGetBytes(v12, v22, (UInt8 *)&length_4);
        length = 255;
        v10 = 0;
        if (!getpeername(length_4, &v20, &length))
        {
          v13 = CFGetAllocator((char *)this - 16);
          v10 = CFDataCreate(v13, &v20.sa_len, length);
        }
      }
      else
      {
        v10 = 0;
      }
      CFRelease(v12);
      return (CFNumberRef)v10;
    }
    return 0;
  }
  return (CFNumberRef)v10;
}

void HTTPServerConnection::setProperty(HTTPServerConnection *this, CFStringRef theString, const void *a3)
{
  int ExactString;
  int v7;
  CFStringRef v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  ExactString = _findExactString(theString, 9u);
  if (ExactString > 465795250)
  {
    if (ExactString != 467908818 && ExactString != 465795251)
    {
LABEL_10:
      HTTPServerBase::setProperty((HTTPServerConnection *)((char *)this + 8), theString, a3);
      return;
    }
  }
  else if (ExactString != 463755406)
  {
    if (ExactString == 464820384)
    {
      CFNumberGetValue((CFNumberRef)a3, kCFNumberCFIndexType, (char *)this + 272);
      return;
    }
    goto LABEL_10;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    v7 = 138412290;
    v8 = theString;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Sorry, %@ isn't implemented yet", (uint8_t *)&v7, 0xCu);
  }
}

uint64_t HTTPServerConnection::invalidateClient(uint64_t this, void *a2)
{
  uint64_t (*v2)(void *);

  v2 = *(uint64_t (**)(void *))(this + 120);
  if (v2)
  {
    *(_QWORD *)(this + 120) = 0;
    return v2(a2);
  }
  return this;
}

uint64_t HTTPServerConnection::errorClient(uint64_t this, void *a2, __CFError *a3)
{
  uint64_t (*v3)(void *, __CFError *);

  v3 = *(uint64_t (**)(void *, __CFError *))(this + 128);
  if (v3)
  {
    *(_QWORD *)(this + 128) = 0;
    return v3(a2, a3);
  }
  return this;
}

uint64_t HTTPServerConnection::scheduled_onQueue(uint64_t this)
{
  uint64_t v1;
  const __CFNumber *v2;
  const __CFNumber *v3;
  const void *v4;
  const __CFAllocator *v5;
  CFAbsoluteTime Current;
  void *v7;
  CFAllocatedReferenceCountedObject *v8;
  void (*v9)(_QWORD, _QWORD, _QWORD);
  uint64_t v10;
  CFRunLoopTimerContext v11;
  void (*v12[5])(_QWORD, _QWORD, _QWORD);

  if (*(int *)(this + 72) <= 2)
  {
    v1 = this;
    if (!*(_QWORD *)(this + 176)
      || *(_QWORD *)(this + 280)
      || (*(_QWORD *)(this + 280) = *(_QWORD *)(this + 88),
          MEMORY[0x186DB62D4](),
          this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 96))(v1),
          *(int *)(v1 + 72) <= 2))
    {
      this = *(_QWORD *)(v1 + 184);
      if (!this
        || *(_QWORD *)(v1 + 288)
        || (*(_QWORD *)(v1 + 288) = *(_QWORD *)(v1 + 88),
            MEMORY[0x186DB6A90](),
            this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 96))(v1),
            *(int *)(v1 + 72) <= 2))
      {
        if (!*(_QWORD *)(v1 + 296))
        {
          *(_QWORD *)(v1 + 208) = 0;
          v2 = (const __CFNumber *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 160) + 64))(*(_QWORD *)(v1 + 160), 0x1EDCFF1F0);
          if (v2)
          {
            v3 = v2;
            CFNumberGetValue(v2, kCFNumberCFIndexType, (void *)(v1 + 208));
            CFRelease(v3);
          }
          *(_QWORD *)(v1 + 216) = 0;
          this = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 160) + 64))(*(_QWORD *)(v1 + 160), 0x1EDCFF538);
          if (this)
          {
            v4 = (const void *)this;
            CFNumberGetValue((CFNumberRef)this, kCFNumberCFIndexType, (void *)(v1 + 216));
            CFRelease(v4);
          }
          if (*(uint64_t *)(v1 + 208) > 0 || *(uint64_t *)(v1 + 216) >= 1)
          {
            v11.version = 0;
            v11.info = (void *)v1;
            memset(&v11.retain, 0, 24);
            (*(void (**)(uint64_t))(*(_QWORD *)v1 + 112))(v1);
            v5 = CFGetAllocator((CFTypeRef)(v1 - 16));
            Current = CFAbsoluteTimeGetCurrent();
            *(_QWORD *)(v1 + 296) = CFRunLoopTimerCreate(v5, Current + 1.0e30, 1.0e30, 0, 0, (CFRunLoopTimerCallBack)_timerCallback, &v11);
            v8 = CoreSchedulingSet::createWithDispatchQueue(*(CoreSchedulingSet **)(v1 + 88), v7);
            v9 = *(void (**)(_QWORD, _QWORD, _QWORD))(v1 + 296);
            v12[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
            v12[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
            v12[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
            v12[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
            v12[4] = v9;
            CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)v8, v12);
            (*(void (**)(CFAllocatedReferenceCountedObject *))(*(_QWORD *)v8 + 48))(v8);
            HTTPServerConnection::touchTimerIdle((HTTPServerConnection *)v1);
          }
        }
        v10 = CoreSchedulingSet::copyRunloopEmulationSet((CoreSchedulingSet *)this);
        (*(void (**)(uint64_t, void *))(*(_QWORD *)v10 + 96))(v10, &__block_literal_global_8_13731);
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 48))(v10);
      }
    }
  }
  return this;
}

void HTTPServerConnection::signalled_onQueue(HTTPServerConnection *this)
{
  uint64_t v1;
  __CFReadStream *v2;
  CFErrorRef v3;
  __CFWriteStream *v4;
  CFErrorRef v5;
  uint64_t v6;
  __CFReadStream *v7;
  CFErrorRef v8;
  CFErrorRef v9;
  CFErrorRef v10;
  __CFReadStream *v11;
  uint64_t v12;
  HTTPServerRequest *v13;
  __CFReadStream *v14;
  CFIndex v15;
  CFIndex v16;
  UInt8 *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  HTTPServerRequest *v21;
  uint64_t v22;
  HTTPServerRequest *v23;
  unsigned int v24;
  _OWORD *Instance;
  uint64_t v26;
  int v27;
  const unsigned __int8 *v28;
  const unsigned __int8 *v29;
  const unsigned __int8 *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int64_t v34;
  int64_t v35;
  uint64_t v36;
  int64_t v37;
  int v38;
  const unsigned __int8 *v39;
  UInt8 *v40;
  uint64_t v41;
  NSObject *v42;
  const char *v43;
  uint64_t v44;
  int v45;
  const unsigned __int8 *v46;
  int v47;
  __darwin_ct_rune_t v48;
  int v49;
  int v50;
  int v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  int v55;
  int v56;
  uint64_t v57;
  unsigned int v58;
  uint64_t v59;
  CFDictionaryRef *v60;
  const __CFAllocator *v61;
  const __CFString *v62;
  uint64_t IntValue;
  CFDictionaryRef *v64;
  const __CFAllocator *v65;
  const __CFAllocator *v66;
  char *v67;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  const __CFAllocator *v76;
  _QWORD *v77;
  _QWORD *v78;
  _QWORD *v79;
  _QWORD *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  __CFReadStream *v85;
  __CFWriteStream *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  CFErrorRef v90;
  uint64_t v91;
  HTTPServerRequest *v92;
  CFErrorRef v93;
  __CFError *v94;
  unsigned int v95;
  uint64_t v96;
  __CFWriteStream *v97;
  uint64_t v98;
  __CFReadStream *v99;
  __CFWriteStream *v100;
  unsigned int v101;
  _BOOL4 v102;
  CFErrorRef v103;
  __CFError *v104;
  unsigned int v105;
  uint64_t v106;
  __CFReadStream *v107;
  CFIndex v108;
  __CFReadStream *v109;
  CFStreamStatus Status;
  CFErrorRef v111;
  void *cf;
  uint8_t v113[8];
  uint64_t v114;
  void (*v115)(uint64_t, uint64_t);
  void *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint8_t buf[8];
  CFTypeRef v121;
  UInt8 buffer[8];
  uint64_t v123;
  UInt8 *v124;
  const unsigned __int8 *v125;
  uint64_t v126;

  v1 = MEMORY[0x1E0C80A78](this);
  v126 = *MEMORY[0x1E0C80C00];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));
  v2 = *(__CFReadStream **)(v1 + 176);
  if (v2)
  {
    v3 = CFReadStreamCopyError(v2);
    if (v3)
      HTTPServerConnection::closeReadSocketSide_onQueue((dispatch_queue_t *)v1);
  }
  else
  {
    v3 = 0;
  }
  v4 = *(__CFWriteStream **)(v1 + 184);
  if (v4)
  {
    v5 = CFWriteStreamCopyError(v4);
    if (v5)
      HTTPServerConnection::closeWriteSocketSide_onQueue((dispatch_queue_t *)v1);
  }
  else
  {
    v5 = 0;
  }
  v6 = *(_QWORD *)(v1 + 248);
  if (v6 && (v7 = *(__CFReadStream **)(v6 + 32)) != 0)
    v8 = CFReadStreamCopyError(v7);
  else
    v8 = 0;
  if (v5)
    v9 = v5;
  else
    v9 = v8;
  if (v3)
    v10 = v3;
  else
    v10 = v9;
  if (v10)
    HTTPServerBase::becomeErrored_onQueue((HTTPServerBase *)(v1 + 8), v10);
  if (v3)
    CFRelease(v3);
  if (v5)
    CFRelease(v5);
  if (v8)
    CFRelease(v8);
  if (!*(_QWORD *)(v1 + 176))
  {
    v86 = *(__CFWriteStream **)(v1 + 184);
    if (v86)
    {
      if (CFWriteStreamCanAcceptBytes(v86))
      {
        v87 = *(_QWORD *)(v1 + 248);
        if (!v87 || (v88 = *(_QWORD *)(v87 + 24)) == 0 || *(_BYTE *)(v88 + 136))
        {
          v89 = *(_QWORD *)(v1 + 240);
          if (!v89 || !*(_QWORD *)(v89 + 24))
            HTTPServerConnection::closeWriteSocketSide_onQueue((dispatch_queue_t *)v1);
        }
      }
    }
  }
  if (*(_QWORD *)(v1 + 136))
  {
    v11 = *(__CFReadStream **)(v1 + 176);
    if (v11)
    {
      if (CFReadStreamGetStatus(v11) == kCFStreamStatusAtEnd)
      {
        v12 = *(_QWORD *)(v1 + 248);
        if (v12)
        {
          v13 = *(HTTPServerRequest **)(v12 + 16);
          if (v13)
            HTTPServerRequest::producerEOFEncountered(v13);
        }
        HTTPServerConnection::closeReadSocketSide_onQueue((dispatch_queue_t *)v1);
      }
      v14 = *(__CFReadStream **)(v1 + 176);
      if (v14)
      {
        if (CFReadStreamHasBytesAvailable(v14))
        {
          v124 = buffer;
          v125 = (const unsigned __int8 *)&v124;
          v15 = CFReadStreamRead(*(CFReadStreamRef *)(v1 + 176), buffer, 36000);
          v16 = v15;
          if (v15 < 0)
          {
            v90 = CFReadStreamCopyError(*(CFReadStreamRef *)(v1 + 176));
            HTTPServerBase::becomeErrored_onQueue((HTTPServerBase *)(v1 + 8), v90);
            if (v90)
              CFRelease(v90);
          }
          else
          {
            if (v15)
            {
              HTTPServerConnection::touchTimerWatchdog((HTTPServerConnection *)v1);
              v17 = v124;
              if (&v124[v16] > v125 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)v113 = 0;
                _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Can't seal more than we own!", v113, 2u);
                v17 = v124;
              }
              v125 = &v17[v16];
              dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));
              if (v125 - v124 >= 1)
              {
                v18 = (uint64_t *)(v1 + 240);
                cf = (void *)(v1 - 16);
                while (1)
                {
                  v19 = *(_QWORD *)(v1 + 232);
                  if (!v19)
                  {
                    v20 = *(_QWORD *)(v1 + 248);
                    if (v20
                      && (v21 = *(HTTPServerRequest **)(v20 + 16)) != 0
                      && (int)HTTPServerRequest::requestState(v21) <= 2)
                    {
                      v22 = *(_QWORD *)(v1 + 248);
                    }
                    else
                    {
                      v22 = *v18;
                      if (!*v18)
                        goto LABEL_55;
                      while (1)
                      {
                        v23 = *(HTTPServerRequest **)(v22 + 16);
                        if (v23)
                        {
                          if ((int)HTTPServerRequest::requestState(v23) < 3)
                            break;
                        }
                        v22 = *(_QWORD *)(v22 + 32);
                        if (!v22)
                          goto LABEL_55;
                      }
                    }
                    v19 = *(_QWORD *)(v22 + 16);
                    if (!v19)
                    {
LABEL_55:
                      v24 = *(_DWORD *)(v1 + 72);
                      if (v24 >= 2 && (v24 != 2 || !*(_QWORD *)(v1 + 88) || !*(_DWORD *)(*(_QWORD *)(v1 + 96) + 40)))
                      {
                        HTTPServerConnection::closeReadSocketSide_onQueue((dispatch_queue_t *)v1);
                        break;
                      }
                      CFGetAllocator(cf);
                      if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
                        dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_57);
                      Instance = (_OWORD *)_CFRuntimeCreateInstance();
                      v19 = (uint64_t)Instance;
                      if (Instance)
                      {
                        Instance[1] = 0u;
                        v19 = (uint64_t)(Instance + 1);
                        Instance[14] = 0u;
                        Instance[15] = 0u;
                        Instance[12] = 0u;
                        Instance[13] = 0u;
                        Instance[10] = 0u;
                        Instance[11] = 0u;
                        Instance[8] = 0u;
                        Instance[9] = 0u;
                        Instance[6] = 0u;
                        Instance[7] = 0u;
                        Instance[4] = 0u;
                        Instance[5] = 0u;
                        Instance[2] = 0u;
                        Instance[3] = 0u;
                      }
                      HTTPServerRequest::HTTPServerRequest(v19, (NSObject **)cf);
                      *(_QWORD *)(v1 + 232) = v19;
                    }
                  }
                  switch(HTTPServerRequest::requestState((HTTPServerRequest *)v19))
                  {
                    case 0u:
                      v26 = HTTPParser::parse(*(HTTPParser **)(v19 + 144), v124, v125 - v124);
                      v27 = *(_DWORD *)(*(_QWORD *)(v19 + 144) + 36);
                      if (v27 == 3 || v26 < 0)
                      {
                        HTTPServerRequest::setRequestState(v19, 4);
                        goto LABEL_159;
                      }
                      v28 = v125;
                      v29 = &v124[v26];
                      v124 = (UInt8 *)v29;
                      if (v29 > v125 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Buffer overrun", buf, 2u);
                        v29 = v124;
                        v28 = v125;
                        v27 = *(_DWORD *)(*(_QWORD *)(v19 + 144) + 36);
                      }
                      if (v28 == v29)
                      {
                        if (v27 < 2)
                          goto LABEL_159;
                      }
                      else if (v27 <= 1 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "we have bytes pending, but the parse is not done?", buf, 2u);
                      }
                      v60 = *(CFDictionaryRef **)(v19 + 208);
                      v61 = CFGetAllocator((CFTypeRef)(v19 - 16));
                      HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(buf, 0x11D1D2CFu);
                      v62 = HTTPHeaderDict::copyStringValue(v60, v61, (const HTTPHeaderKeyMixedValue *)buf);
                      *(_QWORD *)buf = &off_1E14E9A00;
                      if (v121)
                        CFRelease(v121);
                      if (v62)
                      {
                        IntValue = CFStringGetIntValue(v62);
                      }
                      else
                      {
                        v64 = *(CFDictionaryRef **)(v19 + 208);
                        v65 = CFGetAllocator((CFTypeRef)(v19 - 16));
                        HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(buf, 0x146233E1u);
                        v62 = HTTPHeaderDict::copyStringValue(v64, v65, (const HTTPHeaderKeyMixedValue *)buf);
                        *(_QWORD *)buf = &off_1E14E9A00;
                        if (v121)
                          CFRelease(v121);
                        if (!v62)
                        {
                          *(_QWORD *)(v19 + 168) = 0;
                          goto LABEL_158;
                        }
                        if (CFStringFind(v62, CFSTR("chunked"), 1uLL).location == -1)
                          IntValue = 0;
                        else
                          IntValue = -1;
                      }
                      CFRelease(v62);
                      *(_QWORD *)(v19 + 168) = IntValue;
                      if (IntValue == -1)
                      {
                        HTTPServerRequest::setRequestState(v19, 2);
                        *(_DWORD *)(v19 + 184) = 0;
                        *(_QWORD *)(v19 + 192) = 0;
                        *(_BYTE *)(v19 + 200) = 0;
                        goto LABEL_156;
                      }
                      if (IntValue)
                      {
                        HTTPServerRequest::setRequestState(v19, 1);
LABEL_156:
                        v66 = CFGetAllocator((CFTypeRef)(v19 - 16));
                        v67 = (char *)CFAllocatorAllocate(v66, 144, 0);
                        *((_OWORD *)v67 + 1) = 0u;
                        *((_OWORD *)v67 + 7) = 0u;
                        *((_OWORD *)v67 + 8) = 0u;
                        *((_OWORD *)v67 + 5) = 0u;
                        *((_OWORD *)v67 + 6) = 0u;
                        *((_OWORD *)v67 + 3) = 0u;
                        *((_OWORD *)v67 + 4) = 0u;
                        *((_OWORD *)v67 + 2) = 0u;
                        *(_QWORD *)v67 = off_1E14E8428;
                        *((_QWORD *)v67 + 1) = v66;
                        _CoreLockable::_CoreLockable((_CoreLockable *)(v67 + 16), 1);
                        *((_QWORD *)v67 + 2) = &off_1E14E57F8;
                        pthread_cond_init((pthread_cond_t *)(v67 + 88), 0);
                        *(_QWORD *)v67 = off_1E14E8258;
                        *((_QWORD *)v67 + 2) = &unk_1E14E8278;
                        v68 = CFAllocatorAllocate(v66, 48, 0);
                        *v68 = off_1E14E6898;
                        v68[1] = v66;
                        v68[2] = v66;
                        v68[3] = 0;
                        v68[4] = 0;
                        v68[5] = 0;
                        *((_QWORD *)v67 + 17) = v68;
                        *(_QWORD *)(v19 + 152) = v67;
                        goto LABEL_159;
                      }
LABEL_158:
                      HTTPServerRequest::setRequestState(v19, 3);
LABEL_159:
                      v69 = *(_QWORD *)(v19 + 152);
                      if (v69)
                        pthread_mutex_lock((pthread_mutex_t *)(v69 + 24));
                      if (*(_QWORD *)(v19 + 176) == *(_QWORD *)(v19 + 168) && *(int *)(v19 + 160) <= 2)
                      {
                        *(_DWORD *)(v19 + 160) = 3;
                        v70 = *(_QWORD *)(v19 + 152);
                        if (!v70)
                        {
                          *(_DWORD *)(v19 + 164) = 3;
                          goto LABEL_167;
                        }
                        pthread_cond_signal((pthread_cond_t *)(v70 + 88));
                      }
                      v71 = *(_QWORD *)(v19 + 152);
                      *(_DWORD *)(v19 + 164) = *(_DWORD *)(v19 + 160);
                      if (v71)
                        pthread_mutex_unlock((pthread_mutex_t *)(v71 + 24));
LABEL_167:
                      HTTPServerRequest::signalReadStreamBasedOnState((HTTPServerRequest *)v19);
                      if ((int)HTTPServerRequest::requestState((HTTPServerRequest *)v19) >= 4)
                      {
                        v93 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("kCFHTTPServerErrorDomain"), 1100, 0);
                        v94 = (__CFError *)CFAutorelease(v93);
                        HTTPServerConnection::connectionError((dispatch_queue_t *)v1, v94);
                        if (v19 == *(_QWORD *)(v1 + 232))
                          HTTPServerConnection::closeStreamsAndCleanupRequests_onQueue((dispatch_queue_t *)v1);
                        goto LABEL_218;
                      }
                      if (v19 == *(_QWORD *)(v1 + 232)
                        && (int)HTTPServerRequest::requestState((HTTPServerRequest *)v19) >= 1)
                      {
                        *(_QWORD *)(v1 + 232) = 0;
                        v76 = CFGetAllocator(cf);
                        v77 = CFAllocatorAllocate(v76, 40, 0);
                        v77[4] = 0;
                        *(_OWORD *)v77 = 0u;
                        *((_OWORD *)v77 + 1) = 0u;
                        v78 = HTTPServerConnection::PendingQueue::PendingQueue(v77, v19);
                        v79 = (_QWORD *)(v1 + 240);
                        do
                        {
                          v80 = v79;
                          v81 = *v79;
                          v79 = (_QWORD *)(*v79 + 32);
                        }
                        while (v81);
                        *v80 = v78;
                        if (*(_QWORD *)(v1 + 136))
                        {
                          CFRetain((CFTypeRef)(v19 - 16));
                          v82 = *(_QWORD *)(v19 + 232);
                          *(_QWORD *)v113 = MEMORY[0x1E0C809B0];
                          v114 = 3221225472;
                          v115 = ___ZN20HTTPServerConnection31processAllIncomingBytes_onQueueEP21ConsumableStackBuffer_block_invoke;
                          v116 = &unk_1E14FC3C0;
                          v118 = v1;
                          v119 = v19;
                          v117 = v82;
                          HTTPServerBase::withClientAsync((_QWORD *)(v1 + 8), (uint64_t)v113);
                        }
                        if ((int)HTTPServerRequest::requestState((HTTPServerRequest *)v19) >= 3 && *v80 == *v18)
                          HTTPServerConnection::suspendTimeout((HTTPServerConnection *)v1);
                        CFRelease((CFTypeRef)(v19 - 16));
                        goto LABEL_192;
                      }
                      if (*v18)
                      {
                        v72 = HTTPServerRequest::requestState((HTTPServerRequest *)v19);
                        v73 = *(_QWORD *)(v1 + 248);
                        if (v72 >= 3)
                        {
                          if (v73)
                            goto LABEL_187;
                          v74 = *v18;
                          do
                          {
                            v75 = v74;
                            v74 = *(_QWORD *)(v74 + 32);
                          }
                          while (v74);
                          if (v19 == *(_QWORD *)(v75 + 16))
                            HTTPServerConnection::suspendTimeout((HTTPServerConnection *)v1);
                          goto LABEL_192;
                        }
                      }
                      else
                      {
                        v73 = *(_QWORD *)(v1 + 248);
                      }
                      if (v73)
                      {
LABEL_187:
                        if (v19 == *(_QWORD *)(v73 + 16)
                          && (int)HTTPServerRequest::requestState((HTTPServerRequest *)v19) >= 3)
                        {
                          v83 = *(_QWORD *)(v1 + 248);
                          v84 = *(_QWORD *)(v83 + 24);
                          if (v84)
                          {
                            if (*(_BYTE *)(v84 + 136)
                              || (v85 = *(__CFReadStream **)(v83 + 32)) != 0
                              && CFReadStreamGetStatus(v85) == kCFStreamStatusAtEnd)
                            {
                              HTTPServerConnection::responseCompleted((HTTPServerConnection *)v1);
                            }
                          }
                        }
                      }
LABEL_192:
                      if (v125 - v124 <= 0)
                        goto LABEL_218;
                      break;
                    case 1u:
                      v30 = v124;
                      v32 = *(_QWORD *)(v19 + 168);
                      v31 = *(_QWORD *)(v19 + 176);
                      v33 = v125 - v124 + v31;
                      v34 = v32 - v31;
                      if (v33 <= v32)
                        v35 = v125 - v124;
                      else
                        v35 = v34;
                      v36 = *(_QWORD *)(v19 + 152);
                      if (v36)
                      {
                        pthread_mutex_lock((pthread_mutex_t *)(v36 + 24));
                        v30 = v124;
                      }
                      HTTPServerRequest::appendToBodyDataLocked((HTTPServerRequest *)v19, v30, v35);
                      v37 = *(_QWORD *)(v19 + 176) + v35;
                      *(_QWORD *)(v19 + 176) = v37;
                      v124 += v35;
                      if (v124 > v125 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Buffer overrun", buf, 2u);
                        v37 = *(_QWORD *)(v19 + 176);
                      }
                      if (v37 == *(_QWORD *)(v19 + 168))
                      {
                        v38 = 3;
                        *(_DWORD *)(v19 + 160) = 3;
                      }
                      else
                      {
                        v38 = *(_DWORD *)(v19 + 160);
                      }
                      *(_DWORD *)(v19 + 164) = v38;
                      v44 = *(_QWORD *)(v19 + 152);
                      if (v44)
                        pthread_mutex_unlock((pthread_mutex_t *)(v44 + 24));
                      goto LABEL_159;
                    case 2u:
                      v40 = v124;
                      v39 = v125;
                      v41 = *(_QWORD *)(v19 + 152);
                      if (v41
                        || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
                        && (*(_WORD *)buf = 0,
                            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Must have a body data", buf, 2u), (v41 = *(_QWORD *)(v19 + 152)) != 0))
                      {
                        pthread_mutex_lock((pthread_mutex_t *)(v41 + 24));
                      }
                      if (v39 - v40 < 1)
                      {
                        v46 = v40;
                      }
                      else
                      {
                        v45 = 0;
                        v46 = v40;
                        while (*(_DWORD *)(v19 + 160) == 2)
                        {
                          v47 = *(_DWORD *)(v19 + 184);
                          switch(v47)
                          {
                            case 0:
                              v48 = *v46++;
                              v49 = __tolower(v48);
                              if (v49 == 10)
                                goto LABEL_115;
                              if (v49 != 13)
                              {
                                v57 = 16 * *(_QWORD *)(v19 + 192);
                                *(_QWORD *)(v19 + 192) = v57;
                                v58 = v49 - 48;
                                if ((v49 - 48) >= 0xA)
                                {
                                  if ((v49 - 97) > 5)
                                  {
                                    if ((v49 - 65) > 5)
                                      goto LABEL_115;
                                    v58 = v49 - 55;
                                  }
                                  else
                                  {
                                    v58 = v49 - 87;
                                  }
                                }
                                *(_QWORD *)(v19 + 192) = v57 + v58;
                                goto LABEL_122;
                              }
                              *(_DWORD *)(v19 + 184) = 1;
                              goto LABEL_132;
                            case 1:
                              v50 = *v46++;
                              if (v50 != 10)
                                goto LABEL_115;
                              v51 = 2;
                              goto LABEL_110;
                            case 2:
                              v52 = *(_QWORD *)(v19 + 192);
                              if (!v52)
                              {
                                *(_BYTE *)(v19 + 200) = 1;
LABEL_114:
                                *(_DWORD *)(v19 + 184) = 3;
                                goto LABEL_132;
                              }
                              if (v52 >= v39 - v46)
                                v53 = v39 - v46;
                              else
                                v53 = *(_QWORD *)(v19 + 192);
                              HTTPServerRequest::appendToBodyDataLocked((HTTPServerRequest *)v19, v46, v53);
                              v46 += v53;
                              v45 = 1;
                              v54 = *(_QWORD *)(v19 + 192) - v53;
                              *(_QWORD *)(v19 + 192) = v54;
                              if (!v54)
                                goto LABEL_114;
LABEL_122:
                              v47 = *(_DWORD *)(v19 + 184);
LABEL_123:
                              if (v47 == 5)
                              {
LABEL_127:
                                if (!*(_BYTE *)(v19 + 200))
                                {
                                  *(_DWORD *)(v19 + 184) = 0;
                                  *(_QWORD *)(v19 + 192) = 0;
                                  *(_BYTE *)(v19 + 200) = 0;
                                  goto LABEL_132;
                                }
                                *(_DWORD *)(v19 + 160) = 3;
                                if (v45)
                                  goto LABEL_129;
                              }
                              else
                              {
                                if (v47 != 6)
                                  goto LABEL_132;
LABEL_125:
                                *(_DWORD *)(v19 + 160) = 5;
                                if (v45)
                                {
LABEL_129:
                                  v45 = 1;
                                  goto LABEL_132;
                                }
                              }
                              pthread_cond_signal((pthread_cond_t *)(*(_QWORD *)(v19 + 152) + 88));
                              v45 = 0;
LABEL_132:
                              if (v46 >= v39)
                                goto LABEL_135;
                              break;
                            case 3:
                              v55 = *v46++;
                              if (v55 != 13)
                                goto LABEL_115;
                              v51 = 4;
LABEL_110:
                              *(_DWORD *)(v19 + 184) = v51;
                              goto LABEL_132;
                            case 4:
                              v56 = *v46++;
                              if (v56 == 10)
                              {
                                *(_DWORD *)(v19 + 184) = 5;
                                goto LABEL_127;
                              }
LABEL_115:
                              *(_DWORD *)(v19 + 184) = 6;
                              goto LABEL_125;
                            default:
                              goto LABEL_123;
                          }
                        }
                      }
LABEL_135:
                      *(_DWORD *)(v19 + 164) = *(_DWORD *)(v19 + 160);
                      v59 = *(_QWORD *)(v19 + 152);
                      if (v59)
                        pthread_mutex_unlock((pthread_mutex_t *)(v59 + 24));
                      v124 += v46 - v40;
                      if (v124 > v125 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        v42 = MEMORY[0x1E0C81028];
                        v43 = "Buffer overrun";
LABEL_140:
                        _os_log_fault_impl(&dword_183ECA000, v42, OS_LOG_TYPE_FAULT, v43, buf, 2u);
                      }
                      goto LABEL_159;
                    case 3u:
                      goto LABEL_159;
                    default:
                      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                        goto LABEL_159;
                      *(_WORD *)buf = 0;
                      v42 = MEMORY[0x1E0C81028];
                      v43 = "Shouldn't get here like this";
                      goto LABEL_140;
                  }
                }
              }
LABEL_218:
              if (*(_QWORD *)(v1 + 176))
              {
                if ((v95 = *(_DWORD *)(v1 + 72), v95 < 2)
                  || v95 == 2 && *(_QWORD *)(v1 + 88) && *(_DWORD *)(*(_QWORD *)(v1 + 96) + 40)
                  || v125 == v124
                  || (HTTPServerConnection::closeReadSocketSide_onQueue((dispatch_queue_t *)v1), *(_QWORD *)(v1 + 176)))
                {
                  if (!*(_BYTE *)(v1 + 168))
                  {
                    HTTPServerConnection::snapshotConnection(v1, v113);
                    if (*(uint64_t *)v113 >= 13 || (v96 = *(_QWORD *)(v1 + 272)) != 0 && v114 >= v96)
                    {
                      *(_BYTE *)(v1 + 168) = 1;
                      if (*(_QWORD *)(v1 + 280))
                        MEMORY[0x186DB62D4](*(_QWORD *)(v1 + 176), 0);
                    }
                  }
                }
              }
              goto LABEL_231;
            }
            v91 = *(_QWORD *)(v1 + 248);
            if (v91)
            {
              v92 = *(HTTPServerRequest **)(v91 + 16);
              if (v92)
                HTTPServerRequest::producerEOFEncountered(v92);
            }
          }
          HTTPServerConnection::closeReadSocketSide_onQueue((dispatch_queue_t *)v1);
        }
      }
    }
LABEL_231:
    v97 = *(__CFWriteStream **)(v1 + 184);
    if (v97 && CFWriteStreamCanAcceptBytes(v97))
    {
      v98 = *(_QWORD *)(v1 + 264);
      if (v98)
      {
        *(_QWORD *)(v1 + 264) = 0;
        HTTPServerConnection::performWritesAndBufferLeftovers((CFWriteStreamRef *)v1, *(const unsigned __int8 **)(v98 + 32), *(_QWORD *)(v98 + 24));
        (*(void (**)(uint64_t))(*(_QWORD *)v98 + 8))(v98);
      }
      else
      {
        v106 = *(_QWORD *)(v1 + 248);
        if (v106)
        {
          v107 = *(__CFReadStream **)(v106 + 32);
          if (v107)
          {
            if (CFReadStreamHasBytesAvailable(v107))
            {
              v108 = CFReadStreamRead(*(CFReadStreamRef *)(*(_QWORD *)(v1 + 248) + 32), buffer, 36000);
              v109 = *(__CFReadStream **)(*(_QWORD *)(v1 + 248) + 32);
              if (v108 < 0)
              {
                v111 = CFReadStreamCopyError(v109);
                HTTPServerBase::becomeErrored_onQueue((HTTPServerBase *)(v1 + 8), v111);
                if (v111)
                  CFRelease(v111);
              }
              else
              {
                Status = CFReadStreamGetStatus(v109);
                if (v108)
                  HTTPServerConnection::performWritesAndBufferLeftovers((CFWriteStreamRef *)v1, buffer, v108);
                if (Status == kCFStreamStatusAtEnd && *(_QWORD *)(v1 + 248))
                  HTTPServerConnection::responseCompleted((HTTPServerConnection *)v1);
              }
            }
          }
        }
      }
    }
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));
  v99 = *(__CFReadStream **)(v1 + 176);
  if (v99 && CFReadStreamGetStatus(v99) == kCFStreamStatusAtEnd)
    HTTPServerConnection::cleanupPendingRequests_onQueue((dispatch_queue_t *)v1);
  v100 = *(__CFWriteStream **)(v1 + 184);
  if (!v100 || CFWriteStreamGetStatus(v100) == kCFStreamStatusAtEnd)
  {
    HTTPServerConnection::cleanupPendingResponses_onQueue((dispatch_queue_t *)v1);
    if (*(int *)(v1 + 72) <= 2)
      *(_DWORD *)(v1 + 72) = 3;
    HTTPServerBase::signal((NSObject **)(v1 + 8));
    HTTPServerBase::deliverTerminalEvent_onQueue((HTTPServerBase *)(v1 + 8));
  }
  v101 = *(_DWORD *)(v1 + 72);
  v102 = v101 >= 2 && (v101 != 2 || !*(_QWORD *)(v1 + 88) || !*(_DWORD *)(*(_QWORD *)(v1 + 96) + 40))
      || *(_QWORD *)(v1 + 136) == 0;
  if (!*(_QWORD *)(v1 + 248))
  {
    if (*(_QWORD *)(v1 + 240))
      v102 = 0;
    if (v102)
      goto LABEL_257;
  }
  if (*(double *)(v1 + 192) != 0.0 && (*(_BYTE *)(v1 + 224) || CFAbsoluteTimeGetCurrent() > *(double *)(v1 + 192)))
  {
    v103 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("kCFHTTPServerErrorDomain"), 1104, 0);
    v104 = (__CFError *)CFAutorelease(v103);
    HTTPServerConnection::connectionError((dispatch_queue_t *)v1, v104);
LABEL_257:
    HTTPServerBase::deliverTerminalEvent_onQueue((HTTPServerBase *)(v1 + 8));
    goto LABEL_272;
  }
  if (*(_BYTE *)(v1 + 168)
    && *(_QWORD *)(v1 + 176)
    && (HTTPServerConnection::snapshotConnection(v1, buffer), *(uint64_t *)buffer <= 2)
    && (!*(_QWORD *)(v1 + 272) || v123 < *(_QWORD *)(v1 + 272) / 2))
  {
    *(_BYTE *)(v1 + 168) = 0;
    if (*(_QWORD *)(v1 + 280))
      MEMORY[0x186DB62D4](*(_QWORD *)(v1 + 176));
    if (CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)(v1 + 176)))
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));
      HTTPServerBase::signal((NSObject **)(v1 + 8));
    }
  }
  else
  {
    v105 = *(_DWORD *)(v1 + 72);
    if (v105 >= 2 && (v105 != 2 || !*(_QWORD *)(v1 + 88) || !*(_DWORD *)(*(_QWORD *)(v1 + 96) + 40)))
    {
      HTTPServerBase::deliverTerminalEvent_onQueue((HTTPServerBase *)(v1 + 8));
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));
    }
  }
LABEL_272:
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));
}

void sub_1840C1DE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPServerConnection::canceled_onQueue(dispatch_queue_t *this)
{
  dispatch_queue_t v2;

  HTTPServerConnection::closeStreamsAndCleanupRequests_onQueue(this);
  v2 = this[20];
  if (v2)
  {
    (*((void (**)(dispatch_queue_t, char *))v2->isa + 7))(v2, (char *)this - 16);
    CFRelease(&this[20][-2]);
    this[20] = 0;
  }
}

CFTypeRef HTTPServerConnection::retainSelf(HTTPServerConnection *this)
{
  return CFRetain((char *)this - 16);
}

void HTTPServerConnection::releaseSelf(HTTPServerConnection *this)
{
  CFRelease((char *)this - 16);
}

void `non-virtual thunk to'HTTPServerConnection::~HTTPServerConnection(HTTPServerConnection *this)
{
  HTTPServerConnection::~HTTPServerConnection((HTTPServerConnection *)((char *)this - 8));
}

{
  HTTPServerConnection::~HTTPServerConnection((HTTPServerConnection *)((char *)this - 8));
}

{
  HTTPServerConnection::~HTTPServerConnection((HTTPServerConnection *)((char *)this - 56));
}

{
  HTTPServerConnection::~HTTPServerConnection((HTTPServerConnection *)((char *)this - 56));
}

CFNumberRef `non-virtual thunk to'HTTPServerConnection::copyProperty(HTTPServerConnection *this, const __CFString *a2)
{
  return HTTPServerConnection::copyProperty((HTTPServerConnection *)((char *)this - 8), a2);
}

void `non-virtual thunk to'HTTPServerConnection::setProperty(HTTPServerConnection *this, const __CFString *a2, const void *a3)
{
  HTTPServerConnection::setProperty((HTTPServerConnection *)((char *)this - 8), a2, a3);
}

uint64_t `non-virtual thunk to'HTTPServerConnection::scheduled_onQueue(HTTPServerConnection *this)
{
  return HTTPServerConnection::scheduled_onQueue((uint64_t)this - 8);
}

void `non-virtual thunk to'HTTPServerConnection::signalled_onQueue(HTTPServerConnection *this)
{
  HTTPServerConnection::signalled_onQueue((HTTPServerConnection *)((char *)this - 8));
}

void `non-virtual thunk to'HTTPServerConnection::canceled_onQueue(dispatch_queue_t *this)
{
  HTTPServerConnection::canceled_onQueue(this - 1);
}

uint64_t `non-virtual thunk to'HTTPServerConnection::invalidateClient(uint64_t this, void *a2)
{
  uint64_t (*v2)(void *);

  v2 = *(uint64_t (**)(void *))(this + 112);
  if (v2)
  {
    *(_QWORD *)(this + 112) = 0;
    return v2(a2);
  }
  return this;
}

uint64_t `non-virtual thunk to'HTTPServerConnection::errorClient(uint64_t this, void *a2, __CFError *a3)
{
  uint64_t (*v3)(void *, __CFError *);

  v3 = *(uint64_t (**)(void *, __CFError *))(this + 120);
  if (v3)
  {
    *(_QWORD *)(this + 120) = 0;
    return v3(a2, a3);
  }
  return this;
}

CFTypeRef `non-virtual thunk to'HTTPServerConnection::retainSelf(HTTPServerConnection *this)
{
  return CFRetain((char *)this - 24);
}

void `non-virtual thunk to'HTTPServerConnection::releaseSelf(HTTPServerConnection *this)
{
  CFRelease((char *)this - 24);
}

void HTTPServerConnection::~HTTPServerConnection(HTTPServerConnection *this)
{
  const char *v1;
  int v2;

  *(_QWORD *)this = &off_1E14EB4D8;
  *((_QWORD *)this + 1) = &unk_1E14EB568;
  *((_QWORD *)this + 7) = &unk_1E14EB5D0;
  if (*((_QWORD *)this + 22))
  {
    v1 = "fSocketReadStream == NULL";
    v2 = 216;
    goto LABEL_6;
  }
  if (*((_QWORD *)this + 23))
  {
    v1 = "fSocketWriteStream == NULL";
    v2 = 217;
LABEL_6:
    __assert_rtn("~HTTPServerConnection", "HTTPServerConnection.cpp", v2, v1);
  }
  HTTPServerBase::~HTTPServerBase((HTTPServerConnection *)((char *)this + 8));
}

void sub_1840C1FD4(_Unwind_Exception *a1)
{
  HTTPServerBase *v1;

  HTTPServerBase::~HTTPServerBase(v1);
  _Unwind_Resume(a1);
}

void HTTPServerConnection::closeStreamsAndCleanupRequests_onQueue(dispatch_queue_t *this)
{
  dispatch_queue_t v2;
  HTTPServerRequest *v3;
  uint8_t v4[16];

  if (this[22])
    HTTPServerConnection::closeReadSocketSide_onQueue(this);
  if (this[23])
    HTTPServerConnection::closeWriteSocketSide_onQueue(this);
  v2 = this[33];
  if (v2)
  {
    (*((void (**)(dispatch_queue_t))v2->isa + 1))(v2);
    this[33] = 0;
  }
  v3 = (HTTPServerRequest *)this[29];
  if (v3)
  {
    HTTPServerRequest::loseConnectionReferenceAndTerminateReads(v3);
    CFRelease(&this[29][-2]);
    this[29] = 0;
  }
  if ((this[30] || this[31]) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Should be all null requests and responses now", v4, 2u);
  }
}

void HTTPServerConnection::closeReadSocketSide_onQueue(dispatch_queue_t *this)
{
  __CFReadStream *v2;
  NSObject *v3;
  void *v4;
  __CFRunLoop *v5;
  const void *v6;
  _QWORD block[5];

  if (this[22])
  {
    HTTPServerConnection::cleanupPendingRequests_onQueue(this);
    v2 = (__CFReadStream *)this[22];
    this[22] = 0;
    v3 = this[35];
    if (v3)
    {
      dispatch_assert_queue_V2(v3);
      MEMORY[0x186DB62D4](v2, 0);
      CFReadStreamSetClient(v2, 0, 0, 0);
      CFReadStreamClose(v2);
      if (v2)
        CFRelease(v2);
      this[35] = 0;
    }
    else
    {
      CFReadStreamSetClient(v2, 0, 0, 0);
      if (v2)
        CFRetain(v2);
      v5 = +[NSURLConnection resourceLoaderRunLoop](NSURLConnection, "resourceLoaderRunLoop");
      v6 = (const void *)*MEMORY[0x1E0C9B280];
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZL19forciblyCloseStreamIP14__CFReadStreamEvT__block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v2;
      CFRunLoopPerformBlock(v5, v6, block);
      CFRunLoopWakeUp(v5);
      if (v2)
        CFRelease(v2);
    }
    HTTPServerConnection::unscheduleTimer((uint64_t)this, v4);
    if (*((int *)this + 18) <= 2)
      *((_DWORD *)this + 18) = 3;
    HTTPServerBase::signal(this + 1);
  }
}

void HTTPServerConnection::closeWriteSocketSide_onQueue(dispatch_queue_t *this)
{
  __CFWriteStream *v2;
  NSObject *v3;
  void *v4;
  __CFRunLoop *v5;
  const void *v6;
  _QWORD block[5];

  if (this[23])
  {
    HTTPServerConnection::cleanupPendingResponses_onQueue(this);
    v2 = (__CFWriteStream *)this[23];
    this[23] = 0;
    v3 = this[36];
    if (v3)
    {
      dispatch_assert_queue_V2(v3);
      MEMORY[0x186DB6A90](v2, 0);
      CFWriteStreamSetClient(v2, 0, 0, 0);
      CFWriteStreamClose(v2);
      if (v2)
        CFRelease(v2);
      this[36] = 0;
    }
    else
    {
      CFWriteStreamSetClient(v2, 0, 0, 0);
      if (v2)
        CFRetain(v2);
      v5 = +[NSURLConnection resourceLoaderRunLoop](NSURLConnection, "resourceLoaderRunLoop");
      v6 = (const void *)*MEMORY[0x1E0C9B280];
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZL19forciblyCloseStreamIP15__CFWriteStreamEvT__block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v2;
      CFRunLoopPerformBlock(v5, v6, block);
      CFRunLoopWakeUp(v5);
      if (v2)
        CFRelease(v2);
    }
    HTTPServerConnection::unscheduleTimer((uint64_t)this, v4);
    if (*((int *)this + 18) <= 2)
      *((_DWORD *)this + 18) = 3;
    HTTPServerBase::signal(this + 1);
  }
}

void HTTPServerConnection::cleanupPendingResponses_onQueue(dispatch_queue_t *this)
{
  dispatch_queue_t isa;
  NSObject *v3;
  uint64_t *v4;
  uint64_t v5;
  dispatch_queue_t v6;
  dispatch_queue_t v7;
  uint8_t v8[16];

  dispatch_assert_queue_V2(this[11]);
  isa = this[30];
  if (isa)
  {
    this[30] = 0;
    v3 = MEMORY[0x1E0C81028];
    do
    {
      v4 = (uint64_t *)isa;
      isa = (dispatch_queue_t)isa[4].isa;
      v4[4] = 0;
      v5 = v4[2];
      if (!v5)
      {
        if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)v8 = 0;
          _os_log_fault_impl(&dword_183ECA000, v3, OS_LOG_TYPE_FAULT, "need  a request at least in the pending queue", v8, 2u);
          v5 = v4[2];
        }
        else
        {
          v5 = 0;
        }
      }
      HTTPServerConnection::sendFailedResponse((uint64_t)this, v5, v4[3]);
      HTTPServerRequest::loseConnectionReferenceAndTerminateReads((HTTPServerRequest *)v4[2]);
      (*(void (**)(uint64_t *))(*v4 + 8))(v4);
    }
    while (isa);
  }
  v6 = this[31];
  if (v6)
  {
    HTTPServerConnection::sendFailedResponse((uint64_t)this, (uint64_t)v6[2].isa, (uint64_t)v6[3].isa);
    v7 = this[31];
    if (v7)
      (*((void (**)(dispatch_queue_t))v7->isa + 1))(v7);
    this[31] = 0;
  }
}

void ___ZL19forciblyCloseStreamIP15__CFWriteStreamEvT__block_invoke(uint64_t a1)
{
  const void *v2;
  void *v3;
  __CFWriteStream *v4;
  __CFRunLoop *Current;
  CFStreamClientContext clientContext;

  if (CFWriteStreamGetStatus(*(CFWriteStreamRef *)(a1 + 32)) == kCFStreamStatusOpen)
  {
    CFWriteStreamClose(*(CFWriteStreamRef *)(a1 + 32));
    v2 = *(const void **)(a1 + 32);
    if (v2)
      CFRelease(v2);
  }
  else
  {
    v3 = *(void **)(a1 + 32);
    clientContext.version = 0;
    clientContext.info = v3;
    clientContext.retain = (void *(__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP15__CFWriteStreamEvT_EUb_ENUlPvE_8__invokeES3_;
    clientContext.release = (void (__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP15__CFWriteStreamEvT_EUb_ENUlPvE0_8__invokeES3_;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP15__CFWriteStreamEvT_EUb_ENUlPvE1_8__invokeES3_;
    CFWriteStreamSetClient((CFWriteStreamRef)v3, 9uLL, (CFWriteStreamClientCallBack)_ZZZL19forciblyCloseStreamIP15__CFWriteStreamEvT_EUb_ENUlS1_mPvE_8__invokeES1_mS3_, &clientContext);
    v4 = *(__CFWriteStream **)(a1 + 32);
    Current = CFRunLoopGetCurrent();
    CFWriteStreamScheduleWithRunLoop(v4, Current, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
    CFWriteStreamOpen(*(CFWriteStreamRef *)(a1 + 32));
  }
}

uint64_t HTTPServerConnection::unscheduleTimer(uint64_t this, void *a2)
{
  uint64_t v2;
  CFAllocatedReferenceCountedObject *v3;
  void (*v4)(_QWORD, _QWORD, _QWORD);
  const void *v5;
  void (*v6[5])(_QWORD, _QWORD, _QWORD);

  if (*(_QWORD *)(this + 296))
  {
    v2 = this;
    v3 = CoreSchedulingSet::createWithDispatchQueue(*(CoreSchedulingSet **)(this + 88), a2);
    v4 = *(void (**)(_QWORD, _QWORD, _QWORD))(v2 + 296);
    v6[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v6[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v6[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZNK17CoreSchedulingSet15unscheduleTimerEP16__CFRunLoopTimer_block_invoke;
    v6[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
    v6[4] = v4;
    CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)v3, v6);
    (*(void (**)(CFAllocatedReferenceCountedObject *))(*(_QWORD *)v3 + 48))(v3);
    CFRunLoopTimerInvalidate(*(CFRunLoopTimerRef *)(v2 + 296));
    v5 = *(const void **)(v2 + 296);
    *(_QWORD *)(v2 + 296) = 0;
    if (v5)
      CFRelease(v5);
    *(_QWORD *)(v2 + 192) = 0;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 120))(v2);
  }
  return this;
}

void _ZZZL19forciblyCloseStreamIP15__CFWriteStreamEvT_EUb_ENUlS1_mPvE_8__invokeES1_mS3_(__CFWriteStream *a1)
{
  __CFRunLoop *Current;

  CFWriteStreamSetClient(a1, 0, 0, 0);
  Current = CFRunLoopGetCurrent();
  CFWriteStreamScheduleWithRunLoop(a1, Current, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
  CFWriteStreamClose(a1);
  if (a1)
    CFRelease(a1);
}

uint64_t HTTPServerConnection::sendFailedResponse(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  const void *v4;
  const void *v5;
  uint64_t v6;
  _QWORD v7[8];

  if (*(_DWORD *)(result + 72) == 5)
    return result;
  v3 = result;
  if (a3)
  {
    v4 = (const void *)(a3 - 16);
    v5 = *(const void **)(a3 + 88);
    if (v5)
      goto LABEL_9;
  }
  else
  {
    v4 = 0;
  }
  if (a2)
    v5 = (const void *)(a2 - 16);
  else
    v5 = 0;
LABEL_9:
  if (*(_QWORD *)(result + 152))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)(result + 8) + 72))(result + 8);
    v6 = *(_QWORD *)(v3 + 88);
    if (v5)
      CFRetain(v5);
    if (v4)
      CFRetain(v4);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZN20HTTPServerConnection18sendFailedResponseEP17HTTPServerRequestP18HTTPServerResponse_block_invoke;
    v7[3] = &unk_1E14FC3E8;
    v7[6] = v5;
    v7[7] = v4;
    v7[4] = v6;
    v7[5] = v3;
    return HTTPServerBase::withClientAsync((_QWORD *)(v3 + 8), (uint64_t)v7);
  }
  return result;
}

void ___ZN20HTTPServerConnection18sendFailedResponseEP17HTTPServerRequestP18HTTPServerResponse_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  void (*v4)(uint64_t, _QWORD, _QWORD);
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  void *v8;
  _QWORD v9[4];
  __int128 v10;
  _QWORD block[6];

  v3 = a1[5];
  if (a2)
  {
    v4 = *(void (**)(uint64_t, _QWORD, _QWORD))(v3 + 152);
    if (v4)
      v4(a2, a1[6], a1[7]);
  }
  v5 = v3 + 8;
  v6 = a1[4];
  v7 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN20HTTPServerConnection18sendFailedResponseEP17HTTPServerRequestP18HTTPServerResponse_block_invoke_2;
  v9[3] = &__block_descriptor_48_e5_v8__0l;
  v10 = *((_OWORD *)a1 + 3);
  v8 = _Block_copy(v9);
  block[0] = v7;
  block[1] = 3221225472;
  block[2] = ___ZN14HTTPServerBase22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v8;
  block[5] = v5;
  dispatch_async(v6, block);
}

void ___ZN20HTTPServerConnection18sendFailedResponseEP17HTTPServerRequestP18HTTPServerResponse_block_invoke_2(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
}

void HTTPServerConnection::cleanupPendingRequests_onQueue(dispatch_queue_t *this)
{
  dispatch_queue_t v2;
  HTTPServerRequest *isa;
  dispatch_queue_t i;
  HTTPServerRequest *v5;

  dispatch_assert_queue_V2(this[11]);
  dispatch_assert_queue_V2(this[11]);
  v2 = this[31];
  if (!v2)
    goto LABEL_12;
  isa = v2[2].isa;
  if (isa && (int)HTTPServerRequest::requestState(v2[2].isa) <= 2)
    HTTPServerRequest::producerEOFEncountered(isa);
  if (this[31])
  {
    for (i = this[30]; i; i = (dispatch_queue_t)i[4].isa)
    {
      v5 = i[2].isa;
      if (v5 && (int)HTTPServerRequest::requestState(i[2].isa) <= 2)
        HTTPServerRequest::producerEOFEncountered(v5);
    }
  }
  else
  {
LABEL_12:
    HTTPServerConnection::checkPendingQueue(this);
  }
  dispatch_assert_queue_V2(this[11]);
}

void ___ZL19forciblyCloseStreamIP14__CFReadStreamEvT__block_invoke(uint64_t a1)
{
  const void *v2;
  void *v3;
  __CFReadStream *v4;
  __CFRunLoop *Current;
  CFStreamClientContext clientContext;

  if (CFReadStreamGetStatus(*(CFReadStreamRef *)(a1 + 32)) == kCFStreamStatusOpen)
  {
    CFReadStreamClose(*(CFReadStreamRef *)(a1 + 32));
    v2 = *(const void **)(a1 + 32);
    if (v2)
      CFRelease(v2);
  }
  else
  {
    v3 = *(void **)(a1 + 32);
    clientContext.version = 0;
    clientContext.info = v3;
    clientContext.retain = (void *(__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP14__CFReadStreamEvT_EUb_ENUlPvE_8__invokeES3_;
    clientContext.release = (void (__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP14__CFReadStreamEvT_EUb_ENUlPvE0_8__invokeES3_;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP14__CFReadStreamEvT_EUb_ENUlPvE1_8__invokeES3_;
    CFReadStreamSetClient((CFReadStreamRef)v3, 9uLL, (CFReadStreamClientCallBack)_ZZZL19forciblyCloseStreamIP14__CFReadStreamEvT_EUb_ENUlS1_mPvE_8__invokeES1_mS3_, &clientContext);
    v4 = *(__CFReadStream **)(a1 + 32);
    Current = CFRunLoopGetCurrent();
    CFReadStreamScheduleWithRunLoop(v4, Current, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
    CFReadStreamOpen(*(CFReadStreamRef *)(a1 + 32));
  }
}

void _ZZZL19forciblyCloseStreamIP14__CFReadStreamEvT_EUb_ENUlS1_mPvE_8__invokeES1_mS3_(__CFReadStream *a1)
{
  __CFRunLoop *Current;

  CFReadStreamSetClient(a1, 0, 0, 0);
  Current = CFRunLoopGetCurrent();
  CFReadStreamScheduleWithRunLoop(a1, Current, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
  CFReadStreamClose(a1);
  if (a1)
    CFRelease(a1);
}

void HTTPServerConnection::checkPendingQueue(dispatch_queue_t *this)
{
  _QWORD *v2;
  NSObject *v3;
  const __CFAllocator *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  CFAllocatorRef v8;
  dispatch_queue_t v9;
  Class isa;
  const void *v11;
  __CFReadStream *v12;
  __CFWriteStream *v13;
  CFErrorRef v14;
  __CFError *v15;
  __CFReadStream *v16;
  CFStreamClientContext clientContext;

  dispatch_assert_queue_V2(this[11]);
  dispatch_assert_queue_V2(this[11]);
  if (this[31])
    goto LABEL_2;
  v2 = this[30];
  if (!v2 || !v2[2] || !v2[3])
    goto LABEL_2;
  v3 = v2[4];
  v2[4] = 0;
  this[30] = v3;
  v4 = CFGetAllocator(this - 2);
  v5 = CFAllocatorAllocate(v4, 48, 0);
  *(_OWORD *)&v5->isa = 0u;
  *(_OWORD *)&v5[2].isa = 0u;
  *(_OWORD *)&v5[4].isa = 0u;
  v7 = v2[2];
  v6 = v2[3];
  v8 = CFGetAllocator((CFTypeRef)(v7 - 16));
  v5[2].isa = 0;
  v5[3].isa = 0;
  v5->isa = (Class)off_1E14F0058;
  v5[1].isa = v8;
  HTTPServerConnection::RRQueue::setRequest((uint64_t)v5, v7);
  HTTPServerConnection::RRQueue::setResponse((uint64_t)v5, v6);
  v5[4].isa = 0;
  LOBYTE(v5[5].isa) = 0;
  this[31] = v5;
  (*(void (**)(_QWORD *))(*v2 + 8))(v2);
  v9 = this[31];
  dispatch_assert_queue_V2(this[11]);
  isa = v9[3].isa;
  if (!isa)
    goto LABEL_14;
  v11 = (const void *)*((_QWORD *)isa + 9);
  if (!v11)
  {
    v9[4].isa = 0;
    goto LABEL_14;
  }
  v12 = (__CFReadStream *)CFRetain(v11);
  v9[4].isa = v12;
  if (!v12)
  {
LABEL_14:
    v14 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("kCFHTTPServerErrorDomain"), 1103, 0);
    v15 = (__CFError *)CFAutorelease(v14);
    HTTPServerConnection::connectionError(this, v15);
    goto LABEL_2;
  }
  clientContext.version = 0;
  clientContext.info = this;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  CFReadStreamSetClient(v12, 0x1BuLL, (CFReadStreamClientCallBack)_readStreamCallback, &clientContext);
  MEMORY[0x186DB62D4](v9[4].isa, this[11]);
  if (!CFReadStreamOpen(v9[4].isa))
  {
    LOBYTE(v9[5].isa) = 0;
    v16 = v9[4].isa;
    v9[4].isa = 0;
    CFReadStreamSetClient(v16, 0, 0, 0);
    if (v16)
      CFRelease(v16);
    goto LABEL_14;
  }
  LOBYTE(v9[5].isa) = 1;
  v13 = (__CFWriteStream *)this[23];
  if (v13 && CFWriteStreamCanAcceptBytes(v13))
  {
    dispatch_assert_queue_V2(this[11]);
    HTTPServerBase::signal(this + 1);
  }
LABEL_2:
  dispatch_assert_queue_V2(this[11]);
}

void sub_1840C2BA8(_Unwind_Exception *a1)
{
  HTTPServerConnection::RRQueue *v1;

  HTTPServerConnection::RRQueue::~RRQueue(v1);
  _Unwind_Resume(a1);
}

void HTTPServerConnection::connectionError(dispatch_queue_t *this, __CFError *a2)
{
  HTTPServerBase *v4;

  v4 = (HTTPServerBase *)(this + 1);
  dispatch_assert_queue_V2(this[11]);
  HTTPServerBase::becomeErrored_onQueue(v4, a2);
  HTTPServerConnection::closeReadSocketSide_onQueue((HTTPServerConnection *)this);
  HTTPServerConnection::closeWriteSocketSide_onQueue(this);
}

void _readStreamCallback(__CFReadStream *a1, unint64_t a2, _QWORD *a3)
{
  NSObject *v3;
  _QWORD block[5];

  v3 = a3[11];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN20HTTPServerConnection27signal_connection_off_queueEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = a3;
  dispatch_async(v3, block);
}

void ___ZN20HTTPServerConnection27signal_connection_off_queueEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject **v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = (NSObject **)(v1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));
  HTTPServerBase::signal(v2);
}

void HTTPServerConnection::RRQueue::setRequest(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != a2)
  {
    if (v2)
      CFRelease((CFTypeRef)(v2 - 16));
    *(_QWORD *)(a1 + 16) = a2;
    if (a2)
      CFRetain((CFTypeRef)(a2 - 16));
  }
}

void HTTPServerConnection::RRQueue::setResponse(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2 != a2)
  {
    if (v2)
      CFRelease((CFTypeRef)(v2 - 16));
    *(_QWORD *)(a1 + 24) = a2;
    if (a2)
      CFRetain((CFTypeRef)(a2 - 16));
  }
}

void HTTPServerConnection::snapshotConnection(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  HTTPServerRequest *v7;
  uint64_t v8;
  HTTPServerRequest *v9;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 88));
  *a2 = 0;
  a2[1] = 0;
  v4 = *(_QWORD *)(a1 + 240);
  if (v4)
  {
    v5 = 0;
    do
    {
      ++v5;
      v4 = *(_QWORD *)(v4 + 32);
    }
    while (v4);
    *a2 = v5;
  }
  v6 = *(_QWORD *)(a1 + 248);
  if (v6)
  {
    v7 = *(HTTPServerRequest **)(v6 + 16);
    if (v7)
    {
      if ((int)HTTPServerRequest::requestState(v7) <= 2)
        a2[1] += HTTPServerRequest::remainingBodySize(*(HTTPServerRequest **)(*(_QWORD *)(a1 + 248) + 16));
    }
  }
  v8 = *(_QWORD *)(a1 + 240);
  if (v8)
  {
    v9 = *(HTTPServerRequest **)(v8 + 16);
    if (v9)
    {
      if ((int)HTTPServerRequest::requestState(v9) <= 2)
        a2[1] += HTTPServerRequest::remainingBodySize(*(HTTPServerRequest **)(*(_QWORD *)(a1 + 240) + 16));
    }
  }
}

void HTTPServerConnection::performWritesAndBufferLeftovers(CFWriteStreamRef *this, const unsigned __int8 *a2, CFIndex a3)
{
  CFIndex v6;
  CFErrorRef v7;
  BOOL v8;
  uint64_t v9;
  const __CFAllocator *v10;
  _QWORD *v11;
  const unsigned __int8 *v12;
  void *v13;
  CFErrorRef v14;
  __CFError *v15;

  v6 = CFWriteStreamWrite(this[23], a2, a3);
  v7 = CFWriteStreamCopyError(this[23]);
  if (v6 < 0)
  {
    HTTPServerConnection::closeWriteSocketSide_onQueue((dispatch_queue_t *)this);
    HTTPServerBase::becomeErrored_onQueue((HTTPServerBase *)(this + 1), v7);
    if (!v7)
      return;
LABEL_10:
    CFRelease(v7);
    return;
  }
  if (!v6)
  {
    v14 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("kCFHTTPServerErrorDomain"), 1101, 0);
    v15 = (__CFError *)CFAutorelease(v14);
    HTTPServerConnection::connectionError((dispatch_queue_t *)this, v15);
LABEL_9:
    if (!v7)
      return;
    goto LABEL_10;
  }
  HTTPServerConnection::touchTimerWatchdog((HTTPServerConnection *)this);
  v8 = a3 <= v6;
  v9 = a3 - v6;
  if (v8)
    goto LABEL_9;
  v10 = CFGetAllocator(this - 2);
  v11 = CFAllocatorAllocate(v10, 32808, 0);
  bzero(v11 + 1, 0x8020uLL);
  v12 = &a2[v6];
  *v11 = &off_1E14ECA30;
  if (v9 >= 0x8000)
    v13 = CFAllocatorAllocate(v10, v9, 0);
  else
    v13 = v11 + 5;
  v11[3] = 0;
  v11[4] = v13;
  v11[1] = v10;
  v11[2] = v9;
  *v11 = off_1E14F0038;
  memcpy(v13, v12, v9);
  v11[3] = v9;
  this[33] = (CFWriteStreamRef)v11;
  if (v7)
    goto LABEL_10;
}

void HTTPServerConnection::responseCompleted(HTTPServerConnection *this)
{
  uint64_t v2;
  _QWORD *v3;
  HTTPServerRequest *v4;
  uint64_t v5;
  const void *v6;
  char *v7;
  uint64_t v8;
  int v9;
  _QWORD v10[8];

  v2 = *((_QWORD *)this + 31);
  if (v2
    || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
    && (LOWORD(v10[0]) = 0,
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "fActivePair should not be NULL in HTTPServerConnection::responseCompleted", (uint8_t *)v10, 2u), (v2 = *((_QWORD *)this + 31)) != 0))
  {
    if ((int)HTTPServerRequest::requestState(*(HTTPServerRequest **)(v2 + 16)) < 3)
      return;
    v3 = (_QWORD *)*((_QWORD *)this + 31);
  }
  else
  {
    v3 = 0;
  }
  *((_QWORD *)this + 31) = 0;
  v4 = (HTTPServerRequest *)v3[2];
  v5 = v3[3];
  if (v5)
  {
    v6 = (const void *)(v5 - 16);
    v7 = *(char **)(v5 + 88);
    if (v7)
      goto LABEL_13;
  }
  else
  {
    v6 = 0;
  }
  if (v4)
    v7 = (char *)v4 - 16;
  else
    v7 = 0;
LABEL_13:
  if (*((_QWORD *)this + 18))
  {
    (*(void (**)(char *))(*((_QWORD *)this + 1) + 72))((char *)this + 8);
    v8 = *((_QWORD *)this + 11);
    if (v7)
      CFRetain(v7);
    if (v6)
      CFRetain(v6);
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3221225472;
    v10[2] = ___ZN20HTTPServerConnection21sendResponseCompletedEP17HTTPServerRequestP18HTTPServerResponse_block_invoke;
    v10[3] = &unk_1E14FC3E8;
    v10[6] = v7;
    v10[7] = v6;
    v10[4] = v8;
    v10[5] = this;
    HTTPServerBase::withClientAsync((_QWORD *)this + 1, (uint64_t)v10);
    v4 = (HTTPServerRequest *)v3[2];
  }
  if ((int)HTTPServerRequest::requestState(v4) < 3)
  {
    (*(void (**)(_QWORD *))(*v3 + 8))(v3);
  }
  else
  {
    v9 = *(unsigned __int8 *)(v3[3] + 105);
    (*(void (**)(_QWORD *))(*v3 + 8))(v3);
    if (!v9)
    {
      HTTPServerConnection::checkPendingQueue((dispatch_queue_t *)this);
      if (!*((_QWORD *)this + 31))
        HTTPServerConnection::touchTimerIdle(this);
      return;
    }
  }
  if (*((int *)this + 18) <= 2)
    *((_DWORD *)this + 18) = 3;
  HTTPServerBase::signal((NSObject **)this + 1);
  HTTPServerConnection::checkPendingQueue((dispatch_queue_t *)this);
}

void HTTPServerConnection::touchTimerIdle(HTTPServerConnection *this)
{
  double Current;
  double v3;
  __CFRunLoopTimer *v4;

  if (*((uint64_t *)this + 26) < 1)
  {
    *((_QWORD *)this + 24) = 0;
  }
  else
  {
    Current = CFAbsoluteTimeGetCurrent();
    v3 = Current + (double)*((uint64_t *)this + 26);
    *((double *)this + 24) = v3;
    *((double *)this + 25) = Current;
    *((_BYTE *)this + 224) = 0;
    v4 = (__CFRunLoopTimer *)*((_QWORD *)this + 37);
    if (v4)
      CFRunLoopTimerSetNextFireDate(v4, v3);
  }
}

void ___ZN20HTTPServerConnection21sendResponseCompletedEP17HTTPServerRequestP18HTTPServerResponse_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  void (*v4)(uint64_t, _QWORD, _QWORD);
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  void *v8;
  _QWORD v9[4];
  __int128 v10;
  _QWORD block[6];

  v3 = a1[5];
  if (a2)
  {
    v4 = *(void (**)(uint64_t, _QWORD, _QWORD))(v3 + 144);
    if (v4)
      v4(a2, a1[6], a1[7]);
  }
  v5 = v3 + 8;
  v6 = a1[4];
  v7 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN20HTTPServerConnection21sendResponseCompletedEP17HTTPServerRequestP18HTTPServerResponse_block_invoke_2;
  v9[3] = &__block_descriptor_48_e5_v8__0l;
  v10 = *((_OWORD *)a1 + 3);
  v8 = _Block_copy(v9);
  block[0] = v7;
  block[1] = 3221225472;
  block[2] = ___ZN14HTTPServerBase22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v8;
  block[5] = v5;
  dispatch_async(v6, block);
}

void ___ZN20HTTPServerConnection21sendResponseCompletedEP17HTTPServerRequestP18HTTPServerResponse_block_invoke_2(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
}

void HTTPServerConnection::touchTimerWatchdog(HTTPServerConnection *this)
{
  double Current;
  double v3;
  __CFRunLoopTimer *v4;

  if (*((uint64_t *)this + 27) < 1)
  {
    *((_QWORD *)this + 24) = 0;
  }
  else
  {
    Current = CFAbsoluteTimeGetCurrent();
    v3 = Current + (double)*((uint64_t *)this + 27);
    *((double *)this + 24) = v3;
    *((double *)this + 25) = Current;
    *((_BYTE *)this + 224) = 0;
    v4 = (__CFRunLoopTimer *)*((_QWORD *)this + 37);
    if (v4)
      CFRunLoopTimerSetNextFireDate(v4, v3);
  }
}

void HTTPServerConnection::LeftoverBuffer::~LeftoverBuffer(HTTPServerConnection::LeftoverBuffer *this)
{
  char *v1;

  *(_QWORD *)this = &off_1E14ECA30;
  v1 = (char *)*((_QWORD *)this + 4);
  if (v1 != (char *)this + 40)
    CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), v1);
}

{
  char *v2;

  *(_QWORD *)this = &off_1E14ECA30;
  v2 = (char *)*((_QWORD *)this + 4);
  if (v2 != (char *)this + 40)
    CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), v2);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

uint64_t CFBufferPossiblyOnStack<32768l>::~CFBufferPossiblyOnStack(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1E14ECA30;
  v2 = *(void **)(a1 + 32);
  if (v2 != (void *)(a1 + 40))
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 8), v2);
  return a1;
}

void CFBufferPossiblyOnStack<32768l>::~CFBufferPossiblyOnStack(char *ptr)
{
  char *v2;

  *(_QWORD *)ptr = &off_1E14ECA30;
  v2 = (char *)*((_QWORD *)ptr + 4);
  if (v2 != ptr + 40)
    CFAllocatorDeallocate(*((CFAllocatorRef *)ptr + 1), v2);
  CFAllocatorDeallocate(*((CFAllocatorRef *)ptr + 1), ptr);
}

_QWORD *HTTPServerConnection::PendingQueue::PendingQueue(_QWORD *a1, uint64_t a2)
{
  CFAllocatorRef v4;

  v4 = CFGetAllocator((CFTypeRef)(a2 - 16));
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_1E14F0018;
  a1[1] = v4;
  HTTPServerConnection::RRQueue::setRequest((uint64_t)a1, a2);
  a1[4] = 0;
  return a1;
}

void sub_1840C3414(_Unwind_Exception *a1)
{
  HTTPServerConnection::RRQueue *v1;

  HTTPServerConnection::RRQueue::~RRQueue(v1);
  _Unwind_Resume(a1);
}

void ___ZN20HTTPServerConnection31processAllIncomingBytes_onQueueEP21ConsumableStackBuffer_block_invoke(uint64_t a1, uint64_t a2)
{
  void (*v3)(uint64_t, uint64_t);
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[6];

  if (a2 && (v3 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 136)) != 0)
    v3(a2, *(_QWORD *)(a1 + 48) - 16);
  else
    HTTPServerRequest::loseConnectionReferenceAndTerminateReads(*(HTTPServerRequest **)(a1 + 48));
  v4 = *(_QWORD *)(a1 + 48);
  v5 = *(NSObject **)(a1 + 32);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN17HTTPServerRequest22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  v6[3] = &unk_1E14FDA90;
  v6[4] = 0;
  v6[5] = v4;
  dispatch_async(v5, v6);
}

void HTTPServerConnection::suspendTimeout(HTTPServerConnection *this)
{
  __CFRunLoopTimer *v2;
  CFAbsoluteTime Current;

  *((_BYTE *)this + 224) = 0;
  v2 = (__CFRunLoopTimer *)*((_QWORD *)this + 37);
  if (v2)
  {
    Current = CFAbsoluteTimeGetCurrent();
    CFRunLoopTimerSetNextFireDate(v2, Current + 1.0e30);
  }
  *((_QWORD *)this + 24) = 0;
}

void ___ZN17HTTPServerRequest22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v4 = a1 + 32;
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v4 + 8);
  if (v2)
  {
    (*(void (**)(void))(v2 + 16))();
    _Block_release(*(const void **)(a1 + 32));
  }
  CFRelease((CFTypeRef)(v3 - 16));
}

void ___ZN9TCFObjectI17HTTPServerRequestE5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  byte_1EDD00CB8 = 116;
  _PNAME<HTTPServerRequest>::GET(void)::p = *(_OWORD *)"HTTPServerRequest>::GET() [OBJTYPE = HTTPServerRequest]";
  CFClass::CFClass(v0, (const char *)&_PNAME<HTTPServerRequest>::GET(void)::p);
  TCFObject<HTTPServerRequest>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840C3598(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void _timerCallback(__CFRunLoopTimer *a1, _QWORD *a2)
{
  _QWORD aBlock[5];

  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZL14_timerCallbackP16__CFRunLoopTimerPv_block_invoke;
  aBlock[3] = &__block_descriptor_40_e5_v8__0l;
  aBlock[4] = a2;
  HTTPServerBase::withWorkQueue(a2 + 1, aBlock);
}

void ___ZL14_timerCallbackP16__CFRunLoopTimerPv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject **v2;

  v1 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v1 + 224) = 1;
  v2 = (NSObject **)(v1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));
  HTTPServerBase::signal(v2);
}

void ___ZN20HTTPServerConnection5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "HTTPServerConnection");
  HTTPServerConnection::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_1840C3690(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void _writeStreamCallback(__CFWriteStream *a1, unint64_t a2, _QWORD *a3)
{
  NSObject *v3;
  _QWORD block[5];

  v3 = a3[11];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN20HTTPServerConnection27signal_connection_off_queueEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = a3;
  dispatch_async(v3, block);
}

uint64_t ___ZN20HTTPServerConnection7abandonEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 104))(*(_QWORD *)(a1 + 32));
}

void HTTPServerReadStream::~HTTPServerReadStream(HTTPServerReadStream *this)
{
  HTTPServerReadStream::~HTTPServerReadStream(this);
  JUMPOUT(0x186DB748CLL);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_1E14EB5F0;
  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    if (!*((_BYTE *)this + 25))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
      v2 = *((_QWORD *)this + 2);
    }
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 56))(v2);
    *((_QWORD *)this + 2) = 0;
  }
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
}

uint64_t HTTPServerReadStream::_streamImpl_Open(HTTPServerReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  int v6;
  uint64_t v7;

  *a4 = 0;
  *((_BYTE *)this + 24) = 1;
  v6 = (*(uint64_t (**)(_QWORD, CFStreamError *))(**((_QWORD **)this + 2) + 16))(*((_QWORD *)this + 2), a3);
  if (v6 == 1)
    goto LABEL_4;
  v7 = 0;
  if (!v6)
  {
    *a4 = 1;
LABEL_4:
    a3->error = 0;
    a3->domain = 0;
    return 1;
  }
  return v7;
}

uint64_t HTTPServerReadStream::_streamImpl_OpenCompleted(HTTPServerReadStream *this, __CFReadStream *a2, CFStreamError *a3)
{
  return *((unsigned __int8 *)this + 24);
}

uint64_t HTTPServerReadStream::_streamImpl_Read(HTTPServerReadStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  return (*(uint64_t (**)(_QWORD, unsigned __int8 *, uint64_t, CFStreamError *, unsigned __int8 *))(**((_QWORD **)this + 2) + 32))(*((_QWORD *)this + 2), a3, a4, a5, a6);
}

uint64_t HTTPServerReadStream::_streamImpl_CanRead(HTTPServerReadStream *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 24))(*((_QWORD *)this + 2));
}

uint64_t HTTPServerReadStream::_streamImpl_Close(HTTPServerReadStream *this, __CFReadStream *a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (result)
  {
    *((_BYTE *)this + 25) = 1;
    (*(void (**)(uint64_t, __CFReadStream *))(*(_QWORD *)result + 40))(result, a2);
    result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 56))(*((_QWORD *)this + 2));
    *((_QWORD *)this + 2) = 0;
  }
  return result;
}

uint64_t HTTPServerReadStream::_streamImpl_CopyProperty(HTTPServerReadStream *this, __CFReadStream *a2, const __CFString *a3)
{
  return 0;
}

uint64_t HTTPServerReadStream::_streamImpl_SetProperty(HTTPServerReadStream *this, __CFReadStream *a2, const __CFString *a3, const void *a4)
{
  return 0;
}

void sub_1840C38AC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

CFStringRef HTTPServerRequest::copyDebugDesc(HTTPServerRequest *this)
{
  CFStringRef v2;
  int v3;
  const __CFAllocator *v4;
  CFStringRef v5;
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  uint64_t v8;
  const char *v9;
  const __CFAllocator *v10;
  const __CFAllocator *v11;
  const char *v12;
  const char *v13;
  uint64_t v14;
  CFStringRef v15;

  v2 = CFObject::copyDebugDescHeader(this);
  v3 = *((_DWORD *)this + 41);
  switch(v3)
  {
    case 0:
      v4 = CFGetAllocator((char *)this - 16);
      v5 = CFStringCreateWithFormat(v4, 0, CFSTR("%@ { state %s }>"), v2, "H");
      break;
    case 1:
      v6 = CFGetAllocator((char *)this - 16);
      v5 = CFStringCreateWithFormat(v6, 0, CFSTR("%@ { state %s, expected total body length %ld  }>"), v2, "B", *((_QWORD *)this + 21));
      break;
    case 2:
      v7 = CFGetAllocator((char *)this - 16);
      v8 = *((unsigned int *)this + 46);
      if (v8 > 6)
        v9 = "BAD";
      else
        v9 = off_1E14FC448[v8];
      v5 = CFStringCreateWithFormat(v7, 0, CFSTR("%@ { state %s, chunk state %s  }>"), v2, "C", v9);
      break;
    case 3:
      v10 = CFGetAllocator((char *)this - 16);
      v5 = CFStringCreateWithFormat(v10, 0, CFSTR("%@ { state %s - COMPLETED, expected body length %ld  }>"), v2, "D", *((_QWORD *)this + 21));
      break;
    default:
      v11 = CFGetAllocator((char *)this - 16);
      v12 = "BAD";
      if ((v3 & 0xFFFFFFFE) == 4)
        v13 = "I";
      else
        v13 = "BAD";
      v14 = *((unsigned int *)this + 46);
      if (v14 <= 6)
        v12 = off_1E14FC448[v14];
      v5 = CFStringCreateWithFormat(v11, 0, CFSTR("%@ { state %s, chunk state %s - INVALID, expected body length %ld  }>"), v2, v13, v12, *((_QWORD *)this + 21));
      break;
  }
  v15 = v5;
  if (v2)
    CFRelease(v2);
  return v15;
}

uint64_t HTTPServerRequest::openUnderlyingStream(HTTPServerRequest *this, CFStreamError *a2)
{
  HTTPServerRequest::signalReadStreamBasedOnState(this);
  return 0;
}

BOOL HTTPServerRequest::canReadFromUnderlyingStream(HTTPServerRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  _BOOL8 v4;
  _BOOL8 result;

  v2 = *((_QWORD *)this + 19);
  if (!v2)
    goto LABEL_5;
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
  v3 = *((_QWORD *)this + 19);
  if (!*((_QWORD *)this + 17))
  {
    v4 = 0;
    result = 0;
    *((_DWORD *)this + 41) = *((_DWORD *)this + 40);
    if (!v3)
      return result;
    goto LABEL_7;
  }
  if (!v3)
  {
LABEL_5:
    result = 0;
    *((_DWORD *)this + 41) = *((_DWORD *)this + 40);
    return result;
  }
  v4 = *(_QWORD *)(*(_QWORD *)(v3 + 136) + 40) > 0;
  *((_DWORD *)this + 41) = *((_DWORD *)this + 40);
LABEL_7:
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 24));
  return v4;
}

uint64_t HTTPServerRequest::readFromUnderlyingStream(HTTPServerRequest *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  HTTPServerRequest *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v20;
  unsigned __int8 *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  _QWORD *v29;
  uint64_t v30;
  size_t v31;
  uint64_t v32;
  size_t v33;
  const __CFAllocator *v34;
  SegmentedData::PrivateAllocation *v35;
  void *v36;
  size_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  BOOL v44;
  _QWORD *v45;
  uint64_t v46;
  unsigned __int8 *v47;
  uint64_t v48;
  uint64_t v49;
  int *v50;
  uint64_t *v51;
  unsigned __int8 *v52;
  uint8_t v53[16];
  uint8_t v54[16];
  uint8_t buf[16];

  v8 = this;
  v9 = *((_QWORD *)this + 19);
  if (v9
    || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
    && (*(_WORD *)v53 = 0,
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "fBodyData must not be NULL - we shouldn't get a read event until we're readable", v53, 2u), (v9 = *((_QWORD *)v8 + 19)) != 0))
  {
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 24));
  }
  *a5 = 0;
  v10 = *((_DWORD *)v8 + 40);
  if (v10 > 3)
  {
    v11 = -1;
    goto LABEL_22;
  }
  v12 = *((_QWORD *)v8 + 19);
  v13 = *(_QWORD **)(v12 + 136);
  v14 = v13[5];
  if (v10 == 3 && !v14)
    goto LABEL_8;
  if (!v14)
  {
    pthread_cond_wait((pthread_cond_t *)(v12 + 88), (pthread_mutex_t *)(v12 + 24));
    v13 = *(_QWORD **)(*((_QWORD *)v8 + 19) + 136);
    v14 = v13[5];
    if (!v14)
    {
      if (*((int *)v8 + 40) <= 2)
      {
        v11 = 0;
        *((_DWORD *)v8 + 40) = 5;
        goto LABEL_21;
      }
LABEL_8:
      v11 = 0;
LABEL_21:
      *a5 = 1;
      v10 = *((_DWORD *)v8 + 40);
      goto LABEL_22;
    }
  }
  v47 = a5;
  v48 = v14;
  v49 = a3;
  v50 = (int *)v8;
  if (v14 >= a3)
    v11 = a3;
  else
    v11 = v14;
  v16 = v13 + 3;
  v15 = v13[3];
  if (v15)
    v17 = v11 < 1;
  else
    v17 = 1;
  if (!v17)
  {
    v20 = 0;
    v21 = &a2[v11];
    v22 = v13 + 3;
    v45 = v13;
    v46 = v11;
    v51 = v13 + 3;
    v52 = &a2[v11];
    do
    {
      v23 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 24))(v15);
      if (v23 >= 1)
      {
        v24 = v23 + v20;
        if (v11 >= v20 && v24 >= 1)
        {
          v25 = v20 & ~(v20 >> 63);
          if (v11 >= v24)
            v26 = v23 + v20;
          else
            v26 = v11;
          v27 = v25 - v20;
          v28 = v26 - v25;
          v29 = (_QWORD *)*v22;
          if ((v25 - v20 < 0 || v29[3] + v27 + v28 > v29[4])
            && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "out of bounds", buf, 2u);
          }
          memcpy(a2, (const void *)(v29[3] + v27), v28);
          v30 = v29[3];
          if (v20 < 0)
          {
            v31 = v27 + v28;
            v32 = v29[4];
            if (v30 + v27 + v28 == v32)
            {
              v29[4] = v30 + v27;
            }
            else
            {
              v33 = v32 - v30 - v31;
              v34 = (const __CFAllocator *)v29[1];
              v35 = (SegmentedData::PrivateAllocation *)CFAllocatorAllocate(v34, (v33 & 0xFFFFFFFFFFFFFFF0) + 64, 0);
              *(_QWORD *)v35 = off_1E14EFF30;
              *((_QWORD *)v35 + 1) = v34;
              *((_QWORD *)v35 + 2) = 0;
              *((_QWORD *)v35 + 3) = (char *)v35 + 40;
              *((_QWORD *)v35 + 4) = (char *)v35 + v33 + 40;
              v36 = (void *)SegmentedData::PrivateAllocation::ptr(v35);
              v37 = v33;
              v13 = v45;
              memcpy(v36, (const void *)(v29[3] + v31), v37);
              v38 = v29[2];
              v29[4] = v29[3] + v27;
              *((_QWORD *)v35 + 2) = v38;
              v29[2] = v35;
              v11 = v46;
            }
            v16 = v51;
          }
          else
          {
            v29[3] = v30 + v28;
          }
          v21 = v52;
          a2 += v28;
          v13[5] -= v28;
        }
        v20 = v24;
      }
      v39 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v22 + 24))(*v22);
      v40 = (_QWORD *)*v22;
      v41 = *(_QWORD *)(*v22 + 16);
      if (v39)
      {
        if (!v41)
        {
          v13[4] = v40;
          v40 = (_QWORD *)*v22;
        }
        v22 = v40 + 2;
      }
      else
      {
        *v22 = v41;
        v40[2] = 0;
        (*(void (**)(_QWORD *))(*v40 + 8))(v40);
        v42 = *v16;
        if (*v16)
        {
          v43 = (_QWORD *)v13[4];
        }
        else
        {
          v43 = 0;
          v13[4] = 0;
        }
        if (v43 == v40)
        {
          v13[4] = v42;
          if (*(_QWORD *)(v42 + 16))
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)v54 = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "tail", v54, 2u);
            }
          }
        }
      }
      v15 = *v22;
      if (*v22)
        v44 = a2 >= v21;
      else
        v44 = 1;
    }
    while (!v44);
  }
  v8 = (HTTPServerRequest *)v50;
  v10 = v50[40];
  if (v48 <= v49)
  {
    a5 = v47;
    if (v10 == 3)
      goto LABEL_21;
  }
LABEL_22:
  *((_DWORD *)v8 + 41) = v10;
  v18 = *((_QWORD *)v8 + 19);
  if (v18)
    pthread_mutex_unlock((pthread_mutex_t *)(v18 + 24));
  HTTPServerRequest::signalReadStreamBasedOnState(v8);
  return v11;
}

uint64_t HTTPServerRequest::closeUnderlyingStream(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = this;
  v2 = *(_QWORD *)(this + 152);
  if (!v2)
  {
    *(_DWORD *)(this + 160) = 3;
    goto LABEL_6;
  }
  this = pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
  v3 = *(_QWORD *)(v1 + 152);
  *(_DWORD *)(v1 + 160) = 3;
  if (!v3)
  {
LABEL_6:
    *(_DWORD *)(v1 + 164) = 3;
    return this;
  }
  this = pthread_cond_signal((pthread_cond_t *)(v3 + 88));
  v4 = *(_QWORD *)(v1 + 152);
  *(_DWORD *)(v1 + 164) = *(_DWORD *)(v1 + 160);
  if (v4)
    return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 24));
  return this;
}

uint64_t HTTPServerRequest::_subclass_retain(HTTPServerRequest *this)
{
  CFRetain((char *)this - 16);
  return (uint64_t)this + 120;
}

void HTTPServerRequest::_subclass_release(HTTPServerRequest *this)
{
  CFRelease((char *)this - 16);
}

uint64_t HTTPServerRequest::mutableVersion(HTTPServerRequest *this)
{
  return (uint64_t)this + 216;
}

uint64_t HTTPServerRequest::mutableHeaders(HTTPServerRequest *this)
{
  return *((_QWORD *)this + 26);
}

uint64_t HTTPServerRequest::parserCompleteFirstLine(HTTPServerRequest *this, const unsigned __int8 *a2)
{
  return (*(uint64_t (**)(char *, const unsigned __int8 *))(*((_QWORD *)this + 7) + 16))((char *)this + 56, a2);
}

uint64_t HTTPServerRequest::parserAddHeader(HTTPServerRequest *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  return (*(uint64_t (**)(char *, const HTTPHeaderKeyMixedValue *, const HTTPHeaderValueMixedValue *))(*((_QWORD *)this + 7) + 24))((char *)this + 56, a2, a3);
}

void `non-virtual thunk to'HTTPServerRequest::~HTTPServerRequest(HTTPServerRequest *this)
{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 8));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 8));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 56));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 56));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 104));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 104));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 112));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 112));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 120));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 120));
}

uint64_t `non-virtual thunk to'HTTPServerRequest::mutableVersion(HTTPServerRequest *this)
{
  return (uint64_t)this + 160;
}

uint64_t `non-virtual thunk to'HTTPServerRequest::mutableHeaders(HTTPServerRequest *this)
{
  return *((_QWORD *)this + 19);
}

uint64_t `non-virtual thunk to'HTTPServerRequest::parserCompleteFirstLine(HTTPServerRequest *this, const unsigned __int8 *a2)
{
  return (*(uint64_t (**)(char *, const unsigned __int8 *))(*((_QWORD *)this - 6) + 16))((char *)this - 48, a2);
}

uint64_t `non-virtual thunk to'HTTPServerRequest::parserAddHeader(HTTPServerRequest *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  return (*(uint64_t (**)(char *, const HTTPHeaderKeyMixedValue *, const HTTPHeaderValueMixedValue *))(*((_QWORD *)this - 6) + 24))((char *)this - 48, a2, a3);
}

uint64_t `non-virtual thunk to'HTTPServerRequest::openUnderlyingStream(HTTPServerRequest *this, CFStreamError *a2)
{
  HTTPServerRequest::signalReadStreamBasedOnState((HTTPServerRequest *)((char *)this - 120));
  return 0;
}

BOOL `non-virtual thunk to'HTTPServerRequest::canReadFromUnderlyingStream(HTTPServerRequest *this)
{
  return HTTPServerRequest::canReadFromUnderlyingStream((HTTPServerRequest *)((char *)this - 120));
}

uint64_t `non-virtual thunk to'HTTPServerRequest::readFromUnderlyingStream(HTTPServerRequest *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  return HTTPServerRequest::readFromUnderlyingStream((HTTPServerRequest *)((char *)this - 120), a2, a3, a4, a5);
}

uint64_t `non-virtual thunk to'HTTPServerRequest::closeUnderlyingStream(HTTPServerRequest *this)
{
  return HTTPServerRequest::closeUnderlyingStream((uint64_t)this - 120);
}

HTTPServerRequest *`non-virtual thunk to'HTTPServerRequest::_subclass_retain(HTTPServerRequest *this)
{
  CFRetain((char *)this - 136);
  return this;
}

void `non-virtual thunk to'HTTPServerRequest::_subclass_release(HTTPServerRequest *this)
{
  CFRelease((char *)this - 136);
}

uint64_t HTTPServerRequest::signalReadStreamBasedOnState(HTTPServerRequest *this)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD block[5];

  v2 = *((_QWORD *)this + 19);
  if (v2)
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
  result = *((_QWORD *)this + 16);
  if (result)
  {
    result = CFReadStreamGetStatus((CFReadStreamRef)result);
    if (result >= 2)
    {
      v4 = *((_QWORD *)this + 17);
      if (v4)
      {
        v5 = *((_QWORD *)this + 19);
        if (v5 && *(uint64_t *)(*(_QWORD *)(v5 + 136) + 40) > 0)
          v6 = 2;
        else
          v6 = 16 * (*((_DWORD *)this + 40) == 3);
        if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
        {
          v10 = *((_QWORD *)this + 17);
          dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
          v4 = v10;
        }
        v7 = *(NSObject **)(v4 + 104);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___ZN20HTTPServerConnection27signal_connection_off_queueEv_block_invoke_13755;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = v4 + 16;
        dispatch_async(v7, block);
      }
      else
      {
        v6 = 16 * (*((_DWORD *)this + 40) == 3);
      }
      result = *((_QWORD *)this + 16);
      if (v6)
        v8 = result == 0;
      else
        v8 = 1;
      if (!v8)
        result = _CFReadStreamSignalEventDelayed();
    }
  }
  *((_DWORD *)this + 41) = *((_DWORD *)this + 40);
  v9 = *((_QWORD *)this + 19);
  if (v9)
    return pthread_mutex_unlock((pthread_mutex_t *)(v9 + 24));
  return result;
}

void ___ZN20HTTPServerConnection27signal_connection_off_queueEv_block_invoke_13755(uint64_t a1)
{
  uint64_t v1;
  NSObject **v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = (NSObject **)(v1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));
  HTTPServerBase::signal(v2);
}

void HTTPServerRequest::~HTTPServerRequest(HTTPServerRequest *this)
{
  void **v2;
  const void *v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  uint8_t v7[16];

  *(_QWORD *)this = &off_1E14E8C38;
  *((_QWORD *)this + 1) = &unk_1E14E8CD0;
  *((_QWORD *)this + 7) = &unk_1E14E8CF0;
  v2 = (void **)((char *)this + 56);
  *((_QWORD *)this + 13) = &unk_1E14E8D30;
  *((_QWORD *)this + 14) = &unk_1E14E8D60;
  v3 = (const void *)*((_QWORD *)this + 16);
  *((_QWORD *)this + 15) = &unk_1E14E8D80;
  *((_QWORD *)this + 16) = 0;
  if (v3)
    CFRelease(v3);
  CFRelease((CFTypeRef)(*((_QWORD *)this + 26) - 16));
  v4 = *((_QWORD *)this + 19);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 18);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  dispatch_release(*((dispatch_object_t *)this + 29));
  if (*((_QWORD *)this + 17) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "fConnection should be null", v7, 2u);
  }
  *((_QWORD *)this + 27) = &off_1E14E9A00;
  v6 = (const void *)*((_QWORD *)this + 28);
  if (v6)
    CFRelease(v6);
  *((_QWORD *)this + 14) = &off_1E14E5838;
  HTTPRequestParserClient::~HTTPRequestParserClient(v2);
}

void sub_1840C42F4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  const void *v4;

  v1[27] = &off_1E14E9A00;
  v4 = (const void *)v1[28];
  if (v4)
    CFRelease(v4);
  v1[14] = &off_1E14E5838;
  HTTPRequestParserClient::~HTTPRequestParserClient(v2);
  _Unwind_Resume(a1);
}

void sub_1840C4390(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

uint64_t HTTPServerRequest::HTTPServerRequest(uint64_t a1, NSObject **cf)
{
  HTTPRequestParserClient *v4;
  CFAllocatorRef v5;
  const __CFAllocator *v6;
  HTTPHeaderDict *Instance;
  uint64_t v8;
  NSObject *v9;
  _QWORD *v10;

  *(_QWORD *)a1 = &off_1E14E82E0;
  *(_QWORD *)(a1 + 8) = &off_1E14EC470;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 48) = 0;
  v4 = (HTTPRequestParserClient *)(a1 + 56);
  v5 = CFGetAllocator(cf);
  HTTPRequestParserClient::HTTPRequestParserClient(v4, v5);
  *(_QWORD *)(a1 + 104) = &unk_1E14E8D30;
  *(_QWORD *)a1 = &off_1E14E8C38;
  *(_QWORD *)(a1 + 8) = &unk_1E14E8CD0;
  *(_QWORD *)(a1 + 56) = &unk_1E14E8CF0;
  *(_QWORD *)(a1 + 112) = &unk_1E14E8D60;
  *(_QWORD *)(a1 + 120) = &unk_1E14E8D80;
  *(_QWORD *)(a1 + 216) = &off_1E14EBF58;
  *(_QWORD *)(a1 + 224) = 0;
  v6 = CFGetAllocator((CFTypeRef)(a1 - 16));
  *(_QWORD *)(a1 + 128) = CFReadStreamCreate();
  if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
    dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
  Instance = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    *((_QWORD *)Instance + 2) = 0;
    *((_QWORD *)Instance + 3) = 0;
    Instance = (HTTPHeaderDict *)((char *)Instance + 16);
  }
  HTTPHeaderDict::HTTPHeaderDict(Instance);
  *(_QWORD *)(a1 + 208) = v8;
  *(_QWORD *)(a1 + 136) = CFRetain(cf);
  if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  v9 = cf[13];
  *(_QWORD *)(a1 + 232) = v9;
  dispatch_retain(v9);
  *(_DWORD *)(a1 + 160) = 0;
  v10 = CFAllocatorAllocate(v6, 592, 0);
  bzero((char *)v10 + 33, 0x20FuLL);
  *v10 = off_1E14E49E0;
  v10[1] = v6;
  v10[2] = &unk_1E14E4A00;
  v10[3] = a1 + 104;
  *((_BYTE *)v10 + 32) = 0;
  v10[71] = 512;
  v10[70] = (char *)v10 + 44;
  *((_OWORD *)v10 + 36) = xmmword_1841E38C0;
  *(_QWORD *)(a1 + 144) = v10;
  *(_QWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 168) = xmmword_1841E3940;
  return a1;
}

void sub_1840C45A4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  const void *v4;

  v1[27] = &off_1E14E9A00;
  v4 = (const void *)v1[28];
  if (v4)
    CFRelease(v4);
  v1[14] = &off_1E14E5838;
  HTTPRequestParserClient::~HTTPRequestParserClient(v2);
  _Unwind_Resume(a1);
}

uint64_t HTTPServerRequest::setRequestState(uint64_t result, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = result;
  v4 = *(_QWORD *)(result + 152);
  if (v4)
  {
    result = pthread_mutex_lock((pthread_mutex_t *)(v4 + 24));
    v5 = *(_QWORD *)(v3 + 152);
    *(_DWORD *)(v3 + 160) = a2;
    *(_DWORD *)(v3 + 164) = a2;
    if (v5)
      return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 24));
  }
  else
  {
    *(_DWORD *)(result + 160) = a2;
    *(_DWORD *)(result + 164) = a2;
  }
  return result;
}

void HTTPServerRequest::appendToBodyDataLocked(HTTPServerRequest *this, const unsigned __int8 *a2, int64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  const __CFAllocator *v10;
  _QWORD *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint8_t v15[16];

  if (!*((_QWORD *)this + 19) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v15 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "habeas corpus ad subjiciendum", v15, 2u);
  }
  if (a3 >= 1)
  {
    v6 = *((_QWORD *)this + 19);
    v7 = *(_QWORD *)(v6 + 136);
    v8 = *(_QWORD *)(v7 + 32);
    if (v8)
      v9 = (_QWORD *)(v8 + 16);
    else
      v9 = (_QWORD *)(v7 + 24);
    v10 = *(const __CFAllocator **)(v7 + 8);
    v11 = CFAllocatorAllocate(v10, (a3 & 0xFFFFFFFFFFFFFFF0) + 64, 0);
    *v11 = off_1E14EFF30;
    v11[1] = v10;
    v11[2] = 0;
    v11[3] = v11 + 5;
    v11[4] = (char *)v11 + a3 + 40;
    *v9 = v11;
    *(_QWORD *)(v7 + 32) = v11;
    v12 = *v9;
    v13 = (void *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v9 + 16))(*v9);
    memcpy(v13, a2, a3);
    v14 = *(_QWORD *)(v6 + 136);
    *(_QWORD *)(v12 + 32) = *(_QWORD *)(v12 + 24) + a3;
    *(_QWORD *)(v14 + 40) += a3;
    pthread_cond_signal((pthread_cond_t *)(v6 + 88));
  }
}

uint64_t HTTPServerRequest::requestState(HTTPServerRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 19);
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
    v3 = *((_QWORD *)this + 19);
    v4 = *((unsigned int *)this + 40);
    *((_DWORD *)this + 41) = v4;
    if (v3)
      pthread_mutex_unlock((pthread_mutex_t *)(v3 + 24));
  }
  else
  {
    v4 = *((unsigned int *)this + 40);
    *((_DWORD *)this + 41) = v4;
  }
  return v4;
}

uint64_t HTTPServerRequest::producerEOFEncountered(HTTPServerRequest *this)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 19);
  if (v2)
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
  v3 = *((_DWORD *)this + 40);
  if ((v3 - 1) >= 2)
  {
    if (!v3)
    {
      v3 = 4;
      *((_DWORD *)this + 40) = 4;
    }
  }
  else
  {
    *((_DWORD *)this + 40) = 3;
    v4 = *((_QWORD *)this + 19);
    if (!v4)
    {
      *((_DWORD *)this + 41) = 3;
      return HTTPServerRequest::signalReadStreamBasedOnState(this);
    }
    pthread_cond_signal((pthread_cond_t *)(v4 + 88));
    v3 = *((_DWORD *)this + 40);
  }
  v5 = *((_QWORD *)this + 19);
  *((_DWORD *)this + 41) = v3;
  if (v5)
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 24));
  return HTTPServerRequest::signalReadStreamBasedOnState(this);
}

CFStringRef HTTPServerRequest::copyProperty(HTTPServerRequest *this, CFStringRef theString)
{
  int ExactString;
  const void *v5;
  const void *v6;
  CFDictionaryRef *v8;
  char *v9;
  const __CFAllocator *v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  uint64_t Count;
  const void **v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  const char *v18;
  size_t v19;
  CFDictionaryRef *v20;
  const __CFAllocator *v21;
  void *MutableDictionary;
  const __CFDictionary *v23;
  const __CFAllocator *v24;
  const void *v25;
  const __CFAllocator *v26;
  CFArrayRef v27;
  const __CFAllocator *v28;
  void (**v29)(StringSerializable *__hidden);
  const __CFDictionary *v30;

  ExactString = _findExactString(theString, 9u);
  if (ExactString > 474175780)
  {
    switch(ExactString)
    {
      case 474175781:
        CFGetAllocator((char *)this - 16);
        v5 = (const void *)*((_QWORD *)this + 10);
        if (v5)
          return (CFStringRef)CFRetain(v5);
        break;
      case 475207987:
        v18 = (const char *)*((_QWORD *)this + 11);
        if (v18)
        {
          v19 = strlen(v18);
          return CFStringCreateWithBytes(*((CFAllocatorRef *)this + 8), (const UInt8 *)v18, v19, 0x201u, 0);
        }
        if (HTTPRequestParserClient::requestURL((HTTPServerRequest *)((char *)this + 56)))
          return CFURLCopyPath(*((CFURLRef *)this + 12));
        return 0;
      case 476248384:
        v5 = (const void *)HTTPRequestParserClient::requestURL((HTTPServerRequest *)((char *)this + 56));
        if (v5)
          return (CFStringRef)CFRetain(v5);
        break;
      default:
        goto LABEL_32;
    }
    return 0;
  }
  if (ExactString != 471062775)
  {
    if (ExactString == 472086791)
    {
      v8 = (CFDictionaryRef *)*((_QWORD *)this + 26);
      v9 = (char *)this - 16;
      v10 = CFGetAllocator((char *)this - 16);
      v11 = HTTPHeaderDict::copyAsOrdinaryDict(v8, v10);
      if (!v11)
      {
        v24 = CFGetAllocator((char *)this - 16);
        return (CFStringRef)cfTypeCreateMutableDictionary(v24, CFSTR("kCFHTTPServerRequestHeaderValues"), 0, CFSTR("kCFHTTPServerRequestHeaderOrder"), 0, 0, 0);
      }
      v12 = v11;
      Count = CFDictionaryGetCount(v11);
      v14 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
      CFDictionaryGetKeysAndValues(v12, v14, 0);
      if (Count >= 2)
      {
        v15 = 1;
        while (1)
        {
          v16 = (uint64_t)v14[v15];
          v17 = v16 >= (uint64_t)&gConstantCFStringValueTable[1897] && v16 < (uint64_t)&gConstantCFStringValueTable[2373];
          if (v17 && *(_DWORD *)(v16 + 32) == 309367554)
            break;
          if (Count == ++v15)
            goto LABEL_39;
        }
        v25 = *v14;
        *v14 = (const void *)v16;
        v14[v15] = v25;
      }
LABEL_39:
      v26 = CFGetAllocator(v12);
      v27 = CFArrayCreate(v26, v14, Count, MEMORY[0x1E0C9B378]);
      free(v14);
      v28 = CFGetAllocator(v9);
      MutableDictionary = cfTypeCreateMutableDictionary(v28, CFSTR("kCFHTTPServerRequestHeaderValues"), v12, CFSTR("kCFHTTPServerRequestHeaderOrder"), v27, 0, 0);
      if (v27)
        CFRelease(v27);
      v23 = v12;
LABEL_42:
      CFRelease(v23);
      return (CFStringRef)MutableDictionary;
    }
    if (ExactString == 473168149)
    {
      if (!*((_QWORD *)this + 28))
        return 0;
      CFGetAllocator((char *)this - 16);
      v5 = (const void *)*((_QWORD *)this + 28);
      if (!v5)
        return 0;
      return (CFStringRef)CFRetain(v5);
    }
LABEL_32:
    HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v29, theString);
    v20 = (CFDictionaryRef *)*((_QWORD *)this + 26);
    v21 = CFGetAllocator((char *)this - 16);
    MutableDictionary = (void *)HTTPHeaderDict::copyStringValue(v20, v21, (const HTTPHeaderKeyMixedValue *)&v29);
    v29 = &off_1E14E9A00;
    v23 = v30;
    if (!v30)
      return (CFStringRef)MutableDictionary;
    goto LABEL_42;
  }
  v6 = (const void *)*((_QWORD *)this + 17);
  if (!v6)
    return 0;
  if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  return (CFStringRef)CFRetain(v6);
}

void sub_1840C4B68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPServerRequest::remainingBodySize(HTTPServerRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 19);
  if (v2 && (pthread_mutex_lock((pthread_mutex_t *)(v2 + 24)), (v3 = *((_QWORD *)this + 19)) != 0))
  {
    v4 = *(_QWORD *)(*(_QWORD *)(v3 + 136) + 40);
    *((_DWORD *)this + 41) = *((_DWORD *)this + 40);
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 24));
  }
  else
  {
    v4 = 0;
    *((_DWORD *)this + 41) = *((_DWORD *)this + 40);
  }
  return v4;
}

void HTTPServerRequest::loseConnectionReferenceAndTerminateReads(HTTPServerRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  const void *v6;
  uint64_t v7;

  v2 = *((_QWORD *)this + 19);
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
    v3 = *((_QWORD *)this + 19);
    if (v3)
      pthread_cond_signal((pthread_cond_t *)(v3 + 88));
  }
  v4 = (const void *)*((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v4)
    CFRelease(v4);
  v5 = *((unsigned int *)this + 40);
  if (v5 <= 2)
  {
    LODWORD(v5) = dword_18411E1EC[v5];
    *((_DWORD *)this + 40) = v5;
  }
  v6 = (const void *)*((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v6)
  {
    CFRelease(v6);
    LODWORD(v5) = *((_DWORD *)this + 40);
  }
  *((_DWORD *)this + 41) = v5;
  v7 = *((_QWORD *)this + 19);
  if (v7)
    pthread_mutex_unlock((pthread_mutex_t *)(v7 + 24));
}

CFStringRef HTTPServerResponse::copyDebugDesc(HTTPServerResponse *this)
{
  CFStringRef v2;
  const __CFAllocator *v3;
  const char *v4;
  CFStringRef v5;

  v2 = CFObject::copyDebugDescHeader(this);
  v3 = CFGetAllocator((char *)this - 16);
  if (*((_BYTE *)this + 136))
    v4 = "completed";
  else
    v4 = "incomplete";
  v5 = CFStringCreateWithFormat(v3, 0, CFSTR("%@ { %@ %s }>"), v2, *((_QWORD *)this + 12), v4);
  if (v2)
    CFRelease(v2);
  return v5;
}

uint64_t HTTPServerResponse::openUnderlyingStream(HTTPServerResponse *this, CFStreamError *a2)
{
  CFStringRef v4;
  __CFHTTPMessage *v5;
  BOOL v6;
  const __CFString *v7;
  const __CFString *v8;
  int v9;
  __CFReadStream *v10;
  const __CFString *v11;
  const __CFString *v12;
  CFTypeID v13;
  const __CFString *v14;
  int v15;
  const __CFString *v16;
  int v17;
  const __CFString *v18;
  const __CFString *v19;
  int CanonicalString;
  _BOOL4 v21;
  CFDataRef v22;
  const __CFData *v23;
  __CFHTTPMessage *v24;
  const __CFAllocator *v25;
  CFIndex Length;
  __CFHTTPMessage *v27;
  const __CFAllocator *v28;
  const __CFString *v29;
  const __CFString *v30;
  __CFHTTPMessage *v31;
  const __CFAllocator *v32;
  uint64_t v33;
  uint64_t v34;
  __CFReadStream *v35;
  unsigned int valuePtr;
  CFStreamClientContext clientContext;
  uint64_t v39;
  CFRange v40;
  CFRange v41;

  v39 = *MEMORY[0x1E0C80C00];
  v4 = CFHTTPMessageCopyHeaderFieldValue(*((CFHTTPMessageRef *)this + 12), (CFStringRef)&unk_1EDCFCE80);
  if (v4)
  {
    CFRelease(v4);
  }
  else
  {
    v7 = CFHTTPMessageCopyHeaderFieldValue(*((CFHTTPMessageRef *)this + 12), CFSTR("Content-Type"));
    if (!v7
      || (v8 = v7,
          v40.length = CFStringGetLength(v7),
          v40.location = 0,
          v9 = CFStringFindWithOptions(v8, CFSTR("multipart/x-mixed-replace"), v40, 1uLL, 0),
          CFRelease(v8),
          !v9))
    {
      v10 = (__CFReadStream *)*((_QWORD *)this + 14);
      if (v10)
      {
        v11 = (const __CFString *)CFReadStreamCopyProperty(v10, CFSTR("kCFStreamPropertyStreamLength"));
        valuePtr = -1;
        if (!v11)
          goto LABEL_33;
        v12 = v11;
        v13 = CFGetTypeID(v11);
        if (v13 == CFStringGetTypeID())
        {
          valuePtr = CFStringGetIntValue(v12);
        }
        else if (v13 == CFNumberGetTypeID() && !CFNumberGetValue((CFNumberRef)v12, kCFNumberSInt32Type, &valuePtr))
        {
          valuePtr = -1;
        }
        CFRelease(v12);
        if (valuePtr == -1)
        {
LABEL_33:
          v29 = CFHTTPMessageCopyHeaderFieldValue(*((CFHTTPMessageRef *)this + 12), (CFStringRef)&unk_1EDCFD778);
          v30 = v29;
          if (v29)
          {
            v41.length = CFStringGetLength(v29);
            v41.location = 0;
            if (!CFStringFindWithOptions(v30, CFSTR("chunked"), v41, 1uLL, 0))
            {
              v31 = (__CFHTTPMessage *)*((_QWORD *)this + 12);
              v32 = CFGetAllocator((char *)this - 16);
              AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)&clientContext, v32, CFSTR("%@%@"), v30, 0x1EDCFDA50);
              CFHTTPMessageSetHeaderFieldValue(v31, (CFStringRef)&unk_1EDCFD778, (CFStringRef)clientContext.info);
              AutoString::~AutoString((AutoString *)&clientContext);
            }
            CFRelease(v30);
          }
          else
          {
            CFHTTPMessageSetHeaderFieldValue(*((CFHTTPMessageRef *)this + 12), (CFStringRef)&unk_1EDCFD778, CFSTR("chunked"));
          }
          *((_BYTE *)this + 104) = 1;
        }
        else
        {
          v27 = (__CFHTTPMessage *)*((_QWORD *)this + 12);
          v28 = CFGetAllocator((char *)this - 16);
          AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)&clientContext, v28, CFSTR("%d"), valuePtr);
          CFHTTPMessageSetHeaderFieldValue(v27, (CFStringRef)&unk_1EDCFCE80, (CFStringRef)clientContext.info);
          AutoString::~AutoString((AutoString *)&clientContext);
        }
      }
      else
      {
        v22 = CFHTTPMessageCopyBody(*((CFHTTPMessageRef *)this + 12));
        if (v22)
        {
          v23 = v22;
          v24 = (__CFHTTPMessage *)*((_QWORD *)this + 12);
          v25 = CFGetAllocator((char *)this - 16);
          Length = CFDataGetLength(v23);
          AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)&clientContext, v25, CFSTR("%ld"), Length);
          CFHTTPMessageSetHeaderFieldValue(v24, (CFStringRef)&unk_1EDCFCE80, (CFStringRef)clientContext.info);
          AutoString::~AutoString((AutoString *)&clientContext);
          CFRelease(v23);
        }
      }
    }
  }
  v5 = (__CFHTTPMessage *)*((_QWORD *)this + 12);
  if (v5)
  {
    if (CFHTTPMessageGetResponseStatusCode(v5) == 100)
    {
      v6 = 0;
      goto LABEL_40;
    }
    v5 = (__CFHTTPMessage *)*((_QWORD *)this + 12);
  }
  v14 = CFHTTPMessageCopyHeaderFieldValue(v5, CFSTR("Connection"));
  v15 = figureCloseKind(v14);
  if (v14)
    CFRelease(v14);
  if (v15)
  {
    v6 = v15 == 2;
    goto LABEL_40;
  }
  v16 = HTTPServerRequest::copyProperty(*((HTTPServerRequest **)this + 10), CFSTR("Connection"));
  v17 = figureCloseKind(v16);
  v18 = CFHTTPMessageCopyVersion(*((CFHTTPMessageRef *)this + 12));
  v19 = v18;
  if (!v18)
  {
    if (v17)
    {
      v6 = v17 == 2;
      goto LABEL_23;
    }
    v21 = 0;
LABEL_38:
    v6 = !v21;
    if (!v16)
      goto LABEL_40;
    goto LABEL_39;
  }
  CanonicalString = _findCanonicalString(v18, 8u);
  v21 = CanonicalString == 426841912;
  CFRelease(v19);
  if (!v17)
    goto LABEL_38;
  v6 = v17 == 2;
  if (CanonicalString != 426841912)
LABEL_23:
    CFHTTPMessageSetHeaderFieldValue(*((CFHTTPMessageRef *)this + 12), CFSTR("Connection"), v16);
  if (v16)
LABEL_39:
    CFRelease(v16);
LABEL_40:
  *((_BYTE *)this + 105) = v6;
  if (*((_QWORD *)this + 14))
  {
    v33 = (*(uint64_t (**)(HTTPServerResponse *))(*(_QWORD *)this + 104))(this);
    *((_QWORD *)this + 15) = v33;
    if (v33)
    {
      clientContext.version = 0;
      clientContext.info = this;
      clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
      clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
      clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
      CFReadStreamSetClient(*((CFReadStreamRef *)this + 14), 0x1AuLL, (CFReadStreamClientCallBack)HTTPServerResponse::_readStreamCallback, &clientContext);
      CoreSchedulingSet::scheduleStream(*((CoreSchedulingSet **)this + 15), *((__CFReadStream **)this + 14));
      if (CFReadStreamOpen(*((CFReadStreamRef *)this + 14)))
        goto LABEL_43;
      if (a2)
        *a2 = CFReadStreamGetError((CFReadStreamRef)*((_QWORD *)this + 14));
    }
    else if (a2)
    {
      a2->domain = 1;
      a2->error = 22;
    }
    return 2;
  }
LABEL_43:
  if (*((_BYTE *)this + 104))
  {
    v34 = operator new();
    v35 = (__CFReadStream *)*((_QWORD *)this + 14);
    ResponseDataCombiner::ResponseDataCombiner((ResponseDataCombiner *)v34, *((CFHTTPMessageRef *)this + 12), v35);
    *(_QWORD *)v34 = &off_1E14EDB38;
    *(_QWORD *)(v34 + 56) = 0;
    *(_QWORD *)(v34 + 64) = 0;
    *(_QWORD *)(v34 + 48) = v34 + 72;
    *(_QWORD *)(v34 + 112) = 0;
    *(_QWORD *)(v34 + 120) = 0;
    *(_QWORD *)(v34 + 104) = v34 + 128;
    if (!v35 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(clientContext.version) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "If you don't have a body stream, you don't need to be chunked.", (uint8_t *)&clientContext, 2u);
    }
    *(_DWORD *)(v34 + 40) = 0;
    *(_WORD *)(v34 + 32896) = 0;
  }
  else
  {
    v34 = operator new();
    ResponseDataCombiner::ResponseDataCombiner((ResponseDataCombiner *)v34, *((CFHTTPMessageRef *)this + 12), *((__CFReadStream **)this + 14));
  }
  *((_QWORD *)this + 16) = v34;
  if (!*((_QWORD *)this + 14))
    _CFReadStreamSignalEventDelayed();
  return 0;
}

void sub_1840C528C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

uint64_t HTTPServerResponse::canReadFromUnderlyingStream(HTTPServerResponse *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 16);
  if (result)
    return (*(unsigned int (**)(uint64_t))(*(_QWORD *)result + 16))(result) != 0;
  return result;
}

uint64_t HTTPServerResponse::readFromUnderlyingStream(HTTPServerResponse *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  uint64_t result;
  _QWORD v8[6];

  result = *((_QWORD *)this + 16);
  if (result)
  {
    memset(&v8[2], 0, 32);
    v8[0] = a2;
    v8[1] = a3;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 24))(result, v8);
    result = v8[2];
    if (v8[2] > -2)
    {
      if (LOBYTE(v8[5]))
        *a5 = 1;
    }
    else if (a4)
    {
      *a4 = *(CFStreamError *)&v8[3];
    }
    if (BYTE1(v8[5]) | LOBYTE(v8[5]))
    {
      _CFReadStreamSignalEventDelayed();
      return v8[2];
    }
  }
  else
  {
    *a5 = 1;
  }
  return result;
}

void HTTPServerResponse::closeUnderlyingStream(HTTPServerResponse *this)
{
  uint64_t v2;
  const void *v3;
  uint64_t v4;
  _QWORD v5[5];

  v2 = *((_QWORD *)this + 16);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 16) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 14);
  if (v3)
  {
    v4 = *((_QWORD *)this + 15);
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 15) = 0;
    if (v4)
    {
      v5[0] = MEMORY[0x1E0C809B0];
      v5[1] = 3221225472;
      v5[2] = ___ZN18HTTPServerResponse21closeUnderlyingStreamEv_block_invoke;
      v5[3] = &__block_descriptor_40_e5_v8__0l;
      v5[4] = v3;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    }
    else
    {
      CFRelease(v3);
    }
  }
  *((_BYTE *)this + 136) = 1;
}

uint64_t HTTPServerResponse::_subclass_retain(HTTPServerResponse *this)
{
  CFRetain((char *)this - 16);
  return (uint64_t)this + 64;
}

void HTTPServerResponse::_subclass_release(HTTPServerResponse *this)
{
  CFRelease((char *)this - 16);
}

CFAllocatedReferenceCountedObject *HTTPServerResponse::coreStreamCopySchedulingInfo(CFAllocatedReferenceCountedObject *this, void *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 10);
  if (!v2)
    return (CFAllocatedReferenceCountedObject *)CoreSchedulingSet::createEmpty((CoreSchedulingSet *)this);
  v3 = *(_QWORD *)(v2 + 136);
  if (!v3)
    return (CFAllocatedReferenceCountedObject *)CoreSchedulingSet::createEmpty((CoreSchedulingSet *)this);
  if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  this = CoreSchedulingSet::createWithDispatchQueue(*(CoreSchedulingSet **)(v3 + 104), a2);
  if (!this)
    return (CFAllocatedReferenceCountedObject *)CoreSchedulingSet::createEmpty((CoreSchedulingSet *)this);
  return this;
}

void `non-virtual thunk to'HTTPServerResponse::~HTTPServerResponse(HTTPServerResponse *this)
{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 8));
}

{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 8));
}

{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 56));
}

{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 56));
}

{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 64));
}

{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 64));
}

uint64_t `non-virtual thunk to'HTTPServerResponse::openUnderlyingStream(HTTPServerResponse *this, CFStreamError *a2)
{
  return HTTPServerResponse::openUnderlyingStream((HTTPServerResponse *)((char *)this - 64), a2);
}

uint64_t `non-virtual thunk to'HTTPServerResponse::canReadFromUnderlyingStream(HTTPServerResponse *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 8);
  if (result)
    return (*(unsigned int (**)(uint64_t))(*(_QWORD *)result + 16))(result) != 0;
  return result;
}

uint64_t `non-virtual thunk to'HTTPServerResponse::readFromUnderlyingStream(HTTPServerResponse *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  return HTTPServerResponse::readFromUnderlyingStream((HTTPServerResponse *)((char *)this - 64), a2, a3, a4, a5);
}

void `non-virtual thunk to'HTTPServerResponse::closeUnderlyingStream(HTTPServerResponse *this)
{
  HTTPServerResponse::closeUnderlyingStream((HTTPServerResponse *)((char *)this - 64));
}

HTTPServerResponse *`non-virtual thunk to'HTTPServerResponse::_subclass_retain(HTTPServerResponse *this)
{
  CFRetain((char *)this - 80);
  return this;
}

void `non-virtual thunk to'HTTPServerResponse::_subclass_release(HTTPServerResponse *this)
{
  CFRelease((char *)this - 80);
}

void HTTPServerResponse::~HTTPServerResponse(HTTPServerResponse *this)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  const void *v6;

  *(_QWORD *)this = &off_1E14E97E8;
  *((_QWORD *)this + 1) = &unk_1E14E9868;
  *((_QWORD *)this + 7) = &unk_1E14E9888;
  *((_QWORD *)this + 8) = &unk_1E14E98A8;
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    CFRelease((CFTypeRef)(v2 - 16));
    *((_QWORD *)this + 10) = 0;
  }
  v3 = *((_QWORD *)this + 16);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    *((_QWORD *)this + 16) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 12);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 11);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v6)
    CFRelease(v6);
  *((_QWORD *)this + 7) = &off_1E14E5838;
}

void sub_1840C5658(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 56) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ___ZN18HTTPServerResponse21closeUnderlyingStreamEv_block_invoke(uint64_t a1)
{
  const void *v2;

  CFReadStreamSetClient(*(CFReadStreamRef *)(a1 + 32), 0, 0, 0);
  CFReadStreamClose(*(CFReadStreamRef *)(a1 + 32));
  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
}

uint64_t HTTPServerResponse::_readStreamCallback(HTTPServerResponse *this, __CFReadStream *a2, unint64_t a3, void *a4)
{
  return _CFReadStreamSignalEventDelayed();
}

uint64_t figureCloseKind(CFStringRef theString)
{
  uint64_t v1;
  int CanonicalString;
  CFArrayRef ArrayBySeparatingStrings;
  const __CFArray *v4;
  unint64_t Count;
  CFRange v6;
  const void **v7;
  CFIndex v8;
  int v9;
  CFTypeRef v11;
  CFIndex range;
  const void **v13;
  _BYTE v14[248];
  CFIndex v15;

  v1 = (uint64_t)theString;
  if (!theString)
    return v1;
  CanonicalString = _findCanonicalString(theString, 6u);
  if (CanonicalString == 370234505)
    return 1;
  if (CanonicalString == 363902060)
    return 2;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFStringRef)v1, CFSTR(", "));
  if (!ArrayBySeparatingStrings)
  {
    v11 = 0;
    range = 0;
    v13 = (const void **)v14;
    v15 = 0;
    goto LABEL_16;
  }
  v4 = ArrayBySeparatingStrings;
  v11 = CFRetain(ArrayBySeparatingStrings);
  Count = CFArrayGetCount(v4);
  v6.length = Count;
  range = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v13 = 0;
    goto LABEL_15;
  }
  if (Count > 0x1E)
  {
    v7 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v13 = v7;
    if (!v7)
      goto LABEL_15;
    v6.length = range;
  }
  else
  {
    v7 = (const void **)v14;
    v13 = (const void **)v14;
  }
  v6.location = 0;
  CFArrayGetValues(v4, v6, v7);
LABEL_15:
  v15 = 0;
  CFRelease(v4);
  while (1)
  {
LABEL_16:
    v8 = v15;
    if (v15 >= range)
    {
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v11);
      return 0;
    }
    ++v15;
    v9 = _findCanonicalString((CFStringRef)v13[v8], 6u);
    if (v9 == 363902060)
      break;
    if (v9 == 370234505)
    {
      v1 = 1;
      goto LABEL_22;
    }
  }
  v1 = 2;
LABEL_22:
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v11);
  return v1;
}

void sub_1840C5870(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void sub_1840C58F8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

void HTTPServerResponse::HTTPServerResponse(HTTPServerResponse *this, HTTPServerRequest *a2)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_QWORD *)this = &off_1E14E97E8;
  *((_QWORD *)this + 1) = &unk_1E14E9868;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = &unk_1E14E9888;
  *((_QWORD *)this + 8) = &unk_1E14E98A8;
  CFGetAllocator((char *)this - 16);
  *((_QWORD *)this + 9) = CFReadStreamCreate();
  *((_QWORD *)this + 10) = a2;
  CFRetain((char *)a2 - 16);
  *((_BYTE *)this + 104) = 0;
  *((_BYTE *)this + 136) = 0;
}

void sub_1840C59B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 56) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ResponseDataCombiner::~ResponseDataCombiner(ResponseDataCombiner *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E14EBA28;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E14E5838;
}

{
  const void *v2;

  *(_QWORD *)this = &off_1E14EBA28;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

void sub_1840C5A10(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_1840C5A78(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t ResponseDataCombiner::canRead(ResponseDataCombiner *this)
{
  uint64_t result;

  if (*((_QWORD *)this + 1) && *((_QWORD *)this + 2) < *((_QWORD *)this + 3))
    return 1;
  result = *((_QWORD *)this + 4);
  if (result)
    return CFReadStreamHasBytesAvailable((CFReadStreamRef)result) != 0;
  return result;
}

void ResponseDataCombiner::read(_QWORD *a1, uint64_t a2)
{
  __CFReadStream *v4;

  if (*(uint64_t *)(a2 + 8) >= 1)
  {
    if (!a1[1] || a1[2] >= a1[3] || (ResponseDataCombiner::readHeaderData((uint64_t)a1, a2), *(uint64_t *)(a2 + 8) >= 1))
    {
      v4 = (__CFReadStream *)a1[4];
      if (!v4)
        goto LABEL_9;
      if (CFReadStreamHasBytesAvailable(v4))
      {
        ResponseDataCombiner::readBodyStreamData((uint64_t)a1, a2);
        return;
      }
      if (!a1[4])
LABEL_9:
        *(_BYTE *)(a2 + 40) = 1;
      *(_BYTE *)(a2 + 41) = 1;
    }
  }
}

void ResponseDataCombiner::readHeaderData(uint64_t a1, uint64_t a2)
{
  CFRange v4;
  _QWORD *v5;
  CFIndex v6;
  CFIndex v7;
  CFIndex v8;
  CFIndex v9;
  const void *v10;

  v4.location = *(_QWORD *)(a1 + 16);
  v5 = (_QWORD *)(a1 + 16);
  if (*(_QWORD *)(a2 + 8) >= *(_QWORD *)(a1 + 24) - v4.location)
    v6 = *(_QWORD *)(a1 + 24) - v4.location;
  else
    v6 = *(_QWORD *)(a2 + 8);
  v4.length = v6;
  CFDataGetBytes(*(CFDataRef *)(a1 + 8), v4, *(UInt8 **)a2);
  v7 = *(_QWORD *)(a2 + 8) - v6;
  *(_QWORD *)a2 += v6;
  *(_QWORD *)(a2 + 8) = v7;
  *(_QWORD *)(a2 + 16) += v6;
  v8 = v5[1];
  v9 = *v5 + v6;
  *v5 = v9;
  if (v9 >= v8)
  {
    v10 = *(const void **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = 0;
    if (v10)
      CFRelease(v10);
    *v5 = 0;
    v5[1] = 0;
  }
  else
  {
    *(_BYTE *)(a2 + 41) = 1;
  }
}

CFIndex ResponseDataCombiner::readBodyStreamData(uint64_t a1, uint64_t a2)
{
  CFIndex v4;
  CFIndex result;
  CFStreamError Error;
  CFIndex v7;
  BOOL v8;

  v4 = CFReadStreamRead(*(CFReadStreamRef *)(a1 + 32), *(UInt8 **)a2, *(_QWORD *)(a2 + 8));
  Error = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)(a1 + 32));
  result = Error.domain;
  *(CFStreamError *)(a2 + 24) = Error;
  if (v4)
  {
    if (v4 < 1)
      return result;
    v7 = *(_QWORD *)(a2 + 8) - v4;
    *(_QWORD *)a2 += v4;
    *(_QWORD *)(a2 + 8) = v7;
    *(_QWORD *)(a2 + 16) += v4;
    result = CFReadStreamGetStatus(*(CFReadStreamRef *)(a1 + 32));
    v8 = result == 5;
  }
  else
  {
    v8 = 1;
  }
  *(_BYTE *)(a2 + 40) = v8;
  return result;
}

void ResponseDataCombiner::ResponseDataCombiner(ResponseDataCombiner *this, CFHTTPMessageRef message, __CFReadStream *a3)
{
  const __CFData *Length;

  *(_QWORD *)this = &off_1E14EBA28;
  Length = CFHTTPMessageCopySerializedMessage(message);
  *((_QWORD *)this + 1) = Length;
  *((_QWORD *)this + 2) = 0;
  if (Length)
    Length = (const __CFData *)CFDataGetLength(Length);
  *((_QWORD *)this + 3) = Length;
  *((_QWORD *)this + 4) = a3;
}

void sub_1840C5CCC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

_QWORD *std::ifstream::~ifstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F40];
  v3 = *MEMORY[0x1E0DE4F40];
  *a1 = *MEMORY[0x1E0DE4F40];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x186DB7354](a1 + 2);
  std::istream::~istream();
  MEMORY[0x186DB7438](a1 + 53);
  return a1;
}

void CoreDiagMsg::~CoreDiagMsg(const __CFArray **this)
{
  CoreDiagMsg::~CoreDiagMsg(this);
  JUMPOUT(0x186DB748CLL);
}

{
  __CFData *Mutable;
  NSObject *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  uint8_t buf[4];
  const UInt8 *BytePtr;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  *this = (const __CFArray *)&off_1E14E4CF0;
  if (CoreDiagMsg::~CoreDiagMsg()::onceToken != -1)
    dispatch_once(&CoreDiagMsg::~CoreDiagMsg()::onceToken, &__block_literal_global_8_13858);
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  mdPrintf(Mutable, 0, CFSTR("CFNetwork Diagnostics [%d:%d] %s {\n"), *((unsigned int *)this + 2), *((unsigned int *)this + 22), (char *)this + 92);
  flattenDict0(Mutable, 0, this[3], this[2]);
  mdPrintf(Mutable, 0, CFSTR("} [%d:%d]\n"), *((unsigned int *)this + 2), *((unsigned int *)this + 22));
  CFDataAppendBytes(Mutable, byte_18411E1F8, 1);
  v3 = CoreDiagMsg::~CoreDiagMsg()::l;
  if (os_log_type_enabled((os_log_t)CoreDiagMsg::~CoreDiagMsg()::l, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    BytePtr = CFDataGetBytePtr(Mutable);
    _os_log_impl(&dword_183ECA000, v3, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }
  if (Mutable)
    CFRelease(Mutable);
  v4 = this[3];
  if (v4)
    CFRelease(v4);
  v5 = this[2];
  if (v5)
    CFRelease(v5);
}

uint64_t CoreDiagMsg::initialize(CFMutableArrayRef *this, const char *a2, void *a3)
{
  CoreDiagMsg::_addPair(this, a2, 0);
  return 1;
}

uint64_t CoreDiagMsg::initialize(CFMutableArrayRef *this, const char *a2, const CFObject *a3, ...)
{
  const __CFString *v5;

  if (!a3)
    return (*((uint64_t (**)(CFMutableArrayRef *, const char *))*this + 2))(this, a2);
  v5 = (const __CFString *)(*(uint64_t (**)(const CFObject *))(*(_QWORD *)a3 + 32))(a3);
  CoreDiagMsg::_addPair(this, a2, v5);
  if (v5)
    CFRelease(v5);
  return 1;
}

uint64_t CoreDiagMsg::initialize(CFMutableArrayRef *this, const char *a2, const CFAllocatedReferenceCountedObject *a3, ...)
{
  const __CFString *v5;

  if (!a3)
    return (*((uint64_t (**)(CFMutableArrayRef *, const char *))*this + 2))(this, a2);
  v5 = (const __CFString *)(*(uint64_t (**)(const CFAllocatedReferenceCountedObject *))(*(_QWORD *)a3 + 16))(a3);
  CoreDiagMsg::_addPair(this, a2, v5);
  if (v5)
    CFRelease(v5);
  return 1;
}

void CoreDiagMsg::logPair(CoreDiagMsg *this, const char *a2, const __CFURL *a3)
{
  const __CFAllocator *v5;
  CFStringRef v6;
  const __CFString *v7;
  void (**v8)(AutoString *__hidden);
  CFStringRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = &off_1E14E4818;
  v10 = 0;
  v11 = 0;
  v9 = CFStringCreateWithCString(v5, a2, 0x8000100u);
  if (a3)
  {
    if (__CFNCanLogSensitiveContent::onceToken != -1)
      dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
    if (__CFNCanLogSensitiveContent::ok || _CFURLIsFileURL())
      v6 = CFCopyDescription(a3);
    else
      v6 = CFStringCreateWithFormat(v5, 0, CFSTR("%@://%@/<redacted>"), -[__CFURL scheme](a3, "scheme"), -[__CFURL host](a3, "host"), v8);
    v7 = v6;
  }
  else
  {
    v7 = CFSTR("null");
  }
  (*(void (**)(CoreDiagMsg *, CFStringRef, const __CFString *))(*(_QWORD *)this + 64))(this, v9, v7);
  if (a3 && v7)
    CFRelease(v7);
  AutoString::~AutoString((AutoString *)&v8);
}

void sub_1840C5FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void CoreDiagMsg::logPair(CoreDiagMsg *this, const char *a2, NSURLRequest *a3)
{
  const __CFAllocator *v5;
  CFStringRef v6;
  void *v7;
  const __CFString *v8;
  CFStringRef v9;
  void (**v10)(AutoString *__hidden);
  CFStringRef v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v10 = &off_1E14E4818;
  v6 = CFStringCreateWithCString(v5, a2, 0x8000100u);
  v12 = 0;
  v13 = 0;
  v11 = v6;
  if (a3)
  {
    v7 = -[NSURLRequest _inner](a3, "_inner", v10);
    v8 = (const __CFString *)(*(uint64_t (**)(void *))(*(_QWORD *)v7 + 24))(v7);
    v9 = v11;
  }
  else
  {
    v9 = v6;
    v8 = CFSTR("null");
  }
  (*(void (**)(CoreDiagMsg *, CFStringRef, const __CFString *))(*(_QWORD *)this + 64))(this, v9, v8);
  if (a3 && v8)
    CFRelease(v8);
  AutoString::~AutoString((AutoString *)&v10);
}

void sub_1840C60B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  AutoString::~AutoString((AutoString *)&a9);
  _Unwind_Resume(a1);
}

void CoreDiagMsg::logPair(CoreDiagMsg *this, const char *a2, __CFError *a3)
{
  const __CFAllocator *v5;
  CFStringRef v6;
  const __CFString *v7;
  void (**v8)(AutoString *__hidden);
  CFStringRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = &off_1E14E4818;
  v10 = 0;
  v11 = 0;
  v9 = CFStringCreateWithCString(v5, a2, 0x8000100u);
  if (a3)
  {
    if (__CFNCanLogSensitiveContent::onceToken != -1)
      dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
    if (__CFNCanLogSensitiveContent::ok)
      v6 = CFCopyDescription(a3);
    else
      v6 = (CFStringRef)objc_msgSend((id)-[__CFError redactedDescription](a3, "redactedDescription", v8), "copy");
    v7 = v6;
  }
  else
  {
    v7 = CFSTR("null");
  }
  (*(void (**)(CoreDiagMsg *, CFStringRef, const __CFString *))(*(_QWORD *)this + 64))(this, v9, v7);
  if (a3 && v7)
    CFRelease(v7);
  AutoString::~AutoString((AutoString *)&v8);
}

void sub_1840C61E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  AutoString::~AutoString((AutoString *)&a9);
  _Unwind_Resume(a1);
}

void CoreDiagMsg::logFormat(CFMutableArrayRef *this, const char *a2, const __CFString *a3, ...)
{
  const __CFString *v5;
  va_list va;

  va_start(va, a3);
  v5 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a3, va);
  CoreDiagMsg::_addPair(this, a2, v5);
  if (v5)
    CFRelease(v5);
}

void CoreDiagMsg::logDict(CFMutableArrayRef *this, const char *a2, const __CFArray *a3, const __CFDictionary *a4)
{
  __CFDictionary *MutableCopy;

  if (a3)
  {
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a4);
    CFDictionarySetValue(MutableCopy, CFSTR("<< ORDER >>"), a3);
    CoreDiagMsg::_addPair(this, a2, (const __CFString *)MutableCopy);
    if (MutableCopy)
      CFRelease(MutableCopy);
  }
  else
  {
    CoreDiagMsg::_addPair(this, a2, (const __CFString *)a4);
  }
}

void CoreDiagMsg::logHex(CFMutableArrayRef *this, const char *a2, UInt8 *bytes, CFIndex length)
{
  const __CFString *v6;

  v6 = (const __CFString *)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, length);
  CoreDiagMsg::_addPair(this, a2, v6);
  if (v6)
    CFRelease(v6);
}

void CoreDiagMsg::_addPair(CFMutableArrayRef *this, const char *a2, const __CFString *a3)
{
  const __CFAllocator *v5;
  void (**v6)(AutoString *__hidden);
  const __CFString *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = &off_1E14E4818;
  v8 = 0;
  v9 = 0;
  v7 = CFStringCreateWithCString(v5, a2, 0x8000100u);
  CoreDiagMsg::_addPair(this, v7, a3);
  AutoString::~AutoString((AutoString *)&v6);
}

void sub_1840C641C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  AutoString::~AutoString((AutoString *)&a9);
  _Unwind_Resume(a1);
}

void CoreDiagMsg::_addPair(CFMutableArrayRef *this, const __CFString *a2, const __CFString *a3)
{
  const __CFString *v6;

  if (a2)
  {
    CFArrayAppendValue(this[3], a2);
    if (a3)
      v6 = a3;
    else
      v6 = CFSTR("(null)");
    CFDictionarySetValue(this[2], a2, v6);
  }
}

CFIndex mdPrintf(CFMutableDataRef theData, uint64_t a2, CFStringRef format, ...)
{
  uint64_t v6;
  const __CFAllocator *v7;
  const __CFString *v8;
  const __CFData *ExternalRepresentation;
  CFIndex Length;
  const UInt8 *BytePtr;
  va_list va;

  va_start(va, format);
  if (a2 >= 1)
  {
    v6 = a2;
    do
    {
      CFDataAppendBytes(theData, (const UInt8 *)" ", 1);
      --v6;
    }
    while (v6);
  }
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, format, va);
  if (format)
    CFRelease(format);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v7, v8, 0x8000100u, 0x2Eu);
  if (v8)
    CFRelease(v8);
  Length = CFDataGetLength(ExternalRepresentation);
  BytePtr = CFDataGetBytePtr(ExternalRepresentation);
  CFDataAppendBytes(theData, BytePtr, Length);
  if (ExternalRepresentation)
    CFRelease(ExternalRepresentation);
  return Length + a2;
}

void flattenDict0(__CFData *a1, uint64_t a2, const __CFArray *a3, const __CFDictionary *a4)
{
  const __CFArray *Mutable;
  const void *Value;
  unint64_t Count;
  CFRange v9;
  const void **v10;
  CFIndex v11;
  uint64_t v12;
  const __CFString *v13;
  CFIndex Length;
  unint64_t v15;
  CFRange v16;
  const void **v17;
  CFIndex v18;
  const __CFString *v19;
  const __CFDictionary *v20;
  const __CFDictionary *v21;
  CFTypeID v22;
  const __CFString *v23;
  CFIndex v24;
  CFTypeID TypeID;
  CFIndex v26;
  CFIndex v27;
  CFIndex v28;
  unint64_t v29;
  const void **v30;
  CFRange v31;
  CFIndex v32;
  CFIndex v33;
  CFIndex v34;
  const __CFData *v35;
  const __CFString *v36;
  CFIndex v37;
  __CFArray *v38;
  const void **v39;
  const __CFArray *v40;
  unint64_t v41;
  CFRange v42;
  const void **v43;
  CFIndex v44;
  uint64_t v45;
  CFTypeRef v47;
  CFIndex v48;
  const void **v49;
  _BYTE v50[248];
  CFIndex v51;
  CFTypeRef v52;
  CFIndex v53;
  const void **v54;
  _BYTE v55[248];
  CFIndex v56;
  CFTypeRef v57;
  CFIndex range;
  const void **v59;
  _BYTE v60[248];
  CFIndex v61;

  if (!a3)
  {
    Value = CFDictionaryGetValue(a4, CFSTR("<< ORDER >>"));
    if (Value)
    {
      Mutable = (const __CFArray *)CFRetain(Value);
      if (Mutable)
        goto LABEL_5;
    }
    else
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      CFDictionaryApplyFunction(a4, (CFDictionaryApplierFunction)_fetchKeys, Mutable);
      if (Mutable)
        goto LABEL_5;
    }
    range = 0;
    v57 = 0;
    v59 = (const void **)v60;
    goto LABEL_14;
  }
  Mutable = a3;
  CFRetain(a3);
LABEL_5:
  v57 = CFRetain(Mutable);
  Count = CFArrayGetCount(Mutable);
  v9.length = Count;
  range = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v59 = 0;
    goto LABEL_14;
  }
  if (Count > 0x1E)
  {
    v10 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v59 = v10;
    if (!v10)
      goto LABEL_14;
    v9.length = range;
  }
  else
  {
    v10 = (const void **)v60;
    v59 = (const void **)v60;
  }
  v9.location = 0;
  CFArrayGetValues(Mutable, v9, v10);
LABEL_14:
  v61 = 0;
  if (range < 1)
  {
    v12 = 0;
  }
  else
  {
    v11 = 0;
    v12 = 0;
    do
    {
      v61 = v11 + 1;
      v13 = (const __CFString *)v59[v11];
      if (!CFEqual(v13, CFSTR("<< ORDER >>")))
      {
        if (CFDictionaryGetValue(a4, v13))
        {
          Length = CFStringGetLength(v13);
          if (Length > v12)
            v12 = Length;
        }
      }
      v11 = v61;
    }
    while (v61 < range);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v57);
  if (!Mutable)
  {
    v47 = 0;
    v48 = 0;
    v49 = (const void **)v50;
    goto LABEL_32;
  }
  v47 = CFRetain(Mutable);
  v15 = CFArrayGetCount(Mutable);
  v16.length = v15;
  v48 = v15;
  if (v15 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v49 = 0;
    goto LABEL_32;
  }
  if (v15 > 0x1E)
  {
    v17 = (const void **)malloc_type_malloc(8 * v15, 0x89ED541CuLL);
    v49 = v17;
    if (!v17)
      goto LABEL_32;
    v16.length = v48;
  }
  else
  {
    v17 = (const void **)v50;
    v49 = (const void **)v50;
  }
  v16.location = 0;
  CFArrayGetValues(Mutable, v16, v17);
LABEL_32:
  v51 = 0;
  if (v48 >= 1)
  {
    v18 = 0;
    v45 = v12 + a2;
    do
    {
      v51 = v18 + 1;
      v19 = (const __CFString *)v49[v18];
      v20 = (const __CFDictionary *)CFDictionaryGetValue(a4, v19);
      v21 = v20;
      if (v20)
      {
        v22 = CFGetTypeID(v20);
        if (v22 == CFStringGetTypeID())
        {
          v23 = (const __CFString *)v21;
        }
        else
        {
          TypeID = CFNullGetTypeID();
          v23 = CFSTR("null");
          if (v22 != TypeID)
          {
            if (v22 != CFArrayGetTypeID())
            {
              if (v22 == CFDictionaryGetTypeID())
              {
                v32 = CFStringGetLength(v19);
                v33 = mdPrintf(a1, v45 - v32, CFSTR("%@: "), v19);
                v34 = CFDictionaryGetCount(v21);
                mdPrintf(a1, 0, CFSTR("dict [%d] {\n"), v34);
                flattenDict0(a1, v33 + 4, 0, v21);
                mdPrintf(a1, v33, CFSTR("}\n"));
              }
              else if (v22 == CFDataGetTypeID())
              {
                addData(a1, a2, (uint64_t)v19, v21, v35);
              }
              else
              {
                v36 = CFCopyDescription(v21);
                addString(a1, a2, v12, v19, v36);
                if (v36)
                  CFRelease(v36);
              }
              goto LABEL_40;
            }
            v26 = CFStringGetLength(v19);
            v27 = mdPrintf(a1, v45 - v26, CFSTR("%@: "), v19);
            v28 = CFArrayGetCount(v21);
            mdPrintf(a1, 0, CFSTR("array [%d] {\n"), v28);
            v57 = CFRetain(v21);
            v29 = CFArrayGetCount(v21);
            v31.length = v29;
            range = v29;
            if (v29 - 1 > 0x1FFFFFFFFFFFFFFDLL)
            {
              v59 = 0;
            }
            else
            {
              if (v29 <= 0x1E)
              {
                v30 = (const void **)v60;
                v59 = (const void **)v60;
                goto LABEL_54;
              }
              v30 = (const void **)malloc_type_malloc(8 * v29, 0x89ED541CuLL);
              v59 = v30;
              v31.length = range;
              if (v30)
              {
LABEL_54:
                v31.location = 0;
                CFArrayGetValues(v21, v31, v30);
                v31.length = range;
              }
            }
            v61 = 0;
            if (v31.length < 1)
            {
LABEL_73:
              mdPrintf(a1, v27, CFSTR("}\n"), v30);
              CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v57);
              goto LABEL_40;
            }
            v37 = 0;
            while (2)
            {
              v61 = v37 + 1;
              v38 = wrapStrings((const __CFString *)v59[v37], 1020 - v27);
              v40 = v38;
              if (v38)
              {
                v52 = CFRetain(v38);
                v41 = CFArrayGetCount(v40);
                v42.length = v41;
                v53 = v41;
                if (v41 - 1 <= 0x1FFFFFFFFFFFFFFDLL)
                {
                  if (v41 <= 0x1E)
                  {
                    v54 = (const void **)v55;
                    v39 = (const void **)v55;
                    goto LABEL_66;
                  }
                  v39 = (const void **)malloc_type_malloc(8 * v41, 0x89ED541CuLL);
                  v54 = v39;
                  if (v39)
                  {
                    v42.length = v53;
LABEL_66:
                    v42.location = 0;
                    CFArrayGetValues(v40, v42, v39);
                  }
LABEL_67:
                  v56 = 0;
                  while (1)
                  {
                    v44 = v56;
                    if (v56 >= v53)
                      break;
                    ++v56;
                    mdPrintf(a1, v27 + 4, CFSTR("%@\n"), v39, v54[v44]);
                  }
                  if (v40)
                    CFRelease(v40);
                  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v52);
                  v37 = v61;
                  if (v61 >= range)
                    goto LABEL_73;
                  continue;
                }
                v43 = 0;
              }
              else
              {
                v52 = 0;
                v53 = 0;
                v43 = (const void **)v55;
              }
              break;
            }
            v54 = v43;
            goto LABEL_67;
          }
        }
        addString(a1, a2, v12, v19, v23);
      }
      else
      {
        v24 = CFStringGetLength(v19);
        mdPrintf(a1, v45 - v24, CFSTR("%@\n"), v19);
      }
LABEL_40:
      v18 = v51;
    }
    while (v51 < v48);
  }
  if (Mutable)
    CFRelease(Mutable);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v47);
}

void sub_1840C6D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void _fetchKeys(const __CFString *a1, const void *a2, __CFArray *a3)
{
  CFTypeID v5;
  __CFArray *v6;
  const __CFString *v7;
  CFStringRef v8;
  CFStringRef v9;

  v5 = CFGetTypeID(a1);
  if (v5 == CFStringGetTypeID())
  {
    v6 = a3;
    v7 = a1;
  }
  else
  {
    v8 = CFCopyDescription(a1);
    if (v8)
    {
      v9 = v8;
      CFArrayAppendValue(a3, v8);
      CFRelease(v9);
      return;
    }
    v7 = CFSTR("Non-descript-key");
    v6 = a3;
  }
  CFArrayAppendValue(v6, v7);
}

void addString(__CFData *a1, uint64_t a2, uint64_t a3, CFStringRef theString, const __CFString *a5)
{
  CFIndex Length;
  CFIndex v11;
  __CFArray *v12;
  const void **v13;
  const __CFArray *v14;
  unint64_t Count;
  CFRange v16;
  const void *v17;
  uint64_t v18;
  CFTypeRef v19;
  CFIndex range;
  const void **v21;
  _BYTE v22[248];
  uint64_t v23;

  Length = CFStringGetLength(theString);
  v11 = mdPrintf(a1, a3 + a2 - Length, CFSTR("%@: "), theString);
  v12 = wrapStrings(a5, 1024 - v11);
  v14 = v12;
  if (!v12)
  {
    v19 = 0;
    range = 0;
    v21 = (const void **)v22;
    goto LABEL_10;
  }
  v19 = CFRetain(v12);
  Count = CFArrayGetCount(v14);
  v16.length = Count;
  range = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v21 = 0;
    goto LABEL_10;
  }
  if (Count > 0x1E)
  {
    v13 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v21 = v13;
    if (!v13)
      goto LABEL_10;
    v16.length = range;
  }
  else
  {
    v13 = (const void **)v22;
    v21 = (const void **)v22;
  }
  v16.location = 0;
  CFArrayGetValues(v14, v16, v13);
LABEL_10:
  v23 = 0;
  if (range < 1)
  {
    v17 = 0;
  }
  else
  {
    v23 = 1;
    v17 = *v21;
  }
  mdPrintf(a1, 0, CFSTR("%@\n"), v13, v17, v19);
  while (1)
  {
    v18 = v23;
    if (v23 >= range)
      break;
    ++v23;
    mdPrintf(a1, v11, CFSTR("%@\n"), v21[v18]);
  }
  if (v14)
    CFRelease(v14);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v19);
}

void sub_1840C6FD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

__CFArray *wrapStrings(const __CFString *a1, uint64_t a2)
{
  CFIndex v3;
  const __CFAllocator *v4;
  __CFArray *Mutable;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v7;
  unint64_t Count;
  CFRange v10;
  const void **v11;
  CFIndex v12;
  CFTypeRef v13;
  CFIndex range;
  const void **v15;
  _BYTE v16[248];
  CFIndex v17;

  if (a2 <= 40)
    v3 = 40;
  else
    v3 = a2;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v4, a1, CFSTR("\n"));
  v7 = ArrayBySeparatingStrings;
  if (ArrayBySeparatingStrings && CFArrayGetCount(ArrayBySeparatingStrings) > 1)
  {
    v13 = CFRetain(v7);
    Count = CFArrayGetCount(v7);
    v10.length = Count;
    range = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v15 = 0;
    }
    else
    {
      if (Count <= 0x1E)
      {
        v11 = (const void **)v16;
        v15 = (const void **)v16;
LABEL_15:
        v10.location = 0;
        CFArrayGetValues(v7, v10, v11);
        goto LABEL_16;
      }
      v11 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
      v15 = v11;
      if (v11)
      {
        v10.length = range;
        goto LABEL_15;
      }
    }
LABEL_16:
    v17 = 0;
    while (1)
    {
      v12 = v17;
      if (v17 >= range)
        break;
      ++v17;
      wrapStrings(Mutable, (const __CFString *)v15[v12], v3);
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v13);
    if (v7)
      goto LABEL_7;
    return Mutable;
  }
  wrapStrings(Mutable, a1, v3);
  if (v7)
LABEL_7:
    CFRelease(v7);
  return Mutable;
}

void sub_1840C7164(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void addData(__CFData *a1, uint64_t a2, uint64_t a3, CFDataRef theData, const __CFData *a5)
{
  CFIndex Length;
  const __CFAllocator *v10;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v12;
  const UInt8 *v13;
  uint64_t v14;
  CFIndex v15;
  int v16;
  char *v17;
  int v18;
  CFIndex v19;
  char *v20;
  uint64_t v21;
  unsigned __int8 v23;
  CFTypeRef v24;
  const void **v25;
  uint64_t v26;
  __CFData *v27;
  uint64_t v28;
  unint64_t Count;
  CFRange v30;
  CFIndex v31;
  uint64_t v32;
  uint64_t v33;
  const UInt8 *v34;
  __CFArray *v35;
  const __CFAllocator *alloc;
  const UInt8 *BytePtr;
  void (**v38)(AutoString *__hidden);
  CFStringRef v39;
  uint64_t v40;
  uint64_t v41;
  char __str[8];
  CFIndex range;
  const void **v44;
  _BYTE v45[248];
  CFIndex v46;
  _QWORD v47[2];

  v47[0] = *MEMORY[0x1E0C80C00];
  Length = CFDataGetLength(theData);
  v32 = a3;
  v33 = a2;
  mdPrintf(a1, a2, CFSTR("%@ data [ %d ] bytes {\n"), a3, Length);
  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  BytePtr = CFDataGetBytePtr(theData);
  alloc = v10;
  Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x1E0C9B378]);
  v12 = Mutable;
  if (Length >= 1)
  {
    v13 = BytePtr;
    v34 = &BytePtr[Length];
    v14 = MEMORY[0x1E0C80978];
    v35 = Mutable;
    while (1)
    {
      v15 = 0;
      v16 = 0;
      v17 = &__str[snprintf(__str, 0x400uLL, "%8.8x: ", (_DWORD)v13 - (_DWORD)BytePtr)];
      do
      {
        if (Length <= v15)
          v18 = snprintf(v17, (char *)v47 - v17, "  ");
        else
          v18 = snprintf(v17, (char *)v47 - v17, "%c%c");
        v17 += v18;
        if (v16 == 1)
        {
          v16 = 0;
          v17 += snprintf(v17, (char *)v47 - v17, " ");
        }
        else
        {
          ++v16;
        }
        ++v15;
      }
      while (v15 != 16);
      v19 = 0;
      v20 = &v17[snprintf(v17, (char *)v47 - v17, "   ")];
      do
      {
        if (Length <= v19)
        {
          v23 = 32;
          v21 = 32;
        }
        else
        {
          v21 = v13[v19];
          if ((_DWORD)v21 == 10 || (_DWORD)v21 == 13)
          {
            v23 = 45;
            goto LABEL_22;
          }
          v23 = v13[v19];
          if ((char)v21 < 27)
          {
            v23 = 46;
            goto LABEL_22;
          }
        }
        if ((*(_DWORD *)(v14 + 4 * v21 + 60) & 0x40000) == 0)
          v23 = 46;
LABEL_22:
        v20 += snprintf(v20, (char *)v47 - v20, "%c", v23);
        ++v19;
      }
      while (v19 != 16);
      v38 = &off_1E14E4818;
      v39 = CFStringCreateWithCString(alloc, __str, 0x8000100u);
      v12 = v35;
      v40 = 0;
      v41 = 0;
      CFArrayAppendValue(v35, v39);
      AutoString::~AutoString((AutoString *)&v38);
      if (Length >= 17)
      {
        v13 += 16;
        Length -= 16;
        if (v13 < v34)
          continue;
      }
      break;
    }
  }
  if (!v12)
  {
    CFRelease(0);
    goto LABEL_34;
  }
  v24 = CFRetain(v12);
  CFRelease(v12);
  if (!v24)
  {
LABEL_34:
    v24 = 0;
    *(_QWORD *)__str = 0;
    range = 0;
    v44 = (const void **)v45;
    v27 = a1;
    v26 = v33;
    v28 = v32;
    goto LABEL_39;
  }
  v27 = a1;
  v26 = v33;
  v28 = v32;
  *(_QWORD *)__str = CFRetain(v24);
  Count = CFArrayGetCount((CFArrayRef)v24);
  v30.length = Count;
  range = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v44 = 0;
  }
  else
  {
    if (Count <= 0x1E)
    {
      v25 = (const void **)v45;
      v44 = (const void **)v45;
LABEL_38:
      v30.location = 0;
      CFArrayGetValues((CFArrayRef)v24, v30, v25);
      goto LABEL_39;
    }
    v25 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v44 = v25;
    if (v25)
    {
      v30.length = range;
      goto LABEL_38;
    }
  }
LABEL_39:
  v46 = 0;
  while (1)
  {
    v31 = v46;
    if (v46 >= range)
      break;
    ++v46;
    mdPrintf(v27, v26, CFSTR("%@ %@\n"), v25, v28, v44[v31]);
  }
  if (v24)
    CFRelease(v24);
  mdPrintf(v27, v26, CFSTR("%@ }\n"), v25, v28);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)__str);
}

void sub_1840C757C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef cf, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  const void *v39;

  CFRelease(v39);
  _Unwind_Resume(a1);
}

void wrapStrings(__CFArray *a1, const __CFString *a2, CFIndex a3)
{
  CFIndex Length;
  CFIndex v7;
  const __CFAllocator *v8;
  CFStringRef v9;
  const __CFString *v10;
  CFRange v11;
  CFRange v12;

  Length = CFStringGetLength(a2);
  v7 = Length - a3;
  if (Length <= a3)
  {
    CFArrayAppendValue(a1, a2);
  }
  else
  {
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v11.location = 0;
    v11.length = a3;
    v9 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, v11);
    CFArrayAppendValue(a1, v9);
    if (v9)
      CFRelease(v9);
    v12.location = a3;
    v12.length = v7;
    v10 = CFStringCreateWithSubstring(v8, a2, v12);
    wrapStrings(a1, v10, a3);
    if (v10)
      CFRelease(v10);
  }
}

os_log_t ___ZN11CoreDiagMsgD2Ev_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.CFNetwork", "Diagnostics");
  CoreDiagMsg::~CoreDiagMsg()::l = (uint64_t)result;
  return result;
}

void HTTPServerClientOwning::~HTTPServerClientOwning(HTTPServerClientOwning *this)
{
  JUMPOUT(0x186DB748CLL);
}

uint64_t HTTPServerClientOwning::setServerClient(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  uint64_t result;
  uint64_t (*v6)(uint64_t);
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t (*v10)(uint64_t);
  _QWORD v11[6];
  uint8_t buf[4];
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  result = *(_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 8) = 0u;
  v6 = *(uint64_t (**)(uint64_t))(a1 + 32);
  *(_QWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  if (v6)
  {
    if (a3 && a3[10])
    {
      v11[0] = MEMORY[0x1E0C809B0];
      v11[1] = 3221225472;
      v11[2] = ___ZN22HTTPServerClientOwning15setServerClientEPK22_CFHTTPServerClient_V0PK17CoreSchedulingSet_block_invoke;
      v11[3] = &__block_descriptor_48_e5_v8__0l;
      v11[4] = v6;
      v11[5] = result;
      result = (*(uint64_t (**)(_DWORD *, _QWORD *))(*(_QWORD *)a3 + 96))(a3, v11);
    }
    else
    {
      result = v6(result);
    }
  }
  if (a2)
  {
    v7 = *a2;
    if (*a2)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 134217984;
        v13 = v7;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Unknown delegate version %ld", buf, 0xCu);
      }
    }
    else
    {
      v8 = *(_OWORD *)a2;
      v9 = *((_OWORD *)a2 + 1);
      *(_QWORD *)(a1 + 40) = a2[4];
      *(_OWORD *)(a1 + 8) = v8;
      *(_OWORD *)(a1 + 24) = v9;
    }
    result = *(_QWORD *)(a1 + 16);
    v10 = *(uint64_t (**)(uint64_t))(a1 + 24);
    if (v10)
      result = v10(result);
    *(_QWORD *)(a1 + 16) = result;
  }
  return result;
}

uint64_t ___ZN22HTTPServerClientOwning15setServerClientEPK22_CFHTTPServerClient_V0PK17CoreSchedulingSet_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40));
}

uint64_t HTTPServerClientOwning::withServerClient(_QWORD *a1, uint64_t a2)
{
  uint64_t (*v4)(_QWORD);
  uint64_t v5;
  uint64_t result;
  uint64_t (*v7)(uint64_t);

  if (!a1[2])
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  v4 = (uint64_t (*)(_QWORD))a1[3];
  if (!v4)
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  v5 = v4(a1[2]);
  v7 = (uint64_t (*)(uint64_t))a1[4];
  result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v5);
  if (v7)
    return v7(v5);
  return result;
}

uint64_t _CFHTTPServerGetTypeID()
{
  if (HTTPServer::Class(void)::sOnce_HTTPServer != -1)
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
  return *(_QWORD *)(HTTPServer::Class(void)::sClass_OBJTYPE + 96);
}

uint64_t _CFHTTPServerCreateService(const void *a1, uint64_t *a2, uint64_t *a3, const __CFString *a4, const __CFString *a5, __int16 a6)
{
  uint64_t result;
  NSObject *v13;
  _OWORD *Instance;
  uint64_t v15;
  const __CFAllocator *v16;
  CFStringRef Copy;
  const __CFAllocator *v18;
  CFStringRef v19;

  result = 0;
  if (a2 && a3)
  {
    v13 = dispatch_queue_create("com.apple.httpserver.byname-nw", 0);
    if (HTTPServer::Class(void)::sOnce_HTTPServer != -1)
      dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
    Instance = (_OWORD *)_CFRuntimeCreateInstance();
    v15 = (uint64_t)Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      v15 = (uint64_t)(Instance + 1);
      Instance[21] = 0u;
      Instance[22] = 0u;
      Instance[19] = 0u;
      Instance[20] = 0u;
      Instance[17] = 0u;
      Instance[18] = 0u;
      Instance[15] = 0u;
      Instance[16] = 0u;
      Instance[13] = 0u;
      Instance[14] = 0u;
      Instance[11] = 0u;
      Instance[12] = 0u;
      Instance[9] = 0u;
      Instance[10] = 0u;
      Instance[7] = 0u;
      Instance[8] = 0u;
      Instance[5] = 0u;
      Instance[6] = 0u;
      Instance[3] = 0u;
      Instance[4] = 0u;
      Instance[2] = 0u;
    }
    HTTPServer::HTTPServer(v15, a1, v13);
    *(_QWORD *)v15 = &off_1E14EB668;
    *(_QWORD *)(v15 + 8) = &unk_1E14EB728;
    *(_QWORD *)(v15 + 56) = &unk_1E14EB790;
    dispatch_release(v13);
    HTTPServer::initialize(v15, a2, a3);
    if (a4)
    {
      v16 = CFGetAllocator(a4);
      Copy = CFStringCreateCopy(v16, a4);
    }
    else
    {
      Copy = 0;
    }
    *(_QWORD *)(v15 + 280) = Copy;
    if (a5)
    {
      v18 = CFGetAllocator(a5);
      v19 = CFStringCreateCopy(v18, a5);
    }
    else
    {
      v19 = 0;
    }
    *(_QWORD *)(v15 + 288) = v19;
    *(_WORD *)(v15 + 296) = a6;
    *(_QWORD *)(v15 + 304) = 0;
    *(_BYTE *)(v15 + 312) = 0;
    *(_QWORD *)(v15 + 320) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 160))(v15);
    return v15 - 16;
  }
  return result;
}

uint64_t _CFHTTPServerCreateWithAcceptedSocket(const void *a1, uint64_t *a2, uint64_t *a3, int a4)
{
  uint64_t result;
  NSObject *v9;
  _OWORD *Instance;
  uint64_t v11;

  result = 0;
  if (a2 && a3 && a4 != -1)
  {
    v9 = dispatch_queue_create("com.apple.httpserver.bysocket", 0);
    if (HTTPServer::Class(void)::sOnce_HTTPServer != -1)
      dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
    Instance = (_OWORD *)_CFRuntimeCreateInstance();
    v11 = (uint64_t)Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      v11 = (uint64_t)(Instance + 1);
      Instance[17] = 0u;
      Instance[18] = 0u;
      Instance[15] = 0u;
      Instance[16] = 0u;
      Instance[13] = 0u;
      Instance[14] = 0u;
      Instance[11] = 0u;
      Instance[12] = 0u;
      Instance[9] = 0u;
      Instance[10] = 0u;
      Instance[7] = 0u;
      Instance[8] = 0u;
      Instance[5] = 0u;
      Instance[6] = 0u;
      Instance[3] = 0u;
      Instance[4] = 0u;
      Instance[2] = 0u;
    }
    HTTPServer::HTTPServer(v11, a1, v9);
    *(_QWORD *)v11 = &off_1E14EB7B0;
    *(_QWORD *)(v11 + 8) = &unk_1E14EB858;
    *(_QWORD *)(v11 + 56) = &unk_1E14EB8C0;
    *(_DWORD *)(v11 + 280) = -1;
    dispatch_release(v9);
    *(_DWORD *)(v11 + 280) = a4;
    HTTPServer::initialize(v11, a2, a3);
    return v11 - 16;
  }
  return result;
}

_QWORD *_CFHTTPServerCreateWithStreams(const void *a1, uint64_t *a2, uint64_t *a3, const void *a4, const void *a5)
{
  _QWORD *result;
  NSObject *v11;
  uint64_t Instance;
  _QWORD *v13;

  result = 0;
  if (a2)
  {
    if (a3)
    {
      result = 0;
      if (a4)
      {
        if (a5)
        {
          v11 = dispatch_queue_create("com.apple.httpserver.bystreams", 0);
          if (HTTPServer::Class(void)::sOnce_HTTPServer != -1)
            dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
          Instance = _CFRuntimeCreateInstance();
          v13 = (_QWORD *)Instance;
          if (Instance)
          {
            *(_OWORD *)(Instance + 16) = 0u;
            v13 = (_QWORD *)(Instance + 16);
            *(_QWORD *)(Instance + 304) = 0;
            *(_OWORD *)(Instance + 272) = 0u;
            *(_OWORD *)(Instance + 288) = 0u;
            *(_OWORD *)(Instance + 240) = 0u;
            *(_OWORD *)(Instance + 256) = 0u;
            *(_OWORD *)(Instance + 208) = 0u;
            *(_OWORD *)(Instance + 224) = 0u;
            *(_OWORD *)(Instance + 176) = 0u;
            *(_OWORD *)(Instance + 192) = 0u;
            *(_OWORD *)(Instance + 144) = 0u;
            *(_OWORD *)(Instance + 160) = 0u;
            *(_OWORD *)(Instance + 112) = 0u;
            *(_OWORD *)(Instance + 128) = 0u;
            *(_OWORD *)(Instance + 80) = 0u;
            *(_OWORD *)(Instance + 96) = 0u;
            *(_OWORD *)(Instance + 48) = 0u;
            *(_OWORD *)(Instance + 64) = 0u;
            *(_OWORD *)(Instance + 32) = 0u;
          }
          HTTPServer::HTTPServer((uint64_t)v13, a1, v11);
          *v13 = &off_1E14EBE20;
          v13[1] = &unk_1E14EBED0;
          v13[7] = &unk_1E14EBF38;
          dispatch_release(v11);
          HTTPServer::initialize((uint64_t)v13, a2, a3);
          v13[35] = CFRetain(a4);
          v13[36] = CFRetain(a5);
          return v13 - 2;
        }
      }
    }
  }
  return result;
}

uint64_t _CFHTTPServerGetClient(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[5];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  if (HTTPServer::Class(void)::sOnce_HTTPServer != -1)
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___CFHTTPServerGetClient_block_invoke;
  v5[3] = &unk_1E14FC540;
  v5[4] = &v6;
  HTTPServerClientOwning::withServerClient((_QWORD *)(v2 + 8), (uint64_t)v5);
  if (a1 && HTTPServer::Class(void)::sOnce_HTTPServer != -1)
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1840C7E0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFHTTPServerSetProperty(uint64_t a1, CFTypeRef cf, CFTypeRef a3)
{
  _QWORD v6[6];

  if (!a1 || HTTPServer::Class(void)::sOnce_HTTPServer == -1)
  {
    if (!cf)
      goto LABEL_5;
    goto LABEL_4;
  }
  dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
  if (cf)
LABEL_4:
    CFRetain(cf);
LABEL_5:
  if (a3)
    CFRetain(a3);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerSetProperty_block_invoke;
  v6[3] = &__block_descriptor_48_e9_v16__0_v8l;
  v6[4] = cf;
  v6[5] = a3;
  withServerAsync(a1, (uint64_t)v6);
}

void withServerAsync(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v5[6];

  if (a1)
  {
    if (HTTPServer::Class(void)::sOnce_HTTPServer != -1)
      dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
    v4 = a1 + 16;
  }
  else
  {
    v4 = 0;
  }
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZL13withBaseAsyncIP13_CFHTTPServer10HTTPServerEvT_U13block_pointerFvPT0_E_block_invoke;
  v5[3] = &unk_1E14FDA90;
  v5[4] = a2;
  v5[5] = v4;
  HTTPServerBase::withWorkQueue((_QWORD *)(v4 + 8), v5);
}

uint64_t ___ZL13withBaseAsyncIP13_CFHTTPServer10HTTPServerEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t _CFHTTPServerCopyProperty(uint64_t a1, CFStringRef theString)
{
  int ExactString;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[5];
  _QWORD block[6];

  if (a1 && HTTPServer::Class(void)::sOnce_HTTPServer != -1)
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
  ExactString = _findExactString(theString, 9u);
  v5 = MEMORY[0x1E0C809B0];
  if (ExactString == 481499530)
  {
    v6 = dispatch_semaphore_create(0);
    v14[0] = v5;
    v14[1] = 3221225472;
    v14[2] = ___CFHTTPServerCopyProperty_block_invoke;
    v14[3] = &unk_1E14FC588;
    v14[4] = v6;
    withServerAsync(a1, (uint64_t)v14);
    dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v6);
  }
  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 0;
  v9[0] = v5;
  v9[1] = 3221225472;
  v9[2] = ___CFHTTPServerCopyProperty_block_invoke_2;
  v9[3] = &unk_1E14FD7F0;
  v9[4] = &v10;
  v9[5] = theString;
  if (HTTPServer::Class(void)::sOnce_HTTPServer != -1)
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZL16withBaseBlockingIP13_CFHTTPServer10HTTPServerEvT_U13block_pointerFvPT0_E_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v9;
  block[5] = a1 + 16;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 104), block);
  v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v7;
}

uint64_t ___ZL16withBaseBlockingIP13_CFHTTPServer10HTTPServerEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t _CFHTTPServerIsValid(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[5];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;
  _QWORD block[6];

  if (a1 && HTTPServer::Class(void)::sOnce_HTTPServer != -1)
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  v2 = MEMORY[0x1E0C809B0];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___CFHTTPServerIsValid_block_invoke;
  v5[3] = &unk_1E14FC540;
  v5[4] = &v6;
  if (HTTPServer::Class(void)::sOnce_HTTPServer != -1)
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_13655);
  block[0] = v2;
  block[1] = 3221225472;
  block[2] = ___ZL16withBaseBlockingIP13_CFHTTPServer10HTTPServerEvT_U13block_pointerFvPT0_E_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v5;
  block[5] = a1 + 16;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 104), block);
  v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void _CFHTTPServerInvalidate(uint64_t a1)
{
  withServerAsync(a1, (uint64_t)&__block_literal_global_13952);
}

void _CFHTTPServerSetDispatchQueue(uint64_t a1, CFTypeRef cf)
{
  _QWORD v4[5];

  if (cf)
    CFRetain(cf);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerSetDispatchQueue_block_invoke;
  v4[3] = &unk_1E14FC588;
  v4[4] = cf;
  withServerAsync(a1, (uint64_t)v4);
}

void _CFHTTPServerScheduleWithRunLoopAndMode(uint64_t a1, CFTypeRef cf, CFTypeRef a3)
{
  _QWORD v6[6];

  if (cf)
    CFRetain(cf);
  if (a3)
    CFRetain(a3);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerScheduleWithRunLoopAndMode_block_invoke;
  v6[3] = &__block_descriptor_48_e9_v16__0_v8l;
  v6[4] = cf;
  v6[5] = a3;
  withServerAsync(a1, (uint64_t)v6);
}

uint64_t _CFHTTPServerConnectionGetTypeID()
{
  if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  return *(_QWORD *)(HTTPServerConnection::Class(void)::sClass_OBJTYPE + 96);
}

void _CFHTTPServerConnectionSetClient(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v6[6];

  if (a1 && HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerConnectionSetClient_block_invoke;
  v6[3] = &__block_descriptor_48_e350_v16__0__HTTPServerConnection_________CFHTTPServerClient_V0_q_v______________CFAllocator_i____CFDictionary____CoreSchedulingSet_____CFError___CFHTTPServerConnectionCallbacks_V1_q_____________HTTPServer_C____CFReadStream_____CFWriteStream_ddqqC__HTTPServerRequest___PendingQueue___ActiveResponseInfo_____CFData___LeftoverBuffer_q______CFRunLoopTimer__8l;
  v6[4] = a2;
  v6[5] = a3;
  withConnectionBlocking(a1, (uint64_t)v6);
}

void withConnectionBlocking(uint64_t a1, uint64_t a2)
{
  _QWORD v4[6];

  if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZL16withBaseBlockingIP23_CFHTTPServerConnection20HTTPServerConnectionEvT_U13block_pointerFvPT0_E_block_invoke;
  v4[3] = &unk_1E14FDA90;
  v4[4] = a2;
  v4[5] = a1 + 16;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 104), v4);
}

uint64_t ___ZL16withBaseBlockingIP23_CFHTTPServerConnection20HTTPServerConnectionEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t _CFHTTPServerConnectionGetClient(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[5];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___CFHTTPServerConnectionGetClient_block_invoke;
  v5[3] = &unk_1E14FC540;
  v5[4] = &v6;
  HTTPServerClientOwning::withServerClient((_QWORD *)(v2 + 8), (uint64_t)v5);
  if (a1 && HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1840C88B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFHTTPServerConnectionSetProperty(uint64_t a1, CFTypeRef cf, CFTypeRef a3)
{
  _QWORD v6[6];

  if (!a1 || HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection == -1)
  {
    if (!cf)
      goto LABEL_5;
    goto LABEL_4;
  }
  dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  if (cf)
LABEL_4:
    CFRetain(cf);
LABEL_5:
  if (a3)
    CFRetain(a3);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerConnectionSetProperty_block_invoke;
  v6[3] = &__block_descriptor_48_e350_v16__0__HTTPServerConnection_________CFHTTPServerClient_V0_q_v______________CFAllocator_i____CFDictionary____CoreSchedulingSet_____CFError___CFHTTPServerConnectionCallbacks_V1_q_____________HTTPServer_C____CFReadStream_____CFWriteStream_ddqqC__HTTPServerRequest___PendingQueue___ActiveResponseInfo_____CFData___LeftoverBuffer_q______CFRunLoopTimer__8l;
  v6[4] = cf;
  v6[5] = a3;
  withConnectionAsync(a1, (uint64_t)v6);
}

void withConnectionAsync(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v5[6];

  if (a1)
  {
    if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
      dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
    v4 = a1 + 16;
  }
  else
  {
    v4 = 0;
  }
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZL13withBaseAsyncIP23_CFHTTPServerConnection20HTTPServerConnectionEvT_U13block_pointerFvPT0_E_block_invoke;
  v5[3] = &unk_1E14FDA90;
  v5[4] = a2;
  v5[5] = v4;
  HTTPServerBase::withWorkQueue((_QWORD *)(v4 + 8), v5);
}

uint64_t ___ZL13withBaseAsyncIP23_CFHTTPServerConnection20HTTPServerConnectionEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t _CFHTTPServerConnectionCopyProperty(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  if (a1 && HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerConnectionCopyProperty_block_invoke;
  v6[3] = &unk_1E14FC5D0;
  v6[4] = &v7;
  v6[5] = a2;
  withConnectionBlocking(a1, (uint64_t)v6);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t _CFHTTPServerConnectionIsValid(uint64_t a1)
{
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  if (a1 && HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_13743);
  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerConnectionIsValid_block_invoke;
  v4[3] = &unk_1E14FC5F8;
  v4[4] = &v5;
  withConnectionBlocking(a1, (uint64_t)v4);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void _CFHTTPServerConnectionInvalidate(uint64_t a1)
{
  withConnectionAsync(a1, (uint64_t)&__block_literal_global_29_13954);
}

void _CFHTTPServerConnectionSetDispatchQueue(uint64_t a1, CFTypeRef cf)
{
  _QWORD v4[5];

  if (cf)
    CFRetain(cf);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerConnectionSetDispatchQueue_block_invoke;
  v4[3] = &unk_1E14FC660;
  v4[4] = cf;
  withConnectionAsync(a1, (uint64_t)v4);
}

void _CFHTTPServerConnectionScheduleWithRunLoopAndMode(uint64_t a1, CFTypeRef cf, CFTypeRef a3)
{
  _QWORD v6[6];

  if (cf)
    CFRetain(cf);
  if (a3)
    CFRetain(a3);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerConnectionScheduleWithRunLoopAndMode_block_invoke;
  v6[3] = &__block_descriptor_48_e350_v16__0__HTTPServerConnection_________CFHTTPServerClient_V0_q_v______________CFAllocator_i____CFDictionary____CoreSchedulingSet_____CFError___CFHTTPServerConnectionCallbacks_V1_q_____________HTTPServer_C____CFReadStream_____CFWriteStream_ddqqC__HTTPServerRequest___PendingQueue___ActiveResponseInfo_____CFData___LeftoverBuffer_q______CFRunLoopTimer__8l;
  v6[4] = cf;
  v6[5] = a3;
  withConnectionAsync(a1, (uint64_t)v6);
}

uint64_t _CFHTTPServerRequestGetTypeID()
{
  if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_33_13955);
  return *(_QWORD *)(TCFObject<HTTPServerRequest>::Class(void)::clazz + 96);
}

void ___ZN9TCFObjectI17HTTPServerRequestE5ClassEv_block_invoke_13956()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  byte_1EDD00CB8 = 116;
  _PNAME<HTTPServerRequest>::GET(void)::p = *(_OWORD *)"HTTPServerRequest>::GET() [OBJTYPE = HTTPServerRequest]";
  CFClass::CFClass(v0, (const char *)&_PNAME<HTTPServerRequest>::GET(void)::p);
  TCFObject<HTTPServerRequest>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840C8F20(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t _CFHTTPServerRequestCopyProperty(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  if (a1 && TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_33_13955);
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerRequestCopyProperty_block_invoke;
  v6[3] = &unk_1E14FD7F0;
  v6[4] = &v7;
  v6[5] = a2;
  withRequestBlocking(a1, (uint64_t)v6);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1840C9004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void withRequestBlocking(uint64_t a1, uint64_t a2)
{
  _QWORD v4[6];

  if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_33_13955);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZL16withBaseBlockingIP20_CFHTTPServerRequest17HTTPServerRequestEvT_U13block_pointerFvPT0_E_block_invoke;
  v4[3] = &unk_1E14FDA90;
  v4[4] = a2;
  v4[5] = a1 + 16;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 248), v4);
}

uint64_t ___ZL16withBaseBlockingIP20_CFHTTPServerRequest17HTTPServerRequestEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t _CFHTTPServerRequestCreateResponseMessage(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  if (a1 && TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_33_13955);
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerRequestCreateResponseMessage_block_invoke;
  v6[3] = &unk_1E14FD7F0;
  v6[4] = &v7;
  v6[5] = a2;
  withRequestBlocking(a1, (uint64_t)v6);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1840C91B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1840C9300(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

_QWORD *_CFHTTPServerResponseCreateWithData(char *a1, __CFHTTPMessage *a2, const __CFData *a3)
{
  _OWORD *Instance;
  HTTPServerResponse *v7;
  HTTPServerRequest *v8;
  _QWORD *v9;
  const __CFAllocator *v10;
  __CFHTTPMessage *Copy;

  CFGetAllocator(a1);
  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_34_13958);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v7 = (HTTPServerResponse *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v7 = (HTTPServerResponse *)(Instance + 1);
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  if (a1)
  {
    if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_33_13955);
    v8 = (HTTPServerRequest *)(a1 + 16);
  }
  else
  {
    v8 = 0;
  }
  HTTPServerResponse::HTTPServerResponse(v7, v8);
  if (!v7)
    return 0;
  v9 = (_QWORD *)((char *)v7 - 16);
  v10 = CFGetAllocator((char *)v7 - 16);
  Copy = CFHTTPMessageCreateCopy(v10, a2);
  *((_QWORD *)v7 + 12) = Copy;
  CFHTTPMessageSetBody(Copy, a3);
  return v9;
}

void ___ZN9TCFObjectI18HTTPServerResponseE5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  word_1EDD00C68 = 25971;
  _PNAME<HTTPServerResponse>::GET(void)::p = *(_OWORD *)"HTTPServerResponse>::GET() [OBJTYPE = HTTPServerResponse]";
  CFClass::CFClass(v0, (const char *)&_PNAME<HTTPServerResponse>::GET(void)::p);
  TCFObject<HTTPServerResponse>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840C9480(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t _CFHTTPServerRequestCopyBodyStream(uint64_t a1)
{
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  if (a1 && TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_33_13955);
  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerRequestCopyBodyStream_block_invoke;
  v4[3] = &unk_1E14FC540;
  v4[4] = &v5;
  withRequestBlocking(a1, (uint64_t)v4);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1840C9560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFHTTPServerResponseGetTypeID()
{
  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_34_13958);
  return *(_QWORD *)(TCFObject<HTTPServerResponse>::Class(void)::clazz + 96);
}

uint64_t _CFHTTPServerResponseCopyProperty(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  if (a1 && TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_34_13958);
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerResponseCopyProperty_block_invoke;
  v6[3] = &unk_1E14FD7F0;
  v6[4] = &v7;
  v6[5] = a2;
  withResponseBlocking(a1, (uint64_t)v6);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1840C96DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void withResponseBlocking(uint64_t a1, uint64_t a2)
{
  _QWORD v4[6];

  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_34_13958);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZL16withBaseBlockingIP21_CFHTTPServerResponse18HTTPServerResponseEvT_U13block_pointerFvPT0_E_block_invoke;
  v4[3] = &unk_1E14FDA90;
  v4[4] = a2;
  v4[5] = a1 + 16;
  dispatch_sync(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 96) + 232), v4);
}

uint64_t ___ZL16withBaseBlockingIP21_CFHTTPServerResponse18HTTPServerResponseEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void _CFHTTPServerRequestSetClient(uint64_t a1, uint64_t a2)
{
  _QWORD v4[5];

  if (a1 && TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_33_13955);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerRequestSetClient_block_invoke;
  v4[3] = &__block_descriptor_40_e9_v16__0_v8l;
  v4[4] = a2;
  withRequestBlocking(a1, (uint64_t)v4);
}

uint64_t _CFHTTPServerRequestGetClient(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[5];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_33_13955);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___CFHTTPServerRequestGetClient_block_invoke;
  v5[3] = &unk_1E14FC540;
  v5[4] = &v6;
  HTTPServerClientOwning::withServerClient((_QWORD *)(v2 + 8), (uint64_t)v5);
  if (a1 && TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_33_13955);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1840C9A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *_CFHTTPServerResponseCreateWithBodyStream(char *a1, __CFHTTPMessage *a2, const void *a3)
{
  _OWORD *Instance;
  HTTPServerResponse *v7;
  HTTPServerRequest *v8;
  _QWORD *v9;
  const __CFAllocator *v10;
  CFTypeRef v11;
  __int16 v13[8];

  CFGetAllocator(a1);
  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_34_13958);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v7 = (HTTPServerResponse *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v7 = (HTTPServerResponse *)(Instance + 1);
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  if (a1)
  {
    if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_33_13955);
    v8 = (HTTPServerRequest *)(a1 + 16);
  }
  else
  {
    v8 = 0;
  }
  HTTPServerResponse::HTTPServerResponse(v7, v8);
  if (v7)
  {
    v9 = (_QWORD *)((char *)v7 - 16);
    v10 = CFGetAllocator((char *)v7 - 16);
    *((_QWORD *)v7 + 12) = CFHTTPMessageCreateCopy(v10, a2);
    if (*((_QWORD *)v7 + 14) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      v13[0] = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Already have a body stream", (uint8_t *)v13, 2u);
      if (a3)
        goto LABEL_14;
    }
    else if (a3)
    {
LABEL_14:
      v11 = CFRetain(a3);
LABEL_18:
      *((_QWORD *)v7 + 14) = v11;
      return v9;
    }
    v11 = 0;
    goto LABEL_18;
  }
  return 0;
}

void _CFHTTPServerResponseSetClient(uint64_t a1, uint64_t a2)
{
  _QWORD v4[5];

  if (a1 && TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_34_13958);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerResponseSetClient_block_invoke;
  v4[3] = &__block_descriptor_40_e9_v16__0_v8l;
  v4[4] = a2;
  withResponseBlocking(a1, (uint64_t)v4);
}

uint64_t _CFHTTPServerResponseGetClient(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[5];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_34_13958);
  v2 = a1 + 16;
  if (!a1)
    v2 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___CFHTTPServerResponseGetClient_block_invoke;
  v5[3] = &unk_1E14FC540;
  v5[4] = &v6;
  HTTPServerClientOwning::withServerClient((_QWORD *)(v2 + 8), (uint64_t)v5);
  if (a1 && TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_34_13958);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1840C9DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFHTTPServerResponseEnqueue(uint64_t a1)
{
  _QWORD v2[6];

  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_34_13958);
  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3221225472;
  v2[2] = ___ZL13withBaseAsyncIP21_CFHTTPServerResponse18HTTPServerResponseEvT_U13block_pointerFvPT0_E_block_invoke;
  v2[3] = &unk_1E14FDA90;
  v2[4] = &__block_literal_global_31_13959;
  v2[5] = a1 + 16;
  dispatch_async(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 96) + 232), v2);
}

uint64_t ___ZL13withBaseAsyncIP21_CFHTTPServerResponse18HTTPServerResponseEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t _CFHTTPServerCreateSelfSignedIdentity(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  SecKeyRef v6;
  SecKeyRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t SelfSignedCertificate;
  const void *v12;
  uint64_t v13;
  CFErrorRef error;
  uint64_t v16;
  _QWORD v17[3];
  _QWORD v18[3];
  _QWORD v19[2];
  uint64_t v20;
  _QWORD v21[2];
  uint64_t v22;
  _QWORD v23[2];
  _QWORD v24[4];
  _QWORD v25[5];

  v25[4] = *MEMORY[0x1E0C80C00];
  v2 = *MEMORY[0x1E0CD6A50];
  v3 = *MEMORY[0x1E0CD6A20];
  v24[0] = *MEMORY[0x1E0CD6A38];
  v24[1] = v3;
  v25[0] = v2;
  v25[1] = &unk_1E152A700;
  v4 = MEMORY[0x1E0C9AAA0];
  v5 = *MEMORY[0x1E0CD6A90];
  v24[2] = *MEMORY[0x1E0CD6970];
  v24[3] = v5;
  v25[2] = MEMORY[0x1E0C9AAA0];
  v25[3] = CFSTR("Anonymous Self Signed certificate");
  error = 0;
  v6 = SecKeyCreateRandomKey((CFDictionaryRef)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v25, v24, 4), &error);
  if (v6)
  {
    v7 = v6;
    v21[0] = *MEMORY[0x1E0CD6F58];
    v21[1] = CFSTR("Apple Inc.");
    v22 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v21, 2);
    v23[0] = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v22, 1);
    v19[0] = *MEMORY[0x1E0CD6F48];
    v19[1] = a1;
    v20 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v19, 2);
    v23[1] = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v20, 1);
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v23, 2);
    v8 = *MEMORY[0x1E0CD6C90];
    v18[0] = &unk_1E152A718;
    v9 = *MEMORY[0x1E0CD6C80];
    v17[0] = v8;
    v17[1] = v9;
    v16 = *MEMORY[0x1E0CD6D48];
    v10 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v16, 1);
    v17[2] = *MEMORY[0x1E0CD6C68];
    v18[1] = v10;
    v18[2] = v4;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v18, v17, 3);
    SelfSignedCertificate = SecGenerateSelfSignedCertificate();
    if (SelfSignedCertificate)
    {
      v12 = (const void *)SelfSignedCertificate;
      v13 = SecIdentityCreate();
      CFRelease(v12);
    }
    else
    {
      v13 = 0;
    }
    CFRelease(v7);
  }
  else
  {
    v13 = 0;
  }
  if (error)
    CFRelease(error);
  return v13;
}

CFStringRef HTTPServerService::copyDebugDesc(HTTPServerService *this)
{
  CFStringRef v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const __CFAllocator *v6;
  CFStringRef v7;

  v2 = HTTPServer::copyDebugDesc(this);
  v3 = (const void *)(*(uint64_t (**)(HTTPServerService *, uint64_t))(*(_QWORD *)this + 64))(this, 0x1EDCFF490);
  v4 = (const void *)(*(uint64_t (**)(HTTPServerService *, uint64_t))(*(_QWORD *)this + 64))(this, 0x1EDCFF228);
  v5 = (const void *)(*(uint64_t (**)(HTTPServerService *, uint64_t))(*(_QWORD *)this + 64))(this, 0x1EDCFF4C8);
  v6 = CFGetAllocator((char *)this - 16);
  v7 = CFStringCreateWithFormat(v6, 0, CFSTR("%@ { service name='%@', type='%@', port=%@> }"), v2, v4, v5, v3);
  if (v5)
    CFRelease(v5);
  if (v4)
    CFRelease(v4);
  if (v3)
    CFRelease(v3);
  if (v2)
    CFRelease(v2);
  return v7;
}

CFNumberRef HTTPServerService::copyProperty(HTTPServerService *this, CFStringRef theString)
{
  int ExactString;
  CFNumberRef result;
  CFNumberRef *v6;
  const __CFAllocator *v7;
  int valuePtr;

  ExactString = _findExactString(theString, 9u);
  if (ExactString <= 480500089)
  {
    if (ExactString == 462731387)
    {
      result = (CFNumberRef)*((_QWORD *)this + 38);
      if (result)
        return (CFNumberRef)CFRetain(result);
    }
    else
    {
      if (ExactString != 469907694)
        return (CFNumberRef)HTTPServer::copyProperty(this, theString);
      result = (CFNumberRef)*((_QWORD *)this + 35);
      if (result)
        return (CFNumberRef)CFRetain(result);
    }
  }
  else
  {
    if (ExactString != 480500090)
    {
      if (ExactString == 481499530)
      {
        valuePtr = (*(uint64_t (**)(HTTPServerService *))(*(_QWORD *)this + 152))(this);
        v7 = CFGetAllocator((char *)this - 16);
        return CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
      }
      if (ExactString == 482548119)
      {
        result = (CFNumberRef)*((_QWORD *)this + 36);
        if (!result)
          return result;
        return (CFNumberRef)CFRetain(result);
      }
      return (CFNumberRef)HTTPServer::copyProperty(this, theString);
    }
    v6 = (CFNumberRef *)MEMORY[0x1E0C9AE50];
    if (!*((_BYTE *)this + 312))
      v6 = (CFNumberRef *)MEMORY[0x1E0C9AE40];
    result = *v6;
    if (*v6)
      return (CFNumberRef)CFRetain(result);
  }
  return result;
}

void HTTPServerService::setProperty(HTTPServerService *this, CFStringRef theString, const __CFBoolean *a3)
{
  int ExactString;
  int v7;
  CFTypeRef v8;
  int v9;
  CFStringRef v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  ExactString = _findExactString(theString, 9u);
  if (ExactString > 480500089)
  {
    if (ExactString == 480500090)
    {
      *((_BYTE *)this + 312) = CFBooleanGetValue(a3);
      return;
    }
    if (ExactString == 482548119)
    {
LABEL_8:
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        v9 = 138412290;
        v10 = theString;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "sorry, setting %@ not yet implemented", (uint8_t *)&v9, 0xCu);
      }
      return;
    }
    v7 = 481499530;
LABEL_7:
    if (ExactString != v7)
    {
      HTTPServer::setProperty(this, theString, a3);
      return;
    }
    goto LABEL_8;
  }
  if (ExactString != 462731387)
  {
    v7 = 469907694;
    goto LABEL_7;
  }
  if (a3)
    v8 = CFRetain(a3);
  else
    v8 = 0;
  *((_QWORD *)this + 38) = v8;
}

void HTTPServerService::scheduled_onQueue(HTTPServerService *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 40);
  if (v2)
  {
    *((_QWORD *)this + 40) = 0;
    HTTPServerBase::becomeErrored_onQueue((HTTPServerService *)((char *)this + 8), v2);
    CFRelease(v2);
  }
  *((_BYTE *)this + 313) = 1;
}

uint64_t HTTPServerService::canceled_onQueue(uint64_t this)
{
  *(_BYTE *)(this + 313) = 0;
  return this;
}

uint64_t HTTPServerService::getPort(HTTPServerService *this)
{
  return *((unsigned __int16 *)this + 148);
}

CFNumberRef `non-virtual thunk to'HTTPServerService::copyProperty(HTTPServerService *this, const __CFString *a2)
{
  return HTTPServerService::copyProperty((HTTPServerService *)((char *)this - 8), a2);
}

void `non-virtual thunk to'HTTPServerService::setProperty(HTTPServerService *this, const __CFString *a2, const __CFBoolean *a3)
{
  HTTPServerService::setProperty((HTTPServerService *)((char *)this - 8), a2, a3);
}

void `non-virtual thunk to'HTTPServerService::scheduled_onQueue(HTTPServerService *this)
{
  HTTPServerService::scheduled_onQueue((HTTPServerService *)((char *)this - 8));
}

uint64_t `non-virtual thunk to'HTTPServerService::canceled_onQueue(uint64_t this)
{
  *(_BYTE *)(this + 305) = 0;
  return this;
}

void HTTPServerService::~HTTPServerService(HTTPServerService *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  *(_QWORD *)this = &off_1E14E8DD0;
  *((_QWORD *)this + 1) = &unk_1E14E8E88;
  *((_QWORD *)this + 7) = &unk_1E14E8EF0;
  v2 = (const void *)*((_QWORD *)this + 35);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 36);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 38);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 40);
  if (v5)
    CFRelease(v5);
  HTTPServer::~HTTPServer(this);
}

void sub_1840CA7EC(_Unwind_Exception *a1)
{
  HTTPServer *v1;

  HTTPServer::~HTTPServer(v1);
  _Unwind_Resume(a1);
}

void HTTPServerWithSocket::connectionClosed(uint64_t a1, const void *a2)
{
  int v3;

  HTTPServer::connectionClosed(a1, a2);
  v3 = *(_DWORD *)(a1 + 280);
  if (v3 != -1)
  {
    close(v3);
    *(_DWORD *)(a1 + 280) = -1;
  }
  if (*(int *)(a1 + 72) <= 2)
    *(_DWORD *)(a1 + 72) = 3;
  HTTPServerBase::signal((NSObject **)(a1 + 8));
}

CFNumberRef HTTPServerWithSocket::copyProperty(HTTPServerWithSocket *this, CFStringRef theString)
{
  const __CFAllocator *v5;
  unsigned int v6;
  socklen_t v7;
  sockaddr v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (_findExactString(theString, 9u) != 481499530)
    return (CFNumberRef)HTTPServer::copyProperty(this, theString);
  v7 = 255;
  if (getsockname(*((_DWORD *)this + 70), &v8, &v7))
    return 0;
  v6 = -1;
  if (v8.sa_family == 30 || v8.sa_family == 2)
    v6 = bswap32(*(unsigned __int16 *)v8.sa_data) >> 16;
  v5 = CFGetAllocator((char *)this - 16);
  return CFNumberCreate(v5, kCFNumberSInt32Type, &v6);
}

intptr_t HTTPServerWithSocket::ensureServerExists(int a1, dispatch_semaphore_t dsema)
{
  return dispatch_semaphore_signal(dsema);
}

void HTTPServerWithSocket::scheduled_onQueue(HTTPServerWithSocket *this)
{
  HTTPServer::newConnection((NSObject **)this, *((_DWORD *)this + 70));
}

void `non-virtual thunk to'HTTPServerWithSocket::~HTTPServerWithSocket(HTTPServerWithSocket *this)
{
  HTTPServerWithSocket::~HTTPServerWithSocket((HTTPServerWithSocket *)((char *)this - 8));
}

{
  HTTPServerWithSocket::~HTTPServerWithSocket((HTTPServerWithSocket *)((char *)this - 8));
}

{
  HTTPServerWithSocket::~HTTPServerWithSocket((HTTPServerWithSocket *)((char *)this - 56));
}

{
  HTTPServerWithSocket::~HTTPServerWithSocket((HTTPServerWithSocket *)((char *)this - 56));
}

CFNumberRef `non-virtual thunk to'HTTPServerWithSocket::copyProperty(HTTPServerWithSocket *this, const __CFString *a2)
{
  return HTTPServerWithSocket::copyProperty((HTTPServerWithSocket *)((char *)this - 8), a2);
}

void `non-virtual thunk to'HTTPServerWithSocket::scheduled_onQueue(HTTPServerWithSocket *this)
{
  HTTPServer::newConnection((NSObject **)this - 1, *((_DWORD *)this + 68));
}

void HTTPServerWithSocket::~HTTPServerWithSocket(HTTPServerWithSocket *this)
{
  int v2;

  *(_QWORD *)this = &off_1E14EB7B0;
  *((_QWORD *)this + 1) = &unk_1E14EB858;
  *((_QWORD *)this + 7) = &unk_1E14EB8C0;
  v2 = *((_DWORD *)this + 70);
  if (v2 != -1)
  {
    close(v2);
    *((_DWORD *)this + 70) = -1;
  }
  HTTPServer::~HTTPServer(this);
}

void sub_1840CAA00(_Unwind_Exception *a1)
{
  HTTPServer *v1;

  HTTPServer::~HTTPServer(v1);
  _Unwind_Resume(a1);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA508;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA508;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void ___ZN20HTTP3ConnectionCache17_timersInitializeEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        *(_BYTE *)(v5 + 96) = 0;
        HTTP3ConnectionCache::_connectionsRemoveIdle((CFDictionaryRef *)v5);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1840CAB40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN20HTTP3ConnectionCache15enableCellTimerEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        *(_BYTE *)(v5 + 96) = 0;
        HTTP3ConnectionCache::_connectionsRemoveIdle((CFDictionaryRef *)v5);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1840CABE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20HTTP3ConnectionCache15enableCellTimerEv_block_invoke_7(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

void HTTP3ConnectionCache::_connectionsRemoveIdle(CFDictionaryRef *this)
{
  __uint64_t v2;
  __uint64_t v3;
  __uint64_t v4;
  const __CFAllocator *v5;
  uint64_t v6;
  _QWORD v7[5];
  _QWORD context[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  CFMutableDictionaryRef (*v12)(uint64_t, uint64_t);
  void (*v13)(uint64_t);
  void *v14;
  uint64_t (**v15)();
  CFTypeRef cf;

  v2 = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
  v3 = v2 - 1000000000 * *((int *)this + 14);
  v4 = v2 - 1000000000 * *((int *)this + 15);
  v9 = 0;
  v10 = &v9;
  v11 = 0x4012000000;
  v12 = __Block_byref_object_copy__14060;
  v13 = __Block_byref_object_dispose__14061;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v14 = &unk_18422E08D;
  v15 = &off_1E14EA508;
  cf = CFDictionaryCreateMutable(v5, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
  v6 = MEMORY[0x1E0C809B0];
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 3221225472;
  context[2] = ___ZN20HTTP3ConnectionCache22_connectionsRemoveIdleEv_block_invoke;
  context[3] = &unk_1E14FC6E8;
  context[5] = v3;
  context[6] = v4;
  context[4] = &v9;
  CFDictionaryApplyFunction(this[11], (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit, context);
  v7[0] = v6;
  v7[1] = 3221225472;
  v7[2] = ___ZN20HTTP3ConnectionCache22_connectionsRemoveIdleEv_block_invoke_2;
  v7[3] = &__block_descriptor_40_e14_v24__0r_v8_v16l;
  v7[4] = this;
  CFDictionaryApplyFunction((CFDictionaryRef)v10[7], (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit, v7);
  if (CFDictionaryGetCount(this[11]))
    HTTP3ConnectionCache::_timersStart((HTTP3ConnectionCache *)this);
  else
    HTTP3ConnectionCache::_timersStop((HTTP3ConnectionCache *)this);
  _Block_object_dispose(&v9, 8);
  v15 = &off_1E14EA508;
  CFRelease(cf);
}

void sub_1840CAD78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,CFTypeRef cf)
{
  _Block_object_dispose(&a21, 8);
  CFRelease(cf);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef __Block_byref_object_copy__14060(uint64_t a1, uint64_t a2)
{
  const __CFAllocator *v4;
  CFMutableDictionaryRef result;

  *(_QWORD *)(a1 + 48) = &off_1E14EA508;
  v4 = CFGetAllocator(*(CFTypeRef *)(a2 + 56));
  result = CFDictionaryCreateMutableCopy(v4, 0, *(CFDictionaryRef *)(a2 + 56));
  *(_QWORD *)(a1 + 56) = result;
  return result;
}

void __Block_byref_object_dispose__14061(uint64_t a1)
{
  *(_QWORD *)(a1 + 48) = &off_1E14EA508;
  CFRelease(*(CFTypeRef *)(a1 + 56));
}

void ___ZN20HTTP3ConnectionCache22_connectionsRemoveIdleEv_block_invoke(_QWORD *a1, const void *a2, _QWORD *a3)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  std::__shared_weak_count *v12;
  HTTP3Connection *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  const void *v19;
  const void *v20;
  CFTypeID v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  _QWORD *v25;
  const void *v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  const void *v29;
  uint8_t buf[16];

  v3 = a3[3];
  v4 = (std::__shared_weak_count *)a3[4];
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v8 = *(_QWORD *)(v3 + 104);
  v7 = *(_QWORD *)(v3 + 112);
  if (v8 == v7)
  {
LABEL_31:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1[4] + 8) + 56), a2, a3);
    goto LABEL_32;
  }
  v26 = a2;
  v27 = a3;
  v28 = v4;
  v10 = a1[5];
  v9 = a1[6];
  v25 = a1;
  v29 = (const void *)*MEMORY[0x1E0C9AE50];
  v11 = 1;
  do
  {
    v13 = *(HTTP3Connection **)v8;
    v12 = *(std::__shared_weak_count **)(v8 + 8);
    if (v12)
    {
      v14 = (unint64_t *)&v12->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    if (*((_QWORD *)v13 + 142) != *((_QWORD *)v13 + 143))
      goto LABEL_10;
    v18 = *((_QWORD *)v13 + 126);
    if (v18
      && (v19 = (const void *)(*(uint64_t (**)(uint64_t, __CFString *))(*(_QWORD *)v18 + 216))(v18, CFSTR("kCFStreamPropertyConnectionIsCellular")), (v20 = v19) != 0))
    {
      v21 = CFGetTypeID(v19);
      if (v21 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      CFRelease(v20);
      v22 = *((_QWORD *)v13 + 147);
      if (v10 != v9 && v29 == v20)
      {
        if (v22 <= v9)
          goto LABEL_29;
        goto LABEL_10;
      }
    }
    else
    {
      v22 = *((_QWORD *)v13 + 147);
    }
    if (v22 <= v10)
    {
LABEL_29:
      HTTP3Connection::stop(v13, 0);
      goto LABEL_11;
    }
LABEL_10:
    v11 = 0;
LABEL_11:
    if (v12)
    {
      v16 = (unint64_t *)&v12->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    v8 += 16;
  }
  while (v8 != v7);
  a3 = v27;
  v4 = v28;
  a1 = v25;
  a2 = v26;
  if ((v11 & 1) != 0)
    goto LABEL_31;
LABEL_32:
  if (v4)
  {
    v23 = (unint64_t *)&v4->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *, const void *, _QWORD *))v4->__on_zero_shared)(v4, a2, a3);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1840CB038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN20HTTP3ConnectionCache22_connectionsRemoveIdleEv_block_invoke_2(uint64_t a1, const HTTPConnectionCacheKey *a2, uint64_t a3)
{
  HTTP3ConnectionCache *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v4 = *(HTTP3ConnectionCache **)(a1 + 32);
  v5 = *(_QWORD *)(a3 + 24);
  v6 = *(std::__shared_weak_count **)(a3 + 32);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  HTTP3ConnectionCacheEntry::stopConnections(*(HTTP3ConnectionCacheEntry **)(v5 + 104), *(HTTP3ConnectionCacheEntry **)(v5 + 112), 0);
  HTTP3ConnectionCache::_entryRemove(v4, a2);
  if (v6)
  {
    v9 = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1840CB118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<HTTP3ConnectionCacheEntry>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0DE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTP3ConnectionCacheEntry>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0DE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

CFStringRef HTTP3ConnectionCacheEntryWrapper::copyDebugDesc(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat(this[1], 0, CFSTR("HTTP3ConnectionCacheEntryWrapper<@%p> for HTTP3ConnectionCacheEntry<@%p>"), this, this[3]);
}

uint64_t HTTP3ConnectionCacheEntryWrapper::equals(HTTP3ConnectionCacheEntryWrapper *this, const CFAllocatedReferenceCountedObject *a2)
{
  (*(void (**)(_QWORD, const CFAllocatedReferenceCountedObject *))(**((_QWORD **)this + 5) + 24))(*((_QWORD *)this + 5), a2);
  return 0;
}

uint64_t HTTP3ConnectionCacheEntryWrapper::hash(HTTP3ConnectionCacheEntryWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 5) + 32))(*((_QWORD *)this + 5));
}

void ___ZN20HTTP3ConnectionCache24_logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  _QWORD block[5];
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;

  v3 = *(_QWORD *)(a3 + 24);
  v4 = *(std::__shared_weak_count **)(a3 + 32);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = *(uint64_t **)(v3 + 104);
  v8 = *(uint64_t **)(v3 + 112);
  if (v7 != v8)
  {
    v9 = MEMORY[0x1E0C809B0];
    do
    {
      v11 = *v7;
      v10 = (std::__shared_weak_count *)v7[1];
      if (v10)
      {
        v12 = (unint64_t *)&v10->__shared_owners_;
        do
          v13 = __ldxr(v12);
        while (__stxr(v13 + 1, v12));
      }
      std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v29, *(_QWORD *)(v11 + 8), *(std::__shared_weak_count **)(v11 + 16));
      v14 = *(NSObject **)(v11 + 1000);
      block[0] = v9;
      block[1] = 3321888768;
      block[2] = ___ZN15HTTP3Connection22logConnectionAtAPSleepEv_block_invoke;
      block[3] = &__block_descriptor_48_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e5_v8__0l;
      block[4] = v29;
      v28 = v30;
      if (v30)
      {
        v15 = (unint64_t *)&v30->__shared_owners_;
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
      dispatch_async(v14, block);
      v17 = v28;
      if (v28)
      {
        v18 = (unint64_t *)&v28->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      v20 = v30;
      if (!v30)
        goto LABEL_21;
      v21 = (unint64_t *)&v30->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
        if (v10)
        {
LABEL_22:
          v23 = (unint64_t *)&v10->__shared_owners_;
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
      }
      else
      {
LABEL_21:
        if (v10)
          goto LABEL_22;
      }
      v7 += 2;
    }
    while (v7 != v8);
  }
  if (v4)
  {
    v25 = (unint64_t *)&v4->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1840CB3D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN20HTTP3ConnectionCache27_markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  _QWORD block[5];
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;

  v3 = *(_QWORD *)(a3 + 24);
  v4 = *(std::__shared_weak_count **)(a3 + 32);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = *(uint64_t **)(v3 + 104);
  v8 = *(uint64_t **)(v3 + 112);
  if (v7 != v8)
  {
    v9 = MEMORY[0x1E0C809B0];
    do
    {
      v11 = *v7;
      v10 = (std::__shared_weak_count *)v7[1];
      if (v10)
      {
        v12 = (unint64_t *)&v10->__shared_owners_;
        do
          v13 = __ldxr(v12);
        while (__stxr(v13 + 1, v12));
      }
      std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v29, *(_QWORD *)(v11 + 8), *(std::__shared_weak_count **)(v11 + 16));
      v14 = *(NSObject **)(v11 + 1000);
      block[0] = v9;
      block[1] = 3321888768;
      block[2] = ___ZN15HTTP3Connection26markReusedAfterAPSleepWakeEv_block_invoke;
      block[3] = &__block_descriptor_48_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e5_v8__0l;
      block[4] = v29;
      v28 = v30;
      if (v30)
      {
        v15 = (unint64_t *)&v30->__shared_owners_;
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
      dispatch_async(v14, block);
      v17 = v28;
      if (v28)
      {
        v18 = (unint64_t *)&v28->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      v20 = v30;
      if (!v30)
        goto LABEL_21;
      v21 = (unint64_t *)&v30->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
        if (v10)
        {
LABEL_22:
          v23 = (unint64_t *)&v10->__shared_owners_;
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
      }
      else
      {
LABEL_21:
        if (v10)
          goto LABEL_22;
      }
      v7 += 2;
    }
    while (v7 != v8);
  }
  if (v4)
  {
    v25 = (unint64_t *)&v4->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1840CB5E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements(NetworkProxyAuthorizationElements *this)
{
  uint64_t v2;

  NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  const void *v6;

  *(_QWORD *)this = off_1E14EF5C0;
  *((_QWORD *)this + 3) = &unk_1E14EF608;
  v2 = (const void *)*((_QWORD *)this + 8);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 7);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 6);
  if (v4)
    CFRelease(v4);
  v5 = *((_QWORD *)this + 5);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
  v6 = (const void *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v6)
    CFRelease(v6);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

CFStringRef NetworkProxyAuthorizationElements::copyDebugDesc(NetworkProxyAuthorizationElements *this)
{
  uint64_t v2;
  const void *v3;
  CFStringRef v4;

  v2 = *((_QWORD *)this + 5);
  if (v2)
    v3 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  else
    v3 = 0;
  v4 = CFStringCreateWithFormat(*((CFAllocatorRef *)this + 1), 0, CFSTR("<NetworkProxyAuthorizationElements %p>{cred=%@, protSpace=%@, challenge=%@ client=%@ <%@>}"), this, v3, *((_QWORD *)this + 6), *((_QWORD *)this + 7), *((_QWORD *)this + 8), *((_QWORD *)this + 9));
  if (v3)
    CFRelease(v3);
  return v4;
}

void sub_1840CB8A8(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void `non-virtual thunk to'NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements(NetworkProxyAuthorizationElements *this)
{
  NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements((NetworkProxyAuthorizationElements *)((char *)this - 24));
}

void `non-virtual thunk to'NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements((NetworkProxyAuthorizationElements *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_1840CB980(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 72);
  *(_QWORD *)(v1 + 72) = 0;
  if (v3)
    CFRelease(v3);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

void NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(NetworkProxyAuthorizationElements *this, const __CFAllocator *a2, NetworkProxyCredential *a3, CFTypeRef cf, CFTypeRef a5, CFTypeRef a6)
{
  CFTypeRef v10;
  const void *v11;

  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14EF5C0;
  *((_QWORD *)this + 3) = &unk_1E14EF608;
  *((_QWORD *)this + 9) = 0;
  if (a3)
  {
    *((_QWORD *)this + 5) = a3;
    (*(void (**)(NetworkProxyCredential *))(*(_QWORD *)a3 + 40))(a3);
  }
  *((_QWORD *)this + 6) = cf;
  if (cf)
    CFRetain(cf);
  *((_QWORD *)this + 7) = a5;
  if (a5)
    CFRetain(a5);
  *((_BYTE *)this + 32) = 0;
  if (a6)
    v10 = CFRetain(a6);
  else
    v10 = 0;
  v11 = (const void *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = v10;
  if (v11)
    CFRelease(v11);
}

void sub_1840CBA98(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 72);
  *(_QWORD *)(v1 + 72) = 0;
  if (v3)
    CFRelease(v3);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

void NetworkProxyAuthorizationElements::setProtectionSpace(NetworkProxyAuthorizationElements *this, CFTypeRef cf)
{
  const void *v4;

  v4 = (const void *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v4)
    CFRelease(v4);
  if (cf)
    *((_QWORD *)this + 6) = CFRetain(cf);
}

void NetworkProxyAuthorizationElements::setChallenge(NetworkProxyAuthorizationElements *this, CFTypeRef cf)
{
  const void *v4;

  v4 = (const void *)*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v4)
    CFRelease(v4);
  if (cf)
    *((_QWORD *)this + 7) = CFRetain(cf);
}

_OWORD *CFNetworkProxyAuthorizationElementsCreateFromDictionary(uint64_t a1, const __CFDictionary *a2)
{
  const __CFAllocator *v3;
  _OWORD *v4;
  _OWORD *v5;
  const __CFDictionary *Value;
  const __CFDictionary *v7;
  CFTypeID v8;
  _QWORD *v9;
  uint64_t v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  CFTypeID v13;
  const __CFNumber *v14;
  const __CFNumber *v15;
  CFTypeID v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  CFTypeID v19;
  int v20;
  const __CFNumber *v21;
  const __CFNumber *v22;
  CFTypeID v23;
  int v24;
  const __CFString *v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  const void *v28;
  const void *v29;
  CFTypeID v30;
  std::__shared_weak_count *v31;
  unint64_t v32;
  const __CFString *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  const void *v36;
  const void *v37;
  CFTypeID v38;
  std::__shared_weak_count *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  const void *v45;
  const void *v46;
  CFTypeID v47;
  const void *v48;
  const void *v49;
  CFTypeID v50;
  CFTypeRef v51;
  const void *v52;
  int v54;
  int v55;
  uint64_t Instance;
  int v57;
  int v58;
  int valuePtr;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 80, 0);
  *(_OWORD *)((char *)v4 + 20) = 0u;
  *(_OWORD *)((char *)v4 + 36) = 0u;
  *(_OWORD *)((char *)v4 + 52) = 0u;
  v4[4] = 0u;
  *(_QWORD *)v4 = off_1E14EF578;
  *((_QWORD *)v4 + 1) = v3;
  *((_DWORD *)v4 + 4) = 1;
  if (((unint64_t)(v4 + 1) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  v5 = v4;
  *(_QWORD *)v4 = off_1E14EF5C0;
  *((_QWORD *)v4 + 3) = &unk_1E14EF608;
  *((_QWORD *)v4 + 9) = 0;
  Value = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("kNetworkProxyAuthorizationElementsKeyCredential"));
  v7 = Value;
  if (Value)
  {
    v8 = CFGetTypeID(Value);
    if (v8 == CFDictionaryGetTypeID())
    {
      v9 = CFAllocatorAllocate(v3, 56, 0);
      v9[6] = 0;
      *((_OWORD *)v9 + 1) = 0u;
      *((_OWORD *)v9 + 2) = 0u;
      *(_OWORD *)v9 = 0u;
      NetworkProxyCredential::NetworkProxyCredential((NetworkProxyCredential *)v9, v3, v7);
      *((_QWORD *)v5 + 5) = v10;
    }
  }
  v11 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("kNetworkProxyAuthorizationElementsKeyProtectionSpace"));
  v12 = v11;
  if (v11)
  {
    v13 = CFGetTypeID(v11);
    if (v13 == CFDictionaryGetTypeID())
    {
      if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
        dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
      Instance = _CFRuntimeCreateInstance();
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3759];
      *(_QWORD *)(Instance + 16) = &off_1E14E9A20;
      *(_QWORD *)(Instance + 24) = &unk_1E14E9A78;
      *(_BYTE *)(Instance + 96) = 0;
      *(_BYTE *)(Instance + 104) = 0;
      *(_QWORD *)(Instance + 112) = 1;
      valuePtr = 0;
      v14 = (const __CFNumber *)CFDictionaryGetValue(v12, CFSTR("kCFURLProtectionSpaceKeyPort"));
      v15 = v14;
      if (v14)
      {
        v16 = CFGetTypeID(v14);
        if (v16 == CFNumberGetTypeID())
          CFNumberGetValue(v15, kCFNumberSInt32Type, &valuePtr);
      }
      v17 = (const __CFNumber *)CFDictionaryGetValue(v12, CFSTR("kCFURLProtectionSpaceKeyServerType"));
      v18 = v17;
      if (v17 && (v19 = CFGetTypeID(v17), v19 == CFNumberGetTypeID()))
      {
        v58 = 0;
        CFNumberGetValue(v18, kCFNumberSInt32Type, &v58);
        v20 = v58;
      }
      else
      {
        v20 = 1;
      }
      v55 = v20;
      v21 = (const __CFNumber *)CFDictionaryGetValue(v12, CFSTR("kCFURLProtectionSpaceKeyAuthenticationScheme"));
      v22 = v21;
      if (v21 && (v23 = CFGetTypeID(v21), v23 == CFNumberGetTypeID()))
      {
        v57 = 0;
        CFNumberGetValue(v22, kCFNumberSInt32Type, &v57);
        v24 = v57;
      }
      else
      {
        v24 = 1;
      }
      v54 = v24;
      v25 = (const __CFString *)CFRetain(&stru_1E1500C68);
      v26 = (std::__shared_weak_count *)operator new();
      v26->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v26->__shared_owners_;
      v26->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
      v26->__shared_weak_owners_ = 0;
      v26[1].__vftable = (std::__shared_weak_count_vtbl *)v25;
      v28 = CFDictionaryGetValue(v12, CFSTR("kCFURLProtectionSpaceKeyHost"));
      v29 = v28;
      if (v28)
      {
        v30 = CFGetTypeID(v28);
        if (v30 == CFStringGetTypeID())
        {
          v25 = (const __CFString *)CFRetain(v29);
          v31 = (std::__shared_weak_count *)operator new();
          v31->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
          v31->__shared_owners_ = 0;
          v31->__shared_weak_owners_ = 0;
          v31[1].__vftable = (std::__shared_weak_count_vtbl *)v25;
          do
            v32 = __ldaxr(p_shared_owners);
          while (__stlxr(v32 - 1, p_shared_owners));
          if (!v32)
          {
            ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
            std::__shared_weak_count::__release_weak(v26);
          }
          v26 = v31;
        }
      }
      v33 = (const __CFString *)CFRetain(&stru_1E1500C68);
      v34 = (std::__shared_weak_count *)operator new();
      v34->__shared_owners_ = 0;
      v35 = (unint64_t *)&v34->__shared_owners_;
      v34->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
      v34->__shared_weak_owners_ = 0;
      v34[1].__vftable = (std::__shared_weak_count_vtbl *)v33;
      v36 = CFDictionaryGetValue(v12, CFSTR("kCFURLProtectionSpaceKeyRealm"));
      v37 = v36;
      if (v36 && (v38 = CFGetTypeID(v36), v38 == CFStringGetTypeID()))
      {
        v33 = (const __CFString *)CFRetain(v37);
        v39 = (std::__shared_weak_count *)operator new();
        v39->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
        v39->__shared_owners_ = 0;
        v39->__shared_weak_owners_ = 0;
        v39[1].__vftable = (std::__shared_weak_count_vtbl *)v33;
        do
          v40 = __ldaxr(v35);
        while (__stlxr(v40 - 1, v35));
        if (!v40)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
      else
      {
        v39 = v34;
      }
      URLProtectionSpace::initialize(Instance + 16, v25, valuePtr, v55, v33, v54);
      v41 = (unint64_t *)&v39->__shared_owners_;
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
      v43 = (unint64_t *)&v26->__shared_owners_;
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
      *((_QWORD *)v5 + 6) = Instance;
    }
  }
  *((_QWORD *)v5 + 7) = 0;
  *((_BYTE *)v5 + 32) = 0;
  v45 = CFDictionaryGetValue(a2, CFSTR("kNetworkProxyAuthorizationElementsKeyClientProcessName"));
  v46 = v45;
  if (v45)
  {
    v47 = CFGetTypeID(v45);
    if (v47 == CFStringGetTypeID())
    {
      *((_QWORD *)v5 + 8) = v46;
      CFRetain(v46);
    }
  }
  v48 = CFDictionaryGetValue(a2, CFSTR("kNetworkProxyAuthorizationElementsKeyClientDescription"));
  v49 = v48;
  if (v48)
  {
    v50 = CFGetTypeID(v48);
    if (v50 == CFStringGetTypeID())
    {
      v51 = CFRetain(v49);
      v52 = (const void *)*((_QWORD *)v5 + 9);
      *((_QWORD *)v5 + 9) = v51;
      if (v52)
        CFRelease(v52);
    }
  }
  return v5;
}

void sub_1840CC0F4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  const void *v9;

  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  v7 = (unint64_t *)&v2->__shared_owners_;
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  v9 = *(const void **)(v1 + 72);
  *(_QWORD *)(v1 + 72) = 0;
  if (v9)
    CFRelease(v9);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

uint64_t CFNetworkProxyAuthorizationElementsRetain(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  return a1;
}

uint64_t CFNetworkProxyAuthorizationElementsRelease(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t CFNetworkProxyAuthorizationElementsCopyDebugDescription(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
}

uint64_t CFNetworkProxyAuthorizationElementsGetCredential(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t CFNetworkProxyAuthorizationElementsGetProtectionSpace(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

BOOL CFNetworkProxyAuthorizationElementsIsViable(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  return v1 && *(_DWORD *)(v1 + 40) == 1;
}

BOOL CFNetworkProxyAuthorizationElementsIsUnviable(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  return v1 && *(_DWORD *)(v1 + 40) == 2;
}

uint64_t CFNetworkProxyAuthorizationElementsGetClientProcessName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t CFNetworkProxyAuthorizationElementsGetClientDescription(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

void std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

BOOL XCookieStorage::equals(XCookieStorage *this, XCookieStorage *a2)
{
  return this == a2;
}

void NSXCookieStorage::NSXCookieStorage(NSXCookieStorage *this, CFTypeRef cf)
{
  uint64_t v2;

  v2 = *MEMORY[0x1E0C9AE00];
  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = v2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14E8148;
  *((_QWORD *)this + 3) = CFRetain(cf);
}

uint64_t CFXCookieStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (!newCookieStorageEnabled(void)::enabled)
  {
    v6 = *(_QWORD *)(a1 + 24);
    if (a2)
    {
      CFHTTPCookieStorageDeleteAllCookies(*(char **)(a1 + 24));
      v6 = *(_QWORD *)(a1 + 24);
      if (newCookieStorageEnabled(void)::onceToken != -1)
        dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
    }
    if (!newCookieStorageEnabled(void)::enabled)
    {
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
      if (v6)
        v7 = v6 + 16;
      else
        v7 = 0;
      HTTPCookieStorage::syncStorageWithCompletion(v7, 1, 0);
    }
  }
  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

void CFXCookieStorage::setExtraCookies(CFXCookieStorage *this, const __CFArray *a2)
{
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (!newCookieStorageEnabled(void)::enabled)
    CFHTTPCookieStorageSetCookies(*((_QWORD **)this + 3), a2, 0, 0);
}

uint64_t CFXCookieStorage::ref(CFXCookieStorage *this)
{
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
    return 0;
  else
    return *((_QWORD *)this + 3);
}

uint64_t ___ZNK16CFXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void NSXCookieStorage::~NSXCookieStorage(NSXCookieStorage *this)
{
  const void *v1;

  *(_QWORD *)this = off_1E14E8148;
  v1 = (const void *)*((_QWORD *)this + 3);
  if (v1)
    CFRelease(v1);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14E8148;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

void NSXCookieStorage::getCookiesForTask(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  void *v8;
  void *v9;
  _QWORD v10[5];
  char v11;

  v8 = (void *)MEMORY[0x186DB8C8C]();
  v9 = *(void **)(a1 + 24);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZNK16NSXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke;
  v10[3] = &unk_1E14FC7A0;
  v11 = a3;
  v10[4] = a4;
  objc_msgSend(v9, "getCookiesForTask:completionHandler:", a2, v10);
  objc_autoreleasePoolPop(v8);
}

void NSXCookieStorage::parseAndStoreCookiesForTask(id *this, const __CFArray *a2, NSURLSessionTask *a3)
{
  void *v6;
  __CFArray *CookiesWithCookieStrings;
  id v8;

  v6 = (void *)MEMORY[0x186DB8C8C]();
  CookiesWithCookieStrings = _createCookiesWithCookieStrings((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2, (const __CFURL *)-[NSURLSessionTask currentRequest_URL](a3, "currentRequest_URL"), 0, 1);
  v8 = +[NSHTTPCookie _cf2nsCookies:](NSHTTPCookie, "_cf2nsCookies:", CookiesWithCookieStrings);
  if (CookiesWithCookieStrings)
    CFRelease(CookiesWithCookieStrings);
  objc_msgSend(this[3], "storeCookies:forTask:", v8, a3);

  objc_autoreleasePoolPop(v6);
}

void NSXCookieStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v6 = (void *)MEMORY[0x186DB8C8C]();
  if (a2)
  {
    v7 = (void *)objc_msgSend(*(id *)(a1 + 24), "cookies");
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
    if (v8)
    {
      v9 = v8;
      v10 = *(_QWORD *)v13;
      do
      {
        v11 = 0;
        do
        {
          if (*(_QWORD *)v13 != v10)
            objc_enumerationMutation(v7);
          objc_msgSend(*(id *)(a1 + 24), "deleteCookie:", *(_QWORD *)(*((_QWORD *)&v12 + 1) + 8 * v11++));
        }
        while (v9 != v11);
        v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      }
      while (v9);
    }
  }
  objc_msgSend(*(id *)(a1 + 24), "_saveCookies");
  (*(void (**)(uint64_t))(a3 + 16))(a3);
  objc_autoreleasePoolPop(v6);
}

void NSXCookieStorage::setExtraCookies(id *this, const __CFArray *a2)
{
  void *v4;
  id v5;

  v4 = (void *)MEMORY[0x186DB8C8C]();
  v5 = +[NSHTTPCookie _cf2nsCookies:](NSHTTPCookie, "_cf2nsCookies:", a2);
  objc_msgSend(this[3], "setCookies:forURL:mainDocumentURL:", v5, 0, 0);

  objc_autoreleasePoolPop(v4);
}

uint64_t NSXCookieStorage::getCookieAcceptPolicy(id *this)
{
  void *v2;
  uint64_t v3;

  v2 = (void *)MEMORY[0x186DB8C8C]();
  v3 = objc_msgSend(this[3], "cookieAcceptPolicy");
  objc_autoreleasePoolPop(v2);
  return v3;
}

uint64_t NSXCookieStorage::ref(id *this)
{
  void *v2;
  uint64_t Instance;
  PrivateHTTPCookieStorage *v4;
  id v5;
  _QWORD *v6;
  CFTypeRef v7;

  v2 = (void *)MEMORY[0x186DB8C8C]();
  Instance = objc_msgSend(this[3], "_cookieStorage");
  if (!Instance)
  {
    v4 = (PrivateHTTPCookieStorage *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 80, 0);
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    *((_OWORD *)v4 + 2) = 0u;
    *((_OWORD *)v4 + 3) = 0u;
    *((_OWORD *)v4 + 4) = 0u;
    v5 = this[3];
    PrivateHTTPCookieStorage::PrivateHTTPCookieStorage(v4, 1);
    *v6 = off_1E14ED028;
    v6[3] = &unk_1E14ED100;
    if (v5)
      v7 = CFRetain(v5);
    else
      v7 = 0;
    *((_QWORD *)v4 + 9) = v7;
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    Instance = _CFRuntimeCreateInstance();
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_QWORD *)(Instance + 16) = &off_1E14E8888;
    *(_QWORD *)(Instance + 24) = &unk_1E14E88D0;
    *(_DWORD *)(Instance + 136) = 0;
    objc_msgSend(this[3], "cookieAcceptPolicy");
    HTTPCookieStorage::initialize((HTTPCookieStorage *)(Instance + 16), v4);
    (*(void (**)(PrivateHTTPCookieStorage *))(*(_QWORD *)v4 + 48))(v4);
  }
  objc_autoreleasePoolPop(v2);
  return Instance;
}

void sub_1840CC9F4(_Unwind_Exception *a1)
{
  PrivateHTTPCookieStorage *v1;

  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(v1);
  _Unwind_Resume(a1);
}

void NSCFPrivateCookieStorage::~NSCFPrivateCookieStorage(NSCFPrivateCookieStorage *this)
{
  uint64_t v2;

  NSCFPrivateCookieStorage::~NSCFPrivateCookieStorage(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14ED028;
  *((_QWORD *)this + 3) = &unk_1E14ED100;
  v2 = (const void *)*((_QWORD *)this + 9);
  if (v2)
    CFRelease(v2);
  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(this);
}

uint64_t NSCFPrivateCookieStorage::wantsSyncTimer(NSCFPrivateCookieStorage *this)
{
  return 1;
}

CFStringRef NSCFPrivateCookieStorage::copyDebugDescLocked(NSCFPrivateCookieStorage *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("NSCFPrivateCookieStorage<%p>"), *((_QWORD *)this + 9));
}

uint64_t NSCFPrivateCookieStorage::copyPersistentCookiesLocked(id *a1, uint64_t a2)
{
  _QWORD *CFCloneOfNSCookieStorage;
  uint64_t v4;

  CFCloneOfNSCookieStorage = NSCFPrivateCookieStorage::createCFCloneOfNSCookieStorage(a1);
  v4 = CFCloneOfNSCookieStorage[4];
  if (v4)
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  (*(void (**)(_QWORD *, uint64_t))(*CFCloneOfNSCookieStorage + 96))(CFCloneOfNSCookieStorage, a2);
  if (v4)
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  return (*(uint64_t (**)(_QWORD *))(*CFCloneOfNSCookieStorage + 48))(CFCloneOfNSCookieStorage);
}

void sub_1840CCAE4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t NSCFPrivateCookieStorage::newCookieArrayEnumeratorLocked(id *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *CFCloneOfNSCookieStorage;
  uint64_t v6;

  CFCloneOfNSCookieStorage = NSCFPrivateCookieStorage::createCFCloneOfNSCookieStorage(a1);
  v6 = CFCloneOfNSCookieStorage[4];
  if (v6)
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*CFCloneOfNSCookieStorage + 104))(CFCloneOfNSCookieStorage, a2, a3);
  if (v6)
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  return (*(uint64_t (**)(_QWORD *))(*CFCloneOfNSCookieStorage + 48))(CFCloneOfNSCookieStorage);
}

void sub_1840CCB6C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t NSCFPrivateCookieStorage::copyDomainCookieArrayLocked(id *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *CFCloneOfNSCookieStorage;
  uint64_t v8;
  _QWORD v10[3];
  uint64_t v11;
  void *v12;
  _QWORD v13[3];
  uint64_t v14;
  void *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  CFCloneOfNSCookieStorage = NSCFPrivateCookieStorage::createCFCloneOfNSCookieStorage(a1);
  DomainAndPartition::DomainAndPartition((uint64_t)v10, a2);
  v8 = CFCloneOfNSCookieStorage[4];
  if (v8)
    pthread_mutex_lock((pthread_mutex_t *)(v8 + 8));
  DomainAndPartition::DomainAndPartition((uint64_t)v13, (uint64_t)v10);
  (*(void (**)(_QWORD *, _QWORD *, uint64_t, uint64_t))(*CFCloneOfNSCookieStorage + 112))(CFCloneOfNSCookieStorage, v13, a3, a4);
  v13[0] = &off_1E14E9488;
  if (v15 && v15 != &v14)
    free(v15);
  if (v8)
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  v10[0] = &off_1E14E9488;
  if (v12 && v12 != &v11)
    free(v12);
  return (*(uint64_t (**)(_QWORD *))(*CFCloneOfNSCookieStorage + 48))(CFCloneOfNSCookieStorage);
}

void sub_1840CCC9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45)
{
  if (a45)
  {
    if (a45 != &a13)
      free(a45);
  }
  _Unwind_Resume(a1);
}

uint64_t NSCFPrivateCookieStorage::setCookieInternalLocked(id *this, const CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3)
{
  void *v5;
  id v6;

  v5 = (void *)MEMORY[0x186DB8C8C](this, a2, a3);
  v6 = -[NSHTTPCookie _initWithHeader:]([NSHTTPCookie alloc], "_initWithHeader:", a2);
  objc_msgSend(this[9], "performSelector:withObject:", sel_setCookie_, v6);

  objc_autoreleasePoolPop(v5);
  return 1;
}

void NSCFPrivateCookieStorage::deleteCookieInternalLocked(id *this, const CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3)
{
  void *v5;
  id v6;

  v5 = (void *)MEMORY[0x186DB8C8C](this, a2, a3);
  v6 = -[NSHTTPCookie _initWithHeader:]([NSHTTPCookie alloc], "_initWithHeader:", a2);
  objc_msgSend(this[9], "performSelector:withObject:", sel_deleteCookie_, v6);

  objc_autoreleasePoolPop(v5);
}

void NSCFPrivateCookieStorage::deleteAllCookiesLocked(id *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _BYTE v12[128];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = (void *)MEMORY[0x186DB8C8C]();
  v3 = (void *)objc_msgSend(this[9], "cookies");
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v8, v12, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v9;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v9 != v6)
          objc_enumerationMutation(v3);
        objc_msgSend(this[9], "deleteCookie:", *(_QWORD *)(*((_QWORD *)&v8 + 1) + 8 * v7++));
      }
      while (v5 != v7);
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v8, v12, 16);
    }
    while (v5);
  }
  objc_autoreleasePoolPop(v2);
}

void NSCFPrivateCookieStorage::deleteAllCookiesSinceDateLocked(uint64_t a1, uint64_t a2)
{
  void *v4;

  v4 = (void *)MEMORY[0x186DB8C8C]();
  objc_msgSend(*(id *)(a1 + 72), "removeCookiesSinceDate:", a2);
  objc_autoreleasePoolPop(v4);
}

uint64_t NSCFPrivateCookieStorage::syncStorageWithCompletionLocked(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;

  v5 = (void *)MEMORY[0x186DB8C8C]();
  objc_msgSend(*(id *)(a1 + 72), "_saveCookies");
  objc_autoreleasePoolPop(v5);
  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

uint64_t NSCFPrivateCookieStorage::addToArchiveInternalLocked(id *this, __CFArray *a2)
{
  _OWORD *CFCloneOfNSCookieStorage;
  uint64_t v4;
  const __CFString *v5;

  CFCloneOfNSCookieStorage = NSCFPrivateCookieStorage::createCFCloneOfNSCookieStorage(this);
  v4 = *((_QWORD *)CFCloneOfNSCookieStorage + 4);
  if (v4)
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  v5 = (const __CFString *)*((_QWORD *)CFCloneOfNSCookieStorage + 7);
  if (v5)
    PrivateHTTPCookieStorage::addIdentifierToArchiveInternalLocked(a2, *((__CFArray **)CFCloneOfNSCookieStorage + 6), v5, (const __CFString *)*((unsigned __int8 *)CFCloneOfNSCookieStorage + 64));
  else
    (*(void (**)(_OWORD *, __CFArray *))(*(_QWORD *)CFCloneOfNSCookieStorage + 160))(CFCloneOfNSCookieStorage, a2);
  if (v4)
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  return (*(uint64_t (**)(_OWORD *))(*(_QWORD *)CFCloneOfNSCookieStorage + 48))(CFCloneOfNSCookieStorage);
}

void sub_1840CD000(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

void NSCFPrivateCookieStorage::setCookieAcceptPolicyLocked(id *this, int a2)
{
  void *v4;

  v4 = (void *)MEMORY[0x186DB8C8C]();
  objc_msgSend(this[9], "setCookieAcceptPolicy:", a2);
  objc_autoreleasePoolPop(v4);
}

uint64_t NSCFPrivateCookieStorage::getCookieAcceptPolicyLocked(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;

  v4 = (void *)MEMORY[0x186DB8C8C]();
  v5 = objc_msgSend(*(id *)(a1 + 72), "cookieAcceptPolicy");
  objc_autoreleasePoolPop(v4);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v5);
}

uint64_t NSCFPrivateCookieStorage::visitCookiesLocked(id *a1, uint64_t a2)
{
  _QWORD *CFCloneOfNSCookieStorage;
  uint64_t v4;

  CFCloneOfNSCookieStorage = NSCFPrivateCookieStorage::createCFCloneOfNSCookieStorage(a1);
  v4 = CFCloneOfNSCookieStorage[4];
  if (v4)
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  (*(void (**)(_QWORD *, uint64_t))(*CFCloneOfNSCookieStorage + 184))(CFCloneOfNSCookieStorage, a2);
  if (v4)
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  return (*(uint64_t (**)(_QWORD *))(*CFCloneOfNSCookieStorage + 48))(CFCloneOfNSCookieStorage);
}

void sub_1840CD110(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t NSCFPrivateCookieStorage::setCookiesWithPoliciesAppliedLocked(id *this, const __CFArray *a2, const HTTPCookieStoragePolicy *a3)
{
  _QWORD *CFCloneOfNSCookieStorage;
  uint64_t v6;

  CFCloneOfNSCookieStorage = NSCFPrivateCookieStorage::createCFCloneOfNSCookieStorage(this);
  v6 = CFCloneOfNSCookieStorage[4];
  if (v6)
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  (*(void (**)(_QWORD *, const __CFArray *, const HTTPCookieStoragePolicy *))(*CFCloneOfNSCookieStorage
                                                                                       + 192))(CFCloneOfNSCookieStorage, a2, a3);
  if (v6)
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  return (*(uint64_t (**)(_QWORD *))(*CFCloneOfNSCookieStorage + 48))(CFCloneOfNSCookieStorage);
}

void sub_1840CD198(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

void `non-virtual thunk to'NSCFPrivateCookieStorage::~NSCFPrivateCookieStorage(NSCFPrivateCookieStorage *this)
{
  NSCFPrivateCookieStorage::~NSCFPrivateCookieStorage((NSCFPrivateCookieStorage *)((char *)this - 24));
}

void `non-virtual thunk to'NSCFPrivateCookieStorage::~NSCFPrivateCookieStorage(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  NSCFPrivateCookieStorage::~NSCFPrivateCookieStorage((NSCFPrivateCookieStorage *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_1840CD228(_Unwind_Exception *a1)
{
  PrivateHTTPCookieStorage *v1;

  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(v1);
  _Unwind_Resume(a1);
}

_OWORD *NSCFPrivateCookieStorage::createCFCloneOfNSCookieStorage(id *this)
{
  void *v2;
  _OWORD *v3;
  __CFArray *v4;
  const __CFArray *v5;
  unint64_t Count;
  CFRange v7;
  const void **v8;
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeRef v14;
  CFIndex range;
  const void **v16;
  _BYTE v17[248];
  CFIndex v18;
  _QWORD v19[5];
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  __int16 v24;

  v2 = (void *)MEMORY[0x186DB8C8C]();
  v3 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 88, 0);
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  v3[4] = 0u;
  *((_QWORD *)v3 + 10) = 0;
  MemoryCookieStorage::MemoryCookieStorage((MemoryCookieStorage *)v3, 0);
  v4 = +[NSHTTPCookie _ns2cfCookies:](NSHTTPCookie, "_ns2cfCookies:", objc_msgSend(this[9], "cookies"));
  v19[0] = &off_1E14ECAE8;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  if (!v4)
    goto LABEL_16;
  v5 = v4;
  v14 = CFRetain(v4);
  Count = CFArrayGetCount(v5);
  v7.length = Count;
  range = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v16 = 0;
  }
  else
  {
    if (Count <= 0x1E)
    {
      v8 = (const void **)v17;
      v16 = (const void **)v17;
LABEL_7:
      v7.location = 0;
      CFArrayGetValues(v5, v7, v8);
      v7.length = range;
      goto LABEL_8;
    }
    v8 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v16 = v8;
    v7.length = range;
    if (v8)
      goto LABEL_7;
  }
LABEL_8:
  v18 = 0;
  if (v7.length >= 1)
  {
    v9 = 0;
    do
    {
      v18 = v9 + 1;
      v10 = objc_msgSend((id)v16[v9], "_inner");
      v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10);
      v12 = *((_QWORD *)v3 + 4);
      if (v12)
        pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
      (*(void (**)(_OWORD *, uint64_t, _QWORD *))(*(_QWORD *)v3 + 120))(v3, v11, v19);
      if (v12)
        pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8));
      v9 = v18;
    }
    while (v18 < range);
  }
  CFRelease(v5);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v14);
LABEL_16:
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v19);
  objc_autoreleasePoolPop(v2);
  CFLog();
  return v3;
}

void sub_1840CD424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)(v3 - 168));
  _Unwind_Resume(a1);
}

void ___ZNK16NSXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke(uint64_t a1, __CFArray *a2)
{
  __CFArray *v2;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  void *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];
  uint64_t v15;

  v2 = a2;
  v15 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (!*(_BYTE *)(a1 + 40))
    {
      v4 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", -[__CFArray count](a2, "count"));
      v10 = 0u;
      v11 = 0u;
      v12 = 0u;
      v13 = 0u;
      v5 = -[__CFArray countByEnumeratingWithState:objects:count:](v2, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
      if (v5)
      {
        v6 = v5;
        v7 = *(_QWORD *)v11;
        do
        {
          for (i = 0; i != v6; ++i)
          {
            if (*(_QWORD *)v11 != v7)
              objc_enumerationMutation(v2);
            v9 = *(void **)(*((_QWORD *)&v10 + 1) + 8 * i);
            if ((objc_msgSend(v9, "isSecure") & 1) == 0)
              objc_msgSend(v4, "addObject:", v9);
          }
          v6 = -[__CFArray countByEnumeratingWithState:objects:count:](v2, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
        }
        while (v6);
      }
      v2 = (__CFArray *)v4;
    }
    v2 = +[NSHTTPCookie _ns2cfCookies:](NSHTTPCookie, "_ns2cfCookies:", v2);
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v2)
    CFRelease(v2);
}

uint64_t EmptyXCookieStorage::flushOrReset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 24);
  if (v3)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 72))(v3);
  else
    return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

uint64_t EmptyXCookieStorage::getCookieAcceptPolicy(EmptyXCookieStorage *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 3);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 96))(v1);
  else
    return 1;
}

void EmptyXCookieStorage::ref(EmptyXCookieStorage *this)
{
  abort();
}

void MemXCookieStorage::~MemXCookieStorage(MemXCookieStorage *this)
{
  uint64_t v2;

  MemXCookieStorage::~MemXCookieStorage(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;
  const void *v3;

  *(_QWORD *)this = off_1E14E8F98;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
    CFRelease(v3);
}

void MemXCookieStorage::getCookiesForTask(_QWORD *a1, NSURLSessionTask *a2, const __CFURL *a3, uint64_t a4)
{
  NSURLSessionTask *v8;
  uint64_t v9;
  _QWORD v10[7];
  char v11;

  if (a1[3])
  {
    v8 = a2;
    (*(void (**)(_QWORD *))(*a1 + 40))(a1);
    v9 = a1[3];
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3221225472;
    v10[2] = ___ZNK17MemXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke;
    v10[3] = &unk_1E14FC7F0;
    v10[5] = a4;
    v10[6] = a1;
    v11 = (char)a3;
    v10[4] = a2;
    (*(void (**)(uint64_t, NSURLSessionTask *, const __CFURL *, _QWORD *))(*(_QWORD *)v9 + 56))(v9, a2, a3, v10);
  }
  else
  {
    MemXCookieStorage::getCookiesForTask0((uint64_t)a1, a2, a3, 0, a4);
  }
}

void MemXCookieStorage::parseAndStoreCookiesForTask(CFTypeRef *this, const __CFArray *a2, NSURLSessionTask *a3)
{
  const __CFURL *v6;
  const void *v7;
  const __CFAllocator *v8;
  __CFArray *CookiesWithCookieStrings;
  NSURL *PolicyPropertiesFromTask;
  const __CFDictionary *v11;
  char *v12;
  HTTPCookieStorage *v13;
  _BYTE v14[104];

  v6 = *(const __CFURL **)(-[NSURLRequest _inner](-[NSURLSessionTask currentRequest](a3, "currentRequest"), "_inner") + 8);
  v7 = *(const void **)(-[NSURLRequest _inner](-[NSURLSessionTask currentRequest](a3, "currentRequest"), "_inner") + 32);
  v8 = CFGetAllocator(this[4]);
  CookiesWithCookieStrings = _createCookiesWithCookieStrings(v8, a2, v6, 0, 1);
  PolicyPropertiesFromTask = getPolicyPropertiesFromTask(a3);
  if (CookiesWithCookieStrings)
  {
    v11 = (const __CFDictionary *)PolicyPropertiesFromTask;
    if (CFArrayGetCount(CookiesWithCookieStrings) >= 1)
    {
      HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v14, v6, v7, (uint64_t)-[NSURLSessionTask _storagePartitionIdentifier](a3, "_storagePartitionIdentifier"), -[NSURLSessionTask _cookieAcceptPolicy](a3, "_cookieAcceptPolicy"), 1, v11);
      v12 = (char *)this[4];
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
      if (v12)
        v13 = (HTTPCookieStorage *)(v12 + 16);
      else
        v13 = 0;
      HTTPCookieStorage::setCookiesWithPolicy(v13, CookiesWithCookieStrings, (const HTTPCookieStoragePolicy *)v14);
      HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v14);
    }
    CFRelease(CookiesWithCookieStrings);
  }
}

void sub_1840CD870(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

uint64_t MemXCookieStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  if (a2)
    CFHTTPCookieStorageDeleteAllCookies(*(char **)(a1 + 32));
  v5 = *(_QWORD *)(a1 + 32);
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (!newCookieStorageEnabled(void)::enabled)
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    if (v5)
      v6 = v5 + 16;
    else
      v6 = 0;
    HTTPCookieStorage::syncStorageWithCompletion(v6, 1, 0);
  }
  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

void MemXCookieStorage::setExtraCookies(MemXCookieStorage *this, const __CFArray *a2)
{
  CFHTTPCookieStorageSetCookies(*((_QWORD **)this + 4), a2, 0, 0);
}

uint64_t MemXCookieStorage::getCookieAcceptPolicy(char **this)
{
  return CFHTTPCookieStorageGetCookieAcceptPolicy(this[4]);
}

uint64_t MemXCookieStorage::ref(MemXCookieStorage *this)
{
  return *((_QWORD *)this + 4);
}

void MemXCookieStorage::getCookiesForTask0(uint64_t a1, NSURLSessionTask *a2, const __CFURL *a3, const void *a4, uint64_t a5)
{
  NSURL *v10;
  NSURL *v11;
  NSURL *PolicyPropertiesFromTask;
  NSHTTPCookieStorage *v13;
  int CookieAcceptPolicy;
  uint64_t v15;
  PrivateHTTPCookieStorage *v16;
  uint64_t v17;
  HTTPCookieStorage *v18;
  CFMutableArrayRef v19;
  const __CFAllocator *v20;
  __CFSet *Mutable;
  unint64_t Count;
  CFRange v23;
  const void **v24;
  CFIndex v25;
  unint64_t v26;
  CFRange v27;
  const void **v28;
  CFIndex v29;
  uint64_t v30;
  const void **v31;
  CFArrayRef v32;
  CFTypeRef v33;
  CFIndex v34;
  const void **v35;
  _BYTE v36[248];
  CFIndex v37;
  CFTypeRef v38;
  CFIndex range;
  const void **v40;
  _BYTE v41[248];
  CFIndex v42;
  _BYTE v43[112];

  v10 = -[NSURLSessionTask currentRequest_URL](a2, "currentRequest_URL");
  v11 = -[NSURLSessionTask currentRequest_mainDocumentURL](a2, "currentRequest_mainDocumentURL");
  PolicyPropertiesFromTask = getPolicyPropertiesFromTask(a2);
  v13 = -[NSURLSessionConfiguration HTTPCookieStorage](-[NSURLSessionTask _effectiveConfiguration](a2, "_effectiveConfiguration"), "HTTPCookieStorage");
  CookieAcceptPolicy = -[NSURLSessionTask _cookieAcceptPolicy](a2, "_cookieAcceptPolicy");
  if ((objc_opt_respondsToSelector() & 1) != 0
    && -[NSHTTPCookieStorage _overrideSessionCookieAcceptPolicy](v13, "_overrideSessionCookieAcceptPolicy"))
  {
    v15 = *(_QWORD *)(a1 + 32);
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    v16 = *(PrivateHTTPCookieStorage **)(v15 + 32);
    if (v16)
      CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v16);
    else
      CookieAcceptPolicy = 2;
  }
  HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v43, v10, v11, (uint64_t)-[NSURLSessionTask _storagePartitionIdentifier](a2, "_storagePartitionIdentifier"), CookieAcceptPolicy, 0, (const __CFDictionary *)PolicyPropertiesFromTask);
  v17 = *(_QWORD *)(a1 + 32);
  if (v17)
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    v18 = (HTTPCookieStorage *)(v17 + 16);
  }
  else
  {
    v18 = 0;
  }
  v19 = HTTPCookieStorage::copyCookiesForURLWithMainDocumentURL(v18, (const HTTPCookieStoragePolicy *)v43, a3);
  if (v19)
  {
    if (a4)
    {
      v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
      v38 = CFRetain(a4);
      Count = CFArrayGetCount((CFArrayRef)a4);
      v23.length = Count;
      range = Count;
      if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v40 = 0;
      }
      else
      {
        if (Count <= 0x1E)
        {
          v24 = (const void **)v41;
          v40 = (const void **)v41;
LABEL_23:
          v23.location = 0;
          CFArrayGetValues((CFArrayRef)a4, v23, v24);
          goto LABEL_24;
        }
        v24 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
        v40 = v24;
        if (v24)
        {
          v23.length = range;
          goto LABEL_23;
        }
      }
LABEL_24:
      v42 = 0;
      while (1)
      {
        v25 = v42;
        if (v42 >= range)
          break;
        ++v42;
        CFSetAddValue(Mutable, v40[v25]);
      }
      CFRelease(a4);
      v33 = CFRetain(v19);
      v26 = CFArrayGetCount(v19);
      v27.length = v26;
      v34 = v26;
      if (v26 - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v35 = 0;
      }
      else
      {
        if (v26 <= 0x1E)
        {
          v28 = (const void **)v36;
          v35 = (const void **)v36;
LABEL_33:
          v27.location = 0;
          CFArrayGetValues(v19, v27, v28);
          goto LABEL_34;
        }
        v28 = (const void **)malloc_type_malloc(8 * v26, 0x89ED541CuLL);
        v35 = v28;
        if (v28)
        {
          v27.length = v34;
          goto LABEL_33;
        }
      }
LABEL_34:
      v37 = 0;
      while (1)
      {
        v29 = v37;
        if (v37 >= v34)
          break;
        ++v37;
        CFSetAddValue(Mutable, v35[v29]);
      }
      CFRelease(v19);
      v30 = CFSetGetCount(Mutable);
      if (v30 < 1)
      {
        v32 = 0;
        if (!Mutable)
        {
LABEL_42:
          (*(void (**)(uint64_t, CFArrayRef))(a5 + 16))(a5, v32);
          CFRelease(v19);
          CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v33);
          CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v38);
          goto LABEL_43;
        }
      }
      else
      {
        v31 = (const void **)operator new[]();
        CFSetGetValues(Mutable, v31);
        v32 = CFArrayCreate(v20, v31, v30, MEMORY[0x1E0C9B378]);
        MEMORY[0x186DB7474](v31, 0x60C8044C4A2DFLL);
        if (!Mutable)
          goto LABEL_42;
      }
      CFRelease(Mutable);
      goto LABEL_42;
    }
    (*(void (**)(uint64_t, CFMutableArrayRef))(a5 + 16))(a5, v19);
    CFRelease(v19);
  }
  else
  {
    (*(void (**)(uint64_t, const void *))(a5 + 16))(a5, a4);
  }
LABEL_43:
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v43);
}

void sub_1840CDD44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  uint64_t v44;

  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a9);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a44);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)(v44 - 192));
  _Unwind_Resume(a1);
}

uint64_t ___ZNK17MemXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 48);
  MemXCookieStorage::getCookiesForTask0(v3, *(NSURLSessionTask **)(a1 + 32), (const __CFURL *)*(unsigned __int8 *)(a1 + 56), a2, *(_QWORD *)(a1 + 40));

  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
}

BOOL HTTPHeaderDict::equals(CFTypeRef *this, CFTypeRef *a2)
{
  return CFEqual(this[1], a2[1]) != 0;
}

CFStringRef HTTPHeaderDict::copyDebugDesc(HTTPHeaderDict *this)
{
  CFStringRef v2;
  char *v3;
  const __CFAllocator *v4;
  CFMutableDictionaryRef v5;
  const __CFAllocator *v6;
  CFStringRef v7;

  v2 = CFObject::copyDebugDescHeader(this);
  v3 = (char *)this - 16;
  v4 = CFGetAllocator((char *)this - 16);
  v5 = HTTPHeaderDict::copyAsOrdinaryDict((CFDictionaryRef *)this, v4);
  v6 = CFGetAllocator(v3);
  v7 = CFStringCreateWithFormat(v6, 0, CFSTR("%@ { %@ }"), v2, v5);
  if (v5)
    CFRelease(v5);
  if (v2)
    CFRelease(v2);
  return v7;
}

uint64_t visit(uint64_t result, CFTypeRef cf, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  CFTypeID v6;
  uint64_t v7;
  CFIndex i;
  const void *ValueAtIndex;

  if (result)
  {
    if (cf)
    {
      v4 = result;
      v5 = *a3;
      v6 = CFGetTypeID(cf);
      result = CFArrayGetTypeID();
      if (v6 == result)
      {
        result = CFArrayGetCount((CFArrayRef)cf);
        if (result >= 1)
        {
          v7 = result;
          for (i = 0; i != v7; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, i);
            result = (*(uint64_t (**)(uint64_t, uint64_t, const void *))(v5 + 16))(v5, v4, ValueAtIndex);
          }
        }
      }
    }
  }
  return result;
}

void sub_1840CE13C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1840CE234(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1840CE2FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840CE3A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840CE454(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840CE504(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840CE65C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;

  a9.super_class = (Class)__NSURLSessionWebSocketTask;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1840CE7C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840CEEF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1840CF0A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1840CFB34(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id webSocketLog(void)
{
  if (webSocketLog(void)::onceToken != -1)
    dispatch_once(&webSocketLog(void)::onceToken, &__block_literal_global_14289);
  return (id)webSocketLog(void)::logHandle;
}

uint64_t __copy_helper_block_ea8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void ___ZL12webSocketLogv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.cfnetwork", "websocket");
  v1 = (void *)webSocketLog(void)::logHandle;
  webSocketLog(void)::logHandle = (uint64_t)v0;

}

void sub_1840CFFF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void sub_1840D0274(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840D0438(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1840D0560(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840D0744(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840D0968(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840D0AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1840D0BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1840D0E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  _Unwind_Resume(a1);
}

void sub_1840D0FD4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840D1160(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840D1210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1840D1390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1840D1560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1840D16C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1840D1B40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1840D1CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_1840D1E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void sub_1840D20E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1840D2248(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840D2358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_1840D2420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void `non-virtual thunk to'HTTPParser::~HTTPParser(HTTPParser *this)
{
  char *v2;

  *((_QWORD *)this - 2) = off_1E14E49E0;
  *(_QWORD *)this = &unk_1E14E4A00;
  *((_QWORD *)this + 1) = 0;
  v2 = (char *)*((_QWORD *)this + 68);
  if (v2 != (char *)this + 28)
    free(v2);
  *(_QWORD *)this = &off_1E14E5838;
}

{
  char *v2;
  char *v3;

  *((_QWORD *)this - 2) = off_1E14E49E0;
  v2 = (char *)this - 16;
  *(_QWORD *)this = &unk_1E14E4A00;
  *((_QWORD *)this + 1) = 0;
  v3 = (char *)*((_QWORD *)this + 68);
  if (v3 != (char *)this + 28)
    free(v3);
  *(_QWORD *)this = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 1), v2);
}

char *HTTPParser::growBuffer(char *this)
{
  uint64_t v1;
  char *v2;
  size_t v3;
  char *v4;

  v1 = *((_QWORD *)this + 71);
  if (v1 >= 1)
  {
    v2 = this;
    v3 = 2 * v1;
    v4 = (char *)*((_QWORD *)this + 70);
    if (v4 == this + 44)
    {
      this = (char *)malloc_type_malloc(v3, 0x4FA712BFuLL);
      *((_QWORD *)v2 + 70) = this;
      if (this)
        this = (char *)memcpy(this, v4, *((_QWORD *)v2 + 71));
    }
    else
    {
      this = (char *)malloc_type_realloc(*((void **)this + 70), v3, 0x3E977CC1uLL);
      *((_QWORD *)v2 + 70) = this;
    }
    *((_QWORD *)v2 + 71) = v3;
  }
  return this;
}

BOOL ConnectionEPTManager::_computeNewTarget(ConnectionEPTManager *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v3 = *((_QWORD *)this + 2);
  v2 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 2) = 0;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v11;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v11 != v6)
          objc_enumerationMutation(v2);
        v8 = objc_msgSend(*(id *)(*((_QWORD *)&v10 + 1) + 8 * v7), "_expectedProgressTarget");
        if (v8 && *((_QWORD *)this + 2) - 1 >= v8)
          *((_QWORD *)this + 2) = v8;
        ++v7;
      }
      while (v5 != v7);
      v5 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
    }
    while (v5);
  }
  return *((_QWORD *)this + 2) != v3;
}

uint64_t ConnectionEPTManager::taskTargetChanged(ConnectionEPTManager *this)
{
  uint64_t result;

  result = ConnectionEPTManager::_computeNewTarget(this);
  if ((_DWORD)result)
  {
    result = *((_QWORD *)this + 1);
    if (result)
      return (*(uint64_t (**)(uint64_t, _QWORD))(result + 16))(result, *((_QWORD *)this + 2));
  }
  return result;
}

void sub_1840D2F04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void sub_1840D3378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  AutoString::~AutoString((AutoString *)&a33);
  _Unwind_Resume(a1);
}

void *copyNSCredentialDictForCFCredentialDict(const __CFDictionary *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  const void *v8;
  id v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = (void *)-[__CFDictionary mutableCopy](a1, "mutableCopy");
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v3 = (void *)objc_msgSend(v2, "allKeys", 0);
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v12;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v12 != v6)
          objc_enumerationMutation(v3);
        v8 = *(const void **)(*((_QWORD *)&v11 + 1) + 8 * i);
        v9 = -[NSURLCredential _initWithCFURLCredential:]([NSURLCredential alloc], "_initWithCFURLCredential:", CFDictionaryGetValue(a1, v8));
        objc_msgSend(v2, "setObject:forKey:", v9, v8);

      }
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    }
    while (v5);
  }
  return v2;
}

CFStringRef HTTPRequestMessage::copyDebugDesc(HTTPRequestMessage *this)
{
  HTTPRequestParserClient *v2;
  char *v3;
  const void *v4;
  CFTypeRef v5;
  const __CFAllocator *v6;
  uint64_t v7;
  CFStringRef v8;

  v2 = (HTTPRequestMessage *)((char *)this + 128);
  v3 = (char *)this - 16;
  CFGetAllocator((char *)this - 16);
  v4 = (const void *)*((_QWORD *)this + 19);
  if (v4)
    v5 = CFRetain(v4);
  else
    v5 = 0;
  v6 = CFGetAllocator(v3);
  v7 = HTTPRequestParserClient::requestURL(v2);
  v8 = CFStringCreateWithFormat(v6, 0, CFSTR("<CFHTTPMessageRef %p(%p)> { %@ request, url %@ }"), v3, this, v5, v7);
  if (v5)
    CFRelease(v5);
  return v8;
}

CFStringRef HTTPRequestMessage::copyDebugSummary(HTTPRequestMessage *this)
{
  char *v2;
  const void *v3;
  CFTypeRef v4;
  const void *v6;
  CFTypeRef v7;
  HTTPRequestParserClient *v8;
  int v9;
  const __CFAllocator *v10;
  const __CFAllocator *v11;
  const __CFURL *v12;
  CFStringRef v13;
  uint64_t v14;
  uint64_t v15;
  CFAllocatorRef allocator;
  uint64_t v17;
  void *ptr;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 22) && (!*((_QWORD *)this + 19) || !*((_QWORD *)this + 5)))
    return (CFStringRef)CFRetain(CFSTR("not yet parsed"));
  v2 = (char *)this - 16;
  CFGetAllocator((char *)this - 16);
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    v4 = CFRetain(v3);
  else
    v4 = 0;
  CFGetAllocator((char *)this - 16);
  v6 = (const void *)*((_QWORD *)this + 19);
  if (v6)
    v7 = CFRetain(v6);
  else
    v7 = 0;
  v8 = (HTTPRequestMessage *)((char *)this + 128);
  if (__CFNCanLogSensitiveContent::onceToken != -1)
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
  v9 = __CFNCanLogSensitiveContent::ok;
  v10 = CFGetAllocator((char *)this - 16);
  if (v9)
  {
    v11 = CFGetAllocator(v2);
    v12 = (const __CFURL *)HTTPRequestParserClient::requestURL(v8);
    URLPortion::URLPortion((URLPortion *)&allocator, v11, v12, 1);
    v13 = CFStringCreateWithFormat(v10, 0, CFSTR("%@ %s %@"), v7, v19, v4);
    if (ptr != &v17)
      CFAllocatorDeallocate(allocator, ptr);
    if (!v4)
      goto LABEL_20;
    goto LABEL_19;
  }
  v14 = objc_msgSend((id)HTTPRequestParserClient::requestURL(v8), "scheme");
  v15 = objc_msgSend((id)HTTPRequestParserClient::requestURL(v8), "host");
  v13 = CFStringCreateWithFormat(v10, 0, CFSTR("%@ %@://%@/<redacted>"), v7, v14, v15);
  if (v4)
LABEL_19:
    CFRelease(v4);
LABEL_20:
  if (v7)
    CFRelease(v7);
  return v13;
}

void sub_1840D3778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const __CFAllocator *allocator, uint64_t a14)
{
  if ((uint64_t *)STACK[0x228] != &a14)
    CFAllocatorDeallocate(allocator, (void *)STACK[0x228]);
  _Unwind_Resume(a1);
}

uint64_t HTTPRequestMessage::parserAddHeader(HTTPRequestMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  return (*(uint64_t (**)(char *, const HTTPHeaderKeyMixedValue *, const HTTPHeaderValueMixedValue *))(*((_QWORD *)this + 16) + 24))((char *)this + 128, a2, a3);
}

uint64_t HTTPRequestMessage::parserCompleteFirstLine(HTTPRequestMessage *this, const unsigned __int8 *a2)
{
  return (*(uint64_t (**)(char *, const unsigned __int8 *))(*((_QWORD *)this + 16) + 16))((char *)this + 128, a2);
}

uint64_t HTTPRequestMessage::mutableVersion(HTTPRequestMessage *this)
{
  return (uint64_t)this + 32;
}

void `non-virtual thunk to'HTTPRequestMessage::~HTTPRequestMessage(HTTPRequestMessage *this)
{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 8));
}

{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 8));
}

{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 16));
}

{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 16));
}

{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 128));
}

{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 128));
}

uint64_t `non-virtual thunk to'HTTPRequestMessage::parserCompleteFirstLine(HTTPRequestMessage *this, const unsigned __int8 *a2)
{
  return (*(uint64_t (**)(char *, const unsigned __int8 *))(*((_QWORD *)this + 14) + 16))((char *)this + 112, a2);
}

uint64_t `non-virtual thunk to'HTTPRequestMessage::parserAddHeader(HTTPRequestMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  return (*(uint64_t (**)(char *, const HTTPHeaderKeyMixedValue *, const HTTPHeaderValueMixedValue *))(*((_QWORD *)this + 14) + 24))((char *)this + 112, a2, a3);
}

uint64_t `non-virtual thunk to'HTTPRequestMessage::mutableVersion(HTTPRequestMessage *this)
{
  return (uint64_t)this - 96;
}

HTTPHeaderDict *`non-virtual thunk to'HTTPRequestMessage::mutableHeaders(HTTPRequestMessage *this)
{
  return HTTPMessage::mutableHeaders((HTTPRequestMessage *)((char *)this - 128));
}

CFStringRef HTTPResponseMessage::copyDebugDesc(HTTPResponseMessage *this)
{
  const char *v2;
  const __CFAllocator *v3;
  int v5;
  const char *v7;
  const __CFAllocator *v8;
  uint64_t v9;
  const __CFData **Length;
  const __CFAllocator *v11;

  if (*((_QWORD *)this + 36) || *((_BYTE *)this + 160))
  {
    if (*((_QWORD *)this + 16) != -1)
    {
      v2 = "parsed";
LABEL_5:
      v3 = CFGetAllocator((char *)this - 16);
      return CFStringCreateWithFormat(v3, 0, CFSTR("<CFHTTPMessageRef %p(%p)> { %s response, url = %@, status = %ld }"), (char *)this - 16, this, v2, *((_QWORD *)this + 18), *((_QWORD *)this + 16));
    }
LABEL_16:
    v11 = CFGetAllocator((char *)this - 16);
    return CFStringCreateWithFormat(v11, 0, CFSTR("<CFHTTPMessageRef %p(%p)> { incomplete response, url = %@ }"), (char *)this - 16, this, *((_QWORD *)this + 18));
  }
  v5 = *((_DWORD *)this + 32);
  if (v5 != 200 && v5 != -1)
  {
    if (*((_QWORD *)this + 16) != -1)
    {
      v2 = "incomplete";
      goto LABEL_5;
    }
    goto LABEL_16;
  }
  v8 = CFGetAllocator((char *)this - 16);
  v9 = *((_QWORD *)this + 18);
  Length = (const __CFData **)*((_QWORD *)this + 6);
  if (Length)
    Length = (const __CFData **)HTTPBodyData::getLength(Length, v7);
  return CFStringCreateWithFormat(v8, 0, CFSTR("<CFHTTPMessageRef %p(%p)> { simple response, url = %@, body = %ld bytes }"), (char *)this - 16, this, v9, Length);
}

CFStringRef HTTPResponseMessage::copyDebugSummary(HTTPResponseMessage *this)
{
  char *v1;
  const __CFAllocator *v2;

  v1 = (char *)*((_QWORD *)this + 36);
  if (!v1)
  {
    v1 = (char *)this + 160;
    if (!*((_BYTE *)this + 160))
      return (CFStringRef)CFRetain(CFSTR("not yet parsed"));
  }
  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("%s"), v1);
}

void HTTPResponseMessage::parserAddHeader(HTTPResponseMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  HTTPHeaderDict *v5;

  v5 = HTTPMessage::mutableHeaders(this);
  HTTPHeaderDict::addValue((uint64_t)v5, (uint64_t)a2, (uint64_t)a3);
}

void `non-virtual thunk to'HTTPResponseMessage::~HTTPResponseMessage(HTTPResponseMessage *this)
{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 8));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 8));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 16));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 16));
}

void HTTPResponseMessage::uninitFirstLine(HTTPResponseMessage *this)
{
  const void *v2;
  void *v3;

  v2 = (const void *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v2)
    CFRelease(v2);
  v3 = (void *)*((_QWORD *)this + 36);
  if (v3)
  {
    free(v3);
    *((_QWORD *)this + 36) = 0;
  }
  *((_BYTE *)this + 160) = 0;
}

void sub_1840D3AD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840D3BA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1840D3C48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840D402C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1840D446C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1840D4664(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v8 = v6;

  _Unwind_Resume(a1);
}

void sub_1840D4894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1840D4E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1840D4F0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840D528C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v3;

  _Unwind_Resume(a1);
}

void sub_1840D5448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1840D56A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1840D6964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  void *v28;
  void *v29;
  void *v30;

  _Unwind_Resume(a1);
}

void sub_1840D6E7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1840D6F44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void SegmentedData::PrivateAllocation::~PrivateAllocation(CFAllocatorRef *this)
{
  CFAllocatorDeallocate(this[1], this);
}

uint64_t SegmentedData::PrivateAllocation::ptr(SegmentedData::PrivateAllocation *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t SegmentedData::PrivateAllocation::length(SegmentedData::PrivateAllocation *this)
{
  return *((_QWORD *)this + 4) - *((_QWORD *)this + 3);
}

void SegmentedData::~SegmentedData(SegmentedData *this)
{
  _QWORD *v2;
  _QWORD *v3;

  *(_QWORD *)this = off_1E14E6898;
  v2 = (_QWORD *)*((_QWORD *)this + 3);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)v2[2];
      (*(void (**)(_QWORD *))(*v2 + 8))(v2);
      *((_QWORD *)this + 3) = v3;
      v2 = v3;
    }
    while (v3);
  }
}

{
  _QWORD *v2;
  _QWORD *v3;

  *(_QWORD *)this = off_1E14E6898;
  v2 = (_QWORD *)*((_QWORD *)this + 3);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)v2[2];
      (*(void (**)(_QWORD *))(*v2 + 8))(v2);
      *((_QWORD *)this + 3) = v3;
      v2 = v3;
    }
    while (v3);
  }
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

CFStringRef SegmentedData::copyDebugDesc(SegmentedData *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 3);
  if (v1)
  {
    v2 = 0;
    do
    {
      ++v2;
      v1 = *(_QWORD *)(v1 + 16);
    }
    while (v1);
  }
  else
  {
    v2 = 0;
  }
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<SegmentedData@%p> { %ld bytes in %ld segments }"), this, *((_QWORD *)this + 5), v2);
}

void SynchronizedData::~SynchronizedData(SynchronizedData *this)
{
  CoreCondLock *v1;
  uint64_t v2;

  *(_QWORD *)this = off_1E14E8258;
  *((_QWORD *)this + 2) = &unk_1E14E8278;
  v1 = (SynchronizedData *)((char *)this + 16);
  v2 = *((_QWORD *)this + 17);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  CoreCondLock::~CoreCondLock(v1);
}

{
  CoreCondLock *v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E14E8258;
  *((_QWORD *)this + 2) = &unk_1E14E8278;
  v2 = (SynchronizedData *)((char *)this + 16);
  v3 = *((_QWORD *)this + 17);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  CoreCondLock::~CoreCondLock(v2);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

void `non-virtual thunk to'SynchronizedData::~SynchronizedData(SynchronizedData *this)
{
  uint64_t v2;

  *((_QWORD *)this - 2) = off_1E14E8258;
  *(_QWORD *)this = &unk_1E14E8278;
  v2 = *((_QWORD *)this + 15);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  CoreCondLock::~CoreCondLock(this);
}

{
  char *v2;
  uint64_t v3;

  *((_QWORD *)this - 2) = off_1E14E8258;
  v2 = (char *)this - 16;
  *(_QWORD *)this = &unk_1E14E8278;
  v3 = *((_QWORD *)this + 15);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  CoreCondLock::~CoreCondLock(this);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 1), v2);
}

CFStringRef HSTSCache::copyDebugDesc(HSTSCache *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<HSTSCache@%p> { %p }"), this, *((_QWORD *)this + 6));
}

void `non-virtual thunk to'HSTSCache::~HSTSCache(HSTSCache *this)
{
  HSTSCache::~HSTSCache((HSTSCache *)((char *)this - 8));
}

{
  HSTSCache::~HSTSCache((HSTSCache *)((char *)this - 8));
}

void HSTSCache::~HSTSCache(HSTSCache *this)
{
  NSObject *v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  const void *v7;
  const void *v8;
  const void *v9;

  *(_QWORD *)this = &off_1E14EFE00;
  *((_QWORD *)this + 1) = &unk_1E14EFE48;
  dispatch_release(*((dispatch_object_t *)this + 2));
  v2 = *((_QWORD *)this + 3);
  if (v2)
    dispatch_release(v2);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    dispatch_source_cancel(v3);
  v4 = *((_QWORD *)this + 5);
  if (v4 >= 1)
  {
    do
    {
      *((_QWORD *)this + 5) = --v4;
      if (!v4)
      {
        v5 = *((_QWORD *)this + 4);
        if (!v5)
          goto LABEL_12;
        dispatch_resume(v5);
        v4 = *((_QWORD *)this + 5);
      }
    }
    while (v4 > 0);
  }
  v6 = *((_QWORD *)this + 4);
  if (v6)
    dispatch_release(v6);
LABEL_12:
  v7 = (const void *)*((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v9)
    CFRelease(v9);
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void _CFNetworkSetHSTSStoragePath(const void *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&HSTSPathOverrideLock);
  if (a1)
    CFRetain(a1);
  if (HSTSPathOverride)
    CFRelease((CFTypeRef)HSTSPathOverride);
  HSTSPathOverride = (uint64_t)a1;
  os_unfair_lock_unlock((os_unfair_lock_t)&HSTSPathOverrideLock);
}

void sub_1840D73DC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&HSTSPathOverrideLock);
  _Unwind_Resume(a1);
}

CFDictionaryRef ___ZNK9HSTSCache40copyInternalRepresentationOfHSTSPoliciesEv_block_invoke(CFDictionaryRef result)
{
  const __CFDictionary *v1;
  CFDictionaryRef v2;

  v1 = *(const __CFDictionary **)(*((_QWORD *)result + 5) + 56);
  if (v1)
  {
    v2 = result;
    result = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v1);
    *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 4) + 8) + 24) = result;
  }
  return result;
}

void HSTSCache::modifyHSTSStore(HSTSCache *this, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4)
{
  NSObject *v8;
  _QWORD v9[8];

  if (cf)
    CFRetain(cf);
  if (a3)
    CFRetain(a3);
  if (a4)
    CFRetain(a4);
  v8 = *((_QWORD *)this + 2);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN9HSTSCache15modifyHSTSStoreEPK10__CFStringPK14__CFDictionaryPK8__CFDate_block_invoke;
  v9[3] = &__block_descriptor_64_e5_v8__0l;
  v9[4] = this;
  v9[5] = cf;
  v9[6] = a3;
  v9[7] = a4;
  dispatch_sync(v8, v9);
}

void ___ZN9HSTSCache15modifyHSTSStoreEPK10__CFStringPK14__CFDictionaryPK8__CFDate_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  __CFDictionary *v5;
  uint64_t v6;
  uint64_t *v7;
  CFIndex Count;
  CFIndex v9;
  size_t v10;
  const void **v11;
  const void **v12;
  uint64_t i;
  CFTypeID v14;
  const __CFString *v15;
  uint64_t v16;
  double TimeForKey;
  const __CFAllocator *v18;
  CFMutableDictionaryRef Mutable;
  const void *v20;
  const __CFAllocator *v21;
  CFMutableDictionaryRef v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  dispatch_source_t v27;
  NSObject *v28;
  dispatch_time_t v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  _QWORD v33[4];
  id v34;
  id location;

  v2 = a1[4];
  if (!*(_BYTE *)(v2 + 88) && *(_BYTE *)(v2 + 73))
  {
    v6 = *(_QWORD *)(v2 + 80);
    v7 = (uint64_t *)MEMORY[0x1E0C9AE40];
    if (!v6)
    {
      if (*(_QWORD *)(v2 + 32))
      {
        v6 = 0;
      }
      else
      {
        v27 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(v2 + 16));
        *(_QWORD *)(v2 + 32) = v27;
        if (!v27)
          goto LABEL_35;
        v28 = v27;
        v29 = dispatch_time(0x8000000000000000, 5000000000);
        dispatch_source_set_timer(v28, v29, 0x12A05F200uLL, 0x3B9ACA00uLL);
        objc_initWeak(&location, (id)(v2 - 16));
        v30 = *(NSObject **)(v2 + 32);
        v33[0] = MEMORY[0x1E0C809B0];
        v33[1] = 3221225472;
        v33[2] = ___ZN9HSTSCache24initPersistentStoreTimerEv_block_invoke;
        v33[3] = &unk_1E14FCD98;
        objc_copyWeak(&v34, &location);
        dispatch_source_set_event_handler(v30, v33);
        *(_QWORD *)(v2 + 40) = 1;
        objc_destroyWeak(&v34);
        objc_destroyWeak(&location);
        if (*(_QWORD *)(v2 + 32))
        {
          v6 = *v7;
          *(_QWORD *)(v2 + 80) = *v7;
        }
        else
        {
LABEL_35:
          *(_BYTE *)(v2 + 88) = 1;
          v6 = *(_QWORD *)(v2 + 80);
        }
      }
    }
    if (v6 == *v7)
    {
      *(_QWORD *)(v2 + 80) = *MEMORY[0x1E0C9AE50];
      v31 = *(_QWORD *)(v2 + 40) - 1;
      *(_QWORD *)(v2 + 40) = v31;
      if (!v31)
      {
        v32 = *(NSObject **)(v2 + 32);
        if (v32)
          dispatch_resume(v32);
      }
    }
  }
  v3 = (const void *)a1[5];
  if (v3)
  {
    v4 = (const void *)a1[6];
    v5 = *(__CFDictionary **)(v2 + 56);
    if (v4)
    {
      CFDictionarySetValue(v5, v3, v4);
      goto LABEL_25;
    }
    CFDictionaryRemoveValue(v5, v3);
  }
  else if (a1[7])
  {
    Count = CFDictionaryGetCount(*(CFDictionaryRef *)(v2 + 56));
    if (Count >= 1)
    {
      v9 = Count;
      v10 = 8 * Count;
      v11 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      v12 = (const void **)malloc_type_malloc(v10, 0x80040B8603338uLL);
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(v2 + 56), v11, v12);
      for (i = 0; i != v9; ++i)
      {
        v14 = CFGetTypeID(v12[i]);
        if (v14 == CFDictionaryGetTypeID())
        {
          v16 = a1[7];
          TimeForKey = HSTSParser::getTimeForKey((HSTSParser *)v12[i], (const __CFDictionary *)CFSTR("Create Time"), v15);
          if (TimeForKey >= MEMORY[0x186DB5F80](v16))
            CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v2 + 56), v11[i]);
        }
      }
      free(v12);
      free(v11);
    }
  }
  else
  {
    v18 = CFGetAllocator((CFTypeRef)(v2 - 16));
    Mutable = CFDictionaryCreateMutable(v18, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v20 = *(const void **)(v2 + 48);
    *(_QWORD *)(v2 + 48) = Mutable;
    if (v20)
      CFRelease(v20);
    v21 = CFGetAllocator((CFTypeRef)(v2 - 16));
    v22 = CFDictionaryCreateMutable(v21, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v23 = *(const void **)(v2 + 56);
    *(_QWORD *)(v2 + 56) = v22;
    if (v23)
    {
      CFRelease(v23);
      v22 = *(CFMutableDictionaryRef *)(v2 + 56);
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v2 + 48), CFSTR("com.apple.CFNetwork.defaultStorageSession"), v22);
  }
  if (*(_BYTE *)(v2 + 73))
    HSTSCache::persistKnownHSTSHosts((CFPropertyListRef *)v2);
LABEL_25:
  v24 = (const void *)a1[7];
  if (v24)
    CFRelease(v24);
  v25 = (const void *)a1[6];
  if (v25)
    CFRelease(v25);
  v26 = (const void *)a1[5];
  if (v26)
    CFRelease(v26);
}

void HSTSCache::persistKnownHSTSHosts(CFPropertyListRef *this)
{
  CFPropertyListRef *v2;
  const __CFAllocator *v3;
  CFDataRef v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  NSObject *v7;
  unint64_t v8;
  char *v9;
  NSObject *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[6];
  std::__shared_weak_count *v18;
  CFDataRef v19;
  std::__shared_weak_count *v20;
  CFErrorRef error;

  if (!*((_BYTE *)this + 88))
  {
    error = 0;
    v2 = this - 2;
    v3 = CFGetAllocator(this - 2);
    v4 = CFPropertyListCreateData(v3, this[6], kCFPropertyListBinaryFormat_v1_0, 0, &error);
    v19 = v4;
    v5 = (std::__shared_weak_count *)operator new();
    v5->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    v5->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A90;
    v5->__shared_weak_owners_ = 0;
    v5[1].__vftable = (std::__shared_weak_count_vtbl *)v4;
    v20 = v5;
    if (error)
      CFRelease(error);
    CFRetain(v2);
    v7 = this[3];
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 3321888768;
    v17[2] = ___ZN9HSTSCache21persistKnownHSTSHostsEv_block_invoke;
    v17[3] = &__block_descriptor_56_e8_40c36_ZTSNSt3__110shared_ptrIK8__CFDataEE_e5_v8__0l;
    v17[4] = this;
    v17[5] = v4;
    v18 = v5;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    dispatch_async(v7, v17);
    this[10] = (CFPropertyListRef)*MEMORY[0x1E0C9AE40];
    v9 = (char *)this[5];
    this[5] = v9 + 1;
    if (!v9)
    {
      v10 = this[4];
      if (v10)
        dispatch_suspend(v10);
    }
    v11 = v18;
    if (v18)
    {
      v12 = (unint64_t *)&v18->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    v14 = v20;
    if (v20)
    {
      v15 = (unint64_t *)&v20->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
}

void sub_1840D79E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN9HSTSCache21persistKnownHSTSHostsEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const __CFData *v3;
  uint64_t v4;
  NSObject *v5;
  char v6;
  NSObject *v7;
  const __CFURL *v8;
  const __CFAllocator *v9;
  __CFWriteStream *v10;
  __CFWriteStream *v11;
  CFIndex Length;
  const UInt8 *BytePtr;
  CFIndex v14;
  CFErrorRef v15;
  const __CFURL *v16;
  const __CFAllocator *v17;
  const __CFURL *PathComponent;
  const __CFURL *v19;
  const __CFString *v20;
  const __CFString *MutableCopy;
  const __CFString *v22;
  uint64_t v23;
  _QWORD v24[5];
  _BYTE buffer[24];
  void *v26;
  _QWORD *v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  CFRetain((CFTypeRef)(v2 - 16));
  v3 = *(const __CFData **)(a1 + 40);
  v4 = MEMORY[0x1E0C809B0];
  v5 = *(NSObject **)(v2 + 16);
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 3221225472;
  v24[2] = ___ZN9HSTSCache21persistKnownHSTSHostsEv_block_invoke_2;
  v24[3] = &__block_descriptor_40_e8_v12__0C8l;
  v24[4] = v2;
  if (!v3)
    goto LABEL_30;
  if (!*(_BYTE *)(v2 + 88))
  {
    if (!*(_BYTE *)(v2 + 72))
    {
      *(_BYTE *)(v2 + 72) = 1;
      v16 = *(const __CFURL **)(v2 + 64);
      if (v16)
      {
        v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v16);
        if (PathComponent)
        {
          v19 = PathComponent;
          v20 = CFURLCopyPath(PathComponent);
          if (v20)
          {
            MutableCopy = CFStringCreateMutableCopy(v17, 0, v20);
            v22 = MutableCopy;
            if (MutableCopy)
            {
              if (CFStringGetFileSystemRepresentation(MutableCopy, buffer, 1024))
                __BuildPath(buffer);
              CFRelease(v22);
            }
            CFRelease(v20);
          }
          CFRelease(v19);
        }
      }
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v23 = *(_QWORD *)(v2 + 64);
      *(_DWORD *)buffer = 134218242;
      *(_QWORD *)&buffer[4] = v2;
      *(_WORD *)&buffer[12] = 2112;
      *(_QWORD *)&buffer[14] = v23;
      _os_log_debug_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEBUG, "HSTS storage %p path %@", buffer, 0x16u);
    }
    v8 = *(const __CFURL **)(v2 + 64);
    if (v8)
    {
      v9 = CFGetAllocator(*(CFTypeRef *)(v2 + 64));
      v10 = CFWriteStreamCreateWithFile((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8);
      v11 = v10;
      if (v10)
      {
        if (CFWriteStreamOpen(v10))
        {
          Length = CFDataGetLength(v3);
          BytePtr = CFDataGetBytePtr(v3);
          v14 = CFWriteStreamWrite(v11, BytePtr, Length);
          if (v14 < 0)
            v15 = CFWriteStreamCopyError(v11);
          else
            v15 = 0;
          CFWriteStreamClose(v11);
          CFRelease(v11);
          if (v14 >= 0)
          {
            v6 = 1;
            goto LABEL_31;
          }
        }
        else
        {
          v15 = CFWriteStreamCopyError(v11);
          CFRelease(v11);
        }
      }
      else
      {
        v15 = CFErrorCreate(v9, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], 1, 0);
      }
      if (v15)
        CFRelease(v15);
    }
LABEL_30:
    v6 = 0;
    *(_BYTE *)(v2 + 88) = 1;
    goto LABEL_31;
  }
  v6 = 0;
LABEL_31:
  *(_QWORD *)buffer = v4;
  *(_QWORD *)&buffer[8] = 3221225472;
  *(_QWORD *)&buffer[16] = ___ZN9HSTSCache35persistKnownHSTSHostsWithCompletionEPK8__CFDataPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvhE_block_invoke;
  v26 = &unk_1E14FCB70;
  v27 = v24;
  v28 = v6;
  dispatch_async(v5, buffer);
  CFRelease((CFTypeRef)(v2 - 16));
}

void sub_1840D7D14(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c36_ZTSNSt3__110shared_ptrIK8__CFDataEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c36_ZTSNSt3__110shared_ptrIK8__CFDataEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void ___ZN9HSTSCache21persistKnownHSTSHostsEv_block_invoke_2(uint64_t a1, int a2)
{
  uint64_t v2;
  NSObject *v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (!a2)
  {
    v3 = *(NSObject **)(v2 + 32);
    if (v3)
      dispatch_source_cancel(v3);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t ___ZN9HSTSCache35persistKnownHSTSHostsWithCompletionEPK8__CFDataPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvhE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void ___ZN9HSTSCache24initPersistentStoreTimerEv_block_invoke(uint64_t a1)
{
  CFPropertyListRef *Weak;
  CFPropertyListRef *v2;

  Weak = (CFPropertyListRef *)objc_loadWeak((id *)(a1 + 32));
  if (Weak)
  {
    v2 = Weak;
    if (HSTSCache::Class(void)::sOnce_HSTSCache != -1)
      dispatch_once(&HSTSCache::Class(void)::sOnce_HSTSCache, &__block_literal_global_1_14738);
    HSTSCache::persistKnownHSTSHosts(v2 + 2);
  }
}

CFDictionaryRef HSTSParser::createHSTSInfo(HSTSParser *this, const __CFAllocator *a2, CFAbsoluteTime a3, int a4, const void *a5, const __CFNumber *a6)
{
  int v8;
  __CFDictionary *Mutable;
  __CFDictionary *v12;
  const void **v13;
  double v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  CFDictionaryRef Copy;
  CFAbsoluteTime valuePtr;

  v8 = (int)a2;
  Mutable = CFDictionaryCreateMutable(this, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v12 = Mutable;
  v13 = (const void **)MEMORY[0x1E0C9AE50];
  if (a4)
    CFDictionaryAddValue(Mutable, CFSTR("HSTS Host"), (const void *)*MEMORY[0x1E0C9AE50]);
  if (v8)
    CFDictionaryAddValue(v12, CFSTR("Include Subdomains"), *v13);
  if (a5)
  {
    CFDictionaryAddValue(v12, CFSTR("Expiry"), a5);
  }
  else
  {
    valuePtr = a3;
    if (a3 > 0.0)
    {
      v14 = CFAbsoluteTimeGetCurrent() + a3;
      if (v14 > 1.79769313e308)
        v14 = 1.79769313e308;
      valuePtr = v14;
    }
    v15 = CFNumberCreate(this, kCFNumberDoubleType, &valuePtr);
    if (v15)
    {
      v16 = v15;
      CFDictionaryAddValue(v12, CFSTR("Expiry"), v15);
      CFRelease(v16);
    }
  }
  valuePtr = CFAbsoluteTimeGetCurrent();
  v17 = CFNumberCreate(this, kCFNumberDoubleType, &valuePtr);
  if (v17)
  {
    v18 = v17;
    CFDictionaryAddValue(v12, CFSTR("Create Time"), v17);
    CFRelease(v18);
  }
  if (!v12)
    return 0;
  Copy = CFDictionaryCreateCopy(this, v12);
  CFRelease(v12);
  return Copy;
}

double HSTSParser::getTimeForKey(HSTSParser *this, const __CFDictionary *a2, const __CFString *a3)
{
  const __CFNumber *Value;
  double v4;
  const __CFNumber *v5;
  CFTypeID v6;
  unint64_t valuePtr;

  valuePtr = 0xBFF0000000000000;
  Value = (const __CFNumber *)CFDictionaryGetValue(this, a2);
  v4 = -1.0;
  if (Value)
  {
    v5 = Value;
    v6 = CFGetTypeID(Value);
    if (v6 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
      return *(double *)&valuePtr;
    }
  }
  return v4;
}

void ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void CoreLogFileSink::~CoreLogFileSink(CoreLogFileSink *this)
{
  CoreLogFileSink::~CoreLogFileSink(this);
}

{
  CoreLogFileSink::~CoreLogFileSink(this);
}

{
  FILE *v2;

  *(_QWORD *)this = off_1E14E7460;
  v2 = (FILE *)*((_QWORD *)this + 34);
  if (v2)
  {
    if (*((_BYTE *)this + 280))
      fclose(v2);
  }
  *(_QWORD *)this = off_1E14E4D78;
  abort();
}

uint64_t CoreLogFileSink::sinkBytes(uint64_t this, CFDataRef theData)
{
  uint64_t v3;
  const UInt8 *BytePtr;
  size_t Length;

  if (*(_QWORD *)(this + 272))
  {
    v3 = this;
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    fwrite(BytePtr, Length, 1uLL, *(FILE **)(v3 + 272));
    return fflush(*(FILE **)(v3 + 272));
  }
  return this;
}

void CoreLogFileSink::CoreLogFileSink(CoreLogFileSink *this, __sFILE *a2)
{
  const char *v4;
  dispatch_queue_t v5;

  *(_QWORD *)this = off_1E14E4D78;
  v4 = (char *)this + 8;
  snprintf((char *)this + 8, 0x100uLL, "com.apple.CFNetwork.LogSink[%s]", "stderr");
  v5 = dispatch_queue_create(v4, 0);
  *(_QWORD *)this = off_1E14E7460;
  *((_QWORD *)this + 33) = v5;
  *((_QWORD *)this + 34) = a2;
  *((_BYTE *)this + 280) = 0;
}

CFStringRef DispatchHost::copyDebugDesc(DispatchHost *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("DispatchHost<%p>"), this);
}

uint64_t DispatchHost::scheduleWithRunLoop(DispatchHost *this, __CFRunLoop *a2, const __CFString *a3)
{
  char *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t Instance;
  _QWORD *v11;
  void *v12;
  const __CFArray *v13;

  v6 = (char *)this - 16;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  if (HostBase::scheduleWithRunLoop(this, a2, a3))
  {
    v7 = *((_QWORD *)this + 21);
    if (v7)
    {
      v8 = *(void **)(v7 + 16);
      if (v8)
        _CFTypeScheduleOnRunLoop(v8, (uint64_t)a2, (uint64_t)a3);
    }
    else
    {
      CFGetAllocator(v6);
      if (HostLookup::Class(void)::sOnce_HostLookup != -1)
        dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_8707);
      Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        *(_OWORD *)(Instance + 16) = 0u;
        Instance += 16;
        *(_QWORD *)(Instance + 48) = 0;
        *(_OWORD *)(Instance + 16) = 0u;
        *(_OWORD *)(Instance + 32) = 0u;
      }
      HostLookup_RunLoopSource::HostLookup_RunLoopSource((HostLookup_RunLoopSource *)Instance, CFSTR("hack"));
      *v11 = &off_1E14E6768;
      v11[1] = &unk_1E14E67D0;
      v11[6] = this;
      *((_QWORD *)this + 21) = v11;
      v12 = (void *)v11[2];
      if (v12)
        _CFTypeScheduleOnMultipleRunLoops(v12, *((const __CFArray **)this + 15));
    }
    v13 = (const __CFArray *)*((_QWORD *)this + 20);
    if (v13 && CFArrayGetCount(v13) >= 1)
      DispatchHost::signalKickerLocked(this);
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  HostBase::unlock(this);
  return v9;
}

void DispatchHost::clientAttached(DispatchHost *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD value[9];

  if (!a2)
  {
    value[7] = v2;
    value[8] = v3;
    CFRetain((char *)this - 16);
    value[0] = MEMORY[0x1E0C809B0];
    value[1] = 3221225472;
    value[2] = ___ZN12DispatchHost14clientAttachedEh_block_invoke;
    value[3] = &__block_descriptor_40_e5_v8__0l;
    value[4] = this;
    HostBase::deferredUntilUnlocked((uint64_t)this, value);
  }
}

void `non-virtual thunk to'DispatchHost::~DispatchHost(DispatchHost *this)
{
  DispatchHost::~DispatchHost((DispatchHost *)((char *)this - 8));
}

{
  DispatchHost::~DispatchHost((DispatchHost *)((char *)this - 8));
}

void ___ZN12DispatchHost14clientAttachedEh_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void (**v3)(_QWORD, _QWORD);

  v2 = *(_QWORD *)(a1 + 32);
  CFRetain((CFTypeRef)(v2 - 16));
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 32));
  ++*(_QWORD *)(v2 + 16);
  v3 = *(void (***)(_QWORD, _QWORD))(v2 + 136);
  *(_QWORD *)(v2 + 136) = 0;
  HostBase::unlock((HostBase *)v2);
  if (v3)
  {
    v3[2](v3, 0);
    _Block_release(v3);
    CFRelease((CFTypeRef)(v2 - 16));
  }
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
}

void DispatchHost::signalKickerLocked(DispatchHost *this)
{
  uint64_t v1;
  const __CFArray *Copy;
  const __CFAllocator *v4;
  CFTypeRef v5;
  _QWORD v6[6];

  v1 = *((_QWORD *)this + 21);
  if (v1)
  {
    Copy = (const __CFArray *)*((_QWORD *)this + 15);
    if (Copy)
    {
      v4 = CFGetAllocator(*((CFTypeRef *)this + 15));
      Copy = CFArrayCreateCopy(v4, Copy);
      v1 = *((_QWORD *)this + 21);
    }
    v5 = *(CFTypeRef *)(v1 + 32);
    if (v5)
      v5 = CFRetain(v5);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN12DispatchHost18signalKickerLockedEv_block_invoke;
    v6[3] = &__block_descriptor_48_e5_v8__0l;
    v6[4] = v5;
    v6[5] = Copy;
    HostBase::deferredUntilUnlocked((uint64_t)this, v6);
  }
}

void ___ZN12DispatchHost18signalKickerLockedEv_block_invoke(uint64_t a1)
{
  __CFRunLoopSource *v2;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  __CFRunLoop *ValueAtIndex;
  const __CFString *v8;
  const __CFString *v9;
  const void *v10;

  CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 32));
  v2 = *(__CFRunLoopSource **)(a1 + 32);
  v3 = *(const __CFArray **)(a1 + 40);
  if (v3)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    if (Count >= 1)
    {
      v5 = Count;
      for (i = 0; i < v5; i += 2)
      {
        ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v3, i);
        if (CFRunLoopIsWaiting(ValueAtIndex))
        {
          v8 = CFRunLoopCopyCurrentMode(ValueAtIndex);
          if (v8)
          {
            v9 = v8;
            if (CFRunLoopContainsSource(ValueAtIndex, v2, v8))
              CFRunLoopWakeUp(ValueAtIndex);
            CFRelease(v9);
          }
        }
      }
    }
    v10 = *(const void **)(a1 + 40);
    if (v10)
      CFRelease(v10);
    v2 = *(__CFRunLoopSource **)(a1 + 32);
  }
  if (v2)
    CFRelease(v2);
}

void RunLoopKicker::perform(RunLoopKicker *this)
{
  uint64_t v1;
  const void *v2;
  unint64_t Count;
  CFRange v4;
  const void **v5;
  CFIndex v6;
  CFTypeRef v7;
  CFIndex range;
  const void **v9;
  _BYTE v10[248];
  CFIndex v11;

  v1 = *((_QWORD *)this + 6);
  if (v1)
  {
    CFRetain((CFTypeRef)(v1 - 16));
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 32));
    ++*(_QWORD *)(v1 + 16);
    v2 = *(const void **)(v1 + 160);
    *(_QWORD *)(v1 + 160) = 0;
    HostBase::unlock((HostBase *)v1);
    if (v2)
    {
      v7 = CFRetain(v2);
      Count = CFArrayGetCount((CFArrayRef)v2);
      v4.length = Count;
      range = Count;
      if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v9 = 0;
        goto LABEL_10;
      }
      if (Count > 0x1E)
      {
        v5 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
        v9 = v5;
        if (!v5)
          goto LABEL_10;
        v4.length = range;
      }
      else
      {
        v5 = (const void **)v10;
        v9 = (const void **)v10;
      }
      v4.location = 0;
      CFArrayGetValues((CFArrayRef)v2, v4, v5);
LABEL_10:
      v11 = 0;
      while (1)
      {
        v6 = v11;
        if (v11 >= range)
          break;
        ++v11;
        HostBase::invokeCallback((HostBase *)v1, (const __CFString *)v9[v6]);
      }
      CFRelease((CFTypeRef)(v1 - 16));
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v7);
      CFRelease(v2);
    }
  }
}

void sub_1840D876C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'RunLoopKicker::~RunLoopKicker(RunLoopKicker *this)
{
  HostLookup_RunLoopSource::~HostLookup_RunLoopSource((RunLoopKicker *)((char *)this - 8));
}

{
  HostLookup_RunLoopSource::~HostLookup_RunLoopSource((RunLoopKicker *)((char *)this - 8));
}

void HostBase::cancelInfoResolution(HostBase *this, const __CFString *a2)
{
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  HostBase::setInfoLocked((CFMutableDictionaryRef *)this, a2, (const void *)*MEMORY[0x1E0C9AE40]);
  HostBase::unlock(this);
}

uint64_t HostBase::scheduleWithRunLoop(HostBase *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6;

  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  v6 = _SchedulesAddRunLoopAndMode(*((const __CFArray **)this + 15), a2, a3);
  HostBase::unlock(this);
  return v6;
}

CFIndex HostBase::unscheduleFromRunLoop(HostBase *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFIndex v6;

  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  v6 = _SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 15), a2, a3);
  HostBase::unlock(this);
  return v6;
}

void HostBase::invokeCallback(HostBase *this, const __CFString *a2)
{
  uint64_t v4;
  const void *Value;
  CFTypeRef v6;
  CFTypeID v7;

  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  v4 = *((_QWORD *)this + 13);
  if (v4)
  {
    (*(void (**)(_QWORD))(*(_QWORD *)v4 + 24))(*((_QWORD *)this + 13));
    Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2);
    v6 = Value;
    if (Value)
    {
      v7 = CFGetTypeID(Value);
      if (v7 == CFErrorGetTypeID())
        v6 = CFRetain(v6);
      else
        v6 = 0;
    }
    HostBase::unlock(this);
    (*(void (**)(uint64_t, HostBase *, const __CFString *, CFTypeRef))(*(_QWORD *)v4 + 16))(v4, this, a2, v6);
    if (v6)
      CFRelease(v6);
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 32))(v4);
  }
  else
  {
    HostBase::unlock(this);
  }
}

uint64_t HostBase::setDelegate(HostBase *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  CFRetain((char *)a1 - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 32));
  ++*((_QWORD *)a1 + 2);
  v4 = *((_QWORD *)a1 + 13);
  if (v4 == a2)
  {
    v6 = 0;
  }
  else
  {
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 32))(v4);
    *((_QWORD *)a1 + 13) = a2;
    if (a2)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
    (*(void (**)(HostBase *, uint64_t))(*(_QWORD *)a1 + 88))(a1, v5);
    v6 = 1;
  }
  HostBase::unlock(a1);
  return v6;
}

void StubHostDelegate::StubHostDelegate(StubHostDelegate *this, const __CFAllocator *a2, CFHostClientContext *a3)
{
  char *v4;
  CFAllocatorCopyDescriptionCallBack copyDescription;
  __int128 v6;
  uint64_t (*v7)(void);

  *(_QWORD *)this = off_1E14E81F0;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = &unk_1E14E8220;
  v4 = (char *)this + 24;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 10) = 1;
  copyDescription = a3->copyDescription;
  v6 = *(_OWORD *)&a3->retain;
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)&a3->version;
  *((_QWORD *)this + 7) = copyDescription;
  *(_OWORD *)((char *)this + 40) = v6;
  if (*((_QWORD *)this + 4))
  {
    v7 = (uint64_t (*)(void))*((_QWORD *)this + 5);
    if (v7)
      *((_QWORD *)this + 4) = v7();
  }
  *((_QWORD *)this + 8) = v4;
  *((_QWORD *)this + 9) = v4;
}

void ClassicHostDelegate::~ClassicHostDelegate(ClassicHostDelegate *this)
{
  uint64_t v2;

  StubHostDelegate::~StubHostDelegate(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

uint64_t StubHostDelegate::hostDelegateRetain(uint64_t this)
{
  ++*(_QWORD *)(this + 80);
  return this;
}

_QWORD *StubHostDelegate::hostDelegateRelease(_QWORD *this)
{
  uint64_t v1;

  v1 = this[10] - 1;
  this[10] = v1;
  if (this)
  {
    if (!v1)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  return this;
}

uint64_t ClassicHostDelegate::hostInfoCallback(ClassicHostDelegate *this, HostBase *a2, const __CFString *a3, __CFError *a4)
{
  uint64_t v7;
  uint64_t (*v8)(char *, uint64_t, _QWORD *, _QWORD);
  int ExactString;
  int v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD v14[2];

  v14[0] = _CFStreamErrorFromCFError(a4);
  v14[1] = v7;
  v8 = (uint64_t (*)(char *, uint64_t, _QWORD *, _QWORD))*((_QWORD *)this + 11);
  ExactString = _findExactString(a3, 0xAu);
  if (ExactString == 492935702)
    v10 = 1;
  else
    v10 = -1;
  if (ExactString == 494041629)
    v11 = 2;
  else
    v11 = v10;
  if (ExactString == 491919885)
    v12 = 0;
  else
    v12 = v11;
  return v8((char *)a2 - 16, v12, v14, *(_QWORD *)(*((_QWORD *)this + 9) + 8));
}

void `non-virtual thunk to'ClassicHostDelegate::~ClassicHostDelegate(ClassicHostDelegate *this)
{
  StubHostDelegate::~StubHostDelegate((ClassicHostDelegate *)((char *)this - 16));
}

void `non-virtual thunk to'ClassicHostDelegate::~ClassicHostDelegate(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 2;
  StubHostDelegate::~StubHostDelegate((StubHostDelegate *)(this - 2));
  CFAllocatorDeallocate(*(this - 1), v2);
}

uint64_t `non-virtual thunk to'ClassicHostDelegate::hostInfoCallback(ClassicHostDelegate *this, HostBase *a2, const __CFString *a3, __CFError *a4)
{
  return ClassicHostDelegate::hostInfoCallback((ClassicHostDelegate *)((char *)this - 16), a2, a3, a4);
}

uint64_t `non-virtual thunk to'StubHostDelegate::hostDelegateRetain(uint64_t this)
{
  ++*(_QWORD *)(this + 64);
  return this;
}

uint64_t `non-virtual thunk to'StubHostDelegate::hostDelegateRelease(uint64_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)(this + 64) - 1;
  *(_QWORD *)(this + 64) = v1;
  if (!v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(this - 16) + 8))(this - 16);
  return this;
}

void StubHostDelegate::~StubHostDelegate(StubHostDelegate *this)
{
  void (*v2)(void);
  int v3;
  const char *v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = off_1E14E81F0;
  *((_QWORD *)this + 2) = &unk_1E14E8220;
  if (!*((_QWORD *)this + 8) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    v3 = 136315138;
    v4 = "T *ClientContextHolderInfo<CFHostClientContext>::forget() [T = CFHostClientContext]";
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s called before remember", (uint8_t *)&v3, 0xCu);
  }
  if (*((_QWORD *)this + 4))
  {
    v2 = (void (*)(void))*((_QWORD *)this + 6);
    if (v2)
      v2();
  }
  *((_QWORD *)this + 9) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
}

void NewerHostDelegate::~NewerHostDelegate(NewerHostDelegate *this)
{
  uint64_t v2;

  StubHostDelegate::~StubHostDelegate(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

uint64_t NewerHostDelegate::hostInfoCallback(NewerHostDelegate *this, HostBase *a2, const __CFString *a3, __CFError *a4)
{
  return (*((uint64_t (**)(char *, const __CFString *, __CFError *, _QWORD))this + 11))((char *)a2 - 16, a3, a4, *(_QWORD *)(*((_QWORD *)this + 9) + 8));
}

void `non-virtual thunk to'NewerHostDelegate::~NewerHostDelegate(NewerHostDelegate *this)
{
  StubHostDelegate::~StubHostDelegate((NewerHostDelegate *)((char *)this - 16));
}

void `non-virtual thunk to'NewerHostDelegate::~NewerHostDelegate(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 2;
  StubHostDelegate::~StubHostDelegate((StubHostDelegate *)(this - 2));
  CFAllocatorDeallocate(*(this - 1), v2);
}

uint64_t `non-virtual thunk to'NewerHostDelegate::hostInfoCallback(NewerHostDelegate *this, HostBase *a2, const __CFString *a3, __CFError *a4)
{
  return (*((uint64_t (**)(char *, const __CFString *, __CFError *, _QWORD))this + 9))((char *)a2 - 16, a3, a4, *(_QWORD *)(*((_QWORD *)this + 7) + 8));
}

void HostBase::deferredUntilUnlocked(uint64_t a1, void *value)
{
  __CFArray *v4;
  const __CFAllocator *v5;
  CFArrayCallBacks v6;

  v4 = *(__CFArray **)(a1 + 112);
  if (!v4)
  {
    *(_OWORD *)&v6.version = xmmword_1E14FCC10;
    *(_OWORD *)&v6.release = *(_OWORD *)&off_1E14FCC20;
    v6.equal = 0;
    v5 = CFGetAllocator((CFTypeRef)(a1 - 16));
    v4 = CFArrayCreateMutable(v5, 0, &v6);
    *(_QWORD *)(a1 + 112) = v4;
  }
  CFArrayAppendValue(v4, value);
}

void *_retain_block(const __CFAllocator *a1, const void *aBlock)
{
  return _Block_copy(aBlock);
}

void _release_block(const __CFAllocator *a1, const void *aBlock)
{
  _Block_release(aBlock);
}

void sub_1840D91EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

void sub_1840D98E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)&a9);
  _Unwind_Resume(a1);
}

void sub_1840D9BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)&a9);
  _Unwind_Resume(a1);
}

void sub_1840D9D14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void sub_1840DA0AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  _Unwind_Resume(exception_object);
}

void __logHARRequestBody_block_invoke(uint64_t a1)
{
  NSObject *v2;
  dispatch_data_t concat;
  NSObject *v4;
  dispatch_data_t subrange;
  NSObject *v6;
  NSObject *data1;
  NSObject *data1a;

  objc_msgSend((id)HARRequestBody, "objectForKeyedSubscript:", *(_QWORD *)(a1 + 32));
  v2 = objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    data1 = v2;
    if (dispatch_data_get_size(v2) >= HARBodySizeLimit)
      goto LABEL_9;
    concat = dispatch_data_create_concat(data1, *(dispatch_data_t *)(a1 + 40));

    v4 = concat;
  }
  else
  {
    v4 = *(id *)(a1 + 40);
  }
  data1a = v4;
  if (dispatch_data_get_size(v4) <= HARBodySizeLimit)
  {
    v6 = data1a;
  }
  else
  {
    subrange = dispatch_data_create_subrange(data1a, 0, HARBodySizeLimit);

    v6 = subrange;
  }
  data1 = v6;
  objc_msgSend((id)HARRequestBody, "setObject:forKeyedSubscript:");
LABEL_9:

}

void sub_1840DA78C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t checkEntitlementForHARLogging(const __CFString *a1)
{
  __SecTask *v2;
  __SecTask *v3;
  void *v4;
  NSObject *v5;
  uint64_t v6;
  int v8;
  const __CFString *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = SecTaskCreateFromSelf((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  v3 = v2;
  v4 = (void *)MEMORY[0x1E0C9AAA0];
  if (v2)
    v4 = (void *)SecTaskCopyValueForEntitlement(v2, a1, 0);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v5 = (id)CFNLog::logger;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v8 = 138412546;
    v9 = a1;
    v10 = 1024;
    v11 = objc_msgSend(v4, "BOOLValue");
    _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "Entitled for HAR logging %@ = %d", (uint8_t *)&v8, 0x12u);
  }

  if (v3)
    CFRelease(v3);
  v6 = objc_msgSend(v4, "BOOLValue");

  return v6;
}

void sub_1840DA8E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL17readHARPreferencev_block_invoke_2()
{
  NSObject *v0;
  void *v1;
  void *v2;
  uint8_t v3[16];

  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v0 = (id)CFNLog::logger;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_183ECA000, v0, OS_LOG_TYPE_DEFAULT, "Stopping HAR logging", v3, 2u);
  }

  HAREnabled = 0;
  objc_msgSend((id)HARRequestBody, "removeAllObjects");
  objc_msgSend((id)HARResponseBody, "removeAllObjects");
  v1 = (void *)HARPathDenialList;
  HARPathDenialList = 0;

  v2 = (void *)HARHostDenialList;
  HARHostDenialList = 0;

}

void ___ZL13initializeHARv_block_invoke()
{
  NSObject *v0;
  dispatch_queue_t v1;
  void *v2;
  os_log_t v3;
  void *v4;
  id v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;

  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v0 = objc_claimAutoreleasedReturnValue();
  v1 = dispatch_queue_create("com.apple.CFNetwork.HARLogging", v0);
  v2 = (void *)HARQueue;
  HARQueue = (uint64_t)v1;

  v3 = os_log_create("com.apple.CFNetwork", "HAR");
  v4 = (void *)HARLog;
  HARLog = (uint64_t)v3;

  v5 = objc_alloc_init(MEMORY[0x1E0CB3578]);
  v6 = (void *)HARDateFormatter;
  HARDateFormatter = (uint64_t)v5;

  objc_msgSend(MEMORY[0x1E0C99DC8], "localeWithLocaleIdentifier:", CFSTR("en_US_POSIX"));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend((id)HARDateFormatter, "setLocale:", v7);

  objc_msgSend((id)HARDateFormatter, "setDateFormat:", CFSTR("yyyy-MM-dd'T'HH:mm:ss.SSSXXXXX"));
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v8 = objc_claimAutoreleasedReturnValue();
  v9 = (void *)HARRequestBody;
  HARRequestBody = v8;

  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v10 = objc_claimAutoreleasedReturnValue();
  v11 = (void *)HARResponseBody;
  HARResponseBody = v10;

}

void sub_1840DAAE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL43registerForDiagnosticExtensionNotificationsv_block_invoke()
{
  void *v0;
  NSObject *v1;
  uint8_t v2[16];

  v0 = (void *)MEMORY[0x186DB8C8C]();
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v1 = (id)CFNLog::logger;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v2 = 0;
    _os_log_debug_impl(&dword_183ECA000, v1, OS_LOG_TYPE_DEBUG, "Got a notification for com.apple.CFNetwork.har-capture-update", v2, 2u);
  }

  readHARPreference();
  objc_autoreleasePoolPop(v0);
}

void __logHARResponseBody_block_invoke(uint64_t a1)
{
  NSObject *v2;
  dispatch_data_t concat;
  NSObject *v4;
  dispatch_data_t subrange;
  NSObject *v6;
  NSObject *data1;
  NSObject *data1a;

  objc_msgSend((id)HARResponseBody, "objectForKeyedSubscript:", *(_QWORD *)(a1 + 32));
  v2 = objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    data1 = v2;
    if (dispatch_data_get_size(v2) >= HARBodySizeLimit)
      goto LABEL_9;
    concat = dispatch_data_create_concat(data1, *(dispatch_data_t *)(a1 + 40));

    v4 = concat;
  }
  else
  {
    v4 = *(id *)(a1 + 40);
  }
  data1a = v4;
  if (dispatch_data_get_size(v4) <= HARBodySizeLimit)
  {
    v6 = data1a;
  }
  else
  {
    subrange = dispatch_data_create_subrange(data1a, 0, HARBodySizeLimit);

    v6 = subrange;
  }
  data1 = v6;
  objc_msgSend((id)HARResponseBody, "setObject:forKeyedSubscript:");
LABEL_9:

}

void sub_1840DAC68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t __clearCachedHARResponseBody_block_invoke(uint64_t a1)
{
  return objc_msgSend((id)HARResponseBody, "setObject:forKeyedSubscript:", 0, *(_QWORD *)(a1 + 32));
}

void __logHAREntry_block_invoke(uint64_t a1, const char *a2)
{
  id Property;
  uint64_t v3;
  id v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  uint64_t v18;
  uint64_t v19;
  uint64_t j;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t k;
  void *v25;
  void *v26;
  __CFHTTPMessage *v27;
  __CFHTTPMessage *v28;
  uint64_t v29;
  void *v30;
  const __CFString *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  const __CFString *v35;
  const __CFString *v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  void *v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  URLResponse *v47;
  const __CFString *v48;
  URLResponse *v49;
  __CFString *v50;
  NSObject *v51;
  const char *v52;
  const __CFString *v53;
  size_t v54;
  int v55;
  void *v56;
  _QWORD *v57;
  _QWORD *v58;
  void *v59;
  _QWORD *v60;
  unint64_t v61;
  char *v62;
  int v63;
  char v64;
  id v65;
  void *v66;
  void *v67;
  void *v68;
  _QWORD *v69;
  _QWORD *v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *v73;
  _QWORD *v74;
  char isKindOfClass;
  _QWORD *v76;
  _QWORD *v77;
  id v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t m;
  void *v82;
  void *v83;
  uint64_t v84;
  uint64_t v85;
  void *v86;
  uint64_t v87;
  void *v88;
  const __CFString *v89;
  void *v90;
  _QWORD *v91;
  _QWORD *v92;
  dispatch_data_t v93;
  size_t v94;
  int v95;
  unint64_t v96;
  char *v97;
  int v98;
  char v99;
  id v100;
  uint64_t v101;
  void *v102;
  const __CFString *v103;
  const __CFString *v104;
  void *v105;
  void *v106;
  _QWORD *v107;
  _QWORD *v108;
  uint64_t v109;
  __CFHTTPMessage *v110;
  __CFString *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  void *v117;
  const __CFString *v118;
  const __CFString *v119;
  uint64_t v120;
  void *v121;
  const __CFString *v122;
  uint64_t v123;
  uint64_t v124;
  void *v125;
  uint64_t v126;
  uint64_t v127;
  void *v128;
  uint64_t v129;
  Class isa;
  double v131;
  uint64_t v132;
  void *v133;
  uint64_t v134;
  Class v135;
  int v136;
  uint64_t v137;
  int v138;
  double v139;
  double v140;
  void *v141;
  uint64_t v142;
  double v143;
  double v144;
  void *v145;
  uint64_t v146;
  double v147;
  double v148;
  void *v149;
  uint64_t v150;
  int v151;
  void *v152;
  double *v153;
  id v154;
  unint64_t v155;
  void *v156;
  unint64_t v157;
  void *v158;
  unint64_t v159;
  unint64_t v160;
  void *v161;
  double v162;
  double v163;
  double v164;
  void *v165;
  double v166;
  double v167;
  double v168;
  void *v169;
  double v170;
  double v171;
  double v172;
  void *v173;
  NSObject *v174;
  char *v175;
  uint64_t v176;
  double v177;
  void *v178;
  uint64_t v179;
  double v180;
  double v181;
  uint64_t v182;
  _QWORD *v183;
  void *v184;
  void *v185;
  void *v186;
  void *v187;
  const __CFString *v188;
  id *v189;
  void *v190;
  id v191;
  _BYTE *v192;
  const __CFString *v193;
  id v194;
  BOOL v195;
  void *v196;
  void *v197;
  _BYTE *v198;
  unint64_t v199;
  int v200;
  unsigned int v201;
  NSObject *v202;
  unint64_t v203;
  BOOL v204;
  char *v205;
  char v206;
  char *v207;
  int v208;
  char v209;
  NSObject *v210;
  void *v211;
  void *v212;
  void *v213;
  void *v214;
  void *v215;
  NSObject *endpoint;
  void *v217;
  _QWORD *v218;
  id v219;
  BOOL v220;
  void *v221;
  void *v222;
  __CFString *v223;
  int v224;
  void *v225;
  void *v226;
  void *v227;
  __CFString *v228;
  __CFString *v229;
  __CFString *v230;
  NSObject *v231;
  NSObject *data;
  void *v233;
  void *v234;
  id *v235;
  void *v236;
  void *v237;
  dispatch_data_t v239;
  void *v240;
  void *v241;
  __int128 v242;
  __int128 v243;
  __int128 v244;
  __int128 v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  __int128 v249;
  __int128 v250;
  __int128 v251;
  __int128 v252;
  __int128 v253;
  __int128 v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  _QWORD v258[13];
  _QWORD v259[13];
  _QWORD v260[2];
  const __CFString *v261;
  const __CFString *v262;
  const __CFString *v263;
  const __CFString *v264;
  const __CFString *v265;
  uint64_t v266;
  void *v267;
  void *v268;
  void *v269;
  void *v270;
  void *v271;
  void *v272;
  _QWORD v273[9];
  _QWORD v274[9];
  _QWORD v275[2];
  _QWORD v276[2];
  _BYTE v277[128];
  _QWORD v278[2];
  _QWORD v279[2];
  _BYTE v280[128];
  size_t size_ptr;
  __int16 v282;
  _BYTE *v283;
  uint8_t buf[4];
  void *v285;
  __CFN_ConnectionMetrics buffer_ptr;

  buffer_ptr._localEndpoint = (OS_nw_endpoint *)*MEMORY[0x1E0C80C00];
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, a2, 88, 1);
  v235 = (id *)Property;
  v3 = *(_QWORD *)(a1 + 32);
  if (v3 && (v4 = *(id *)(v3 + 64)) != 0)
  {
    v5 = v4;
    v6 = v5;
  }
  else
  {
    v7 = *(_QWORD **)(a1 + 32);
    if (v7)
      v7 = (_QWORD *)v7[7];
    v6 = v7;

    v5 = 0;
  }

  v8 = v6;
  v9 = v8;
  v236 = v8;
  if (__PAIR128__(HARHostDenialList, HARPathDenialList) != 0)
  {
    objc_msgSend(v8, "URL");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "path");
    v11 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v9, "URL");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "host");
    v13 = (void *)objc_claimAutoreleasedReturnValue();

    v256 = 0u;
    v257 = 0u;
    v254 = 0u;
    v255 = 0u;
    v14 = (id)HARPathDenialList;
    v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v254, &buffer_ptr, 16);
    if (v15)
    {
      v16 = *(_QWORD *)v255;
      do
      {
        for (i = 0; i != v15; ++i)
        {
          if (*(_QWORD *)v255 != v16)
            objc_enumerationMutation(v14);
          if (objc_msgSend(v11, "containsString:", *(_QWORD *)(*((_QWORD *)&v254 + 1) + 8 * i)))
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v51 = (id)CFNLog::logger;
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              v285 = v9;
              v52 = "Path contains denial list entry for request {%@}";
              goto LABEL_73;
            }
LABEL_74:

            v56 = (void *)HARRequestBody;
            v57 = *(_QWORD **)(a1 + 32);
            if (v57)
              v57 = (_QWORD *)v57[6];
            v58 = v57;
            objc_msgSend(v56, "setObject:forKeyedSubscript:", 0, v58);

            v59 = (void *)HARResponseBody;
            v60 = *(_QWORD **)(a1 + 32);
            if (v60)
              v60 = (_QWORD *)v60[6];
            v21 = v60;
            objc_msgSend(v59, "setObject:forKeyedSubscript:", 0, v21);
            goto LABEL_281;
          }
        }
        v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v254, &buffer_ptr, 16);
      }
      while (v15);
    }

    v252 = 0u;
    v253 = 0u;
    v250 = 0u;
    v251 = 0u;
    v14 = (id)HARHostDenialList;
    v18 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v250, &size_ptr, 16);
    if (!v18)
      goto LABEL_26;
    v19 = *(_QWORD *)v251;
    while (1)
    {
      for (j = 0; j != v18; ++j)
      {
        if (*(_QWORD *)v251 != v19)
          objc_enumerationMutation(v14);
        if (objc_msgSend(v13, "containsString:", *(_QWORD *)(*((_QWORD *)&v250 + 1) + 8 * j)))
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v51 = (id)CFNLog::logger;
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v285 = v236;
            v52 = "Host contains denial list entry for request {%@}";
LABEL_73:
            _os_log_impl(&dword_183ECA000, v51, OS_LOG_TYPE_DEFAULT, v52, buf, 0xCu);
          }
          goto LABEL_74;
        }
      }
      v18 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v250, &size_ptr, 16);
      if (!v18)
      {
LABEL_26:

        v9 = v236;
        goto LABEL_28;
      }
    }
  }

LABEL_28:
  objc_msgSend(v9, "allHTTPHeaderFields");
  v212 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", objc_msgSend(v212, "count"));
  v241 = (void *)objc_claimAutoreleasedReturnValue();
  v248 = 0u;
  v249 = 0u;
  v246 = 0u;
  v247 = 0u;
  v21 = v212;
  v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v246, v280, 16);
  if (v22)
  {
    v23 = *(_QWORD *)v247;
    do
    {
      for (k = 0; k != v22; ++k)
      {
        if (*(_QWORD *)v247 != v23)
          objc_enumerationMutation(v21);
        v279[0] = *(_QWORD *)(*((_QWORD *)&v246 + 1) + 8 * k);
        v278[0] = CFSTR("name");
        v278[1] = CFSTR("value");
        objc_msgSend(v21, "objectForKeyedSubscript:");
        v25 = (void *)objc_claimAutoreleasedReturnValue();
        v279[1] = v25;
        objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v279, v278, 2);
        v26 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v241, "addObject:", v26);

      }
      v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v246, v280, 16);
    }
    while (v22);
  }

  if (v236 && (v27 = CFURLRequestCopyHTTPRequest(v236), (v28 = v27) != 0))
  {
    v230 = (__CFString *)CFHTTPMessageCopyVersion(v27);
    CFRelease(v28);
  }
  else
  {
    v230 = 0;
  }
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithCapacity:", 9);
  v237 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v236, "HTTPMethod");
  v29 = objc_claimAutoreleasedReturnValue();
  v30 = (void *)v29;
  if (v29)
    v31 = (const __CFString *)v29;
  else
    v31 = CFSTR("GET");
  objc_msgSend(v237, "setObject:forKeyedSubscript:", v31, CFSTR("method"));

  objc_msgSend(v236, "URL");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v32, "absoluteString");
  v33 = objc_claimAutoreleasedReturnValue();
  v34 = (void *)v33;
  if (v33)
    v35 = (const __CFString *)v33;
  else
    v35 = &stru_1E1500C68;
  objc_msgSend(v237, "setObject:forKeyedSubscript:", v35, CFSTR("url"));

  if (v230)
    v36 = v230;
  else
    v36 = &stru_1E1500C68;
  objc_msgSend(v237, "setObject:forKeyedSubscript:", v36, CFSTR("httpVersion"));
  objc_msgSend(v237, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AA60], CFSTR("cookies"));
  objc_msgSend(v237, "setObject:forKeyedSubscript:", v241, CFSTR("headers"));
  objc_msgSend(v237, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AA60], CFSTR("queryString"));
  v37 = *(_QWORD *)(a1 + 32);
  if (v37)
    v38 = *(_QWORD *)(v37 + 96);
  else
    v38 = 0;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v38);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v237, "setObject:forKeyedSubscript:", v39, CFSTR("headersSize"));

  v40 = *(_QWORD *)(a1 + 32);
  if (v40)
    v41 = *(_QWORD *)(v40 + 112);
  else
    v41 = 0;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v41);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v237, "setObject:forKeyedSubscript:", v42, CFSTR("bodySize"));

  v43 = (void *)HARRequestBody;
  v44 = *(_QWORD **)(a1 + 32);
  if (v44)
    v44 = (_QWORD *)v44[6];
  v45 = v44;
  objc_msgSend(v43, "objectForKeyedSubscript:", v45);
  data = objc_claimAutoreleasedReturnValue();

  if (data)
  {
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithCapacity:", 2);
    v46 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v21, "objectForKeyedSubscript:", CFSTR("Content-Type"));
    v47 = (URLResponse *)objc_claimAutoreleasedReturnValue();
    v49 = v47;
    if (v47)
    {
      v50 = (id)URLResponse::copyMIMETypeFromContentHeader(v47, v48);

    }
    else
    {
      v50 = 0;
    }
    if (v50)
      v53 = v50;
    else
      v53 = CFSTR("application/octet-stream");
    objc_msgSend(v46, "setObject:forKeyedSubscript:", v53, CFSTR("mimeType"));
    buffer_ptr.super.isa = 0;
    size_ptr = 0;
    v239 = dispatch_data_create_map(data, (const void **)&buffer_ptr.super.isa, &size_ptr);
    if (!size_ptr)
      goto LABEL_89;
    v54 = size_ptr - 1;
    v55 = *((char *)buffer_ptr.super.isa + size_ptr - 1);
    if ((v55 & 0x80000000) == 0)
      goto LABEL_89;
    if ((v55 + 62) > 0x32u)
    {
      if (*((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) > 0xBFu)
        goto LABEL_89;
      v54 = size_ptr - 2;
      v61 = *((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 2);
      if ((v61 + 32) > 0x14u)
      {
        if ((char)v61 > -65
          || (v54 = size_ptr - 3, v64 = *((_BYTE *)buffer_ptr.super.isa + size_ptr - 3),
                                  (v64 + 16) > 4u)
          || ((byte_18411E394[v61 >> 4] >> (v64 & 7)) & 1) == 0)
        {
LABEL_89:
          v65 = objc_alloc(MEMORY[0x1E0CB3940]);
          v66 = (void *)objc_msgSend(v65, "initWithBytes:length:encoding:", buffer_ptr.super.isa, size_ptr, 4);
          if (v66)
          {
            objc_msgSend(v46, "setObject:forKeyedSubscript:", v66, CFSTR("text"));
          }
          else
          {
            -[NSObject base64EncodedStringWithOptions:](data, "base64EncodedStringWithOptions:", 0);
            v67 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v46, "setObject:forKeyedSubscript:", v67, CFSTR("_textBase64"));

          }
          objc_msgSend(v237, "setObject:forKeyedSubscript:", v46, CFSTR("postData"));
          v68 = (void *)HARRequestBody;
          v69 = *(_QWORD **)(a1 + 32);
          if (v69)
            v69 = (_QWORD *)v69[6];
          v70 = v69;
          objc_msgSend(v68, "setObject:forKeyedSubscript:", 0, v70);

          goto LABEL_95;
        }
      }
      else
      {
        if (v61 > 0xEF)
        {
          v62 = (char *)&byte_18411E394[(unint64_t)*((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) >> 4];
          LOBYTE(v63) = v61 & 7;
        }
        else
        {
          v62 = &a00000000000000[v61 & 0xF];
          v63 = *((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) >> 5;
        }
        if (((*v62 >> v63) & 1) == 0)
          goto LABEL_89;
      }
    }
    size_ptr = v54;
    goto LABEL_89;
  }
LABEL_95:
  v71 = *(_QWORD **)(a1 + 32);
  if (v71)
    v71 = (_QWORD *)v71[10];
  v72 = v71;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if (v72 && objc_msgSend(v72, "statusCode") != 304)
      goto LABEL_108;
  }
  else
  {

    v72 = 0;
  }
  v73 = *(_QWORD **)(a1 + 32);
  if (v73)
    v73 = (_QWORD *)v73[9];
  v74 = v73;
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  if ((isKindOfClass & 1) != 0)
  {
    v76 = *(_QWORD **)(a1 + 32);
    if (v76)
      v76 = (_QWORD *)v76[9];
    v77 = v76;

    v72 = v77;
    v220 = objc_msgSend(v77, "statusCode") == 304;
    goto LABEL_109;
  }
LABEL_108:
  v220 = 0;
LABEL_109:
  objc_msgSend(v72, "allHeaderFields");
  v233 = v72;
  v211 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", objc_msgSend(v211, "count"));
  v240 = (void *)objc_claimAutoreleasedReturnValue();
  v244 = 0u;
  v245 = 0u;
  v242 = 0u;
  v243 = 0u;
  v78 = v211;
  v79 = objc_msgSend(v78, "countByEnumeratingWithState:objects:count:", &v242, v277, 16);
  if (v79)
  {
    v80 = *(_QWORD *)v243;
    do
    {
      for (m = 0; m != v79; ++m)
      {
        if (*(_QWORD *)v243 != v80)
          objc_enumerationMutation(v78);
        v276[0] = *(_QWORD *)(*((_QWORD *)&v242 + 1) + 8 * m);
        v275[0] = CFSTR("name");
        v275[1] = CFSTR("value");
        objc_msgSend(v78, "objectForKeyedSubscript:");
        v82 = (void *)objc_claimAutoreleasedReturnValue();
        v276[1] = v82;
        objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v276, v275, 2);
        v83 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v240, "addObject:", v83);

      }
      v79 = objc_msgSend(v78, "countByEnumeratingWithState:objects:count:", &v242, v277, 16);
    }
    while (v79);
  }

  objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithCapacity:", 4);
  v234 = (void *)objc_claimAutoreleasedReturnValue();
  v84 = *(_QWORD *)(a1 + 32);
  if (v84)
    v85 = *(_QWORD *)(v84 + 128);
  else
    v85 = 0;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v85);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v234, "setObject:forKeyedSubscript:", v86, CFSTR("size"));

  objc_msgSend(v233, "MIMEType");
  v87 = objc_claimAutoreleasedReturnValue();
  v88 = (void *)v87;
  if (v87)
    v89 = (const __CFString *)v87;
  else
    v89 = CFSTR("application/octet-stream");
  objc_msgSend(v234, "setObject:forKeyedSubscript:", v89, CFSTR("mimeType"));

  v90 = (void *)HARResponseBody;
  v91 = *(_QWORD **)(a1 + 32);
  if (v91)
    v91 = (_QWORD *)v91[6];
  v92 = v91;
  objc_msgSend(v90, "objectForKeyedSubscript:", v92);
  v231 = objc_claimAutoreleasedReturnValue();

  if (!v231)
    goto LABEL_144;
  buffer_ptr.super.isa = 0;
  size_ptr = 0;
  v93 = dispatch_data_create_map(v231, (const void **)&buffer_ptr.super.isa, &size_ptr);
  if (size_ptr)
  {
    v94 = size_ptr - 1;
    v95 = *((char *)buffer_ptr.super.isa + size_ptr - 1);
    if (v95 < 0)
    {
      if ((v95 + 62) <= 0x32u)
        goto LABEL_127;
      if (*((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) > 0xBFu)
        goto LABEL_138;
      v94 = size_ptr - 2;
      v96 = *((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 2);
      if ((v96 + 32) <= 0x14u)
      {
        if (v96 > 0xEF)
        {
          v97 = (char *)&byte_18411E394[(unint64_t)*((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) >> 4];
          LOBYTE(v98) = v96 & 7;
        }
        else
        {
          v97 = &a00000000000000[v96 & 0xF];
          v98 = *((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) >> 5;
        }
        if (((*v97 >> v98) & 1) == 0)
          goto LABEL_138;
        goto LABEL_127;
      }
      if ((char)v96 <= -65)
      {
        v94 = size_ptr - 3;
        v99 = *((_BYTE *)buffer_ptr.super.isa + size_ptr - 3);
        if ((v99 + 16) <= 4u && ((byte_18411E394[v96 >> 4] >> (v99 & 7)) & 1) != 0)
LABEL_127:
          size_ptr = v94;
      }
    }
  }
LABEL_138:
  v100 = objc_alloc(MEMORY[0x1E0CB3940]);
  v101 = objc_msgSend(v100, "initWithBytes:length:encoding:", buffer_ptr.super.isa, size_ptr, 4);
  v102 = (void *)v101;
  if (v101)
  {
    v103 = CFSTR("text");
    v104 = (const __CFString *)v101;
  }
  else
  {
    -[NSObject base64EncodedStringWithOptions:](v231, "base64EncodedStringWithOptions:", 0);
    v105 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v234, "setObject:forKeyedSubscript:", v105, CFSTR("text"));

    v103 = CFSTR("encoding");
    v104 = CFSTR("base64");
  }
  objc_msgSend(v234, "setObject:forKeyedSubscript:", v104, v103);
  v106 = (void *)HARResponseBody;
  v107 = *(_QWORD **)(a1 + 32);
  if (v107)
    v107 = (_QWORD *)v107[6];
  v108 = v107;
  objc_msgSend(v106, "setObject:forKeyedSubscript:", 0, v108);

LABEL_144:
  if (!v233
    || ((v109 = *(_QWORD *)(objc_msgSend(v233, "_inner") + 88)) != 0
      ? (v110 = (__CFHTTPMessage *)(v109 - 16))
      : (v110 = 0),
        !v109))
  {
    v228 = 0;
    v229 = 0;
    goto LABEL_159;
  }
  v111 = objc_retainAutorelease((id)CFHTTPMessageCopyResponseStatusLine(v110));
  v112 = -[__CFString UTF8String](v111, "UTF8String");
  v113 = 0;
  v114 = 0;
  while (*(_BYTE *)(v112 + v113) != 32)
  {
    if (!*(_BYTE *)(v112 + v113))
      goto LABEL_158;
LABEL_155:
    ++v113;
  }
  if (v114 != 1)
  {
    v114 = 1;
    goto LABEL_155;
  }
  ++v113;
LABEL_158:
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v112 + v113);
  v115 = objc_claimAutoreleasedReturnValue();
  v229 = (__CFString *)CFHTTPMessageCopyVersion(v110);
  v228 = (__CFString *)v115;

LABEL_159:
  v273[0] = CFSTR("status");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", objc_msgSend(v233, "statusCode"));
  v116 = objc_claimAutoreleasedReturnValue();
  v117 = (void *)v116;
  v118 = v228;
  if (!v228)
    v118 = &stru_1E1500C68;
  v274[0] = v116;
  v274[1] = v118;
  v273[1] = CFSTR("statusText");
  v273[2] = CFSTR("httpVersion");
  v119 = v229;
  if (!v229)
    v119 = &stru_1E1500C68;
  v274[2] = v119;
  v274[3] = MEMORY[0x1E0C9AA60];
  v273[3] = CFSTR("cookies");
  v273[4] = CFSTR("headers");
  v274[4] = v240;
  v274[5] = v234;
  v273[5] = CFSTR("content");
  v273[6] = CFSTR("redirectURL");
  objc_msgSend(v78, "objectForKeyedSubscript:", CFSTR("Location"));
  v120 = objc_claimAutoreleasedReturnValue();
  v121 = (void *)v120;
  if (v120)
    v122 = (const __CFString *)v120;
  else
    v122 = &stru_1E1500C68;
  v274[6] = v122;
  v273[7] = CFSTR("headersSize");
  v123 = *(_QWORD *)(a1 + 32);
  if (v123)
    v124 = *(_QWORD *)(v123 + 120);
  else
    v124 = 0;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v124);
  v125 = (void *)objc_claimAutoreleasedReturnValue();
  v274[7] = v125;
  v273[8] = CFSTR("bodySize");
  v126 = *(_QWORD *)(a1 + 32);
  if (v126)
    v127 = *(_QWORD *)(v126 + 136);
  else
    v127 = 0;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v127);
  v128 = (void *)objc_claimAutoreleasedReturnValue();
  v274[8] = v128;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v274, v273, 9);
  v227 = (void *)objc_claimAutoreleasedReturnValue();

  memset(&buffer_ptr, 0, 32);
  connectionTimingFromMetrics(&buffer_ptr, v235);
  v260[0] = CFSTR("blocked");
  v129 = *(_QWORD *)(a1 + 32);
  isa = 0;
  if (v129)
  {
    v131 = *(double *)(v129 + 144);
    if (*(_BYTE *)(v129 + 9))
      isa = buffer_ptr.super.isa;
    else
      isa = *(Class *)(v129 + 176);
  }
  else
  {
    v131 = 0.0;
  }
  HARTimeInterval(v131, *(double *)&isa);
  v132 = objc_claimAutoreleasedReturnValue();
  v133 = (void *)v132;
  v266 = v132;
  v260[1] = CFSTR("dns");
  v134 = *(_QWORD *)(a1 + 32);
  if (v134)
  {
    v135 = buffer_ptr.super.isa;
    if (*(_BYTE *)(v134 + 9))
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)&buffer_ptr._expensive);
      v132 = objc_claimAutoreleasedReturnValue();
      v134 = *(_QWORD *)(a1 + 32);
      v267 = (void *)v132;
      v261 = CFSTR("connect");
      v136 = 1;
      if (!v134)
      {
        v224 = 1;
        v222 = (void *)v132;
        goto LABEL_289;
      }
    }
    else
    {
      v136 = 0;
      v267 = &unk_1E152A730;
      v261 = CFSTR("connect");
    }
    v222 = (void *)v132;
    v224 = v136;
    if (*(_BYTE *)(v134 + 9))
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)&buffer_ptr._isUnlistedTracker, *(double *)&buffer_ptr.connectionLock._os_unfair_lock_opaque);
      v137 = objc_claimAutoreleasedReturnValue();
      v134 = *(_QWORD *)(a1 + 32);
      v217 = (void *)v137;
      v268 = (void *)v137;
      v262 = CFSTR("send");
      v138 = 1;
      if (!v134)
      {
        v139 = 0.0;
        goto LABEL_290;
      }
    }
    else
    {
      v138 = 0;
      v268 = &unk_1E152A730;
      v262 = CFSTR("send");
    }
    v139 = *(double *)(v134 + 176);
    v140 = *(double *)(v134 + 184);
  }
  else
  {
    v224 = 0;
    v135 = buffer_ptr.super.isa;
    v267 = &unk_1E152A730;
    v261 = CFSTR("connect");
LABEL_289:
    v138 = 0;
    v268 = &unk_1E152A730;
    v262 = CFSTR("send");
    v139 = 0.0;
LABEL_290:
    v140 = 0.0;
  }
  HARTimeInterval(v139, v140);
  v141 = (void *)objc_claimAutoreleasedReturnValue();
  v269 = v141;
  v263 = CFSTR("wait");
  v142 = *(_QWORD *)(a1 + 32);
  if (v142)
  {
    v143 = *(double *)(v142 + 184);
    v144 = *(double *)(v142 + 192);
  }
  else
  {
    v143 = 0.0;
    v144 = 0.0;
  }
  HARTimeInterval(v143, v144);
  v145 = (void *)objc_claimAutoreleasedReturnValue();
  v270 = v145;
  v264 = CFSTR("receive");
  v146 = *(_QWORD *)(a1 + 32);
  if (v146)
  {
    v147 = *(double *)(v146 + 192);
    v148 = *(double *)(v146 + 200);
  }
  else
  {
    v147 = 0.0;
    v148 = 0.0;
  }
  HARTimeInterval(v147, v148);
  v149 = (void *)objc_claimAutoreleasedReturnValue();
  v271 = v149;
  v265 = CFSTR("ssl");
  v150 = *(_QWORD *)(a1 + 32);
  if (v150)
  {
    v151 = 0;
    v152 = &unk_1E152A730;
    if (*(_BYTE *)(v150 + 9) && LOBYTE(buffer_ptr._negotiatedTLSProtocolVersion))
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)&buffer_ptr._coalesced);
      v152 = (void *)objc_claimAutoreleasedReturnValue();
      v151 = 1;
    }
  }
  else
  {
    v151 = 0;
    v152 = &unk_1E152A730;
  }
  v272 = v152;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v266, v260, 7);
  v226 = (void *)objc_claimAutoreleasedReturnValue();
  if (v151)

  if (v138)
  if (v224)

  v153 = (double *)*(id *)(a1 + 32);
  v154 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  if (v153)
  {
    if (*((_BYTE *)v153 + 9))
    {
      LODWORD(v155) = *(_DWORD *)&buffer_ptr._expensive;
      precisionPreservingInterval(*(double *)&v135, *(double *)&v135 + (double)v155 / 1000.0, v153[18]);
      v156 = (void *)objc_claimAutoreleasedReturnValue();
      if (v156)
        objc_msgSend(v154, "setObject:forKeyedSubscript:", v156, CFSTR("dns"));

      if (*((_BYTE *)v153 + 9))
      {
        LODWORD(v157) = *(_DWORD *)&buffer_ptr._isUnlistedTracker;
        precisionPreservingInterval(*(double *)&buffer_ptr.connectionLock._os_unfair_lock_opaque, *(double *)&buffer_ptr.connectionLock._os_unfair_lock_opaque + (double)v157 / 1000.0, v153[18]);
        v158 = (void *)objc_claimAutoreleasedReturnValue();
        if (v158)
          objc_msgSend(v154, "setObject:forKeyedSubscript:", v158, CFSTR("connect"));

        if (*((_BYTE *)v153 + 9) && LOBYTE(buffer_ptr._negotiatedTLSProtocolVersion))
        {
          LODWORD(v160) = *(_DWORD *)&buffer_ptr._coalesced;
          LODWORD(v159) = *(_DWORD *)&buffer_ptr._isUnlistedTracker;
          precisionPreservingInterval(*(double *)&buffer_ptr.connectionLock._os_unfair_lock_opaque + (double)v159 / 1000.0 - (double)v160 / 1000.0, *(double *)&buffer_ptr.connectionLock._os_unfair_lock_opaque + (double)v159 / 1000.0, v153[18]);
          v161 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v154, "setObject:forKeyedSubscript:", v161, CFSTR("secureConnection"));

        }
      }
    }
    v162 = v153[20];
    v163 = v153[21];
    v164 = v153[18];
  }
  else
  {
    v163 = 0.0;
    v162 = 0.0;
    v164 = 0.0;
  }
  precisionPreservingInterval(v162, v163, v164);
  v165 = (void *)objc_claimAutoreleasedReturnValue();
  if (v165)
    objc_msgSend(v154, "setObject:forKeyedSubscript:", v165, CFSTR("cache"));
  if (v153)
  {
    v166 = v153[22];
    v167 = v153[23];
    v168 = v153[18];
  }
  else
  {
    v167 = 0.0;
    v166 = 0.0;
    v168 = 0.0;
  }
  precisionPreservingInterval(v166, v167, v168);
  v169 = (void *)objc_claimAutoreleasedReturnValue();
  if (v169)
    objc_msgSend(v154, "setObject:forKeyedSubscript:", v169, CFSTR("send"));
  if (v153)
  {
    v170 = v153[24];
    v171 = v153[25];
    v172 = v153[18];
  }
  else
  {
    v171 = 0.0;
    v170 = 0.0;
    v172 = 0.0;
  }
  precisionPreservingInterval(v170, v171, v172);
  v173 = (void *)objc_claimAutoreleasedReturnValue();
  if (v173)
    objc_msgSend(v154, "setObject:forKeyedSubscript:", v173, CFSTR("receive"));
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithDictionary:", v154);
  v225 = (void *)objc_claimAutoreleasedReturnValue();

  if (v235 && (v174 = v235[18]) != 0)
  {
    endpoint = v174;
    if (nw_endpoint_get_type(v174) == nw_endpoint_type_address)
    {
      v175 = nw_endpoint_copy_address_string(endpoint);
      v223 = (__CFString *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v175, 0x600u, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
      goto LABEL_225;
    }
  }
  else
  {
    endpoint = 0;
  }
  v223 = 0;
LABEL_225:
  v258[0] = CFSTR("startedDateTime");
  v176 = *(_QWORD *)(a1 + 32);
  if (v176)
    v177 = *(double *)(v176 + 144);
  else
    v177 = 0.0;
  v178 = (void *)HARDateFormatter;
  objc_msgSend(MEMORY[0x1E0C99D68], "dateWithTimeIntervalSinceReferenceDate:", v177);
  v215 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v178, "stringFromDate:");
  v214 = (void *)objc_claimAutoreleasedReturnValue();
  v259[0] = v214;
  v258[1] = CFSTR("time");
  v179 = *(_QWORD *)(a1 + 32);
  if (v179)
  {
    v180 = *(double *)(v179 + 144);
    v181 = *(double *)(v179 + 152);
  }
  else
  {
    v180 = 0.0;
    v181 = 0.0;
  }
  HARTimeInterval(v180, v181);
  v182 = objc_claimAutoreleasedReturnValue();
  v258[2] = CFSTR("request");
  v258[3] = CFSTR("response");
  v213 = (void *)v182;
  v259[1] = v182;
  v259[2] = v237;
  v259[3] = v227;
  v259[4] = MEMORY[0x1E0C9AA70];
  v258[4] = CFSTR("cache");
  v258[5] = CFSTR("timings");
  v259[5] = v226;
  v258[6] = CFSTR("_transactionUUID");
  v183 = *(_QWORD **)(a1 + 32);
  if (v183)
    v183 = (_QWORD *)v183[6];
  v218 = v183;
  objc_msgSend(v218, "UUIDString");
  v184 = (void *)objc_claimAutoreleasedReturnValue();
  v185 = v184;
  if (!v184)
  {
    objc_msgSend(MEMORY[0x1E0C99E38], "null");
    v185 = (void *)objc_claimAutoreleasedReturnValue();
  }
  v259[6] = v185;
  v258[7] = CFSTR("_taskUUID");
  objc_msgSend(*(id *)(a1 + 40), "UUIDString");
  v186 = (void *)objc_claimAutoreleasedReturnValue();
  v187 = v186;
  if (!v186)
  {
    objc_msgSend(MEMORY[0x1E0C99E38], "null");
    v187 = (void *)objc_claimAutoreleasedReturnValue();
  }
  v259[7] = v187;
  v259[8] = v225;
  v258[8] = CFSTR("_precisionPreservingTimings");
  v258[9] = CFSTR("serverIPAddress");
  v188 = &stru_1E1500C68;
  if (v223)
    v188 = v223;
  v259[9] = v188;
  v258[10] = CFSTR("connection");
  v189 = v235;
  if (v235)
    v189 = (id *)v235[9];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%llu"), v189);
  v190 = (void *)objc_claimAutoreleasedReturnValue();
  v259[10] = v190;
  v258[11] = CFSTR("_fetchType");
  v191 = *(id *)(a1 + 32);
  v192 = v191;
  if (v220)
  {
    v193 = CFSTR("Revalidated Cache");
    goto LABEL_248;
  }
  if (!v191)
    goto LABEL_246;
  if (*((_BYTE *)v191 + 10))
  {
    v193 = CFSTR("Server Push");
    goto LABEL_248;
  }
  v194 = *((id *)v191 + 9);
  if (v194 && (v195 = v192[8] == 0, v194, v195))
    v193 = CFSTR("Local Cache");
  else
LABEL_246:
    v193 = CFSTR("Network Load");
LABEL_248:

  v259[11] = v193;
  v258[12] = CFSTR("_sourceApplicationBundleIdentifier");
  v196 = *(void **)(a1 + 48);
  v197 = v196;
  if (!v196)
  {
    objc_msgSend(MEMORY[0x1E0C99E38], "null");
    v197 = (void *)objc_claimAutoreleasedReturnValue();
  }
  v259[12] = v197;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v259, v258, 13);
  v221 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v196)

  if (!v186)
  if (!v184)

  objc_msgSend(MEMORY[0x1E0CB36D8], "dataWithJSONObject:options:error:", v221, 0, 0);
  v219 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v198 = (_BYTE *)objc_msgSend(v219, "bytes");
  v199 = objc_msgSend(v219, "length");
  if (v199 >= 0x7801)
  {
    while (2)
    {
      v200 = (char)v198[30719];
      if ((v200 & 0x80000000) == 0)
        break;
      if ((v200 + 62) < 0x33u)
      {
        v201 = 30719;
        goto LABEL_259;
      }
      if (v198[30719] <= 0xBFu)
      {
        v203 = v198[30718];
        if ((v203 + 32) <= 0x14u)
        {
          v204 = v203 > 0xEF;
          v205 = (char *)&byte_18411E394[(unint64_t)v198[30719] >> 4];
          v206 = v203 & 7;
          v207 = &a00000000000000[v203 & 0xF];
          v208 = v198[30719] >> 5;
          if (v204)
            LOBYTE(v208) = v206;
          else
            v205 = v207;
          if (((*v205 >> v208) & 1) != 0)
            v201 = 30718;
          else
            v201 = 30720;
LABEL_259:
          v202 = (id)HARLog;
          if (os_log_type_enabled(v202, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(size_ptr) = 68157954;
            HIDWORD(size_ptr) = v201;
            v282 = 2082;
            v283 = v198;
            _os_log_impl(&dword_183ECA000, v202, OS_LOG_TYPE_DEFAULT, "<incomplete> %{public,xcode:data}.*s", (uint8_t *)&size_ptr, 0x12u);
          }

          v199 -= v201;
          v198 += v201;
          if (v199 <= 0x7800)
            goto LABEL_278;
          continue;
        }
        if ((char)v203 <= -65)
        {
          v209 = v198[30717];
          if ((v209 + 16) <= 4u)
          {
            if (((byte_18411E394[v203 >> 4] >> (v209 & 7)) & 1) != 0)
              v201 = 30717;
            else
              v201 = 30720;
            goto LABEL_259;
          }
        }
      }
      break;
    }
    v201 = 30720;
    goto LABEL_259;
  }
LABEL_278:
  v210 = (id)HARLog;
  if (os_log_type_enabled(v210, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(size_ptr) = 68157954;
    HIDWORD(size_ptr) = v199;
    v282 = 2082;
    v283 = v198;
    _os_log_impl(&dword_183ECA000, v210, OS_LOG_TYPE_DEFAULT, "%{public,xcode:data}.*s", (uint8_t *)&size_ptr, 0x12u);
  }

LABEL_281:
}

void sub_1840DC788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,uint64_t a33,uint64_t a34,void *a35,void *a36)
{
  void *v36;
  void *v37;
  void *v38;

  _Unwind_Resume(a1);
}

id HARTimeInterval(double a1, double a2)
{
  uint64_t v2;
  uint64_t v3;

  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", (int)((a2 - a1) * 1000.0), v2, v3);
  return (id)objc_claimAutoreleasedReturnValue();
}

id precisionPreservingInterval(double a1, double a2, double a3)
{
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 2);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", a1 - a3);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "setObject:forKeyedSubscript:", v7, CFSTR("start"));

  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", a2 - a3);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "setObject:forKeyedSubscript:", v8, CFSTR("end"));

  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithDictionary:", v6);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  return v9;
}

void sub_1840DCDDC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id instrumentsTaskLog(void)
{
  if (instrumentsTaskLog(void)::onceToken != -1)
    dispatch_once(&instrumentsTaskLog(void)::onceToken, &__block_literal_global_170);
  return (id)instrumentsTaskLog(void)::log;
}

void ___ZL18instrumentsTaskLogv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.CFNetwork.Instruments", "DynamicStackTracing");
  v1 = (void *)instrumentsTaskLog(void)::log;
  instrumentsTaskLog(void)::log = (uint64_t)v0;

}

id instrumentsTransactionLog(void)
{
  if (instrumentsTransactionLog(void)::onceToken != -1)
    dispatch_once(&instrumentsTransactionLog(void)::onceToken, &__block_literal_global_204_15280);
  return (id)instrumentsTransactionLog(void)::log;
}

void ___ZL25instrumentsTransactionLogv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.CFNetwork.Instruments", "HTTP Transactions");
  v1 = (void *)instrumentsTransactionLog(void)::log;
  instrumentsTransactionLog(void)::log = (uint64_t)v0;

}

void ___ZL17emptyJSONDictDatav_block_invoke()
{
  uint64_t v0;
  void *v1;

  objc_msgSend(MEMORY[0x1E0CB36D8], "dataWithJSONObject:options:error:", MEMORY[0x1E0C9AA70], 0, 0);
  v0 = objc_claimAutoreleasedReturnValue();
  v1 = (void *)emptyJSONDictData(void)::data;
  emptyJSONDictData(void)::data = v0;

}

void sub_1840E07C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1840E0A5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  id *v10;

  objc_destroyWeak(v10);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void _onqueue_readStreamEvent(__CFReadStream *a1, uint64_t a2, void *a3)
{
  NSObject *v5;
  _QWORD v6[6];

  v5 = objc_msgSend(a3, "workQueue");
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZL24_onqueue_readStreamEventP14__CFReadStreammPv_block_invoke;
  v6[3] = &unk_1E14FE140;
  v6[4] = a3;
  v6[5] = a2;
  dispatch_async(v5, v6);
}

void _onqueue_writeStreamEvent(__CFWriteStream *a1, uint64_t a2, void *a3)
{
  NSObject *v5;
  _QWORD v6[6];

  v5 = objc_msgSend(a3, "workQueue");
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZL25_onqueue_writeStreamEventP15__CFWriteStreammPv_block_invoke;
  v6[3] = &unk_1E14FE140;
  v6[4] = a3;
  v6[5] = a2;
  dispatch_async(v5, v6);
}

void ___ZL25_onqueue_writeStreamEventP15__CFWriteStreammPv_block_invoke(uint64_t a1)
{
  -[__NSCFURLLocalStreamTask _onqueue_writeStreamEvent:](*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void ___ZL24_onqueue_readStreamEventP14__CFReadStreammPv_block_invoke(uint64_t a1)
{
  -[__NSCFURLLocalStreamTask _onqueue_readStreamEvent:](*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void sub_1840E1228(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  MEMORY[0x186DB748C](v1, 0x10A1C40B93A1745);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke_15516()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  dword_1EDD01068 = 1835099506;
  _PNAME<SocketStream>::GET(void)::p = *(_QWORD *)"SocketStream>::GET() [OBJTYPE = SocketStream]";
  CFClass::CFClass(v0, (const char *)&_PNAME<SocketStream>::GET(void)::p);
  TCFObject<SocketStream>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840E14F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void TaskSocketStreamClient::~TaskSocketStreamClient(TaskSocketStreamClient *this)
{
  TaskSocketStreamClient::~TaskSocketStreamClient(this);
  JUMPOUT(0x186DB748CLL);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_1E14EC6D0;
  *((_QWORD *)this + 1) = &unk_1E14EC758;

  v2 = *((_QWORD *)this + 3);
  if (v2)
    CFRelease((CFTypeRef)(v2 - 16));
  *(_QWORD *)this = &off_1E14E5838;
}

uint64_t TaskSocketStreamClient::initialize(TaskSocketStreamClient *this, NSString *a2, uint64_t a3)
{
  *((_QWORD *)this + 4) = -[NSString copy](a2, "copy");
  *((_QWORD *)this + 5) = a3;
  return (*(uint64_t (**)(_QWORD, NSString *, uint64_t))(**((_QWORD **)this + 3) + 56))(*((_QWORD *)this + 3), a2, a3);
}

void TaskSocketStreamClient::initialize(TaskSocketStreamClient *this, NSNetService *a2)
{
  CFMutableDictionaryRef *v2;

  v2 = (CFMutableDictionaryRef *)*((_QWORD *)this + 3);
  if (a2)
    a2 = (NSNetService *)a2->_netService;
  SocketStream::initialize(v2, (__CFNetService *)a2);
}

uint64_t TaskSocketStreamClient::beginConnection(TaskSocketStreamClient *this)
{
  uint64_t result;
  uint64_t v3;
  const void *v4;

  result = *((_QWORD *)this + 3);
  if (result)
  {
    (*(void (**)(uint64_t, char *))(*(_QWORD *)result + 176))(result, (char *)this + 8);
    v3 = objc_msgSend(*((id *)this + 2), "_copySocketStreamProperties");
    if (v3)
    {
      v4 = (const void *)v3;
      (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 3) + 208))(*((_QWORD *)this + 3), v3);
      CFRelease(v4);
    }
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 192))(*((_QWORD *)this + 3));
  }
  return result;
}

uint64_t TaskSocketStreamClient::endConnection(TaskSocketStreamClient *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 176))(result, 0);
  return result;
}

void TaskSocketStreamClient::copySocketProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  _QWORD block[7];

  v6 = objc_msgSend(*(id *)(a1 + 16), "workQueue");
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN22TaskSocketStreamClient18copySocketPropertyEPK10__CFStringU13block_pointerFvPKvE_block_invoke;
  block[3] = &unk_1E14FDB30;
  block[5] = a1;
  block[6] = a2;
  block[4] = a3;
  dispatch_async(v6, block);
}

id TaskSocketStreamClient::ceRetain(id *this)
{
  return this[2];
}

void TaskSocketStreamClient::ceRelease(id *this)
{

}

void TaskSocketStreamClient::ssPreConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[6];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN22TaskSocketStreamClient25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke;
  v3[3] = &unk_1E14FCF60;
  v3[4] = a2;
  v3[5] = a3;
  TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 16), (uint64_t)v3);
}

void TaskSocketStreamClient::ssNeedServerTrust(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  const __CFString *v7;
  const void *Challenge;
  id v9;
  _QWORD v10[6];
  _QWORD v11[5];

  if (*(_QWORD *)(a1 + 24))
  {
    v5 = MEMORY[0x1E0C809B0];
    v7 = *(const __CFString **)(a1 + 32);
    v6 = *(_QWORD *)(a1 + 40);
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = ___ZN22HTTPProtocolSSLSupport35CreateTrustChallengeWithHostAndPortEPK10__CFStringlP10__SecTrust_block_invoke;
    v11[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
    v11[4] = a2;
    Challenge = (const void *)createChallenge(8, v7, v6, (uint64_t)v11);
    v9 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:](NSURLAuthenticationChallenge, "_authenticationChallengeForCFAuthChallenge:sender:", Challenge, 0);
    if (Challenge)
      CFRelease(Challenge);
    v10[0] = v5;
    v10[1] = 3221225472;
    v10[2] = ___ZN22TaskSocketStreamClient17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke;
    v10[3] = &unk_1E14FCF60;
    v10[4] = v9;
    v10[5] = a3;
    TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 16), (uint64_t)v10);
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD))(a3 + 16))(a3, 0);
  }
}

void TaskSocketStreamClient::ssNeedClientCert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  const __CFString *v7;
  const void *Challenge;
  id v9;
  _QWORD v10[6];
  _QWORD v11[5];

  if (*(_QWORD *)(a1 + 24))
  {
    v5 = MEMORY[0x1E0C809B0];
    v7 = *(const __CFString **)(a1 + 32);
    v6 = *(_QWORD *)(a1 + 40);
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = ___ZN22HTTPProtocolSSLSupport40CreateClientCertChallengeWithHostAndPortEPK10__CFStringlPK9__CFArray_block_invoke;
    v11[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
    v11[4] = a2;
    Challenge = (const void *)createChallenge(7, v7, v6, (uint64_t)v11);
    v9 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:](NSURLAuthenticationChallenge, "_authenticationChallengeForCFAuthChallenge:sender:", Challenge, 0);
    if (Challenge)
      CFRelease(Challenge);
    v10[0] = v5;
    v10[1] = 3221225472;
    v10[2] = ___ZN22TaskSocketStreamClient16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke;
    v10[3] = &unk_1E14FCF60;
    v10[4] = v9;
    v10[5] = a3;
    TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 16), (uint64_t)v10);
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD))(a3 + 16))(a3, 0);
  }
}

void TaskSocketStreamClient::ssPostConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[6];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN22TaskSocketStreamClient26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
  v3[3] = &unk_1E14FCF60;
  v3[4] = a2;
  v3[5] = a3;
  TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 16), (uint64_t)v3);
}

void TaskSocketStreamClient::ssPostHandshakesStreamsAvailable(void **this, CFTypeRef cf, CFTypeRef a3)
{
  _QWORD v6[6];

  if (cf)
    CFRetain(cf);
  if (a3)
    CFRetain(a3);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN22TaskSocketStreamClient32ssPostHandshakesStreamsAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke;
  v6[3] = &__block_descriptor_48_e34_v16__0____NSCFURLLocalStreamTask_8l;
  v6[4] = cf;
  v6[5] = a3;
  TaskSocketStreamClient::withWorkQueue(this[2], (uint64_t)v6);
}

void `non-virtual thunk to'TaskSocketStreamClient::~TaskSocketStreamClient(TaskSocketStreamClient *this)
{
  TaskSocketStreamClient::~TaskSocketStreamClient((TaskSocketStreamClient *)((char *)this - 8));
}

{
  TaskSocketStreamClient::~TaskSocketStreamClient((TaskSocketStreamClient *)((char *)this - 8));
  JUMPOUT(0x186DB748CLL);
}

id `non-virtual thunk to'TaskSocketStreamClient::ceRetain(id *this)
{
  return this[1];
}

void `non-virtual thunk to'TaskSocketStreamClient::ceRelease(id *this)
{

}

void `non-virtual thunk to'TaskSocketStreamClient::ssPreConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[6];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN22TaskSocketStreamClient25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke;
  v3[3] = &unk_1E14FCF60;
  v3[4] = a2;
  v3[5] = a3;
  TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 8), (uint64_t)v3);
}

void `non-virtual thunk to'TaskSocketStreamClient::ssNeedServerTrust(uint64_t a1, uint64_t a2, uint64_t a3)
{
  TaskSocketStreamClient::ssNeedServerTrust(a1 - 8, a2, a3);
}

void `non-virtual thunk to'TaskSocketStreamClient::ssNeedClientCert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  TaskSocketStreamClient::ssNeedClientCert(a1 - 8, a2, a3);
}

void `non-virtual thunk to'TaskSocketStreamClient::ssPostConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[6];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN22TaskSocketStreamClient26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
  v3[3] = &unk_1E14FCF60;
  v3[4] = a2;
  v3[5] = a3;
  TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 8), (uint64_t)v3);
}

void `non-virtual thunk to'TaskSocketStreamClient::ssPostHandshakesStreamsAvailable(void **this, __CFReadStream *a2, __CFWriteStream *a3)
{
  TaskSocketStreamClient::ssPostHandshakesStreamsAvailable(this - 1, a2, a3);
}

uint64_t ___ZN22TaskSocketStreamClient26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(void))(*(_QWORD *)(result + 40) + 16))();
  return result;
}

void TaskSocketStreamClient::withWorkQueue(void *a1, uint64_t a2)
{
  id v3;
  NSObject *v4;
  _QWORD v5[6];

  v3 = a1;
  v4 = objc_msgSend(v3, "workQueue");
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN22TaskSocketStreamClient13withWorkQueueEU13block_pointerFvP24__NSCFURLLocalStreamTaskE_block_invoke;
  v5[3] = &unk_1E14FDF00;
  v5[4] = v3;
  v5[5] = a2;
  dispatch_async(v4, v5);
}

void ___ZN22TaskSocketStreamClient13withWorkQueueEU13block_pointerFvP24__NSCFURLLocalStreamTaskE_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

uint64_t ___ZN22TaskSocketStreamClient25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(void))(*(_QWORD *)(result + 40) + 16))();
  return result;
}

void sub_1840E1C1C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ___ZN22TaskSocketStreamClient32ssPostHandshakesStreamsAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;
  const void *v4;

  -[__NSCFURLLocalStreamTask _onqueue_readStream:writeStreamAvailable:](a2, *(void **)(a1 + 32), *(const void **)(a1 + 40));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
}

uint64_t ___ZN22TaskSocketStreamClient16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke(uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  char *v4;
  _QWORD v5[7];

  if (a2)
  {
    v4 = *(char **)(result + 32);
    v3 = *(_QWORD *)(result + 40);
    if (objc_msgSend(a2, "state") < 2)
    {
      v5[0] = MEMORY[0x1E0C809B0];
      v5[1] = 3221225472;
      v5[2] = __70____NSCFURLLocalStreamTask__onqueue_needClientCert_completionHandler___block_invoke;
      v5[3] = &unk_1E14FCEB0;
      v5[4] = a2;
      v5[5] = v4;
      v5[6] = v3;
      result = -[__NSCFURLLocalStreamTask _onqueue_sendSessionChallenge:completionHandler:](a2, v4, v5);
      if ((result & 1) == 0)
        return (*(uint64_t (**)(uint64_t, _QWORD))(v3 + 16))(v3, 0);
    }
    else
    {
      return (*(uint64_t (**)(uint64_t, _QWORD))(v3 + 16))(v3, 0);
    }
  }
  return result;
}

void sub_1840E24B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN22TaskSocketStreamClient17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke(uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  char *v4;
  _QWORD v5[7];

  if (a2)
  {
    v4 = *(char **)(result + 32);
    v3 = *(_QWORD *)(result + 40);
    if (objc_msgSend(a2, "state") < 2)
    {
      v5[0] = MEMORY[0x1E0C809B0];
      v5[1] = 3221225472;
      v5[2] = __71____NSCFURLLocalStreamTask__onqueue_needServerTrust_completionHandler___block_invoke;
      v5[3] = &unk_1E14FCEB0;
      v5[4] = a2;
      v5[5] = v4;
      v5[6] = v3;
      result = -[__NSCFURLLocalStreamTask _onqueue_sendSessionChallenge:completionHandler:](a2, v4, v5);
      if ((result & 1) == 0)
        return (*(uint64_t (**)(uint64_t, _QWORD))(v3 + 16))(v3, 0);
    }
    else
    {
      return (*(uint64_t (**)(uint64_t, _QWORD))(v3 + 16))(v3, 0);
    }
  }
  return result;
}

uint64_t ___ZN22TaskSocketStreamClient18copySocketPropertyEPK10__CFStringU13block_pointerFvPKvE_block_invoke(_QWORD *a1)
{
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1[5] + 24) + 224))(*(_QWORD *)(a1[5] + 24), a1[6]);
  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

void BaseSocketStreamClient::~BaseSocketStreamClient(BaseSocketStreamClient *this)
{
  this->var0 = (void **)&off_1E14E5838;
}

{
  this->var0 = (void **)&off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

void _onqueue_stFromDataTaskReadCallback(__CFReadStream *a1, uint64_t a2, void *a3)
{
  NSObject *v5;
  _QWORD v6[6];

  v5 = objc_msgSend(a3, "workQueue");
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZL35_onqueue_stFromDataTaskReadCallbackP14__CFReadStreammPv_block_invoke;
  v6[3] = &unk_1E14FE140;
  v6[4] = a3;
  v6[5] = a2;
  dispatch_async(v5, v6);
}

void _onqueue_stFromDataTaskWriteCallback(__CFWriteStream *a1, uint64_t a2, void *a3)
{
  NSObject *v5;
  _QWORD v6[6];

  v5 = objc_msgSend(a3, "workQueue");
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZL36_onqueue_stFromDataTaskWriteCallbackP15__CFWriteStreammPv_block_invoke;
  v6[3] = &unk_1E14FE140;
  v6[4] = a3;
  v6[5] = a2;
  dispatch_async(v5, v6);
}

void ___ZL36_onqueue_stFromDataTaskWriteCallbackP15__CFWriteStreammPv_block_invoke(uint64_t a1)
{
  CFStreamError *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(CFStreamError **)(a1 + 32);
  if (v1 && v1[75].domain)
  {
    v2 = *(_QWORD *)(a1 + 40);
    if (v1[48].error == 1)
      v1[48].error = 2;
    switch(v2)
    {
      case 16:
        v3 = 1208;
        break;
      case 8:
        v1[76] = CFWriteStreamGetError((CFWriteStreamRef)v1[75].domain);
        goto LABEL_13;
      case 4:
        v3 = 1209;
        break;
      default:
LABEL_13:
        -[__NSCFURLLocalStreamTaskFromDataTask _onqueue_ioTickFromDataTaskConversion:]((uint64_t)v1, (uint64_t)"writeEvent");
        return;
    }
    *((_BYTE *)&v1->domain + v3) = 1;
    goto LABEL_13;
  }
}

void ___ZL35_onqueue_stFromDataTaskReadCallbackP14__CFReadStreammPv_block_invoke(uint64_t a1)
{
  CFStreamError *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(CFStreamError **)(a1 + 32);
  if (v1 && v1[73].domain)
  {
    v2 = *(_QWORD *)(a1 + 40);
    if (v1[48].error == 1)
      v1[48].error = 2;
    switch(v2)
    {
      case 16:
        v3 = 1176;
        break;
      case 8:
        v1[74] = CFReadStreamGetError((CFReadStreamRef)v1[73].domain);
        goto LABEL_13;
      case 2:
        v3 = 1177;
        break;
      default:
LABEL_13:
        -[__NSCFURLLocalStreamTaskFromDataTask _onqueue_ioTickFromDataTaskConversion:]((uint64_t)v1, (uint64_t)"readevent");
        return;
    }
    *((_BYTE *)&v1->domain + v3) = 1;
    goto LABEL_13;
  }
}

void __NSCFClosedWriteStream::~__NSCFClosedWriteStream(__NSCFClosedWriteStream *this)
{
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
}

{
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x186DB748CLL);
}

uint64_t __NSCFClosedWriteStream::_streamImpl_Open(CFStreamError *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a3 = this[1];
  *a4 = 1;
  return 1;
}

uint64_t __NSCFClosedWriteStream::_streamImpl_OpenCompleted(CFStreamError *this, __CFWriteStream *a2, CFStreamError *a3)
{
  *a3 = this[1];
  return 1;
}

uint64_t __NSCFClosedWriteStream::_streamImpl_Write(CFStreamError *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5)
{
  *a5 = this[1];
  return 0;
}

CFStringRef HTTPServerWithStreams::copyDebugDesc(HTTPServerWithStreams *this)
{
  CFStringRef v2;
  const __CFAllocator *v3;
  CFStringRef v4;

  v2 = CFObject::copyDebugDescHeader(this);
  v3 = CFGetAllocator((char *)this - 16);
  v4 = CFStringCreateWithFormat(v3, 0, CFSTR("%@ { rs = %@, ws = %@ }"), v2, *((_QWORD *)this + 35), *((_QWORD *)this + 36));
  if (v2)
    CFRelease(v2);
  return v4;
}

intptr_t HTTPServerWithStreams::ensureServerExists(int a1, dispatch_semaphore_t dsema)
{
  return dispatch_semaphore_signal(dsema);
}

uint64_t HTTPServerWithStreams::scheduled(HTTPServerWithStreams *this)
{
  return HTTPServer::newConnectionWithStreams((NSObject **)this, *((__CFReadStream **)this + 35), *((__CFWriteStream **)this + 36));
}

void `non-virtual thunk to'HTTPServerWithStreams::~HTTPServerWithStreams(HTTPServerWithStreams *this)
{
  HTTPServerWithStreams::~HTTPServerWithStreams((HTTPServerWithStreams *)((char *)this - 8));
}

{
  HTTPServerWithStreams::~HTTPServerWithStreams((HTTPServerWithStreams *)((char *)this - 8));
}

{
  HTTPServerWithStreams::~HTTPServerWithStreams((HTTPServerWithStreams *)((char *)this - 56));
}

{
  HTTPServerWithStreams::~HTTPServerWithStreams((HTTPServerWithStreams *)((char *)this - 56));
}

void HTTPServerWithStreams::~HTTPServerWithStreams(HTTPServerWithStreams *this)
{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = &off_1E14EBE20;
  *((_QWORD *)this + 1) = &unk_1E14EBED0;
  *((_QWORD *)this + 7) = &unk_1E14EBF38;
  v2 = (const void *)*((_QWORD *)this + 35);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 36);
  if (v3)
    CFRelease(v3);
  HTTPServer::~HTTPServer(this);
}

void sub_1840E3AE4(_Unwind_Exception *a1)
{
  HTTPServer *v1;

  HTTPServer::~HTTPServer(v1);
  _Unwind_Resume(a1);
}

CFXURLCache *XURLCache::createCFXURLCache(XURLCache *this, NSURLSession *a2, NSURLSession *a3)
{
  CFTypeID v5;
  NSURLSession *v6;
  CFXURLCache *v7;

  v5 = CFGetTypeID(this);
  if (v5 != CFURLCacheGetTypeID())
    return XURLCache::createNSXURLCache(this, a2, v6);
  v7 = (CFXURLCache *)operator new();
  CFXURLCache::CFXURLCache(v7, this, a2);
  return v7;
}

void sub_1840E3B78(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0xE1C406F2C477FLL);
  _Unwind_Resume(a1);
}

void NSXURLCache::addCachedResponseForRequest(id *this, const _CFCachedURLResponse *a2, const _CFURLRequest *a3)
{
  id v5;
  id v6;

  v5 = -[NSCachedURLResponse _initWithCFCachedURLResponse:]([NSCachedURLResponse alloc], "_initWithCFCachedURLResponse:", a2);
  v6 = -[NSURLRequest _initWithCFURLRequest:]([NSURLRequest alloc], "_initWithCFURLRequest:", a3);
  objc_msgSend(this[1], "storeCachedResponse:forRequest:", v5, v6);

}

uint64_t NSXURLCache::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  if (a2)
    objc_msgSend(*(id *)(a1 + 8), "removeAllCachedResponses");
  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

void CFXURLCache::addCachedResponseForRequest(CFXURLCache *this, _CFCachedURLResponse *a2, _CFURLRequest *a3, uint64_t a4, const void *a5)
{
  _CFURLCacheAddCachedResponseForRequestWithSession(*((_CFURLCache **)this + 1), *((HTTPProtocol **)this + 2), a2, a3, a5);
}

void CFXURLCache::flushOrReset(uint64_t a1, int a2, void (**a3)(_QWORD))
{
  if (a2)
    CFURLCacheRemoveAllCachedResponses(*(_QWORD **)(a1 + 8));
  _CFURLCacheFlush(*(_QWORD *)(a1 + 8), a3);
}

void SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry(SHTTPConnectionCacheEntry *this)
{
  uint64_t v2;

  SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;
  CFArrayRef *v3;
  CFTypeRef *v4;
  CFTypeRef *v5;
  uint64_t v6;
  CFArrayRef *v7;
  int v8;
  uint64_t i;
  uint64_t v10;
  CFTypeRef *v11;
  const void *v12;

  *(_QWORD *)this = off_1E14ED4E8;
  *((_QWORD *)this + 3) = &unk_1E14ED550;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v3 = (CFArrayRef *)*((_QWORD *)this + 6);
  if (v3)
  {
    SUnauthConnectionArray::~SUnauthConnectionArray(v3);
    MEMORY[0x186DB748C]();
  }
  v4 = (CFTypeRef *)*((_QWORD *)this + 7);
  if (v4)
  {
    CFRelease(*v4);
    MEMORY[0x186DB748C](v4, 0x20C4093837F09);
  }
  v5 = (CFTypeRef *)*((_QWORD *)this + 8);
  if (v5)
  {
    CFRelease(*v5);
    MEMORY[0x186DB748C](v5, 0x20C4093837F09);
  }
  v6 = *((_QWORD *)this + 9);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v7 = (CFArrayRef *)*((_QWORD *)this + 10);
  if (v7)
  {
    SAuthConnectionArray::~SAuthConnectionArray(v7);
    MEMORY[0x186DB748C]();
  }
  v8 = *((_DWORD *)this + 52);
  if (v8 >= 1)
  {
    for (i = 0; i < v8; *(_QWORD *)(v10 + 8 * i++) = 0)
    {
      v10 = *((_QWORD *)this + 11);
      v11 = *(CFTypeRef **)(v10 + 8 * i);
      if (v11)
      {
        CFRelease(*v11);
        MEMORY[0x186DB748C](v11, 0x20C4093837F09);
        v10 = *((_QWORD *)this + 11);
        v8 = *((_DWORD *)this + 52);
      }
    }
  }
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), *((void **)this + 11));
  v12 = (const void *)*((_QWORD *)this + 27);
  if (v12)
    CFRelease(v12);
  CFRelease(*((CFTypeRef *)this + 29));
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

__CFString *SHTTPConnectionCacheEntry::copyDebugDesc(SHTTPConnectionCacheEntry *this)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  const __CFString *v4;
  CFArrayRef *v5;
  CFIndex Count;
  const __CFString *v7;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFString *v10;
  CFArrayRef *v11;
  CFIndex v12;
  const __CFString *v13;
  CFIndex j;
  const void *v15;
  const __CFString *v16;
  uint64_t v17;
  CFArrayRef *v18;
  CFIndex v19;
  const __CFString *v20;
  CFIndex k;
  const void *v22;
  const __CFString *v23;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v4 = CFStringCreateWithFormat(v2, 0, CFSTR("<HTTPConnectionCacheEntry@%p>{\n"), this);
  CFStringAppend(Mutable, v4);
  if (v4)
    CFRelease(v4);
  v5 = (CFArrayRef *)*((_QWORD *)this + 6);
  if (v5)
  {
    Count = CFArrayGetCount(*v5);
    v7 = CFStringCreateWithFormat(v2, 0, CFSTR("\tfUnAuthConns(%ld) = {\n"), Count);
    CFStringAppend(Mutable, v7);
    if (v7)
      CFRelease(v7);
    for (i = 0; CFArrayGetCount(**((CFArrayRef **)this + 6)) > i; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(**((CFArrayRef **)this + 6), i);
      v10 = CFStringCreateWithFormat(v2, 0, CFSTR("\t\t%d: %@ ,\n"), i, ValueAtIndex);
      CFStringAppend(Mutable, v10);
      if (v10)
        CFRelease(v10);
    }
    CFStringAppend(Mutable, CFSTR("\t},\n"));
  }
  v11 = (CFArrayRef *)*((_QWORD *)this + 10);
  if (v11)
  {
    v12 = CFArrayGetCount(*v11);
    v13 = CFStringCreateWithFormat(v2, 0, CFSTR("\tfAuthConns(%ld) = {\n"), v12);
    CFStringAppend(Mutable, v13);
    if (v13)
      CFRelease(v13);
    for (j = 0; CFArrayGetCount(**((CFArrayRef **)this + 10)) > j; ++j)
    {
      v15 = CFArrayGetValueAtIndex(**((CFArrayRef **)this + 10), j);
      v16 = CFStringCreateWithFormat(v2, 0, CFSTR("\t\t%d: %@ ,\n"), j, v15);
      CFStringAppend(Mutable, v16);
      if (v16)
        CFRelease(v16);
    }
    CFStringAppend(Mutable, CFSTR("\t},\n"));
  }
  v17 = *((unsigned int *)this + 52);
  if ((int)v17 >= 1)
  {
    do
    {
      v18 = *(CFArrayRef **)(*((_QWORD *)this + 11) + 8 * (v17 - 1));
      if (v18)
      {
        v19 = CFArrayGetCount(*v18);
        v20 = CFStringCreateWithFormat(v2, 0, CFSTR("\tfQueues[%d] (%ld) = {\n"), v17 - 1, v19);
        CFStringAppend(Mutable, v20);
        if (v20)
          CFRelease(v20);
        for (k = 0; CFArrayGetCount(*v18) > k; ++k)
        {
          v22 = CFArrayGetValueAtIndex(*v18, k);
          v23 = CFStringCreateWithFormat(v2, 0, CFSTR("\t\t%d: %p ,\n"), k, v22);
          CFStringAppend(Mutable, v23);
          if (v23)
            CFRelease(v23);
        }
        CFStringAppend(Mutable, CFSTR("\t},\n"));
      }
    }
    while (v17-- > 1);
  }
  CFStringAppend(Mutable, CFSTR("}\n"));
  return Mutable;
}

uint64_t SHTTPConnectionCacheEntry::newTubeReady(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v6[6];

  (*(void (**)(_QWORD *))(*a1 + 40))(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  v4 = a1[4];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN25SHTTPConnectionCacheEntry12newTubeReadyEP5STube13CFStreamError_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = a1;
  v6[5] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v6);
}

uint64_t SHTTPConnectionCacheEntry::getValidAwaitingTubeForKey(SHTTPConnectionCacheEntry *this, const HTTPConnectionCacheKey *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  v2 = *((_QWORD *)this + 4);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN25SHTTPConnectionCacheEntry26getValidAwaitingTubeForKeyEPK22HTTPConnectionCacheKey_block_invoke;
  v5[3] = &unk_1E14FDA68;
  v5[4] = &v6;
  v5[5] = this;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 104))(v2, v5);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1840E4148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFMutableArrayRef SHTTPConnectionCacheEntry::pendingTubes@<X0>(CFTypeRef *this@<X0>, CFMutableArrayRef *a2@<X8>)
{
  const __CFAllocator *v4;
  CFMutableArrayRef result;

  v4 = CFGetAllocator(this[29]);
  result = CFArrayCreateMutableCopy(v4, 0, (CFArrayRef)this[29]);
  *a2 = result;
  return result;
}

uint64_t SBaseTubeManager::getPendingTubeForProtocolWithKey(uint64_t a1, uint64_t a2)
{
  const __CFArray *v3;
  uint64_t v4;
  _QWORD context[6];
  CFArrayRef theArray;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  CFRange v12;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = 0;
  (*(void (**)(CFArrayRef *__return_ptr))(*(_QWORD *)a1 + 72))(&theArray);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 3221225472;
  context[2] = ___ZN16SBaseTubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke;
  context[3] = &unk_1E14FD7F0;
  context[4] = &v8;
  context[5] = a2;
  v3 = theArray;
  v12.length = CFArrayGetCount(theArray);
  v12.location = 0;
  CFArrayApplyFunction(v3, v12, (CFArrayApplierFunction)RetainableTypedArray<STube *>::_invoke, context);
  CFRelease(theArray);
  v4 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v4;
}

void sub_1840E425C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf)
{
  uint64_t v16;

  _Block_object_dispose((const void *)(v16 - 48), 8);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry(SHTTPConnectionCacheEntry *this)
{
  SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry((SHTTPConnectionCacheEntry *)((char *)this - 24));
}

void `non-virtual thunk to'SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry((SHTTPConnectionCacheEntry *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_1840E4430(_Unwind_Exception *a1)
{
  uint64_t v1;

  CFRelease(*(CFTypeRef *)(v1 + 232));
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void SUnauthConnectionArray::~SUnauthConnectionArray(CFArrayRef *this)
{
  const __CFArray *v2;
  CFRange v3;

  v2 = *this;
  v3.length = CFArrayGetCount(*this);
  v3.location = 0;
  CFArrayApplyFunction(v2, v3, (CFArrayApplierFunction)RetainableTypedArray<HTTPNetConnection *>::_invoke, &__block_literal_global_38_15649);
  CFRelease(*this);
}

void sub_1840E44A4(_Unwind_Exception *a1)
{
  CFTypeRef *v1;

  CFRelease(*v1);
  _Unwind_Resume(a1);
}

void SAuthConnectionArray::~SAuthConnectionArray(CFArrayRef *this)
{
  const __CFArray *v2;
  CFRange v3;

  v2 = *this;
  v3.length = CFArrayGetCount(*this);
  v3.location = 0;
  CFArrayApplyFunction(v2, v3, (CFArrayApplierFunction)RetainableTypedArray<SNetConnectionAuthEntryThing *>::_invoke, &__block_literal_global_41_15647);
  CFRelease(*this);
}

void sub_1840E450C(_Unwind_Exception *a1)
{
  CFTypeRef *v1;

  CFRelease(*v1);
  _Unwind_Resume(a1);
}

uint64_t RetainableTypedArray<SNetConnectionAuthEntryThing *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t ___ZN20SAuthConnectionArrayD2Ev_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;

  v2 = *(_QWORD *)(a2 + 24);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 96);
    if (v3)
      pthread_mutex_lock((pthread_mutex_t *)(v3 + 8));
    *(_WORD *)(v2 + 88) &= ~1u;
    result = NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v2);
    v5 = *(_QWORD *)(v2 + 96);
    if (v5)
      return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  return result;
}

uint64_t RetainableTypedArray<HTTPNetConnection *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t ___ZN22SUnauthConnectionArrayD2Ev_block_invoke(int a1, NetConnection *this)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;

  v3 = *((_QWORD *)this + 12);
  if (v3)
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 8));
  *((_WORD *)this + 44) &= ~1u;
  result = NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
  v5 = *((_QWORD *)this + 12);
  if (v5)
    return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  return result;
}

uint64_t ___ZN16SBaseTubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  result = *(_QWORD *)(a2 + 120);
  if (result)
  {
    v5 = *(_QWORD *)(a1 + 40);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 64))(result);
    if (result == v5)
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  }
  return result;
}

uint64_t RetainableTypedArray<STube *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t ___ZN25SHTTPConnectionCacheEntry26getValidAwaitingTubeForKeyEPK22HTTPConnectionCacheKey_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  CFArrayRef *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  v1 = result;
  v2 = *(_QWORD *)(result + 40);
  v3 = *(unsigned int *)(v2 + 208);
  if ((int)v3 < 1)
  {
    v8 = 0;
  }
  else
  {
    do
    {
      v4 = *(CFArrayRef **)(*(_QWORD *)(v2 + 88) + 8 * (v3 - 1));
      if (v4 && (result = CFArrayGetCount(*v4), result >= 1))
      {
        v5 = result;
        v6 = 1;
        do
        {
          result = (uint64_t)CFArrayGetValueAtIndex(*v4, v6 - 1);
          if (result
            && (v7 = (_QWORD *)result,
                result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 112))(result),
                (result & 1) == 0))
          {
            v8 = (_QWORD *)v7[3];
            if (v8)
            {
              result = (*(uint64_t (**)(_QWORD *))(*v7 + 96))(v7);
              if ((_DWORD)result)
                v8 = v7;
              else
                v8 = 0;
            }
          }
          else
          {
            v8 = 0;
          }
          if (v8)
            break;
          v9 = v6++ < v5;
        }
        while (v9);
      }
      else
      {
        v8 = 0;
      }
      if (v8)
        break;
      v9 = v3-- <= 1;
    }
    while (!v9);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24) = v8;
  return result;
}

uint64_t ___ZN25SHTTPConnectionCacheEntry12newTubeReadyEP5STube13CFStreamError_block_invoke(uint64_t a1)
{
  SHTTPConnectionCacheEntry *v2;

  v2 = *(SHTTPConnectionCacheEntry **)(a1 + 32);
  SHTTPConnectionCacheEntry::ingestTube(v2, *(HTTPConnectionCacheKey ***)(a1 + 40));
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 48))(*(_QWORD *)(a1 + 40));
  return (*(uint64_t (**)(SHTTPConnectionCacheEntry *))(*(_QWORD *)v2 + 48))(v2);
}

uint64_t SHTTPConnectionCacheEntry::ingestTube(SHTTPConnectionCacheEntry *this, HTTPConnectionCacheKey **a2)
{
  const __CFArray *v4;
  CFIndex FirstIndexOfValue;
  CFIndex v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t Waiter;
  uint64_t v10;
  uint64_t v11;
  __CFError *v12;
  HTTPConnectionCacheKey *v13;
  _OWORD *v14;
  uint64_t v15;
  void (*v16)(_QWORD);
  void (*v17)(_QWORD);
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  BOOL v24;
  int v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const _CFURLCredential *v30;
  __CFHTTPMessage *v31;
  const _CFURLCredential *v32;
  SHTTPConnectionCacheEntry *v33;
  uint64_t v34;
  uint64_t v35;
  CFTypeRef v37;
  int v38;
  CFTypeRef v39;
  CFTypeRef cf;
  int v41;
  __int128 v42;
  int v43;
  _BYTE v44[20];
  int v45;
  uint64_t v46;
  uint64_t v47;
  CFRange v48;

  v4 = (const __CFArray *)*((_QWORD *)this + 29);
  v48.length = CFArrayGetCount(v4);
  v48.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v48, a2);
  if (FirstIndexOfValue == -1)
  {
    if (!*((_QWORD *)this + 30))
    {
      v38 = *((_DWORD *)a2 + 34);
      if (!*((_BYTE *)this + 248))
      {
        if (v38 != 1)
          __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 816, "newTube->getType() == kSTubeTypeHTTP");
        __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 817, "_neverDecrementedPlusOneForFirstTube");
      }
      if (v38 != 1)
        __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 822, "newTube->getType() == kSTubeTypeHTTP");
      __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 829, "_plusOneForFirstTube");
    }
    if (*((_DWORD *)a2 + 34) != 1)
      __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 826, "newTube->getType() == kSTubeTypeHTTP");
    *((_QWORD *)this + 30) = 0;
    *((_BYTE *)this + 248) = 0;
  }
  else
  {
    v6 = FirstIndexOfValue;
    if (CFArrayGetValueAtIndex(*((CFArrayRef *)this + 29), FirstIndexOfValue) != a2)
      __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 834, "checkTube == newTube");
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 29), v6);
  }
  if ((STube::isCanceled((STube *)a2) & 1) != 0
    || (v7 = STube::getWaiter((STube *)a2),
        v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 64))(v7),
        (*(unsigned int (**)(uint64_t))(*(_QWORD *)v8 + 176))(v8)))
  {
    Waiter = STube::getWaiter((STube *)a2);
    v10 = STube::getWaiter((STube *)a2);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 64))(v10);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)Waiter + 56))(Waiter, 0);
    if (STube::isCanceled((STube *)a2))
    {
      if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 176))(v11))
      {
        v12 = CFErrorCreate(*((CFAllocatorRef *)this + 1), CFSTR("kCFErrorDomainCFNetwork"), -999, 0);
        URLProtocol::sendDidFail((URLProtocol *)(v11 - 176), v12);
        CFRelease(v12);
      }
    }
    return SHTTPConnectionCacheEntry::connectionWasLost(this, 0);
  }
  v13 = a2[12];
  v14 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 320, 0);
  *v14 = 0u;
  v14[1] = 0u;
  v14[2] = 0u;
  v14[3] = 0u;
  v14[4] = 0u;
  v14[5] = 0u;
  v14[6] = 0u;
  v14[7] = 0u;
  v14[8] = 0u;
  v14[9] = 0u;
  v14[10] = 0u;
  v14[11] = 0u;
  v14[12] = 0u;
  v14[13] = 0u;
  v14[14] = 0u;
  v14[15] = 0u;
  v14[16] = 0u;
  v14[17] = 0u;
  v14[18] = 0u;
  v14[19] = 0u;
  HTTPNetConnection_NoAuth::HTTPNetConnection_NoAuth((HTTPNetConnection_NoAuth *)v14, *((const __CFAllocator **)this + 1), v13);
  *(_QWORD *)(v15 + 304) = a2;
  (*((void (**)(HTTPConnectionCacheKey **))*a2 + 5))(a2);
  if (!NetConnection::initialize((NetConnection *)v14, 1))
  {
    (*(void (**)(_OWORD *))(*(_QWORD *)v14 + 48))(v14);
    v35 = STube::getWaiter((STube *)a2);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v35 + 56))(v35, 0);
    return SHTTPConnectionCacheEntry::connectionWasLost(this, 0);
  }
  v16 = (void (*)(_QWORD))*((_QWORD *)this + 23);
  if (v16)
    v16(*((_QWORD *)this + 25));
  v17 = (void (*)(_QWORD))*((_QWORD *)v14 + 26);
  if (v17)
    v17(*((_QWORD *)v14 + 27));
  v18 = *(_OWORD *)((char *)this + 152);
  v19 = *(_OWORD *)((char *)this + 168);
  v20 = *(_OWORD *)((char *)this + 184);
  *((_QWORD *)v14 + 27) = *((_QWORD *)this + 25);
  *(_OWORD *)((char *)v14 + 184) = v19;
  *(_OWORD *)((char *)v14 + 200) = v20;
  *(_OWORD *)((char *)v14 + 168) = v18;
  CFArrayAppendValue(**((CFMutableArrayRef **)this + 6), v14);
  v21 = STube::getWaiter((STube *)a2);
  v47 = 0;
  v46 = 0;
  *(_QWORD *)v44 = 0x3F000000FFFFFFFFLL;
  *(_QWORD *)&v44[8] = 0;
  *(_DWORD *)&v44[16] = 0;
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, _BYTE *))(*(_QWORD *)v21 + 88))(v21, &v47, &v46, v44);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 56))(v21, 0);
  v22 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v47 + 32))(v47);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v22 + 88))(v22) == 2)
  {
    *((_BYTE *)this + 40) |= 0x40u;
    v23 = 0;
  }
  else
  {
    v23 = *(_DWORD *)v44 < *((_DWORD *)this + 52);
  }
  v24 = !v23 || *(int *)v44 < 0;
  v42 = *(_OWORD *)&v44[4];
  v43 = v45;
  if (v24)
    v25 = 0;
  else
    v25 = *(_DWORD *)v44;
  v26 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 80, 0);
  *(_OWORD *)v26 = 0u;
  *((_OWORD *)v26 + 1) = 0u;
  *((_OWORD *)v26 + 2) = 0u;
  *((_OWORD *)v26 + 3) = 0u;
  *((_OWORD *)v26 + 4) = 0u;
  v27 = *((_QWORD *)this + 1);
  v41 = v25;
  SHTTPConnectionCacheEnqueuedRequestInfo::SHTTPConnectionCacheEnqueuedRequestInfo((uint64_t)v26, v27, v47, v46, (__int128 *)&v41);
  if (v44[19])
  {
    v28 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v26 + 3) + 32))(*((_QWORD *)v26 + 3));
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v28 + 88))(v28) != 2)
    {
      v29 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v26 + 3) + 32))(*((_QWORD *)v26 + 3));
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v29 + 88))(v29) != 3)
        *((_BYTE *)this + 40) |= 8u;
    }
  }
  v39 = 0;
  cf = 0;
  SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, (SHTTPConnectionCacheEnqueuedRequestInfo *)v26, (_CFHTTPAuthentication **)&cf, &v39, 0, 0);
  v31 = (__CFHTTPMessage *)cf;
  if (cf)
  {
    v32 = (const _CFURLCredential *)v39;
    if (v39)
    {
      v33 = (SHTTPConnectionCacheEntry *)*((_QWORD *)v26 + 5);
      if (!v33)
      {
        v34 = *((_QWORD *)v26 + 4);
        if (v34)
        {
          *((_QWORD *)v26 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)v26 + 1), (CFHTTPMessageRef)(v34 - 16));
          CFRelease((CFTypeRef)(*((_QWORD *)v26 + 4) - 16));
          *((_QWORD *)v26 + 4) = 0;
          v33 = (SHTTPConnectionCacheEntry *)*((_QWORD *)v26 + 5);
          v32 = (const _CFURLCredential *)v39;
          v31 = (__CFHTTPMessage *)cf;
        }
        else
        {
          v33 = 0;
        }
      }
      SHTTPConnectionCacheEntry::applyCredentialsToRequest(v33, v31, v32, v30);
      v31 = (__CFHTTPMessage *)cf;
    }
  }
  cf = 0;
  if (v31)
    CFRelease(v31);
  v37 = v39;
  v39 = 0;
  if (v37)
    CFRelease(v37);
  if (!SHTTPConnectionCacheEntry::dispatchConnectionToProtocol(this, (HTTPNetConnection *)v14, (SHTTPConnectionCacheEnqueuedRequestInfo *)v26, 1))SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection((CFArrayRef **)this, (HTTPNetConnection *)v14, 1u);
  (*(void (**)(void *))(*(_QWORD *)v26 + 48))(v26);
  return (*(uint64_t (**)(_OWORD *))(*(_QWORD *)v14 + 48))(v14);
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::SHTTPConnectionCacheEnqueuedRequestInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  __int128 v7;

  *(_QWORD *)a1 = off_1E14EF578;
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = 1;
  if (((a1 + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)a1 = off_1E14EF6E0;
  v7 = *a5;
  *(_QWORD *)(a1 + 64) = *((_QWORD *)a5 + 2);
  *(_OWORD *)(a1 + 48) = v7;
  *(_QWORD *)(a1 + 24) = a3;
  (*(void (**)(uint64_t))(*(_QWORD *)a3 + 16))(a3);
  *(_QWORD *)(a1 + 32) = a4;
  CFRetain((CFTypeRef)(a4 - 16));
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  return a1;
}

void SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(SHTTPConnectionCacheEntry *this, SHTTPConnectionCacheEnqueuedRequestInfo *a2, _CFHTTPAuthentication **a3, CFTypeRef *a4, _CFHTTPAuthentication **a5, CFTypeRef *a6)
{
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  CFArrayRef *v15;
  uint64_t v16;
  const void *v17;
  CFArrayRef *v18;
  uint64_t v19;
  const void *v20;
  const __CFString *AuthSchemeStringFromChallenge;
  _BOOL4 v22;
  BOOL v23;
  int v24;
  _BOOL4 v26;
  CFHTTPAuthenticationRef v28;
  CFHTTPAuthenticationRef v29;

  v12 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 3) + 32))(*((_QWORD *)a2 + 3));
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v12 + 88))(v12) == 2)
  {
    v13 = 1;
  }
  else
  {
    v14 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 3) + 32))(*((_QWORD *)a2 + 3));
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 88))(v14) == 3;
  }
  v15 = (CFArrayRef *)*((_QWORD *)this + 7);
  v16 = *((_QWORD *)this + 9);
  v17 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 3) + 96))(*((_QWORD *)a2 + 3));
  SHTTPConnectionCacheEntry::findCachedAuthentication((uint64_t)a2, 1, v15, v16, v17, a3, a4);
  v18 = (CFArrayRef *)*((_QWORD *)this + 8);
  v19 = *((_QWORD *)this + 9);
  v20 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 3) + 120))(*((_QWORD *)a2 + 3));
  SHTTPConnectionCacheEntry::findCachedAuthentication((uint64_t)a2, v13, v18, v19, v20, a5, a6);
  AuthSchemeStringFromChallenge = (const __CFString *)SHTTPConnectionCacheEnqueuedRequestInfo::getAuthSchemeStringFromChallenge(*((SHTTPConnectionCacheEnqueuedRequestInfo **)a2 + 3), 0);
  if (AuthSchemeStringFromChallenge)
    v22 = CFStringCompare(AuthSchemeStringFromChallenge, CFSTR("Negotiate"), 0x80uLL) == kCFCompareEqualTo;
  else
    v22 = 0;
  if (a3)
    v23 = a4 == 0;
  else
    v23 = 1;
  v24 = !v23;
  if (!v23 && !*a3 && ((*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 3) + 96))(*((_QWORD *)a2 + 3)) || v22))
    SHTTPConnectionCacheEntry::createAuthAndMakeAvailable((__CFArray ***)this, (SHTTPConnectionCacheEnqueuedRequestInfo **)a2, 0, a3, (const _CFURLCredential **)a4);
  if (a5)
    v26 = v13;
  else
    v26 = 0;
  if (a6
    && v26
    && !*a5
    && ((*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 3) + 120))(*((_QWORD *)a2 + 3)) || v22))
  {
    SHTTPConnectionCacheEntry::createAuthAndMakeAvailable((__CFArray ***)this, (SHTTPConnectionCacheEnqueuedRequestInfo **)a2, 1, a5, (const _CFURLCredential **)a6);
  }
  if (v24)
  {
    v28 = *a3;
    if (*a3)
    {
      if (!*a4 && !v22)
      {
        *a3 = 0;
        CFRelease(v28);
      }
    }
    else if (!v22 && !*a4)
    {
      *a3 = 0;
    }
  }
  if (a5 && a6)
  {
    v29 = *a5;
    if (*a5)
    {
      if (!*a6 && !v22)
      {
        *a5 = 0;
        CFRelease(v29);
      }
    }
    else if (!v22 && !*a6)
    {
      *a5 = 0;
    }
  }
}

void SHTTPConnectionCacheEntry::applyCredentialsToRequest(SHTTPConnectionCacheEntry *this, __CFHTTPMessage *a2, const _CFURLCredential *a3, const _CFURLCredential *a4)
{
  const __CFAllocator *v7;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v9;
  uint64_t Username;
  const _CFURLCredential *v11;
  const __CFString *v12;
  const __CFAllocator *v13;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v15;
  const void *ValueAtIndex;
  const void *v17;
  __CFDictionary *v18;
  uint64_t v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  CFNumberRef v26;
  CFNumberRef v27;
  int valuePtr;

  v7 = CFGetAllocator(this);
  Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v9 = Mutable;
    Username = CFURLCredentialGetUsername((uint64_t)a3);
    if (Username)
    {
      v12 = (const __CFString *)Username;
      if (CFHTTPAuthenticationRequiresAccountDomain(a2)
        && (v13 = CFGetAllocator(v12),
            (ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v13, v12, CFSTR("\\"))) != 0))
      {
        v15 = ArrayBySeparatingStrings;
        if (CFArrayGetCount(ArrayBySeparatingStrings) == 2)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v15, 0);
          CFDictionaryAddValue(v9, CFSTR("kCFHTTPAuthenticationAccountDomain"), ValueAtIndex);
          v17 = CFArrayGetValueAtIndex(v15, 1);
          v18 = v9;
        }
        else
        {
          v18 = v9;
          v17 = v12;
        }
        CFDictionaryAddValue(v18, CFSTR("kCFHTTPAuthenticationUsername"), v17);
        CFRelease(v15);
      }
      else
      {
        CFDictionaryAddValue(v9, CFSTR("kCFHTTPAuthenticationUsername"), v12);
      }
    }
    v19 = URLCredential_PasswordBased::safelyCast((uint64_t)a3, v11);
    if (v19)
    {
      v20 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 128))(v19);
      if (v20)
      {
        v21 = v20;
        CFDictionaryAddValue(v9, CFSTR("kCFHTTPAuthenticationPassword"), v20);
        CFRelease(v21);
      }
    }
    v22 = (const void *)_CFURLCredentialCopyOAuthToken(a3);
    if (v22)
    {
      v23 = v22;
      CFDictionaryAddValue(v9, CFSTR("kCFHTTPAuthenticationOAuthToken"), v22);
      CFRelease(v23);
    }
    v24 = (const void *)_CFURLCredentialCopyOAuth1Account(a3);
    if (v24)
    {
      v25 = v24;
      CFDictionaryAddValue(v9, CFSTR("kCFHTTPAuthenticationOAuth1Account"), v24);
      CFRelease(v25);
      valuePtr = _CFURLCredentialGetOAuth1PID(a3);
      v26 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
      if (v26)
      {
        v27 = v26;
        CFDictionaryAddValue(v9, CFSTR("kCFHTTPAuthenticationOAuth1PID"), v26);
        CFRelease(v27);
      }
    }
    CFHTTPMessageApplyCredentialDictionary(this, a2, v9, 0);
    CFRelease(v9);
  }
}

uint64_t SHTTPConnectionCacheEntry::dispatchConnectionToProtocol(SHTTPConnectionCacheEntry *this, HTTPNetConnection *a2, SHTTPConnectionCacheEnqueuedRequestInfo *a3, uint64_t a4)
{
  os_unfair_lock_s *v7;
  _BOOL4 v8;
  const void *v9;
  uint64_t v10;
  uint64_t InfoPointer;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!*((_BYTE *)a3 + 65))
    *((_BYTE *)this + 40) &= ~0x10u;
  *((_WORD *)a2 + 44) = *((_WORD *)a2 + 44) & 0xFFFB | (4 * (*((_BYTE *)a3 + 66) != 0));
  if ((*((_BYTE *)this + 40) & 8) != 0
    && ((*((_BYTE *)this + 40) & 0x10) == 0 || (*((_BYTE *)this + 40) & 0x60) == 0x20)
    && *((_BYTE *)a3 + 67))
  {
    v7 = (os_unfair_lock_s *)*((_QWORD *)a3 + 4);
    if (v7)
      v8 = HTTPMessage::hasHeaderField(v7, 0x1470F3EAu) == 0;
    else
      v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  NetConnection::setShouldPipeline(a2, v8);
  v9 = (const void *)CFReadStreamCreate();
  v10 = *((_QWORD *)a3 + 3);
  InfoPointer = CFReadStreamGetInfoPointer();
  if (InfoPointer)
    v12 = InfoPointer + 16;
  else
    v12 = 0;
  v13 = *((_QWORD *)a3 + 5);
  if (v13)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_BYTE *)(v13 + 40))
      v14 = 0;
    else
      v14 = v13 + 16;
  }
  else
  {
    v14 = *((_QWORD *)a3 + 4);
  }
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 80))(v10, v12, v14, a4);
  if ((_DWORD)v15)
    *((_DWORD *)a2 + 58) = *((_DWORD *)a3 + 12);
  CFRelease(v9);
  return v15;
}

uint64_t SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection(CFArrayRef **this, HTTPNetConnection *a2, unsigned int a3)
{
  uint64_t result;
  CFIndex i;
  SNetConnectionAuthEntryThing *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  CFArrayRef *v13;
  CFIndex v14;
  SHTTPConnectionCacheEnqueuedRequestInfo *ValueAtIndex;
  SHTTPConnectionCacheEnqueuedRequestInfo *v17;
  char *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  CFArrayRef *v25;
  CFTypeRef v27;
  CFTypeRef cf;

  result = (*(uint64_t (**)(HTTPNetConnection *))(*(_QWORD *)a2 + 208))(a2);
  if ((_DWORD)result)
  {
    for (i = 0; ; ++i)
    {
      result = CFArrayGetCount(*this[10]);
      if (i >= result)
        break;
      if (*((HTTPNetConnection **)CFArrayGetValueAtIndex(*this[10], i) + 3) == a2)
      {
        result = (uint64_t)CFArrayGetValueAtIndex(*this[10], i);
        v7 = (SNetConnectionAuthEntryThing *)result;
        goto LABEL_8;
      }
    }
  }
  v7 = 0;
LABEL_8:
  v8 = *((unsigned int *)this + 52);
  if ((int)v8 >= 1)
  {
    while (1)
    {
      if (*((_DWORD *)a2 + 58) < (int)v8 - 1)
      {
        v9 = *((_QWORD *)a2 + 12);
        if (v9)
        {
          result = pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
          v10 = *((_QWORD *)a2 + 12);
          v11 = *((_QWORD *)a2 + 17);
          if (v10)
            result = pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
          if (v11)
          {
LABEL_14:
            v12 = 0;
            goto LABEL_55;
          }
        }
        else if (*((_QWORD *)a2 + 17))
        {
          goto LABEL_14;
        }
      }
      v13 = (CFArrayRef *)this[11][(v8 - 1)];
      if (v13)
      {
        v14 = 0;
LABEL_18:
        v12 = 0;
        while (1)
        {
LABEL_19:
          result = CFArrayGetCount(*v13);
          if (v14 >= result || v12 != 0)
            goto LABEL_46;
          ValueAtIndex = (SHTTPConnectionCacheEnqueuedRequestInfo *)CFArrayGetValueAtIndex(*v13, v14);
          if (!ValueAtIndex)
          {
            CFArrayRemoveValueAtIndex(*v13, v14);
            goto LABEL_18;
          }
          v17 = ValueAtIndex;
          if (v7)
          {
            if (!SHTTPConnectionCacheEntry::doesConnAuthApply((SHTTPConnectionCacheEntry *)this, v7, ValueAtIndex))break;
          }
          v27 = 0;
          cf = 0;
          SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol((SHTTPConnectionCacheEntry *)this, v17, (_CFHTTPAuthentication **)&cf, &v27, 0, 0);
          v18 = (char *)cf;
          if (cf)
          {
            if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
              dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
            v19 = HTTPAuthentication::isConnectionBasedAuth((HTTPAuthentication *)(v18 + 16));
            if (cf)
              CFRelease(cf);
            if (v27)
              CFRelease(v27);
            if (v19 && ((*(uint64_t (**)(HTTPNetConnection *))(*(_QWORD *)a2 + 208))(a2) & 1) == 0)
              break;
          }
          else if (v27)
          {
            CFRelease(v27);
          }
          (*(void (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)v17 + 40))(v17);
          CFArrayRemoveValueAtIndex(*v13, v14);
          v20 = *((_QWORD *)v17 + 3);
          if (v20 && !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v20 + 176))(v20))
            v12 = SHTTPConnectionCacheEntry::dispatchConnectionToProtocol((SHTTPConnectionCacheEntry *)this, a2, v17, a3);
          else
            v12 = 0;
          (*(void (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)v17 + 48))(v17);
        }
        v12 = 0;
        ++v14;
        goto LABEL_19;
      }
      v12 = 0;
LABEL_46:
      if (((_BYTE)this[5] & 4) != 0)
      {
        v21 = *((unsigned int *)this + 52);
        if ((int)v21 < 1)
          goto LABEL_54;
        v22 = v21 + 1;
        v23 = v21 - 1;
        v24 = 1;
        do
        {
          v25 = (CFArrayRef *)this[11][v23];
          if (v25)
          {
            result = CFArrayGetCount(*v25);
            if (result > 0)
              v24 = 0;
          }
          --v22;
          --v23;
        }
        while (v22 > 1);
        if (v24)
LABEL_54:
          result = SHTTPConnectionCacheEntry::removeAllConnections((SHTTPConnectionCacheEntry *)this);
      }
LABEL_55:
      if (v8 >= 2)
      {
        --v8;
        if (!v12)
          continue;
      }
      return result;
    }
  }
  return result;
}

uint64_t SHTTPConnectionCacheEntry::connectionWasLost(SHTTPConnectionCacheEntry *this, HTTPNetConnection *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  CFArrayRef *v10;
  SHTTPConnectionCacheEnqueuedRequestInfo *ValueAtIndex;
  SHTTPConnectionCacheEnqueuedRequestInfo *v13;
  int v14;
  HTTPNetConnection *v15;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  char v20;
  CFArrayRef *v21;
  HTTPNetConnection *v23;
  unsigned __int8 v24;

  (*(void (**)(SHTTPConnectionCacheEntry *))(*(_QWORD *)this + 40))(this);
  if (a2)
  {
    SHTTPConnectionCacheEntry::removeUnauthConnection(this, a2);
    if ((*((_BYTE *)this + 40) & 8) != 0
      && ((*((_BYTE *)this + 40) & 0x10) == 0 || (*((_BYTE *)this + 40) & 0x60) == 0x20))
    {
      v4 = *((_QWORD *)a2 + 12);
      if (v4)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
        v5 = *((_QWORD *)a2 + 12);
        v6 = *((_QWORD *)a2 + 28);
        if (v5)
          pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
      }
      else
      {
        v6 = *((_QWORD *)a2 + 28);
      }
      if (v6 <= 1 && (*(int (**)(HTTPNetConnection *))(*(_QWORD *)a2 + 104))(a2) >= 1)
        *((_BYTE *)this + 40) |= 0x40u;
    }
  }
  v7 = *((unsigned int *)this + 52);
  if ((int)v7 >= 1)
  {
    v8 = 0;
    v9 = *((_DWORD *)this + 52);
    do
    {
      v10 = *(CFArrayRef **)(*((_QWORD *)this + 11) + 8 * --v9);
      if (v10)
      {
        while (CFArrayGetCount(*v10) >= 1 && v8 == 0)
        {
          ValueAtIndex = (SHTTPConnectionCacheEnqueuedRequestInfo *)CFArrayGetValueAtIndex(*v10, 0);
          v8 = 0;
          if (ValueAtIndex)
          {
            v13 = ValueAtIndex;
            (*(void (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)ValueAtIndex + 40))(ValueAtIndex);
            CFArrayRemoveValueAtIndex(*v10, 0);
            if ((*(unsigned int (**)(_QWORD *))(**((_QWORD **)v13 + 3) + 176))(*((_QWORD **)v13 + 3)))
            {
              v8 = 0;
            }
            else
            {
              v24 = 0;
              v23 = 0;
              v14 = SHTTPConnectionCacheEntry::findOrCreateEmptyNetConnection(this, &v23, v13, &v24);
              v15 = v23;
              if (v23)
              {
                if (v14 != 1)
                  __assert_rtn("connectionWasLost", "SHTTPConnectionCacheEntry.cpp", 2306, "status == kSHTTPConnectionCacheEntryFoundExistingNetConnection");
                v8 = SHTTPConnectionCacheEntry::dispatchConnectionToProtocol(this, v23, v13, v24);
                (*(void (**)(HTTPNetConnection *))(*(_QWORD *)v15 + 48))(v15);
              }
              else
              {
                if (v14)
                {
                  if (v14 != 2)
                    __assert_rtn("connectionWasLost", "SHTTPConnectionCacheEntry.cpp", 2314, "status == kSHTTPConnectionCacheEntryNewTubeCreated");
                }
                else
                {
                  CFArrayAppendValue(*v10, v13);
                }
                v8 = 1;
              }
            }
            (*(void (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)v13 + 48))(v13);
          }
        }
      }
    }
    while (v7-- > 1);
  }
  if ((*((_BYTE *)this + 40) & 4) != 0)
  {
    v17 = *((unsigned int *)this + 52);
    if ((int)v17 < 1)
      goto LABEL_41;
    v18 = v17 + 1;
    v19 = v17 - 1;
    v20 = 1;
    do
    {
      v21 = *(CFArrayRef **)(*((_QWORD *)this + 11) + 8 * v19);
      if (v21 && CFArrayGetCount(*v21) > 0)
        v20 = 0;
      --v18;
      --v19;
    }
    while (v18 > 1);
    if (v20)
LABEL_41:
      SHTTPConnectionCacheEntry::removeAllConnections(this);
  }
  return (*(uint64_t (**)(SHTTPConnectionCacheEntry *))(*(_QWORD *)this + 48))(this);
}

CFIndex SHTTPConnectionCacheEntry::removeUnauthConnection(CFIndex this, HTTPNetConnection *a2)
{
  CFArrayRef *v2;
  SHTTPConnectionCacheEntry *v4;
  const __CFArray *v5;
  CFIndex v6;
  void (*v7)(_QWORD);
  CFArrayRef *v8;
  _QWORD *ValueAtIndex;
  uint64_t v10;
  char *v11;
  void (*v12)(_QWORD);
  uint64_t v13;
  uint64_t v14;
  CFRange v15;

  v2 = *(CFArrayRef **)(this + 48);
  if (v2)
  {
    v4 = (SHTTPConnectionCacheEntry *)this;
    v5 = *v2;
    v15.length = CFArrayGetCount(*v2);
    v15.location = 0;
    this = CFArrayGetFirstIndexOfValue(v5, v15, a2);
    if (this != -1)
    {
      v6 = this;
      if (a2)
        (*(void (**)(HTTPNetConnection *))(*(_QWORD *)a2 + 40))(a2);
      v7 = (void (*)(_QWORD))*((_QWORD *)a2 + 26);
      if (v7)
        v7(*((_QWORD *)a2 + 27));
      *((_QWORD *)a2 + 27) = 0;
      *(_OWORD *)((char *)a2 + 184) = 0u;
      *(_OWORD *)((char *)a2 + 200) = 0u;
      *(_OWORD *)((char *)a2 + 168) = 0u;
      v8 = (CFArrayRef *)*((_QWORD *)v4 + 6);
      ValueAtIndex = CFArrayGetValueAtIndex(*v8, v6);
      v10 = (uint64_t)ValueAtIndex;
      v11 = (char *)(ValueAtIndex + 21);
      v12 = (void (*)(_QWORD))ValueAtIndex[26];
      if (v12)
        v12(ValueAtIndex[27]);
      *((_QWORD *)v11 + 6) = 0;
      *((_OWORD *)v11 + 1) = 0u;
      *((_OWORD *)v11 + 2) = 0u;
      *(_OWORD *)v11 = 0u;
      v13 = *(_QWORD *)(v10 + 96);
      if (v13)
        pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
      *(_WORD *)(v10 + 88) &= ~1u;
      NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v10);
      v14 = *(_QWORD *)(v10 + 96);
      if (v14)
        pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
      CFArrayRemoveValueAtIndex(*v8, v6);
      SHTTPConnectionCacheEntry::connectionWasLost(v4, a2);
      return (*(uint64_t (**)(HTTPNetConnection *))(*(_QWORD *)a2 + 48))(a2);
    }
  }
  return this;
}

uint64_t SHTTPConnectionCacheEntry::findOrCreateEmptyNetConnection(SHTTPConnectionCacheEntry *this, HTTPNetConnection **a2, SHTTPConnectionCacheEnqueuedRequestInfo *a3, unsigned __int8 *a4)
{
  uint64_t v7;
  uint64_t v8;
  __CFArray *Mutable;
  __CFArray *v10;
  CFIndex i;
  SNetConnectionAuthEntryThing *ValueAtIndex;
  void *v13;
  CFIndex v14;
  char *v15;
  uint64_t j;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _CFHTTPAuthentication *v22;
  unsigned int v23;
  _BOOL4 v24;
  CFTypeRef v25;
  SHTTPConnectionCacheEntry *v26;
  const _CFURLCredential *v27;
  const _CFURLCredential *v28;
  CFDictionaryRef v29;
  SHTTPConnectionCacheEntry *v30;
  const _CFURLCredential *v31;
  const _CFURLCredential *v32;
  CFDictionaryRef v33;
  const __CFAllocator *v34;
  HTTPConnectionCacheKey *v35;
  CFHTTPAuthenticationRef v36;
  CFHTTPAuthenticationRef v37;
  const __CFAllocator *v38;
  CFDictionaryRef Copy;
  CFTypeRef v40;
  const __CFAllocator *v41;
  CFDictionaryRef v42;
  void (*v43)(_QWORD);
  void (*v44)(_QWORD);
  __int128 v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  _DWORD *v49;
  uint64_t v50;
  CFHTTPAuthenticationRef v51;
  CFHTTPAuthenticationRef v52;
  _QWORD *v53;
  CFTypeRef v54;
  CFTypeRef v55;
  __CFArray **v56;
  __CFArray *v57;
  _QWORD *v58;
  uint64_t result;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unsigned int v64;
  CFHTTPAuthenticationRef v65;
  CFTypeRef v66;
  HTTPNetConnection *v67;
  int v68;
  HTTPNetConnection **v69;
  CFIndex Count;
  CFIndex v71;
  __CFArray *v72;
  uint64_t v73;
  CFIndex v74;
  uint64_t v75;
  int *v76;
  int *v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  CFHTTPAuthenticationRef v81;
  CFTypeRef v82;
  CFTypeRef v83;
  CFTypeRef v84;
  CFHTTPAuthenticationRef v85;
  CFTypeRef v86;
  CFTypeRef v87;
  CFTypeRef v88;
  const _CFURLCredential *v89;
  __CFHTTPMessage *v90;
  const _CFURLCredential *v91;
  SHTTPConnectionCacheEntry *v92;
  uint64_t v93;
  const _CFURLCredential *v94;
  __CFHTTPMessage *v95;
  const _CFURLCredential *v96;
  SHTTPConnectionCacheEntry *v97;
  uint64_t v98;
  CFArrayRef *v99;
  const __CFArray *v100;
  __CFHTTPMessage *v101;
  const _CFURLCredential *v102;
  int *v103;
  CFIndex v104;
  BOOL v105;
  CFIndex v106;
  uint64_t v107;
  const __CFString *v108;
  __CFHTTPMessage *v109;
  uint64_t v110;
  unsigned int v111;
  uint64_t v112;
  const __CFString *v113;
  __CFHTTPMessage *v114;
  uint64_t v115;
  _CFHTTPAuthentication *v116;
  const __CFString *v117;
  CFArrayRef *v118;
  CFIndex v119;
  SBaseAwaitingTube *v120;
  uint64_t v121;
  _OWORD *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  _CFHTTPAuthentication *v128;
  const __CFString *v129;
  CFHTTPAuthenticationRef v130;
  CFTypeRef v131;
  CFTypeRef v132;
  CFTypeRef v133;
  int *v134;
  const _CFURLCredential *v135;
  SHTTPConnectionCacheEntry *v136;
  uint64_t v137;
  uint64_t v138;
  const __CFString *v139;
  __CFHTTPMessage *v140;
  uint64_t v141;
  _CFHTTPAuthentication *v142;
  const __CFString *Username;
  CFIndex v144;
  int *v145;
  CFHTTPAuthenticationRef auth[5];
  CFTypeRef v148;
  CFTypeRef v149;
  CFTypeRef cf;
  CFHTTPAuthenticationRef v151;
  uint64_t context;
  uint64_t v153;
  void *v154;
  void *v155;
  SHTTPConnectionCacheEntry *v156;
  uint64_t v157;
  CFRange v158;
  CFRange v159;
  CFRange v160;

  auth[0] = 0;
  cf = 0;
  v151 = 0;
  v149 = 0;
  v7 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 32))(*((_QWORD *)a3 + 3));
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 88))(v7) == 2
    || (v8 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 32))(*((_QWORD *)a3 + 3)),
        (*(unsigned int (**)(uint64_t))(*(_QWORD *)v8 + 88))(v8) == 3))
  {
    *((_BYTE *)this + 40) &= ~8u;
  }
  *a4 = 0;
  if (*((_QWORD *)this + 10))
  {
    Mutable = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    v10 = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    for (i = 0; i < CFArrayGetCount(**((CFArrayRef **)this + 10)); ++i)
    {
      ValueAtIndex = (SNetConnectionAuthEntryThing *)CFArrayGetValueAtIndex(**((CFArrayRef **)this + 10), i);
      if (SHTTPConnectionCacheEntry::doesConnAuthApply(this, ValueAtIndex, a3))
      {
        v13 = (void *)*((_QWORD *)ValueAtIndex + 3);
        if (v13)
        {
          (*(void (**)(void *))(*(_QWORD *)v13 + 40))(v13);
          if (NetConnection::willEnqueueRequests((NetConnection *)v13)
            && _isSocketOpenOnNetConnection((HTTPNetConnection *)v13))
          {
            CFArrayAppendValue(Mutable, v13);
            (*(void (**)(void *))(*(_QWORD *)v13 + 48))(v13);
            *a4 = 0;
          }
          else
          {
            CFArrayAppendValue(v10, v13);
            (*(void (**)(void *))(*(_QWORD *)v13 + 48))(v13);
          }
        }
      }
    }
    context = MEMORY[0x1E0C809B0];
    v153 = 3221225472;
    v154 = ___ZN25SHTTPConnectionCacheEntry43findOrCreateEmptyAuthenticatedNetConnectionEP39SHTTPConnectionCacheEnqueuedRequestInfoPh_block_invoke;
    v155 = &__block_descriptor_40_e9_v16__0_v8l;
    v156 = this;
    v158.length = CFArrayGetCount(v10);
    v158.location = 0;
    CFArrayApplyFunction(v10, v158, (CFArrayApplierFunction)RetainableTypedArray<HTTPNetConnection *>::_invoke, &context);
    v14 = 0;
    v15 = 0;
    for (j = 0xFFFFFFFFLL; ; j = v21)
    {
      if (CFArrayGetCount(Mutable) <= v14)
      {
        if (v15
          && (int)j > 0
          && (CFArrayGetCount(Mutable) < **((int **)this + 28)
           || (int)NetConnection::pendingRequestCount((NetConnection *)v15) > 0
           || !SHTTPConnectionCacheEntry::canPipelineOnConnection(this, (HTTPNetConnection *)v15)))
        {
          (*(void (**)(char *))(*(_QWORD *)v15 + 48))(v15);
          v15 = 0;
        }
        CFRelease(v10);
        CFRelease(Mutable);
        if (!v15)
          break;
LABEL_110:
        *a2 = (HTTPNetConnection *)v15;
        return 1;
      }
      v17 = (char *)CFArrayGetValueAtIndex(Mutable, v14);
      v18 = v17;
      v19 = *((_QWORD *)v17 + 12);
      if (v19)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v19 + 8));
        v20 = *((_QWORD *)v18 + 12);
        v21 = *((unsigned int *)v18 + 26);
        if (v20)
          pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8));
        if ((j & 0x80000000) != 0)
          goto LABEL_24;
      }
      else
      {
        v21 = *((unsigned int *)v17 + 26);
        if ((j & 0x80000000) != 0)
          goto LABEL_24;
      }
      if ((int)v21 >= (int)j)
      {
        v18 = v15;
        v21 = j;
        goto LABEL_27;
      }
LABEL_24:
      if (v15)
        (*(void (**)(char *))(*(_QWORD *)v15 + 48))(v15);
      (*(void (**)(char *))(*(_QWORD *)v18 + 40))(v18);
LABEL_27:
      ++v14;
      v15 = v18;
    }
  }
  SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, auth, &cf, &v151, &v149);
  v22 = auth[0];
  if (!auth[0])
    goto LABEL_267;
  if (cf)
  {
LABEL_41:
    v23 = _CFHTTPAuthenticationIsConnectionBasedAuth(v22);
    goto LABEL_42;
  }
  if (!CFHTTPAuthenticationRequiresOrderedRequests(auth[0]))
  {
LABEL_267:
    if (!v151 || !v149 && !CFHTTPAuthenticationRequiresOrderedRequests(v151))
      goto LABEL_47;
  }
  v22 = auth[0];
  if (auth[0])
    goto LABEL_41;
  v23 = 0;
LABEL_42:
  if (!v151)
  {
    v24 = 0;
    if (v23)
      goto LABEL_48;
LABEL_46:
    if (v24)
      goto LABEL_48;
LABEL_47:
    v15 = 0;
    goto LABEL_101;
  }
  v24 = _CFHTTPAuthenticationIsConnectionBasedAuth(v151) != 0;
  if (!v23)
    goto LABEL_46;
LABEL_48:
  if (auth[0])
  {
    v25 = CFRetain(auth[0]);
    v26 = auth[0];
    if (auth[0])
    {
      v27 = (const _CFURLCredential *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 96))(*((_QWORD *)a3 + 3));
      v29 = SHTTPConnectionCacheEntry::credentialDictionaryFromURLCredential(v26, v27, v28);
      goto LABEL_54;
    }
  }
  else
  {
    v25 = 0;
  }
  v29 = 0;
  auth[0] = 0;
LABEL_54:
  v30 = v151;
  if (v151)
  {
    v31 = (const _CFURLCredential *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 120))(*((_QWORD *)a3 + 3));
    v33 = SHTTPConnectionCacheEntry::credentialDictionaryFromURLCredential(v30, v31, v32);
  }
  else
  {
    v33 = 0;
    v151 = 0;
  }
  *a4 = 1;
  v15 = (char *)CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 376, 0);
  *(_OWORD *)v15 = 0u;
  *((_OWORD *)v15 + 1) = 0u;
  *((_OWORD *)v15 + 2) = 0u;
  *((_OWORD *)v15 + 3) = 0u;
  *((_OWORD *)v15 + 4) = 0u;
  *((_OWORD *)v15 + 5) = 0u;
  *((_OWORD *)v15 + 6) = 0u;
  *((_OWORD *)v15 + 7) = 0u;
  *((_OWORD *)v15 + 8) = 0u;
  *((_OWORD *)v15 + 9) = 0u;
  *((_OWORD *)v15 + 10) = 0u;
  *((_OWORD *)v15 + 11) = 0u;
  *((_OWORD *)v15 + 12) = 0u;
  *((_OWORD *)v15 + 13) = 0u;
  *((_OWORD *)v15 + 14) = 0u;
  *((_OWORD *)v15 + 15) = 0u;
  *((_OWORD *)v15 + 16) = 0u;
  *((_OWORD *)v15 + 17) = 0u;
  *((_OWORD *)v15 + 18) = 0u;
  *((_OWORD *)v15 + 19) = 0u;
  *((_OWORD *)v15 + 20) = 0u;
  *((_OWORD *)v15 + 21) = 0u;
  *((_OWORD *)v15 + 22) = 0u;
  *((_QWORD *)v15 + 46) = 0;
  v34 = (const __CFAllocator *)*((_QWORD *)this + 1);
  v35 = (HTTPConnectionCacheKey *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 32))(*((_QWORD *)a3 + 3));
  HTTPNetConnection::HTTPNetConnection((HTTPNetConnection *)v15, v34, v35);
  *(_QWORD *)v15 = off_1E14ED9A0;
  *((_QWORD *)v15 + 3) = &unk_1E14EDAD8;
  v15[344] = 0;
  *((_QWORD *)v15 + 46) = 0;
  v36 = auth[0];
  v37 = v151;
  if (auth[0])
    v36 = (CFHTTPAuthenticationRef)CFRetain(auth[0]);
  *((_QWORD *)v15 + 39) = v36;
  if (v29)
  {
    v38 = CFGetAllocator(v29);
    Copy = CFDictionaryCreateCopy(v38, v29);
  }
  else
  {
    Copy = 0;
  }
  *((_QWORD *)v15 + 40) = Copy;
  if (v37)
    v40 = CFRetain(v37);
  else
    v40 = 0;
  *((_QWORD *)v15 + 41) = v40;
  if (v33)
  {
    v41 = CFGetAllocator(v33);
    v42 = CFDictionaryCreateCopy(v41, v33);
  }
  else
  {
    v42 = 0;
  }
  *((_QWORD *)v15 + 42) = v42;
  if (NetConnection::initialize((NetConnection *)v15, 1))
  {
    v43 = (void (*)(_QWORD))*((_QWORD *)this + 16);
    if (v43)
      v43(*((_QWORD *)this + 18));
    v44 = (void (*)(_QWORD))*((_QWORD *)v15 + 26);
    if (v44)
      v44(*((_QWORD *)v15 + 27));
    v45 = *((_OWORD *)this + 6);
    v46 = *((_OWORD *)this + 7);
    v47 = *((_OWORD *)this + 8);
    *((_QWORD *)v15 + 27) = *((_QWORD *)this + 18);
    *(_OWORD *)(v15 + 184) = v46;
    *(_OWORD *)(v15 + 200) = v47;
    *(_OWORD *)(v15 + 168) = v45;
    if (cf && v25)
    {
      (*(void (**)(char *))(*(_QWORD *)v15 + 88))(v15);
    }
    else if (!v25)
    {
      goto LABEL_78;
    }
    goto LABEL_77;
  }
  (*(void (**)(char *))(*(_QWORD *)v15 + 48))(v15);
  v15 = 0;
  if (v25)
LABEL_77:
    CFRelease(v25);
LABEL_78:
  if (v29)
    CFRelease(v29);
  if (v33)
    CFRelease(v33);
  v48 = (char *)CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 48, 0);
  *(_OWORD *)v48 = 0u;
  *((_OWORD *)v48 + 2) = 0u;
  *((_OWORD *)v48 + 1) = 0u;
  v49 = v48 + 16;
  v50 = *((_QWORD *)this + 1);
  if (v23)
    v51 = auth[0];
  else
    v51 = 0;
  if (v24)
    v52 = v151;
  else
    v52 = 0;
  *(_QWORD *)v48 = off_1E14EF578;
  *((_QWORD *)v48 + 1) = v50;
  *v49 = 1;
  if ((v49 & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  v53 = v48;
  *(_QWORD *)v48 = off_1E14EEA38;
  *((_QWORD *)v48 + 3) = v15;
  if (v15)
    (*(void (**)(char *))(*(_QWORD *)v15 + 40))(v15);
  if (v51)
    v54 = CFRetain(v51);
  else
    v54 = 0;
  v53[4] = v54;
  if (v52)
    v55 = CFRetain(v52);
  else
    v55 = 0;
  v53[5] = v55;
  v56 = (__CFArray **)*((_QWORD *)this + 10);
  if (v56)
  {
    v57 = *v56;
  }
  else
  {
    v58 = (_QWORD *)operator new();
    v57 = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    *v58 = v57;
    *((_QWORD *)this + 10) = v58;
  }
  CFArrayAppendValue(v57, v53);
  (*(void (**)(_QWORD *))(*v53 + 48))(v53);
LABEL_101:
  if (auth[0])
    CFRelease(auth[0]);
  if (cf)
    CFRelease(cf);
  if (v151)
    CFRelease(v151);
  if (v149)
    CFRelease(v149);
  if (v15)
    goto LABEL_110;
  cf = 0;
  v151 = 0;
  v148 = 0;
  v149 = 0;
  v60 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 32))(*((_QWORD *)a3 + 3));
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v60 + 88))(v60) == 2)
  {
    *a4 = 0;
  }
  else
  {
    v61 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 32))(*((_QWORD *)a3 + 3));
    v62 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v61 + 88))(v61);
    v63 = 0;
    *a4 = 0;
    if (v62 != 3)
      goto LABEL_115;
  }
  *((_BYTE *)this + 40) &= ~8u;
  v63 = 1;
LABEL_115:
  SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, &v151, &v149, (_CFHTTPAuthentication **)&cf, &v148);
  if (v151)
  {
    v64 = _CFHTTPAuthenticationIsConnectionBasedAuth(v151);
    v65 = v151;
    v151 = 0;
    if (v65)
      CFRelease(v65);
  }
  else
  {
    v64 = 0;
    v151 = 0;
  }
  v66 = v149;
  v149 = 0;
  if (v66)
    CFRelease(v66);
  if (!*((_QWORD *)this + 6))
    goto LABEL_160;
  if ((*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 96))(*((_QWORD *)a3 + 3)) && v64 && !v151)
  {
    v67 = 0;
    v151 = 0;
    v68 = 1;
    v69 = a2;
    goto LABEL_163;
  }
  if (v63 && (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 120))(*((_QWORD *)a3 + 3)) && !cf
    || (Count = CFArrayGetCount(**((CFArrayRef **)this + 6)), Count < 1))
  {
LABEL_160:
    v67 = 0;
    v68 = 1;
    v69 = a2;
    goto LABEL_161;
  }
  v71 = Count;
  v72 = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  v73 = 0;
  v144 = 0;
  v145 = 0;
  v74 = 0;
  v75 = -1;
  do
  {
    v76 = (int *)CFArrayGetValueAtIndex(**((CFArrayRef **)this + 6), v74);
    if (!NetConnection::willEnqueueRequests((NetConnection *)v76)
      || !_isSocketOpenOnNetConnection((HTTPNetConnection *)v76))
    {
      CFArrayAppendValue(v72, v76);
LABEL_141:
      v81 = v151;
      v151 = 0;
      if (v81)
        CFRelease(v81);
      v82 = v149;
      v149 = 0;
      if (v82)
        CFRelease(v82);
      v83 = cf;
      cf = 0;
      if (v83)
        CFRelease(v83);
      v84 = v148;
      v148 = 0;
      if (v84)
        CFRelease(v84);
      SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, &v151, &v149, (_CFHTTPAuthentication **)&cf, &v148);
      goto LABEL_150;
    }
    v77 = (int *)*((_QWORD *)this + 28);
    if (v73 + *v77 > v77[4] || *((_DWORD *)a3 + 12) >= v77[5])
    {
      v78 = *((_QWORD *)v76 + 12);
      if (v78)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v78 + 8));
        v79 = *((_QWORD *)v76 + 12);
        v80 = v76[26];
        if (v79)
          pthread_mutex_unlock((pthread_mutex_t *)(v79 + 8));
      }
      else
      {
        v80 = v76[26];
      }
      if (v80 < 1 || *((_DWORD *)a3 + 12) <= v76[58])
      {
        if (v75 < 0 || v75 > v80)
        {
          if (v145)
            (*(void (**)(int *))(*(_QWORD *)v145 + 48))(v145);
          (*(void (**)(int *))(*(_QWORD *)v76 + 40))(v76);
          v144 = v74;
          v145 = v76;
          v75 = v80;
        }
        goto LABEL_141;
      }
    }
LABEL_150:
    ++v74;
    --v73;
  }
  while (v71 != v74);
  auth[0] = (CFHTTPAuthenticationRef)MEMORY[0x1E0C809B0];
  auth[1] = (CFHTTPAuthenticationRef)3221225472;
  auth[2] = (CFHTTPAuthenticationRef)___ZN25SHTTPConnectionCacheEntry45findOrCreateEmptyUnauthenticatedNetConnectionEPP17HTTPNetConnectionP39SHTTPConnectionCacheEnqueuedRequestInfoPh_block_invoke;
  auth[3] = (CFHTTPAuthenticationRef)&__block_descriptor_40_e9_v16__0_v8l;
  auth[4] = this;
  v159.length = CFArrayGetCount(v72);
  v159.location = 0;
  CFArrayApplyFunction(v72, v159, (CFArrayApplierFunction)RetainableTypedArray<HTTPNetConnection *>::_invoke, auth);
  CFRelease(v72);
  v67 = (HTTPNetConnection *)v145;
  v69 = a2;
  if (!v145)
    goto LABEL_192;
  v99 = (CFArrayRef *)*((_QWORD *)this + 6);
  if (!v99
    || (v100 = *v99,
        v160.length = CFArrayGetCount(*v99),
        v160.location = 0,
        CFArrayGetFirstIndexOfValue(v100, v160, v145) == -1))
  {
LABEL_191:
    (*(void (**)(int *))(*(_QWORD *)v145 + 48))(v145);
    v67 = 0;
LABEL_192:
    v68 = 1;
    goto LABEL_161;
  }
  if (v75 < 1)
    goto LABEL_242;
  v103 = (int *)*((_QWORD *)this + 28);
  v104 = *v103;
  v105 = v104 <= v71;
  v106 = v104 - v71;
  if (v105)
  {
    if ((int)NetConnection::pendingRequestCount((NetConnection *)v145) > 0
      || !SHTTPConnectionCacheEntry::canPipelineOnConnection(this, (HTTPNetConnection *)v145))
    {
LABEL_244:
      (*(void (**)(int *))(*(_QWORD *)v145 + 48))(v145);
      v67 = 0;
      v68 = 0;
      goto LABEL_161;
    }
LABEL_242:
    v134 = (int *)*((_QWORD *)this + 28);
    if (*v134 - v144 > v134[4] || *((_DWORD *)a3 + 12) >= v134[5])
    {
      v68 = 0;
      goto LABEL_246;
    }
    goto LABEL_244;
  }
  if (v106 > v103[4] || *((_DWORD *)a3 + 12) >= v103[5])
    goto LABEL_191;
  v68 = 1;
LABEL_246:
  v135 = (const _CFURLCredential *)v149;
  if (v149)
  {
    v101 = v151;
    if (v151)
    {
      v136 = (SHTTPConnectionCacheEntry *)*((_QWORD *)a3 + 5);
      if (!v136)
      {
        v137 = *((_QWORD *)a3 + 4);
        if (v137)
        {
          *((_QWORD *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v137 - 16));
          CFRelease((CFTypeRef)(*((_QWORD *)a3 + 4) - 16));
          *((_QWORD *)a3 + 4) = 0;
          v136 = (SHTTPConnectionCacheEntry *)*((_QWORD *)a3 + 5);
          v101 = v151;
          v135 = (const _CFURLCredential *)v149;
        }
        else
        {
          v136 = 0;
        }
      }
      SHTTPConnectionCacheEntry::applyCredentialsToRequest(v136, v101, v135, v102);
    }
  }
  if (v148 && cf)
  {
    v138 = URLCredential_PasswordBased::safelyCast((uint64_t)v148, (const _CFURLCredential *)v101);
    if (v138)
      v139 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v138 + 128))(v138);
    else
      v139 = 0;
    v140 = (__CFHTTPMessage *)*((_QWORD *)a3 + 5);
    if (!v140)
    {
      v141 = *((_QWORD *)a3 + 4);
      if (v141)
      {
        *((_QWORD *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v141 - 16));
        CFRelease((CFTypeRef)(*((_QWORD *)a3 + 4) - 16));
        *((_QWORD *)a3 + 4) = 0;
        v140 = (__CFHTTPMessage *)*((_QWORD *)a3 + 5);
      }
      else
      {
        v140 = 0;
      }
    }
    v142 = (_CFHTTPAuthentication *)cf;
    Username = (const __CFString *)CFURLCredentialGetUsername((uint64_t)v148);
    CFHTTPMessageApplyCredentials(v140, v142, Username, v139, 0);
    if (v139)
      CFRelease(v139);
  }
LABEL_161:
  v85 = v151;
  v151 = 0;
  if (v85)
    CFRelease(v85);
LABEL_163:
  v86 = v149;
  v149 = 0;
  if (v86)
    CFRelease(v86);
  v87 = cf;
  cf = 0;
  if (v87)
    CFRelease(v87);
  v88 = v148;
  v148 = 0;
  if (v88)
    CFRelease(v88);
  if (!v68 || v67)
  {
    SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, &v151, &v149, (_CFHTTPAuthentication **)&cf, &v148);
    v95 = v151;
    if (v151)
    {
      v96 = (const _CFURLCredential *)v149;
      if (v149)
      {
        v97 = (SHTTPConnectionCacheEntry *)*((_QWORD *)a3 + 5);
        if (!v97)
        {
          v98 = *((_QWORD *)a3 + 4);
          if (v98)
          {
            *((_QWORD *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v98 - 16));
            CFRelease((CFTypeRef)(*((_QWORD *)a3 + 4) - 16));
            *((_QWORD *)a3 + 4) = 0;
            v97 = (SHTTPConnectionCacheEntry *)*((_QWORD *)a3 + 5);
            v95 = v151;
            v96 = (const _CFURLCredential *)v149;
          }
          else
          {
            v97 = 0;
          }
        }
        SHTTPConnectionCacheEntry::applyCredentialsToRequest(v97, v95, v96, v94);
      }
    }
    v111 = 0;
    if (cf && v148)
    {
      v112 = URLCredential_PasswordBased::safelyCast((uint64_t)v148, (const _CFURLCredential *)v95);
      if (v112)
        v113 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v112 + 128))(v112);
      else
        v113 = 0;
      v114 = (__CFHTTPMessage *)*((_QWORD *)a3 + 5);
      if (!v114)
      {
        v115 = *((_QWORD *)a3 + 4);
        if (v115)
        {
          *((_QWORD *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v115 - 16));
          CFRelease((CFTypeRef)(*((_QWORD *)a3 + 4) - 16));
          *((_QWORD *)a3 + 4) = 0;
          v114 = (__CFHTTPMessage *)*((_QWORD *)a3 + 5);
        }
        else
        {
          v114 = 0;
        }
      }
      v128 = (_CFHTTPAuthentication *)cf;
      v129 = (const __CFString *)CFURLCredentialGetUsername((uint64_t)v148);
      CFHTTPMessageApplyCredentials(v114, v128, v129, v113, 0);
      if (v113)
        CFRelease(v113);
      goto LABEL_227;
    }
  }
  else
  {
    *a4 = 1;
    SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, &v151, &v149, (_CFHTTPAuthentication **)&cf, &v148);
    v90 = v151;
    if (v151)
    {
      v91 = (const _CFURLCredential *)v149;
      if (v149)
      {
        v92 = (SHTTPConnectionCacheEntry *)*((_QWORD *)a3 + 5);
        if (!v92)
        {
          v93 = *((_QWORD *)a3 + 4);
          if (v93)
          {
            *((_QWORD *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v93 - 16));
            CFRelease((CFTypeRef)(*((_QWORD *)a3 + 4) - 16));
            *((_QWORD *)a3 + 4) = 0;
            v92 = (SHTTPConnectionCacheEntry *)*((_QWORD *)a3 + 5);
            v90 = v151;
            v91 = (const _CFURLCredential *)v149;
          }
          else
          {
            v92 = 0;
          }
        }
        SHTTPConnectionCacheEntry::applyCredentialsToRequest(v92, v90, v91, v89);
      }
    }
    if (cf && v148)
    {
      v107 = URLCredential_PasswordBased::safelyCast((uint64_t)v148, (const _CFURLCredential *)v90);
      if (v107)
        v108 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v107 + 128))(v107);
      else
        v108 = 0;
      v109 = (__CFHTTPMessage *)*((_QWORD *)a3 + 5);
      if (!v109)
      {
        v110 = *((_QWORD *)a3 + 4);
        if (v110)
        {
          *((_QWORD *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v110 - 16));
          CFRelease((CFTypeRef)(*((_QWORD *)a3 + 4) - 16));
          *((_QWORD *)a3 + 4) = 0;
          v109 = (__CFHTTPMessage *)*((_QWORD *)a3 + 5);
        }
        else
        {
          v109 = 0;
        }
      }
      v116 = (_CFHTTPAuthentication *)cf;
      v117 = (const __CFString *)CFURLCredentialGetUsername((uint64_t)v148);
      CFHTTPMessageApplyCredentials(v109, v116, v117, v108, 0);
      if (v108)
        CFRelease(v108);
    }
    v118 = (CFArrayRef *)*((_QWORD *)this + 6);
    if (v118)
      v119 = CFArrayGetCount(*v118);
    else
      v119 = 0;
    if (CFArrayGetCount(*((CFArrayRef *)this + 29)) + v119 + *((_QWORD *)this + 30) < **((int **)this + 28))
    {
      if (((*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)a3 + 112))(a3) & 1) == 0
        && (v120 = a3,
            ((*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)a3 + 96))(a3) & 1) != 0)
        || (v121 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 32))(*((_QWORD *)a3 + 3)),
            (v120 = (SBaseAwaitingTube *)(*(uint64_t (**)(SHTTPConnectionCacheEntry *, uint64_t))(*(_QWORD *)this + 64))(this, v121)) != 0))
      {
        v122 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 248, 0);
        *v122 = 0u;
        v122[1] = 0u;
        v122[2] = 0u;
        v122[3] = 0u;
        v122[4] = 0u;
        v122[5] = 0u;
        v122[6] = 0u;
        v122[7] = 0u;
        v122[8] = 0u;
        v122[9] = 0u;
        v122[10] = 0u;
        v122[11] = 0u;
        v122[12] = 0u;
        v122[13] = 0u;
        v122[14] = 0u;
        *((_QWORD *)v122 + 30) = 0;
        v123 = *((_QWORD *)this + 1);
        v124 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 32))(*((_QWORD *)a3 + 3));
        STube::STube((uint64_t)v122, v123, v124, (uint64_t)this, *((_QWORD *)this + 4));
        v125 = *((_QWORD *)v122 + 14);
        v126 = MEMORY[0x1E0C809B0];
        context = MEMORY[0x1E0C809B0];
        v153 = 3221225472;
        v154 = ___ZN5STube24overrideAllowedProtocolsEm_block_invoke;
        v155 = &__block_descriptor_48_e5_v8__0l;
        v156 = (SHTTPConnectionCacheEntry *)v122;
        v157 = 1;
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v125 + 104))(v125, &context);
        (*(void (**)(SBaseAwaitingTube *, _OWORD *))(*(_QWORD *)v120 + 56))(v120, v122);
        STube::initialize((STube *)v122, v120);
        CFArrayAppendValue(*((CFMutableArrayRef *)this + 29), v122);
        (*(void (**)(_OWORD *))(*(_QWORD *)v122 + 48))(v122);
        v127 = *((_QWORD *)this + 4);
        context = v126;
        v153 = 3221225472;
        v154 = ___ZN25SHTTPConnectionCacheEntry47unenqueuePendingRequestMatchingStubAwaitingTubeEP17SBaseAwaitingTube_block_invoke;
        v155 = &__block_descriptor_48_e5_v8__0l;
        v156 = this;
        v157 = (uint64_t)v120;
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v127 + 104))(v127, &context);
        v111 = 2;
        goto LABEL_228;
      }
    }
LABEL_227:
    v111 = 0;
  }
LABEL_228:
  v130 = v151;
  v151 = 0;
  if (v130)
    CFRelease(v130);
  v131 = v149;
  v149 = 0;
  if (v131)
    CFRelease(v131);
  v132 = cf;
  cf = 0;
  if (v132)
    CFRelease(v132);
  v133 = v148;
  v148 = 0;
  if (v133)
    CFRelease(v133);
  if (v67)
    result = 1;
  else
    result = v111;
  *v69 = v67;
  return result;
}

void sub_1840E6B5C(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t SHTTPConnectionCacheEntry::removeAllConnections(SHTTPConnectionCacheEntry *this)
{
  CFArrayRef *v2;
  CFArrayRef *v3;
  _QWORD *v4;
  _QWORD *v5;
  CFIndex Count;
  unint64_t v7;
  _QWORD *ValueAtIndex;
  _QWORD *v9;
  void (*v10)(_QWORD);
  _QWORD *v11;
  uint64_t v12;
  void (*v13)(_QWORD);
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  unint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD);
  uint64_t v20;
  void (*v21)(_QWORD);
  uint64_t v22;
  uint64_t v23;
  CFTypeRef *v24;
  uint64_t v25;

  v2 = (CFArrayRef *)*((_QWORD *)this + 6);
  v3 = (CFArrayRef *)*((_QWORD *)this + 10);
  v4 = (_QWORD *)operator new();
  *v4 = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  *((_QWORD *)this + 6) = v4;
  v5 = (_QWORD *)operator new();
  *v5 = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  *((_QWORD *)this + 10) = v5;
  (*(void (**)(SHTTPConnectionCacheEntry *))(*(_QWORD *)this + 40))(this);
  if (v2)
  {
    Count = CFArrayGetCount(*v2);
    if (Count >= 1)
    {
      v7 = Count + 1;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*v2, v7 - 2);
        v9 = ValueAtIndex;
        v10 = (void (*)(_QWORD))ValueAtIndex[26];
        if (v10)
          v10(ValueAtIndex[27]);
        v9[27] = 0;
        *(_OWORD *)(v9 + 23) = 0u;
        *(_OWORD *)(v9 + 25) = 0u;
        *(_OWORD *)(v9 + 21) = 0u;
        v11 = CFArrayGetValueAtIndex(*v2, v7 - 2);
        v12 = (uint64_t)v11;
        v13 = (void (*)(_QWORD))v11[26];
        if (v13)
          v13(v11[27]);
        *(_QWORD *)(v12 + 216) = 0;
        *(_OWORD *)(v12 + 184) = 0u;
        *(_OWORD *)(v12 + 200) = 0u;
        *(_OWORD *)(v12 + 168) = 0u;
        v14 = *(_QWORD *)(v12 + 96);
        if (v14)
          pthread_mutex_lock((pthread_mutex_t *)(v14 + 8));
        *(_WORD *)(v12 + 88) &= ~1u;
        NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v12);
        v15 = *(_QWORD *)(v12 + 96);
        if (v15)
          pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8));
        CFArrayRemoveValueAtIndex(*v2, v7 - 2);
        --v7;
      }
      while (v7 > 1);
    }
    SUnauthConnectionArray::~SUnauthConnectionArray(v2);
    MEMORY[0x186DB748C]();
  }
  if (v3)
  {
    v16 = CFArrayGetCount(*v3);
    if (v16 >= 1)
    {
      v17 = v16 + 1;
      do
      {
        v18 = *((_QWORD *)CFArrayGetValueAtIndex(*v3, v17 - 2) + 3);
        if (v18)
        {
          v19 = *(void (**)(_QWORD))(v18 + 208);
          if (v19)
            v19(*(_QWORD *)(v18 + 216));
          *(_QWORD *)(v18 + 216) = 0;
          *(_OWORD *)(v18 + 184) = 0u;
          *(_OWORD *)(v18 + 200) = 0u;
          *(_OWORD *)(v18 + 168) = 0u;
        }
        v20 = *((_QWORD *)CFArrayGetValueAtIndex(*v3, v17 - 2) + 3);
        if (v20)
        {
          v21 = *(void (**)(_QWORD))(v20 + 208);
          if (v21)
            v21(*(_QWORD *)(v20 + 216));
          *(_QWORD *)(v20 + 216) = 0;
          *(_OWORD *)(v20 + 184) = 0u;
          *(_OWORD *)(v20 + 200) = 0u;
          *(_OWORD *)(v20 + 168) = 0u;
          v22 = *(_QWORD *)(v20 + 96);
          if (v22)
            pthread_mutex_lock((pthread_mutex_t *)(v22 + 8));
          *(_WORD *)(v20 + 88) &= ~1u;
          NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v20);
          v23 = *(_QWORD *)(v20 + 96);
          if (v23)
            pthread_mutex_unlock((pthread_mutex_t *)(v23 + 8));
        }
        CFArrayRemoveValueAtIndex(*v3, v17 - 2);
        --v17;
      }
      while (v17 > 1);
    }
    v24 = (CFTypeRef *)*((_QWORD *)this + 7);
    if (v24)
    {
      CFRelease(*v24);
      MEMORY[0x186DB748C](v24, 0x20C4093837F09);
    }
    *((_QWORD *)this + 7) = 0;
    v25 = *((_QWORD *)this + 9);
    if (v25)
      (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
    *((_QWORD *)this + 9) = 0;
    SAuthConnectionArray::~SAuthConnectionArray(v3);
    MEMORY[0x186DB748C]();
  }
  return (*(uint64_t (**)(SHTTPConnectionCacheEntry *))(*(_QWORD *)this + 48))(this);
}

void sub_1840E6EB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

BOOL _isSocketOpenOnNetConnection(HTTPNetConnection *a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  _BOOL8 v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  const __CFData *v12;
  const __CFData *v13;
  size_t v14;
  fd_set *v15;
  fd_set *v16;
  int v17;
  int v18;
  timeval v19;
  UInt8 buffer[4];
  CFRange v21;

  v2 = *((_QWORD *)a1 + 12);
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
    v3 = *((_QWORD *)a1 + 12);
    v4 = *((_DWORD *)a1 + 26);
    if (v3)
      pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  }
  else
  {
    v4 = *((_DWORD *)a1 + 26);
  }
  if (v4 > 0)
    return 1;
  v7 = *((_QWORD *)a1 + 12);
  if (!v7)
  {
    v9 = *((_QWORD *)a1 + 19);
    if (v9)
      goto LABEL_12;
    return 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 8));
  v8 = *((_QWORD *)a1 + 12);
  v9 = *((_QWORD *)a1 + 19);
  if (v8)
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  if (!v9)
    return 0;
LABEL_12:
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  ++*(_QWORD *)(v9 + 96);
  v10 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v9 + 40) + 40))(*(_QWORD *)(v9 + 40), 0x1EDCFE540);
  --*(_QWORD *)(v9 + 96);
  if (v10)
  {
    tcp_connection_release();
    return 1;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  ++*(_QWORD *)(v9 + 96);
  v11 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v9 + 40) + 40))(*(_QWORD *)(v9 + 40), 0x1EDCFE2D8);
  --*(_QWORD *)(v9 + 96);
  if ((const void *)*MEMORY[0x1E0C9AE50] == v11)
    goto LABEL_31;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  ++*(_QWORD *)(v9 + 96);
  v12 = (const __CFData *)(*(uint64_t (**)(_QWORD, void *))(**(_QWORD **)(v9 + 40) + 40))(*(_QWORD *)(v9 + 40), &unk_1EDCFBDA8);
  --*(_QWORD *)(v9 + 96);
  if (!v12)
  {
LABEL_31:
    v5 = 0;
  }
  else
  {
    v13 = v12;
    *(_DWORD *)buffer = 0;
    v21.location = 0;
    v21.length = 4;
    CFDataGetBytes(v12, v21, buffer);
    v5 = 0;
    if (!(*(_DWORD *)buffer >> 20))
    {
      v14 = (((unint64_t)*(unsigned int *)buffer + 8) >> 3) + 7;
      v15 = (fd_set *)malloc_type_malloc(v14, 0x37ECECFCuLL);
      v16 = (fd_set *)malloc_type_malloc(v14, 0xF77AEB08uLL);
      v19.tv_sec = 0;
      *(_QWORD *)&v19.tv_usec = 0;
      bzero(v15, v14);
      bzero(v16, v14);
      v17 = *(_DWORD *)buffer;
      if (__darwin_check_fd_set_overflow(*(int *)buffer, v15, 0))
        *(__int32_t *)((char *)v15->fds_bits + (((unint64_t)v17 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v17;
      v18 = *(_DWORD *)buffer;
      if (__darwin_check_fd_set_overflow(*(int *)buffer, v16, 0))
        *(__int32_t *)((char *)v16->fds_bits + (((unint64_t)v18 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v18;
      v5 = select(*(_DWORD *)buffer + 1, v15, 0, v16, &v19) == 0;
      free(v15);
      free(v16);
    }
    CFRelease(v13);
  }
  if (v11)
    CFRelease(v11);
  return v5;
}

uint64_t ___ZN25SHTTPConnectionCacheEntry45findOrCreateEmptyUnauthenticatedNetConnectionEPP17HTTPNetConnectionP39SHTTPConnectionCacheEnqueuedRequestInfoPh_block_invoke(uint64_t a1, HTTPNetConnection *a2)
{
  return SHTTPConnectionCacheEntry::removeUnauthConnection(*(SHTTPConnectionCacheEntry **)(a1 + 32), a2);
}

uint64_t SHTTPConnectionCacheEntry::canPipelineOnConnection(SHTTPConnectionCacheEntry *this, HTTPNetConnection *a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  __int16 v7;
  __int16 v8;

  if ((*((_BYTE *)this + 40) & 8) == 0
    || (*((_BYTE *)this + 40) & 0x10) != 0 && (*((_BYTE *)this + 40) & 0x60) != 0x20
    || (*((_WORD *)a2 + 44) & 2) == 0)
  {
    return 0;
  }
  v5 = (*(uint64_t (**)(HTTPNetConnection *))(*(_QWORD *)a2 + 104))(a2);
  v6 = *((_QWORD *)this + 28);
  v7 = *((_WORD *)a2 + 44);
  if (v5 >= *(_DWORD *)(v6 + 4))
  {
    result = 0;
    v8 = v7 | 0x1000;
  }
  else
  {
    if ((*((_WORD *)a2 + 44) & 0x1000) == 0)
      return 1;
    if (v5 > *(_DWORD *)(v6 + 8))
      return 0;
    v8 = v7 & 0xEFFF;
    result = 1;
  }
  *((_WORD *)a2 + 44) = v8;
  return result;
}

void ___ZN25SHTTPConnectionCacheEntry47unenqueuePendingRequestMatchingStubAwaitingTubeEP17SBaseAwaitingTube_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  CFArrayRef *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(unsigned int *)(v1 + 208);
  if ((int)v2 >= 1)
  {
    while (1)
    {
      v4 = *(CFArrayRef **)(*(_QWORD *)(v1 + 88) + 8 * (v2 - 1));
      if (v4)
      {
        Count = CFArrayGetCount(*v4);
        if (Count >= 1)
          break;
      }
LABEL_7:
      if (v2-- <= 1)
        return;
    }
    v6 = Count;
    v7 = 0;
    while (*(const void **)(a1 + 40) != CFArrayGetValueAtIndex(*v4, v7))
    {
      if (v6 == ++v7)
        goto LABEL_7;
    }
    CFArrayRemoveValueAtIndex(*v4, v7);
  }
}

uint64_t SHTTPConnectionCacheEntry::doesConnAuthApply(SHTTPConnectionCacheEntry *this, SNetConnectionAuthEntryThing *a2, SHTTPConnectionCacheEnqueuedRequestInfo *a3)
{
  int v6;
  const __CFDictionary **v7;
  const __CFDictionary **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  BOOL v13;
  const _CFURLCredential *v14;
  const __CFDictionary **v15;
  CFDictionaryRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  const void *Value;
  int IsValid;
  uint64_t v23;
  uint64_t v24;
  const __CFDictionary **v25;
  uint64_t result;
  const void *v27;
  const void *v28;
  CFTypeRef cf;
  _CFHTTPAuthentication *v30;

  if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)a3 + 3) + 48))(*((_QWORD *)a3 + 3)))
  {
    v6 = 0;
    v7 = 0;
    cf = 0;
    v30 = 0;
    v8 = (const __CFDictionary **)*((_QWORD *)a2 + 4);
    goto LABEL_8;
  }
  v9 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 32))(*((_QWORD *)a3 + 3));
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 88))(v9) == 2)
  {
    cf = 0;
    v30 = 0;
    v8 = (const __CFDictionary **)*((_QWORD *)a2 + 4);
LABEL_6:
    v7 = (const __CFDictionary **)*((_QWORD *)a2 + 5);
    v6 = 1;
    goto LABEL_8;
  }
  v10 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 32))(*((_QWORD *)a3 + 3));
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10);
  cf = 0;
  v30 = 0;
  v8 = (const __CFDictionary **)*((_QWORD *)a2 + 4);
  if (v11 == 3)
    goto LABEL_6;
  v6 = 0;
  v7 = 0;
LABEL_8:
  v12 = (_DWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 96))(*((_QWORD *)a3 + 3));
  if (v12)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1)
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
    v13 = v12[13] == 1;
    if (v8)
    {
      CFRetain(v8);
    }
    else
    {
      SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, &v30, &cf, 0, 0);
      v15 = (const __CFDictionary **)cf;
      v8 = (const __CFDictionary **)v30;
      if (!v30 || !cf)
      {
        if (v30)
        {
          CFRelease(v30);
          v15 = (const __CFDictionary **)cf;
        }
        if (!v15)
          return 0;
        v25 = v15;
        goto LABEL_52;
      }
      v16 = SHTTPConnectionCacheEntry::credentialDictionaryFromURLCredential(v30, (const _CFURLCredential *)cf, v14);
      v17 = *((_QWORD *)a2 + 3);
      if (v17)
      {
        (*(void (**)(uint64_t, CFDictionaryRef, _CFHTTPAuthentication *))(*(_QWORD *)v17 + 96))(v17, v16, v30);
        (*(void (**)(uint64_t, CFTypeRef, _CFHTTPAuthentication *))(*(_QWORD *)v17 + 88))(v17, cf, v30);
      }
      if (v16)
        CFRelease(v16);
      CFRelease(cf);
    }
  }
  else
  {
    if (!v8)
      goto LABEL_43;
    CFRetain(v8);
    v13 = 0;
  }
  v18 = *((_QWORD *)a3 + 5);
  if (v18)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v19 = v18 + 16;
    if (*(_BYTE *)(v18 + 40))
      v19 = 0;
  }
  else
  {
    v19 = *((_QWORD *)a3 + 4);
  }
  if (!CFHTTPAuthenticationAppliesToRequest((CFHTTPAuthenticationRef)v8, (CFHTTPMessageRef)(v19 - 16)))
    goto LABEL_51;
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
  if (HTTPAuthentication::isKerberosThePreferredAuthScheme(v8[19]))
    v20 = 1;
  else
    v20 = v13;
  if ((v20 & 1) == 0)
  {
    if (CFDictionaryGetValue(*(CFDictionaryRef *)(*((_QWORD *)this + 9) + 8), v8))
    {
      v13 = 0;
      goto LABEL_38;
    }
LABEL_51:
    v25 = v8;
LABEL_52:
    CFRelease(v25);
    return 0;
  }
LABEL_38:
  if (v12)
  {
    if (!v13)
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*((_QWORD *)this + 9) + 8), v8);
      if (!Value || !CFEqual(v12, Value))
        goto LABEL_51;
    }
  }
  IsValid = CFHTTPAuthenticationIsValid((CFHTTPAuthenticationRef)v8, 0);
  CFRelease(v8);
  if (!IsValid)
    return 0;
LABEL_43:
  if (!v6)
    return !v7;
  if (!v7)
    return !(*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 120))(*((_QWORD *)a3 + 3));
  v23 = *((_QWORD *)a3 + 5);
  if (v23)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v24 = v23 + 16;
    if (*(_BYTE *)(v23 + 40))
      v24 = 0;
  }
  else
  {
    v24 = *((_QWORD *)a3 + 4);
  }
  result = CFHTTPAuthenticationAppliesToRequest((CFHTTPAuthenticationRef)v7, (CFHTTPMessageRef)(v24 - 16));
  if ((_DWORD)result)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
    if (HTTPAuthentication::isKerberosThePreferredAuthScheme(v7[19])
      || !(*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 120))(*((_QWORD *)a3 + 3))
      || (result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(*((_QWORD *)this + 9) + 8), v7)) != 0
      && (v27 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 120))(*((_QWORD *)a3 + 3)),
          v28 = CFDictionaryGetValue(*(CFDictionaryRef *)(*((_QWORD *)this + 9) + 8), v7),
          result = 0,
          v27)
      && v28
      && (result = CFEqual(v27, v28), (_DWORD)result))
    {
      result = CFHTTPAuthenticationIsValid((CFHTTPAuthenticationRef)v7, 0);
      if ((_DWORD)result)
        return 1;
    }
  }
  return result;
}

uint64_t ___ZN25SHTTPConnectionCacheEntry43findOrCreateEmptyAuthenticatedNetConnectionEP39SHTTPConnectionCacheEnqueuedRequestInfoPh_block_invoke(uint64_t a1, HTTPNetConnection *a2)
{
  return SHTTPConnectionCacheEntry::removeAuthConnection(*(_QWORD *)(a1 + 32), a2);
}

CFDictionaryRef SHTTPConnectionCacheEntry::credentialDictionaryFromURLCredential(SHTTPConnectionCacheEntry *this, const _CFURLCredential *cf, const _CFURLCredential *a3)
{
  const __CFAllocator *v5;
  const _CFURLCredential *v6;
  uint64_t Username;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v9;
  CFDictionaryRef v10;
  uint64_t v11;
  void *v12;
  const void *v13;
  char v14;
  void *v15;
  const void *v16;
  void *v17;
  CFNumberRef v18;
  CFNumberRef v19;
  int valuePtr;
  void *values[2];
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  void *keys[2];
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!cf)
    return 0;
  v29 = 0;
  v27 = 0u;
  v28 = 0u;
  *(_OWORD *)keys = 0u;
  v25 = 0;
  v23 = 0u;
  v24 = 0u;
  *(_OWORD *)values = 0u;
  v5 = CFGetAllocator(cf);
  Username = CFURLCredentialGetUsername((uint64_t)cf);
  if (Username)
  {
    if (CFHTTPAuthenticationRequiresAccountDomain(this))
    {
      ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v5, (CFStringRef)Username, CFSTR("\\"));
      v9 = ArrayBySeparatingStrings;
      if (ArrayBySeparatingStrings && CFArrayGetCount(ArrayBySeparatingStrings) == 2)
      {
        keys[0] = CFSTR("kCFHTTPAuthenticationAccountDomain");
        values[0] = (void *)CFArrayGetValueAtIndex(v9, 0);
        keys[1] = CFSTR("kCFHTTPAuthenticationUsername");
        values[1] = (void *)CFArrayGetValueAtIndex(v9, 1);
        Username = 2;
        goto LABEL_11;
      }
    }
    else
    {
      v9 = 0;
    }
    keys[0] = CFSTR("kCFHTTPAuthenticationUsername");
    values[0] = (void *)Username;
    Username = 1;
  }
  else
  {
    v9 = 0;
  }
LABEL_11:
  v11 = URLCredential_PasswordBased::safelyCast((uint64_t)cf, v6);
  if (!v11)
  {
    v13 = 0;
    goto LABEL_15;
  }
  v12 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 128))(v11);
  v13 = v12;
  if (!v12)
  {
LABEL_15:
    v14 = 1;
    goto LABEL_16;
  }
  v14 = 0;
  values[Username] = v12;
  keys[Username++] = CFSTR("kCFHTTPAuthenticationPassword");
LABEL_16:
  v15 = (void *)_CFURLCredentialCopyOAuthToken(cf);
  v16 = v15;
  if (v15)
  {
    values[Username] = v15;
    keys[Username++] = CFSTR("kCFHTTPAuthenticationOAuthToken");
  }
  v17 = (void *)_CFURLCredentialCopyOAuth1Account(cf);
  if (v17)
  {
    values[Username] = v17;
    keys[Username++] = CFSTR("kCFHTTPAuthenticationOAuth1Account");
    CFRelease(v17);
  }
  valuePtr = _CFURLCredentialGetOAuth1PID(cf);
  if (valuePtr < 1)
  {
    v19 = 0;
  }
  else
  {
    v18 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
    v19 = v18;
    if (v18)
    {
      values[Username] = v18;
      keys[Username++] = CFSTR("kCFHTTPAuthenticationOAuth1PID");
    }
  }
  v10 = CFDictionaryCreate(v5, (const void **)keys, (const void **)values, Username, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v9)
    CFRelease(v9);
  if ((v14 & 1) == 0)
    CFRelease(v13);
  if (v16)
    CFRelease(v16);
  if (v19)
    CFRelease(v19);
  return v10;
}

void SNetConnectionAuthEntryThing::~SNetConnectionAuthEntryThing(SNetConnectionAuthEntryThing *this)
{
  uint64_t v2;

  SNetConnectionAuthEntryThing::~SNetConnectionAuthEntryThing(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;
  const void *v3;
  const void *v4;

  *(_QWORD *)this = off_1E14EEA38;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 5);
  if (v4)
    CFRelease(v4);
}

BOOL SNetConnectionAuthEntryThing::equals(SNetConnectionAuthEntryThing *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

uint64_t SHTTPConnectionCacheEntry::removeAuthConnection(uint64_t this, HTTPNetConnection *a2)
{
  CFArrayRef *v2;
  uint64_t v4;
  uint64_t v5;
  CFIndex v6;
  uint64_t v7;
  const void *v8;
  const void *v9;
  void (*v10)(_QWORD);
  CFArrayRef *v11;
  uint64_t v12;
  void (*v13)(_QWORD);
  uint64_t v14;
  uint64_t v15;

  v2 = *(CFArrayRef **)(this + 80);
  if (v2)
  {
    v4 = this;
    this = CFArrayGetCount(*v2);
    if (this >= 1)
    {
      v5 = this;
      v6 = 0;
      while (1)
      {
        this = (uint64_t)CFArrayGetValueAtIndex(**(CFArrayRef **)(v4 + 80), v6);
        if (this)
        {
          v7 = this;
          if (*(HTTPNetConnection **)(this + 24) == a2)
            break;
        }
        if (v5 == ++v6)
          return this;
      }
      v8 = *(const void **)(this + 32);
      if (a2)
        (*(void (**)(HTTPNetConnection *))(*(_QWORD *)a2 + 40))(a2);
      if (v8)
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(v4 + 72) + 8), v8);
      v9 = *(const void **)(v7 + 40);
      if (v9)
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(v4 + 72) + 8), v9);
      v10 = (void (*)(_QWORD))*((_QWORD *)a2 + 26);
      if (v10)
        v10(*((_QWORD *)a2 + 27));
      *((_QWORD *)a2 + 27) = 0;
      *(_OWORD *)((char *)a2 + 184) = 0u;
      *(_OWORD *)((char *)a2 + 200) = 0u;
      *(_OWORD *)((char *)a2 + 168) = 0u;
      v11 = *(CFArrayRef **)(v4 + 80);
      v12 = *((_QWORD *)CFArrayGetValueAtIndex(*v11, v6) + 3);
      if (v12)
      {
        v13 = *(void (**)(_QWORD))(v12 + 208);
        if (v13)
          v13(*(_QWORD *)(v12 + 216));
        *(_QWORD *)(v12 + 216) = 0;
        *(_OWORD *)(v12 + 184) = 0u;
        *(_OWORD *)(v12 + 200) = 0u;
        *(_OWORD *)(v12 + 168) = 0u;
        v14 = *(_QWORD *)(v12 + 96);
        if (v14)
          pthread_mutex_lock((pthread_mutex_t *)(v14 + 8));
        *(_WORD *)(v12 + 88) &= ~1u;
        NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v12);
        v15 = *(_QWORD *)(v12 + 96);
        if (v15)
          pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8));
      }
      CFArrayRemoveValueAtIndex(*v11, v6);
      SHTTPConnectionCacheEntry::removeAuthConnection((SHTTPConnectionCacheEntry *)v4, a2);
      SHTTPConnectionCacheEntry::connectionWasLost((SHTTPConnectionCacheEntry *)v4, a2);
      return (*(uint64_t (**)(HTTPNetConnection *))(*(_QWORD *)a2 + 48))(a2);
    }
  }
  return this;
}

void SHTTPConnectionCacheEntry::findCachedAuthentication(uint64_t a1, int a2, CFArrayRef *a3, uint64_t a4, const void *a5, CFHTTPAuthenticationRef *a6, CFTypeRef *a7)
{
  uint64_t v13;
  uint64_t v14;
  CFIndex Count;
  _QWORD *v16;
  CFIndex v17;
  _CFHTTPAuthentication *ValueAtIndex;
  const void *Value;

  v13 = *(_QWORD *)(a1 + 40);
  if (v13)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_BYTE *)(v13 + 40))
      v14 = 0;
    else
      v14 = v13 + 16;
    if (!a2)
      goto LABEL_22;
  }
  else
  {
    v14 = *(_QWORD *)(a1 + 32);
    if (!a2)
      goto LABEL_22;
  }
  if (!a3 || !a6 || !a7)
    goto LABEL_22;
  Count = CFArrayGetCount(*a3);
  v16 = a6;
  if (Count < 1)
    goto LABEL_21;
  v17 = Count + 1;
  while (1)
  {
    ValueAtIndex = (_CFHTTPAuthentication *)CFArrayGetValueAtIndex(*a3, v17 - 2);
    *a6 = ValueAtIndex;
    if (!CFHTTPAuthenticationIsValid(ValueAtIndex, 0))
    {
      CFArrayRemoveValueAtIndex(*a3, v17 - 2);
      goto LABEL_19;
    }
    if (CFHTTPAuthenticationAppliesToRequest(*a6, (CFHTTPMessageRef)(v14 - 16)))
      break;
LABEL_19:
    if ((unint64_t)--v17 <= 1)
    {
      v16 = a6;
      goto LABEL_21;
    }
  }
  if (*a6)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 8), *a6);
    *a7 = Value;
    if (a5)
    {
      if (*a6 && (!Value || !CFEqual(a5, Value)))
      {
        *a6 = 0;
        v16 = a7;
LABEL_21:
        *v16 = 0;
      }
    }
  }
LABEL_22:
  if (a6 && a7)
  {
    if (*a6 && *a7)
    {
      CFRetain(*a6);
      CFRetain(*a7);
    }
    else
    {
      *a6 = 0;
      *a7 = 0;
    }
  }
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::getAuthSchemeStringFromChallenge(SHTTPConnectionCacheEnqueuedRequestInfo *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;

  v2 = 128;
  if (!a2)
    v2 = 104;
  v3 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)this + v2))(this);
  if (!v3)
    return 0;
  v4 = v3;
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v5 = *(_QWORD *)(v4 + 40);
  if (!v5)
    return 0;
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v6 = *(_DWORD *)(v5 + 72);
  if (v6)
    return URLProtectionSpace::stringForProtSpaceAuthScheme(v6);
  else
    return 0;
}

const _CFURLCredential *SHTTPConnectionCacheEntry::createAuthAndMakeAvailable(__CFArray ***this, SHTTPConnectionCacheEnqueuedRequestInfo **a2, int a3, _CFHTTPAuthentication **a4, const _CFURLCredential **a5)
{
  const __CFAllocator *v8;
  const __CFString *AuthSchemeStringFromChallenge;
  const void *v10;
  const __CFString *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFHTTPMessage *v16;
  CFComparisonResult v17;
  const __CFAllocator *v18;
  const __CFAllocator *v19;
  __CFHTTPMessage *v20;
  const __CFString *v21;
  char v22;
  const void *v23;
  const __CFString *v24;
  _CFHTTPAuthentication *v25;
  uint64_t v26;
  SHTTPConnectionCacheEntry *v27;
  __CFArray **v28;
  __CFArray **v29;
  __CFArray *Mutable;
  _CFHTTPAuthentication *v31;
  _CFHTTPAuthentication *v32;
  HTTPAuthentication *v33;
  const void *v34;
  const void *v35;
  const __CFString *v36;
  __CFArray **v37;
  _QWORD *v38;
  const _CFURLCredential *result;
  unsigned __int8 v40;
  const void *v41;
  char v42;
  _DWORD *value;

  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  AuthSchemeStringFromChallenge = (const __CFString *)SHTTPConnectionCacheEnqueuedRequestInfo::getAuthSchemeStringFromChallenge(a2[3], a3);
  v42 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)a2[3] + 160))(a2[3]);
  v10 = (const void *)(*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)a2[3] + 200))(a2[3]);
  v41 = (const void *)(*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)a2[3] + 208))(a2[3]);
  v11 = (const __CFString *)(*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)a2[3]
                                                                                                 + 216))(a2[3]);
  v12 = 120;
  if (a3)
  {
    v13 = 128;
  }
  else
  {
    v12 = 96;
    v13 = 104;
  }
  if (a3)
    v14 = 136;
  else
    v14 = 112;
  value = (_DWORD *)(*(uint64_t (**)(void))(*(_QWORD *)a2[3] + v12))();
  v15 = (*(uint64_t (**)(void))(*(_QWORD *)a2[3] + v13))();
  v16 = (__CFHTTPMessage *)(*(uint64_t (**)(void))(*(_QWORD *)a2[3] + v14))();
  if (!AuthSchemeStringFromChallenge
    || (v17 = CFStringCompare(AuthSchemeStringFromChallenge, CFSTR("Negotiate"), 0x80uLL), !v15))
  {
    v18 = v8;
    v19 = v8;
    v20 = v16;
    v21 = 0;
    v22 = 1;
    v23 = 0;
    goto LABEL_15;
  }
  if (v17 == kCFCompareEqualTo)
  {
    v36 = (const __CFString *)(*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)a2[3] + 224))(a2[3]);
    v18 = v8;
    v25 = (_CFHTTPAuthentication *)_CFHTTPAuthenticationCreateFromResponseInternal(v8, v16, AuthSchemeStringFromChallenge, v42, v41, v11, v36, 0, 0, v40);
LABEL_17:
    *a4 = v25;
    if (v25)
      goto LABEL_18;
    goto LABEL_35;
  }
  v18 = v8;
  if (CFStringCompare(AuthSchemeStringFromChallenge, CFSTR("X-MobileMe-AuthToken"), 1uLL)
    && CFStringCompare(AuthSchemeStringFromChallenge, CFSTR("OAuth"), 1uLL))
  {
    if (CFStringCompare(AuthSchemeStringFromChallenge, CFSTR("Negotiate"), 1uLL) == kCFCompareEqualTo)
    {
      v19 = v8;
      v20 = v16;
      v21 = AuthSchemeStringFromChallenge;
      v22 = v42;
      v23 = v41;
      v24 = v11;
      goto LABEL_16;
    }
    v19 = v8;
    v20 = v16;
    v21 = AuthSchemeStringFromChallenge;
    v22 = v42;
    v23 = v10;
LABEL_15:
    v24 = 0;
LABEL_16:
    v25 = (_CFHTTPAuthentication *)_CFHTTPAuthenticationCreateFromResponseInternal(v19, v20, v21, v22, v23, v24, 0, 0, 0, v40);
    goto LABEL_17;
  }
  v31 = (_CFHTTPAuthentication *)_CFHTTPAuthenticationCreateFromResponseInternal(v8, v16, AuthSchemeStringFromChallenge, v42, v10, 0, 0, 0, 0, v40);
  *a4 = v31;
  if (v31)
  {
    if ((*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)a2[3] + 152))(a2[3]))
    {
      v32 = *a4;
      if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
        dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
      if (v32)
        v33 = (_CFHTTPAuthentication *)((char *)v32 + 16);
      else
        v33 = 0;
      v34 = (const void *)(*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)a2[3] + 152))(a2[3]);
      HTTPAuthentication::setSecTrust(v33, v34);
    }
    v25 = *a4;
    if (*a4)
    {
LABEL_18:
      if (a3)
      {
        v26 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(_QWORD *)a2[3] + 32))(a2[3]);
        v27 = (SHTTPConnectionCacheEntry *)this;
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v26 + 88))(v26) == 3
          || _CFHTTPAuthenticationIsConnectionBasedAuth(*a4))
        {
LABEL_41:
          if (!*((_QWORD *)v27 + 9))
          {
            v38 = (_QWORD *)operator new();
            *v38 = &off_1E14EA3C8;
            v38[1] = CFDictionaryCreateMutable(v18, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            *((_QWORD *)v27 + 9) = v38;
          }
          v35 = value;
          if (value)
          {
            if (URLCredential::Class(void)::sOnce_URLCredential != -1)
              dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
            if (value[13] != 1)
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(*((_QWORD *)v27 + 9) + 8), *a4, value);
            goto LABEL_48;
          }
LABEL_49:
          result = 0;
          goto LABEL_50;
        }
        v28 = this[8];
        if (!v28)
        {
          v29 = (__CFArray **)operator new();
          Mutable = CFArrayCreateMutable(v18, 0, MEMORY[0x1E0C9B378]);
          *v29 = Mutable;
          this[8] = v29;
LABEL_40:
          CFArrayAppendValue(Mutable, *a4);
          goto LABEL_41;
        }
      }
      else
      {
        v27 = (SHTTPConnectionCacheEntry *)this;
        if (_CFHTTPAuthenticationIsConnectionBasedAuth(v25))
          goto LABEL_41;
        v28 = this[7];
        if (!v28)
        {
          v37 = (__CFArray **)operator new();
          Mutable = CFArrayCreateMutable(v18, 0, MEMORY[0x1E0C9B378]);
          *v37 = Mutable;
          this[7] = v37;
          goto LABEL_40;
        }
      }
      Mutable = *v28;
      goto LABEL_40;
    }
  }
LABEL_35:
  v35 = value;
  if (!value)
    goto LABEL_49;
LABEL_48:
  result = (const _CFURLCredential *)CFRetain(v35);
LABEL_50:
  *a5 = result;
  return result;
}

void sub_1840E8414(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

uint64_t RetainableTypedDict<_CFHTTPAuthentication *,_CFURLCredential const*>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA3C8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<_CFHTTPAuthentication *,_CFURLCredential const*>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA3C8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void SHTTPConnectionCacheEnqueuedRequestInfo::~SHTTPConnectionCacheEnqueuedRequestInfo(SHTTPConnectionCacheEnqueuedRequestInfo *this)
{
  uint64_t v2;

  SHTTPConnectionCacheEnqueuedRequestInfo::~SHTTPConnectionCacheEnqueuedRequestInfo(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;

  *(_QWORD *)this = off_1E14EF6E0;
  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 9) = 0;
  }
  v3 = *((_QWORD *)this + 3);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    *((_QWORD *)this + 3) = 0;
  }
  v4 = *((_QWORD *)this + 4);
  if (v4)
  {
    CFRelease((CFTypeRef)(v4 - 16));
    *((_QWORD *)this + 4) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 5);
  if (v5)
  {
    *((_QWORD *)this + 5) = 0;
    CFRelease(v5);
  }
}

CFStringRef SHTTPConnectionCacheEnqueuedRequestInfo::copyDebugDesc(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat(this[1], 0, CFSTR("<%p client=%p, message=%@>"), this, this[3], (char *)this[4] - 16);
}

BOOL SHTTPConnectionCacheEnqueuedRequestInfo::equals(SHTTPConnectionCacheEnqueuedRequestInfo *this, const CFAllocatedReferenceCountedObject *a2)
{
  if (this == a2)
    return 1;
  if (*((_QWORD *)this + 3) == *((_QWORD *)a2 + 3))
    return CFEqual((CFTypeRef)(*((_QWORD *)this + 4) - 16), (CFTypeRef)(*((_QWORD *)a2 + 4) - 16)) != 0;
  return 0;
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::hash(SHTTPConnectionCacheEnqueuedRequestInfo *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 3);
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 8))(*((_QWORD *)this + 4)) ^ v1;
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::linkWithTube(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 72);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    *(_QWORD *)(a1 + 72) = 0;
  }
  if (a2)
  {
    *(_QWORD *)(a1 + 72) = a2;
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  }
  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 56))(result, *(_QWORD *)(a1 + 72));
  return result;
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::getClient(SHTTPConnectionCacheEnqueuedRequestInfo *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::getRequest(SHTTPConnectionCacheEnqueuedRequestInfo *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 5);
  if (!v1)
    return *((_QWORD *)this + 4);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (*(_BYTE *)(v1 + 40))
    return 0;
  else
    return v1 + 16;
}

__n128 SHTTPConnectionCacheEnqueuedRequestInfo::getOptions@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result;

  result = this[3];
  *a2 = result;
  a2[1].n128_u64[0] = this[4].n128_u64[0];
  return result;
}

__n128 SHTTPConnectionCacheEnqueuedRequestInfo::getRequestToEnqueue(__n128 *a1, _QWORD *a2, unint64_t *a3, __n128 *a4)
{
  unint64_t v8;
  unint64_t v9;
  __n128 result;

  v8 = a1[2].n128_u64[1];
  if (v8)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v9 = v8 + 16;
    if (*(_BYTE *)(v8 + 40))
      v9 = 0;
  }
  else
  {
    v9 = a1[2].n128_u64[0];
  }
  *a3 = v9;
  *a2 = a1[1].n128_u64[1];
  result = a1[3];
  a4[1].n128_u64[0] = a1[4].n128_u64[0];
  *a4 = result;
  return result;
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::isValid(SHTTPConnectionCacheEnqueuedRequestInfo *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  if (result)
    return (*(unsigned int (**)(uint64_t))(*(_QWORD *)result + 184))(result) != 0;
  return result;
}

uint64_t SBaseAwaitingTube::markAsClaimed(uint64_t this)
{
  if (*(_BYTE *)(this + 20))
    __assert_rtn("markAsClaimed", "SAwaitingTube.h", 52, "!claimedByTube");
  *(_BYTE *)(this + 20) = 1;
  return this;
}

uint64_t SBaseAwaitingTube::hasBeenClaimed(SBaseAwaitingTube *this)
{
  return *((unsigned __int8 *)this + 20);
}

uint64_t SHTTPConnectionCacheEntry::authenticatedConnectionCompletedResponse(SHTTPConnectionCacheEntry *this, CFArrayRef **a2, void *a3)
{
  if (_isSocketOpenOnNetConnection(this))
    return SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection(a2, this, 0);
  else
    return SHTTPConnectionCacheEntry::removeAuthConnection((uint64_t)a2, this);
}

uint64_t SHTTPConnectionCacheEntry::authenticatedConnectionWasLost(SHTTPConnectionCacheEntry *this, NetConnection *a2, void *a3)
{
  SHTTPConnectionCacheEntry::removeAuthConnection((uint64_t)a2, this);
  return SHTTPConnectionCacheEntry::connectionWasLost(a2, this);
}

SHTTPConnectionCacheEntry *SHTTPConnectionCacheEntry::retainCacheEntry(SHTTPConnectionCacheEntry *this, const void *a2)
{
  if (this)
    (*(void (**)(SHTTPConnectionCacheEntry *, const void *))(*(_QWORD *)this + 40))(this, a2);
  return this;
}

uint64_t SHTTPConnectionCacheEntry::releaseCacheEntry(uint64_t this, const void *a2)
{
  if (this)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 48))(this);
  return this;
}

CFIndex SHTTPConnectionCacheEntry::authenticatedConnectionActivity(SHTTPConnectionCacheEntry *this, NetConnection *a2, void *a3)
{
  return SHTTPConnectionCacheEntry::connectionActivity((CFIndex)a2, a2);
}

HTTPNetConnection *SHTTPConnectionCacheEntry::connectionCompletedRequest(HTTPNetConnection *this, NetConnection *a2, void *a3)
{
  HTTPNetConnection *v4;

  if ((*((_BYTE *)a2 + 40) & 8) != 0)
  {
    v4 = this;
    if ((*((_BYTE *)a2 + 40) & 0x10) == 0 || (*((_BYTE *)a2 + 40) & 0x60) == 0x20)
    {
      this = (HTTPNetConnection *)SHTTPConnectionCacheEntry::canPipelineOnConnection(a2, this);
      if ((_DWORD)this)
        return (HTTPNetConnection *)SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection((CFArrayRef **)a2, v4, 0);
    }
  }
  return this;
}

CFIndex SHTTPConnectionCacheEntry::connectionCompletedResponse(SHTTPConnectionCacheEntry *this, NetConnection *a2, void *a3)
{
  char v5;
  CFIndex result;

  if (!_isSocketOpenOnNetConnection(this))
    return SHTTPConnectionCacheEntry::removeUnauthConnection((CFIndex)a2, this);
  v5 = *((_BYTE *)a2 + 40);
  *((_BYTE *)a2 + 40) = v5 | 0x20;
  if ((v5 & 8) == 0)
    return SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection((CFArrayRef **)a2, this, 0);
  if ((v5 & 0x50) == 0x50)
    return SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection((CFArrayRef **)a2, this, 0);
  if (!SHTTPConnectionCacheEntry::canPipelineOnConnection(a2, this))
    return SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection((CFArrayRef **)a2, this, 0);
  result = (*(uint64_t (**)(SHTTPConnectionCacheEntry *))(*(_QWORD *)this + 104))(this);
  if (!(_DWORD)result)
    return SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection((CFArrayRef **)a2, this, 0);
  return result;
}

uint64_t SHTTPConnectionCacheEntry::connectionWasLost(SHTTPConnectionCacheEntry *this, NetConnection *a2, void *a3)
{
  return SHTTPConnectionCacheEntry::connectionWasLost(a2, this);
}

CFIndex SHTTPConnectionCacheEntry::connectionActivity(SHTTPConnectionCacheEntry *this, NetConnection *a2, void *a3)
{
  return SHTTPConnectionCacheEntry::connectionActivity((CFIndex)a2, a2);
}

CFIndex SHTTPConnectionCacheEntry::connectionActivity(CFIndex this, HTTPNetConnection *a2)
{
  uint64_t v2;
  uint64_t v3;
  CFArrayRef *v4;
  unint64_t v5;
  _QWORD **ValueAtIndex;

  v2 = *(unsigned int *)(this + 208);
  if ((int)v2 >= 1)
  {
    v3 = this;
    do
    {
      v4 = *(CFArrayRef **)(*(_QWORD *)(v3 + 88) + 8 * (v2 - 1));
      if (v4)
      {
        this = CFArrayGetCount(*v4);
        if (this >= 1)
        {
          v5 = this + 1;
          do
          {
            ValueAtIndex = (_QWORD **)CFArrayGetValueAtIndex(*v4, v5 - 2);
            this = (*(uint64_t (**)(_QWORD *))(*ValueAtIndex[3] + 192))(ValueAtIndex[3]);
            --v5;
          }
          while (v5 > 1);
        }
      }
    }
    while (v2-- > 1);
  }
  return this;
}

CFIndex SHTTPConnectionCacheEntry::countConnections(SHTTPConnectionCacheEntry *this)
{
  CFIndex v2;
  CFArrayRef *v3;
  CFArrayRef *v4;

  v2 = *((_QWORD *)this + 30) + CFArrayGetCount(*((CFArrayRef *)this + 29));
  v3 = (CFArrayRef *)*((_QWORD *)this + 6);
  if (v3)
    v2 += CFArrayGetCount(*v3);
  v4 = (CFArrayRef *)*((_QWORD *)this + 10);
  if (v4)
    v2 += CFArrayGetCount(*v4);
  return v2;
}

void SHTTPConnectionCacheEntry::checkForPurgability(uint64_t a1, CFMutableArrayRef *a2, double a3, double a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  const void *v13;
  const void *v14;

  if (a1)
  {
    CFAbsoluteTimeGetCurrent();
    if (CFAbsoluteTimeGetCurrent() >= *(double *)(a1 + 296))
    {
      if (a3 == a4)
        goto LABEL_16;
      v8 = *(_QWORD *)(a1 + 96);
      if (v8)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v8 + 8));
        v9 = *(_QWORD *)(a1 + 96);
        v10 = *(_QWORD *)(a1 + 152);
        if (v9)
          pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
      }
      else
      {
        v10 = *(_QWORD *)(a1 + 152);
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
      if (v10)
        v11 = v10 + 16;
      else
        v11 = 0;
      ++*(_QWORD *)(v11 + 80);
      v12 = (const void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v11 + 24) + 40))(*(_QWORD *)(v11 + 24));
      v13 = v12;
      --*(_QWORD *)(v11 + 80);
      v14 = (const void *)*MEMORY[0x1E0C9AE50];
      if (v12)
        CFRelease(v12);
      if (v14 != v13)
LABEL_16:
        a4 = a3;
      if (a4 > NetConnection::getLastAccessTime((NetConnection *)a1)
        || !_isSocketOpenOnNetConnection((HTTPNetConnection *)a1))
      {
        CFArrayAppendValue(*a2, (const void *)a1);
      }
    }
  }
}

void SHTTPConnectionCacheEntry::purgeIdleConnections(SHTTPConnectionCacheEntry *this, double a2, double a3)
{
  CFArrayRef *v6;
  uint64_t v7;
  CFIndex Count;
  __CFArray *Mutable;
  BOOL v10;
  const void *ValueAtIndex;
  CFArrayRef *v12;
  CFIndex v13;
  __CFArray *v14;
  _QWORD *v15;
  _QWORD v16[5];
  _QWORD context[5];
  CFMutableArrayRef i;
  CFRange v19;
  CFRange v20;

  v6 = (CFArrayRef *)*((_QWORD *)this + 6);
  v7 = MEMORY[0x1E0C809B0];
  if (v6)
  {
    Count = CFArrayGetCount(*v6);
    Mutable = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    for (i = Mutable; ; SHTTPConnectionCacheEntry::checkForPurgability((uint64_t)ValueAtIndex, &i, a2, a3))
    {
      v10 = Count-- < 1;
      if (v10)
        break;
      ValueAtIndex = CFArrayGetValueAtIndex(**((CFArrayRef **)this + 6), Count);
    }
    context[0] = v7;
    context[1] = 3221225472;
    context[2] = ___ZN25SHTTPConnectionCacheEntry20purgeIdleConnectionsEdd_block_invoke;
    context[3] = &__block_descriptor_40_e9_v16__0_v8l;
    context[4] = this;
    v19.length = CFArrayGetCount(Mutable);
    v19.location = 0;
    CFArrayApplyFunction(Mutable, v19, (CFArrayApplierFunction)RetainableTypedArray<HTTPNetConnection *>::_invoke, context);
    CFRelease(Mutable);
  }
  v12 = (CFArrayRef *)*((_QWORD *)this + 10);
  if (v12)
  {
    v13 = CFArrayGetCount(*v12);
    v14 = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    for (i = v14; ; SHTTPConnectionCacheEntry::checkForPurgability(v15[3], &i, a2, a3))
    {
      v10 = v13-- < 1;
      if (v10)
        break;
      v15 = CFArrayGetValueAtIndex(**((CFArrayRef **)this + 10), v13);
    }
    v16[0] = v7;
    v16[1] = 3221225472;
    v16[2] = ___ZN25SHTTPConnectionCacheEntry20purgeIdleConnectionsEdd_block_invoke_2;
    v16[3] = &__block_descriptor_40_e9_v16__0_v8l;
    v16[4] = this;
    v20.length = CFArrayGetCount(v14);
    v20.location = 0;
    CFArrayApplyFunction(v14, v20, (CFArrayApplierFunction)RetainableTypedArray<HTTPNetConnection *>::_invoke, v16);
    CFRelease(v14);
  }
}

void sub_1840E8DFC(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

CFIndex ___ZN25SHTTPConnectionCacheEntry20purgeIdleConnectionsEdd_block_invoke(uint64_t a1, HTTPNetConnection *a2)
{
  return SHTTPConnectionCacheEntry::removeUnauthConnection(*(_QWORD *)(a1 + 32), a2);
}

uint64_t ___ZN25SHTTPConnectionCacheEntry20purgeIdleConnectionsEdd_block_invoke_2(uint64_t a1, HTTPNetConnection *a2)
{
  return SHTTPConnectionCacheEntry::removeAuthConnection(*(_QWORD *)(a1 + 32), a2);
}

void SHTTPConnectionCacheEntry::setHasBeenForgotten(SHTTPConnectionCacheEntry *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  char v5;
  CFArrayRef *v6;
  const __CFArray *v7;
  CFRange v8;

  *((_BYTE *)this + 40) |= 4u;
  v2 = *((unsigned int *)this + 52);
  if ((int)v2 < 1)
    goto LABEL_8;
  v3 = v2 + 1;
  v4 = v2 - 1;
  v5 = 1;
  do
  {
    v6 = *(CFArrayRef **)(*((_QWORD *)this + 11) + 8 * v4);
    if (v6)
    {
      if (CFArrayGetCount(*v6) > 0)
        v5 = 0;
    }
    --v3;
    --v4;
  }
  while (v3 > 1);
  if (v5)
  {
LABEL_8:
    SHTTPConnectionCacheEntry::removeAllConnections(this);
    v7 = (const __CFArray *)*((_QWORD *)this + 29);
    v8.length = CFArrayGetCount(v7);
    v8.location = 0;
    CFArrayApplyFunction(v7, v8, (CFArrayApplierFunction)RetainableTypedArray<STube *>::_invoke, &__block_literal_global_15700);
  }
}

uint64_t ___ZN25SHTTPConnectionCacheEntry19setHasBeenForgottenEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[5];

  v2 = *(_QWORD *)(a2 + 112);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN5STube6cancelEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 104))(v2, v4);
}

uint64_t SHTTPConnectionCacheEntry::invalidateUnpurgeableConnections(uint64_t this)
{
  uint64_t v1;
  CFArrayRef *v2;
  unint64_t v3;
  CFArrayRef *v4;
  unint64_t v5;
  uint64_t v6;

  v1 = this;
  v2 = *(CFArrayRef **)(this + 48);
  if (v2)
  {
    this = CFArrayGetCount(*v2);
    if (this >= 1)
    {
      v3 = this + 1;
      do
      {
        this = (uint64_t)CFArrayGetValueAtIndex(**(CFArrayRef **)(v1 + 48), v3 - 2);
        if (this)
          *(_QWORD *)(this + 296) = 0;
        --v3;
      }
      while (v3 > 1);
    }
  }
  v4 = *(CFArrayRef **)(v1 + 80);
  if (v4)
  {
    this = CFArrayGetCount(*v4);
    if (this >= 1)
    {
      v5 = this + 1;
      do
      {
        this = (uint64_t)CFArrayGetValueAtIndex(**(CFArrayRef **)(v1 + 80), v5 - 2);
        v6 = *(_QWORD *)(this + 24);
        if (v6)
          *(_QWORD *)(v6 + 296) = 0;
        --v5;
      }
      while (v5 > 1);
    }
  }
  return this;
}

CFStringRef NetworkProxy::copyDebugDesc(NetworkProxy *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;

  v2 = *((_QWORD *)this + 3);
  v3 = *((_QWORD *)this + 9);
  v4 = *((_QWORD *)this + 10);
  v5 = *((unsigned int *)this + 10);
  v6 = (*(uint64_t (**)(void))(*(_QWORD *)this + 24))();
  if (*((_BYTE *)this + 96))
    v7 = "T";
  else
    v7 = "F";
  return CFStringCreateWithFormat(0, 0, CFSTR("<NetworkProxy %p>{host = %@, port=%d, user=%@, pass=%@, type=%@, CONNECTProperties=%@, transparent=%s}"), this, v2, v5, v3, v4, v6, *((_QWORD *)this + 11), v7);
}

const __CFString *NetworkProxy::prettyType(NetworkProxy *this)
{
  return CFSTR("http");
}

CFTypeRef NetworkProxy::copyCONNECTProperties(NetworkProxy *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 11);
  if (result)
    return CFRetain(result);
  return result;
}

CFTypeRef NetworkProxy::copyCONNECTEndpointProperties(NetworkProxy *this)
{
  const __CFDictionary *v1;
  const void *Value;

  v1 = (const __CFDictionary *)*((_QWORD *)this + 11);
  if (v1 && (Value = CFDictionaryGetValue(v1, &unk_1EDD003E0)) != 0)
    return CFRetain(Value);
  else
    return 0;
}

void NetworkProxy::copyURL(NetworkProxy *this@<X0>, CFURLRef *a2@<X8>)
{
  uint64_t v4;
  const __CFString *v5;

  *a2 = 0;
  v4 = (*(uint64_t (**)(NetworkProxy *))(*(_QWORD *)this + 24))(this);
  v5 = CFStringCreateWithFormat(0, 0, CFSTR("%@://%@:%d/"), v4, *((_QWORD *)this + 3), *((unsigned int *)this + 10));
  if (v5)
  {
    *a2 = CFURLCreateWithString(0, v5, 0);
    CFRelease(v5);
  }
}

void sub_1840E918C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  const void *v2;

  CFRelease(v2);
  *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t NetworkProxy::getType(NetworkProxy *this)
{
  return 2;
}

void NetworkProxy::setEndpointHost(NetworkProxy *this, CFTypeRef cf)
{
  CFTypeRef v3;
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  __int128 v8;

  v3 = CFRetain(cf);
  *(_QWORD *)&v8 = v3;
  v4 = (_QWORD *)operator new();
  *v4 = &off_1E14F19E8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = v3;
  *((_QWORD *)&v8 + 1) = v4;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 48, &v8);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

uint64_t NetworkProxy::setEndpointPort(uint64_t this, int a2)
{
  *(_DWORD *)(this + 64) = a2;
  return this;
}

void NetworkProxy::establishProxyConnection(uint64_t a1, uint64_t *a2)
{
  std::__shared_weak_count *v3;
  uint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v6, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
  SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()(*a2, v6, v7, 0, 0, 0);
  v3 = v7;
  if (v7)
  {
    p_shared_owners = &v7->__shared_owners_;
    do
      v5 = __ldaxr((unint64_t *)p_shared_owners);
    while (__stlxr(v5 - 1, (unint64_t *)p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1840E92EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t NetworkProxy::proxyResponse(NetworkProxy *this)
{
  uint8_t v2[16];

  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Proxy response is not available", v2, 2u);
  }
  return 0;
}

uint64_t NetworkProxy::proxyResponseData(NetworkProxy *this)
{
  uint8_t v2[16];

  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Proxy response data is not available", v2, 2u);
  }
  return 0;
}

uint64_t NetworkProxy::NetworkProxy(uint64_t a1, _QWORD *a2)
{
  CFTypeRef v4;
  _QWORD *v5;
  CFTypeRef v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  CFTypeRef v10;
  CFTypeRef cf;

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &off_1E14E6108;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(*(_QWORD *)*a2 + 24))(&cf);
  v4 = cf;
  if (cf)
  {
    v5 = (_QWORD *)operator new();
    v6 = cf;
    *v5 = &off_1E14F19E8;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  cf = 0;
  v7 = *(std::__shared_weak_count **)(a1 + 32);
  *(_QWORD *)(a1 + 24) = v4;
  *(_QWORD *)(a1 + 32) = v5;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = cf;
  cf = 0;
  if (v10)
    CFRelease(v10);
  *(_DWORD *)(a1 + 40) = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 32))(*a2);
  return a1;
}

void sub_1840E94F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  const void **v13;
  const void *v15;
  const void *v16;
  const void *v17;
  std::__shared_weak_count *v18;

  if (cf)
    CFRelease(cf);
  v15 = (const void *)v10[11];
  v10[11] = 0;
  if (v15)
    CFRelease(v15);
  v16 = (const void *)v10[10];
  v10[10] = 0;
  if (v16)
    CFRelease(v16);
  v17 = *v13;
  *v13 = 0;
  if (v17)
    CFRelease(v17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11);
  *v10 = &off_1E14E5838;
  v18 = (std::__shared_weak_count *)v10[2];
  if (v18)
    std::__shared_weak_count::__release_weak(v18);
  _Unwind_Resume(a1);
}

void HTTPEngine::connErrorOccurred(CFStreamError *this, CFStreamError a2)
{
  if (!this[6].domain && !this[6].error)
    this[6] = a2;
  HTTPEngine::_cleanupConnection((HTTPEngine *)this, 0);
}

uint64_t HTTPEngine::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;

  v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (!v3)
    return 0;
  v5 = std::__shared_weak_count::lock(v3);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = *(_QWORD *)(a1 + 80);
  if (v7)
    v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 32))(v7, a2);
  else
    v8 = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  return v8;
}

void sub_1840E9664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'HTTPEngine::~HTTPEngine(HTTPEngine *this)
{
  HTTPEngine::~HTTPEngine((HTTPEngine *)((char *)this - 24));
}

{
  HTTPEngine::~HTTPEngine((HTTPEngine *)((char *)this - 24));
  JUMPOUT(0x186DB748CLL);
}

uint64_t HTTPEngine::HTTPEngineDelegate::alternatePathAvailable()
{
  return 0;
}

void std::__shared_ptr_emplace<ConnectionReadAggregator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0D70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ConnectionReadAggregator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0D70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void HTTPEngine::resetResponse(HTTPEngine *this)
{
  _OWORD *Instance;
  HTTPMessage *v3;
  _QWORD *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  __int128 v8;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v3 = (HTTPMessage *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v3 = (HTTPMessage *)(Instance + 1);
    Instance[18] = 0u;
    Instance[19] = 0u;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  HTTPMessage::HTTPMessage(v3, "httpresponse");
  *(_QWORD *)v3 = &off_1E14E9F38;
  *((_QWORD *)v3 + 1) = &unk_1E14E9FA8;
  *((_QWORD *)v3 + 2) = &unk_1E14E9FC8;
  *((_DWORD *)v3 + 32) = -1;
  *((_QWORD *)v3 + 17) = 0;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_BYTE *)v3 + 296) = 0;
  *(_QWORD *)&v8 = v3;
  v4 = (_QWORD *)operator new();
  *v4 = &off_1E14F1710;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = v3;
  *((_QWORD *)&v8 + 1) = v4;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 128, &v8);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void ___ZN10HTTPEngine12readResponseENSt3__110shared_ptrI18HTTPRequestMessageEEU13block_pointerFxvEU13block_pointerFvNS1_I19HTTPResponseMessageEE13CFStreamErrorEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectS8_bEU13block_pointerFvS7_E_block_invoke(uint64_t a1)
{
  HTTPEngine::_readHeadersFinish(*(std::__shared_weak_count ***)(a1 + 32), *(CFStreamError *)(a1 + 48));
}

__n128 __Block_byref_object_copy__15809(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

void HTTPEngine::_100ContinueProceed(HTTPEngine *this)
{
  if (*((_QWORD *)this + 18) == *((_QWORD *)this + 30))
  {
    HTTPEngine::_100ContinueTimerCancel(this);
    *((_DWORD *)this + 8) &= ~0x20u;
    HTTPEngine::_writeBodyStart(this);
  }
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_dispatch_data}*,HTTPEngine::_writeBodyPlain(NSObject  {objcproto16OS_dispatch_data}*,CFStreamError,BOOL)::$_0,std::allocator<NSObject  {objcproto16OS_dispatch_data}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void HTTPEngine::_chunkedWriteTrailer(HTTPEngine *this)
{
  uint64_t v2;
  const void *v3;
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  unint64_t Count;
  const void **v7;
  unint64_t v8;
  const void **v9;
  CFAllocatorRef *v10;
  uint64_t Instance;
  HTTPHeaderDict *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  const void *v17;
  BOOL v18;
  NSObject *v19;
  uint64_t v20;
  CFIndex v21;
  const __CFAllocator *v22;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  const __CFString *v25;
  const __CFString *v26;
  size_t Length;
  char *v28;
  dispatch_data_t v29;
  NSObject *v30;
  std::__shared_weak_count *v31;
  const void *v32;
  uint64_t v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  _QWORD v45[7];
  std::__shared_weak_count *v46;
  void (**v47)(StringSerializable *__hidden);
  CFTypeRef cf;
  CFTypeRef v49;
  uint64_t v50;
  void (*v51)(uint64_t, const __CFString *, const __CFArray *);
  _QWORD v52[31];
  CFTypeRef v53;
  uint64_t v54;
  const void **v55;
  _BYTE v56[248];
  HTTPHeaderDict *v57;
  std::__shared_weak_count *v58;
  __int128 buf;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v57 = 0;
  v58 = 0;
  v2 = *((_QWORD *)this + 32);
  v3 = (const void *)MEMORY[0x1E0C809B0];
  if (v2)
  {
    v4 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 32))(v2, 0x1EDCFA528);
    v5 = v4;
    if (!v4)
      goto LABEL_45;
    if (CFDictionaryGetCount(v4) > 0)
    {
      v49 = CFRetain(v5);
      Count = CFDictionaryGetCount(v5);
      v50 = Count;
      if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v51 = 0;
        goto LABEL_11;
      }
      if (Count > 0x1E)
      {
        v7 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
        v51 = (void (*)(uint64_t, const __CFString *, const __CFArray *))v7;
        if (!v7)
          goto LABEL_11;
      }
      else
      {
        v7 = (const void **)v52;
        v51 = (void (*)(uint64_t, const __CFString *, const __CFArray *))v52;
      }
      CFDictionaryGetKeysAndValues(v5, v7, 0);
LABEL_11:
      v53 = CFRetain(v5);
      v8 = CFDictionaryGetCount(v5);
      v54 = v8;
      if (v8 - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v55 = 0;
      }
      else
      {
        if (v8 <= 0x1E)
        {
          v9 = (const void **)v56;
          v55 = (const void **)v56;
LABEL_16:
          CFDictionaryGetKeysAndValues(v5, 0, v9);
          goto LABEL_17;
        }
        v9 = (const void **)malloc_type_malloc(8 * v8, 0x89ED541CuLL);
        v55 = v9;
        if (v9)
          goto LABEL_16;
      }
LABEL_17:
      v10 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
      if (v54 < 1)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v19 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v5;
          _os_log_impl(&dword_183ECA000, v19, OS_LOG_TYPE_DEFAULT, "chunkedTrailer: FOUND trailer-dict: %@, but it is empty.", (uint8_t *)&buf, 0xCu);
        }
        v12 = 0;
      }
      else
      {
        if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
          dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
        Instance = _CFRuntimeCreateInstance();
        v12 = (HTTPHeaderDict *)Instance;
        if (Instance)
        {
          *(_QWORD *)(Instance + 16) = 0;
          *(_QWORD *)(Instance + 24) = 0;
          v12 = (HTTPHeaderDict *)(Instance + 16);
        }
        HTTPHeaderDict::HTTPHeaderDict(v12);
        v13 = (std::__shared_weak_count *)operator new();
        v13->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1518;
        v13->__shared_owners_ = 0;
        v13->__shared_weak_owners_ = 0;
        v13[1].__vftable = (std::__shared_weak_count_vtbl *)v12;
        v57 = v12;
        v58 = v13;
        if (v12)
        {
          v14 = v54;
          if (v54 >= 1)
          {
            v15 = 0;
            do
            {
              v16 = (const __CFString *)*((_QWORD *)v51 + v15);
              v17 = v55[v15];
              if (v16)
                v18 = v17 == 0;
              else
                v18 = 1;
              if (!v18)
              {
                HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&buf, v16);
                HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue((HTTPHeaderValueMixedValue *)&v47, v17);
                HTTPHeaderDict::setValue((uint64_t)v12, (uint64_t)&buf, (uint64_t)&v47);
                v47 = &off_1E14E9A00;
                if (cf)
                  CFRelease(cf);
                *(_QWORD *)&buf = &off_1E14E9A00;
                if (*((_QWORD *)&buf + 1))
                  CFRelease(*((CFTypeRef *)&buf + 1));
                v14 = v54;
              }
              ++v15;
            }
            while (v15 < v14);
          }
        }
      }
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v53);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v49);
      CFRelease(v5);
      if (v12)
      {
        v20 = operator new();
        v21 = HTTPHeaderDict::sizeHeaders(v12);
        v22 = *v10;
        Mutable = CFDataCreateMutable(*v10, v21);
        *(_QWORD *)v20 = Mutable;
        CFDataSetLength(Mutable, v21);
        MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)v20);
        *(_QWORD *)(v20 + 8) = MutableBytePtr;
        *(_QWORD *)(v20 + 16) = &MutableBytePtr[v21];
        *(_QWORD *)(v20 + 24) = MutableBytePtr;
        v49 = v3;
        v50 = 3221225472;
        v51 = ___ZNK14HTTPHeaderDict16serializeHeadersEPNS_6BufferE_block_invoke;
        v52[0] = &__block_descriptor_48_e36_v24__0____CFString__8____CFArray__16l;
        v52[1] = v57;
        v52[2] = v20;
        HTTPHeaderDict::visitHeaders((uint64_t)v57, 1, (uint64_t)&v49);
        v25 = CFStringCreateWithFormat(v22, 0, CFSTR("0\r\n%s\r\n"), *(_QWORD *)(v20 + 8));
        v26 = v25;
        if (v25)
        {
          Length = CFStringGetLength(v25);
          v28 = (char *)operator new[]();
          CFStringGetCString(v26, v28, Length + 1, 0x600u);
          strnlen(v28, Length);
          CFRelease(v26);
        }
        std::default_delete<HTTPHeaderDict::Buffer>::operator()[abi:nn180100]((const void **)v20);
      }
      goto LABEL_44;
    }
    CFRelease(v5);
  }
LABEL_44:
  v5 = 0;
LABEL_45:
  v29 = dispatch_data_create("0\r\n\r\n", 5uLL, 0, 0);
  if (!v29)
    __assert_rtn("_chunkedWriteTrailer", "HTTPEngine.cpp", 3067, "trailerData");
  v30 = v29;
  *((_QWORD *)this + 35) += 5;
  HTTPEngine::_updateBytesTransferred(this);
  v49 = 0;
  v50 = 0;
  v31 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (v31 && (v31 = std::__shared_weak_count::lock(v31), (v50 = (uint64_t)v31) != 0))
  {
    v32 = (const void *)*((_QWORD *)this + 5);
    v49 = v32;
  }
  else
  {
    v32 = 0;
  }
  v33 = *((_QWORD *)this + 7);
  v45[0] = v3;
  v45[1] = 3321888768;
  v45[2] = ___ZN10HTTPEngine20_chunkedWriteTrailerEv_block_invoke;
  v45[3] = &__block_descriptor_64_e8_48c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e13_v24__0___qi_8l;
  v45[4] = this;
  v45[5] = 5;
  v45[6] = v32;
  v46 = v31;
  if (v31)
  {
    p_shared_owners = (unint64_t *)&v31->__shared_owners_;
    do
      v35 = __ldxr(p_shared_owners);
    while (__stxr(v35 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, NSObject *, _QWORD *))(*(_QWORD *)v33 + 48))(v33, v30, v45);
  dispatch_release(v30);
  v36 = v46;
  if (v46)
  {
    v37 = (unint64_t *)&v46->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  v39 = (std::__shared_weak_count *)v50;
  if (v50)
  {
    v40 = (unint64_t *)(v50 + 8);
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  if (v5)
    MEMORY[0x186DB7474](v5, 0x1000C8077774924);
  v42 = v58;
  if (v58)
  {
    v43 = (unint64_t *)&v58->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
}

void sub_1840E9F68()
{
  const void **v0;
  const void *v1;

  CFRelease(v1);
  std::default_delete<HTTPHeaderDict::Buffer>::operator()[abi:nn180100](v0);
}

void sub_1840E9FA0(_Unwind_Exception *a1)
{
  const void *v1;
  uint64_t v2;

  CFRelease(v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 128);
  _Unwind_Resume(a1);
}

void sub_1840E9FAC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x186DB748C](v1, 0x30C40E3C0B0CCLL);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 128);
  _Unwind_Resume(a1);
}

void sub_1840E9FD8()
{
  JUMPOUT(0x1840EA034);
}

void sub_1840E9FE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v12;
  va_list va;

  va_start(va, a12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  sub_1840EA04C();
}

void sub_1840E9FF8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf)
{
  uint64_t v20;
  uint64_t v21;
  const void *v22;

  *(_QWORD *)(v21 - 112) = v20;
  v22 = *(const void **)(v21 - 104);
  if (v22)
    CFRelease(v22);
  JUMPOUT(0x1840EA02CLL);
}

void sub_1840EA028(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  CFContainerEnumeratorBase *v21;

  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v21);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a21);
  JUMPOUT(0x1840EA03CLL);
}

void sub_1840EA04C()
{
  _Unwind_Exception *v0;
  uint64_t v1;
  uint64_t v2;

  if (v1)
    MEMORY[0x186DB7474](v1, 0x1000C8077774924);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 128);
  _Unwind_Resume(v0);
}

void std::default_delete<HTTPHeaderDict::Buffer>::operator()[abi:nn180100](const void **a1)
{
  const void *v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
    CFRelease(v2);
  JUMPOUT(0x186DB748CLL);
}

void ___ZN10HTTPEngine20_chunkedWriteTrailerEv_block_invoke(uint64_t a1, CFStreamError a2)
{
  uint64_t v2;
  HTTPEngine *v4;
  uint64_t v5;

  v2 = *(_QWORD *)&a2.error;
  if (a2.error)
  {
    v4 = *(HTTPEngine **)(a1 + 32);
    *((_QWORD *)v4 + 35) -= *(_QWORD *)(a1 + 40);
    HTTPEngine::_updateBytesTransferred(v4);
    v5 = 4294967292;
    a2.domain = 4;
  }
  else
  {
    v5 = 0;
  }
  *(_QWORD *)&a2.error = v5 | v2 & 0xFFFFFFFF00000000;
  HTTPEngine::_writeBodyFinish(*(HTTPEngine **)(a1 + 48), a2);
}

void std::__shared_ptr_pointer<HTTPHeaderDict *,HTTPEngine::_chunkedWriteTrailer(void)::$_0,std::allocator<HTTPHeaderDict>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<HTTPHeaderDict *,HTTPEngine::_chunkedWriteTrailer(void)::$_0,std::allocator<HTTPHeaderDict>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
    CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN10HTTPEngine26_chunkedWriteHeaderAndBodyEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke(uint64_t a1, CFIndex a2, uint64_t a3)
{
  HTTPEngine *v6;
  uint64_t v7;
  CFStreamError v8;

  v6 = *(HTTPEngine **)(a1 + 32);
  --*((_QWORD *)v6 + 34);
  if ((_DWORD)a3)
  {
    *((_QWORD *)v6 + 35) -= *(_QWORD *)(a1 + 40);
    HTTPEngine::_updateBytesTransferred(v6);
    v7 = *((_QWORD *)v6 + 41);
    if (v7)
      *(_QWORD *)(v7 + 112) -= *(_QWORD *)(a1 + 40);
  }
  if (*(_QWORD *)(a1 + 56))
    *(_QWORD *)&v8.error = *(_QWORD *)(a1 + 56);
  else
    *(_QWORD *)&v8.error = a3;
  if (v8.error)
  {
    if (*(_QWORD *)(a1 + 56))
      v8.domain = *(_QWORD *)(a1 + 48);
    else
      v8.domain = a2;
    HTTPEngine::_writeBodyFinish(v6, v8);
  }
  else if (*(_BYTE *)(a1 + 80))
  {
    HTTPEngine::_chunkedWriteTrailer(v6);
  }
  else if (*((uint64_t *)v6 + 34) <= 1)
  {
    HTTPEngine::_writeBodyResume(*(HTTPEngine **)(a1 + 64));
  }
}

uint64_t __copy_helper_block_e8_64c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(result + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(result + 72) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_64c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_dispatch_data}*,HTTPEngine::_chunkedWriteHeaderAndBody(NSObject  {objcproto16OS_dispatch_data}*,CFStreamError,BOOL)::$_0,std::allocator<NSObject  {objcproto16OS_dispatch_data}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_dispatch_data}*,HTTPEngine::_chunkedWriteHeaderAndBody(NSObject  {objcproto16OS_dispatch_data}*,CFStreamError,BOOL)::$_0,std::allocator<NSObject  {objcproto16OS_dispatch_data}>>::__on_zero_shared(uint64_t a1)
{
  NSObject *v1;

  v1 = *(NSObject **)(a1 + 24);
  if (v1)
    dispatch_release(v1);
}

dispatch_data_t ___ZL13_enchunkulatePU27objcproto16OS_dispatch_data8NSObject_block_invoke()
{
  dispatch_data_t result;

  result = dispatch_data_create("\r\n", 2uLL, 0, 0);
  _enchunkulate(NSObject  {objcproto16OS_dispatch_data}*)::chunkTrailer = (uint64_t)result;
  return result;
}

void __Block_byref_object_copy__28(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__29(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_32(_QWORD *a1, dispatch_data_t data, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v11;
  dispatch_data_t concat;
  NSObject *v13;

  v9 = a1[8];
  if ((_DWORD)a5)
  {
    if (!data || !dispatch_data_get_size(data))
    {
      v11 = *(_QWORD *)(a1[5] + 8);
      *(_QWORD *)(v11 + 48) = a4;
      *(_QWORD *)(v11 + 56) = a5;
      goto LABEL_9;
    }
  }
  else if (!data)
  {
    if ((*(_BYTE *)(v9 + 32) & 8) != 0)
    {
      *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
      if (*(_QWORD *)(a1[9] + 192))
        goto LABEL_14;
      goto LABEL_15;
    }
    goto LABEL_7;
  }
  *(_QWORD *)(v9 + 168) += dispatch_data_get_size(data);
LABEL_7:
  if (a3)
    *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
LABEL_9:
  if (*(_QWORD *)(a1[9] + 192))
  {
    if (data)
    {
      concat = dispatch_data_create_concat(*(dispatch_data_t *)(v9 + 192), data);
      dispatch_release(*(dispatch_object_t *)(v9 + 192));
      *(_QWORD *)(v9 + 192) = 0;
      *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 40) = concat;
      return (*(uint64_t (**)(void))(a1[4] + 16))();
    }
LABEL_14:
    *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 40) = *(_QWORD *)(v9 + 192);
    *(_QWORD *)(v9 + 192) = 0;
    return (*(uint64_t (**)(void))(a1[4] + 16))();
  }
LABEL_15:
  *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 40) = data;
  v13 = *(NSObject **)(*(_QWORD *)(a1[7] + 8) + 40);
  if (v13)
    dispatch_retain(v13);
  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

uint64_t ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_33(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_34(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t HTTPEngine::_chunkedParseHeader_skipToken(NSObject *this, int64_t a2)
{
  int64_t v2;
  int64_t size;
  NSObject *subrange;
  _QWORD v7[6];
  _QWORD v8[3];
  char v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int64_t v13;

  v2 = a2;
  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = a2;
  size = dispatch_data_get_size(this);
  if (size > v2)
  {
    subrange = dispatch_data_create_subrange(this, v2, size - v2);
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x2020000000;
    v9 = 1;
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZN10HTTPEngine29_chunkedParseHeader_skipTokenEl_block_invoke;
    v7[3] = &unk_1E14FD160;
    v7[4] = v8;
    v7[5] = &v10;
    dispatch_data_apply(subrange, v7);
    if (subrange)
      dispatch_release(subrange);
    v2 = v11[3];
    _Block_object_dispose(v8, 8);
  }
  _Block_object_dispose(&v10, 8);
  return v2;
}

uint64_t HTTPEngine::_chunkedParseHeader_skipQuotedString(NSObject *this, size_t a2)
{
  int64_t v4;
  int64_t size;
  NSObject *subrange;
  _QWORD v8[6];
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  size_t v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v4 = a2 + 1;
  v14 = a2 + 1;
  size = dispatch_data_get_size(this);
  if (v4 < size)
  {
    subrange = dispatch_data_create_subrange(this, a2, size - a2);
    v9[0] = 0;
    v9[1] = v9;
    v9[2] = 0x2020000000;
    v10 = 1;
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___ZN10HTTPEngine36_chunkedParseHeader_skipQuotedStringEl_block_invoke;
    v8[3] = &unk_1E14FD160;
    v8[4] = v9;
    v8[5] = &v11;
    dispatch_data_apply(subrange, v8);
    if (subrange)
      dispatch_release(subrange);
    v4 = v12[3];
    _Block_object_dispose(v9, 8);
  }
  _Block_object_dispose(&v11, 8);
  return v4;
}

uint64_t ___ZN10HTTPEngine36_chunkedParseHeader_skipQuotedStringEl_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v8;

  v5 = 0;
  if (a5)
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(unsigned __int8 *)(v6 + 24);
    while (1)
    {
      if (!v7)
        goto LABEL_10;
      v8 = *(unsigned __int8 *)(a4 + v5);
      if (v8 == 92)
        break;
      if (v8 != 34)
        goto LABEL_8;
      ++v5;
      *(_BYTE *)(v6 + 24) = 0;
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v7 = *(unsigned __int8 *)(v6 + 24);
LABEL_9:
      v5 += v7;
      if (v5 >= a5)
        goto LABEL_10;
    }
    ++v5;
LABEL_8:
    v7 = 1;
    goto LABEL_9;
  }
LABEL_10:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v5;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t ___ZN10HTTPEngine29_chunkedParseHeader_skipTokenEl_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  uint64_t v10;
  BOOL v11;

  v5 = 0;
  while (v5 < a5)
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (!*(_BYTE *)(v6 + 24))
      break;
    if ((v7 = *(unsigned __int8 *)(a4 + v5), v8 = v7 - 32, v7 < 0x20)
      || v7 == 127
      || ((v9 = v8 > 0x3D, v10 = (1 << v8) & 0x38000001FC009305, !v9) ? (v11 = v10 == 0) : (v11 = 1),
          !v11 || v7 == 123 || v7 == 125))
    {
      *(_BYTE *)(v6 + 24) = 0;
    }
    else
    {
      ++v5;
    }
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v5;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void HTTPEngine::_chunkedReadTrailerDoRead(_QWORD *a1, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  _QWORD v20[5];
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;

  if (a1[24])
    __assert_rtn("_chunkedReadTrailerDoRead", "HTTPEngine.cpp", 2813, "!_inData");
  v24 = 0;
  v25 = 0;
  v4 = (std::__shared_weak_count *)a1[6];
  if (v4 && (v4 = std::__shared_weak_count::lock(v4), (v25 = v4) != 0))
  {
    v5 = a1[5];
    v24 = v5;
  }
  else
  {
    v5 = 0;
  }
  v20[0] = MEMORY[0x1E0C809B0];
  v20[1] = 3321888768;
  v20[2] = ___ZN10HTTPEngine25_chunkedReadTrailerDoReadENSt3__110shared_ptrI19HTTPResponseMessageEE_block_invoke;
  v20[3] = &__block_descriptor_64_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE48c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE_e16_v28__0___qi_8B24l;
  v20[4] = v5;
  v21 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (std::__shared_weak_count *)a2[1];
  v22 = *a2;
  v23 = v8;
  if (v8)
  {
    v9 = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  HTTPEngine::_readBlob((uint64_t)a1, 0x4000, (uint64_t)v20);
  v11 = v23;
  if (v23)
  {
    v12 = (unint64_t *)&v23->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v21;
  if (v21)
  {
    v15 = (unint64_t *)&v21->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v25;
  if (v25)
  {
    v18 = (unint64_t *)&v25->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void sub_1840EA8C0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 48);
  _Unwind_Resume(a1);
}

void ___ZN10HTTPEngine25_chunkedReadTrailerDoReadENSt3__110shared_ptrI19HTTPResponseMessageEE_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD v11[2];

  v5 = a1[4];
  v6 = (std::__shared_weak_count *)a1[7];
  v11[0] = a1[6];
  v11[1] = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  HTTPEngine::_chunkedReadTrailerDoParse(v5, v11, a2, a3, a4);
  if (v6)
  {
    v9 = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1840EA980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE48c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE48c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

uint64_t __copy_helper_block_e8_40c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void ___ZN10HTTPEngine12suspendReadsEb_block_invoke(uint64_t a1)
{
  HTTPEngine::_readHeadersDoRead(*(HTTPEngine **)(a1 + 32));
}

void ___ZN10HTTPEngine12suspendReadsEb_block_invoke_14(uint64_t a1)
{
  HTTPEngine::_readBodyStartNextRead(*(HTTPEngine **)(a1 + 32));
}

void ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke(uint64_t a1)
{
  HTTPEngine::_writeFinish(*(HTTPEngine **)(a1 + 32), *(CFStreamError *)(a1 + 48));
}

void ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke_2(uint64_t a1)
{
  HTTPEngine::_writeFinish(*(HTTPEngine **)(a1 + 32), *(CFStreamError *)(a1 + 48));
}

void ___ZN10HTTPEngine22_100ContinueTimerStartEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  HTTPEngine *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(std::__shared_weak_count **)(v1 + 48);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(HTTPEngine **)(v1 + 40);
      if (v5)
      {
        if ((*((_BYTE *)v5 + 32) & 0x20) == 0)
          __assert_rtn("_100ContinueTimerFired", "HTTPEngine.cpp", 3211, "false");
        HTTPEngine::_100ContinueTimerCancel(v5);
        *((_DWORD *)v5 + 8) &= ~0x20u;
        HTTPEngine::_writeBodyStart(v5);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1840EAB28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTPEngine::suspendWrites(HTTPEngine *this, int a2)
{
  int v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  NSObject *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[5];
  std::__shared_weak_count *v16;

  v3 = *((_DWORD *)this + 8);
  if (a2)
  {
    *((_DWORD *)this + 8) = v3 | 0x2000000;
  }
  else
  {
    *((_DWORD *)this + 8) = v3 & 0xFDFFFFFF;
    if ((~v3 & 0x6000000) == 0)
    {
      *((_DWORD *)this + 8) = v3 & 0xF9FFFFFF;
      v4 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
      if (v4)
      {
        v5 = std::__shared_weak_count::lock(v4);
        if (v5)
          v6 = *((_QWORD *)this + 5);
        else
          v6 = 0;
      }
      else
      {
        v6 = 0;
        v5 = 0;
      }
      v7 = *((_QWORD *)this + 9);
      v15[0] = MEMORY[0x1E0C809B0];
      v15[1] = 3321888768;
      v15[2] = ___ZN10HTTPEngine13suspendWritesEb_block_invoke;
      v15[3] = &__block_descriptor_48_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
      v15[4] = v6;
      v16 = v5;
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v9 = __ldxr(p_shared_owners);
        while (__stxr(v9 + 1, p_shared_owners));
      }
      dispatch_async(v7, v15);
      v10 = v16;
      if (v16)
      {
        v11 = (unint64_t *)&v16->__shared_owners_;
        do
          v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
      if (v5)
      {
        v13 = (unint64_t *)&v5->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }
}

void ___ZN10HTTPEngine13suspendWritesEb_block_invoke(uint64_t a1)
{
  HTTPEngine::_writeHeadersStart(*(HTTPEngine **)(a1 + 32));
}

void AuthBrokerAgentClient::cachedProxyCredentialForProtectionSpace(AuthBrokerAgentClient *this, _CFURLProtectionSpace *a2)
{
  _QWORD *LocalCredCache;
  const void *Value;
  const void *v6;

  *(_QWORD *)this = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&_LocalCredCacheLock);
  LocalCredCache = _GetLocalCredCache();
  Value = CFDictionaryGetValue((CFDictionaryRef)LocalCredCache[1], a2);
  v6 = Value;
  if (Value)
    (*(void (**)(const void *))(*(_QWORD *)Value + 40))(Value);
  *(_QWORD *)this = v6;
  os_unfair_lock_unlock((os_unfair_lock_t)&_LocalCredCacheLock);
}

void sub_1840EACE8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  os_unfair_lock_unlock((os_unfair_lock_t)&_LocalCredCacheLock);
  *v1 = 0;
  _Unwind_Resume(a1);
}

_QWORD *_GetLocalCredCache(void)
{
  _QWORD *v0;
  const __CFAllocator *v1;

  v0 = (_QWORD *)_LocalCredCache;
  if (!_LocalCredCache)
  {
    v0 = (_QWORD *)operator new();
    v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *v0 = &off_1E14EA368;
    v0[1] = CFDictionaryCreateMutable(v1, 0, MEMORY[0x1E0C9B390], &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
    _LocalCredCache = (uint64_t)v0;
  }
  return v0;
}

void sub_1840EAD80(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void _AuthBrokerSetCachedCredential(_CFURLProtectionSpace *a1, NetworkProxyCredential *a2)
{
  _QWORD *LocalCredCache;

  os_unfair_lock_lock((os_unfair_lock_t)&_LocalCredCacheLock);
  LocalCredCache = _GetLocalCredCache();
  if (a2)
    CFDictionarySetValue((CFMutableDictionaryRef)LocalCredCache[1], a1, a2);
  else
    CFDictionaryRemoveValue((CFMutableDictionaryRef)LocalCredCache[1], a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&_LocalCredCacheLock);
}

void sub_1840EAE04(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&_LocalCredCacheLock);
  _Unwind_Resume(a1);
}

char *AuthBrokerAgentClient::AuthBrokerIsAvailable(AuthBrokerAgentClient *this)
{
  char *result;

  if (_AuthBrokerGetServiceName(void)::onceToken != -1)
    dispatch_once(&_AuthBrokerGetServiceName(void)::onceToken, &__block_literal_global_16792);
  result = (char *)objc_msgSend((id)_AuthBrokerGetServiceName(void)::serviceName, "UTF8String");
  if (result)
    return (char *)(__CFNIsMachServiceReachable(result) != 0);
  return result;
}

void AuthBrokerAgentClient::FetchProxyCredentials(uint64_t a1, uint64_t *a2)
{
  const void *v4;
  __CFError *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  NSObject *v8;
  const __CFAllocator *v9;
  __CFDictionary *Mutable;
  CFAllocatorRef *v11;
  __CFDictionary *SerializedCredential;
  uint64_t v13;
  void *v14;
  CFIndex v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  void (*v19)(_QWORD *, uint64_t);
  uint64_t v20;
  _QWORD *v21;
  CFNumberRef v22;
  CFNumberRef v23;
  void *v24;
  CFNumberRef v25;
  CFDictionaryRef v26;
  const char **v27;
  CFStringRef v28;
  const void *v29;
  CFDataRef Data;
  std::__shared_weak_count *v31;
  NSObject *v32;
  uint64_t v33;
  void (*v34)(_QWORD *, _QWORD);
  uint64_t v35;
  _QWORD *v36;
  const void *v37;
  std::__shared_weak_count_vtbl *v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  id v41;
  void *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  void *v47;
  unint64_t v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  unint64_t *v71;
  unint64_t v72;
  unint64_t *v73;
  unint64_t v74;
  __CFError *v75;
  uint64_t *v76;
  _QWORD v77[6];
  std::__shared_weak_count *v78;
  std::__shared_weak_count_vtbl *v79;
  std::__shared_weak_count *v80;
  uint64_t v81;
  std::__shared_weak_count *v82;
  _QWORD v83[6];
  std::__shared_weak_count *v84;
  uint64_t v85;
  std::__shared_weak_count *v86;
  CFDataRef v87;
  std::__shared_weak_count *v88;
  _QWORD v89[2];
  void (*v90)(uint64_t);
  void *v91;
  uint64_t v92;
  CFErrorRef error[2];
  std::__shared_weak_count *v94;
  int valuePtr;
  void *values[2];
  __int128 v97;
  uint64_t v98;
  _QWORD buf[8];

  buf[5] = *MEMORY[0x1E0C80C00];
  v4 = *(const void **)(a1 + 72);
  if (v4)
    v5 = (__CFError *)CFRetain(v4);
  else
    v5 = 0;
  error[1] = v5;
  v6 = (std::__shared_weak_count *)operator new();
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
  v6->__shared_weak_owners_ = 0;
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)v5;
  v94 = v6;
  v76 = a2;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v8 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf[0]) = 138543362;
    *(_QWORD *)((char *)buf + 4) = v5;
    _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "Fetching proxy credential for %{public}@", (uint8_t *)buf, 0xCu);
  }
  v75 = v5;
  if (*(_QWORD *)(a1 + 40))
  {
    _AuthBrokerSetCachedCredential(*(_CFURLProtectionSpace **)(a1 + 48), 0);
    goto LABEL_10;
  }
  AuthBrokerAgentClient::cachedProxyCredentialForProtectionSpace((AuthBrokerAgentClient *)buf, *(_CFURLProtectionSpace **)(a1 + 48));
  v16 = buf[0];
  if (!buf[0])
  {
LABEL_10:
    error[0] = 0;
    v89[0] = MEMORY[0x1E0C809B0];
    v89[1] = 3221225472;
    v90 = ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke;
    v91 = &__block_descriptor_40_e5_v8__0l;
    v92 = 0;
    v9 = *(const __CFAllocator **)(a1 + 8);
    Mutable = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v11 = *(CFAllocatorRef **)(a1 + 40);
    if (v11)
    {
      SerializedCredential = NetworkProxyCredential::createSerializedCredential(v11);
      CFDictionaryAddValue(Mutable, CFSTR("kNetworkProxyAuthorizationElementsKeyCredential"), SerializedCredential);
      CFRelease(SerializedCredential);
    }
    v13 = *(_QWORD *)(a1 + 48);
    if (!v13)
    {
LABEL_47:
      if (os_variant_has_internal_ui())
      {
        v27 = (const char **)_CFGetProgname();
        if (v27)
        {
          if (*v27)
          {
            v28 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *v27, 0x8000100u);
            if (v28)
            {
              CFDictionaryAddValue(Mutable, CFSTR("kNetworkProxyAuthorizationElementsKeyClientProcessName"), v28);
              CFRelease(v28);
            }
          }
        }
      }
      v29 = *(const void **)(a1 + 72);
      if (v29)
        CFDictionaryAddValue(Mutable, CFSTR("kNetworkProxyAuthorizationElementsKeyClientDescription"), v29);
      Data = CFPropertyListCreateData(*(CFAllocatorRef *)(a1 + 8), Mutable, kCFPropertyListBinaryFormat_v1_0, 0, error);
      CFRelease(Mutable);
      v87 = Data;
      v31 = (std::__shared_weak_count *)operator new();
      v31->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A90;
      v31->__shared_owners_ = 0;
      v31->__shared_weak_owners_ = 0;
      v31[1].__vftable = (std::__shared_weak_count_vtbl *)Data;
      v88 = v31;
      if (error[0])
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v32 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf[0]) = 138543618;
          *(_QWORD *)((char *)buf + 4) = v75;
          WORD2(buf[1]) = 2112;
          *(CFErrorRef *)((char *)&buf[1] + 6) = error[0];
          _os_log_error_impl(&dword_183ECA000, v32, OS_LOG_TYPE_ERROR, "Failed to create ABQuery data %{public}@ error %@", (uint8_t *)buf, 0x16u);
        }
        v33 = *v76;
        if (*v76)
        {
          v34 = *(void (**)(_QWORD *, _QWORD))(v33 + 8);
          v35 = *(_QWORD *)(v33 + 16);
          v36 = (_QWORD *)(v33 + (v35 >> 1));
          if ((v35 & 1) != 0)
            v34 = *(void (**)(_QWORD *, _QWORD))(*v36 + v34);
          v34(v36, 0);
        }
      }
      else
      {
        v37 = *(const void **)(a1 + 48);
        if (v37)
          v38 = (std::__shared_weak_count_vtbl *)CFRetain(v37);
        else
          v38 = 0;
        buf[0] = v38;
        v39 = (std::__shared_weak_count *)operator new();
        v39->__shared_owners_ = 0;
        v40 = (unint64_t *)&v39->__shared_owners_;
        v39->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1780;
        v39->__shared_weak_owners_ = 0;
        v39[1].__vftable = v38;
        buf[1] = v39;
        v41 = objc_alloc(MEMORY[0x1E0CB3B38]);
        if (_AuthBrokerGetServiceName(void)::onceToken != -1)
          dispatch_once(&_AuthBrokerGetServiceName(void)::onceToken, &__block_literal_global_16792);
        v42 = (void *)objc_msgSend(v41, "initWithMachServiceName:options:", _AuthBrokerGetServiceName(void)::serviceName, 0);
        objc_msgSend(v42, "setRemoteObjectInterface:", objc_msgSend(MEMORY[0x1E0CB3B50], "interfaceWithProtocol:", &unk_1EDD19648));
        objc_msgSend(v42, "resume");
        v83[0] = MEMORY[0x1E0C809B0];
        v83[1] = 3321888768;
        v83[2] = ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_7;
        v83[3] = &unk_1E14F42D0;
        v83[5] = v75;
        v84 = v6;
        do
          v43 = __ldxr(p_shared_owners);
        while (__stxr(v43 + 1, p_shared_owners));
        v44 = (std::__shared_weak_count *)v76[1];
        v85 = *v76;
        v86 = v44;
        if (v44)
        {
          v45 = (unint64_t *)&v44->__shared_owners_;
          do
            v46 = __ldxr(v45);
          while (__stxr(v46 + 1, v45));
        }
        v83[4] = v42;
        v47 = (void *)objc_msgSend(v42, "remoteObjectProxyWithErrorHandler:", v83);
        v77[0] = MEMORY[0x1E0C809B0];
        v77[1] = 3321888768;
        v77[2] = ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_9;
        v77[3] = &unk_1E14F47F8;
        v77[5] = v75;
        v78 = v6;
        do
          v48 = __ldxr(p_shared_owners);
        while (__stxr(v48 + 1, p_shared_owners));
        v79 = v38;
        v80 = v39;
        do
          v49 = __ldxr(v40);
        while (__stxr(v49 + 1, v40));
        v50 = (std::__shared_weak_count *)v76[1];
        v81 = *v76;
        v82 = v50;
        if (v50)
        {
          v51 = (unint64_t *)&v50->__shared_owners_;
          do
            v52 = __ldxr(v51);
          while (__stxr(v52 + 1, v51));
        }
        v77[4] = v42;
        objc_msgSend(v47, "fetchProxyCredential:reply:", Data, v77);
        v53 = v82;
        if (v82)
        {
          v54 = (unint64_t *)&v82->__shared_owners_;
          do
            v55 = __ldaxr(v54);
          while (__stlxr(v55 - 1, v54));
          if (!v55)
          {
            ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
            std::__shared_weak_count::__release_weak(v53);
          }
        }
        v56 = v80;
        if (v80)
        {
          v57 = (unint64_t *)&v80->__shared_owners_;
          do
            v58 = __ldaxr(v57);
          while (__stlxr(v58 - 1, v57));
          if (!v58)
          {
            ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
            std::__shared_weak_count::__release_weak(v56);
          }
        }
        v59 = v78;
        if (v78)
        {
          v60 = (unint64_t *)&v78->__shared_owners_;
          do
            v61 = __ldaxr(v60);
          while (__stlxr(v61 - 1, v60));
          if (!v61)
          {
            ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
            std::__shared_weak_count::__release_weak(v59);
          }
        }
        v62 = v86;
        if (v86)
        {
          v63 = (unint64_t *)&v86->__shared_owners_;
          do
            v64 = __ldaxr(v63);
          while (__stlxr(v64 - 1, v63));
          if (!v64)
          {
            ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
            std::__shared_weak_count::__release_weak(v62);
          }
        }
        v65 = v84;
        if (v84)
        {
          v66 = (unint64_t *)&v84->__shared_owners_;
          do
            v67 = __ldaxr(v66);
          while (__stlxr(v67 - 1, v66));
          if (!v67)
          {
            ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
            std::__shared_weak_count::__release_weak(v65);
          }
        }
        v68 = (std::__shared_weak_count *)buf[1];
        if (buf[1])
        {
          v69 = (unint64_t *)(buf[1] + 8);
          do
            v70 = __ldaxr(v69);
          while (__stlxr(v70 - 1, v69));
          if (!v70)
          {
            ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
            std::__shared_weak_count::__release_weak(v68);
          }
        }
        v31 = v88;
        if (!v88)
        {
LABEL_115:
          v90((uint64_t)v89);
          v6 = v94;
          if (!v94)
            return;
          goto LABEL_116;
        }
      }
      v71 = (unint64_t *)&v31->__shared_owners_;
      do
        v72 = __ldaxr(v71);
      while (__stlxr(v72 - 1, v71));
      if (!v72)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
      goto LABEL_115;
    }
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
    memset(buf, 0, 40);
    v98 = 0;
    *(_OWORD *)values = 0u;
    v97 = 0u;
    v14 = *(void **)(v13 + 48);
    if (v14)
    {
      buf[0] = CFSTR("kCFURLProtectionSpaceKeyHost");
      values[0] = v14;
      v15 = 1;
    }
    else
    {
      v15 = 0;
    }
    if (*(_DWORD *)(v13 + 56))
    {
      *(_QWORD *)((unint64_t)buf | (8 * v15)) = CFSTR("kCFURLProtectionSpaceKeyPort");
      v22 = CFNumberCreate(v9, kCFNumberSInt32Type, (const void *)(v13 + 56));
      *(_QWORD *)((unint64_t)values | (8 * v15++)) = v22;
    }
    else
    {
      v22 = 0;
    }
    if (*(_DWORD *)(v13 + 60))
    {
      valuePtr = *(_DWORD *)(v13 + 60);
      v23 = CFNumberCreate(v9, kCFNumberSInt32Type, &valuePtr);
      buf[v15] = CFSTR("kCFURLProtectionSpaceKeyServerType");
      values[v15++] = v23;
    }
    else
    {
      v23 = 0;
    }
    v24 = *(void **)(v13 + 64);
    if (v24)
    {
      buf[v15] = CFSTR("kCFURLProtectionSpaceKeyRealm");
      values[v15++] = v24;
    }
    if (*(_DWORD *)(v13 + 72))
    {
      valuePtr = *(_DWORD *)(v13 + 72);
      v25 = CFNumberCreate(v9, kCFNumberSInt32Type, &valuePtr);
      buf[v15] = CFSTR("kCFURLProtectionSpaceKeyAuthenticationScheme");
      values[v15++] = v25;
    }
    else
    {
      v25 = 0;
      v26 = 0;
      if (!v15)
      {
LABEL_40:
        if (v22)
          CFRelease(v22);
        if (v23)
          CFRelease(v23);
        if (v25)
          CFRelease(v25);
        CFDictionaryAddValue(Mutable, CFSTR("kNetworkProxyAuthorizationElementsKeyProtectionSpace"), v26);
        CFRelease(v26);
        goto LABEL_47;
      }
    }
    v26 = CFDictionaryCreate(v9, (const void **)buf, (const void **)values, v15, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_40;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v17 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf[0]) = 134218242;
    *(_QWORD *)((char *)buf + 4) = v16;
    WORD2(buf[1]) = 2114;
    *(_QWORD *)((char *)&buf[1] + 6) = v75;
    _os_log_impl(&dword_183ECA000, v17, OS_LOG_TYPE_DEFAULT, "Found cached proxy cred %p for %{public}@", (uint8_t *)buf, 0x16u);
  }
  v18 = *v76;
  if (*v76)
  {
    v19 = *(void (**)(_QWORD *, uint64_t))(v18 + 8);
    v20 = *(_QWORD *)(v18 + 16);
    v21 = (_QWORD *)(v18 + (v20 >> 1));
    if ((v20 & 1) != 0)
      v19 = *(void (**)(_QWORD *, uint64_t))(*v21 + v19);
    v19(v21, v16);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v16 + 48))(v16);
LABEL_116:
  v73 = (unint64_t *)&v6->__shared_owners_;
  do
    v74 = __ldaxr(v73);
  while (__stlxr(v74 - 1, v73));
  if (!v74)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_1840EB840(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 232);
  _Unwind_Resume(a1);
}

void ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_7(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  void (*v6)(_QWORD *, _QWORD);
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v9 = *(_QWORD *)(a1 + 40);
    if (_AuthBrokerGetServiceName(void)::onceToken != -1)
    {
      v10 = *(_QWORD *)(a1 + 40);
      dispatch_once(&_AuthBrokerGetServiceName(void)::onceToken, &__block_literal_global_16792);
      v9 = v10;
    }
    *(_DWORD *)buf = 138543874;
    v12 = v9;
    v13 = 2112;
    v14 = _AuthBrokerGetServiceName(void)::serviceName;
    v15 = 2112;
    v16 = a2;
    _os_log_error_impl(&dword_183ECA000, v4, OS_LOG_TYPE_ERROR, "%{public}@ failed to connect to %@ XPC error %@", buf, 0x20u);
  }
  v5 = *(_QWORD *)(a1 + 56);
  if (v5)
  {
    v6 = *(void (**)(_QWORD *, _QWORD))(v5 + 8);
    v7 = *(_QWORD *)(v5 + 16);
    v8 = (_QWORD *)(v5 + (v7 >> 1));
    if ((v7 & 1) != 0)
      v6 = *(void (**)(_QWORD *, _QWORD))(*v8 + v6);
    v6(v8, 0);
  }
  objc_msgSend(*(id *)(a1 + 32), "invalidate");

}

uint64_t ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_9(uint64_t a1, const __CFData *a2)
{
  const __CFDictionary *v3;
  NSObject *v4;
  _QWORD *v5;
  _CFURLProtectionSpace *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(_QWORD *, _QWORD *);
  uint64_t v11;
  _QWORD *v12;
  uint64_t v14;
  _QWORD v15[2];
  void (*v16)(uint64_t);
  void *v17;
  uint64_t v18;
  CFErrorRef error;
  _QWORD v20[2];
  uint64_t (*v21)(uint64_t);
  void *v22;
  uint64_t v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  CFErrorRef v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v20[0] = MEMORY[0x1E0C809B0];
  v20[1] = 3221225472;
  v21 = ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_2;
  v22 = &__block_descriptor_40_e5_v8__0l;
  v23 = 0;
  if (a2)
  {
    v18 = 0;
    error = 0;
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v16 = ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_3;
    v17 = &__block_descriptor_40_e5_v8__0l;
    v3 = (const __CFDictionary *)CFPropertyListCreateWithData(0, a2, 0, 0, &error);
    if (error)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v4 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v14 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)buf = 138543618;
        v25 = v14;
        v26 = 2112;
        v27 = error;
        _os_log_error_impl(&dword_183ECA000, v4, OS_LOG_TYPE_ERROR, "%{public}@ failed to deserialize data error %@", buf, 0x16u);
      }
      v5 = 0;
    }
    else
    {
      v5 = CFAllocatorAllocate(0, 56, 0);
      v5[6] = 0;
      *((_OWORD *)v5 + 1) = 0u;
      *((_OWORD *)v5 + 2) = 0u;
      *(_OWORD *)v5 = 0u;
      NetworkProxyCredential::NetworkProxyCredential((NetworkProxyCredential *)v5, 0, v3);
      v6 = *(_CFURLProtectionSpace **)(a1 + 56);
      if (v6)
        _AuthBrokerSetCachedCredential(v6, (NetworkProxyCredential *)v5);
    }
    if (v3)
      CFRelease(v3);
    v16((uint64_t)v15);
  }
  else
  {
    v5 = 0;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 138543618;
    v25 = v8;
    v26 = 2048;
    v27 = (CFErrorRef)v5;
    _os_log_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@ done fetching proxy credential %p", buf, 0x16u);
  }
  v9 = *(_QWORD *)(a1 + 72);
  if (v9)
  {
    v10 = *(void (**)(_QWORD *, _QWORD *))(v9 + 8);
    v11 = *(_QWORD *)(v9 + 16);
    v12 = (_QWORD *)(v9 + (v11 >> 1));
    if ((v11 & 1) != 0)
      v10 = *(void (**)(_QWORD *, _QWORD *))(*v12 + v10);
    v10(v12, v5);
  }
  objc_msgSend(*(id *)(a1 + 32), "invalidate");

  return v21((uint64_t)v20);
}

void sub_1840EBCC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *), uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void (*a18)(char *))
{
  const void *v18;

  if (v18)
    CFRelease(v18);
  a12(&a10);
  a18(&a16);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_40c39_ZTSNSt3__110shared_ptrIK10__CFStringEE56c49_ZTSNSt3__110shared_ptrI21_CFURLProtectionSpaceEE72c53_ZTS18SmartBlockWithArgsIJP22NetworkProxyCredentialEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[10];
  result[9] = a2[9];
  result[10] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c39_ZTSNSt3__110shared_ptrIK10__CFStringEE56c49_ZTSNSt3__110shared_ptrI21_CFURLProtectionSpaceEE72c53_ZTS18SmartBlockWithArgsIJP22NetworkProxyCredentialEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = a1 + 40;
  v2 = a1 + 56;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 72);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

uint64_t ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_2(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

void ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_3(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

_QWORD *__copy_helper_block_e8_40c39_ZTSNSt3__110shared_ptrIK10__CFStringEE56c53_ZTS18SmartBlockWithArgsIJP22NetworkProxyCredentialEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c39_ZTSNSt3__110shared_ptrIK10__CFStringEE56c53_ZTS18SmartBlockWithArgsIJP22NetworkProxyCredentialEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 40;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void CFNetworkReadStream::~CFNetworkReadStream(CFNetworkReadStream *this)
{
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
}

{
  *(_QWORD *)this = &off_1E14E5838;
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x186DB748CLL);
}

CFStringRef CFNetworkReadStream::copyDescription(CFNetworkReadStream *this, CFTypeRef cf)
{
  const __CFAllocator *v3;

  v3 = CFGetAllocator(cf);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFNetworkReadStream@%p>"), this);
}

uint64_t CFNetworkReadStream::_streamImpl_Open(CFNetworkReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a4 = 0;
  return 0;
}

uint64_t CFNetworkReadStream::_streamImpl_OpenCompleted(CFNetworkReadStream *this, __CFReadStream *a2, CFStreamError *a3)
{
  return 0;
}

uint64_t CFNetworkReadStream::_streamImpl_Read(CFNetworkReadStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  return -1;
}

uint64_t CFNetworkReadStream::_streamImpl_CanRead(CFNetworkReadStream *this, __CFReadStream *a2)
{
  return 0;
}

uint64_t CFNetworkReadStream::_streamImpl_CopyProperty(CFNetworkReadStream *this, __CFReadStream *a2, const __CFString *a3)
{
  return 0;
}

uint64_t CFNetworkReadStream::_streamImpl_SetProperty(CFNetworkReadStream *this, __CFReadStream *a2, const __CFString *a3, const void *a4)
{
  return 0;
}

void CFNetworkReadStream::_readStreamClientCallBack(CFNetworkReadStream *this, __CFReadStream *a2)
{
  abort();
}

uint64_t CFNetworkReadStream::_createStream(CFNetworkReadStream *this, uint64_t (**a2)(__CFReadStream *, CFNetworkReadStream *), void *a3)
{
  return a2[2]((__CFReadStream *)a2, this);
}

void CFNetworkReadStream::httpStreamFinalize(CFNetworkReadStream *this, __CFReadStream *a2, void *a3)
{
  const __CFAllocator *v4;

  if (this)
    v4 = CFGetAllocator(this);
  else
    v4 = 0;
  (**(void (***)(__CFReadStream *))a2)(a2);
  CFAllocatorDeallocate(v4, a2);
}

uint64_t CFNetworkReadStream::httpStreamCopyDescription(CFNetworkReadStream *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFReadStream *, CFNetworkReadStream *))(*(_QWORD *)a2 + 16))(a2, this);
}

uint64_t CFNetworkReadStream::httpStreamOpen(CFNetworkReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(unsigned __int8 *, CFNetworkReadStream *, __CFReadStream *, CFStreamError *))(*(_QWORD *)a4 + 24))(a4, this, a2, a3);
}

uint64_t CFNetworkReadStream::httpStreamOpenCompleted(CFNetworkReadStream *this, __CFReadStream *a2, CFStreamError *a3, void *a4)
{
  return (*(uint64_t (**)(CFStreamError *, CFNetworkReadStream *, __CFReadStream *))(a3->domain + 32))(a3, this, a2);
}

uint64_t CFNetworkReadStream::httpStreamCanRead(CFNetworkReadStream *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFReadStream *, CFNetworkReadStream *))(*(_QWORD *)a2 + 48))(a2, this);
}

uint64_t CFNetworkReadStream::httpStreamClose(CFNetworkReadStream *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFReadStream *, CFNetworkReadStream *))(*(_QWORD *)a2 + 56))(a2, this);
}

uint64_t CFNetworkReadStream::httpStreamSetProperty(CFNetworkReadStream *this, __CFReadStream *a2, const __CFString *a3, const void *a4, void *a5)
{
  return (*(uint64_t (**)(const void *, CFNetworkReadStream *, __CFReadStream *, const __CFString *))(*(_QWORD *)a4 + 72))(a4, this, a2, a3);
}

uint64_t CFNetworkReadStream::httpStreamSchedule(CFNetworkReadStream *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkReadStream *, __CFReadStream *, __CFRunLoop *))a4->isa
          + 10))(a4, this, a2, a3);
}

uint64_t CFNetworkReadStream::httpStreamUnschedule(CFNetworkReadStream *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkReadStream *, __CFReadStream *, __CFRunLoop *))a4->isa
          + 11))(a4, this, a2, a3);
}

CFTypeRef *_CFNetworkReadStream_retain(CFTypeRef *a1)
{
  CFRetain(a1[1]);
  return a1;
}

void _CFNetworkReadStream_release(CFTypeRef *a1)
{
  CFRelease(a1[1]);
}

CFStringRef _CFNetworkReadStream_copyDesc(void *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("WHAT: %p"), a1);
}

void CFNetworkReadStream::_readStreamClientCallBackCallBack(CFNetworkReadStream *this, __CFReadStream *a2, CFTypeRef *a3, void *a4)
{
  void *v7;

  if (this)
  {
    if (a3)
    {
      v7 = (void *)MEMORY[0x186DB8C8C]();
      CFRetain(a3[1]);
      (*((void (**)(CFTypeRef *, CFNetworkReadStream *, __CFReadStream *))*a3 + 12))(a3, this, a2);
      CFRelease(a3[1]);
      objc_autoreleasePoolPop(v7);
    }
  }
}

void BinaryCookieStorage::~BinaryCookieStorage(BinaryCookieStorage *this)
{
  uint64_t v2;

  DiskCookieStorage::~DiskCookieStorage(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

CFStringRef BinaryCookieStorage::copyDebugDescLocked(CFAllocatorRef *this)
{
  CFStringRef v2;
  CFStringRef v3;

  v2 = DiskCookieStorage::copyDebugDescLocked((DiskCookieStorage *)this);
  v3 = CFStringCreateWithFormat(this[1], 0, CFSTR("Binary{ %@ }"), v2);
  if (v2)
    CFRelease(v2);
  return v3;
}

void `non-virtual thunk to'BinaryCookieStorage::~BinaryCookieStorage(BinaryCookieStorage *this)
{
  DiskCookieStorage::~DiskCookieStorage((BinaryCookieStorage *)((char *)this - 24));
}

void `non-virtual thunk to'BinaryCookieStorage::~BinaryCookieStorage(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  DiskCookieStorage::~DiskCookieStorage((DiskCookieStorage *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

CFErrorRef createParseError(const __CFAllocator *a1, const char *a2)
{
  CFStringRef v3;
  __CFDictionary *MutableDictionary;
  CFErrorRef v5;

  v3 = CFStringCreateWithCString(a1, a2, 0x8000100u);
  MutableDictionary = cfTypeCreateMutableDictionary(a1, *MEMORY[0x1E0C9AFB0], v3, 0, 0);
  CFRelease(v3);
  v5 = CFErrorCreate(a1, CFSTR("kCFErrorDomainCFNetwork"), -4000, MutableDictionary);
  CFRelease(MutableDictionary);
  return v5;
}

uint64_t URLCredentialXMobileMeAuthToken::equals(URLCredentialXMobileMeAuthToken *this, const CFObject *a2)
{
  uint64_t v4;
  uint64_t result;

  if (*((_DWORD *)this + 8) != *((_DWORD *)a2 + 8))
    return 0;
  v4 = (*(uint64_t (**)(URLCredentialXMobileMeAuthToken *))(*(_QWORD *)this + 8))(this);
  if (v4 != (*(uint64_t (**)(const CFObject *))(*(_QWORD *)a2 + 8))(a2)
    || *((_DWORD *)this + 9) != *((_DWORD *)a2 + 9))
  {
    return 0;
  }
  if (CFEqual(*((CFTypeRef *)this + 9), *((CFTypeRef *)a2 + 9)))
    return 1;
  result = CFEqual(*((CFTypeRef *)this + 8), *((CFTypeRef *)a2 + 8));
  if ((_DWORD)result)
    return 1;
  return result;
}

CFStringRef URLCredentialXMobileMeAuthToken::copyDebugDesc(URLCredentialXMobileMeAuthToken *this)
{
  char *v2;
  const __CFAllocator *v3;

  v2 = (char *)this - 16;
  v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLCredential %p>{appleID = %@, password = %@ realm = %@, persistence = %d}"), v2, *((_QWORD *)this + 9), *((_QWORD *)this + 10), *((_QWORD *)this + 8), *((unsigned int *)this + 9));
}

uint64_t URLCredentialXMobileMeAuthToken::copy(const __CFString **this)
{
  uint64_t Instance;

  CFGetAllocator(this - 2);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_DWORD *)(Instance + 48) = 4;
  *(_QWORD *)(Instance + 24) = &unk_1E14EF370;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EF2C8;
  *(_QWORD *)(Instance + 40) = &unk_1E14EF3A0;
  URLCredentialXMobileMeAuthToken::initialize((URLCredentialXMobileMeAuthToken *)(Instance + 16), this[9], this[10], this[8]);
  return Instance;
}

BOOL URLCredentialXMobileMeAuthToken::initializeFromPropertyList(_QWORD *a1, CFDictionaryRef *a2)
{
  _BOOL8 result;
  const void *Value;
  const void *v6;
  const void *v7;
  const void *v8;

  result = URLCredential::initializeFromPropertyList((uint64_t)a1, a2);
  if (result)
  {
    Value = CFDictionaryGetValue(*a2, CFSTR("realm"));
    if (Value)
      Value = CFRetain(Value);
    a1[8] = Value;
    v6 = CFDictionaryGetValue(*a2, CFSTR("appleid"));
    if (v6)
      v6 = CFRetain(v6);
    a1[9] = v6;
    v7 = CFDictionaryGetValue(*a2, CFSTR("password"));
    if (v7)
      v7 = CFRetain(v7);
    a1[10] = v7;
    v8 = CFDictionaryGetValue(*a2, CFSTR("valid"));
    if (v8)
      v8 = CFRetain(v8);
    a1[11] = v8;
    return 1;
  }
  return result;
}

uint64_t URLCredentialXMobileMeAuthToken::serializeToPropertyList(URLCredentialXMobileMeAuthToken *this, SerializableArchive **a2)
{
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;

  URLCredential::serializeToPropertyList(this, a2);
  v4 = (const void *)*((_QWORD *)this + 8);
  SerializableArchive::assertEmpty(*a2, CFSTR("realm"));
  if (v4)
    CFDictionarySetValue(*a2, CFSTR("realm"), v4);
  v5 = (const void *)*((_QWORD *)this + 9);
  SerializableArchive::assertEmpty(*a2, CFSTR("appleid"));
  if (v5)
    CFDictionarySetValue(*a2, CFSTR("appleid"), v5);
  v6 = (const void *)*((_QWORD *)this + 10);
  SerializableArchive::assertEmpty(*a2, CFSTR("password"));
  if (v6)
    CFDictionarySetValue(*a2, CFSTR("password"), v6);
  v7 = (const void *)*((_QWORD *)this + 11);
  SerializableArchive::assertEmpty(*a2, CFSTR("valid"));
  if (v7)
    CFDictionarySetValue(*a2, CFSTR("valid"), v7);
  return 1;
}

CFHashCode URLCredentialXMobileMeAuthToken::calcHash(URLCredentialXMobileMeAuthToken *this, uint64_t a2)
{
  uint64_t v2;
  const void *v3;

  v2 = a2;
  v3 = (const void *)*((_QWORD *)this + 9);
  if (v3)
    return CFHash(v3) ^ a2;
  return v2;
}

CFTypeRef URLCredentialXMobileMeAuthToken::copyStorageNameForCredentialType(URLCredentialXMobileMeAuthToken *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 9);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t URLCredentialXMobileMeAuthToken::getUserName(URLCredentialXMobileMeAuthToken *this)
{
  CFTypeID TypeID;

  if (*((_QWORD *)this + 9) && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 9))))
    return *((_QWORD *)this + 9);
  else
    return 0;
}

uint64_t URLCredentialXMobileMeAuthToken::getPassword(URLCredentialXMobileMeAuthToken *this)
{
  CFTypeID TypeID;

  if (*((_QWORD *)this + 10) && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 10))))
    return *((_QWORD *)this + 10);
  else
    return 0;
}

CFTypeRef URLCredentialXMobileMeAuthToken::copyPassword(URLCredentialXMobileMeAuthToken *this)
{
  CFTypeID TypeID;
  const void *v3;

  if (*((_QWORD *)this + 10)
    && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 10)))
    && (v3 = (const void *)*((_QWORD *)this + 10)) != 0)
  {
    return CFRetain(v3);
  }
  else
  {
    return 0;
  }
}

BOOL URLCredentialXMobileMeAuthToken::containsPassword(URLCredentialXMobileMeAuthToken *this)
{
  return *((_QWORD *)this + 10) != 0;
}

uint64_t URLCredentialXMobileMeAuthToken::isTokenValid(CFBooleanRef *this)
{
  return CFBooleanGetValue(this[11]);
}

void `non-virtual thunk to'URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken(URLCredentialXMobileMeAuthToken *this)
{
  URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken((URLCredentialXMobileMeAuthToken *)((char *)this - 8));
}

{
  URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken((URLCredentialXMobileMeAuthToken *)((char *)this - 8));
}

{
  URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken((URLCredentialXMobileMeAuthToken *)((char *)this - 24));
}

{
  URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken((URLCredentialXMobileMeAuthToken *)((char *)this - 24));
}

BOOL `non-virtual thunk to'URLCredentialXMobileMeAuthToken::initializeFromPropertyList(uint64_t a1, CFDictionaryRef *a2)
{
  return URLCredentialXMobileMeAuthToken::initializeFromPropertyList((_QWORD *)(a1 - 8), a2);
}

uint64_t `non-virtual thunk to'URLCredentialXMobileMeAuthToken::serializeToPropertyList(URLCredentialXMobileMeAuthToken *this, SerializableArchive **a2)
{
  URLCredentialXMobileMeAuthToken::serializeToPropertyList((URLCredentialXMobileMeAuthToken *)((char *)this - 8), a2);
  return 1;
}

void URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken(URLCredentialXMobileMeAuthToken *this)
{
  const void *v2;
  const void *v3;
  const void *v4;

  *(_QWORD *)this = &off_1E14EF2C8;
  *((_QWORD *)this + 1) = &unk_1E14EF370;
  *((_QWORD *)this + 3) = &unk_1E14EF3A0;
  v2 = (const void *)*((_QWORD *)this + 8);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 9);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 10);
  if (v4)
    CFRelease(v4);
  URLCredential::~URLCredential(this);
}

void sub_1840EC780(_Unwind_Exception *a1)
{
  URLCredential *v1;

  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t URLCredentialXMobileMeAuthToken::initialize(URLCredentialXMobileMeAuthToken *this, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  uint64_t result;
  _QWORD *v6;
  CFTypeID TypeID;
  CFTypeID v11;
  const __CFAllocator *v12;
  const __CFAllocator *v13;
  CFTypeID v14;
  const __CFAllocator *v15;
  CFStringRef Copy;

  result = 0;
  *((_DWORD *)this + 9) = 2;
  v6 = (_QWORD *)MEMORY[0x1E0C9AE40];
  if (a2 && a4)
  {
    TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(a2))
      return 0;
    v11 = CFStringGetTypeID();
    if (v11 != CFGetTypeID(a4))
      return 0;
    v12 = CFGetAllocator((char *)this - 16);
    *((_QWORD *)this + 9) = CFStringCreateCopy(v12, a2);
    v13 = CFGetAllocator((char *)this - 16);
    *((_QWORD *)this + 8) = CFStringCreateCopy(v13, a4);
    if (a3 && (v14 = CFStringGetTypeID(), v14 == CFGetTypeID(a3)))
    {
      v15 = CFGetAllocator((char *)this - 16);
      Copy = CFStringCreateCopy(v15, a3);
    }
    else
    {
      Copy = 0;
    }
    *((_QWORD *)this + 10) = Copy;
    result = 1;
    v6 = (_QWORD *)MEMORY[0x1E0C9AE50];
  }
  *((_QWORD *)this + 11) = *v6;
  return result;
}

int *kCFNIE()
{
  {
    kCFNIE::sCFNIE = 65542;
    qword_1EDD01600 = (uint64_t)xx_CFHTTPConnectionAcceptsRequests;
    unk_1EDD01608 = xx_CFHTTPConnectionCreate;
    qword_1EDD01610 = (uint64_t)xx_core_streamable_CFHTTPConnectionEnqueue;
    unk_1EDD01618 = xx_CFHTTPConnectionLost;
    qword_1EDD01620 = (uint64_t)xx_CFNetConnectionSetShouldPipeline;
    unk_1EDD01628 = xx_CFHTTPConnectionGetLastAccessTime;
    qword_1EDD01630 = (uint64_t)xx_CFHTTPConnectionGetQueueDepth;
    unk_1EDD01638 = xx_CFURLProtocolCopySchedulingArray;
    qword_1EDD01640 = (uint64_t)CFReadStreamCreateHTTPStream;
    unk_1EDD01648 = CFWriteStreamCreateHTTPStream;
    qword_1EDD01650 = (uint64_t)__CFNetworkCopyProxiesForInterface;
    unk_1EDD01658 = xx_CFHSTSParserIndexOfFirstDotInDomainName;
    qword_1EDD01660 = (uint64_t)xx_CFHSTSPolicyCreateWithProperties;
    unk_1EDD01668 = xx_CFHSTSPolicyHandleSTSHeader;
    qword_1EDD01670 = (uint64_t)xx_CFHSTSPolicyIsKnownHSTSHost;
    unk_1EDD01678 = xx_CFHSTSPolicyIsKnownHSTSHostWithBytes;
    qword_1EDD01680 = (uint64_t)xx_createKerberosTicketForHostWithPassword;
    unk_1EDD01688 = xx_destroyAllKerberosTickets;
    qword_1EDD01690 = (uint64_t)xx_listKerberosTickets;
    unk_1EDD01698 = xx_createCFRULCredentialForKerberosTicketWithUUID;
    qword_1EDD016A0 = (uint64_t)xx_equalType;
    unk_1EDD016A8 = xx_CFHSTSPolicyUpdateHSTSInfoForHost;
    qword_1EDD016B0 = (uint64_t)xx_CFHSTSParserCreateHSTSInfo;
    unk_1EDD016B8 = xx_CFHSTSPolicyResetHostsSinceDate;
    qword_1EDD016C0 = (uint64_t)xx_CFHTTPCookieStorageFlushCookieStores;
    unk_1EDD016C8 = _CFHTTPCookieStorageCopyCookiesSortedByFields;
    qword_1EDD016D0 = (uint64_t)xx_CFHTTPCookieStorageRemoveObserver;
    unk_1EDD016D8 = xx_CFHTTPCookieStorageAddObserver;
    qword_1EDD016E0 = (uint64_t)CFHTTPCookie_domainMatches;
    unk_1EDD016E8 = CFHTTPCookie_looksLikeIPAddress;
    qword_1EDD016F0 = (uint64_t)_CookieStorageCreateInMemory;
    unk_1EDD016F8 = _CFURLCacheGetSharedCache;
    qword_1EDD01700 = (uint64_t)CFURLConnectionCopyPeerAddress;
    unk_1EDD01708 = CFHTTPCookieGetVersion;
    qword_1EDD01710 = (uint64_t)CFHTTPCookieGetCreationTime;
    unk_1EDD01718 = CFHTTPCookieCopyComment;
    qword_1EDD01720 = (uint64_t)CFHTTPCookieCopyCommentURL;
    unk_1EDD01728 = CFHTTPCookieCopyPortArray;
    qword_1EDD01730 = (uint64_t)CFHTTPCookieStorageSyncStorageNow;
    unk_1EDD01738 = CFURLDownloadUseCredential;
    qword_1EDD01740 = (uint64_t)_CFGregorianDateCreateWithString;
    unk_1EDD01748 = _CFGregorianDateCreateWithBytes;
    qword_1EDD01750 = (uint64_t)_CFStringCreateRFC2616DateStringWithGregorianDate;
    unk_1EDD01758 = _CFStringCreateRFC1123DateStringWithGregorianDate;
    qword_1EDD01760 = (uint64_t)CFURLRequestIsIdempotent;
    unk_1EDD01768 = CFURLResponseCreateCopy;
    qword_1EDD01770 = 0;
    unk_1EDD01778 = _CFHTTPMessageSetMultipleHeaderFields;
    qword_1EDD01780 = (uint64_t)CFURLResponseGetLastModifiedDate;
    unk_1EDD01788 = _CFHostSetClientInfoCallback;
    qword_1EDD01790 = (uint64_t)CFSTR("base");
    unk_1EDD01798 = CFSTR("persistent");
    qword_1EDD017A0 = (uint64_t)CFSTR("type");
    unk_1EDD017A8 = CFSTR("binary");
    qword_1EDD017B0 = (uint64_t)CFSTR("url");
    unk_1EDD017B8 = CFSTR("ident");
    qword_1EDD017C0 = (uint64_t)CFSTR("policy");
    unk_1EDD017C8 = 0x1EDCFB360;
    qword_1EDD017D0 = 0x1EDCFBAD0;
    unk_1EDD017D8 = 0x1EDCFAE58;
    qword_1EDD017E0 = 0x1EDCFE578;
    unk_1EDD017E8 = 0x1EDCFE5B0;
    qword_1EDD017F0 = 0x1EDCFA2F8;
    unk_1EDD017F8 = 0x1EDCFA170;
    qword_1EDD01800 = 0x1EDCFE310;
    qword_1EDD01808 = 0x1EDCFE6C8;
    qword_1EDD01810 = 0x1EDD00AA8;
    qword_1EDD01818 = 0x1EDD00AE0;
    qword_1EDD01820 = 0x1EDD00A38;
    qword_1EDD01828 = 0x1EDD00A70;
    qword_1EDD01830 = 0x1EDCFC0B8;
    qword_1EDD01838 = (uint64_t)CFURLDownloadSetOriginatingURL;
    qword_1EDD01840 = (uint64_t)_CFServerScheduleWithRunLoopAndMode;
    qword_1EDD01848 = (uint64_t)CFURLCacheCurrentMemoryUsage;
    qword_1EDD01850 = (uint64_t)CFURLDataDecoderCreateWithResponse;
    qword_1EDD01858 = (uint64_t)CFURLDataDecoderDecodeData;
    qword_1EDD01860 = (uint64_t)CFURLDataDecoderIsFinishedDecoding;
    qword_1EDD01868 = (uint64_t)CFURLDataDecoderCreateWithContentEncoding;
    qword_1EDD01870 = (uint64_t)_CFURLStorageSessionGetDefault;
    qword_1EDD01878 = (uint64_t)CFURLDownloadCreateWithResumeInformation;
    qword_1EDD01880 = (uint64_t)CFURLDownloadCopyResumeInformation;
    qword_1EDD01888 = (uint64_t)CFURLDownloadSetDirectoryPath;
    qword_1EDD01890 = (uint64_t)older_spi_CFHTTPCookieStorageSetCookiesWithResponseHeaderFields;
    qword_1EDD01898 = (uint64_t)CFURLRequestGetPreventsIdleSystemSleep;
    qword_1EDD018A0 = (uint64_t)CFURLRequestSetPreventsIdleSystemSleep;
    qword_1EDD018A8 = (uint64_t)_xx_requestSetBoundInterfaceIdentifier;
    dword_1EDD018B0 = -1060454374;
  }
  return &kCFNIE::sCFNIE;
}

uint64_t xx_CFHTTPConnectionAcceptsRequests(const __CFArray *a1)
{
  NetConnection *ValueAtIndex;

  ValueAtIndex = (NetConnection *)CFArrayGetValueAtIndex(a1, 0);
  return NetConnection::willEnqueueRequests(ValueAtIndex);
}

CFArrayRef xx_CFHTTPConnectionCreate(const __CFAllocator *a1, const __CFString *a2, int a3, int a4, const __CFDictionary *a5)
{
  _OWORD *v10;
  HTTPNetConnection_NoAuth *v11;
  CFArrayRef v12;
  void *values;

  v10 = CFAllocatorAllocate(a1, 152, 0);
  *v10 = 0u;
  v10[1] = 0u;
  v10[2] = 0u;
  v10[3] = 0u;
  v10[4] = 0u;
  v10[5] = 0u;
  v10[6] = 0u;
  v10[7] = 0u;
  v10[8] = 0u;
  *((_QWORD *)v10 + 18) = 0;
  HTTPConnectionCacheKey::HTTPConnectionCacheKey((uint64_t)v10, (uint64_t)a1, a2, a3, a4, a5, 0);
  v11 = (HTTPNetConnection_NoAuth *)CFAllocatorAllocate(a1, 320, 0);
  *(_OWORD *)v11 = 0u;
  *((_OWORD *)v11 + 1) = 0u;
  *((_OWORD *)v11 + 2) = 0u;
  *((_OWORD *)v11 + 3) = 0u;
  *((_OWORD *)v11 + 4) = 0u;
  *((_OWORD *)v11 + 5) = 0u;
  *((_OWORD *)v11 + 6) = 0u;
  *((_OWORD *)v11 + 7) = 0u;
  *((_OWORD *)v11 + 8) = 0u;
  *((_OWORD *)v11 + 9) = 0u;
  *((_OWORD *)v11 + 10) = 0u;
  *((_OWORD *)v11 + 11) = 0u;
  *((_OWORD *)v11 + 12) = 0u;
  *((_OWORD *)v11 + 13) = 0u;
  *((_OWORD *)v11 + 14) = 0u;
  *((_OWORD *)v11 + 15) = 0u;
  *((_OWORD *)v11 + 16) = 0u;
  *((_OWORD *)v11 + 17) = 0u;
  *((_OWORD *)v11 + 18) = 0u;
  *((_OWORD *)v11 + 19) = 0u;
  HTTPNetConnection_NoAuth::HTTPNetConnection_NoAuth(v11, a1, (HTTPConnectionCacheKey *)v10);
  (*(void (**)(_OWORD *))(*(_QWORD *)v10 + 48))(v10);
  if (!NetConnection::initialize(v11, 1))
  {
    (*(void (**)(HTTPNetConnection_NoAuth *))(*(_QWORD *)v11 + 48))(v11);
    v11 = 0;
  }
  values = v11;
  v12 = CFArrayCreate(a1, (const void **)&values, 1, &xx_CFHTTPConnectionCreate(__CFAllocator const*,__CFString const*,int,unsigned int,__CFDictionary const*)::netConnectionRetain);
  (*(void (**)(void *))(*(_QWORD *)values + 48))(values);
  return v12;
}

uint64_t xx_core_streamable_CFHTTPConnectionEnqueue(const __CFArray *a1, __CFHTTPMessage *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  CFArrayGetValueAtIndex(a1, 0);
  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  CFReadStreamCreate();
  v2 = v5[3];
  _Block_object_dispose(&v4, 8);
  if (v2)
    return *(_QWORD *)(v2 + 8);
  else
    return 0;
}

void sub_1840ECEA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t xx_CFHTTPConnectionLost(const __CFArray *a1)
{
  const void *ValueAtIndex;

  ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
  return (*(uint64_t (**)(const void *))(*(_QWORD *)ValueAtIndex + 288))(ValueAtIndex);
}

void xx_CFNetConnectionSetShouldPipeline(const __CFArray *a1, int a2)
{
  NetConnection *ValueAtIndex;

  ValueAtIndex = (NetConnection *)CFArrayGetValueAtIndex(a1, 0);
  NetConnection::setShouldPipeline(ValueAtIndex, a2);
}

double xx_CFHTTPConnectionGetLastAccessTime(const __CFArray *a1)
{
  NetConnection *ValueAtIndex;

  ValueAtIndex = (NetConnection *)CFArrayGetValueAtIndex(a1, 0);
  return NetConnection::getLastAccessTime(ValueAtIndex);
}

uint64_t xx_CFHTTPConnectionGetQueueDepth(const __CFArray *a1)
{
  _QWORD *ValueAtIndex;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
  v2 = ValueAtIndex;
  v3 = ValueAtIndex[12];
  if (v3)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 8));
    v4 = v2[12];
    v5 = *((_DWORD *)v2 + 26);
    if (v4)
      pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  }
  else
  {
    return *((int *)ValueAtIndex + 26);
  }
  return v5;
}

CFMutableArrayRef xx_CFURLProtocolCopySchedulingArray(_CFURLProtocol *a1)
{
  const __CFAllocator *v2;
  CFMutableArrayRef Mutable;
  uint64_t v4;
  void (*v6[5])(_QWORD, _QWORD, _QWORD);

  v2 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
  if (TCFObject<URLProtocol>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLProtocol>::Class(void)::sOnce, &__block_literal_global_15936);
  v4 = *((_QWORD *)a1 + 5);
  v6[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  v6[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
  v6[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZL35xx_CFURLProtocolCopySchedulingArrayP14_CFURLProtocol_block_invoke;
  v6[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v6[4] = (void (*)(_QWORD, _QWORD, _QWORD))Mutable;
  CoreSchedulingSet::applyBlock(v4, v6);
  return Mutable;
}

__CFArray *_CFHTTPCookieStorageCopyCookiesSortedByFields(OpaqueCFHTTPCookieStorage *a1, const __CFArray *a2)
{
  HTTPCookieStorage *v4;

  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
  if (a1)
    v4 = (HTTPCookieStorage *)((char *)a1 + 16);
  else
    v4 = 0;
  return HTTPCookieStorage::copyCookiesMatching(v4, 0, 32, a2);
}

uint64_t CFURLConnectionCopyPeerAddress(_CFURLConnection *a1)
{
  void *v2;
  char *v3;
  uint64_t v4;

  v2 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_3_15933);
  if (a1)
    v3 = (char *)a1 + 16;
  else
    v3 = 0;
  v4 = (*(uint64_t (**)(char *))(*(_QWORD *)v3 + 160))(v3);
  objc_autoreleasePoolPop(v2);
  return v4;
}

uint64_t CFHTTPCookieGetVersion(OpaqueCFHTTPCookie *a1)
{
  uint64_t v1;
  _DWORD *v2;

  v1 = -[OpaqueCFHTTPCookie _inner](a1, "_inner");
  v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
  if (*v2 >= 8u)
    return v2[1];
  else
    return 0;
}

double CFHTTPCookieGetCreationTime(OpaqueCFHTTPCookie *a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = -[OpaqueCFHTTPCookie _inner](a1, "_inner");
  v2 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
  if (*(_DWORD *)v2 >= 0x38u)
    return floor(*(double *)(v2 + 48));
  else
    return 0.0;
}

CFStringRef CFHTTPCookieCopyComment(OpaqueCFHTTPCookie *a1)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  const char *v8;

  v2 = -[OpaqueCFHTTPCookie _inner](a1, "_inner");
  v3 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  if (*v3 >= 0x24 && (v4 = v3[8], (_DWORD)v4) && (v5 = *v3, v5 > v4))
  {
    v6 = (char *)v3 + v4;
    v7 = (char *)v3 + v5;
    v8 = v6;
    while (*v8)
    {
      if (++v8 >= v7)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v6 = 0;
  }
  return createCookieString(a1, v6);
}

CFStringRef CFHTTPCookieCopyCommentURL(OpaqueCFHTTPCookie *a1)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  const char *v8;
  CFStringRef result;
  const __CFString *v10;
  const __CFAllocator *v11;
  CFURLRef v12;

  v2 = -[OpaqueCFHTTPCookie _inner](a1, "_inner");
  v3 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  if (*v3 >= 0x28 && (v4 = v3[9], (_DWORD)v4) && (v5 = *v3, v5 > v4))
  {
    v6 = (char *)v3 + v4;
    v7 = (char *)v3 + v5;
    v8 = v6;
    while (*v8)
    {
      if (++v8 >= v7)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v6 = 0;
  }
  result = createCookieString(a1, v6);
  if (result)
  {
    v10 = result;
    v11 = CFGetAllocator(a1);
    v12 = CFURLCreateWithString(v11, v10, 0);
    CFRelease(v10);
    return (CFStringRef)v12;
  }
  return result;
}

void CFHTTPCookieStorageSyncStorageNow(OpaqueCFHTTPCookieStorage *a1)
{
  char *v2;

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (!newCookieStorageEnabled(void)::enabled)
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    if (a1)
      v2 = (char *)a1 + 16;
    else
      v2 = 0;
    HTTPCookieStorage::syncStorageWithCompletion((uint64_t)v2, 1, 0);
  }
}

void CFURLDownloadUseCredential(_CFURLDownload *a1, const _CFURLCredential *a2, CFTypeRef cf2)
{
  URLDownload *v6;

  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  if (a1)
    v6 = (URLDownload *)((char *)a1 + 16);
  else
    v6 = 0;
  URLDownload::useCredential(v6, a2, cf2);
}

uint64_t CFURLRequestIsIdempotent(_CFURLRequest *a1)
{
  uint64_t v1;
  uint64_t result;
  uint8_t v3[16];

  v1 = *(_QWORD *)(-[_CFURLRequest _inner](a1, "_inner") + 56);
  if (!v1)
    return 1;
  result = *(_QWORD *)(v1 + 152);
  if (!result)
    return result;
  if (CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo)
    return 1;
  result = *(_QWORD *)(v1 + 152);
  if (result)
    return CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo;
  result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT);
  if ((_DWORD)result)
  {
    *(_WORD *)v3 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", v3, 2u);
    result = *(_QWORD *)(v1 + 152);
    if (result)
      return CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo;
  }
  return result;
}

double CFURLResponseGetLastModifiedDate(_CFURLResponse *a1)
{
  return URLResponse::getLastModifiedDate((URLResponse *)-[_CFURLResponse _inner](a1, "_inner"));
}

void CFURLDownloadSetOriginatingURL(_CFURLDownload *a1, const __CFURL *a2)
{
  char *v4;
  const __CFAllocator *v5;
  const __CFAllocator *v6;
  size_t v7;
  CFURLRef v8;
  _QWORD *v9;
  const __CFURL *v10;
  CFTypeRef v11;
  uint64_t v12;
  CFAllocatorRef allocator;
  uint64_t v14;
  void *ptr;
  char *__s;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  if (a1)
    v4 = (char *)a1 + 16;
  else
    v4 = 0;
  if (!a2)
  {
    v12 = *((_QWORD *)v4 + 28);
    v9 = v4 + 224;
    if (!v12)
      return;
    v8 = 0;
LABEL_14:
    v11 = 0;
    goto LABEL_15;
  }
  v5 = CFGetAllocator(v4 - 16);
  URLPortion::URLPortion((URLPortion *)&allocator, v5, a2, 1);
  v6 = CFGetAllocator(v4 - 16);
  v7 = strlen(__s);
  v8 = CFURLCreateWithBytes(v6, (const UInt8 *)__s, v7, 0x201u, 0);
  if (ptr != &v14)
    CFAllocatorDeallocate(allocator, ptr);
  v10 = (const __CFURL *)*((_QWORD *)v4 + 28);
  v9 = v4 + 224;
  if (v10 == v8)
    goto LABEL_16;
  if (!v8)
    goto LABEL_14;
  v11 = CFRetain(v8);
LABEL_15:
  *v9 = v11;
LABEL_16:
  if (v8)
    CFRelease(v8);
}

void sub_1840ED598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const __CFAllocator *allocator, uint64_t a10)
{
  if ((uint64_t *)STACK[0x208] != &a10)
    CFAllocatorDeallocate(allocator, (void *)STACK[0x208]);
  _Unwind_Resume(a1);
}

CFDictionaryRef CFURLDownloadCopyResumeInformation(char *cf)
{
  URLDownload *v2;
  const __CFAllocator *v3;

  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  if (cf)
    v2 = (URLDownload *)(cf + 16);
  else
    v2 = 0;
  v3 = CFGetAllocator(cf);
  return URLDownload::createResumeInformation(v2, v3);
}

CFTypeRef CFURLDownloadSetDirectoryPath(_CFURLDownload *a1, CFTypeRef cf)
{
  _CFURLDownload *v3;

  if (a1)
  {
    v3 = a1;
    if (URLDownload::Class(void)::sOnce_URLDownload != -1)
      dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
    a1 = (_CFURLDownload *)((char *)v3 + 16);
  }
  return URLDownload::setDirectoryURL((URLDownload *)a1, cf);
}

uint64_t CFURLRequestGetPreventsIdleSystemSleep(const _CFURLRequest *a1)
{
  return 0;
}

__CFString *_xx_requestSetBoundInterfaceIdentifier(_CFURLRequest *a1, __CFString *a2)
{
  return URLRequest::setBoundInterfaceIdentifier((URLRequest *)-[_CFURLRequest _inner](a1, "_inner"), a2);
}

CFTypeRef URLDownload::setDirectoryURL(URLDownload *this, CFTypeRef cf)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 27);
  if (result != cf)
  {
    if (result)
      CFRelease(result);
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *((_QWORD *)this + 27) = result;
  }
  return result;
}

void ___ZN9TCFObjectI13URLConnectionE5ClassEv_block_invoke_15934()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  qmemcpy(_PNAME<URLConnection>::GET(void)::p, "URLConnection", 13);
  CFClass::CFClass(v0, (const char *)_PNAME<URLConnection>::GET(void)::p);
  TCFObject<URLConnection>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840ED758(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZL35xx_CFURLProtocolCopySchedulingArrayP14_CFURLProtocol_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), a2);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), a3);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_15937()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(_QWORD *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840ED810(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

const void *_ncRetain(const __CFAllocator *a1, const void *a2)
{
  (*(void (**)(const void *))(*(_QWORD *)a2 + 40))(a2);
  return a2;
}

uint64_t _ncRelease(const __CFAllocator *a1, const void *a2)
{
  return (*(uint64_t (**)(const void *))(*(_QWORD *)a2 + 48))(a2);
}

uint64_t _NSURLConnectionWillSendRequest(_CFURLConnection *a1, const _CFURLRequest *a2, _CFURLResponse *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD v6[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZL31_NSURLConnectionWillSendRequestP16_CFURLConnectionPK13_CFURLRequestP14_CFURLResponsePKv_block_invoke;
  v6[3] = &unk_1E14FD248;
  v6[5] = a2;
  v6[6] = a3;
  v6[4] = &v7;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a4, (uint64_t)v6);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1840EDF98(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void _NSURLConnectionWillSendRequestForEstablishedConnection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD v5[7];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZL55_NSURLConnectionWillSendRequestForEstablishedConnectionP16_CFURLConnectionPK13_CFURLRequestPK14__CFDictionaryU13block_pointerFvS3_EPKv_block_invoke;
  v5[3] = &unk_1E14FD270;
  v5[5] = a2;
  v5[6] = a3;
  v5[4] = a4;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a5, (uint64_t)v5);
}

void _NSURLConnectionConnectionWaiting(_CFURLConnection *a1, uint64_t a2)
{
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a2, (uint64_t)&__block_literal_global_16024);
}

void _NSURLConnectionConditionalRequirementsChanged(_CFURLConnection *a1, char a2, uint64_t a3)
{
  _QWORD v3[4];
  char v4;

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZL46_NSURLConnectionConditionalRequirementsChangedP16_CFURLConnectionhPKv_block_invoke;
  v3[3] = &__block_descriptor_33_e28_v24__0__NSURLConnection_8_16l;
  v4 = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v3);
}

void _NSURLConnectionDidReceiveDataArray(_CFURLConnection *a1, const __CFArray *a2, uint64_t a3)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZL35_NSURLConnectionDidReceiveDataArrayP16_CFURLConnectionPK9__CFArrayPKv_block_invoke;
  v3[3] = &__block_descriptor_40_e28_v24__0__NSURLConnection_8_16l;
  v3[4] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v3);
}

void _NSURLConnectionDidReceiveData_LengthReceived(_CFURLConnection *a1, const __CFData *a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[6];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZL45_NSURLConnectionDidReceiveData_LengthReceivedP16_CFURLConnectionPK8__CFDatalPKv_block_invoke;
  v4[3] = &__block_descriptor_48_e28_v24__0__NSURLConnection_8_16l;
  v4[4] = a2;
  v4[5] = a3;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a4, (uint64_t)v4);
}

void _NSURLConnectionDidReceiveData(_CFURLConnection *a1, const __CFData *a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZL30_NSURLConnectionDidReceiveDataP16_CFURLConnectionPK8__CFDatalPKv_block_invoke;
  v4[3] = &__block_descriptor_40_e28_v24__0__NSURLConnection_8_16l;
  v4[4] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a4, (uint64_t)v4);
}

const __CFString *_NSURLConnectionDidReceiveResponse_Download_NoDelegate(_CFURLConnection *a1, _CFURLResponse *a2, _QWORD *a3)
{
  const __CFString *result;

  a3[15] = CFURLResponseGetExpectedContentLength(a2);
  result = URLResponse::copySuggestedFilename((URLResponse *)-[_CFURLResponse _inner](a2, "_inner"));
  a3[12] = result;
  return result;
}

void _NSURLConnectionDidReceiveResponse_Download(_CFURLConnection *a1, _CFURLResponse *a2, _QWORD *a3)
{
  _QWORD v5[5];

  a3[15] = CFURLResponseGetExpectedContentLength(a2);
  a3[12] = URLResponse::copySuggestedFilename((URLResponse *)-[_CFURLResponse _inner](a2, "_inner"));
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZL34_NSURLConnectionDidReceiveResponseP16_CFURLConnectionP14_CFURLResponsePKv_block_invoke;
  v5[3] = &__block_descriptor_40_e28_v24__0__NSURLConnection_8_16l;
  v5[4] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:]((uint64_t)a3, (uint64_t)v5);
}

void _NSURLConnectionDidReceiveData_Download(_CFURLConnection *a1, const __CFData *a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[6];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZL39_NSURLConnectionDidReceiveData_DownloadP16_CFURLConnectionPK8__CFDatalPKv_block_invoke;
  v4[3] = &unk_1E14FD338;
  v4[4] = a4;
  v4[5] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a4, (uint64_t)v4);
}

void _NSURLConnectionDidFinishLoading_Download(_CFURLConnection *a1, uint64_t a2)
{
  _QWORD v2[5];

  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3221225472;
  v2[2] = ___ZL41_NSURLConnectionDidFinishLoading_DownloadP16_CFURLConnectionPKv_block_invoke;
  v2[3] = &unk_1E14FE318;
  v2[4] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a2, (uint64_t)v2);
}

void _NSURLConnectionDidFail(_CFURLConnection *a1, __CFError *a2, uint64_t a3)
{
  _QWORD v3[6];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZL23_NSURLConnectionDidFailP16_CFURLConnectionP9__CFErrorPKv_block_invoke;
  v3[3] = &unk_1E14FD338;
  v3[4] = a3;
  v3[5] = a2;
  -[NSURLConnectionInternal _withConnectionAndDelegate:](a3, (uint64_t)v3);
}

uint64_t _NSURLConnectionWillCacheResponse_noCache(_CFURLConnection *a1, const _CFCachedURLResponse *a2, const void *a3)
{
  return 0;
}

const _CFCachedURLResponse *_NSURLConnectionWillCacheResponse(_CFURLConnection *a1, const _CFCachedURLResponse *a2, uint64_t a3)
{
  const _CFCachedURLResponse *v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  const _CFCachedURLResponse *v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = a2;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZL33_NSURLConnectionWillCacheResponseP16_CFURLConnectionPK20_CFCachedURLResponsePKv_block_invoke;
  v6[3] = &unk_1E14FD368;
  v6[4] = &v7;
  v6[5] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v6);
  v4 = (const _CFCachedURLResponse *)v8[3];
  if (v4 == a2)
  {
    CFRetain(a2);
    v4 = (const _CFCachedURLResponse *)v8[3];
  }
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1840EE3F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _NSURLConnectionDidSendBodyData(_CFURLConnection *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD v5[7];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZL31_NSURLConnectionDidSendBodyDataP16_CFURLConnectionlllPKv_block_invoke;
  v5[3] = &__block_descriptor_56_e28_v24__0__NSURLConnection_8_16l;
  v5[4] = a2;
  v5[5] = a3;
  v5[6] = a4;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a5, (uint64_t)v5);
}

void _NSURLConnectionDidReceiveAuthenticationChallenge_noSelector(_CFURLConnection *a1, _CFURLAuthChallenge *a2, uint64_t a3)
{
  uint64_t v4;
  const void *v5;

  v4 = -[NSURLConnectionInternalConnection _retainCFURLConnection](a3);
  if (v4)
  {
    v5 = (const void *)v4;
    CFURLConnectionUseCredential(v4, 0, (uint64_t)a2);
    CFRelease(v5);
  }
}

void _NSURLConnectionDidReceiveAuthenticationChallenge(_CFURLConnection *a1, _CFURLAuthChallenge *a2, uint64_t a3)
{
  -[NSURLConnectionInternalConnection sendCFChallenge:toSelector:](a3, (uint64_t)a2, (uint64_t)sel_connection_didReceiveAuthenticationChallenge_);
}

uint64_t _NSURLConnectionShouldUseCredentialStorage(_CFURLConnection *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 1;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZL42_NSURLConnectionShouldUseCredentialStorageP16_CFURLConnectionPKv_block_invoke;
  v4[3] = &unk_1E14FD3B0;
  v4[4] = &v5;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a2, (uint64_t)v4);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1840EE54C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _NSURLConnectionCanRespondToProtectionSpace(_CFURLConnection *a1, _CFURLProtectionSpace *a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZL43_NSURLConnectionCanRespondToProtectionSpaceP16_CFURLConnectionP21_CFURLProtectionSpacePKv_block_invoke;
  v5[3] = &unk_1E14FD368;
  v5[4] = &v6;
  v5[5] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v5);
  v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1840EE5F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _NSURLConnectionNeedNewBodyStream(_CFURLConnection *a1, const _CFURLRequest *a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZL33_NSURLConnectionNeedNewBodyStreamP16_CFURLConnectionPK13_CFURLRequestPKv_block_invoke;
  v5[3] = &unk_1E14FD368;
  v5[4] = &v6;
  v5[5] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v5);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1840EE694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _NSURLConnectionWillSendRequestForAuthenticationChallenge(_CFURLConnection *a1, _CFURLAuthChallenge *a2, uint64_t a3)
{
  -[NSURLConnectionInternalConnection sendCFChallenge:toSelector:](a3, (uint64_t)a2, (uint64_t)sel_connection_willSendRequestForAuthenticationChallenge_);
}

CFTypeRef ___ZL33_NSURLConnectionNeedNewBodyStreamP16_CFURLConnectionPK13_CFURLRequestPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v6;
  const void *v7;
  CFTypeRef result;

  v6 = -[NSURLRequest _initWithCFURLRequest:]([NSURLRequest alloc], "_initWithCFURLRequest:", *(_QWORD *)(a1 + 40));
  v7 = (const void *)objc_msgSend(a3, "connection:needNewBodyStream:", a2, v6);

  if (v7)
    result = CFRetain(v7);
  else
    result = 0;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void ___ZL43_NSURLConnectionCanRespondToProtectionSpaceP16_CFURLConnectionP21_CFURLProtectionSpacePKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v6;

  v6 = -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]([NSURLProtectionSpace alloc], "_initWithCFURLProtectionSpace:", *(_QWORD *)(a1 + 40));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_msgSend(a3, "connection:canAuthenticateAgainstProtectionSpace:", a2, v6);

}

uint64_t ___ZL42_NSURLConnectionShouldUseCredentialStorageP16_CFURLConnectionPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result;

  result = objc_msgSend(a3, "connectionShouldUseCredentialStorage:", a2);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t ___ZL31_NSURLConnectionDidSendBodyDataP16_CFURLConnectionlllPKv_block_invoke(_QWORD *a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "connection:didSendBodyData:totalBytesWritten:totalBytesExpectedToWrite:", a2, a1[4], a1[5], a1[6]);
}

void ___ZL33_NSURLConnectionWillCacheResponseP16_CFURLConnectionPK20_CFCachedURLResponsePKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v6;
  const void *v7;
  id v8;

  v8 = -[NSCachedURLResponse _initWithCFCachedURLResponse:]([NSCachedURLResponse alloc], "_initWithCFCachedURLResponse:", *(_QWORD *)(a1 + 40));
  v6 = (id)objc_msgSend(a3, "connection:willCacheResponse:", a2, v8);
  if (v6 != v8)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_msgSend(v6, "_CFCachedURLResponse");
    v7 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v7)
      CFRetain(v7);
  }

}

uint64_t ___ZL23_NSURLConnectionDidFailP16_CFURLConnectionP9__CFErrorPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  void *v6;

  v6 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 40), "userInfo"), "objectForKey:", CFSTR("NSErrorFailingURLKey"));
  if (!v6)
    v6 = *(void **)(*(_QWORD *)(a1 + 32) + 24);
  return objc_msgSend(a3, "connection:didFailWithError:", a2, cfnTranslateCFError(*(__CFError **)(a1 + 40), v6));
}

uint64_t ___ZL41_NSURLConnectionDidFinishLoading_DownloadP16_CFURLConnectionPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "connectionDidFinishDownloading:destinationURL:", a2, objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:isDirectory:", -[NSString stringByAppendingPathComponent:](NSTemporaryDirectory(), "stringByAppendingPathComponent:", *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96)), 0));
}

uint64_t ___ZL39_NSURLConnectionDidReceiveData_DownloadP16_CFURLConnectionPK8__CFDatalPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  CFIndex Length;
  const __CFData *v7;

  Length = CFDataGetLength(*(CFDataRef *)(a1 + 40));
  v7 = *(const __CFData **)(a1 + 40);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112) += Length;
  return objc_msgSend(a3, "connection:didWriteData:totalBytesWritten:expectedTotalBytes:", a2, CFDataGetLength(v7), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 120));
}

uint64_t ___ZL30_NSURLConnectionDidReceiveDataP16_CFURLConnectionPK8__CFDatalPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "connection:didReceiveData:", a2, *(_QWORD *)(a1 + 32));
}

uint64_t ___ZL45_NSURLConnectionDidReceiveData_LengthReceivedP16_CFURLConnectionPK8__CFDatalPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "connection:didReceiveData:lengthReceived:", a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t ___ZL35_NSURLConnectionDidReceiveDataArrayP16_CFURLConnectionPK9__CFArrayPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "connection:didReceiveDataArray:", a2, *(_QWORD *)(a1 + 32));
}

uint64_t ___ZL46_NSURLConnectionConditionalRequirementsChangedP16_CFURLConnectionhPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "connection:conditionalRequirementsChanged:", a2, *(_BYTE *)(a1 + 32) != 0);
}

uint64_t ___ZL33_NSURLConnectionConnectionWaitingP16_CFURLConnectionPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "connectionWaiting:", a2);
}

uint64_t ___ZL55_NSURLConnectionWillSendRequestForEstablishedConnectionP16_CFURLConnectionPK13_CFURLRequestPK14__CFDictionaryU13block_pointerFvS3_EPKv_block_invoke(_QWORD *a1, uint64_t a2, void *a3)
{
  id v6;

  v6 = -[NSURLRequest _initWithCFURLRequest:]([NSURLRequest alloc], "_initWithCFURLRequest:", a1[5]);
  objc_msgSend(a3, "connection:willSendRequestForEstablishedConnection:properties:", a2, v6, a1[6]);

  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

void ___ZL31_NSURLConnectionWillSendRequestP16_CFURLConnectionPK13_CFURLRequestP14_CFURLResponsePKv_block_invoke(_QWORD *a1, uint64_t a2, void *a3)
{
  id v6;
  uint64_t v7;
  const void *v8;
  id v9;

  v9 = -[NSURLRequest _initWithCFURLRequest:]([NSURLRequest alloc], "_initWithCFURLRequest:", a1[5]);
  if (a1[6])
    v6 = +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:");
  else
    v6 = 0;
  v7 = objc_msgSend(a3, "connection:willSendRequest:redirectResponse:", a2, v9, v6);
  if ((id)v7 == v9)
    v7 = a1[5];
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v7;
  v8 = *(const void **)(*(_QWORD *)(a1[4] + 8) + 24);
  if (v8)
    CFRetain(v8);

}

uint64_t HTTPTransaction::copyProperty(HTTPTransaction *this, const __CFString *a2)
{
  return (*(uint64_t (**)(_QWORD, const __CFString *))(**((_QWORD **)this + 24) + 32))(*((_QWORD *)this + 24), a2);
}

void HTTPTransaction::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;

  v3 = *a2;
  v4 = (std::__shared_weak_count *)a2[1];
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 136), v3, (uint64_t)v4);
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  else
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 136), v3, 0);
  }
}

void HTTPTransaction::connAuthState(HTTPTransaction *this@<X0>, _QWORD *a2@<X8>)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;

  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (v4 && (v5 = std::__shared_weak_count::lock(v4)) != 0)
  {
    v6 = v5;
    v7 = *((_QWORD *)this + 7);
    if (v7)
    {
      v9 = *(_QWORD *)(v7 + 176);
      v8 = *(_QWORD *)(v7 + 184);
      *a2 = v9;
      a2[1] = v8;
      if (v8)
      {
        v10 = (unint64_t *)(v8 + 8);
        do
          v11 = __ldxr(v10);
        while (__stxr(v11 + 1, v10));
      }
    }
    else
    {
      *a2 = 0;
      a2[1] = 0;
    }
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void HTTPTransaction::resetConnAuthState(HTTPTransaction *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  __int128 v11;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *((_QWORD *)this + 7);
      if (v5)
      {
        std::allocate_shared[abi:nn180100]<HTTPConnectionAuthenticator,std::allocator<HTTPConnectionAuthenticator>,std::weak_ptr<HTTPConnection> &,std::shared_ptr<HTTPEngine> &,void>((std::__shared_weak_count_vtbl **)&v11, *(_QWORD *)(v5 + 40), *(std::__shared_weak_count **)(v5 + 48), (std::__shared_weak_count_vtbl **)(v5 + 64));
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v5 + 176, &v11);
        v6 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
        if (*((_QWORD *)&v11 + 1))
        {
          v7 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
          do
            v8 = __ldaxr(v7);
          while (__stlxr(v8 - 1, v7));
          if (!v8)
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
        }
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1840EEE88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTPTransaction::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *(_QWORD *)(a1 + 208);
  if (v2)
  {
    v3 = (std::__shared_weak_count *)a2[1];
    v9 = *a2;
    v10 = v3;
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 272))(v2, &v9);
    v6 = v10;
    if (v10)
    {
      v7 = (unint64_t *)&v10->__shared_owners_;
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 152))(*a2, 0);
  }
}

void sub_1840EEF50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'HTTPTransaction::~HTTPTransaction(HTTPTransaction *this)
{
  HTTPTransaction::~HTTPTransaction((HTTPTransaction *)((char *)this - 24));
}

{
  HTTPTransaction::~HTTPTransaction((HTTPTransaction *)((char *)this - 24));
  JUMPOUT(0x186DB748CLL);
}

__n128 __Block_byref_object_copy__16088(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__16089(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN15HTTPTransaction25_onqueue_updateSchedulingEPK17CoreSchedulingSetb_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  HTTPTransaction::_onqueue_invokeHandler(*(HTTPTransaction **)(a1 + 40));
  *(_WORD *)(v1 + 32) &= 0xFE7Fu;
}

uint64_t __copy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void HTTPTransaction::_onqueue_handleError(HTTPTransaction *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  int v5;
  int v6;

  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  HTTPTransaction::stopStallTimer(this);
  v5 = *((_DWORD *)this + 20);
  if (v5 != 11)
  {
    *((_QWORD *)this + 11) = domain;
    *((_QWORD *)this + 12) = v2;
    if (domain == 1 && v2 == 89)
    {
      if (v5 < 11)
      {
        v6 = 10;
LABEL_8:
        *((_DWORD *)this + 20) = v6;
        HTTPTransaction::captureStreamProperties(this);
        return;
      }
    }
    else if (v5 < 12)
    {
      v6 = 11;
      goto LABEL_8;
    }
    __assert_rtn("_onqueue_changeState", "HTTPTransaction.cpp", 1664, "newState >= _state");
  }
}

__n128 __Block_byref_object_copy__21(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__22(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void HTTPTransaction::_onqueue_scheduleAndOpenWithHandler(uint64_t a1, uint64_t a2, void *aBlock, const void *a4)
{
  int v5;
  std::__shared_weak_count *v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  _QWORD *v20;
  char v21;
  char v22;
  HTTPEngine *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  char *v36;
  __int128 v37;
  int64x2_t v38;
  uint64_t v39;
  void *v40;
  int v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  uint64_t v51;
  AuthenticationState *v52;
  __int128 *v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  std::__shared_weak_count *v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  NSObject *v64;
  unint64_t *v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  unint64_t *v70;
  unint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  std::__shared_weak_count *v79;
  unint64_t *p_shared_owners;
  unint64_t v81;
  uint64_t v82;
  unint64_t *v83;
  unint64_t v84;
  NSObject *v85;
  std::__shared_weak_count *v86;
  unint64_t *v87;
  unint64_t v88;
  std::__shared_weak_count *v89;
  uint64_t v90;
  char v91;
  unint64_t *v92;
  unint64_t v93;
  std::__shared_weak_count *v94;
  unint64_t *v95;
  unint64_t v96;
  std::__shared_weak_count *v97;
  unint64_t *v98;
  unint64_t v99;
  uint64_t v100;
  _QWORD v101[6];
  std::__shared_weak_count *v102;
  __int128 v103;
  uint64_t v104;
  std::__shared_weak_count *v105;
  uint64_t v106;
  std::__shared_weak_count *v107;
  AuthenticationState *v108;
  std::__shared_weak_count *v109;
  char v110;
  __int128 block;
  void (*v112)(uint64_t);
  __int128 *p_block;
  uint64_t v114;
  std::__shared_weak_count *v115;
  uint64_t v116;
  CFStreamError v117;

  v116 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 224))
    __assert_rtn("_onqueue_scheduleAndOpenWithHandler", "HTTPTransaction.cpp", 981, "!_callbackHandler");
  v5 = *(_DWORD *)(a1 + 80);
  if ((v5 - 10) >= 2 && v5 != 1)
    __assert_rtn("_onqueue_scheduleAndOpenWithHandler", "HTTPTransaction.cpp", 1013, "(_state == State::WaitingToEnqueue) || (_state == State::Canceled) || (_state == State::Error)");
  if (v5 != 11 && v5 != 1)
  {
    v21 = 0;
    v22 = 0;
    goto LABEL_142;
  }
  *(_QWORD *)(a1 + 224) = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 240) = _Block_copy(a4);
  *(_WORD *)(a1 + 32) |= 4u;
  HTTPTransaction::_onqueue_updateScheduling((HTTPTransaction *)a1, (const CoreSchedulingSet *)a2, 0);
  v21 = 0;
  v22 = 0;
  if (v5 == 1)
  {
    v104 = 0;
    v105 = 0;
    v10 = *(std::__shared_weak_count **)(a1 + 64);
    if (!v10)
      goto LABEL_132;
    v105 = std::__shared_weak_count::lock(v10);
    if (!v105)
      goto LABEL_132;
    v11 = *(_QWORD *)(a1 + 56);
    v104 = v11;
    if (!v11)
      goto LABEL_132;
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v103, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
    if (!(_QWORD)v103)
      __assert_rtn("enqueue", "HTTPConnection.cpp", 479, "transaction");
    v12 = *(unsigned __int16 *)(v11 + 32);
    v13 = v12 | (*(unsigned __int8 *)(v11 + 34) << 16);
    v14 = v12 & 3;
    if (v14 != 1)
    {
      if (*(_QWORD *)(v11 + 120) == *(_QWORD *)(v11 + 128) && (v12 & 0x80) != 0 && (v12 & 0x100) == 0)
      {
        v23 = *(HTTPEngine **)(v11 + 64);
        if (v23)
        {
          *(_BYTE *)(v11 + 34) = BYTE2(v13);
          *(_WORD *)(v11 + 32) = v13 | 0x100;
          HTTPEngine::_cleanupConnection(v23, 0);
        }
      }
LABEL_104:
      v72 = (std::__shared_weak_count *)*((_QWORD *)&v103 + 1);
      if (*((_QWORD *)&v103 + 1))
      {
        v73 = (unint64_t *)(*((_QWORD *)&v103 + 1) + 8);
        do
          v74 = __ldaxr(v73);
        while (__stlxr(v74 - 1, v73));
        if (!v74)
        {
          ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
          std::__shared_weak_count::__release_weak(v72);
        }
      }
      if (v14 == 1)
      {
        v75 = *(_DWORD *)(a1 + 80);
        if (v75 != 11)
        {
          if (v75 >= 3)
            __assert_rtn("_onqueue_changeState", "HTTPTransaction.cpp", 1664, "newState >= _state");
          *(_DWORD *)(a1 + 80) = 2;
        }
        *(_WORD *)(a1 + 32) |= 2u;
        v76 = *(_QWORD *)(a1 + 208);
        if (v76)
        {
          if (v104)
          {
            v77 = *(_QWORD *)(v104 + 64);
            if (v77)
            {
              v78 = *(_QWORD *)(v77 + 56);
              v79 = *(std::__shared_weak_count **)(v77 + 64);
              *(_QWORD *)&block = v78;
              *((_QWORD *)&block + 1) = v79;
              if (v79)
              {
                p_shared_owners = (unint64_t *)&v79->__shared_owners_;
                do
                  v81 = __ldxr(p_shared_owners);
                while (__stxr(v81 + 1, p_shared_owners));
                v76 = *(_QWORD *)(a1 + 208);
              }
              if (v76)
                v82 = v76 - 176;
              else
                v82 = 0;
              if (v78 && *(_QWORD *)(v82 + 80))
                (*(void (**)(uint64_t))(*(_QWORD *)v78 + 280))(v78);
              if (v79)
              {
                v83 = (unint64_t *)&v79->__shared_owners_;
                do
                  v84 = __ldaxr(v83);
                while (__stlxr(v84 - 1, v83));
                if (!v84)
                {
                  ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
                  std::__shared_weak_count::__release_weak(v79);
                }
              }
            }
          }
        }
        v22 = 1;
LABEL_137:
        v21 = v22 ^ 1;
        v86 = v105;
        if (v105)
        {
          v87 = (unint64_t *)&v105->__shared_owners_;
          do
            v88 = __ldaxr(v87);
          while (__stlxr(v88 - 1, v87));
          if (!v88)
          {
            ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
            std::__shared_weak_count::__release_weak(v86);
          }
        }
        goto LABEL_142;
      }
LABEL_132:
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v85 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v100 = *(_QWORD *)(a1 + 280);
        LODWORD(block) = 138543362;
        *(_QWORD *)((char *)&block + 4) = v100;
        _os_log_error_impl(&dword_183ECA000, v85, OS_LOG_TYPE_ERROR, "%{public}@ failed to enqueue", (uint8_t *)&block, 0xCu);
      }
      v117.domain = 4;
      *(_QWORD *)&v117.error = 4294967292;
      HTTPTransaction::_onqueue_handleError((HTTPTransaction *)a1, v117);
      v22 = 0;
      goto LABEL_137;
    }
    v15 = *(_QWORD **)(v11 + 128);
    v16 = *(_QWORD *)(v11 + 136);
    if ((unint64_t)v15 >= v16)
    {
      v24 = *(_QWORD *)(v11 + 120);
      v25 = ((uint64_t)v15 - v24) >> 4;
      v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 60)
        abort();
      v27 = v16 - v24;
      if (v27 >> 3 > v26)
        v26 = v27 >> 3;
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0)
        v28 = 0xFFFFFFFFFFFFFFFLL;
      else
        v28 = v26;
      if (v28 >> 60)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v29 = (char *)operator new(16 * v28);
      v30 = &v29[16 * v25];
      v31 = *((_QWORD *)&v103 + 1);
      *(_OWORD *)v30 = v103;
      if (v31)
      {
        v32 = (unint64_t *)(v31 + 8);
        do
          v33 = __ldxr(v32);
        while (__stxr(v33 + 1, v32));
      }
      v35 = *(_QWORD **)(v11 + 120);
      v34 = *(_QWORD **)(v11 + 128);
      if (v34 == v35)
      {
        v38 = vdupq_n_s64((unint64_t)v34);
        v36 = &v29[16 * v25];
      }
      else
      {
        v36 = &v29[16 * v25];
        do
        {
          v37 = *((_OWORD *)v34 - 1);
          v34 -= 2;
          *((_OWORD *)v36 - 1) = v37;
          v36 -= 16;
          *v34 = 0;
          v34[1] = 0;
        }
        while (v34 != v35);
        v38 = *(int64x2_t *)(v11 + 120);
      }
      v20 = v30 + 16;
      *(_QWORD *)(v11 + 120) = v36;
      *(_QWORD *)(v11 + 128) = v30 + 16;
      *(_QWORD *)(v11 + 136) = &v29[16 * v28];
      v39 = v38.i64[1];
      v40 = (void *)v38.i64[0];
      while ((void *)v39 != v40)
        v39 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v39 - 16);
      if (v40)
        operator delete(v40);
    }
    else
    {
      *v15 = v103;
      v17 = *((_QWORD *)&v103 + 1);
      v15[1] = *((_QWORD *)&v103 + 1);
      if (v17)
      {
        v18 = (unint64_t *)(v17 + 8);
        do
          v19 = __ldxr(v18);
        while (__stxr(v19 + 1, v18));
      }
      v20 = v15 + 2;
    }
    *(_QWORD *)(v11 + 128) = v20;
    v41 = *(unsigned __int16 *)(v11 + 32) | (*(unsigned __int8 *)(v11 + 34) << 16);
    if ((v41 & 0xA0000) == 0x20000)
    {
      if ((v41 & 0x40000) != 0)
      {
        if ((v41 & 0x10000) == 0)
          goto LABEL_54;
        v42 = v41 & 0xFFFDFFFF;
      }
      else
      {
        v42 = v41 & 0xFFF8FFFF | 0x50000;
      }
      *(_WORD *)(v11 + 32) = v42;
      *(_BYTE *)(v11 + 34) = BYTE2(v42);
    }
LABEL_54:
    v43 = v103;
    if (!*(_QWORD *)(v11 + 144))
    {
      std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v11 + 144), v103, *((uint64_t *)&v103 + 1));
      v44 = *(_QWORD *)(v11 + 64);
      v45 = (void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v11 + 144) + 40))(*(_QWORD *)(v11 + 144));

      *(_QWORD *)(v44 + 336) = v45;
      v43 = v103;
    }
    if (!*(_QWORD *)(v11 + 160))
    {
      std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v11 + 160), v43, *((uint64_t *)&v103 + 1));
      v46 = *(_QWORD *)(v11 + 64);
      v47 = (void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v11 + 160) + 40))(*(_QWORD *)(v11 + 160));

      *(_QWORD *)(v46 + 328) = v47;
      v43 = v103;
    }
    v48 = *((_QWORD *)&v103 + 1);
    v106 = v43;
    v107 = (std::__shared_weak_count *)*((_QWORD *)&v103 + 1);
    if (*((_QWORD *)&v103 + 1))
    {
      v49 = (unint64_t *)(*((_QWORD *)&v103 + 1) + 8);
      do
        v50 = __ldxr(v49);
      while (__stxr(v50 + 1, v49));
    }
    if ((*(_WORD *)(v11 + 32) & 2) != 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(block) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Never check for auth triggers while negotiating auth.", (uint8_t *)&block, 2u);
    }
    v51 = *(_QWORD *)(v43 + 208);
    if (!v51)
    {
      v108 = 0;
      v109 = 0;
      goto LABEL_76;
    }
    (*(void (**)(AuthenticationState **__return_ptr))(*(_QWORD *)v51 + 88))(&v108);
    if (!v108 || !AuthenticationState::isConnectionBased(v108))
      goto LABEL_76;
    v52 = *(AuthenticationState **)(v11 + 176);
    if (AuthenticationState::addsConnectionAuth(v52, v108))
    {
LABEL_75:
      *(_WORD *)(v11 + 32) |= 2u;
      std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v11 + 192), v43, v48);
      AuthenticationState::incorporate(*(AuthenticationState **)(v11 + 176), v108);
LABEL_76:
      v55 = v109;
      if (v109)
      {
        v56 = (unint64_t *)&v109->__shared_owners_;
        do
          v57 = __ldaxr(v56);
        while (__stlxr(v57 - 1, v56));
        if (!v57)
        {
          ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
          std::__shared_weak_count::__release_weak(v55);
        }
      }
      v58 = v107;
      if (v107)
      {
        v59 = (unint64_t *)&v107->__shared_owners_;
        do
          v60 = __ldaxr(v59);
        while (__stlxr(v60 - 1, v59));
        if (!v60)
        {
          ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
          std::__shared_weak_count::__release_weak(v58);
        }
      }
      v61 = *(std::__shared_weak_count **)(v11 + 48);
      if (v61)
      {
        v62 = std::__shared_weak_count::lock(v61);
        if (v62)
          v63 = *(_QWORD *)(v11 + 40);
        else
          v63 = 0;
      }
      else
      {
        v63 = 0;
        v62 = 0;
      }
      v64 = *(NSObject **)(v11 + 56);
      *(_QWORD *)&block = MEMORY[0x1E0C809B0];
      *((_QWORD *)&block + 1) = 3321888768;
      v112 = ___ZN14HTTPConnection7enqueueENSt3__110shared_ptrI15HTTPTransactionEE_block_invoke;
      p_block = (__int128 *)&__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e5_v8__0l;
      v114 = v63;
      v115 = v62;
      if (v62)
      {
        v65 = (unint64_t *)&v62->__shared_owners_;
        do
          v66 = __ldxr(v65);
        while (__stxr(v66 + 1, v65));
      }
      dispatch_async(v64, &block);
      v67 = v115;
      if (v115)
      {
        v68 = (unint64_t *)&v115->__shared_owners_;
        do
          v69 = __ldaxr(v68);
        while (__stlxr(v69 - 1, v68));
        if (!v69)
        {
          ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
          std::__shared_weak_count::__release_weak(v67);
        }
      }
      if (v62)
      {
        v70 = (unint64_t *)&v62->__shared_owners_;
        do
          v71 = __ldaxr(v70);
        while (__stlxr(v71 - 1, v70));
        if (!v71)
        {
          ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
          std::__shared_weak_count::__release_weak(v62);
        }
      }
      goto LABEL_104;
    }
    v110 = 0;
    *(_QWORD *)&block = &off_1E14F0708;
    *((_QWORD *)&block + 1) = v52;
    v112 = (void (*)(uint64_t))&v110;
    p_block = &block;
    AuthenticationState::_foreachAuthenticationInfo((uint64_t)v52, (uint64_t)&block);
    v53 = p_block;
    if (p_block == &block)
    {
      v54 = 4;
      v53 = &block;
    }
    else
    {
      if (!p_block)
        goto LABEL_74;
      v54 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v53 + 8 * v54))();
LABEL_74:
    if (!v110)
      goto LABEL_76;
    goto LABEL_75;
  }
LABEL_142:
  if ((*(_WORD *)(a1 + 32) & 4) != 0)
  {
    if (v5 == 11 || v5 == 1)
    {
      v91 = v21 | v22;
      if (v5 != 1)
        v91 = 1;
    }
    else
    {
      v91 = 0;
    }
    *(_BYTE *)(a1 + 248) = v91;
    HTTPTransaction::_onqueue_invokeHandler((HTTPTransaction *)a1);
  }
  else
  {
    if (!*(_DWORD *)(a2 + 40))
      __assert_rtn("_onqueue_scheduleAndOpenWithHandler", "HTTPTransaction.cpp", 1129, "!ss->isEmpty()");
    block = 0uLL;
    v89 = *(std::__shared_weak_count **)(a1 + 48);
    if (v89 && (v89 = std::__shared_weak_count::lock(v89), (*((_QWORD *)&block + 1) = v89) != 0))
    {
      v90 = *(_QWORD *)(a1 + 40);
      *(_QWORD *)&block = v90;
    }
    else
    {
      v90 = 0;
    }
    v101[0] = MEMORY[0x1E0C809B0];
    v101[1] = 3321888768;
    v101[2] = ___ZN15HTTPTransaction35_onqueue_scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke;
    v101[3] = &unk_1E14F2FE8;
    v101[4] = a4;
    v101[5] = v90;
    v102 = v89;
    if (v89)
    {
      v92 = (unint64_t *)&v89->__shared_owners_;
      do
        v93 = __ldxr(v92);
      while (__stxr(v93 + 1, v92));
    }
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)a2 + 96))(a2, v101);
    v94 = v102;
    if (v102)
    {
      v95 = (unint64_t *)&v102->__shared_owners_;
      do
        v96 = __ldaxr(v95);
      while (__stlxr(v96 - 1, v95));
      if (!v96)
      {
        ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
        std::__shared_weak_count::__release_weak(v94);
      }
    }
    v97 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
    if (*((_QWORD *)&block + 1))
    {
      v98 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
      do
        v99 = __ldaxr(v98);
      while (__stlxr(v99 - 1, v98));
      if (!v99)
      {
        ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
        std::__shared_weak_count::__release_weak(v97);
      }
    }
  }
}

void sub_1840EFAE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char *a30)
{
  char *v30;
  char *v32;
  uint64_t v33;

  v32 = a30;
  if (a30 == v30)
  {
    v33 = 4;
    v32 = &a27;
  }
  else
  {
    if (!a30)
      goto LABEL_6;
    v33 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v32 + 8 * v33))();
LABEL_6:
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a24);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a20);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTPTransaction35_onqueue_scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  *(_BYTE *)(*(_QWORD *)(a1 + 40) + 249) = 0;
  return result;
}

_QWORD *__copy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14__CFReadStreamEE56c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14__CFReadStreamEE56c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 40;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void ___ZN15HTTPTransaction15startStallTimerEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  CFNumberRef v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  int valuePtr;
  uint64_t v11;
  std::__shared_weak_count *v12;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(std::__shared_weak_count **)(v2 + 48);
  if (v3 && (v4 = std::__shared_weak_count::lock(v3), (v12 = v4) != 0))
  {
    v5 = v4;
    v6 = *(_QWORD *)(v2 + 40);
    v11 = v6;
    if (v6)
    {
      valuePtr = 3;
      v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
      if (v7)
      {
        (*(void (**)(uint64_t, uint64_t, CFNumberRef))(*(_QWORD *)v6 + 208))(v6, 0x1EDCF9DF0, v7);
        CFRelease(v7);
      }
    }
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
  }
}

void sub_1840EFD20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 AwaitingTube::getOptions@<Q0>(AwaitingTube *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result;

  result = *(__n128 *)((char *)this + 56);
  *a2 = result;
  a2[1].n128_u64[0] = *((_QWORD *)this + 9);
  return result;
}

void `non-virtual thunk to'AwaitingTube::~AwaitingTube(AwaitingTube *this)
{
  AwaitingTube::~AwaitingTube((AwaitingTube *)((char *)this - 24));
}

void `non-virtual thunk to'AwaitingTube::~AwaitingTube(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  AwaitingTube::~AwaitingTube((AwaitingTube *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

uint64_t _CFURLStorageSessionGetTypeID()
{
  if (StorageSession::Class(void)::sOnce_StorageSession != -1)
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
  return *(_QWORD *)(StorageSession::Class(void)::sClass_OBJTYPE + 96);
}

uint64_t _CFURLStorageSessionCreateWithData()
{
  uint8_t v1[16];

  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v1 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "This function should never be called", v1, 2u);
  }
  return 0;
}

char *_CFURLStorageSessionGetDefault(const __CFAllocator *a1)
{
  char *result;

  result = (char *)_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault;
  if (!_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault)
  {
    result = StorageSession::copyProcessDefault(0) - 16;
    _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault = (uint64_t)result;
  }
  return result;
}

char *_CFURLStorageSessionCopyProcessDefault(StorageSession *a1)
{
  return StorageSession::copyProcessDefault(a1) - 16;
}

CFTypeRef _CFURLStorageSessionCopyIdentifier(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  CFTypeRef result;

  if (StorageSession::Class(void)::sOnce_StorageSession != -1)
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
  v3 = a2 + 16;
  if (!a2)
    v3 = 0;
  result = *(CFTypeRef *)(v3 + 72);
  if (result)
    return CFRetain(result);
  return result;
}

void SerializableArchive::add(SerializableArchive **this, CFURLRef relativeURL, const __CFURL *a3)
{
  const __CFURL *v4;
  const __CFURL *v5;
  CFStringRef v6;

  v4 = CFURLCopyAbsoluteURL(relativeURL);
  if (v4)
  {
    v5 = v4;
    v6 = CFURLGetString(v4);
    SerializableArchive::assertEmpty(*this, CFSTR("valu"));
    if (v6)
      CFDictionarySetValue(*this, CFSTR("valu"), v6);
    CFRelease(v5);
  }
}

CFURLRef DeserializableArchive::deserialize(const __CFString *this, CFURLRef *a2, const __CFURL **a3)
{
  const __CFAllocator *v5;
  CFURLRef result;

  v5 = CFGetAllocator(this);
  result = CFURLCreateWithString(v5, this, 0);
  *a2 = result;
  return result;
}

void SerializableArchive::add(CFTypeRef *this, const __CFString *a2, __CFError *a3)
{
  const __CFAllocator *v6;
  CFMutableDictionaryRef Mutable;
  CFErrorDomain Domain;
  const __CFAllocator *Code;
  CFTypeRef v10;
  const __CFDictionary *v11;
  CFMutableDictionaryRef v12;
  void (**v13)(AutoScalar *__hidden);
  CFTypeRef cf;

  if (a3)
  {
    v6 = CFGetAllocator(*this);
    Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v12 = Mutable;
    Domain = CFErrorGetDomain(a3);
    SerializableArchive::assertEmpty(Mutable, CFSTR("domain"));
    if (Domain)
      CFDictionarySetValue(Mutable, CFSTR("domain"), Domain);
    Code = (const __CFAllocator *)CFErrorGetCode(a3);
    AutoScalar::AutoScalar((AutoScalar *)&v13, Code);
    v10 = cf;
    SerializableArchive::assertEmpty(Mutable, CFSTR("code"));
    if (v10)
      CFDictionarySetValue(Mutable, CFSTR("code"), v10);
    v13 = &off_1E14E47E8;
    if (cf)
      CFRelease(cf);
    v11 = CFErrorCopyUserInfo(a3);
    if (v11)
    {
      SerializableArchive::add((CFTypeRef *)&v12, CFSTR("userinfo"), v11);
      CFRelease(v11);
    }
    SerializableArchive::assertEmpty((SerializableArchive *)*this, a2);
    CFDictionarySetValue((CFMutableDictionaryRef)*this, a2, Mutable);
    if (Mutable)
      CFRelease(Mutable);
  }
}

void sub_1840F00C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  const void *v12;

  if (cf)
    CFRelease(cf);
  if (v12)
    CFRelease(v12);
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2, void *cf)
{
  const __CFAllocator *v6;
  CFDictionaryRef v7;

  if (cf)
  {
    v6 = CFGetAllocator(cf);
    v7 = URLResponse::copyPropertyList((URLResponse *)objc_msgSend(cf, "_inner"), v6);
    SerializableArchive::assertEmpty(*this, a2);
    if (v7)
    {
      CFDictionarySetValue(*this, a2, v7);
      CFRelease(v7);
    }
  }
}

void SerializableArchive::add(CFTypeRef *this, __CFString *a2, NSURLRequest *a3)
{
  const __CFAllocator *v5;
  const __CFAllocator *v6;
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v8;
  void **v9;
  uint64_t v10;
  const __CFArray *v11;
  CFTypeRef v12;
  CFDictionaryRef v13;
  const void *v14;
  const __CFAllocator *v15;
  CFMutableDictionaryRef v16;
  CFDictionaryRef theDict;
  uint64_t v18;
  void **v19;
  __CFAllocator *v20;
  void (**v21)(AutoScalar *__hidden);
  CFTypeRef cf;

  v19 = 0;
  v20 = 0;
  theDict = 0;
  v18 = 0;
  v5 = CFGetAllocator(*this);
  if (a2)
    URLRequest::createArchiveList((URLRequest *)-[__CFString _inner](a2, "_inner"), v5, (uint64_t *)&v20, (const void ***)&v19, &v18, &theDict);
  else
    v18 = 22;
  v6 = CFGetAllocator(*this);
  Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v16 = Mutable;
  v8 = CFGetAllocator(*this);
  v10 = v18;
  v9 = v19;
  v11 = CFArrayCreate(v8, (const void **)v19, v18, MEMORY[0x1E0C9B378]);
  AutoScalar::AutoScalar((AutoScalar *)&v21, (const __CFAllocator *)v20);
  v12 = cf;
  SerializableArchive::assertEmpty(Mutable, CFSTR("version"));
  if (v12)
    CFDictionarySetValue(Mutable, CFSTR("version"), v12);
  v21 = &off_1E14E47E8;
  if (cf)
    CFRelease(cf);
  SerializableArchive::add((SerializableArchive *)&v16, CFSTR("objects"), v11);
  if (v11)
    CFRelease(v11);
  v13 = theDict;
  if (theDict)
  {
    SerializableArchive::add((CFTypeRef *)&v16, CFSTR("protocolProperties"), theDict);
    CFRelease(v13);
  }
  SerializableArchive::assertEmpty((SerializableArchive *)*this, CFSTR("valu"));
  CFDictionarySetValue((CFMutableDictionaryRef)*this, CFSTR("valu"), Mutable);
  if (v10 >= 1)
  {
    do
    {
      v14 = v9[v10 - 1];
      if (v14)
        CFRelease(v14);
      --v10;
    }
    while ((unint64_t)(v10 + 1) > 1);
  }
  v15 = CFGetAllocator(*this);
  CFAllocatorDeallocate(v15, v9);
  if (Mutable)
    CFRelease(Mutable);
}

void sub_1840F034C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf)
{
  const void *v16;

  if (cf)
    CFRelease(cf);
  if (v16)
    CFRelease(v16);
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(CFTypeRef *this, const __CFString *a2, __SecAccessControl *a3)
{
  const __CFAllocator *v4;
  SerializableArchive *Mutable;
  const void *v6;

  v4 = CFGetAllocator(*this);
  Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v6 = (const void *)SecAccessControlCopyData();
  if (v6)
  {
    SerializableArchive::assertEmpty(Mutable, CFSTR("data"));
    CFDictionarySetValue(Mutable, CFSTR("data"), v6);
    CFRelease(v6);
  }
  SerializableArchive::assertEmpty((SerializableArchive *)*this, CFSTR("valu"));
  CFDictionarySetValue((CFMutableDictionaryRef)*this, CFSTR("valu"), Mutable);
  if (Mutable)
    CFRelease(Mutable);
}

void sub_1840F044C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2, __SecKey *a3)
{
  SerializableArchive::assertEmpty(*this, CFSTR("valu"));
  CFDictionarySetValue(*this, CFSTR("valu"), CFSTR("key_not_serialized"));
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2, _CFURLAuthChallenge *a3)
{
  const __CFAllocator *v5;
  CFTypeRef cf;

  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  SerializableArchive::assertEmpty(*this, CFSTR("valu"));
  v5 = CFGetAllocator(*this);
  cf = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if ((*(unsigned int (**)(uint64_t *, CFTypeRef *))(a2->length + 24))(&a2->length, &cf))
    SerializableArchive::add((CFTypeRef *)this, CFSTR("valu"), (CFDictionaryRef)cf);
  if (cf)
    CFRelease(cf);
}

void sub_1840F0560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::deserialize(DeserializableArchive *this, CFErrorRef *a2, __CFError **a3)
{
  const __CFDictionary *v5;
  const void *Value;
  const __CFString *v7;
  const __CFNumber *v8;
  CFIndex v9;
  CFTypeID TypeID;
  const __CFDictionary *v11;
  const __CFAllocator *v12;
  _QWORD v13[2];
  const __CFDictionary *valuePtr;

  v13[1] = CFGetAllocator(this);
  v5 = (const __CFDictionary *)CFRetain(this);
  v13[0] = v5;
  Value = CFDictionaryGetValue(v5, CFSTR("domain"));
  if (Value)
    v7 = (const __CFString *)CFRetain(Value);
  else
    v7 = 0;
  v8 = (const __CFNumber *)CFDictionaryGetValue(v5, CFSTR("code"));
  if (v8)
  {
    valuePtr = 0;
    CFNumberGetValue(v8, kCFNumberCFIndexType, &valuePtr);
    v9 = (CFIndex)valuePtr;
  }
  else
  {
    v9 = 0;
  }
  valuePtr = 0;
  TypeID = CFDictionaryGetTypeID();
  DeserializableArchive::decant((DeserializableArchive *)v13, CFSTR("userinfo"), TypeID, (const void **)&valuePtr);
  v11 = valuePtr;
  if (a2)
  {
    v12 = CFGetAllocator(this);
    *a2 = CFErrorCreate(v12, v7, v9, v11);
  }
  if (v7)
    CFRelease(v7);
  if (v11)
    CFRelease(v11);
  if (v5)
    CFRelease(v5);
}

void sub_1840F0680(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::deserialize(DeserializableArchive *this, uint64_t *a2, __SecAccessControl **a3)
{
  const __CFDictionary *v5;
  const void *Value;
  CFTypeRef v7;

  CFGetAllocator(this);
  v5 = (const __CFDictionary *)CFRetain(this);
  Value = CFDictionaryGetValue(v5, CFSTR("data"));
  if (Value)
  {
    v7 = CFRetain(Value);
    if (v7)
    {
      CFGetAllocator(this);
      *a2 = SecAccessControlCreateFromData();
      CFRelease(v7);
    }
  }
  if (v5)
    CFRelease(v5);
}

void sub_1840F072C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::decantClass(CFDictionaryRef *this, const __CFString *a2, objc_class *a3, id *a4)
{
  const void *Value;
  const void *v8;
  const void *v9;
  const __CFDictionary *v10;
  const __CFNumber *v11;
  uint64_t v12;
  CFTypeID TypeID;
  const __CFArray *v14;
  CFTypeID v15;
  const __CFDictionary *v16;
  CFIndex Count;
  const void **v18;
  CFAllocatorRef v19;
  const __CFArray *valuePtr;
  _BYTE buf[22];
  uint64_t v22;
  CFRange v23;

  v22 = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  Value = CFDictionaryGetValue(*this, a2);
  if (Value)
  {
    v8 = Value;
    if ((objc_class *)objc_opt_class() == a3)
    {
      CFGetAllocator(v8);
      *a4 = (id)_CFURLResponseCreateFromPropertyList((const __CFAllocator *)v8, v9);
    }
    else if ((objc_class *)objc_opt_class() == a3)
    {
      *(_QWORD *)&buf[8] = CFGetAllocator(v8);
      v10 = (const __CFDictionary *)CFRetain(v8);
      *(_QWORD *)buf = v10;
      v11 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("version"));
      if (v11)
      {
        valuePtr = 0;
        CFNumberGetValue(v11, kCFNumberCFIndexType, &valuePtr);
        v12 = (uint64_t)valuePtr;
      }
      else
      {
        v12 = 0;
      }
      valuePtr = 0;
      TypeID = CFArrayGetTypeID();
      DeserializableArchive::decant((DeserializableArchive *)buf, CFSTR("objects"), TypeID, (const void **)&valuePtr);
      v14 = valuePtr;
      if (valuePtr)
      {
        valuePtr = 0;
        v15 = CFDictionaryGetTypeID();
        DeserializableArchive::decant((DeserializableArchive *)buf, CFSTR("protocolProperties"), v15, (const void **)&valuePtr);
        v16 = valuePtr;
        Count = CFArrayGetCount(v14);
        v18 = (const void **)operator new[]();
        v23.location = 0;
        v23.length = Count;
        CFArrayGetValues(v14, v23, v18);
        v19 = CFGetAllocator(v8);
        *a4 = _CFURLRequestCreateFromArchiveList((uint64_t)v19, v12, v18, Count, v16);
        MEMORY[0x186DB7474](v18, 0xC0C80B8AA526DLL);
        CFRelease(v14);
        if (v16)
          CFRelease(v16);
      }
      if (v10)
        CFRelease(v10);
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = a2;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = a3;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Unable to deserialize key %@ as class %@ - is there a specialization", buf, 0x16u);
    }
  }
}

void sub_1840F0998(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::decant(const __CFAllocator **this, const __CFString *a2, Serializable **a3)
{
  CFTypeID TypeID;
  const void *v7;
  const __CFDictionary *v8;
  const __CFAllocator *v9;
  const void *Value;
  const __CFString *v11;
  const __CFString *v12;
  int ExactString;
  const void *v14;
  char *v15;
  char *v16;
  Serializable *v17;
  uint64_t v18;
  _BYTE cf[24];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)cf = 0;
  TypeID = CFDictionaryGetTypeID();
  DeserializableArchive::decant((DeserializableArchive *)this, a2, TypeID, (const void **)cf);
  v7 = *(const void **)cf;
  if (!*(_QWORD *)cf)
  {
    *a3 = 0;
    return;
  }
  v8 = (const __CFDictionary *)CFRetain(*(CFTypeRef *)cf);
  v9 = this[1];
  Value = CFDictionaryGetValue(v8, CFSTR("_kind"));
  if (!Value || (v11 = (const __CFString *)CFRetain(Value), (v12 = v11) == 0))
  {
    v17 = 0;
    goto LABEL_34;
  }
  ExactString = _findExactString(v11, 0xDu);
  switch(ExactString)
  {
    case 561110140:
      v15 = (char *)_CFURLAuthChallengeCreateFromArchive(v9, v8);
      if (v15)
      {
        if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
          dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
        v16 = v15 + 16;
      }
      else
      {
        v16 = 0;
      }
      break;
    case 562125956:
      v18 = URLCredential::createFromPropertyList(v9, v8, v14);
      if (v18)
        v15 = (char *)(v18 - 16);
      else
        v15 = 0;
      if (v18)
      {
        if (URLCredential::Class(void)::sOnce_URLCredential != -1)
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
        v16 = v15 + 16;
      }
      else
      {
        v16 = 0;
      }
      break;
    case 563223690:
      v15 = (char *)_CFURLProtectionSpaceCreateFromArchive(v9, v8);
      if (v15)
      {
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
        v16 = v15 + 16;
      }
      else
      {
        v16 = 0;
      }
      break;
    default:
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)cf = 138412290;
        *(_QWORD *)&cf[4] = v12;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Don't know how to deserialize %@", cf, 0xCu);
      }
      v17 = 0;
      goto LABEL_33;
  }
  CFRetain(v16 - 16);
  CFRelease(v15);
  if (v16)
    v17 = (Serializable *)(v16 + 8);
  else
    v17 = 0;
LABEL_33:
  CFRelease(v12);
LABEL_34:
  *a3 = v17;
  CFRelease(v7);
  if (v8)
    CFRelease(v8);
}

void sub_1840F0C64(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void HTTPBodyData::~HTTPBodyData(HTTPBodyData *this, const char *a2)
{
  *(_QWORD *)this = off_1E14E5A48;
  HTTPBodyData::becomeEmpty(this, a2);
}

const __CFData *HTTPBodyData::getLength(const __CFData **this, const char *a2)
{
  const __CFData *result;

  HTTPBodyData::logit((HTTPBodyData *)this, a2);
  result = this[2];
  if (result)
    return (const __CFData *)CFDataGetLength(result);
  result = this[3];
  if (result)
    return (const __CFData *)CFDataGetLength(result);
  return result;
}

void SAwaitingTube::~SAwaitingTube(SAwaitingTube *this)
{
  uint64_t v2;

  SAwaitingTube::~SAwaitingTube(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E14E67F0;
  *((_QWORD *)this + 3) = &unk_1E14E6878;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 4) + 48))(*((_QWORD *)this + 4));
  *((_QWORD *)this + 4) = 0;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 6) + 24))(*((_QWORD *)this + 6));
  *((_QWORD *)this + 6) = 0;
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 10) = 0;
  }
  CFRelease((CFTypeRef)(*((_QWORD *)this + 5) - 16));
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

uint64_t SAwaitingTube::linkWithTube(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    *(_QWORD *)(a1 + 80) = 0;
  }
  if (a2)
  {
    *(_QWORD *)(a1 + 80) = a2;
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
    v5 = *(_QWORD *)(a1 + 80);
  }
  else
  {
    v5 = 0;
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 56))(*(_QWORD *)(a1 + 48), v5);
}

uint64_t SAwaitingTube::getClient(SAwaitingTube *this)
{
  return *((_QWORD *)this + 6);
}

uint64_t SAwaitingTube::getRequest(SAwaitingTube *this)
{
  return *((_QWORD *)this + 5);
}

__n128 SAwaitingTube::getOptions@<Q0>(SAwaitingTube *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result;

  result = *(__n128 *)((char *)this + 56);
  *a2 = result;
  a2[1].n128_u64[0] = *((_QWORD *)this + 9);
  return result;
}

void SAwaitingTube::getRequestToEnqueue(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4)
{
  __int128 v4;

  *a3 = *(_QWORD *)(a1 + 40);
  *a2 = *(_QWORD *)(a1 + 48);
  v4 = *(_OWORD *)(a1 + 56);
  *(_QWORD *)(a4 + 16) = *(_QWORD *)(a1 + 72);
  *(_OWORD *)a4 = v4;
  *(CFAbsoluteTime *)(a1 + 96) = CFAbsoluteTimeGetCurrent();
}

BOOL SAwaitingTube::isValid(SAwaitingTube *this)
{
  return (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 6) + 184))(*((_QWORD *)this + 6)) != 0;
}

void `non-virtual thunk to'SAwaitingTube::~SAwaitingTube(SAwaitingTube *this)
{
  SAwaitingTube::~SAwaitingTube((SAwaitingTube *)((char *)this - 24));
}

void `non-virtual thunk to'SAwaitingTube::~SAwaitingTube(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  SAwaitingTube::~SAwaitingTube((SAwaitingTube *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_1840F0EDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

CFStringRef StorageSession::copyDebugDesc(const __CFDictionary **this)
{
  CFStringRef v2;
  const __CFAllocator *v3;
  _BOOL8 v4;
  const __CFDictionary *v5;
  const void *v6;
  _BOOL4 v7;
  const __CFDictionary *v8;
  _BOOL8 v9;
  CFStringRef v10;

  v2 = CFObject::copyDebugDescHeader((CFObject *)this);
  v3 = CFGetAllocator(this - 2);
  v4 = *((_BYTE *)this + 56) != 0;
  v5 = this[10];
  if (v5)
  {
    v7 = CFDictionaryGetValue(v5, CFSTR("kCFURLStorageSessionIsPrivate")) == (const void *)*MEMORY[0x1E0C9AE50];
    v8 = this[10];
    if (v8)
    {
      v6 = (const void *)*MEMORY[0x1E0C9AE50];
      v9 = CFDictionaryGetValue(v8, CFSTR("kCFURLStorageSessionProcessSharing")) == v6;
      goto LABEL_6;
    }
  }
  else
  {
    v7 = 0;
  }
  v9 = 0;
LABEL_6:
  v10 = CFStringCreateWithFormat(v3, 0, CFSTR("%@{ default: %d private: %d process-sharing: %d ident: %@, cache = %p, cookies = %p, auth = %p, hsts = %p }"), v2, v4, v7, v9, this[9], this[2], this[3], this[4], this[5]);
  if (v2)
    CFRelease(v2);
  return v10;
}

void `non-virtual thunk to'StorageSession::~StorageSession(StorageSession *this)
{
  StorageSession::~StorageSession((StorageSession *)((char *)this - 8));
}

{
  StorageSession::~StorageSession((StorageSession *)((char *)this - 8));
}

void StorageSession::~StorageSession(StorageSession *this)
{
  const __CFDictionary *v2;
  char *v3;
  const void *v4;
  CFTypeRef v5;
  NSObject *global_queue;
  uint64_t v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  _QWORD block[5];

  *(_QWORD *)this = &off_1E14E72B0;
  *((_QWORD *)this + 1) = &unk_1E14E72F8;
  v2 = (const __CFDictionary *)*((_QWORD *)this + 10);
  if (v2 && CFDictionaryGetValue(v2, CFSTR("kCFURLStorageSessionIsPrivate")) == (const void *)*MEMORY[0x1E0C9AE50])
  {
    v3 = (char *)*((_QWORD *)this + 3);
    if (v3)
      CFHTTPCookieStorageDeleteAllCookies(v3);
    v4 = (const void *)*((_QWORD *)this + 2);
    if (v4)
    {
      v5 = CFRetain(v4);
      global_queue = dispatch_get_global_queue(0, 0);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZN14StorageSessionD2Ev_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v5;
      dispatch_async(global_queue, block);
    }
    v7 = *((_QWORD *)this + 5);
    if (v7)
      _CFHSTSPolicyResetHSTSHostsSinceDate(v7, 0);
  }
  v8 = (const void *)*((_QWORD *)this + 2);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 3);
  if (v9)
    CFRelease(v9);
  v10 = (const void *)*((_QWORD *)this + 4);
  if (v10)
    CFRelease(v10);
  v11 = (const void *)*((_QWORD *)this + 5);
  if (v11)
    CFRelease(v11);
  v12 = (const void *)*((_QWORD *)this + 9);
  if (v12)
    CFRelease(v12);
  v13 = (const void *)*((_QWORD *)this + 10);
  if (v13)
    CFRelease(v13);
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_1840F1118(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ___ZN14StorageSessionD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  const void *v9;

  CFURLCacheRemoveAllCachedResponses(*(_QWORD **)(a1 + 32));
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v4 = *(_QWORD *)(v2 + 16);
    v3 = *(std::__shared_weak_count **)(v2 + 24);
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 56));
    *(_BYTE *)(v4 + 40) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 56));
    if (v3)
    {
      v7 = (unint64_t *)&v3->__shared_owners_;
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v9 = *(const void **)(a1 + 32);
    if (v9)
      CFRelease(v9);
  }
}

void sub_1840F11F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

CFTypeRef StorageSession::copyHSTSStorage(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  const __CFDictionary *v3;
  const void *v4;
  const void *v5;
  uint64_t *v6;
  const __CFAllocator *v7;
  uint64_t v8;
  const __CFAllocator *v9;
  __CFDictionary *MutableDictionary;
  CFAllocatorRef v11;
  CFTypeRef result;

  v2 = this + 12;
  os_unfair_lock_lock(this + 12);
  if (!HIBYTE(this[13]._os_unfair_lock_opaque))
  {
    HIBYTE(this[13]._os_unfair_lock_opaque) = 1;
    if (!*(_QWORD *)&this[10]._os_unfair_lock_opaque)
    {
      v3 = *(const __CFDictionary **)&this[20]._os_unfair_lock_opaque;
      if (v3 && CFDictionaryGetValue(v3, CFSTR("kCFURLStorageSessionIsPrivate")) == (const void *)*MEMORY[0x1E0C9AE50])
      {
        v7 = CFGetAllocator(&this[-4]);
        v5 = CFStringCreateWithFormat(v7, 0, CFSTR("%@-%ld"), *(_QWORD *)&this[18]._os_unfair_lock_opaque, *(_QWORD *)&this[16]._os_unfair_lock_opaque);
        v6 = (uint64_t *)MEMORY[0x1E0C9AE40];
      }
      else
      {
        v4 = *(const void **)&this[18]._os_unfair_lock_opaque;
        if (v4)
          v5 = CFRetain(v4);
        else
          v5 = 0;
        v6 = (uint64_t *)MEMORY[0x1E0C9AE50];
      }
      v8 = *v6;
      v9 = CFGetAllocator(&this[-4]);
      MutableDictionary = cfTypeCreateMutableDictionary(v9, CFSTR("hsts_identifier"), v5, CFSTR("hsts_persistent"), v8, 0, 0);
      if (v5)
        CFRelease(v5);
      v11 = CFGetAllocator(&this[-4]);
      *(_QWORD *)&this[10]._os_unfair_lock_opaque = _CFHSTSPolicyCreateWithProperties((uint64_t)v11, MutableDictionary);
      if (MutableDictionary)
        CFRelease(MutableDictionary);
    }
  }
  os_unfair_lock_unlock(v2);
  result = *(CFTypeRef *)&this[10]._os_unfair_lock_opaque;
  if (result)
    return CFRetain(result);
  return result;
}

void ___ZL25ConnectionProtocolConnectP11nw_protocolS0__block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 32) + 384))(*(_QWORD *)(a1 + 32), a3);
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 32) + 392))(*(_QWORD *)(a1 + 32), a4);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 352))(*(_QWORD *)(a1 + 32));
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v8 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 256))(*(_QWORD *)(a1 + 32));
    v10 = 134218242;
    v11 = v9;
    v12 = 2112;
    v13 = a5;
    _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "TIC Coalescing TCP Conn [%llu] may go into %@", (uint8_t *)&v10, 0x16u);
  }
}

uint64_t ___ZN18H2CoalescingEngine29findCoalescingConnectionEntryEP14__CFDictionaryPKS0_PK10__CFStringPK9__CFArrayU13block_pointerFvS6_S9_PK8__CFDataS6_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

_QWORD *TransportConnection::setConnectionEstablishmentDelegate(uint64_t a1, uint64_t *a2)
{
  return std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 144), *a2, a2[1]);
}

void TransportConnection::rstConnectionEstablishmentDelegate(TransportConnection *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 19);
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void TransportConnection::setConnectionDelegate(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  v3 = *a2;
  v2 = a2[1];
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = *(std::__shared_weak_count **)(a1 + 168);
  *(_QWORD *)(a1 + 160) = v3;
  *(_QWORD *)(a1 + 168) = v2;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void TransportConnection::rstConnectionDelegate(TransportConnection *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void TransportConnection::initialize(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;

  v3 = *a2;
  v2 = a2[1];
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = *(std::__shared_weak_count **)(a1 + 216);
  *(_QWORD *)(a1 + 208) = v3;
  *(_QWORD *)(a1 + 216) = v2;
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void ___ZN19TransportConnection13associateTaskEP16NSURLSessionTaskNS_20TaskAssociationEventEP24__CFN_TransactionMetrics_block_invoke(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  CFNumberRef v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t valuePtr;

  valuePtr = a2;
  v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)(a1 + 32);
      if (v6)
      {
        v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongLongType, &valuePtr);
        (*(void (**)(uint64_t, uint64_t, CFNumberRef))(*(_QWORD *)v6 + 200))(v6, 0x1EDCF98B0, v7);
        if (v7)
          CFRelease(v7);
      }
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_1840F1708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  const void *v10;

  if (v10)
    CFRelease(v10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<NSObject  {objcproto17OS_dispatch_queue}*,Deleter_DispatchRelease<NSObject  {objcproto17OS_dispatch_queue}*>,std::allocator<NSObject  {objcproto17OS_dispatch_queue}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

CFStringRef TransportConnection::RefCountedWrapper::copyDebugDesc(TransportConnection::RefCountedWrapper *this)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, CFSTR("Wrapping TransportConnection(%p)"), *((_QWORD *)this + 1));
}

void ___ZN9TCFObjectIN19TransportConnection17RefCountedWrapperEE5ClassEv_block_invoke_16407()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  qmemcpy(&_PNAME<TransportConnection::RefCountedWrapper>::GET(void)::p, "TransportConnection::RefCountedWrapper", 38);
  CFClass::CFClass(v0, (const char *)&_PNAME<TransportConnection::RefCountedWrapper>::GET(void)::p);
  TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840F180C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void sub_1840F1898(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840F1980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1840F1AC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840F1BCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1840F1D18(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840F1E34(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1840F201C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1840F2398(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void NetworkProxyConfiguration::host(CFStringRef *a1@<X8>)
{
  void *v3;
  void *v4;
  const char *string_ptr;

  *a1 = 0;
  v3 = (void *)network_proxy_copy_host();
  v4 = v3;
  if (v3)
  {
    string_ptr = xpc_string_get_string_ptr(v3);
    *a1 = CFStringCreateWithCString(0, string_ptr, 0x8000100u);
    xpc_release(v4);
  }
}

void sub_1840F24DC(_Unwind_Exception *exception_object)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(exception_object);
}

uint64_t NetworkProxyConfiguration::port(NetworkProxyConfiguration *this)
{
  return __rev16(network_proxy_get_port());
}

uint64_t NetworkProxyConfiguration::connectionType(NetworkProxyConfiguration *this)
{
  return *((unsigned int *)this + 6);
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_network_proxy}*,void (*)(void *),std::allocator<NSObject  {objcproto16OS_network_proxy}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_pointer<NSObject  {objcproto16OS_network_proxy}*,void (*)(void *),std::allocator<NSObject  {objcproto16OS_network_proxy}>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 24));
}

uint64_t __estimatedPropertyListSize_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += estimatedPropertyListSize(a2);
  result = estimatedPropertyListSize(a3);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += result;
  return result;
}

uint64_t CFNetworkDiagnosticLevel()
{
  if (DiagnosticLogging::userDiagnosticLevel(void)::onceToken != -1)
    dispatch_once(&DiagnosticLogging::userDiagnosticLevel(void)::onceToken, &__block_literal_global_13840);
  return DiagnosticLogging::userDiagnosticLevel(void)::sChecked;
}

void CoreReadStreamClient::coreStreamEventsAvailable(CoreReadStreamClient *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = a2;
  if (*((_QWORD *)this + 1) && CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    if (!v2)
      return;
  }
  else if (!a2)
  {
    return;
  }
  v4 = 1;
  do
  {
    if ((v4 & ~v2) == 0)
    {
      (*(void (**)(CoreReadStreamClient *, _QWORD, uint64_t))(*(_QWORD *)this + 56))(this, *((_QWORD *)this + 1), v4);
      v2 &= ~v4;
    }
    v4 *= 2;
  }
  while (v2);
}

void ___ZN14CoreReadStream5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CoreReadStream");
  CoreReadStream::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_1840F2700(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

CFReadStreamRef CoreReadStreamFromCFReadStream::streamSetClient(CFReadStreamRef *this, CFOptionFlags a2, CoreStreamClient *a3)
{
  CFReadStreamRef result;
  CFStreamClientContext clientContext;

  if (a3)
  {
    clientContext.version = 0;
    clientContext.info = this;
    clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
    clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
    CFReadStreamSetClient(this[16], a2, (CFReadStreamClientCallBack)CoreReadStreamFromCFReadStream::_readStreamClientCallBack, &clientContext);
    return (CFReadStreamRef)CoreStreamBase::streamSetClient((uint64_t)this, a2, a3);
  }
  else
  {
    CFReadStreamSetClient(this[16], 0, 0, 0);
    result = this[2];
    this[2] = 0;
    if (result)
      return (CFReadStreamRef)(*(uint64_t (**)(CFReadStreamRef))(*(_QWORD *)result + 24))(result);
  }
  return result;
}

CFIndex CoreReadStreamFromCFReadStream::_streamImpl_Read(CFReadStreamRef *this, unsigned __int8 *a2, CFIndex a3, CFStreamError *a4, BOOL *a5)
{
  CFReadStreamRef *v7;
  CFIndex v8;
  char v9;
  CFStreamStatus Status;
  __CFError *v11;
  __CFError *v12;
  CFIndex v13;
  uint64_t v14;
  uint64_t v15;

  if (a4)
  {
    a4->domain = 0;
    a4->error = 0;
    if (!a5)
    {
      v7 = this + 16;
      v8 = CFReadStreamRead(this[16], a2, a3);
      if (CFReadStreamGetStatus(*v7) != kCFStreamStatusError)
      {
        a4->error = 0;
        a4->domain = 0;
        return v8;
      }
      v9 = 1;
      goto LABEL_9;
    }
LABEL_6:
    *a5 = 0;
    v7 = this + 16;
    v8 = CFReadStreamRead(this[16], a2, a3);
    Status = CFReadStreamGetStatus(*v7);
    if (a4)
    {
      if (Status == kCFStreamStatusError)
      {
        v9 = 0;
LABEL_9:
        if (*v7 && (v11 = CFReadStreamCopyError(*v7)) != 0)
        {
          v12 = v11;
          v13 = _CFStreamErrorFromCFError(v11);
          v15 = v14;
          CFRelease(v12);
        }
        else
        {
          v15 = 0;
          v13 = 0;
        }
        a4->domain = v13;
        *(_QWORD *)&a4->error = v15;
        if ((v9 & 1) != 0)
          return v8;
        Status = kCFStreamStatusError;
        goto LABEL_16;
      }
      a4->error = 0;
      a4->domain = 0;
    }
LABEL_16:
    *a5 = Status == kCFStreamStatusAtEnd;
    return v8;
  }
  if (a5)
    goto LABEL_6;
  return CFReadStreamRead(this[16], a2, a3);
}

uint64_t CoreReadStreamFromCFReadStream::_streamImpl_CanRead(CFReadStreamRef *this)
{
  return CFReadStreamHasBytesAvailable(this[16]);
}

uint64_t CoreReadStreamFromCFReadStream::_streamImpl_SetProperty(CFReadStreamRef *this, const __CFString *a2, const void *a3)
{
  return CFReadStreamSetProperty(this[16], a2, a3);
}

CFTypeRef CoreReadStreamFromCFReadStream::_streamImpl_CopyProperty(CFReadStreamRef *this, const __CFString *a2)
{
  return CFReadStreamCopyProperty(this[16], a2);
}

uint64_t CoreReadStreamFromCFReadStream::_streamImpl_Open(CoreReadStreamFromCFReadStream *this, unint64_t a2, BOOL *a3)
{
  CFStreamStatus Status;
  __CFReadStream *v7;
  __CFError *v8;
  __CFError *v9;
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;

  if (a2)
  {
    *(_QWORD *)a2 = 0;
    *(_DWORD *)(a2 + 8) = 0;
  }
  if (a3)
    *a3 = 0;
  *((_BYTE *)this + 136) = CFReadStreamOpen(*((CFReadStreamRef *)this + 16));
  if (a2 | (unint64_t)a3)
  {
    Status = CFReadStreamGetStatus(*((CFReadStreamRef *)this + 16));
    if (a3)
      *a3 = Status > kCFStreamStatusOpening;
    if (a2 && Status == kCFStreamStatusError)
    {
      v7 = (__CFReadStream *)*((_QWORD *)this + 16);
      if (v7 && (v8 = CFReadStreamCopyError(v7)) != 0)
      {
        v9 = v8;
        v10 = _CFStreamErrorFromCFError(v8);
        v12 = v11;
        CFRelease(v9);
      }
      else
      {
        v12 = 0;
        v10 = 0;
      }
      *(_QWORD *)a2 = v10;
      *(_QWORD *)(a2 + 8) = v12;
    }
  }
  return *((unsigned __int8 *)this + 136);
}

BOOL CoreReadStreamFromCFReadStream::_streamImpl_OpenCompleted(CFReadStreamRef *this, CFStreamError *a2)
{
  CFStreamStatus Status;
  uint64_t v5;
  __CFReadStream *v6;
  __CFError *v7;
  __CFError *v8;
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;

  Status = CFReadStreamGetStatus(this[16]);
  v5 = Status;
  if (a2)
  {
    if (Status == kCFStreamStatusError)
    {
      v6 = this[16];
      if (v6 && (v7 = CFReadStreamCopyError(v6)) != 0)
      {
        v8 = v7;
        v9 = _CFStreamErrorFromCFError(v7);
        v11 = v10;
        CFRelease(v8);
      }
      else
      {
        v11 = 0;
        v9 = 0;
      }
      a2->domain = v9;
      *(_QWORD *)&a2->error = v11;
    }
    else
    {
      a2->domain = 0;
      a2->error = 0;
    }
  }
  return v5 > 1;
}

void CoreReadStreamFromCFReadStream::_streamImpl_Close(CoreReadStreamFromCFReadStream *this)
{
  if (*((_BYTE *)this + 136))
  {
    if (!*((_BYTE *)this + 137))
    {
      *((_BYTE *)this + 137) = 1;
      CFReadStreamClose(*((CFReadStreamRef *)this + 16));
    }
  }
}

void CoreReadStreamFromCFReadStream::_streamImpl_UpdateScheduling(__CFReadStream **this, CoreSchedulingSet *a2, CoreSchedulingSet *a3)
{
  CoreSchedulingSet::unscheduleStream(a2, this[16]);
  CoreSchedulingSet::scheduleStream(a3, this[16]);
}

void CoreReadStreamFromCFReadStream::_streamImpl_openAsync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *global_queue;
  _QWORD block[7];

  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  CFRetain((CFTypeRef)(a1 - 16));
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_openAsyncEPK17CoreSchedulingSetU13block_pointerFv13CFStreamErrorE_block_invoke;
  block[3] = &unk_1E14FDB30;
  block[5] = a1;
  block[6] = a2;
  block[4] = a3;
  dispatch_async(global_queue, block);
}

void CoreReadStreamFromCFReadStream::_streamImpl_readAsync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *global_queue;
  _QWORD v10[8];

  (*(void (**)(uint64_t))(*(_QWORD *)a4 + 40))(a4);
  CFRetain((CFTypeRef)(a1 - 16));
  global_queue = dispatch_get_global_queue(0, 0);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_readAsyncEllPK17CoreSchedulingSetU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke;
  v10[3] = &unk_1E14FD590;
  v10[6] = a3;
  v10[7] = a4;
  v10[4] = a5;
  v10[5] = a1;
  dispatch_async(global_queue, v10);
}

void `non-virtual thunk to'CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream(CoreReadStreamFromCFReadStream *this)
{
  CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream((CoreReadStreamFromCFReadStream *)((char *)this - 8));
}

{
  CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream((CoreReadStreamFromCFReadStream *)((char *)this - 8));
}

{
  CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream((CoreReadStreamFromCFReadStream *)((char *)this - 120));
}

{
  CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream((CoreReadStreamFromCFReadStream *)((char *)this - 120));
}

uint64_t `non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_SetProperty(CFReadStreamRef *this, const __CFString *a2, const void *a3)
{
  return CFReadStreamSetProperty(this[1], a2, a3);
}

CFTypeRef `non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_CopyProperty(CFReadStreamRef *this, const __CFString *a2)
{
  return CFReadStreamCopyProperty(this[1], a2);
}

uint64_t `non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_Open(CoreReadStreamFromCFReadStream *this, CFStreamError *a2, BOOL *a3)
{
  return CoreReadStreamFromCFReadStream::_streamImpl_Open((CoreReadStreamFromCFReadStream *)((char *)this - 120), (unint64_t)a2, a3);
}

BOOL `non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_OpenCompleted(CFReadStreamRef *this, CFStreamError *a2)
{
  return CoreReadStreamFromCFReadStream::_streamImpl_OpenCompleted(this - 15, a2);
}

void `non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_Close(CoreReadStreamFromCFReadStream *this)
{
  if (*((_BYTE *)this + 16))
  {
    if (!*((_BYTE *)this + 17))
    {
      *((_BYTE *)this + 17) = 1;
      CFReadStreamClose(*((CFReadStreamRef *)this + 1));
    }
  }
}

CFIndex `non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_Read(CFReadStreamRef *this, unsigned __int8 *a2, CFIndex a3, CFStreamError *a4, BOOL *a5)
{
  return CoreReadStreamFromCFReadStream::_streamImpl_Read(this - 15, a2, a3, a4, a5);
}

uint64_t `non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_CanRead(CFReadStreamRef *this)
{
  return CFReadStreamHasBytesAvailable(this[1]);
}

void `non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_openAsync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CoreReadStreamFromCFReadStream::_streamImpl_openAsync(a1 - 120, a2, a3);
}

void `non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_readAsync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CoreReadStreamFromCFReadStream::_streamImpl_readAsync(a1 - 120, a2, a3, a4, a5);
}

void `non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_UpdateScheduling(__CFReadStream **this, CoreSchedulingSet *a2, CoreSchedulingSet *a3)
{
  CoreSchedulingSet::unscheduleStream(a2, this[1]);
  CoreSchedulingSet::scheduleStream(a3, this[1]);
}

void CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream(CoreReadStreamFromCFReadStream *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E14EEE68;
  *((_QWORD *)this + 1) = &unk_1E14EEF10;
  v2 = (const void *)*((_QWORD *)this + 16);
  *((_QWORD *)this + 15) = &unk_1E14EEF30;
  *((_QWORD *)this + 16) = 0;
  if (v2)
    CFRelease(v2);
  *(_QWORD *)this = &off_1E14E9310;
  *((_QWORD *)this + 1) = &unk_1E14E9378;
  *((_QWORD *)this + 15) = &unk_1E14E9398;
  CoreStreamBase::~CoreStreamBase(this);
}

void sub_1840F2D2C(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;

  *(_QWORD *)v1 = &off_1E14E9310;
  *((_QWORD *)v1 + 1) = &unk_1E14E9378;
  *((_QWORD *)v1 + 15) = &unk_1E14E9398;
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

void ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_readAsyncEllPK17CoreSchedulingSetU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  CFIndex v4;
  size_t v5;
  size_t v6;
  dispatch_data_t v7;
  CFIndex domain;
  CFStreamError Error;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[8];
  UInt8 buffer[32768];
  uint64_t v14;

  v1 = MEMORY[0x1E0C80A78](a1);
  v2 = v1;
  v14 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(v1 + 40);
  if (*(_QWORD *)(v1 + 48) >= 0x8000uLL)
    v4 = 0x8000;
  else
    v4 = *(_QWORD *)(v1 + 48);
  v5 = CFReadStreamRead(*(CFReadStreamRef *)(v3 + 128), buffer, v4);
  if ((v5 & 0x8000000000000000) != 0)
  {
    Error = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)(v3 + 128));
    v6 = *(size_t *)&Error.error;
    domain = Error.domain;
LABEL_9:
    v7 = 0;
    goto LABEL_10;
  }
  v6 = v5;
  if (!v5)
  {
    domain = 0;
    goto LABEL_9;
  }
  v7 = dispatch_data_create(buffer, v5, 0, 0);
  domain = 0;
  v6 = 0;
LABEL_10:
  v10 = *(_QWORD *)(v2 + 56);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_readAsyncEllPK17CoreSchedulingSetU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke_2;
  v12[3] = &unk_1E14FD568;
  v11 = *(_QWORD *)(v2 + 32);
  v12[4] = v7;
  v12[5] = v11;
  v12[6] = domain;
  v12[7] = v6;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v10 + 96))(v10, v12);
  (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 56) + 48))(*(_QWORD *)(v2 + 56));
  CFRelease((CFTypeRef)(v3 - 16));
}

void ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_readAsyncEllPK17CoreSchedulingSetU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke_2(uint64_t a1)
{
  NSObject *v2;

  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  v2 = *(NSObject **)(a1 + 32);
  if (v2)
    dispatch_release(v2);
}

void ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_openAsyncEPK17CoreSchedulingSetU13block_pointerFv13CFStreamErrorE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  CFIndex domain;
  CFStreamError Error;
  uint64_t v6;
  _QWORD v7[7];

  v2 = a1[5];
  if (CFReadStreamOpen(*(CFReadStreamRef *)(v2 + 128)))
  {
    v3 = 0;
    domain = 0;
  }
  else
  {
    Error = CFReadStreamGetError((CFReadStreamRef)*(_QWORD *)(v2 + 128));
    v3 = *(CFIndex *)&Error.error;
    domain = Error.domain;
  }
  v6 = a1[6];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_openAsyncEPK17CoreSchedulingSetU13block_pointerFv13CFStreamErrorE_block_invoke_2;
  v7[3] = &unk_1E14FDB30;
  v7[4] = a1[4];
  v7[5] = domain;
  v7[6] = v3;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v7);
  (*(void (**)(_QWORD))(*(_QWORD *)a1[6] + 48))(a1[6]);
  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_openAsyncEPK17CoreSchedulingSetU13block_pointerFv13CFStreamErrorE_block_invoke_2(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a1[4] + 16))(a1[4], a1[5], a1[6]);
}

void CoreReadStreamFromCFReadStream::_readStreamClientCallBack(CoreReadStreamFromCFReadStream *this, uint64_t a2, CoreStreamBase *a3, void *a4)
{
  __CFError *v5;
  __CFError *v6;
  CFIndex v7;
  uint64_t v8;
  uint64_t v9;
  CoreStreamBase *v10;
  CFStreamError v11;

  if (a2 == 8)
  {
    if (this && (v5 = CFReadStreamCopyError(this)) != 0)
    {
      v6 = v5;
      v7 = _CFStreamErrorFromCFError(v5);
      v9 = v8;
      CFRelease(v6);
    }
    else
    {
      v9 = 0;
      v7 = 0;
    }
    v10 = a3;
    a2 = 8;
    v11.domain = v7;
    *(_QWORD *)&v11.error = v9;
  }
  else
  {
    v10 = a3;
    v11.domain = 0;
    *(_QWORD *)&v11.error = 0;
  }
  CoreStreamBase::_signalEvent(v10, a2, v11, 1);
}

uint64_t CoreReadStream::setClient(uint64_t a1, uint64_t a2, uint64_t a3, const CFStreamClientContext *a4)
{
  uint64_t v8;
  const __CFAllocator *v9;
  char *v10;
  char *v11;
  const __CFAllocator *v12;
  uint64_t result;

  if (a3)
  {
    v8 = a1 - 16;
    v9 = CFGetAllocator((CFTypeRef)(a1 - 16));
    v10 = (char *)CFAllocatorAllocate(v9, 96, 0);
    *(_OWORD *)v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 4) = 0u;
    v11 = v10 + 64;
    v12 = CFGetAllocator((CFTypeRef)(a1 - 16));
    ClassicStreamClient::ClassicStreamClient((ClassicStreamClient *)v10, v12, a4);
    *(_QWORD *)v10 = off_1E14E8448;
    *((_QWORD *)v10 + 8) = &unk_1E14E84B0;
    *((_QWORD *)v10 + 9) = v8;
    *((_QWORD *)v10 + 10) = v8;
    *((_QWORD *)v10 + 11) = a3;
  }
  else
  {
    v11 = 0;
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(_QWORD *)a1 + 56))(a1, a2, v11);
  if (v11)
    return (*(uint64_t (**)(char *))(*(_QWORD *)v11 + 24))(v11);
  return result;
}

void ClassicReadClient::~ClassicReadClient(ClassicReadClient *this)
{
  void (*v1)(void);

  *((_QWORD *)this + 8) = off_1E14EB378;
  *((_QWORD *)this + 9) = 0;
  *(_QWORD *)this = off_1E14E9D28;
  if (*((_QWORD *)this + 4))
  {
    v1 = (void (*)(void))*((_QWORD *)this + 6);
    if (v1)
      v1();
  }
}

{
  void (*v2)(void);

  *((_QWORD *)this + 8) = off_1E14EB378;
  *((_QWORD *)this + 9) = 0;
  *(_QWORD *)this = off_1E14E9D28;
  if (*((_QWORD *)this + 4))
  {
    v2 = (void (*)(void))*((_QWORD *)this + 6);
    if (v2)
      v2();
  }
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

BOOL ClassicReadClient::equals(ClassicReadClient *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

char *ClassicReadClient::coreStreamClientRetain(ClassicReadClient *this)
{
  char *v1;

  v1 = (char *)this + 64;
  (*(void (**)(ClassicReadClient *))(*(_QWORD *)this + 40))(this);
  return v1;
}

uint64_t ClassicReadClient::coreStreamClientRelease(ClassicReadClient *this)
{
  return (*(uint64_t (**)(ClassicReadClient *))(*(_QWORD *)this + 48))(this);
}

uint64_t ClassicReadClient::coreStreamReadEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(a1 + 88))(*(_QWORD *)(a1 + 80), a3, *(_QWORD *)(a1 + 32));
}

void `non-virtual thunk to'ClassicReadClient::~ClassicReadClient(ClassicReadClient *this)
{
  void (*v1)(void);

  *(_QWORD *)this = off_1E14EB378;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this - 8) = off_1E14E9D28;
  if (*((_QWORD *)this - 4))
  {
    v1 = (void (*)(void))*((_QWORD *)this - 2);
    if (v1)
      v1();
  }
}

{
  ClassicReadClient::~ClassicReadClient((ClassicReadClient *)((char *)this - 64));
}

ClassicReadClient *`non-virtual thunk to'ClassicReadClient::coreStreamClientRetain(ClassicReadClient *this)
{
  (*(void (**)(char *))(*((_QWORD *)this - 8) + 40))((char *)this - 64);
  return this;
}

uint64_t `non-virtual thunk to'ClassicReadClient::coreStreamClientRelease(ClassicReadClient *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 8) + 48))((char *)this - 64);
}

CFStringRef `non-virtual thunk to'ClassicReadClient::coreStreamClientCopyDescription(ClassicReadClient *this)
{
  return ClassicStreamClient::clientCopyDescription((ClassicReadClient *)((char *)this - 64));
}

uint64_t `non-virtual thunk to'ClassicReadClient::coreStreamReadEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ClassicReadClient::coreStreamReadEvent(a1 - 64, a2, a3);
}

_OWORD *CoreReadStreamCreate(uint64_t a1, __int128 *a2, uint64_t a3)
{
  _OWORD *Instance;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t (*v13)(_OWORD *, uint64_t);

  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v6 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v6 = Instance + 1;
    Instance[15] = 0u;
    Instance[16] = 0u;
    Instance[13] = 0u;
    Instance[14] = 0u;
    Instance[11] = 0u;
    Instance[12] = 0u;
    Instance[9] = 0u;
    Instance[10] = 0u;
    Instance[7] = 0u;
    Instance[8] = 0u;
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
  }
  *((_DWORD *)v6 + 26) = 0;
  *((_QWORD *)v6 + 15) = &unk_1E14EDC28;
  *((_QWORD *)v6 + 3) = (char *)v6 + 120;
  *(_QWORD *)v6 = &off_1E14EDB68;
  *((_QWORD *)v6 + 1) = &unk_1E14EDC08;
  v7 = *a2;
  v8 = a2[1];
  v9 = a2[2];
  *(_OWORD *)((char *)v6 + 184) = a2[3];
  *(_OWORD *)((char *)v6 + 168) = v9;
  *(_OWORD *)((char *)v6 + 152) = v8;
  *(_OWORD *)((char *)v6 + 136) = v7;
  v10 = a2[4];
  v11 = a2[5];
  v12 = a2[6];
  *((_QWORD *)v6 + 31) = *((_QWORD *)a2 + 14);
  *(_OWORD *)((char *)v6 + 232) = v12;
  *(_OWORD *)((char *)v6 + 216) = v11;
  *(_OWORD *)((char *)v6 + 200) = v10;
  v13 = (uint64_t (*)(_OWORD *, uint64_t))*((_QWORD *)v6 + 18);
  if (v13)
    a3 = v13(v6 - 1, a3);
  *((_QWORD *)v6 + 16) = a3;
  return v6 - 1;
}

void sub_1840F33F0(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;

  *(_QWORD *)v1 = &off_1E14E9310;
  *((_QWORD *)v1 + 1) = &unk_1E14E9378;
  *((_QWORD *)v1 + 15) = &unk_1E14E9398;
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_Read(CoreReadStreamWithCallBacks *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  uint64_t (*v5)(char *, unsigned __int8 *);

  if (a4)
  {
    a4->domain = 0;
    a4->error = 0;
  }
  if (a5)
    *a5 = 0;
  v5 = (uint64_t (*)(char *, unsigned __int8 *))*((_QWORD *)this + 23);
  if (v5)
    return v5((char *)this - 16, a2);
  else
    return -1;
}

BOOL CoreReadStreamWithCallBacks::_streamImpl_CanRead(CoreReadStreamWithCallBacks *this)
{
  unsigned int (*v1)(char *, _QWORD);

  v1 = (unsigned int (*)(char *, _QWORD))*((_QWORD *)this + 25);
  return v1 && v1((char *)this - 16, *((_QWORD *)this + 16)) != 0;
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_RequestEvents(uint64_t this, uint64_t a2)
{
  uint64_t (*v2)(uint64_t, uint64_t, _QWORD);

  v2 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(this + 232);
  if (v2)
    return v2(this - 16, a2, *(_QWORD *)(this + 128));
  return this;
}

BOOL CoreReadStreamWithCallBacks::_streamImpl_SetProperty(CoreReadStreamWithCallBacks *this, const __CFString *a2, const void *a3)
{
  unsigned int (*v3)(char *, const __CFString *, const void *, _QWORD);

  v3 = (unsigned int (*)(char *, const __CFString *, const void *, _QWORD))*((_QWORD *)this + 28);
  return v3 && v3((char *)this - 16, a2, a3, *((_QWORD *)this + 16)) != 0;
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_CopyProperty(CoreReadStreamWithCallBacks *this, const __CFString *a2)
{
  uint64_t (*v2)(char *, const __CFString *, _QWORD);

  v2 = (uint64_t (*)(char *, const __CFString *, _QWORD))*((_QWORD *)this + 27);
  if (v2)
    return v2((char *)this - 16, a2, *((_QWORD *)this + 16));
  else
    return 0;
}

BOOL CoreReadStreamWithCallBacks::_streamImpl_Open(CoreReadStreamWithCallBacks *this, CFStreamError *a2, unsigned __int8 *a3)
{
  unsigned int (*v3)(char *);

  if (a2)
  {
    a2->domain = 0;
    a2->error = 0;
  }
  if (a3)
    *a3 = 0;
  v3 = (unsigned int (*)(char *))*((_QWORD *)this + 21);
  return v3 && v3((char *)this - 16) != 0;
}

BOOL CoreReadStreamWithCallBacks::_streamImpl_OpenCompleted(CoreReadStreamWithCallBacks *this, CFStreamError *a2)
{
  unsigned int (*v2)(char *);

  if (a2)
  {
    a2->domain = 0;
    a2->error = 0;
  }
  v2 = (unsigned int (*)(char *))*((_QWORD *)this + 22);
  return v2 && v2((char *)this - 16) != 0;
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_Close(uint64_t this)
{
  uint64_t (*v1)(uint64_t, _QWORD);

  v1 = *(uint64_t (**)(uint64_t, _QWORD))(this + 208);
  if (v1)
    return v1(this - 16, *(_QWORD *)(this + 128));
  return this;
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_deprecated_Schedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t (*v3)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD);

  v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD))(this + 240);
  if (v3)
    return v3(this - 16, a2, a3, *(_QWORD *)(this + 128));
  return this;
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_deprecated_Unschedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t (*v3)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD);

  v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD))(this + 248);
  if (v3)
    return v3(this - 16, a2, a3, *(_QWORD *)(this + 128));
  return this;
}

void `non-virtual thunk to'CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks(CoreReadStreamWithCallBacks *this)
{
  CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks((CoreReadStreamWithCallBacks *)((char *)this - 8));
}

{
  CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks((CoreReadStreamWithCallBacks *)((char *)this - 8));
}

{
  CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks((CoreReadStreamWithCallBacks *)((char *)this - 120));
}

{
  CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks((CoreReadStreamWithCallBacks *)((char *)this - 120));
}

BOOL `non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_SetProperty(CoreReadStreamWithCallBacks *this, const __CFString *a2, const void *a3)
{
  unsigned int (*v3)(char *, const __CFString *, const void *, _QWORD);

  v3 = (unsigned int (*)(char *, const __CFString *, const void *, _QWORD))*((_QWORD *)this + 13);
  return v3 && v3((char *)this - 136, a2, a3, *((_QWORD *)this + 1)) != 0;
}

uint64_t `non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_CopyProperty(CoreReadStreamWithCallBacks *this, const __CFString *a2)
{
  uint64_t (*v2)(char *, const __CFString *, _QWORD);

  v2 = (uint64_t (*)(char *, const __CFString *, _QWORD))*((_QWORD *)this + 12);
  if (v2)
    return v2((char *)this - 136, a2, *((_QWORD *)this + 1));
  else
    return 0;
}

uint64_t `non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_RequestEvents(uint64_t this, uint64_t a2)
{
  uint64_t (*v2)(uint64_t, uint64_t, _QWORD);

  v2 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(this + 112);
  if (v2)
    return v2(this - 136, a2, *(_QWORD *)(this + 8));
  return this;
}

BOOL `non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_Open(CoreReadStreamWithCallBacks *this, CFStreamError *a2, unsigned __int8 *a3)
{
  unsigned int (*v3)(char *);

  if (a2)
  {
    a2->domain = 0;
    a2->error = 0;
  }
  if (a3)
    *a3 = 0;
  v3 = (unsigned int (*)(char *))*((_QWORD *)this + 6);
  return v3 && v3((char *)this - 136) != 0;
}

BOOL `non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_OpenCompleted(CoreReadStreamWithCallBacks *this, CFStreamError *a2)
{
  unsigned int (*v2)(char *);

  if (a2)
  {
    a2->domain = 0;
    a2->error = 0;
  }
  v2 = (unsigned int (*)(char *))*((_QWORD *)this + 7);
  return v2 && v2((char *)this - 136) != 0;
}

uint64_t `non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_Close(uint64_t this)
{
  uint64_t (*v1)(uint64_t, _QWORD);

  v1 = *(uint64_t (**)(uint64_t, _QWORD))(this + 88);
  if (v1)
    return v1(this - 136, *(_QWORD *)(this + 8));
  return this;
}

uint64_t `non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_Read(CoreReadStreamWithCallBacks *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  uint64_t (*v5)(char *, unsigned __int8 *);

  if (a4)
  {
    a4->domain = 0;
    a4->error = 0;
  }
  if (a5)
    *a5 = 0;
  v5 = (uint64_t (*)(char *, unsigned __int8 *))*((_QWORD *)this + 8);
  if (v5)
    return v5((char *)this - 136, a2);
  else
    return -1;
}

BOOL `non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_CanRead(CoreReadStreamWithCallBacks *this)
{
  unsigned int (*v1)(char *, _QWORD);

  v1 = (unsigned int (*)(char *, _QWORD))*((_QWORD *)this + 10);
  return v1 && v1((char *)this - 136, *((_QWORD *)this + 1)) != 0;
}

uint64_t `non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_deprecated_Schedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t (*v3)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD);

  v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD))(this + 120);
  if (v3)
    return v3(this - 136, a2, a3, *(_QWORD *)(this + 8));
  return this;
}

uint64_t `non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_deprecated_Unschedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t (*v3)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD);

  v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD))(this + 128);
  if (v3)
    return v3(this - 136, a2, a3, *(_QWORD *)(this + 8));
  return this;
}

void CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks(CoreReadStreamWithCallBacks *this)
{
  void (*v2)(char *, _QWORD);

  *(_QWORD *)this = &off_1E14EDB68;
  *((_QWORD *)this + 1) = &unk_1E14EDC08;
  *((_QWORD *)this + 15) = &unk_1E14EDC28;
  v2 = (void (*)(char *, _QWORD))*((_QWORD *)this + 19);
  if (v2)
    v2((char *)this - 16, *((_QWORD *)this + 16));
  *(_QWORD *)this = &off_1E14E9310;
  *((_QWORD *)this + 1) = &unk_1E14E9378;
  *((_QWORD *)this + 15) = &unk_1E14E9398;
  CoreStreamBase::~CoreStreamBase(this);
}

void sub_1840F3830(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;

  *(_QWORD *)v1 = &off_1E14E9310;
  *((_QWORD *)v1 + 1) = &unk_1E14E9378;
  *((_QWORD *)v1 + 15) = &unk_1E14E9398;
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

_OWORD *CoreReadStreamCreateWithCFReadStream(const __CFAllocator *a1, __CFReadStream *a2)
{
  _OWORD *Instance;
  _OWORD *v4;

  if (!a2)
    return 0;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v4 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v4 = Instance + 1;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  *((_DWORD *)v4 + 26) = 0;
  *((_QWORD *)v4 + 15) = &unk_1E14EEF30;
  *((_QWORD *)v4 + 3) = (char *)v4 + 120;
  *(_QWORD *)v4 = &off_1E14EEE68;
  *((_QWORD *)v4 + 1) = &unk_1E14EEF10;
  *((_QWORD *)v4 + 16) = CFRetain(a2);
  *((_WORD *)v4 + 68) = 0;
  return v4 - 1;
}

void sub_1840F3924(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;

  *(_QWORD *)v1 = &off_1E14E9310;
  *((_QWORD *)v1 + 1) = &unk_1E14E9378;
  *((_QWORD *)v1 + 15) = &unk_1E14E9398;
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFReadStreamCreateWithCoreStream(uint64_t a1, uint64_t a2)
{
  if (a2 && CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  return CFReadStreamCreate();
}

__CFReadStream *CoreReadStreamCFStreamSupport::_stream_create_and_bump_refcount(CoreReadStreamCFStreamSupport *this, __CFReadStream *a2, void *a3)
{
  char *v5;
  const __CFAllocator *v6;
  _OWORD *v7;
  CFAllocatorRef v8;

  v5 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  v6 = CFGetAllocator(this);
  v7 = CFAllocatorAllocate(v6, 56, 0);
  *v7 = 0u;
  v7[2] = 0u;
  *((_QWORD *)v7 + 6) = 0;
  v7[1] = 0u;
  v8 = CFGetAllocator(this);
  *(_QWORD *)v7 = off_1E14EF578;
  *((_QWORD *)v7 + 1) = v8;
  *((_DWORD *)v7 + 4) = 1;
  if (((unint64_t)(v7 + 1) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *((_QWORD *)v7 + 3) = &unk_1E14EEB88;
  *(_QWORD *)v7 = off_1E14EEB18;
  *((_QWORD *)v7 + 4) = v5;
  *((_QWORD *)v7 + 5) = this;
  *((_QWORD *)v7 + 6) = CFRetain(v5);
  (*(void (**)(__CFReadStream *, uint64_t, uint64_t))(*(_QWORD *)a2 + 56))(a2, -1, (uint64_t)v7 + 24);
  (*(void (**)(_OWORD *))(*(_QWORD *)v7 + 48))(v7);
  return a2;
}

void sub_1840F3AB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = off_1E14EB378;
  *(_QWORD *)(v1 + 32) = 0;
  _Unwind_Resume(a1);
}

void CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_finalize(uint64_t a1, uint64_t a2)
{
  CFRelease((CFTypeRef)(a2 - 16));
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_copyDescription(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_open(int a1, uint64_t a2, _BYTE *a3, CoreStreamBase *this)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a2)
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(_QWORD *)a2 = 0;
  }
  if (a3)
  {
    *a3 = 0;
    v7 = CoreStreamBase::_streamInterface_Open(this);
    if ((_DWORD)v7)
    {
      v8 = v7;
      *a3 = (*(uint64_t (**)(char *, uint64_t))(*((_QWORD *)this + 15) + 64))((char *)this + 120, a2);
      return v8;
    }
    if (!a2)
      return 0;
LABEL_10:
    v8 = 0;
    *(_OWORD *)a2 = *(_OWORD *)((char *)this + 56);
    return v8;
  }
  v9 = CoreStreamBase::_streamInterface_Open(this);
  v8 = v9;
  if (a2 && !(_DWORD)v9)
    goto LABEL_10;
  return v8;
}

BOOL CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_openCompleted(int a1, uint64_t a2, CoreStreamBase *this)
{
  uint64_t Status;

  Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (a2)
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(_QWORD *)a2 = 0;
    if (Status == 7)
      *(_OWORD *)a2 = *(_OWORD *)((char *)this + 56);
  }
  return Status > 1;
}

uint64_t CoreReadStreamCFStreamSupport::_stream_read(CoreReadStreamCFStreamSupport *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, CoreStreamBase *a6, void *a7)
{
  uint64_t v10;
  uint64_t Status;

  if (a4)
  {
    *(_QWORD *)a4 = 0;
    *(_DWORD *)(a4 + 8) = 0;
  }
  if (a5)
    LOBYTE(a5->domain) = 0;
  v10 = CoreStreamBase::_streamInterface_Read(a6, (unsigned __int8 *)a2, (uint64_t)a3);
  Status = CoreStreamBase::_streamInterface_GetStatus(a6);
  if (Status == 5)
  {
    if (a5)
      LOBYTE(a5->domain) = 1;
  }
  else if (a4 && Status == 7)
  {
    *(_OWORD *)a4 = *(_OWORD *)((char *)a6 + 56);
  }
  return v10;
}

uint64_t CoreReadStreamCFStreamSupport::_stream_canRead(CoreReadStreamCFStreamSupport *this, __CFReadStream *a2, void *a3)
{
  uint64_t v4;
  uint64_t Status;

  v4 = CoreStreamBase::_streamInterface_CanRead(a2);
  if (!(_DWORD)v4)
  {
    Status = CoreStreamBase::_streamInterface_GetStatus(a2);
    if (Status == 5 || Status == 7)
      CFReadStreamSignalEvent();
  }
  return v4;
}

void CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_close(uint64_t a1, CoreStreamBase *a2)
{
  (*(void (**)(CoreStreamBase *, _QWORD, _QWORD))(*(_QWORD *)a2 + 56))(a2, 0, 0);
  CoreStreamBase::_streamInterface_Close(a2);
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_copyProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  ++*(_QWORD *)(a3 + 80);
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a3 + 24) + 40))(*(_QWORD *)(a3 + 24));
  --*(_QWORD *)(a3 + 80);
  return result;
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_setProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  ++*(_QWORD *)(a4 + 80);
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a4 + 24) + 32))(*(_QWORD *)(a4 + 24));
  --*(_QWORD *)(a4 + 80);
  return result;
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_requestEvents(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 80))(a3);
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_schedule(int a1, __CFRunLoop *a2, const __CFString *a3, os_unfair_lock_s *this)
{
  return CoreStreamBase::_streamInterface_Deprecated_Schedule(this, a2, a3);
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_unschedule(int a1, __CFRunLoop *a2, const __CFString *a3, os_unfair_lock_s *this)
{
  return CoreStreamBase::_streamInterface_Deprecated_Unschedule(this, a2, a3);
}

void CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport(CoreReadStreamCFStreamSupport *this)
{
  uint64_t v2;

  CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14EEB18;
  *((_QWORD *)this + 3) = &unk_1E14EEB88;
  v2 = (const void *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 3) = off_1E14EB378;
  *((_QWORD *)this + 4) = 0;
}

BOOL CoreReadStreamCFStreamSupport::equals(CoreReadStreamCFStreamSupport *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

CFTypeRef CoreReadStreamCFStreamSupport::coreStreamClientCopyCFStreamRef(CoreReadStreamCFStreamSupport *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 5);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t CoreReadStreamCFStreamSupport::coreStreamClientRetain(CoreReadStreamCFStreamSupport *this)
{
  const void *v2;
  const void *v3;

  (*(void (**)(CoreReadStreamCFStreamSupport *))(*(_QWORD *)this + 40))(this);
  v2 = (const void *)*((_QWORD *)this + 6);
  if (v2)
    CFRetain(v2);
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    CFRetain(v3);
  return (uint64_t)this + 24;
}

uint64_t CoreReadStreamCFStreamSupport::coreStreamClientRelease(CoreReadStreamCFStreamSupport *this)
{
  const void *v2;
  const void *v3;

  v2 = (const void *)*((_QWORD *)this + 6);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    CFRelease(v3);
  return (*(uint64_t (**)(CoreReadStreamCFStreamSupport *))(*(_QWORD *)this + 48))(this);
}

CFStringRef CoreReadStreamCFStreamSupport::coreStreamClientCopyDescription(CoreReadStreamCFStreamSupport *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<read side %p to stream %p>"), *((_QWORD *)this + 6), *((_QWORD *)this + 5));
}

uint64_t CoreReadStreamCFStreamSupport::coreStreamReadEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)(a1 + 48) && CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (a3 == 8 && CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  return CFReadStreamSignalEvent();
}

void `non-virtual thunk to'CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport(CoreReadStreamCFStreamSupport *this)
{
  CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport((CoreReadStreamCFStreamSupport *)((char *)this - 24));
}

void `non-virtual thunk to'CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport((CoreReadStreamCFStreamSupport *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

uint64_t `non-virtual thunk to'CoreReadStreamCFStreamSupport::coreStreamClientRetain(CoreReadStreamCFStreamSupport *this)
{
  return CoreReadStreamCFStreamSupport::coreStreamClientRetain((CoreReadStreamCFStreamSupport *)((char *)this - 24));
}

uint64_t `non-virtual thunk to'CoreReadStreamCFStreamSupport::coreStreamClientRelease(CoreReadStreamCFStreamSupport *this)
{
  return CoreReadStreamCFStreamSupport::coreStreamClientRelease((CoreReadStreamCFStreamSupport *)((char *)this - 24));
}

CFStringRef `non-virtual thunk to'CoreReadStreamCFStreamSupport::coreStreamClientCopyDescription(CoreReadStreamCFStreamSupport *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<read side %p to stream %p>"), *((_QWORD *)this + 3), *((_QWORD *)this + 2));
}

CFTypeRef `non-virtual thunk to'CoreReadStreamCFStreamSupport::coreStreamClientCopyCFStreamRef(CoreReadStreamCFStreamSupport *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 2);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t `non-virtual thunk to'CoreReadStreamCFStreamSupport::coreStreamReadEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CoreReadStreamCFStreamSupport::coreStreamReadEvent(a1 - 24, a2, a3);
}

void sub_1840F406C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = off_1E14EB378;
  *(_QWORD *)(v1 + 32) = 0;
  _Unwind_Resume(a1);
}

void *_retain_block(int a1, void *aBlock)
{
  return _Block_copy(aBlock);
}

void _release_block(int a1, void *aBlock)
{
  _Block_release(aBlock);
}

BOOL URLCredentialOAuth1::equals(URLCredentialOAuth1 *this, const CFObject *a2)
{
  uint64_t v4;
  void *v5;
  void *v6;

  if (*((_DWORD *)this + 8) != *((_DWORD *)a2 + 8))
    return 0;
  v4 = (*(uint64_t (**)(URLCredentialOAuth1 *))(*(_QWORD *)this + 8))(this);
  if (v4 != (*(uint64_t (**)(const CFObject *))(*(_QWORD *)a2 + 8))(a2)
    || *((_DWORD *)this + 9) != *((_DWORD *)a2 + 9))
  {
    return 0;
  }
  v5 = CFNAccount::username(*((CFNAccount **)this + 9));
  v6 = CFNAccount::username(*((CFNAccount **)a2 + 9));
  return CFEqual(v5, v6) != 0;
}

CFStringRef URLCredentialOAuth1::copyDebugDesc(URLCredentialOAuth1 *this)
{
  char *v2;
  const __CFAllocator *v3;

  v2 = (char *)this - 16;
  v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLCredential %p>{Account = %@, persistence = %d}"), v2, *(_QWORD *)(*((_QWORD *)this + 9) + 16), *((unsigned int *)this + 9));
}

uint64_t URLCredentialOAuth1::copy(URLCredentialOAuth1 *this)
{
  uint64_t Instance;
  objc_object *v3;
  int v4;

  CFGetAllocator((char *)this - 16);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 48) = 7;
  *(_QWORD *)(Instance + 24) = &unk_1E14EAF60;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EAEB0;
  *(_QWORD *)(Instance + 40) = &unk_1E14EAF90;
  *(_DWORD *)(Instance + 80) = 0;
  *(_QWORD *)(Instance + 88) = 0;
  *(_QWORD *)(Instance + 96) = 0;
  v3 = *(objc_object **)(*((_QWORD *)this + 9) + 16);
  v4 = (*(uint64_t (**)(URLCredentialOAuth1 *))(*(_QWORD *)this + 152))(this);
  URLCredentialOAuth1::initialize((URLCredentialOAuth1 *)(Instance + 16), v3, v4, *((const __CFString **)this + 10));
  return Instance;
}

CFHashCode URLCredentialOAuth1::calcHash(URLCredentialOAuth1 *this, uint64_t a2)
{
  CFNAccount *v3;
  void *v4;

  v3 = (CFNAccount *)*((_QWORD *)this + 9);
  if (v3)
  {
    v4 = CFNAccount::username(v3);
    return CFHash(v4) ^ a2;
  }
  return a2;
}

void *URLCredentialOAuth1::copyStorageNameForCredentialType(URLCredentialOAuth1 *this)
{
  CFNAccount *v1;
  void *v2;
  void *v3;

  v1 = (CFNAccount *)*((_QWORD *)this + 9);
  if (!v1)
    return 0;
  v2 = CFNAccount::username(v1);
  v3 = v2;
  if (v2)
    CFRetain(v2);
  return v3;
}

void *URLCredentialOAuth1::getUserName(CFNAccount **this)
{
  return CFNAccount::username(this[9]);
}

uint64_t URLCredentialOAuth1::getAccount(URLCredentialOAuth1 *this)
{
  return *((_QWORD *)this + 9) - 16;
}

uint64_t URLCredentialOAuth1::copyAccount(URLCredentialOAuth1 *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 9);
  if (!v1)
    return 0;
  v2 = v1 - 16;
  CFRetain((CFTypeRef)(v1 - 16));
  return v2;
}

uint64_t URLCredentialOAuth1::getRealm(URLCredentialOAuth1 *this)
{
  return *((_QWORD *)this + 10);
}

CFTypeRef URLCredentialOAuth1::copyRealm(URLCredentialOAuth1 *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 10);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t URLCredentialOAuth1::getPID(URLCredentialOAuth1 *this)
{
  return *((unsigned int *)this + 16);
}

void `non-virtual thunk to'URLCredentialOAuth1::~URLCredentialOAuth1(URLCredentialOAuth1 *this)
{
  URLCredentialOAuth1::~URLCredentialOAuth1((URLCredentialOAuth1 *)((char *)this - 8));
}

{
  URLCredentialOAuth1::~URLCredentialOAuth1((URLCredentialOAuth1 *)((char *)this - 8));
}

{
  URLCredentialOAuth1::~URLCredentialOAuth1((URLCredentialOAuth1 *)((char *)this - 24));
}

{
  URLCredentialOAuth1::~URLCredentialOAuth1((URLCredentialOAuth1 *)((char *)this - 24));
}

void URLCredentialOAuth1::~URLCredentialOAuth1(URLCredentialOAuth1 *this)
{
  uint64_t v2;
  const void *v3;

  *(_QWORD *)this = &off_1E14EAEB0;
  *((_QWORD *)this + 1) = &unk_1E14EAF60;
  *((_QWORD *)this + 3) = &unk_1E14EAF90;
  v2 = *((_QWORD *)this + 9);
  if (v2)
    CFRelease((CFTypeRef)(v2 - 16));
  v3 = (const void *)*((_QWORD *)this + 10);
  if (v3)
    CFRelease(v3);
  URLCredential::~URLCredential(this);
}

void sub_1840F43E0(_Unwind_Exception *a1)
{
  URLCredential *v1;

  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t URLCredentialOAuth1::initialize(URLCredentialOAuth1 *this, objc_object *a2, int a3, const __CFString *a4)
{
  uint64_t result;
  uint64_t Instance;
  CFTypeID TypeID;
  const __CFAllocator *v11;

  result = 0;
  *((_DWORD *)this + 9) = 2;
  if (a3 && a2 && a4)
  {
    CFGetAllocator((char *)this - 16);
    if (TCFObject<CFNAccount>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<CFNAccount>::Class(void)::sOnce, &__block_literal_global_16755);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      *(_OWORD *)(Instance + 16) = 0u;
      Instance += 16;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
    }
    *(_QWORD *)Instance = &off_1E14E4838;
    *(_QWORD *)(Instance + 8) = &unk_1E14E4888;
    *(_QWORD *)(Instance + 24) = 0;
    *(_QWORD *)(Instance + 32) = 0;
    *(_QWORD *)(Instance + 16) = 0;
    *((_QWORD *)this + 9) = Instance;
    CFNAccount::initialize((CFNAccount *)Instance, a2);
    TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(a4))
    {
      v11 = CFGetAllocator((char *)this - 16);
      *((_QWORD *)this + 10) = CFStringCreateCopy(v11, a4);
      result = 1;
    }
    else
    {
      result = 0;
    }
    *((_DWORD *)this + 16) = a3;
  }
  return result;
}

void ___ZN9TCFObjectI10CFNAccountE5ClassEv_block_invoke_16756()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  word_1EDD018D8 = 29806;
  _PNAME<CFNAccount>::GET(void)::p = *(_QWORD *)"CFNAccount>::GET() [OBJTYPE = CFNAccount]";
  CFClass::CFClass(v0, (const char *)&_PNAME<CFNAccount>::GET(void)::p);
  TCFObject<CFNAccount>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840F4568(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

CFStringRef HTTP2ConnectionCache::copyDebugDesc(HTTP2ConnectionCache *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("HTTP2ConnectionCache<@%p>"), this);
}

uint64_t HTTP2ConnectionCache::logConnectionsAtAPSleep(HTTP2ConnectionCache *this)
{
  uint64_t v2;
  _QWORD v4[5];

  (*(void (**)(HTTP2ConnectionCache *))(*(_QWORD *)this + 40))(this);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 40))(*((_QWORD *)this + 13));
  v2 = *((_QWORD *)this + 10);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN20HTTP2ConnectionCache23logConnectionsAtAPSleepEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 96))(v2, v4);
}

uint64_t HTTP2ConnectionCache::purgeIdleConnections(HTTP2ConnectionCache *this)
{
  uint64_t v2;
  _QWORD v4[5];

  (*(void (**)(HTTP2ConnectionCache *))(*(_QWORD *)this + 40))(this);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 40))(*((_QWORD *)this + 13));
  v2 = *((_QWORD *)this + 10);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN20HTTP2ConnectionCache20purgeIdleConnectionsEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 96))(v2, v4);
}

uint64_t HTTP2ConnectionCache::markReusedAfterAPSleepWake(HTTP2ConnectionCache *this)
{
  uint64_t v2;
  _QWORD v4[5];

  (*(void (**)(HTTP2ConnectionCache *))(*(_QWORD *)this + 40))(this);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 40))(*((_QWORD *)this + 13));
  v2 = *((_QWORD *)this + 10);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN20HTTP2ConnectionCache26markReusedAfterAPSleepWakeEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 96))(v2, v4);
}

void `non-virtual thunk to'HTTP2ConnectionCache::~HTTP2ConnectionCache(HTTP2ConnectionCache *this)
{
  HTTP2ConnectionCache::~HTTP2ConnectionCache((HTTP2ConnectionCache *)((char *)this - 32));
}

void `non-virtual thunk to'HTTP2ConnectionCache::~HTTP2ConnectionCache(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 4;
  HTTP2ConnectionCache::~HTTP2ConnectionCache((HTTP2ConnectionCache *)(this - 4));
  CFAllocatorDeallocate(*(this - 3), v2);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA4A8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA4A8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

uint64_t ___ZN20HTTP2ConnectionCache26markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(v1 + 96), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::_visit, &__block_literal_global_9_16766);
  (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 104) + 48))(*(_QWORD *)(v1 + 104));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void ___ZN20HTTP2ConnectionCache35_onqueue_markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFArray *v3;
  CFRange v4;

  v3 = *(const __CFArray **)(a3 + 88);
  v4.length = CFArrayGetCount(v3);
  v4.location = 0;
  CFArrayApplyFunction(v3, v4, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, &__block_literal_global_12_6343);
}

uint64_t ___ZN20HTTP2ConnectionCache20purgeIdleConnectionsEv_block_invoke(uint64_t a1)
{
  HTTP2ConnectionCache *v1;

  v1 = *(HTTP2ConnectionCache **)(a1 + 32);
  HTTP2ConnectionCache::_onqueue_removeIdleConnections(v1);
  (*(void (**)(_QWORD *))(**((_QWORD **)v1 + 13) + 48))(*((_QWORD **)v1 + 13));
  return (*(uint64_t (**)(HTTP2ConnectionCache *))(*(_QWORD *)v1 + 48))(v1);
}

void HTTP2ConnectionCache::_onqueue_removeIdleConnections(HTTP2ConnectionCache *this)
{
  NSObject *v2;
  dispatch_time_t v3;
  NSObject *v4;
  dispatch_time_t v5;
  NSObject *v6;
  dispatch_time_t v7;
  NSObject *v8;
  dispatch_time_t v9;

  v2 = *((_QWORD *)this + 14);
  v3 = dispatch_time(0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  v4 = *((_QWORD *)this + 15);
  v5 = dispatch_time(0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  HTTP2ConnectionCache::_onqueue_base_remove_connections(this, 0, 0);
  if (CFDictionaryGetCount(*((CFDictionaryRef *)this + 12)))
  {
    v6 = *((_QWORD *)this + 14);
    v7 = dispatch_time(0x8000000000000000, (uint64_t)((double)*((int *)this + 18) * 1000000000.0));
    dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    v8 = *((_QWORD *)this + 15);
    v9 = dispatch_time(0, (uint64_t)((double)*((int *)this + 19) * 1000000000.0));
    dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  }
}

void ___ZN20HTTP2ConnectionCache32_onqueue_base_remove_connectionsEbb_block_invoke_2(uint64_t a1, void *a2, HTTP2ConnectionCacheEntry *a3)
{
  uint64_t v6;
  const __CFArray *v7;
  _QWORD context[5];
  __int128 v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;
  CFRange v14;

  v6 = *(_QWORD *)(a1 + 32);
  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 1;
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 3221225472;
  context[2] = ___ZN25HTTP2ConnectionCacheEntry15shouldIdleCloseEdd_block_invoke;
  context[3] = &unk_1E14F9760;
  v9 = *(_OWORD *)(a1 + 40);
  context[4] = &v10;
  v7 = (const __CFArray *)*((_QWORD *)a3 + 11);
  v14.length = CFArrayGetCount(v7);
  v14.location = 0;
  CFArrayApplyFunction(v7, v14, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, context);
  LODWORD(v7) = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  if ((_DWORD)v7)
  {
    HTTP2ConnectionCacheEntry::stopConnections(a3, 0);
    TubeManager::invalidateKey(*(_QWORD *)(v6 + 104), a2, 1, 1u);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), a2);
  }
}

void sub_1840F4AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20HTTP2ConnectionCache23logConnectionsAtAPSleepEv_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(v1 + 96), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::_visit, &__block_literal_global_16775);
  (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 104) + 48))(*(_QWORD *)(v1 + 104));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void ___ZN20HTTP2ConnectionCache32_onqueue_logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFArray *v3;
  CFRange v4;

  v3 = *(const __CFArray **)(a3 + 88);
  v4.length = CFArrayGetCount(v3);
  v4.location = 0;
  CFArrayApplyFunction(v3, v4, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, &__block_literal_global_13);
}

void ___ZN20HTTP2ConnectionCache15initCacheTimersEv_block_invoke(uint64_t a1)
{
  HTTP2ConnectionCache::_onqueue_removeIdleConnections(*(HTTP2ConnectionCache **)(a1 + 32));
}

void ___ZN20HTTP2ConnectionCache15initCacheTimersEv_block_invoke_3(uint64_t a1)
{
  HTTP2ConnectionCache::_onqueue_removeIdleConnections(*(HTTP2ConnectionCache **)(a1 + 32));
}

id ___Z25_AuthBrokerGetServiceNamev_block_invoke()
{
  char *v0;
  const char *v1;
  id result;

  v0 = getenv("AUTHBROKER_SERVICE_NAME");
  if (v0)
    v1 = v0;
  else
    v1 = "com.apple.cfnetwork.AuthBrokerAgent";
  result = (id)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v1);
  _AuthBrokerGetServiceName(void)::serviceName = (uint64_t)result;
  return result;
}

CFStringRef CFNAccountKerberos::copyDebugDesc(CFNAccountKerberos *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CFNAccountKerberos@%p>"), this);
}

uint64_t CFNAccountKerberos::initialize(CFNAccountKerberos *this, objc_object *a2)
{
  if (!a2)
    return 0;
  *((_QWORD *)this + 2) = a2;
  *((_BYTE *)this + 48) = 0;
  return 1;
}

void `non-virtual thunk to'CFNAccountKerberos::~CFNAccountKerberos(CFNAccountKerberos *this)
{
  CFNAccountKerberos::~CFNAccountKerberos((CFNAccountKerberos *)((char *)this - 8));
}

{
  CFNAccountKerberos::~CFNAccountKerberos((CFNAccountKerberos *)((char *)this - 8));
}

void CFNAccountKerberos::~CFNAccountKerberos(CFNAccountKerberos *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E14E9158;
  *((_QWORD *)this + 1) = &unk_1E14E91A8;
  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
    CFRelease(v2);
  CFNAccount::~CFNAccount(this);
}

void sub_1840F4CC4(_Unwind_Exception *a1)
{
  CFNAccount *v1;

  CFNAccount::~CFNAccount(v1);
  _Unwind_Resume(a1);
}

void ___ZN18CFNAccountKerberos5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFNAccountKerberos");
  CFNAccountKerberos::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_1840F4D20(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t CFNAccountKerberos::kerberosCredential(CFNAccountKerberos *this, const __CFURL *a2)
{
  const __CFAllocator *v3;
  CFUUIDRef v4;
  const __CFUUID *v5;
  const __CFAllocator *v6;
  void *v8;
  const void *v9;
  void *v10;
  void *v11;
  id v12;

  if (*((_QWORD *)this + 7))
    return *((_QWORD *)this + 7);
  if (!*((_QWORD *)this + 4))
  {
    v8 = (void *)*((_QWORD *)this + 3);
    if (v8)
      goto LABEL_7;
    v10 = (void *)*((_QWORD *)this + 2);
    if (v10)
    {
      v11 = (void *)objc_msgSend(v10, "credential");
      *((_QWORD *)this + 3) = v11;
      if (v11)
      {
        v12 = v11;
        v8 = (void *)*((_QWORD *)this + 3);
        if (v8)
        {
LABEL_7:
          v9 = (const void *)objc_msgSend(v8, "token");
          *((_QWORD *)this + 4) = v9;
          if (!v9)
            return *((_QWORD *)this + 7);
          CFRetain(v9);
          if (!*((_QWORD *)this + 4))
            return *((_QWORD *)this + 7);
          goto LABEL_3;
        }
      }
    }
    else
    {
      *((_QWORD *)this + 3) = 0;
    }
    *((_QWORD *)this + 4) = 0;
    return *((_QWORD *)this + 7);
  }
LABEL_3:
  v3 = CFGetAllocator((char *)this - 16);
  v4 = CFUUIDCreateFromString(v3, *((CFStringRef *)this + 4));
  if (v4)
  {
    v5 = v4;
    v6 = CFGetAllocator((char *)this - 16);
    *((_QWORD *)this + 7) = _CFURLCredentialCreateForKerberosTicketWithUUID(v6, 0, 0, 0, v5);
    CFRelease(v5);
  }
  return *((_QWORD *)this + 7);
}

void STubeManager::~STubeManager(STubeManager *this)
{
  uint64_t v2;

  STubeManager::~STubeManager(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t i;
  uint64_t v3;

  *(_QWORD *)this = off_1E14E61A8;
  *((_QWORD *)this + 3) = &unk_1E14E6210;
  for (i = 80; i != 104; i += 8)
  {
    v3 = *(_QWORD *)((char *)this + i);
    if (v3)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
      *(_QWORD *)((char *)this + i) = 0;
    }
  }
  (*(void (**)(_QWORD))(**((_QWORD **)this + 4) + 48))(*((_QWORD *)this + 4));
  *((_QWORD *)this + 4) = 0;
  CFRelease(*((CFTypeRef *)this + 18));
  CFRelease(*((CFTypeRef *)this + 17));
  *((_QWORD *)this + 15) = &off_1E14EA528;
  CFRelease(*((CFTypeRef *)this + 16));
  *((_QWORD *)this + 13) = &off_1E14EA488;
  CFRelease(*((CFTypeRef *)this + 14));
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

uint64_t STubeManager::newTubeReady(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  _QWORD v10[8];

  if (!a2)
    __assert_rtn("newTubeReady", "STubeManager.cpp", 255, "FALSE");
  if (!a2[12])
    __assert_rtn("newTubeReady", "STubeManager.cpp", 251, "FALSE");
  (*(void (**)(_QWORD *))(*a2 + 40))(a2);
  (*(void (**)(_QWORD *))(*a1 + 40))(a1);
  v8 = a1[4];
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN12STubeManager12newTubeReadyEP5STube13CFStreamError_block_invoke;
  v10[3] = &__block_descriptor_64_e5_v8__0l;
  v10[4] = a1;
  v10[5] = a2;
  v10[6] = a3;
  v10[7] = a4;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v8 + 96))(v8, v10);
}

uint64_t STubeManager::getValidAwaitingTubeForKey(STubeManager *this, const HTTPConnectionCacheKey *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  v2 = *((_QWORD *)this + 4);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN12STubeManager26getValidAwaitingTubeForKeyEPK22HTTPConnectionCacheKey_block_invoke;
  v5[3] = &unk_1E14FD7A8;
  v5[4] = &v6;
  v5[5] = this;
  v5[6] = a2;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 104))(v2, v5);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1840F4FC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

CFMutableArrayRef STubeManager::pendingTubes@<X0>(CFTypeRef *this@<X0>, CFMutableArrayRef *a2@<X8>)
{
  const __CFAllocator *v4;
  CFMutableArrayRef result;

  v4 = CFGetAllocator(this[18]);
  result = CFArrayCreateMutableCopy(v4, 0, (CFArrayRef)this[18]);
  *a2 = result;
  return result;
}

uint64_t STubeManager::getPendingTubeForProtocolWithKey(uint64_t a1, uint64_t a2, void *key)
{
  const void *Value;
  uint64_t PendingTubeForProtocolWithKey;
  const __CFArray *v8;
  _QWORD v10[6];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  CFRange v15;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v14 = 0;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), key);
  if (Value)
  {
    PendingTubeForProtocolWithKey = (*(uint64_t (**)(const void *, uint64_t, void *))(*(_QWORD *)Value + 104))(Value, a2, key);
    v12[3] = PendingTubeForProtocolWithKey;
    if (PendingTubeForProtocolWithKey)
      goto LABEL_7;
  }
  else
  {
    PendingTubeForProtocolWithKey = v12[3];
    if (PendingTubeForProtocolWithKey)
      goto LABEL_7;
  }
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN12STubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke;
  v10[3] = &unk_1E14FD740;
  v10[4] = &v11;
  v10[5] = a2;
  v8 = *(const __CFArray **)(a1 + 136);
  v15.length = CFArrayGetCount(v8);
  v15.location = 0;
  CFArrayApplyFunction(v8, v15, (CFArrayApplierFunction)RetainableTypedArray<SAwaitingTube *>::_invoke, v10);
  PendingTubeForProtocolWithKey = v12[3];
  if (!PendingTubeForProtocolWithKey)
  {
    PendingTubeForProtocolWithKey = SBaseTubeManager::getPendingTubeForProtocolWithKey(a1, a2);
    v12[3] = PendingTubeForProtocolWithKey;
  }
LABEL_7:
  _Block_object_dispose(&v11, 8);
  return PendingTubeForProtocolWithKey;
}

void sub_1840F5138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'STubeManager::~STubeManager(STubeManager *this)
{
  STubeManager::~STubeManager((STubeManager *)((char *)this - 24));
}

void `non-virtual thunk to'STubeManager::~STubeManager(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  STubeManager::~STubeManager((STubeManager *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_1840F523C(_Unwind_Exception *a1)
{
  uint64_t v1;

  CFRelease(*(CFTypeRef *)(v1 + 144));
  CFRelease(*(CFTypeRef *)(v1 + 136));
  *(_QWORD *)(v1 + 120) = &off_1E14EA528;
  CFRelease(*(CFTypeRef *)(v1 + 128));
  *(_QWORD *)(v1 + 104) = &off_1E14EA488;
  CFRelease(*(CFTypeRef *)(v1 + 112));
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t ___ZN12STubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD *))(*a2 + 64))(a2);
  if (result == *(_QWORD *)(a1 + 40))
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2[10];
  return result;
}

uint64_t RetainableTypedArray<SAwaitingTube *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

_QWORD **STubeManager::_onqueue_getValidAwaitingTubeForKey(CFArrayRef *this, const HTTPConnectionCacheKey *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  _QWORD **ValueAtIndex;

  Count = CFArrayGetCount(this[17]);
  if (Count < 1)
    return 0;
  v5 = Count;
  v6 = 0;
  while (1)
  {
    ValueAtIndex = (_QWORD **)CFArrayGetValueAtIndex(this[17], v6);
    if ((*(unsigned int (**)(_QWORD *, const HTTPConnectionCacheKey *))(*ValueAtIndex[4] + 24))(ValueAtIndex[4], a2))
    {
      if (((unsigned int (*)(_QWORD **))(*ValueAtIndex)[12])(ValueAtIndex)
        && !((unsigned int (*)(_QWORD **))(*ValueAtIndex)[14])(ValueAtIndex))
      {
        break;
      }
    }
    if (v5 == ++v6)
      return 0;
  }
  return ValueAtIndex;
}

uint64_t ___ZN12STubeManager12newTubeReadyEP5STube13CFStreamError_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFArray *v6;
  CFIndex FirstIndexOfValue;
  uint64_t Waiter;
  const void *v9;
  const __CFArray *v10;
  CFIndex v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v22;
  const void *ValueAtIndex;
  uint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  const void *v44;
  uint64_t v45;
  int v46;
  uint64_t context;
  uint64_t p_context;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  void *v65;
  uint64_t *v66;
  const void *v67;
  CFRange v68;
  CFRange v69;
  CFRange v70;

  v2 = a1[4];
  v3 = a1[5];
  if (!v3)
    goto LABEL_61;
  v4 = a1[6];
  v5 = a1[7];
  (*(void (**)(_QWORD))(*(_QWORD *)v3 + 40))(a1[5]);
  v6 = *(const __CFArray **)(v2 + 144);
  v68.length = CFArrayGetCount(v6);
  v68.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v6, v68, (const void *)v3);
  if (FirstIndexOfValue == -1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
    goto LABEL_61;
  }
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v2 + 144), FirstIndexOfValue);
  Waiter = STube::getWaiter((STube *)v3);
  if (!Waiter)
    __assert_rtn("_onqueue_newTubeReady", "STubeManager.cpp", 444, "firstWaiter != NULL");
  v9 = (const void *)Waiter;
  (*(void (**)(uint64_t))(*(_QWORD *)Waiter + 40))(Waiter);
  v10 = *(const __CFArray **)(v2 + 136);
  v69.length = CFArrayGetCount(v10);
  v69.location = 0;
  v11 = CFArrayGetFirstIndexOfValue(v10, v69, v9);
  if (v11 == -1)
    __assert_rtn("_onqueue_newTubeReady", "STubeManager.cpp", 447, "i != -1");
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v2 + 136), v11);
  v12 = *(void **)(v3 + 96);
  v60 = 0;
  v61 = 0;
  v58 = 0x3F000000FFFFFFFFuLL;
  LODWORD(v59) = 0;
  if ((_DWORD)v5)
  {
    v13 = (*(uint64_t (**)(const void *))(*(_QWORD *)v9 + 64))(v9);
    if (v4 == *MEMORY[0x1E0C9B298])
    {
      context = 0;
      p_context = (uint64_t)&context;
      v49 = 0x2020000000;
      v50 = 0;
      v14 = *(_QWORD *)(v3 + 112);
      v62 = MEMORY[0x1E0C809B0];
      v63 = 3221225472;
      v64 = ___ZN5STube18copySSLCertContextEv_block_invoke;
      v65 = &unk_1E14FDA68;
      v66 = &context;
      v67 = (const void *)v3;
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v14 + 104))(v14, &v62);
      v15 = *(const void **)(p_context + 24);
      _Block_object_dispose(&context, 8);
    }
    else
    {
      v15 = 0;
    }
    if (v13)
      v18 = v13 - 176;
    else
      v18 = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t, const void *))(*(_QWORD *)v18 + 280))(v18, v4, v5, v15);
    if (v15)
      CFRelease(v15);
  }
  else
  {
    if ((STube::isCanceled((STube *)v3) & 1) == 0)
    {
      if (*(_DWORD *)(v3 + 136) != 1)
        __assert_rtn("connectionCacheTypeForTubeType", "STubeManager.h", 124, "FALSE");
      STubeManager::_onqueue_pairKeyWithConnectionCache(v2, v12);
      v19 = *(_QWORD *)(v2 + 80);
      if (!v19)
        __assert_rtn("_onqueue_newTubeReady", "STubeManager.cpp", 506, "connCache");
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)v19 + 96))(*(_QWORD *)(v2 + 80), v3);
      v46 = 0;
      goto LABEL_21;
    }
    v16 = (*(uint64_t (**)(const void *))(*(_QWORD *)v9 + 64))(v9);
    if (v16)
      v17 = v16 - 176;
    else
      v17 = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v17 + 280))(v17, 1, 89, 0);
  }
  v61 = 0;
  (*(void (**)(const void *, _QWORD))(*(_QWORD *)v9 + 56))(v9, 0);
  v19 = 0;
  v46 = 1;
LABEL_21:
  Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(v2 + 8), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 136));
  if (Count >= 1)
  {
    v22 = 0;
    v44 = v9;
    v45 = v19;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 136), v22);
      if ((*(unsigned int (**)(_QWORD, void *))(**((_QWORD **)ValueAtIndex + 4) + 24))(*((_QWORD *)ValueAtIndex + 4), v12)&& *((_QWORD *)ValueAtIndex + 10) == v3)
      {
        if (((*(uint64_t (**)(const void *))(*(_QWORD *)ValueAtIndex + 96))(ValueAtIndex) & 1) != 0)
        {
          if (!v46)
          {
            if (!v19)
              __assert_rtn("_onqueue_newTubeReady", "STubeManager.cpp", 564, "connCache != NULL");
            (*(void (**)(const void *, uint64_t *, uint64_t *, __int128 *))(*(_QWORD *)ValueAtIndex + 88))(ValueAtIndex, &v61, &v60, &v58);
            (*(void (**)(const void *, _QWORD))(*(_QWORD *)ValueAtIndex + 56))(ValueAtIndex, 0);
            v25 = *(_QWORD *)(v3 + 200);
            v26 = *(std::__shared_weak_count **)(v3 + 208);
            if (v26)
            {
              p_shared_owners = (unint64_t *)&v26->__shared_owners_;
              do
                v28 = __ldxr(p_shared_owners);
              while (__stxr(v28 + 1, p_shared_owners));
              if (v25)
              {
                v29 = v61;
                v56 = v25;
                v57 = v26;
                do
                  v30 = __ldxr(p_shared_owners);
                while (__stxr(v30 + 1, p_shared_owners));
LABEL_42:
                (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v29 + 40))(v29, &v56);
                v31 = v57;
                if (v57)
                {
                  v32 = (unint64_t *)&v57->__shared_owners_;
                  do
                    v33 = __ldaxr(v32);
                  while (__stlxr(v33 - 1, v32));
                  if (!v33)
                  {
                    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
                    std::__shared_weak_count::__release_weak(v31);
                  }
                }
                v34 = *(_QWORD *)(v3 + 96);
                v54 = v25;
                v55 = v26;
                if (v26)
                {
                  v35 = (unint64_t *)&v26->__shared_owners_;
                  do
                    v36 = __ldxr(v35);
                  while (__stxr(v36 + 1, v35));
                }
                (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v34 + 56))(v34, &v54);
                v37 = v55;
                if (v55)
                {
                  v38 = (unint64_t *)&v55->__shared_owners_;
                  do
                    v39 = __ldaxr(v38);
                  while (__stlxr(v39 - 1, v38));
                  if (!v39)
                  {
                    ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
                    std::__shared_weak_count::__release_weak(v37);
                  }
                }
              }
            }
            else if (v25)
            {
              v29 = v61;
              v56 = *(_QWORD *)(v3 + 200);
              v57 = 0;
              goto LABEL_42;
            }
            v52 = v58;
            v53 = v59;
            v19 = v45;
            (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *))(*(_QWORD *)v45 + 80))(v45, v61, v60, &v52);
            v9 = v44;
            if (v26)
            {
              v40 = (unint64_t *)&v26->__shared_owners_;
              do
                v41 = __ldaxr(v40);
              while (__stlxr(v41 - 1, v40));
              if (!v41)
              {
                ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
                std::__shared_weak_count::__release_weak(v26);
              }
            }
            goto LABEL_26;
          }
          (*(void (**)(const void *, _QWORD))(*(_QWORD *)ValueAtIndex + 56))(ValueAtIndex, 0);
          (*(void (**)(const void *))(*(_QWORD *)ValueAtIndex + 40))(ValueAtIndex);
          (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
          v24 = *(_QWORD *)(v2 + 32);
          v62 = MEMORY[0x1E0C809B0];
          v63 = 3221225472;
          v64 = ___ZN12STubeManager21_onqueue_newTubeReadyEP5STube13CFStreamError_block_invoke;
          v65 = &__block_descriptor_48_e5_v8__0l;
          v66 = (uint64_t *)v2;
          v67 = ValueAtIndex;
          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v24 + 96))(v24, &v62);
        }
        else
        {
          (*(void (**)(const void *, _QWORD))(*(_QWORD *)ValueAtIndex + 56))(ValueAtIndex, 0);
        }
      }
      else
      {
        CFArrayAppendValue(Mutable, ValueAtIndex);
      }
LABEL_26:
      ++v22;
    }
    while (v22 != Count);
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v2 + 136));
  context = MEMORY[0x1E0C809B0];
  p_context = 3221225472;
  v49 = (uint64_t)___ZN12STubeManager21_onqueue_newTubeReadyEP5STube13CFStreamError_block_invoke_2;
  v50 = &__block_descriptor_40_e163_v16__0__SAwaitingTube________CFAllocator_iB_____HTTPConnectionCacheKey___HTTPRequestMessage___MetaConnectionCacheClient__MetaConnectionOptions_ifQCCCC___STube_dd_8l;
  v51 = v2;
  v70.length = CFArrayGetCount(Mutable);
  v70.location = 0;
  CFArrayApplyFunction(Mutable, v70, (CFArrayApplierFunction)RetainableTypedArray<SAwaitingTube *>::_invoke, &context);
  (*(void (**)(const void *))(*(_QWORD *)v9 + 48))(v9);
  (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
  CFRelease(Mutable);
LABEL_61:
  v42 = a1[5];
  if (v42)
    (*(void (**)(uint64_t))(*(_QWORD *)v42 + 48))(v42);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void sub_1840F5A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void STubeManager::_onqueue_pairKeyWithConnectionCache(uint64_t a1, void *key)
{
  _OWORD *v4;
  const __CFAllocator *v5;
  _QWORD *v6;
  __int128 v7;
  __int128 v8;

  v4 = *(_OWORD **)(a1 + 80);
  if (!v4)
  {
    v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 128, 0);
    *v4 = 0u;
    v4[1] = 0u;
    v4[2] = 0u;
    v4[3] = 0u;
    v4[4] = 0u;
    v4[5] = 0u;
    v4[6] = 0u;
    v4[7] = 0u;
    v5 = *(const __CFAllocator **)(a1 + 8);
    MetaConnectionCache::MetaConnectionCache((MetaConnectionCache *)v4, v5);
    *v6 = off_1E14EBB00;
    v6[4] = &unk_1E14EBBC0;
    *((_QWORD *)v4 + 6) = CFSetCreateMutable(v5, 0, &CFAllocatedReferenceCountedObject::skCFTypeSetCallBacks);
    v7 = *(_OWORD *)(a1 + 40);
    v8 = *(_OWORD *)(a1 + 56);
    *((_QWORD *)v4 + 11) = *(_QWORD *)(a1 + 72);
    *(_OWORD *)((char *)v4 + 72) = v8;
    *(_OWORD *)((char *)v4 + 56) = v7;
    (*(void (**)(_OWORD *, _QWORD, uint64_t))(*(_QWORD *)v4 + 64))(v4, *(_QWORD *)(a1 + 32), a1);
    *(_QWORD *)(a1 + 80) = v4;
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 112), key, v4);
}

void sub_1840F5C14(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 32) = &off_1E14E5838;
  *(_QWORD *)v1 = off_1E14EA0F0;

  _Unwind_Resume(a1);
}

uint64_t ___ZN12STubeManager21_onqueue_newTubeReadyEP5STube13CFStreamError_block_invoke(uint64_t a1)
{
  uint64_t v2;
  SBaseAwaitingTube *v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v7;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(SBaseAwaitingTube **)(a1 + 40);
  v4 = (*(uint64_t (**)(SBaseAwaitingTube *))(*(_QWORD *)v3 + 64))(v3);
  v5 = (*(uint64_t (**)(SBaseAwaitingTube *))(*(_QWORD *)v3 + 72))(v3);
  (*(void (**)(__int128 *__return_ptr, SBaseAwaitingTube *))(*(_QWORD *)v3 + 80))(&v7, v3);
  STubeManager::_onqueue_enqueueRequestForProtocol(v2, v4, v5, &v7, v3);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 48))(*(_QWORD *)(a1 + 40));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void ___ZN12STubeManager21_onqueue_newTubeReadyEP5STube13CFStreamError_block_invoke_2(uint64_t a1, const void *a2)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 32) + 136), a2);
}

uint64_t STubeManager::_onqueue_enqueueRequestForProtocol(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, SBaseAwaitingTube *a5)
{
  void *v10;
  const void *Value;
  const void *v13;
  _QWORD *v14;
  BOOL v15;
  unint64_t v16;
  CFIndex Count;
  CFIndex v18;
  CFIndex v19;
  _OWORD *ValueAtIndex;
  uint64_t v21;
  int v22;
  int v23;
  _OWORD *v24;
  uint64_t v25;
  uint64_t v26;
  CFAbsoluteTime Current;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t (*v36)(uint64_t);
  void *v37;
  uint64_t *v38;
  _OWORD *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  char v43;

  v10 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), v10);
  if (Value)
  {
    if (!a5)
    {
LABEL_4:
      v31 = *a4;
      v32 = *((_QWORD *)a4 + 2);
      return (*(uint64_t (**)(const void *, uint64_t, uint64_t, __int128 *))(*(_QWORD *)Value + 80))(Value, a2, a3, &v31);
    }
LABEL_3:
    v40 = 0;
    v33 = 0;
    v34 = 0x3F000000FFFFFFFFLL;
    v35 = 0;
    LODWORD(v36) = 0;
    (*(void (**)(SBaseAwaitingTube *, uint64_t *, uint64_t *, uint64_t *))(*(_QWORD *)a5 + 88))(a5, &v40, &v33, &v34);
    goto LABEL_4;
  }
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 144))(a2) & 1) != 0)
  {
LABEL_6:
    STubeManager::_onqueue_pairKeyWithConnectionCache(a1, v10);
    v13 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), v10);
    if (!v13)
      __assert_rtn("_onqueue_enqueueRequestForProtocol", "STubeManager.cpp", 313, "connCache != NULL");
    Value = v13;
    (*(void (**)(const void *, void *))(*(_QWORD *)v13 + 72))(v13, v10);
    if (!a5)
      goto LABEL_4;
    goto LABEL_3;
  }
  v14 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  v15 = (*(unsigned int (**)(_QWORD *))(*v14 + 88))(v14) == 1
     || (*(unsigned int (**)(_QWORD *))(*v14 + 88))(v14) == 3;
  v16 = v14[9];
  (*(void (**)(_QWORD *))(*v14 + 64))(v14);
  if (v15)
  {
    if (v16 == 1)
      goto LABEL_6;
  }
  else if (v16 < 2)
  {
    goto LABEL_6;
  }
  v28 = a3;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 144));
  if (Count < 1)
  {
LABEL_22:
    ValueAtIndex = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 248, 0);
    *ValueAtIndex = 0u;
    ValueAtIndex[1] = 0u;
    ValueAtIndex[2] = 0u;
    ValueAtIndex[3] = 0u;
    ValueAtIndex[4] = 0u;
    ValueAtIndex[5] = 0u;
    ValueAtIndex[6] = 0u;
    ValueAtIndex[7] = 0u;
    ValueAtIndex[8] = 0u;
    ValueAtIndex[9] = 0u;
    ValueAtIndex[10] = 0u;
    ValueAtIndex[11] = 0u;
    ValueAtIndex[12] = 0u;
    ValueAtIndex[13] = 0u;
    ValueAtIndex[14] = 0u;
    *((_QWORD *)ValueAtIndex + 30) = 0;
    STube::STube((uint64_t)ValueAtIndex, *(_QWORD *)(a1 + 8), (uint64_t)v10, a1, *(_QWORD *)(a1 + 32));
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 144), ValueAtIndex);
    (*(void (**)(_OWORD *))(*(_QWORD *)ValueAtIndex + 48))(ValueAtIndex);
    v23 = 1;
  }
  else
  {
    v18 = Count;
    v19 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), v19);
      if ((*(unsigned int (**)(_QWORD, void *))(**((_QWORD **)ValueAtIndex + 12) + 24))(*((_QWORD *)ValueAtIndex + 12), v10))
      {
        v40 = 0;
        v41 = &v40;
        v42 = 0x2020000000;
        v43 = 0;
        v21 = *((_QWORD *)ValueAtIndex + 14);
        v34 = MEMORY[0x1E0C809B0];
        v35 = 3221225472;
        v36 = ___ZN5STube16canAcceptWaitersEv_block_invoke;
        v37 = &unk_1E14FDA68;
        v38 = &v40;
        v39 = ValueAtIndex;
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v21 + 104))(v21, &v34);
        v22 = *((unsigned __int8 *)v41 + 24);
        _Block_object_dispose(&v40, 8);
        if (v22)
          break;
      }
      if (v18 == ++v19)
        goto LABEL_22;
    }
    v23 = 0;
  }
  if (!a5)
  {
    v24 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 104, 0);
    *v24 = 0u;
    v24[2] = 0u;
    v24[3] = 0u;
    v24[4] = 0u;
    v24[5] = 0u;
    *((_QWORD *)v24 + 12) = 0;
    v24[1] = 0u;
    v25 = *(_QWORD *)(a1 + 8);
    v30 = *((_QWORD *)a4 + 2);
    v29 = *a4;
    *(_QWORD *)v24 = off_1E14EF578;
    *((_QWORD *)v24 + 1) = v25;
    *((_DWORD *)v24 + 4) = 1;
    if (((unint64_t)(v24 + 1) & 3) != 0)
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    a5 = (SBaseAwaitingTube *)v24;
    *(_QWORD *)v24 = off_1E14E67F0;
    *((_QWORD *)v24 + 3) = &unk_1E14E6878;
    *(_OWORD *)((char *)v24 + 56) = v29;
    *((_QWORD *)v24 + 9) = v30;
    if (!v28)
      __assert_rtn("SAwaitingTube", "SAwaitingTube.cpp", 16, "httpMessage");
    *((_QWORD *)v24 + 5) = v28;
    CFRetain((CFTypeRef)(v28 - 16));
    *((_QWORD *)a5 + 6) = a2;
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v26 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a5 + 6) + 32))(*((_QWORD *)a5 + 6));
    *((_QWORD *)a5 + 4) = v26;
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 40))(v26);
    *((_QWORD *)a5 + 10) = 0;
    Current = CFAbsoluteTimeGetCurrent();
    *((CFAbsoluteTime *)a5 + 11) = Current;
    *((CFAbsoluteTime *)a5 + 12) = Current;
    (*(void (**)(SBaseAwaitingTube *, _OWORD *))(*(_QWORD *)a5 + 56))(a5, ValueAtIndex);
    if (!v23)
      goto LABEL_27;
    goto LABEL_26;
  }
  (*(void (**)(SBaseAwaitingTube *, _OWORD *))(*(_QWORD *)a5 + 56))(a5, ValueAtIndex);
  (*(void (**)(SBaseAwaitingTube *))(*(_QWORD *)a5 + 40))(a5);
  if (v23)
LABEL_26:
    STube::initialize((STube *)ValueAtIndex, a5);
LABEL_27:
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 136), a5);
  return (*(uint64_t (**)(SBaseAwaitingTube *))(*(_QWORD *)a5 + 48))(a5);
}

void sub_1840F618C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12STubeManager24invalidateAllConnectionsEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[5];

  v2 = *(_QWORD *)(a2 + 112);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN5STube6cancelEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 104))(v2, v4);
}

uint64_t ___ZN12STubeManager38invalidateUnpurgeableConnectionsForKeyEPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 128))(a2, *(_QWORD *)(a1 + 32));
}

uint64_t ___ZN12STubeManager25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v8;
  uint64_t v9;

  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  v4 = *(_QWORD *)(a1 + 48);
  v8 = *(_OWORD *)(a1 + 56);
  v9 = *(_QWORD *)(a1 + 72);
  STubeManager::_onqueue_enqueueRequestForProtocol(v3, v2, v4, &v8, 0);
  v5 = *(_QWORD *)(a1 + 40);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  v6 = *(_QWORD *)(a1 + 48);
  if (v6)
    CFRelease((CFTypeRef)(v6 - 16));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
}

CFStringRef CoreSchedulingSet::copyDebugDesc(CoreSchedulingSet *this)
{
  CFAllocatorRef *v2;
  const __CFAllocator *v3;
  const __CFString *v4;
  UInt8 *v5;
  NSObject *v6;
  const char *label;
  const __CFAllocator *allocator;
  uint64_t v10;
  void *ptr;
  UInt8 v12[1024];
  char __str[16];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  *(_OWORD *)__str = 0u;
  v14 = 0u;
  v2 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  switch(*((_DWORD *)this + 10))
  {
    case 0:
      strcpy(__str, "not scheduled");
      break;
    case 1:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const __CFString *)*((_QWORD *)this + 10);
      allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v10 = 1023;
      if (v4)
      {
        v5 = _CFStringGetOrCreateCString(v3, v4, v12, &v10, 0x8000100u);
      }
      else
      {
        v12[0] = 0;
        v10 = 0;
        v5 = v12;
      }
      ptr = v5;
      snprintf(__str, 0x100uLL, "pair { %p, %s }", *((const void **)this + 9), (const char *)v5);
      if (ptr && v12 != ptr)
        CFAllocatorDeallocate(allocator, ptr);
      break;
    case 2:
      strcpy(__str, "multi scheduled");
      break;
    case 3:
      v6 = *((_QWORD *)this + 7);
      label = dispatch_queue_get_label(v6);
      snprintf(__str, 0x100uLL, "queue %p %s", v6, label);
      break;
    default:
      return CFStringCreateWithFormat(*v2, 0, CFSTR("CoreSchedulingSet<%p> { %s }"), this, __str);
  }
  return CFStringCreateWithFormat(*v2, 0, CFSTR("CoreSchedulingSet<%p> { %s }"), this, __str);
}

uint64_t CoreSchedulingSet::copyWithAdditionReleaseSelf(CoreSchedulingSet *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  _OWORD *v4;
  uint64_t v5;

  v4 = CoreSchedulingSet::create(a2, cf1, cf1);
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
  v5 = (*(uint64_t (**)(CoreSchedulingSet *, _OWORD *, uint64_t))(*(_QWORD *)this + 72))(this, v4, CoreSchedulingSet::getEmptySet(void)::sEmptySet);
  (*(void (**)(_OWORD *))(*(_QWORD *)v4 + 48))(v4);
  return v5;
}

uint64_t CoreSchedulingSet::copyWithRemovalReleaseSelf(CoreSchedulingSet *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  _OWORD *v4;
  uint64_t v5;

  v4 = CoreSchedulingSet::create(a2, cf1, cf1);
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
  v5 = (*(uint64_t (**)(CoreSchedulingSet *, uint64_t, _OWORD *))(*(_QWORD *)this + 72))(this, CoreSchedulingSet::getEmptySet(void)::sEmptySet, v4);
  (*(void (**)(_OWORD *))(*(_QWORD *)v4 + 48))(v4);
  return v5;
}

CFSetRef *CoreSchedulingSet::copyWithUpdatesReleaseSelf(CoreSchedulingSet *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  uint64_t isEqualTo;
  CFSetRef *v7;
  int v8;
  int v9;
  int v10;
  const __CFAllocator *v11;
  const __CFSet *v12;
  const __CFSet *v13;
  CFIndex v14;
  CoreSchedulingSet *Array;
  const __CFSet *v16;
  uint64_t Empty;
  CoreSchedulingSet *v18;
  uint64_t v19;
  NSObject *v20;
  const char *v21;
  uint32_t v22;
  const __CFAllocator *v23;
  CFIndex Count;
  __CFSet *MutableCopy;
  const __CFSet *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  const __CFAllocator *v31;
  CoreSchedulingSet *v32;
  uint64_t v33;
  CFIndex v34;
  const __CFSet *v35;
  const __CFAllocator *v36;
  CoreSchedulingSet *v37;
  const __CFSet *v38;
  uint64_t v39;
  const void *v40;
  uint64_t v41;
  const __CFAllocator *v42;
  const __CFSet *v43;
  const __CFSet *v44;
  CFIndex v45;
  CFIndex v46;
  const __CFSet *v47;
  __CFSet *v48;
  const __CFSet *v49;
  uint64_t v50;
  uint8_t buf[8];
  __CFArray *v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  isEqualTo = (*(uint64_t (**)(CoreSchedulingSet *))(*(_QWORD *)this + 88))(this);
  v7 = (CFSetRef *)isEqualTo;
  v8 = *((_DWORD *)a3 + 10);
  if (v8)
  {
    v9 = *(_DWORD *)(isEqualTo + 40);
    v10 = v8 | (v9 << 16);
    if (v10 >= 0x20000)
    {
      if (v10 >= 196608)
      {
        if ((v10 - 196609) < 2)
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            v20 = MEMORY[0x1E0C81028];
            v21 = "was scheduled on a dispatch queue, but now want to be on a runloop?";
            v22 = 2;
            goto LABEL_25;
          }
LABEL_38:
          v19 = (*((uint64_t (**)(CFSetRef *))*v7 + 11))(v7);
          goto LABEL_39;
        }
        if (v10 == 196611)
        {
          if (*(_QWORD *)(isEqualTo + 56) != *((_QWORD *)a3 + 7))
            goto LABEL_38;
        }
        else if (v10 != 196608)
        {
          goto LABEL_21;
        }
      }
      else if (v10 != 0x20000)
      {
        if (v10 == 131073)
        {
          v23 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          Array = (CoreSchedulingSet *)cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(_QWORD *)(isEqualTo + 72), *(_QWORD *)(isEqualTo + 80), 0);
          if (CFSetContainsValue(v7[6], Array))
          {
            Count = CFSetGetCount(v7[6]);
            MutableCopy = CFSetCreateMutableCopy(v23, Count, v7[6]);
            CFSetRemoveValue(MutableCopy, Array);
            CoreSchedulingSet::create((CoreSchedulingSet *)MutableCopy, v26);
            v19 = v27;
            if (MutableCopy)
              CFRelease(MutableCopy);
LABEL_32:
            if (Array)
              CFRelease(Array);
            if (v19)
              goto LABEL_39;
            goto LABEL_38;
          }
LABEL_31:
          v19 = 0;
          goto LABEL_32;
        }
        if (v10 != 131074)
        {
LABEL_21:
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&buf[4] = v9;
            LOWORD(v53) = 1024;
            *(_DWORD *)((char *)&v53 + 2) = v8;
            v20 = MEMORY[0x1E0C81028];
            v21 = "Can't remove scheduling of type %d with type %d";
            v22 = 14;
LABEL_25:
            _os_log_fault_impl(&dword_183ECA000, v20, OS_LOG_TYPE_FAULT, v21, buf, v22);
            goto LABEL_38;
          }
          goto LABEL_38;
        }
        isEqualTo = CFEqual(*(CFTypeRef *)(isEqualTo + 48), *((CFTypeRef *)a3 + 6));
        if (!(_DWORD)isEqualTo)
        {
          v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v12 = v7[6];
          v13 = (const __CFSet *)*((_QWORD *)a3 + 6);
          v14 = CFSetGetCount(v12);
          Array = (CoreSchedulingSet *)CFSetCreateMutableCopy(v11, v14, v12);
          CFSetApplyFunction(v13, (CFSetApplierFunction)_subPair, Array);
          CoreSchedulingSet::create(Array, v16);
LABEL_17:
          v19 = Empty;
          goto LABEL_32;
        }
      }
    }
    else
    {
      if (v10 < 0x10000)
      {
        if (v10 < 4)
          goto LABEL_38;
        goto LABEL_21;
      }
      if (v10 != 0x10000)
      {
        if (v10 != 65537)
        {
          if (v10 == 65538)
          {
            Array = (CoreSchedulingSet *)cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(_QWORD *)(isEqualTo + 72), *(_QWORD *)(isEqualTo + 80), 0);
            v18 = (CoreSchedulingSet *)CFSetContainsValue(*((CFSetRef *)a3 + 6), Array);
            if ((_DWORD)v18)
            {
              Empty = CoreSchedulingSet::createEmpty(v18);
              goto LABEL_17;
            }
            goto LABEL_31;
          }
          goto LABEL_21;
        }
        isEqualTo = CoreSchedulingSet::isEqualTo((CoreSchedulingSet *)isEqualTo, a3);
        if (!(_DWORD)isEqualTo)
          goto LABEL_38;
      }
    }
    v19 = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)isEqualTo);
    if (v19)
    {
LABEL_39:
      (*((void (**)(CFSetRef *))*v7 + 6))(v7);
      v7 = (CFSetRef *)v19;
      goto LABEL_40;
    }
    goto LABEL_38;
  }
LABEL_40:
  v28 = *((_DWORD *)a2 + 10);
  if (v28)
  {
    v29 = *((_DWORD *)v7 + 10);
    v30 = v28 | (v29 << 16);
    if (v30 <= 65537)
    {
      if (v30 < 0x10000)
      {
        if ((v30 - 1) >= 3)
        {
          if (v30)
          {
LABEL_69:
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&buf[4] = v29;
              LOWORD(v53) = 1024;
              *(_DWORD *)((char *)&v53 + 2) = v28;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Can't add scheduling of type %d with type %d", buf, 0xEu);
            }
          }
LABEL_78:
          v33 = (*((uint64_t (**)(CFSetRef *))*v7 + 11))(v7);
          goto LABEL_79;
        }
        goto LABEL_55;
      }
      if (v30 == 0x10000 || CoreSchedulingSet::isEqualTo((CoreSchedulingSet *)v7, a2))
        goto LABEL_78;
      v36 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      *(_QWORD *)buf = cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v7[9], v7[10], 0);
      v53 = cfTypeCreateArray(v36, *((_QWORD *)a2 + 9), *((_QWORD *)a2 + 10), 0);
      v37 = (CoreSchedulingSet *)CFSetCreate(v36, (const void **)buf, 2, MEMORY[0x1E0C9B3B0]);
      CoreSchedulingSet::create(v37, v38);
      v33 = v39;
      if (v37)
        CFRelease(v37);
      if (*(_QWORD *)buf)
        CFRelease(*(CFTypeRef *)buf);
      v40 = v53;
      if (!v53)
        goto LABEL_77;
      goto LABEL_76;
    }
    if (v30 > 131073)
    {
      if (v30 != 131074)
      {
        if (v30 == 196608)
          goto LABEL_78;
        if (v30 != 196611)
          goto LABEL_69;
LABEL_55:
        v33 = (*(uint64_t (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 88))(a2);
        goto LABEL_77;
      }
      if (CFEqual(v7[6], *((CFTypeRef *)a2 + 6)))
        goto LABEL_78;
      v42 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v43 = v7[6];
      v44 = (const __CFSet *)*((_QWORD *)a2 + 6);
      v45 = CFSetGetCount(v43);
      v46 = CFSetGetCount(v44);
      v32 = (CoreSchedulingSet *)CFSetCreateMutableCopy(v42, v46 + v45, v43);
      CFSetApplyFunction(v44, (CFSetApplierFunction)_unionPair, v32);
      CoreSchedulingSet::create(v32, v47);
    }
    else
    {
      if (v30 != 65538)
      {
        if (v30 == 0x20000)
          goto LABEL_78;
        if (v30 != 131073)
          goto LABEL_69;
        v31 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v32 = (CoreSchedulingSet *)cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *((_QWORD *)a2 + 9), *((_QWORD *)a2 + 10), 0);
        v33 = 0;
        if (CFSetContainsValue(v7[6], v32))
          goto LABEL_74;
        v34 = CFSetGetCount(v7[6]) + 1;
        v35 = v7[6];
        goto LABEL_72;
      }
      v31 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v32 = (CoreSchedulingSet *)cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v7[9], v7[10], 0);
      if (!CFSetContainsValue(*((CFSetRef *)a2 + 6), v32))
      {
        v34 = CFSetGetCount(*((CFSetRef *)a2 + 6)) + 1;
        v35 = (const __CFSet *)*((_QWORD *)a2 + 6);
LABEL_72:
        v48 = CFSetCreateMutableCopy(v31, v34, v35);
        CFSetAddValue(v48, v32);
        CoreSchedulingSet::create((CoreSchedulingSet *)v48, v49);
        v33 = v50;
        if (v48)
          CFRelease(v48);
        goto LABEL_74;
      }
      v41 = (*(uint64_t (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 88))(a2);
    }
    v33 = v41;
LABEL_74:
    if (!v32)
      goto LABEL_77;
    v40 = v32;
LABEL_76:
    CFRelease(v40);
LABEL_77:
    if (v33)
    {
LABEL_79:
      (*((void (**)(CFSetRef *))*v7 + 6))(v7);
      v7 = (CFSetRef *)v33;
      goto LABEL_80;
    }
    goto LABEL_78;
  }
LABEL_80:
  (*(void (**)(CoreSchedulingSet *))(*(_QWORD *)this + 48))(this);
  return v7;
}

uint64_t CoreSchedulingSet::createDispatchTimer(CoreSchedulingSet *this)
{
  return 0;
}

uint64_t _applyRunloopBlock(const __CFArray *a1, uint64_t (**a2)(_QWORD, _QWORD, _QWORD))
{
  const void *ValueAtIndex;
  const void *v5;

  ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
  v5 = CFArrayGetValueAtIndex(a1, 1);
  return ((uint64_t (**)(_QWORD, const void *, const void *))a2)[2](a2, ValueAtIndex, v5);
}

void CoreSchedulingSet::create(CoreSchedulingSet *this, const __CFSet *a2)
{
  CFIndex Count;
  const __CFArray *v4;
  _OWORD *v5;
  uint8_t v6[8];
  void *values;

  Count = CFSetGetCount((CFSetRef)this);
  if (Count == 1)
  {
    values = 0;
    CFSetGetValues((CFSetRef)this, (const void **)&values);
    if (CFArrayGetCount((CFArrayRef)values) != 2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v6 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "assertion failure", v6, 2u);
    }
    CoreSchedulingSet::create((CoreSchedulingSet *)values, v4);
  }
  else if (Count)
  {
    v5 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 120, 0);
    *v5 = 0u;
    v5[1] = 0u;
    v5[2] = 0u;
    v5[3] = 0u;
    v5[4] = 0u;
    v5[5] = 0u;
    v5[6] = 0u;
    *((_QWORD *)v5 + 14) = 0;
    RunLoopSchedulingSet::RunLoopSchedulingSet((RunLoopSchedulingSet *)v5, (const __CFSet *)this);
  }
  else
  {
    CoreSchedulingSet::createEmpty(0);
  }
}

void _unionPair(const void *value, CFMutableSetRef theSet)
{
  CFSetAddValue(theSet, value);
}

_OWORD *CoreSchedulingSet::create(CoreSchedulingSet *this, const __CFArray *a2)
{
  CFIndex Count;
  uint64_t v4;
  CoreSchedulingSet *ValueAtIndex;
  const __CFString *v7;
  const __CFString *v8;
  const __CFAllocator *v9;
  uint64_t v10;
  const __CFSet *v11;
  __CFSet *Mutable;
  CFIndex i;
  const void *v14;
  CFIndex v15;
  const void *v16;
  __CFArray *Array;
  uint64_t v18;
  uint64_t v19;
  uint8_t buf[16];

  Count = CFArrayGetCount((CFArrayRef)this);
  if (Count == 2)
  {
    ValueAtIndex = (CoreSchedulingSet *)CFArrayGetValueAtIndex((CFArrayRef)this, 0);
    v7 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)this, 1);
    return CoreSchedulingSet::create(ValueAtIndex, v7, v8);
  }
  else
  {
    v4 = Count;
    if (Count)
    {
      if ((Count & 1) != 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "odd number in runloop/mode array", buf, 2u);
      }
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (v4 >= 0)
        v10 = v4;
      else
        v10 = v4 + 1;
      Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v10 >> 1, MEMORY[0x1E0C9B3B0]);
      if (v4 >= 1)
      {
        for (i = 0; i < v4; i = v15 + 1)
        {
          v14 = CFArrayGetValueAtIndex((CFArrayRef)this, i);
          v15 = i + 1;
          v16 = CFArrayGetValueAtIndex((CFArrayRef)this, v15);
          Array = cfTypeCreateArray(v9, v14, v16, 0);
          CFSetAddValue(Mutable, Array);
          if (Array)
            CFRelease(Array);
        }
      }
      CoreSchedulingSet::create((CoreSchedulingSet *)Mutable, v11);
      v19 = v18;
      if (Mutable)
        CFRelease(Mutable);
      return (_OWORD *)v19;
    }
    else
    {
      return (_OWORD *)CoreSchedulingSet::createEmpty(0);
    }
  }
}

void RunLoopSchedulingSet::RunLoopSchedulingSet(RunLoopSchedulingSet *this, const __CFSet *a2)
{
  uint64_t v4;

  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, (const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
  *(_DWORD *)(v4 + 40) = 2;
  *(_QWORD *)v4 = off_1E14EBA58;
  *(_QWORD *)(v4 + 24) = &unk_1E14EBAE0;
  *((_QWORD *)this + 6) = CFSetCreateCopy(*(CFAllocatorRef *)(v4 + 8), a2);
  *((_BYTE *)this + 116) = 0;
}

void sub_1840F6F58(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)v1 = off_1E14E8500;
  *(_DWORD *)(v1 + 40) = 0;
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

CFStringRef RunLoopSchedulingSet::copyDebugDesc(CoreSchedulingSet *this)
{
  CFStringRef v2;
  CFStringRef v3;
  const __CFAllocator *v4;
  CFStringRef v5;
  uint64_t v6;
  const __CFString *v7;
  char *v8;
  CFStringRef v9;

  v2 = CoreSchedulingSet::copyDebugDesc(this);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@ (%s)"), v2, *((_QWORD *)this + 12));
  CFRelease(v3);
  if (v5)
  {
    v6 = *((_QWORD *)this + 13);
    if (v6)
    {
      v7 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
      v8 = _cfnAutoreleaseInDebug(v7);
      v9 = CFStringCreateWithFormat(v4, 0, CFSTR("%@ - PENDING %s"), v5, v8);
      CFRelease(v5);
      return v9;
    }
  }
  return v5;
}

CoreSchedulingSet *RunLoopSchedulingSet::copyWithAdditionReleaseSelf(CoreSchedulingSet *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  if (*((_DWORD *)this + 10) == 1 && *((CoreSchedulingSet **)this + 9) == a2 && CFEqual(cf1, *((CFTypeRef *)this + 10)))
    return this;
  else
    return (CoreSchedulingSet *)CoreSchedulingSet::copyWithAdditionReleaseSelf(this, a2, cf1);
}

uint64_t RunLoopSchedulingSet::copyWithRemovalReleaseSelf(CoreSchedulingSet *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  CoreSchedulingSet *v7;
  uint64_t Empty;

  if (*((_DWORD *)this + 10) != 1)
    return CoreSchedulingSet::copyWithAdditionReleaseSelf(this, a2, cf1);
  if (*((CoreSchedulingSet **)this + 9) != a2)
    return CoreSchedulingSet::copyWithAdditionReleaseSelf(this, a2, cf1);
  v7 = (CoreSchedulingSet *)CFEqual(cf1, *((CFTypeRef *)this + 10));
  if (!(_DWORD)v7)
    return CoreSchedulingSet::copyWithAdditionReleaseSelf(this, a2, cf1);
  Empty = CoreSchedulingSet::createEmpty(v7);
  (*(void (**)(CoreSchedulingSet *))(*(_QWORD *)this + 48))(this);
  return Empty;
}

void `non-virtual thunk to'RunLoopSchedulingSet::~RunLoopSchedulingSet(RunLoopSchedulingSet *this)
{
  RunLoopSchedulingSet::~RunLoopSchedulingSet((RunLoopSchedulingSet *)((char *)this - 24));
}

void `non-virtual thunk to'RunLoopSchedulingSet::~RunLoopSchedulingSet(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  RunLoopSchedulingSet::~RunLoopSchedulingSet((RunLoopSchedulingSet *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

uint64_t RetainableTypedDict<__CFRunLoop *,CoreSchedulingSet const*>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA3A8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<__CFRunLoop *,CoreSchedulingSet const*>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA3A8;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

BOOL RunloopBlockContext::equals(RunloopBlockContext *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

void `non-virtual thunk to'RunloopBlockContext::~RunloopBlockContext(RunloopBlockContext *this)
{
  RunloopBlockContext::~RunloopBlockContext((RunloopBlockContext *)((char *)this - 24));
}

{
  RunloopBlockContext::~RunloopBlockContext((RunloopBlockContext *)((char *)this - 32));
}

void `non-virtual thunk to'RunloopBlockContext::~RunloopBlockContext(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  RunloopBlockContext::~RunloopBlockContext((RunloopBlockContext *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 4;
  RunloopBlockContext::~RunloopBlockContext((RunloopBlockContext *)(this - 4));
  CFAllocatorDeallocate(*(this - 3), v2);
}

const __CFString *_createWrappedStringWithFormat(CFStringRef format, ...)
{
  const __CFAllocator *v1;
  const __CFString *v2;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v4;
  va_list va;

  va_start(va, format);
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v2 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, format, va);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v1, v2, CFSTR("\n"));
  if (ArrayBySeparatingStrings)
  {
    v4 = ArrayBySeparatingStrings;
    if (CFArrayGetCount(ArrayBySeparatingStrings) != 1)
    {
      CFRelease(v2);
      v2 = CFStringCreateByCombiningStrings(v1, v4, CFSTR(" "));
    }
    CFRelease(v4);
  }
  return v2;
}

_QWORD *_cancel(_QWORD *result, __CFRunLoop *a2, const __CFString *a3)
{
  _QWORD *v5;
  NSObject *v6;
  uint8_t buf[4];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v5 = result;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v8 = v5;
      _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "Unexpectedly canceled: %@", buf, 0xCu);
    }
    -[__CFN_CoreSchedulingSetRunnable __SITUATIONAL_ABORT__:reason:](v5, (uint64_t)"source was canceled", (void *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("cancel called for rl %p, mode %@"), a2, a3));
  }
  return result;
}

void _perform(char *a1)
{
  NSObject *v2;
  unint64_t *v3;
  unint64_t v4;
  int v5;
  char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v2 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 138412290;
      v6 = a1;
      _os_log_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEFAULT, "Unexpectedly performed: %@", (uint8_t *)&v5, 0xCu);
    }
    v3 = (unint64_t *)(a1 + 40);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
}

void EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet(EmptyCoreSchedulingSet *this)
{
  EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet(this);
}

{
  EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet(this);
}

{
  *(_QWORD *)this = off_1E14EC358;
  *((_QWORD *)this + 3) = &unk_1E14EC3E0;
  fprintf((FILE *)*MEMORY[0x1E0C80C10], "empty scheduling set being deallocated %p\n", this);
  abort();
}

uint64_t EmptyCoreSchedulingSet::copyWithRemovalReleaseSelf(EmptyCoreSchedulingSet *this, __CFRunLoop *a2, const __CFString *a3)
{
  return (*(uint64_t (**)(EmptyCoreSchedulingSet *))(*(_QWORD *)this + 88))(this);
}

EmptyCoreSchedulingSet *EmptyCoreSchedulingSet::createCopy(EmptyCoreSchedulingSet *this)
{
  (*(void (**)(EmptyCoreSchedulingSet *))(*(_QWORD *)this + 40))(this);
  return this;
}

void EmptyCoreSchedulingSet::performAsync()
{
  uint8_t v0[16];

  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v0 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "EMPTY SET INVOKED", v0, 2u);
  }
}

void `non-virtual thunk to'EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet(EmptyCoreSchedulingSet *this)
{
  EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet((EmptyCoreSchedulingSet *)((char *)this - 24));
}

{
  EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet((EmptyCoreSchedulingSet *)((char *)this - 24));
}

void sub_1840F7998(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)v1 = off_1E14E8500;
  *(_DWORD *)(v1 + 40) = 0;
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void _subPair(const void *value, CFMutableSetRef theSet)
{
  CFSetRemoveValue(theSet, value);
}

CFAllocatedReferenceCountedObject *CoreSchedulingSet::createWithDispatchQueue(CoreSchedulingSet *this, void *a2)
{
  const __CFAllocator *v3;
  CFAllocatedReferenceCountedObject *v4;
  uint64_t v5;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 96, 0);
  *(_OWORD *)v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  *((_OWORD *)v4 + 5) = 0u;
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v4, v3);
  *(_DWORD *)(v5 + 40) = 3;
  *(_QWORD *)v5 = off_1E14E9938;
  *(_QWORD *)(v5 + 24) = &unk_1E14E99C0;
  *(_DWORD *)(v5 + 64) = 0;
  *(_QWORD *)(v5 + 56) = this;
  dispatch_retain((dispatch_object_t)this);
  return v4;
}

void QCoreSchedulingSet::~QCoreSchedulingSet(QCoreSchedulingSet *this)
{
  *(_QWORD *)this = off_1E14E9938;
  *((_QWORD *)this + 3) = &unk_1E14E99C0;
  dispatch_release(*((dispatch_object_t *)this + 7));
  *((_QWORD *)this + 7) = 0;
  *(_QWORD *)this = off_1E14E8500;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

{
  *(_QWORD *)this = off_1E14E9938;
  *((_QWORD *)this + 3) = &unk_1E14E99C0;
  dispatch_release(*((dispatch_object_t *)this + 7));
  *((_QWORD *)this + 7) = 0;
  *(_QWORD *)this = off_1E14E8500;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 3) = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

QCoreSchedulingSet *QCoreSchedulingSet::createCopy(QCoreSchedulingSet *this)
{
  (*(void (**)(QCoreSchedulingSet *))(*(_QWORD *)this + 40))(this);
  return this;
}

void `non-virtual thunk to'QCoreSchedulingSet::~QCoreSchedulingSet(QCoreSchedulingSet *this)
{
  *((_QWORD *)this - 3) = off_1E14E9938;
  *(_QWORD *)this = &unk_1E14E99C0;
  dispatch_release(*((dispatch_object_t *)this + 4));
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this - 3) = off_1E14E8500;
  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E14E5838;
}

{
  _QWORD *v2;

  *((_QWORD *)this - 3) = off_1E14E9938;
  v2 = (_QWORD *)((char *)this - 24);
  *(_QWORD *)this = &unk_1E14E99C0;
  dispatch_release(*((dispatch_object_t *)this + 4));
  *((_QWORD *)this + 4) = 0;
  *v2 = off_1E14E8500;
  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 2), v2);
}

void ___ZNK17CoreSchedulingSet14scheduleSourceEP17__CFRunLoopSource_block_invoke(uint64_t a1, CFRunLoopRef rl, const __CFString *a3)
{
  CFRunLoopAddSource(rl, *(CFRunLoopSourceRef *)(a1 + 32), a3);
}

void ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke(uint64_t a1, CFRunLoopRef rl, const __CFString *a3)
{
  CFRunLoopAddTimer(rl, *(CFRunLoopTimerRef *)(a1 + 32), a3);
}

void ___ZNK17CoreSchedulingSet15unscheduleTimerEP16__CFRunLoopTimer_block_invoke(uint64_t a1, CFRunLoopRef rl, const __CFString *a3)
{
  CFRunLoopRemoveTimer(rl, *(CFRunLoopTimerRef *)(a1 + 32), a3);
}

void CoreSchedulingSet::scheduleStream(CoreSchedulingSet *this, __CFReadStream *a2)
{
  int v2;
  void (*v3[6])(_QWORD, _QWORD, _QWORD);

  v2 = *((_DWORD *)this + 10);
  if (v2)
  {
    if (v2 == 3)
      JUMPOUT(0x186DB62D4);
    v3[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v3[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v3[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZNK17CoreSchedulingSet15_scheduleStreamEPvPFvS0_PU28objcproto17OS_dispatch_queue8NSObjectEPFvS0_P11__CFRunLoopPK10__CFStringE_block_invoke;
    v3[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_48_e38_v24__0____CFRunLoop__8____CFString__16l;
    v3[4] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C98B90];
    v3[5] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
    CoreSchedulingSet::applyBlock((uint64_t)this, v3);
  }
}

void CoreSchedulingSet::scheduleStream(CoreSchedulingSet *this, __CFWriteStream *a2)
{
  int v2;
  void (*v3[6])(_QWORD, _QWORD, _QWORD);

  v2 = *((_DWORD *)this + 10);
  if (v2)
  {
    if (v2 == 3)
      JUMPOUT(0x186DB6A90);
    v3[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v3[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v3[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZNK17CoreSchedulingSet15_scheduleStreamEPvPFvS0_PU28objcproto17OS_dispatch_queue8NSObjectEPFvS0_P11__CFRunLoopPK10__CFStringE_block_invoke;
    v3[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_48_e38_v24__0____CFRunLoop__8____CFString__16l;
    v3[4] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C99658];
    v3[5] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
    CoreSchedulingSet::applyBlock((uint64_t)this, v3);
  }
}

void CoreSchedulingSet::unscheduleStream(CoreSchedulingSet *this, __CFReadStream *a2)
{
  int v2;
  void (*v3[6])(_QWORD, _QWORD, _QWORD);

  v2 = *((_DWORD *)this + 10);
  if (v2)
  {
    if (v2 == 3)
      JUMPOUT(0x186DB62D4);
    v3[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v3[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v3[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZNK17CoreSchedulingSet15_scheduleStreamEPvPFvS0_PU28objcproto17OS_dispatch_queue8NSObjectEPFvS0_P11__CFRunLoopPK10__CFStringE_block_invoke;
    v3[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_48_e38_v24__0____CFRunLoop__8____CFString__16l;
    v3[4] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C98BB8];
    v3[5] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
    CoreSchedulingSet::applyBlock((uint64_t)this, v3);
  }
}

void CoreSchedulingSet::unscheduleStream(CoreSchedulingSet *this, __CFWriteStream *a2)
{
  int v2;
  void (*v3[6])(_QWORD, _QWORD, _QWORD);

  v2 = *((_DWORD *)this + 10);
  if (v2)
  {
    if (v2 == 3)
      JUMPOUT(0x186DB62D4);
    v3[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v3[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v3[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZNK17CoreSchedulingSet15_scheduleStreamEPvPFvS0_PU28objcproto17OS_dispatch_queue8NSObjectEPFvS0_P11__CFRunLoopPK10__CFStringE_block_invoke;
    v3[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_48_e38_v24__0____CFRunLoop__8____CFString__16l;
    v3[4] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C99680];
    v3[5] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
    CoreSchedulingSet::applyBlock((uint64_t)this, v3);
  }
}

void RunLoopMultiplexer::~RunLoopMultiplexer(CFTypeRef *this)
{
  *this = &off_1E14E99E0;
  CFRelease(this[3]);
  *this = &off_1E14E5838;
}

{
  *this = &off_1E14E99E0;
  CFRelease(this[3]);
  *this = &off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

void sub_1840F7E60(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_1840F7EC0(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t coreSchedulingSetCopyDescription(const void *a1)
{
  return (*(uint64_t (**)(const void *))(*(_QWORD *)a1 + 16))(a1);
}

CFStringRef MultiplexerSource::_copyDesc(MultiplexerSource *this, const void *a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CFMultiplexerSource %p>"), this);
}

__n128 __Block_byref_object_copy__17001(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  return result;
}

BOOL URLCredentialOAuth2::equals(CFTypeRef *this, CFTypeRef *a2)
{
  uint64_t v4;

  if (*((_DWORD *)this + 8) == *((_DWORD *)a2 + 8)
    && (v4 = (*((uint64_t (**)(CFTypeRef *))*this + 1))(this),
        v4 == (*((uint64_t (**)(CFTypeRef *))*a2 + 1))(a2))
    && *((_DWORD *)this + 9) == *((_DWORD *)a2 + 9))
  {
    return CFEqual(this[8], a2[8]) != 0;
  }
  else
  {
    return 0;
  }
}

CFStringRef URLCredentialOAuth2::copyDebugDesc(URLCredentialOAuth2 *this)
{
  char *v2;
  const __CFAllocator *v3;

  v2 = (char *)this - 16;
  v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CFURLCredential %p>{OAuthToken = %@, persistence = %d}"), v2, *((_QWORD *)this + 8), *((unsigned int *)this + 9));
}

uint64_t URLCredentialOAuth2::copy(const __CFString **this)
{
  uint64_t Instance;

  CFGetAllocator(this - 2);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_DWORD *)(Instance + 48) = 6;
  *(_QWORD *)(Instance + 24) = &unk_1E14EB048;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EAFB0;
  *(_QWORD *)(Instance + 40) = &unk_1E14EB078;
  *(_QWORD *)(Instance + 80) = 0;
  *(_QWORD *)(Instance + 88) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  URLCredentialOAuth2::initialize((URLCredentialOAuth2 *)(Instance + 16), this[8], this[9]);
  return Instance;
}

BOOL URLCredentialOAuth2::initializeFromPropertyList(URLCredentialOAuth2 *this, CFDictionaryRef *a2)
{
  _BOOL8 result;
  const void *Value;

  result = URLCredential::initializeFromPropertyList((uint64_t)this, a2);
  if (result)
  {
    Value = CFDictionaryGetValue(*a2, CFSTR("oauthtoken"));
    if (Value)
      Value = CFRetain(Value);
    *((_QWORD *)this + 8) = Value;
    return 1;
  }
  return result;
}

uint64_t URLCredentialOAuth2::serializeToPropertyList(URLCredentialOAuth2 *this, SerializableArchive **a2)
{
  const void *v4;

  URLCredential::serializeToPropertyList(this, a2);
  v4 = (const void *)*((_QWORD *)this + 8);
  SerializableArchive::assertEmpty(*a2, CFSTR("oauthtoken"));
  if (v4)
    CFDictionarySetValue(*a2, CFSTR("oauthtoken"), v4);
  return 1;
}

CFHashCode URLCredentialOAuth2::calcHash(URLCredentialOAuth2 *this, uint64_t a2)
{
  uint64_t v2;
  const void *v3;

  v2 = a2;
  v3 = (const void *)*((_QWORD *)this + 8);
  if (v3)
    return CFHash(v3) ^ a2;
  return v2;
}

CFTypeRef URLCredentialOAuth2::copyStorageNameForCredentialType(URLCredentialOAuth2 *this)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 8);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t URLCredentialOAuth2::getUserName(URLCredentialOAuth2 *this)
{
  return 0;
}

uint64_t URLCredentialOAuth2::getOAuthToken(URLCredentialOAuth2 *this)
{
  CFTypeID TypeID;

  if (*((_QWORD *)this + 8) && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 8))))
    return *((_QWORD *)this + 8);
  else
    return 0;
}

CFTypeRef URLCredentialOAuth2::copyOAuthToken(URLCredentialOAuth2 *this)
{
  CFTypeID TypeID;
  const void *v3;

  if (*((_QWORD *)this + 8)
    && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 8)))
    && (v3 = (const void *)*((_QWORD *)this + 8)) != 0)
  {
    return CFRetain(v3);
  }
  else
  {
    return 0;
  }
}

void `non-virtual thunk to'URLCredentialOAuth2::~URLCredentialOAuth2(URLCredentialOAuth2 *this)
{
  URLCredentialOAuth2::~URLCredentialOAuth2((URLCredentialOAuth2 *)((char *)this - 8));
}

{
  URLCredentialOAuth2::~URLCredentialOAuth2((URLCredentialOAuth2 *)((char *)this - 8));
}

{
  URLCredentialOAuth2::~URLCredentialOAuth2((URLCredentialOAuth2 *)((char *)this - 24));
}

{
  URLCredentialOAuth2::~URLCredentialOAuth2((URLCredentialOAuth2 *)((char *)this - 24));
}

BOOL `non-virtual thunk to'URLCredentialOAuth2::initializeFromPropertyList(URLCredentialOAuth2 *this, CFDictionaryRef *a2)
{
  return URLCredentialOAuth2::initializeFromPropertyList((URLCredentialOAuth2 *)((char *)this - 8), a2);
}

uint64_t `non-virtual thunk to'URLCredentialOAuth2::serializeToPropertyList(URLCredentialOAuth2 *this, SerializableArchive **a2)
{
  URLCredentialOAuth2::serializeToPropertyList((URLCredentialOAuth2 *)((char *)this - 8), a2);
  return 1;
}

void URLCredentialOAuth2::~URLCredentialOAuth2(URLCredentialOAuth2 *this)
{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = &off_1E14EAFB0;
  *((_QWORD *)this + 1) = &unk_1E14EB048;
  *((_QWORD *)this + 3) = &unk_1E14EB078;
  v2 = (const void *)*((_QWORD *)this + 8);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 9);
  if (v3)
    CFRelease(v3);
  URLCredential::~URLCredential(this);
}

void sub_1840F82FC(_Unwind_Exception *a1)
{
  URLCredential *v1;

  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t URLCredentialOAuth2::initialize(URLCredentialOAuth2 *this, const __CFString *a2, const __CFString *a3)
{
  uint64_t result;
  CFTypeID TypeID;
  CFTypeID v8;
  const __CFAllocator *v9;
  const __CFAllocator *v10;

  result = 0;
  *((_DWORD *)this + 9) = 2;
  if (a2 && a3)
  {
    TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(a2) && (v8 = CFStringGetTypeID(), v8 == CFGetTypeID(a3)))
    {
      v9 = CFGetAllocator((char *)this - 16);
      *((_QWORD *)this + 8) = CFStringCreateCopy(v9, a2);
      v10 = CFGetAllocator((char *)this - 16);
      *((_QWORD *)this + 9) = CFStringCreateCopy(v10, a3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CFURLDownloadCopyRequest(char *cf)
{
  id *v2;

  if (URLDownload::Class(void)::sOnce_URLDownload != -1)
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
  if (cf)
    v2 = (id *)(cf + 16);
  else
    v2 = 0;
  CFGetAllocator(cf);
  return objc_msgSend(v2[3], "copy");
}

void _NSURLDownloadReleaseClient(_QWORD *a1)
{
  void *v2;

  v2 = (void *)MEMORY[0x186DB8C8C]();
  if (a1)
  {

    *(_QWORD *)(a1[1] + 32) = 0;
  }
  CFRelease(a1);
  objc_autoreleasePoolPop(v2);
}

void _NSURLDownloadDidStart(_CFURLDownload *a1, _QWORD *a2)
{
  void *v4;
  id v5;
  uint64_t v6;
  _QWORD v7[5];
  _QWORD v8[5];

  if (a2 && *(_BYTE *)(a2[1] + 40))
  {
    v4 = (void *)MEMORY[0x186DB8C8C]();
    v5 = *(id *)(a2[1] + 32);
    v6 = a2[1];
    if (!*(_QWORD *)(v6 + 8))
      *(_QWORD *)(v6 + 8) = a1;
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 3221225472;
      v8[2] = __30__NSURLDownload_sendDidStart___block_invoke;
      v8[3] = &unk_1E14FE118;
      v8[4] = a2;
      objc_msgSend(a2, "withDelegate:", v8);
    }
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = __30__NSURLDownload_sendDidStart___block_invoke_2;
      v7[3] = &unk_1E14FE118;
      v7[4] = a2;
      objc_msgSend(a2, "withDelegate:", v7);
    }

    objc_autoreleasePoolPop(v4);
  }
}

_QWORD *_NSURLDownloadWillSendRequest(_CFURLDownload *a1, const _CFURLRequest *a2, _CFURLResponse *a3, _QWORD *a4)
{
  _QWORD *v4;
  void *v7;
  id v8;
  _QWORD v10[8];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  v4 = a4;
  if (a4)
  {
    if (*(_BYTE *)(a4[1] + 40))
    {
      v7 = (void *)MEMORY[0x186DB8C8C](a1);
      v8 = *(id *)(v4[1] + 32);
      v11 = 0;
      v12 = &v11;
      v13 = 0x2020000000;
      v14 = 0;
      if ((objc_opt_respondsToSelector() & 1) != 0)
      {
        v10[0] = MEMORY[0x1E0C809B0];
        v10[1] = 3221225472;
        v10[2] = __54__NSURLDownload_sendWillSendRequest_redirectResponse___block_invoke;
        v10[3] = &unk_1E14FD928;
        v10[6] = a2;
        v10[7] = a3;
        v10[4] = v4;
        v10[5] = &v11;
        objc_msgSend(v4, "withDelegate:", v10);
      }
      v4 = (_QWORD *)v12[3];
      if (!v4)
      {
        v12[3] = (uint64_t)a2;
        CFRetain(a2);
        v4 = (_QWORD *)v12[3];
      }
      _Block_object_dispose(&v11, 8);

      objc_autoreleasePoolPop(v7);
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

void sub_1840F9448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _NSURLDownloadDidReceiveAuthenticationChallenge(_CFURLDownload *a1, _CFURLAuthChallenge *a2, _QWORD *a3)
{
  void *v5;
  id v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  URLDownload *v10;
  _QWORD v11[5];

  if (a3 && *(_BYTE *)(a3[1] + 40))
  {
    v5 = (void *)MEMORY[0x186DB8C8C](a1);
    v6 = *(id *)(a3[1] + 32);
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      CFRetain(a2);
      *(_QWORD *)(a3[1] + 16) = a2;
      CFMakeCollectable(a2);
      v7 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:](NSURLAuthenticationChallenge, "_authenticationChallengeForCFAuthChallenge:sender:", a2, a3);
      v8 = MEMORY[0x1E0C809B0];
      *(_QWORD *)(a3[1] + 24) = v7;
      v11[0] = v8;
      v11[1] = 3221225472;
      v11[2] = __41__NSURLDownload_sendDidReceiveChallenge___block_invoke;
      v11[3] = &unk_1E14FE118;
      v11[4] = a3;
      objc_msgSend(a3, "withDelegate:", v11);
    }
    else
    {
      v9 = *(_QWORD *)(a3[1] + 8);
      if (URLDownload::Class(void)::sOnce_URLDownload != -1)
        dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_4678);
      if (v9)
        v10 = (URLDownload *)(v9 + 16);
      else
        v10 = 0;
      URLDownload::useCredential(v10, 0, a2);
    }

    objc_autoreleasePoolPop(v5);
  }
}

void _NSURLDownloadDidReceiveResponse(_CFURLDownload *a1, _CFURLResponse *a2, _QWORD *a3)
{
  void *v5;
  id v6;
  id v7;
  _QWORD v8[6];

  if (a3 && *(_BYTE *)(a3[1] + 40))
  {
    v5 = (void *)MEMORY[0x186DB8C8C](a1);
    v6 = *(id *)(a3[1] + 32);
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v7 = +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:", a2);
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 3221225472;
      v8[2] = __40__NSURLDownload_sendDidReceiveResponse___block_invoke;
      v8[3] = &unk_1E14FDE88;
      v8[4] = a3;
      v8[5] = v7;
      objc_msgSend(a3, "withDelegate:", v8);
    }

    objc_autoreleasePoolPop(v5);
  }
}

void _NSURLDownloadWillResumeWithResponse(_CFURLDownload *a1, _CFURLResponse *a2, uint64_t a3, _QWORD *a4)
{
  void *v7;
  id v8;
  id v9;
  _QWORD v10[7];

  if (a4 && *(_BYTE *)(a4[1] + 40))
  {
    v7 = (void *)MEMORY[0x186DB8C8C](a1);
    v8 = *(id *)(a4[1] + 32);
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v9 = +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:", a2);
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 3221225472;
      v10[2] = __57__NSURLDownload_sendWillResumeWithResponse_startingByte___block_invoke;
      v10[3] = &unk_1E14FD950;
      v10[4] = a4;
      v10[5] = v9;
      v10[6] = a3;
      objc_msgSend(a4, "withDelegate:", v10);
    }

    objc_autoreleasePoolPop(v7);
  }
}

void _NSURLDownloadDidReceiveData(_CFURLDownload *a1, uint64_t a2, _QWORD *a3)
{
  void *v5;
  id v6;
  _QWORD v7[6];

  if (a3 && *(_BYTE *)(a3[1] + 40))
  {
    v5 = (void *)MEMORY[0x186DB8C8C](a1);
    v6 = *(id *)(a3[1] + 32);
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = __36__NSURLDownload_sendDidReceiveData___block_invoke;
      v7[3] = &unk_1E14FE140;
      v7[4] = a3;
      v7[5] = a2;
      objc_msgSend(a3, "withDelegate:", v7);
    }

    objc_autoreleasePoolPop(v5);
  }
}

_QWORD *_NSURLDownloadShouldDecodeDataOfMIMEType(_CFURLDownload *a1, const __CFString *a2, _QWORD *a3)
{
  _QWORD *v3;
  void *v5;
  id v6;
  _QWORD v8[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v3 = a3;
  if (a3)
  {
    if (*(_BYTE *)(a3[1] + 40))
    {
      v5 = (void *)MEMORY[0x186DB8C8C](a1);
      v6 = *(id *)(v3[1] + 32);
      v9 = 0;
      v10 = &v9;
      v11 = 0x2020000000;
      v12 = 1;
      if ((objc_opt_respondsToSelector() & 1) != 0)
      {
        v8[0] = MEMORY[0x1E0C809B0];
        v8[1] = 3221225472;
        v8[2] = __48__NSURLDownload_sendShouldDecodeDataOfMIMEType___block_invoke;
        v8[3] = &unk_1E14FD978;
        v8[4] = v3;
        v8[5] = &v9;
        v8[6] = a2;
        objc_msgSend(v3, "withDelegate:", v8);
      }
      v3 = (_QWORD *)*((unsigned __int8 *)v10 + 24);
      _Block_object_dispose(&v9, 8);

      objc_autoreleasePoolPop(v5);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

void sub_1840F9934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _NSURLDownloadDecideDestinationWithSuggestedObjectName(_CFURLDownload *a1, const __CFString *a2, _QWORD *a3)
{
  void *v5;
  id v6;
  _QWORD v7[6];

  if (a3 && *(_BYTE *)(a3[1] + 40))
  {
    v5 = (void *)MEMORY[0x186DB8C8C](a1);
    v6 = *(id *)(a3[1] + 32);
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = __62__NSURLDownload_sendDecideDestinationWithSuggestedObjectName___block_invoke;
      v7[3] = &unk_1E14FE140;
      v7[4] = a3;
      v7[5] = a2;
      objc_msgSend(a3, "withDelegate:", v7);
    }

    objc_autoreleasePoolPop(v5);
  }
}

void _NSURLDownloadDidCreateDestination(_CFURLDownload *a1, const __CFURL *a2, _QWORD *a3)
{
  void *v5;
  id v6;
  CFStringRef v7;
  _QWORD v8[6];

  if (a3 && *(_BYTE *)(a3[1] + 40))
  {
    v5 = (void *)MEMORY[0x186DB8C8C](a1);
    v6 = *(id *)(a3[1] + 32);
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v7 = CFURLCopyFileSystemPath(a2, kCFURLPOSIXPathStyle);
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 3221225472;
      v8[2] = __42__NSURLDownload_sendDidCreateDestination___block_invoke;
      v8[3] = &unk_1E14FE140;
      v8[4] = a3;
      v8[5] = v7;
      objc_msgSend(a3, "withDelegate:", v8);
      CFRelease(v7);
    }

    objc_autoreleasePoolPop(v5);
  }
}

void _NSURLDownloadDidFinish(_CFURLDownload *a1, _QWORD *a2)
{
  void *v3;
  id v4;
  _QWORD v5[5];

  if (a2 && *(_BYTE *)(a2[1] + 40))
  {
    v3 = (void *)MEMORY[0x186DB8C8C](a1);
    v4 = *(id *)(a2[1] + 32);
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v5[0] = MEMORY[0x1E0C809B0];
      v5[1] = 3221225472;
      v5[2] = __30__NSURLDownload_sendDidFinish__block_invoke;
      v5[3] = &unk_1E14FE118;
      v5[4] = a2;
      objc_msgSend(a2, "withDelegate:", v5);
    }

    objc_autoreleasePoolPop(v3);
  }
}

void _NSURLDownloadDidFail(_CFURLDownload *a1, __CFError *a2, _QWORD *a3)
{
  void *v5;
  id v6;
  __CFError *v7;
  _QWORD v8[6];

  if (a3 && *(_BYTE *)(a3[1] + 40))
  {
    v5 = (void *)MEMORY[0x186DB8C8C](a1);
    v6 = *(id *)(a3[1] + 32);
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v7 = cfnTranslateCFError(a2, (void *)objc_msgSend(a3, "url"));
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 3221225472;
      v8[2] = __29__NSURLDownload_sendDidFail___block_invoke;
      v8[3] = &unk_1E14FDE88;
      v8[4] = a3;
      v8[5] = v7;
      objc_msgSend(a3, "withDelegate:", v8);
    }

    objc_autoreleasePoolPop(v5);
  }
}

void IOLogger::~IOLogger(IOLogger *this)
{
  *(_QWORD *)this = &off_1E14EFD68;
  *((_QWORD *)this + 34) = 0;
}

{
  *(_QWORD *)this = &off_1E14EFD68;
  *((_QWORD *)this + 34) = 0;
  JUMPOUT(0x186DB748CLL);
}

void DiagnoticIOLoggerDestination::~DiagnoticIOLoggerDestination(DiagnoticIOLoggerDestination *this)
{
  JUMPOUT(0x186DB748CLL);
}

int *DiagnoticIOLoggerDestination::logData(DiagnoticIOLoggerDestination *this, const LineInfo *a2, const char *a3, const char *a4, const unsigned __int8 *a5, uint64_t a6)
{
  int *result;
  int *v11;

  result = (int *)DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_23_17234, 2);
  if (result)
  {
    v11 = result;
    result = (int *)(*(uint64_t (**)(int *, const char *, _QWORD))(*(_QWORD *)result + 16))(result, a3, 0);
    if ((_DWORD)result)
    {
      if (v11[2] >= 3)
        (*(void (**)(int *, const char *, const unsigned __int8 *, uint64_t))(*(_QWORD *)v11 + 112))(v11, a4, a5, a6);
      return (int *)(*(uint64_t (**)(int *))(*(_QWORD *)v11 + 8))(v11);
    }
  }
  return result;
}

uint64_t DiagnoticIOLoggerDestination::logStructured(DiagnoticIOLoggerDestination *this, const LineInfo *a2, const __CFArray *a3)
{
  uint64_t result;
  uint64_t v6;
  const char *buffer;

  result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_24_17228, 3);
  if (result)
  {
    v6 = result;
    buffer = "Structured";
    if (a2 && a2[1].buffer)
      buffer = a2[1].buffer;
    result = (*(uint64_t (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)result + 16))(result, buffer, 0);
    if ((_DWORD)result)
    {
      (*(void (**)(uint64_t, const char *, const __CFArray *))(*(_QWORD *)v6 + 80))(v6, "logStruct", a3);
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return result;
}

uint64_t ___ZN28DiagnoticIOLoggerDestination13logStructuredEPKN12LogFormatter8LineInfoEPK9__CFArray_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 31;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN28DiagnoticIOLoggerDestination7logDataEPKN12LogFormatter8LineInfoEPKcS5_PKhl_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 24;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN8IOLogger11_initLoggerEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 85;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void CoreIOLoggerDestination::~CoreIOLoggerDestination(CoreIOLoggerDestination *this)
{
  JUMPOUT(0x186DB748CLL);
}

uint64_t IOLogger::logBytes(IOLogger *this, const char *a2, unsigned __int8 a3, const unsigned __int8 *a4, uint64_t a5)
{
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  BOOL v12;
  char v13[256];
  char __str[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x80uLL, "%s (%d) | %c", a2, *((_DWORD *)this + 2), a3);
  v8 = 1;
  v9 = a5;
  do
  {
    if (v9 >= 144)
      v10 = 144;
    else
      v10 = v9;
    if ((v8 & 1) != 0)
      snprintf(v13, 0x100uLL, "%s %s %ld");
    else
      snprintf(v13, 0x100uLL, "%s %s continuation");
    result = (*(uint64_t (**)(_QWORD, char *, char *, char *, const unsigned __int8 *, uint64_t))(**((_QWORD **)this + 34) + 16))(*((_QWORD *)this + 34), (char *)this + 280, v13, __str, a4, v10);
    v8 = 0;
    a4 += v10;
    v12 = v9 <= v10;
    v9 -= v10;
  }
  while (!v12);
  return result;
}

void IOLogger::logBytesSent(IOLogger *this, int a2, const unsigned __int8 *a3, uint64_t a4)
{
  const char *v7;

  if (!a2)
  {
    v7 = "RAW-SEND";
    goto LABEL_7;
  }
  if (__CFNIsInDevelopmentEnvironment::onceToken != -1)
    dispatch_once(&__CFNIsInDevelopmentEnvironment::onceToken, &__block_literal_global_21_4777);
  if (__CFNIsInDevelopmentEnvironment::ok)
  {
    v7 = "SSL-SEND";
LABEL_7:
    IOLogger::logBytes(this, v7, 0x3Eu, a3, a4);
  }
}

void IOLogger::logBytesRead(IOLogger *this, int a2, const unsigned __int8 *a3, uint64_t a4)
{
  const char *v7;

  if (!a2)
  {
    v7 = "RAW-READ";
    goto LABEL_7;
  }
  if (__CFNIsInDevelopmentEnvironment::onceToken != -1)
    dispatch_once(&__CFNIsInDevelopmentEnvironment::onceToken, &__block_literal_global_21_4777);
  if (__CFNIsInDevelopmentEnvironment::ok)
  {
    v7 = "SSL-READ";
LABEL_7:
    IOLogger::logBytes(this, v7, 0x3Cu, a3, a4);
  }
}

const char *IOLogger::addrToName(uint64_t a1, char *__str)
{
  int v4;
  const void *v5;
  int v6;
  const char *result;
  size_t v8;

  v4 = *(unsigned __int8 *)(a1 + 1);
  if (v4 == 30)
  {
    v5 = (const void *)(a1 + 8);
  }
  else
  {
    if (v4 != 2)
      return (const char *)snprintf(__str, 0x400uLL, "[error %d converting]");
    v5 = (const void *)(a1 + 4);
  }
  v6 = *(unsigned __int16 *)(a1 + 2);
  result = inet_ntop(v4, v5, __str, 0x400u);
  if (!result)
  {
    __error();
    return (const char *)snprintf(__str, 0x400uLL, "[error %d converting]");
  }
  if (v6)
  {
    v8 = strlen(__str);
    return (const char *)snprintf(&__str[v8], 1024 - v8, ":%d");
  }
  return result;
}

void STube::~STube(STube *this)
{
  uint64_t v2;

  STube::~STube(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  ProxyConnectionEstablishment *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  _QWORD v11[5];
  char v12;

  *(_QWORD *)this = off_1E14EFA28;
  *((_QWORD *)this + 3) = &unk_1E14EFAE0;
  *((_QWORD *)this + 4) = &unk_1E14EFB00;
  v2 = (STube *)((char *)this + 32);
  *((_QWORD *)this + 5) = &unk_1E14EFBA8;
  v3 = (const void *)*((_QWORD *)this + 28);
  if (v3)
  {
    _Block_release(v3);
    *((_QWORD *)this + 28) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 27);
  if (v4)
  {
    _Block_release(v4);
    *((_QWORD *)this + 27) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 24);
  *((_QWORD *)this + 24) = 0;
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v6)
    CFRelease(v6);
  v7 = *((_BYTE *)this + 176);
  v8 = *((_QWORD *)this + 14);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = ___ZN5STube14cleanupStreamsEb_block_invoke;
  v11[3] = &__block_descriptor_41_e5_v8__0l;
  v11[4] = this;
  v12 = v7;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v8 + 104))(v8, v11);
  v9 = *((_QWORD *)this + 15);
  if (v9)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
    *((_QWORD *)this + 15) = 0;
  }
  (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 48))(*((_QWORD *)this + 13));
  *((_QWORD *)this + 13) = 0;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 12) + 48))(*((_QWORD *)this + 12));
  *((_QWORD *)this + 12) = 0;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 14) + 48))(*((_QWORD *)this + 14));
  *((_QWORD *)this + 14) = 0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 200);
  v10 = (const void *)*((_QWORD *)this + 21);
  *((_QWORD *)this + 21) = 0;
  if (v10)
    CFRelease(v10);
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(v2);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

BOOL STube::setConnectionProperty(STube *this, const __CFString *a2, const void *a3)
{
  uint64_t v3;

  v3 = *((_QWORD *)this + 16);
  if (v3)
    (*(void (**)(_QWORD, const __CFString *, const void *))(*(_QWORD *)v3 + 200))(*((_QWORD *)this + 16), a2, a3);
  return v3 != 0;
}

uint64_t GlueTube::copyConnectionProperty(GlueTube *this, const __CFString *a2)
{
  return 0;
}

uint64_t STube::clientCanceled(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[6];

  v2 = *(_QWORD *)(a1 + 112);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN5STube14clientCanceledEP25MetaConnectionCacheClient_block_invoke;
  v4[3] = &__block_descriptor_48_e5_v8__0l;
  v4[4] = a1;
  v4[5] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 104))(v2, v4);
}

uint64_t GlueTube::isCoalesced(GlueTube *this)
{
  return 0;
}

uint64_t STube::ceRetain(STube *this)
{
  return (*(uint64_t (**)(STube *))(*(_QWORD *)this + 40))(this);
}

uint64_t STube::ceRelease(STube *this)
{
  return (*(uint64_t (**)(STube *))(*(_QWORD *)this + 48))(this);
}

uint64_t STube::ssPreConnectConfiguration(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[7];

  tcp_connection_retain();
  (*(void (**)(_QWORD *))(*a1 + 40))(a1);
  v6 = a1[14];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN5STube25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke;
  v8[3] = &unk_1E14FDBE0;
  v8[5] = a3;
  v8[6] = a1;
  v8[4] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v8);
}

uint64_t STube::ssNeedServerTrust(_QWORD *a1, CFTypeRef cf, void *aBlock)
{
  uint64_t v5;
  _QWORD v7[5];

  if (a1[24])
    __assert_rtn("ssNeedServerTrust", "STube.cpp", 1358, "!fSSLTrust");
  a1[24] = cf;
  if (cf)
    CFRetain(cf);
  a1[28] = _Block_copy(aBlock);
  (*(void (**)(_QWORD *))(*a1 + 40))(a1);
  v5 = a1[14];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN5STube17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke;
  v7[3] = &__block_descriptor_40_e5_v8__0l;
  v7[4] = a1;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v5 + 96))(v5, v7);
}

uint64_t STube::ssNeedClientCert(_QWORD *a1, CFTypeRef cf, void *aBlock)
{
  uint64_t v5;
  _QWORD v7[5];

  if (a1[23])
    __assert_rtn("ssNeedClientCert", "STube.cpp", 1245, "!fSSLDistNames");
  a1[23] = cf;
  if (cf)
    CFRetain(cf);
  a1[27] = _Block_copy(aBlock);
  (*(void (**)(_QWORD *))(*a1 + 40))(a1);
  v5 = a1[14];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN5STube16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke;
  v7[3] = &__block_descriptor_40_e5_v8__0l;
  v7[4] = a1;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v5 + 96))(v5, v7);
}

uint64_t STube::ssPostConnectConfiguration(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[7];

  tcp_connection_retain();
  (*(void (**)(_QWORD *))(*a1 + 40))(a1);
  v6 = a1[14];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN5STube26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
  v8[3] = &unk_1E14FDBE0;
  v8[5] = a3;
  v8[6] = a1;
  v8[4] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v8);
}

uint64_t STube::ssPostHandshakesStreamsAvailable(STube *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  uint64_t v6;
  _QWORD v8[7];

  (*(void (**)(STube *))(*(_QWORD *)this + 40))(this);
  if (a2)
    CFRetain(a2);
  if (a3)
    CFRetain(a3);
  v6 = *((_QWORD *)this + 14);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN5STube32ssPostHandshakesStreamsAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke;
  v8[3] = &__block_descriptor_56_e5_v8__0l;
  v8[4] = this;
  v8[5] = a2;
  v8[6] = a3;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v8);
}

uint64_t STube::ssConnectionWaitingNotification(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[6];

  v2 = *(_QWORD *)(a1 + 112);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN5STube31ssConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke;
  v4[3] = &__block_descriptor_48_e5_v8__0l;
  v4[4] = a1;
  v4[5] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 96))(v2, v4);
}

void `non-virtual thunk to'STube::~STube(STube *this)
{
  STube::~STube((STube *)((char *)this - 24));
}

{
  STube::~STube((STube *)((char *)this - 32));
}

{
  STube::~STube((STube *)((char *)this - 40));
}

void `non-virtual thunk to'STube::~STube(CFAllocatorRef *this)
{
  CFAllocatorRef *v2;

  v2 = this - 3;
  STube::~STube((STube *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 4;
  STube::~STube((STube *)(this - 4));
  CFAllocatorDeallocate(*(this - 3), v2);
}

{
  CFAllocatorRef *v2;

  v2 = this - 5;
  STube::~STube((STube *)(this - 5));
  CFAllocatorDeallocate(*(this - 4), v2);
}

uint64_t `non-virtual thunk to'STube::ceRetain(STube *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 4) + 40))((char *)this - 32);
}

uint64_t `non-virtual thunk to'STube::ceRelease(STube *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 4) + 48))((char *)this - 32);
}

uint64_t `non-virtual thunk to'STube::ssPreConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return STube::ssPreConnectConfiguration((_QWORD *)(a1 - 32), a2, a3);
}

uint64_t `non-virtual thunk to'STube::ssNeedServerTrust(uint64_t a1, const void *a2, void *a3)
{
  return STube::ssNeedServerTrust((_QWORD *)(a1 - 32), a2, a3);
}

uint64_t `non-virtual thunk to'STube::ssNeedClientCert(uint64_t a1, const void *a2, void *a3)
{
  return STube::ssNeedClientCert((_QWORD *)(a1 - 32), a2, a3);
}

uint64_t `non-virtual thunk to'STube::ssPostConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return STube::ssPostConnectConfiguration((_QWORD *)(a1 - 32), a2, a3);
}

uint64_t `non-virtual thunk to'STube::ssPostHandshakesStreamsAvailable(STube *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return STube::ssPostHandshakesStreamsAvailable((STube *)((char *)this - 32), a2, a3);
}

uint64_t `non-virtual thunk to'STube::ssConnectionWaitingNotification(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[6];

  v2 = a1 - 32;
  v3 = *(_QWORD *)(a1 + 80);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN5STube31ssConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke;
  v5[3] = &__block_descriptor_48_e5_v8__0l;
  v5[4] = v2;
  v5[5] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 96))(v3, v5);
}

void sub_1840FB614(_Unwind_Exception *a1)
{
  uint64_t v1;
  ProxyConnectionEstablishment *v2;
  const void *v4;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 200);
  v4 = *(const void **)(v1 + 168);
  *(_QWORD *)(v1 + 168) = 0;
  if (v4)
    CFRelease(v4);
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(v2);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ___ZN5STube14cleanupStreamsEb_block_invoke(uint64_t a1)
{
  STube::_onqueue_cleanupStreams(*(STube **)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void STube::_onqueue_cleanupStreams(STube *this, int a2)
{
  __CFReadStream *v4;
  CFWriteStreamRef v5;
  CFWriteStreamRef *v6;
  uint64_t v7;
  uint64_t *v8;

  v4 = (__CFReadStream *)*((_QWORD *)this + 29);
  if (v4)
  {
    if ((a2 & 1) != 0)
    {
      if (CFReadStreamGetStatus(v4) <= kCFStreamStatusOpening)
        CFReadStreamOpen(*((CFReadStreamRef *)this + 29));
      CFReadStreamClose(*((CFReadStreamRef *)this + 29));
      v4 = (__CFReadStream *)*((_QWORD *)this + 29);
      *((_QWORD *)this + 29) = 0;
      if (!v4)
      {
        v6 = (CFWriteStreamRef *)((char *)this + 240);
        v5 = (CFWriteStreamRef)*((_QWORD *)this + 30);
        if (!v5)
          goto LABEL_15;
        goto LABEL_12;
      }
    }
    else
    {
      *((_QWORD *)this + 29) = 0;
    }
    CFRelease(v4);
  }
  v6 = (CFWriteStreamRef *)((char *)this + 240);
  v5 = (CFWriteStreamRef)*((_QWORD *)this + 30);
  if (!v5)
    goto LABEL_19;
  if ((a2 & 1) == 0)
  {
    *v6 = 0;
LABEL_18:
    CFRelease(v5);
LABEL_19:
    v8 = (uint64_t *)((char *)this + 128);
    v7 = *((_QWORD *)this + 16);
    if (!v7)
      return;
    if (!a2)
      goto LABEL_24;
    goto LABEL_21;
  }
LABEL_12:
  if (CFWriteStreamGetStatus(v5) <= kCFStreamStatusOpening)
    CFWriteStreamOpen(*v6);
  CFWriteStreamClose(*v6);
  v5 = *v6;
  *v6 = 0;
  if (v5)
    goto LABEL_18;
LABEL_15:
  v8 = (uint64_t *)((char *)this + 128);
  v7 = *((_QWORD *)this + 16);
  if (v7)
  {
LABEL_21:
    if (!*((_BYTE *)this + 177))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 232))(v7);
      v7 = *v8;
    }
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 176))(v7, 0);
    v7 = *v8;
LABEL_24:
    CFRelease((CFTypeRef)(v7 - 16));
    *v8 = 0;
  }
}

uint64_t ___ZN5STube31ssConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 32);
  result = *(_QWORD *)(v2 + 120);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 96))(result);
    if ((_DWORD)result)
    {
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 120) + 64))(*(_QWORD *)(v2 + 120));
      if (result)
        return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(result - 176) + 408))(result - 176, *(_QWORD *)(a1 + 40));
    }
  }
  return result;
}

uint64_t ___ZN5STube32ssPostHandshakesStreamsAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke(_QWORD *a1)
{
  uint64_t v1;
  __CFWriteStream *v2;
  CFStreamError Error;
  uint64_t v4;
  CFIndex domain;
  const void *v6;
  const void *v7;
  const __CFBoolean *v8;
  const __CFBoolean *v9;
  _DWORD *v10;
  uint64_t v11;
  const __CFString *v13;
  const __CFString *v14;
  BOOL v15;
  _QWORD v16[5];
  CFDictionaryRef v17;
  CFStreamError v18;

  v1 = a1[4];
  *(_QWORD *)(v1 + 232) = a1[5];
  v2 = (__CFWriteStream *)a1[6];
  *(_QWORD *)(v1 + 240) = v2;
  *(_BYTE *)(v1 + 177) = 1;
  if (v2 && (Error = CFWriteStreamGetError(v2), v4 = *(_QWORD *)&Error.error, Error.error))
  {
    domain = Error.domain;
    if (Error.domain == *MEMORY[0x1E0C9B298] && *(_QWORD *)(v1 + 232))
    {
      v6 = *(const void **)(v1 + 168);
      *(_QWORD *)(v1 + 168) = 0;
      if (v6)
        CFRelease(v6);
      v16[0] = MEMORY[0x1E0C809B0];
      v16[1] = 3221225472;
      v16[2] = ___ZN5STube27_onqueue_saveSSLCertContextEv_block_invoke;
      v16[3] = &__block_descriptor_40_e22__v16__0____CFString__8l;
      v16[4] = v1;
      createSSLCertificateContext(&v17, (uint64_t)v16);
      v7 = *(const void **)(v1 + 168);
      *(_QWORD *)(v1 + 168) = v17;
      if (v7)
        CFRelease(v7);
      if ((Error.error + 9850) <= 0x2B && ((1 << (LOBYTE(Error.error) + 122)) & 0xC7803E80081) != 0)
      {
        v8 = (const __CFBoolean *)CFReadStreamCopyProperty(*(CFReadStreamRef *)(v1 + 232), CFSTR("kCFStreamPropertyConnectionIsCellular"));
        if (v8)
        {
          v9 = v8;
          if (!CFBooleanGetValue(v8))
            __CFNReportSSLSymptom(Error.domain, Error.error);
          CFRelease(v9);
        }
        else
        {
          __CFNReportSSLSymptom(Error.domain, Error.error);
        }
      }
    }
    v10 = (_DWORD *)(v1 + 160);
    if (*(_DWORD *)(v1 + 160) != 9)
      goto LABEL_25;
  }
  else
  {
    v10 = (_DWORD *)(v1 + 160);
    if (*(_DWORD *)(v1 + 160) == 9)
    {
      v4 = 89;
      domain = 1;
    }
    else
    {
      v11 = *(_QWORD *)(v1 + 128);
      if (!v11 || !*(_QWORD *)(v1 + 232) || !*(_QWORD *)(v1 + 240))
      {
        v4 = 57;
        domain = 1;
LABEL_25:
        *v10 = 10;
        goto LABEL_26;
      }
      *(_DWORD *)(v1 + 160) = 8;
      if (*(_DWORD *)(v1 + 136))
      {
        domain = 0;
        v4 = 0;
      }
      else
      {
        v13 = (const __CFString *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 224))(v11, 0x1EDCFA720);
        if (v13)
        {
          v14 = v13;
          if (CFStringGetLength(v13))
          {
            if (CFStringCompare(v14, CFSTR("http/1.1"), 1uLL) && CFStringCompare(v14, CFSTR("http/1.0"), 1uLL))
            {
              domain = 0;
              v4 = 0;
            }
            else
            {
              domain = 0;
              v4 = 0;
              *(_DWORD *)(v1 + 136) = 1;
            }
          }
          else
          {
            v4 = 100;
            domain = 1;
          }
          CFRelease(v14);
        }
        else
        {
          domain = 1;
          if (*(_QWORD *)(*(_QWORD *)(v1 + 96) + 72))
            v15 = (*(_QWORD *)(*(_QWORD *)(v1 + 96) + 72) & 1) == 0;
          else
            v15 = 0;
          if (v15)
          {
            v4 = 100;
          }
          else
          {
            v4 = 0;
            *(_DWORD *)(v1 + 136) = 1;
            domain = 0;
          }
        }
      }
    }
  }
LABEL_26:
  v18.domain = domain;
  *(_QWORD *)&v18.error = v4;
  STube::_onqueue_notifyTubeManager((STube *)v1, v18);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void STube::_onqueue_notifyTubeManager(STube *this, CFStreamError a2)
{
  CoreSchedulingSet *v3;
  SInt32 error;
  uint64_t v5;
  CFAllocatorRef *v6;
  CFErrorRef CFErrorWithStreamError;
  const __CFString *v8;
  int v9;
  const __CFString *v10;
  const void *v11;
  uint64_t v12;
  const void *v13;
  const __CFString *v14;
  CFStringRef v15;
  CFStreamError valuePtr;

  valuePtr = a2;
  v3 = (CoreSchedulingSet *)*((_QWORD *)this + 14);
  if (!v3)
    __assert_rtn("_onqueue_notifyTubeManager", "STube.cpp", 1069, "fSchedulingSet");
  error = a2.error;
  if (!CoreSchedulingSet::currentlyInContext(v3))
    __assert_rtn("_onqueue_notifyTubeManager", "STube.cpp", 1070, "fSchedulingSet->currentlyInContext()");
  if (!*((_BYTE *)this + 164))
  {
    *((_BYTE *)this + 164) = 1;
    if (nw_settings_get_signposts_enabled())
      kdebug_trace();
    v5 = *((_QWORD *)this + 16);
    if (v5)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 176))(v5, 0);
    v6 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    if (error)
      CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (int *)&valuePtr);
    else
      CFErrorWithStreamError = 0;
    if (GlueTube::notifyOfTubeType)
    {
      v8 = CFSTR("Unknown");
      v9 = *((_DWORD *)this + 34);
      if (v9 == 1)
        v8 = CFSTR("kSTubeTypeHTTP");
      if (v9)
        v10 = v8;
      else
        v10 = CFSTR("kSTubeTypeNPN");
      v11 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 16))(*((_QWORD *)this + 12));
      v12 = *((_QWORD *)this + 16);
      if (v12)
        v13 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v12 + 224))(v12, 0x1EDCFA720);
      else
        v13 = 0;
      v14 = CFSTR("YES");
      if (!v13)
        v14 = CFSTR("NO");
      v15 = CFStringCreateWithFormat(*v6, 0, CFSTR("%@, ALPN supported %@, Tube type: %@"), v11, v14, v10);
      (*(void (**)(uint64_t, CFStringRef, CFErrorRef))(GlueTube::notifyOfTubeType + 16))(GlueTube::notifyOfTubeType, v15, CFErrorWithStreamError);
      if (v15)
        CFRelease(v15);
      if (v13)
        CFRelease(v13);
      if (v11)
        CFRelease(v11);
    }
    (*(void (**)(_QWORD, STube *, CFIndex, _QWORD))(**((_QWORD **)this + 13) + 56))(*((_QWORD *)this + 13), this, valuePtr.domain, *(_QWORD *)&valuePtr.error);
    if (CFErrorWithStreamError)
      CFRelease(CFErrorWithStreamError);
  }
}

void sub_1840FBC88(_Unwind_Exception *exception_object)
{
  const void *v1;
  const void *v2;

  if (v2)
  {
    CFRelease(v2);
    if (!v1)
LABEL_4:
      _Unwind_Resume(exception_object);
  }
  else if (!v1)
  {
    goto LABEL_4;
  }
  CFRelease(v1);
  goto LABEL_4;
}

void sub_1840FBCEC()
{
  uint64_t v0;

  if (!v0)
    JUMPOUT(0x1840FBCB0);
  JUMPOUT(0x1840FBCA8);
}

CFTypeRef ___ZN5STube27_onqueue_saveSSLCertContextEv_block_invoke(uint64_t a1, const __CFString *a2)
{
  return CFReadStreamCopyProperty(*(CFReadStreamRef *)(*(_QWORD *)(a1 + 32) + 232), a2);
}

uint64_t ___ZN5STube26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  __CFHTTPMessage *v4;
  __CFHTTPMessage *v5;
  _BOOL8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[6];

  v2 = a1[5];
  v1 = a1[6];
  if (*(_DWORD *)(v1 + 160) == 9)
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD, uint64_t))(v2 + 16))(a1[5], 0, 0, 1);
  }
  else
  {
    v3 = a1[4];
    *(_DWORD *)(v1 + 160) = 5;
    v4 = (__CFHTTPMessage *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 128) + 224))(*(_QWORD *)(v1 + 128), 0x1EDD00488);
    if (v4)
    {
      v5 = v4;
      v6 = CFHTTPMessageGetResponseStatusCode(v4) != 200;
      (*(void (**)(uint64_t, _QWORD, _QWORD, _BOOL8))(v2 + 16))(v2, 0, 0, v6);
      CFRelease(v5);
    }
    else
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
      v7 = *(_QWORD *)(v1 + 8);
      v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 120) + 72))(*(_QWORD *)(v1 + 120));
      v12[5] = v1;
      v9 = *(_QWORD *)(v1 + 32);
      v10 = *(_QWORD *)(v1 + 96);
      v12[0] = MEMORY[0x1E0C809B0];
      v12[1] = 3221225472;
      v12[2] = ___ZN5STube33_onqueue_postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
      v12[3] = &unk_1E14FDC08;
      v12[4] = v2;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(v9 + 144))(v1 + 32, v7, v3, v8 - 16, v10, v12);
    }
  }
  tcp_connection_release();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void ___ZN5STube33_onqueue_postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke(uint64_t a1, _QWORD *a2, CFTypeRef cf)
{
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[7];
  std::__shared_weak_count *v15;
  CFTypeRef v16;

  v6 = *(_QWORD *)(a1 + 40);
  if (cf)
    CFRetain(cf);
  v7 = *(_QWORD *)(v6 + 112);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3321888768;
  v14[2] = ___ZN5STube33_onqueue_postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke_2;
  v14[3] = &unk_1E14F4298;
  v14[4] = *(_QWORD *)(a1 + 32);
  v14[5] = v6;
  v8 = (std::__shared_weak_count *)a2[1];
  v14[6] = *a2;
  v15 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v16 = cf;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v7 + 96))(v7, v14);
  v11 = v15;
  if (v15)
  {
    v12 = (unint64_t *)&v15->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_1840FBF40(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube33_onqueue_postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke_2(_QWORD *a1)
{
  uint64_t v2;
  void (*v3)(void);
  uint64_t v4;
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  CFStringRef v7;
  CFStringRef v8;
  const void *v9;

  v2 = a1[5];
  if (*(int *)(v2 + 160) < 9)
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v2 + 200), a1[6], a1[7]);
    v4 = *(_QWORD *)(v2 + 200);
    if (v4)
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 56))(v4) == 3)
      {
        Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(v2 + 8), 0, MEMORY[0x1E0C9B378]);
        if (Mutable)
        {
          v6 = Mutable;
          v7 = CFStringCreateWithCString(*(CFAllocatorRef *)(v2 + 8), "http/1.1", 0x8000100u);
          CFArrayAppendValue(v6, v7);
          CFRelease(v7);
          v8 = CFStringCreateWithCString(*(CFAllocatorRef *)(v2 + 8), "http/1.0", 0x8000100u);
          CFArrayAppendValue(v6, v8);
          CFRelease(v8);
          (*(void (**)(_QWORD, uint64_t, __CFArray *))(**(_QWORD **)(v2 + 128) + 200))(*(_QWORD *)(v2 + 128), 0x1EDCFA6E8, v6);
          CFRelease(v6);
        }
      }
    }
    v3 = *(void (**)(void))(a1[4] + 16);
  }
  else
  {
    v3 = *(void (**)(void))(a1[4] + 16);
  }
  v3();
  v9 = (const void *)a1[8];
  if (v9)
    CFRelease(v9);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

uint64_t __copy_helper_block_e8_48c40_ZTSNSt3__110shared_ptrI12NetworkProxyEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_48c40_ZTSNSt3__110shared_ptrI12NetworkProxyEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t ___ZN5STube16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t);
  void *v11;
  uint64_t v12;
  uint64_t v13;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(int *)(v1 + 160) < 9)
  {
    *(_DWORD *)(v1 + 160) = 7;
    v2 = *(_QWORD *)(v1 + 120);
    if (v2 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2))
    {
      v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 120) + 64))(*(_QWORD *)(v1 + 120));
      if (v3)
        v4 = v3 - 176;
      else
        v4 = 0;
      if (v3)
        v5 = v4 + 112;
      else
        v5 = 0;
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
      v6 = *(_QWORD *)(v4 + 24);
      v8 = MEMORY[0x1E0C809B0];
      v9 = 3221225472;
      v10 = ___ZN5STube23_onqueue_needClientCertEv_block_invoke;
      v11 = &__block_descriptor_48_e5_v8__0l;
      v12 = v1;
      v13 = v5;
    }
    else
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
      v6 = *(_QWORD *)(v1 + 112);
      v8 = MEMORY[0x1E0C809B0];
      v9 = 3221225472;
      v10 = ___ZN5STube23_onqueue_needClientCertEv_block_invoke_3;
      v11 = &__block_descriptor_40_e5_v8__0l;
      v12 = v1;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v6 + 96))(v6, &v8);
  }
  else
  {
    STube::_onqueue_complete_needClientCert(*(STube **)(a1 + 32), 0);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void STube::_onqueue_complete_needClientCert(STube *this, const __CFArray *a2)
{
  uint64_t v3;
  const void *v4;
  const void *v5;

  v3 = *((_QWORD *)this + 27);
  if (v3)
    (*(void (**)(uint64_t, const __CFArray *))(v3 + 16))(v3, a2);
  v4 = (const void *)*((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 27);
  if (v5)
  {
    _Block_release(v5);
    *((_QWORD *)this + 27) = 0;
  }
}

uint64_t ___ZN5STube23_onqueue_needClientCertEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[5];

  v3 = *(_QWORD **)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  v4 = v3[23];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN5STube23_onqueue_needClientCertEv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e20_v16__0____CFArray__8l;
  v6[4] = v3;
  (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v2 + 48))(v2, v4, v6);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 24))(*(_QWORD *)(a1 + 40));
  return (*(uint64_t (**)(_QWORD *))(*v3 + 48))(v3);
}

uint64_t ___ZN5STube23_onqueue_needClientCertEv_block_invoke_3(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  STube::_onqueue_cancel(v1);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

uint64_t STube::_onqueue_cancel(uint64_t this)
{
  STube *v1;
  uint64_t v2;
  _QWORD v3[5];

  if (*(_DWORD *)(this + 160) != 9)
  {
    v1 = (STube *)this;
    *(_DWORD *)(this + 160) = 9;
    if (*(_QWORD *)(this + 224))
      STube::_onqueue_complete_needServerTrust(this);
    if (*((_QWORD *)v1 + 27))
      STube::_onqueue_complete_needClientCert(v1, 0);
    STube::_onqueue_cleanupStreams(v1, 1);
    (*(void (**)(STube *))(*(_QWORD *)v1 + 40))(v1);
    v2 = *((_QWORD *)v1 + 14);
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = ___ZN5STube15_onqueue_cancelEv_block_invoke;
    v3[3] = &__block_descriptor_40_e5_v8__0l;
    v3[4] = v1;
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 96))(v2, v3);
  }
  return this;
}

void STube::_onqueue_complete_needServerTrust(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 224);
  if (v2)
    (*(void (**)(void))(v2 + 16))();
  v3 = *(const void **)(a1 + 192);
  *(_QWORD *)(a1 + 192) = 0;
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 224);
  if (v4)
  {
    _Block_release(v4);
    *(_QWORD *)(a1 + 224) = 0;
  }
}

uint64_t ___ZN5STube15_onqueue_cancelEv_block_invoke(uint64_t a1)
{
  STube *v1;
  CFStreamError v3;

  v1 = *(STube **)(a1 + 32);
  v3.domain = 1;
  *(_QWORD *)&v3.error = 89;
  STube::_onqueue_notifyTubeManager(v1, v3);
  return (*(uint64_t (**)(STube *))(*(_QWORD *)v1 + 48))(v1);
}

uint64_t ___ZN5STube23_onqueue_needClientCertEv_block_invoke_2(uint64_t a1, const void *a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[6];

  v3 = *(_QWORD **)(a1 + 32);
  (*(void (**)(_QWORD *))(*v3 + 40))(v3);
  if (a2)
    CFRetain(a2);
  v4 = v3[14];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN5STube24_complete_needClientCertEPK9__CFArray_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = v3;
  v6[5] = a2;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v6);
  return (*(uint64_t (**)(_QWORD *))(*v3 + 48))(v3);
}

uint64_t ___ZN5STube24_complete_needClientCertEPK9__CFArray_block_invoke(uint64_t a1)
{
  STube *v2;
  const void *v3;

  v2 = *(STube **)(a1 + 32);
  STube::_onqueue_complete_needClientCert(v2, *(const __CFArray **)(a1 + 40));
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  return (*(uint64_t (**)(STube *))(*(_QWORD *)v2 + 48))(v2);
}

uint64_t ___ZN5STube17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t);
  void *v11;
  uint64_t v12;
  uint64_t v13;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(int *)(v1 + 160) < 9)
  {
    *(_DWORD *)(v1 + 160) = 6;
    v2 = *(_QWORD *)(v1 + 120);
    if (v2 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2))
    {
      v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 120) + 64))(*(_QWORD *)(v1 + 120));
      if (v3)
        v4 = v3 - 176;
      else
        v4 = 0;
      if (v3)
        v5 = v4 + 112;
      else
        v5 = 0;
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
      v6 = *(_QWORD *)(v4 + 24);
      v8 = MEMORY[0x1E0C809B0];
      v9 = 3221225472;
      v10 = ___ZN5STube24_onqueue_needServerTrustEv_block_invoke;
      v11 = &__block_descriptor_48_e5_v8__0l;
      v12 = v1;
      v13 = v5;
    }
    else
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
      v6 = *(_QWORD *)(v1 + 112);
      v8 = MEMORY[0x1E0C809B0];
      v9 = 3221225472;
      v10 = ___ZN5STube24_onqueue_needServerTrustEv_block_invoke_3;
      v11 = &__block_descriptor_40_e5_v8__0l;
      v12 = v1;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v6 + 96))(v6, &v8);
  }
  else
  {
    STube::_onqueue_complete_needServerTrust(*(_QWORD *)(a1 + 32));
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

uint64_t ___ZN5STube24_onqueue_needServerTrustEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[5];

  v3 = *(_QWORD **)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  v4 = v3[24];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN5STube24_onqueue_needServerTrustEv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e8_v12__0i8l;
  v6[4] = v3;
  (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v2 + 40))(v2, v4, v6);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 24))(*(_QWORD *)(a1 + 40));
  return (*(uint64_t (**)(_QWORD *))(*v3 + 48))(v3);
}

uint64_t ___ZN5STube24_onqueue_needServerTrustEv_block_invoke_3(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  STube::_onqueue_cancel(v1);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

uint64_t ___ZN5STube24_onqueue_needServerTrustEv_block_invoke_2(uint64_t a1, int a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[5];
  int v7;

  v3 = *(_QWORD **)(a1 + 32);
  (*(void (**)(_QWORD *))(*v3 + 40))(v3);
  v4 = v3[14];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN5STube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicy_block_invoke;
  v6[3] = &__block_descriptor_44_e5_v8__0l;
  v6[4] = v3;
  v7 = a2;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v6);
  return (*(uint64_t (**)(_QWORD *))(*v3 + 48))(v3);
}

uint64_t ___ZN5STube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicy_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  STube::_onqueue_complete_needServerTrust(v1);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

uint64_t ___ZN5STube25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = a1[6];
  if (*(int *)(v2 + 160) <= 3)
  {
    *(_DWORD *)(v2 + 160) = 4;
    v3 = *(_QWORD *)(v2 + 120);
    if (v3)
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 96))(v3))
      {
        v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 120) + 64))(*(_QWORD *)(v2 + 120));
        if (v4)
        {
          v5 = v4;
          v6 = tcp_connection_id();
          (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(v2 + 32) + 128))(v2 + 32, v6, a1[4], 0, objc_msgSend(*(id *)(v5 - 88), "cfURL"), *(_QWORD *)(v5 + 432));
        }
      }
    }
  }
  (*(void (**)(void))(a1[5] + 16))();
  tcp_connection_release();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

uint64_t ___ZN5STube14clientCanceledEP25MetaConnectionCacheClient_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 32);
  result = *(_QWORD *)(v2 + 120);
  if (result)
  {
    v4 = *(_QWORD *)(a1 + 40);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 64))(result);
    if (result == v4)
      return STube::_onqueue_cancel(v2);
  }
  return result;
}

uint64_t STube::STube(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  const void *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  const char *v14;
  int v15;
  __int128 v16;

  *(_QWORD *)a1 = off_1E14EF578;
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = 1;
  if (((a1 + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)(a1 + 32) = &unk_1E14EFB00;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)a1 = off_1E14EFA28;
  *(_QWORD *)(a1 + 24) = &unk_1E14EFAE0;
  *(_QWORD *)(a1 + 40) = &unk_1E14EFBA8;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  v6 = a1 + 200;
  *(_QWORD *)(a1 + 208) = 0;
  if (!a3)
  {
    v14 = "key";
    v15 = 38;
    goto LABEL_17;
  }
  *(_QWORD *)(a1 + 96) = a3;
  (*(void (**)(uint64_t))(*(_QWORD *)a3 + 40))(a3);
  if (!a4)
  {
    v14 = "manager";
    v15 = 42;
    goto LABEL_17;
  }
  *(_QWORD *)(a1 + 104) = a4;
  (*(void (**)(uint64_t))(*(_QWORD *)a4 + 40))(a4);
  if (!a5)
  {
    v14 = "schedulingSet";
    v15 = 46;
LABEL_17:
    __assert_rtn("STube", "STube.cpp", v15, v14);
  }
  *(_QWORD *)(a1 + 112) = a5;
  (*(void (**)(uint64_t))(*(_QWORD *)a5 + 40))(a5);
  *(_BYTE *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 160) = 0;
  *(_BYTE *)(a1 + 164) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 133) = 0;
  v9 = *(const void **)(a1 + 168);
  *(_QWORD *)(a1 + 168) = 0;
  if (v9)
    CFRelease(v9);
  *(_WORD *)(a1 + 176) = 1;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  v16 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v6, &v16);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
  if (*((_QWORD *)&v16 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return a1;
}

void sub_1840FCAFC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  ProxyConnectionEstablishment *v3;
  const void *v5;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  v5 = *(const void **)(v1 + 168);
  *(_QWORD *)(v1 + 168) = 0;
  if (v5)
    CFRelease(v5);
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(v3);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t STube::initialize(STube *this, SBaseAwaitingTube *a2)
{
  uint64_t v4;
  _QWORD v6[5];

  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  if (!a2)
    __assert_rtn("initialize", "STube.cpp", 124, "waiter");
  if ((*(unsigned int (**)(SBaseAwaitingTube *))(*(_QWORD *)a2 + 112))(a2))
    __assert_rtn("initialize", "STube.cpp", 125, "!waiter->hasBeenClaimed()");
  *((_QWORD *)this + 15) = a2;
  (*(void (**)(SBaseAwaitingTube *))(*(_QWORD *)a2 + 40))(a2);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 15) + 104))(*((_QWORD *)this + 15));
  if (*((_DWORD *)this + 40) != 9)
    *((_DWORD *)this + 40) = 1;
  (*(void (**)(STube *))(*(_QWORD *)this + 40))(this);
  v4 = *((_QWORD *)this + 14);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN5STube10initializeEP17SBaseAwaitingTube_block_invoke;
  v6[3] = &__block_descriptor_40_e5_v8__0l;
  v6[4] = this;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v6);
}

uint64_t ___ZN5STube10initializeEP17SBaseAwaitingTube_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v4[5];
  _QWORD v5[6];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = MEMORY[0x1E0C809B0];
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN5STube10initializeEP17SBaseAwaitingTube_block_invoke_2;
  v4[3] = &__block_descriptor_40_e13_v24__0___qi_8l;
  v4[4] = v1;
  if (*(_QWORD *)(v1 + 128))
    __assert_rtn("connect", "STube.cpp", 420, "fSocketStream == NULL");
  if (*(_DWORD *)(v1 + 160) != 9)
    *(_DWORD *)(v1 + 160) = 2;
  v5[0] = v2;
  v5[1] = 3221225472;
  v5[2] = ___ZN5STube7connectEU13block_pointerFv13CFStreamErrorE_block_invoke;
  v5[3] = &unk_1E14FDA90;
  v5[4] = v4;
  v5[5] = v1;
  ___ZN5STube7connectEU13block_pointerFv13CFStreamErrorE_block_invoke((uint64_t)v5);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void ___ZN5STube10initializeEP17SBaseAwaitingTube_block_invoke_2(uint64_t a1, CFStreamError a2)
{
  STube *v2;

  if (a2.error)
  {
    v2 = *(STube **)(a1 + 32);
    if (*((_DWORD *)v2 + 40) != 9)
    {
      *((_DWORD *)v2 + 40) = 10;
      STube::_onqueue_notifyTubeManager(v2, a2);
    }
  }
}

void ___ZN5STube7connectEU13block_pointerFv13CFStreamErrorE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t Instance;
  const char *v4;
  SocketStream *v5;
  int v6;
  uint64_t v7;
  BOOL v8;
  _QWORD *v9;
  unint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const __CFAllocator *v14;
  CFMutableArrayRef Mutable;
  __CFArray *ArrayBySeparatingStrings;
  CFStringRef v17;
  uint64_t v18;
  uint64_t v19;
  const __CFDictionary *v20;
  uint64_t v21;
  uint64_t v22;
  const __CFString *v23;
  const __CFString *v24;
  int v25;
  _QWORD v26[6];
  _QWORD v27[9];
  _QWORD v28[10];
  _QWORD v29[4];
  _QWORD v30[3];
  char v31;
  _QWORD context[5];
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  CFMutableDictionaryRef v36;

  v2 = *(_QWORD *)(a1 + 40);
  if (TCFObject<SocketStream>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_17305);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v5 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B8uLL);
  }
  else
  {
    v5 = 0;
  }
  SocketStream::SocketStream(v5, v4);
  *(_QWORD *)(v2 + 128) = v5;
  v6 = (*(uint64_t (**)(void))(*(_QWORD *)v5 + 56))();
  v7 = *(_QWORD *)(v2 + 128);
  if (!v6)
  {
    CFRelease((CFTypeRef)(v7 - 16));
    *(_QWORD *)(v2 + 128) = 0;
    goto LABEL_12;
  }
  if (!v7)
  {
LABEL_12:
    STube::_onqueue_cleanupStreams((STube *)v2, 1);
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    return;
  }
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 88))(*(_QWORD *)(v2 + 96)) == 1
    || (*(unsigned int (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 88))(*(_QWORD *)(v2 + 96)) == 3)
  {
    v8 = 1;
    *(_BYTE *)(v2 + 140) = 1;
  }
  else
  {
    v8 = *(_BYTE *)(v2 + 140) != 0;
  }
  v9 = *(_QWORD **)(v2 + 96);
  v12 = *v9;
  v10 = v9 + 9;
  v11 = v12;
  if (*(_BYTE *)(v2 + 144))
    v10 = (unint64_t *)(v2 + 152);
  v13 = *v10;
  (*(void (**)(void))(v11 + 64))();
  if (!v8)
  {
    if (v13 > 1)
      goto LABEL_12;
LABEL_23:
    *(_DWORD *)(v2 + 136) = 1;
    goto LABEL_24;
  }
  if (v13 == 1)
    goto LABEL_23;
  *(_DWORD *)(v2 + 136) = 0;
  v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!v13)
  {
    v23 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], ",", 0x8000100u);
    v24 = CFStringCreateWithCString(v14, "http/1.1", 0x8000100u);
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v14, v24, v23);
    CFRelease(v24);
    CFRelease(v23);
    goto LABEL_28;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  ArrayBySeparatingStrings = Mutable;
  if ((v13 & 1) == 0 || !Mutable)
  {
LABEL_28:
    if (ArrayBySeparatingStrings)
      goto LABEL_29;
    goto LABEL_12;
  }
  v17 = CFStringCreateWithCString(v14, "http/1.1", 0x8000100u);
  CFArrayAppendValue(ArrayBySeparatingStrings, v17);
  CFRelease(v17);
LABEL_29:
  if (!ArrayBySeparatingStrings || *(_DWORD *)(v2 + 136))
  {
    CFRelease(ArrayBySeparatingStrings);
  }
  else
  {
    v25 = (*(uint64_t (**)(_QWORD, uint64_t, __CFArray *))(**(_QWORD **)(v2 + 128) + 200))(*(_QWORD *)(v2 + 128), 0x1EDCFA6E8, ArrayBySeparatingStrings);
    CFRelease(ArrayBySeparatingStrings);
    if (!v25)
      goto LABEL_12;
  }
LABEL_24:
  v18 = MEMORY[0x1E0C809B0];
  v26[0] = MEMORY[0x1E0C809B0];
  v26[1] = 3221225472;
  v26[2] = ___ZN5STube7connectEU13block_pointerFv13CFStreamErrorE_block_invoke_2;
  v26[3] = &unk_1E14FDA90;
  v19 = *(_QWORD *)(a1 + 32);
  v26[4] = v19;
  v26[5] = v2;
  v33 = 0;
  v34 = &v33;
  v35 = 0x2020000000;
  v36 = 0;
  v36 = CFDictionaryCreateMutable(*(CFAllocatorRef *)(v2 + 8), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue((CFMutableDictionaryRef)v34[3], &unk_1EDCFB1A0, (const void *)*MEMORY[0x1E0C9AE50]);
  if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 64))(*(_QWORD *)(v2 + 96)))
  {
    v20 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 64))(*(_QWORD *)(v2 + 96));
    context[0] = v18;
    context[1] = 3221225472;
    context[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke;
    context[3] = &unk_1E14FDAB8;
    context[4] = &v33;
    CFDictionaryApplyFunction(v20, (CFDictionaryApplierFunction)_apply_block, context);
  }
  v30[0] = 0;
  v30[1] = v30;
  v30[2] = 0x2020000000;
  v31 = 1;
  v29[0] = 0;
  v29[1] = v29;
  v29[2] = 0x2020000000;
  v29[3] = 0;
  v28[0] = v18;
  v28[1] = 3221225472;
  v28[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_2;
  v28[3] = &unk_1E14FDB08;
  v28[6] = v29;
  v28[7] = &v33;
  v28[8] = v30;
  v28[9] = v2;
  v28[4] = v19;
  v28[5] = v26;
  v21 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 120) + 64))(*(_QWORD *)(v2 + 120));
  (*(void (**)(uint64_t))(*(_QWORD *)v21 + 16))(v21);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
  v22 = *(_QWORD *)(v21 - 152);
  v27[0] = v18;
  v27[1] = 3221225472;
  v27[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_15;
  v27[3] = &unk_1E14FDB58;
  v27[7] = v2;
  v27[8] = v21;
  v27[5] = v30;
  v27[6] = v29;
  v27[4] = v28;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v22 + 96))(v22, v27);
  _Block_object_dispose(v29, 8);
  _Block_object_dispose(v30, 8);
  _Block_object_dispose(&v33, 8);
}

void sub_1840FD224(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube7connectEU13block_pointerFv13CFStreamErrorE_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_DWORD *)(v2 + 160) != 9)
    *(_DWORD *)(v2 + 160) = 3;
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 128) + 192))(*(_QWORD *)(v2 + 128));
  if (!(_DWORD)result)
  {
    STube::_onqueue_cleanupStreams((STube *)v2, 1);
    return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
  return result;
}

void ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2, a3);
}

void ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_2(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  const void *v6;
  BOOL v7;
  const __CFDictionary *v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  _CFHTTPAuthentication *v16;
  __CFHTTPMessage *v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  const __CFDictionary *Value;
  const __CFDictionary *v21;
  const void *v22;
  char v23;
  CFHTTPMessageRef Copy;
  int v25;
  _BOOL4 v26;
  __CFString *v27;
  const __CFAllocator *v28;
  void *MutableCopy;
  CFIndex Count;
  const __CFAllocator *v31;
  CFIndex v32;
  __CFDictionary *v33;
  _QWORD context[6];
  void *values;
  void **p_values;
  uint64_t v37;
  BOOL v38;
  void *v39;

  v2 = a1[9];
  if (*(_DWORD *)(v2 + 160) != 9)
  {
    if (*(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24))
    {
      values = 0;
      p_values = &values;
      v37 = 0x2020000000;
      v38 = 0;
      v7 = (*(unsigned int (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 88))(*(_QWORD *)(v2 + 96)) == 1
        || (*(unsigned int (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 88))(*(_QWORD *)(v2 + 96)) == 3;
      v38 = v7;
      v8 = *(const __CFDictionary **)(*(_QWORD *)(a1[6] + 8) + 24);
      if (v8)
      {
        context[0] = MEMORY[0x1E0C809B0];
        context[1] = 3221225472;
        context[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_3;
        context[3] = &unk_1E14FDAE0;
        v9 = a1[7];
        context[4] = &values;
        context[5] = v9;
        CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)_apply_block, context);
        v10 = *(_QWORD *)(a1[6] + 8);
        v11 = *(const void **)(v10 + 24);
        *(_QWORD *)(v10 + 24) = 0;
        if (v11)
          CFRelease(v11);
      }
      if (*((_BYTE *)p_values + 24))
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1[7] + 8) + 24), &unk_1EDCFBEC0, &unk_1EDCFC1D0);
      _Block_object_dispose(&values, 8);
      if (*(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24))
        (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v2 + 128) + 208))(*(_QWORD *)(v2 + 128), *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24));
    }
    v12 = *(_QWORD *)(a1[7] + 8);
    v13 = *(const void **)(v12 + 24);
    *(_QWORD *)(v12 + 24) = 0;
    if (v13)
      CFRelease(v13);
    if (!*(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24)
      || (*(unsigned int (**)(_QWORD))(**(_QWORD **)(v2 + 96) + 88))(*(_QWORD *)(v2 + 96)) != 3)
    {
      goto LABEL_55;
    }
    v14 = *(_QWORD *)(v2 + 120);
    if (!v14 || !(*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 72))(v14))
    {
LABEL_54:
      *(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24) = 0;
LABEL_55:
      if (*(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24)
        && ((*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 128) + 176))(*(_QWORD *)(v2 + 128), v2 + 32),
            *(_BYTE *)(*(_QWORD *)(a1[8] + 8) + 24)))
      {
        (*(void (**)(void))(a1[5] + 16))();
      }
      else
      {
        STube::_onqueue_cleanupStreams((STube *)v2, 1);
        (*(void (**)(void))(a1[4] + 16))();
      }
      return;
    }
    v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 120) + 72))(*(_QWORD *)(v2 + 120));
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v16 = *(_CFHTTPAuthentication **)(v15 + 80);
    if (!v16)
      goto LABEL_55;
    v17 = (__CFHTTPMessage *)(v15 - 16);
    v18 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 128) + 224))(*(_QWORD *)(v2 + 128), 0x1EDD003E0);
    v19 = v18;
    if (v18)
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(v18, &unk_1EDD003A8);
      v21 = Value;
      if (Value)
      {
        v22 = CFDictionaryGetValue(Value, &unk_1EDCFD3F8);
        v23 = 0;
        goto LABEL_31;
      }
    }
    else
    {
      v21 = 0;
    }
    v22 = 0;
    v23 = 1;
LABEL_31:
    Copy = CFHTTPMessageCreateCopy(*(CFAllocatorRef *)(v2 + 8), v17);
    _CFHTTPAuthenticationApplyHeaderToRequest(v16, Copy, (const void *)v2);
    if (v25)
    {
      values = 0;
      CFRelease(Copy);
      v26 = 0;
    }
    else
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v27 = (__CFString *)HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Copy + 16), 0x1362735Fu);
      values = v27;
      CFRelease(Copy);
      if (!v27 || v22 && CFEqual(v22, v27))
      {
        v26 = 1;
      }
      else
      {
        v28 = *(const __CFAllocator **)(v2 + 8);
        if ((v23 & 1) != 0)
        {
          MutableCopy = CFDictionaryCreate(*(CFAllocatorRef *)(v2 + 8), (const void **)&kCFHTTPHeaderProxyAuthorization, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v39 = MutableCopy;
        }
        else
        {
          Count = CFDictionaryGetCount(v21);
          MutableCopy = CFDictionaryCreateMutableCopy(v28, Count + 1, v21);
          v39 = MutableCopy;
          CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, &unk_1EDCFD3F8, v27);
        }
        v31 = *(const __CFAllocator **)(v2 + 8);
        if (v19)
        {
          v32 = CFDictionaryGetCount(v19);
          v33 = CFDictionaryCreateMutableCopy(v31, v32 + 1, v19);
          CFDictionarySetValue(v33, &unk_1EDD003A8, MutableCopy);
        }
        else
        {
          v33 = CFDictionaryCreate(*(CFAllocatorRef *)(v2 + 8), (const void **)&kCFStreamPropertyCONNECTAdditionalHeaders, (const void **)&v39, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          MutableCopy = v39;
        }
        if (MutableCopy)
          CFRelease(MutableCopy);
        v26 = (*(uint64_t (**)(_QWORD, uint64_t, __CFDictionary *))(**(_QWORD **)(v2 + 128) + 200))(*(_QWORD *)(v2 + 128), 0x1EDD003E0, v33) != 0;
        if (v33)
          CFRelease(v33);
      }
    }
    if (v19)
      CFRelease(v19);
    if (values)
      CFRelease(values);
    if (v26)
      goto LABEL_55;
    goto LABEL_54;
  }
  v3 = *(_QWORD *)(a1[6] + 8);
  v4 = *(const void **)(v3 + 24);
  *(_QWORD *)(v3 + 24) = 0;
  if (v4)
    CFRelease(v4);
  v5 = *(_QWORD *)(a1[7] + 8);
  v6 = *(const void **)(v5 + 24);
  *(_QWORD *)(v5 + 24) = 0;
  if (v6)
    CFRelease(v6);
}

void sub_1840FD808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_15(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  HTTPProtocol *v4;
  uint64_t v5;
  _QWORD v7[7];

  v2 = (_QWORD *)a1[7];
  if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)a1[8] + 184))(a1[8]))
  {
    v3 = a1[8];
    if (v3)
      v4 = (HTTPProtocol *)(v3 - 176);
    else
      v4 = 0;
    *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = HTTPProtocol::copyProtocolPropertiesForStream(v4);
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
  }
  (*(void (**)(_QWORD *))(*v2 + 40))(v2);
  v5 = v2[14];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_2_17;
  v7[3] = &unk_1E14FDB30;
  v7[4] = a1[4];
  v7[5] = v2;
  v7[6] = a1[8];
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v5 + 96))(v5, v7);
  return (*(uint64_t (**)(_QWORD *))(*v2 + 48))(v2);
}

uint64_t ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_2_17(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 24))(*(_QWORD *)(a1 + 48));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_3(uint64_t a1, CFStringRef theString1, const void *a3)
{
  const __CFDictionary *Value;
  CFMutableDictionaryRef MutableCopy;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[5];
  std::__shared_weak_count *v18;
  CFMutableDictionaryRef v19;
  std::__shared_weak_count *v20;

  if (CFStringCompare(theString1, (CFStringRef)&unk_1EDCFBEC0, 1uLL) == kCFCompareEqualTo)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
LABEL_18:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), theString1, a3);
    return;
  }
  if (CFStringCompare(theString1, CFSTR("kCFStreamPropertySSLSettings"), 1uLL))
    goto LABEL_18;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), CFSTR("kCFStreamPropertySSLSettings"));
  if (!Value)
    goto LABEL_18;
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, Value);
  v19 = MutableCopy;
  v8 = (std::__shared_weak_count *)operator new();
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1588;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)MutableCopy;
  v20 = v8;
  v17[4] = MutableCopy;
  v18 = v8;
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3321888768;
  v17[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_4;
  v17[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE_e25_v24__0____CFString__8_v16l;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  CFDictionaryApplyFunction((CFDictionaryRef)a3, (CFDictionaryApplierFunction)_apply_block, v17);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), theString1, MutableCopy);
  v11 = v18;
  if (v18)
  {
    v12 = (unint64_t *)&v18->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v20;
  if (v20)
  {
    v15 = (unint64_t *)&v20->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_1840FDB44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_4(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke_17306()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  dword_1EDD01068 = 1835099506;
  _PNAME<SocketStream>::GET(void)::p = *(_QWORD *)"SocketStream>::GET() [OBJTYPE = SocketStream]";
  CFClass::CFClass(v0, (const char *)&_PNAME<SocketStream>::GET(void)::p);
  TCFObject<SocketStream>::Class(void)::clazz = (uint64_t)v0;
}

void sub_1840FDBD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube24overrideAllowedProtocolsEm_block_invoke(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 32);
  if (*(int *)(v1 + 160) <= 1)
  {
    *(_BYTE *)(v1 + 144) = 1;
    *(_QWORD *)(v1 + 152) = *(_QWORD *)(result + 40);
  }
  return result;
}

uint64_t STube::getWaiter(STube *this)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v1 = *((_QWORD *)this + 14);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN5STube9getWaiterEv_block_invoke;
  v4[3] = &unk_1E14FDA68;
  v4[4] = &v5;
  v4[5] = this;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v1 + 104))(v1, v4);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1840FDCB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube9getWaiterEv_block_invoke(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_QWORD *)(*(_QWORD *)(result + 40) + 120);
  return result;
}

CFTypeRef ___ZN5STube18copySSLCertContextEv_block_invoke(uint64_t a1)
{
  CFTypeRef result;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 168);
  result = *(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t ___ZN5STube6cancelEv_block_invoke(uint64_t a1)
{
  return STube::_onqueue_cancel(*(_QWORD *)(a1 + 32));
}

uint64_t STube::isCanceled(STube *this)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v1 = *((_QWORD *)this + 14);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN5STube10isCanceledEv_block_invoke;
  v4[3] = &unk_1E14FDA68;
  v4[4] = &v5;
  v4[5] = this;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v1 + 104))(v1, v4);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1840FDDA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube10isCanceledEv_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_DWORD *)(*(_QWORD *)(result + 40) + 160) == 9;
  return result;
}

uint64_t ___ZN5STube16canAcceptWaitersEv_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_DWORD *)(*(_QWORD *)(result + 40) + 160) < 9;
  return result;
}

void *__CFTubeSetTubeTypeNotifier(void *aBlock)
{
  void *result;

  if (GlueTube::notifyOfTubeType)
    _Block_release((const void *)GlueTube::notifyOfTubeType);
  result = _Block_copy(aBlock);
  GlueTube::notifyOfTubeType = (uint64_t)result;
  return result;
}

uint64_t __Block_byref_object_copy__17333(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = a2[6];
  a2[6] = 0;
  *(_QWORD *)(result + 48) = v2;
  *(_QWORD *)(result + 56) = a2[7];
  a2[7] = 0;
  v5 = a2[8];
  v3 = a2 + 8;
  v4 = v5;
  *(_QWORD *)(result + 64) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 64;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__17334(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table(a1 + 48);
}

uint64_t ___Z34__HTTP2ServerPushMatchAcceptHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke(uint64_t a1, uint64_t *a2)
{
  char v2;
  uint64_t v3;
  char *v4;
  char *v7;
  size_t v8;
  char *v9;
  char *v10;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  int v16;
  unsigned __int8 v17;
  unsigned __int8 *v19;
  void *__p[2];
  unsigned __int8 v22;
  void *v23[2];
  unsigned __int8 v24;

  v2 = *((_BYTE *)a2 + 23);
  if (v2 >= 0)
    v3 = *((unsigned __int8 *)a2 + 23);
  else
    v3 = a2[1];
  if (v2 >= 0)
    v4 = (char *)a2;
  else
    v4 = (char *)*a2;
  if (v3 >= 1)
  {
    v7 = &v4[v3];
    v8 = v3;
    v9 = v4;
    do
    {
      v10 = (char *)memchr(v9, 47, v8);
      if (!v10)
        break;
      if (*v10 == 47)
      {
        if (v10 != v7 && v10 - v4 != -1)
        {
          v11 = v4;
          while (*v11 != 47)
          {
            ++v11;
            if (!--v3)
            {
              v11 = v7;
              break;
            }
          }
          if (v11 == v7)
            v12 = -1;
          else
            v12 = v11 - v4;
          std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(v23, v4, &v4[v12], v12);
          v13 = *((unsigned __int8 *)a2 + 23);
          if ((v13 & 0x80u) == 0)
            v14 = (char *)a2;
          else
            v14 = (char *)*a2;
          if ((v13 & 0x80u) != 0)
            v13 = a2[1];
          std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(__p, &v14[v12 + 1], &v14[v13], v13 - (v12 + 1));
          v15 = v24;
          v16 = (char)v24;
          if ((v24 & 0x80u) != 0)
            v15 = (unint64_t)v23[1];
          v17 = v22;
          if (v15)
          {
            if ((v22 & 0x80u) == 0 ? (void *)v22 : __p[1])
            {
              v19 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, (uint64_t)v23, (uint64_t)v23);
              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t *)v19 + 5, (uint64_t)__p, (uint64_t)__p);
            }
          }
          if ((v17 & 0x80) != 0)
            operator delete(__p[0]);
          if (v16 < 0)
            operator delete(v23[0]);
        }
        return 1;
      }
      v9 = v10 + 1;
      v8 = v7 - v9;
    }
    while (v7 - v9 >= 1);
  }
  return 1;
}

void sub_1840FE02C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  char v17;
  char v18;

  if (v18 < 0)
    operator delete(__p);
  if (v17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

void split(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unsigned __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 *v14;
  int64_t v15;
  char *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t v21;
  _Unwind_Exception *v22;
  _Unwind_Exception *v23;
  void *__p[2];
  uint64_t v25;

  while (1)
  {
    if (*(char *)(a1 + 23) < 0)
    {
      v6 = *(unsigned __int8 **)a1;
      v7 = *(_QWORD *)(a1 + 8);
    }
    else
    {
      v6 = (unsigned __int8 *)a1;
      v7 = *(unsigned __int8 *)(a1 + 23);
    }
    v8 = a2[23];
    if ((v8 & 0x80u) == 0)
      v9 = a2;
    else
      v9 = *(unsigned __int8 **)a2;
    if ((v8 & 0x80u) != 0)
      v8 = *((_QWORD *)a2 + 1);
    if (!v7 || v8 == 0)
      break;
    v11 = &v6[v7];
    v12 = v6;
LABEL_14:
    v13 = v8;
    v14 = v9;
    while (*v12 != *v14)
    {
      ++v14;
      if (!--v13)
      {
        if (++v12 == v11)
          goto LABEL_33;
        goto LABEL_14;
      }
    }
    if (v12 == v11)
      break;
    v15 = v12 - v6;
    if (v12 - v6 == -1)
      break;
    v16 = (char *)a1;
    if ((*(_BYTE *)(a1 + 23) & 0x80) != 0)
      v16 = *(char **)a1;
    std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(__p, v16, &v16[v15], v12 - v6);
    v17 = *(_QWORD *)(a3 + 24);
    if (!v17)
    {
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
LABEL_37:
      std::__throw_bad_function_call[abi:nn180100]();
      v23 = v22;
      if (SHIBYTE(v25) < 0)
        operator delete(__p[0]);
      _Unwind_Resume(v23);
    }
    v18 = (*(uint64_t (**)(uint64_t, void **))(*(_QWORD *)v17 + 48))(v17, __p);
    if (SHIBYTE(v25) < 0)
      operator delete(__p[0]);
    if ((v18 & 1) == 0)
      return;
    if (*(char *)(a1 + 23) < 0)
    {
      v20 = *(unsigned __int8 **)a1;
      v19 = *(_QWORD *)(a1 + 8);
    }
    else
    {
      v19 = *(unsigned __int8 *)(a1 + 23);
      v20 = (unsigned __int8 *)a1;
    }
    std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(__p, (char *)&v20[v15 + 1], (char *)&v20[v19], v19 - (v15 + 1));
    if (*(char *)(a1 + 23) < 0)
      operator delete(*(void **)a1);
    *(_OWORD *)a1 = *(_OWORD *)__p;
    *(_QWORD *)(a1 + 16) = v25;
  }
LABEL_33:
  v21 = *(_QWORD *)(a3 + 24);
  if (!v21)
    goto LABEL_37;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v21 + 48))(v21, a1);
}

BOOL ___Z34__HTTP2ServerPushMatchAcceptHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke_2(uint64_t a1, uint64_t *a2)
{
  char v2;
  uint64_t v3;
  char *v4;
  char *v7;
  size_t v8;
  char *v9;
  char *v10;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  int v15;
  unint64_t v16;
  unsigned __int8 v17;
  int8x8_t *v19;
  uint64_t *v20;
  unint64_t v21;
  int8x8_t v22;
  unint64_t v23;
  int8x8_t *v24;
  uint8x8_t v25;
  unint64_t v26;
  unint64_t v27;
  unsigned __int8 **v28;
  unsigned __int8 *v29;
  unint64_t v30;
  char v31;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  void *v36[2];
  char v37;
  void *__p[2];
  unsigned __int8 v39;
  void *v40[2];
  unsigned __int8 v41;

  v2 = *((_BYTE *)a2 + 23);
  if (v2 >= 0)
    v3 = *((unsigned __int8 *)a2 + 23);
  else
    v3 = a2[1];
  if (v2 >= 0)
    v4 = (char *)a2;
  else
    v4 = (char *)*a2;
  if (v3 < 1)
    return 1;
  v7 = &v4[v3];
  v8 = v3;
  v9 = v4;
  while (1)
  {
    v10 = (char *)memchr(v9, 47, v8);
    if (!v10)
      return 1;
    if (*v10 == 47)
      break;
    v9 = v10 + 1;
    v8 = v7 - v9;
    if (v7 - v9 < 1)
      return 1;
  }
  if (v10 == v7 || v10 - v4 == -1)
    return 1;
  v11 = v4;
  while (*v11 != 47)
  {
    ++v11;
    if (!--v3)
    {
      v11 = v7;
      break;
    }
  }
  if (v11 == v7)
    v12 = -1;
  else
    v12 = v11 - v4;
  std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(v40, v4, &v4[v12], v12);
  v13 = *((unsigned __int8 *)a2 + 23);
  if ((v13 & 0x80u) == 0)
    v14 = (char *)a2;
  else
    v14 = (char *)*a2;
  if ((v13 & 0x80u) != 0)
    v13 = a2[1];
  std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(__p, &v14[v12 + 1], &v14[v13], v13 - (v12 + 1));
  v15 = (char)v41;
  if ((v41 & 0x80u) == 0)
    v16 = v41;
  else
    v16 = (unint64_t)v40[1];
  v17 = v39;
  if (!v16)
    goto LABEL_54;
  if (!((v39 & 0x80u) == 0 ? (void *)v39 : __p[1]))
    goto LABEL_54;
  v19 = *(int8x8_t **)(*(_QWORD *)(a1 + 32) + 8);
  v20 = (v41 & 0x80u) == 0 ? (uint64_t *)v40 : (uint64_t *)v40[0];
  v21 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v20, v16);
  v22 = v19[7];
  if (!*(_QWORD *)&v22)
    goto LABEL_54;
  v23 = v21;
  v24 = v19 + 6;
  v25 = (uint8x8_t)vcnt_s8(v22);
  v25.i16[0] = vaddlv_u8(v25);
  v26 = v25.u32[0];
  if (v25.u32[0] > 1uLL)
  {
    v27 = v21;
    if (v21 >= *(_QWORD *)&v22)
      v27 = v21 % *(_QWORD *)&v22;
  }
  else
  {
    v27 = (*(_QWORD *)&v22 - 1) & v21;
  }
  v28 = *(unsigned __int8 ***)(*(_QWORD *)v24 + 8 * v27);
  if (!v28 || (v29 = *v28) == 0)
  {
LABEL_54:
    v31 = 1;
    if ((v17 & 0x80) != 0)
      goto LABEL_55;
    goto LABEL_56;
  }
  while (1)
  {
    v30 = *((_QWORD *)v29 + 1);
    if (v23 == v30)
      break;
    if (v26 > 1)
    {
      if (v30 >= *(_QWORD *)&v22)
        v30 %= *(_QWORD *)&v22;
    }
    else
    {
      v30 &= *(_QWORD *)&v22 - 1;
    }
    if (v30 != v27)
      goto LABEL_54;
LABEL_53:
    v29 = *(unsigned __int8 **)v29;
    if (!v29)
      goto LABEL_54;
  }
  if (!std::equal_to<std::string>::operator()[abi:nn180100](v29 + 16, (unsigned __int8 *)v40))
    goto LABEL_53;
  v33 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v24, (uint64_t)v40, (uint64_t)v40);
  if (!std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>((_QWORD *)v33 + 5, (uint64_t)__p))
  {
    v34 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, (uint64_t)v40, (uint64_t)v40);
    std::string::basic_string[abi:nn180100]<0>(v36, "*");
    v35 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>((_QWORD *)v34 + 5, (uint64_t)v36);
    if (v37 < 0)
      operator delete(v36[0]);
    if (!v35)
      goto LABEL_54;
  }
  v31 = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  if ((v17 & 0x80) != 0)
LABEL_55:
    operator delete(__p[0]);
LABEL_56:
  if (v15 < 0)
  {
    operator delete(v40[0]);
    return (v31 & 1) != 0;
  }
  return (v31 & 1) != 0;
}

void sub_1840FE4E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  char v21;
  char v22;

  if (v22 < 0)
    operator delete(__p);
  if (v21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_set<std::string>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_set<std::string>>,0>(uint64_t a1)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(uint64_t a1)
{
  void **v2;
  void **v3;
  void *v4;

  v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0)
        operator delete(v2[2]);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

_QWORD *std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(_QWORD *result, char *a2, char *a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  if (a4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = result;
  if (a4 > 0x16)
  {
    v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17)
      v8 = a4 | 7;
    v9 = v8 + 1;
    result = operator new(v8 + 1);
    v7[1] = a4;
    v7[2] = v9 | 0x8000000000000000;
    *v7 = result;
    v7 = result;
  }
  else
  {
    *((_BYTE *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    v10 = *a2++;
    *(_BYTE *)v7 = v10;
    v7 = (_QWORD *)((char *)v7 + 1);
  }
  *(_BYTE *)v7 = 0;
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  _QWORD *v18;
  char *v19;
  std::string *v20;
  float v21;
  float v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  int8x8_t prime;
  void *v27;
  void *v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  uint8x8_t v32;
  unint64_t v33;
  uint8x8_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  unsigned __int8 **v38;
  unint64_t v39;
  void *v41;
  _QWORD v42[2];
  char v43;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3)
            break;
        }
      }
    }
  }
  v18 = (_QWORD *)(a1 + 16);
  v19 = (char *)operator new(0x50uLL);
  v42[0] = v19;
  v42[1] = a1 + 16;
  v43 = 0;
  *(_QWORD *)v19 = 0;
  *((_QWORD *)v19 + 1) = v11;
  v20 = (std::string *)(v19 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v20, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v20->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((_QWORD *)v19 + 4) = *(_QWORD *)(a3 + 16);
  }
  *(_OWORD *)(v19 + 56) = 0u;
  *(_OWORD *)(v19 + 40) = 0u;
  *((_DWORD *)v19 + 18) = 1065353216;
  v43 = 1;
  v21 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v22 = *(float *)(a1 + 32);
  if (!v12 || (float)(v22 * (float)v12) < v21)
  {
    v23 = 1;
    if (v12 >= 3)
      v23 = (v12 & (v12 - 1)) != 0;
    v24 = v23 | (2 * v12);
    v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25)
      prime = (int8x8_t)v25;
    else
      prime = (int8x8_t)v24;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v12 = *(_QWORD *)(a1 + 8);
    if (*(_QWORD *)&prime > v12)
      goto LABEL_39;
    if (*(_QWORD *)&prime < v12)
    {
      v33 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v12 < 3 || (v34 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        v33 = std::__next_prime(v33);
      }
      else
      {
        v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2)
          v33 = v35;
      }
      if (*(_QWORD *)&prime <= v33)
        prime = (int8x8_t)v33;
      if (*(_QWORD *)&prime >= v12)
      {
        v12 = *(_QWORD *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v27 = operator new(8 * *(_QWORD *)&prime);
          v28 = *(void **)a1;
          *(_QWORD *)a1 = v27;
          if (v28)
            operator delete(v28);
          v29 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v29++) = 0;
          while (*(_QWORD *)&prime != v29);
          v30 = (_QWORD *)*v18;
          if (*v18)
          {
            v31 = v30[1];
            v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(_QWORD *)&prime)
                v31 %= *(_QWORD *)&prime;
            }
            else
            {
              v31 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v31) = v18;
            v36 = (_QWORD *)*v30;
            if (*v30)
            {
              do
              {
                v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(_QWORD *)&prime)
                    v37 %= *(_QWORD *)&prime;
                }
                else
                {
                  v37 &= *(_QWORD *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v37))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v37) = v30;
                    goto LABEL_64;
                  }
                  *v30 = *v36;
                  *v36 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v37);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v37) = v36;
                  v36 = v30;
                }
                v37 = v31;
LABEL_64:
                v30 = v36;
                v36 = (_QWORD *)*v36;
                v31 = v37;
              }
              while (v36);
            }
          }
          v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        v41 = *(void **)a1;
        *(_QWORD *)a1 = 0;
        if (v41)
          operator delete(v41);
        v12 = 0;
        *(_QWORD *)(a1 + 8) = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v38 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
  i = (unsigned __int8 *)v42[0];
  if (v38)
  {
    *(_QWORD *)v42[0] = *v38;
LABEL_81:
    *v38 = i;
    goto LABEL_82;
  }
  *(_QWORD *)v42[0] = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = v18;
  if (*(_QWORD *)i)
  {
    v39 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v39 >= v12)
        v39 %= v12;
    }
    else
    {
      v39 &= v12 - 1;
    }
    v38 = (unsigned __int8 **)(*(_QWORD *)a1 + 8 * v39);
    goto LABEL_81;
  }
LABEL_82:
  v42[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)v42);
  return i;
}

void sub_1840FEB18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(_QWORD *a1, uint64_t a2)
{
  int v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  int8x8_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;

  v4 = *(char *)(a2 + 23);
  if (v4 >= 0)
    v5 = (uint64_t *)a2;
  else
    v5 = *(uint64_t **)a2;
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_QWORD *)(a2 + 8);
  v7 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v5, v6);
  v8 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v8)
    return 0;
  v9 = v7;
  v10 = (uint8x8_t)vcnt_s8(v8);
  v10.i16[0] = vaddlv_u8(v10);
  v11 = v10.u32[0];
  if (v10.u32[0] > 1uLL)
  {
    v12 = v7;
    if (v7 >= *(_QWORD *)&v8)
      v12 = v7 % *(_QWORD *)&v8;
  }
  else
  {
    v12 = (*(_QWORD *)&v8 - 1) & v7;
  }
  v13 = *(unsigned __int8 ***)(*a1 + 8 * v12);
  if (!v13)
    return 0;
  for (i = *v13; i; i = *(unsigned __int8 **)i)
  {
    v15 = *((_QWORD *)i + 1);
    if (v9 == v15)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
        return i;
    }
    else
    {
      if (v11 > 1)
      {
        if (v15 >= *(_QWORD *)&v8)
          v15 %= *(_QWORD *)&v8;
      }
      else
      {
        v15 &= *(_QWORD *)&v8 - 1;
      }
      if (v15 != v12)
        return 0;
    }
  }
  return i;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_set<std::string>>,0>((uint64_t)v1 + 16);
    operator delete(v1);
  }
}

void std::__function::__func<BOOL({block_pointer})(std::string const&),std::allocator<BOOL({block_pointer})(std::string const&)>,BOOL ()(std::string const&)>::~__func()
{
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__function::__func<BOOL({block_pointer})(std::string const&),std::allocator<BOOL({block_pointer})(std::string const&)>,BOOL ()(std::string const&)>::__clone()
{
  return 0;
}

void *std::__function::__func<BOOL({block_pointer})(std::string const&),std::allocator<BOOL({block_pointer})(std::string const&)>,BOOL ()(std::string const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  void *result;

  *a2 = &off_1E14F01F8;
  result = *(void **)(a1 + 8);
  if (result)
    result = _Block_copy(result);
  a2[1] = result;
  return result;
}

void std::__function::__func<BOOL({block_pointer})(std::string const&),std::allocator<BOOL({block_pointer})(std::string const&)>,BOOL ()(std::string const&)>::destroy(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    _Block_release(v2);
  *(_QWORD *)(a1 + 8) = 0;
}

uint64_t std::__function::__func<BOOL({block_pointer})(std::string const&),std::allocator<BOOL({block_pointer})(std::string const&)>,BOOL ()(std::string const&)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  _QWORD *v18;
  std::string *v19;
  _QWORD *v20;
  float v21;
  float v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  int8x8_t prime;
  void *v27;
  void *v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  uint8x8_t v32;
  unint64_t v33;
  uint8x8_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  void *v41;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = a1[1];
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*a1 + 8 * v3);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
            return;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3)
            break;
        }
      }
    }
  }
  v18 = operator new(0x28uLL);
  *v18 = 0;
  v18[1] = v11;
  v19 = (std::string *)(v18 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v18[4] = *(_QWORD *)(a3 + 16);
  }
  v20 = a1 + 2;
  v21 = (float)(unint64_t)(a1[3] + 1);
  v22 = *((float *)a1 + 8);
  if (!v12 || (float)(v22 * (float)v12) < v21)
  {
    v23 = 1;
    if (v12 >= 3)
      v23 = (v12 & (v12 - 1)) != 0;
    v24 = v23 | (2 * v12);
    v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25)
      prime = (int8x8_t)v25;
    else
      prime = (int8x8_t)v24;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v12 = a1[1];
    if (*(_QWORD *)&prime > v12)
      goto LABEL_39;
    if (*(_QWORD *)&prime < v12)
    {
      v33 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (v34 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        v33 = std::__next_prime(v33);
      }
      else
      {
        v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2)
          v33 = v35;
      }
      if (*(_QWORD *)&prime <= v33)
        prime = (int8x8_t)v33;
      if (*(_QWORD *)&prime >= v12)
      {
        v12 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v27 = operator new(8 * *(_QWORD *)&prime);
          v28 = (void *)*a1;
          *a1 = (uint64_t)v27;
          if (v28)
            operator delete(v28);
          v29 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v29++) = 0;
          while (*(_QWORD *)&prime != v29);
          v30 = (_QWORD *)*v20;
          if (*v20)
          {
            v31 = v30[1];
            v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(_QWORD *)&prime)
                v31 %= *(_QWORD *)&prime;
            }
            else
            {
              v31 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v31) = v20;
            v36 = (_QWORD *)*v30;
            if (*v30)
            {
              do
              {
                v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(_QWORD *)&prime)
                    v37 %= *(_QWORD *)&prime;
                }
                else
                {
                  v37 &= *(_QWORD *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v37))
                  {
                    *(_QWORD *)(*a1 + 8 * v37) = v30;
                    goto LABEL_64;
                  }
                  *v30 = *v36;
                  *v36 = **(_QWORD **)(*a1 + 8 * v37);
                  **(_QWORD **)(*a1 + 8 * v37) = v36;
                  v36 = v30;
                }
                v37 = v31;
LABEL_64:
                v30 = v36;
                v36 = (_QWORD *)*v36;
                v31 = v37;
              }
              while (v36);
            }
          }
          v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        v41 = (void *)*a1;
        *a1 = 0;
        if (v41)
          operator delete(v41);
        v12 = 0;
        a1[1] = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v38 = *a1;
  v39 = *(_QWORD **)(*a1 + 8 * v3);
  if (v39)
  {
    *v18 = *v39;
LABEL_81:
    *v39 = v18;
    goto LABEL_82;
  }
  *v18 = *v20;
  *v20 = v18;
  *(_QWORD *)(v38 + 8 * v3) = v20;
  if (*v18)
  {
    v40 = *(_QWORD *)(*v18 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v40 >= v12)
        v40 %= v12;
    }
    else
    {
      v40 &= v12 - 1;
    }
    v39 = (_QWORD *)(*a1 + 8 * v40);
    goto LABEL_81;
  }
LABEL_82:
  ++a1[3];
}

void sub_1840FF130(_Unwind_Exception *a1)
{
  void **v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100](0, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 39) < 0)
      operator delete(__p[2]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t __Block_byref_object_copy__5(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = a2[6];
  a2[6] = 0;
  *(_QWORD *)(result + 48) = v2;
  *(_QWORD *)(result + 56) = a2[7];
  a2[7] = 0;
  v5 = a2[8];
  v3 = a2 + 8;
  v4 = v5;
  *(_QWORD *)(result + 64) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 64;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__6(uint64_t a1)
{
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a1 + 48);
}

uint64_t ___Z42__HTTP2ServerPushMatchAcceptEncodingHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0)
    v2 = *(_QWORD *)(a2 + 8);
  if (v2)
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), a2, a2);
  return 1;
}

uint64_t ___Z42__HTTP2ServerPushMatchAcceptEncodingHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0)
    v2 = *(_QWORD *)(a2 + 8);
  if (!v2)
    return 1;
  result = (uint64_t)std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), a2);
  if (result)
    return 1;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  return result;
}

void ___ZN21HTTP2ServerPushStream18_getExpirationTimeEv_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(_QWORD *a1, uint64_t a2)
{
  int v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  int8x8_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;

  v4 = *(char *)(a2 + 23);
  if (v4 >= 0)
    v5 = (uint64_t *)a2;
  else
    v5 = *(uint64_t **)a2;
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_QWORD *)(a2 + 8);
  v7 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v5, v6);
  v8 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v8)
    return 0;
  v9 = v7;
  v10 = (uint8x8_t)vcnt_s8(v8);
  v10.i16[0] = vaddlv_u8(v10);
  v11 = v10.u32[0];
  if (v10.u32[0] > 1uLL)
  {
    v12 = v7;
    if (v7 >= *(_QWORD *)&v8)
      v12 = v7 % *(_QWORD *)&v8;
  }
  else
  {
    v12 = (*(_QWORD *)&v8 - 1) & v7;
  }
  v13 = *(unsigned __int8 ***)(*a1 + 8 * v12);
  if (!v13)
    return 0;
  for (i = *v13; i; i = *(unsigned __int8 **)i)
  {
    v15 = *((_QWORD *)i + 1);
    if (v15 == v9)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
        return i;
    }
    else
    {
      if (v11 > 1)
      {
        if (v15 >= *(_QWORD *)&v8)
          v15 %= *(_QWORD *)&v8;
      }
      else
      {
        v15 &= *(_QWORD *)&v8 - 1;
      }
      if (v15 != v12)
        return 0;
    }
  }
  return i;
}

uint64_t std::string::basic_string[abi:nn180100](uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

void ___ZN21HTTP2ServerPushStream18_getExpirationTimeEv_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void HTTP2ServerPushStream::_getFullURL(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned __int8 *v5;
  const std::string::value_type *v6;
  unsigned int *v7;
  size_t v8;
  std::string *p_p;
  const void *v10;
  int v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  int v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  std::string *v18;
  std::string::size_type size;
  unsigned __int8 *v20;
  const std::string::value_type *v21;
  unsigned __int8 *v22;
  const std::string::value_type *v23;
  int v24;
  const std::string::value_type *v25;
  std::string::size_type v26;
  std::string __p;

  v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0)
    v2 = *(_QWORD *)(a2 + 8);
  if (!v2)
  {
    std::string::basic_string[abi:nn180100]<0>(&__p, ":scheme");
    v5 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    v6 = ":443";
    if (v5)
    {
      v7 = (unsigned int *)(v5 + 40);
      if ((v5[63] & 0x80u) == 0)
        v8 = v5[63];
      else
        v8 = *((_QWORD *)v5 + 6);
      p_p = &__p;
      std::string::basic_string[abi:nn180100]((uint64_t)&__p, v8 + 3);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (v8)
      {
        if ((v5[63] & 0x80u) == 0)
          v10 = v5 + 40;
        else
          v10 = (const void *)*((_QWORD *)v5 + 5);
        memmove(p_p, v10, v8);
      }
      *(_DWORD *)((char *)&p_p->__r_.__value_.__l.__data_ + v8) = 3092282;
      if (*(char *)(a2 + 23) < 0)
        operator delete(*(void **)a2);
      *(std::string *)a2 = __p;
      v11 = (char)v5[63];
      if (v11 < 0)
      {
        if (*((_QWORD *)v5 + 6) != 4)
          goto LABEL_29;
        v7 = *(unsigned int **)v7;
      }
      else if (v11 != 4)
      {
        goto LABEL_29;
      }
      v12 = bswap32(*v7);
      v13 = v12 >= 0x68747470;
      v14 = v12 > 0x68747470;
      v15 = !v13;
      if (v14 == v15)
        v6 = ":80";
    }
LABEL_29:
    std::string::basic_string[abi:nn180100]<0>(&__p, ":authority");
    v16 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), (uint64_t)&__p);
    v17 = v16;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if (!v17)
      {
LABEL_46:
        std::string::basic_string[abi:nn180100]<0>(&__p, ":path");
        v20 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), (uint64_t)&__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (v20)
        {
          v23 = (const std::string::value_type *)*((_QWORD *)v20 + 5);
          v22 = v20 + 40;
          v21 = v23;
          v24 = (char)v22[23];
          if (v24 >= 0)
            v25 = (const std::string::value_type *)v22;
          else
            v25 = v21;
          if (v24 >= 0)
            v26 = v22[23];
          else
            v26 = *((_QWORD *)v22 + 1);
          std::string::append((std::string *)a2, v25, v26);
        }
        return;
      }
    }
    else if (!v16)
    {
      goto LABEL_46;
    }
    if ((char)v17[63] < 0)
      std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)v17 + 5), *((_QWORD *)v17 + 6));
    else
      __p = *(std::string *)(v17 + 40);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v18 = &__p;
    else
      v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    std::string::append((std::string *)a2, (const std::string::value_type *)v18, size);
    if (std::string::find(&__p, 58, 0) == -1)
      std::string::append((std::string *)a2, v6);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_46;
  }
}

void sub_1840FF6E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;

  v6 = *(char *)(a3 + 23);
  if (v6 >= 0)
    v7 = (uint64_t *)a3;
  else
    v7 = *(uint64_t **)a3;
  if (v6 >= 0)
    v8 = *(unsigned __int8 *)(a3 + 23);
  else
    v8 = *(_QWORD *)(a3 + 8);
  v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  if (!a2)
    return 0;
  v10 = v9;
  v11 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v11.i16[0] = vaddlv_u8(v11);
  v12 = v11.u32[0];
  if (v11.u32[0] > 1uLL)
  {
    v13 = v9;
    if (v9 >= a2)
      v13 = v9 % a2;
  }
  else
  {
    v13 = (a2 - 1) & v9;
  }
  v14 = *(unsigned __int8 ***)(a1 + 8 * v13);
  if (!v14)
    return 0;
  for (i = *v14; i; i = *(unsigned __int8 **)i)
  {
    v16 = *((_QWORD *)i + 1);
    if (v10 == v16)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a3))
        return i;
    }
    else
    {
      if (v12 > 1)
      {
        if (v16 >= a2)
          v16 %= a2;
      }
      else
      {
        v16 &= a2 - 1;
      }
      if (v16 != v13)
        return 0;
    }
  }
  return i;
}

void HTTP2ServerPushStream::~HTTP2ServerPushStream(void **this)
{
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void **v6;

  if (*((char *)this + 247) < 0)
    operator delete(this[28]);
  v2 = this[22];
  if (v2)
  {
    v3 = (uint64_t)this[23];
    v4 = this[22];
    if ((void *)v3 != v2)
    {
      do
        v3 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 16);
      while ((void *)v3 != v2);
      v4 = this[22];
    }
    this[23] = v2;
    operator delete(v4);
  }
  v5 = this[19];
  this[19] = 0;
  if (v5)
    ((void (*)(void))this[20])();
  v6 = this + 15;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:nn180100](&v6);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)(this + 10));
  v6 = this + 6;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:nn180100](&v6);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)(this + 1));
}

uint64_t HTTP2ServerPushStream::_invokeCompletionHadlers(uint64_t a1, int a2)
{
  uint64_t *v3;
  uint64_t *v4;
  char v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  BOOL v9;
  _BOOL4 v10;
  _QWORD *v12;
  uint64_t *v13;

  *(_DWORD *)(a1 + 256) = a2;
  v3 = *(uint64_t **)(a1 + 176);
  v4 = *(uint64_t **)(a1 + 184);
  if (v3 == v4)
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    do
    {
      v6 = *v3;
      if (*v3)
      {
        v7 = *(_QWORD *)(v6 + 8);
        v8 = *(_QWORD *)(v6 + 16);
        v9 = !v8 || (*(_QWORD *)(v6 + 16) & 1 | v7) == 0;
        v10 = !v9;
        if ((uint64_t (*)())v7 != BlockHolderVar<BOOL>::invoke_reseted || v10)
        {
          v12 = (_QWORD *)(v6 + (v8 >> 1));
          if ((v8 & 1) != 0)
            v7 = *(_QWORD *)(*v12 + v7);
          v5 = 1;
          ((void (*)(_QWORD *, uint64_t))v7)(v12, 1);
          --*(_DWORD *)(*(_QWORD *)a1 + 16);
        }
      }
      v3 += 2;
    }
    while (v3 != v4);
    v13 = *(uint64_t **)(a1 + 176);
    v3 = *(uint64_t **)(a1 + 184);
    if (v3 != v13)
    {
      do
      {
        v3 -= 2;
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v3);
      }
      while (v3 != v13);
      v3 = v13;
    }
  }
  *(_QWORD *)(a1 + 184) = v3;
  return v5 & 1;
}

void std::vector<SmartBlockWithArgs<BOOL>>::push_back[abi:nn180100](char **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  char *v7;
  unint64_t *v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  unint64_t *v18;
  unint64_t v19;
  __int128 v20;
  int64x2_t v21;
  uint64_t v22;
  void *v23;

  v7 = a1[1];
  v6 = (unint64_t)a1[2];
  if ((unint64_t)v7 >= v6)
  {
    v11 = *a1;
    v12 = (v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      abort();
    v14 = v6 - (_QWORD)v11;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    if (v15)
    {
      if (v15 >> 60)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v16 = (char *)operator new(16 * v15);
    }
    else
    {
      v16 = 0;
    }
    v17 = &v16[16 * v12];
    *(_QWORD *)v17 = a2;
    *((_QWORD *)v17 + 1) = a3;
    if (a3)
    {
      v18 = (unint64_t *)(a3 + 8);
      do
        v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
      v11 = *a1;
      v7 = a1[1];
    }
    v10 = v17 + 16;
    if (v7 == v11)
    {
      v21 = vdupq_n_s64((unint64_t)v7);
    }
    else
    {
      do
      {
        v20 = *((_OWORD *)v7 - 1);
        v7 -= 16;
        *((_OWORD *)v17 - 1) = v20;
        v17 -= 16;
        *(_QWORD *)v7 = 0;
        *((_QWORD *)v7 + 1) = 0;
      }
      while (v7 != v11);
      v21 = *(int64x2_t *)a1;
    }
    *a1 = v17;
    a1[1] = v10;
    a1[2] = &v16[16 * v15];
    v22 = v21.i64[1];
    v23 = (void *)v21.i64[0];
    while ((void *)v22 != v23)
      v22 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v22 - 16);
    if (v23)
      operator delete(v23);
  }
  else
  {
    *(_QWORD *)v7 = a2;
    *((_QWORD *)v7 + 1) = a3;
    if (a3)
    {
      v8 = (unint64_t *)(a3 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    v10 = v7 + 16;
  }
  a1[1] = v10;
}

void **std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](void ***a1, void **a2)
{
  void **result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    HTTP2ServerPushStream::~HTTP2ServerPushStream(result);
    JUMPOUT(0x186DB748CLL);
  }
  return result;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,0>(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>(_QWORD *a1, int a2)
{
  unint64_t v2;
  uint8x8_t v3;
  unint64_t v4;
  uint64_t **v5;
  uint64_t *result;
  unint64_t v7;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
      v4 = a2 % v2;
  }
  else
  {
    v4 = (v2 - 1) & a2;
  }
  v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  for (result = *v5; result; result = (uint64_t *)*result)
  {
    v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2)
        return result;
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2)
          v7 %= v2;
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4)
        return 0;
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::__erase_unique<int>(uint64_t *a1, int a2)
{
  unint64_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t **v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;

  v2 = a1[1];
  if (v2)
  {
    v3 = a2;
    v4 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      v5 = a2;
      if (v2 <= a2)
        v5 = a2 % v2;
    }
    else
    {
      v5 = (v2 - 1) & a2;
    }
    v6 = *a1;
    v7 = *(uint64_t ***)(*a1 + 8 * v5);
    if (v7)
    {
      v8 = *v7;
      if (v8)
      {
        v9 = v2 - 1;
        do
        {
          v10 = v8[1];
          if (v10 == a2)
          {
            if (*((_DWORD *)v8 + 4) == a2)
            {
              if (v4.u32[0] > 1uLL)
              {
                if (v2 <= a2)
                  v3 = a2 % v2;
              }
              else
              {
                v3 = v9 & a2;
              }
              v11 = *(uint64_t **)(v6 + 8 * v3);
              do
              {
                v12 = v11;
                v11 = (uint64_t *)*v11;
              }
              while (v11 != v8);
              if (v12 == a1 + 2)
                goto LABEL_36;
              v13 = v12[1];
              if (v4.u32[0] > 1uLL)
              {
                if (v13 >= v2)
                  v13 %= v2;
              }
              else
              {
                v13 &= v9;
              }
              if (v13 != v3)
              {
LABEL_36:
                if (!*v8)
                  goto LABEL_37;
                v14 = *(_QWORD *)(*v8 + 8);
                if (v4.u32[0] > 1uLL)
                {
                  if (v14 >= v2)
                    v14 %= v2;
                }
                else
                {
                  v14 &= v9;
                }
                if (v14 != v3)
LABEL_37:
                  *(_QWORD *)(v6 + 8 * v3) = 0;
              }
              v15 = *v8;
              if (*v8)
              {
                v16 = *(_QWORD *)(v15 + 8);
                if (v4.u32[0] > 1uLL)
                {
                  if (v16 >= v2)
                    v16 %= v2;
                }
                else
                {
                  v16 &= v9;
                }
                if (v16 != v3)
                {
                  *(_QWORD *)(*a1 + 8 * v16) = v12;
                  v15 = *v8;
                }
              }
              *v12 = v15;
              *v8 = 0;
              --a1[3];
              operator delete(v8);
              return;
            }
          }
          else
          {
            if (v4.u32[0] > 1uLL)
            {
              if (v10 >= v2)
                v10 %= v2;
            }
            else
            {
              v10 &= v9;
            }
            if (v10 != v5)
              return;
          }
          v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
    }
  }
}

void std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__erase_unique<std::reference_wrapper<HTTP2ServerPushStream const>>(_QWORD *a1, uint64_t *a2)
{
  _QWORD *v3;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;

  v3 = std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::find<std::reference_wrapper<HTTP2ServerPushStream const>>(a1, a2);
  if (v3)
  {
    v4 = (int8x8_t)a1[1];
    v5 = v3[1];
    v6 = (uint8x8_t)vcnt_s8(v4);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      if (v5 >= *(_QWORD *)&v4)
        v5 %= *(_QWORD *)&v4;
    }
    else
    {
      v5 &= *(_QWORD *)&v4 - 1;
    }
    v7 = *(_QWORD **)(*a1 + 8 * v5);
    do
    {
      v8 = v7;
      v7 = (_QWORD *)*v7;
    }
    while (v7 != v3);
    if (v8 == a1 + 2)
      goto LABEL_20;
    v9 = v8[1];
    if (v6.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v4)
        v9 %= *(_QWORD *)&v4;
    }
    else
    {
      v9 &= *(_QWORD *)&v4 - 1;
    }
    if (v9 != v5)
    {
LABEL_20:
      if (!*v3)
        goto LABEL_21;
      v10 = *(_QWORD *)(*v3 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(_QWORD *)&v4)
          v10 %= *(_QWORD *)&v4;
      }
      else
      {
        v10 &= *(_QWORD *)&v4 - 1;
      }
      if (v10 != v5)
LABEL_21:
        *(_QWORD *)(*a1 + 8 * v5) = 0;
    }
    v11 = *v3;
    if (*v3)
    {
      v12 = *(_QWORD *)(v11 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v12 >= *(_QWORD *)&v4)
          v12 %= *(_QWORD *)&v4;
      }
      else
      {
        v12 &= *(_QWORD *)&v4 - 1;
      }
      if (v12 != v5)
      {
        *(_QWORD *)(*a1 + 8 * v12) = v8;
        v11 = *v3;
      }
    }
    *v8 = v11;
    *v3 = 0;
    --a1[3];
    operator delete(v3);
  }
}

_QWORD *HTTP2ServerPush::_removeFromUrlToServerPushStreamsMap(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;
  char *v5;
  char *v6;
  _QWORD *v7;
  int64_t v8;

  result = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 88, a2, a2);
  v6 = (char *)result[5];
  v5 = (char *)result[6];
  if (v6 != v5)
  {
    v7 = result;
    while (*(_QWORD *)v6 != a3)
    {
      v6 += 8;
      if (v6 == v5)
        return result;
    }
    v8 = v5 - (v6 + 8);
    if (v5 != v6 + 8)
      result = memmove(v6, v6 + 8, v5 - (v6 + 8));
    v7[6] = &v6[v8];
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  std::string *v20;
  float v21;
  float v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  int8x8_t prime;
  void *v27;
  void *v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  uint8x8_t v32;
  unint64_t v33;
  uint8x8_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  unsigned __int8 **v38;
  unint64_t v39;
  void *v41;
  _QWORD v42[2];
  char v43;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
            return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3)
            break;
        }
      }
    }
  }
  v18 = (_QWORD *)(a1 + 16);
  v19 = operator new(0x40uLL);
  v42[0] = v19;
  v42[1] = a1 + 16;
  v43 = 0;
  *v19 = 0;
  v19[1] = v11;
  v20 = (std::string *)(v19 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v20, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v20->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v19[4] = *(_QWORD *)(a3 + 16);
  }
  v19[5] = 0;
  v19[6] = 0;
  v19[7] = 0;
  v43 = 1;
  v21 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v22 = *(float *)(a1 + 32);
  if (!v12 || (float)(v22 * (float)v12) < v21)
  {
    v23 = 1;
    if (v12 >= 3)
      v23 = (v12 & (v12 - 1)) != 0;
    v24 = v23 | (2 * v12);
    v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25)
      prime = (int8x8_t)v25;
    else
      prime = (int8x8_t)v24;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v12 = *(_QWORD *)(a1 + 8);
    if (*(_QWORD *)&prime > v12)
      goto LABEL_39;
    if (*(_QWORD *)&prime < v12)
    {
      v33 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v12 < 3 || (v34 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        v33 = std::__next_prime(v33);
      }
      else
      {
        v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2)
          v33 = v35;
      }
      if (*(_QWORD *)&prime <= v33)
        prime = (int8x8_t)v33;
      if (*(_QWORD *)&prime >= v12)
      {
        v12 = *(_QWORD *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v27 = operator new(8 * *(_QWORD *)&prime);
          v28 = *(void **)a1;
          *(_QWORD *)a1 = v27;
          if (v28)
            operator delete(v28);
          v29 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v29++) = 0;
          while (*(_QWORD *)&prime != v29);
          v30 = (_QWORD *)*v18;
          if (*v18)
          {
            v31 = v30[1];
            v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(_QWORD *)&prime)
                v31 %= *(_QWORD *)&prime;
            }
            else
            {
              v31 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v31) = v18;
            v36 = (_QWORD *)*v30;
            if (*v30)
            {
              do
              {
                v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(_QWORD *)&prime)
                    v37 %= *(_QWORD *)&prime;
                }
                else
                {
                  v37 &= *(_QWORD *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v37))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v37) = v30;
                    goto LABEL_64;
                  }
                  *v30 = *v36;
                  *v36 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v37);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v37) = v36;
                  v36 = v30;
                }
                v37 = v31;
LABEL_64:
                v30 = v36;
                v36 = (_QWORD *)*v36;
                v31 = v37;
              }
              while (v36);
            }
          }
          v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        v41 = *(void **)a1;
        *(_QWORD *)a1 = 0;
        if (v41)
          operator delete(v41);
        v12 = 0;
        *(_QWORD *)(a1 + 8) = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v38 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
  i = (unsigned __int8 *)v42[0];
  if (v38)
  {
    *(_QWORD *)v42[0] = *v38;
LABEL_81:
    *v38 = i;
    goto LABEL_82;
  }
  *(_QWORD *)v42[0] = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = v18;
  if (*(_QWORD *)i)
  {
    v39 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v39 >= v12)
        v39 %= v12;
    }
    else
    {
      v39 &= v12 - 1;
    }
    v38 = (unsigned __int8 **)(*(_QWORD *)a1 + 8 * v39);
    goto LABEL_81;
  }
LABEL_82:
  v42[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>>>>::reset[abi:nn180100]((uint64_t)v42);
  return i;
}

void sub_1841003EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,0>((uint64_t)v1 + 16);
    operator delete(v1);
  }
}

_QWORD *std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::find<std::reference_wrapper<HTTP2ServerPushStream const>>(_QWORD *a1, uint64_t *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;

  v4 = HTTP2ServerPushStream::Hasher::operator()(*a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(_QWORD **)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = (_QWORD *)*v10;
  if (*v10)
  {
    do
    {
      v12 = v11[1];
      if (v12 == v6)
      {
        if ((HTTP2ServerPushStream::operator==(v11[2], *a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v12 >= *(_QWORD *)&v5)
            v12 %= *(_QWORD *)&v5;
        }
        else
        {
          v12 &= *(_QWORD *)&v5 - 1;
        }
        if (v12 != v9)
          return 0;
      }
      v11 = (_QWORD *)*v11;
    }
    while (v11);
  }
  return v11;
}

unint64_t HTTP2ServerPushStream::Hasher::operator()(uint64_t a1)
{
  unsigned __int8 *v2;
  uint64_t *v3;
  unsigned __int8 *v4;
  uint64_t *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  void *__p[2];
  char v11;

  if (!*(_BYTE *)(a1 + 72))
    __assert_rtn("operator()", "HTTP2ServerPush.h", 45, "stream._promised_headers_complete");
  std::string::basic_string[abi:nn180100]<0>(__p, ":path");
  v2 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), (uint64_t)__p);
  if (v11 < 0)
    operator delete(__p[0]);
  if (!v2)
    __assert_rtn("operator()", "HTTP2ServerPush.h", 47, "found != stream._promised_headers.end()");
  v5 = (uint64_t *)*((_QWORD *)v2 + 5);
  v4 = v2 + 40;
  v3 = v5;
  v6 = (char)v4[23];
  if (v6 >= 0)
    v7 = (uint64_t *)v4;
  else
    v7 = v3;
  if (v6 >= 0)
    v8 = v4[23];
  else
    v8 = *((_QWORD *)v4 + 1);
  return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
}

uint64_t HTTP2ServerPushStream::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  BOOL v3;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  const void **v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  const void **v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;

  if (*(_BYTE *)(a1 + 72))
    v2 = *(_BYTE *)(a2 + 72) == 0;
  else
    v2 = 1;
  if (v2)
    __assert_rtn("operator==", "HTTP2ServerPush.h", 33, "_promised_headers_complete && other._promised_headers_complete");
  if (*(_BYTE *)(a1 + 216))
    v3 = *(_BYTE *)(a2 + 216) == 0;
  else
    v3 = 1;
  if (v3)
    __assert_rtn("operator==", "HTTP2ServerPush.h", 34, "_valid && other._valid");
  if (*(_QWORD *)(a1 + 32) != *(_QWORD *)(a2 + 32))
    return 0;
  v4 = *(uint64_t **)(a1 + 24);
  if (!v4)
    return 1;
  v5 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  do
  {
    v7 = (const void **)(v4 + 2);
    result = (uint64_t)std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(v5, v6, (uint64_t)(v4 + 2));
    if (!result)
      break;
    v9 = result;
    v10 = *((unsigned __int8 *)v4 + 39);
    if ((v10 & 0x80u) == 0)
      v11 = *((unsigned __int8 *)v4 + 39);
    else
      v11 = v4[3];
    v12 = *(unsigned __int8 *)(result + 39);
    v13 = (char)v12;
    if ((v12 & 0x80u) != 0)
      v12 = *(_QWORD *)(result + 24);
    if (v11 != v12)
      return 0;
    if (v13 >= 0)
      v14 = (unsigned __int8 *)(result + 16);
    else
      v14 = *(unsigned __int8 **)(result + 16);
    if ((v10 & 0x80) != 0)
    {
      if (memcmp(*v7, v14, v4[3]))
        return 0;
    }
    else if (*((_BYTE *)v4 + 39))
    {
      while (*(unsigned __int8 *)v7 == *v14)
      {
        v7 = (const void **)((char *)v7 + 1);
        ++v14;
        if (!--v10)
          goto LABEL_28;
      }
      return 0;
    }
LABEL_28:
    v15 = *((unsigned __int8 *)v4 + 63);
    if ((v15 & 0x80u) == 0)
      v16 = *((unsigned __int8 *)v4 + 63);
    else
      v16 = v4[6];
    v17 = *(unsigned __int8 *)(v9 + 63);
    v18 = (char)v17;
    if ((v17 & 0x80u) != 0)
      v17 = *(_QWORD *)(v9 + 48);
    if (v16 != v17)
      return 0;
    v19 = (const void **)(v4 + 5);
    v22 = *(unsigned __int8 **)(v9 + 40);
    v21 = (unsigned __int8 *)(v9 + 40);
    v20 = v22;
    if (v18 >= 0)
      v23 = v21;
    else
      v23 = v20;
    if ((v15 & 0x80) != 0)
    {
      if (memcmp(*v19, v23, v4[6]))
        return 0;
    }
    else if (*((_BYTE *)v4 + 63))
    {
      while (*(unsigned __int8 *)v19 == *v23)
      {
        v19 = (const void **)((char *)v19 + 1);
        ++v23;
        if (!--v15)
          goto LABEL_43;
      }
      return 0;
    }
LABEL_43:
    v4 = (uint64_t *)*v4;
    result = 1;
  }
  while (v4);
  return result;
}

uint64_t ___ZN15HTTP2ServerPush9_makeRoomEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 278;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void *HTTP2ServerPush::_removeStream(HTTP2ServerPush *this, int a2, int a3)
{
  uint64_t *v6;
  void *result;
  uint64_t v8;
  void ***v9;
  void ***v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  void ***v14;
  int v15;
  unint64_t v16;
  void ***v17;
  void ***v18;
  void **v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  void ***v23;
  void ***v24;
  void **v25;
  uint64_t v26;
  void **v27;
  HTTP2ServerPushStream *v28;

  v6 = (uint64_t *)((char *)this + 48);
  result = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)this + 6, a2);
  if (!result)
    return result;
  v8 = *((_QWORD *)result + 3);
  if (!v8)
    return result;
  v28 = (HTTP2ServerPushStream *)*((_QWORD *)result + 3);
  v10 = (void ***)*((_QWORD *)this + 3);
  v9 = (void ***)*((_QWORD *)this + 4);
  if (v9 == v10)
    goto LABEL_15;
  v11 = v9 - v10;
  v12 = *(_DWORD *)(v8 + 172);
  while (1)
  {
    v13 = v11 >> 1;
    v14 = &v10[v11 >> 1];
    v15 = *((_DWORD *)*v14 + 43);
    if (v15 >= v12)
      break;
    v10 = v14 + 1;
    v13 = v11 + ~v13;
LABEL_8:
    v11 = v13;
    if (!v13)
      goto LABEL_15;
  }
  if (v12 < v15)
    goto LABEL_8;
  if (v11 >= 2)
  {
    do
    {
      v16 = v13 >> 1;
      v17 = &v10[v13 >> 1];
      v19 = *v17;
      v18 = v17 + 1;
      v13 += ~(v13 >> 1);
      if (*((_DWORD *)v19 + 43) < v12)
        v10 = v18;
      else
        v13 = v16;
    }
    while (v13);
  }
LABEL_15:
  v28 = 0;
  v20 = (uint64_t)*v10;
  if (*((_DWORD *)*v10 + 43) != a2)
    __assert_rtn("_removeStream", "HTTP2ServerPush.cpp", 313, "(*bounds.first)->_stream_id == stream_id");
  v27 = *v10;
  v21 = *(NSObject **)(v8 + 152);
  if (v21)
    *((_QWORD *)this + 1) -= dispatch_data_get_size(v21);
  if (*(_BYTE *)(v8 + 216) && a3 && *(_BYTE *)(v8 + 72))
  {
    std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__erase_unique<std::reference_wrapper<HTTP2ServerPushStream const>>((_QWORD *)this + 16, (uint64_t *)&v27);
    v22 = (uint64_t)(*v10 + 28);
    HTTP2ServerPushStream::_getFullURL((uint64_t)(*v10 + 1), v22);
    HTTP2ServerPush::_removeFromUrlToServerPushStreamsMap((uint64_t)this, v22, v20);
    v9 = (void ***)*((_QWORD *)this + 4);
  }
  v23 = v10 + 1;
  if (v10 + 1 != v9)
  {
    do
    {
      v10 = v23;
      v24 = v23 - 1;
      v25 = *v23;
      *v23++ = 0;
      std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](v24, v25);
    }
    while (v23 != v9);
    v9 = (void ***)*((_QWORD *)this + 4);
  }
  while (v9 != v10)
    std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](--v9, 0);
  *((_QWORD *)this + 4) = v10;
  std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::__erase_unique<int>(v6, a2);
  result = v28;
  if (v28)
  {
    HTTP2ServerPushStream::~HTTP2ServerPushStream((void **)v28);
    return (void *)MEMORY[0x186DB748C](v26);
  }
  return result;
}

void sub_184100A2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100]((void ***)va, 0);
  _Unwind_Resume(a1);
}

uint64_t HTTP2ServerPush::createNewForStreamId(HTTP2ServerPush *this, int a2, NSURLRequestCachePolicy a3, int a4)
{
  unint64_t v4;
  int v9;
  uint64_t result;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint8x8_t v14;
  uint64_t **v15;
  uint64_t *i;
  unint64_t v17;
  _QWORD *v18;
  float v19;
  float v20;
  _BOOL8 v21;
  unint64_t v22;
  unint64_t v23;
  int8x8_t prime;
  void *v25;
  void *v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint8x8_t v30;
  unint64_t v31;
  uint8x8_t v32;
  uint64_t v33;
  _QWORD *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  unint64_t v39;
  void ***v40;
  char *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t *v44;
  char *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  void ***v60;
  void ***v61;
  void ***v62;
  void ***v63;
  void ***v64;
  void **v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t *v70;
  unint64_t v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  int64x2_t v75;
  void ***v76;
  void ***v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void **v82;
  void *v83;
  unint64_t v84;
  char *v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  int64x2_t v94;
  char *v95;
  void ***v96;
  void ***v97;
  void ***v98;
  void **v99;
  void ***v100;
  void **v101;
  char *v102;
  char *v103;
  void **v104;
  char *v105;
  __int128 v106;
  char *v107;
  char *v108;
  uint64_t v109;
  int64x2_t v110;
  unint64_t v111;
  char *v112;

  if (a4)
  {
    v9 = *((_DWORD *)this + 43);
    if (v9 <= a2)
    {
      if (v9 < a2)
      {
        do
        {
          std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((uint64_t)this + 176, v9, v9);
          std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((uint64_t)this + 216, v9, v9);
          ++v9;
        }
        while (a2 != v9);
      }
      std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((uint64_t)this + 216, a2, a2);
      *((_DWORD *)this + 43) = a2 + 1;
    }
    else
    {
      result = std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>((uint64_t *)this + 22, a2);
      if (!result)
        return result;
    }
  }
  v11 = operator new();
  *(_QWORD *)v11 = this;
  *(_OWORD *)(v11 + 8) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  *(_DWORD *)(v11 + 40) = 1065353216;
  *(_OWORD *)(v11 + 80) = 0u;
  *(_OWORD *)(v11 + 96) = 0u;
  *(_QWORD *)(v11 + 56) = 0;
  *(_QWORD *)(v11 + 64) = 0;
  *(_QWORD *)(v11 + 48) = 0;
  *(_BYTE *)(v11 + 72) = 0;
  *(_DWORD *)(v11 + 112) = 1065353216;
  *(_QWORD *)(v11 + 128) = 0;
  *(_QWORD *)(v11 + 136) = 0;
  *(_QWORD *)(v11 + 120) = 0;
  *(_BYTE *)(v11 + 144) = 0;
  *(_QWORD *)(v11 + 152) = 0;
  *(_QWORD *)(v11 + 160) = HTTP2ServerPushStream::safe_data_deleter;
  *(_BYTE *)(v11 + 168) = 0;
  *(_QWORD *)(v11 + 176) = 0;
  *(_QWORD *)(v11 + 184) = 0;
  *(_QWORD *)(v11 + 192) = 0;
  *(_QWORD *)(v11 + 200) = 0xFFFF0000FFFFLL;
  *(_QWORD *)(v11 + 208) = 0;
  *(_BYTE *)(v11 + 216) = 1;
  *(_OWORD *)(v11 + 224) = 0u;
  *(_OWORD *)(v11 + 240) = 0u;
  *(_DWORD *)(v11 + 256) = 0;
  v104 = (void **)v11;
  *(_DWORD *)(v11 + 172) = a2;
  *(_QWORD *)(v11 + 248) = a3;
  v12 = a2;
  v13 = *((_QWORD *)this + 7);
  if (v13)
  {
    v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    if (v14.u32[0] > 1uLL)
    {
      v4 = a2;
      if (v13 <= a2)
        v4 = a2 % v13;
    }
    else
    {
      v4 = (v13 - 1) & a2;
    }
    v15 = *(uint64_t ***)(*((_QWORD *)this + 6) + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = (uint64_t *)*i)
      {
        v17 = i[1];
        if (v17 == a2)
        {
          if (*((_DWORD *)i + 4) == a2)
            goto LABEL_81;
        }
        else
        {
          if (v14.u32[0] > 1uLL)
          {
            if (v17 >= v13)
              v17 %= v13;
          }
          else
          {
            v17 &= v13 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  v18 = operator new(0x20uLL);
  *v18 = 0;
  v18[1] = a2;
  *((_DWORD *)v18 + 4) = a2;
  v18[3] = v11;
  v19 = (float)(unint64_t)(*((_QWORD *)this + 9) + 1);
  v20 = *((float *)this + 20);
  if (!v13 || (float)(v20 * (float)v13) < v19)
  {
    v21 = 1;
    if (v13 >= 3)
      v21 = (v13 & (v13 - 1)) != 0;
    v22 = v21 | (2 * v13);
    v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23)
      prime = (int8x8_t)v23;
    else
      prime = (int8x8_t)v22;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v13 = *((_QWORD *)this + 7);
    }
    if (*(_QWORD *)&prime > v13)
      goto LABEL_37;
    if (*(_QWORD *)&prime < v13)
    {
      v31 = vcvtps_u32_f32((float)*((unint64_t *)this + 9) / *((float *)this + 20));
      if (v13 < 3 || (v32 = (uint8x8_t)vcnt_s8((int8x8_t)v13), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        v31 = std::__next_prime(v31);
      }
      else
      {
        v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2)
          v31 = v33;
      }
      if (*(_QWORD *)&prime <= v31)
        prime = (int8x8_t)v31;
      if (*(_QWORD *)&prime >= v13)
      {
        v13 = *((_QWORD *)this + 7);
      }
      else
      {
        if (prime)
        {
LABEL_37:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v25 = operator new(8 * *(_QWORD *)&prime);
          v26 = (void *)*((_QWORD *)this + 6);
          *((_QWORD *)this + 6) = v25;
          if (v26)
            operator delete(v26);
          v27 = 0;
          *((int8x8_t *)this + 7) = prime;
          do
            *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v27++) = 0;
          while (*(_QWORD *)&prime != v27);
          v28 = (_QWORD *)*((_QWORD *)this + 8);
          if (v28)
          {
            v29 = v28[1];
            v30 = (uint8x8_t)vcnt_s8(prime);
            v30.i16[0] = vaddlv_u8(v30);
            if (v30.u32[0] > 1uLL)
            {
              if (v29 >= *(_QWORD *)&prime)
                v29 %= *(_QWORD *)&prime;
            }
            else
            {
              v29 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v29) = (char *)this + 64;
            v34 = (_QWORD *)*v28;
            if (*v28)
            {
              do
              {
                v35 = v34[1];
                if (v30.u32[0] > 1uLL)
                {
                  if (v35 >= *(_QWORD *)&prime)
                    v35 %= *(_QWORD *)&prime;
                }
                else
                {
                  v35 &= *(_QWORD *)&prime - 1;
                }
                if (v35 != v29)
                {
                  v36 = *((_QWORD *)this + 6);
                  if (!*(_QWORD *)(v36 + 8 * v35))
                  {
                    *(_QWORD *)(v36 + 8 * v35) = v28;
                    goto LABEL_62;
                  }
                  *v28 = *v34;
                  *v34 = **(_QWORD **)(*((_QWORD *)this + 6) + 8 * v35);
                  **(_QWORD **)(*((_QWORD *)this + 6) + 8 * v35) = v34;
                  v34 = v28;
                }
                v35 = v29;
LABEL_62:
                v28 = v34;
                v34 = (_QWORD *)*v34;
                v29 = v35;
              }
              while (v34);
            }
          }
          v13 = (unint64_t)prime;
          goto LABEL_66;
        }
        v83 = (void *)*((_QWORD *)this + 6);
        *((_QWORD *)this + 6) = 0;
        if (v83)
          operator delete(v83);
        v13 = 0;
        *((_QWORD *)this + 7) = 0;
      }
    }
LABEL_66:
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v13 <= v12)
        v4 = v12 % v13;
      else
        v4 = v12;
    }
    else
    {
      v4 = (v13 - 1) & v12;
    }
  }
  v37 = *((_QWORD *)this + 6);
  v38 = *(_QWORD **)(v37 + 8 * v4);
  if (v38)
  {
    *v18 = *v38;
  }
  else
  {
    *v18 = *((_QWORD *)this + 8);
    *((_QWORD *)this + 8) = v18;
    *(_QWORD *)(v37 + 8 * v4) = (char *)this + 64;
    if (!*v18)
      goto LABEL_80;
    v39 = *(_QWORD *)(*v18 + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v39 >= v13)
        v39 %= v13;
    }
    else
    {
      v39 &= v13 - 1;
    }
    v38 = (_QWORD *)(*((_QWORD *)this + 6) + 8 * v39);
  }
  *v38 = v18;
LABEL_80:
  ++*((_QWORD *)this + 9);
LABEL_81:
  if (a4)
  {
    v41 = (char *)*((_QWORD *)this + 3);
    v40 = (void ***)*((_QWORD *)this + 4);
    if (v40 == (void ***)v41)
    {
      v41 = (char *)*((_QWORD *)this + 4);
    }
    else
    {
      v42 = ((char *)v40 - v41) >> 3;
      do
      {
        v43 = v42 >> 1;
        v44 = (uint64_t *)&v41[8 * (v42 >> 1)];
        v46 = *v44;
        v45 = (char *)(v44 + 1);
        v42 += ~(v42 >> 1);
        if (*(_DWORD *)(v11 + 172) < *(_DWORD *)(v46 + 172))
          v42 = v43;
        else
          v41 = v45;
      }
      while (v42);
    }
    v56 = *((_QWORD *)this + 5);
    v57 = (char *)*((_QWORD *)this + 3);
    v58 = v41 - v57;
    v59 = (v41 - v57) >> 3;
    v60 = (void ***)&v57[(v41 - v57) & 0xFFFFFFFFFFFFFFF8];
    if ((unint64_t)v40 >= v56)
    {
      v66 = (((char *)v40 - v57) >> 3) + 1;
      if (v66 >> 61)
        abort();
      v67 = v56 - (_QWORD)v57;
      if (v67 >> 2 > v66)
        v66 = v67 >> 2;
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8)
        v68 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v68 = v66;
      v108 = (char *)this + 40;
      if (v68)
        v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v68);
      else
        v69 = 0;
      v76 = (void ***)(v68 + 8 * v59);
      v105 = (char *)v68;
      *(_QWORD *)&v106 = v76;
      *((_QWORD *)&v106 + 1) = v76;
      v107 = (char *)(v68 + 8 * v69);
      v77 = v76;
      if (v59 == v69)
      {
        if (v58 < 1)
        {
          if (v41 == v57)
            v84 = 1;
          else
            v84 = v58 >> 2;
          v112 = (char *)this + 40;
          v85 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v84);
          v87 = (uint64_t *)v106;
          v88 = *((_QWORD *)&v106 + 1) - v106;
          if (*((_QWORD *)&v106 + 1) == (_QWORD)v106)
          {
            v94 = vdupq_n_s64(v106);
            v90 = (unint64_t)&v85[8 * (v84 >> 2)];
          }
          else
          {
            v89 = v88 >> 3;
            v90 = (unint64_t)&v85[8 * (v84 >> 2) + (v88 & 0xFFFFFFFFFFFFFFF8)];
            v91 = 8 * v89;
            v92 = &v85[8 * (v84 >> 2)];
            do
            {
              v93 = *v87;
              *v87++ = 0;
              *(_QWORD *)v92 = v93;
              v92 += 8;
              v91 -= 8;
            }
            while (v91);
            v94 = (int64x2_t)v106;
          }
          v95 = v107;
          v109 = (uint64_t)v105;
          v105 = v85;
          *(_QWORD *)&v106 = &v85[8 * (v84 >> 2)];
          v110 = v94;
          *((_QWORD *)&v106 + 1) = v90;
          v107 = &v85[8 * v86];
          v111 = (unint64_t)v95;
          std::__split_buffer<std::unique_ptr<HTTP2ServerPushStream>>::~__split_buffer((uint64_t)&v109);
          v77 = (void ***)*((_QWORD *)&v106 + 1);
          v76 = (void ***)v106;
        }
        else
        {
          v78 = v59 + 2;
          if (v59 >= -1)
            v78 = v59 + 1;
          v76 -= v78 >> 1;
          v77 = v76;
        }
      }
      *v77 = v104;
      v96 = v77 + 1;
      v97 = (void ***)*((_QWORD *)this + 3);
      if (v97 != v60)
      {
        v98 = v60;
        do
        {
          v99 = *--v98;
          *v98 = 0;
          *--v76 = v99;
        }
        while (v98 != v97);
      }
      *(_QWORD *)&v106 = v76;
      v100 = (void ***)*((_QWORD *)this + 4);
      if (v100 != v60)
      {
        do
        {
          v101 = *v60;
          *v60++ = 0;
          *v96++ = v101;
        }
        while (v60 != v100);
        v76 = (void ***)v106;
        v60 = (void ***)*((_QWORD *)this + 4);
      }
      v102 = (char *)*((_QWORD *)this + 3);
      *((_QWORD *)this + 3) = v76;
      *((_QWORD *)this + 4) = v96;
      v103 = (char *)*((_QWORD *)this + 5);
      *((_QWORD *)this + 5) = v107;
      *((_QWORD *)&v106 + 1) = v60;
      v107 = v103;
      v105 = v102;
      *(_QWORD *)&v106 = v102;
      std::__split_buffer<std::unique_ptr<HTTP2ServerPushStream>>::~__split_buffer((uint64_t)&v105);
    }
    else if (v60 == v40)
    {
      *v40 = v104;
      *((_QWORD *)this + 4) = v40 + 1;
    }
    else
    {
      v61 = v60 + 1;
      v62 = v40 - 1;
      if ((unint64_t)v40 < 8)
      {
        v64 = (void ***)*((_QWORD *)this + 4);
      }
      else
      {
        v63 = v40 - 1;
        v64 = (void ***)*((_QWORD *)this + 4);
        do
        {
          v65 = *v63;
          *v63++ = 0;
          *v64++ = v65;
        }
        while (v63 < v40);
      }
      *((_QWORD *)this + 4) = v64;
      if (v40 != v61)
      {
        v80 = 8 * (v40 - v61);
        v81 = (uint64_t)&v57[8 * v59 - 8];
        do
        {
          v82 = *(void ***)(v81 + v80);
          *(_QWORD *)(v81 + v80) = 0;
          std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](v62--, v82);
          v80 -= 8;
        }
        while (v80);
      }
      std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](v60, v104);
    }
  }
  else
  {
    v47 = *((_QWORD *)this + 5);
    v48 = (uint64_t *)*((_QWORD *)this + 4);
    if ((unint64_t)v48 >= v47)
    {
      v50 = *((_QWORD *)this + 3);
      v51 = ((uint64_t)v48 - v50) >> 3;
      if ((unint64_t)(v51 + 1) >> 61)
        abort();
      v52 = v47 - v50;
      v53 = v52 >> 2;
      if (v52 >> 2 <= (unint64_t)(v51 + 1))
        v53 = v51 + 1;
      if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8)
        v54 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v54 = v53;
      v112 = (char *)this + 40;
      if (v54)
        v54 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v54);
      else
        v55 = 0;
      v70 = (uint64_t *)(v54 + 8 * v51);
      v71 = v54 + 8 * v55;
      v111 = v71;
      *v70 = v11;
      v49 = v70 + 1;
      v110.i64[1] = (uint64_t)(v70 + 1);
      v73 = (_QWORD *)*((_QWORD *)this + 3);
      v72 = (_QWORD *)*((_QWORD *)this + 4);
      if (v72 == v73)
      {
        v75 = vdupq_n_s64((unint64_t)v72);
      }
      else
      {
        do
        {
          v74 = *--v72;
          *v72 = 0;
          *--v70 = v74;
        }
        while (v72 != v73);
        v75 = *(int64x2_t *)((char *)this + 24);
        v49 = (_QWORD *)v110.i64[1];
        v71 = v111;
      }
      *((_QWORD *)this + 3) = v70;
      *((_QWORD *)this + 4) = v49;
      v110 = v75;
      v79 = *((_QWORD *)this + 5);
      *((_QWORD *)this + 5) = v71;
      v111 = v79;
      v109 = v75.i64[0];
      std::__split_buffer<std::unique_ptr<HTTP2ServerPushStream>>::~__split_buffer((uint64_t)&v109);
    }
    else
    {
      *v48 = v11;
      v49 = v48 + 1;
    }
    *((_QWORD *)this + 4) = v49;
  }
  return 1;
}

void sub_1841012F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void **v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, void **);
  std::__split_buffer<std::unique_ptr<HTTP2ServerPushStream>>::~__split_buffer((uint64_t)va1);
  std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100]((void ***)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(uint64_t a1, int a2, int a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  uint64_t **v9;
  uint64_t *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2)
            return;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = operator new(0x18uLL);
  *v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = a3;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *v12 = *v20;
LABEL_38:
    *v20 = v12;
    goto LABEL_39;
  }
  *v12 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    v21 = *(_QWORD *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
}

void sub_184101528(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>(uint64_t *a1, int a2)
{
  unint64_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t v6;
  void **v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t *v12;
  uint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = a2;
  v4 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = a2;
    if (v2 <= a2)
      v5 = a2 % v2;
  }
  else
  {
    v5 = (v2 - 1) & a2;
  }
  v6 = *a1;
  v7 = *(void ***)(*a1 + 8 * v5);
  if (!v7)
    return 0;
  v8 = (uint64_t *)*v7;
  if (!v8)
    return 0;
  v9 = v2 - 1;
  while (1)
  {
    v10 = v8[1];
    if (v10 == a2)
      break;
    if (v4.u32[0] > 1uLL)
    {
      if (v10 >= v2)
        v10 %= v2;
    }
    else
    {
      v10 &= v9;
    }
    if (v10 != v5)
      return 0;
LABEL_17:
    v8 = (uint64_t *)*v8;
    if (!v8)
      return 0;
  }
  if (*((_DWORD *)v8 + 4) != a2)
    goto LABEL_17;
  if (v4.u32[0] > 1uLL)
  {
    if (v2 <= a2)
      v3 = a2 % v2;
  }
  else
  {
    v3 = v9 & a2;
  }
  v12 = *(uint64_t **)(v6 + 8 * v3);
  do
  {
    v13 = v12;
    v12 = (uint64_t *)*v12;
  }
  while (v12 != v8);
  if (v13 == a1 + 2)
    goto LABEL_37;
  v14 = v13[1];
  if (v4.u32[0] > 1uLL)
  {
    if (v14 >= v2)
      v14 %= v2;
  }
  else
  {
    v14 &= v9;
  }
  if (v14 != v3)
  {
LABEL_37:
    if (!*v8)
      goto LABEL_38;
    v15 = *(_QWORD *)(*v8 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v15 >= v2)
        v15 %= v2;
    }
    else
    {
      v15 &= v9;
    }
    if (v15 != v3)
LABEL_38:
      *(_QWORD *)(v6 + 8 * v3) = 0;
  }
  v16 = *v8;
  if (*v8)
  {
    v17 = *(_QWORD *)(v16 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v17 >= v2)
        v17 %= v2;
    }
    else
    {
      v17 &= v9;
    }
    if (v17 != v3)
    {
      *(_QWORD *)(*a1 + 8 * v17) = v13;
      v16 = *v8;
    }
  }
  *v13 = v16;
  *v8 = 0;
  --a1[3];
  operator delete(v8);
  return 1;
}

uint64_t std::__split_buffer<std::unique_ptr<HTTP2ServerPushStream>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100]((void ***)(i - 8), 0);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void HTTP2ServerPush::addPromisedHeaderToStream(uint64_t a1, __int128 *a2, __int128 *a3, int a4)
{
  uint64_t *v6;
  uint64_t v7;
  std::string v8;
  void *__p;
  char v10;

  v6 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)(a1 + 48), a4);
  if (v6)
  {
    v7 = v6[3];
    if (v7)
    {
      std::pair<std::string,std::string>::pair[abi:nn180100]<std::string&,std::string&,0>(&v8, a2, a3);
      std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::string>>(v7 + 8, (uint64_t)&v8, (uint64_t)&v8);
      if (v10 < 0)
        operator delete(__p);
      if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v8.__r_.__value_.__l.__data_);
      if (DiagnosticLogging::userDiagnosticLevel(void)::onceToken != -1)
        dispatch_once(&DiagnosticLogging::userDiagnosticLevel(void)::onceToken, &__block_literal_global_13840);
      if (DiagnosticLogging::userDiagnosticLevel(void)::sChecked >= 2)
      {
        std::pair<std::string,std::string>::pair[abi:nn180100]<std::string&,std::string&,0>(&v8, a2, a3);
        std::vector<std::pair<std::string,std::string>>::emplace_back<std::pair<std::string,std::string>>((char **)(v7 + 48), (__int128 *)&v8);
        if (v10 < 0)
          operator delete(__p);
        if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v8.__r_.__value_.__l.__data_);
      }
    }
  }
}

void sub_184101854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::pair<std::string,std::string>::~pair((uint64_t)&a9);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string,std::string>::pair[abi:nn180100]<std::string&,std::string&,0>(std::string *this, __int128 *a2, __int128 *a3)
{
  __int128 v5;
  std::string *v6;
  __int128 v7;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  v6 = this + 1;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v7 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return this;
}

void sub_1841018E4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<std::string,std::string>>::emplace_back<std::pair<std::string,std::string>>(char **a1, __int128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  __int128 v6;
  __int128 v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  __int128 v15;
  unint64_t v16;
  char *v17;
  char *v18;
  __int128 v19;
  __int128 v20;
  int64x2_t v21;
  void *v22;
  uint64_t v23;

  v4 = (unint64_t)a1[1];
  v5 = (unint64_t)a1[2];
  if (v4 >= v5)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - (_QWORD)*a1) >> 4);
    v10 = v9 + 1;
    if (v9 + 1 > 0x555555555555555)
      abort();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (_QWORD)*a1) >> 4);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x2AAAAAAAAAAAAAALL)
      v12 = 0x555555555555555;
    else
      v12 = v10;
    if (v12)
    {
      if (v12 > 0x555555555555555)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v13 = (char *)operator new(48 * v12);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[48 * v9];
    *(_OWORD *)v14 = *a2;
    *((_QWORD *)v14 + 2) = *((_QWORD *)a2 + 2);
    v15 = *(__int128 *)((char *)a2 + 24);
    *((_QWORD *)a2 + 2) = 0;
    *((_QWORD *)a2 + 3) = 0;
    *(_QWORD *)a2 = 0;
    *((_QWORD *)a2 + 1) = 0;
    *(_OWORD *)(v14 + 24) = v15;
    *((_QWORD *)v14 + 5) = *((_QWORD *)a2 + 5);
    *((_QWORD *)a2 + 4) = 0;
    *((_QWORD *)a2 + 5) = 0;
    v17 = *a1;
    v16 = (unint64_t)a1[1];
    if ((char *)v16 == *a1)
    {
      v21 = vdupq_n_s64(v16);
      v18 = &v13[48 * v9];
    }
    else
    {
      v18 = &v13[48 * v9];
      do
      {
        v19 = *(_OWORD *)(v16 - 48);
        *((_QWORD *)v18 - 4) = *(_QWORD *)(v16 - 32);
        *((_OWORD *)v18 - 3) = v19;
        *(_QWORD *)(v16 - 40) = 0;
        *(_QWORD *)(v16 - 32) = 0;
        *(_QWORD *)(v16 - 48) = 0;
        v20 = *(_OWORD *)(v16 - 24);
        *((_QWORD *)v18 - 1) = *(_QWORD *)(v16 - 8);
        *(_OWORD *)(v18 - 24) = v20;
        v18 -= 48;
        *(_QWORD *)(v16 - 16) = 0;
        *(_QWORD *)(v16 - 8) = 0;
        *(_QWORD *)(v16 - 24) = 0;
        v16 -= 48;
      }
      while ((char *)v16 != v17);
      v21 = *(int64x2_t *)a1;
    }
    v8 = v14 + 48;
    *a1 = v18;
    a1[1] = v14 + 48;
    a1[2] = &v13[48 * v12];
    v23 = v21.i64[1];
    v22 = (void *)v21.i64[0];
    while ((void *)v23 != v22)
    {
      v23 -= 48;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(v23);
    }
    if (v22)
      operator delete(v22);
  }
  else
  {
    v6 = *a2;
    *(_QWORD *)(v4 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v4 = v6;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v7 = *(__int128 *)((char *)a2 + 24);
    *(_QWORD *)(v4 + 40) = *((_QWORD *)a2 + 5);
    *(_OWORD *)(v4 + 24) = v7;
    *((_QWORD *)a2 + 4) = 0;
    *((_QWORD *)a2 + 5) = 0;
    *((_QWORD *)a2 + 3) = 0;
    v8 = (char *)(v4 + 48);
  }
  a1[1] = v8;
}

uint64_t *HTTP2ServerPush::endPromisedHeadersWithCheckTheCacheBlock(uint64_t *a1, int a2)
{
  int v2;
  uint64_t *v3;
  uint64_t *result;
  uint64_t v5;
  _QWORD *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  const std::string *v9;
  uint64_t v10;
  _BOOL4 v11;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  int8x8_t v20;
  unint64_t v21;
  uint8x8_t v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t *v29;
  _QWORD *v30;
  uint64_t v31;
  int v32;
  double v33;
  uint64_t v34;
  _QWORD *v35;
  std::string *v36;
  std::string::size_type size;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint8x8_t v41;
  unint64_t v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  unint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  void **v53;
  char *v54;
  unint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  std::string::size_type v58;
  float v59;
  float v60;
  _BOOL8 v61;
  unint64_t v62;
  unint64_t v63;
  size_t v64;
  uint64_t *v65;
  unint64_t v66;
  _QWORD *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  unint64_t v73;
  int v74;
  __CFHTTPMessage *Response;
  uint64_t v76;
  void *v77;
  char v78;
  unsigned __int8 *v79;
  unsigned __int8 *v80;
  size_t v81;
  std::string *v82;
  const void *v83;
  const std::string::value_type *v84;
  unsigned __int8 *v85;
  const std::string::value_type *v86;
  int v87;
  const std::string::value_type *v88;
  std::string::size_type v89;
  std::string *v90;
  __int128 v91;
  std::string *v92;
  std::string::size_type v93;
  char v94;
  std::string *v95;
  std::string::size_type v96;
  uint64_t appended;
  id v98;
  unsigned __int8 *v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  char *v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t *v110;
  uint64_t v111;
  _BOOL4 v112;
  int v113;
  _QWORD *v114;
  uint64_t v115;
  std::string v116;
  void *v117;
  id v118;
  std::string v119;
  std::string v120;
  void *__p;
  uint64_t v122;
  void (*v123)(uint64_t);
  void *v124;
  __CFHTTPMessage *v125;
  _QWORD v126[5];

  v2 = a2;
  v3 = a1;
  v126[2] = *MEMORY[0x1E0C80C00];
  result = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>(a1 + 6, a2);
  if (!result)
    return result;
  v5 = result[3];
  if (!v5)
    return 0;
  *(_BYTE *)(v5 + 72) = 1;
  std::string::basic_string[abi:nn180100]<0>(&__p, ":method");
  v6 = (_QWORD *)(v5 + 8);
  v7 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>((_QWORD *)(v5 + 8), (uint64_t)&__p);
  v8 = v7;
  if (SHIBYTE(v123) < 0)
  {
    operator delete(__p);
    if (!v8)
    {
LABEL_9:
      HTTP2ServerPush::_removeStream((HTTP2ServerPush *)v3, v2, 0);
      return 0;
    }
  }
  else if (!v7)
  {
    goto LABEL_9;
  }
  v9 = (const std::string *)(v8 + 40);
  if (std::string::compare(v9, "GET") && std::string::compare(v9, "HEAD"))
    goto LABEL_9;
  v10 = *(_QWORD *)(v5 + 248);
  v11 = v10 == 4 || v10 == 1;
  if (v10 != 1 && v10 != 4)
  {
    std::string::basic_string[abi:nn180100]<0>(&__p, "cache-control");
    v13 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>((_QWORD *)(v5 + 8), (uint64_t)&__p);
    if (SHIBYTE(v123) < 0)
      operator delete(__p);
    if (v13)
    {
      if ((char)v13[63] < 0)
      {
        v14 = (unsigned __int8 *)*((_QWORD *)v13 + 5);
        v15 = *((_QWORD *)v13 + 6);
      }
      else
      {
        v14 = v13 + 40;
        v15 = v13[63];
      }
      if (v15 >= 9)
      {
        v16 = &v14[v15];
        v17 = v14;
        do
        {
          v18 = (unsigned __int8 *)memchr(v17, 109, v15 - 8);
          if (!v18)
            break;
          if (*(_QWORD *)v18 == 0x3D6567612D78616DLL && v18[8] == 48)
          {
            if (v18 != v16 && v18 - v14 != -1)
              v11 = 1;
            break;
          }
          v17 = v18 + 1;
          v15 = v16 - v17;
        }
        while (v16 - v17 >= 9);
      }
      v20 = *(int8x8_t *)(v5 + 16);
      v21 = *((_QWORD *)v13 + 1);
      v22 = (uint8x8_t)vcnt_s8(v20);
      v22.i16[0] = vaddlv_u8(v22);
      if (v22.u32[0] > 1uLL)
      {
        if (v21 >= *(_QWORD *)&v20)
          v21 %= *(_QWORD *)&v20;
      }
      else
      {
        v21 &= *(_QWORD *)&v20 - 1;
      }
      v23 = *(unsigned __int8 **)(*v6 + 8 * v21);
      do
      {
        v24 = v23;
        v23 = *(unsigned __int8 **)v23;
      }
      while (v23 != v13);
      if (v24 == (unsigned __int8 *)(v5 + 24))
        goto LABEL_54;
      v25 = *((_QWORD *)v24 + 1);
      if (v22.u32[0] > 1uLL)
      {
        if (v25 >= *(_QWORD *)&v20)
          v25 %= *(_QWORD *)&v20;
      }
      else
      {
        v25 &= *(_QWORD *)&v20 - 1;
      }
      if (v25 != v21)
      {
LABEL_54:
        if (!*(_QWORD *)v13)
          goto LABEL_55;
        v26 = *(_QWORD *)(*(_QWORD *)v13 + 8);
        if (v22.u32[0] > 1uLL)
        {
          if (v26 >= *(_QWORD *)&v20)
            v26 %= *(_QWORD *)&v20;
        }
        else
        {
          v26 &= *(_QWORD *)&v20 - 1;
        }
        if (v26 != v21)
LABEL_55:
          *(_QWORD *)(*v6 + 8 * v21) = 0;
      }
      v27 = *(_QWORD *)v13;
      if (*(_QWORD *)v13)
      {
        v28 = *(_QWORD *)(v27 + 8);
        if (v22.u32[0] > 1uLL)
        {
          if (v28 >= *(_QWORD *)&v20)
            v28 %= *(_QWORD *)&v20;
        }
        else
        {
          v28 &= *(_QWORD *)&v20 - 1;
        }
        if (v28 != v21)
        {
          *(_QWORD *)(*v6 + 8 * v28) = v24;
          v27 = *(_QWORD *)v13;
        }
      }
      *(_QWORD *)v24 = v27;
      *(_QWORD *)v13 = 0;
      --*(_QWORD *)(v5 + 32);
      __p = v13;
      v122 = v5 + 24;
      LOBYTE(v123) = 1;
      std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)&__p);
    }
  }
  v29 = v3 + 16;
  __p = (void *)v5;
  v30 = std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::find<std::reference_wrapper<HTTP2ServerPushStream const>>(v3 + 16, (uint64_t *)&__p);
  if (!v30)
  {
    std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__emplace_unique_impl<HTTP2ServerPushStream&>(v3 + 16, v5);
    HTTP2ServerPushStream::_getFullURL(v5 + 8, v5 + 224);
    v43 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v3 + 11), v5 + 224, v5 + 224);
    v44 = v43;
    v46 = (uint64_t *)*((_QWORD *)v43 + 6);
    v45 = *((_QWORD *)v43 + 7);
    if ((unint64_t)v46 < v45)
      goto LABEL_174;
    v47 = *((_QWORD *)v43 + 5);
    v48 = ((uint64_t)v46 - v47) >> 3;
    if ((unint64_t)(v48 + 1) >> 61)
      abort();
    v49 = v45 - v47;
    v50 = v49 >> 2;
    if (v49 >> 2 <= (unint64_t)(v48 + 1))
      v50 = v48 + 1;
    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8)
      v51 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v51 = v50;
    if (v51)
      v51 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v51);
    else
      v52 = 0;
    v65 = (uint64_t *)(v51 + 8 * v48);
    v66 = v51 + 8 * v52;
    *v65 = v5;
    v67 = v65 + 1;
    v69 = (char *)*((_QWORD *)v44 + 5);
    v68 = (char *)*((_QWORD *)v44 + 6);
    if (v68 != v69)
    {
      do
      {
        v70 = *((_QWORD *)v68 - 1);
        v68 -= 8;
        *--v65 = v70;
      }
      while (v68 != v69);
LABEL_186:
      v68 = (char *)*((_QWORD *)v44 + 5);
    }
LABEL_187:
    *((_QWORD *)v44 + 5) = v65;
    *((_QWORD *)v44 + 6) = v67;
    *((_QWORD *)v44 + 7) = v66;
    if (v68)
      operator delete(v68);
LABEL_189:
    *((_QWORD *)v44 + 6) = v67;
    return (uint64_t *)1;
  }
  v31 = v30[2];
  v32 = *(unsigned __int8 *)(v31 + 144);
  if (!*(_BYTE *)(v31 + 144))
    goto LABEL_168;
  v33 = *(double *)(v31 + 208);
  if (v33 != 0.0)
    goto LABEL_167;
  v34 = (uint64_t)&v116;
  std::string::basic_string[abi:nn180100]<0>(&v116, ":status");
  v112 = v11;
  v113 = v2;
  v114 = (_QWORD *)(v5 + 8);
  v35 = (_QWORD *)(v31 + 80);
  if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v36 = &v116;
  else
    v36 = (std::string *)v116.__r_.__value_.__r.__words[0];
  if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v116.__r_.__value_.__r.__words[2]);
  else
    size = v116.__r_.__value_.__l.__size_;
  v38 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v36, size);
  v39 = v38;
  v40 = *(_QWORD *)(v31 + 88);
  v115 = v31;
  if (v40)
  {
    v41 = (uint8x8_t)vcnt_s8((int8x8_t)v40);
    v41.i16[0] = vaddlv_u8(v41);
    v42 = v41.u32[0];
    if (v41.u32[0] > 1uLL)
    {
      v34 = v38;
      if (v38 >= v40)
        v34 = v38 % v40;
    }
    else
    {
      v34 = (v40 - 1) & v38;
    }
    v53 = *(void ***)(*v35 + 8 * v34);
    if (v53)
    {
      v54 = (char *)*v53;
      if (*v53)
      {
        do
        {
          v55 = *((_QWORD *)v54 + 1);
          if (v55 == v39)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v54 + 16, (unsigned __int8 *)&v116))
            {
              goto LABEL_126;
            }
          }
          else
          {
            if (v42 > 1)
            {
              if (v55 >= v40)
                v55 %= v40;
            }
            else
            {
              v55 &= v40 - 1;
            }
            if (v55 != v34)
              break;
          }
          v54 = *(char **)v54;
        }
        while (v54);
      }
    }
    v31 = v115;
  }
  v54 = (char *)operator new(0x40uLL);
  v56 = v31;
  v57 = (_QWORD *)(v31 + 96);
  __p = v54;
  v122 = (uint64_t)v57;
  *(_QWORD *)v54 = 0;
  *((_QWORD *)v54 + 1) = v39;
  v58 = v116.__r_.__value_.__r.__words[2];
  *((_OWORD *)v54 + 1) = *(_OWORD *)&v116.__r_.__value_.__l.__data_;
  memset(&v116, 0, sizeof(v116));
  *((_QWORD *)v54 + 4) = v58;
  *((_QWORD *)v54 + 5) = 0;
  *((_QWORD *)v54 + 6) = 0;
  *((_QWORD *)v54 + 7) = 0;
  LOBYTE(v123) = 1;
  v59 = (float)(unint64_t)(*(_QWORD *)(v56 + 104) + 1);
  v60 = *(float *)(v56 + 112);
  if (!v40 || (float)(v60 * (float)v40) < v59)
  {
    v61 = 1;
    if (v40 >= 3)
      v61 = (v40 & (v40 - 1)) != 0;
    v62 = v61 | (2 * v40);
    v63 = vcvtps_u32_f32(v59 / v60);
    if (v62 <= v63)
      v64 = v63;
    else
      v64 = v62;
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>((uint64_t)v35, v64);
    v40 = *(_QWORD *)(v115 + 88);
    if ((v40 & (v40 - 1)) != 0)
    {
      if (v39 >= v40)
        v34 = v39 % v40;
      else
        v34 = v39;
    }
    else
    {
      v34 = (v40 - 1) & v39;
    }
  }
  v71 = *(_QWORD **)(*v35 + 8 * v34);
  if (v71)
  {
    *(_QWORD *)v54 = *v71;
    v72 = v115;
  }
  else
  {
    *(_QWORD *)v54 = *v57;
    *v57 = v54;
    *(_QWORD *)(*v35 + 8 * v34) = v57;
    v72 = v115;
    if (!*(_QWORD *)v54)
      goto LABEL_125;
    v73 = *(_QWORD *)(*(_QWORD *)v54 + 8);
    if ((v40 & (v40 - 1)) != 0)
    {
      if (v73 >= v40)
        v73 %= v40;
    }
    else
    {
      v73 &= v40 - 1;
    }
    v71 = (_QWORD *)(*v35 + 8 * v73);
  }
  *v71 = v54;
LABEL_125:
  __p = 0;
  ++*(_QWORD *)(v72 + 104);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)&__p);
LABEL_126:
  v74 = std::stoi((const std::string *)(v54 + 40), 0, 10);
  Response = CFHTTPMessageCreateResponse((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v74, 0, CFSTR("HTTP/2.0"));
  v109 = v3 + 16;
  v110 = v3;
  v111 = v5;
  if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v116.__r_.__value_.__l.__data_);
  v76 = 0;
  v77 = 0;
  v78 = 0;
  __p = (void *)MEMORY[0x1E0C809B0];
  v122 = 3221225472;
  v123 = ___ZN21HTTP2ServerPushStream18_getExpirationTimeEv_block_invoke;
  v124 = &__block_descriptor_40_e5_v8__0l;
  v125 = Response;
  memset(&v120, 0, sizeof(v120));
  do
  {
    std::string::basic_string[abi:nn180100]<0>(&v116, off_1E14FDCF8[v76]);
    v79 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(v35, (uint64_t)&v116);
    v80 = v79;
    if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v116.__r_.__value_.__l.__data_);
      if (!v80)
        goto LABEL_157;
    }
    else if (!v79)
    {
      goto LABEL_157;
    }
    if ((v80[39] & 0x80u) == 0)
      v81 = v80[39];
    else
      v81 = *((_QWORD *)v80 + 3);
    std::string::basic_string[abi:nn180100]((uint64_t)&v119, v81 + 2);
    if ((v119.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v82 = &v119;
    else
      v82 = (std::string *)v119.__r_.__value_.__r.__words[0];
    if (v81)
    {
      if ((v80[39] & 0x80u) == 0)
        v83 = v80 + 16;
      else
        v83 = (const void *)*((_QWORD *)v80 + 2);
      memmove(v82, v83, v81);
    }
    strcpy((char *)v82 + v81, ": ");
    v86 = (const std::string::value_type *)*((_QWORD *)v80 + 5);
    v85 = v80 + 40;
    v84 = v86;
    v87 = (char)v85[23];
    if (v87 >= 0)
      v88 = (const std::string::value_type *)v85;
    else
      v88 = v84;
    if (v87 >= 0)
      v89 = v85[23];
    else
      v89 = *((_QWORD *)v85 + 1);
    v90 = std::string::append(&v119, v88, v89);
    v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    v116.__r_.__value_.__r.__words[2] = v90->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v116.__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0;
    v90->__r_.__value_.__r.__words[2] = 0;
    v90->__r_.__value_.__r.__words[0] = 0;
    v92 = std::string::append(&v116, "\r\n");
    v93 = v92->__r_.__value_.__r.__words[0];
    v126[0] = v92->__r_.__value_.__l.__size_;
    *(_QWORD *)((char *)v126 + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    v94 = HIBYTE(v92->__r_.__value_.__r.__words[2]);
    v92->__r_.__value_.__l.__size_ = 0;
    v92->__r_.__value_.__r.__words[2] = 0;
    v92->__r_.__value_.__r.__words[0] = 0;
    if (v78 < 0)
      operator delete(v77);
    v120.__r_.__value_.__r.__words[0] = v93;
    v120.__r_.__value_.__l.__size_ = v126[0];
    *(std::string::size_type *)((char *)&v120.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)((char *)v126 + 7);
    *((_BYTE *)&v120.__r_.__value_.__s + 23) = v94;
    if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v116.__r_.__value_.__l.__data_);
    if (SHIBYTE(v119.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v119.__r_.__value_.__l.__data_);
    v77 = (void *)v93;
    v78 = v94;
LABEL_157:
    ++v76;
  }
  while (v76 != 3);
  std::string::append(&v120, "\r\n");
  if ((v120.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v95 = &v120;
  else
    v95 = (std::string *)v120.__r_.__value_.__r.__words[0];
  if ((v120.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v96 = HIBYTE(v120.__r_.__value_.__r.__words[2]);
  else
    v96 = v120.__r_.__value_.__l.__size_;
  appended = CFHTTPMessageAppendBytes(Response, (const UInt8 *)v95, v96);
  v98 = CFURLResponseCreateWithHTTPResponse(appended, 0, (uint64_t)Response, 0);
  v3 = v110;
  v5 = v111;
  v6 = v114;
  v31 = v115;
  v11 = v112;
  v2 = v113;
  v29 = v109;
  v116.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
  v116.__r_.__value_.__l.__size_ = 3221225472;
  v116.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN21HTTP2ServerPushStream18_getExpirationTimeEv_block_invoke_2;
  v117 = &__block_descriptor_40_e5_v8__0l;
  v118 = v98;
  *(double *)(v115 + 208) = CFURLResponseGetExpirationTime(v98);
  ((void (*)(std::string *))v116.__r_.__value_.__r.__words[2])(&v116);
  if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v120.__r_.__value_.__l.__data_);
  v123((uint64_t)&__p);
  v33 = *(double *)(v115 + 208);
LABEL_167:
  v32 = v33 < CFAbsoluteTimeGetCurrent();
LABEL_168:
  if (((v11 | v32) & 1) != 0)
  {
    if (*(_QWORD *)(v31 + 184) == *(_QWORD *)(v31 + 176))
    {
      HTTP2ServerPush::_removeStream((HTTP2ServerPush *)v3, *(_DWORD *)(v31 + 172), 1);
    }
    else
    {
      __p = (void *)v31;
      std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__erase_unique<std::reference_wrapper<HTTP2ServerPushStream const>>(v29, (uint64_t *)&__p);
      HTTP2ServerPushStream::_getFullURL(v31 + 8, v31 + 224);
      HTTP2ServerPush::_removeFromUrlToServerPushStreamsMap((uint64_t)v3, v31 + 224, v31);
      *(_BYTE *)(v31 + 216) = 0;
    }
    std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__emplace_unique_impl<HTTP2ServerPushStream&>(v29, v5);
    HTTP2ServerPushStream::_getFullURL((uint64_t)v6, v5 + 224);
    v99 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v3 + 11), v5 + 224, v5 + 224);
    v44 = v99;
    v46 = (uint64_t *)*((_QWORD *)v99 + 6);
    v100 = *((_QWORD *)v99 + 7);
    if ((unint64_t)v46 < v100)
    {
LABEL_174:
      *v46 = v5;
      v67 = v46 + 1;
      goto LABEL_189;
    }
    v101 = *((_QWORD *)v99 + 5);
    v102 = ((uint64_t)v46 - v101) >> 3;
    if ((unint64_t)(v102 + 1) >> 61)
      abort();
    v103 = v100 - v101;
    v104 = v103 >> 2;
    if (v103 >> 2 <= (unint64_t)(v102 + 1))
      v104 = v102 + 1;
    if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF8)
      v105 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v105 = v104;
    if (v105)
      v105 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v105);
    else
      v106 = 0;
    v65 = (uint64_t *)(v105 + 8 * v102);
    v66 = v105 + 8 * v106;
    *v65 = v5;
    v67 = v65 + 1;
    v107 = (char *)*((_QWORD *)v44 + 5);
    v68 = (char *)*((_QWORD *)v44 + 6);
    if (v68 != v107)
    {
      do
      {
        v108 = *((_QWORD *)v68 - 1);
        v68 -= 8;
        *--v65 = v108;
      }
      while (v68 != v107);
      goto LABEL_186;
    }
    goto LABEL_187;
  }
  HTTP2ServerPush::_removeStream((HTTP2ServerPush *)v3, v2, 0);
  return 0;
}

void sub_184102558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,uint64_t a39,uint64_t a40)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)&a38);
  if (a22 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__emplace_unique_impl<HTTP2ServerPushStream&>(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  float v15;
  float v16;
  int8x8_t v17;
  unint64_t v18;
  uint8x8_t v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  int8x8_t prime;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  int8x8_t v27;
  void *v28;
  void *v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  uint8x8_t v33;
  unint64_t v34;
  uint8x8_t v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  void *v39;

  v4 = operator new(0x18uLL);
  *v4 = 0;
  v4[1] = 0;
  v4[2] = a2;
  v4[1] = HTTP2ServerPushStream::Hasher::operator()(a2);
  v5 = HTTP2ServerPushStream::Hasher::operator()(v4[2]);
  v6 = v5;
  v4[1] = v5;
  v7 = a1[1];
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    v9 = v8.u32[0];
    if (v8.u32[0] > 1uLL)
    {
      v10 = v5;
      if (v7 <= v5)
        v10 = v5 % v7;
    }
    else
    {
      v10 = (v7 - 1) & v5;
    }
    v11 = *(_QWORD **)(*a1 + 8 * v10);
    if (v11)
    {
      v12 = (_QWORD *)*v11;
      if (*v11)
      {
        do
        {
          v13 = v12[1];
          if (v13 == v6)
          {
            if ((HTTP2ServerPushStream::operator==(v12[2], v4[2]) & 1) != 0)
            {
              operator delete(v4);
              return;
            }
          }
          else
          {
            if (v9 > 1)
            {
              if (v13 >= v7)
                v13 %= v7;
            }
            else
            {
              v13 &= v7 - 1;
            }
            if (v13 != v10)
              break;
          }
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
    }
  }
  v14 = a1 + 2;
  v15 = (float)(unint64_t)(a1[3] + 1);
  v16 = *((float *)a1 + 8);
  if (!v7 || (float)(v16 * (float)v7) < v15)
  {
    v20 = 1;
    if (v7 >= 3)
      v20 = (v7 & (v7 - 1)) != 0;
    v21 = v20 | (2 * v7);
    v22 = vcvtps_u32_f32(v15 / v16);
    if (v21 <= v22)
      prime = (int8x8_t)v22;
    else
      prime = (int8x8_t)v21;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v27 = (int8x8_t)a1[1];
    if (*(_QWORD *)&prime <= *(_QWORD *)&v27)
    {
      if (*(_QWORD *)&prime >= *(_QWORD *)&v27)
        goto LABEL_19;
      v34 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (*(_QWORD *)&v27 < 3uLL || (v35 = (uint8x8_t)vcnt_s8(v27), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
      {
        v34 = std::__next_prime(v34);
      }
      else
      {
        v36 = 1 << -(char)__clz(v34 - 1);
        if (v34 >= 2)
          v34 = v36;
      }
      if (*(_QWORD *)&prime <= v34)
        prime = (int8x8_t)v34;
      if (*(_QWORD *)&prime >= *(_QWORD *)&v27)
        goto LABEL_19;
      if (!*(_QWORD *)&prime)
      {
        v39 = (void *)*a1;
        *a1 = 0;
        if (v39)
          operator delete(v39);
        a1[1] = 0;
        goto LABEL_19;
      }
    }
    if (*(_QWORD *)&prime >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v28 = operator new(8 * *(_QWORD *)&prime);
    v29 = (void *)*a1;
    *a1 = (uint64_t)v28;
    if (v29)
      operator delete(v29);
    v30 = 0;
    a1[1] = (uint64_t)prime;
    do
      *(_QWORD *)(*a1 + 8 * v30++) = 0;
    while (*(_QWORD *)&prime != v30);
    v31 = (_QWORD *)*v14;
    if (!*v14)
      goto LABEL_19;
    v32 = v31[1];
    v33 = (uint8x8_t)vcnt_s8(prime);
    v33.i16[0] = vaddlv_u8(v33);
    if (v33.u32[0] > 1uLL)
    {
      if (v32 >= *(_QWORD *)&prime)
        v32 %= *(_QWORD *)&prime;
    }
    else
    {
      v32 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*a1 + 8 * v32) = v14;
    v37 = (_QWORD *)*v31;
    if (!*v31)
      goto LABEL_19;
    do
    {
      v38 = v37[1];
      if (v33.u32[0] > 1uLL)
      {
        if (v38 >= *(_QWORD *)&prime)
          v38 %= *(_QWORD *)&prime;
      }
      else
      {
        v38 &= *(_QWORD *)&prime - 1;
      }
      if (v38 != v32)
      {
        if (!*(_QWORD *)(*a1 + 8 * v38))
        {
          *(_QWORD *)(*a1 + 8 * v38) = v31;
          goto LABEL_68;
        }
        *v31 = *v37;
        *v37 = **(_QWORD **)(*a1 + 8 * v38);
        **(_QWORD **)(*a1 + 8 * v38) = v37;
        v37 = v31;
      }
      v38 = v32;
LABEL_68:
      v31 = v37;
      v37 = (_QWORD *)*v37;
      v32 = v38;
    }
    while (v37);
  }
LABEL_19:
  v17 = (int8x8_t)a1[1];
  v18 = v4[1];
  v19 = (uint8x8_t)vcnt_s8(v17);
  v19.i16[0] = vaddlv_u8(v19);
  if (v19.u32[0] > 1uLL)
  {
    if (v18 >= *(_QWORD *)&v17)
      v18 %= *(_QWORD *)&v17;
  }
  else
  {
    v18 &= *(_QWORD *)&v17 - 1;
  }
  v24 = *a1;
  v25 = *(_QWORD **)(*a1 + 8 * v18);
  if (v25)
  {
    *v4 = *v25;
LABEL_55:
    *v25 = v4;
    goto LABEL_56;
  }
  *v4 = *v14;
  *v14 = v4;
  *(_QWORD *)(v24 + 8 * v18) = v14;
  if (*v4)
  {
    v26 = *(_QWORD *)(*v4 + 8);
    if (v19.u32[0] > 1uLL)
    {
      if (v26 >= *(_QWORD *)&v17)
        v26 %= *(_QWORD *)&v17;
    }
    else
    {
      v26 &= *(_QWORD *)&v17 - 1;
    }
    v25 = (_QWORD *)(*a1 + 8 * v26);
    goto LABEL_55;
  }
LABEL_56:
  ++a1[3];
}

void sub_184102A04(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  void **v15;
  char *v16;
  unint64_t v17;
  _QWORD *v18;
  std::string *v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  size_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD v30[2];
  char v31;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v15)
    {
      v16 = (char *)*v15;
      if (*v15)
      {
        do
        {
          v17 = *((_QWORD *)v16 + 1);
          if (v17 == v11)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v16 + 16, (unsigned __int8 *)a2))
            {
              return v16;
            }
          }
          else
          {
            if (v14 > 1)
            {
              if (v17 >= v12)
                v17 %= v12;
            }
            else
            {
              v17 &= v12 - 1;
            }
            if (v17 != v3)
              break;
          }
          v16 = *(char **)v16;
        }
        while (v16);
      }
    }
  }
  v18 = (_QWORD *)(a1 + 16);
  v16 = (char *)operator new(0x40uLL);
  v30[0] = v16;
  v30[1] = a1 + 16;
  v31 = 0;
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = v11;
  v19 = (std::string *)(v16 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((_QWORD *)v16 + 4) = *(_QWORD *)(a3 + 16);
  }
  *((_QWORD *)v16 + 5) = 0;
  *((_QWORD *)v16 + 6) = 0;
  *((_QWORD *)v16 + 7) = 0;
  v31 = 1;
  v20 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    v22 = 1;
    if (v12 >= 3)
      v22 = (v12 & (v12 - 1)) != 0;
    v23 = v22 | (2 * v12);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      v25 = v24;
    else
      v25 = v23;
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>(a1, v25);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v26 = *(_QWORD *)a1;
  v27 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v27)
  {
    *(_QWORD *)v16 = *v27;
LABEL_47:
    *v27 = v16;
    goto LABEL_48;
  }
  *(_QWORD *)v16 = *v18;
  *v18 = v16;
  *(_QWORD *)(v26 + 8 * v3) = v18;
  if (*(_QWORD *)v16)
  {
    v28 = *(_QWORD *)(*(_QWORD *)v16 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12)
        v28 %= v12;
    }
    else
    {
      v28 &= v12 - 1;
    }
    v27 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    goto LABEL_47;
  }
LABEL_48:
  v30[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v30);
  return v16;
}

void sub_184102C94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HTTP2ServerPush::appendDataForStream(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  NSObject *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void ***v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  void ***v18;
  void ***v19;
  void ***v20;
  void **v21;
  NSObject *v22;
  NSObject *v23;
  dispatch_data_t concat;
  uint64_t v25;
  void (*v26)(dispatch_object_t);
  uint64_t v28;
  uint64_t v29;

  v7 = a1 + 6;
  v8 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>(a1 + 6, a3);
  if (!v8)
    return 0;
  v9 = v8[3];
  if (v9)
  {
    v10 = *(NSObject **)a2;
    if (!*(_QWORD *)a2)
      goto LABEL_28;
    v11 = a1[1];
    if (*a1 < v11)
    {
      v12 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_17375, 2);
      if (v12)
      {
        v13 = v12;
        if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v12 + 16))(v12, "h2 info server push", 0))
        {
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v13 + 72))(v13, "h2 psps", CFSTR("server push storage is full stored data size=%zu, max size=%zd"));
          (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
        }
      }
      v15 = a1[3];
      v14 = (void ***)a1[4];
      while ((void ***)v15 != v14)
      {
        v16 = *(_QWORD *)v15;
        if (*(_BYTE *)(*(_QWORD *)v15 + 168))
        {
          v17 = *(NSObject **)(v16 + 152);
          if (v17)
            a1[1] -= dispatch_data_get_size(v17);
          std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::__erase_unique<int>(v7, *(_DWORD *)(v16 + 172));
          v29 = v16;
          std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__erase_unique<std::reference_wrapper<HTTP2ServerPushStream const>>(a1 + 16, &v29);
          HTTP2ServerPushStream::_getFullURL(v16 + 8, v16 + 224);
          HTTP2ServerPush::_removeFromUrlToServerPushStreamsMap((uint64_t)a1, v16 + 224, v16);
          v18 = (void ***)(v15 + 8);
          v19 = (void ***)a1[4];
          if ((void ***)(v15 + 8) == v19)
          {
            v14 = (void ***)v15;
          }
          else
          {
            do
            {
              v14 = v18;
              v20 = v18 - 1;
              v21 = *v18;
              *v18++ = 0;
              std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](v20, v21);
            }
            while (v18 != v19);
            v18 = (void ***)a1[4];
          }
          while (v18 != v14)
            std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](--v18, 0);
          a1[4] = (uint64_t)v14;
          if (*a1 >= (unint64_t)a1[1])
            break;
        }
        else
        {
          v15 += 8;
        }
      }
      v10 = *(NSObject **)a2;
      if (!*(_QWORD *)a2)
        goto LABEL_28;
      v11 = a1[1];
    }
    a1[1] = v11 + dispatch_data_get_size(v10);
    v22 = *(NSObject **)a2;
    if (!*(_QWORD *)a2)
    {
LABEL_28:
      *(_BYTE *)(v9 + 168) = a4;
      if (a4)
      {
        if (*(_QWORD *)(v9 + 184) != *(_QWORD *)(v9 + 176))
          HTTP2ServerPushStream::_invokeCompletionHadlers(v9, 0);
        if (!*(_BYTE *)(v9 + 216))
          HTTP2ServerPush::_removeStream((HTTP2ServerPush *)a1, *(_DWORD *)(v9 + 172), 0);
      }
      return v9;
    }
    v23 = *(NSObject **)(v9 + 152);
    if (v23)
    {
      concat = dispatch_data_create_concat(v23, v22);
      v25 = *(_QWORD *)(v9 + 152);
      *(_QWORD *)(v9 + 152) = concat;
      v26 = HTTP2ServerPushStream::safe_data_deleter;
      if (!v25)
      {
LABEL_27:
        *(_QWORD *)(v9 + 160) = v26;
        goto LABEL_28;
      }
    }
    else
    {
      *(_QWORD *)a2 = 0;
      v26 = *(void (**)(dispatch_object_t))(a2 + 8);
      v28 = *(_QWORD *)(v9 + 152);
      *(_QWORD *)(v9 + 152) = v22;
      if (!v28)
        goto LABEL_27;
    }
    (*(void (**)(void))(v9 + 160))();
    goto LABEL_27;
  }
  return v9;
}

uint64_t HTTP2ServerPush::hasPromised(int8x8_t *a1, _QWORD *a2)
{
  uint64_t *p_p;
  unint64_t v5;
  unint64_t v6;
  int8x8_t v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 **v12;
  unsigned __int8 *v13;
  unint64_t v14;
  int8x8_t *v16;
  int v17;
  int v18;
  BOOL v19;
  uint64_t *v20;
  _DWORD *v21;
  int v22;
  _DWORD *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  std::string *v31;
  unsigned __int8 **v32;
  signed __int8 v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  uint64_t v39;
  int *v40;
  uint64_t v41;
  int v42;
  int v43;
  std::string *v45;
  char *v46;
  std::string *v47;
  char *v48;
  uint64_t v50;
  uint64_t (***v51)();
  uint64_t v52;
  uint64_t (***v53)();
  uint64_t v54;
  int v55;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  unsigned __int8 *v61;
  std::string *v62;
  uint64_t v63;
  uint64_t (***v64)();
  uint64_t v65;
  uint64_t (***v66)();
  uint64_t v67;
  int v68;
  int8x8_t *v69;
  int8x8_t *v70;
  void *__p;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  void *v77;
  uint64_t *v78;
  uint64_t *v79;
  std::string v80;
  uint64_t aBlock;
  uint64_t v82;
  void *v83;
  void *v84;
  uint64_t *v85;
  std::string v86;
  void *v87[2];
  char v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t (*v92)(uint64_t, _QWORD *);
  uint64_t (*v93)(uint64_t);
  __int128 v94;
  __int128 v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  char v101;
  uint64_t (**v102)();
  void *v103;
  uint64_t (***v104)();
  uint64_t (**v105)();
  void *v106;
  uint64_t (***v107)();
  uint64_t v108;

  v108 = *MEMORY[0x1E0C80C00];
  __p = 0;
  v72 = 0;
  v73 = 0;
  HTTP2ServerPushStream::_getFullURL((uint64_t)a2, (uint64_t)&__p);
  if (v73 >= 0)
    p_p = (uint64_t *)&__p;
  else
    p_p = (uint64_t *)__p;
  if (v73 >= 0)
    v5 = HIBYTE(v73);
  else
    v5 = v72;
  v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](p_p, v5);
  v7 = a1[12];
  if (!*(_QWORD *)&v7)
    goto LABEL_24;
  v8 = v6;
  v9 = (uint8x8_t)vcnt_s8(v7);
  v9.i16[0] = vaddlv_u8(v9);
  v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    v11 = v6;
    if (v6 >= *(_QWORD *)&v7)
      v11 = v6 % *(_QWORD *)&v7;
  }
  else
  {
    v11 = (*(_QWORD *)&v7 - 1) & v6;
  }
  v12 = *(unsigned __int8 ***)(*(_QWORD *)&a1[11] + 8 * v11);
  if (!v12 || (v13 = *v12) == 0)
  {
LABEL_23:
    v7 = 0;
    goto LABEL_24;
  }
  while (1)
  {
    v14 = *((_QWORD *)v13 + 1);
    if (v8 == v14)
      break;
    if (v10 > 1)
    {
      if (v14 >= *(_QWORD *)&v7)
        v14 %= *(_QWORD *)&v7;
    }
    else
    {
      v14 &= *(_QWORD *)&v7 - 1;
    }
    if (v14 != v11)
      goto LABEL_23;
LABEL_22:
    v13 = *(unsigned __int8 **)v13;
    if (!v13)
      goto LABEL_23;
  }
  if (!std::equal_to<std::string>::operator()[abi:nn180100](v13 + 16, (unsigned __int8 *)&__p))
    goto LABEL_22;
  v16 = (int8x8_t *)*((_QWORD *)v13 + 5);
  v69 = (int8x8_t *)*((_QWORD *)v13 + 6);
  if (v16 == v69)
    goto LABEL_23;
  while (1)
  {
    v70 = v16;
    v7 = *v16;
    v17 = *(unsigned __int8 *)(*(_QWORD *)v16 + 216);
    v18 = *(unsigned __int8 *)(*(_QWORD *)v16 + 72);
    v19 = !v17 || v18 == 0;
    if (!v19 && *(_QWORD *)(*(_QWORD *)&v7 + 32))
      break;
LABEL_166:
    v7 = 0;
    v16 = v70 + 1;
    if (&v70[1] == v69)
      goto LABEL_24;
  }
  v20 = *(uint64_t **)(*(_QWORD *)&v7 + 24);
  if (v20)
  {
    while (2)
    {
      v21 = v20 + 2;
      v22 = *((unsigned __int8 *)v20 + 39);
      if (*((char *)v20 + 39) < 0)
      {
        v24 = v20[3];
        if (v24 != 4)
        {
          if (v24 != 10)
            goto LABEL_50;
          v23 = *(_DWORD **)v21;
          goto LABEL_41;
        }
        v28 = **(_DWORD **)v21;
      }
      else
      {
        if (v22 != 4)
        {
          v23 = v20 + 2;
          if (v22 != 10)
            goto LABEL_50;
LABEL_41:
          v25 = *(_QWORD *)v23;
          v26 = *((unsigned __int16 *)v23 + 4);
          if (v25 == 0x69726F687475613ALL && v26 == 31092)
            goto LABEL_164;
LABEL_50:
          v29 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(a2, (uint64_t)(v20 + 2));
          if (!v29)
            goto LABEL_166;
          v30 = v29;
          v31 = (std::string *)(v29 + 40);
          v32 = (unsigned __int8 **)(v20 + 5);
          v33 = v29[63];
          if (v33 >= 0)
            v34 = v29[63];
          else
            v34 = *((_QWORD *)v29 + 6);
          v35 = *((unsigned __int8 *)v20 + 63);
          v36 = (char)v35;
          if ((v35 & 0x80u) != 0)
            v35 = v20[6];
          if (v34 == v35)
          {
            if (v36 >= 0)
              v37 = (unsigned __int8 *)(v20 + 5);
            else
              v37 = *v32;
            if ((v29[63] & 0x80) != 0)
            {
              if (memcmp(v31->__r_.__value_.__l.__data_, v37, *((_QWORD *)v29 + 6)))
                goto LABEL_67;
            }
            else if (v29[63])
            {
              v38 = v29 + 40;
              v39 = v29[63];
              while (*v38 == *v37)
              {
                ++v38;
                ++v37;
                if (!--v39)
                  goto LABEL_164;
              }
              goto LABEL_67;
            }
LABEL_164:
            v20 = (uint64_t *)*v20;
            if (!v20)
              goto LABEL_24;
            continue;
          }
LABEL_67:
          if ((v22 & 0x80) != 0)
          {
            v41 = v20[3];
            if (v41 == 6)
            {
              v40 = *(int **)v21;
              goto LABEL_72;
            }
            goto LABEL_118;
          }
          v40 = (int *)(v20 + 2);
          if (v22 != 6)
            goto LABEL_77;
LABEL_72:
          v42 = *v40;
          v43 = *((unsigned __int16 *)v40 + 2);
          if (v42 != 1701012321 || v43 != 29808)
          {
            if ((v22 & 0x80) == 0)
              goto LABEL_77;
LABEL_117:
            v41 = v20[3];
LABEL_118:
            if (v41 != 15)
              goto LABEL_166;
            v21 = *(_DWORD **)v21;
LABEL_120:
            if (*(_QWORD *)v21 != 0x652D747065636361 || *(_QWORD *)((char *)v21 + 7) != 0x676E69646F636E65)
              goto LABEL_166;
            v57 = v30[63];
            if ((v57 & 0x80u) == 0)
              v58 = v30[63];
            else
              v58 = *((_QWORD *)v30 + 6);
            v59 = *((unsigned __int8 *)v20 + 63);
            v60 = (char)v59;
            if ((v59 & 0x80u) != 0)
              v59 = v20[6];
            if (v58 == v59)
            {
              if (v60 >= 0)
                v61 = (unsigned __int8 *)(v20 + 5);
              else
                v61 = *v32;
              if ((v57 & 0x80) != 0)
              {
                if (!memcmp(v31->__r_.__value_.__l.__data_, v61, *((_QWORD *)v30 + 6)))
                  goto LABEL_164;
              }
              else
              {
                if (!v30[63])
                  goto LABEL_164;
                v62 = v31;
                while (v62->__r_.__value_.__s.__data_[0] == *v61)
                {
                  v62 = (std::string *)((char *)v62 + 1);
                  ++v61;
                  if (!--v57)
                    goto LABEL_164;
                }
              }
            }
            v98 = 0;
            v99 = &v98;
            v100 = 0x2020000000;
            v101 = 1;
            v89 = 0;
            v90 = &v89;
            v91 = 0x5812000000;
            v92 = __Block_byref_object_copy__5;
            v93 = __Block_byref_object_dispose__6;
            v94 = 0u;
            v95 = 0u;
            v96 = 0;
            v97 = 1065353216;
            std::string::basic_string[abi:nn180100]<0>(v87, ", \t");
            v63 = MEMORY[0x1E0C809B0];
            if ((char)v30[63] < 0)
              std::string::__init_copy_ctor_external(&v86, *((const std::string::value_type **)v30 + 5), *((_QWORD *)v30 + 6));
            else
              v86 = *v31;
            aBlock = v63;
            v82 = 3221225472;
            v83 = ___Z42__HTTP2ServerPushMatchAcceptEncodingHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke;
            v84 = &unk_1E14FDCB0;
            v85 = &v89;
            v107 = 0;
            v105 = &off_1E14F01F8;
            v106 = _Block_copy(&aBlock);
            v107 = &v105;
            split((uint64_t)&v86, (unsigned __int8 *)v87, (uint64_t)&v105);
            v64 = v107;
            if (v107 == &v105)
            {
              v64 = &v105;
              v65 = 4;
LABEL_148:
              (*v64)[v65]();
            }
            else if (v107)
            {
              v65 = 5;
              goto LABEL_148;
            }
            if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v86.__r_.__value_.__l.__data_);
            if (*((char *)v20 + 63) < 0)
            {
              std::string::__init_copy_ctor_external(&v80, (const std::string::value_type *)v20[5], v20[6]);
            }
            else
            {
              *(_OWORD *)&v80.__r_.__value_.__l.__data_ = *(_OWORD *)v32;
              v80.__r_.__value_.__r.__words[2] = v20[7];
            }
            v74 = v63;
            v75 = 3221225472;
            v76 = ___Z42__HTTP2ServerPushMatchAcceptEncodingHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke_2;
            v77 = &unk_1E14FDCD8;
            v78 = &v89;
            v79 = &v98;
            v104 = 0;
            v102 = &off_1E14F01F8;
            v103 = _Block_copy(&v74);
            v104 = &v102;
            split((uint64_t)&v80, (unsigned __int8 *)v87, (uint64_t)&v102);
            v66 = v104;
            if (v104 == &v102)
            {
              v66 = &v102;
              v67 = 4;
LABEL_158:
              (*v66)[v67]();
            }
            else if (v104)
            {
              v67 = 5;
              goto LABEL_158;
            }
            if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v80.__r_.__value_.__l.__data_);
            v68 = *((unsigned __int8 *)v99 + 24);
            if (v88 < 0)
              operator delete(v87[0]);
            _Block_object_dispose(&v89, 8);
            std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v94 + 8);
            _Block_object_dispose(&v98, 8);
            if (!v68)
              goto LABEL_166;
            goto LABEL_164;
          }
          if (v33 >= 0)
            v45 = v31;
          else
            v45 = (std::string *)v31->__r_.__value_.__r.__words[0];
          if (v34 >= 3)
          {
            v46 = (char *)v45 + v34;
            v47 = v45;
            do
            {
              v48 = (char *)memchr(v47, 42, v34 - 2);
              if (!v48)
                break;
              if (*(_WORD *)v48 == 12074 && v48[2] == 42)
              {
                if (v48 != v46 && v48 - (char *)v45 != -1)
                  goto LABEL_164;
                break;
              }
              v47 = (std::string *)(v48 + 1);
              v34 = v46 - (char *)v47;
            }
            while (v46 - (char *)v47 >= 3);
          }
          v98 = 0;
          v99 = &v98;
          v100 = 0x2020000000;
          v101 = 0;
          v89 = 0;
          v90 = &v89;
          v91 = 0x5812000000;
          v92 = __Block_byref_object_copy__17333;
          v93 = __Block_byref_object_dispose__17334;
          v94 = 0u;
          v95 = 0u;
          v96 = 0;
          v97 = 1065353216;
          std::string::basic_string[abi:nn180100]<0>(v87, ",; \t");
          v50 = MEMORY[0x1E0C809B0];
          if ((char)v30[63] < 0)
            std::string::__init_copy_ctor_external(&v86, *((const std::string::value_type **)v30 + 5), *((_QWORD *)v30 + 6));
          else
            v86 = *v31;
          aBlock = v50;
          v82 = 3221225472;
          v83 = ___Z34__HTTP2ServerPushMatchAcceptHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke;
          v84 = &unk_1E14FDCB0;
          v85 = &v89;
          v107 = 0;
          v105 = &off_1E14F01F8;
          v106 = _Block_copy(&aBlock);
          v107 = &v105;
          split((uint64_t)&v86, (unsigned __int8 *)v87, (uint64_t)&v105);
          v51 = v107;
          if (v107 == &v105)
          {
            v51 = &v105;
            v52 = 4;
LABEL_100:
            (*v51)[v52]();
          }
          else if (v107)
          {
            v52 = 5;
            goto LABEL_100;
          }
          if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v86.__r_.__value_.__l.__data_);
          if (*((char *)v20 + 63) < 0)
          {
            std::string::__init_copy_ctor_external(&v80, (const std::string::value_type *)v20[5], v20[6]);
          }
          else
          {
            *(_OWORD *)&v80.__r_.__value_.__l.__data_ = *(_OWORD *)v32;
            v80.__r_.__value_.__r.__words[2] = v20[7];
          }
          v74 = v50;
          v75 = 3221225472;
          v76 = ___Z34__HTTP2ServerPushMatchAcceptHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke_2;
          v77 = &unk_1E14FDCD8;
          v78 = &v89;
          v79 = &v98;
          v104 = 0;
          v102 = &off_1E14F01F8;
          v103 = _Block_copy(&v74);
          v104 = &v102;
          split((uint64_t)&v80, (unsigned __int8 *)v87, (uint64_t)&v102);
          v53 = v104;
          if (v104 == &v102)
          {
            v53 = &v102;
            v54 = 4;
LABEL_110:
            (*v53)[v54]();
          }
          else if (v104)
          {
            v54 = 5;
            goto LABEL_110;
          }
          if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v80.__r_.__value_.__l.__data_);
          v55 = *((unsigned __int8 *)v99 + 24);
          if (v88 < 0)
            operator delete(v87[0]);
          _Block_object_dispose(&v89, 8);
          std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table((uint64_t)&v94 + 8);
          _Block_object_dispose(&v98, 8);
          if (v55)
            goto LABEL_164;
          v22 = *((unsigned __int8 *)v20 + 39);
          if ((v22 & 0x80) != 0)
            goto LABEL_117;
LABEL_77:
          if (v22 != 15)
            goto LABEL_166;
          goto LABEL_120;
        }
        v28 = *v21;
      }
      break;
    }
    if (v28 != 1953722216)
      goto LABEL_50;
    goto LABEL_164;
  }
LABEL_24:
  if (SHIBYTE(v73) < 0)
    operator delete(__p);
  return (uint64_t)v7;
}

void sub_184103808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48,char a49)
{
  uint64_t v49;

  if (a48 < 0)
    operator delete(__p);
  _Block_object_dispose(&a49, 8);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table(a12);
  _Block_object_dispose((const void *)(v49 - 232), 8);
  if (a19 < 0)
    operator delete(a14);
  _Unwind_Resume(a1);
}

void *HTTP2ServerPush::removeAsRefusedStream(HTTP2ServerPush *this, int a2)
{
  uint64_t *v4;
  uint64_t v5;

  v4 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)this + 6, a2);
  if (v4)
  {
    v5 = v4[3];
    if (v5)
      HTTP2ServerPushStream::_invokeCompletionHadlers(v5, 7);
  }
  return HTTP2ServerPush::_removeStream(this, a2, 1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v1 + 24);
    operator delete(v1);
  }
}

uint64_t __Block_byref_object_copy__39(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = a2[6];
  a2[6] = 0;
  *(_QWORD *)(result + 48) = v2;
  *(_QWORD *)(result + 56) = a2[7];
  a2[7] = 0;
  v5 = a2[8];
  v3 = a2 + 8;
  v4 = v5;
  *(_QWORD *)(result + 64) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 64;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__40(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(a1 + 48);
}

void ___ZN15HTTP2ServerPush24getFramerForHTTP3RequestERK11HTTP3FieldsU13block_pointerFvNSt3__110shared_ptrI11HTTP3FramerEEbE_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3, size_t __len, unsigned int a5, unsigned int a6)
{
  unint64_t v6;
  uint64_t v11;
  _QWORD *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  std::string *p_dst;
  unsigned int v16;
  unsigned int v17;
  int v18;
  char *v19;
  size_t v20;
  std::string::size_type size;
  std::string *v22;
  const void *v23;
  std::string *v24;
  std::string *p_p;
  std::string::size_type v26;
  std::string *v27;
  std::string::size_type v28;
  char v29;
  char *v30;
  char *v31;
  uint64_t v32;
  void *v33;
  __int128 v34;
  std::string *v35;
  std::string::size_type v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint8x8_t v40;
  unint64_t v41;
  unsigned __int8 **v42;
  unsigned __int8 *v43;
  unint64_t v44;
  char *v45;
  _QWORD *v46;
  std::string *v47;
  float v48;
  float v49;
  _BOOL8 v50;
  unint64_t v51;
  unint64_t v52;
  size_t v53;
  _QWORD *v54;
  unint64_t v55;
  int v56;
  std::string v57;
  std::string v58;
  std::string __p;
  std::string __dst;
  std::string v61;
  _QWORD v62[4];

  v62[2] = *MEMORY[0x1E0C80C00];
  std::string::basic_string[abi:nn180100](&__dst, (void *)(a2 + a3), __len);
  std::string::basic_string[abi:nn180100](&__p, (void *)(a2 + a5), a6);
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v12 = (_QWORD *)(v11 + 48);
  v13 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>((_QWORD *)(v11 + 48), (uint64_t)&__dst);
  if (v13)
  {
    v14 = v13;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      if (__dst.__r_.__value_.__l.__size_ == 6)
      {
        p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
LABEL_9:
        v16 = 1668247403;
        v17 = bswap32(p_dst->__r_.__value_.__l.__data_);
        if (v17 == 1668247403
          && (v17 = bswap32(WORD2(p_dst->__r_.__value_.__r.__words[0])) >> 16, v16 = 26981, v17 == 26981))
        {
          v18 = 0;
        }
        else if (v17 < v16)
        {
          v18 = -1;
        }
        else
        {
          v18 = 1;
        }
        if (v18)
          v19 = ", ";
        else
          v19 = "; ";
LABEL_19:
        std::string::basic_string[abi:nn180100]<0>(&v57, v19);
        if ((v14[63] & 0x80u) == 0)
          v20 = v14[63];
        else
          v20 = *((_QWORD *)v14 + 6);
        if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(v57.__r_.__value_.__r.__words[2]);
        else
          size = v57.__r_.__value_.__l.__size_;
        v22 = &v61;
        std::string::basic_string[abi:nn180100]((uint64_t)&v61, size + v20);
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v22 = (std::string *)v61.__r_.__value_.__r.__words[0];
        if (v20)
        {
          if ((v14[63] & 0x80u) == 0)
            v23 = v14 + 40;
          else
            v23 = (const void *)*((_QWORD *)v14 + 5);
          memmove(v22, v23, v20);
        }
        if (size)
        {
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v24 = &v57;
          else
            v24 = (std::string *)v57.__r_.__value_.__r.__words[0];
          memmove((char *)v22 + v20, v24, size);
        }
        v22->__r_.__value_.__s.__data_[v20 + size] = 0;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v26 = __p.__r_.__value_.__l.__size_;
        v27 = std::string::append(&v61, (const std::string::value_type *)p_p, v26);
        v28 = v27->__r_.__value_.__r.__words[0];
        v62[0] = v27->__r_.__value_.__l.__size_;
        *(_QWORD *)((char *)v62 + 7) = *(std::string::size_type *)((char *)&v27->__r_.__value_.__r.__words[1] + 7);
        v29 = HIBYTE(v27->__r_.__value_.__r.__words[2]);
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        v30 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, (uint64_t)&__dst, (uint64_t)&__dst);
        v31 = v30;
        if (v30[63] < 0)
          operator delete(*((void **)v30 + 5));
        v32 = v62[0];
        *((_QWORD *)v31 + 5) = v28;
        *((_QWORD *)v31 + 6) = v32;
        *(_QWORD *)(v31 + 55) = *(_QWORD *)((char *)v62 + 7);
        v31[63] = v29;
        if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v61.__r_.__value_.__l.__data_);
        if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
        {
          v33 = (void *)v57.__r_.__value_.__r.__words[0];
          goto LABEL_103;
        }
        goto LABEL_104;
      }
    }
    else if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) == 6)
    {
      p_dst = &__dst;
      goto LABEL_9;
    }
    v19 = ", ";
    goto LABEL_19;
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v57, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  else
    v57 = __dst;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v58, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  else
    v58 = __p;
  v34 = *(_OWORD *)&v57.__r_.__value_.__l.__data_;
  v56 = SHIBYTE(v57.__r_.__value_.__r.__words[2]);
  if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v35 = &v57;
  else
    v35 = (std::string *)v57.__r_.__value_.__r.__words[0];
  if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v36 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
  else
    v36 = v57.__r_.__value_.__l.__size_;
  v37 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v35, v36);
  v38 = v37;
  v39 = *(_QWORD *)(v11 + 56);
  if (!v39)
    goto LABEL_76;
  v40 = (uint8x8_t)vcnt_s8((int8x8_t)v39);
  v40.i16[0] = vaddlv_u8(v40);
  v41 = v40.u32[0];
  if (v40.u32[0] > 1uLL)
  {
    v6 = v37;
    if (v37 >= v39)
      v6 = v37 % v39;
  }
  else
  {
    v6 = (v39 - 1) & v37;
  }
  v42 = *(unsigned __int8 ***)(*v12 + 8 * v6);
  if (!v42 || (v43 = *v42) == 0)
  {
LABEL_76:
    v45 = (char *)operator new(0x40uLL);
    v46 = (_QWORD *)(v11 + 64);
    v61.__r_.__value_.__r.__words[0] = (std::string::size_type)v45;
    v61.__r_.__value_.__l.__size_ = v11 + 64;
    v61.__r_.__value_.__s.__data_[16] = 0;
    v47 = (std::string *)(v45 + 16);
    *(_QWORD *)v45 = 0;
    *((_QWORD *)v45 + 1) = v38;
    if (v56 < 0)
    {
      std::string::__init_copy_ctor_external(v47, (const std::string::value_type *)v34, *((std::string::size_type *)&v34 + 1));
    }
    else
    {
      *(_OWORD *)&v47->__r_.__value_.__l.__data_ = *(_OWORD *)&v57.__r_.__value_.__l.__data_;
      *((_QWORD *)v45 + 4) = *((_QWORD *)&v57.__r_.__value_.__l + 2);
    }
    *(std::string *)(v45 + 40) = v58;
    memset(&v58, 0, sizeof(v58));
    v61.__r_.__value_.__s.__data_[16] = 1;
    v48 = (float)(unint64_t)(*(_QWORD *)(v11 + 72) + 1);
    v49 = *(float *)(v11 + 80);
    if (!v39 || (float)(v49 * (float)v39) < v48)
    {
      v50 = 1;
      if (v39 >= 3)
        v50 = (v39 & (v39 - 1)) != 0;
      v51 = v50 | (2 * v39);
      v52 = vcvtps_u32_f32(v48 / v49);
      if (v51 <= v52)
        v53 = v52;
      else
        v53 = v51;
      std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>(v11 + 48, v53);
      v39 = *(_QWORD *)(v11 + 56);
      if ((v39 & (v39 - 1)) != 0)
      {
        if (v38 >= v39)
          v6 = v38 % v39;
        else
          v6 = v38;
      }
      else
      {
        v6 = (v39 - 1) & v38;
      }
    }
    v54 = *(_QWORD **)(*v12 + 8 * v6);
    if (v54)
    {
      *(_QWORD *)v45 = *v54;
    }
    else
    {
      *(_QWORD *)v45 = *v46;
      *v46 = v45;
      *(_QWORD *)(*v12 + 8 * v6) = v46;
      if (!*(_QWORD *)v45)
      {
LABEL_100:
        v61.__r_.__value_.__r.__words[0] = 0;
        ++*(_QWORD *)(v11 + 72);
        std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)&v61);
        goto LABEL_101;
      }
      v55 = *(_QWORD *)(*(_QWORD *)v45 + 8);
      if ((v39 & (v39 - 1)) != 0)
      {
        if (v55 >= v39)
          v55 %= v39;
      }
      else
      {
        v55 &= v39 - 1;
      }
      v54 = (_QWORD *)(*v12 + 8 * v55);
    }
    *v54 = v45;
    goto LABEL_100;
  }
  while (1)
  {
    v44 = *((_QWORD *)v43 + 1);
    if (v44 == v38)
      break;
    if (v41 > 1)
    {
      if (v44 >= v39)
        v44 %= v39;
    }
    else
    {
      v44 &= v39 - 1;
    }
    if (v44 != v6)
      goto LABEL_76;
LABEL_75:
    v43 = *(unsigned __int8 **)v43;
    if (!v43)
      goto LABEL_76;
  }
  if (!std::equal_to<std::string>::operator()[abi:nn180100](v43 + 16, (unsigned __int8 *)&v57))
    goto LABEL_75;
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v58.__r_.__value_.__l.__data_);
LABEL_101:
  if (v56 < 0)
  {
    v33 = (void *)v34;
LABEL_103:
    operator delete(v33);
  }
LABEL_104:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
}

void sub_184104050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)&a33);
  std::pair<std::string,std::string>::~pair((uint64_t)&a11);
  if (a26 < 0)
    operator delete(__p);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>>>::__erase_unique<int>(_QWORD *a1, int a2)
{
  uint64_t *v3;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t *v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD v13[2];
  char v14;

  v3 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>(a1, a2);
  if (v3)
  {
    v4 = (int8x8_t)a1[1];
    v5 = v3[1];
    v6 = (uint8x8_t)vcnt_s8(v4);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      if (v5 >= *(_QWORD *)&v4)
        v5 %= *(_QWORD *)&v4;
    }
    else
    {
      v5 &= *(_QWORD *)&v4 - 1;
    }
    v7 = *(uint64_t **)(*a1 + 8 * v5);
    do
    {
      v8 = v7;
      v7 = (uint64_t *)*v7;
    }
    while (v7 != v3);
    if (v8 == a1 + 2)
      goto LABEL_19;
    v9 = v8[1];
    if (v6.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v4)
        v9 %= *(_QWORD *)&v4;
    }
    else
    {
      v9 &= *(_QWORD *)&v4 - 1;
    }
    if (v9 != v5)
    {
LABEL_19:
      if (!*v3)
        goto LABEL_20;
      v10 = *(_QWORD *)(*v3 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(_QWORD *)&v4)
          v10 %= *(_QWORD *)&v4;
      }
      else
      {
        v10 &= *(_QWORD *)&v4 - 1;
      }
      if (v10 != v5)
LABEL_20:
        *(_QWORD *)(*a1 + 8 * v5) = 0;
    }
    v11 = *v3;
    if (*v3)
    {
      v12 = *(_QWORD *)(v11 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v12 >= *(_QWORD *)&v4)
          v12 %= *(_QWORD *)&v4;
      }
      else
      {
        v12 &= *(_QWORD *)&v4 - 1;
      }
      if (v12 != v5)
      {
        *(_QWORD *)(*a1 + 8 * v12) = v8;
        v11 = *v3;
      }
    }
    *v8 = v11;
    *v3 = 0;
    --a1[3];
    v13[0] = v3;
    v13[1] = a1 + 2;
    v14 = 1;
    std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>>>>::reset[abi:nn180100]((uint64_t)v13);
  }
}

void ___ZN15HTTP2ServerPush24getFramerForHTTP3RequestERK11HTTP3FieldsU13block_pointerFvNSt3__110shared_ptrI11HTTP3FramerEEbE_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  int v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = (_QWORD *)(v2 + 256);
  v4 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)(v2 + 256), *(_DWORD *)(a1 + 48));
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)(a1 + 32);
    v8 = v5[3];
    v7 = (std::__shared_weak_count *)v5[4];
    v16 = v8;
    v17 = v7;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
    }
    v11 = *(_DWORD *)(v2 + 168);
    if (v11 > 2147483597 || v11 - *(_DWORD *)(v2 + 172) + *(_DWORD *)(v2 + 200) + *(_DWORD *)(v2 + 72) > 49)
    {
      v12 = 0;
    }
    else
    {
      *(_DWORD *)(v2 + 168) = v11 + 50;
      v12 = 1;
    }
    (*(void (**)(uint64_t, uint64_t *, uint64_t))(v6 + 16))(v6, &v16, v12);
    v13 = v17;
    if (v17)
    {
      v14 = (unint64_t *)&v17->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    std::__hash_table<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>>>::__erase_unique<int>(v3, *(_DWORD *)(a1 + 48));
  }
  else
  {
    (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32));
  }
}

void sub_1841043B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

dispatch_queue_t ___ZL17configureLogQueuev_block_invoke()
{
  NSObject *v0;
  dispatch_queue_t result;

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  result = dispatch_queue_create("metricstream_queue", v0);
  logQueue = (uint64_t)result;
  return result;
}

void __CFNReportSSLSymptom(uint64_t a1, int a2)
{
  NSObject *v4;
  double v5;
  double Helper_x8__symptom_framework_init;
  uint64_t v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v13 = 134218240;
    v14 = a1;
    v15 = 1024;
    v16 = a2;
    _os_log_debug_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEBUG, "Sending SSL symptom [%ld:%d]", (uint8_t *)&v13, 0x12u);
  }
  Helper_x8__symptom_framework_init = gotLoadHelper_x8__symptom_framework_init(v5);
  if (*(_QWORD *)(v7 + 304))
  {
    ++__CFNReportSSLSymptom::sSSLSymptomsReported;
    if (getSymptomHandle(void)::sInitSymptomFramework != -1)
      dispatch_once(&getSymptomHandle(void)::sInitSymptomFramework, &__block_literal_global_17446);
    symptom_new_delayInitStub(Helper_x8__symptom_framework_init);
    symptom_set_qualifier_delayInitStub(v8);
    symptom_set_qualifier_delayInitStub(v9);
    symptom_set_qualifier_delayInitStub(v10);
    symptom_set_qualifier_delayInitStub(v11);
    symptom_send_delayInitStub(v12);
  }
}

void __CFNPopulateTransactionMetrics(_QWORD *a1, NSMutableDictionary *a2)
{
  void *v4;
  void *v5;
  unint64_t v6;
  char *v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;

  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDBytes:", a1 + 10);
  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDBytes:", a1 + 8);
  if (v4 && !-[NSMutableDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("taskUUID")))
  {
    -[NSMutableDictionary setValue:forKey:](a2, "setValue:forKey:", objc_msgSend(v4, "UUIDString"), CFSTR("taskUUID"));
    if (!v5)
      goto LABEL_7;
  }
  else if (!v5)
  {
    goto LABEL_7;
  }
  if (!-[NSMutableDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("activityUUID")))
    -[NSMutableDictionary setValue:forKey:](a2, "setValue:forKey:", objc_msgSend(v5, "UUIDString"), CFSTR("activityUUID"));
LABEL_7:
  v11 = (id)objc_msgSend((id)-[NSMutableDictionary objectForKey:](a2, "objectForKey:", CFSTR("transactionMetrics")), "mutableCopy");
  if (a1[7])
  {
    v6 = 0;
    v7 = (char *)(a1 + 19);
    do
    {
      if (v11 && objc_msgSend(v11, "count") > v6)
      {
        v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDBytes:", v7);
        v9 = (void *)objc_msgSend((id)objc_msgSend(v11, "objectAtIndex:", v6), "mutableCopy");
        v10 = v9;
        if (v8 && !objc_msgSend(v9, "objectForKey:", CFSTR("connectionUUID")))
        {
          objc_msgSend(v10, "setValue:forKey:", objc_msgSend(v8, "UUIDString"), CFSTR("connectionUUID"));
          objc_msgSend(v11, "replaceObjectAtIndex:withObject:", v6, v10);
          -[NSMutableDictionary setValue:forKey:](a2, "setValue:forKey:", v11, CFSTR("transactionMetrics"));
        }

      }
      ++v6;
      v7 += 120;
    }
    while (a1[7] > v6);
  }

}

void ___Z28__CFNReportMetricsToSymptomsPvm_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t buf[4];
  int v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(MEMORY[0x1E0CB36D8], "isValidJSONObject:", *(_QWORD *)(a1 + 32)))
  {
    v7 = 0;
    v2 = objc_msgSend(MEMORY[0x1E0CB36D8], "dataWithJSONObject:options:error:", *(_QWORD *)(a1 + 32), 0, &v7);
    if (!v7)
    {
      v3 = (void *)v2;
      if (v2)
      {
        v4 = metricLog;
        if (os_log_type_enabled((os_log_t)metricLog, OS_LOG_TYPE_DEFAULT))
        {
          v5 = objc_msgSend(v3, "length");
          v6 = objc_msgSend(v3, "bytes");
          *(_DWORD *)buf = 68157954;
          v9 = v5;
          v10 = 2082;
          v11 = v6;
          _os_log_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEFAULT, "%{public}.*s", buf, 0x12u);
        }
      }
    }
  }
}

void ___Z30__CFNReportNetworkScoreMetricsPvmPK10__CFStringjj_block_invoke(_QWORD *a1)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  void *v9;
  uint64_t v10;
  id v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  void *v17;
  id v18;
  uint64_t aBlock;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;

  v18 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  objc_msgSend(v18, "setValue:forKey:", CFSTR("HTTP_NETWORKSCORE_DATA"), CFSTR("name"));
  objc_msgSend(v18, "setValue:forKey:", a1[4], CFSTR("HTTP_NETWORKSCORE_DATA"));
  objc_msgSend(v18, "setValue:forKey:", a1[5], CFSTR("BundleID"));
  v2 = objc_alloc_init(MEMORY[0x1E0CB3578]);
  objc_msgSend(v2, "setDateFormat:", CFSTR("yyyy-MM-dd'T'HH:mm:ssZZZZZ"));
  v3 = objc_msgSend(v2, "stringFromDate:", objc_msgSend(MEMORY[0x1E0C99D68], "now"));

  objc_msgSend(v18, "setValue:forKey:", v3, CFSTR("METRIC_DATE"));
  objc_msgSend((id)networkScoreMetrics, "addObject:", v18);
  if ((unint64_t)objc_msgSend((id)networkScoreMetrics, "count") >= 2)
  {
    v4 = a1[6];
    v5 = (void *)logQueue;
    v6 = (id)networkScoreMetrics;
    v7 = v5;
    v8 = v7;
    if (v4)
    {
      v9 = *(void **)(v4 + 8);
      v10 = MEMORY[0x1E0C809B0];
      if (!v9)
      {
        v11 = v7;
        v12 = objc_msgSend(objc_alloc(MEMORY[0x1E0CB3B38]), "initWithMachServiceName:options:", CFSTR("com.apple.networkscored"), 4096);
        v13 = *(void **)(v4 + 8);
        *(_QWORD *)(v4 + 8) = v12;

        objc_msgSend(MEMORY[0x1E0CB3B50], "interfaceWithProtocol:", &unk_1EDD195E8);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(*(id *)(v4 + 8), "setRemoteObjectInterface:", v14);

        objc_msgSend(*(id *)(v4 + 8), "setInterruptionHandler:", &__block_literal_global_7096);
        aBlock = v10;
        v20 = 3221225472;
        v21 = __48____NSCFNetworkScoreReporting_createConnection___block_invoke_4;
        v22 = &unk_1E14FE118;
        v23 = v4;
        v15 = _Block_copy(&aBlock);
        objc_msgSend(*(id *)(v4 + 8), "setInvalidationHandler:", v15);
        objc_msgSend(*(id *)(v4 + 8), "_setQueue:", v11);
        objc_msgSend(*(id *)(v4 + 8), "activate");

        v9 = *(void **)(v4 + 8);
      }
      v16 = v9;
      aBlock = v10;
      v20 = 3221225472;
      v21 = __49____NSCFNetworkScoreReporting_sendMetrics_queue___block_invoke;
      v22 = &unk_1E14F9B68;
      v23 = v4;
      objc_msgSend(v16, "remoteObjectProxyWithErrorHandler:", &aBlock);
      v17 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v17, "sendHTTPMetricsWithMetrics:", v6);
    }

    objc_msgSend((id)networkScoreMetrics, "removeAllObjects");
  }

}

void sub_184104B30(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void ___ZL26setupNetworkScoreReportingv_block_invoke()
{
  networkScoreMetrics = (uint64_t)objc_alloc_init(MEMORY[0x1E0C99DE8]);
  setupNetworkScoreReporting(void)::networkScoreReporting = objc_alloc_init(__NSCFNetworkScoreReporting);
  if (configureLogQueue(void)::sInitLogQueue != -1)
    dispatch_once(&configureLogQueue(void)::sInitLogQueue, &__block_literal_global_26_17449);
}

CFAllocatorRef URLConnection::_irl_allocator(URLConnection *this)
{
  return CFGetAllocator((char *)this - 16);
}

uint64_t URLConnection::_irl_retain(URLConnection *this)
{
  CFRetain((char *)this - 16);
  return (uint64_t)this + 8;
}

void URLConnection::_irl_release(URLConnection *this)
{
  CFRelease((char *)this - 16);
}

void sub_18410535C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1841053EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_184105530(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_184105670(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1841056DC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_184105F58(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZL19__CopyHeadersStringP15__CFHTTPMessagePK10__CFString_block_invoke(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "compare:");
}

void CFURLCacheFS::asyncCacheDirectoryRemove(CFURLCacheFS *this, const char *a2)
{
  char *v3;
  char *v4;
  NSObject *global_queue;
  NSObject *v6;
  int v7;
  _QWORD block[5];
  uint8_t buf[4];
  CFURLCacheFS *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = strndup((const char *)this, 0x400uLL);
  if (v3)
  {
    v4 = v3;
    global_queue = dispatch_get_global_queue(-2, 0);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZNK12CFURLCacheFS25asyncCacheDirectoryRemoveEPKc_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = v4;
    dispatch_async(global_queue, block);
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v7 = *__error();
      *(_DWORD *)buf = 136315394;
      v10 = this;
      v11 = 1024;
      v12 = v7;
      _os_log_error_impl(&dword_183ECA000, v6, OS_LOG_TYPE_ERROR, "asyncCacheDirectoryRemove - failed to duplicate target string for dir %s.  Errno=%{errno}d", buf, 0x12u);
    }
  }
}

void ___ZNK12CFURLCacheFS25asyncCacheDirectoryRemoveEPKc_block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (removefile(*(const char **)(a1 + 32), 0, 1u))
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v2 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v3 = *(_QWORD *)(a1 + 32);
      v4 = *__error();
      v5 = 136315394;
      v6 = v3;
      v7 = 1024;
      v8 = v4;
      _os_log_error_impl(&dword_183ECA000, v2, OS_LOG_TYPE_ERROR, "asyncCacheDirectoryRemove - failed to remove old cache dir %s.  Errno=%{errno}d", (uint8_t *)&v5, 0x12u);
    }
  }
  free(*(void **)(a1 + 32));
}

void _CFURLCacheFSPurgeItemFromFileSystemStore(uint64_t a1, char *a2)
{
  const __CFString *v3;
  const __CFString *v4;
  char *v5;
  NSObject *v6;
  BOOL v7;
  NSObject *v8;
  int v9;
  BOOL v10;
  uint8_t buf[4];
  char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@/%s"), *(_QWORD *)(a1 + 80), a2);
    if (v3)
    {
      v4 = v3;
      v10 = 0;
      v5 = _ExtractCStringfromCFStringRef(v3, &v10);
      if (unlink(v5) == -1 && *__error() != 2)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v6 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          v9 = *__error();
          *(_DWORD *)buf = 136315394;
          v12 = v5;
          v13 = 1024;
          v14 = v9;
          _os_log_error_impl(&dword_183ECA000, v6, OS_LOG_TYPE_ERROR, "ERROR: purgeItemFromFileSystemStore - unlink of file %s failed Errno=%{errno}d.", buf, 0x12u);
        }
      }
      if (v5)
        v7 = !v10;
      else
        v7 = 1;
      if (!v7)
        MEMORY[0x186DB7474](v5, 0x1000C8077774924);
      CFRelease(v4);
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v8 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315138;
        v12 = a2;
        _os_log_error_impl(&dword_183ECA000, v8, OS_LOG_TYPE_ERROR, "ERROR: purgeItemFromFileSystemStore - unable to create path to file %s.", buf, 0xCu);
      }
    }
  }
}

void sub_18410875C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{

}

void sub_1841088D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_184108960(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__18519(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void sub_184108AEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_184108B98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_184108C20(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_184108D6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_184108E60(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_184108FBC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1841090B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1841091E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_184109250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t xx_CFHSTSPolicyHandleSTSHeader(char *a1, const __CFString *a2, const __CFURL *a3)
{
  HSTSPolicy *v6;

  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
  if (a1)
    v6 = (HSTSPolicy *)(a1 + 16);
  else
    v6 = 0;
  return HSTSPolicy::handleSTSHeader(v6, a2, a3);
}

NSString *xx_CFHSTSPolicyIsKnownHSTSHost(char *a1, const __CFURL *a2)
{
  HSTSPolicy *v4;
  NSString *result;
  unsigned __int8 v6;

  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
  if (a1)
    v4 = (HSTSPolicy *)(a1 + 16);
  else
    v4 = 0;
  if (!a2)
    return 0;
  result = (NSString *)-[__CFURL host](a2, "host");
  if (result)
    return (NSString *)HSTSPolicy::isKnownHSTSHost(v4, result, &v6);
  return result;
}

uint64_t xx_CFHSTSPolicyIsKnownHSTSHostWithBytes(char *a1, unsigned __int8 *a2, CFIndex a3)
{
  HSTSPolicy *v6;
  unsigned __int8 v8;

  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
  if (a1)
    v6 = (HSTSPolicy *)(a1 + 16);
  else
    v6 = 0;
  return HSTSPolicy::isKnownHSTSHost(v6, a2, a3, &v8);
}

uint64_t xx_CFHSTSPolicyUpdateHSTSInfoForHost(char *a1, CFStringRef theString, const __CFDictionary *a3)
{
  CFIndex Length;
  CFMutableStringRef MutableCopy;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  HSTSPolicy *v10;
  uint64_t updated;
  unint64_t v12;

  Length = CFStringGetLength(theString);
  MutableCopy = CFStringCreateMutableCopy(0, Length, theString);
  v8 = (std::__shared_weak_count *)operator new();
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1010;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)MutableCopy;
  CFStringLowercase(MutableCopy, 0);
  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
  if (a1)
    v10 = (HSTSPolicy *)(a1 + 16);
  else
    v10 = 0;
  updated = HSTSPolicy::updateHSTSInfoForHost(v10, MutableCopy, a3);
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  return updated;
}

void sub_184109584(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *v2;
  unint64_t v4;

  do
    v4 = __ldaxr(v2);
  while (__stlxr(v4 - 1, v2));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL xx_createKerberosTicketForHostWithPassword(const char *a1, const char *a2, const char *a3, const char *a4, uint64_t a5, const char *a6, double a7)
{
  int SvcTicketForHostWithPassword;
  void *v9;
  _BYTE v10[4];

  v9 = 0;
  SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(a7, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)v10, (uint64_t)&v9, a5, (uint64_t)a6, 0);
  if (v9)
    free(v9);
  return SvcTicketForHostWithPassword == 0;
}

uint64_t xx_destroyAllKerberosTickets(double a1)
{
  return gss_iter_creds_delayInitStub(a1);
}

uint64_t xx_listKerberosTickets(double a1)
{
  return gss_iter_creds_delayInitStub(a1);
}

uint64_t xx_equalType(const _CFURLCredential *a1, const _CFURLCredential *a2)
{
  if (a1 && a2)
    return CFEqual(a1, a2);
  else
    return 0;
}

void yydestruct(int a1, CFTypeRef *a2)
{
  switch(a1)
  {
    case 4:
    case 5:
    case 6:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 27:
    case 28:
    case 29:
      if (*a2)
        CFRelease(*a2);
      break;
    default:
      return;
  }
}

void yydestruct_19755(int a1, CFTypeRef *a2)
{
  switch(a1)
  {
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 27:
    case 28:
    case 29:
      if (*a2)
        CFRelease(*a2);
      break;
    default:
      return;
  }
}

void qenc_hist_update_size(uint64_t a1, unsigned int a2)
{
  _QWORD *v4;
  _QWORD *v5;
  FILE *v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;

  if (*(_DWORD *)(a1 + 228) != a2)
  {
    if (!a2)
    {
      *(_QWORD *)(a1 + 224) = 0;
      *(_DWORD *)(a1 + 232) = 0;
      return;
    }
    v4 = malloc_type_malloc(8 * (a2 + 1), 0x100004000313F17uLL);
    if (!v4)
      return;
    v5 = v4;
    v6 = *(FILE **)(a1 + 200);
    if (v6)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v6);
      fprintf(*(FILE **)(a1 + 200), "history size change from %u to %u", *(_DWORD *)(a1 + 228), a2);
      fputc(10, *(FILE **)(a1 + 200));
    }
    v7 = *(_DWORD *)(a1 + 224);
    if (*(_DWORD *)(a1 + 232))
    {
      v8 = v7 + 1;
      v7 = *(_DWORD *)(a1 + 228);
      v9 = v8 % v7;
    }
    else
    {
      v9 = 0;
      if (!v7)
      {
        LODWORD(v10) = 0;
LABEL_15:
        v13 = v10 % a2;
        *(_DWORD *)(a1 + 224) = v13;
        *(_DWORD *)(a1 + 228) = a2;
        *(_DWORD *)(a1 + 232) = v13 == 0;
        free(*(void **)(a1 + 216));
        *(_QWORD *)(a1 + 216) = v5;
        return;
      }
    }
    v10 = 0;
    v11 = v7 - 1;
    do
    {
      v12 = v10;
      v5[v10] = *(_QWORD *)(*(_QWORD *)(a1 + 216) + 8 * ((v9 + v10) % *(_DWORD *)(a1 + 228)));
      ++v10;
    }
    while (v11 != v12 && v10 < a2);
    goto LABEL_15;
  }
}

uint64_t enc_proc_stream_cancel(uint64_t a1, unint64_t a2)
{
  FILE *v4;
  FILE *v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  FILE *v10;
  FILE *v11;

  v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got Cancel Stream instruction; stream=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (!(a2 >> 62))
  {
    v7 = *(_QWORD *)(a1 + 96);
    if (v7)
    {
      v8 = 0;
      do
      {
        v9 = *(_QWORD *)v7;
        if (*(_QWORD *)(v7 + 40) == a2)
        {
          v10 = *(FILE **)(a1 + 200);
          if (v10)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v10);
            fprintf(*(FILE **)(a1 + 200), "cancel header block for stream %llu, seqno %u", a2, *(_DWORD *)(v7 + 48));
            fputc(10, *(FILE **)(a1 + 200));
          }
          if (*(_DWORD *)(v7 + 60) > *(_DWORD *)(a1 + 4))
            qenc_remove_from_risked_list(a1, (_QWORD *)v7);
          enc_free_hinfo(a1, v7);
          ++v8;
        }
        v7 = v9;
      }
      while (v9);
    }
    else
    {
      v8 = 0;
    }
    v11 = *(FILE **)(a1 + 200);
    if (!v11)
      return 0;
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v11);
    fprintf(*(FILE **)(a1 + 200), "cancelled %u header block%.*s of stream %llu", v8, v8 != 1, "s", a2);
    v6 = 0;
    goto LABEL_20;
  }
  v5 = *(FILE **)(a1 + 200);
  if (v5)
  {
    fwrite("qenc: info: ", 0xCuLL, 1uLL, v5);
    fprintf(*(FILE **)(a1 + 200), "Invalid stream ID %llu in Cancel Stream", a2);
    v6 = 0xFFFFFFFFLL;
LABEL_20:
    fputc(10, *(FILE **)(a1 + 200));
    return v6;
  }
  return 0xFFFFFFFFLL;
}

uint64_t enc_proc_ici(uint64_t a1, unint64_t a2)
{
  FILE *v4;
  FILE *v5;
  FILE *v6;
  unsigned int v7;
  FILE *v8;
  FILE *v10;
  FILE *v11;

  v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got ICI instruction, count=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (!a2)
  {
    v6 = *(FILE **)(a1 + 200);
    if (v6)
    {
      fwrite("qenc: info: ", 0xCuLL, 1uLL, v6);
      fwrite("ICI=0 is an error", 0x11uLL, 1uLL, *(FILE **)(a1 + 200));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  if (HIDWORD(a2))
  {
    v5 = *(FILE **)(a1 + 200);
    if (v5)
    {
      fwrite("qenc: info: ", 0xCuLL, 1uLL, v5);
      fprintf(*(FILE **)(a1 + 200), "insertion count too high: %llu");
LABEL_12:
      fputc(10, *(FILE **)(a1 + 200));
      return 0xFFFFFFFFLL;
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_DWORD *)(a1 + 8) + a2;
  if (v7 > *(_DWORD *)a1)
  {
    v8 = *(FILE **)(a1 + 200);
    if (v8)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
      fprintf(*(FILE **)(a1 + 200), "ICI: max_acked %u is larger than number of inserts %u");
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  if (v7 <= *(_DWORD *)(a1 + 4))
  {
    v11 = *(FILE **)(a1 + 200);
    if (v11)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v11);
      fprintf(*(FILE **)(a1 + 200), "duplicate ICI: %u", v7);
      fputc(10, *(FILE **)(a1 + 200));
    }
  }
  else
  {
    *(_DWORD *)(a1 + 4) = v7;
    *(_DWORD *)(a1 + 8) = v7;
    v10 = *(FILE **)(a1 + 200);
    if (v10)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v10);
      fprintf(*(FILE **)(a1 + 200), "max acked ID is now %u", *(_DWORD *)(a1 + 4));
      fputc(10, *(FILE **)(a1 + 200));
    }
    qenc_update_risked_list(a1);
  }
  return 0;
}

float lsqpack_dec_ratio(uint64_t a1)
{
  unsigned int v1;
  float v3;
  FILE *v4;

  v1 = *(_DWORD *)(a1 + 28);
  if (!v1)
    return 0.0;
  v3 = (float)*(unsigned int *)(a1 + 24) / (float)v1;
  v4 = *(FILE **)(a1 + 48);
  if (v4)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 48), "bytes in: %u; bytes out: %u, ratio: %.3f",
      *(_DWORD *)(a1 + 28),
      *(_DWORD *)(a1 + 24),
      v3);
    fputc(10, *(FILE **)(a1 + 48));
  }
  return v3;
}

uint64_t lsqpack_huff_decode_full(_BYTE *a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5, int a6)
{
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned __int8 *v11;
  unsigned __int8 v12;
  char *v13;
  char v14;
  char v15;

  if ((_DWORD)a4)
  {
    v6 = &a3[(int)a4];
    v7 = a1;
    v8 = a3;
    switch(*(_DWORD *)a5)
    {
      case 0:
        *(_WORD *)(a5 + 4) = 256;
        v7 = a1;
        v8 = a3;
        goto LABEL_6;
      case 1:
        goto LABEL_6;
      case 2:
        goto LABEL_8;
      case 3:
        v10 = *(unsigned __int8 *)(a5 + 4);
        v7 = a1;
        v8 = a3;
        break;
      default:
        goto LABEL_20;
    }
    while (1)
    {
      v13 = (char *)&decode_tables + 48 * v10 + 3 * (*v7 & 0xF);
      v14 = v13[1];
      if ((v14 & 4) != 0)
      {
LABEL_17:
        a4 = 0;
        v9 = 3;
        return v9 | (a4 << 32);
      }
      v15 = *v13;
      if ((v13[1] & 2) != 0)
      {
        *v8++ = v13[2];
        *(_BYTE *)(a5 + 4) = v15;
        *(_BYTE *)(a5 + 5) = v14 & 1;
      }
      else
      {
        *(_BYTE *)(a5 + 4) = v15;
        *(_BYTE *)(a5 + 5) = v14 & 1;
        if (!v8)
          goto LABEL_17;
      }
      ++v7;
LABEL_6:
      if (v7 == &a1[a2])
        break;
      if (v8 == v6)
      {
        v9 = 2;
        *(_DWORD *)a5 = 2;
        return v9 | (a4 << 32);
      }
LABEL_8:
      v11 = (unsigned __int8 *)&decode_tables
          + 48 * *(unsigned __int8 *)(a5 + 4)
          + 3 * ((unint64_t)*v7 >> 4);
      v12 = v11[1];
      if ((v12 & 4) != 0)
        goto LABEL_17;
      v10 = *v11;
      if ((v11[1] & 2) != 0)
      {
        *v8++ = v11[2];
        *(_BYTE *)(a5 + 4) = v10;
        *(_BYTE *)(a5 + 5) = v12 & 1;
      }
      else
      {
        *(_BYTE *)(a5 + 4) = v10;
        *(_BYTE *)(a5 + 5) = v12 & 1;
        if (!v8)
          goto LABEL_17;
      }
      if (v8 == v6)
      {
        *(_DWORD *)a5 = 3;
        goto LABEL_4;
      }
    }
LABEL_20:
    if (a6)
    {
      v9 = 3;
      if (*(_BYTE *)(a5 + 5))
        v9 = 0;
    }
    else
    {
      v9 = 1;
      *(_DWORD *)a5 = 1;
    }
    a4 = ((_DWORD)v8 - (_DWORD)a3);
  }
  else
  {
LABEL_4:
    v9 = 2;
  }
  return v9 | (a4 << 32);
}

uint64_t header_out_begin_dynamic_nameref(unsigned int *a1, _QWORD *a2, unsigned int *a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  size_t v12;
  char *v13;
  char *v14;
  uint64_t result;

  if (a2[10])
    __assert_rtn("header_out_begin_dynamic_nameref", "lsqpack.c", 3131, "!read_ctx->hbrc_out.xhdr");
  v8 = 4 * (*a1 & 1);
  v9 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*((_QWORD *)a1 + 5) + 8))(a2[4], 0, v8 + *a3);
  a2[10] = v9;
  if (!v9)
    return 0xFFFFFFFFLL;
  v10 = v9;
  *(_BYTE *)(v9 + 35) = v8;
  if (a4)
    *(_BYTE *)(v9 + 33) |= 0x40u;
  qdec_maybe_update_entry_hashes(*a1, a3);
  v11 = a3[6];
  if ((v11 & 1) != 0)
  {
    *(_BYTE *)(v10 + 33) |= 8u;
    *(_DWORD *)(v10 + 8) = a3[3];
    v11 = a3[6];
  }
  if ((v11 & 4) != 0)
  {
    *(_BYTE *)(v10 + 33) |= 2u;
    *(_BYTE *)(v10 + 31) = a3[5];
  }
  v12 = *a3;
  *(_WORD *)(v10 + 24) = v12;
  v13 = (char *)(*(_QWORD *)v10 + *(int *)(v10 + 16));
  memcpy(v13, a3 + 7, v12);
  v14 = &v13[*a3];
  if ((_DWORD)v8)
  {
    *(_WORD *)v14 = 8250;
    LOWORD(v14) = (_WORD)v14 + 2;
  }
  result = 0;
  *(_DWORD *)(v10 + 20) = (unsigned __int16)((_WORD)v14 - *(_DWORD *)v10);
  a2[11] = 1;
  return result;
}

uint64_t header_out_grow_buf(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  FILE *v12;

  v4 = (_QWORD *)(a2 + 80);
  v3 = *(_QWORD *)(a2 + 80);
  if (!v3)
    __assert_rtn("header_out_grow_buf", "lsqpack.c", 3291, "read_ctx->hbrc_out.xhdr");
  if (*(_DWORD *)(a2 + 88))
    v6 = *(_DWORD *)(v3 + 20) - *(_DWORD *)(v3 + 16) + *(_DWORD *)(a2 + 92);
  else
    v6 = *(_DWORD *)(a2 + 92);
  v7 = *(unsigned __int16 *)(v3 + 26);
  v8 = v7 >= v6;
  v9 = v7 - v6;
  if (!v8)
    __assert_rtn("header_out_grow_buf", "lsqpack.c", 3303, "read_ctx->hbrc_out.xhdr->val_len >= off");
  if (v9 <= 2)
    v9 = 2;
  if ((v9 >> 1) + (unint64_t)*(unsigned __int16 *)(v3 + 26) >= 0xFFFF)
    v10 = 0xFFFFLL;
  else
    v10 = (v9 >> 1) + (unint64_t)*(unsigned __int16 *)(v3 + 26);
  v11 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 40) + 8))(*(_QWORD *)(a2 + 32));
  *(_QWORD *)(a2 + 80) = v11;
  if (!v11)
    return 0xFFFFFFFFLL;
  if (v10 > *(unsigned __int16 *)(v11 + 26))
  {
    v12 = *(FILE **)(a1 + 48);
    if (v12)
    {
      fwrite("qdec: info: ", 0xCuLL, 1uLL, v12);
      fprintf(*(FILE **)(a1 + 48), "allocated xhdr size (%zd) is smaller than requested (%zd)", *(unsigned __int16 *)(*v4 + 26), v10);
      fputc(10, *(FILE **)(a1 + 48));
    }
    *v4 = 0;
    v4[1] = 0;
    return 0xFFFFFFFFLL;
  }
  return 0;
}

void __URLSESSION_CLIENT_API_MISUSE_INVALIDATED_SESSION__(NSString *a1)
{
  objc_exception_throw((id)objc_msgSend(MEMORY[0x1E0C99DA0], "exceptionWithName:reason:userInfo:", *MEMORY[0x1E0C99750], CFSTR("Task created in a session that has been invalidated"), 0));
}

void __URLSESSION_CLIENT_API_MISUSE_NIL_ARGUMENT__(NSString *a1)
{
  objc_exception_throw((id)objc_msgSend(MEMORY[0x1E0C99DA0], "exceptionWithName:reason:userInfo:", *MEMORY[0x1E0C99778], a1, 0));
}

uint64_t NSRequestConcreteImplementation(uint64_t a1, const char *a2, objc_class *a3)
{
  uint64_t v5;
  void *v6;
  uint64_t v7;
  const char *Name;
  objc_class *v9;
  const char *v10;
  uint64_t v12;

  v5 = objc_opt_class();
  v6 = (void *)MEMORY[0x1E0C99DA0];
  v7 = *MEMORY[0x1E0C99778];
  Name = sel_getName(a2);
  if ((objc_class *)v5 == a3)
    return objc_msgSend(v6, "raise:format:", v7, CFSTR("*** -%s cannot be sent to an abstract object of class %s: Create a concrete instance!"), Name, class_getName(a3), v12);
  v9 = (objc_class *)objc_opt_class();
  v10 = class_getName(v9);
  return objc_msgSend(v6, "raise:format:", v7, CFSTR("*** -%s only defined for abstract class.  Define -[%s %s]!"), Name, v10, sel_getName(a2));
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x1E0C80310](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x1E0C80318](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1E0C80320](c, data, *(_QWORD *)&len);
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1E0C80328](data, *(_QWORD *)&len, md);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

SInt32 CFAbsoluteTimeGetDayOfWeek(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  return MEMORY[0x1E0C97C68](tz, at);
}

CFGregorianDate CFAbsoluteTimeGetGregorianDate(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  uint64_t v2;
  double v3;
  CFGregorianDate result;

  v2 = MEMORY[0x1E0C97C88](tz, at);
  result.second = v3;
  result.year = v2;
  result.month = BYTE4(v2);
  result.day = BYTE5(v2);
  result.hour = BYTE6(v2);
  result.minute = HIBYTE(v2);
  return result;
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  return (void *)MEMORY[0x1E0C97C98](allocator, size, hint);
}

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  return (CFAllocatorRef)MEMORY[0x1E0C97CA8](allocator, context);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
  MEMORY[0x1E0C97CB0](allocator, ptr);
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  return (CFAllocatorRef)MEMORY[0x1E0C97CC0]();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  MEMORY[0x1E0C97CE8](theArray, otherArray, otherRange.location, otherRange.length);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x1E0C97D00](theArray, range.location, range.length, applier, context);
}

CFIndex CFArrayBSearchValues(CFArrayRef theArray, CFRange range, const void *value, CFComparatorFunction comparator, void *context)
{
  return MEMORY[0x1E0C97D08](theArray, range.location, range.length, value, comparator, context);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D10](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1E0C97D20](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1E0C97D30](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D50](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D78](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
  MEMORY[0x1E0C97DA8](theArray, range.location, range.length, values);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DB0](theArray, idx, value);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  MEMORY[0x1E0C97DB8](theArray);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x1E0C97DC0](theArray, idx);
}

void CFArrayReplaceValues(CFMutableArrayRef theArray, CFRange range, const void **newValues, CFIndex newCount)
{
  MEMORY[0x1E0C97DC8](theArray, range.location, range.length, newValues, newCount);
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  MEMORY[0x1E0C97DE0](theArray, range.location, range.length, comparator, context);
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return (CFTypeRef)MEMORY[0x1E0C97E90](arg);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

CFURLRef CFBundleCopyExecutableURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1E0C98020](bundle);
}

uint64_t CFBundleCopyLocalizationForLocalizationInfo()
{
  return MEMORY[0x1E0C98038]();
}

CFStringRef CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return (CFStringRef)MEMORY[0x1E0C98050](bundle, key, value, tableName);
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1E0C98080](bundle, resourceName, resourceType, subDirName);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1E0C980E8](bundleID);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1E0C98120](bundle);
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98130](bundle);
}

uint64_t CFBundleGetLocalizationInfoForLocalization()
{
  return MEMORY[0x1E0C98140]();
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1E0C98150]();
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0C98180](bundle, key);
}

CFCharacterSetRef CFCharacterSetCreateInvertedSet(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982C0](alloc, theSet);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982E8](alloc, theString);
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982F0](theSetIdentifier);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return MEMORY[0x1E0C98320](theSet, theChar);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1E0C98350](cf);
}

uint64_t CFCopyHomeDirectoryURLForUser()
{
  return MEMORY[0x1E0C98368]();
}

uint64_t CFCopySearchPathForDirectoriesInDomains()
{
  return MEMORY[0x1E0C98370]();
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  MEMORY[0x1E0C98390](theData, bytes, length);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1E0C983B0](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983B8](allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983C0](allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1E0C983C8](allocator, bytes, length, bytesDeallocator);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
  MEMORY[0x1E0C983D0](theData, range.location, range.length);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  MEMORY[0x1E0C983F0](theData, range.location, range.length, buffer);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1E0C98408](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1E0C98418]();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  MEMORY[0x1E0C98430](theData, length);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1E0C98448](allocator, at);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C984D8](theDate);
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1E0C984E8]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98538](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98558](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x1E0C985A0](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1E0C985C8](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  MEMORY[0x1E0C985D8](theDict);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C985F8](theDict, key, value);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1E0C98630](err);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98648](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1E0C98650](allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1E0C98660](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x1E0C98670](err);
}

CFTypeID CFErrorGetTypeID(void)
{
  return MEMORY[0x1E0C98678]();
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1E0C98718](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFAbsoluteTime CFGregorianDateGetAbsoluteTime(CFGregorianDate gdate, CFTimeZoneRef tz)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C98748](*(_QWORD *)&gdate.year, *(_QWORD *)&gdate.second, tz);
  return result;
}

Boolean CFGregorianDateIsValid(CFGregorianDate gdate, CFOptionFlags unitFlags)
{
  return MEMORY[0x1E0C98750](*(_QWORD *)&gdate.year, *(_QWORD *)&gdate.second, unitFlags);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1E0C98758](cf);
}

CFLocaleRef CFLocaleGetSystem(void)
{
  return (CFLocaleRef)MEMORY[0x1E0C987F0]();
}

uint64_t CFLog()
{
  return MEMORY[0x1E0C98808]();
}

CFRunLoopSourceRef CFMachPortCreateRunLoopSource(CFAllocatorRef allocator, CFMachPortRef port, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x1E0C98818](allocator, port, order);
}

CFMachPortRef CFMachPortCreateWithPort(CFAllocatorRef allocator, mach_port_t portNum, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)MEMORY[0x1E0C98820](allocator, *(_QWORD *)&portNum, callout, context, shouldFreeInfo);
}

CFTypeID CFMachPortGetTypeID(void)
{
  return MEMORY[0x1E0C98838]();
}

void CFMachPortInvalidate(CFMachPortRef port)
{
  MEMORY[0x1E0C98840](port);
}

CFTypeRef CFMakeCollectable(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98858](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x1E0C988B0](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988B8]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
  MEMORY[0x1E0C988E0](center, name, object, userInfo, deliverImmediately);
}

void CFNotificationCenterRemoveEveryObserver(CFNotificationCenterRef center, const void *observer)
{
  MEMORY[0x1E0C988F0](center, observer);
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1E0C98908]();
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

Boolean CFPreferencesAppValueIsForced(CFStringRef key, CFStringRef applicationID)
{
  return MEMORY[0x1E0C98A38](key, applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A40](key, applicationID);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A60](key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A70](key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A78](key, applicationID, keyExistsAndHasValidFormat);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1E0C98AA0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AD0](allocator, data, options, format, error);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AE0](allocator, stream, streamLength, options, format, error);
}

Boolean CFPropertyListIsValid(CFPropertyListRef plist, CFPropertyListFormat format)
{
  return MEMORY[0x1E0C98AF0](plist, format);
}

CFIndex CFPropertyListWrite(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return MEMORY[0x1E0C98AF8](propertyList, stream, format, options, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  MEMORY[0x1E0C98B10](stream);
}

dispatch_queue_t CFReadStreamCopyDispatchQueue(CFReadStreamRef stream)
{
  return (dispatch_queue_t)MEMORY[0x1E0C98B18](stream);
}

CFErrorRef CFReadStreamCopyError(CFReadStreamRef stream)
{
  return (CFErrorRef)MEMORY[0x1E0C98B20](stream);
}

CFTypeRef CFReadStreamCopyProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1E0C98B28](stream, propertyName);
}

uint64_t CFReadStreamCreate()
{
  return MEMORY[0x1E0C98B30]();
}

CFReadStreamRef CFReadStreamCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFReadStreamRef)MEMORY[0x1E0C98B38](alloc, bytes, length, bytesDeallocator);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1E0C98B48](alloc, fileURL);
}

CFStreamError CFReadStreamGetError(CFReadStreamRef stream)
{
  CFIndex v1;
  uint64_t v2;
  CFStreamError result;

  v1 = MEMORY[0x1E0C98B58](stream);
  result.error = v2;
  result.domain = v1;
  return result;
}

uint64_t CFReadStreamGetInfoPointer()
{
  return MEMORY[0x1E0C98B60]();
}

CFStreamStatus CFReadStreamGetStatus(CFReadStreamRef stream)
{
  return MEMORY[0x1E0C98B68](stream);
}

CFTypeID CFReadStreamGetTypeID(void)
{
  return MEMORY[0x1E0C98B70]();
}

Boolean CFReadStreamHasBytesAvailable(CFReadStreamRef stream)
{
  return MEMORY[0x1E0C98B78](stream);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1E0C98B80](stream);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1E0C98B88](stream, buffer, bufferLength);
}

void CFReadStreamScheduleWithRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  MEMORY[0x1E0C98B90](stream, runLoop, runLoopMode);
}

Boolean CFReadStreamSetClient(CFReadStreamRef stream, CFOptionFlags streamEvents, CFReadStreamClientCallBack clientCB, CFStreamClientContext *clientContext)
{
  return MEMORY[0x1E0C98B98](stream, streamEvents, clientCB, clientContext);
}

void CFReadStreamSetDispatchQueue(CFReadStreamRef stream, dispatch_queue_t q)
{
  MEMORY[0x1E0C98BA0](stream, q);
}

Boolean CFReadStreamSetProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  return MEMORY[0x1E0C98BA8](stream, propertyName, propertyValue);
}

uint64_t CFReadStreamSignalEvent()
{
  return MEMORY[0x1E0C98BB0]();
}

void CFReadStreamUnscheduleFromRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  MEMORY[0x1E0C98BB8](stream, runLoop, runLoopMode);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98BF8](rl, source, mode);
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C00](rl, timer, mode);
}

Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  return MEMORY[0x1E0C98C10](rl, source, mode);
}

CFRunLoopMode CFRunLoopCopyCurrentMode(CFRunLoopRef rl)
{
  return (CFRunLoopMode)MEMORY[0x1E0C98C28](rl);
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1E0C98C30]();
}

Boolean CFRunLoopIsWaiting(CFRunLoopRef rl)
{
  return MEMORY[0x1E0C98C58](rl);
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
  MEMORY[0x1E0C98C80](rl, mode, block);
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C90](rl, source, mode);
}

void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98CA0](rl, timer, mode);
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return MEMORY[0x1E0C98CB0](mode, returnAfterSourceHandled, seconds);
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x1E0C98CC8](allocator, order, context);
}

void CFRunLoopSourceGetContext(CFRunLoopSourceRef source, CFRunLoopSourceContext *context)
{
  MEMORY[0x1E0C98CD0](source, context);
}

CFTypeID CFRunLoopSourceGetTypeID(void)
{
  return MEMORY[0x1E0C98CD8]();
}

void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source)
{
  MEMORY[0x1E0C98CE0](source);
}

Boolean CFRunLoopSourceIsValid(CFRunLoopSourceRef source)
{
  return MEMORY[0x1E0C98CE8](source);
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
  MEMORY[0x1E0C98CF0](source);
}

void CFRunLoopStop(CFRunLoopRef rl)
{
  MEMORY[0x1E0C98D00](rl);
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  return (CFRunLoopTimerRef)MEMORY[0x1E0C98D08](allocator, flags, order, callout, context, fireDate, interval);
}

CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, void *block)
{
  return (CFRunLoopTimerRef)MEMORY[0x1E0C98D10](allocator, flags, order, block, fireDate, interval);
}

CFTypeID CFRunLoopTimerGetTypeID(void)
{
  return MEMORY[0x1E0C98D40]();
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
  MEMORY[0x1E0C98D48](timer);
}

Boolean CFRunLoopTimerIsValid(CFRunLoopTimerRef timer)
{
  return MEMORY[0x1E0C98D50](timer);
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
  MEMORY[0x1E0C98D58](timer, fireDate);
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
  MEMORY[0x1E0C98D68](rl);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98D70](theSet, value);
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98D78](theSet, applier, context);
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1E0C98D80](theSet, value);
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  return (CFSetRef)MEMORY[0x1E0C98D88](allocator, values, numValues, callBacks);
}

CFSetRef CFSetCreateCopy(CFAllocatorRef allocator, CFSetRef theSet)
{
  return (CFSetRef)MEMORY[0x1E0C98D90](allocator, theSet);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98D98](allocator, capacity, callBacks);
}

CFMutableSetRef CFSetCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFSetRef theSet)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98DA0](allocator, capacity, theSet);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1E0C98DA8](theSet);
}

CFTypeID CFSetGetTypeID(void)
{
  return MEMORY[0x1E0C98DB8]();
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
  MEMORY[0x1E0C98DD0](theSet, values);
}

void CFSetRemoveAllValues(CFMutableSetRef theSet)
{
  MEMORY[0x1E0C98DD8](theSet);
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98DE0](theSet, value);
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98DF0](theSet, value);
}

void CFShow(CFTypeRef obj)
{
  MEMORY[0x1E0C98DF8](obj);
}

CFDataRef CFSocketCopyAddress(CFSocketRef s)
{
  return (CFDataRef)MEMORY[0x1E0C98E00](s);
}

CFDataRef CFSocketCopyPeerAddress(CFSocketRef s)
{
  return (CFDataRef)MEMORY[0x1E0C98E08](s);
}

CFSocketRef CFSocketCreate(CFAllocatorRef allocator, SInt32 protocolFamily, SInt32 socketType, SInt32 protocol, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  return (CFSocketRef)MEMORY[0x1E0C98E10](allocator, *(_QWORD *)&protocolFamily, *(_QWORD *)&socketType, *(_QWORD *)&protocol, callBackTypes, callout, context);
}

CFRunLoopSourceRef CFSocketCreateRunLoopSource(CFAllocatorRef allocator, CFSocketRef s, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x1E0C98E18](allocator, s, order);
}

CFSocketRef CFSocketCreateWithNative(CFAllocatorRef allocator, CFSocketNativeHandle sock, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  return (CFSocketRef)MEMORY[0x1E0C98E20](allocator, *(_QWORD *)&sock, callBackTypes, callout, context);
}

void CFSocketDisableCallBacks(CFSocketRef s, CFOptionFlags callBackTypes)
{
  MEMORY[0x1E0C98E28](s, callBackTypes);
}

void CFSocketEnableCallBacks(CFSocketRef s, CFOptionFlags callBackTypes)
{
  MEMORY[0x1E0C98E30](s, callBackTypes);
}

CFSocketNativeHandle CFSocketGetNative(CFSocketRef s)
{
  return MEMORY[0x1E0C98E38](s);
}

CFOptionFlags CFSocketGetSocketFlags(CFSocketRef s)
{
  return MEMORY[0x1E0C98E40](s);
}

CFTypeID CFSocketGetTypeID(void)
{
  return MEMORY[0x1E0C98E48]();
}

void CFSocketInvalidate(CFSocketRef s)
{
  MEMORY[0x1E0C98E50](s);
}

Boolean CFSocketIsValid(CFSocketRef s)
{
  return MEMORY[0x1E0C98E58](s);
}

CFSocketError CFSocketSetAddress(CFSocketRef s, CFDataRef address)
{
  return MEMORY[0x1E0C98E60](s, address);
}

void CFSocketSetSocketFlags(CFSocketRef s, CFOptionFlags flags)
{
  MEMORY[0x1E0C98E68](s, flags);
}

void CFStreamCreateBoundPair(CFAllocatorRef alloc, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream, CFIndex transferBufferSize)
{
  MEMORY[0x1E0C98EC0](alloc, readStream, writeStream, transferBufferSize);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x1E0C98ED8](theString, appendedString);
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
  MEMORY[0x1E0C98EE0](theString, cStr, *(_QWORD *)&encoding);
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
  MEMORY[0x1E0C98EE8](theString, chars, numChars);
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  MEMORY[0x1E0C98EF0](theString, formatOptions, format);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F18](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

unint64_t CFStringConvertEncodingToNSStringEncoding(CFStringEncoding encoding)
{
  return MEMORY[0x1E0C98F30](*(_QWORD *)&encoding);
}

CFStringEncoding CFStringConvertNSStringEncodingToEncoding(unint64_t encoding)
{
  return MEMORY[0x1E0C98F48](encoding);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1E0C98F58](alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1E0C98F68](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1E0C98F78](alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return (CFDataRef)MEMORY[0x1E0C98F80](alloc, theString, *(_QWORD *)&encoding, lossByte);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F90](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F98](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1E0C98FB8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FC8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FE0](alloc, cStr, *(_QWORD *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1E0C98FE8](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  return (CFStringRef)MEMORY[0x1E0C99008](alloc, buffer);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1E0C99020](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithPascalString(CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C99028](alloc, pStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99030](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
  MEMORY[0x1E0C99038](theString, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99050](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C99058](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99060](theString, theSet, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99068](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1E0C99080](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1E0C990B0](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  MEMORY[0x1E0C990C0](theString, range.location, range.length, buffer);
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return (const UniChar *)MEMORY[0x1E0C990C8](theString);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  double result;

  MEMORY[0x1E0C990D0](str);
  return result;
}

CFStringEncoding CFStringGetFastestEncoding(CFStringRef theString)
{
  return MEMORY[0x1E0C990D8](theString);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C990E0](string, buffer, maxBufLen);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1E0C990F0](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99118](length, *(_QWORD *)&encoding);
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  return MEMORY[0x1E0C99128](string);
}

Boolean CFStringGetPascalString(CFStringRef theString, StringPtr buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99148](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1E0C99180](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1E0C99190](theString, suffix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  MEMORY[0x1E0C991B8](str, idx, insertedStr);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x1E0C991D0](theString, locale);
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
  MEMORY[0x1E0C991F0](theString, range.location, range.length, replacement);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
  MEMORY[0x1E0C99258](theString);
}

CFTimeZoneRef CFTimeZoneCopyDefault(void)
{
  return (CFTimeZoneRef)MEMORY[0x1E0C99270]();
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1E0C99280]();
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  return (CFTimeZoneRef)MEMORY[0x1E0C99290](allocator, ti);
}

CFTimeInterval CFTimeZoneGetSecondsFromGMT(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  CFTimeInterval result;

  MEMORY[0x1E0C992A0](tz, at);
  return result;
}

Boolean CFURLCanBeDecomposed(CFURLRef anURL)
{
  return MEMORY[0x1E0C992B0](anURL);
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1E0C992C8](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1E0C992D8](anURL, pathStyle);
}

CFStringRef CFURLCopyHostName(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C992F0](anURL);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C992F8](url);
}

CFStringRef CFURLCopyNetLocation(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99300](anURL);
}

CFStringRef CFURLCopyPassword(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99310](anURL);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99318](anURL);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C99320](url);
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  return MEMORY[0x1E0C99338](url, key, propertyValueTypeRefPtr, error);
}

CFStringRef CFURLCopyResourceSpecifier(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99340](anURL);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99348](anURL);
}

CFStringRef CFURLCopyStrictPath(CFURLRef anURL, Boolean *isAbsolute)
{
  return (CFStringRef)MEMORY[0x1E0C99350](anURL, isAbsolute);
}

CFStringRef CFURLCopyUserName(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99358](anURL);
}

CFURLRef CFURLCreateAbsoluteURLWithBytes(CFAllocatorRef alloc, const UInt8 *relativeURLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL, Boolean useCompatibilityMode)
{
  return (CFURLRef)MEMORY[0x1E0C99360](alloc, relativeURLBytes, length, *(_QWORD *)&encoding, baseURL, useCompatibilityMode);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99380](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1E0C99390](allocator, url);
}

CFURLRef CFURLCreateCopyDeletingPathExtension(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1E0C99398](allocator, url);
}

Boolean CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  return MEMORY[0x1E0C993B0](alloc, url, resourceData, properties, desiredProperties, errorCode);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C993C8](allocator, buffer, bufLen, isDirectory);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C993F8](allocator, originalString, charactersToLeaveUnescaped, legalURLCharactersToBeEscaped, *(_QWORD *)&encoding);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1E0C99400](allocator, originalString, charactersToLeaveEscaped);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapesUsingEncoding(CFAllocatorRef allocator, CFStringRef origString, CFStringRef charsToLeaveEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C99408](allocator, origString, charsToLeaveEscaped, *(_QWORD *)&encoding);
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99418](allocator, URLBytes, length, *(_QWORD *)&encoding, baseURL);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPathRelativeToBase(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99438](allocator, filePath, pathStyle, isDirectory, baseURL);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99448](allocator, URLString, baseURL);
}

CFURLRef CFURLGetBaseURL(CFURLRef anURL)
{
  return (CFURLRef)MEMORY[0x1E0C99478](anURL);
}

CFRange CFURLGetByteRangeForComponent(CFURLRef url, CFURLComponentType component, CFRange *rangeIncludingSeparators)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99480](url, component, rangeIncludingSeparators);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFURLGetBytes(CFURLRef url, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1E0C99488](url, buffer, bufferLength);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C99490](url, resolveAgainstBase, buffer, maxBufLen);
}

SInt32 CFURLGetPortNumber(CFURLRef anURL)
{
  return MEMORY[0x1E0C99498](anURL);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C994A0](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1E0C994B8]();
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  return MEMORY[0x1E0C994C0](anURL);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1E0C99518](alloc);
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  return (CFUUIDRef)MEMORY[0x1E0C99520](alloc, uuidStr);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1E0C99538](alloc, uuid);
}

CFTypeID CFUUIDGetTypeID(void)
{
  return MEMORY[0x1E0C99560]();
}

Boolean CFWriteStreamCanAcceptBytes(CFWriteStreamRef stream)
{
  return MEMORY[0x1E0C995F8](stream);
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
  MEMORY[0x1E0C99600](stream);
}

CFErrorRef CFWriteStreamCopyError(CFWriteStreamRef stream)
{
  return (CFErrorRef)MEMORY[0x1E0C99608](stream);
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1E0C99610](stream, propertyName);
}

uint64_t CFWriteStreamCreate()
{
  return MEMORY[0x1E0C99618]();
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  return (CFWriteStreamRef)MEMORY[0x1E0C99620](alloc, bufferAllocator);
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)MEMORY[0x1E0C99630](alloc, fileURL);
}

CFStreamError CFWriteStreamGetError(CFWriteStreamRef stream)
{
  CFIndex v1;
  uint64_t v2;
  CFStreamError result;

  v1 = MEMORY[0x1E0C99638](stream);
  result.error = v2;
  result.domain = v1;
  return result;
}

CFStreamStatus CFWriteStreamGetStatus(CFWriteStreamRef stream)
{
  return MEMORY[0x1E0C99640](stream);
}

CFTypeID CFWriteStreamGetTypeID(void)
{
  return MEMORY[0x1E0C99648]();
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x1E0C99650](stream);
}

void CFWriteStreamScheduleWithRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  MEMORY[0x1E0C99658](stream, runLoop, runLoopMode);
}

Boolean CFWriteStreamSetClient(CFWriteStreamRef stream, CFOptionFlags streamEvents, CFWriteStreamClientCallBack clientCB, CFStreamClientContext *clientContext)
{
  return MEMORY[0x1E0C99660](stream, streamEvents, clientCB, clientContext);
}

void CFWriteStreamSetDispatchQueue(CFWriteStreamRef stream, dispatch_queue_t q)
{
  MEMORY[0x1E0C99668](stream, q);
}

Boolean CFWriteStreamSetProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  return MEMORY[0x1E0C99670](stream, propertyName, propertyValue);
}

uint64_t CFWriteStreamSignalEvent()
{
  return MEMORY[0x1E0C99678]();
}

void CFWriteStreamUnscheduleFromRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  MEMORY[0x1E0C99680](stream, runLoop, runLoopMode);
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1E0C99688](stream, buffer, bufferLength);
}

DNSServiceErrorType DNSServiceAddRecord(DNSServiceRef sdRef, DNSRecordRef *RecordRef, DNSServiceFlags flags, uint16_t rrtype, uint16_t rdlen, const void *rdata, uint32_t ttl)
{
  return MEMORY[0x1E0C80400](sdRef, RecordRef, *(_QWORD *)&flags, rrtype, rdlen, rdata, *(_QWORD *)&ttl);
}

DNSServiceErrorType DNSServiceBrowse(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *regtype, const char *domain, DNSServiceBrowseReply callBack, void *context)
{
  return MEMORY[0x1E0C80420](sdRef, *(_QWORD *)&flags, *(_QWORD *)&interfaceIndex, regtype, domain, callBack, context);
}

DNSServiceErrorType DNSServiceConstructFullName(char *const fullName, const char *const service, const char *const regtype, const char *const domain)
{
  return MEMORY[0x1E0C80430](fullName, service, regtype, domain);
}

DNSServiceErrorType DNSServiceCreateConnection(DNSServiceRef *sdRef)
{
  return MEMORY[0x1E0C80438](sdRef);
}

DNSServiceErrorType DNSServiceEnumerateDomains(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, DNSServiceDomainEnumReply callBack, void *context)
{
  return MEMORY[0x1E0C80448](sdRef, *(_QWORD *)&flags, *(_QWORD *)&interfaceIndex, callBack, context);
}

DNSServiceErrorType DNSServiceProcessResult(DNSServiceRef sdRef)
{
  return MEMORY[0x1E0C80470](sdRef);
}

DNSServiceErrorType DNSServiceQueryRecord(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *fullname, uint16_t rrtype, uint16_t rrclass, DNSServiceQueryRecordReply callBack, void *context)
{
  return MEMORY[0x1E0C80478](sdRef, *(_QWORD *)&flags, *(_QWORD *)&interfaceIndex, fullname, rrtype, rrclass, callBack, context);
}

void DNSServiceRefDeallocate(DNSServiceRef sdRef)
{
  MEMORY[0x1E0C80490](sdRef);
}

dnssd_sock_t DNSServiceRefSockFD(DNSServiceRef sdRef)
{
  return MEMORY[0x1E0C80498](sdRef);
}

DNSServiceErrorType DNSServiceRegister(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *name, const char *regtype, const char *domain, const char *host, uint16_t port, uint16_t txtLen, const void *txtRecord, DNSServiceRegisterReply callBack, void *context)
{
  return MEMORY[0x1E0C804A0](sdRef, *(_QWORD *)&flags, *(_QWORD *)&interfaceIndex, name, regtype, domain, host, port);
}

DNSServiceErrorType DNSServiceRemoveRecord(DNSServiceRef sdRef, DNSRecordRef RecordRef, DNSServiceFlags flags)
{
  return MEMORY[0x1E0C804B0](sdRef, RecordRef, *(_QWORD *)&flags);
}

DNSServiceErrorType DNSServiceResolve(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *name, const char *regtype, const char *domain, DNSServiceResolveReply callBack, void *context)
{
  return MEMORY[0x1E0C804B8](sdRef, *(_QWORD *)&flags, *(_QWORD *)&interfaceIndex, name, regtype, domain, callBack, context);
}

DNSServiceErrorType DNSServiceUpdateRecord(DNSServiceRef sdRef, DNSRecordRef recordRef, DNSServiceFlags flags, uint16_t rdlen, const void *rdata, uint32_t ttl)
{
  return MEMORY[0x1E0C804E0](sdRef, recordRef, *(_QWORD *)&flags, rdlen, rdata, *(_QWORD *)&ttl);
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  return MEMORY[0x1E0CBAD20](*(_QWORD *)&kernelPort, notificationID);
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  return MEMORY[0x1E0CBAE38](notifier);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
  MEMORY[0x1E0CBB6A0](notify);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
  MEMORY[0x1E0CBB6B8](notify, queue);
}

IOReturn IOPMAssertionCreateWithProperties(CFDictionaryRef AssertionProperties, IOPMAssertionID *AssertionID)
{
  return MEMORY[0x1E0CBB718](AssertionProperties, AssertionID);
}

IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
{
  return MEMORY[0x1E0CBB738](*(_QWORD *)&AssertionID);
}

IOReturn IOPMAssertionSetProperty(IOPMAssertionID theAssertion, CFStringRef theProperty, CFTypeRef theValue)
{
  return MEMORY[0x1E0CBB748](*(_QWORD *)&theAssertion, theProperty, theValue);
}

io_connect_t IORegisterForSystemPower(void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  return MEMORY[0x1E0CBB8D8](refcon, thePortRef, callback, notifier);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x1E0CBB9D0](*(_QWORD *)&connect);
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x1E0CB2D88](format);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x1E0CB3250]();
}

uint64_t NtlmCreateClientRequest()
{
  return MEMORY[0x1E0CD5BE8]();
}

uint64_t NtlmGeneratePasswordHashes()
{
  return MEMORY[0x1E0CD5BF8]();
}

uint64_t NtlmGeneratorCreate()
{
  return MEMORY[0x1E0CD5C00]();
}

uint64_t NtlmGeneratorRelease()
{
  return MEMORY[0x1E0CD5C08]();
}

CFStringRef SCDynamicStoreCopyComputerName(SCDynamicStoreRef store, CFStringEncoding *nameEncoding)
{
  return (CFStringRef)MEMORY[0x1E0CE8738](store, nameEncoding);
}

CFArrayRef SCDynamicStoreCopyKeyList(SCDynamicStoreRef store, CFStringRef pattern)
{
  return (CFArrayRef)MEMORY[0x1E0CE8748](store, pattern);
}

CFDictionaryRef SCDynamicStoreCopyProxies(SCDynamicStoreRef store)
{
  return (CFDictionaryRef)MEMORY[0x1E0CE8760](store);
}

CFPropertyListRef SCDynamicStoreCopyValue(SCDynamicStoreRef store, CFStringRef key)
{
  return (CFPropertyListRef)MEMORY[0x1E0CE8768](store, key);
}

SCDynamicStoreRef SCDynamicStoreCreate(CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return (SCDynamicStoreRef)MEMORY[0x1E0CE8770](allocator, name, callout, context);
}

CFStringRef SCDynamicStoreKeyCreateNetworkGlobalEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef entity)
{
  return (CFStringRef)MEMORY[0x1E0CE8798](allocator, domain, entity);
}

CFStringRef SCDynamicStoreKeyCreateNetworkInterfaceEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef ifname, CFStringRef entity)
{
  return (CFStringRef)MEMORY[0x1E0CE87A8](allocator, domain, ifname, entity);
}

CFStringRef SCDynamicStoreKeyCreateNetworkServiceEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef serviceID, CFStringRef entity)
{
  return (CFStringRef)MEMORY[0x1E0CE87B0](allocator, domain, serviceID, entity);
}

SCNetworkConnectionRef SCNetworkConnectionCreateWithServiceID(CFAllocatorRef allocator, CFStringRef serviceID, SCNetworkConnectionCallBack callout, SCNetworkConnectionContext *context)
{
  return (SCNetworkConnectionRef)MEMORY[0x1E0CE8810](allocator, serviceID, callout, context);
}

SCNetworkConnectionStatus SCNetworkConnectionGetStatus(SCNetworkConnectionRef connection)
{
  return MEMORY[0x1E0CE8818](connection);
}

CFTypeID SCNetworkConnectionGetTypeID(void)
{
  return MEMORY[0x1E0CE8820]();
}

uint64_t SCNetworkProxiesCopyMatching()
{
  return MEMORY[0x1E0CE88A8]();
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithAddress(CFAllocatorRef allocator, const sockaddr *address)
{
  return (SCNetworkReachabilityRef)MEMORY[0x1E0CE88B8](allocator, address);
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithName(CFAllocatorRef allocator, const char *nodename)
{
  return (SCNetworkReachabilityRef)MEMORY[0x1E0CE88C8](allocator, nodename);
}

Boolean SCNetworkReachabilityGetFlags(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags *flags)
{
  return MEMORY[0x1E0CE88D8](target, flags);
}

CFTypeID SCNetworkReachabilityGetTypeID(void)
{
  return MEMORY[0x1E0CE88E0]();
}

Boolean SCNetworkReachabilitySetCallback(SCNetworkReachabilityRef target, SCNetworkReachabilityCallBack callout, SCNetworkReachabilityContext *context)
{
  return MEMORY[0x1E0CE88F0](target, callout, context);
}

Boolean SCNetworkReachabilitySetDispatchQueue(SCNetworkReachabilityRef target, dispatch_queue_t queue)
{
  return MEMORY[0x1E0CE88F8](target, queue);
}

uint64_t SCNetworkSignatureCopyIdentifierForConnectedSocket()
{
  return MEMORY[0x1E0CE89B0]();
}

OSStatus SSLClose(SSLContextRef context)
{
  return MEMORY[0x1E0CD5D38](context);
}

CFTypeID SSLContextGetTypeID(void)
{
  return MEMORY[0x1E0CD5D40]();
}

OSStatus SSLCopyDistinguishedNames(SSLContextRef context, CFArrayRef *names)
{
  return MEMORY[0x1E0CD5D48](context, names);
}

OSStatus SSLCopyPeerTrust(SSLContextRef context, SecTrustRef *trust)
{
  return MEMORY[0x1E0CD5D50](context, trust);
}

SSLContextRef SSLCreateContext(CFAllocatorRef alloc, SSLProtocolSide protocolSide, SSLConnectionType connectionType)
{
  return (SSLContextRef)MEMORY[0x1E0CD5D58](alloc, *(_QWORD *)&protocolSide, *(_QWORD *)&connectionType);
}

uint64_t SSLGetCertificate()
{
  return MEMORY[0x1E0CD5D68]();
}

OSStatus SSLGetClientCertificateState(SSLContextRef context, SSLClientCertificateState *clientState)
{
  return MEMORY[0x1E0CD5D70](context, clientState);
}

uint64_t SSLGetClientSideAuthenticate()
{
  return MEMORY[0x1E0CD5D78]();
}

OSStatus SSLGetNegotiatedCipher(SSLContextRef context, SSLCipherSuite *cipherSuite)
{
  return MEMORY[0x1E0CD5D80](context, cipherSuite);
}

OSStatus SSLGetNegotiatedProtocolVersion(SSLContextRef context, SSLProtocol *protocol)
{
  return MEMORY[0x1E0CD5D88](context, protocol);
}

OSStatus SSLGetPeerDomainName(SSLContextRef context, char *peerName, size_t *peerNameLen)
{
  return MEMORY[0x1E0CD5D90](context, peerName, peerNameLen);
}

OSStatus SSLGetPeerDomainNameLength(SSLContextRef context, size_t *peerNameLen)
{
  return MEMORY[0x1E0CD5D98](context, peerNameLen);
}

OSStatus SSLGetPeerID(SSLContextRef context, const void **peerID, size_t *peerIDLen)
{
  return MEMORY[0x1E0CD5DA0](context, peerID, peerIDLen);
}

OSStatus SSLGetProtocolVersionMax(SSLContextRef context, SSLProtocol *maxVersion)
{
  return MEMORY[0x1E0CD5DA8](context, maxVersion);
}

OSStatus SSLGetProtocolVersionMin(SSLContextRef context, SSLProtocol *minVersion)
{
  return MEMORY[0x1E0CD5DB0](context, minVersion);
}

OSStatus SSLGetSessionState(SSLContextRef context, SSLSessionState *state)
{
  return MEMORY[0x1E0CD5DB8](context, state);
}

OSStatus SSLHandshake(SSLContextRef context)
{
  return MEMORY[0x1E0CD5DC0](context);
}

uint64_t SSLProtocolFromVersionCodepoint()
{
  return MEMORY[0x1E0CD5DC8]();
}

OSStatus SSLRead(SSLContextRef context, void *data, size_t dataLength, size_t *processed)
{
  return MEMORY[0x1E0CD5DD0](context, data, dataLength, processed);
}

uint64_t SSLSetALPNData()
{
  return MEMORY[0x1E0CD5DD8]();
}

uint64_t SSLSetALPNFunc()
{
  return MEMORY[0x1E0CD5DE0]();
}

uint64_t SSLSetAllowAnonymousCiphers()
{
  return MEMORY[0x1E0CD5DE8]();
}

OSStatus SSLSetCertificate(SSLContextRef context, CFArrayRef certRefs)
{
  return MEMORY[0x1E0CD5DF0](context, certRefs);
}

OSStatus SSLSetClientSideAuthenticate(SSLContextRef context, SSLAuthenticate auth)
{
  return MEMORY[0x1E0CD5DF8](context, *(_QWORD *)&auth);
}

OSStatus SSLSetConnection(SSLContextRef context, SSLConnectionRef connection)
{
  return MEMORY[0x1E0CD5E00](context, connection);
}

uint64_t SSLSetDHEEnabled()
{
  return MEMORY[0x1E0CD5E08]();
}

OSStatus SSLSetEnabledCiphers(SSLContextRef context, const SSLCipherSuite *ciphers, size_t numCiphers)
{
  return MEMORY[0x1E0CD5E10](context, ciphers, numCiphers);
}

OSStatus SSLSetIOFuncs(SSLContextRef context, SSLReadFunc readFunc, SSLWriteFunc writeFunc)
{
  return MEMORY[0x1E0CD5E18](context, readFunc, writeFunc);
}

uint64_t SSLSetNPNData()
{
  return MEMORY[0x1E0CD5E28]();
}

uint64_t SSLSetNPNFunc()
{
  return MEMORY[0x1E0CD5E30]();
}

uint64_t SSLSetPSKIdentity()
{
  return MEMORY[0x1E0CD5E38]();
}

uint64_t SSLSetPSKSharedSecret()
{
  return MEMORY[0x1E0CD5E40]();
}

OSStatus SSLSetPeerDomainName(SSLContextRef context, const char *peerName, size_t peerNameLen)
{
  return MEMORY[0x1E0CD5E48](context, peerName, peerNameLen);
}

OSStatus SSLSetPeerID(SSLContextRef context, const void *peerID, size_t peerIDLen)
{
  return MEMORY[0x1E0CD5E50](context, peerID, peerIDLen);
}

OSStatus SSLSetProtocolVersionMax(SSLContextRef context, SSLProtocol maxVersion)
{
  return MEMORY[0x1E0CD5E58](context, *(_QWORD *)&maxVersion);
}

OSStatus SSLSetProtocolVersionMin(SSLContextRef context, SSLProtocol minVersion)
{
  return MEMORY[0x1E0CD5E60](context, *(_QWORD *)&minVersion);
}

OSStatus SSLSetSessionConfig(SSLContextRef context, CFStringRef config)
{
  return MEMORY[0x1E0CD5E68](context, config);
}

OSStatus SSLSetSessionOption(SSLContextRef context, SSLSessionOption option, Boolean value)
{
  return MEMORY[0x1E0CD5E70](context, *(_QWORD *)&option, value);
}

OSStatus SSLWrite(SSLContextRef context, const void *data, size_t dataLength, size_t *processed)
{
  return MEMORY[0x1E0CD5E78](context, data, dataLength, processed);
}

uint64_t SecAccessControlCopyData()
{
  return MEMORY[0x1E0CD5E90]();
}

uint64_t SecAccessControlCreateFromData()
{
  return MEMORY[0x1E0CD5EA0]();
}

CFTypeID SecAccessControlGetTypeID(void)
{
  return MEMORY[0x1E0CD5ED0]();
}

OSStatus SecCertificateCopyCommonName(SecCertificateRef certificate, CFStringRef *commonName)
{
  return MEMORY[0x1E0CD5F48](certificate, commonName);
}

uint64_t SecCertificateCopyDNSNames()
{
  return MEMORY[0x1E0CD5F58]();
}

CFDataRef SecCertificateCopyData(SecCertificateRef certificate)
{
  return (CFDataRef)MEMORY[0x1E0CD5F60](certificate);
}

OSStatus SecCertificateCopyEmailAddresses(SecCertificateRef certificate, CFArrayRef *emailAddresses)
{
  return MEMORY[0x1E0CD5F68](certificate, emailAddresses);
}

uint64_t SecCertificateCopyIssuerSummary()
{
  return MEMORY[0x1E0CD5F90]();
}

CFStringRef SecCertificateCopySubjectSummary(SecCertificateRef certificate)
{
  return (CFStringRef)MEMORY[0x1E0CD5FF8](certificate);
}

SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef allocator, CFDataRef data)
{
  return (SecCertificateRef)MEMORY[0x1E0CD6010](allocator, data);
}

uint64_t SecCertificateGetSignatureHashAlgorithm()
{
  return MEMORY[0x1E0CD6040]();
}

CFTypeID SecCertificateGetTypeID(void)
{
  return MEMORY[0x1E0CD6050]();
}

uint64_t SecGenerateSelfSignedCertificate()
{
  return MEMORY[0x1E0CD6268]();
}

OSStatus SecIdentityCopyCertificate(SecIdentityRef identityRef, SecCertificateRef *certificateRef)
{
  return MEMORY[0x1E0CD6270](identityRef, certificateRef);
}

uint64_t SecIdentityCreate()
{
  return MEMORY[0x1E0CD6280]();
}

CFTypeID SecIdentityGetTypeID(void)
{
  return MEMORY[0x1E0CD6288]();
}

SecKeyRef SecKeyCreateRandomKey(CFDictionaryRef parameters, CFErrorRef *error)
{
  return (SecKeyRef)MEMORY[0x1E0CD6388](parameters, error);
}

uint64_t SecKeyGetAlgorithmId()
{
  return MEMORY[0x1E0CD63D0]();
}

size_t SecKeyGetBlockSize(SecKeyRef key)
{
  return MEMORY[0x1E0CD63D8](key);
}

CFTypeID SecKeyGetTypeID(void)
{
  return MEMORY[0x1E0CD63E8]();
}

CFDictionaryRef SecPolicyCopyProperties(SecPolicyRef policyRef)
{
  return (CFDictionaryRef)MEMORY[0x1E0CD6458](policyRef);
}

SecPolicyRef SecPolicyCreateBasicX509(void)
{
  return (SecPolicyRef)MEMORY[0x1E0CD64D8]();
}

SecPolicyRef SecPolicyCreateSSL(Boolean server, CFStringRef hostname)
{
  return (SecPolicyRef)MEMORY[0x1E0CD6520](server, hostname);
}

uint64_t SecPolicyCreateSSLWithATSPinning()
{
  return MEMORY[0x1E0CD6528]();
}

SecPolicyRef SecPolicyCreateWithProperties(CFTypeRef policyIdentifier, CFDictionaryRef properties)
{
  return (SecPolicyRef)MEMORY[0x1E0CD6540](policyIdentifier, properties);
}

CFTypeID SecPolicyGetTypeID(void)
{
  return MEMORY[0x1E0CD6580]();
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1E0CD65F0](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x1E0CD6610](allocator);
}

CFArrayRef SecTrustCopyCertificateChain(SecTrustRef trust)
{
  return (CFArrayRef)MEMORY[0x1E0CD6648](trust);
}

CFDataRef SecTrustCopyExceptions(SecTrustRef trust)
{
  return (CFDataRef)MEMORY[0x1E0CD6658](trust);
}

SecKeyRef SecTrustCopyKey(SecTrustRef trust)
{
  return (SecKeyRef)MEMORY[0x1E0CD6670](trust);
}

OSStatus SecTrustCopyPolicies(SecTrustRef trust, CFArrayRef *policies)
{
  return MEMORY[0x1E0CD6678](trust, policies);
}

CFArrayRef SecTrustCopyProperties(SecTrustRef trust)
{
  return (CFArrayRef)MEMORY[0x1E0CD6680](trust);
}

OSStatus SecTrustCreateWithCertificates(CFTypeRef certificates, CFTypeRef policies, SecTrustRef *trust)
{
  return MEMORY[0x1E0CD6698](certificates, policies, trust);
}

uint64_t SecTrustDeserialize()
{
  return MEMORY[0x1E0CD66A0]();
}

OSStatus SecTrustEvaluate(SecTrustRef trust, SecTrustResultType *result)
{
  return MEMORY[0x1E0CD66A8](trust, result);
}

uint64_t SecTrustEvaluateFastAsync()
{
  return MEMORY[0x1E0CD66C0]();
}

BOOL SecTrustEvaluateWithError(SecTrustRef trust, CFErrorRef *error)
{
  return MEMORY[0x1E0CD66C8](trust, error);
}

CFIndex SecTrustGetCertificateCount(SecTrustRef trust)
{
  return MEMORY[0x1E0CD66E0](trust);
}

CFTypeID SecTrustGetTypeID(void)
{
  return MEMORY[0x1E0CD66F0]();
}

uint64_t SecTrustReportNetworkingAnalytics()
{
  return MEMORY[0x1E0CD6700]();
}

uint64_t SecTrustSerialize()
{
  return MEMORY[0x1E0CD6708]();
}

BOOL SecTrustSetExceptions(SecTrustRef trust, CFDataRef exceptions)
{
  return MEMORY[0x1E0CD6728](trust, exceptions);
}

uint64_t SecTrustSetPinningPolicyName()
{
  return MEMORY[0x1E0CD6740]();
}

OSStatus SecTrustSetPolicies(SecTrustRef trust, CFTypeRef policies)
{
  return MEMORY[0x1E0CD6748](trust, policies);
}

void TXTRecordCreate(TXTRecordRef *txtRecord, uint16_t bufferLen, void *buffer)
{
  MEMORY[0x1E0C806F0](txtRecord, bufferLen, buffer);
}

void TXTRecordDeallocate(TXTRecordRef *txtRecord)
{
  MEMORY[0x1E0C806F8](txtRecord);
}

const void *__cdecl TXTRecordGetBytesPtr(const TXTRecordRef *txtRecord)
{
  return (const void *)MEMORY[0x1E0C80700](txtRecord);
}

uint16_t TXTRecordGetCount(uint16_t txtLen, const void *txtRecord)
{
  return MEMORY[0x1E0C80708](txtLen, txtRecord);
}

DNSServiceErrorType TXTRecordGetItemAtIndex(uint16_t txtLen, const void *txtRecord, uint16_t itemIndex, uint16_t keyBufLen, char *key, uint8_t *valueLen, const void **value)
{
  return MEMORY[0x1E0C80710](txtLen, txtRecord, itemIndex, keyBufLen, key, valueLen, value);
}

uint16_t TXTRecordGetLength(const TXTRecordRef *txtRecord)
{
  return MEMORY[0x1E0C80718](txtRecord);
}

DNSServiceErrorType TXTRecordSetValue(TXTRecordRef *txtRecord, const char *key, uint8_t valueSize, const void *value)
{
  return MEMORY[0x1E0C80730](txtRecord, key, valueSize, value);
}

CFStringRef UTTypeCopyPreferredTagWithClass(CFStringRef inUTI, CFStringRef inTagClass)
{
  return (CFStringRef)MEMORY[0x1E0CA5970](inUTI, inTagClass);
}

CFStringRef UTTypeCreatePreferredIdentifierForTag(CFStringRef inTagClass, CFStringRef inTag, CFStringRef inConformingToUTI)
{
  return (CFStringRef)MEMORY[0x1E0CA5980](inTagClass, inTag, inConformingToUTI);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
  MEMORY[0x1E0C80940](a1, a2, *(_QWORD *)&a3);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

uint64_t _CFGetProgname()
{
  return MEMORY[0x1E0C9A1C0]();
}

uint64_t _CFReadStreamSignalEventDelayed()
{
  return MEMORY[0x1E0C9A438]();
}

uint64_t _CFRunLoop01()
{
  return MEMORY[0x1E0C9A450]();
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1E0C9A498]();
}

uint64_t _CFRuntimeGetClassWithTypeID()
{
  return MEMORY[0x1E0C9A4A0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1E0C9A4B0]();
}

uint64_t _CFURLCopyComponents()
{
  return MEMORY[0x1E0C9A600]();
}

uint64_t _CFURLCopyPropertyListRepresentation()
{
  return MEMORY[0x1E0C9A650]();
}

uint64_t _CFURLCreateFromComponents()
{
  return MEMORY[0x1E0C9A6A0]();
}

uint64_t _CFURLCreateFromPropertyListRepresentation()
{
  return MEMORY[0x1E0C9A6A8]();
}

uint64_t _CFURLGetEncoding()
{
  return MEMORY[0x1E0C9A6F8]();
}

uint64_t _CFURLIsFileURL()
{
  return MEMORY[0x1E0C9A710]();
}

uint64_t _CFWriteStreamCreateFromFileDescriptor()
{
  return MEMORY[0x1E0C9A778]();
}

uint64_t _CFWriteStreamSignalEventDelayed()
{
  return MEMORY[0x1E0C9A798]();
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return MEMORY[0x1E0C9A800]();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return MEMORY[0x1E0C9A818]();
}

uint64_t _NtlmCreateClientResponse()
{
  return MEMORY[0x1E0CD6790]();
}

uint64_t _SSLCopyPeerCertificates()
{
  return MEMORY[0x1E0CD67B0]();
}

uint64_t _SSLGetDiffieHellmanParams()
{
  return MEMORY[0x1E0CD67C0]();
}

uint64_t _SSLSetAllowsAnyRoot()
{
  return MEMORY[0x1E0CD67D0]();
}

uint64_t _SSLSetAllowsExpiredCerts()
{
  return MEMORY[0x1E0CD67D8]();
}

uint64_t _SSLSetAllowsExpiredRoots()
{
  return MEMORY[0x1E0CD67E0]();
}

uint64_t _SSLSetDiffieHellmanParams()
{
  return MEMORY[0x1E0CD67E8]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x1E0DE41C8](this, __c, __pos);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return MEMORY[0x1E0DE41D8](this, __s);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1E0DE41F0]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1E0DE4248](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1E0DE4258](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1E0DE43E8](__n);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4408](this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4420](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4428](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4468](this, __pos, __s);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
  MEMORY[0x1E0DE44B8](this, __c);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1E0DE44D8](this, __str);
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x1E0DE4598]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1E0DE45A8]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1E0DE45B0]();
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x1E0DE4608]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1E0DE4628]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1E0DE4700]();
}

uint64_t std::ifstream::open()
{
  return MEMORY[0x1E0DE4798]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1E0DE47A8]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1E0DE48F8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
  MEMORY[0x1E0DE4930](__format);
}

int std::stoi(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1E0DE4A78](__str, __idx, *(_QWORD *)&__base);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA0](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA8](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x1E0DE4AB8](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x1E0DE4B98](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x1E0DE4C80](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1E0DE4D58](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x1E0DE4D60](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return (std::string *)MEMORY[0x1E0DE4D80](retstr, __val);
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

uint64_t operator delete[]()
{
  return off_1E14E1FA8();
}

void operator delete(void *__p)
{
  off_1E14E1FB0(__p);
}

uint64_t operator delete()
{
  return off_1E14E1FB8();
}

uint64_t operator new[]()
{
  return off_1E14E1FC0();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1E14E1FC8(__sz);
}

uint64_t operator new()
{
  return off_1E14E1FD0();
}

uint64_t __CFDataMtbl()
{
  return MEMORY[0x1E0C9A948]();
}

uint64_t __CFSocketRead()
{
  return MEMORY[0x1E0C9A9A8]();
}

uint64_t __CFSocketSetSocketReadBufferAttrs()
{
  return MEMORY[0x1E0C9A9B0]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x1E0C80A58](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return MEMORY[0x1E0C80AA0](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1E0C80B50](*(_QWORD *)&a1, a2);
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C70](*(_QWORD *)&a1);
}

uint64_t _getaddrinfo_interface_async_call()
{
  return MEMORY[0x1E0C80F90]();
}

uint64_t _getnameinfo_interface_async_call()
{
  return MEMORY[0x1E0C80F98]();
}

uint64_t _os_crash()
{
  return MEMORY[0x1E0C81000]();
}

uint64_t _os_crash_msg()
{
  return MEMORY[0x1E0C81008]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1E0C81010]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81020](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81040](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x1E0C81068]();
}

uint64_t _os_nospin_lock_lock()
{
  return MEMORY[0x1E0C81080]();
}

uint64_t _os_nospin_lock_unlock()
{
  return MEMORY[0x1E0C81090]();
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C810D0](dso, log, type, spid, name, format, buf, *(_QWORD *)&size);
}

uint64_t _xpc_runtime_is_app_sandboxed()
{
  return MEMORY[0x1E0C812A0]();
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

int acl_free(void *obj_p)
{
  return MEMORY[0x1E0C81438](obj_p);
}

acl_t acl_get_link_np(const char *path_p, acl_type_t type)
{
  return (acl_t)MEMORY[0x1E0C81478](path_p, *(_QWORD *)&type);
}

char *__cdecl acl_to_text(acl_t acl, ssize_t *len_p)
{
  return (char *)MEMORY[0x1E0C814F8](acl, len_p);
}

uint32_t arc4random(void)
{
  return MEMORY[0x1E0C81570]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
  MEMORY[0x1E0C81580](__buf, __nbytes);
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1E0C81588](*(_QWORD *)&__upper_bound);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1E0C81608](a1, a2);
}

int atexit(void (*a1)(void))
{
  return MEMORY[0x1E0C81648](a1);
}

int atoi(const char *a1)
{
  return MEMORY[0x1E0C81668](a1);
}

uint64_t atol(const char *a1)
{
  return MEMORY[0x1E0C81678](a1);
}

void backtrace_image_offsets(void *const *array, image_offset *image_offsets, int size)
{
  MEMORY[0x1E0C816C0](array, image_offsets, *(_QWORD *)&size);
}

kern_return_t bootstrap_look_up(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1E0C81708](*(_QWORD *)&bp, service_name, sp);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

const char *__cdecl class_getName(Class cls)
{
  return (const char *)MEMORY[0x1E0DE7AC8](cls);
}

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
{
  return MEMORY[0x1E0C82670](*(_QWORD *)&__clock_id);
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

compression_status compression_stream_destroy(compression_stream *stream)
{
  return MEMORY[0x1E0DE5290](stream);
}

compression_status compression_stream_init(compression_stream *stream, compression_stream_operation operation, compression_algorithm algorithm)
{
  return MEMORY[0x1E0DE52A0](stream, *(_QWORD *)&operation, *(_QWORD *)&algorithm);
}

compression_status compression_stream_process(compression_stream *stream, int flags)
{
  return MEMORY[0x1E0DE52B0](stream, *(_QWORD *)&flags);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return MEMORY[0x1E0C826D0](*(_QWORD *)&a1, a2, a3);
}

uint64_t container_system_group_path_for_identifier()
{
  return MEMORY[0x1E0C82A90]();
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  return MEMORY[0x1E0DE92B0](crc, buf, *(_QWORD *)&len);
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1E0C82BB0](a1, a2);
}

uint64_t dirstat_np()
{
  return MEMORY[0x1E0C82BB8]();
}

void dispatch_activate(dispatch_object_t object)
{
  MEMORY[0x1E0C82BC0](object);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BE8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82C18](queue, context, work);
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1E0C82C60](flags, block);
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1E0C82C68](flags, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority, block);
}

uint64_t dispatch_block_create_with_voucher_and_qos_class()
{
  return MEMORY[0x1E0C82C78]();
}

BOOL dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier)
{
  return MEMORY[0x1E0C82CA0](data, applier);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x1E0C82CB0](buffer, size, queue, destructor);
}

uint64_t dispatch_data_create_alloc()
{
  return MEMORY[0x1E0C82CB8]();
}

dispatch_data_t dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2)
{
  return (dispatch_data_t)MEMORY[0x1E0C82CC0](data1, data2);
}

dispatch_data_t dispatch_data_create_map(dispatch_data_t data, const void **buffer_ptr, size_t *size_ptr)
{
  return (dispatch_data_t)MEMORY[0x1E0C82CD0](data, buffer_ptr, size_ptr);
}

dispatch_data_t dispatch_data_create_subrange(dispatch_data_t data, size_t offset, size_t length)
{
  return (dispatch_data_t)MEMORY[0x1E0C82CD8](data, offset, length);
}

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return MEMORY[0x1E0C82CE8](data);
}

dispatch_queue_t dispatch_get_current_queue(void)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82CF8]();
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82D10](group, queue, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1E0C82D20]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x1E0C82D28](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x1E0C82D30](group);
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82D38](group, queue, block);
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82D48](group, timeout);
}

void dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier)
{
  MEMORY[0x1E0C82D50](channel, barrier);
}

void dispatch_io_close(dispatch_io_t channel, dispatch_io_close_flags_t flags)
{
  MEMORY[0x1E0C82D58](channel, flags);
}

dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void *cleanup_handler)
{
  return (dispatch_io_t)MEMORY[0x1E0C82D60](type, *(_QWORD *)&fd, queue, cleanup_handler);
}

dispatch_fd_t dispatch_io_get_descriptor(dispatch_io_t channel)
{
  return MEMORY[0x1E0C82D78](channel);
}

void dispatch_io_set_low_water(dispatch_io_t channel, size_t low_water)
{
  MEMORY[0x1E0C82D98](channel, low_water);
}

void dispatch_io_write(dispatch_io_t channel, off_t offset, dispatch_data_t data, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
  MEMORY[0x1E0C82DA0](channel, offset, data, queue, io_handler);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E28](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E38](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  return (const char *)MEMORY[0x1E0C82E58](queue);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA8](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F48](source, handler);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x1E0C82F78](source, start, interval, leeway);
}

void dispatch_suspend(dispatch_object_t object)
{
  MEMORY[0x1E0C82F88](object);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82FA0](queue, context, work);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return MEMORY[0x1E0C82FC8](when, delta);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

int dup(int a1)
{
  return MEMORY[0x1E0C83078](*(_QWORD *)&a1);
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1E0C83158]();
}

void exit(int a1)
{
  MEMORY[0x1E0C83278](*(_QWORD *)&a1);
}

int fchown(int a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x1E0C832E0](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  return (FILE *)MEMORY[0x1E0C83318](*(_QWORD *)&a1, a2);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1E0C83370](a1);
}

int ffsctl(int a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x1E0C83378](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

ssize_t fgetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1E0C833A8](*(_QWORD *)&fd, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1E0C83488](*(_QWORD *)&a1, a2);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

void freeaddrinfo(addrinfo *a1)
{
  MEMORY[0x1E0C834C0](a1);
}

void freeifaddrs(ifaddrs *a1)
{
  MEMORY[0x1E0C834D0](a1);
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x1E0C83528](a1, a2, a3, *(_QWORD *)&a4);
}

int fsetxattr(int fd, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1E0C83548](*(_QWORD *)&fd, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1E0C83560](*(_QWORD *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return MEMORY[0x1E0C835F8](a1, a2, a3, a4);
}

uint64_t getaddrinfo_async_handle_reply()
{
  return MEMORY[0x1E0C83600]();
}

uint64_t getaddrinfo_async_start()
{
  return MEMORY[0x1E0C83608]();
}

gid_t getegid(void)
{
  return MEMORY[0x1E0C83658]();
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1E0C83660](a1);
}

uid_t geteuid(void)
{
  return MEMORY[0x1E0C83668]();
}

gid_t getgid(void)
{
  return MEMORY[0x1E0C83678]();
}

hostent *__cdecl gethostbyname(const char *a1)
{
  return (hostent *)MEMORY[0x1E0C836B0](a1);
}

