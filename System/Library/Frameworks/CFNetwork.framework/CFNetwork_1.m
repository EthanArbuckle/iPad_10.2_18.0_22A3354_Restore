void sub_183F4C8B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;

  _Block_object_dispose((const void *)(v4 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11HTTP3Framer4readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke(uint64_t a1, __int128 *a2, uint64_t a3)
{
  uint64_t v3;
  __int128 v5;
  uint64_t v6;

  *(_BYTE *)(*(_QWORD *)(a1 + 40) + 72) = 0;
  v3 = *(_QWORD *)(a1 + 32);
  v6 = *((_QWORD *)a2 + 2);
  v5 = *a2;
  return (*(uint64_t (**)(uint64_t, __int128 *, uint64_t))(v3 + 16))(v3, &v5, a3);
}

void ___ZN11HTTP3Stream5_readEb_block_invoke(_QWORD *a1, uint64_t *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  HTTP3Connection *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  dispatch_data_t subrange;
  std::__shared_weak_count *v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  HTTP3Connection *v32;
  unint64_t *v33;
  unint64_t v34;
  unsigned int v35;
  NSObject *v36;
  dispatch_data_t concat;
  std::__shared_weak_count *v38;
  std::__shared_weak_count *v39;
  std::__shared_weak_count *v40;
  uint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  NSObject *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  HTTPHeaderDict *Instance;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  unsigned int v55;
  std::__shared_weak_count *v56;
  HTTPHeaderDict *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  void *v61;
  uint64_t v62;
  size_t v63;
  uint64_t v64;
  _QWORD *v65;
  int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  id v70;
  void *v71;
  void *v72;
  int v73;
  std::__shared_weak_count *v74;
  uint64_t v75;
  std::__shared_weak_count *v76;
  uint64_t v77;
  std::__shared_weak_count *v78;
  uint64_t v79;
  std::__shared_weak_count *v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char NewForStreamId;
  id v86;
  NSObject *data2;
  _QWORD applier[7];
  uint64_t v89;
  _BYTE v90[10];
  __int16 v91;
  uint64_t v92;
  __int16 v93;
  size_t size;
  __int16 v95;
  int v96;
  uint8_t buf[32];
  __int128 v98;
  __int128 v99;
  __int128 v100;
  uint64_t v101;
  CFStreamError v102;
  CFStreamError v103;

  v101 = *MEMORY[0x1E0C80C00];
  v11 = a3;
  v12 = a1[7];
  v14 = *a2;
  v13 = a2[1];
  v15 = a2[2];
  data2 = v11;
  if ((_DWORD)a6)
  {
    v16 = *(std::__shared_weak_count **)(v12 + 56);
    if (v16)
    {
      v17 = std::__shared_weak_count::lock(v16);
      *(_QWORD *)v90 = v17;
      if (v17)
      {
        v18 = v17;
        v19 = *(HTTP3Connection **)(v12 + 48);
        v89 = (uint64_t)v19;
        if (v19)
        {
          v102.domain = a5;
          *(_QWORD *)&v102.error = a6;
          if (HTTP3Connection::checkAndPerformFallback(v19, v102))
          {
            CFN_LOG_h3stream();
            v20 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              v21 = *(_QWORD *)(v12 + 336);
              v22 = *(_QWORD *)(v12 + 352);
              *(_DWORD *)buf = 134218498;
              *(_QWORD *)&buf[4] = v12;
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v21;
              *(_WORD *)&buf[22] = 2114;
              *(_QWORD *)&buf[24] = v22;
              _os_log_impl(&dword_183ECA000, v20, OS_LOG_TYPE_DEFAULT, "%p ID=%llu %{public}@ fallback triggered", buf, 0x20u);
            }

            p_shared_owners = (unint64_t *)&v18->__shared_owners_;
            do
              v24 = __ldaxr(p_shared_owners);
            while (__stlxr(v24 - 1, p_shared_owners));
            if (!v24)
            {
              ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
              v25 = v18;
LABEL_43:
              std::__shared_weak_count::__release_weak(v25);
            }
            goto LABEL_72;
          }
        }
        v26 = (unint64_t *)&v18->__shared_owners_;
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
    }
  }
  subrange = data2;
  if (*(_DWORD *)(v12 + 116) == 9)
    goto LABEL_118;
  if (data2)
  {
    v29 = *(std::__shared_weak_count **)(v12 + 56);
    if (v29)
    {
      v30 = std::__shared_weak_count::lock(v29);
      if (v30)
      {
        v31 = v30;
        v32 = *(HTTP3Connection **)(v12 + 48);
        if (v32 && *((_QWORD *)v32 + 124))
          HTTP3Connection::_stopStallRecovery(v32);
        v33 = (unint64_t *)&v31->__shared_owners_;
        do
          v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
    }
    switch(v14)
    {
      case 0:
        v35 = *(_DWORD *)(v12 + 116);
        subrange = data2;
        if (v35 > 9)
          goto LABEL_89;
        if (!v35)
        {
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          v56 = *(std::__shared_weak_count **)(v12 + 56);
          if (!v56)
            goto LABEL_71;
          *(_QWORD *)&buf[8] = std::__shared_weak_count::lock(v56);
          if (!*(_QWORD *)&buf[8])
            goto LABEL_71;
          v47 = *(_QWORD *)(v12 + 48);
          *(_QWORD *)buf = v47;
          if (!v47)
            goto LABEL_71;
          goto LABEL_70;
        }
        if (v35 != 3)
        {
          applier[6] = 0;
          v99 = 0u;
          v100 = 0u;
          v98 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
          LODWORD(v89) = 67110144;
          HIDWORD(v89) = v35;
          *(_WORD *)v90 = 2048;
          *(_QWORD *)&v90[2] = 0;
          v91 = 2048;
          v92 = v13;
          v93 = 2048;
          size = dispatch_data_get_size(data2);
          v95 = 1024;
          v96 = a4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_153:
          __assert_rtn("_received", "HTTP3Stream.mm", v48, "false");
        }
        v36 = *(NSObject **)(v12 + 160);
        if (v36)
          concat = dispatch_data_create_concat(v36, data2);
        else
          concat = data2;
        v61 = *(void **)(v12 + 160);
        *(_QWORD *)(v12 + 160) = concat;

        v62 = *(_QWORD *)(v12 + 344);
        subrange = data2;
        if (v62)
        {
          v63 = dispatch_data_get_size(data2);
          if ((_DWORD)a4)
            v64 = v15;
          else
            v64 = 0;
          *(_QWORD *)(v62 + 136) += v63 + v64;
          goto LABEL_88;
        }
        goto LABEL_89;
      case 1:
        subrange = data2;
        v48 = 1046;
        switch(*(_DWORD *)(v12 + 116))
        {
          case 0:
            v49 = *(_QWORD *)(v12 + 344);
            if (v49)
              *(_QWORD *)(v49 + 200) = 0x7FF8000000000000;
            *(_DWORD *)(v12 + 116) = 1;
            *(_DWORD *)(v12 + 248) = -1;
            if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
              dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
            Instance = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
            if (Instance)
            {
              *((_QWORD *)Instance + 2) = 0;
              *((_QWORD *)Instance + 3) = 0;
              Instance = (HTTPHeaderDict *)((char *)Instance + 16);
            }
            HTTPHeaderDict::HTTPHeaderDict(Instance);
            v51 = *(_QWORD *)(v12 + 256);
            *(_QWORD *)(v12 + 256) = v52;
            if (v51)
              CFRelease((CFTypeRef)(v51 - 16));
            goto LABEL_61;
          case 1:
LABEL_61:
            if ((_DWORD)a4)
            {
              v53 = *(_QWORD *)(v12 + 344);
              if (v53)
                *(_QWORD *)(v53 + 120) += v13 + v15;
            }
            goto LABEL_79;
          case 2:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
            goto LABEL_153;
          case 3:
            *(_DWORD *)(v12 + 116) = 4;
            if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
              dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
            v57 = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
            if (v57)
            {
              *((_QWORD *)v57 + 2) = 0;
              *((_QWORD *)v57 + 3) = 0;
              v57 = (HTTPHeaderDict *)((char *)v57 + 16);
            }
            HTTPHeaderDict::HTTPHeaderDict(v57);
            v58 = *(_QWORD *)(v12 + 256);
            *(_QWORD *)(v12 + 256) = v59;
            if (v58)
              CFRelease((CFTypeRef)(v58 - 16));
            goto LABEL_79;
          case 4:
LABEL_79:
            v60 = HTTP3Stream::_handleHeaders(v12, v13, data2, a4);
            subrange = data2;
            if (v60)
              goto LABEL_80;
            goto LABEL_89;
          default:
            goto LABEL_89;
        }
      case 2:
      case 6:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
        goto LABEL_44;
      case 3:
      case 4:
      case 7:
      case 13:
        goto LABEL_35;
      case 5:
        if (*(_BYTE *)(v12 + 126))
        {
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          v46 = *(std::__shared_weak_count **)(v12 + 56);
          if (v46)
          {
            *(_QWORD *)&buf[8] = std::__shared_weak_count::lock(v46);
            if (*(_QWORD *)&buf[8])
            {
              v47 = *(_QWORD *)(v12 + 48);
              *(_QWORD *)buf = v47;
              if (v47)
              {
LABEL_70:
                *(_QWORD *)(v47 + 1160) = 4;
                *(_DWORD *)(v47 + 1168) = -1;
                HTTP3Connection::_cleanupConnection((HTTP3Connection *)v47, 261, 0);
                HTTP3Connection::reportServerProtocolViolation(*(uint64_t *)buf, 48, *(_QWORD *)(v12 + 336));
              }
            }
          }
LABEL_71:
          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)buf);
LABEL_72:
          subrange = data2;
          goto LABEL_118;
        }
        break;
      default:
        if ((unint64_t)(v14 - 984832) >= 2)
        {
LABEL_44:
          CFN_LOG_h3stream();
          v44 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
          {
            v45 = *(_QWORD *)(v12 + 336);
            *(_DWORD *)buf = 134218496;
            *(_QWORD *)&buf[4] = v12;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v45;
            *(_WORD *)&buf[22] = 2048;
            *(_QWORD *)&buf[24] = v14;
            _os_log_impl(&dword_183ECA000, v44, OS_LOG_TYPE_INFO, "%p ID=%llu unsupported frame type %llu", buf, 0x20u);
          }

LABEL_88:
          subrange = data2;
          goto LABEL_89;
        }
LABEL_35:
        v38 = *(std::__shared_weak_count **)(v12 + 56);
        if (v38)
        {
          v39 = std::__shared_weak_count::lock(v38);
          *(_QWORD *)&buf[8] = v39;
          if (v39)
          {
            v40 = v39;
            v41 = *(_QWORD *)(v12 + 48);
            *(_QWORD *)buf = v41;
            if (v41)
            {
              *(_QWORD *)(v41 + 1160) = 4;
              *(_DWORD *)(v41 + 1168) = -1;
              HTTP3Connection::_cleanupConnection((HTTP3Connection *)v41, 261, 0);
              HTTP3Connection::reportServerProtocolViolation(v41, 48, *(_QWORD *)(v12 + 336));
            }
            v42 = (unint64_t *)&v40->__shared_owners_;
            do
              v43 = __ldaxr(v42);
            while (__stlxr(v43 - 1, v42));
            if (!v43)
            {
              ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
              v25 = v40;
              goto LABEL_43;
            }
          }
        }
        goto LABEL_72;
    }
    v54 = *(_DWORD *)(v12 + 116);
    v48 = 1144;
    subrange = data2;
    switch(v54)
    {
      case 0:
      case 3:
        v55 = 0;
        *(_DWORD *)(v12 + 116) = 6;
        *(_DWORD *)(v12 + 120) = v54;
        *(_BYTE *)(v12 + 176) = 0;
        goto LABEL_129;
      case 1:
      case 2:
      case 4:
      case 5:
      case 8:
      case 9:
        goto LABEL_153;
      case 6:
        v55 = *(unsigned __int8 *)(v12 + 176);
LABEL_129:
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x2020000000;
        buf[24] = 0;
        applier[0] = MEMORY[0x1E0C809B0];
        applier[1] = 3221225472;
        applier[2] = ___ZN11HTTP3Stream9_receivedEN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamError_block_invoke;
        applier[3] = &unk_1E14F9100;
        applier[4] = buf;
        applier[5] = v12;
        dispatch_data_apply(data2, applier);
        if (!*(_BYTE *)(*(_QWORD *)&buf[8] + 24))
        {
          if (!(_DWORD)a4)
          {
            _Block_object_dispose(buf, 8);
            goto LABEL_88;
          }
          v89 = 0;
          *(_QWORD *)v90 = 0;
          v80 = *(std::__shared_weak_count **)(v12 + 56);
          if (v80)
          {
            *(_QWORD *)v90 = std::__shared_weak_count::lock(v80);
            if (*(_QWORD *)v90)
            {
              v81 = *(_QWORD *)(v12 + 48);
              v89 = v81;
              if (v81)
              {
                *(_QWORD *)(v81 + 1160) = 4;
                *(_DWORD *)(v81 + 1168) = -1;
                HTTP3Connection::_cleanupConnection((HTTP3Connection *)v81, 262, 0);
                HTTP3Connection::reportServerProtocolViolation(v89, 54, *(_QWORD *)(v12 + 336));
              }
            }
          }
          goto LABEL_143;
        }
        *(_DWORD *)(v12 + 116) = 7;
        v89 = 0;
        *(_QWORD *)v90 = 0;
        v78 = *(std::__shared_weak_count **)(v12 + 56);
        if (v78)
        {
          *(_QWORD *)v90 = std::__shared_weak_count::lock(v78);
          if (*(_QWORD *)v90)
          {
            v79 = *(_QWORD *)(v12 + 48);
            v89 = v79;
          }
          else
          {
            v79 = v89;
          }
          if (v79)
          {
            v82 = *(_QWORD *)(v12 + 168);
            if (v82 > *(int *)(v79 + 792) - 1)
            {
              *(_QWORD *)(v79 + 1160) = 4;
              *(_DWORD *)(v79 + 1168) = -1;
              HTTP3Connection::_cleanupConnection((HTTP3Connection *)v79, 264, 0);
              HTTP3Connection::reportServerProtocolViolation(v89, 55, *(_QWORD *)(v12 + 336));
LABEL_143:
              std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&v89);
              _Block_object_dispose(buf, 8);
              goto LABEL_72;
            }
            v83 = *(_QWORD *)(v12 + 296);
            if (v83)
              v84 = v83 - 176;
            else
              v84 = 0;
            v86 = *(id *)(v84 + 80);
            NewForStreamId = HTTP2ServerPush::createNewForStreamId((HTTP2ServerPush *)(v79 + 624), v82, (NSURLRequestCachePolicy)objc_msgSend(v86, "_cachePolicy"), 1);

            if ((NewForStreamId & 1) == 0)
              *(_BYTE *)(v12 + 177) = 1;
          }
        }
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&v89);
        subrange = dispatch_data_create_subrange(data2, *(unsigned __int8 *)(v12 + 176) - (unint64_t)v55, 0xFFFFFFFFFFFFFFFFLL);

        _Block_object_dispose(buf, 8);
LABEL_150:
        v60 = HTTP3Stream::_handleHeaders(v12, v13 - *(unsigned __int8 *)(v12 + 176), subrange, a4);
        if (v60)
        {
LABEL_80:

          if (v60 == 2)
            goto LABEL_119;
          goto LABEL_121;
        }
        break;
      case 7:
        goto LABEL_150;
      default:
        break;
    }
  }
  else
  {
    subrange = 0;
  }
LABEL_89:
  v103.domain = a5;
  *(_QWORD *)&v103.error = a6;
  switch(HTTP3Stream::_translateError((HTTP3Stream *)v12, v103, 0))
  {
    case 0u:

      if (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
      {
        *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 1;
        v65 = a1 + 6;
        goto LABEL_120;
      }
      HTTP3Stream::_read((HTTP3Stream *)a1[7], 1);
      goto LABEL_121;
    case 1u:
      if ((_DWORD)a4)
      {
        v67 = *(_DWORD *)(v12 + 116);
        if (v67 == 9 || v67 == 3)
        {
          *(_DWORD *)(v12 + 116) = 9;
          HTTP3Stream::_reportResult((HTTP3Stream *)v12, 1);
          *(_BYTE *)(v12 + 132) = 1;
          break;
        }
LABEL_97:
        *(_QWORD *)(v12 + 264) = 4;
        v66 = -4;
LABEL_98:
        *(_DWORD *)(v12 + 272) = v66;
      }
      else
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        v76 = *(std::__shared_weak_count **)(v12 + 56);
        if (v76)
        {
          *(_QWORD *)&buf[8] = std::__shared_weak_count::lock(v76);
          if (*(_QWORD *)&buf[8])
          {
            v77 = *(_QWORD *)(v12 + 48);
            *(_QWORD *)buf = v77;
            if (v77)
            {
              *(_QWORD *)(v77 + 1160) = 4;
              *(_DWORD *)(v77 + 1168) = -1;
              HTTP3Connection::_cleanupConnection((HTTP3Connection *)v77, 262, 0);
              HTTP3Connection::reportServerProtocolViolation(*(uint64_t *)buf, 49, *(_QWORD *)(v12 + 336));
            }
          }
        }
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)buf);
      }
LABEL_99:
      HTTP3Stream::_reportResult((HTTP3Stream *)v12, 0);
      break;
    case 2u:
      *(_QWORD *)(v12 + 264) = a5;
      *(_QWORD *)(v12 + 272) = a6;
      if (a5 == 1 && a6 == 57)
        break;
      goto LABEL_99;
    case 3u:
      goto LABEL_97;
    case 4u:
      *(_QWORD *)(v12 + 264) = 4;
      v66 = -1;
      goto LABEL_98;
    case 5u:
      *(_QWORD *)(v12 + 264) = 4;
      v73 = -2205;
      goto LABEL_117;
    case 6u:
      if (!*(_DWORD *)(v12 + 116))
        goto LABEL_116;
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      v74 = *(std::__shared_weak_count **)(v12 + 56);
      if (v74)
      {
        *(_QWORD *)&buf[8] = std::__shared_weak_count::lock(v74);
        if (*(_QWORD *)&buf[8])
        {
          v75 = *(_QWORD *)(v12 + 48);
          *(_QWORD *)buf = v75;
          if (v75)
          {
            *(_QWORD *)(v75 + 1160) = 4;
            *(_DWORD *)(v75 + 1168) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v75, 257, 0);
            HTTP3Connection::reportServerProtocolViolation(*(uint64_t *)buf, 50, *(_QWORD *)(v12 + 336));
          }
        }
      }
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)buf);
      *(_QWORD *)(v12 + 264) = 4;
      v73 = -1;
      goto LABEL_117;
    case 7u:
      v68 = *(_QWORD *)(v12 + 296);
      if (v68)
        v69 = v68 - 176;
      else
        v69 = 0;
      v70 = *(id *)(v69 + 80);
      objc_msgSend(v70, "session");
      v71 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend((id)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(_QWORD *)(v12 + 64) + 128)), "host");
      v72 = (void *)objc_claimAutoreleasedReturnValue();
      if (v71)
        -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:]((uint64_t)v71, v72, 80);

LABEL_116:
      *(_QWORD *)(v12 + 264) = 4;
      v73 = -2200;
LABEL_117:
      *(_DWORD *)(v12 + 272) = v73;
      break;
    default:
      break;
  }
LABEL_118:

LABEL_119:
  HTTP3Stream::_protocolCallback((HTTP3Stream *)a1[7]);
  v65 = a1 + 5;
LABEL_120:
  *(_BYTE *)(*(_QWORD *)(*v65 + 8) + 24) = 0;
LABEL_121:

}

void sub_183F4D4F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  _Block_object_dispose(&a27, 8);

  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::_translateError(HTTP3Stream *this, CFStreamError a2, int a3)
{
  uint64_t v3;
  NSObject *v6;
  NSObject *v7;
  nw_protocol_metadata_t v8;
  void *v9;
  uint64_t application_error;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *p_shared_owners;
  unint64_t v19;

  v3 = *(_QWORD *)&a2.error;
  if (a2.error)
  {
    v6 = *(NSObject **)(*((_QWORD *)this + 3) + 48);
    v7 = nw_protocol_copy_quic_connection_definition();
    v8 = nw_content_context_copy_protocol_metadata(v6, v7);

    v9 = (void *)nw_quic_connection_copy_stream_metadata();
    application_error = nw_quic_stream_get_application_error();

    v3 = 5;
    switch(application_error)
    {
      case 257:
      case 259:
      case 260:
      case 261:
      case 262:
      case 264:
      case 265:
      case 266:
      case 270:
      case 271:
        return 4;
      case 258:
      case 268:
      case 269:
        return 3;
      case 263:
        return v3;
      case 267:
        return 6;
      case 272:
        return 7;
      default:
        if ((unint64_t)(application_error - 512) < 3)
          return 4;
        if (application_error != -1)
        {
          if (a3)
            return 1;
          else
            return 3;
        }
        v12 = (std::__shared_weak_count *)*((_QWORD *)this + 7);
        if (!v12)
          return 3;
        v13 = std::__shared_weak_count::lock(v12);
        if (!v13)
          return 3;
        v14 = v13;
        v15 = *((_QWORD *)this + 6);
        if (!v15)
          goto LABEL_22;
        v16 = *(_QWORD *)(v15 + 1008);
        if (!v16
          || (*(_BYTE *)(v15 + 920) & 4) != 0
          || (v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 120))(v16), v17 == -1))
        {
          v3 = 2;
        }
        else if (v17 == 272)
        {
          v3 = 7;
        }
        else
        {
LABEL_22:
          v3 = 3;
        }
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          v19 = __ldaxr(p_shared_owners);
        while (__stlxr(v19 - 1, p_shared_owners));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
        break;
    }
  }
  return v3;
}

void sub_183F4D774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTP3Stream::_protocolCallback(HTTP3Stream *this)
{
  void (**v2)(_QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v3;
  int v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  void (**v11)(id, uint64_t, _QWORD, char *);

  v2 = (void (**)(_QWORD, _QWORD, _QWORD, _QWORD))*((_QWORD *)this + 41);
  if (v2)
  {
    v3 = *((_QWORD *)this + 39);
    if (v3 && *(_DWORD *)(v3 + 40))
    {
      v4 = *((_DWORD *)this + 68);
      if (v4)
        v5 = (char *)this + 264;
      else
        v5 = 0;
      v6 = *((_QWORD *)this + 10);
      if (v6)
      {
        v7 = *((_QWORD *)this + 20);
        if (!v7
          || (v2[2](v2, v6 - 16, v7, 0),
              v8 = (void *)*((_QWORD *)this + 20),
              *((_QWORD *)this + 20) = 0,
              v8,
              (v2 = (void (**)(_QWORD, _QWORD, _QWORD, _QWORD))*((_QWORD *)this + 41)) != 0))
        {
          if (*((_DWORD *)this + 28) == 4 && *((_DWORD *)this + 29) == 9 || *((_DWORD *)this + 68))
          {
            v11 = (void (**)(id, uint64_t, _QWORD, char *))_Block_copy(v2);
            v9 = (void *)*((_QWORD *)this + 41);
            *((_QWORD *)this + 41) = 0;

            v11[2](v11, *((_QWORD *)this + 10) - 16, 0, v5);
LABEL_18:

          }
        }
      }
      else if (v4)
      {
        v11 = (void (**)(id, uint64_t, _QWORD, char *))_Block_copy(v2);
        v10 = (void *)*((_QWORD *)this + 41);
        *((_QWORD *)this + 41) = 0;

        v11[2](v11, 0, 0, (char *)this + 264);
        goto LABEL_18;
      }
    }
    else
    {
      *((_BYTE *)this + 128) = 1;
    }
  }
}

void sub_183F4D8D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void `non-virtual thunk to'NWIOConnection::readWithContext(uint64_t a1, uint64_t a2, uint32_t a3, uint32_t a4, uint64_t a5)
{
  NWIOConnection::readWithContext(a1 - 112, a2, a3, a4, a5);
}

id CFN_LOG_h3stream(void)
{
  if (CFN_LOG_h3stream(void)::once != -1)
    dispatch_once(&CFN_LOG_h3stream(void)::once, &__block_literal_global_5426);
  return (id)CFN_LOG_h3stream(void)::log;
}

uint64_t NWIOConnection::getQUICApplicationError(nw_connection_t *this)
{
  NSObject *v2;
  nw_protocol_metadata_t v3;
  uint64_t application_error;

  v2 = nw_protocol_copy_quic_connection_definition();
  v3 = nw_connection_copy_protocol_metadata(this[34], v2);
  if (!v3)
  {
    application_error = -1;
    if (!v2)
      return application_error;
    goto LABEL_3;
  }
  application_error = nw_quic_connection_get_application_error();
  nw_release(v3);
  if (v2)
LABEL_3:
    nw_release(v2);
  return application_error;
}

void sub_183F4D9A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  nw_release(v2);
  if (v1)
    nw_release(v1);
  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::_handleHeaders(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  NSObject *v7;
  size_t size;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  unint64_t *v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  int v26;
  void *v27;
  int v29;
  int v30;
  uint64_t v31;
  _OWORD *Instance;
  HTTPMessage *v33;
  int v34;
  _QWORD *v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  HTTPResponseMessage *v39;
  const void *v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  HTTPHeaderDict *v46;
  uint64_t v47;
  uint64_t v48;
  CFMutableDictionaryRef v49;
  uint64_t v50;
  int v51;
  std::__shared_weak_count *v52;
  std::__shared_weak_count *v53;
  std::__shared_weak_count *v54;
  uint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  std::__shared_weak_count *v58;
  std::__shared_weak_count *v59;
  uint64_t v60;
  unint64_t *v61;
  _OWORD *v62;
  HTTPMessage *v63;
  int v64;
  _QWORD *v65;
  HTTPMessage **v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  HTTPResponseMessage *v70;
  const void *v71;
  uint64_t v72;
  int hasHeaderField;
  NSObject *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  std::__shared_weak_count *v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  std::__shared_weak_count *v84;
  unint64_t *v85;
  unint64_t v86;
  std::__shared_weak_count *v87;
  std::__shared_weak_count *v88;
  uint64_t v89;
  unint64_t *v90;
  const char *v91;
  int v92;
  const char *v93;
  _QWORD v94[8];
  uint64_t v95;
  uint64_t *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t *v100;
  uint64_t v101;
  int v102;
  void (**v103)(StringSerializable *__hidden);
  CFTypeRef cf;
  _BYTE buf[22];
  __int16 v106;
  uint64_t v107;
  __int16 v108;
  int v109;
  __int16 v110;
  int v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  v7 = a3;
  size = dispatch_data_get_size(v7);
  v99 = 0;
  v100 = &v99;
  v101 = 0x2020000000;
  v102 = 2;
  v95 = 0;
  v96 = &v95;
  v97 = 0x2020000000;
  v98 = 0;
  v94[0] = MEMORY[0x1E0C809B0];
  v94[1] = 3221225472;
  v94[2] = ___ZN11HTTP3Stream14_handleHeadersEmPU27objcproto16OS_dispatch_data8NSObjectb_block_invoke;
  v94[3] = &unk_1E14F90D8;
  v94[6] = a1;
  v94[7] = a2;
  v94[4] = &v99;
  v94[5] = &v95;
  dispatch_data_apply(v7, v94);
  switch(*((_DWORD *)v100 + 6))
  {
    case 0:
      if (!(_DWORD)a4 || v96[3] < size)
      {
        v9 = *(std::__shared_weak_count **)(a1 + 56);
        if (v9)
        {
          v10 = std::__shared_weak_count::lock(v9);
          *(_QWORD *)&buf[8] = v10;
          if (v10)
          {
            v11 = v10;
            v12 = *(_QWORD *)(a1 + 48);
            *(_QWORD *)buf = v12;
            if (v12)
            {
              *(_QWORD *)(v12 + 1160) = 4;
              *(_DWORD *)(v12 + 1168) = -1;
              HTTP3Connection::_cleanupConnection((HTTP3Connection *)v12, 512, 0);
              HTTP3Connection::reportServerProtocolViolation(v12, 129, *(_QWORD *)(a1 + 336));
            }
            p_shared_owners = (unint64_t *)&v11->__shared_owners_;
            do
              v14 = __ldaxr(p_shared_owners);
            while (__stlxr(v14 - 1, p_shared_owners));
LABEL_27:
            if (!v14)
            {
              ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
              std::__shared_weak_count::__release_weak(v11);
            }
            goto LABEL_29;
          }
        }
        goto LABEL_29;
      }
      v29 = *(_DWORD *)(a1 + 116);
      switch(v29)
      {
        case 7:
          if (!*(_BYTE *)(a1 + 177))
          {
            v52 = *(std::__shared_weak_count **)(a1 + 56);
            if (v52)
            {
              v53 = std::__shared_weak_count::lock(v52);
              *(_QWORD *)&buf[8] = v53;
              if (v53)
              {
                v54 = v53;
                v55 = *(_QWORD *)(a1 + 48);
                *(_QWORD *)buf = v55;
                if (v55)
                  HTTP2ServerPush::endPromisedHeadersWithCheckTheCacheBlock((uint64_t *)(v55 + 624), *(_DWORD *)(a1 + 168));
                v56 = (unint64_t *)&v54->__shared_owners_;
                do
                  v57 = __ldaxr(v56);
                while (__stlxr(v57 - 1, v56));
                if (!v57)
                {
                  ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
                  std::__shared_weak_count::__release_weak(v54);
                }
              }
            }
          }
          a4 = 0;
          *(_BYTE *)(a1 + 177) = 0;
          v51 = *(_DWORD *)(a1 + 120);
          goto LABEL_77;
        case 4:
          v49 = HTTPHeaderDict::copyAsOrdinaryDict(*(CFDictionaryRef **)(a1 + 256), (const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
          v50 = *(_QWORD *)(a1 + 256);
          *(_QWORD *)(a1 + 256) = 0;
          if (v50)
            CFRelease((CFTypeRef)(v50 - 16));
          HTTPMessage::setTrailerFields(*(HTTPMessage **)(a1 + 80), v49);
          *(_DWORD *)(a1 + 116) = 9;

          goto LABEL_74;
        case 1:
          v30 = *(_DWORD *)(a1 + 248);
          if (v30 == -1)
          {
            *(_QWORD *)(a1 + 264) = 4;
            *(_DWORD *)(a1 + 272) = -1;
            HTTP3Stream::_cleanupStream(a1, 270, 0);
            HTTP3Stream::_protocolCallback((HTTP3Stream *)a1);
            v58 = *(std::__shared_weak_count **)(a1 + 56);
            if (v58)
            {
              v59 = std::__shared_weak_count::lock(v58);
              *(_QWORD *)&buf[8] = v59;
              if (v59)
              {
                v11 = v59;
                v60 = *(_QWORD *)(a1 + 48);
                *(_QWORD *)buf = v60;
                if (v60)
                  HTTP3Connection::reportServerProtocolViolation(v60, 51, *(_QWORD *)(a1 + 336));
                v61 = (unint64_t *)&v11->__shared_owners_;
                do
                  v14 = __ldaxr(v61);
                while (__stlxr(v14 - 1, v61));
                goto LABEL_27;
              }
            }
            goto LABEL_29;
          }
          if ((v30 - 100) <= 0x63)
          {
            if (v30 == 100)
              HTTP3Stream::_100ContinueReceived((HTTP3Stream *)a1);
            v31 = *(_QWORD *)(a1 + 296);
            if (v31)
            {
              if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
              Instance = (_OWORD *)_CFRuntimeCreateInstance();
              v33 = (HTTPMessage *)Instance;
              if (Instance)
              {
                Instance[1] = 0u;
                v33 = (HTTPMessage *)(Instance + 1);
                Instance[18] = 0u;
                Instance[19] = 0u;
                Instance[16] = 0u;
                Instance[17] = 0u;
                Instance[14] = 0u;
                Instance[15] = 0u;
                Instance[12] = 0u;
                Instance[13] = 0u;
                Instance[10] = 0u;
                Instance[11] = 0u;
                Instance[8] = 0u;
                Instance[9] = 0u;
                Instance[6] = 0u;
                Instance[7] = 0u;
                Instance[4] = 0u;
                Instance[5] = 0u;
                Instance[2] = 0u;
                Instance[3] = 0u;
              }
              v34 = *(_DWORD *)(a1 + 248);
              HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v103, CFSTR("HTTP/3.0"));
              HTTPMessage::HTTPMessage(v33, "httpresponse", cf);
              *(_QWORD *)v33 = &off_1E14E9F38;
              *((_QWORD *)v33 + 1) = &unk_1E14E9FA8;
              *((_QWORD *)v33 + 2) = &unk_1E14E9FC8;
              *((_DWORD *)v33 + 32) = v34;
              *((_QWORD *)v33 + 17) = 0;
              *((_OWORD *)v33 + 10) = 0u;
              *((_OWORD *)v33 + 11) = 0u;
              *((_OWORD *)v33 + 12) = 0u;
              *((_OWORD *)v33 + 13) = 0u;
              *((_OWORD *)v33 + 14) = 0u;
              *((_OWORD *)v33 + 15) = 0u;
              *((_OWORD *)v33 + 16) = 0u;
              *((_OWORD *)v33 + 17) = 0u;
              *((_BYTE *)v33 + 296) = 0;
              *(_QWORD *)buf = v33;
              v35 = (_QWORD *)operator new();
              *v35 = &off_1E14F1710;
              v35[1] = 0;
              v35[2] = 0;
              v35[3] = v33;
              *(_QWORD *)&buf[8] = v35;
              std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 80, (__int128 *)buf);
              v36 = *(std::__shared_weak_count **)&buf[8];
              if (*(_QWORD *)&buf[8])
              {
                v37 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
                do
                  v38 = __ldaxr(v37);
                while (__stlxr(v38 - 1, v37));
                if (!v38)
                {
                  ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
                  std::__shared_weak_count::__release_weak(v36);
                }
              }
              v103 = &off_1E14E9A00;
              if (cf)
                CFRelease(cf);
              HTTPMessage::ensureParserFinished(*(HTTPMessage **)(a1 + 80));
              v39 = *(HTTPResponseMessage **)(a1 + 80);
              v40 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(_QWORD *)(a1 + 64)
                                                                                                + 128));
              HTTPResponseMessage::setResponseURL(v39, v40, 0);
              HTTPMessage::replaceHeaderFieldsWithExternalHeaderDict(*(HTTPMessage **)(a1 + 80), *(HTTPHeaderDict **)(a1 + 256));
              v41 = *(std::__shared_weak_count **)(a1 + 88);
              *(_QWORD *)buf = *(_QWORD *)(a1 + 80);
              *(_QWORD *)&buf[8] = v41;
              if (v41)
              {
                v42 = (unint64_t *)&v41->__shared_owners_;
                do
                  v43 = __ldxr(v42);
                while (__stxr(v43 + 1, v42));
              }
              HTTPProtocol::handleInformationalResponse((_QWORD *)(v31 - 176), (uint64_t)buf);
              if (v41)
              {
                v44 = (unint64_t *)&v41->__shared_owners_;
                do
                  v45 = __ldaxr(v44);
                while (__stlxr(v45 - 1, v44));
                if (!v45)
                {
                  ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
                  std::__shared_weak_count::__release_weak(v41);
                }
              }
            }
            *(_DWORD *)(a1 + 116) = 0;
            *(_DWORD *)(a1 + 248) = -1;
            if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
              dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
            v46 = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
            if (v46)
            {
              *((_QWORD *)v46 + 2) = 0;
              *((_QWORD *)v46 + 3) = 0;
              v46 = (HTTPHeaderDict *)((char *)v46 + 16);
            }
            HTTPHeaderDict::HTTPHeaderDict(v46);
            v47 = *(_QWORD *)(a1 + 256);
            *(_QWORD *)(a1 + 256) = v48;
            if (v47)
              CFRelease((CFTypeRef)(v47 - 16));
LABEL_74:
            a4 = 0;
            goto LABEL_37;
          }
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          v62 = (_OWORD *)_CFRuntimeCreateInstance();
          v63 = (HTTPMessage *)v62;
          if (v62)
          {
            v62[1] = 0u;
            v63 = (HTTPMessage *)(v62 + 1);
            v62[18] = 0u;
            v62[19] = 0u;
            v62[16] = 0u;
            v62[17] = 0u;
            v62[14] = 0u;
            v62[15] = 0u;
            v62[12] = 0u;
            v62[13] = 0u;
            v62[10] = 0u;
            v62[11] = 0u;
            v62[8] = 0u;
            v62[9] = 0u;
            v62[6] = 0u;
            v62[7] = 0u;
            v62[4] = 0u;
            v62[5] = 0u;
            v62[2] = 0u;
            v62[3] = 0u;
          }
          v64 = *(_DWORD *)(a1 + 248);
          HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v103, CFSTR("HTTP/3.0"));
          HTTPMessage::HTTPMessage(v63, "httpresponse", cf);
          *(_QWORD *)v63 = &off_1E14E9F38;
          *((_QWORD *)v63 + 1) = &unk_1E14E9FA8;
          *((_QWORD *)v63 + 2) = &unk_1E14E9FC8;
          *((_DWORD *)v63 + 32) = v64;
          *((_QWORD *)v63 + 17) = 0;
          *((_OWORD *)v63 + 10) = 0u;
          *((_OWORD *)v63 + 11) = 0u;
          *((_OWORD *)v63 + 12) = 0u;
          *((_OWORD *)v63 + 13) = 0u;
          *((_OWORD *)v63 + 14) = 0u;
          *((_OWORD *)v63 + 15) = 0u;
          *((_OWORD *)v63 + 16) = 0u;
          *((_OWORD *)v63 + 17) = 0u;
          *((_BYTE *)v63 + 296) = 0;
          *(_QWORD *)buf = v63;
          v65 = (_QWORD *)operator new();
          *v65 = &off_1E14F1710;
          v65[1] = 0;
          v65[2] = 0;
          v65[3] = v63;
          *(_QWORD *)&buf[8] = v65;
          v66 = (HTTPMessage **)(a1 + 80);
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 80, (__int128 *)buf);
          v67 = *(std::__shared_weak_count **)&buf[8];
          if (*(_QWORD *)&buf[8])
          {
            v68 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
            do
              v69 = __ldaxr(v68);
            while (__stlxr(v69 - 1, v68));
            if (!v69)
            {
              ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
              std::__shared_weak_count::__release_weak(v67);
            }
          }
          v103 = &off_1E14E9A00;
          if (cf)
            CFRelease(cf);
          HTTPMessage::ensureParserFinished(*v66);
          v70 = *(HTTPResponseMessage **)(a1 + 80);
          v71 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(_QWORD *)(a1 + 64)
                                                                                            + 128));
          HTTPResponseMessage::setResponseURL(v70, v71, 0);
          HTTPMessage::replaceHeaderFieldsWithExternalHeaderDict(*(HTTPMessage **)(a1 + 80), *(HTTPHeaderDict **)(a1 + 256));
          v72 = *(_QWORD *)(a1 + 256);
          *(_QWORD *)(a1 + 256) = 0;
          if (v72)
            CFRelease((CFTypeRef)(v72 - 16));
          if ((HTTPResponseMessage::isValid((os_unfair_lock_s *)*v66) & 1) == 0)
          {
            *(_QWORD *)(a1 + 264) = 4;
            *(_DWORD *)(a1 + 272) = -1;
            HTTP3Stream::_cleanupStream(a1, 270, 0);
            HTTP3Stream::_protocolCallback((HTTP3Stream *)a1);
            v87 = *(std::__shared_weak_count **)(a1 + 56);
            if (v87)
            {
              v88 = std::__shared_weak_count::lock(v87);
              *(_QWORD *)&buf[8] = v88;
              if (v88)
              {
                v11 = v88;
                v89 = *(_QWORD *)(a1 + 48);
                *(_QWORD *)buf = v89;
                if (v89)
                  HTTP3Connection::reportServerProtocolViolation(v89, 56, *(_QWORD *)(a1 + 336));
                v90 = (unint64_t *)&v11->__shared_owners_;
                do
                  v14 = __ldaxr(v90);
                while (__stlxr(v14 - 1, v90));
                goto LABEL_27;
              }
            }
LABEL_29:
            a4 = 2;
            goto LABEL_37;
          }
          hasHeaderField = HTTPMessage::hasHeaderField((os_unfair_lock_s *)*v66, 0x11D1D2CFu);
          CFN_LOG_h3stream();
          v74 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
          {
            v75 = *(_QWORD *)(a1 + 336);
            v76 = *(_QWORD *)(a1 + 352);
            v77 = *(_DWORD *)(a1 + 248);
            if (hasHeaderField)
              v78 = 75;
            else
              v78 = 85;
            *(_DWORD *)buf = 134219010;
            *(_QWORD *)&buf[4] = a1;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v75;
            v106 = 2114;
            v107 = v76;
            v108 = 1024;
            v109 = v77;
            v110 = 1024;
            v111 = v78;
            _os_log_impl(&dword_183ECA000, v74, OS_LOG_TYPE_DEFAULT, "%p ID=%llu %{public}@ received response, status %d content %c", buf, 0x2Cu);
          }

          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          v79 = *(std::__shared_weak_count **)(a1 + 56);
          if (v79)
          {
            *(_QWORD *)&buf[8] = std::__shared_weak_count::lock(v79);
            if (*(_QWORD *)&buf[8])
            {
              v80 = *(_QWORD *)(a1 + 48);
              *(_QWORD *)buf = v80;
              if (v80)
              {
                std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v103, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
                HTTP3Connection::streamExitedStallableState(v80, (uint64_t)v103, (std::__shared_weak_count *)cf);
                v81 = (std::__shared_weak_count *)cf;
                if (cf)
                {
                  v82 = (unint64_t *)((char *)cf + 8);
                  do
                    v83 = __ldaxr(v82);
                  while (__stlxr(v83 - 1, v82));
                  if (!v83)
                  {
                    ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
                    std::__shared_weak_count::__release_weak(v81);
                  }
                }
              }
            }
          }
          v84 = *(std::__shared_weak_count **)&buf[8];
          if (*(_QWORD *)&buf[8])
          {
            v85 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
            do
              v86 = __ldaxr(v85);
            while (__stlxr(v86 - 1, v85));
            if (!v86)
            {
              ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
              std::__shared_weak_count::__release_weak(v84);
            }
          }
          a4 = 0;
          v51 = 3;
LABEL_77:
          *(_DWORD *)(a1 + 116) = v51;
          goto LABEL_37;
      }
      v91 = "false";
      v92 = 1298;
      v93 = "_receivedHeadersDone";
      goto LABEL_134;
    case 1:
      v23 = dispatch_data_create_subrange(v7, v96[3], size);
      v24 = v23;
      v25 = *(_DWORD *)(a1 + 116);
      switch(v25)
      {
        case 1:
          v26 = 2;
          break;
        case 7:
          v26 = 8;
          break;
        case 4:
          v26 = 5;
          break;
        default:
          __assert_rtn("_receivedHeadersBlocked", "HTTP3Stream.mm", 1316, "false");
      }
      *(_DWORD *)(a1 + 116) = v26;
      v27 = *(void **)(a1 + 152);
      *(_QWORD *)(a1 + 152) = v23;

      *(_BYTE *)(a1 + 131) = a4;
      a4 = 1;
      goto LABEL_37;
    case 2:
      if (v96[3] != size)
      {
        v91 = "consumedSize == dataSize";
        v92 = 905;
        v93 = "_handleHeaders";
LABEL_134:
        __assert_rtn(v93, "HTTP3Stream.mm", v92, v91);
      }
      if ((_DWORD)a4)
      {
        v15 = *(std::__shared_weak_count **)(a1 + 56);
        if (v15)
        {
          v16 = std::__shared_weak_count::lock(v15);
          *(_QWORD *)&buf[8] = v16;
          if (v16)
          {
            v11 = v16;
            v17 = *(_QWORD *)(a1 + 48);
            *(_QWORD *)buf = v17;
            if (v17)
            {
              *(_QWORD *)(v17 + 1160) = 4;
              *(_DWORD *)(v17 + 1168) = -1;
              HTTP3Connection::_cleanupConnection((HTTP3Connection *)v17, 512, 0);
              HTTP3Connection::reportServerProtocolViolation(v17, 130, *(_QWORD *)(a1 + 336));
            }
            v18 = (unint64_t *)&v11->__shared_owners_;
            do
              v14 = __ldaxr(v18);
            while (__stlxr(v14 - 1, v18));
            goto LABEL_27;
          }
        }
        goto LABEL_29;
      }
LABEL_37:
      _Block_object_dispose(&v95, 8);
      _Block_object_dispose(&v99, 8);

      return a4;
    case 3:
      v19 = *(std::__shared_weak_count **)(a1 + 56);
      if (!v19)
        goto LABEL_29;
      v20 = std::__shared_weak_count::lock(v19);
      *(_QWORD *)&buf[8] = v20;
      if (!v20)
        goto LABEL_29;
      v11 = v20;
      v21 = *(_QWORD *)(a1 + 48);
      *(_QWORD *)buf = v21;
      if (v21 && !*(_DWORD *)(a1 + 272))
      {
        *(_QWORD *)(v21 + 1160) = 4;
        *(_DWORD *)(v21 + 1168) = -1;
        HTTP3Connection::_cleanupConnection((HTTP3Connection *)v21, 512, 0);
        HTTP3Connection::reportServerProtocolViolation(v21, 128, *(_QWORD *)(a1 + 336));
      }
      v22 = (unint64_t *)&v11->__shared_owners_;
      do
        v14 = __ldaxr(v22);
      while (__stlxr(v14 - 1, v22));
      goto LABEL_27;
    default:
      goto LABEL_37;
  }
}

void sub_183F4E514(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,CFTypeRef cf)
{
  void *v26;
  uint64_t v27;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112);
  _Block_object_dispose(&a17, 8);
  _Block_object_dispose(&a21, 8);

  _Unwind_Resume(a1);
}

BOOL ___ZN11HTTP3Stream14_handleHeadersEmPU27objcproto16OS_dispatch_data8NSObjectb_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;
  FILE *v15;
  int v16;
  _QWORD *v17;
  FILE *v18;
  FILE *v19;
  uint64_t v20;
  uint64_t v21;
  dispatch_data_t v22;
  FILE *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  uint64_t v27;
  size_t size;
  _OWORD v29[2];
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t (*v36)(uint64_t, uint64_t, unsigned __int8 *, uint64_t);
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _BYTE buffer[10];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v7 = a1[6];
  v8 = *(std::__shared_weak_count **)(v7 + 56);
  if (!v8 || (v10 = a1[7], (v11 = std::__shared_weak_count::lock(v8)) == 0))
  {
    v16 = 3;
    goto LABEL_34;
  }
  v12 = v11;
  v13 = *(_QWORD *)(v7 + 48);
  if (v13)
  {
    v27 = a4;
    size = 10;
    if (*(_BYTE *)(v7 + 130))
    {
      v14 = *(_QWORD *)(v7 + 336);
      if (v10 > 1)
      {
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v37 = 0;
        v38 = 0u;
        v34 = 0u;
        v35 = 0u;
        memset(v29, 0, sizeof(v29));
        v30 = v7;
        v31 = v14;
        v32 = v10;
        v33 = v10;
        v36 = parse_header_prefix;
        v19 = *(FILE **)(v13 + 320);
        if (v19)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v19);
          fprintf(*(FILE **)(v13 + 320), "begin reading header block for stream %llu", v14);
          fputc(10, *(FILE **)(v13 + 320));
        }
        v16 = qdec_header_process(v13 + 272, v29, &v27, a5, buffer, &size);
      }
      else
      {
        v15 = *(FILE **)(v13 + 320);
        if (v15)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v15);
          fprintf(*(FILE **)(v13 + 320), "header block for stream %llu is too short (%zd byte%.*s)", v14, v10, v10 != 1, "s");
          fputc(10, *(FILE **)(v13 + 320));
        }
        *(_QWORD *)(v13 + 600) = 0x10AF00000000;
        *(_QWORD *)(v13 + 608) = 0;
        *(_QWORD *)(v13 + 616) = v14;
        v16 = 3;
      }
      *(_BYTE *)(v7 + 130) = 0;
LABEL_20:
      a5 = v27 - a4;
      if (!v16)
      {
        *(_QWORD *)(v7 + 192) = *(_QWORD *)(v7 + 184);
        v20 = *(_QWORD *)(v7 + 344);
        v21 = *(_QWORD *)(v13 + 1208);
        *(_QWORD *)(v13 + 1208) = 0;
        if (v20)
          *(_QWORD *)(v20 + 120) += v21;
        if (size)
        {
          v22 = dispatch_data_create(buffer, size, 0, 0);
          HTTP3Connection::writeDecoderStream(v13, v22);

        }
        v16 = 0;
        *(_BYTE *)(v7 + 130) = 1;
      }
      goto LABEL_30;
    }
    v17 = (_QWORD *)(v13 + 352);
    while (1)
    {
      v17 = (_QWORD *)*v17;
      if (!v17)
        break;
      if (v17[4] == v7)
      {
        v18 = *(FILE **)(v13 + 320);
        if (v18)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v18);
          fprintf(*(FILE **)(v13 + 320), "continue reading header block for stream %llu", v17[5]);
          fputc(10, *(FILE **)(v13 + 320));
        }
        v16 = qdec_header_process(v13 + 272, v17, &v27, a5, buffer, &size);
        goto LABEL_20;
      }
    }
    v23 = *(FILE **)(v13 + 320);
    if (v23)
    {
      fwrite("qdec: info: ", 0xCuLL, 1uLL, v23);
      fwrite("could not find header block to continue reading", 0x2FuLL, 1uLL, *(FILE **)(v13 + 320));
      fputc(10, *(FILE **)(v13 + 320));
    }
    a5 = 0;
  }
  v16 = 3;
LABEL_30:
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  do
    v25 = __ldaxr(p_shared_owners);
  while (__stlxr(v25 - 1, p_shared_owners));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
LABEL_34:
  *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v16;
  *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) += a5;
  return *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) == 2;
}

void sub_183F4E920(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t qdec_header_process(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4, _BYTE *a5, _QWORD *a6)
{
  _OWORD *v9;
  unint64_t v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  FILE *v17;
  FILE **v18;
  _OWORD *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _QWORD *v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  FILE *v33;
  uint64_t v34;
  FILE *v35;
  FILE *v36;
  float v37;
  float v38;
  unint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  unsigned int v44;
  unsigned int v46;
  unsigned int v47;
  FILE *v48;
  FILE *v49;
  float v50;
  FILE *v51;

  v9 = a2;
  a2[14] = *a3;
  a2[15] = a4;
  a2[16] = 0;
  v11 = a2[7];
  while (2)
  {
    if (!v11)
    {
LABEL_30:
      v37 = *(float *)(a1 + 228);
      v38 = (float)*((unsigned int *)v9 + 18);
      if (v37 != 0.0)
        v38 = v37 + (float)(v38 - v37) * 0.4;
      *(float *)(a1 + 228) = v38;
      if (a6 && a5 && (*((_DWORD *)v9 + 26) & 2) != 0)
      {
        if (!*a6)
          goto LABEL_40;
        v39 = *((_QWORD *)v9 + 5);
        *a5 = 0x80;
        v40 = lsqpack_enc_int(a5, (unint64_t)&a5[*a6], v39, 7);
        v41 = v40 - a5;
        if (v40 <= a5)
          goto LABEL_40;
        *a6 = v41;
        v42 = *(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 24) += v41;
        if (v42)
        {
          v43 = *((_DWORD *)v9 + 16);
          v44 = v43 + 2 * v42 - *(_DWORD *)(a1 + 36);
          if (~(v44 / (2 * v42) * 2 * v42) + v44 < v42)
            *(_DWORD *)(a1 + 36) = v43;
        }
      }
      else if (a6)
      {
        *a6 = 0;
      }
      *a3 += *((_QWORD *)v9 + 16);
      v46 = *(_DWORD *)(a1 + 28);
      v47 = *(_DWORD *)(a1 + 24) + *((_DWORD *)v9 + 12);
      *(_DWORD *)(a1 + 24) = v47;
      if (v46 >= 0x80000001)
      {
        *(_DWORD *)(a1 + 24) = (float)((float)((float)v47 / (float)v46) * 1000.0);
        *(_DWORD *)(a1 + 28) = 1000;
        v48 = *(FILE **)(a1 + 48);
        if (v48)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v48);
          v49 = *(FILE **)(a1 + 48);
          v50 = lsqpack_dec_ratio(a1);
          fprintf(v49, "reset bytes in/out counters, ratio: %.3f", v50);
          fputc(10, *(FILE **)(a1 + 48));
        }
      }
      v18 = (FILE **)(a1 + 48);
      v51 = *(FILE **)(a1 + 48);
      if (v51)
      {
        fwrite("qdec: debug: ", 0xDuLL, 1uLL, v51);
        fprintf(*v18, "header block for stream %llu is done", *((_QWORD *)v9 + 5));
        v34 = 0;
        goto LABEL_28;
      }
      v34 = 0;
LABEL_41:
      if ((*((_BYTE *)v9 + 104) & 0x10) != 0)
        destroy_header_block_read_ctx(a1, (uint64_t *)v9);
      return v34;
    }
    v12 = *((_DWORD *)v9 + 26);
    if ((v12 & 1) != 0)
      v13 = v11;
    else
      v13 = 1;
    v14 = *((_QWORD *)v9 + 16);
    v15 = *((_QWORD *)v9 + 14);
    if (*((_QWORD *)v9 + 15) - v14 >= v13)
      v16 = v13;
    else
      v16 = *((_QWORD *)v9 + 15) - v14;
    *((_QWORD *)v9 + 16) = v16 + v14;
    if (v16)
    {
      *((_QWORD *)v9 + 7) = v11 - v16;
      switch((*((unsigned int (**)(uint64_t, _OWORD *, uint64_t, unint64_t))v9 + 12))(a1, v9, v15 + v14, v16))
      {
        case 0u:
          goto LABEL_30;
        case 1u:
          v12 = *((_DWORD *)v9 + 26);
          goto LABEL_15;
        case 2u:
          v11 = *((_QWORD *)v9 + 7);
          if (!v11)
            goto LABEL_12;
          continue;
        case 3u:
LABEL_12:
          v18 = (FILE **)(a1 + 48);
          v17 = *(FILE **)(a1 + 48);
          if (!v17)
            goto LABEL_40;
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v17);
          fprintf(*v18, "header block for stream %llu has had an error");
          break;
        default:
          __assert_rtn("qdec_header_process", "lsqpack.c", 4223, "st == LQRHS_ERROR");
      }
      goto LABEL_27;
    }
    break;
  }
LABEL_15:
  if ((v12 & 0x10) == 0)
  {
    v19 = malloc_type_malloc(0xC0uLL, 0x10F0040D151BEFFuLL);
    if (v19)
    {
      v20 = v9[3];
      v22 = *v9;
      v21 = v9[1];
      v19[2] = v9[2];
      v19[3] = v20;
      *v19 = v22;
      v19[1] = v21;
      v23 = v9[4];
      v24 = v9[5];
      v25 = v9[7];
      v19[6] = v9[6];
      v19[7] = v25;
      v19[4] = v23;
      v19[5] = v24;
      v26 = v9[8];
      v27 = v9[9];
      v28 = v9[11];
      v19[10] = v9[10];
      v19[11] = v28;
      v19[8] = v26;
      v19[9] = v27;
      v29 = *(_QWORD **)(a1 + 88);
      *(_QWORD *)v19 = 0;
      *((_QWORD *)v19 + 1) = v29;
      *v29 = v19;
      *(_QWORD *)(a1 + 88) = v19;
      v12 = *((_DWORD *)v19 + 26) | 0x10;
      *((_DWORD *)v19 + 26) = v12;
      v9 = v19;
      goto LABEL_18;
    }
LABEL_40:
    v34 = 3;
    goto LABEL_41;
  }
LABEL_18:
  if (v16)
  {
    v30 = *(_DWORD *)(a1 + 224);
    if (v30 < *(_DWORD *)(a1 + 16))
    {
      v31 = v9[4] & 7;
      *((_QWORD *)v9 + 2) = 0;
      v32 = a1 + 16 * v31;
      *((_QWORD *)v9 + 3) = *(_QWORD *)(v32 + 104);
      **(_QWORD **)(v32 + 104) = v9;
      *(_QWORD *)(v32 + 104) = v9 + 1;
      *(_DWORD *)(a1 + 224) = v30 + 1;
      *((_DWORD *)v9 + 26) = v12 | 4;
      *a3 += *((_QWORD *)v9 + 16);
      v33 = *(FILE **)(a1 + 48);
      v34 = 1;
      if (v33)
      {
        fwrite("qdec: debug: ", 0xDuLL, 1uLL, v33);
        fprintf(*(FILE **)(a1 + 48), "header block for stream %llu is blocked", *((_QWORD *)v9 + 5));
        fputc(10, *(FILE **)(a1 + 48));
      }
      return v34;
    }
    v18 = (FILE **)(a1 + 48);
    v36 = *(FILE **)(a1 + 48);
    if (v36)
    {
      fwrite("qdec: info: ", 0xCuLL, 1uLL, v36);
      fprintf(*(FILE **)(a1 + 48), "cannot block another header: reached maximum of %u");
LABEL_27:
      v34 = 3;
LABEL_28:
      fputc(10, *v18);
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  *a3 += *((_QWORD *)v9 + 16);
  v35 = *(FILE **)(a1 + 48);
  if (v35)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v35);
    fprintf(*(FILE **)(a1 + 48), "header block for stream %llu needs more bytes", *((_QWORD *)v9 + 5));
    fputc(10, *(FILE **)(a1 + 48));
  }
  return 2;
}

uint64_t parse_header_prefix(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  unsigned __int8 *v6;
  unint64_t *v7;
  int v8;
  char v9;
  int v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t v18;
  uint64x2_t v19;
  int v20;
  int v21;
  uint64_t result;
  int v23;
  unsigned int v24;
  unint64_t v25;
  unsigned __int8 *v26;

  v26 = a3;
  if (a4 < 1)
  {
LABEL_19:
    if (*(_QWORD *)(a2 + 56))
      return 2;
    else
      return 3;
  }
  v6 = &a3[a4];
  v7 = (unint64_t *)(a2 + 168);
  v8 = *(_DWORD *)(a2 + 136);
  v9 = -1;
  while (2)
  {
    switch(v8)
    {
      case 0:
        *(_DWORD *)(a2 + 144) = 0;
        *(_DWORD *)(a2 + 136) = 1;
        v9 = 8;
        goto LABEL_5;
      case 1:
LABEL_5:
        v10 = lsqpack_dec_int(&v26, (unint64_t)v6, v9, (uint64_t *)(a2 + 168), (int *)(a2 + 144));
        if (!v10)
        {
          v11 = *v7;
          if (*v7)
          {
            v12 = *(_DWORD *)(a1 + 20);
            v13 = (2 * v12);
            if (v11 > v13)
              return 3;
            if (v12)
              v14 = (v11 + v13 - 2) % v13;
            else
              LODWORD(v14) = 0;
            *(_DWORD *)(a2 + 64) = v14;
            *(_DWORD *)(a2 + 104) |= 3u;
            *(_DWORD *)(a2 + 136) = 2;
            v15 = *(_DWORD *)(a1 + 32);
            v16 = *(_DWORD *)(a1 + 20);
            if (v15 >= v16)
            {
              result = 1;
              if (v15 < v14 || v15 - v16 + 1 > v14)
                return result;
            }
            else if (v15 < v14 && v16 + v15 >= v14)
            {
              return 1;
            }
          }
          else
          {
            *(_DWORD *)(a2 + 104) |= 1u;
            *(_DWORD *)(a2 + 136) = 2;
          }
          a3 = v26;
          v8 = 2;
          if (v26 >= v6)
            goto LABEL_19;
          continue;
        }
        if (v10 != -1)
          return 3;
        v17 = (2 * *(_DWORD *)(a1 + 20));
        v18 = 1;
        if (v17 >= 0xFF)
          v18 = 2;
        v19 = (uint64x2_t)vdupq_n_s64(v17);
        *(int8x8_t *)v19.i8 = vcnt_s8((int8x8_t)vaddvq_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v19, (uint64x2_t)xmmword_1841E3A10), (int32x4_t)vcgtq_u64(v19, (uint64x2_t)xmmword_1841E3A00)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v19, (uint64x2_t)xmmword_1841E39F0), (int32x4_t)vcgtq_u64(v19, (uint64x2_t)xmmword_1841E39E0))), (int8x16_t)xmmword_1841E39D0)));
        v19.i16[0] = vaddlv_u8(*(uint8x8_t *)v19.i8);
        if (*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 56) <= v18 + (unint64_t)v19.u32[0])
          return 2;
        else
          return 3;
      case 2:
        *(_DWORD *)(a2 + 176) = *a3 >> 7;
        *(_DWORD *)(a2 + 144) = 0;
        *(_DWORD *)(a2 + 136) = 3;
        v9 = 7;
        goto LABEL_29;
      case 3:
LABEL_29:
        v20 = lsqpack_dec_int(&v26, (unint64_t)v6, v9, (uint64_t *)(a2 + 168), (int *)(a2 + 144));
        if (v20 == -1)
          return 2;
        if (v20)
          return 3;
        if ((*(_BYTE *)(a2 + 104) & 2) == 0)
          goto LABEL_32;
        v23 = *(_DWORD *)(a1 + 20);
        if (*(_DWORD *)(a2 + 176))
        {
          if (v23)
          {
            v24 = 2 * v23;
            v25 = (*(_DWORD *)(a2 + 64) + 2 * v23) + ~*(_QWORD *)(a2 + 168);
            goto LABEL_40;
          }
        }
        else if (v23)
        {
          v25 = *(_QWORD *)(a2 + 168) + *(unsigned int *)(a2 + 64);
          v24 = 2 * v23;
LABEL_40:
          v21 = v25 % v24;
LABEL_41:
          *(_DWORD *)(a2 + 68) = v21;
          *(_QWORD *)(a2 + 96) = parse_header_data;
          *(_DWORD *)(a2 + 136) = 0;
          if (v6 == v26)
            return 2;
          else
            return parse_header_data(a1, a2, v26, v6 - v26);
        }
LABEL_32:
        v21 = 0;
        goto LABEL_41;
      default:
        __assert_rtn("parse_header_prefix", "lsqpack.c", 3987, "0");
    }
  }
}

uint64_t HTTP3Connection::checkAndPerformFallback(HTTP3Connection *this, CFStreamError a2)
{
  char v2;
  uint64_t result;
  NSObject *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *i;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  void *v17;
  void *v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  __int128 v28;
  _BYTE buf[12];
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v2 = *((_BYTE *)this + 920);
  if ((v2 & 0x10) != 0)
    return 1;
  result = 0;
  if ((v2 & 0x20) != 0 && a2.domain == 1 && a2.error == 60)
  {
    CFN_LOG_h3connection();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v24 = *((_QWORD *)this + 152);
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = this;
      v30 = 2048;
      v31 = v24;
      _os_log_error_impl(&dword_183ECA000, v5, OS_LOG_TYPE_ERROR, "%p %llu stalled, attempting fallback", buf, 0x16u);
    }

    *((_BYTE *)this + 920) |= 0x10u;
    HTTP3Connection::_stopStallRecovery(this);
    v6 = *((_QWORD *)this + 126);
    if (v6)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 128))(v6, 1);
    v28 = xmmword_1841E38A0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(&v25, *((_QWORD **)this + 142), *((_QWORD **)this + 143), (uint64_t)(*((_QWORD *)this + 143) - *((_QWORD *)this + 142)) >> 4);
    v7 = v25;
    for (i = v26; v7 != i; v7 += 2)
    {
      v10 = *v7;
      v9 = (std::__shared_weak_count *)v7[1];
      if (v9)
      {
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v12 = __ldxr(p_shared_owners);
        while (__stxr(v12 + 1, p_shared_owners));
      }
      if ((*(unsigned int (**)(_QWORD, __int128 *, _QWORD))(**(_QWORD **)(v10 + 296) + 280))(*(_QWORD *)(v10 + 296), &v28, 0)- 5 <= 5)
      {
        CFN_LOG_h3stream();
        v13 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          v22 = *(_QWORD *)(v10 + 352);
          v23 = *(_QWORD *)(v10 + 336);
          *(_DWORD *)buf = 138543874;
          *(_QWORD *)&buf[4] = v22;
          v30 = 2048;
          v31 = v10;
          v32 = 2048;
          v33 = v23;
          _os_log_error_impl(&dword_183ECA000, v13, OS_LOG_TYPE_ERROR, "%{public}@ %p ID=%llu handling fallback", buf, 0x20u);
        }

        v14 = *(_QWORD *)(v10 + 296);
        if (v14)
          v15 = v14 - 176;
        else
          v15 = 0;
        v16 = *(id *)(v15 + 80);
        objc_msgSend(v16, "session");
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend((id)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(_QWORD *)(v10 + 64) + 128)), "host");
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:]((uint64_t)v17, v18, 64);

        v19 = v28;
        HTTP3Stream::_cleanupStream(v10, 256, 0);
        *(_OWORD *)(v10 + 264) = v19;
        HTTP3Stream::_protocolCallback((HTTP3Stream *)v10);
      }
      if (v9)
      {
        v20 = (unint64_t *)&v9->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
    HTTP3Connection::_cleanupConnection(this, 256, 0);
    *(_QWORD *)buf = &v25;
    std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
    return 1;
  }
  return result;
}

void sub_183F4F454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  a17 = (void **)&a12;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a17);
  _Unwind_Resume(a1);
}

void HTTP3Connection::writeDecoderStream(uint64_t a1, void *a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  NSObject *v8;
  dispatch_data_t concat;
  char buffer;

  v3 = a2;
  v4 = *(_QWORD *)(a1 + 1008);
  if (v4 && (*(_BYTE *)(a1 + 920) & 4) == 0)
  {
    v5 = *(_QWORD *)(a1 + 1056);
    if (!v5)
    {
      HTTP3Connection::_newClientUnidirectionalStreamHandle((HTTP3Connection *)"outbound decoder", 0);
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = *(void **)(a1 + 1056);
      *(_QWORD *)(a1 + 1056) = v6;

      buffer = 3;
      v8 = dispatch_data_create(&buffer, 1uLL, 0, 0);
      concat = dispatch_data_create_concat(v8, v3);

      v4 = *(_QWORD *)(a1 + 1008);
      v5 = *(_QWORD *)(a1 + 1056);
      v3 = concat;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, NSObject *, void *))(*(_QWORD *)v4 + 64))(v4, v5, 1, v3, &__block_literal_global_15_5231);
  }

}

void sub_183F4F5C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void HTTP3Connection::streamExitedStallableState(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  _QWORD *v3;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8[2];

  if (a2)
  {
    v3 = *(_QWORD **)(a1 + 976);
    if (v3)
    {
      v8[0] = a2;
      v8[1] = (uint64_t)a3;
      if (a3)
      {
        p_shared_owners = (unint64_t *)&a3->__shared_owners_;
        do
          v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
        HTTPStallTimer::remove(v3, v8);
        do
          v7 = __ldaxr(p_shared_owners);
        while (__stlxr(v7 - 1, p_shared_owners));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
          std::__shared_weak_count::__release_weak(a3);
        }
      }
      else
      {
        HTTPStallTimer::remove(v3, v8);
      }
    }
  }
}

void HTTP3Stream::_reportResult(HTTP3Stream *this, int a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;

  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 7);
  if (!v3)
    return;
  v5 = std::__shared_weak_count::lock(v3);
  v16 = v5;
  if (!v5)
    return;
  v6 = *((_QWORD *)this + 6);
  if (!v6)
  {
    v13 = v5;
LABEL_17:
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    return;
  }
  v7 = *(_QWORD *)(v6 + 1008);
  v8 = *(std::__shared_weak_count **)(v6 + 1016);
  if (v8)
  {
    v9 = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  if (v7)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 128))(v7, a2 ^ 1u);
  if (v8)
  {
    v11 = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v13 = v16;
  if (v16)
    goto LABEL_17;
}

void sub_183F4F778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void NWIOConnection::reportQUICApplicationResult(uint64_t a1)
{
  NSObject *v2;
  nw_protocol_metadata_t v3;

  if (*(_QWORD *)(a1 + 272))
  {
    v2 = nw_protocol_copy_quic_connection_definition();
    v3 = nw_connection_copy_protocol_metadata(*(nw_connection_t *)(a1 + 272), v2);
    if (v3)
    {
      nw_quic_connection_report_application_result();
      nw_release(v3);
    }
    if (v2)
      nw_release(v2);
  }
}

void sub_183F4F810(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  nw_release(v2);
  if (v1)
    nw_release(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTP3Connection18_readEncoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1, int a2, int a3, unsigned __int8 *__src, uint64_t a5)
{
  unsigned __int8 *v6;
  uint64_t v7;
  FILE *v8;
  unint64_t v9;
  _QWORD *v10;
  const char **v11;
  char v12;
  unsigned __int8 v13;
  int v14;
  unsigned int v15;
  unsigned int *v16;
  const void *v17;
  size_t v18;
  _DWORD *v19;
  _DWORD *v20;
  unsigned int v21;
  char **v22;
  const char *v23;
  uint64_t v24;
  char *v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int v28;
  size_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  int v35;
  int v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  int v45;
  unsigned int v46;
  uint64_t v47;
  unsigned int v48;
  size_t v49;
  int v50;
  unsigned int v51;
  const char *v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  int v58;
  unsigned int *v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  _DWORD *v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  _DWORD *v67;
  _DWORD *v68;
  int v69;
  _DWORD *v70;
  int v71;
  uint64_t v72;
  unsigned int v73;
  size_t v74;
  unsigned int v75;
  uint64_t table_entry_rel;
  uint64_t v77;
  void *v78;
  uint64_t v79;
  void *v80;
  size_t v81;
  malloc_type_id_t v82;
  int v83;
  uint64_t v84;
  void *v85;
  unsigned int v86;
  uint64_t v87;
  _DWORD *v88;
  unint64_t v89;
  FILE *v90;
  int v91;
  unsigned int v92;
  int v93;
  int v94;
  char *v96;
  int v97;
  _DWORD *v98;
  int v99;
  int v100;
  int *v101;
  uint64_t *v102;
  uint64_t v103;
  unsigned __int8 *v104;
  unint64_t v105;

  v6 = __src;
  v7 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v7 + 1208) += a5;
  v104 = __src;
  v8 = *(FILE **)(v7 + 320);
  if (v8)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v8);
    fprintf(*(FILE **)(v7 + 320), "got %zu bytes of encoder stream", a5);
    fputc(10, *(FILE **)(v7 + 320));
  }
  *(_DWORD *)(v7 + 296) += a5;
  if (a5 <= 0)
    return 1;
  v9 = (unint64_t)&v6[a5];
  v10 = (_QWORD *)(v7 + 564);
  v11 = (const char **)(v7 + 552);
  v101 = (int *)(v7 + 544);
  v102 = (uint64_t *)(v7 + 536);
  v103 = v7 + 272;
  v12 = -1;
  while (1)
  {
    switch(*(_DWORD *)(v7 + 504))
    {
      case 0:
        v13 = *v6;
        if ((char)*v6 < 0)
        {
          *(_BYTE *)(v7 + 593) = (v13 & 0x40) != 0;
          *(_DWORD *)(v7 + 512) = 0;
          *v11 = 0;
          *(_QWORD *)(v7 + 560) = 0;
          v12 = 6;
          *(_DWORD *)(v7 + 504) = 1;
LABEL_93:
          v105 = 0;
          v14 = lsqpack_dec_int(&v104, v9, v12, (uint64_t *)&v105, (int *)(v7 + 512));
          if (v14)
            goto LABEL_136;
          v75 = v105;
          if (v105 >> 24)
            goto LABEL_136;
          *(_DWORD *)(v7 + 544) = v105;
          if (*(_BYTE *)(v7 + 593))
          {
            if (v75 > 0x62)
              goto LABEL_146;
            *v11 = 0;
          }
          else
          {
            table_entry_rel = qdec_get_table_entry_rel(v103, v75);
            *v11 = (const char *)table_entry_rel;
            if (!table_entry_rel)
              goto LABEL_146;
            ++*(_DWORD *)(table_entry_rel + 8);
          }
          v50 = 2;
LABEL_123:
          *(_DWORD *)(v7 + 504) = v50;
          goto LABEL_134;
        }
        if ((*v6 & 0x40) != 0)
        {
          *(_BYTE *)(v7 + 572) = (v13 & 0x20) != 0;
          *(_DWORD *)(v7 + 512) = 0;
          *(_QWORD *)(v7 + 552) = 0;
          *(_DWORD *)(v7 + 504) = 8;
          v12 = 5;
LABEL_111:
          v105 = 0;
          v14 = lsqpack_dec_int(&v104, v9, v12, (uint64_t *)&v105, (int *)(v7 + 512));
          if (!v14)
          {
            v86 = v105;
            if (!(v105 >> 24))
            {
              *(_DWORD *)(v7 + 544) = v105;
              if (*(_DWORD *)(v7 + 280) << (2 * *(_BYTE *)(v7 + 572)) < v86)
                goto LABEL_146;
              v87 = v86 ? v86 + (v86 >> 1) : 16;
              *(_DWORD *)(v7 + 560) = v87;
              v88 = malloc_type_malloc(v87 + 28, 0x922E1F78uLL);
              *(_QWORD *)(v7 + 552) = v88;
              if (!v88)
                goto LABEL_146;
              v88[6] = 0;
              *v10 = 0;
              if (*(_BYTE *)(v7 + 572))
              {
                v69 = 9;
LABEL_120:
                *(_DWORD *)(v7 + 504) = v69;
LABEL_121:
                *(_DWORD *)(v7 + 536) = 0;
                goto LABEL_134;
              }
              v50 = 10;
              goto LABEL_123;
            }
          }
LABEL_136:
          if (v14 != -1)
            goto LABEL_146;
          return 1;
        }
        *(_DWORD *)(v7 + 512) = 0;
        if ((v13 & 0x20) != 0)
        {
          *(_DWORD *)(v7 + 504) = 7;
          v12 = 5;
LABEL_125:
          v14 = lsqpack_dec_int(&v104, v9, v12, v102, (int *)(v7 + 512));
          if (v14)
            goto LABEL_136;
          v89 = *(_QWORD *)(v7 + 536);
          if (v89 > *(unsigned int *)(v7 + 276))
            goto LABEL_146;
          *(_DWORD *)(v7 + 504) = 0;
          v90 = *(FILE **)(v7 + 320);
          if (v90)
          {
            fwrite("qdec: debug: ", 0xDuLL, 1uLL, v90);
            fprintf(*(FILE **)(v7 + 320), "got TSU=%llu", *(_QWORD *)(v7 + 536));
            fputc(10, *(FILE **)(v7 + 320));
            v89 = *(_QWORD *)(v7 + 536);
          }
          *(_DWORD *)(v7 + 280) = v89;
          v91 = *(_DWORD *)(v7 + 292);
          v92 = v89 >> 5;
          *(_DWORD *)(v7 + 292) = v89 >> 5;
          if (v91 != v89 >> 5)
          {
            v93 = *(_DWORD *)(v7 + 304);
            if (v93 == *(_DWORD *)(v7 + 308) && v93 == 2 * v91 - 1)
            {
              v94 = 2 * v92 - 1;
              *(_DWORD *)(v7 + 304) = v94;
              *(_DWORD *)(v7 + 308) = v94;
            }
          }
          qdec_remove_overflow_entries(v103);
        }
        else
        {
          *(_DWORD *)(v7 + 504) = 6;
          v12 = 5;
LABEL_10:
          v105 = 0;
          v14 = lsqpack_dec_int(&v104, v9, v12, (uint64_t *)&v105, (int *)(v7 + 512));
          if (v14)
            goto LABEL_136;
          v15 = v105;
          if (v105 >> 24)
            goto LABEL_136;
          *(_DWORD *)v102 = v105;
          v16 = (unsigned int *)qdec_get_table_entry_rel(v103, v15);
          if (!v16)
            goto LABEL_146;
          v17 = v16;
          v18 = *v16 + (unint64_t)v16[1] + 28;
          v19 = malloc_type_malloc(v18, 0x943048F6uLL);
          if (!v19)
            goto LABEL_146;
          v20 = v19;
          memcpy(v19, v17, v18);
          v20[2] = 1;
          if (lsqpack_dec_push_entry(v103, (const char *)v20))
          {
            v100 = v20[2] - 1;
            v20[2] = v100;
            if (!v100)
              free(v20);
            goto LABEL_146;
          }
          *(_DWORD *)(v7 + 504) = 0;
        }
LABEL_134:
        v6 = v104;
        if ((unint64_t)v104 >= v9)
          return 1;
        break;
      case 1:
        goto LABEL_93;
      case 2:
        *(_BYTE *)(v7 + 592) = *v6 >> 7;
        *(_DWORD *)(v7 + 512) = 0;
        *(_DWORD *)(v7 + 504) = 3;
        v12 = 7;
        goto LABEL_17;
      case 3:
LABEL_17:
        v105 = 0;
        v14 = lsqpack_dec_int(&v104, v9, v12, (uint64_t *)&v105, (int *)(v7 + 512));
        if (v14)
          goto LABEL_136;
        v21 = v105;
        if (v105 >> 24)
          goto LABEL_136;
        *(_DWORD *)(v7 + 548) = v105;
        if (*(_BYTE *)(v7 + 593))
        {
          v22 = &(&static_table)[3 * *v101];
          v25 = *v22;
          v23 = (const char *)(v22 + 2);
          v24 = (uint64_t)v25;
        }
        else
        {
          v23 = *v11;
          v24 = (uint64_t)(*v11 + 28);
        }
        v64 = *(unsigned int *)v23;
        *(_DWORD *)(v7 + 588) = v64;
        *(_QWORD *)(v7 + 568) = v24;
        if ((*(_DWORD *)(v7 + 280) - (int)v64) << (2 * *(_BYTE *)(v7 + 592)) < v21)
          goto LABEL_146;
        v65 = v21 >> 1;
        if (!*(_BYTE *)(v7 + 592))
          v65 = 0;
        v66 = v65 + v21;
        *(_DWORD *)(v7 + 576) = v66;
        v67 = malloc_type_malloc(v64 + v66 + 28, 0x555E5004uLL);
        *(_QWORD *)(v7 + 560) = v67;
        if (!v67)
          goto LABEL_146;
        if (*(_BYTE *)(v7 + 593))
        {
          v67[6] = 5;
          *(_DWORD *)(*(_QWORD *)(v7 + 560) + 12) = name_hashes[*(unsigned int *)(v7 + 544)];
          v68 = (_DWORD *)(v7 + 544);
        }
        else
        {
          v67[6] = *(_DWORD *)(*(_QWORD *)(v7 + 552) + 24) & 5;
          *(_DWORD *)(*(_QWORD *)(v7 + 560) + 12) = *(_DWORD *)(*(_QWORD *)(v7 + 552) + 12);
          v68 = (_DWORD *)(*(_QWORD *)(v7 + 552) + 20);
        }
        *(_DWORD *)(*(_QWORD *)(v7 + 560) + 20) = *v68;
        **(_DWORD **)(v7 + 560) = *(_DWORD *)(v7 + 588);
        *(_QWORD *)(v7 + 580) = 0;
        v30 = *(_DWORD *)(v7 + 548);
        if (!v30)
          goto LABEL_75;
        if (*(_BYTE *)(v7 + 592))
        {
          v69 = 5;
          goto LABEL_120;
        }
        v50 = 4;
        goto LABEL_123;
      case 4:
        v26 = *(_DWORD *)(v7 + 548);
        if (*(_DWORD *)(v7 + 576) < v26)
          __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4714, "WINR.alloced_val_len >= WINR.val_len");
        v27 = *(unsigned int *)(v7 + 580);
        v28 = v26 - v27;
        if (v28 >= (int)v9 - (int)v6)
          v29 = (v9 - (_DWORD)v6);
        else
          v29 = v28;
        memcpy((void *)(*(_QWORD *)(v7 + 560) + v27 + **(unsigned int **)(v7 + 560) + 28), v6, v29);
        v30 = *(_DWORD *)(v7 + 580) + v29;
        *(_DWORD *)(v7 + 580) = v30;
        v104 = &v6[v29];
        if (v30 != *(_DWORD *)(v7 + 548))
          goto LABEL_134;
        goto LABEL_75;
      case 5:
        v31 = *(unsigned int *)(v7 + 548);
        v32 = *(unsigned int *)(v7 + 584);
        if ((int)v31 - (int)v32 >= (v9 - (_DWORD)v6))
          v33 = (v9 - (_DWORD)v6);
        else
          v33 = (v31 - v32);
        v34 = lsqpack_huff_decode(v6, v33, (char *)(*(_QWORD *)(v7 + 560) + *(unsigned int *)(v7 + 580) + **(unsigned int **)(v7 + 560) + 28), (*(_DWORD *)(v7 + 576) - *(_DWORD *)(v7 + 580)), v102, v33 + v32 == v31);
        v36 = v35;
        v37 = HIDWORD(v34);
        if ((_DWORD)v34 == 2)
        {
          v77 = (2 * *(_DWORD *)(v7 + 576));
          *(_DWORD *)(v7 + 576) = v77;
          v78 = malloc_type_realloc(*(void **)(v7 + 560), v77 + *(unsigned int *)(v7 + 588) + 28, 0x2406461BuLL);
          if (!v78)
            goto LABEL_146;
          *(_QWORD *)(v7 + 560) = v78;
LABEL_103:
          v104 = &v6[v36];
          *(_DWORD *)(v7 + 584) += v36;
          *(_DWORD *)(v7 + 580) += v37;
          goto LABEL_134;
        }
        if ((_DWORD)v34 == 1)
          goto LABEL_103;
        if ((_DWORD)v34)
          goto LABEL_146;
        v104 = &v6[v35];
        v30 = *(_DWORD *)(v7 + 580) + HIDWORD(v34);
LABEL_75:
        *(_DWORD *)(*(_QWORD *)(v7 + 560) + 4) = v30;
        *(_DWORD *)(*(_QWORD *)(v7 + 560) + 8) = 1;
        memcpy((void *)(*(_QWORD *)(v7 + 560) + 28), *(const void **)(v7 + 568), *(unsigned int *)(v7 + 588));
        v70 = *(_DWORD **)(v7 + 552);
        if (v70)
        {
          v71 = v70[2] - 1;
          v70[2] = v71;
          if (!v71)
            free(v70);
          *v11 = 0;
        }
        if (lsqpack_dec_push_entry(v103, *(const char **)(v7 + 560)))
        {
          v98 = *(_DWORD **)(v7 + 560);
          v99 = v98[2] - 1;
          v98[2] = v99;
          if (!v99)
            free(v98);
          *(_QWORD *)(v7 + 560) = 0;
          goto LABEL_146;
        }
        *(_DWORD *)(v7 + 504) = 0;
        *(_QWORD *)(v7 + 560) = 0;
        goto LABEL_134;
      case 6:
        goto LABEL_10;
      case 7:
        goto LABEL_125;
      case 8:
        goto LABEL_111;
      case 9:
        v38 = *(unsigned int *)(v7 + 544);
        v39 = *(unsigned int *)(v7 + 568);
        if ((int)v38 - (int)v39 >= (v9 - (_DWORD)v6))
          v40 = (v9 - (_DWORD)v6);
        else
          v40 = (v38 - v39);
        v41 = lsqpack_huff_decode(v6, v40, (char *)(*(_QWORD *)(v7 + 552) + *(unsigned int *)(v7 + 564) + 28), (*(_DWORD *)(v7 + 560) - *(_DWORD *)(v7 + 564)), v102, v40 + v39 == v38);
        v43 = v42;
        v44 = HIDWORD(v41);
        if ((_DWORD)v41 == 2)
        {
          v79 = (2 * *(_DWORD *)(v7 + 560));
          *(_DWORD *)(v7 + 560) = v79;
          v80 = *(void **)(v7 + 552);
          v81 = v79 + 28;
          v82 = 2184326241;
          goto LABEL_107;
        }
        if ((_DWORD)v41 == 1)
          goto LABEL_109;
        if ((_DWORD)v41)
          goto LABEL_146;
        v104 = &v6[v42];
        v45 = *(_DWORD *)(v7 + 564) + HIDWORD(v41);
LABEL_46:
        **(_DWORD **)(v7 + 552) = v45;
        v50 = 11;
        goto LABEL_123;
      case 0xA:
        v46 = *(_DWORD *)(v7 + 544);
        if (*(_DWORD *)(v7 + 560) < v46)
          __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4809, "WONR.alloced_len >= WONR.str_len");
        v47 = *(unsigned int *)v10;
        v48 = v46 - v47;
        if (v48 >= (int)v9 - (int)v6)
          v49 = (v9 - (_DWORD)v6);
        else
          v49 = v48;
        memcpy((void *)&(*v11)[v47 + 28], v6, v49);
        v45 = *(_DWORD *)v10 + v49;
        *(_DWORD *)v10 = v45;
        v104 = &v6[v49];
        if (v45 == *v101)
          goto LABEL_46;
        goto LABEL_134;
      case 0xB:
        *(_BYTE *)(v7 + 572) = *v6 >> 7;
        *(_DWORD *)(v7 + 512) = 0;
        *(_DWORD *)(v7 + 504) = 12;
        v12 = 7;
        goto LABEL_48;
      case 0xC:
LABEL_48:
        v105 = 0;
        v14 = lsqpack_dec_int(&v104, v9, v12, (uint64_t *)&v105, (int *)(v7 + 512));
        if (v14)
          goto LABEL_136;
        v51 = v105;
        if (v105 >> 24)
          goto LABEL_136;
        *(_DWORD *)(v7 + 544) = v105;
        v52 = *(const char **)(v7 + 552);
        v53 = *(_BYTE *)(v7 + 572);
        if ((*(_DWORD *)(v7 + 280) - *(_DWORD *)v52) << (2 * v53) < v51)
          goto LABEL_146;
        *v10 = 0;
        if (!v51)
          goto LABEL_87;
        if (v53)
        {
          *(_DWORD *)(v7 + 504) = 13;
          goto LABEL_121;
        }
        v50 = 14;
        goto LABEL_123;
      case 0xD:
        v54 = *(unsigned int *)(v7 + 544);
        v55 = *(unsigned int *)(v7 + 568);
        if ((int)v54 - (int)v55 >= (v9 - (_DWORD)v6))
          v56 = (v9 - (_DWORD)v6);
        else
          v56 = (v54 - v55);
        v57 = lsqpack_huff_decode(v6, v56, (char *)(*(_QWORD *)(v7 + 552) + *(unsigned int *)(v7 + 564) + **(unsigned int **)(v7 + 552) + 28), (*(_DWORD *)(v7 + 560) - *(_DWORD *)(v7 + 564) - **(_DWORD **)(v7 + 552)), v102, v56 + v55 == v54);
        v43 = v58;
        v44 = HIDWORD(v57);
        if ((_DWORD)v57 == 2)
        {
          v83 = *(_DWORD *)(v7 + 560);
          if (!v83)
            __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4885, "WONR.alloced_len");
          v84 = (2 * v83);
          *(_DWORD *)(v7 + 560) = v84;
          v80 = *(void **)(v7 + 552);
          v81 = v84 + 28;
          v82 = 2751939443;
LABEL_107:
          v85 = malloc_type_realloc(v80, v81, v82);
          if (!v85)
            goto LABEL_146;
          *(_QWORD *)(v7 + 552) = v85;
LABEL_109:
          v104 = &v6[v43];
          *(_DWORD *)(v7 + 568) += v43;
          *(_DWORD *)(v7 + 564) += v44;
          goto LABEL_134;
        }
        if ((_DWORD)v57 == 1)
          goto LABEL_109;
        if ((_DWORD)v57)
          goto LABEL_146;
        v104 = &v6[v58];
        *((_DWORD *)*v11 + 1) = *(_DWORD *)v10 + HIDWORD(v57);
LABEL_88:
        *((_DWORD *)*v11 + 2) = 1;
        if (!lsqpack_dec_push_entry(v103, *v11))
        {
          *(_DWORD *)(v7 + 504) = 0;
          *(_QWORD *)(v7 + 552) = 0;
          goto LABEL_134;
        }
        v96 = (char *)*v11;
        v97 = *((_DWORD *)*v11 + 2) - 1;
        *((_DWORD *)*v11 + 2) = v97;
        if (!v97)
          free(v96);
        *v11 = 0;
LABEL_146:
        HTTP3Connection::_cleanupConnection((HTTP3Connection *)v7, 513, 0);
        HTTP3Connection::reportServerProtocolViolation(v7, 16, -1);
        return 0;
      case 0xE:
        v59 = *(unsigned int **)(v7 + 552);
        v60 = *v59;
        v61 = *(_DWORD *)(v7 + 544);
        v62 = v61 + *v59;
        if (*(_DWORD *)(v7 + 560) >= v62)
        {
          v63 = (_DWORD *)(v7 + 544);
        }
        else
        {
          *(_DWORD *)(v7 + 560) = v62;
          v59 = (unsigned int *)malloc_type_realloc(v59, v62 + 28, 0x9D13A7E5uLL);
          if (!v59)
            goto LABEL_146;
          *v11 = (const char *)v59;
          v63 = (_DWORD *)(v7 + 544);
          v61 = *v101;
          v60 = *v59;
        }
        v72 = *(unsigned int *)v10;
        v73 = v61 - v72;
        if (v73 >= (int)v9 - (int)v6)
          v74 = (v9 - (_DWORD)v6);
        else
          v74 = v73;
        memcpy((char *)v59 + v60 + v72 + 28, v6, v74);
        v51 = *(_DWORD *)v10 + v74;
        *(_DWORD *)v10 = v51;
        v104 = &v6[v74];
        if (v51 != *v63)
          goto LABEL_134;
        v52 = *v11;
LABEL_87:
        *((_DWORD *)v52 + 1) = v51;
        goto LABEL_88;
      default:
        __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4981, "0");
    }
  }
}

uint64_t lsqpack_huff_decode(unsigned __int8 *a1, int a2, char *a3, uint64_t a4, _DWORD *a5, int a6)
{
  int v6;
  unint64_t v7;
  unsigned int v8;
  unint64_t v9;
  char *v10;
  char *v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  unsigned int v21;
  __int16 v22;
  BOOL v23;
  char *v24;
  unsigned int v25;
  int v26;
  char *v27;
  char v29;
  char v30;
  char v31;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  char *v38;
  int v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  char *v44;
  unsigned int v45;
  int v46;
  char *v47;
  char v49;
  char v50;
  char v51;

  v6 = a4;
  if (!a6 || *a5)
    return lsqpack_huff_decode_full(a1, a2, a3, a4, (uint64_t)a5, a6);
  v7 = 0;
  v8 = 0;
  v9 = (unint64_t)&a1[a2];
  v10 = &a3[(int)a4];
  v11 = a3;
  do
  {
    while (1)
    {
LABEL_4:
      if ((unint64_t)(a1 + 8) <= v9)
      {
        v15 = (64 - v8) >> 3;
        if (v15 != 7)
        {
          if (v15 != 8)
          {
LABEL_15:
            v8 += (64 - (_BYTE)v8) & 0x78;
            v18 = (v7 << 48) | ((unint64_t)*a1 << 40) | ((unint64_t)a1[1] << 32) | ((unint64_t)a1[2] << 24) | ((unint64_t)a1[3] << 16) | ((unint64_t)a1[4] << 8);
            v19 = a1[5];
            a1 += 6;
            v7 = v18 | v19;
            goto LABEL_16;
          }
          v16 = *a1++;
          v7 = v16;
        }
        v17 = *a1++;
        v7 = v17 | (v7 << 8);
        goto LABEL_15;
      }
      if ((unint64_t)a1 >= v9)
      {
        if (v8 >= 5)
        {
          v43 = ((_DWORD)v7 << (16 - v8)) & 0xFFFE | (-1 << (16 - v8)) & 0xFFFE ^ 0xFFFF;
          if (v8 <= 7 && v43 == 0xFFFF)
            goto LABEL_78;
          v44 = &hdecs[4 * v43];
          v45 = *v44;
          if (v8 < v45 >> 2)
          {
LABEL_79:
            v35 = 0;
            v36 = 3;
            return v36 | (v35 << 32);
          }
          v46 = v45 & 3;
          v47 = &v11[v45 & 3];
          if ((v45 & 3) == 0 || v47 > v10)
          {
            if (v47 > v10)
              goto LABEL_38;
            goto LABEL_79;
          }
          v49 = v44[1];
          v50 = v44[2];
          if (v46 == 2)
          {
            *v11 = v49;
            v11[1] = v50;
            LODWORD(v11) = (_DWORD)v11 + 2;
          }
          else if (v46 == 3)
          {
            v51 = v44[3];
            *v11 = v49;
            v11[1] = v50;
            v11[2] = v51;
            LODWORD(v11) = (_DWORD)v11 + 3;
          }
          else
          {
            *v11 = v49;
            LODWORD(v11) = (_DWORD)v11 + 1;
          }
          v8 -= v45 >> 2;
        }
        if (!v8 || (~(_DWORD)v7 & ~(-1 << v8)) == 0)
        {
LABEL_78:
          v36 = 0;
          v35 = ((_DWORD)v11 - (_DWORD)a3);
          return v36 | (v35 << 32);
        }
        goto LABEL_79;
      }
      v12 = v8;
      do
      {
        v13 = *a1++;
        v7 = v13 | (v7 << 8);
        v8 = v12 + 8;
        if ((unint64_t)a1 >= v9)
          break;
        v14 = v12 >= 0x31;
        v12 += 8;
      }
      while (!v14);
LABEL_16:
      if (v10 - v11 < 12 || v8 < 0x10)
        break;
      do
      {
        v20 = &hdecs[4 * (unsigned __int16)(v7 >> (v8 - 16))];
        v21 = *v20;
        v22 = *(_WORD *)(v20 + 1);
        LOBYTE(v20) = v20[3];
        *(_WORD *)v11 = v22;
        v11[2] = (char)v20;
        v11 += v21 & 3;
        v8 -= v21 >> 2;
        if (v21)
          v23 = v8 > 0xF;
        else
          v23 = 0;
      }
      while (v23);
      if (v8 >= 0x10)
        goto LABEL_47;
    }
  }
  while (v8 < 0x10);
  while (1)
  {
    v24 = &hdecs[4 * (unsigned __int16)(v7 >> (v8 - 16))];
    v25 = *v24;
    v26 = v25 & 3;
    v27 = &v11[v25 & 3];
    if ((v25 & 3) == 0 || v27 > v10)
      break;
    v29 = v24[1];
    v30 = v24[2];
    if (v26 == 2)
    {
      *v11 = v29;
      v11[1] = v30;
      v11 += 2;
    }
    else if (v26 == 3)
    {
      v31 = v24[3];
      *v11 = v29;
      v11[1] = v30;
      v11[2] = v31;
      v11 += 3;
    }
    else
    {
      *v11++ = v29;
    }
    v8 -= v25 >> 2;
    if (v8 <= 0xF)
      goto LABEL_4;
  }
  if (v27 <= v10)
  {
LABEL_47:
    v37 = v8 & 7;
    if ((v8 & 7) != 0 && v11 > a3)
    {
      v38 = v11 - 1;
      do
      {
        v23 = v38 > a3;
        v39 = *v38--;
        v8 += encode_table[2 * v39 + 1];
        v37 = v8 & 7;
      }
      while (v23 && (v8 & 7) != 0);
      v11 = v38 + 1;
    }
    if (v37)
      __assert_rtn("huff_decode_fast", "lsqpack.c", 5398, "(avail_bits & 7) == 0");
    v40 = (_DWORD)v10 - (_DWORD)v11;
    v41 = lsqpack_huff_decode_full(&a1[-(v8 >> 3)], v9 - ((_DWORD)a1 - (v8 >> 3)), v11, ((_DWORD)v10 - (_DWORD)v11), (uint64_t)a5, 1);
    v42 = v6 - v40;
    if ((v41 & 0xFFFFFFFD) != 0)
      v42 = 0;
    v35 = (v42 + HIDWORD(v41));
    v36 = v41;
  }
  else
  {
LABEL_38:
    v33 = v8 & 7;
    if ((v8 & 7) != 0 && v11 > a3)
    {
      --v11;
      do
      {
        v23 = v11 > a3;
        v34 = *v11--;
        v8 += encode_table[2 * v34 + 1];
        v33 = v8 & 7;
      }
      while (v23 && (v8 & 7) != 0);
      LODWORD(v11) = (_DWORD)v11 + 1;
    }
    if (v33)
      __assert_rtn("huff_decode_fast", "lsqpack.c", 5386, "(avail_bits & 7) == 0");
    v35 = ((_DWORD)v11 - (_DWORD)v10 + v6);
    v36 = 2;
  }
  return v36 | (v35 << 32);
}

uint64_t lsqpack_dec_push_entry(uint64_t a1, const char *a2)
{
  unsigned int v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _QWORD *v10;
  int v11;
  uint64_t v12;
  FILE *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  FILE *v20;

  v4 = *(_DWORD *)(a1 + 56);
  if (v4)
  {
    if ((*(_DWORD *)(a1 + 60) + 1) % v4 != *(_DWORD *)(a1 + 64))
    {
      v6 = *(_QWORD **)(a1 + 72);
      goto LABEL_12;
    }
    v5 = malloc_type_malloc(16 * v4, 0x80040B8603338uLL);
    if (v5)
    {
      v6 = v5;
      v7 = *(unsigned int *)(a1 + 60);
      v8 = *(unsigned int *)(a1 + 64);
      if (v7 >= v8)
      {
        v11 = v7 - v8;
        memcpy(v5, (const void *)(*(_QWORD *)(a1 + 72) + 8 * v8), 8 * (v7 - v8 + 1));
        v9 = 0;
        *(_DWORD *)(a1 + 60) = v11;
      }
      else
      {
        memcpy(v5, *(const void **)(a1 + 72), 8 * v7 + 8);
        memcpy(&v6[*(unsigned int *)(a1 + 56) + *(unsigned int *)(a1 + 64)], (const void *)(*(_QWORD *)(a1 + 72) + 8 * *(unsigned int *)(a1 + 64)), 8 * (*(_DWORD *)(a1 + 56) - *(_DWORD *)(a1 + 64)));
        v9 = *(_DWORD *)(a1 + 64) + *(_DWORD *)(a1 + 56);
      }
      *(_DWORD *)(a1 + 64) = v9;
      free(*(void **)(a1 + 72));
      *(_QWORD *)(a1 + 72) = v6;
      v4 = 2 * *(_DWORD *)(a1 + 56);
      goto LABEL_11;
    }
    return 0xFFFFFFFFLL;
  }
  v10 = malloc_type_malloc(0x20uLL, 0x80040B8603338uLL);
  *(_QWORD *)(a1 + 72) = v10;
  if (!v10)
    return 0xFFFFFFFFLL;
  v6 = v10;
  v4 = 4;
LABEL_11:
  *(_DWORD *)(a1 + 56) = v4;
LABEL_12:
  v12 = *(unsigned int *)(a1 + 60);
  v6[v12] = a2;
  *(_DWORD *)(a1 + 60) = ((int)v12 + 1) % v4;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)a2 + *((_DWORD *)a2 + 1) + 32;
  v13 = *(FILE **)(a1 + 48);
  if (v13)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v13);
    fputc(10, *(FILE **)(a1 + 48));
  }
  v14 = *(_DWORD *)(a1 + 20);
  if (v14)
    v14 = (*(_DWORD *)(a1 + 32) + 1) % (2 * v14);
  *(_DWORD *)(a1 + 32) = v14;
  qdec_remove_overflow_entries(a1);
  v15 = a1 + 16 * (*(_DWORD *)(a1 + 32) & 7);
  v16 = *(_QWORD *)(v15 + 96);
  if (v16)
  {
    v17 = (_QWORD *)(v15 + 104);
    do
    {
      v18 = *(_QWORD *)(v16 + 16);
      if (*(_DWORD *)(v16 + 64) == *(_DWORD *)(a1 + 32))
      {
        *(_DWORD *)(v16 + 104) &= ~4u;
        v19 = (_QWORD *)(v18 + 24);
        if (!v18)
          v19 = v17;
        *v19 = *(_QWORD *)(v16 + 24);
        **(_QWORD **)(v16 + 24) = v18;
        --*(_DWORD *)(a1 + 224);
        v20 = *(FILE **)(a1 + 48);
        if (v20)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v20);
          fprintf(*(FILE **)(a1 + 48), "header block for stream %llu has become unblocked", *(_QWORD *)(v16 + 40));
          fputc(10, *(FILE **)(a1 + 48));
        }
        (**(void (***)(_QWORD))(a1 + 40))(*(_QWORD *)(v16 + 32));
      }
      v16 = v18;
    }
    while (v18);
  }
  if (*(_DWORD *)(a1 + 12) > *(_DWORD *)(a1 + 8))
    return 0xFFFFFFFFLL;
  return 0;
}

void qdec_remove_overflow_entries(uint64_t a1)
{
  unsigned int v1;
  FILE *v3;
  uint64_t v4;
  _DWORD *v5;
  int v6;

  v1 = *(_DWORD *)(a1 + 12);
  while (v1 > *(_DWORD *)(a1 + 8))
  {
    v3 = *(FILE **)(a1 + 48);
    if (v3)
    {
      fwrite("qdec: debug: ", 0xDuLL, 1uLL, v3);
      fprintf(*(FILE **)(a1 + 48), "capacity %u, drop entry", *(_DWORD *)(a1 + 12));
      fputc(10, *(FILE **)(a1 + 48));
      v1 = *(_DWORD *)(a1 + 12);
    }
    v4 = *(unsigned int *)(a1 + 64);
    v5 = *(_DWORD **)(*(_QWORD *)(a1 + 72) + 8 * v4);
    *(_DWORD *)(a1 + 64) = (v4 + 1) % *(_DWORD *)(a1 + 56);
    v1 = v1 - (*v5 + v5[1]) - 32;
    *(_DWORD *)(a1 + 12) = v1;
    v6 = v5[2] - 1;
    v5[2] = v6;
    if (!v6)
    {
      free(v5);
      v1 = *(_DWORD *)(a1 + 12);
    }
  }
}

uint64_t parse_header_data(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  unsigned __int8 *v4;
  unint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  unsigned __int8 *v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  int v22;
  char *dst;
  unint64_t v24;
  int v25;
  unint64_t v26;
  int v27;
  unint64_t v28;
  unsigned int v29;
  size_t v30;
  void *v31;
  int v32;
  int v33;
  unint64_t v34;
  int v35;
  char *v36;
  unint64_t v37;
  int v38;
  int v39;
  unsigned int v40;
  size_t v41;
  void *v42;
  int v43;
  int v44;
  unsigned int *table_entry_rel;
  int v46;
  int v47;
  uint64_t v48;
  int v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char **v53;
  size_t v54;
  size_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _DWORD *v59;
  char *v60;
  char *v61;
  int v62;
  unsigned int v63;
  unsigned __int8 *v64;
  uint64_t v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  char **v72;
  size_t v73;
  uint64_t v74;
  uint64_t v75;
  _DWORD *v76;
  char v77;
  char *v78;
  char *v79;
  int v80;
  unsigned int v81;
  unsigned int v82;
  unsigned int v83;
  int v84;
  int v85;
  int v86;
  unsigned int *v87;
  int v88;
  int v89;
  int v90;
  unsigned int v91;
  uint64_t v92;
  int v93;
  unsigned int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  int v99;
  unsigned int v100;
  int v101;
  int v102;
  int v103;
  int v105;
  int v106;
  FILE *v107;
  unint64_t v108;
  _DWORD *v109;
  int *v111;
  size_t v112;
  unsigned __int8 *v113;
  unint64_t v114;

  v4 = a3;
  v112 = 0;
  v113 = a3;
  if (a4 < 1)
  {
LABEL_146:
    if (*(_QWORD *)(a2 + 56))
      return 2;
    if (*(_DWORD *)(a2 + 136))
    {
      v106 = 3843;
      goto LABEL_187;
    }
    v105 = *(_DWORD *)(a2 + 104);
    if ((v105 & 0x22) == 2)
    {
      v106 = 3837;
      goto LABEL_187;
    }
    if ((v105 & 0x40) != 0)
    {
      v106 = 3839;
      goto LABEL_187;
    }
    return 0;
  }
  v7 = (unint64_t)&a3[a4];
  v8 = (_DWORD *)(a2 + 184);
  v111 = (int *)(a2 + 160);
  v9 = 0xFFFFFFFFLL;
  v10 = a3;
  v109 = (_DWORD *)(a2 + 184);
  while (2)
  {
    switch(*(_DWORD *)(a2 + 136))
    {
      case 0:
        v11 = (char)*v10;
        if (v11 < 0)
        {
          *(_DWORD *)(a2 + 144) = v11 & 0x40;
          *(_DWORD *)(a2 + 160) = 0;
          v9 = 6;
          *(_DWORD *)(a2 + 136) = 1;
LABEL_71:
          v114 = 0;
          v48 = v9;
          v49 = lsqpack_dec_int(&v113, v7, v9, (uint64_t *)&v114, v111);
          if (v49 || (v50 = v114, v114 >> 24))
          {
            if (v49 != -1)
            {
              v106 = 3590;
              goto LABEL_187;
            }
            return 2;
          }
          if (*(_DWORD *)(a2 + 144))
          {
            if (v114 > 0x62)
              goto LABEL_158;
            v108 = v7;
            v51 = a1;
            v52 = 4 * (*(_DWORD *)a1 & 1);
            v53 = &(&static_table)[3 * v114];
            v55 = *((unsigned int *)v53 + 4);
            v54 = *((unsigned int *)v53 + 5);
            v56 = (v54 + v55);
            v57 = v51;
            v58 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(v51 + 40) + 8))(*(_QWORD *)(a2 + 32), 0, v56 + v52);
            if (!v58)
            {
              v106 = 3585;
              v4 = a3;
              a1 = v57;
              goto LABEL_187;
            }
            v59 = (_DWORD *)v58;
            *(_BYTE *)(v58 + 35) = v52;
            *(_BYTE *)(v58 + 31) = v50;
            *(_BYTE *)(v58 + 33) |= 0x3Au;
            *(_WORD *)(v58 + 24) = v55;
            *(_WORD *)(v58 + 26) = v54;
            *(_DWORD *)(v58 + 8) = name_hashes[v50];
            *(_DWORD *)(v58 + 12) = nameval_hashes[v50];
            v60 = (char *)(*(_QWORD *)v58 + *(int *)(v58 + 16));
            memcpy(v60, (&static_table)[3 * v50], v55);
            v61 = &v60[v55];
            if ((_DWORD)v52)
            {
              *(_WORD *)v61 = 8250;
              v61 += 2;
            }
            v59[5] = (unsigned __int16)((_WORD)v61 - *v59);
            memcpy(v61, (&static_table)[3 * v50 + 1], v54);
            if ((_DWORD)v52)
              *(_WORD *)&v61[v54] = 2573;
            a1 = v57;
            if ((*(unsigned int (**)(_QWORD, _DWORD *))(*(_QWORD *)(v57 + 40) + 16))(*(_QWORD *)(a2 + 32), v59))
            {
              v106 = 3585;
              goto LABEL_183;
            }
            v9 = v48;
            *(_DWORD *)(v57 + 28) += v56;
            v8 = v109;
            v4 = a3;
            v7 = v108;
          }
          else
          {
            v62 = *(_DWORD *)(a1 + 20);
            if (v62)
              v63 = (2 * v62 - (int)v114 + *(_DWORD *)(a2 + 68)) % (2 * v62);
            else
              v63 = 0;
            v9 = v48;
            v84 = header_out_dynamic_entry((unsigned int *)a1, a2, v63);
            v85 = *(_DWORD *)(a2 + 104);
            if ((v85 & 2) != 0)
              v86 = v85 | (32 * (*(_DWORD *)(a2 + 64) == v63));
            else
              v86 = v85 | 0x40;
            *(_DWORD *)(a2 + 104) = v86;
            if (v84)
            {
LABEL_158:
              v106 = 3585;
              goto LABEL_187;
            }
          }
LABEL_144:
          *(_DWORD *)(a2 + 136) = 0;
          goto LABEL_145;
        }
        if ((v11 & 0x40) == 0)
        {
          if ((v11 & 0x20) != 0)
          {
            *(_DWORD *)(a2 + 148) = v11 & 0x10;
            *(_DWORD *)(a2 + 152) = *v10 & 8;
            *(_DWORD *)(a2 + 160) = 0;
            *(_DWORD *)(a2 + 136) = 8;
            v9 = 3;
LABEL_121:
            v114 = 0;
            v90 = lsqpack_dec_int(&v113, v7, v9, (uint64_t *)&v114, v111);
            if (v90 || (v91 = v114, v114 >> 24))
            {
              if (v90 != -1)
              {
                v106 = 3731;
                goto LABEL_187;
              }
              return 2;
            }
            *(_DWORD *)(a2 + 140) = v114;
            if (*(_QWORD *)(a2 + 80))
              __assert_rtn("header_out_begin_literal", "lsqpack.c", 3177, "!read_ctx->hbrc_out.xhdr");
            v92 = v9;
            v93 = *(_DWORD *)(a2 + 148);
            if (*(_DWORD *)(a2 + 152))
              v94 = v91 >> 1;
            else
              v94 = 0;
            v95 = 4 * (*(_DWORD *)a1 & 1);
            v96 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 8))(*(_QWORD *)(a2 + 32), 0, v95 + v94 + v91);
            *(_QWORD *)(a2 + 80) = v96;
            if (!v96)
            {
              v106 = 3719;
              goto LABEL_187;
            }
            *(_BYTE *)(v96 + 35) = v95;
            if (v93)
              *(_BYTE *)(v96 + 33) |= 0x40u;
            *(_QWORD *)(a2 + 88) = 0;
            if (*(_DWORD *)(a2 + 152))
            {
              *(_DWORD *)(a2 + 184) = 0;
              v97 = 9;
            }
            else
            {
              v97 = 10;
            }
            *(_DWORD *)(a2 + 136) = v97;
            v9 = v92;
            goto LABEL_145;
          }
          if ((v11 & 0x10) != 0)
          {
            *(_DWORD *)(a2 + 160) = 0;
            *(_DWORD *)(a2 + 136) = 2;
            v9 = 4;
LABEL_135:
            v114 = 0;
            v98 = lsqpack_dec_int(&v113, v7, v9, (uint64_t *)&v114, v111);
            if (v98 || v114 >> 24)
            {
              if (v98 != -1)
              {
                v106 = 3821;
                goto LABEL_187;
              }
              return 2;
            }
            v99 = *(_DWORD *)(a1 + 20);
            if (v99)
              v100 = ((int)v114 + *(_DWORD *)(a2 + 68) + 1) % (2 * v99);
            else
              v100 = 0;
            v101 = header_out_dynamic_entry((unsigned int *)a1, a2, v100);
            v102 = *(_DWORD *)(a2 + 104);
            if ((v102 & 2) != 0)
              v103 = v102 | (32 * (*(_DWORD *)(a2 + 64) == v100));
            else
              v103 = v102 | 0x40;
            *(_DWORD *)(a2 + 104) = v103;
            if (v101)
            {
              v106 = 3816;
              goto LABEL_187;
            }
            goto LABEL_144;
          }
          *(_DWORD *)(a2 + 148) = v11 & 8;
          *(_DWORD *)(a2 + 160) = 0;
          *(_DWORD *)(a2 + 136) = 11;
          v9 = 3;
LABEL_9:
          v114 = 0;
          v12 = lsqpack_dec_int(&v113, v7, v9, (uint64_t *)&v114, v111);
          if (v12 || v114 >> 24)
          {
            if (v12 != -1)
            {
              v106 = 3802;
              goto LABEL_187;
            }
            return 2;
          }
          v13 = v9;
          v14 = *(_DWORD *)(a1 + 20);
          if (v14)
          {
            v15 = 2 * v14;
            v16 = ((int)v114 + *(_DWORD *)(a2 + 68) + 1) % v15;
            v17 = (v15 - v16 + *(_DWORD *)(a1 + 32)) % v15;
          }
          else
          {
            v16 = 0;
            v17 = 0;
          }
          table_entry_rel = (unsigned int *)qdec_get_table_entry_rel(a1, v17);
          if (!table_entry_rel)
          {
            v106 = 3792;
            goto LABEL_187;
          }
          v46 = *(_DWORD *)(a2 + 104);
          if ((v46 & 2) != 0)
            v47 = v46 | (32 * (*(_DWORD *)(a2 + 64) == v16));
          else
            v47 = v46 | 0x40;
          v9 = v13;
          *(_DWORD *)(a2 + 104) = v47;
          if (header_out_begin_dynamic_nameref((unsigned int *)a1, (_QWORD *)a2, table_entry_rel, *(_DWORD *)(a2 + 148)))
          {
            v106 = 3796;
            goto LABEL_187;
          }
          goto LABEL_118;
        }
        *(_DWORD *)(a2 + 148) = v11 & 0x20;
        *(_DWORD *)(a2 + 144) = *v10 & 0x10;
        *(_DWORD *)(a2 + 160) = 0;
        *(_DWORD *)(a2 + 136) = 3;
        v9 = 4;
LABEL_93:
        v64 = v4;
        v114 = 0;
        v65 = v9;
        v66 = lsqpack_dec_int(&v113, v7, v9, (uint64_t *)&v114, v111);
        if (v66 || (v67 = v114, v114 >> 24))
        {
          if (v66 == -1)
            return 2;
          v106 = 3621;
          goto LABEL_186;
        }
        if (!*(_DWORD *)(a2 + 144))
        {
          v80 = *(_DWORD *)(a1 + 20);
          if (v80)
          {
            v81 = 2 * v80;
            v82 = (v81 - v114 + *(_DWORD *)(a2 + 68)) % v81;
            v83 = (v81 - v82 + *(_DWORD *)(a1 + 32)) % v81;
          }
          else
          {
            v82 = 0;
            v83 = 0;
          }
          v87 = (unsigned int *)qdec_get_table_entry_rel(a1, v83);
          if (!v87)
          {
            v106 = 3609;
LABEL_186:
            v4 = v64;
            goto LABEL_187;
          }
          v88 = *(_DWORD *)(a2 + 104);
          if ((v88 & 2) != 0)
            v89 = v88 | (32 * (*(_DWORD *)(a2 + 64) == v82));
          else
            v89 = v88 | 0x40;
          v9 = v65;
          *(_DWORD *)(a2 + 104) = v89;
          v4 = v64;
          if (header_out_begin_dynamic_nameref((unsigned int *)a1, (_QWORD *)a2, v87, *(_DWORD *)(a2 + 148)))
          {
            v106 = 3613;
            goto LABEL_187;
          }
LABEL_118:
          v20 = 4;
LABEL_119:
          *(_DWORD *)(a2 + 136) = v20;
LABEL_145:
          v10 = v113;
          if ((unint64_t)v113 >= v7)
            goto LABEL_146;
          continue;
        }
        if (*(_QWORD *)(a2 + 80))
          __assert_rtn("header_out_begin_static_nameref", "lsqpack.c", 3088, "!read_ctx->hbrc_out.xhdr");
        if (v114 > 0x62)
        {
          v106 = 3602;
          goto LABEL_186;
        }
        v68 = v7;
        v69 = *(_DWORD *)(a2 + 148);
        v70 = 4 * (*(_DWORD *)a1 & 1);
        v71 = a1;
        v72 = &(&static_table)[3 * v114];
        v73 = *((unsigned int *)v72 + 4);
        v74 = v71;
        v75 = (*(uint64_t (**)(_QWORD, _QWORD, size_t))(*(_QWORD *)(v71 + 40) + 8))(*(_QWORD *)(a2 + 32), 0, v70 + v73);
        *(_QWORD *)(a2 + 80) = v75;
        if (v75)
        {
          v76 = (_DWORD *)v75;
          *(_BYTE *)(v75 + 35) = v70;
          *(_BYTE *)(v75 + 31) = v67;
          v77 = *(_BYTE *)(v75 + 33);
          *(_BYTE *)(v75 + 33) = v77 | 0xA;
          *(_DWORD *)(v75 + 8) = name_hashes[v67];
          if (v69)
            *(_BYTE *)(v75 + 33) = v77 | 0x4A;
          *(_WORD *)(v75 + 24) = v73;
          v78 = (char *)(*(_QWORD *)v75 + *(int *)(v75 + 16));
          memcpy(v78, *v72, v73);
          v79 = &v78[v73];
          v9 = v65;
          if ((_DWORD)v70)
          {
            *(_WORD *)v79 = 8250;
            LOWORD(v79) = (_WORD)v79 + 2;
          }
          a1 = v74;
          v7 = v68;
          v76[5] = (unsigned __int16)((_WORD)v79 - *v76);
          *(_QWORD *)(a2 + 88) = 1;
          v8 = v109;
          v4 = a3;
          goto LABEL_118;
        }
        v106 = 3602;
        a1 = v74;
LABEL_183:
        v4 = a3;
LABEL_187:
        *(_DWORD *)(a1 + 332) = v106;
        *(_DWORD *)(a1 + 328) = 0;
        *(_QWORD *)(a1 + 336) = &v113[*(_QWORD *)(a2 + 48) - (_QWORD)&v4[*(_QWORD *)(a2 + 56)]];
        *(_QWORD *)(a1 + 344) = *(_QWORD *)(a2 + 40);
        v107 = *(FILE **)(a1 + 48);
        if (v107)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v107);
          fprintf(*(FILE **)(a1 + 48), "header block error on line %d, offset %llu, stream id %llu", *(_DWORD *)(a1 + 332), *(_QWORD *)(a1 + 336), *(_QWORD *)(a1 + 344));
          fputc(10, *(FILE **)(a1 + 48));
        }
        return 3;
      case 1:
        goto LABEL_71;
      case 2:
        goto LABEL_135;
      case 3:
        goto LABEL_93;
      case 4:
        *(_DWORD *)(a2 + 152) = *v10 & 0x80;
        *(_DWORD *)(a2 + 160) = 0;
        *(_DWORD *)(a2 + 136) = 5;
        v9 = 7;
        goto LABEL_14;
      case 5:
LABEL_14:
        v114 = 0;
        v18 = lsqpack_dec_int(&v113, v7, v9, (uint64_t *)&v114, v111);
        if (v18 || (v19 = v114, v114 >> 24))
        {
          if (v18 != -1)
          {
            v106 = 3658;
            goto LABEL_187;
          }
          return 2;
        }
        *(_DWORD *)(a2 + 140) = v114;
        if (!(_DWORD)v19)
        {
          if (header_out_write_value((int *)a1, a2, 0, 1))
          {
            v106 = 3653;
            goto LABEL_187;
          }
          goto LABEL_144;
        }
        if (*(_DWORD *)(a2 + 152))
        {
          if (guarantee_out_bytes(a1, a2, v19 + (v19 >> 1)))
          {
            v106 = 3639;
            goto LABEL_187;
          }
          *(_DWORD *)(a2 + 184) = 0;
          v20 = 6;
        }
        else
        {
          if (guarantee_out_bytes(a1, a2, v19))
          {
            v106 = 3646;
            goto LABEL_187;
          }
          v20 = 7;
        }
        goto LABEL_119;
      case 6:
        v21 = v7;
        if (*(_DWORD *)(a2 + 140) >= (v7 - (_DWORD)v10))
          v22 = v7 - (_DWORD)v10;
        else
          v22 = *(_DWORD *)(a2 + 140);
        if (!v22)
        {
          v106 = 3663;
          goto LABEL_187;
        }
        dst = (char *)get_dst(a2, &v112);
        v24 = lsqpack_huff_decode(v10, v22, dst, v112, v8, *(_DWORD *)(a2 + 140) == v22);
        v26 = HIDWORD(v24);
        v113 = &v10[v25];
        v27 = *(_DWORD *)(a2 + 140);
        *(_DWORD *)(a2 + 140) = v27 - v25;
        if ((_DWORD)v24 == 2)
        {
          v7 = v21;
          if (HIDWORD(v24))
            *(_DWORD *)(a2 + 92) += HIDWORD(v24);
          if (header_out_grow_buf(a1, a2))
          {
            v106 = 3688;
            goto LABEL_187;
          }
          goto LABEL_145;
        }
        v7 = v21;
        if ((_DWORD)v24 == 1)
          goto LABEL_59;
        if ((_DWORD)v24)
        {
          v106 = 3691;
          goto LABEL_187;
        }
        if (header_out_write_value((int *)a1, a2, SHIDWORD(v24), v27 == v25))
        {
          v106 = 3674;
          goto LABEL_187;
        }
        if (!*(_DWORD *)(a2 + 140))
          goto LABEL_144;
        goto LABEL_145;
      case 7:
        v28 = v7;
        v29 = *(_DWORD *)(a2 + 140);
        if (v29 >= (int)v7 - (int)v10)
          v30 = (v7 - (_DWORD)v10);
        else
          v30 = v29;
        if (!(_DWORD)v30)
        {
          v106 = 3697;
          goto LABEL_187;
        }
        v31 = (void *)get_dst(a2, &v112);
        if (v112 < v30)
        {
          v106 = 3700;
          goto LABEL_187;
        }
        memcpy(v31, v10, v30);
        if (header_out_write_value((int *)a1, a2, v30, *(_DWORD *)(a2 + 140) == v30))
        {
          v106 = 3704;
          goto LABEL_187;
        }
        v32 = *(_DWORD *)(a2 + 140);
        v113 = &v10[v30];
        v33 = v32 - v30;
        *(_DWORD *)(a2 + 140) = v33;
        if (!v33)
          *(_DWORD *)(a2 + 136) = 0;
        goto LABEL_56;
      case 8:
        goto LABEL_121;
      case 9:
        v34 = v7;
        if (*(_DWORD *)(a2 + 140) >= (v7 - (_DWORD)v10))
          v35 = v7 - (_DWORD)v10;
        else
          v35 = *(_DWORD *)(a2 + 140);
        if (!v35)
        {
          v106 = 3736;
          goto LABEL_187;
        }
        v36 = (char *)get_dst(a2, &v112);
        v37 = lsqpack_huff_decode(v10, v35, v36, v112, v8, *(_DWORD *)(a2 + 140) == v35);
        v26 = HIDWORD(v37);
        v113 = &v10[v38];
        v39 = *(_DWORD *)(a2 + 140);
        *(_DWORD *)(a2 + 140) = v39 - v38;
        if ((_DWORD)v37 == 2)
        {
          v7 = v34;
          if (HIDWORD(v37))
            *(_DWORD *)(a2 + 92) += HIDWORD(v37);
          if (header_out_grow_buf(a1, a2))
          {
            v106 = 3761;
            goto LABEL_187;
          }
          goto LABEL_145;
        }
        v7 = v34;
        if ((_DWORD)v37 == 1)
        {
LABEL_59:
          if ((_DWORD)v26)
            *(_DWORD *)(a2 + 92) += v26;
          goto LABEL_145;
        }
        if ((_DWORD)v37)
        {
          v106 = 3764;
          goto LABEL_187;
        }
        if (header_out_write_name((int *)a1, a2, SHIDWORD(v37), v39 == v38))
        {
          v106 = 3747;
          goto LABEL_187;
        }
        if (!*(_DWORD *)(a2 + 140))
          goto LABEL_118;
        goto LABEL_145;
      case 0xA:
        v28 = v7;
        v40 = *(_DWORD *)(a2 + 140);
        if (v40 >= (int)v7 - (int)v10)
          v41 = (v7 - (_DWORD)v10);
        else
          v41 = v40;
        if (!(_DWORD)v41)
        {
          v106 = 3770;
          goto LABEL_187;
        }
        v42 = (void *)get_dst(a2, &v112);
        if (v112 < v41)
        {
          v106 = 3773;
          goto LABEL_187;
        }
        memcpy(v42, v10, v41);
        if (header_out_write_name((int *)a1, a2, v41, *(_DWORD *)(a2 + 140) == v41))
        {
          v106 = 3777;
          goto LABEL_187;
        }
        v43 = *(_DWORD *)(a2 + 140);
        v113 = &v10[v41];
        v44 = v43 - v41;
        *(_DWORD *)(a2 + 140) = v44;
        if (!v44)
          *(_DWORD *)(a2 + 136) = 4;
LABEL_56:
        v7 = v28;
        goto LABEL_145;
      case 0xB:
        goto LABEL_9;
      default:
        __assert_rtn("parse_header_data", "lsqpack.c", 3826, "0");
    }
  }
}

uint64_t lsqpack_dec_int(unsigned __int8 **a1, unint64_t a2, char a3, uint64_t *a4, int *a5)
{
  unsigned __int8 *v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned __int8 *v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;

  v5 = *a1;
  v6 = *a5;
  if (!*a5)
  {
    v9 = v5 + 1;
    v10 = *v5;
    v11 = ~(-1 << a3);
    v7 = v10 & v11;
    if ((v10 & v11) >= v11)
    {
      v8 = 0;
      goto LABEL_5;
    }
LABEL_8:
    v14 = 0;
    *a1 = v9;
    *a4 = v7;
    return v14;
  }
  v7 = *((_QWORD *)a5 + 2);
  v8 = a5[1];
  v9 = *a1;
  while (1)
  {
    v13 = *v9++;
    v12 = v13;
    v7 += (unint64_t)(v13 & 0x7F) << v8;
    v8 += 7;
    if ((v13 & 0x80) == 0)
      break;
LABEL_5:
    if ((unint64_t)v9 >= a2)
    {
      if (v6)
        v6 = a5[2];
      v15 = v6 + (_DWORD)v9 - (_DWORD)v5;
      if (v15 <= 0xA)
      {
        *((_QWORD *)a5 + 2) = v7;
        a5[1] = v8;
        a5[2] = v15;
        *a5 = 1;
        return 0xFFFFFFFFLL;
      }
      return 4294967294;
    }
  }
  if (v8 < 0x40)
    goto LABEL_8;
  if (v8 != 70)
    return 4294967294;
  v14 = 4294967294;
  if (v12 <= 1 && v7 < 0)
    goto LABEL_8;
  return v14;
}

uint64_t header_out_dynamic_entry(unsigned int *a1, uint64_t a2, int a3)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int *table_entry_rel;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  size_t v13;
  unsigned int v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t result;

  v5 = a1[5];
  if (v5)
    v6 = (2 * v5 - a3 + a1[8]) % (2 * v5);
  else
    v6 = 0;
  table_entry_rel = (unsigned int *)qdec_get_table_entry_rel((uint64_t)a1, v6);
  if (!table_entry_rel)
    return 0xFFFFFFFFLL;
  v8 = table_entry_rel;
  v9 = 4 * (*a1 & 1);
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*((_QWORD *)a1 + 5) + 8))(*(_QWORD *)(a2 + 32), 0, table_entry_rel[1] + *table_entry_rel + v9);
  if (!v10)
    return 0xFFFFFFFFLL;
  v11 = v10;
  qdec_maybe_update_entry_hashes(*a1, v8);
  v12 = v8[6];
  if ((v12 & 1) == 0)
  {
    if ((v12 & 2) == 0)
      goto LABEL_8;
LABEL_19:
    *(_BYTE *)(v11 + 33) |= 0x10u;
    *(_DWORD *)(v11 + 12) = v8[4];
    if ((v8[6] & 4) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  *(_BYTE *)(v11 + 33) |= 8u;
  *(_DWORD *)(v11 + 8) = v8[3];
  v12 = v8[6];
  if ((v12 & 2) != 0)
    goto LABEL_19;
LABEL_8:
  if ((v12 & 4) != 0)
  {
LABEL_9:
    *(_BYTE *)(v11 + 33) |= 2u;
    *(_BYTE *)(v11 + 31) = v8[5];
  }
LABEL_10:
  *(_BYTE *)(v11 + 35) = v9;
  v13 = *v8;
  v14 = v8[1];
  *(_WORD *)(v11 + 24) = v13;
  *(_WORD *)(v11 + 26) = v14;
  v15 = (char *)(*(_QWORD *)v11 + *(int *)(v11 + 16));
  memcpy(v15, v8 + 7, v13);
  v16 = *v8;
  v17 = &v15[v16];
  if ((_DWORD)v9)
  {
    *(_WORD *)v17 = 8250;
    v17 += 2;
    v16 = *v8;
  }
  *(_DWORD *)(v11 + 20) = (unsigned __int16)((_WORD)v17 - *(_DWORD *)v11);
  memcpy(v17, (char *)v8 + v16 + 28, v8[1]);
  if ((_DWORD)v9)
    *(_WORD *)&v17[v8[1]] = 2573;
  result = (*(uint64_t (**)(_QWORD, uint64_t))(*((_QWORD *)a1 + 5) + 16))(*(_QWORD *)(a2 + 32), v11);
  if (!(_DWORD)result)
    a1[7] += v8[1] + *v8;
  return result;
}

uint64_t HTTP3Connection::_decoderPrepareDecode(uint64_t a1, uint64_t a2, unint64_t a3)
{
  std::vector<char> *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v7 = *(_QWORD *)(a1 + 184);
  v6 = *(_QWORD *)(a1 + 192);
  v5 = (std::vector<char> *)(a1 + 184);
  v8 = v6 - v7;
  if (v8 < a3)
  {
    v9 = 2 * v8;
    if (2 * v8 <= a3)
      v9 = a3;
    if (v9 <= 0x200)
      v9 = 512;
    std::vector<char>::__append(v5, v9 - v8);
    v7 = *(_QWORD *)(a1 + 184);
    v8 = *(_QWORD *)(a1 + 192) - v7;
  }
  if (!a2)
  {
    *(_OWORD *)(a1 + 232) = 0u;
    *(_OWORD *)(a1 + 216) = 0u;
    if (v8 >= 0xFFFF)
      LOWORD(v8) = -1;
  }
  *(_QWORD *)(a1 + 208) = v7;
  v10 = a1 + 208;
  *(_WORD *)(v10 + 26) = v8;
  return v10;
}

uint64_t HTTP3Connection::_decoderProcessHeader(uint64_t a1, uint64_t *a2)
{
  int v4;
  __CFString *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  unint64_t *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  void *v28;
  uint64_t v29;
  unsigned __int8 *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  void *__p[2];
  char v37;
  void *__dst[2];
  char v39;

  v4 = *(_DWORD *)(a1 + 116);
  switch(v4)
  {
    case 7:
      if (*(_BYTE *)(a1 + 177))
        return 0;
      v12 = *(std::__shared_weak_count **)(a1 + 56);
      if (!v12)
        return 0;
      v13 = std::__shared_weak_count::lock(v12);
      if (v13)
      {
        v14 = *(_QWORD *)(a1 + 48);
        if (v14)
        {
          std::string::basic_string[abi:nn180100](__dst, (void *)(*a2 + *((int *)a2 + 4)), *((unsigned __int16 *)a2 + 12));
          std::string::basic_string[abi:nn180100](__p, (void *)(*a2 + *((int *)a2 + 5)), *((unsigned __int16 *)a2 + 13));
          HTTP2ServerPush::addPromisedHeaderToStream(v14 + 624, (__int128 *)__dst, (__int128 *)__p, *(_DWORD *)(a1 + 168));
          if (v37 < 0)
            operator delete(__p[0]);
          if (v39 < 0)
            operator delete(__dst[0]);
        }
        p_shared_owners = (unint64_t *)&v13->__shared_owners_;
        do
          v16 = __ldaxr(p_shared_owners);
        while (__stlxr(v16 - 1, p_shared_owners));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
        return 0;
      }
      break;
    case 4:
      v5 = (__CFString *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithBytes:length:encoding:", *a2 + *((int *)a2 + 4), *((unsigned __int16 *)a2 + 12), 1);
      if (-[__CFString hasPrefix:](v5, "hasPrefix:", CFSTR(":")))
      {
        *(_QWORD *)(a1 + 264) = 4;
        *(_DWORD *)(a1 + 272) = -1;
        HTTP3Stream::_cleanupStream(a1, 270, 0);
        HTTP3Stream::_protocolCallback((HTTP3Stream *)a1);
        v17 = *(std::__shared_weak_count **)(a1 + 56);
        if (v17)
        {
          v18 = std::__shared_weak_count::lock(v17);
          if (v18)
          {
            v8 = v18;
            v19 = *(_QWORD *)(a1 + 48);
            if (v19)
              HTTP3Connection::reportServerProtocolViolation(v19, 53, *(_QWORD *)(a1 + 336));
            v20 = (unint64_t *)&v8->__shared_owners_;
            do
              v11 = __ldaxr(v20);
            while (__stlxr(v11 - 1, v20));
            goto LABEL_32;
          }
        }
LABEL_34:

        return 0xFFFFFFFFLL;
      }
      goto LABEL_46;
    case 1:
      if (*(_DWORD *)(a1 + 248) != -1)
      {
        v5 = (__CFString *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithBytes:length:encoding:", *a2 + *((int *)a2 + 4), *((unsigned __int16 *)a2 + 12), 1);
        if (-[__CFString hasPrefix:](v5, "hasPrefix:", CFSTR(":")))
        {
          *(_QWORD *)(a1 + 264) = 4;
          *(_DWORD *)(a1 + 272) = -1;
          HTTP3Stream::_cleanupStream(a1, 270, 0);
          HTTP3Stream::_protocolCallback((HTTP3Stream *)a1);
          v6 = *(std::__shared_weak_count **)(a1 + 56);
          if (v6)
          {
            v7 = std::__shared_weak_count::lock(v6);
            if (v7)
            {
              v8 = v7;
              v9 = *(_QWORD *)(a1 + 48);
              if (v9)
                HTTP3Connection::reportServerProtocolViolation(v9, 52, *(_QWORD *)(a1 + 336));
              v10 = (unint64_t *)&v8->__shared_owners_;
              do
                v11 = __ldaxr(v10);
              while (__stlxr(v11 - 1, v10));
LABEL_32:
              if (!v11)
              {
                ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
                std::__shared_weak_count::__release_weak(v8);
              }
              goto LABEL_34;
            }
          }
          goto LABEL_34;
        }
LABEL_46:
        v28 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithBytes:length:encoding:", *a2 + *((int *)a2 + 5), *((unsigned __int16 *)a2 + 13), 1);
        v29 = *(_QWORD *)(a1 + 256);
        HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)__dst, v5);
        HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue((HTTPHeaderValueMixedValue *)__p, v28);
        HTTPHeaderDict::addValue(v29, (uint64_t)__dst, (uint64_t)__p);
        __p[0] = &off_1E14E9A00;
        if (__p[1])
          CFRelease(__p[1]);
        __dst[0] = &off_1E14E9A00;
        if (__dst[1])
          CFRelease(__dst[1]);

        return 0;
      }
      v21 = *a2;
      if (!strncmp(":status", (const char *)(*a2 + *((int *)a2 + 4)), *((unsigned __int16 *)a2 + 12)))
      {
        if (*((_WORD *)a2 + 13) == 3
          && (v31 = (unsigned __int8 *)(v21 + *((int *)a2 + 5)),
              v32 = *v31,
              (*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v32 + 60) & 0x400) != 0)
          && (v33 = v31[1], (*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v33 + 60) & 0x400) != 0)
          && (v34 = v31[2], (*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v34 + 60) & 0x400) != 0))
        {
          v35 = 10 * v33 + 100 * v32 + v34 - 5328;
        }
        else
        {
          v35 = 0;
        }
        v13 = 0;
        *(_DWORD *)(a1 + 248) = v35;
      }
      else
      {
        *(_QWORD *)(a1 + 264) = 4;
        v13 = (std::__shared_weak_count *)0xFFFFFFFFLL;
        *(_DWORD *)(a1 + 272) = -1;
        HTTP3Stream::_cleanupStream(a1, 270, 0);
        HTTP3Stream::_protocolCallback((HTTP3Stream *)a1);
        v22 = *(std::__shared_weak_count **)(a1 + 56);
        if (v22)
        {
          v23 = std::__shared_weak_count::lock(v22);
          if (v23)
          {
            v24 = v23;
            v25 = *(_QWORD *)(a1 + 48);
            if (v25)
              HTTP3Connection::reportServerProtocolViolation(v25, 51, *(_QWORD *)(a1 + 336));
            v26 = (unint64_t *)&v24->__shared_owners_;
            do
              v27 = __ldaxr(v26);
            while (__stlxr(v27 - 1, v26));
            if (!v27)
            {
              ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
              std::__shared_weak_count::__release_weak(v24);
            }
            return 0xFFFFFFFFLL;
          }
        }
      }
      break;
    default:
      __assert_rtn("processHeader", "HTTP3Stream.mm", 520, "false");
  }
  return (uint64_t)v13;
}

void sub_183F51F88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, CFTypeRef cf, int a11, __int16 a12, char a13, char a14, void *a15, CFTypeRef a16, int a17, __int16 a18, char a19, char a20)
{
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v23;

  p_shared_owners = (unint64_t *)&v20->__shared_owners_;
  do
    v23 = __ldaxr(p_shared_owners);
  while (__stlxr(v23 - 1, p_shared_owners));
  if (!v23)
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t qdec_maybe_update_entry_hashes(uint64_t result, unsigned int *a2)
{
  unsigned int v3;
  int *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  unsigned int v21;
  unsigned int v22;

  if ((result & 6) != 0)
  {
    v3 = a2[6];
    if ((v3 & 1) == 0)
    {
      a2[6] = v3 | 1;
      v4 = (int *)(a2 + 7);
      v5 = *a2;
      if (v5 < 0x10)
      {
        v16 = v5 + 414139866;
      }
      else
      {
        v6 = (unint64_t)v4 + v5 - 15;
        v7 = 1679910008;
        v8 = 39378473;
        v9 = -2008766304;
        v10 = 645669457;
        do
        {
          HIDWORD(v11) = v10 - 2048144777 * *v4;
          LODWORD(v11) = HIDWORD(v11);
          v10 = -1640531535 * (v11 >> 19);
          HIDWORD(v11) = v9 - 2048144777 * v4[1];
          LODWORD(v11) = HIDWORD(v11);
          v9 = -1640531535 * (v11 >> 19);
          HIDWORD(v11) = v8 - 2048144777 * v4[2];
          LODWORD(v11) = HIDWORD(v11);
          v8 = -1640531535 * (v11 >> 19);
          HIDWORD(v11) = v7 - 2048144777 * v4[3];
          LODWORD(v11) = HIDWORD(v11);
          v7 = -1640531535 * (v11 >> 19);
          v4 += 4;
        }
        while ((unint64_t)v4 < v6);
        HIDWORD(v13) = v10;
        LODWORD(v13) = v10;
        v12 = v13 >> 31;
        HIDWORD(v13) = v9;
        LODWORD(v13) = v9;
        v14 = v13 >> 25;
        HIDWORD(v13) = v8;
        LODWORD(v13) = v8;
        v15 = v13 >> 20;
        HIDWORD(v13) = v7;
        LODWORD(v13) = v7;
        v16 = v12 + v5 + v14 + v15 + (v13 >> 14);
        v5 &= 0xFu;
      }
      if (v5 >= 4)
      {
        do
        {
          v17 = *v4++;
          HIDWORD(v18) = v16 - 1028477379 * v17;
          LODWORD(v18) = HIDWORD(v18);
          v16 = 668265263 * (v18 >> 15);
          v5 -= 4;
        }
        while (v5 > 3);
      }
      for (; v5; --v5)
      {
        v19 = *(unsigned __int8 *)v4;
        v4 = (int *)((char *)v4 + 1);
        HIDWORD(v20) = v16 + 374761393 * v19;
        LODWORD(v20) = HIDWORD(v20);
        v16 = -1640531535 * (v20 >> 21);
      }
      v21 = -1028477379 * ((-2048144777 * (v16 ^ (v16 >> 15))) ^ ((-2048144777 * (v16 ^ (v16 >> 15))) >> 13));
      a2[3] = v21 ^ HIWORD(v21);
    }
  }
  if ((result & 4) != 0)
  {
    v22 = a2[6];
    if ((v22 & 2) == 0)
    {
      if ((v22 & 1) == 0)
        __assert_rtn("qdec_maybe_update_entry_hashes", "lsqpack.c", 2964, "entry->dte_flags & DTEF_NAME_HASH");
      a2[6] = v22 | 2;
      result = XXH_INLINE_XXH32((int *)((char *)a2 + *a2 + 28), a2[1], a2[3]);
      a2[4] = result;
    }
  }
  return result;
}

uint64_t qdec_get_table_entry_rel(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  int v5;

  v2 = *(_DWORD *)(a1 + 56);
  if (v2
    && ((v3 = *(_DWORD *)(a1 + 60), v4 = *(_DWORD *)(a1 + 64), v3 >= v4) ? (v5 = 0) : (v5 = *(_DWORD *)(a1 + 56)),
        v3 + v5 - v4 > a2))
  {
    return *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * ((v2 + ~a2 + v3) % v2));
  }
  else
  {
    return 0;
  }
}

uint64_t get_dst(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  BOOL v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a1 + 80);
  if (!v2)
    __assert_rtn("get_dst", "lsqpack.c", 3359, "read_ctx->hbrc_out.xhdr");
  if (*(_DWORD *)(a1 + 88))
    v3 = *(_DWORD *)(v2 + 20) - *(_DWORD *)(v2 + 16) + *(_DWORD *)(a1 + 92);
  else
    v3 = *(_DWORD *)(a1 + 92);
  v4 = *(unsigned __int16 *)(v2 + 26);
  v5 = v4 >= v3;
  v6 = v4 - v3;
  if (!v5)
    __assert_rtn("get_dst", "lsqpack.c", 3366, "read_ctx->hbrc_out.xhdr->val_len >= off");
  *a2 = v6;
  return *(_QWORD *)v2 + *(int *)(v2 + 16) + v3;
}

uint64_t header_out_write_value(int *a1, uint64_t a2, int a3, int a4)
{
  unsigned int v4;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char v12;
  uint64_t result;

  v4 = *(_DWORD *)(a2 + 92) + a3;
  *(_DWORD *)(a2 + 92) = v4;
  if (!a4)
    return 0;
  v7 = (_QWORD *)(a2 + 80);
  v8 = *(_QWORD *)(a2 + 80);
  v9 = *a1;
  if ((*a1 & 1) != 0)
  {
    v10 = *(_DWORD *)(v8 + 20);
    if (v4 + v10 + 2 > *(unsigned __int16 *)(v8 + 26))
    {
      v11 = (*(uint64_t (**)(_QWORD, _QWORD))(*((_QWORD *)a1 + 5) + 8))(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 80));
      *(_QWORD *)(a2 + 80) = v11;
      if (!v11)
        return 0xFFFFFFFFLL;
      v8 = v11;
      v10 = *(_DWORD *)(v11 + 20);
      v4 = *(_DWORD *)(a2 + 92);
    }
    *(_WORD *)(*(_QWORD *)v8 + v10 + v4) = 2573;
    LOWORD(v4) = *(_WORD *)(a2 + 92);
    v9 = *a1;
  }
  *(_WORD *)(v8 + 26) = v4;
  if ((v9 & 2) != 0)
  {
    v12 = *(_BYTE *)(v8 + 33);
    if ((v12 & 8) == 0)
      __assert_rtn("header_out_write_value", "lsqpack.c", 3266, "xhdr->flags & LSXPACK_NAME_HASH");
    *(_DWORD *)(v8 + 12) = XXH_INLINE_XXH32((int *)(*(_QWORD *)v8 + *(int *)(v8 + 20)), (unsigned __int16)v4, *(_DWORD *)(v8 + 8));
    *(_BYTE *)(v8 + 33) = v12 | 0x10;
  }
  result = (*(uint64_t (**)(_QWORD, uint64_t))(*((_QWORD *)a1 + 5) + 16))(*(_QWORD *)(a2 + 32), v8);
  if ((_DWORD)result)
    result = 0xFFFFFFFFLL;
  else
    a1[7] += *(unsigned __int16 *)(v8 + 26) + *(unsigned __int16 *)(v8 + 24);
  ++*(_DWORD *)(a2 + 72);
  *v7 = 0;
  v7[1] = 0;
  return result;
}

uint64_t guarantee_out_bytes(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4;
  int v5;
  int v6;
  BOOL v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;

  v4 = *(_QWORD *)(a2 + 80);
  if (!v4)
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3332, "read_ctx->hbrc_out.xhdr");
  if (*(_DWORD *)(a2 + 88) != 1)
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3333, "read_ctx->hbrc_out.state == XOUT_VALUE");
  v6 = *(_DWORD *)(v4 + 16);
  v5 = *(_DWORD *)(v4 + 20);
  v7 = __OFSUB__(v5, v6);
  v8 = v5 - v6;
  if (v8 < 0 != v7)
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3335, "read_ctx->hbrc_out.xhdr->val_offset >= read_ctx->hbrc_out.xhdr->name_offset");
  v9 = *(_DWORD *)(a2 + 92) + v8;
  v10 = *(unsigned __int16 *)(v4 + 26);
  v11 = v10 >= v9;
  v12 = v10 - v9;
  if (!v11)
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3339, "read_ctx->hbrc_out.xhdr->val_len >= off");
  if (v12 >= a3)
    return 0;
  v13 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 40) + 8))(*(_QWORD *)(a2 + 32));
  *(_QWORD *)(a2 + 80) = v13;
  if (v13)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t header_out_write_name(int *a1, uint64_t a2, int a3, int a4)
{
  unint64_t v4;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  int *v11;
  unint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t result;
  int v24;
  unint64_t v25;
  int v26;
  unint64_t v27;
  unsigned int v28;

  LODWORD(v4) = *(_DWORD *)(a2 + 92) + a3;
  *(_DWORD *)(a2 + 92) = v4;
  if (!a4)
    return 0;
  v7 = *(_QWORD *)(a2 + 80);
  v8 = *a1;
  if ((*a1 & 1) != 0)
  {
    if ((int)v4 + 2 > *(unsigned __int16 *)(v7 + 26))
    {
      v10 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)a1 + 5) + 8))(*(_QWORD *)(a2 + 32));
      *(_QWORD *)(a2 + 80) = v10;
      if (!v10)
        return 0xFFFFFFFFLL;
      v7 = v10;
      LODWORD(v4) = *(_DWORD *)(a2 + 92);
    }
    *(_WORD *)(*(_QWORD *)v7 + *(int *)(v7 + 16) + v4) = 8250;
    v9 = *(_DWORD *)(v7 + 16);
    LODWORD(v4) = *(_DWORD *)(a2 + 92);
    *(_DWORD *)(v7 + 20) = (unsigned __int16)(v9 + v4 + 2);
    v8 = *a1;
  }
  else
  {
    v9 = *(_DWORD *)(v7 + 16);
    *(_DWORD *)(v7 + 20) = (unsigned __int16)(v9 + v4);
  }
  *(_WORD *)(v7 + 24) = v4;
  *(_QWORD *)(a2 + 88) = 1;
  if ((v8 & 6) == 0)
    return 0;
  if (*(_QWORD *)v7)
  {
    v11 = (int *)(*(_QWORD *)v7 + v9);
    v4 = (unsigned __int16)v4;
    if ((unsigned __int16)v4 < 0x10u)
    {
      v22 = (unsigned __int16)v4 + 414139866;
    }
    else
    {
      v12 = (unint64_t)v11 + (unsigned __int16)v4 - 15;
      v13 = 1679910008;
      v14 = 39378473;
      v15 = -2008766304;
      v16 = 645669457;
      do
      {
        HIDWORD(v17) = v16 - 2048144777 * *v11;
        LODWORD(v17) = HIDWORD(v17);
        v16 = -1640531535 * (v17 >> 19);
        HIDWORD(v17) = v15 - 2048144777 * v11[1];
        LODWORD(v17) = HIDWORD(v17);
        v15 = -1640531535 * (v17 >> 19);
        HIDWORD(v17) = v14 - 2048144777 * v11[2];
        LODWORD(v17) = HIDWORD(v17);
        v14 = -1640531535 * (v17 >> 19);
        HIDWORD(v17) = v13 - 2048144777 * v11[3];
        LODWORD(v17) = HIDWORD(v17);
        v13 = -1640531535 * (v17 >> 19);
        v11 += 4;
      }
      while ((unint64_t)v11 < v12);
      HIDWORD(v19) = v16;
      LODWORD(v19) = v16;
      v18 = v19 >> 31;
      HIDWORD(v19) = v15;
      LODWORD(v19) = v15;
      v20 = v19 >> 25;
      HIDWORD(v19) = v14;
      LODWORD(v19) = v14;
      v21 = v19 >> 20;
      HIDWORD(v19) = v13;
      LODWORD(v19) = v13;
      v22 = v18 + (unsigned __int16)v4 + v20 + v21 + (v19 >> 14);
      v4 &= 0xFu;
    }
    if (v4 >= 4)
    {
      do
      {
        v24 = *v11++;
        HIDWORD(v25) = v22 - 1028477379 * v24;
        LODWORD(v25) = HIDWORD(v25);
        v22 = 668265263 * (v25 >> 15);
        v4 -= 4;
      }
      while (v4 > 3);
    }
    for (; v4; --v4)
    {
      v26 = *(unsigned __int8 *)v11;
      v11 = (int *)((char *)v11 + 1);
      HIDWORD(v27) = v22 + 374761393 * v26;
      LODWORD(v27) = HIDWORD(v27);
      v22 = -1640531535 * (v27 >> 21);
    }
  }
  else
  {
    v22 = 414139866;
  }
  result = 0;
  v28 = (-2048144777 * (v22 ^ (v22 >> 15))) ^ ((-2048144777 * (v22 ^ (v22 >> 15))) >> 13);
  *(_DWORD *)(v7 + 8) = (-1028477379 * v28) ^ ((-1028477379 * v28) >> 16);
  *(_BYTE *)(v7 + 33) |= 8u;
  return result;
}

void ___ZN11HTTP3Framer10_readFrameEmPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_13CFStreamErrorE_block_invoke(_QWORD *a1, __int128 *a2, void *a3, int a4, uint64_t a5, uint64_t a6)
{
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  dispatch_data_t concat;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  dispatch_data_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;

  v11 = a3;
  if (v11)
  {
    v12 = a1[6];
    v13 = a1[4];
    if (dispatch_data_get_size(v13) >= a1[7])
      concat = v13;
    else
      concat = dispatch_data_create_concat(v13, v11);
    v18 = concat;
    if (a4)
    {
      v19 = a1[5];
      v21 = *((_QWORD *)a2 + 2);
      v20 = *a2;
      (*(void (**)(uint64_t, __int128 *, dispatch_data_t))(v19 + 16))(v19, &v20, v18);
    }
    else
    {
      HTTP3Framer::_readFrame(v12, a1[7], concat, a1[5]);
    }

  }
  else
  {
    v15 = a6;
    if ((_DWORD)a6)
      v16 = a5;
    else
      v16 = 4;
    v17 = a1[5];
    v23 = *((_QWORD *)a2 + 2);
    v22 = *a2;
    if (!(_DWORD)a6)
      v15 = 0xFFFFFFFFLL;
    (*(void (**)(uint64_t, __int128 *, _QWORD, uint64_t, unint64_t))(v17 + 16))(v17, &v22, 0, v16, v15 | a6 & 0xFFFFFFFF00000000);
  }

}

void sub_183F52910(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZN11HTTP3Framer9readFrameEmU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke(uint64_t a1, __int128 *a2, uint64_t a3)
{
  uint64_t v3;
  __int128 v5;
  uint64_t v6;

  *(_BYTE *)(*(_QWORD *)(a1 + 40) + 72) = 0;
  v3 = *(_QWORD *)(a1 + 32);
  v6 = *((_QWORD *)a2 + 2);
  v5 = *a2;
  return (*(uint64_t (**)(uint64_t, __int128 *, uint64_t))(v3 + 16))(v3, &v5, a3);
}

void sub_183F5311C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 - 96);
  _Unwind_Resume(a1);
}

void sub_183F53C3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  uint64_t v37;

  _Block_object_dispose(&a33, 8);
  _Block_object_dispose((const void *)(v37 - 208), 8);
  _Block_object_dispose(&a37, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTPTransaction22bodyStartProvidingDataEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  HTTPMessage *v3;
  const __CFString *v4;
  const __CFString *v5;
  int v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  HTTPConnection *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  CFStreamError v13;
  CFRange v14;

  v1 = *(_QWORD *)(result + 40);
  if (*(_DWORD *)(v1 + 80) != 3)
  {
    v2 = result;
    if ((*(_WORD *)(v1 + 32) & 0x20) == 0)
    {
      v3 = *(HTTPMessage **)(*(_QWORD *)(result + 48) + 160);
      if (!v3)
        __assert_rtn("_onqueue_requestIsChunkEncoded", "HTTPTransaction.cpp", 1773, "_request");
      v4 = HTTPMessage::copyHeaderFieldValue(v3, 0x146233E1u);
      if (!v4
        || (v5 = v4,
            v14.length = CFStringGetLength(v4),
            v14.location = 0,
            v6 = CFStringFindWithOptions(v5, (CFStringRef)&unk_1EDCFDBA0, v14, 1uLL, 0),
            CFRelease(v5),
            !v6))
      {
        v7 = *(std::__shared_weak_count **)(v1 + 64);
        if (!v7
          || (v8 = std::__shared_weak_count::lock(v7)) == 0
          || (v9 = v8, (v10 = *(HTTPConnection **)(v1 + 56)) == 0))
        {
          __assert_rtn("bodyStartProvidingData_block_invoke", "HTTPTransaction.cpp", 698, "strongConn");
        }
        v13.domain = 4;
        *(_QWORD *)&v13.error = 4294967292;
        HTTPConnection::_onqueue_doNotAllowMoreRequests(v10, v13, 0);
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v12 = __ldaxr(p_shared_owners);
        while (__stlxr(v12 - 1, p_shared_owners));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
    return (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 32) + 16))();
  }
  return result;
}

void sub_183F540E0(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP3Connection18_readEncoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2(uint64_t a1, void *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  id v10;
  NSObject *v11;
  HTTP3Connection *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t i;
  std::__shared_weak_count *v22;
  void **v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  unsigned int v26;
  BOOL v27;
  int v28;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void **v34[2];
  uint8_t buf[24];
  uint64_t v36;
  CFStreamError v37;

  v36 = *MEMORY[0x1E0C80C00];
  v10 = a2;
  v11 = a3;
  if (v11 && !(_DWORD)a6)
  {
    v12 = *(HTTP3Connection **)(a1 + 40);
    if (*((_QWORD *)v12 + 124))
    {
      HTTP3Connection::_stopStallRecovery(v12);
      v12 = *(HTTP3Connection **)(a1 + 40);
    }
    HTTP3Connection::_readEncoderStream((int)v12, v11);
    goto LABEL_36;
  }
  if (!(_DWORD)a6)
  {
    v13 = *(_QWORD *)(a1 + 40);
    if ((*(_BYTE *)(v13 + 920) & 4) == 0)
    {
      v14 = *(_QWORD *)(v13 + 1008);
      if (v14)
      {
        if ((*(uint64_t (**)(_QWORD))(*(_QWORD *)v14 + 120))(*(_QWORD *)(v13 + 1008)) != -1)
          goto LABEL_10;
        v13 = *(_QWORD *)(a1 + 40);
      }
      *(_QWORD *)(v13 + 1160) = 4;
      *(_DWORD *)(v13 + 1168) = -1;
      HTTP3Connection::_cleanupConnection((HTTP3Connection *)v13, 260, 0);
      HTTP3Connection::reportServerProtocolViolation(*(_QWORD *)(a1 + 40), 18, -1);
      CFN_LOG_h3connection();
      v15 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      {
        v32 = *(_QWORD *)(a1 + 40);
        v33 = *(_QWORD *)(v32 + 1216);
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v32;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v33;
        _os_log_fault_impl(&dword_183ECA000, v15, OS_LOG_TYPE_FAULT, "%p %llu Encoder stream closed but connection is alive", buf, 0x16u);
      }
      goto LABEL_35;
    }
  }
LABEL_10:
  v37.domain = a5;
  *(_QWORD *)&v37.error = a6;
  if (HTTP3Connection::checkAndPerformFallback(*(HTTP3Connection **)(a1 + 40), v37))
  {
    CFN_LOG_h3connection();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_QWORD *)(a1 + 40);
      v17 = *(_QWORD *)(v16 + 1216);
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v16;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v17;
      _os_log_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEFAULT, "%p %llu Encoder stream fallback triggered", buf, 0x16u);
    }
LABEL_35:

    goto LABEL_36;
  }
  v18 = *(_QWORD *)(a1 + 40);
  *(_BYTE *)(v18 + 920) |= 2u;
  if (*(_QWORD *)(v18 + 1136) == *(_QWORD *)(v18 + 1144))
    HTTP3Connection::_cleanupConnection((HTTP3Connection *)v18, 256, 0);
  v19 = *(_QWORD *)(a1 + 40);
  memset(buf, 0, sizeof(buf));
  std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(buf, *(_QWORD **)(v19 + 1136), *(_QWORD **)(v19 + 1144), (uint64_t)(*(_QWORD *)(v19 + 1144) - *(_QWORD *)(v19 + 1136)) >> 4);
  v20 = *(_QWORD *)buf;
  for (i = *(_QWORD *)&buf[8]; v20 != i; v20 += 16)
  {
    v23 = *(void ***)v20;
    v22 = *(std::__shared_weak_count **)(v20 + 8);
    v34[0] = *(void ***)v20;
    v34[1] = (void **)&v22->__vftable;
    if (v22)
    {
      p_shared_owners = (unint64_t *)&v22->__shared_owners_;
      do
        v25 = __ldxr(p_shared_owners);
      while (__stxr(v25 + 1, p_shared_owners));
    }
    v26 = *((_DWORD *)v23 + 29);
    v27 = v26 > 8;
    v28 = (1 << v26) & 0x124;
    if (!v27 && v28 != 0)
    {
      HTTP3Stream::_cleanupStream((uint64_t)v23, -1, 0);
      v23[33] = (void *)4;
      *((_DWORD *)v23 + 68) = -4;
      HTTP3Stream::_protocolCallback((HTTP3Stream *)v23);
    }
    if (v22)
    {
      v30 = (unint64_t *)&v22->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
  }
  v34[0] = (void **)buf;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](v34);
LABEL_36:

}

void sub_183F54420(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZN11HTTP3Framer5_readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke(uint64_t a1, void *a2, void *a3, int a4, uint64_t a5, uint64_t a6)
{
  id v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  size_t size;
  size_t v16;
  size_t v17;
  dispatch_data_t subrange;
  dispatch_data_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;

  v11 = a2;
  v12 = a3;
  v13 = v12;
  v14 = *(_QWORD *)(a1 + 40);
  if ((_DWORD)a6)
  {
    *(_QWORD *)(v14 + 144) = a5;
    *(_QWORD *)(v14 + 152) = a6;
  }
  else if (a4)
  {
    *(_QWORD *)(v14 + 144) = 4;
    *(_DWORD *)(v14 + 152) = -2300;
  }
  if (v12)
  {
    size = dispatch_data_get_size(v12);
    v16 = *(_QWORD *)(v14 + 104);
    if (v16 <= size)
    {
      if (v16 == size)
      {
        subrange = v13;
      }
      else
      {
        v17 = size;
        subrange = dispatch_data_create_subrange(v13, 0, v16);
        v19 = dispatch_data_create_subrange(v13, *(_QWORD *)(v14 + 104), v17 - *(_QWORD *)(v14 + 104));
        v20 = *(void **)(v14 + 136);
        *(_QWORD *)(v14 + 136) = v19;

      }
      v21 = 0;
      v22 = 0;
      *(_QWORD *)(v14 + 104) = 0;
      *(_DWORD *)(v14 + 76) = 0;
      v23 = *(_QWORD *)(a1 + 32);
      v24 = *(_OWORD *)(v14 + 80);
      v25 = *(_QWORD *)(v14 + 96);
      if (!*(_QWORD *)(v14 + 136))
      {
        v22 = *(_QWORD *)(v14 + 144);
        v21 = *(_QWORD *)(v14 + 152);
      }
      (*(void (**)(uint64_t, __int128 *, dispatch_data_t, uint64_t, uint64_t, uint64_t))(v23 + 16))(v23, &v24, subrange, 1, v22, v21);

    }
    else
    {
      *(_QWORD *)(v14 + 104) = v16 - size;
      (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    }
  }
  else
  {
    if (!*(_DWORD *)(v14 + 152))
    {
      *(_QWORD *)(v14 + 144) = 4;
      *(_DWORD *)(v14 + 152) = -1;
    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }

}

void sub_183F54604(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZN10HTTPEngine16_writeBodyResumeEv_block_invoke(uint64_t a1, dispatch_data_t data, CFStreamError a3, int a4)
{
  uint64_t v4;
  int v5;
  std::__shared_weak_count *v7;
  CFIndex domain;
  NSObject *subrange;
  uint64_t v11;
  size_t size;
  int64_t v13;
  size_t v14;
  int v15;
  NSObject *v16;
  NSObject *concat;
  NSObject *v18;
  std::__shared_weak_count *v19;
  size_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  CFIndex v23;
  std::__shared_weak_count *v24;
  size_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  size_t v28;
  uint64_t v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  uint64_t v32;
  int v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  std::__shared_weak_count *v54;
  std::__shared_weak_count *v55;
  std::__shared_weak_count *v56;
  char __str[8];
  uint64_t v58;
  void (*v59)(uint64_t, CFIndex, uint64_t);
  void *v60;
  uint64_t v61;
  size_t v62;
  std::__shared_weak_count *v63;
  size_t v64;
  CFIndex v65;
  std::__shared_weak_count *v66;
  char v67;
  uint64_t v68;
  CFStreamError v69;
  CFStreamError v70;

  v68 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  if (!*(_QWORD *)(v4 + 56) || (v5 = *(_DWORD *)(v4 + 32), (v5 & 1) != 0))
  {
    if (!*(_QWORD *)(v4 + 96) && !*(_DWORD *)(v4 + 104))
      *(_OWORD *)(v4 + 96) = xmmword_1841E3960;
    HTTPEngine::_cleanupConnection((HTTPEngine *)v4, 0);
  }
  else
  {
    v7 = *(std::__shared_weak_count **)&a3.error;
    domain = a3.domain;
    subrange = data;
    if (data)
    {
      -[__CFN_TransactionMetrics requestBody:](*(_QWORD *)(v4 + 336), data);
      v5 = *(_DWORD *)(v4 + 32);
    }
    v11 = *(_QWORD *)(a1 + 40);
    if ((v5 & 0x8000000) == 0)
    {
      if ((*(_BYTE *)(v11 + 35) & 0x10) != 0)
      {
        if (subrange)
        {
          size = dispatch_data_get_size(subrange);
          if (size)
          {
            v13 = *(_QWORD *)(v11 + 288) - *(_QWORD *)(v11 + 296);
            if (v13 >= 1)
            {
              if (size <= v13)
                dispatch_retain(subrange);
              else
                subrange = dispatch_data_create_subrange(subrange, 0, v13);
              ++*(_QWORD *)(v11 + 272);
              v24 = (std::__shared_weak_count *)operator new();
              v24->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1C18;
              v24->__shared_owners_ = 0;
              v24->__shared_weak_owners_ = 0;
              v24[1].__vftable = (std::__shared_weak_count_vtbl *)subrange;
              v56 = v24;
              v25 = dispatch_data_get_size(subrange);
              *(_QWORD *)(v11 + 280) += v25;
              HTTPEngine::_updateBytesTransferred((HTTPEngine *)v11);
              v26 = *(_QWORD *)(v11 + 336);
              if (v26)
                *(_QWORD *)(v26 + 112) += v25;
              v54 = 0;
              v27 = *(std::__shared_weak_count **)(v11 + 48);
              if (v27 && (v27 = std::__shared_weak_count::lock(v27), (v54 = v27) != 0))
                v28 = *(_QWORD *)(v11 + 40);
              else
                v28 = 0;
              v29 = *(_QWORD *)(v11 + 56);
              *(_QWORD *)__str = MEMORY[0x1E0C809B0];
              v58 = 3321888768;
              v59 = ___ZN10HTTPEngine15_writeBodyPlainEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke;
              v60 = &__block_descriptor_81_e8_40c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e13_v24__0___qi_8l;
              v61 = v11;
              v62 = v28;
              v63 = v27;
              if (v27)
              {
                p_shared_owners = (unint64_t *)&v27->__shared_owners_;
                do
                  v31 = __ldxr(p_shared_owners);
                while (__stxr(v31 + 1, p_shared_owners));
              }
              v64 = v25;
              v65 = domain;
              v66 = v7;
              v67 = a4;
              (*(void (**)(uint64_t, NSObject *, char *))(*(_QWORD *)v29 + 48))(v29, subrange, __str);
              if (*(uint64_t *)(v11 + 272) >= 2)
              {
                v32 = *(_QWORD *)(v11 + 256);
                if (v32)
                {
                  v33 = *(_DWORD *)(v11 + 32);
                  if ((v33 & 0x10000000) != 0)
                  {
                    *(_DWORD *)(v11 + 32) = v33 & 0xEFFFFFFF;
                    (*(void (**)(uint64_t))(*(_QWORD *)v32 + 24))(v32);
                  }
                }
              }
              v34 = v63;
              if (v63)
              {
                v35 = (unint64_t *)&v63->__shared_owners_;
                do
                  v36 = __ldaxr(v35);
                while (__stlxr(v36 - 1, v35));
                if (!v36)
                {
                  ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
                  std::__shared_weak_count::__release_weak(v34);
                }
              }
              if (v54)
              {
                v37 = (unint64_t *)&v54->__shared_owners_;
                do
                  v38 = __ldaxr(v37);
                while (__stlxr(v38 - 1, v37));
                if (!v38)
                {
                  ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
                  std::__shared_weak_count::__release_weak(v54);
                }
              }
              if (v56)
              {
                v39 = (unint64_t *)&v56->__shared_owners_;
                do
                  v40 = __ldaxr(v39);
                while (__stlxr(v40 - 1, v39));
                if (!v40)
                {
                  ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
                  std::__shared_weak_count::__release_weak(v56);
                }
              }
              return;
            }
          }
        }
LABEL_33:
        v69.domain = domain;
        *(_QWORD *)&v69.error = v7;
        HTTPEngine::_writeBodyFinish((HTTPEngine *)v11, v69);
        return;
      }
LABEL_90:
      abort();
    }
    if ((*(_BYTE *)(v11 + 35) & 0x10) == 0)
      goto LABEL_90;
    if (!subrange || (v14 = dispatch_data_get_size(subrange)) == 0)
    {
      if (a4 && !(_DWORD)v7)
      {
        HTTPEngine::_chunkedWriteTrailer((HTTPEngine *)v11);
        return;
      }
      goto LABEL_33;
    }
    v15 = snprintf(__str, 0x15uLL, "%x\r\n", v14);
    if (v15 <= 0)
      goto LABEL_34;
    v16 = dispatch_data_create(__str, v15, 0, 0);
    if (_enchunkulate(NSObject  {objcproto16OS_dispatch_data}*)::sOnce != -1)
      dispatch_once(&_enchunkulate(NSObject  {objcproto16OS_dispatch_data}*)::sOnce, &__block_literal_global_15822);
    concat = dispatch_data_create_concat(v16, subrange);
    dispatch_release(v16);
    v18 = dispatch_data_create_concat(concat, (dispatch_data_t)_enchunkulate(NSObject  {objcproto16OS_dispatch_data}*)::chunkTrailer);
    dispatch_release(concat);
    if (v18)
    {
      if (!dispatch_data_get_size(v18))
        __assert_rtn("_chunkedWriteHeaderAndBody", "HTTPEngine.cpp", 2930, "dispatch_data_get_size(data) > 0");
      ++*(_QWORD *)(v11 + 272);
      dispatch_retain(v18);
      v19 = (std::__shared_weak_count *)operator new();
      v19->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1C50;
      v19->__shared_owners_ = 0;
      v19->__shared_weak_owners_ = 0;
      v19[1].__vftable = (std::__shared_weak_count_vtbl *)v18;
      v55 = v19;
      v20 = dispatch_data_get_size(v18);
      *(_QWORD *)(v11 + 280) += v20;
      HTTPEngine::_updateBytesTransferred((HTTPEngine *)v11);
      v21 = *(_QWORD *)(v11 + 328);
      if (v21)
        *(_QWORD *)(v21 + 112) += v20;
      v53 = 0;
      v22 = *(std::__shared_weak_count **)(v11 + 48);
      if (v22 && (v22 = std::__shared_weak_count::lock(v22), (v53 = v22) != 0))
        v23 = *(_QWORD *)(v11 + 40);
      else
        v23 = 0;
      v41 = *(_QWORD *)(v11 + 56);
      *(_QWORD *)__str = MEMORY[0x1E0C809B0];
      v58 = 3321888768;
      v59 = ___ZN10HTTPEngine26_chunkedWriteHeaderAndBodyEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke;
      v60 = &__block_descriptor_81_e8_64c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e13_v24__0___qi_8l;
      v61 = v11;
      v62 = v20;
      v63 = (std::__shared_weak_count *)domain;
      v64 = (size_t)v7;
      v67 = a4;
      v65 = v23;
      v66 = v22;
      if (v22)
      {
        v42 = (unint64_t *)&v22->__shared_owners_;
        do
          v43 = __ldxr(v42);
        while (__stxr(v43 + 1, v42));
      }
      (*(void (**)(uint64_t, NSObject *, char *))(*(_QWORD *)v41 + 48))(v41, v18, __str);
      if (*(uint64_t *)(v11 + 272) >= 2)
      {
        v44 = *(_QWORD *)(v11 + 256);
        if (v44)
        {
          v45 = *(_DWORD *)(v11 + 32);
          if ((v45 & 0x10000000) != 0)
          {
            *(_DWORD *)(v11 + 32) = v45 & 0xEFFFFFFF;
            (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
          }
        }
      }
      v46 = v66;
      if (v66)
      {
        v47 = (unint64_t *)&v66->__shared_owners_;
        do
          v48 = __ldaxr(v47);
        while (__stlxr(v48 - 1, v47));
        if (!v48)
        {
          ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
          std::__shared_weak_count::__release_weak(v46);
        }
      }
      if (v53)
      {
        v49 = (unint64_t *)&v53->__shared_owners_;
        do
          v50 = __ldaxr(v49);
        while (__stlxr(v50 - 1, v49));
        if (!v50)
        {
          ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
          std::__shared_weak_count::__release_weak(v53);
        }
      }
      if (v55)
      {
        v51 = (unint64_t *)&v55->__shared_owners_;
        do
          v52 = __ldaxr(v51);
        while (__stlxr(v52 - 1, v51));
        if (!v52)
        {
          ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
          std::__shared_weak_count::__release_weak(v55);
        }
      }
      dispatch_release(v18);
    }
    else
    {
LABEL_34:
      v70.domain = 4;
      *(_QWORD *)&v70.error = 303;
      HTTPEngine::_writeBodyFinish((HTTPEngine *)v11, v70);
    }
  }
}

void sub_183F54CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va2;

  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ___ZN10HTTPEngine15_writeBodyPlainEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke(uint64_t a1, CFIndex a2, uint64_t a3)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  CFStreamError v9;

  v6 = *(uint64_t **)(a1 + 32);
  --*(_QWORD *)(*(_QWORD *)(a1 + 40) + 272);
  v7 = *(_QWORD *)(a1 + 56);
  if ((_DWORD)a3)
  {
    v6[35] -= v7;
    HTTPEngine::_updateBytesTransferred((HTTPEngine *)v6);
    v8 = v6[42];
    if (v8)
      *(_QWORD *)(v8 + 112) -= *(_QWORD *)(a1 + 56);
  }
  else
  {
    v6[37] += v7;
  }
  if (*(_QWORD *)(a1 + 72))
    v9.domain = *(_QWORD *)(a1 + 64);
  else
    v9.domain = a2;
  if (*(_QWORD *)(a1 + 72))
    *(_QWORD *)&v9.error = *(_QWORD *)(a1 + 72);
  else
    *(_QWORD *)&v9.error = a3;
  if (v9.error || *(_BYTE *)(a1 + 80))
  {
    HTTPEngine::_writeBodyFinish((HTTPEngine *)v6, v9);
  }
  else if (v6[34] <= 1)
  {
    HTTPEngine::_writeBodyResume((HTTPEngine *)v6);
  }
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_dispatch_data}*,HTTPEngine::_writeBodyPlain(NSObject  {objcproto16OS_dispatch_data}*,CFStreamError,BOOL)::$_0,std::allocator<NSObject  {objcproto16OS_dispatch_data}>>::__on_zero_shared(uint64_t a1)
{
  NSObject *v1;

  v1 = *(NSObject **)(a1 + 24);
  if (v1)
    dispatch_release(v1);
}

uint64_t MemoryCookieStorage::getCookieAcceptPolicyLocked(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a2 + 16))(a2, *(unsigned int *)(a1 + 80));
}

uint64_t MemoryCookieStorage::setCookieInternalLocked(const HTTPCookieStoragePolicy **this, CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3, const MemoryCookies *a4)
{
  uint64_t result;

  result = PrivateHTTPCookieStorage::allowCookieToBeWrittenConsideringHTTPOnly((PrivateHTTPCookieStorage *)a2, (const CompactCookieHeader *)*((unsigned int *)a3 + 18), this[9], a4);
  if ((_DWORD)result)
    return MemoryCookies::setCookie((CompactCookieArray **)this[9], a2);
  return result;
}

void RunLoopMultiplexer::schedule(uint64_t a1, const void *a2, const void *a3)
{
  os_unfair_lock_s *v6;
  uint64_t Value;
  const __CFAllocator *v8;
  CFStringRef (__cdecl *v9)(const void *);
  CFIndex v10;
  CFRunLoopSourceContext v11;

  v6 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
  Value = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (!Value)
  {
    Value = operator new();
    v8 = *(const __CFAllocator **)(a1 + 32);
    *(_DWORD *)(Value + 8) = 0;
    *(_QWORD *)Value = &off_1E14E9018;
    *(CFAbsoluteTime *)(Value + 16) = CFAbsoluteTimeGetCurrent();
    *(_QWORD *)(Value + 88) = a1;
    *(_QWORD *)(Value + 80) = CFSetCreateMutable(v8, 0, &MultiplexerSource::sClientSetContext);
    *(_QWORD *)(Value + 64) = CFSetCreateMutable(v8, 0, &MultiplexerSource::sClientSetContext);
    *(_QWORD *)(Value + 72) = CFArrayCreateMutable(v8, 0, &MultiplexerSource::sClientArrayContext);
    *(_WORD *)(Value + 24) = 0;
    *(_QWORD *)(Value + 32) = 0;
    *(_QWORD *)(Value + 40) = 0;
    *(_QWORD *)(Value + 48) = 1;
    v11.version = 0;
    v11.info = (void *)Value;
    v11.retain = (const void *(__cdecl *)(const void *))MultiplexerSource::Retain;
    v11.release = (void (__cdecl *)(const void *))MultiplexerSource::Release;
    v11.copyDescription = (CFStringRef (__cdecl *)(const void *))MultiplexerSource::_copyDesc;
    memset(&v11.equal, 0, 32);
    v11.perform = (void (__cdecl *)(void *))MultiplexerSource::_perform;
    v9 = (CFStringRef (__cdecl *)(const void *))CFRunLoopSourceCreate(v8, 0, &v11);
    v10 = MEMORY[0x1E0C809B0];
    *(_QWORD *)(Value + 56) = v9;
    v11.version = v10;
    v11.info = (void *)3221225472;
    v11.retain = (const void *(__cdecl *)(const void *))___ZN18RunLoopMultiplexer19sourceForSchedulingEPK17CoreSchedulingSeth_block_invoke;
    v11.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
    v11.copyDescription = v9;
    CoreSchedulingSet::applyBlock((uint64_t)a2, &v11);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, (const void *)Value);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(Value + 8));
  CFSetAddValue(*(CFMutableSetRef *)(Value + 80), a3);
  os_unfair_lock_unlock((os_unfair_lock_t)(Value + 8));
  os_unfair_lock_unlock(v6);
}

void sub_183F55118(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  MEMORY[0x186DB748C](v1, 0x10A1C400F30E120);
  _Unwind_Resume(a1);
}

void RequestBodyStream::bodyStopProvidingData(RequestBodyStream *this)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD block[5];
  _QWORD v4[6];

  v1 = *((_QWORD *)this + 10);
  if (!v1)
    __assert_rtn("bodyStopProvidingData", "HTTPRequestBody.cpp", 465, "_cb");
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x3052000000;
  v4[3] = __Block_byref_object_copy__13669;
  v4[4] = __Block_byref_object_dispose__13670;
  v4[5] = v1;
  *((_QWORD *)this + 10) = 0;
  v2 = *((_QWORD *)this + 6);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN17RequestBodyStream21bodyStopProvidingDataEv_block_invoke;
  block[3] = &unk_1E14FD3D8;
  block[4] = v4;
  dispatch_async(v2, block);
  _Block_object_dispose(v4, 8);
}

uint64_t HTTPTransaction::bodyStopProvidingData(HTTPTransaction *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void HTTP3Connection::_settingsReceived(HTTP3Connection *this)
{
  unsigned int v2;
  unint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  FILE *v7;
  size_t v8;
  unsigned int v9;
  void *v10;
  char *v11;
  int v12;
  uint64_t v13;
  __int128 v14;
  double *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  dispatch_data_t v20;
  _BYTE buffer[6];
  uint64_t v22;

  v2 = *((_DWORD *)this + 236);
  if (v2 >= 0x10000)
    v3 = 0x10000;
  else
    v3 = v2;
  *((_QWORD *)this + 118) = v3;
  if (*((_QWORD *)this + 119) >= 0x64uLL)
    v4 = 100;
  else
    v4 = *((_QWORD *)this + 119);
  *((_QWORD *)this + 119) = v4;
  if ((_DWORD)v3)
  {
    buffer[0] = 32;
    v5 = lsqpack_enc_int(buffer, (unint64_t)&v22, v3, 5);
    if (v5 <= buffer)
    {
      *__error() = 55;
      v8 = 6;
      goto LABEL_25;
    }
    v6 = v5;
    v7 = (FILE *)*((_QWORD *)this + 29);
    if (v7)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
      v8 = v6 - buffer;
      fprintf(*((FILE **)this + 29), "generated TSU=%u instruction %zd byte%.*s in size", v3, v8, v8 != 1, "s");
      fputc(10, *((FILE **)this + 29));
    }
    else
    {
      v8 = v5 - buffer;
    }
  }
  else
  {
    v8 = 0;
  }
  v9 = v3 / 0x60;
  if (v3 <= 0x4DF)
    v9 = 12;
  *((_DWORD *)this + 65) = v9;
  v10 = malloc_type_malloc(8 * v9 + 8, 0x100004000313F17uLL);
  *((_QWORD *)this + 31) = v10;
  if (!v10)
  {
LABEL_24:
    if (!v8)
      return;
    goto LABEL_25;
  }
  if (v2 < 0x20)
  {
    v11 = 0;
    v12 = 0;
LABEL_23:
    *((_DWORD *)this + 14) = v2;
    *((_DWORD *)this + 15) = v2 >> 5;
    *((_DWORD *)this + 13) = v3;
    *((_DWORD *)this + 17) = v4;
    *((_QWORD *)this + 13) = v11;
    *((_DWORD *)this + 21) = v12;
    *((_QWORD *)this + 29) = 0;
    *((_DWORD *)this + 11) |= 2u;
    goto LABEL_24;
  }
  v11 = (char *)malloc_type_malloc(0x80uLL, 0xA004088793A40uLL);
  if (v11)
  {
    v13 = 0;
    v14 = 0uLL;
    do
    {
      v15 = (double *)&v11[v13];
      v16 = (uint64_t)&v11[v13 + 32];
      v17 = (uint64_t)&v11[v13 + 16];
      v18 = (uint64_t)&v11[v13 + 48];
      v19 = 0uLL;
      vst4q_f64(v15, *(float64x2x4_t *)&v14);
      v13 += 64;
    }
    while (v13 != 128);
    v12 = 2;
    goto LABEL_23;
  }
  free(*((void **)this + 31));
  if (!v8)
    return;
LABEL_25:
  v20 = dispatch_data_create(buffer, v8, 0, 0);
  HTTP3Connection::writeEncoderStream((uint64_t)this, v20);

}

void sub_183F55440(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL HTTP3Framer::setReadHandleBeforeReading(uint64_t a1, void *a2, void *a3, int a4)
{
  id v8;
  id v9;
  uint64_t v10;

  v8 = a2;
  v9 = a3;
  v10 = *(_QWORD *)(a1 + 48);
  if (!v10)
  {
    objc_storeStrong((id *)(a1 + 48), a2);
    objc_storeStrong((id *)(a1 + 136), a3);
    if (a4)
    {
      *(_QWORD *)(a1 + 144) = 4;
      *(_DWORD *)(a1 + 152) = -2300;
    }
  }

  return v10 == 0;
}

void HTTPEngine::_writeBodyResume(HTTPEngine *this)
{
  int v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[6];
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  if (*((_QWORD *)this + 32))
  {
    v2 = *((_DWORD *)this + 8);
    if ((v2 & 0x10000000) == 0)
    {
      *((_DWORD *)this + 8) = v2 | 0x10000000;
      v16 = 0;
      v17 = 0;
      v3 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
      if (v3 && (v3 = std::__shared_weak_count::lock(v3), (v17 = v3) != 0))
      {
        v4 = *((_QWORD *)this + 5);
        v16 = v4;
      }
      else
      {
        v4 = 0;
      }
      v5 = *((_QWORD *)this + 32);
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 3321888768;
      v14[2] = ___ZN10HTTPEngine16_writeBodyResumeEv_block_invoke;
      v14[3] = &__block_descriptor_56_e8_40c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
      v14[4] = this;
      v14[5] = v4;
      v15 = v3;
      if (v3)
      {
        p_shared_owners = (unint64_t *)&v3->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
      }
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v5 + 16))(v5, v14);
      v8 = v15;
      if (v15)
      {
        v9 = (unint64_t *)&v15->__shared_owners_;
        do
          v10 = __ldaxr(v9);
        while (__stlxr(v10 - 1, v9));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
      v11 = v17;
      if (v17)
      {
        v12 = (unint64_t *)&v17->__shared_owners_;
        do
          v13 = __ldaxr(v12);
        while (__stlxr(v13 - 1, v12));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
    }
  }
}

void sub_183F55628(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

void HTTPTransaction::bodyStartProvidingData(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  _QWORD v21[7];
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;

  if (*(_QWORD *)(a1 + 192))
  {
    if (*(int *)(a1 + 80) <= 4)
      *(_DWORD *)(a1 + 80) = 5;
    v25 = 0;
    v26 = 0;
    v4 = *(std::__shared_weak_count **)(a1 + 48);
    if (v4 && (v4 = std::__shared_weak_count::lock(v4), (v26 = v4) != 0))
    {
      v5 = *(_QWORD *)(a1 + 40);
      v25 = v5;
    }
    else
    {
      v5 = 0;
    }
    v6 = *(_QWORD *)(a1 + 192);
    v7 = *(std::__shared_weak_count **)(a1 + 200);
    v23 = v6;
    v24 = v7;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3321888768;
    v21[2] = ___ZN15HTTPTransaction22bodyStartProvidingDataEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke;
    v21[3] = &unk_1E14F3BA0;
    v21[5] = a1;
    v21[6] = v5;
    v22 = v4;
    if (v4)
    {
      v10 = (unint64_t *)&v4->__shared_owners_;
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    v21[4] = a2;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 16))(v6, v21);
    v12 = v22;
    if (v22)
    {
      v13 = (unint64_t *)&v22->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    v15 = v24;
    if (v24)
    {
      v16 = (unint64_t *)&v24->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v18 = v26;
    if (v26)
    {
      v19 = (unint64_t *)&v26->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }
}

void sub_183F557EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  uint64_t v10;
  va_list va;

  va_start(va, a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v10 - 48);
  _Unwind_Resume(a1);
}

void RequestBodyStream::bodyStartProvidingData(uint64_t a1, void *aBlock)
{
  if (*(_QWORD *)(a1 + 80))
    __assert_rtn("bodyStartProvidingData", "HTTPRequestBody.cpp", 445, "!_cb");
  *(_QWORD *)(a1 + 80) = _Block_copy(aBlock);
  if ((*(_BYTE *)(a1 + 192) & 1) != 0)
  {
    if ((*(_BYTE *)(a1 + 192) & 8) != 0)
      RequestBodyStream::_onqueue_resume((RequestBodyStream *)a1);
  }
  else
  {
    RequestBodyStream::_onqueue_setupStream((RequestBodyStream *)a1);
  }
}

void HTTPEngine::_writeBodyStart(HTTPEngine *this)
{
  int v2;
  CFStreamError v3;
  CFStreamError v4;

  if (!*((_QWORD *)this + 7) || (v2 = *((_DWORD *)this + 8), (v2 & 1) != 0))
  {
    v3.domain = 4;
    *(_QWORD *)&v3.error = 4294967292;
    goto LABEL_7;
  }
  if ((v2 & 0x1000000) != 0 && (v2 & 0x10) != 0)
  {
    v3.domain = 4;
    *(_QWORD *)&v3.error = 4294965201;
LABEL_7:
    HTTPEngine::_writeBodyFinish(this, v3);
    return;
  }
  if ((v2 & 0x800000) != 0)
  {
    if (!*((_QWORD *)this + 32))
    {
      v4.domain = 0;
      *(_QWORD *)&v4.error = 0;
      HTTPEngine::_writeBodyFinish(this, v4);
    }
    HTTPEngine::_writeBodyResume(this);
  }
  else
  {
    HTTPEngine::_writeHeadersStart(this);
  }
}

uint64_t FormContentLengthWithArray(const __CFArray *a1)
{
  CFIndex Count;
  CFAllocatorRef v3;
  const __CFAllocator *v4;
  CFIndex v5;
  uint64_t v6;
  const __CFString *ValueAtIndex;
  CFTypeID v8;
  CFTypeID v9;
  const __CFURL *v10;
  const __CFURL *v11;
  CFTypeID v12;
  stat v14;
  char v15;
  char v16[1035];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  Count = CFArrayGetCount(a1);
  v3 = CFGetAllocator(a1);
  if (Count >= 1)
  {
    v4 = v3;
    v5 = 0;
    v6 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, v5);
      v8 = CFGetTypeID(ValueAtIndex);
      if (v8 == CFDataGetTypeID())
      {
        v6 += CFDataGetLength((CFDataRef)ValueAtIndex);
      }
      else
      {
        v9 = CFGetTypeID(ValueAtIndex);
        if (v9 == CFStringGetTypeID())
        {
          v10 = CFURLCreateWithFileSystemPath(v4, ValueAtIndex, kCFURLPOSIXPathStyle, 0);
          if (v10)
          {
            v11 = v10;
            FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v15, v10, 0, 0, 0);
            if (v15 && !stat(v16, &v14) && v14.st_size != -1)
              v6 += v14.st_size;
            CFRelease(v11);
          }
        }
        else
        {
          v12 = CFGetTypeID(ValueAtIndex);
          if (v12 == CFReadStreamGetTypeID())
            return -1;
        }
      }
      if (Count == ++v5)
        return v6;
    }
  }
  return 0;
}

uint64_t HTTPProtocol::performHeaderRead(HTTPProtocol *this, __CFHTTPMessage *cf)
{
  CFHTTPMessageRef Response;
  uint64_t v4;
  int *v5;
  const __CFAllocator *v6;
  const __CFString *v7;
  CFStringRef v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  const __CFString *v12;
  int v13;
  BOOL v14;
  const __CFString *v15;
  const __CFString *v16;
  uint64_t v17;
  void *v18;
  _BOOL4 v19;
  HTTPMessage *v20;
  CFStringRef v21;
  uint64_t v22;
  int v23;
  int v24;
  const __CFURL *v25;
  void *v26;
  uint64_t v27;
  const __CFURL *v28;
  CFStringRef v29;
  CFStringRef v30;
  const __CFString *v31;
  NSObject *v32;
  const __CFURL *v33;
  const void *v34;
  CFTypeRef v35;
  int v36;
  CFIndex ResponseStatusCode;
  const __CFArray *v38;
  char *v39;
  _BYTE *v40;
  BOOL v41;
  NSURLSessionTask *v42;
  NSObject **KerberosAccountBroker;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  const __CFSet *v48;
  const __CFAllocator *v49;
  CFNumberRef v50;
  int v51;
  const void *v52;
  uint64_t CacheStoragePolicy;
  void (**v54)(StringSerializable *__hidden);
  _QWORD *v55;
  CFTypeRef v56;
  const __CFAllocator *v57;
  const __CFTimeZone *v58;
  CFAbsoluteTime Current;
  const __CFAllocator *v60;
  CFStringRef RFC1123DateStringWithGregorianDate;
  uint64_t v62;
  void *v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  __int16 v69;
  void *v71;
  HTTPMessage *v72;
  const __CFString *HeaderFieldValue;
  const __CFString *v74;
  BOOL v75;
  os_unfair_lock_s *v76;
  CFDictionaryRef *v77;
  int v78;
  CFDictionaryRef *v79;
  CFStringRef v80;
  int v81;
  CFIndex v82;
  int HasCredentialsForChallenge;
  AuthenticationState *v84;
  HTTPResponseMessage *v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  const _CFCachedURLResponse *v90;
  uint64_t v91;
  const __CFDictionary *v92;
  const __CFNumber *Value;
  const __CFAllocator *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  __CFError *CFError;
  const __CFDictionary *v101;
  const __CFAllocator *v102;
  const __CFAllocator *v103;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  const void *v106;
  std::__shared_weak_count *v107;
  unint64_t *p_shared_owners;
  void *v109;
  unint64_t v110;
  std::__shared_weak_count *v111;
  unint64_t *v112;
  unint64_t v113;
  unint64_t *v114;
  unint64_t v115;
  unint64_t *v116;
  unint64_t v117;
  std::__shared_weak_count *v118;
  unint64_t *v119;
  unint64_t v120;
  const void *v121;
  uint64_t v122;
  const char *v123;
  id v124;
  void *v125;
  void *v126;
  uint64_t v127;
  _BYTE *v128;
  const __CFDictionary *v129;
  const __CFAllocator *v130;
  CFHTTPMessageRef Copy;
  CFStringRef v132;
  HTTPMessage *v133;
  CFStringRef v134;
  const void *v135;
  uint64_t v136;
  id v137;
  uint64_t ExpectedContentLength;
  uint64_t v139;
  uint64_t v140;
  __CFString *MIMEType;
  CFAllocatorRef v142;
  uint64_t v143;
  uint64_t v144;
  const void *v145;
  int v146;
  const char *v147;
  uint64_t v148;
  const void *v149;
  const void **v150;
  unint64_t v151;
  const _CFURLCredential *v152;
  uint64_t v153;
  const char *v154;
  id Property;
  const char *v156;
  void *v157;
  CFAbsoluteTime *v158;
  uint64_t v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  const char *v163;
  const void *v164;
  uint64_t v165;
  uint64_t v166;
  void *v167;
  const void *v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  uint64_t v172;
  __CFError *v173;
  const __CFString *RegistrableDomain;
  const void *v175;
  __CFError *v176;
  id v177;
  const char *v178;
  void *v179;
  CFAbsoluteTime *v180;
  const __CFAllocator *v181;
  const __CFString *Domain;
  CFIndex Code;
  CFAbsoluteTime v184;
  const __CFAllocator *v185;
  CFStringRef RFC2616DateStringWithGregorianDate;
  uint64_t v187;
  id v188;
  _BOOL4 v189;
  const __CFAllocator *v190;
  CFDataRef v191;
  CFDataRef v192;
  const void *v193;
  void *v194;
  const char *v195;
  id v196;
  const char *v197;
  void *v198;
  CFAbsoluteTime *v199;
  uint64_t v200;
  const _CFCachedURLResponse *v201;
  const void *v202;
  uint64_t v203;
  uint64_t v204;
  void *v205;
  const char *v206;
  void *v207;
  CFAbsoluteTime *v208;
  CFTypeRef v209;
  const __CFString *v210;
  CFStringRef cfa;
  id cfb;
  std::__shared_weak_count *v213;
  void (**v214)(StringSerializable *__hidden);
  CFTypeRef v215;
  _BYTE valuePtr[24];
  const char *v217;
  __int128 v218;
  uint64_t v219;
  CFRange v220;

  Response = cf;
  v219 = *MEMORY[0x1E0C80C00];
  if (cf)
    CFRetain(cf);
  *((_DWORD *)this + 48) &= 0xFFFFFFE9;
  *((_BYTE *)this + 492) = 0;
  v4 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_137, 1);
  if (v4)
  {
    v5 = (int *)v4;
    if ((*(unsigned int (**)(uint64_t, const char *, HTTPProtocol *))(*(_QWORD *)v4 + 24))(v4, "Protocol Received", this))
    {
      v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (Response)
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        *(_QWORD *)valuePtr = &off_1E14E4818;
        *(_QWORD *)&valuePtr[16] = 0;
        v217 = 0;
        *(_QWORD *)&valuePtr[8] = CFStringCreateWithCString(v6, "Response", 0x8000100u);
        v7 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*((_QWORD *)Response + 2) + 32))((uint64_t)Response + 16);
        v8 = *(CFStringRef *)&valuePtr[8];
        v9 = (char *)Response + 16;
      }
      else
      {
        *(_QWORD *)valuePtr = &off_1E14E4818;
        v8 = CFStringCreateWithCString(v6, "Response", 0x8000100u);
        v9 = 0;
        *(_QWORD *)&valuePtr[16] = 0;
        v217 = 0;
        *(_QWORD *)&valuePtr[8] = v8;
        v7 = CFSTR("null");
      }
      (*(void (**)(int *, CFStringRef, const __CFString *))(*(_QWORD *)v5 + 64))(v5, v8, v7);
      if (v9 && v7)
        CFRelease(v7);
      AutoString::~AutoString((AutoString *)valuePtr);
      if (Response && v5[2] >= 2)
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        v10 = HTTPMessage::headers((os_unfair_lock_s *)Response + 4);
        *(_QWORD *)valuePtr = MEMORY[0x1E0C809B0];
        *(_QWORD *)&valuePtr[8] = 3221225472;
        *(_QWORD *)&valuePtr[16] = ___ZN11HTTPMessage13logMsgHeadersEP17DiagnosticLoggingPKc_block_invoke;
        v217 = (const char *)&__block_descriptor_40_e36_v24__0____CFString__8____CFArray__16l;
        *(_QWORD *)&v218 = v5;
        HTTPHeaderDict::visitHeaders(v10, 1, (uint64_t)valuePtr);
      }
      (*(void (**)(int *))(*(_QWORD *)v5 + 8))(v5);
    }
  }
  if (*((_QWORD *)this + 59))
  {
    if (!Response)
      goto LABEL_34;
  }
  else
  {
    v11 = *((_QWORD *)this + 34);
    if (v11)
      v11 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 32))(v11, 2);
    *((_QWORD *)this + 59) = v11;
    if (!Response)
      goto LABEL_34;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v12 = HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Response + 16), 0x13721369u);
  if (v12)
    goto LABEL_31;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v12 = HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Response + 16), 0x119152ADu);
  if (v12)
  {
LABEL_31:
    v220.length = CFStringGetLength(v12);
    v220.location = 0;
    v13 = CFStringFindWithOptions(v12, CFSTR("keep-alive"), v220, 1uLL, 0);
    CFRelease(v12);
    v14 = v13 != 0;
  }
  else
  {
    v15 = CFHTTPMessageCopyVersion(Response);
    v16 = v15;
    if (!v15)
    {
LABEL_34:
      v14 = 0;
      goto LABEL_35;
    }
    v14 = CFStringCompare(v15, CFSTR("HTTP/1.1"), 1uLL) == kCFCompareEqualTo;
    CFRelease(v16);
  }
LABEL_35:
  v17 = *((_QWORD *)this + 34);
  if (v17 && !v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 128))(v17);
  if ((*((_DWORD *)this + 48) & 0x4000) != 0)
  {
    HTTPProtocol::constructSSLCertContext(this);
    v18 = (void *)*((_QWORD *)this + 11);
    v19 = !v18 || *(_BYTE *)(objc_msgSend(*((id *)this + 11), "_inner") + 153) == 0;
    if (*((_QWORD *)this + 92) && v19)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v20 = Response ? (CFHTTPMessageRef)((char *)Response + 16) : 0;
      v21 = HTTPMessage::copyHeaderFieldValue(v20, 0x145333D4u);
      if (v21)
      {
        v22 = *((_QWORD *)this + 93);
        if (v22)
          v23 = objc_msgSend(*(id *)(v22 + 112), "_allowsHSTSWithUntrustedRootCertificate");
        else
          v23 = 0;
        v24 = v23 ^ 1;
        if (v18)
        {
          if ((v23 & 1) == 0)
          {
            v25 = (const __CFURL *)objc_msgSend(v18, "cfURL");
            if (v25)
              v24 = StrictSecurityPolicy::strictSecurityPolicyInEffectForURL(*((StrictSecurityPolicy **)this + 92), v25, *(const __CFDictionary **)(objc_msgSend(v18, "_inner") + 192)) == 0;
          }
        }
        if (!*((_QWORD *)this + 92))
          goto LABEL_82;
        v26 = (void *)*((_QWORD *)this + 11);
        v27 = *((_QWORD *)this + 99);
        if (v26)
        {
          v28 = *(const __CFURL **)(objc_msgSend(*((id *)this + 11), "_inner") + 8);
          if (v28)
          {
            v26 = *(void **)(objc_msgSend(v26, "_inner") + 32);
            if (v26)
            {
              v29 = CFURLCopyHostName(v28);
              v30 = CFURLCopyHostName((CFURLRef)v26);
              v31 = v30;
              if (!v29)
              {
                LODWORD(v31) = 0;
                v29 = v30;
                if (!v30)
                  goto LABEL_72;
                goto LABEL_71;
              }
              if (!v30)
              {
LABEL_71:
                CFRelease(v29);
LABEL_72:
                if (CFNLog::onceToken != -1)
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
                v32 = CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
                {
                  v147 = "NOT ";
                  *(_DWORD *)valuePtr = 138544131;
                  *(_QWORD *)&valuePtr[4] = v27;
                  *(_WORD *)&valuePtr[12] = 2117;
                  if ((_DWORD)v31)
                    v147 = "";
                  *(_QWORD *)&valuePtr[14] = v28;
                  *(_WORD *)&valuePtr[22] = 2080;
                  v217 = v147;
                  LOWORD(v218) = 2117;
                  *(_QWORD *)((char *)&v218 + 2) = v26;
                  _os_log_debug_impl(&dword_183ECA000, v32, OS_LOG_TYPE_DEBUG, "%{public}@ request %{sensitive}@ is %sallowed to set HSTS for main doc %{sensitive}@", valuePtr, 0x2Au);
                  if (!(_DWORD)v31)
                    goto LABEL_82;
                }
                else if (!(_DWORD)v31)
                {
LABEL_82:
                  CFRelease(v21);
                  goto LABEL_83;
                }
                v33 = CFHTTPMessageCopyRequestURL(Response);
                if (v33)
                {
                  if (!v24)
                    goto LABEL_80;
                  v34 = (const void *)*((_QWORD *)this + 57);
                  if (v34)
                    goto LABEL_370;
                  v148 = *((_QWORD *)this + 34);
                  if (v148)
                  {
                    v149 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v148 + 120))(v148);
                    v150 = (const void **)((char *)this + 456);
                    if (v149)
                    {
                      setTypeProperty<_CFURLCredential const*>((CFTypeRef *)this + 57, v149);
                      CFRelease(v149);
                    }
                    v34 = *v150;
                    if (*v150)
                    {
LABEL_370:
                      *(_QWORD *)valuePtr = &off_1E14E6B30;
                      LOWORD(v218) = 0;
                      v35 = CFRetain(v34);
                      *(_QWORD *)&valuePtr[16] = 0;
                      v217 = 0;
                      *(_QWORD *)&valuePtr[8] = v35;
                      v36 = CFNetworkTrust::strictEvaluate((uint64_t)valuePtr, 0, 0);
                      CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)valuePtr);
                      if (!v36)
LABEL_80:
                        HSTSPolicy::handleSTSHeader(**((HSTSPolicy ***)this + 92), v21, v33);
                    }
                  }
                  CFRelease(v33);
                }
                goto LABEL_82;
              }
              cfa = v30;
              if (CFStringCompare(v29, &stru_1E1500C68, 0) == kCFCompareEqualTo
                || CFStringCompare(v31, &stru_1E1500C68, 0) == kCFCompareEqualTo
                || isTopLevelDomain(v29, 0))
              {
                goto LABEL_65;
              }
              if (CFStringCompare(v29, v31, 1uLL) == kCFCompareEqualTo)
              {
                LODWORD(v31) = 1;
                goto LABEL_66;
              }
              RegistrableDomain = _cfnCreateRegistrableDomain(v31);
              if (RegistrableDomain)
              {
                v210 = RegistrableDomain;
                LODWORD(v31) = CFStringCompare(RegistrableDomain, v29, 1uLL) == kCFCompareEqualTo;
                CFRelease(v210);
              }
              else
              {
LABEL_65:
                LODWORD(v31) = 0;
              }
LABEL_66:
              CFRelease(cfa);
              goto LABEL_71;
            }
          }
          else
          {
            v26 = 0;
          }
        }
        else
        {
          v28 = 0;
        }
        LODWORD(v31) = 0;
        goto LABEL_72;
      }
    }
  }
  if (!Response || (ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(Response), ResponseStatusCode == -1))
  {
    v38 = (const __CFArray *)*((_QWORD *)this + 37);
    if (v38 && CFArrayGetCount(v38) >= 2)
    {
      CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 37), 0);
      HTTPProtocol::destroyReadStream(this);
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((_QWORD *)this + 104), 1026, 0);
      HTTPProtocol::createAndOpenStream(this, 0);
LABEL_144:
      v62 = 0;
      goto LABEL_145;
    }
    ResponseStatusCode = -1;
    if (!Response)
      goto LABEL_97;
  }
LABEL_83:
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v39 = (char *)Response + 16;
  if (!*((_BYTE *)Response + 40))
    v39 = 0;
  v40 = (_BYTE *)*((_QWORD *)v39 + 36);
  if (v40
    || (v40 = v39 + 160, v39[160])
    || (v40 = (_BYTE *)(*(uint64_t (**)(char *, _QWORD))(*(_QWORD *)v39 + 88))(v39, 0)) != 0)
  {
    v41 = *v40 != 0;
  }
  else
  {
LABEL_97:
    v41 = 0;
  }
  if ((*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 592))(this))
  {
    if (ResponseStatusCode == 401 || ResponseStatusCode == 407)
      goto LABEL_116;
    KerberosAccountBroker = (NSObject **)KerberosAccountBroker::getKerberosAccountBroker(*((KerberosAccountBroker **)this + 10), v42);
    if (KerberosAccountBroker)
      KerberosAccountBroker::clearAccountRefreshState(KerberosAccountBroker, *(const __CFURL **)(objc_msgSend(*((id *)this + 11), "_inner") + 8));
  }
  if (ResponseStatusCode != 401 && ResponseStatusCode != 407)
  {
    v44 = *((_QWORD *)this + 97);
    if (Response)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (*((_BYTE *)Response + 40))
        v45 = (char *)Response + 16;
      else
        v45 = 0;
    }
    else
    {
      v45 = 0;
    }
    v46 = *((_QWORD *)this + 34);
    if (v46)
      v47 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v46 + 112))(v46);
    else
      v47 = 0;
    (*(void (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v44 + 16))(v44, v45, v47);
  }
LABEL_116:
  if (!v41)
  {
    if (Response)
      CFRelease(Response);
    v57 = CFGetAllocator((char *)this - 16);
    Response = CFHTTPMessageCreateResponse(v57, 200, 0, CFSTR("HTTP/0.9"));
    v58 = CFTimeZoneCopyDefault();
    Current = CFAbsoluteTimeGetCurrent();
    *(CFGregorianDate *)valuePtr = CFAbsoluteTimeGetGregorianDate(Current, v58);
    v60 = CFGetAllocator((char *)this - 16);
    RFC1123DateStringWithGregorianDate = _CFStringCreateRFC1123DateStringWithGregorianDate(v60, (CFGregorianDate *)valuePtr, v58);
    if (v58)
      CFRelease(v58);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)Response + 16), 0x121092EBu, RFC1123DateStringWithGregorianDate);
    if (RFC1123DateStringWithGregorianDate)
      CFRelease(RFC1123DateStringWithGregorianDate);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)Response + 16), 0x12F0F32Fu, &unk_1EDCFDA88);
    *((_DWORD *)this + 48) |= 0x2000u;
    goto LABEL_136;
  }
  if (*((int *)this + 182) >= 1)
  {
    *(_QWORD *)valuePtr = ResponseStatusCode;
    v48 = (const __CFSet *)objc_msgSend(*((id *)this + 10), "_getAuthenticatorStatusCodes");
    if (v48)
    {
      v49 = CFGetAllocator((char *)this - 16);
      v50 = CFNumberCreate(v49, kCFNumberCFIndexType, valuePtr);
      if (v50)
      {
        v51 = CFSetContainsValue(v48, v50);
        CFRelease(v50);
        if (v51)
        {
          if (!(*(unsigned int (**)(HTTPProtocol *))(*(_QWORD *)this + 696))(this))
            HTTPProtocol::performHeaderReadPostProcessing(this, Response, 1);
          *((_DWORD *)this + 48) |= 2u;
          *((_QWORD *)this + 91) = 0x100000002;
          CFGetAllocator((char *)this - 16);
          v52 = *(const void **)(objc_msgSend(*((id *)this + 11), "_inner") + 8);
          CacheStoragePolicy = HTTPProtocol::getCacheStoragePolicy(this, (char *)Response);
          v54 = (void (**)(StringSerializable *__hidden))CFURLResponseCreateWithHTTPResponse(CacheStoragePolicy, v52, (uint64_t)Response, CacheStoragePolicy);
          v214 = v54;
          v55 = (_QWORD *)operator new();
          *v55 = &off_1E14F1550;
          v55[1] = 0;
          v55[2] = 0;
          v55[3] = v54;
          v215 = v55;
          if (Response)
            v56 = CFRetain(Response);
          else
            v56 = 0;
          v106 = (const void *)*((_QWORD *)this + 89);
          *((_QWORD *)this + 89) = v56;
          if (v106)
            CFRelease(v106);
          CFRetain((char *)this - 16);
          v107 = (std::__shared_weak_count *)operator new();
          v107->__shared_owners_ = 0;
          p_shared_owners = (unint64_t *)&v107->__shared_owners_;
          v107->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
          v107->__shared_weak_owners_ = 0;
          v107[1].__vftable = (std::__shared_weak_count_vtbl *)this;
          v213 = v107;
          v109 = (void *)*((_QWORD *)this + 10);
          *(_QWORD *)valuePtr = MEMORY[0x1E0C809B0];
          *(_QWORD *)&valuePtr[8] = 3321888768;
          *(_QWORD *)&valuePtr[16] = ___ZN12HTTPProtocol42asynchronouslyHandleHTTPResponseExternallyEP15__CFHTTPMessage_block_invoke;
          v217 = (const char *)&__block_descriptor_48_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e47_v28__0C8____CFDictionary__12___CFURLRequest__20l;
          *(_QWORD *)&v218 = this;
          *((_QWORD *)&v218 + 1) = v107;
          do
            v110 = __ldxr(p_shared_owners);
          while (__stxr(v110 + 1, p_shared_owners));
          objc_msgSend(v109, "_getAuthenticationHeadersForResponse:completionHandler:", v54, valuePtr);
          v111 = (std::__shared_weak_count *)*((_QWORD *)&v218 + 1);
          if (*((_QWORD *)&v218 + 1))
          {
            v112 = (unint64_t *)(*((_QWORD *)&v218 + 1) + 8);
            do
              v113 = __ldaxr(v112);
            while (__stlxr(v113 - 1, v112));
            if (!v113)
            {
              ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
              std::__shared_weak_count::__release_weak(v111);
            }
          }
          if (v213)
          {
            v114 = (unint64_t *)&v213->__shared_owners_;
            do
              v115 = __ldaxr(v114);
            while (__stlxr(v115 - 1, v114));
            if (!v115)
            {
              ((void (*)(std::__shared_weak_count *))v213->__on_zero_shared)(v213);
              std::__shared_weak_count::__release_weak(v213);
            }
          }
          if (v215)
          {
            v116 = (unint64_t *)((char *)v215 + 8);
            do
              v117 = __ldaxr(v116);
            while (__stlxr(v117 - 1, v116));
            if (!v117)
            {
              (*(void (**)(CFTypeRef))(*(_QWORD *)v215 + 16))(v215);
              std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v215);
            }
          }
          goto LABEL_136;
        }
      }
    }
  }
  v62 = 1;
  if (ResponseStatusCode > 400)
  {
    if (ResponseStatusCode != 401)
    {
      if (ResponseStatusCode == 403)
      {
        *(_QWORD *)valuePtr = 0;
        v92 = (const __CFDictionary *)*((_QWORD *)this + 50);
        if (!v92)
          goto LABEL_137;
        Value = (const __CFNumber *)CFDictionaryGetValue(v92, &unk_1EDCFAB48);
        if (!Value)
          goto LABEL_137;
        CFNumberGetValue(Value, kCFNumberCFIndexType, valuePtr);
        if (*(uint64_t *)valuePtr <= 1)
          goto LABEL_137;
        v94 = CFGetAllocator((char *)this - 16);
        CFError = __cfnCreateCFError(v94, CFSTR("kCFErrorDomainCFNetwork"), -1206, v95, v96, v97, v98, v99, 0);
        if (!CFError)
        {
LABEL_136:
          v62 = 1;
          goto LABEL_137;
        }
        HTTPProtocol::destroyReadStream(this);
        if (!*((_QWORD *)this + 59))
          goto LABEL_320;
        v101 = CFErrorCopyUserInfo(CFError);
        v102 = CFGetAllocator((char *)this - 16);
        v103 = v102;
        if (v101)
        {
          Count = CFDictionaryGetCount(v101);
          MutableCopy = CFDictionaryCreateMutableCopy(v103, Count + 1, v101);
          CFDictionarySetValue(MutableCopy, CFSTR("NSErrorPeerAddressKey"), *((const void **)this + 59));
          CFRelease(v101);
        }
        else
        {
          MutableCopy = cfTypeCreateMutableDictionary(v102, CFSTR("NSErrorPeerAddressKey"), *((_QWORD *)this + 59), 0);
        }
        if (MutableCopy)
        {
          v181 = CFGetAllocator((char *)this - 16);
          Domain = CFErrorGetDomain(CFError);
          Code = CFErrorGetCode(CFError);
          v176 = CFErrorCreate(v181, Domain, Code, MutableCopy);
          CFRelease(CFError);
          CFRelease(MutableCopy);
          URLProtocol::sendDidFail((URLProtocol *)this, v176);
          if (!v176)
            goto LABEL_144;
        }
        else
        {
LABEL_320:
          URLProtocol::sendDidFail((URLProtocol *)this, CFError);
          v176 = CFError;
        }
LABEL_350:
        CFRelease(v176);
        goto LABEL_144;
      }
      if (ResponseStatusCode != 407)
        goto LABEL_137;
    }
    v81 = *((_DWORD *)this + 48);
    if ((v81 & 0x8000) != 0)
      goto LABEL_137;
    *((_WORD *)this + 98) = *((_WORD *)this + 98);
    *((_DWORD *)this + 48) = v81 | 4;
    v82 = CFHTTPMessageGetResponseStatusCode(Response);
    if (!*((_QWORD *)this + 97))
    {
      _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((std::__shared_weak_count_vtbl **)valuePtr);
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 776, (__int128 *)valuePtr);
      v118 = *(std::__shared_weak_count **)&valuePtr[8];
      if (*(_QWORD *)&valuePtr[8])
      {
        v119 = (unint64_t *)(*(_QWORD *)&valuePtr[8] + 8);
        do
          v120 = __ldaxr(v119);
        while (__stlxr(v120 - 1, v119));
        if (!v120)
        {
          ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
          std::__shared_weak_count::__release_weak(v118);
        }
      }
    }
    HasCredentialsForChallenge = HTTPProtocol::_CFHTTPProtHasCredentialsForChallenge(this, Response);
    if ((((unint64_t)*((unsigned __int16 *)this + 98) << 32) & 0x120000000000) == 0)
    {
      v84 = (AuthenticationState *)*((_QWORD *)this + 97);
      if (Response)
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        if (*((_BYTE *)Response + 40))
          v85 = (CFHTTPMessageRef)((char *)Response + 16);
        else
          v85 = 0;
      }
      else
      {
        v85 = 0;
      }
      if (v82 == 407)
      {
        v151 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 648))(this);
        v152 = (const _CFURLCredential *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this);
      }
      else
      {
        v151 = *((_QWORD *)this + 47);
        v152 = (const _CFURLCredential *)*((_QWORD *)this + 44);
      }
      AuthenticationState::updateState(v84, v85, v151, v152, *((__SecTrust **)this + 57));
    }
    if (HasCredentialsForChallenge)
    {
      HTTPProtocol::destroyReadStream(this);
      CFGetAllocator((char *)this - 16);
      v153 = objc_msgSend(*((id *)this + 11), "_inner");
      v62 = (uint64_t)CFURLResponseCreateWithHTTPResponse(v153, *(const void **)(v153 + 8), (uint64_t)Response, 2);
      Property = (id)*((_QWORD *)this + 104);
      if (Property)
        Property = objc_getProperty(Property, v154, 96, 1);
      -[__CFN_TransactionMetrics responseHeaderEnd:]((uint64_t)Property, (void *)v62);
      v157 = (void *)*((_QWORD *)this + 104);
      if (v157)
      {
        v158 = (CFAbsoluteTime *)objc_getProperty(v157, v156, 96, 1);
        if (v158)
        {
          v158[25] = CFAbsoluteTimeGetCurrent();
          *((_OWORD *)v158 + 2) = *((_OWORD *)v158 + 8);
        }
      }
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((_QWORD *)this + 104), 3, 0);
      HTTPProtocol::createAndOpenStream(this, 0);
LABEL_284:
      if (!v62)
        goto LABEL_145;
      CFRelease((CFTypeRef)v62);
      goto LABEL_144;
    }
    v159 = *((unsigned int *)this + 48);
    v160 = v159 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    if ((v159 & 0x40000) != 0)
    {
      if (v82 != 407)
      {
        v160 = v159 & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        *((_DWORD *)this + 48) = v159 & 0xFFFEFFFF;
        *((_WORD *)this + 98) = WORD2(v160);
      }
      *((_WORD *)this + 98) = WORD2(v160);
      *((_DWORD *)this + 48) = v160 & 0xFFFFFFFB;
      goto LABEL_136;
    }
    if ((v160 & 0x120024200000) != 0)
    {
      CFGetAllocator((char *)this - 16);
      v161 = objc_msgSend(*((id *)this + 11), "_inner");
      v62 = (uint64_t)CFURLResponseCreateWithHTTPResponse(v161, *(const void **)(v161 + 8), (uint64_t)Response, 2);
      v162 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
      if ((v162 & 0x120000000000) != 0)
      {
        *((_WORD *)this + 98) = WORD2(v162);
        *((_DWORD *)this + 48) = v162 | 2;

        *((_QWORD *)this + 26) = (id)v62;
      }
      else
      {
        HTTPProtocol::destroyReadStream(this);
      }
      v177 = (id)*((_QWORD *)this + 104);
      if (v177)
        v177 = objc_getProperty(v177, v163, 96, 1);
      -[__CFN_TransactionMetrics responseHeaderEnd:]((uint64_t)v177, (void *)v62);
      v179 = (void *)*((_QWORD *)this + 104);
      if (v179)
      {
        v180 = (CFAbsoluteTime *)objc_getProperty(v179, v178, 96, 1);
        if (v180)
        {
          v180[25] = CFAbsoluteTimeGetCurrent();
          *((_OWORD *)v180 + 2) = *((_OWORD *)v180 + 8);
        }
      }
      goto LABEL_284;
    }
    if (v82 == 407 && (v172 = *((_QWORD *)this + 46)) != 0)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v172 + 40))(v172);
      v173 = (__CFError *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 648))(this);
    }
    else
    {
      v175 = (const void *)*((_QWORD *)this + 47);
      if (!v175)
      {
        v176 = 0;
        goto LABEL_341;
      }
      v173 = (__CFError *)CFRetain(v175);
    }
    v176 = v173;
LABEL_341:
    *((_DWORD *)this + 48) |= 2u;
    HTTPProtocol::updateForHeader(this, Response);
    HTTPProtocol::destroyReadStream(this);
    v196 = (id)*((_QWORD *)this + 104);
    if (v196)
      v196 = objc_getProperty(v196, v195, 96, 1);
    -[__CFN_TransactionMetrics responseHeaderEnd:]((uint64_t)v196, *((void **)this + 26));
    v198 = (void *)*((_QWORD *)this + 104);
    if (v198)
    {
      v199 = (CFAbsoluteTime *)objc_getProperty(v198, v197, 96, 1);
      if (v199)
      {
        v199[25] = CFAbsoluteTimeGetCurrent();
        *((_OWORD *)v199 + 2) = *((_OWORD *)v199 + 8);
      }
    }
    HTTPProtocol::sendDidReceiveAuthChallenge(this, (_CFURLAuthChallenge *)v176);
    if (v82 == 407)
    {
      v200 = *((_QWORD *)this + 46);
      if (v200)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v200 + 48))(v200);
        goto LABEL_144;
      }
    }
    if (!v176)
      goto LABEL_144;
    goto LABEL_350;
  }
  if ((unint64_t)(ResponseStatusCode - 301) <= 7)
  {
    if (((1 << (ResponseStatusCode - 45)) & 0xC7) != 0)
    {
      v71 = (void *)*((_QWORD *)this + 11);
      if (v71)
        CFRetain(*((CFTypeRef *)this + 11));
      v62 = (*(uint64_t (**)(HTTPProtocol *, CFHTTPMessageRef))(*(_QWORD *)this + 184))(this, Response);
      if ((_DWORD)v62 && (ResponseStatusCode == 308 || ResponseStatusCode == 301) && Response && *((_BYTE *)this + 448))
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        if (*((_BYTE *)Response + 40))
          v72 = (CFHTTPMessageRef)((char *)Response + 16);
        else
          v72 = 0;
        HeaderFieldValue = HTTPMessage::copyLastHeaderFieldValue(v72, 0x12E1132Au);
        v74 = HeaderFieldValue;
        if (HeaderFieldValue)
        {
          v75 = CFStringGetLength(HeaderFieldValue) == 0;
          CFRelease(v74);
          if (!v75 && HTTPProtocol::getCacheStoragePolicy(this, (char *)Response) != 2)
          {
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
            if (*((_BYTE *)Response + 40))
              v76 = (os_unfair_lock_s *)((char *)Response + 16);
            else
              v76 = 0;
            HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(valuePtr, 0x141153BEu);
            v77 = (CFDictionaryRef *)HTTPMessage::headers(v76);
            v78 = HTTPHeaderDict::containsKey(v77, (const HTTPHeaderKeyMixedValue *)valuePtr);
            if (!v78)
            {
              HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(&v214, 0x142173C4u);
              v79 = (CFDictionaryRef *)HTTPMessage::headers(v76);
              v78 = HTTPHeaderDict::containsKey(v79, (const HTTPHeaderKeyMixedValue *)&v214);
              v214 = &off_1E14E9A00;
              if (v215)
                CFRelease(v215);
            }
            *(_QWORD *)valuePtr = &off_1E14E9A00;
            if (*(_QWORD *)&valuePtr[8])
              CFRelease(*(CFTypeRef *)&valuePtr[8]);
            if (!v78)
            {
              if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
              v80 = HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Response + 16), 0x1260F2FEu);
              if (v80)
              {
                CFRelease(v80);
              }
              else
              {
                v184 = CFAbsoluteTimeGetCurrent();
                *(CFGregorianDate *)valuePtr = CFAbsoluteTimeGetGregorianDate(v184 + 604800.0, 0);
                v185 = CFGetAllocator((char *)this - 16);
                RFC2616DateStringWithGregorianDate = _CFStringCreateRFC2616DateStringWithGregorianDate(v185, (CFGregorianDate *)valuePtr, 0);
                if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                  dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
                HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)Response + 16), 0x1260F2FEu, RFC2616DateStringWithGregorianDate);
                if (RFC2616DateStringWithGregorianDate)
                  CFRelease(RFC2616DateStringWithGregorianDate);
              }
              CFGetAllocator((char *)this - 16);
              v187 = objc_msgSend(v71, "_inner");
              v188 = CFURLResponseCreateWithHTTPResponse(v187, *(const void **)(v187 + 8), (uint64_t)Response, 0);
              v189 = CFHTTPMessageGetResponseStatusCode(Response) == 301;
              v190 = CFGetAllocator((char *)this - 16);
              if (v189)
                v191 = CFDataCreate(v190, (const UInt8 *)"301PermMove", 11);
              else
                v191 = CFDataCreate(v190, (const UInt8 *)"308PermRedirect", 15);
              v192 = v191;
              v193 = (const void *)CFCachedURLResponseCreateWithUserInfo(*MEMORY[0x1E0C9AE00], v188, v191, 0, 0);
              if (*((_BYTE *)this + 448))
              {
                v194 = (void *)*((_QWORD *)this + 10);
                *(_QWORD *)valuePtr = MEMORY[0x1E0C809B0];
                *(_QWORD *)&valuePtr[8] = 3221225472;
                *(_QWORD *)&valuePtr[16] = ___ZN12HTTPProtocol30attemptToCacheMovedPermanentlyEP15__CFHTTPMessage23CFURLCacheStoragePolicyPK13_CFURLRequest_block_invoke;
                v217 = (const char *)&__block_descriptor_48_e24_v16__0r__XURLCache_____8l;
                *(_QWORD *)&v218 = v193;
                *((_QWORD *)&v218 + 1) = v71;
                objc_msgSend(v194, "_withXURLCache:", valuePtr);
              }
              if (v193)
                CFRelease(v193);

              if (v192)
                CFRelease(v192);
            }
          }
        }
      }
      if (v71)
        CFRelease(v71);
      if (!(_DWORD)v62)
        goto LABEL_145;
      goto LABEL_137;
    }
    if (ResponseStatusCode == 304)
    {
      v86 = *((unsigned int *)this + 48);
      v87 = v86 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
      if ((v86 & 0x10000) != 0)
      {
        v88 = v86 & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        *((_DWORD *)this + 48) = v86 & 0xFFFEFFFF;
        *((_WORD *)this + 98) = WORD2(v88);
        HTTPProtocol::storeCredentials(this);
        v87 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
      }
      v89 = v87 & 0xFFFFFFFFFFFFFFFBLL;
      *((_WORD *)this + 98) = WORD2(v89);
      *((_DWORD *)this + 48) = v89 | 2;
      v90 = (const _CFCachedURLResponse *)*((_QWORD *)this + 62);
      if (v90)
      {
        v91 = *((_QWORD *)this + 95);
        if (v91 != 1 && v91 != 4)
        {
          if (Response)
          {
            CFGetAllocator((char *)this - 16);
            v121 = *(const void **)(objc_msgSend(*((id *)this + 11), "_inner") + 8);
            v122 = HTTPProtocol::getCacheStoragePolicy(this, (char *)Response);
            cfb = CFURLResponseCreateWithHTTPResponse(v122, v121, (uint64_t)Response, v122);
            v124 = (id)*((_QWORD *)this + 104);
            if (v124)
              v124 = objc_getProperty(v124, v123, 96, 1);
            -[__CFN_TransactionMetrics responseHeaderEnd:]((uint64_t)v124, cfb);
            v125 = (void *)CFCachedURLResponseCopyWrappedResponse(*((const _CFCachedURLResponse **)this + 62));
            v126 = v125;
            if (v125
              && ((v127 = *(_QWORD *)(objc_msgSend(v125, "_inner") + 88)) != 0
                ? (v128 = (_BYTE *)(v127 - 16))
                : (v128 = 0),
                  v127))
            {
              v129 = CFHTTPMessageCopyAllHeaderFields(Response);
              if (v129)
              {
                v130 = CFGetAllocator((char *)this - 16);
                Copy = CFHTTPMessageCreateCopy(v130, (CFHTTPMessageRef)v128);
                v209 = CFCachedURLResponseCopyReceiverDataArray(*((_QWORD *)this + 62));
                if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                  dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
                v132 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)(v128 + 16), 0x11F192E0u);
                if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                  dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
                if (v128[40])
                  v133 = (HTTPMessage *)(v128 + 16);
                else
                  v133 = 0;
                v134 = HTTPMessage::copyLastHeaderFieldValue(v133, 0x11D1D2CFu);
                _CFHTTPMessageSetMultipleHeaderFields(Copy, v129);
                CFRelease(v129);
                if (v132)
                {
                  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
                  HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)Copy + 16), 0x11F192E0u, v132);
                  CFRelease(v132);
                }
                if (v134)
                {
                  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
                  HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)Copy + 16), 0x11D1D2CFu, v134);
                  CFRelease(v134);
                }
                CFGetAllocator((char *)this - 16);
                v135 = *(const void **)(objc_msgSend(v126, "_inner") + 8);
                v136 = objc_msgSend(v126, "_inner");
                v137 = CFURLResponseCreateWithHTTPResponse(v136, v135, (uint64_t)Copy, *(_DWORD *)(v136 + 72));
                CFRelease(Copy);
                ExpectedContentLength = CFURLResponseGetExpectedContentLength(v126);
                v139 = objc_msgSend(v137, "_inner");
                *(_QWORD *)(v139 + 32) = ExpectedContentLength;
                v140 = *(_QWORD *)(v139 + 88);
                if (v140)
                {
                  *(_WORD *)(v140 + 297) |= 0x100u;
                  *(_WORD *)(*(_QWORD *)(v139 + 88) + 297) |= 0x2000u;
                }
                MIMEType = URLResponse::getMIMEType((URLResponse *)objc_msgSend(v126, "_inner"));
                CFURLResponseSetMIMEType(v137, MIMEType);
                v142 = CFGetAllocator((char *)this - 16);
                v143 = *((_QWORD *)this + 62);
                if (v143)
                {
                  v144 = *(_QWORD *)(v143 + 16);
                  v145 = *(const void **)(v144 + 40);
                  v146 = *(_DWORD *)(v144 + 56);
                }
                else
                {
                  v145 = 0;
                  v146 = 2;
                }
                v201 = (const _CFCachedURLResponse *)CFCachedURLResponseCreateWithDataArray((uint64_t)v142, v137, v209, v145, v146);
                v202 = (const void *)*((_QWORD *)this + 62);
                *((_QWORD *)this + 62) = 0;
                if (v202)
                  CFRelease(v202);
                if (v209)
                  CFRelease(v209);

                HTTPProtocol::setSSLCertContextOnResponseOrCachedResponse(this, 0, v201);
                v203 = *((_QWORD *)this + 12);
                if (v203)
                {
                  v204 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v203 + 16))(*((_QWORD *)this + 12));
                  v205 = (void *)MEMORY[0x186DB8C8C](v204);
                  (*(void (**)(_QWORD, const _CFCachedURLResponse *))(**((_QWORD **)this + 12) + 48))(*((_QWORD *)this + 12), v201);
                  objc_autoreleasePoolPop(v205);
                  (*(void (**)(uint64_t))(*(_QWORD *)v203 + 24))(v203);
                }
                if (v201)
                  CFRelease(v201);
              }
            }
            else
            {
              HTTPProtocol::setSSLCertContextOnResponseOrCachedResponse(this, 0, *((const _CFCachedURLResponse **)this + 62));
              v164 = (const void *)*((_QWORD *)this + 62);
              v165 = *((_QWORD *)this + 12);
              if (v165)
              {
                v166 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v165 + 16))(*((_QWORD *)this + 12));
                v167 = (void *)MEMORY[0x186DB8C8C](v166);
                (*(void (**)(_QWORD, const void *))(**((_QWORD **)this + 12) + 48))(*((_QWORD *)this + 12), v164);
                objc_autoreleasePoolPop(v167);
                (*(void (**)(uint64_t))(*(_QWORD *)v165 + 24))(v165);
                v164 = (const void *)*((_QWORD *)this + 62);
              }
              *((_QWORD *)this + 62) = 0;
              if (v164)
                CFRelease(v164);
            }

            if (cfb)
              CFRelease(cfb);
          }
          else
          {
            HTTPProtocol::setSSLCertContextOnResponseOrCachedResponse(this, 0, v90);
            v168 = (const void *)*((_QWORD *)this + 62);
            v169 = *((_QWORD *)this + 12);
            if (v169)
            {
              v170 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v169 + 16))(*((_QWORD *)this + 12));
              v171 = (void *)MEMORY[0x186DB8C8C](v170);
              (*(void (**)(_QWORD, const void *))(**((_QWORD **)this + 12) + 48))(*((_QWORD *)this + 12), v168);
              objc_autoreleasePoolPop(v171);
              (*(void (**)(uint64_t))(*(_QWORD *)v169 + 24))(v169);
              v168 = (const void *)*((_QWORD *)this + 62);
            }
            *((_QWORD *)this + 62) = 0;
            if (v168)
              CFRelease(v168);
          }
          HTTPProtocol::destroyReadStream(this);
          v207 = (void *)*((_QWORD *)this + 104);
          if (v207)
          {
            v208 = (CFAbsoluteTime *)objc_getProperty(v207, v206, 96, 1);
            if (v208)
            {
              v208[25] = CFAbsoluteTimeGetCurrent();
              *((_OWORD *)v208 + 2) = *((_OWORD *)v208 + 8);
            }
          }
          HTTPProtocol::updateCookieStoreDuringHeaderRead(this, Response);
          goto LABEL_144;
        }
      }
      HTTPProtocol::setSSLCertContextOnResponseOrCachedResponse(this, *((HTTPProtocol **)this + 26), 0);
      goto LABEL_136;
    }
  }
LABEL_137:
  v63 = (void *)*((_QWORD *)this + 10);
  if (objc_msgSend(v63, "resumableUploadState"))
  {
    v64 = (void *)objc_msgSend(v63, "resumableUploadState");
    v65 = (uint64_t)v64;
    if (!v64
      || objc_msgSend(v64, "isResumable")
      && (-[__NSCFResumableUploadState processResponse:](v65, Response) & 1) == 0)
    {
      HTTPProtocol::destroyReadStream(this);
      v66 = objc_msgSend(v63, "resumableUploadState");
      if (v66)
        v67 = *(_QWORD *)(v66 + 24);
      else
        v67 = 0;
      v68 = *((_DWORD *)this + 48);
      *((_QWORD *)this + 6) = v67;
      v69 = *((_WORD *)this + 98);
      *((_DWORD *)this + 48) = v68;
      *((_WORD *)this + 98) = v69 | 0x4000;
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((_QWORD *)this + 104), 4, 0);
      HTTPProtocol::createAndOpenStream(this, 0);
      goto LABEL_144;
    }
  }
LABEL_145:
  if (*((_DWORD *)this + 182) != 2
    && (((unint64_t)*((unsigned __int16 *)this + 98) << 32) & 0x120000000000) == 0)
  {
    HTTPProtocol::performHeaderReadPostProcessing(this, Response, v62);
  }
  if (Response)
    CFRelease(Response);
  return v62;
}

void sub_183F576D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFTypeRef cf, CFTypeRef a14, char a15, uint64_t a16, uint64_t a17, CFTypeRef a18, uint64_t a19, uint64_t a20)
{
  const void *v20;
  const void *v21;

  CFRelease(cf);
  CFRelease(a14);
  CFRelease(v21);
  CFRelease(v20);
  _Unwind_Resume(a1);
}

void HTTPProtocol::performHeaderReadPostProcessing(HTTPProtocol *this, __CFHTTPMessage *a2, int a3)
{
  void *v5;
  uint64_t ExpectedContentLength;
  const __CFNumber *v7;
  uint64_t v8;
  size_t v9;
  const __CFAllocator *v10;
  CFNumberRef v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  HTTPMessage *v15;
  const __CFString *HeaderFieldValue;
  const __CFString *v17;
  uint8_t v18[16];

  if (a3)
  {
    if (!a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v18 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "updateForHeader(): No HTTP response available", v18, 2u);
    }
    *((_DWORD *)this + 48) |= 2u;
    HTTPProtocol::updateForHeader(this, a2);
    HTTPProtocol::checkAndSendDidReceiveResponse(this);
  }
  v5 = (void *)*((_QWORD *)this + 26);
  if (v5)
    ExpectedContentLength = CFURLResponseGetExpectedContentLength(v5);
  else
    ExpectedContentLength = -1;
  v7 = (const __CFNumber *)*((_QWORD *)this + 67);
  if ((v7 || *((_QWORD *)this + 68)) && *((_QWORD *)this + 34) && *((_QWORD *)this + 26) && ExpectedContentLength >= 1)
  {
    if (v7)
    {
      *(_QWORD *)v18 = 0;
      CFNumberGetValue(v7, kCFNumberCFIndexType, v18);
      v8 = *(_QWORD *)v18;
    }
    else
    {
      v8 = 0xFFFFLL;
    }
    if (ExpectedContentLength >= v8)
    {
      if (v8 >= 10485760)
        v9 = 10485760;
      else
        v9 = v8;
      *((_QWORD *)this + 70) = v9;
      *((_QWORD *)this + 69) = malloc_type_malloc(v9, 0x61D9053FuLL);
      if (*((_QWORD *)this + 67))
        (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 24);
      if (*((_QWORD *)this + 68))
        (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 25);
    }
  }
  if (*((_BYTE *)this + 47))
  {
    *((_QWORD *)this + 64) = ExpectedContentLength;
    if (ExpectedContentLength == -1)
    {
      v12 = (void *)*((_QWORD *)this + 26);
      if (v12)
      {
        v13 = *(_QWORD *)(objc_msgSend(v12, "_inner") + 88);
        v14 = v13 ? v13 - 16 : 0;
        if (v13)
        {
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          if (*(_BYTE *)(v14 + 40))
            v15 = (HTTPMessage *)(v14 + 16);
          else
            v15 = 0;
          HeaderFieldValue = HTTPMessage::copyLastHeaderFieldValue(v15, 0x11D1D2CFu);
          if (HeaderFieldValue)
          {
            v17 = HeaderFieldValue;
            *((_QWORD *)this + 64) = CFNGetContentLengthFromHeaderFieldValue(HeaderFieldValue);
            CFRelease(v17);
          }
        }
      }
    }
  }
  if (*((_QWORD *)this + 64) != -1 && *((_QWORD *)this + 34))
  {
    *(_QWORD *)v18 = *((_QWORD *)this + 64);
    v10 = CFGetAllocator((char *)this - 16);
    v11 = CFNumberCreate(v10, kCFNumberSInt64Type, v18);
    (*(void (**)(_QWORD, uint64_t, CFNumberRef))(**((_QWORD **)this + 34) + 40))(*((_QWORD *)this + 34), 8, v11);
    if (v11)
      CFRelease(v11);
  }
}

void sub_183F57AAC(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void HTTPProtocol::checkAndSendDidReceiveResponse(HTTPProtocol *this)
{
  void *v2;
  uint64_t v3;
  void *v4;
  const __CFURL *v5;
  const __CFString *v6;
  const __CFString *v7;
  CFComparisonResult v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  id Property;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  CFStreamError v17;

  v2 = (void *)*((_QWORD *)this + 26);
  if (v2)
  {
    v3 = *(_QWORD *)(objc_msgSend(v2, "_inner") + 88);
    if (v3)
    {
      if (*(_DWORD *)(v3 + 128) == 407)
      {
        v4 = (void *)*((_QWORD *)this + 11);
        if (v4 && (v5 = (const __CFURL *)objc_msgSend(v4, "cfURL")) != 0 && (v6 = CFURLCopyScheme(v5)) != 0)
        {
          v7 = v6;
          v8 = CFStringCompare(v6, (CFStringRef)&unk_1EDD00AE0, 1uLL);
          CFRelease(v7);
          v9 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
          if (v8)
          {
            if ((*((_DWORD *)this + 48) & 0x40) != 0)
              return;
            goto LABEL_11;
          }
        }
        else
        {
          v9 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        }
        *((_WORD *)this + 98) = WORD2(v9);
        *((_DWORD *)this + 48) = v9 | 0x40;
        v17.domain = 4;
        v17.error = -2098;
        HTTPProtocol::streamError(this, &v17);
        return;
      }
    }
  }
  v10 = *((unsigned int *)this + 48);
  v9 = v10 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
  if ((v10 & 0x40) != 0)
    return;
LABEL_11:
  *((_WORD *)this + 98) = WORD2(v9);
  *((_DWORD *)this + 48) = v9 | 0x40;
  v11 = (char *)*((_QWORD *)this + 26);
  if (v11)
  {
    Property = (id)*((_QWORD *)this + 104);
    if (Property)
    {
      Property = objc_getProperty(Property, v11, 96, 1);
      v11 = (char *)*((_QWORD *)this + 26);
    }
    -[__CFN_TransactionMetrics responseHeaderEnd:]((uint64_t)Property, v11);
  }
  v13 = *((_QWORD *)this + 12);
  if (v13)
  {
    v14 = *((_QWORD *)this + 26);
    v15 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v13 + 16))(*((_QWORD *)this + 12));
    v16 = (void *)MEMORY[0x186DB8C8C](v15);
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 12) + 64))(*((_QWORD *)this + 12), v14);
    objc_autoreleasePoolPop(v16);
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
  }
}

void sub_183F57C40(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTPProtocol::updateForHeader(HTTPProtocol *this, __CFHTTPMessage *a2)
{
  uint64_t *v4;
  HTTPMessage *v5;
  HTTPMessage *v6;
  const __CFString *v7;
  const __CFString *v8;
  CFIndex Length;
  CFIndex v10;
  const char *CStringPtr;
  uint64_t v12;
  int64_t v13;
  int v14;
  BOOL v15;
  CFIndex v16;
  uint64_t v17;
  CFIndex v18;
  uint64_t v19;
  int64_t v20;
  UniChar v21;
  int IsCharacterMember;
  uint64_t v23;
  int64_t v24;
  int64_t v25;
  uint64_t v27;
  uint64_t v28;
  int64_t v29;
  int64_t v30;
  const __CFAllocator *v31;
  const __CFString *v32;
  int64_t v33;
  CFIndex v34;
  UniChar *v35;
  uint64_t v36;
  UniChar v37;
  int64_t v38;
  CFIndex v39;
  UniChar *v40;
  uint64_t v41;
  UniChar v42;
  int64_t v43;
  CFIndex v44;
  CFMutableStringRef MutableCopy;
  const __CFAllocator *v46;
  const void *v47;
  const __CFAllocator *v48;
  const void *v49;
  const __CFAllocator *v50;
  CFMutableStringRef Mutable;
  const __CFAllocator *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  os_unfair_lock_s *v56;
  CFDictionaryRef *v57;
  __CFString *v58;
  uint64_t v59;
  __SecTrust *v60;
  __SecTrust *v61;
  CFArrayRef v62;
  void *v63;
  uint64_t v64;
  void *v65;
  void *v66;
  uint64_t v67;
  int v68;
  _NSHTTPAlternativeServicesStorage *v69;
  __CFString *v70;
  uint64_t v71;
  char *v72;
  _NSHTTPAlternativeServiceEntry *v73;
  CFCharacterSetRef v74;
  int v75;
  char *v76;
  char *v77;
  unsigned int v78;
  char *v79;
  BOOL v80;
  char *v81;
  char *v82;
  _NSHTTPAlternativeServiceEntry *v83;
  size_t v84;
  uint64_t v85;
  char *v86;
  char *v87;
  int v88;
  uint64_t v89;
  int v90;
  int v91;
  _NSHTTPAlternativeServiceEntry *v92;
  void *v93;
  uint64_t v94;
  void *v95;
  const void *v96;
  const __CFArray *v97;
  const __CFArray *v98;
  HTTPMessage *v99;
  CFURLRef v100;
  const __CFString *HeaderFieldValue;
  const __CFString *v102;
  uint64_t *v103;
  CFIndex v104;
  CFIndex MaximumSizeForEncoding;
  UInt8 *v106;
  CFIndex Count;
  CFIndex v108;
  CFIndex v109;
  CFStringEncoding ValueAtIndex;
  const __CFAllocator *v111;
  CFStringRef v112;
  CFStringRef v113;
  const __CFString *v114;
  const __CFString *v115;
  unsigned int v116;
  HTTPMessage *v117;
  const __CFString *FilenameFromContentDispositionHeader;
  int v119;
  const __CFString *v120;
  const __CFString *v121;
  const __CFString *ExtensionFromFilename;
  CFTypeID v123;
  int Value;
  BOOL v125;
  const void *v126;
  uint64_t CacheStoragePolicy;
  id v128;
  uint64_t v129;
  const void *v130;
  const void *v131;
  CFTypeRef v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  const void *v138;
  uint64_t v139;
  const void *v140;
  int64_t v141;
  CFIndex v142;
  char *v143;
  __CFString *v144;
  __SecTrust *v145;
  __CFString *v146;
  id v147;
  id v148;
  const __CFArray *v149;
  const __CFString *v150;
  _NSHTTPAlternativeServicesStorage *v151;
  HTTPMessage *v152;
  HTTPMessage *v153;
  HTTPMessage *v154;
  HTTPMessage *v155;
  HTTPMessage *v156;
  HTTPMessage *v157;
  __CFHTTPMessage *v158;
  __CFHTTPMessage *v159;
  const __CFCharacterSet *theSet;
  CFCharacterSetRef theSeta;
  UniChar buffer[4];
  CFTypeRef cf;
  void (*v164)(uint64_t);
  void *v165;
  char *v166;
  CFStringRef theString;
  const UniChar *CharactersPtr;
  const char *v169;
  uint64_t v170;
  int64_t v171;
  int64_t v172;
  int64_t v173;
  void (**v174)(StringSerializable *__hidden);
  CFTypeRef v175;
  CFRange v176;
  CFRange v177;
  CFRange v178;
  CFRange v179;
  CFRange v180;
  CFRange v181;

  v4 = &HSTSCache::defaultStoreURL(void)::once;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v5 = (__CFHTTPMessage *)((char *)a2 + 16);
  if (a2)
    v6 = (__CFHTTPMessage *)((char *)a2 + 16);
  else
    v6 = 0;
  v7 = HTTPMessage::copyHeaderFieldValue(v6, 0x11F192E0u);
  if (!v7)
    goto LABEL_89;
  v8 = v7;
  if (CFStringGetLength(v7) < 25)
    goto LABEL_88;
  v180.location = 0;
  v180.length = 25;
  if (CFStringCompareWithOptions(v8, CFSTR("multipart/x-mixed-replace"), v180, 1uLL))
    goto LABEL_88;
  v155 = v6;
  Length = CFStringGetLength(v8);
  theSet = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  v10 = Length - 25;
  theString = v8;
  v170 = 25;
  v171 = Length - 25;
  CharactersPtr = CFStringGetCharactersPtr(v8);
  if (CharactersPtr)
    CStringPtr = 0;
  else
    CStringPtr = CFStringGetCStringPtr(v8, 0x600u);
  v172 = 0;
  v173 = 0;
  v169 = CStringPtr;
  if (Length < 26)
    goto LABEL_85;
  v150 = v8;
  v152 = (__CFHTTPMessage *)((char *)a2 + 16);
  v158 = a2;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = -1;
  v17 = 64;
  v18 = -1;
  do
  {
    if ((unint64_t)v13 >= 4)
      v19 = 4;
    else
      v19 = v13;
    v20 = v171;
    if (v171 <= v13)
    {
      v21 = 0;
      goto LABEL_22;
    }
    if (CharactersPtr)
    {
      v21 = CharactersPtr[v13 + v170];
      if (v14)
        goto LABEL_43;
    }
    else if (v169)
    {
      v21 = v169[v170 + v13];
      if (v14)
        goto LABEL_43;
    }
    else
    {
      v25 = v172;
      if (v173 <= v13 || v172 > v13)
      {
        v27 = v19 + v12;
        v28 = v17 - v19;
        v29 = v13 - v19;
        v30 = v29 + 64;
        if (v29 + 64 >= v171)
          v30 = v171;
        v172 = v29;
        v173 = v30;
        if (v171 >= v28)
          v20 = v28;
        v176.length = v20 + v27;
        v176.location = v29 + v170;
        CFStringGetCharacters(theString, v176, buffer);
        v25 = v172;
      }
      v21 = buffer[v13 - v25];
      if (v14)
        goto LABEL_43;
    }
    if (!v15 && v21 == 61)
    {
      v15 = 0;
      v18 = -1;
      v14 = 1;
      v16 = -1;
      goto LABEL_45;
    }
LABEL_43:
    if (v21 == 34)
    {
      v15 = !v15;
      goto LABEL_45;
    }
LABEL_22:
    IsCharacterMember = CFCharacterSetIsCharacterMember(theSet, v21);
    v23 = v13 - v16 + 26;
    if (v16 == -1)
    {
      v23 = 1;
      v24 = v13 + 25;
    }
    else
    {
      v24 = v16;
    }
    if (!IsCharacterMember)
    {
      v18 = v23;
      v16 = v24;
    }
LABEL_45:
    ++v13;
    --v12;
    ++v17;
  }
  while (v10 != v13);
  a2 = v158;
  v8 = v150;
  v5 = v152;
  v4 = &HSTSCache::defaultStoreURL(void)::once;
  if (v16 != -1 && v18 != -1)
  {
    v31 = CFGetAllocator((char *)this - 16);
    v181.location = v16;
    v181.length = v18;
    v32 = CFStringCreateWithSubstring(v31, v150, v181);
    if (v18 < 3)
      goto LABEL_73;
    v33 = v16 - 25;
    if (v16 < 25)
      goto LABEL_73;
    v34 = v171;
    if (v171 <= v33)
      goto LABEL_73;
    v35 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      v36 = v170 + v33;
      goto LABEL_53;
    }
    if (v169)
    {
      v37 = v169[v170 + v33];
    }
    else
    {
      if (v173 <= v33 || (v43 = v172, v172 > v33))
      {
        v44 = v16 - 29;
        if ((unint64_t)v33 < 4)
          v44 = 0;
        if (v44 + 64 < v171)
          v34 = v44 + 64;
        v172 = v44;
        v173 = v34;
        v177.location = v170 + v44;
        v177.length = v34 - v44;
        CFStringGetCharacters(theString, v177, buffer);
        v43 = v172;
      }
      v36 = v33 - v43;
      v35 = buffer;
LABEL_53:
      v37 = v35[v36];
    }
    if (v37 != 45)
      goto LABEL_73;
    v38 = v16 - 24;
    v39 = v171;
    if (v171 <= v16 - 24)
      goto LABEL_73;
    v40 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      v41 = v170 + v38;
      goto LABEL_60;
    }
    if (v169)
    {
      v42 = v169[v170 + v38];
    }
    else
    {
      if (v173 <= v38 || (v141 = v172, v172 > v38))
      {
        v142 = v16 - 28;
        if ((unint64_t)v38 < 4)
          v142 = 0;
        if (v142 + 64 < v171)
          v39 = v142 + 64;
        v172 = v142;
        v173 = v39;
        v179.location = v170 + v142;
        v179.length = v39 - v142;
        CFStringGetCharacters(theString, v179, buffer);
        v141 = v172;
      }
      v41 = v38 - v141;
      v40 = buffer;
LABEL_60:
      v42 = v40[v41];
    }
    if (v42 == 45)
    {
      MutableCopy = (CFMutableStringRef)v32;
    }
    else
    {
LABEL_73:
      v46 = CFGetAllocator((char *)this - 16);
      MutableCopy = CFStringCreateMutableCopy(v46, v18 + 2, v32);
      CFStringInsert(MutableCopy, 0, CFSTR("-"));
      CFStringInsert(MutableCopy, 0, CFSTR("-"));
      if (v32)
        CFRelease(v32);
    }
    *((_DWORD *)this + 48) |= 0x1000u;
    v47 = (const void *)*((_QWORD *)this + 29);
    if (v47)
      CFRelease(v47);
    v48 = CFGetAllocator((char *)this - 16);
    *((_QWORD *)this + 29) = CFStringCreateExternalRepresentation(v48, MutableCopy, 0x8000100u, 0);
    v49 = (const void *)*((_QWORD *)this + 30);
    if (v49)
      CFRelease(v49);
    v50 = CFGetAllocator((char *)this - 16);
    Mutable = CFStringCreateMutable(v50, 0);
    CFStringAppend(Mutable, CFSTR("\r\n"));
    CFStringAppend(Mutable, MutableCopy);
    a2 = v158;
    if (MutableCopy)
      CFRelease(MutableCopy);
    v52 = CFGetAllocator((char *)this - 16);
    *((_QWORD *)this + 30) = CFStringCreateExternalRepresentation(v52, Mutable, 0x8000100u, 0);
    if (Mutable)
      CFRelease(Mutable);
    v53 = *((_QWORD *)this + 34);
    if (v53)
      (*(void (**)(uint64_t))(*(_QWORD *)v53 + 128))(v53);
  }
LABEL_85:
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v6 = v155;
  HTTPMessage::removeHeaderFieldValue(v155, (const __CFString *)&unk_1EDCFCE80);
LABEL_88:
  CFRelease(v8);
LABEL_89:
  v54 = *((unsigned int *)this + 48);
  if ((v54 & 0x10000) != 0)
  {
    v55 = v54 & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    *((_DWORD *)this + 48) = v54 & 0xFFFEFFFF;
    *((_WORD *)this + 98) = WORD2(v55);
    if (*((_BYTE *)this + 40))
      HTTPProtocol::storeCredentials(this);
  }
  HTTPProtocol::updateCookieStoreDuringHeaderRead(this, a2);
  if (CFHTTPMessageGetResponseStatusCode(a2) != 421)
  {
    if (a2)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v56 = *((_BYTE *)a2 + 40) ? (os_unfair_lock_s *)v5 : 0;
    }
    else
    {
      v56 = 0;
    }
    HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(buffer, 0x1150F291u);
    v57 = (CFDictionaryRef *)HTTPMessage::headers(v56);
    HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(&v174, 0x1150F291u);
    v159 = a2;
    v58 = (__CFString *)HTTPHeaderDict::copyStringValue(v57, (const __CFAllocator *)*MEMORY[0x1E0C9AE00], (const HTTPHeaderKeyMixedValue *)&v174);
    v174 = &off_1E14E9A00;
    if (v175)
      CFRelease(v175);
    *(_QWORD *)buffer = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    if (v58)
    {
      v59 = *((_QWORD *)this + 34);
      if (v59)
      {
        v60 = (__SecTrust *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v59 + 120))(v59);
        v61 = v60;
        if (v60)
        {
          v62 = SecTrustCopyCertificateChain(v60);
          if (v62)
          {
            v149 = v62;
            v156 = v6;
            v63 = (void *)objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_alternativeServicesStorage");
            v64 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 432))(this);
            v65 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v64 + 72))(v64);
            v66 = *(void **)((*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 432))(this) + 48);
            v67 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 432))(this);
            v68 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v67 + 80))(v67);
            v69 = v63;
            v70 = v58;
            v148 = v65;
            v147 = v66;
            a2 = v159;
            v151 = v69;
            if (v69)
            {
              v71 = v68;
              v72 = strdup((const char *)-[__CFString UTF8String](objc_retainAutorelease(v70), "UTF8String"));
              theSeta = (CFCharacterSetRef)strlen(v72);
              *(_QWORD *)buffer = MEMORY[0x1E0C809B0];
              cf = (CFTypeRef)3221225472;
              v164 = ___Z25parseAndStoreAltSvcHeaderP33_NSHTTPAlternativeServicesStorageP8NSStringS2_S2_lPK9__CFArray_block_invoke;
              v165 = &__block_descriptor_40_e5_v8__0l;
              v166 = v72;
              if (!strcmp(v72, "clear"))
              {
                -[_NSHTTPAlternativeServicesStorage removeHTTPAlternativeServiceEntriesWithHost:port:](v69, "removeHTTPAlternativeServiceEntriesWithHost:port:", v148, v68);
                v4 = &HSTSCache::defaultStoreURL(void)::once;
              }
              else
              {
                v144 = v70;
                v145 = v61;
                v146 = v58;
                v73 = objc_alloc_init(_NSHTTPAlternativeServiceEntry);
                v153 = v5;
                if (theSeta != (CFCharacterSetRef)-1)
                {
                  v74 = 0;
                  v75 = 2;
                  v76 = v72;
                  while (1)
                  {
                    v77 = (char *)v74 + (_QWORD)v72;
                    v78 = *((unsigned __int8 *)v74 + (_QWORD)v72);
                    if (v78 != 61)
                      break;
                    *v77 = 0;
                    v79 = trimwhitespace(v76);
                    v76 = v77 + 1;
                    if (!strcmp(v79, "h3"))
                    {
                      -[_NSHTTPAlternativeServiceEntry setServiceType:](v73, "setServiceType:", 1);
                      -[_NSHTTPAlternativeServiceEntry setHost:](v73, "setHost:", v148);
                      -[_NSHTTPAlternativeServiceEntry setPort:](v73, "setPort:", v71);
                      -[_NSHTTPAlternativeServiceEntry setPartition:](v73, "setPartition:", v147);
                      v75 = 0;
                    }
                    else if (!strcmp(v79, "ma"))
                    {
                      v75 = 1;
                    }
                    else
                    {
                      v75 = 2;
                    }
LABEL_142:
                    v80 = v74 == theSeta;
                    v74 = (CFCharacterSetRef)((char *)v74 + 1);
                    if (v80)
                      goto LABEL_150;
                  }
                  v80 = v78 > 0x3B || ((1 << v78) & 0x800100000000001) == 0;
                  if (v80)
                    goto LABEL_142;
                  *v77 = 0;
                  v81 = trimwhitespace(v76);
                  v82 = v81;
                  if (v75 != 1)
                  {
                    if (!v75)
                    {
                      v83 = v73;
                      v84 = strlen(v82);
                      if (v84 >= 2 && *v82 == 34 && v82[v84 - 1] == 34)
                      {
                        if (v84 == -1)
                        {
LABEL_130:
                          LODWORD(v85) = 0;
                        }
                        else
                        {
                          v85 = 0;
                          while (v82[v85] != 58)
                          {
                            if (v84 + 1 == ++v85)
                              goto LABEL_130;
                          }
                        }
                        v86 = &v82[v85];
                        *v86 = 0;
                        v143 = v86 + 1;
                        v82[v84 - 1] = 0;
                        v88 = v82[1];
                        v87 = v82 + 1;
                        if (v88)
                        {
                          v89 = objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithUTF8String:", v87);
                        }
                        else
                        {
                          -[_NSHTTPAlternativeServiceEntry host](v83, "host");
                          v89 = objc_claimAutoreleasedReturnValue();
                        }
                        v93 = (void *)v89;
                        -[_NSHTTPAlternativeServiceEntry setAlternateHost:](v83, "setAlternateHost:", v89);

                        if (*v143)
                          v94 = atoi(v143);
                        else
                          v94 = -[_NSHTTPAlternativeServiceEntry port](v83, "port");
                        -[_NSHTTPAlternativeServiceEntry setAlternatePort:](v83, "setAlternatePort:", v94);
                      }
LABEL_138:

                    }
                    v76 = v77 + 1;
                    if (v78 == 44)
                    {
                      checkCertAndStore(v151, v73, v149);
                      v92 = objc_alloc_init(_NSHTTPAlternativeServiceEntry);

                      v75 = 2;
                      v73 = v92;
                    }
                    else
                    {
                      v75 = 2;
                    }
                    goto LABEL_142;
                  }
                  v90 = atoi(v81);
                  if (v90 >= 604800)
                    v91 = 604800;
                  else
                    v91 = v90;
                  objc_msgSend(MEMORY[0x1E0C99D68], "dateWithTimeIntervalSinceNow:", (double)v91);
                  v83 = (_NSHTTPAlternativeServiceEntry *)objc_claimAutoreleasedReturnValue();
                  -[_NSHTTPAlternativeServiceEntry setExpirationDate:](v73, "setExpirationDate:", v83);
                  goto LABEL_138;
                }
LABEL_150:
                checkCertAndStore(v151, v73, v149);

                a2 = v159;
                v5 = v153;
                v4 = &HSTSCache::defaultStoreURL(void)::once;
                v61 = v145;
                v58 = v146;
                v70 = v144;
              }
              v164((uint64_t)buffer);
            }

            CFRelease(v149);
            v6 = v156;
          }
          CFRelease(v61);
        }
      }
      CFRelease(v58);
    }
  }
  v95 = (void *)*((_QWORD *)this + 11);
  if (v95)
  {
    v96 = *(const void **)(objc_msgSend(*((id *)this + 11), "_inner") + 80);
    if (v96)
    {
      v97 = (const __CFArray *)CFRetain(v96);
      if (v97)
      {
        v98 = v97;
        if (a2)
        {
          if (v4[127] != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          if (*((_BYTE *)a2 + 40))
            v99 = v5;
          else
            v99 = 0;
        }
        else
        {
          v99 = 0;
        }
        HeaderFieldValue = HTTPMessage::copyLastHeaderFieldValue(v99, 0x11A272B3u);
        if (HeaderFieldValue)
        {
          v102 = HeaderFieldValue;
          v154 = v5;
          v157 = v6;
          v103 = v4;
          v104 = CFStringGetLength(HeaderFieldValue);
          MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v104, 0x201u);
          *(_QWORD *)buffer = 0;
          v106 = (UInt8 *)malloc_type_malloc(MaximumSizeForEncoding, 0x8A257BACuLL);
          v178.length = CFStringGetLength(v102);
          v178.location = 0;
          CFStringGetBytes(v102, v178, 0x201u, 0, 0, v106, MaximumSizeForEncoding, (CFIndex *)buffer);
          Count = CFArrayGetCount(v98);
          if (Count >= 1)
          {
            v108 = Count;
            v109 = 0;
            while (1)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v98, v109);
              v111 = CFGetAllocator(a2);
              v112 = CFStringCreateWithBytes(v111, v106, *(CFIndex *)buffer, ValueAtIndex, 0);
              if (v112)
                break;
              if (v108 == ++v109)
                goto LABEL_176;
            }
            v113 = v112;
            if (v103[127] != -1)
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
            HTTPMessage::setHeaderFieldStringValue(v157, 0x11A272B3u, v113);
            CFRelease(v113);
          }
LABEL_176:
          free(v106);
          CFRelease(v102);
          v5 = v154;
          v6 = v157;
          v4 = v103;
        }
        CFRelease(v98);
      }
    }
    v100 = _CFURLRequestCopyProtocolPropertyForKey(v95, CFSTR("kCFURLRequestDoNotDecodeData"));
  }
  else
  {
    v100 = 0;
  }
  if (v4[127] != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v114 = HTTPMessage::copyHeaderFieldValue(v6, 0x11B212BDu);
  if (!v114)
  {
    LODWORD(FilenameFromContentDispositionHeader) = 0;
    v119 = 2;
    goto LABEL_209;
  }
  v115 = v114;
  v116 = determineHTTPEncodingFromString(v114);
  if (v116 != 3)
  {
    LODWORD(FilenameFromContentDispositionHeader) = 0;
    if (v116 >= 5)
      v119 = v116;
    else
      v119 = 2;
    goto LABEL_204;
  }
  if (a2)
  {
    if (v4[127] != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*((_BYTE *)a2 + 40))
      v117 = v5;
    else
      v117 = 0;
  }
  else
  {
    v117 = 0;
  }
  v120 = HTTPMessage::copyLastHeaderFieldValue(v117, 0x11A272B3u);
  if (!v120)
    goto LABEL_200;
  v121 = v120;
  FilenameFromContentDispositionHeader = createFilenameFromContentDispositionHeader(v120);
  CFRelease(v121);
  if (!FilenameFromContentDispositionHeader)
  {
LABEL_201:
    v119 = 3;
    goto LABEL_204;
  }
  ExtensionFromFilename = createExtensionFromFilename(FilenameFromContentDispositionHeader);
  CFRelease(FilenameFromContentDispositionHeader);
  if (!ExtensionFromFilename)
  {
LABEL_200:
    LODWORD(FilenameFromContentDispositionHeader) = 0;
    goto LABEL_201;
  }
  if (CFStringCompare(ExtensionFromFilename, CFSTR("gz"), 1uLL)
    && CFStringCompare(ExtensionFromFilename, CFSTR("tgz"), 1uLL))
  {
    LODWORD(FilenameFromContentDispositionHeader) = 0;
    v119 = 3;
  }
  else
  {
    v119 = 2;
    LODWORD(FilenameFromContentDispositionHeader) = 1;
  }
  CFRelease(ExtensionFromFilename);
LABEL_204:
  CFRelease(v115);
  if (v119 == 2 || !v100)
  {
LABEL_209:
    v125 = 1;
    if (v100)
      goto LABEL_212;
    goto LABEL_213;
  }
  v123 = CFGetTypeID(v100);
  if (v123 == CFBooleanGetTypeID())
  {
    Value = CFBooleanGetValue(v100);
    v125 = Value == 0;
    if (Value)
      v119 = 2;
  }
  else
  {
    v125 = 1;
  }
LABEL_212:
  CFRelease(v100);
LABEL_213:
  *((_DWORD *)this + 50) = v119;

  if (v95)
  {
    CFGetAllocator((char *)this - 16);
    v126 = *(const void **)(objc_msgSend(v95, "_inner") + 8);
    CacheStoragePolicy = HTTPProtocol::getCacheStoragePolicy(this, (char *)a2);
    v128 = CFURLResponseCreateWithHTTPResponse(CacheStoragePolicy, v126, (uint64_t)a2, CacheStoragePolicy);
    *((_QWORD *)this + 26) = v128;
    if (v128)
      goto LABEL_215;
  }
  else
  {
    *((_QWORD *)this + 26) = 0;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    buffer[0] = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "updateForHeader(): Could not create the CFURLResponse for this header", (uint8_t *)buffer, 2u);
    v128 = (id)*((_QWORD *)this + 26);
    if (v128)
    {
LABEL_215:
      if (*((_QWORD *)this + 59))
      {
        v129 = objc_msgSend(v128, "_inner");
        v130 = (const void *)*((_QWORD *)this + 59);
        v131 = *(const void **)(v129 + 80);
        if (v131 != v130)
        {
          if (v131)
            CFRelease(v131);
          if (v130)
            v132 = CFRetain(v130);
          else
            v132 = 0;
          *(_QWORD *)(v129 + 80) = v132;
        }
      }
      v133 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
      if ((v133 & 0x200000000) != 0)
      {
        *(_BYTE *)(objc_msgSend(*((id *)this + 26), "_inner") + 97) = 1;
        v133 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
      }
      if ((v133 & 0x400000000) != 0)
        *(_BYTE *)(objc_msgSend(*((id *)this + 26), "_inner") + 96) = 1;
      if (v119 != 2)
      {
        v134 = objc_msgSend(*((id *)this + 26), "_inner");
        *(_QWORD *)(v134 + 32) = -1;
        v135 = *(_QWORD *)(v134 + 88);
        if (v135)
        {
          *(_WORD *)(v135 + 297) |= 0x100u;
          *(_WORD *)(*(_QWORD *)(v134 + 88) + 297) |= 0x2000u;
        }
      }
      if ((_DWORD)FilenameFromContentDispositionHeader)
        CFURLResponseSetMIMEType(*((void **)this + 26), (const __CFString *)&unk_1EDCFFB20);
      if (!v125)
      {
        v136 = *(_QWORD *)(objc_msgSend(*((id *)this + 26), "_inner") + 88);
        if (v136)
          *(_BYTE *)(v136 + 299) = (*(unsigned __int16 *)(v136 + 297) | (*(unsigned __int8 *)(v136 + 299) << 16) | 0x10000u) >> 16;
      }
      if (*((_QWORD *)this + 29))
      {
        v137 = *(_QWORD *)(objc_msgSend(*((id *)this + 26), "_inner") + 88);
        if (v137)
          *(_WORD *)(v137 + 297) |= 0x8000u;
      }
      if ((*((_DWORD *)this + 48) & 0x4000) != 0)
      {
        v138 = (const void *)*((_QWORD *)this + 50);
        if (v138)
        {
          v139 = objc_msgSend(*((id *)this + 26), "_inner");
          v140 = *(const void **)(v139 + 64);
          if (v140)
            CFRelease(v140);
          *(_QWORD *)(v139 + 64) = CFRetain(v138);
        }
      }
    }
  }
}

void sub_183F58C38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, CFTypeRef a13, CFTypeRef a14, void *a15, void *a16, CFTypeRef cf, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void (*a25)(uint64_t *))
{
  void *v25;

  a25(&a23);
  CFRelease(cf);
  CFRelease(a13);
  CFRelease(a14);
  _Unwind_Resume(a1);
}

void HTTPProtocol::updateCookieStoreDuringHeaderRead(HTTPProtocol *this, __CFHTTPMessage *a2)
{
  os_unfair_lock_s *v4;
  const __CFArray *v5;

  if (((*((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32)) & 0x1000000000) == 0)
  {
    if (a2)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (*((_BYTE *)a2 + 40))
        v4 = (os_unfair_lock_s *)((char *)a2 + 16);
      else
        v4 = 0;
    }
    else
    {
      v4 = 0;
    }
    v5 = HTTPResponseMessage::copyCookiesStrings(v4);
    HTTPProtocol::updateCookieStoreDuringHeaderRead(this, v5);
    if (v5)
      CFRelease(v5);
  }
}

void sub_183F58DE0(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPProtocol::getCacheStoragePolicy(HTTPProtocol *this, char *response)
{
  CFIndex ResponseStatusCode;
  uint64_t result;
  HTTPMessage *v6;
  const __CFString *v7;
  const __CFString *v8;
  int v9;
  void *v10;
  HTTPMessage *v11;
  const __CFString *v12;
  const __CFString *v13;
  uint64_t v14;
  const void *v15;
  _BOOL4 v16;

  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)response);
  result = 2;
  if (ResponseStatusCode <= 300)
  {
    if (ResponseStatusCode != 200 && ResponseStatusCode != 203)
      return result;
LABEL_9:
    if ((*((_DWORD *)this + 48) & 0x2000) != 0)
      return result;
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (response)
      v6 = (HTTPMessage *)(response + 16);
    else
      v6 = 0;
    v7 = HTTPMessage::copyHeaderFieldValue(v6, 0x1181B2A6u);
    v8 = v7;
    if (!v7 || CFStringFind(v7, (CFStringRef)&unk_1EDCFDE78, 1uLL).location == -1)
    {
      v10 = (void *)*((_QWORD *)this + 11);
      if (v10
        && (v11 = *(HTTPMessage **)(objc_msgSend(v10, "_inner") + 56)) != 0
        && (v12 = HTTPMessage::copyHeaderFieldValue(v11, 0x1181B2A6u)) != 0)
      {
        v13 = v12;
        if (CFStringFind(v12, (CFStringRef)&unk_1EDCFDE78, 1uLL).location != -1
          || (v9 = 1, CFStringFind(v13, (CFStringRef)&unk_1EDCFDE40, 1uLL).location != -1))
        {
          v9 = 0;
        }
        CFRelease(v13);
        if (!v8)
          goto LABEL_28;
      }
      else
      {
        v9 = 1;
        if (!v8)
          goto LABEL_28;
      }
    }
    else
    {
      v9 = 0;
    }
    CFRelease(v8);
LABEL_28:
    if (!v9)
      return 2;
    result = *((_QWORD *)this + 11);
    if (result)
    {
      v14 = *(_QWORD *)(objc_msgSend((id)result, "_inner") + 56);
      if (v14)
      {
        result = (uint64_t)CFHTTPMessageCopyRequestMethod((CFHTTPMessageRef)(v14 - 16));
        if (result)
        {
          v15 = (const void *)result;
          v16 = CFStringCompare((CFStringRef)result, CFSTR("PUT"), 1uLL) == kCFCompareEqualTo;
          CFRelease(v15);
          return (2 * v16);
        }
      }
      else
      {
        return 0;
      }
    }
    return result;
  }
  if ((unint64_t)(ResponseStatusCode - 301) <= 7
    && ((1 << (ResponseStatusCode - 45)) & 0x89) != 0
    || ResponseStatusCode == 410
    || ResponseStatusCode == 404)
  {
    goto LABEL_9;
  }
  return result;
}

char *trimwhitespace(char *a1)
{
  char *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  char *v5;
  char *v6;
  uint64_t v7;
  int v8;

  v1 = a1 - 1;
  v2 = MEMORY[0x1E0C80978];
  do
  {
    v3 = v1[1];
    if (v1[1] < 0)
      v4 = __maskrune(v3, 0x4000uLL);
    else
      v4 = *(_DWORD *)(v2 + 4 * v3 + 60) & 0x4000;
    ++v1;
  }
  while (v4);
  if (*v1)
  {
    v5 = &v1[strlen(v1) - 1];
    do
    {
      v6 = v5;
      if (v5 <= v1)
        break;
      v7 = *v5;
      v8 = *v5 < 0 ? __maskrune(v7, 0x4000uLL) : *(_DWORD *)(v2 + 4 * v7 + 60) & 0x4000;
      v5 = v6 - 1;
    }
    while (v8);
    v6[1] = 0;
  }
  return v1;
}

void sub_183F591A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolDidReceiveResponse(URLConnectionLoader_Classic *this, _CFURLResponse *a2)
{
  URLConnectionLoader_Classic::protocolDidReceiveResponse((URLConnectionLoader_Classic *)((char *)this - 56), a2);
}

CFArrayRef HTTPResponseMessage::copyCookiesStrings(os_unfair_lock_s *this)
{
  CFDictionaryRef *v2;
  CFArrayRef v3;
  void (**v5)(StringSerializable *__hidden);
  CFTypeRef cf;

  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(&v5, 0x141153BEu);
  v2 = (CFDictionaryRef *)HTTPMessage::headers(this);
  v3 = HTTPHeaderDict::copyHeaderKeyValues(v2, (const HTTPHeaderKeyMixedValue *)&v5);
  v5 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  return v3;
}

void sub_183F5922C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPResponseMessage::isValid(os_unfair_lock_s *this)
{
  CFDictionaryRef *v2;
  const __CFArray *v3;
  CFDictionaryRef *v4;
  const __CFArray *v5;
  CFDictionaryRef *v6;
  const __CFArray *v7;
  uint64_t v8;
  void (**v10)(StringSerializable *__hidden);
  CFTypeRef cf;

  v2 = (CFDictionaryRef *)HTTPMessage::headers(this);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v10, (CFStringRef)&unk_1EDCFD238);
  v3 = HTTPHeaderDict::copyHeaderKeyValues(v2, (const HTTPHeaderKeyMixedValue *)&v10);
  v10 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  if ((isArrayValuesSame(v3) & 1) != 0)
  {
    v4 = (CFDictionaryRef *)HTTPMessage::headers(this);
    HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v10, (CFStringRef)&unk_1EDCFCE80);
    v5 = HTTPHeaderDict::copyHeaderKeyValues(v4, (const HTTPHeaderKeyMixedValue *)&v10);
    v10 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    if ((isArrayValuesSame(v5) & 1) != 0)
    {
      v6 = (CFDictionaryRef *)HTTPMessage::headers(this);
      HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v10, (CFStringRef)&unk_1EDCFCDD8);
      v7 = HTTPHeaderDict::copyHeaderKeyValues(v6, (const HTTPHeaderKeyMixedValue *)&v10);
      v10 = &off_1E14E9A00;
      if (cf)
        CFRelease(cf);
      v8 = isArrayValuesSame(v7);
      if (v7)
        CFRelease(v7);
    }
    else
    {
      v8 = 0;
    }
    if (v5)
      CFRelease(v5);
  }
  else
  {
    v8 = 0;
  }
  if (v3)
    CFRelease(v3);
  return v8;
}

void sub_183F593A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  const void *v10;
  const void *v11;
  const void *v12;

  if (v12)
    CFRelease(v12);
  if (v11)
    CFRelease(v11);
  if (v10)
    CFRelease(v10);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPMessage::headers(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = this + 30;
  os_unfair_lock_lock(this + 30);
  v3 = *(_QWORD *)&this[26]._os_unfair_lock_opaque;
  if (!v3)
  {
    v3 = *(_QWORD *)&this[24]._os_unfair_lock_opaque;
    if (!v3)
    {
      if (HTTPHeaderDict::emptyDict(void)::sOnce != -1)
        dispatch_once(&HTTPHeaderDict::emptyDict(void)::sOnce, &__block_literal_global_3_14198);
      v3 = HTTPHeaderDict::emptyDict(void)::gEmpty;
    }
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

CFArrayRef HTTPHeaderDict::copyHeaderKeyValues(CFDictionaryRef *this, const HTTPHeaderKeyMixedValue *a2)
{
  CFDictionaryRef *v4;
  const void *v5;
  CFTypeRef v6;
  const __CFArray *Value;
  const __CFAllocator *v8;

  v4 = this - 2;
  CFGetAllocator(this - 2);
  v5 = (const void *)*((_QWORD *)a2 + 1);
  if (v5)
  {
    v6 = CFRetain(v5);
    Value = (const __CFArray *)CFDictionaryGetValue(this[1], v6);
    if (v6)
      CFRelease(v6);
    if (Value)
      goto LABEL_5;
  }
  else
  {
    Value = (const __CFArray *)CFDictionaryGetValue(this[1], 0);
    if (Value)
    {
LABEL_5:
      v8 = CFGetAllocator(v4);
      return CFArrayCreateCopy(v8, Value);
    }
  }
  return 0;
}

uint64_t isArrayValuesSame(const __CFArray *a1)
{
  uint64_t result;
  const void *ValueAtIndex;
  CFIndex v4;
  CFIndex Count;
  BOOL v6;
  const void *v7;

  if (!a1)
    return 1;
  if (CFArrayGetCount(a1) < 2)
    return 1;
  ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
  v4 = 1;
  do
  {
    Count = CFArrayGetCount(a1);
    v6 = v4 < Count;
    result = v4 >= Count;
    if (!v6)
      break;
    v7 = CFArrayGetValueAtIndex(a1, v4);
    result = CFEqual(ValueAtIndex, v7);
    ++v4;
  }
  while ((_DWORD)result);
  return result;
}

void URLConnectionLoader_Classic::protocolDidReceiveResponse(URLConnectionLoader_Classic *this, _CFURLResponse *a2)
{
  _CFURLResponse *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[6];
  _QWORD block[6];

  v4 = a2;
  v5 = MEMORY[0x1E0C809B0];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN27URLConnectionLoader_Classic26protocolDidReceiveResponseEP14_CFURLResponse_block_invoke;
  v8[3] = &__block_descriptor_48_e5_v8__0l;
  v8[4] = this;
  v8[5] = a2;
  v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v7 = *((_QWORD *)this + 5);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v8;
  block[5] = v6;
  dispatch_async(v7, block);
}

uint64_t HTTPProtocol::getUUID(HTTPProtocol *this)
{
  __CFHTTPMessage *v2;
  uint64_t v3;

  if (!*((_QWORD *)this + 44) && !(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this))
    return 0;
  v2 = (__CFHTTPMessage *)*((_QWORD *)this + 39);
  if (v2 && CFHTTPMessageGetResponseStatusCode(v2) == 407)
  {
    v3 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this);
    if (!v3)
      return 0;
  }
  else
  {
    v3 = *((_QWORD *)this + 44);
    if (!v3)
      return 0;
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  if (*(_DWORD *)(v3 + 48) == 2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v3 + 16) + 144))(v3 + 16);
  return 0;
}

HTTPProtocol *HTTPProtocol::updateCookieStoreDuringHeaderRead(HTTPProtocol *this, const __CFArray *a2)
{
  HTTPProtocol *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  _OWORD *v7;

  if (a2)
  {
    v3 = this;
    v4 = (void *)*((_QWORD *)this + 11);
    this = (HTTPProtocol *)objc_msgSend(*((id *)this + 10), "shouldHandleCookiesAndSchemeIsAppropriate");
    if ((_DWORD)this)
    {
      this = (HTTPProtocol *)objc_msgSend(v4, "_inner");
      if (*((_QWORD *)this + 1))
      {
        v5 = *(_QWORD *)(objc_msgSend(v4, "_inner") + 56);
        if (v5)
        {
          v6 = *(void **)(v5 + 192);
          if (v6)
          {
            v7 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 40, 0);
            *v7 = 0u;
            v7[1] = 0u;
            *((_QWORD *)v7 + 4) = 0;
            CFXCookieStorage::CFXCookieStorage((CFXCookieStorage *)v7, v6);
LABEL_9:
            (*(void (**)(_OWORD *, const __CFArray *, _QWORD))(*(_QWORD *)v7 + 64))(v7, a2, *((_QWORD *)v3 + 10));
            return (HTTPProtocol *)(*(uint64_t (**)(_OWORD *))(*(_QWORD *)v7 + 48))(v7);
          }
        }
        this = (HTTPProtocol *)*((_QWORD *)v3 + 10);
        if (this)
        {
          this = (HTTPProtocol *)-[HTTPProtocol _createXCookieStorage](this, "_createXCookieStorage");
          v7 = this;
          if (this)
            goto LABEL_9;
        }
      }
    }
  }
  return this;
}

uint64_t HTTPProtocol::proxyCreds(HTTPProtocol *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 46);
  if (v1 && (v2 = *(_QWORD *)(v1 + 40)) != 0)
    return *(_QWORD *)(v2 + 32);
  else
    return 0;
}

void HTTPProtocol::constructSSLCertContext(HTTPProtocol *this)
{
  const __CFString *v2;
  CFDictionaryRef v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const __CFNumber *v7;
  const __CFNumber *v8;
  uint64_t valuePtr;
  _QWORD v10[5];
  CFDictionaryRef v11;

  if (!*((_QWORD *)this + 50) && *((_QWORD *)this + 34))
  {
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3221225472;
    v10[2] = ___ZN12HTTPProtocol23constructSSLCertContextEv_block_invoke;
    v10[3] = &__block_descriptor_40_e22__v16__0____CFString__8l;
    v10[4] = this;
    createSSLCertificateContext(&v11, (uint64_t)v10);
    v3 = v11;
    if (v11)
      *((_QWORD *)this + 50) = CFRetain(v11);
    v4 = (void *)*((_QWORD *)this + 10);
    if (v4)
    {
      v5 = *((_QWORD *)this + 34);
      v6 = MetaNetStreamInfo::propertyNameToApplicableProperty(CFSTR("_kCFStreamPropertySSLNegotiatedCipher"), v2);
      v7 = (const __CFNumber *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 32))(v5, v6);
      v8 = v7;
      valuePtr = 0;
      if (v7)
      {
        if (CFNumberGetValue(v7, kCFNumberCFIndexType, &valuePtr))
          objc_msgSend(v4, "set_TLSNegotiatedCipherSuite:", (unsigned __int16)valuePtr);
        CFRelease(v8);
      }
    }
    if (v3)
      CFRelease(v3);
  }
}

void sub_183F5993C(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_183F599F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void HTTPConnectionAuthenticator::updateWithResponse(HTTPConnectionAuthenticator *this, HTTPResponseMessage *a2, void *a3)
{
  __CFHTTPMessage *v5;
  CFIndex ResponseStatusCode;
  int v7;
  uint64_t v8;
  CFIndex v9;
  int v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  HTTPAuthentication *v19;
  HTTPAuthentication *v20;
  _BOOL4 v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;

  if (this)
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  if (a2)
  {
    v5 = (HTTPResponseMessage *)((char *)a2 - 16);
    ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((HTTPResponseMessage *)((char *)a2 - 16));
    if (AuthenticationState::_isLikelyForProxy(this, a2))
      v7 = 2;
    else
      v7 = 1;
    if (AuthenticationState::_haveAuthenticationInfo((uint64_t)this, v7))
    {
      AuthenticationState::_authForType(&v30, (uint64_t)this, v7);
      v8 = v30;
      v9 = CFHTTPMessageGetResponseStatusCode(v5);
      if (v9 == 407 || v9 == 401)
        v10 = *(_DWORD *)(v8 + 24) == 2 ? 3 : 4;
      else
        v10 = 2;
      *(_DWORD *)(v8 + 24) = v10;
      v11 = v31;
      if (v31)
      {
        p_shared_owners = (unint64_t *)&v31->__shared_owners_;
        do
          v13 = __ldaxr(p_shared_owners);
        while (__stlxr(v13 - 1, p_shared_owners));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
    }
    if (ResponseStatusCode != 407)
    {
      if (ResponseStatusCode != 401)
        goto LABEL_50;
      v14 = *((_QWORD *)this + 16);
      if (v14)
      {
        v15 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
        if (v15)
        {
          v16 = (unint64_t *)&v15->__shared_owners_;
          do
            v17 = __ldxr(v16);
          while (__stxr(v17 + 1, v16));
          *(_DWORD *)(v14 + 24) = 2;
          do
            v18 = __ldaxr(v16);
          while (__stlxr(v18 - 1, v16));
          if (!v18)
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
        }
        else
        {
          *(_DWORD *)(v14 + 24) = 2;
        }
      }
    }
    if (AuthenticationState::_haveAuthenticationInfo((uint64_t)this, v7))
    {
      AuthenticationState::_authForType(&v30, (uint64_t)this, v7);
      v19 = *(HTTPAuthentication **)(v30 + 8);
      if (v19 && HTTPAuthentication::isConnectionBasedAuth(v19))
      {
        AuthenticationState::_authForType(&v28, (uint64_t)this, v7);
        v21 = (*(_DWORD *)(v28 + 24) & 0xFFFFFFFE) != 2
           || (v20 = *(HTTPAuthentication **)(v28 + 8)) == 0
           || HTTPAuthentication::isConnectionBasedAuth(v20) == 0;
        v22 = v29;
        if (v29)
        {
          v23 = (unint64_t *)&v29->__shared_owners_;
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
      }
      else
      {
        v21 = 0;
      }
      v25 = v31;
      if (v31)
      {
        v26 = (unint64_t *)&v31->__shared_owners_;
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      if (v21)
        AuthenticationState::_removeAuthenticationInfo((uint64_t)this, v7);
    }
  }
LABEL_50:
  if (this)
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
}

void sub_183F59C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  if (v11)
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
  _Unwind_Resume(a1);
}

uint64_t AuthenticationState::updateWithResponse(uint64_t this, HTTPResponseMessage *a2, void *a3)
{
  HTTPResponseMessage *v4;
  uint64_t v5;
  int v6;
  CFIndex v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  HTTPAuthentication *v11;
  HTTPAuthentication **v12;
  uint64_t v13;
  CFIndex ResponseStatusCode;
  _OWORD *Instance;
  HTTPAuthentication *v16;
  HTTPAuthentication *v17;
  uint64_t v18;
  __CFHTTPMessage *v19;
  uint64_t v20;
  const __CFString *v21;
  const void *v22;
  const __CFString *v23;
  __CFString *v24;
  const __CFUUID *v25;
  uint64_t v26;
  __CFHTTPMessage *v27;
  __CFHTTPMessage *v28;
  const __CFDictionary *v29;
  _BYTE *v30;
  const __CFDictionary *v31;
  _QWORD *Value;
  std::__shared_weak_count *v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  CFIndex v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  uint64_t v39;
  __CFString *v40;
  const __CFString *v41;
  uint8_t buf[16];

  v4 = a2;
  v5 = this;
  if (this)
  {
    pthread_mutex_lock((pthread_mutex_t *)(this + 8));
    if (!v4)
      return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
LABEL_5:
    if (AuthenticationState::_isLikelyForProxy((AuthenticationState *)v5, v4))
      v6 = 2;
    else
      v6 = 1;
    if (!AuthenticationState::_haveAuthenticationInfo(v5, v6))
    {
      v38 = 0;
      v39 = 0;
      AuthenticationState::_makeAuth(v5, v6, 0, 0);
    }
    AuthenticationState::_authForType(&v36, v5, v6);
    v7 = v36;
    v8 = *(_QWORD *)(v5 + 144);
    CFRetain((char *)v4 - 16);
    v9 = *(_QWORD *)(v7 + 32);
    *(_QWORD *)(v7 + 32) = v4;
    if (v9 && (CFRelease((CFTypeRef)(v9 - 16)), (v4 = *(HTTPResponseMessage **)(v7 + 32)) == 0))
    {
      v12 = (HTTPAuthentication **)(v7 + 8);
      v11 = *(HTTPAuthentication **)(v7 + 8);
      if (v11)
      {
        v13 = 0;
        goto LABEL_52;
      }
    }
    else
    {
      if (CFHTTPMessageGetResponseStatusCode((HTTPResponseMessage *)((char *)v4 - 16)) == 407
        && (*(_DWORD *)(v8 + 12) & 0xFFFFFFFE) != 2)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v10 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_183ECA000, v10, OS_LOG_TYPE_ERROR, "Received unexpected proxy response", buf, 2u);
        }
      }
      v12 = (HTTPAuthentication **)(v7 + 8);
      v11 = *(HTTPAuthentication **)(v7 + 8);
      v13 = *(_QWORD *)(v7 + 32);
      if (v11)
        goto LABEL_52;
      if (v13)
      {
        ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)(v13 - 16));
        if (ResponseStatusCode == 407 || ResponseStatusCode == 401)
        {
          CFGetAllocator((CFTypeRef)(*(_QWORD *)(v7 + 32) - 16));
          if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
            dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7917);
          Instance = (_OWORD *)_CFRuntimeCreateInstance();
          v16 = (HTTPAuthentication *)Instance;
          if (Instance)
          {
            Instance[1] = 0u;
            v16 = (HTTPAuthentication *)(Instance + 1);
            Instance[14] = 0u;
            Instance[15] = 0u;
            Instance[12] = 0u;
            Instance[13] = 0u;
            Instance[10] = 0u;
            Instance[11] = 0u;
            Instance[8] = 0u;
            Instance[9] = 0u;
            Instance[6] = 0u;
            Instance[7] = 0u;
            Instance[4] = 0u;
            Instance[5] = 0u;
            Instance[2] = 0u;
            Instance[3] = 0u;
          }
          HTTPAuthentication::HTTPAuthentication(v16);
          v17 = *v12;
          *v12 = v16;
          if (v17)
          {
            CFRelease((char *)v17 - 16);
            v16 = *v12;
          }
          *((_BYTE *)v16 + 161) = *(_BYTE *)(v8 + 8) & 1;
          v18 = *(_QWORD *)(v7 + 32);
          if (v18)
            v19 = (__CFHTTPMessage *)(v18 - 16);
          else
            v19 = 0;
          v20 = *(_QWORD *)(v7 + 16);
          if (!v20)
            goto LABEL_39;
          if (URLCredential::Class(void)::sOnce_URLCredential != -1)
            dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
          if (*(_DWORD *)(v20 + 48) == 2)
            v21 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)(v20 + 16) + 120))(v20 + 16);
          else
LABEL_39:
            v21 = 0;
          AuthenticationInfo::_getCredentialUserPrincipal((AuthenticationInfo *)buf, *(_QWORD *)(v7 + 16));
          v22 = *(const void **)buf;
          AuthenticationInfo::_getCredentialServicePrincipal((AuthenticationInfo *)&v41, *(_QWORD *)(v7 + 16));
          v23 = v41;
          AuthenticationInfo::_getCredentialUUID((AuthenticationInfo *)&v40, *(_QWORD *)(v7 + 16));
          v24 = v40;
          HTTPAuthentication::_initialize(v16, v19, v21, v22, v23, v40, v25);
          if (v24)
            CFRelease(v24);
          if (v23)
            CFRelease(v23);
          if (v22)
            CFRelease(v22);
          v26 = *(_QWORD *)(v7 + 32);
          if (v26)
            v27 = (__CFHTTPMessage *)(v26 - 16);
          else
            v27 = 0;
          HTTPAuthentication::initializeSchemes(*(HTTPAuthentication **)(v7 + 8), v27, 0);
          goto LABEL_62;
        }
        v11 = *v12;
        if (*v12)
        {
          v13 = *(_QWORD *)(v7 + 32);
LABEL_52:
          if (v13)
            v28 = (__CFHTTPMessage *)(v13 - 16);
          else
            v28 = 0;
          HTTPAuthentication::updateFromResponse(v11, v28, a3);
          v29 = (const __CFDictionary *)*((_QWORD *)*v12 + 19);
          if (!v29 || (v30 = CFDictionaryGetValue(v29, a3)) == 0 || !v30[24])
          {
            v31 = (const __CFDictionary *)*((_QWORD *)*v12 + 19);
            if (!v31 || (Value = CFDictionaryGetValue(v31, a3)) == 0 || *Value || !Value[2])
              AuthenticationInfo::updateCredentialStatus(v7, *(HTTPResponseMessage **)(v7 + 32));
          }
        }
      }
    }
LABEL_62:
    v33 = v37;
    if (v37)
    {
      p_shared_owners = (unint64_t *)&v37->__shared_owners_;
      do
        v35 = __ldaxr(p_shared_owners);
      while (__stlxr(v35 - 1, p_shared_owners));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  if (a2)
    goto LABEL_5;
  return this;
}

void sub_183F5A100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;
  const void *v12;
  const void *v13;
  const void *v14;

  if (v14)
  {
    CFRelease(v14);
    if (!v13)
    {
LABEL_3:
      if (!v12)
      {
LABEL_8:
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
        pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
        _Unwind_Resume(a1);
      }
LABEL_7:
      CFRelease(v12);
      goto LABEL_8;
    }
  }
  else if (!v13)
  {
    goto LABEL_3;
  }
  CFRelease(v13);
  if (!v12)
    goto LABEL_8;
  goto LABEL_7;
}

BOOL AuthenticationState::_haveAuthenticationInfo(uint64_t a1, int a2)
{
  _QWORD *v3;
  uint8_t v5[16];

  if (a2 == 1)
  {
    v3 = (_QWORD *)(a1 + 104);
  }
  else
  {
    if (!a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "assertion failure", v5, 2u);
    }
    v3 = (_QWORD *)(a1 + 128);
  }
  return *v3 != 0;
}

BOOL AuthenticationState::_isLikelyForProxy(AuthenticationState *this, HTTPResponseMessage *a2)
{
  __CFHTTPMessage *v3;
  _BOOL8 result;
  uint64_t v5;

  if (!a2)
    __assert_rtn("_isLikelyForProxy", "AuthenticationHelpers.cpp", 1077, "response");
  v3 = (HTTPResponseMessage *)((char *)a2 - 16);
  result = 1;
  if (CFHTTPMessageGetResponseStatusCode((HTTPResponseMessage *)((char *)a2 - 16)) != 407)
  {
    if (CFHTTPMessageGetResponseStatusCode(v3) == 401)
      return 0;
    v5 = *((_QWORD *)this + 16);
    if (!v5 || *(_DWORD *)(v5 + 24) == 2)
      return 0;
  }
  return result;
}

void AuthenticationState::_authForType(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint8_t v11[16];

  if (!a3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v11 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "assertion failure", v11, 2u);
  }
  v6 = a2 + 104;
  v7 = 128;
  if (a3 == 1)
    v7 = 104;
  else
    v6 = a2 + 128;
  v8 = *(_QWORD *)(v6 + 8);
  *a1 = *(_QWORD *)(a2 + v7);
  a1[1] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
}

void AuthenticationState::_makeAuth(uint64_t a1, int a2, char *a3, char *a4)
{
  unint64_t *v5;
  unint64_t v6;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  __int128 v14;

  if (a2 == 1)
  {
    if (a3)
    {
      if (a4)
      {
        v5 = (unint64_t *)(a4 + 8);
        do
          v6 = __ldxr(v5);
        while (__stxr(v6 + 1, v5));
      }
    }
    else
    {
      a4 = (char *)operator new(0x58uLL);
      *((_QWORD *)a4 + 1) = 0;
      *((_QWORD *)a4 + 2) = 0;
      *(_QWORD *)a4 = &off_1E14F0C20;
      *((_QWORD *)a4 + 3) = &off_1E14E9138;
      a3 = a4 + 24;
      *((_QWORD *)a4 + 4) = 0;
      *((_QWORD *)a4 + 5) = 0;
      *((_DWORD *)a4 + 12) = 0;
      *(_OWORD *)(a4 + 56) = 0u;
      *(_OWORD *)(a4 + 72) = 0u;
    }
    *(_QWORD *)&v14 = a3;
    *((_QWORD *)&v14 + 1) = a4;
    *(_DWORD *)(a1 + 96) = 1;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 104, &v14);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
    if (*((_QWORD *)&v14 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
LABEL_21:
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  else
  {
    if (a3)
    {
      if (a4)
      {
        v8 = (unint64_t *)(a4 + 8);
        do
          v9 = __ldxr(v8);
        while (__stxr(v9 + 1, v8));
      }
    }
    else
    {
      a4 = (char *)operator new(0x58uLL);
      *((_QWORD *)a4 + 1) = 0;
      *((_QWORD *)a4 + 2) = 0;
      *(_QWORD *)a4 = &off_1E14F0C20;
      *((_QWORD *)a4 + 3) = &off_1E14E9138;
      a3 = a4 + 24;
      *((_QWORD *)a4 + 4) = 0;
      *((_QWORD *)a4 + 5) = 0;
      *((_DWORD *)a4 + 12) = 0;
      *(_OWORD *)(a4 + 56) = 0u;
      *(_OWORD *)(a4 + 72) = 0u;
    }
    *(_QWORD *)&v14 = a3;
    *((_QWORD *)&v14 + 1) = a4;
    *(_DWORD *)(a1 + 120) = a2;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 128, &v14);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
    if (*((_QWORD *)&v14 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
      do
        v12 = __ldaxr(v13);
      while (__stlxr(v12 - 1, v13));
      goto LABEL_21;
    }
  }
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::getConnectionIdentifier(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 128))(*((_QWORD *)this + 1));
}

uint64_t HTTPTransaction::getConnectionIdentifier(HTTPTransaction *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (!v2)
    return 0;
  v3 = std::__shared_weak_count::lock(v2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = *((_QWORD *)this + 7);
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v4);
  }
  return v5;
}

void URLRequest::_setHTTPBodyParts(URLRequest *this, const __CFArray *a2, uint64_t a3)
{
  HTTPRequest *fHTTPRequest;
  unsigned int v7;
  const __CFAllocator *v8;
  CFIndex Count;
  CFMutableArrayRef MutableCopy;
  uint64_t v11;
  CFMutableArrayRef v12;
  CFTypeRef v13;
  void (**v14)(StringSerializable *__hidden);
  CFTypeRef cf;

  fHTTPRequest = this->fHTTPRequest;
  if (!fHTTPRequest)
  {
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v14);
    URLRequest::createHTTPRequest(this, (CFTypeRef *)&v14);
    v14 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    fHTTPRequest = this->fHTTPRequest;
  }
  v7 = 341980129;
  (*(void (**)(HTTPRequest *, _QWORD))(*(_QWORD *)fHTTPRequest + 64))(fHTTPRequest, 0);
  if (a2)
  {
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Count = CFArrayGetCount(a2);
    MutableCopy = CFArrayCreateMutableCopy(v8, Count, a2);
    v11 = FormContentLengthWithArray(a2) - a3;
    if (v11 < 0)
    {
      HTTPMessage::setHeaderFieldStringValue((HTTPMessage *)fHTTPRequest, 0x146233E1u, 0x1590F464u);
      v7 = 298963663;
    }
    else
    {
      HTTPMessage::setHeaderFieldScalarValue((HTTPMessage *)fHTTPRequest, v11);
    }
    HTTPMessage::removeHeaderFieldValue((HTTPMessage *)fHTTPRequest, v7);
    v12 = (CFMutableArrayRef)*((_QWORD *)fHTTPRequest + 26);
    if (v12 != MutableCopy)
    {
      if (v12)
        CFRelease(v12);
      if (MutableCopy)
        v13 = CFRetain(MutableCopy);
      else
        v13 = 0;
      *((_QWORD *)fHTTPRequest + 26) = v13;
    }
    if (MutableCopy)
      CFRelease(MutableCopy);
  }
  else
  {
    HTTPMessage::removeHeaderFieldValue((HTTPMessage *)fHTTPRequest, 0x146233E1u);
    HTTPMessage::removeHeaderFieldValue((HTTPMessage *)fHTTPRequest, 0x11D1D2CFu);
  }
}

void sub_183F5A6B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPMessage::setHeaderFieldScalarValue(HTTPMessage *a1, uint64_t a2)
{
  HTTPHeaderDict *v3;
  CFStringRef v4;
  _QWORD v5[2];
  void (**v6)(StringSerializable *__hidden);
  CFTypeRef cf;

  v3 = HTTPMessage::mutableHeaders(a1);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(&v6, 0x11D1D2CFu);
  v5[0] = &off_1E14ED488;
  v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%lld"), a2);
  v5[1] = v4;
  HTTPHeaderDict::setValue((uint64_t)v3, (uint64_t)&v6, (uint64_t)v5);
  if (v4)
    CFRelease(v4);
  v6 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
}

void sub_183F5A780(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf)
{
  const void *v14;

  if (v14)
    CFRelease(v14);
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void HTTPMessage::removeHeaderFieldValue(HTTPMessage *this, unsigned int a2)
{
  HTTPHeaderDict *v3;
  void (**v4)(StringSerializable *__hidden);
  CFTypeRef cf;

  v3 = HTTPMessage::mutableHeaders(this);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v4, a2);
  HTTPHeaderDict::removeValue((uint64_t)v3, (uint64_t)&v4);
  v4 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
}

void sub_183F5A814(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::_conn_no_more_reqests_after_this_one_connectionLost(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 104))(*((_QWORD *)this + 2));
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::getConnectionIdentifier(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 88))(*((_QWORD *)this + 2));
}

uint64_t HTTP2Stream::getConnectionIdentifier(HTTP2Stream *this)
{
  return *((_QWORD *)this + 8);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::_conn_no_more_reqests_after_this_one_connectionLost(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 144))(*((_QWORD *)this + 1));
}

void HTTPTransaction::_conn_no_more_requests_after_this_one_connectionLost(HTTPTransaction *this)
{
  _QWORD v1[5];

  v1[0] = MEMORY[0x1E0C809B0];
  v1[1] = 3221225472;
  v1[2] = ___ZN15HTTPTransaction52_conn_no_more_requests_after_this_one_connectionLostEv_block_invoke;
  v1[3] = &__block_descriptor_40_e5_v8__0l;
  v1[4] = this;
  ___ZN15HTTPTransaction52_conn_no_more_requests_after_this_one_connectionLostEv_block_invoke((uint64_t)v1);
}

void ___ZN15HTTPTransaction52_conn_no_more_requests_after_this_one_connectionLostEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  HTTPConnection *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  CFStreamError v8;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(std::__shared_weak_count **)(v1 + 64);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(HTTPConnection **)(v1 + 56);
      if (v5)
      {
        v8.domain = 4;
        *(_QWORD *)&v8.error = 4294967292;
        HTTPConnection::_onqueue_doNotAllowMoreRequests(v5, v8, 0);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_183F5A958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t determineHTTPEncodingFromString(const __CFString *a1)
{
  const __CFAllocator *v2;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFString *ValueAtIndex;
  const __CFString *CanonicalHTTPEncodingFromString;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  CFComparisonResult v12;
  uint64_t v13;

  if (CFStringFind(a1, CFSTR(","), 0).location == -1)
  {
    CanonicalHTTPEncodingFromString = createCanonicalHTTPEncodingFromString(a1);
    v13 = 2;
    if (!CanonicalHTTPEncodingFromString)
      return v13;
    goto LABEL_12;
  }
  v2 = CFGetAllocator(a1);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v2, a1, CFSTR(","));
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
  CanonicalHTTPEncodingFromString = createCanonicalHTTPEncodingFromString(ValueAtIndex);
  if (CanonicalHTTPEncodingFromString && (Count = CFArrayGetCount(ArrayBySeparatingStrings), Count >= 2))
  {
    v7 = Count;
    v8 = 1;
    while (1)
    {
      v9 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v8);
      v10 = createCanonicalHTTPEncodingFromString(v9);
      if (v10)
      {
        v11 = v10;
        v12 = CFStringCompare(CanonicalHTTPEncodingFromString, v10, 1uLL);
        CFRelease(v11);
        if (v12)
          break;
      }
      if (v7 == ++v8)
        goto LABEL_8;
    }
    v13 = 0;
  }
  else
  {
LABEL_8:
    v13 = 2;
  }
  CFRelease(ArrayBySeparatingStrings);
  if (CanonicalHTTPEncodingFromString)
  {
LABEL_12:
    v13 = 1;
    if (CFStringCompare(CanonicalHTTPEncodingFromString, (CFStringRef)&unk_1EDCFDBA0, 1uLL))
    {
      if (CFStringCompare(CanonicalHTTPEncodingFromString, (CFStringRef)&unk_1EDCFDCF0, 1uLL))
      {
        if (CFStringCompare(CanonicalHTTPEncodingFromString, CFSTR("gzip"), 1uLL)
          && CFStringCompare(CanonicalHTTPEncodingFromString, (CFStringRef)&unk_1EDCFE070, 1uLL))
        {
          if (CFStringCompare(CanonicalHTTPEncodingFromString, CFSTR("compress"), 1uLL)
            && CFStringCompare(CanonicalHTTPEncodingFromString, (CFStringRef)&unk_1EDCFE038, 1uLL))
          {
            if (CFStringCompare(CanonicalHTTPEncodingFromString, CFSTR("deflate"), 1uLL))
            {
              if (dyld_program_sdk_at_least()
                && CFStringCompare(CanonicalHTTPEncodingFromString, (CFStringRef)&unk_1EDCFDB30, 1uLL) == kCFCompareEqualTo)
              {
                v13 = 6;
              }
              else
              {
                v13 = 0;
              }
            }
            else
            {
              v13 = 5;
            }
          }
          else
          {
            v13 = 4;
          }
        }
        else
        {
          v13 = 3;
        }
      }
      else
      {
        v13 = 2;
      }
    }
    CFRelease(CanonicalHTTPEncodingFromString);
  }
  return v13;
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::_conn_no_more_reqests_after_this_one_connectionLost(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 112))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::getConnectionIdentifier(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 96))(*((_QWORD *)this + 1));
}

uint64_t HTTPResponseMessage::firstLineForSerialization(HTTPResponseMessage *this)
{
  uint64_t result;
  int v3;
  const __CFAllocator *v4;
  const __CFString *v5;
  UInt8 *v6;
  const char *v7;
  const __CFAllocator *allocator;
  uint64_t v9;
  void *ptr;
  UInt8 v11[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  result = *((_QWORD *)this + 36);
  if (result)
    return result;
  if (!*((_BYTE *)this + 160))
  {
    v3 = *((_DWORD *)this + 32);
    if (v3 != -1)
    {
      if (*((_QWORD *)this + 5))
      {
        if (*((_QWORD *)this + 17))
        {
          v4 = CFGetAllocator((char *)this - 16);
          v5 = (const __CFString *)*((_QWORD *)this + 17);
          allocator = v4;
          v9 = 1023;
          if (v5)
          {
            v6 = _CFStringGetOrCreateCString(v4, v5, v11, &v9, 0x201u);
          }
          else
          {
            v11[0] = 0;
            v9 = 0;
            v6 = v11;
          }
          ptr = v6;
          HTTPResponseMessage::setFirstLineWithDescription(this, (const char *)v6);
          if (ptr && v11 != ptr)
            CFAllocatorDeallocate(allocator, ptr);
          goto LABEL_3;
        }
        if (v3 > 299)
        {
          switch(v3)
          {
            case 400:
              v7 = "Bad Request";
              break;
            case 401:
              v7 = "Unauthorized";
              break;
            case 402:
              v7 = "Payment Required";
              break;
            case 403:
              v7 = "Forbidden";
              break;
            case 404:
              v7 = "Not Found";
              break;
            case 405:
              v7 = "Method Not Allowed";
              break;
            case 406:
              v7 = "Not Acceptable";
              break;
            case 407:
              v7 = "Proxy Authentication Required";
              break;
            case 408:
              v7 = "Request Time-out";
              break;
            case 409:
              v7 = "Conflict";
              break;
            case 410:
              v7 = "Gone";
              break;
            case 411:
              v7 = "Length Required";
              break;
            case 412:
              v7 = "Precondition Failed";
              break;
            case 413:
              v7 = "Request Entity Too Large";
              break;
            case 414:
              v7 = "Request-URI Too Large";
              break;
            case 415:
              v7 = "Unsupported Media Type";
              break;
            case 416:
              v7 = "Requested range not satisfiable";
              break;
            case 417:
              v7 = "Expectation Failed";
              break;
            default:
              switch(v3)
              {
                case 300:
                  goto LABEL_24;
                case 301:
                  v7 = "Moved Permanently";
                  break;
                case 302:
                  v7 = "Found";
                  break;
                case 303:
                  v7 = "See Other";
                  break;
                case 304:
                  v7 = "Not Modified";
                  break;
                case 305:
                  v7 = "Use Proxy";
                  break;
                case 306:
                  goto LABEL_36;
                case 307:
                  v7 = "Temporary Redirect";
                  break;
                case 308:
                  v7 = "Permanent Redirect";
                  break;
                default:
                  switch(v3)
                  {
                    case 500:
                      v7 = "Internal Server Error";
                      break;
                    case 501:
                      v7 = "Not Implemented";
                      break;
                    case 502:
                      v7 = "Bad Gateway";
                      break;
                    case 503:
                      v7 = "Service Unavailable";
                      break;
                    case 504:
                      v7 = "Gateway Time-out";
                      break;
                    case 505:
                      v7 = "HTTP Version not supported";
                      break;
                    default:
                      goto LABEL_36;
                  }
                  break;
              }
              break;
          }
          goto LABEL_73;
        }
        v7 = "OK";
        if (v3 > 199)
        {
          switch(v3)
          {
            case 200:
              goto LABEL_73;
            case 201:
              v7 = "Created";
              break;
            case 202:
              v7 = "Accepted";
              break;
            case 203:
              v7 = "Non-Authoritative Information";
              break;
            case 204:
              v7 = "No Content";
              break;
            case 205:
              v7 = "Reset Content";
              break;
            case 206:
              v7 = "Partial Content";
              break;
            case 207:
              v7 = "Multi-Status";
              break;
            default:
              goto LABEL_36;
          }
          goto LABEL_73;
        }
        if (v3 != 100)
        {
          if (v3 == 101)
          {
            v7 = "Switching Protocols";
LABEL_73:
            HTTPResponseMessage::setFirstLineWithDescription(this, v7);
            goto LABEL_3;
          }
LABEL_36:
          if (v3 >= 200)
          {
            if (v3 >= 0x12C)
            {
              if (v3 < 0x190)
              {
LABEL_24:
                v7 = "Multiple Choices";
              }
              else if (v3 >= 0x1F4)
              {
                v7 = "Internal Server Error";
              }
              else
              {
                v7 = "Bad Request";
              }
            }
            else
            {
              v7 = "OK";
            }
            goto LABEL_73;
          }
        }
        v7 = "Continue";
        goto LABEL_73;
      }
    }
  }
LABEL_3:
  result = *((_QWORD *)this + 36);
  if (!result)
  {
    if (*((_BYTE *)this + 160))
      return (uint64_t)this + 160;
    else
      return 0;
  }
  return result;
}

void sub_183F5AFB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  _Unwind_Resume(exception_object);
}

void HTTPResponseMessage::setFirstLineWithDescription(HTTPResponseMessage *this, const char *a2)
{
  StringSerializable *v4;
  const __CFString *v5;
  unsigned __int8 *v6;
  size_t v7;
  uint64_t v8;
  int v9;
  int v10;
  char v11[4];
  unsigned __int8 __dst[128];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (HTTPResponseMessage *)((char *)this + 32);
  v5 = StringSerializable::maximumSerializedLength(*((const __CFString **)this + 5));
  if ((unint64_t)v5 >= 0x80)
    v6 = (unsigned __int8 *)malloc_type_malloc((size_t)v5, 0xADFC5EC9uLL);
  else
    v6 = __dst;
  v7 = StringSerializable::serialize(v4, v6);
  v8 = 0;
  v9 = *((_DWORD *)this + 32);
  v10 = 100;
  do
  {
    v11[v8++] = (char)(v9 / v10) % 10 + 48;
    v10 /= 10;
  }
  while (v8 != 3);
  v11[3] = 0;
  if (v7 + strlen(a2) - 121 > 0xFFFFFFFFFFFFFF7FLL)
    snprintf((char *)this + 160, 0x80uLL, "%.*s %s %s", v7, (const char *)v6, v11, a2);
  else
    asprintf((char **)this + 36, "%.*s %s %s", v7, (const char *)v6, v11, a2);
  if (v6 != __dst)
    free(v6);
}

uint64_t HTTP3Stream::getConnectionIdentifier(HTTP3Stream *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 7);
  if (!v2)
    return 0;
  v3 = std::__shared_weak_count::lock(v2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = *((_QWORD *)this + 6);
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v4);
    if (v5)
      return v5;
    return 0;
  }
  if (!v5)
    return 0;
  return v5;
}

CFStringRef createCanonicalHTTPEncodingFromString(const __CFString *a1)
{
  CFIndex Length;
  const __CFCharacterSet *Predefined;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v6;
  uint64_t v7;
  CFIndex v8;
  uint64_t v9;
  CFIndex v10;
  uint64_t v11;
  CFIndex v12;
  UniChar v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFIndex v19;
  int IsCharacterMember;
  uint64_t v21;
  CFIndex v22;
  CFIndex v23;
  UniChar *v24;
  CFIndex v25;
  UniChar v26;
  int64_t v28;
  CFIndex v29;
  UniChar *v30;
  int64_t v31;
  UniChar v32;
  uint64_t v33;
  CFIndex v34;
  const __CFAllocator *v35;
  uint64_t v36;
  CFIndex v37;
  UniChar v38[64];
  CFStringRef theString;
  UniChar *v40;
  const char *v41;
  uint64_t v42;
  CFIndex v43;
  uint64_t v44;
  uint64_t v45;
  CFRange v46;
  CFRange v47;
  CFRange v48;
  CFRange v49;

  Length = CFStringGetLength(a1);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  theString = a1;
  v42 = 0;
  v43 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v40 = (UniChar *)CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v44 = 0;
  v45 = 0;
  v41 = CStringPtr;
  if (Length < 1)
    return 0;
  v6 = 0;
  v7 = 0;
  v8 = -1;
  v9 = 64;
  v10 = -1;
  while (1)
  {
    v11 = (unint64_t)v7 >= 4 ? 4 : v7;
    v12 = v43;
    if (v43 > v7)
      break;
    v13 = 0;
LABEL_25:
    IsCharacterMember = CFCharacterSetIsCharacterMember(Predefined, v13);
    if (v8 == -1)
      v21 = 1;
    else
      v21 = v7 - v8 + 1;
    if (v8 == -1)
      v22 = v7;
    else
      v22 = v8;
    if (!IsCharacterMember)
    {
      v10 = v21;
      v8 = v22;
    }
    ++v7;
    --v6;
    ++v9;
    if (Length == v7)
      goto LABEL_34;
  }
  if (v40)
  {
    v13 = v40[v7 + v42];
  }
  else if (v41)
  {
    v13 = v41[v42 + v7];
  }
  else
  {
    v14 = v44;
    if (v45 <= v7 || v44 > v7)
    {
      v16 = v11 + v6;
      v17 = v9 - v11;
      v18 = v7 - v11;
      v19 = v18 + 64;
      if (v18 + 64 >= v43)
        v19 = v43;
      v44 = v18;
      v45 = v19;
      if (v43 >= v17)
        v12 = v17;
      v46.length = v12 + v16;
      v46.location = v18 + v42;
      CFStringGetCharacters(theString, v46, v38);
      v14 = v44;
    }
    v13 = v38[v7 - v14];
  }
  if (v13 != 59)
    goto LABEL_25;
LABEL_34:
  if (v8 == -1)
    return 0;
  if (v10 >= 2 && (v8 & 0x8000000000000000) == 0)
  {
    v23 = v43;
    if (v43 > v8)
    {
      v24 = v40;
      if (v40)
      {
        v25 = v42 + v8;
        goto LABEL_40;
      }
      if (v41)
      {
        v26 = v41[v42 + v8];
      }
      else
      {
        if (v45 <= v8 || (v33 = v44, v44 > v8))
        {
          v34 = v8 - 4;
          if ((unint64_t)v8 < 4)
            v34 = 0;
          if (v34 + 64 < v43)
            v23 = v34 + 64;
          v44 = v34;
          v45 = v23;
          v47.location = v42 + v34;
          v47.length = v23 - v34;
          CFStringGetCharacters(theString, v47, v38);
          v33 = v44;
        }
        v25 = v8 - v33;
        v24 = v38;
LABEL_40:
        v26 = v24[v25];
      }
      if (v26 == 120)
      {
        v28 = v8 + 1;
        v29 = v43;
        if (v43 > v8 + 1)
        {
          v30 = v40;
          if (v40)
          {
            v31 = v42 + v28;
            goto LABEL_48;
          }
          if (v41)
          {
            v32 = v41[v42 + v28];
          }
          else
          {
            if (v45 <= v28 || (v36 = v44, v44 > v28))
            {
              v37 = v8 - 3;
              if ((unint64_t)v28 < 4)
                v37 = 0;
              if (v37 + 64 < v43)
                v29 = v37 + 64;
              v44 = v37;
              v45 = v29;
              v48.location = v42 + v37;
              v48.length = v29 - v37;
              CFStringGetCharacters(theString, v48, v38);
              v36 = v44;
            }
            v31 = v28 - v36;
            v30 = v38;
LABEL_48:
            v32 = v30[v31];
          }
          if (v32 == 45)
          {
            v8 += 2;
            v10 -= 2;
          }
        }
      }
    }
  }
  v35 = CFGetAllocator(a1);
  v49.location = v8;
  v49.length = v10;
  return CFStringCreateWithSubstring(v35, a1, v49);
}

void ___Z25parseAndStoreAltSvcHeaderP33_NSHTTPAlternativeServicesStorageP8NSStringS2_S2_lPK9__CFArray_block_invoke(uint64_t a1)
{
  free(*(void **)(a1 + 32));
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::copyTrust(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1));
}

HTTP3Stream *HTTP3Stream::copyTrust(std::__shared_weak_count **this)
{
  HTTP3Stream *v1;
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;

  v1 = (HTTP3Stream *)this;
  v2 = this[7];
  if (!v2)
    return 0;
  v3 = std::__shared_weak_count::lock(v2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = *((_QWORD *)v1 + 6);
  if (v5)
  {
    v6 = *(_QWORD *)(v5 + 1008);
    if (v6)
      v1 = (HTTP3Stream *)(*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v6 + 216))(v6, &unk_1EDCFC048);
    else
      v1 = 0;
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (v10)
      return v1;
  }
  else
  {
    v7 = (unint64_t *)&v3->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (v8)
      return 0;
  }
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  if (!v5)
    return 0;
  return v1;
}

void sub_183F5B5C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t CFCachedURLResponseCreateWithDataArray(uint64_t a1, const void *a2, const void *a3, const void *a4, int a5)
{
  uint64_t Instance;
  uint64_t v10;
  CFTypeRef v11;
  const void *ValueAtIndex;
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2382;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = _CachedURLResponseRegisterClass;
  if (_CFCachedURLResponseClassRegistration != -1)
    dispatch_once(&_CFCachedURLResponseClassRegistration, block);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v10 = operator new();
    *(_QWORD *)v10 = &off_1E14EC248;
    v11 = CFRetain(a2);
    *(_QWORD *)(v10 + 40) = 0;
    *(_QWORD *)(v10 + 32) = v11;
    *(_QWORD *)(v10 + 48) = 0;
    *(_QWORD *)(v10 + 72) = 0;
    *(_QWORD *)(v10 + 80) = 0;
    *(_QWORD *)(v10 + 64) = 0;
    *(_DWORD *)(v10 + 88) = 0;
    *(_QWORD *)(v10 + 104) = 0;
    *(_QWORD *)(v10 + 112) = 0;
    *(_QWORD *)(v10 + 96) = 0;
    if (a4)
      *(_QWORD *)(v10 + 40) = CFRetain(a4);
    if (a3)
    {
      *(_QWORD *)(v10 + 80) = CFRetain(a3);
      if (CFArrayGetCount((CFArrayRef)a3) == 1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, 0);
        if (ValueAtIndex)
          *(_QWORD *)(v10 + 72) = CFRetain(ValueAtIndex);
      }
    }
    *(_DWORD *)(v10 + 56) = a5;
    *(_BYTE *)(v10 + 120) = 0;
    *(_QWORD *)(v10 + 128) = 0;
    *(_QWORD *)(v10 + 8) = 0;
    *(_QWORD *)(v10 + 16) = 0;
    __CFCachedURLResponse::Encode((__CFCachedURLResponse *)v10);
    *(_QWORD *)(Instance + 16) = v10;
  }
  return Instance;
}

void sub_183F5B9E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10E1C40D8EAFA61);
  _Unwind_Resume(a1);
}

uint64_t HTTPProtocol::attemptRedirection(HTTPProtocol *this, __CFHTTPMessage *a2)
{
  uint64_t v4;
  HTTPMessage *v6;
  const __CFString *HeaderFieldValue;
  const __CFString *v8;
  const __CFAllocator *v9;
  const __CFString *v10;
  int v11;
  void *v12;
  uint64_t v13;
  char *v14;
  int v15;
  __int16 v16;
  void *v17;
  const __CFAllocator *v18;
  const __CFURL *v19;
  const __CFURL *v20;
  CFIndex Length;
  UInt8 *v22;
  CFStringEncoding v23;
  const __CFURL *v24;
  const __CFAllocator *v25;
  CFURLRef v26;
  const __CFURL *v27;
  const __CFString *v28;
  const __CFString *v29;
  void *v30;
  CFIndex ResponseStatusCode;
  const __CFString *v32;
  const __CFString *v33;
  CFComparisonResult v34;
  uint64_t v35;
  const __CFString *v36;
  const __CFString *v37;
  char v38;
  _BOOL4 v39;
  uint64_t v40;
  uint64_t v41;
  const void *v42;
  uint64_t v43;
  CFTypeRef v44;
  const void *v45;
  uint64_t v46;
  id v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  __int16 v53;
  void *v54;
  const __CFBoolean *v55;
  const __CFBoolean *v56;
  double v57;
  double v58;
  CFURLRef relativeURL;
  uint8_t buf[16];

  if ((*(unsigned int (**)(HTTPProtocol *))(*(_QWORD *)this + 520))(this) || !*((_QWORD *)this + 11))
    return 0;
  relativeURL = 0;
  if (a2)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*((_BYTE *)a2 + 40))
      v6 = (__CFHTTPMessage *)((char *)a2 + 16);
    else
      v6 = 0;
  }
  else
  {
    v6 = 0;
  }
  HeaderFieldValue = HTTPMessage::copyLastHeaderFieldValue(v6, 0x12E1132Au);
  if (!HeaderFieldValue)
  {
LABEL_18:
    v15 = *((_DWORD *)this + 48);
    v14 = (char *)this + 192;
    v16 = *((_WORD *)v14 + 2);
    *(_DWORD *)v14 = v15 & 0xFFFFFFFB;
    *((_WORD *)v14 + 2) = v16;
    return 1;
  }
  v8 = HeaderFieldValue;
  if (!CFStringGetLength(HeaderFieldValue))
  {
    CFRelease(v8);
    goto LABEL_18;
  }
  v9 = CFGetAllocator((char *)this - 16);
  v10 = CFURLCreateStringByAddingPercentEscapes(v9, v8, CFSTR("%#?:;/@=&[]"), 0, 0x201u);
  CFRelease(v8);
  if (!v10)
    goto LABEL_31;
  v11 = dyld_program_sdk_at_least();
  v12 = (void *)*((_QWORD *)this + 10);
  v13 = v11 ? objc_msgSend(v12, "currentRequest") : objc_msgSend(v12, "originalRequest");
  v17 = (void *)v13;
  v18 = CFGetAllocator((char *)this - 16);
  v19 = CFURLCreateWithString(v18, v10, *(CFURLRef *)(objc_msgSend(*((id *)this + 11), "_inner") + 8));
  if (v19)
  {
    v20 = v19;
    relativeURL = CFURLCopyAbsoluteURL(v19);
    _ApplyOriginalComponents(v17, (CFTypeRef *)&relativeURL);
    CFRelease(v20);
  }
  else
  {
    Length = CFStringGetLength(v10);
    v22 = (UInt8 *)malloc_type_malloc(Length + 1, 0xA9011058uLL);
    v23 = 513;
    if (CFStringGetCString(v10, (char *)v22, Length + 1, 0x201u)
      || (v23 = 134217984, CFStringGetCString(v10, (char *)v22, Length + 1, 0x8000100u)))
    {
      v24 = *(const __CFURL **)(objc_msgSend(*((id *)this + 11), "_inner") + 8);
      v25 = CFGetAllocator((char *)this - 16);
      relativeURL = CFURLCreateAbsoluteURLWithBytes(v25, v22, Length, v23, v24, 0);
      _ApplyOriginalComponents(v17, (CFTypeRef *)&relativeURL);
    }
    free(v22);
  }
  CFRelease(v10);
  v26 = relativeURL;
  if (!relativeURL)
  {
LABEL_31:
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC0ELL);
    HTTPProtocol::destroyReadStream(this);
    return 0;
  }
  v27 = CFURLCopyAbsoluteURL(relativeURL);
  v28 = CFURLCopyScheme(v27);
  v29 = v28;
  if (v28 && CFStringCompare(v28, CFSTR("file"), 1uLL) == kCFCompareEqualTo)
  {
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFBB2);
    v39 = 0;
  }
  else
  {
    CFGetAllocator((char *)this - 16);
    v30 = (void *)objc_msgSend(*((id *)this + 11), "mutableCopy");
    CFURLRequestSetURL(v30, v27);
    ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(a2);
    if (ResponseStatusCode == 303
      || (unint64_t)(ResponseStatusCode - 301) <= 1
      && (v32 = (const __CFString *)CFURLRequestCopyHTTPRequestMethod(v30), (v33 = v32) != 0)
      && (v34 = CFStringCompare(v32, CFSTR("POST"), 1uLL), CFRelease(v33), v34 == kCFCompareEqualTo))
    {
      CFURLRequestSetHTTPRequestMethod(v30, CFSTR("GET"));
      CFURLRequestSetHTTPRequestBody(v30, 0);
      URLRequest::_setHTTPBodyParts((URLRequest *)objc_msgSend(v30, "_inner"), 0, 0);
      CFURLRequestSetHTTPRequestBodyStream(v30, 0);
      CFURLRequestSetHTTPHeaderFieldValue(v30, (const __CFString *)&unk_1EDCFCE80, 0);
      CFURLRequestSetHTTPHeaderFieldValue(v30, CFSTR("Content-Type"), 0);
    }
    if (!haveTheSameOrigin(*(NSURL **)(objc_msgSend(*((id *)this + 11), "_inner") + 8), (NSURL *)v27))
      CFURLRequestSetHTTPHeaderFieldValue(v30, (const __CFString *)&unk_1EDCFD2E0, 0);
    CFURLRequestSetHTTPHeaderFieldValue(v30, (const __CFString *)&unk_1EDCFCD30, 0);
    CFURLRequestSetHTTPHeaderFieldValue(v30, (const __CFString *)&unk_1EDCFD3F8, 0);
    v35 = *(_QWORD *)(objc_msgSend(*((id *)this + 11), "_inner") + 56);
    if (v35 && *(_BYTE *)(v35 + 216))
    {
      v36 = *(const __CFString **)(v35 + 152);
      v38 = v36
         && (CFStringCompare(v36, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo
          || ((v37 = *(const __CFString **)(v35 + 152)) != 0
           || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
           && (*(_WORD *)buf = 0,
               _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (v37 = *(const __CFString **)(v35 + 152)) != 0))&& CFStringCompare(v37, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo)|| *(_BYTE *)(v35 + 218) != 0;
    }
    else
    {
      v38 = 0;
    }
    CFURLRequestSetShouldPipelineHTTP(v30, v38, 1);
    v40 = *(_QWORD *)(objc_msgSend(*((id *)this + 11), "_inner") + 88);
    *(_QWORD *)(objc_msgSend(v30, "_inner") + 88) = v40;
    v41 = *((_QWORD *)this + 10);
    if (v41)
    {
      v42 = (const void *)objc_msgSend(*((id *)this + 10), "_copyHSTSPolicy");
      v43 = objc_msgSend(v30, "_inner");
      if (v42)
        v44 = CFRetain(v42);
      else
        v44 = 0;
      v45 = *(const void **)(v43 + 200);
      *(_QWORD *)(v43 + 200) = v44;
      if (v45)
        CFRelease(v45);
      if (v42)
        CFRelease(v42);
    }
    HTTPProtocol::updateForHeader(this, a2);
    v46 = objc_msgSend(v30, "_inner");
    *(_WORD *)(v46 + 64) &= ~2u;
    v47 = -[NSURLRequest _initWithCFURLRequest:]([NSURLRequest alloc], "_initWithCFURLRequest:", v30);
    v48 = -[__NSURLSessionLocal _protocolClassForRequest:](*((_QWORD *)this + 93), (uint64_t)v47);
    if (v41 && v48)
      v47 = (id)objc_msgSend(v48, "canonicalRequestForRequest:task:", v47, v41);
    v49 = *((_QWORD *)this + 12);
    if (v49)
    {
      v50 = *((_QWORD *)this + 26);
      v51 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v49 + 16))(*((_QWORD *)this + 12));
      v52 = (void *)MEMORY[0x186DB8C8C](v51);
      (*(void (**)(_QWORD, id, uint64_t))(**((_QWORD **)this + 12) + 40))(*((_QWORD *)this + 12), v47, v50);
      objc_autoreleasePoolPop(v52);
      (*(void (**)(uint64_t))(*(_QWORD *)v49 + 24))(v49);
    }
    v53 = *((_WORD *)this + 98);
    *((_DWORD *)this + 48) = *((_DWORD *)this + 48);
    *((_WORD *)this + 98) = v53 | 0x10;
    v39 = *((_QWORD *)this + 34) != 0;
    if (v30)
      CFRelease(v30);
  }
  if (v27)
    CFRelease(v27);
  if (v29)
    CFRelease(v29);
  if (v39)
  {
    v54 = (void *)*((_QWORD *)this + 11);
    if (v54)
    {
      v55 = (const __CFBoolean *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 34) + 32))(*((_QWORD *)this + 34), 32);
      if (v55)
      {
        v56 = v55;
        if (!CFBooleanGetValue(v55))
        {
          objc_msgSend(v54, "_inner");
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          __CFNReportRedirectSymptom(v57);
        }
        CFRelease(v56);
      }
      else
      {
        objc_msgSend(v54, "_inner");
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        __CFNReportRedirectSymptom(v58);
      }
    }
    v4 = 1;
  }
  else
  {
    HTTPProtocol::destroyReadStream(this);
    v4 = 0;
  }
  CFRelease(v26);
  return v4;
}

void sub_183F5C17C(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

void __CFNReportRedirectSymptom(double a1)
{
  const __CFURL *v1;
  const __CFURL *v2;
  uint64_t v3;
  BOOL v4;
  const __CFURL *v5;
  CFStringRef v6;
  const __CFString *v7;
  const __CFString *v8;
  const char *CString;
  uint64_t v10;
  double v11;
  const char *v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  _QWORD v18[19];
  _QWORD v19[20];
  CFRange v20;

  v19[19] = *MEMORY[0x1E0C80C00];
  gotLoadHelper_x8__symptom_framework_init(a1);
  if (*(_QWORD *)(v3 + 304))
    v4 = v1 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v5 = v2;
    v6 = CFURLCopyNetLocation(v1);
    v7 = CFURLCopyNetLocation(v5);
    v8 = v7;
    if (v6 && v7)
    {
      if (CFStringCompare(v6, v7, 1uLL))
      {
        v20.length = CFStringGetLength(v8);
        v20.location = 0;
        if (!CFStringFindWithOptions(v8, v6, v20, 1uLL, 0))
        {
          v19[0] = &off_1E14E4818;
          v19[1] = CFRetain(v6);
          v19[2] = 0;
          v19[3] = 0;
          v18[0] = &off_1E14E4818;
          v18[1] = CFRetain(v8);
          v18[2] = 0;
          v18[3] = 0;
          CString = (const char *)AutoString::getCString((AutoString *)v19);
          v10 = AutoString::getCString((AutoString *)v18);
          if (CString)
          {
            v12 = (const char *)v10;
            if (v10)
            {
              if (getSymptomHandle(void)::sInitSymptomFramework != -1)
                dispatch_once(&getSymptomHandle(void)::sInitSymptomFramework, &__block_literal_global_17446);
              symptom_new_delayInitStub(v11);
              getpid();
              symptom_set_qualifier_delayInitStub(v13);
              symptom_set_qualifier_delayInitStub(v14);
              strlen(CString);
              symptom_set_additional_digest_delayInitStub(v15);
              strlen(v12);
              symptom_set_additional_digest_delayInitStub(v16);
              symptom_send_delayInitStub(v17);
            }
          }
          AutoString::~AutoString((AutoString *)v18);
          AutoString::~AutoString((AutoString *)v19);
        }
      }
    }
    else if (!v6)
    {
      goto LABEL_17;
    }
    CFRelease(v6);
LABEL_17:
    if (v8)
      CFRelease(v8);
  }
}

void sub_183F5C3B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  AutoString::~AutoString((AutoString *)&a10);
  AutoString::~AutoString((AutoString *)&a29);
  _Unwind_Resume(a1);
}

uint64_t AutoString::getCString(AutoString *this)
{
  uint64_t result;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  CFIndex v5;
  char *v6;
  const void *v7;

  result = *((_QWORD *)this + 2);
  if (!result)
  {
    Length = CFStringGetLength(*((CFStringRef *)this + 1));
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    v5 = MaximumSizeForEncoding + 1;
    if (MaximumSizeForEncoding > 118)
    {
      v7 = CFGetAllocator(*((CFTypeRef *)this + 1));
      if (v7)
        v7 = CFRetain(v7);
      *((_QWORD *)this + 3) = v7;
      v6 = (char *)CFAllocatorAllocate((CFAllocatorRef)v7, v5, 0);
    }
    else
    {
      v6 = (char *)this + 32;
    }
    *((_QWORD *)this + 2) = v6;
    CFStringGetCString(*((CFStringRef *)this + 1), v6, v5, 0x8000100u);
    return *((_QWORD *)this + 2);
  }
  return result;
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolWasRedirected(URLConnectionLoader_Classic *this, NSURLRequest *a2, _CFURLResponse *a3)
{
  URLConnectionLoader_Classic::protocolWasRedirected((URLConnectionLoader_Classic *)((char *)this - 56), a2, a3);
}

void URLConnectionLoader_Classic::protocolWasRedirected(URLConnectionLoader_Classic *this, CFTypeRef cf, _CFURLResponse *a3)
{
  _CFURLResponse *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  _QWORD v10[7];
  _QWORD block[6];

  if (cf)
    CFRetain(cf);
  v6 = a3;
  v7 = MEMORY[0x1E0C809B0];
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN27URLConnectionLoader_Classic21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke;
  v10[3] = &unk_1E14FB048;
  v10[4] = cf;
  v10[5] = this;
  v10[6] = a3;
  v8 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v9 = *((_QWORD *)this + 5);
  block[0] = v7;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v10;
  block[5] = v8;
  dispatch_async(v9, block);
}

void HTTP3Connection::writeEncoderStream(uint64_t a1, void *a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  NSObject *v8;
  dispatch_data_t concat;
  char buffer;

  v3 = a2;
  v4 = *(_QWORD *)(a1 + 1008);
  if (v4 && (*(_BYTE *)(a1 + 920) & 4) == 0)
  {
    v5 = *(_QWORD *)(a1 + 1040);
    if (!v5)
    {
      HTTP3Connection::_newClientUnidirectionalStreamHandle((HTTP3Connection *)"outbound encoder", 0);
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = *(void **)(a1 + 1040);
      *(_QWORD *)(a1 + 1040) = v6;

      buffer = 2;
      v8 = dispatch_data_create(&buffer, 1uLL, 0, 0);
      concat = dispatch_data_create_concat(v8, v3);

      v4 = *(_QWORD *)(a1 + 1008);
      v5 = *(_QWORD *)(a1 + 1040);
      v3 = concat;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, NSObject *, void *))(*(_QWORD *)v4 + 64))(v4, v5, 1, v3, &__block_literal_global_5240);
  }

}

void sub_183F5C72C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<HTTP3ConnectionCacheEntry>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__shared_ptr_emplace<HTTP3ConnectionCache>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__shared_ptr_emplace<HTTP3Connection>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void HTTP3ConnectionCacheEntry::~HTTP3ConnectionCacheEntry(HTTP3ConnectionCacheEntry *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  void **v7;

  *(_QWORD *)this = &off_1E14ED468;
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 10) = 0;
  }
  v3 = *((_QWORD *)this + 11);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
    *((_QWORD *)this + 11) = 0;
  }
  if (*((_QWORD *)this + 12))
    *((_QWORD *)this + 12) = 0;
  v4 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v7 = (void **)((char *)this + 104);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&v7);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  *(_QWORD *)this = &off_1E14E5838;
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

{
  HTTP3ConnectionCacheEntry::~HTTP3ConnectionCacheEntry(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F5C824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;

  v12 = *(_QWORD *)(v10 + 128);
  *(_QWORD *)(v10 + 128) = 0;
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  a10 = (void **)(v10 + 104);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a10);
  v13 = *(std::__shared_weak_count **)(v10 + 32);
  if (v13)
    std::__shared_weak_count::__release_weak(v13);
  *(_QWORD *)v10 = &off_1E14E5838;
  v14 = *(std::__shared_weak_count **)(v10 + 16);
  if (v14)
    std::__shared_weak_count::__release_weak(v14);
  _Unwind_Resume(a1);
}

void AuthenticationCache::~AuthenticationCache(AuthenticationCache *this)
{
  *(_QWORD *)this = &off_1E14E9AC8;
  std::__list_imp<std::shared_ptr<AuthenticationState>>::clear((uint64_t *)this + 1);
  *(_QWORD *)this = &off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

{
  *(_QWORD *)this = &off_1E14E9AC8;
  std::__list_imp<std::shared_ptr<AuthenticationState>>::clear((uint64_t *)this + 1);
  *(_QWORD *)this = &off_1E14E5838;
}

void HTTP3ConnectionCache::~HTTP3ConnectionCache(HTTP3ConnectionCache *this)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  void *v5;
  std::__shared_weak_count *v6;

  *(_QWORD *)this = &off_1E14EB498;
  v2 = *((_QWORD *)this + 8);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 8) = 0;
  }
  *((_QWORD *)this + 9) = 0;
  if (*((_BYTE *)this + 96))
    HTTP3ConnectionCache::_timersStop(this);
  v3 = *((_QWORD *)this + 13);
  if (v3)
    dispatch_source_cancel(v3);
  v4 = *((_QWORD *)this + 14);
  if (v4)
  {
    dispatch_source_cancel(v4);
    v5 = (void *)*((_QWORD *)this + 14);
  }
  else
  {
    v5 = 0;
  }

  *((_QWORD *)this + 10) = &off_1E14EA508;
  CFRelease(*((CFTypeRef *)this + 11));
  *(_QWORD *)this = &off_1E14E5838;
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

{
  HTTP3ConnectionCache::~HTTP3ConnectionCache(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F5C980(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v3;

  *(_QWORD *)(v1 + 80) = &off_1E14EA508;
  CFRelease(*(CFTypeRef *)(v1 + 88));
  *(_QWORD *)v1 = &off_1E14E5838;
  v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(a1);
}

void HTTPConnectionCache::useFastPathForCacheEntryWithKey(HTTPConnectionCache *this, const HTTPConnectionCacheKey *value)
{
  uint64_t v4;
  const void *v5;
  const void *v6;

  if (value)
  {
    v4 = *((_QWORD *)this + 5);
    if (v4 && (v5 = CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 32), value)) != 0)
    {
      v6 = v5;
      (*(void (**)(const void *))(*(_QWORD *)v5 + 40))(v5);
      (*(void (**)(const void *))(*(_QWORD *)v6 + 48))(v6);
    }
    else
    {
      CFSetAddValue(*((CFMutableSetRef *)this + 6), value);
    }
  }
}

void HTTP3Connection::_cleanupConnection(HTTP3Connection *this, uint64_t a2, uint64_t a3)
{
  HTTPStallTimer *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  void *v11;
  NSObject *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  HTTP3Stream *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  std::__shared_weak_count *v54;
  _QWORD *v55;
  std::__shared_weak_count *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  _BYTE buf[24];
  void *v63;
  uint64_t v64;
  std::__shared_weak_count *v65;
  uint64_t v66;
  std::__shared_weak_count *v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  if ((*((_BYTE *)this + 920) & 4) != 0)
    return;
  if (*((_QWORD *)this + 124))
    HTTP3Connection::_stopStallRecovery(this);
  v6 = (HTTPStallTimer *)*((_QWORD *)this + 122);
  if (v6)
  {
    HTTPStallTimer::invalidate(v6);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 976, (__int128 *)buf);
    v7 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v8 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
  if (a2 != -1)
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 126) + 112))(*((_QWORD *)this + 126), a2);
  v10 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 126) + 120))(*((_QWORD *)this + 126));
  if (v10 != -1)
  {
    v11 = (void *)v10;
    if (v10 != 256)
    {
      CFN_LOG_h3connection();
      v12 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v52 = *((_QWORD *)this + 152);
        *(_DWORD *)buf = 134218496;
        *(_QWORD *)&buf[4] = this;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v52;
        *(_WORD *)&buf[22] = 2048;
        v63 = v11;
        _os_log_error_impl(&dword_183ECA000, v12, OS_LOG_TYPE_ERROR, "%p %llu closed with peer error %llu", buf, 0x20u);
      }

    }
  }
  v13 = *((_QWORD *)this + 145);
  v14 = *((_QWORD *)this + 146);
  v57 = 0;
  v58 = 0;
  v59 = 0;
  std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(&v57, *((_QWORD **)this + 142), *((_QWORD **)this + 143), (uint64_t)(*((_QWORD *)this + 143) - *((_QWORD *)this + 142)) >> 4);
  v15 = v57;
  v16 = v58;
  if (v57 != v58)
  {
    v17 = v13 | v14;
    if (v17)
      v18 = v14;
    else
      v18 = v14 & 0xFFFFFFFF00000000 | 0xFFFFFFFC;
    if (v17)
      v19 = v13;
    else
      v19 = 4;
    do
    {
      v21 = *(HTTP3Stream **)v15;
      v20 = *(std::__shared_weak_count **)(v15 + 8);
      *(_QWORD *)buf = *(_QWORD *)v15;
      *(_QWORD *)&buf[8] = v20;
      if (v20)
      {
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          v23 = __ldxr(p_shared_owners);
        while (__stxr(v23 + 1, p_shared_owners));
      }
      HTTP3Stream::_cleanupStream((uint64_t)v21, 256, 1);
      *((_QWORD *)v21 + 33) = v19;
      *((_QWORD *)v21 + 34) = v18;
      HTTP3Stream::_protocolCallback(v21);
      if (v20)
      {
        v24 = (unint64_t *)&v20->__shared_owners_;
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      v15 += 16;
    }
    while (v15 != v16);
  }
  TransportConnection::rstConnectionDelegate(*((TransportConnection **)this + 126));
  (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 126) + 152))(*((_QWORD *)this + 126), a3);
  *((_BYTE *)this + 920) |= 4u;
  v55 = 0;
  v56 = 0;
  v26 = (std::__shared_weak_count *)*((_QWORD *)this + 121);
  if (v26)
  {
    v56 = std::__shared_weak_count::lock(v26);
    if (v56)
    {
      v27 = (_QWORD *)*((_QWORD *)this + 120);
      v55 = v27;
      if (v27)
      {
        std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v53, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
        v29 = v27[1];
        v28 = (std::__shared_weak_count *)v27[2];
        v60 = v29;
        if (v28)
        {
          v30 = std::__shared_weak_count::lock(v28);
          v61 = v30;
          if (v30)
          {
            v31 = v30;
            v32 = v27[11];
            *(_QWORD *)buf = MEMORY[0x1E0C809B0];
            *(_QWORD *)&buf[8] = 3321888768;
            *(_QWORD *)&buf[16] = ___ZN25HTTP3ConnectionCacheEntry16connectionClosedENSt3__110shared_ptrI15HTTP3ConnectionEE_block_invoke;
            v63 = &__block_descriptor_64_ea8_32c53_ZTSNSt3__110shared_ptrI25HTTP3ConnectionCacheEntryEE48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e5_v8__0l;
            v64 = v29;
            v65 = v31;
            v33 = (unint64_t *)&v31->__shared_owners_;
            do
              v34 = __ldxr(v33);
            while (__stxr(v34 + 1, v33));
            v66 = v53;
            v67 = v54;
            if (v54)
            {
              v35 = (unint64_t *)&v54->__shared_owners_;
              do
                v36 = __ldxr(v35);
              while (__stxr(v36 + 1, v35));
            }
            (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v32 + 96))(v32, buf);
            v37 = v67;
            if (v67)
            {
              v38 = (unint64_t *)&v67->__shared_owners_;
              do
                v39 = __ldaxr(v38);
              while (__stlxr(v39 - 1, v38));
              if (!v39)
              {
                ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
                std::__shared_weak_count::__release_weak(v37);
              }
            }
            v40 = v65;
            if (v65)
            {
              v41 = (unint64_t *)&v65->__shared_owners_;
              do
                v42 = __ldaxr(v41);
              while (__stlxr(v42 - 1, v41));
              if (!v42)
              {
                ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
                std::__shared_weak_count::__release_weak(v40);
              }
            }
            v43 = v61;
            if (v61)
            {
              v44 = (unint64_t *)&v61->__shared_owners_;
              do
                v45 = __ldaxr(v44);
              while (__stlxr(v45 - 1, v44));
              if (!v45)
              {
                ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
                std::__shared_weak_count::__release_weak(v43);
              }
            }
            v46 = v54;
            if (v54)
            {
              v47 = (unint64_t *)&v54->__shared_owners_;
              do
                v48 = __ldaxr(v47);
              while (__stlxr(v48 - 1, v47));
              if (!v48)
              {
                ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
                std::__shared_weak_count::__release_weak(v46);
              }
            }
            goto LABEL_63;
          }
        }
        else
        {
          v61 = 0;
        }
        std::__throw_bad_weak_ptr[abi:nn180100]();
        __break(1u);
        return;
      }
    }
  }
LABEL_63:
  v49 = v56;
  if (v56)
  {
    v50 = (unint64_t *)&v56->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  *(_QWORD *)buf = &v57;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
}

void sub_183F5CEE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  void **v8;
  va_list va1;
  uint64_t v10;
  uint64_t v11;
  va_list va2;
  uint64_t v13;
  uint64_t v14;
  va_list va3;

  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v8 = va_arg(va2, void **);
  v10 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v11 = va_arg(va3, _QWORD);
  v13 = va_arg(va3, _QWORD);
  v14 = va_arg(va3, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  va_copy((va_list)v8, va2);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)va1);
  _Unwind_Resume(a1);
}

void HTTPStallTimer::invalidate(HTTPStallTimer *this)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;

  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = *((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = 0;
    if (v3)
      dispatch_release(v3);
  }
  else
  {
    *((_QWORD *)this + 4) = 0;
  }
  std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100]((uint64_t *)this + 5, 0);
  v4 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v4)
    dispatch_release(v4);
}

void HTTP3Connection::~HTTP3Connection(HTTP3Connection *this)
{
  char *v2;
  HTTPStallTimer *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  FILE *v11;
  _QWORD *v12;
  _QWORD *v13;
  int v14;
  _DWORD *v15;
  int v16;
  unsigned int v17;
  int v18;
  FILE *v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  __int128 v22;

  *(_QWORD *)this = &off_1E14E78D8;
  *((_QWORD *)this + 3) = &unk_1E14E7928;
  v2 = (char *)this + 976;
  v3 = (HTTPStallTimer *)*((_QWORD *)this + 122);
  if (v3)
  {
    HTTPStallTimer::invalidate(v3);
    v22 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v22);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
    if (*((_QWORD *)&v22 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  v7 = (_QWORD *)*((_QWORD *)this + 11);
  if (v7)
  {
    do
    {
      v8 = (_QWORD *)v7[2];
      free(v7);
      v7 = v8;
    }
    while (v8);
  }
  v9 = (_QWORD *)*((_QWORD *)this + 14);
  if (v9)
  {
    do
    {
      v10 = (_QWORD *)*v9;
      free(v9);
      v9 = v10;
    }
    while (v10);
  }
  free(*((void **)this + 13));
  free(*((void **)this + 31));
  v11 = (FILE *)*((_QWORD *)this + 29);
  if (v11)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v11);
    fwrite("cleaned up", 0xAuLL, 1uLL, *((FILE **)this + 29));
    fputc(10, *((FILE **)this + 29));
  }
  v12 = (_QWORD *)*((_QWORD *)this + 44);
  if (v12)
  {
    do
    {
      v13 = (_QWORD *)*v12;
      free(v12);
      v12 = v13;
    }
    while (v13);
  }
  v14 = *((_DWORD *)this + 126);
  if ((v14 - 1) > 4)
  {
    if ((v14 - 8) > 6)
      goto LABEL_21;
    v15 = (_DWORD *)*((_QWORD *)this + 69);
    if (!v15)
      goto LABEL_21;
  }
  else
  {
    v15 = (_DWORD *)*((_QWORD *)this + 70);
    if (!v15)
      goto LABEL_21;
  }
LABEL_20:
  free(v15);
LABEL_21:
  v16 = *((_DWORD *)this + 83);
  v17 = *((_DWORD *)this + 84);
  while (v16 != v17)
  {
    v15 = *(_DWORD **)(*((_QWORD *)this + 43) + 8 * v17);
    v17 = (v17 + 1) % *((_DWORD *)this + 82);
    *((_DWORD *)this + 84) = v17;
    v18 = v15[2] - 1;
    v15[2] = v18;
    if (!v18)
      goto LABEL_20;
  }
  free(*((void **)this + 43));
  *((_QWORD *)this + 41) = 0;
  *((_QWORD *)this + 42) = 0;
  *((_QWORD *)this + 43) = 0;
  v19 = (FILE *)*((_QWORD *)this + 40);
  if (v19)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v19);
    fwrite("cleaned up", 0xAuLL, 1uLL, *((FILE **)this + 40));
    fputc(10, *((FILE **)this + 40));
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 1192);
  *(_QWORD *)&v22 = (char *)this + 1136;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v22);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 1120);
  std::deque<void({block_pointer} {__strong})(std::shared_ptr<HTTP3Framer>,unsigned long long,BOOL),std::allocator<void({block_pointer} {__strong})(std::shared_ptr<HTTP3Framer>,unsigned long long,BOOL)>>::~deque[abi:nn180100]((uint64_t)this + 1072);

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 1024);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 1008);

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v2);
  v20 = (std::__shared_weak_count *)*((_QWORD *)this + 121);
  if (v20)
    std::__shared_weak_count::__release_weak(v20);
  HTTP2ServerPush::~HTTP2ServerPush((HTTP3Connection *)((char *)this + 624));
  *((_QWORD *)this + 3) = &off_1E14E5838;
  v21 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v21)
    std::__shared_weak_count::__release_weak(v21);
}

{
  HTTP3Connection::~HTTP3Connection(this);
  JUMPOUT(0x186DB748CLL);
}

void HTTP2ServerPush::~HTTP2ServerPush(HTTP2ServerPush *this)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  void ***v14;
  void ***v15;
  void *v16;

  v2 = (_QWORD *)*((_QWORD *)this + 34);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 32);
  *((_QWORD *)this + 32) = 0;
  if (v4)
    operator delete(v4);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)this + 216);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)this + 176);
  v5 = (_QWORD *)*((_QWORD *)this + 18);
  if (v5)
  {
    do
    {
      v6 = (_QWORD *)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while (v6);
  }
  v7 = (void *)*((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v7)
    operator delete(v7);
  v8 = (_QWORD *)*((_QWORD *)this + 13);
  if (v8)
  {
    do
    {
      v9 = (_QWORD *)*v8;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,0>((uint64_t)(v8 + 2));
      operator delete(v8);
      v8 = v9;
    }
    while (v9);
  }
  v10 = (void *)*((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v10)
    operator delete(v10);
  v11 = (_QWORD *)*((_QWORD *)this + 8);
  if (v11)
  {
    do
    {
      v12 = (_QWORD *)*v11;
      operator delete(v11);
      v11 = v12;
    }
    while (v12);
  }
  v13 = (void *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v13)
    operator delete(v13);
  v14 = (void ***)*((_QWORD *)this + 3);
  if (v14)
  {
    v15 = (void ***)*((_QWORD *)this + 4);
    v16 = (void *)*((_QWORD *)this + 3);
    if (v15 != v14)
    {
      do
        std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](--v15, 0);
      while (v15 != v14);
      v16 = (void *)*((_QWORD *)this + 3);
    }
    *((_QWORD *)this + 4) = v14;
    operator delete(v16);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t GZipDataDecoder::isInitialized(GZipDataDecoder *this)
{
  return *((unsigned __int8 *)this + 120);
}

void NWIOConnection::closeWithQUICApplicationError(nw_connection_t *this)
{
  NSObject *v2;
  nw_protocol_metadata_t v3;

  v2 = nw_protocol_copy_quic_connection_definition();
  v3 = nw_connection_copy_protocol_metadata(this[34], v2);
  if (v3)
  {
    nw_quic_connection_close_with_error();
    nw_release(v3);
  }
  if (v2)
    nw_release(v2);
}

void sub_183F5D448(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  nw_release(v2);
  if (v1)
    nw_release(v1);
  _Unwind_Resume(a1);
}

uint64_t gzipDecodeHeader(const __CFData *a1, uInt *a2, const __CFAllocator *a3, const __CFString **a4, unint64_t *a5, unsigned __int8 *a6)
{
  int Length;
  const UInt8 *BytePtr;
  uint64_t result;
  const UInt8 *v15;
  unsigned int v16;
  uInt v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  unsigned __int16 v25;
  int v26;

  Length = CFDataGetLength(a1);
  BytePtr = CFDataGetBytePtr(a1);
  if (Length <= 9)
    goto LABEL_2;
  v15 = BytePtr;
  result = 0;
  *a6 = 0;
  if (*v15 == 31)
  {
    if (v15[1] != 139)
      return 0;
    if (v15[2] != 8)
      return 0;
    v16 = v15[3];
    if (v16 > 0x1F)
      return 0;
    if ((v16 & 4) != 0)
    {
      if (Length <= 0xB)
        goto LABEL_2;
      v17 = *((unsigned __int16 *)v15 + 5) + 12;
      if (v17 > Length)
        goto LABEL_2;
    }
    else
    {
      v17 = 10;
    }
    if ((v16 & 8) != 0)
    {
      v19 = v17;
      v18 = (const char *)&v15[v17];
      if ((int)v17 <= Length)
        v20 = Length;
      else
        v20 = v17;
      while (v20 != v19)
      {
        v17 = v19 + 1;
        if (!v15[v19++])
          goto LABEL_18;
      }
      goto LABEL_2;
    }
    v18 = 0;
LABEL_18:
    if ((v16 & 0x10) != 0)
    {
      v22 = (int)v17;
      if ((int)v17 <= Length)
        v23 = Length;
      else
        v23 = v17;
      while (v23 != v22)
      {
        v17 = v22 + 1;
        if (!v15[v22++])
          goto LABEL_24;
      }
      goto LABEL_2;
    }
LABEL_24:
    if ((v16 & 2) == 0)
      goto LABEL_25;
    if ((int)(v17 + 2) <= Length)
    {
      v25 = crc32(0, v15, v17);
      v26 = *(unsigned __int16 *)&v15[v17];
      v17 += 2;
      if (v26 == v25)
      {
LABEL_25:
        if (a2)
          *a2 = v17;
        if (a5)
          *a5 = *((int *)v15 + 1);
        if (a4)
        {
          if (v18)
            *a4 = CFStringCreateWithCString(a3, v18, 0x500u);
          else
            *a4 = 0;
        }
        return 1;
      }
      return 0;
    }
LABEL_2:
    result = 0;
    *a6 = 1;
  }
  return result;
}

BOOL HTTPConnectionCacheEntry::_doesConnAuthApply(uint64_t a1, std::__shared_weak_count *a2, HTTPConnectionCacheEntry::EnqueuedRequest **a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  HTTPRequestMessage *v9;
  uint64_t v10;
  pthread_mutex_t *v11;
  _QWORD *v12;
  uint64_t v13;
  _BOOL8 v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  char v26;
  _QWORD v27[3];
  _QWORD *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v24 = a1;
  v25 = a2;
  if (a2)
  {
    p_shared_owners = (unint64_t *)&a2->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = (*(uint64_t (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(_QWORD *)*a3 + 80))(*a3);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v7 + 88))(&v22);
  if (!AuthenticationState::isEmpty((AuthenticationState *)a1) && !AuthenticationState::isValid(a1, 0))
    goto LABEL_21;
  if (!AuthenticationState::isEmpty((AuthenticationState *)a1))
  {
    v8 = HTTPConnectionCacheEntry::EnqueuedRequest::mutableRequest(*a3);
    if (v8)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v9 = *(_BYTE *)(v8 + 40) ? 0 : (HTTPRequestMessage *)(v8 + 16);
    }
    else
    {
      v9 = 0;
    }
    if (!AuthenticationState::canApplyHeadersToRequest((AuthenticationState *)a1, v9))
    {
LABEL_21:
      v14 = 0;
      goto LABEL_28;
    }
  }
  v10 = v22;
  if (a1)
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (!v10)
  {
    v14 = 1;
    if (!a1)
      goto LABEL_28;
    goto LABEL_27;
  }
  v11 = (pthread_mutex_t *)(v10 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
  v26 = 1;
  v27[0] = &off_1E14F0318;
  v27[1] = a1;
  v27[2] = &v26;
  v28 = v27;
  AuthenticationState::_foreachAuthenticationInfo(v10, (uint64_t)v27);
  v12 = v28;
  if (v28 == v27)
  {
    v13 = 4;
    v12 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_26;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_26:
  v14 = v26 != 0;
  pthread_mutex_unlock(v11);
  if (a1)
LABEL_27:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
LABEL_28:
  v15 = v23;
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = v25;
  if (v25)
  {
    v19 = (unint64_t *)&v25->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  return v14;
}

void sub_183F5D864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  uint64_t v17;
  pthread_mutex_t *v18;
  char *v19;
  char *v21;
  uint64_t v22;

  v21 = a17;
  if (a17 == v19)
  {
    v22 = 4;
    v21 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v22 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_6:
  pthread_mutex_unlock(v18);
  if (v17)
    pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

BOOL AuthenticationState::isEmpty(AuthenticationState *this)
{
  _BOOL8 v2;

  if (this)
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  if (*((_QWORD *)this + 13))
    v2 = 0;
  else
    v2 = *((_QWORD *)this + 16) == 0;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return v2;
}

void RequestBodyStream::_onqueue_pollStream(RequestBodyStream *this)
{
  unint64_t *p_shared_owners;
  unint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD v16[6];
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;

  if ((~*((unsigned __int8 *)this + 192) & 5) == 0
    && (*(unsigned int (**)(RequestBodyStream *))(*(_QWORD *)this + 48))(this))
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v18, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
    v20 = v18;
    v21 = v19;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v3 = __ldxr(p_shared_owners);
      while (__stxr(v3 + 1, p_shared_owners));
      v4 = v19;
      if (v19)
      {
        v5 = (unint64_t *)&v19->__shared_owners_;
        do
          v6 = __ldaxr(v5);
        while (__stlxr(v6 - 1, v5));
        if (!v6)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
    v7 = *((_QWORD *)this + 17);
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 3321888768;
    v16[2] = ___ZN17RequestBodyStream19_onqueue_pollStreamEv_block_invoke;
    v16[3] = &__block_descriptor_56_e8_40c45_ZTSNSt3__110shared_ptrI17RequestBodyStreamEE_e5_v8__0l;
    v16[4] = this;
    v16[5] = v20;
    v17 = v21;
    if (v21)
    {
      v8 = (unint64_t *)&v21->__shared_owners_;
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v7 + 96))(v7, v16);
    v10 = v17;
    if (v17)
    {
      v11 = (unint64_t *)&v17->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v13 = v21;
    if (v21)
    {
      v14 = (unint64_t *)&v21->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
}

void sub_183F5DAAC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

void NSXURLCache::~NSXURLCache(NSXURLCache *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E5280;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E5280;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

void ___ZNK13MemoryCookies24newCookieArrayEnumeratorEP12CookieSifter_block_invoke(uint64_t a1, CFTypeRef cf)
{
  unint64_t Count;
  const void **v5;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  const __CFData *v9;
  uint64_t v10;
  const UInt8 *BytePtr;
  uint64_t v12;
  const CompactCookieHeader **v13;
  unsigned int v14;
  uint64_t v15;
  const __CFData *v16;
  const UInt8 *v17;
  const UInt8 *v18;
  uint64_t v19;
  CompactCookieHeader *v20;
  uint64_t v21;
  BOOL v22;
  unint64_t i;
  uint64_t v24;
  CookieSifter::Term *v25;
  uint64_t v26;
  int v27;
  BOOL EnumeratedTime;
  double v29;
  double v30;
  uint64_t v31;
  _DWORD *v32;
  int v33;
  _BYTE *v34;
  int EnumeratedBoolean;
  uint64_t v36;
  _DWORD *v37;
  int v38;
  int v39;
  char *EnumeratedString;
  uint64_t v41;
  _DWORD *v42;
  int v43;
  const __CFAllocator *v44;
  const __CFString *v45;
  UInt8 *CString;
  uint64_t v47;
  _DWORD *v48;
  int v49;
  unsigned __int16 *v50;
  CFTypeRef v51;
  CFTypeID v52;
  uint64_t v53;
  double v54;
  _BOOL4 v55;
  _BOOL4 v56;
  BOOL v57;
  CFTypeID v58;
  unsigned __int16 v59;
  unsigned __int16 v60;
  unint64_t v61;
  const __CFNumber *ValueAtIndex;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v70;
  unint64_t v71;
  int v72;
  const char *v74;
  uint64_t v75;
  char *v76;
  int v77;
  char v78;
  char v79;
  char v80;
  char v81;
  _QWORD *Instance;
  CompactCookieArray *v83;
  char *v84;
  uint64_t v85;
  CFTypeRef cf2;
  uint64_t v87;
  uint64_t v88;
  const CompactCookieHeader **v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int v93;
  uint64_t v94;
  CFTypeRef v95;
  uint64_t v96;
  const void **v97;
  _BYTE v98[248];
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  CFAllocatorRef valuePtr;
  uint64_t v132[2];
  UInt8 v133[1024];
  uint64_t v134;

  v134 = *MEMORY[0x1E0C80C00];
  if (!cf)
  {
    v95 = 0;
    v96 = 0;
    v97 = (const void **)v98;
    goto LABEL_9;
  }
  v95 = CFRetain(cf);
  Count = CFDictionaryGetCount((CFDictionaryRef)cf);
  v96 = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v97 = 0;
    goto LABEL_9;
  }
  if (Count > 0x1E)
  {
    v5 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v97 = v5;
    if (!v5)
      goto LABEL_9;
  }
  else
  {
    v5 = (const void **)v98;
    v97 = (const void **)v98;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, 0, v5);
LABEL_9:
  v85 = v96;
  if (v96 >= 1)
  {
    v6 = 0;
    cf2 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
    v92 = *MEMORY[0x1E0C9B0D0];
    v87 = a1;
    do
    {
      v7 = v97[v6];
      if (*(_BYTE *)(a1 + 48))
      {
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v97[v6]);
      }
      else
      {
        if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
          dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
        if (v7)
          v8 = (uint64_t)v7 + 16;
        else
          v8 = 0;
        v9 = *(const __CFData **)(v8 + 16);
        if (!v9 || (v10 = *(_QWORD *)(v87 + 40), (BytePtr = CFDataGetBytePtr(v9)) == 0))
        {
          v14 = 0;
          v129 = 0u;
          v130 = 0u;
          v127 = 0u;
          v128 = 0u;
          v125 = 0u;
          v126 = 0u;
          v123 = 0u;
          v124 = 0u;
          v121 = 0u;
          v122 = 0u;
          v119 = 0u;
          v120 = 0u;
          v117 = 0u;
          v118 = 0u;
          v115 = 0u;
          v116 = 0u;
          v113 = 0u;
          v114 = 0u;
          v111 = 0u;
          v112 = 0u;
          v109 = 0u;
          v110 = 0u;
          v107 = 0u;
          v108 = 0u;
          v105 = 0u;
          v106 = 0u;
          v103 = 0u;
          v104 = 0u;
          v101 = 0u;
          v102 = 0u;
          v13 = (const CompactCookieHeader **)&v99;
          v99 = 0u;
          v100 = 0u;
          goto LABEL_124;
        }
        v12 = *((unsigned int *)BytePtr + 1);
        v129 = 0u;
        v130 = 0u;
        v127 = 0u;
        v128 = 0u;
        v125 = 0u;
        v126 = 0u;
        v123 = 0u;
        v124 = 0u;
        v121 = 0u;
        v122 = 0u;
        v119 = 0u;
        v120 = 0u;
        v117 = 0u;
        v118 = 0u;
        v115 = 0u;
        v116 = 0u;
        v113 = 0u;
        v114 = 0u;
        v111 = 0u;
        v112 = 0u;
        v109 = 0u;
        v110 = 0u;
        v107 = 0u;
        v108 = 0u;
        v105 = 0u;
        v106 = 0u;
        v103 = 0u;
        v104 = 0u;
        v101 = 0u;
        v102 = 0u;
        v99 = 0u;
        v100 = 0u;
        if (v12 >= 0x41)
        {
          v13 = (const CompactCookieHeader **)operator new[]();
LABEL_25:
          v15 = 0;
          v93 = 0;
          v90 = v8;
          v91 = v6;
          v88 = v12;
          v89 = v13;
          while (1)
          {
            v16 = *(const __CFData **)(v8 + 16);
            v94 = v15;
            if (v16 && CFDataGetBytePtr(v16))
            {
              v17 = CFDataGetBytePtr(*(CFDataRef *)(v8 + 16));
              v18 = *(const UInt8 **)(v8 + 16);
              v19 = *(unsigned int *)&v17[4 * v15 + 8];
              if (v18)
                v18 = CFDataGetBytePtr((CFDataRef)v18);
              v20 = (CompactCookieHeader *)&v18[v19];
            }
            else
            {
              v20 = 0;
            }
            v21 = *(_QWORD *)(v10 + 800);
            if (!*(_QWORD *)(v10 + 24))
            {
              if ((v21 & 0x20) == 0)
                goto LABEL_119;
              goto LABEL_120;
            }
            v22 = 0;
            for (i = 0; i != 19; ++i)
            {
              v24 = v10 + 40 * i;
              v26 = *(_QWORD *)(v24 + 40);
              v25 = (CookieSifter::Term *)(v24 + 40);
              if (v26)
              {
                v27 = CookieData::sCookieFieldInfo[5 * i + 3];
                switch(v27)
                {
                  case 0:
                    goto LABEL_109;
                  case 1:
                    EnumeratedString = (char *)CompactCookieHeader::getEnumeratedString(v20, i, 0);
                    v41 = v10 + 40 * i;
                    v43 = *(_DWORD *)(v41 + 72);
                    v42 = (_DWORD *)(v41 + 72);
                    if (v43 != 2)
                    {
                      CookieSifter::Term::cleanCache(v25);
                      *v42 = 2;
                      v44 = CFGetAllocator(*(CFTypeRef *)v25);
                      v45 = *(const __CFString **)v25;
                      valuePtr = v44;
                      v132[0] = 1023;
                      if (v45)
                      {
                        CString = _CFStringGetOrCreateCString(v44, v45, v133, v132, 0x8000100u);
                      }
                      else
                      {
                        v133[0] = 0;
                        v132[0] = 0;
                        CString = v133;
                      }
                      v132[1] = (uint64_t)CString;
                      *(_QWORD *)(v10 + 40 * i + 56) = strdup((const char *)CString);
                      if (CString && v133 != CString)
                        CFAllocatorDeallocate(valuePtr, CString);
                    }
                    v74 = *(const char **)(v10 + 40 * i + 56);
                    if (EnumeratedString == v74)
                      goto LABEL_109;
                    if (!EnumeratedString)
                    {
                      v57 = *v74 == 0;
LABEL_105:
                      v56 = v57;
                      goto LABEL_108;
                    }
                    v75 = *(_QWORD *)(v10 + 800);
                    if ((v75 & 2) != 0)
                    {
                      if ((v75 & 1) != 0)
                        v77 = strcmp(EnumeratedString, v74);
                      else
                        v77 = strcasecmp(EnumeratedString, v74);
                      v57 = v77 == 0;
                      goto LABEL_105;
                    }
                    if ((v75 & 1) != 0)
                      v76 = strstr(EnumeratedString, v74);
                    else
                      v76 = strcasestr(EnumeratedString, v74);
                    v56 = v76 != 0;
LABEL_108:
                    if (!v56)
                      goto LABEL_111;
LABEL_109:
                    v78 = 1;
                    v79 = 1;
                    v80 = 1;
                    if ((v21 & 0x10) == 0)
                      goto LABEL_113;
                    goto LABEL_112;
                  case 2:
                  case 4:
                    EnumeratedTime = CompactCookieHeader::getEnumeratedTime(v20, i);
                    v30 = v29;
                    v31 = v10 + 40 * i;
                    v33 = *(_DWORD *)(v31 + 72);
                    v32 = (_DWORD *)(v31 + 72);
                    if (v33 != 1)
                    {
                      CookieSifter::Term::cleanCache(v25);
                      *v32 = 1;
                      v34 = (_BYTE *)(v10 + 40 * i + 56);
                      if (*(_QWORD *)v25 == v92)
                      {
                        *v34 = 0;
                      }
                      else
                      {
                        *v34 = 1;
                        *(double *)(v10 + 40 * i + 64) = MEMORY[0x186DB5F80]();
                      }
                    }
                    v53 = v10 + 40 * i;
                    v54 = *(double *)(v53 + 64);
                    v55 = *(unsigned __int8 *)(v53 + 56) == EnumeratedTime;
                    if (v54 > v30)
                      v55 = 0;
                    v56 = v54 >= v30 && v55;
                    goto LABEL_108;
                  case 3:
                  case 5:
                  case 6:
                  case 7:
                    goto LABEL_111;
                  case 8:
                    v47 = v10 + 40 * i;
                    v49 = *(_DWORD *)(v47 + 72);
                    v48 = (_DWORD *)(v47 + 72);
                    if (v49 == 3)
                    {
                      v50 = *(unsigned __int16 **)(v10 + 40 * i + 56);
                    }
                    else
                    {
                      CookieSifter::Term::cleanCache(v25);
                      *v48 = 3;
                      v50 = (unsigned __int16 *)operator new();
                      v51 = *(CFTypeRef *)v25;
                      v52 = CFGetTypeID(v51);
                      if (v52 == CFNumberGetTypeID())
                      {
                        *v50 = 1;
                        valuePtr = 0;
                        CFNumberGetValue((CFNumberRef)v51, kCFNumberCFIndexType, &valuePtr);
                        v50[1] = (unsigned __int16)valuePtr;
                      }
                      else
                      {
                        v58 = CFGetTypeID(v51);
                        if (v58 == CFArrayGetTypeID())
                        {
                          v59 = CFArrayGetCount((CFArrayRef)v51);
                          v60 = v59 <= 0x40uLL ? v59 : 64;
                          *v50 = v60;
                          if (v60)
                          {
                            v61 = 0;
                            do
                            {
                              ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v51, v61);
                              valuePtr = 0;
                              CFNumberGetValue(ValueAtIndex, kCFNumberCFIndexType, &valuePtr);
                              v50[++v61] = (unsigned __int16)valuePtr;
                            }
                            while (v61 < *v50);
                          }
                        }
                      }
                      *(_QWORD *)(v10 + 40 * i + 56) = v50;
                    }
                    if (*(_DWORD *)v20 < 0x10u)
                      goto LABEL_111;
                    v63 = *((unsigned int *)v20 + 3);
                    if (!(_DWORD)v63)
                      goto LABEL_111;
                    v64 = 0;
                    v65 = *(_QWORD *)(v10 + 800);
                    v66 = *v50;
                    break;
                  default:
                    if (v27 != 16)
                      goto LABEL_111;
                    EnumeratedBoolean = CompactCookieHeader::getEnumeratedBoolean(v20, i);
                    v36 = v10 + 40 * i;
                    v38 = *(_DWORD *)(v36 + 72);
                    v37 = (_DWORD *)(v36 + 72);
                    if (v38 == 4)
                    {
                      v39 = *(unsigned __int8 *)(v10 + 40 * i + 56);
                    }
                    else
                    {
                      CookieSifter::Term::cleanCache(v25);
                      *v37 = 4;
                      v39 = CFEqual(*(CFTypeRef *)v25, cf2);
                      *(_BYTE *)(v10 + 40 * i + 56) = v39;
                    }
                    v57 = EnumeratedBoolean == v39;
                    goto LABEL_105;
                }
                while (2)
                {
                  v67 = (2 * v64 + 56);
                  v68 = *(_DWORD *)v20;
                  if (v68 > v67 && (char *)v20 + v67 + 2 <= (char *)v20 + v68)
                  {
                    v70 = *(unsigned __int16 *)((char *)v20 + v67);
                    if (*v50)
                      goto LABEL_76;
                    goto LABEL_83;
                  }
                  v70 = 0;
                  if (!*v50)
                    goto LABEL_83;
LABEL_76:
                  if (v50[1] == v70)
                    goto LABEL_77;
                  v71 = 0;
                  do
                  {
                    if (v66 - 1 == v71)
                      goto LABEL_83;
                    v72 = v50[v71++ + 2];
                  }
                  while (v72 != v70);
                  if (v71 < v66)
                  {
LABEL_77:
                    if ((v65 & 8) == 0)
                      goto LABEL_109;
                    v56 = 1;
                  }
                  else
                  {
LABEL_83:
                    if ((v65 & 8) != 0)
                      break;
                    v56 = 0;
                  }
                  if (++v64 == v63)
                    goto LABEL_108;
                  continue;
                }
              }
LABEL_111:
              v78 = 0;
              v79 = 0;
              v80 = 0;
              if ((v21 & 0x10) != 0)
                break;
LABEL_112:
              v22 = i > 0x11;
              v80 = v78;
            }
LABEL_113:
            if ((v21 & 0x10) != 0)
              v81 = v80;
            else
              v81 = 0;
            if (!v22)
              v81 = v79;
            v8 = v90;
            v6 = v91;
            v12 = v88;
            v13 = v89;
            if ((v81 != 0) == ((*(_BYTE *)(v10 + 800) & 0x20) == 0))
LABEL_119:
              v13[v93++] = v20;
LABEL_120:
            v15 = v94 + 1;
            if (v94 + 1 == v12)
            {
              v14 = v93;
              goto LABEL_124;
            }
          }
        }
        if ((_DWORD)v12)
        {
          v13 = (const CompactCookieHeader **)&v99;
          goto LABEL_25;
        }
        v14 = 0;
        v13 = (const CompactCookieHeader **)&v99;
LABEL_124:
        CFGetAllocator((CFTypeRef)(v8 - 16));
        if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
          dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
        Instance = (_QWORD *)_CFRuntimeCreateInstance();
        v83 = (CompactCookieArray *)Instance;
        if (Instance)
        {
          Instance[2] = 0;
          Instance[3] = 0;
          v83 = (CompactCookieArray *)(Instance + 2);
          Instance[4] = 0;
        }
        CompactCookieArray::CompactCookieArray(v83, v13, v14);
        if (v13 != (const CompactCookieHeader **)&v99)
          MEMORY[0x186DB7474](v13, 0x60C8044C4A2DFLL);
        if (v83)
        {
          v84 = (char *)v83 - 16;
          CFArrayAppendValue(*(CFMutableArrayRef *)(v87 + 32), v84);
          CFRelease(v84);
        }
      }
      ++v6;
      a1 = v87;
    }
    while (v6 != v85);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v95);
}

void sub_183F5E440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_6(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_5(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_4(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_3(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

uint64_t ___ZN10HTTPEngine19_chunkedParseHeaderE13CFStreamError_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;

  v5 = 0;
  while (v5 < a5)
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (!*(_BYTE *)(v6 + 24))
      break;
    v7 = *(unsigned __int8 *)(a4 + v5);
    v8 = v7 > 0x20;
    v9 = (1 << v7) & 0x100002600;
    if (v8 || v9 == 0)
      *(_BYTE *)(v6 + 24) = 0;
    else
      ++v5;
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v5;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void std::__shared_ptr_pointer<_CFURLRequest const*,Deleter_CFRelease,std::allocator<_CFURLRequest const>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void std::__shared_ptr_pointer<__CFError *,Deleter_CFRelease,std::allocator<__CFError>>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

void Tube::_onqueue_errorHandler(Tube *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  int v5;
  int v6;
  unsigned int v9;
  NSObject *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  CFIndex v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  unsigned int v21;
  uint64_t v22;
  CFStreamError v23;

  v2 = *(_QWORD *)&a2.error;
  v22 = *MEMORY[0x1E0C80C00];
  if (!a2.error)
    __assert_rtn("_onqueue_errorHandler", "Tube.cpp", 1120, "error.error != 0");
  domain = a2.domain;
  if ((unint64_t)(a2.domain - 5) <= 0xFFFFFFFFFFFFFFFDLL
    && (v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 88))(*((_QWORD *)this + 13)),
        (v5 & 0xFFFFFFFE) == 2))
  {
    if (v5 == 2)
      v6 = -2094;
    else
      v6 = -2096;
    if ((_DWORD)v2 == 80 && domain == 1 && *((_DWORD *)this + 22) == 2)
      v9 = -2099;
    else
      v9 = v6;
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v10 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v11 = *((_QWORD *)this + 17);
      v12 = 134219008;
      v13 = v11;
      v14 = 2048;
      v15 = domain;
      v16 = 1024;
      v17 = v2;
      v18 = 2048;
      domain = 4;
      v19 = 4;
      v20 = 1024;
      v21 = v9;
      _os_log_error_impl(&dword_183ECA000, v10, OS_LOG_TYPE_ERROR, "Tube connection %p received error %lu:%d => proxy error %lu:%d", (uint8_t *)&v12, 0x2Cu);
    }
    else
    {
      domain = 4;
    }
  }
  else
  {
    v9 = v2;
  }
  if (*((_DWORD *)this + 55) != 10)
    *((_DWORD *)this + 55) = 11;
  Tube::_onqueue_cleanupConnection(this);
  *(_QWORD *)&v23.error = v2 & 0xFFFFFFFF00000000 | v9;
  v23.domain = domain;
  Tube::_onqueue_invokeCB(this, v23);
}

CFErrorRef BinaryCookieStorage::readCookiesFromStream(BinaryCookieStorage *this, CFReadStreamRef stream, CFDictionaryRef *a3, const __CFData **a4)
{
  const __CFAllocator *v5;
  CFErrorRef Entirely;
  unsigned int v7;
  unint64_t v8;
  CFErrorRef v11;
  int v12;
  _BOOL4 v13;
  unint64_t v14;
  unsigned int v15;
  CFIndex v16;
  __CFData *Mutable;
  __CFData *v18;
  UInt8 *MutableBytePtr;
  CFErrorRef ParseError;
  const __CFData *v21;
  CompactCookieArray *CompactCookieArray;
  CompactCookieArray *v23;
  const __CFData *v24;
  const UInt8 *BytePtr;
  const __CFData *v26;
  const UInt8 *v27;
  const __CFData *v28;
  int v29;
  const UInt8 *v30;
  UInt8 *v31;
  uint64_t v32;
  UInt8 *v33;
  uint64_t v34;
  char *EnumeratedString;
  uint64_t v36;
  const UInt8 *v37;
  const UInt8 *v38;
  int v39;
  CFErrorRef v40;
  CFIndex v41;
  __CFData *v42;
  UInt8 *v43;
  char *__s;
  UInt8 *v47;
  UInt8 buffer[4];
  unsigned int v49;
  unsigned int v50[6];
  uint64_t v51;
  void *v52;
  unsigned __int8 *v53;
  UInt8 v54[8];
  uint64_t v55;
  void *v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v5 = (const __CFAllocator *)*((_QWORD *)this + 1);
  *a4 = 0;
  Entirely = readEntirely(stream, buffer, 8);
  if (!Entirely)
  {
    if (*(_DWORD *)buffer != 1802465123)
      return createParseError(v5, "bad signature");
    v7 = v49;
    v8 = bswap32(v49);
    if (v8 >> 27)
      return createParseError(v5, "bad count");
    v47 = (UInt8 *)operator new[]();
    v11 = readEntirely(stream, v47, 4 * v8);
    Entirely = v11;
    v12 = 0;
    v13 = v11 == 0;
    if (v7 && !v11)
    {
      v14 = 0;
      v12 = 0;
      do
      {
        v15 = *(_DWORD *)&v47[4 * v14];
        v16 = bswap32(v15);
        if ((v16 & 0x80000000) != 0)
        {
          Entirely = createParseError(v5, "bad length");
        }
        else
        {
          Mutable = CFDataCreateMutable(v5, v16);
          v18 = Mutable;
          if (Mutable)
          {
            CFDataSetLength(Mutable, v16);
            if (CFDataGetMutableBytePtr(v18))
            {
              MutableBytePtr = CFDataGetMutableBytePtr(v18);
              ParseError = readEntirely(stream, MutableBytePtr, v16);
            }
            else
            {
              ParseError = createParseError(v5, "can't grow data to length");
            }
          }
          else
          {
            ParseError = createParseError(v5, "can't alloc length");
          }
          Entirely = ParseError;
          if (!ParseError)
          {
            CompactCookieArray = CompactCookieArray::makeCompactCookieArray((CompactCookieArray *)v5, v18, v21);
            v23 = CompactCookieArray;
            if (CompactCookieArray)
            {
              if (CompactCookieArray::assertCookiesValid(CompactCookieArray))
              {
                v24 = (const __CFData *)*((_QWORD *)v23 + 2);
                if (v24)
                {
                  BytePtr = CFDataGetBytePtr(v24);
                  if (BytePtr)
                  {
                    if (*((_DWORD *)BytePtr + 1))
                    {
                      v26 = (const __CFData *)*((_QWORD *)v23 + 2);
                      if (v26)
                      {
                        if (CFDataGetBytePtr(v26))
                        {
                          v27 = CFDataGetBytePtr(*((CFDataRef *)v23 + 2));
                          v28 = (const __CFData *)*((_QWORD *)v23 + 2);
                          if (v28)
                          {
                            v29 = *((_DWORD *)v27 + 2);
                            v30 = CFDataGetBytePtr(v28);
                            if (v30)
                            {
                              v31 = (UInt8 *)&v30[v29];
                              if (*(_DWORD *)v31 >= 0x14u)
                              {
                                v32 = *((unsigned int *)v31 + 4);
                                if ((_DWORD)v32)
                                {
                                  v33 = &v31[v32];
                                  v34 = *(unsigned int *)v31;
                                  __s = (char *)&v31[v32];
                                  if (v34 > v32)
                                  {
                                    while (*v33)
                                    {
                                      if (++v33 >= &v31[v34])
                                        goto LABEL_50;
                                    }
                                    EnumeratedString = (char *)CompactCookieHeader::getEnumeratedString((CompactCookieHeader *)v31, 15, 0);
                                    if (*(_DWORD *)v31 >= 0x38u)
                                    {
                                      *(_QWORD *)v54 = *((_QWORD *)v31 + 6);
                                      v36 = floor(*(double *)v54);
                                    }
                                    else
                                    {
                                      v36 = 0;
                                    }
                                    DomainAndPartition::DomainAndPartition(v54, __s, EnumeratedString, 1, v36);
                                    DomainAndPartition::DomainAndPartition((uint64_t)v50, (uint64_t)v54);
                                    MemoryCookies::setCookiesWithPartitionedDomains(a3, v53, v23);
                                    *(_QWORD *)v50 = &off_1E14E9488;
                                    if (v52 && v52 != &v51)
                                      free(v52);
                                    *(_QWORD *)v54 = &off_1E14E9488;
                                    if (v56 && v56 != &v55)
                                      free(v56);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
LABEL_50:
                Entirely = 0;
              }
              else
              {
                Entirely = createParseError(v5, "failed array validation");
              }
              CFRelease((char *)v23 - 16);
              v37 = CFDataGetBytePtr(v18);
              if (v15)
              {
                v38 = &v37[v16];
                do
                {
                  v39 = *v37;
                  v37 += 4;
                  v12 += v39;
                }
                while (v37 < v38);
              }
            }
            else
            {
              Entirely = createParseError(v5, "failed to make array");
            }
          }
          if (v18)
            CFRelease(v18);
        }
        ++v14;
        v13 = Entirely == 0;
      }
      while (v14 < v8 && !Entirely);
    }
    MEMORY[0x186DB7474](v47, 0x1000C8052888210);
    if (v13)
    {
      Entirely = readEntirely(stream, v54, 8);
      if (!Entirely
        && (*(_DWORD *)&v54[4] == 85989127 && bswap32(*(unsigned int *)v54) == v12
         || (Entirely = CFErrorCreate(v5, CFSTR("kCFErrorDomainCFNetwork"), -4000, 0)) == 0))
      {
        if (CFReadStreamHasBytesAvailable(stream))
        {
          v50[0] = 0;
          v40 = readEntirely(stream, (UInt8 *)v50, 4);
          if (!v40)
          {
            v41 = bswap32(v50[0]);
            if ((v41 - 1) > 0xFFFFE)
              return 0;
            v42 = CFDataCreateMutable(v5, v41);
            CFDataSetLength(v42, v41);
            v43 = CFDataGetMutableBytePtr(v42);
            v40 = readEntirely(stream, v43, v41);
            if (!v40)
            {
              *a4 = v42;
              return 0;
            }
            if (v42)
              CFRelease(v42);
          }
          CFRelease(v40);
        }
        return 0;
      }
    }
  }
  return Entirely;
}

void sub_183F5EC38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52)
{
  void *v53;

  if (a52 && a52 != (void *)a11)
    free(a52);
  v53 = (void *)STACK[0x298];
  if (STACK[0x298])
  {
    if (v53 != (void *)a12)
      free(v53);
  }
  _Unwind_Resume(a1);
}

uint64_t MemoryCookies::setCookie(CompactCookieArray **this, CompactCookieHeader *a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  CompactCookieArray *CompactCookieArray;
  CompactCookieArray *v12;
  char *EnumeratedString;
  uint64_t v14;
  const CompactCookieHeader *v15;
  void (**v16)(DomainAndPartition *__hidden);
  uint64_t v17;
  void *v18;
  unsigned __int8 *v19;
  double v20[3];
  uint64_t v21;
  void *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v15 = a2;
  if (*(_DWORD *)a2 < 0x14u)
    return 0;
  v3 = *((unsigned int *)a2 + 4);
  if (!(_DWORD)v3)
    return 0;
  v4 = *(_DWORD *)a2;
  if (v4 <= v3)
    return 0;
  v6 = (char *)a2 + v3;
  v7 = (char *)a2 + v4;
  v8 = v6;
  while (*v8)
  {
    if (++v8 >= v7)
      return 0;
  }
  CompactCookieArray = CompactCookieArray::makeCompactCookieArray(this[1], &v15, (const CompactCookieHeader **)1);
  if (!CompactCookieArray)
  {
    CompactCookieArray::newEmptyArray(0);
    CompactCookieArray = v12;
  }
  EnumeratedString = (char *)CompactCookieHeader::getEnumeratedString(a2, 15, 0);
  v14 = 0;
  if (*(_DWORD *)a2 >= 0x38u)
  {
    v20[0] = *((double *)a2 + 6);
    v14 = floor(v20[0]);
  }
  DomainAndPartition::DomainAndPartition(v20, v6, EnumeratedString, 1, v14);
  DomainAndPartition::DomainAndPartition((uint64_t)&v16, (uint64_t)v20);
  v9 = MemoryCookies::setCookiesWithPartitionedDomains((CFDictionaryRef *)this, v19, CompactCookieArray);
  v16 = &off_1E14E9488;
  if (v18 && v18 != &v17)
    free(v18);
  CFRelease((char *)CompactCookieArray - 16);
  *(_QWORD *)&v20[0] = &off_1E14E9488;
  if (v22 && v22 != &v21)
    free(v22);
  return v9;
}

void sub_183F5EE28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  uint64_t *v54;

  if (a45 && a45 != &a13)
    free(a45);
  a50 = (uint64_t)&off_1E14E9488;
  v54 = (uint64_t *)STACK[0x260];
  if (STACK[0x260])
  {
    if (v54 != &a53)
      free(v54);
  }
  _Unwind_Resume(a1);
}

_QWORD *DomainAndPartition::DomainAndPartition(_QWORD *a1, char *__s, char *a3, uint64_t a4, uint64_t a5)
{
  size_t v10;

  *a1 = &off_1E14E9488;
  if (a3 && *a3)
  {
    v10 = strlen(a3);
    DomainAndPartition::init(a1, a4, a5, __s, (uint64_t)a3, v10);
  }
  else
  {
    DomainAndPartition::init(a1, a4, a5, __s);
  }
  return a1;
}

char *DomainAndPartition::init(_QWORD *a1, uint64_t a2, uint64_t a3, char *__s)
{
  size_t v6;
  size_t v7;
  char *v8;
  char *result;

  a1[1] = a2;
  a1[2] = a3;
  a1[35] = 0;
  a1[38] = 0;
  a1[39] = 0;
  a1[37] = 0;
  v6 = strlen(__s);
  v7 = v6 + 1;
  if (v6 + 1 > 0xFF)
  {
    a1[36] = v7;
    v8 = (char *)malloc_type_malloc(v6 + 1, 0xE61DE4C8uLL);
  }
  else
  {
    v8 = (char *)(a1 + 3);
  }
  a1[35] = v8;
  a1[37] = v8;
  a1[39] = v8;
  result = strncpy(v8, __s, v7);
  a1[38] = 0;
  return result;
}

uint64_t MemoryCookies::setCookiesWithPartitionedDomains(CFDictionaryRef *this, const unsigned __int8 *a2, CompactCookieArray *a3)
{
  char *Value;
  char *v7;
  CompactCookieArray *v8;
  CompactCookieArray *CompactCookieArray;
  uint64_t v10;
  double Current;
  const __CFData *v12;
  double v13;
  const UInt8 *BytePtr;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  const CompactCookieHeader **v18;
  const __CFData *v19;
  const UInt8 *v20;
  const __CFData *v21;
  uint64_t v22;
  const UInt8 *v23;
  const UInt8 *v24;
  double v25;
  CompactCookieArray *v26;
  const __CFData *v27;
  const UInt8 *v28;

  Value = (char *)CFDictionaryGetValue(this[3], a2);
  if (!Value)
  {
    Current = CFAbsoluteTimeGetCurrent();
    v12 = (const __CFData *)*((_QWORD *)a3 + 2);
    if (v12)
    {
      v13 = Current;
      BytePtr = CFDataGetBytePtr(v12);
      if (BytePtr)
      {
        v15 = *((unsigned int *)BytePtr + 1);
        if ((_DWORD)v15)
        {
          v16 = malloc_type_malloc(8 * v15, 0x2004093837F09uLL);
          v17 = 0;
          v18 = 0;
          do
          {
            v19 = (const __CFData *)*((_QWORD *)a3 + 2);
            if (v19)
            {
              if (CFDataGetBytePtr(v19))
              {
                v20 = CFDataGetBytePtr(*((CFDataRef *)a3 + 2));
                v21 = (const __CFData *)*((_QWORD *)a3 + 2);
                if (v21)
                {
                  v22 = *(unsigned int *)&v20[v17 + 8];
                  v23 = CFDataGetBytePtr(v21);
                  if (v23)
                  {
                    v24 = &v23[v22];
                    if (*(_DWORD *)&v23[v22] >= 0xCu && (*((_DWORD *)v24 + 2) & 2) != 0)
                      goto LABEL_20;
                    v25 = 0.0;
                    if (*(_DWORD *)v24 >= 0x30u)
                      v25 = floor(*((double *)v24 + 5));
                    if (v25 > v13)
                    {
LABEL_20:
                      v16[v18] = v24;
                      v18 = (const CompactCookieHeader **)((_DWORD)v18 + 1);
                    }
                  }
                }
              }
            }
            v17 += 4;
          }
          while (4 * v15 != v17);
          if ((_DWORD)v15 == (_DWORD)v18)
          {
            free(v16);
          }
          else
          {
            v26 = (CompactCookieArray *)CFGetAllocator((char *)a3 - 16);
            CompactCookieArray = CompactCookieArray::makeCompactCookieArray(v26, (const CompactCookieHeader **)v16, v18);
            free(v16);
            if (CompactCookieArray)
            {
LABEL_27:
              v27 = (const __CFData *)*((_QWORD *)CompactCookieArray + 2);
              if (!v27 || (v28 = CFDataGetBytePtr(v27)) == 0 || !*((_DWORD *)v28 + 1))
              {
                v10 = 0;
                v7 = (char *)CompactCookieArray - 16;
                goto LABEL_32;
              }
              goto LABEL_30;
            }
          }
        }
      }
    }
    CFRetain((char *)a3 - 16);
    CompactCookieArray = a3;
    goto LABEL_27;
  }
  v7 = Value;
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
  v8 = CompactCookieArray::_mungeCookies((CompactCookieArray *)(v7 + 16), a3, (const CompactCookieArray *)1);
  if (v8 == (CompactCookieArray *)(v7 + 16))
  {
    v10 = 0;
LABEL_32:
    CFRelease(v7);
    return v10;
  }
  CompactCookieArray = v8;
  if (v8)
  {
LABEL_30:
    v7 = (char *)CompactCookieArray - 16;
    CFDictionarySetValue(this[3], a2, (char *)CompactCookieArray - 16);
    v10 = 1;
    goto LABEL_32;
  }
  return 0;
}

CompactCookieArray *CompactCookieArray::makeCompactCookieArray(CompactCookieArray *this, const CompactCookieHeader **a2, const CompactCookieHeader **a3)
{
  unsigned int v3;
  _QWORD *Instance;
  CompactCookieArray *v6;
  CompactCookieArray *v7;

  v3 = a3;
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  v6 = (CompactCookieArray *)Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    v6 = (CompactCookieArray *)(Instance + 2);
    Instance[4] = 0;
  }
  CompactCookieArray::CompactCookieArray(v6, a2, v3);
  if (!CompactCookieArray::assertCookiesValid(v7))
  {
    CFRelease((char *)v6 - 16);
    return 0;
  }
  return v6;
}

void CompactCookieArray::CompactCookieArray(CompactCookieArray *this, const CompactCookieHeader **a2, unsigned int a3)
{
  const __CFAllocator *v6;
  __CFData *Mutable;
  CFMutableDataRef v8;

  *(_QWORD *)this = &off_1E14E92A8;
  *((_QWORD *)this + 1) = &unk_1E14E92F0;
  v6 = CFGetAllocator((char *)this - 16);
  Mutable = CFDataCreateMutable(v6, 0);
  v8 = Mutable;
  *((_QWORD *)this + 2) = CookieArrayViewConstructionKit::createArrayView(&v8, a2, a3);
  if (Mutable)
    CFRelease(Mutable);
}

void sub_183F5F2EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v2;

  if (v2)
    CFRelease(v2);
  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

CFMutableDataRef CookieArrayViewConstructionKit::createArrayView(CFMutableDataRef *this, const CompactCookieHeader **a2, unsigned int a3)
{
  CFIndex v6;
  UInt8 *MutableBytePtr;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  const UInt8 *v11;
  CFIndex v12;
  CFIndex Length;
  CFMutableDataRef result;
  uint8_t buf[4];
  CFIndex v16;
  __int16 v17;
  CFIndex v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v6 = 4 * a3 + 12;
  CFDataSetLength(*this, v6);
  MutableBytePtr = CFDataGetMutableBytePtr(*this);
  *(_DWORD *)MutableBytePtr = 0x10000;
  *((_DWORD *)MutableBytePtr + 1) = a3;
  if (a3)
  {
    v8 = 0;
    v9 = a3;
    v10 = MEMORY[0x1E0C81028];
    do
    {
      if (v6 != CFDataGetLength(*this) && os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        Length = CFDataGetLength(*this);
        *(_DWORD *)buf = 134218240;
        v16 = v6;
        v17 = 2048;
        v18 = Length;
        _os_log_fault_impl(&dword_183ECA000, v10, OS_LOG_TYPE_FAULT, "currentLength %ld != getCurrentLength %ld", buf, 0x16u);
      }
      *(_DWORD *)&CFDataGetMutableBytePtr(*this)[4 * v8 + 8] = v6;
      v11 = (const UInt8 *)a2[v8];
      if (v11)
      {
        if (*(_DWORD *)v11 >= 4u)
          v12 = *(unsigned int *)v11;
        else
          v12 = 0;
        CFDataAppendBytes(*this, v11, v12);
        v6 += v12;
      }
      ++v8;
    }
    while (v9 != v8);
  }
  result = *this;
  if (*this)
    return (CFMutableDataRef)CFRetain(result);
  return result;
}

CompactCookieArray *CompactCookieArray::_mungeCookies(CompactCookieArray *this, const CompactCookieArray *a2, const CompactCookieArray *a3)
{
  CompactCookieArray *v4;
  const __CFData *v5;
  const UInt8 *BytePtr;
  unsigned int v7;
  const __CFData *v8;
  const UInt8 *v9;
  unsigned int v10;
  unsigned int v11;
  const CompactCookieHeader **v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  const __CFData *v16;
  const UInt8 *v17;
  const UInt8 *v18;
  uint64_t v19;
  CompactCookieHeader *v20;
  const __CFData *v21;
  const UInt8 *v22;
  const UInt8 *v23;
  uint64_t v24;
  CompactCookieHeader *v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  const __CFData *v29;
  const UInt8 *v30;
  const UInt8 *v31;
  uint64_t v32;
  const CompactCookieHeader *v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int v37;
  const __CFData *v38;
  const UInt8 *v39;
  const UInt8 *v40;
  uint64_t v41;
  const CompactCookieHeader *v42;
  double Current;
  unsigned int v44;
  uint64_t v45;
  const CompactCookieHeader **v46;
  const CompactCookieHeader *v47;
  double v48;
  _QWORD *Instance;
  int v51;
  int v52;
  uint8_t buf[8];
  _OWORD v54[32];
  uint64_t v55;

  v52 = (int)a3;
  v4 = this;
  v55 = *MEMORY[0x1E0C80C00];
  memset(v54, 0, sizeof(v54));
  v5 = (const __CFData *)*((_QWORD *)this + 2);
  if (v5 && (BytePtr = CFDataGetBytePtr(v5)) != 0)
    v7 = *((_DWORD *)BytePtr + 1);
  else
    v7 = 0;
  v8 = (const __CFData *)*((_QWORD *)a2 + 2);
  if (v8 && (v9 = CFDataGetBytePtr(v8)) != 0)
    v10 = *((_DWORD *)v9 + 1);
  else
    v10 = 0;
  if (v52)
    v11 = v10;
  else
    v11 = 0;
  if (v11 + v7 < 0x41)
    v12 = (const CompactCookieHeader **)v54;
  else
    v12 = (const CompactCookieHeader **)operator new[]();
  v13 = 0;
  v14 = 0;
  v15 = 0;
  if (v7)
  {
    v51 = 0;
    if (v10)
    {
      v51 = 0;
      v15 = 0;
      v14 = 0;
      v13 = 0;
      do
      {
        v16 = (const __CFData *)*((_QWORD *)v4 + 2);
        if (v16 && CFDataGetBytePtr(v16))
        {
          v17 = CFDataGetBytePtr(*((CFDataRef *)v4 + 2));
          v18 = (const UInt8 *)*((_QWORD *)v4 + 2);
          v19 = *(unsigned int *)&v17[4 * v14 + 8];
          if (v18)
            v18 = CFDataGetBytePtr((CFDataRef)v18);
          v20 = (CompactCookieHeader *)&v18[v19];
        }
        else
        {
          v20 = 0;
        }
        v21 = (const __CFData *)*((_QWORD *)a2 + 2);
        if (v21 && CFDataGetBytePtr(v21))
        {
          v22 = CFDataGetBytePtr(*((CFDataRef *)a2 + 2));
          v23 = (const UInt8 *)*((_QWORD *)a2 + 2);
          v24 = *(unsigned int *)&v22[4 * v15 + 8];
          if (v23)
            v23 = CFDataGetBytePtr((CFDataRef)v23);
          v25 = (CompactCookieHeader *)&v23[v24];
        }
        else
        {
          v25 = 0;
        }
        v26 = cookieHeaderSort(v20, v25);
        switch(v26)
        {
          case -1:
            v12[v13++] = v20;
            ++v14;
            break;
          case 1:
            if (v52)
            {
              v12[v13++] = v25;
              v51 = 1;
            }
            ++v15;
            break;
          case 0:
            if (v52)
              v12[v13++] = v25;
            ++v14;
            ++v15;
            v51 = 1;
            break;
        }
      }
      while (v14 < v7 && v15 < v10);
    }
  }
  else
  {
    v51 = 0;
  }
  if (v7 != v14 && v10 != v15 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "How did I get here then?", buf, 2u);
  }
  v27 = v7 - v14;
  if (v7 <= v14)
  {
    v34 = v13;
  }
  else
  {
    v28 = 4 * v14 + 8;
    do
    {
      v29 = (const __CFData *)*((_QWORD *)v4 + 2);
      if (v29 && CFDataGetBytePtr(v29))
      {
        v30 = CFDataGetBytePtr(*((CFDataRef *)v4 + 2));
        v31 = (const UInt8 *)*((_QWORD *)v4 + 2);
        v32 = *(unsigned int *)&v30[v28];
        if (v31)
          v31 = CFDataGetBytePtr((CFDataRef)v31);
        v33 = (const CompactCookieHeader *)&v31[v32];
      }
      else
      {
        v33 = 0;
      }
      v34 = v13 + 1;
      v12[v13] = v33;
      v28 += 4;
      ++v13;
      --v27;
    }
    while (v27);
  }
  if (v52 && (v35 = v10 - v15, v10 > v15))
  {
    v36 = 4 * v15 + 8;
    v37 = v34;
    do
    {
      v38 = (const __CFData *)*((_QWORD *)a2 + 2);
      if (v38 && CFDataGetBytePtr(v38))
      {
        v39 = CFDataGetBytePtr(*((CFDataRef *)a2 + 2));
        v40 = (const UInt8 *)*((_QWORD *)a2 + 2);
        v41 = *(unsigned int *)&v39[v36];
        if (v40)
          v40 = CFDataGetBytePtr((CFDataRef)v40);
        v42 = (const CompactCookieHeader *)&v40[v41];
      }
      else
      {
        v42 = 0;
      }
      v34 = v37 + 1;
      v12[v37] = v42;
      v36 += 4;
      ++v37;
      --v35;
    }
    while (v35);
  }
  else if (!v51)
  {
    CFRetain((char *)v4 - 16);
    goto LABEL_86;
  }
  Current = CFAbsoluteTimeGetCurrent();
  v44 = 0;
  if (v34)
  {
    v45 = v34;
    v46 = v12;
    do
    {
      v47 = *v46;
      if (*v46)
      {
        if (*(_DWORD *)v47 >= 0xCu && (*((_DWORD *)v47 + 2) & 2) != 0)
          goto LABEL_79;
        v48 = 0.0;
        if (*(_DWORD *)v47 >= 0x30u)
        {
          *(_QWORD *)buf = *((_QWORD *)v47 + 5);
          v48 = floor(*(double *)buf);
        }
        if (Current < v48)
LABEL_79:
          v12[v44++] = v47;
      }
      ++v46;
      --v45;
    }
    while (v45);
  }
  CFGetAllocator((char *)v4 - 16);
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  v4 = (CompactCookieArray *)Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    v4 = (CompactCookieArray *)(Instance + 2);
    Instance[4] = 0;
  }
  CompactCookieArray::CompactCookieArray(v4, v12, v44);
LABEL_86:
  if (v12 != (const CompactCookieHeader **)v54)
    MEMORY[0x186DB7474](v12, 0x60C8044C4A2DFLL);
  return v4;
}

uint64_t cookieHeaderSort(CompactCookieHeader *a1, CompactCookieHeader *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  _BYTE *v23;
  const char *EnumeratedString;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  _BYTE *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  _BYTE *v35;
  uint64_t v36;
  int v37;
  int v38;
  BOOL v39;
  BOOL v40;
  int v41;

  if (*(_DWORD *)a1 >= 0x14u
    && (v4 = *((unsigned int *)a1 + 4), (_DWORD)v4)
    && (v5 = *(_DWORD *)a1, v5 > v4))
  {
    v6 = (unint64_t)a1 + v4;
    v7 = (char *)a1 + v5;
    v8 = (_BYTE *)v6;
    while (*v8)
    {
      if (++v8 >= v7)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v6 = 0;
  }
  if (*(_DWORD *)a2 >= 0x14u
    && (v9 = *((unsigned int *)a2 + 4), (_DWORD)v9)
    && (v10 = *(_DWORD *)a2, v10 > v9))
  {
    v11 = (unint64_t)a2 + v9;
    v12 = (char *)a2 + v10;
    v13 = (_BYTE *)v11;
    while (*v13)
    {
      if (++v13 >= v12)
        goto LABEL_14;
    }
  }
  else
  {
LABEL_14:
    v11 = 0;
  }
  if (v6 | v11)
  {
    if (!v6 && v11)
      return 1;
    if (v6 && !v11)
      return 0xFFFFFFFFLL;
    v37 = strcasecmp((const char *)v6, (const char *)v11);
    if (v37 < 0)
      return 0xFFFFFFFFLL;
    if (v37)
      return 1;
  }
  if (*(_DWORD *)a1 >= 0x1Cu
    && (v14 = *((unsigned int *)a1 + 6), (_DWORD)v14)
    && (v15 = *(_DWORD *)a1, v15 > v14))
  {
    v16 = (unint64_t)a1 + v14;
    v17 = (char *)a1 + v15;
    v18 = (_BYTE *)v16;
    while (*v18)
    {
      if (++v18 >= v17)
        goto LABEL_22;
    }
  }
  else
  {
LABEL_22:
    v16 = 0;
  }
  if (*(_DWORD *)a2 >= 0x1Cu
    && (v19 = *((unsigned int *)a2 + 6), (_DWORD)v19)
    && (v20 = *(_DWORD *)a2, v20 > v19))
  {
    v21 = (unint64_t)a2 + v19;
    v22 = (char *)a2 + v20;
    v23 = (_BYTE *)v21;
    while (*v23)
    {
      if (++v23 >= v22)
        goto LABEL_29;
    }
  }
  else
  {
LABEL_29:
    v21 = 0;
  }
  if (v16 | v21)
  {
    if (!v16 && v21)
      return 1;
    if (v16 && !v21)
      return 0xFFFFFFFFLL;
    v38 = strcasecmp((const char *)v16, (const char *)v21);
    if (v38 < 0)
      return 0xFFFFFFFFLL;
    if (v38)
      return 1;
  }
  EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString(a1, 15, 0);
  v25 = (const char *)CompactCookieHeader::getEnumeratedString(a2, 15, 0);
  if ((unint64_t)EnumeratedString | (unint64_t)v25)
  {
    if (!EnumeratedString && v25)
      return 1;
    if (EnumeratedString && !v25)
      return 0xFFFFFFFFLL;
    v41 = strcasecmp(EnumeratedString, v25);
    if (v41 < 0)
      return 0xFFFFFFFFLL;
    if (v41)
      return 1;
  }
  if (*(_DWORD *)a1 >= 0x18u
    && (v26 = *((unsigned int *)a1 + 5), (_DWORD)v26)
    && (v27 = *(_DWORD *)a1, v27 > v26))
  {
    v28 = (unint64_t)a1 + v26;
    v29 = (char *)a1 + v27;
    v30 = (_BYTE *)v28;
    while (*v30)
    {
      if (++v30 >= v29)
        goto LABEL_38;
    }
  }
  else
  {
LABEL_38:
    v28 = 0;
  }
  if (*(_DWORD *)a2 >= 0x18u
    && (v31 = *((unsigned int *)a2 + 5), (_DWORD)v31)
    && (v32 = *(_DWORD *)a2, v32 > v31))
  {
    v33 = (unint64_t)a2 + v31;
    v34 = (char *)a2 + v32;
    v35 = (_BYTE *)v33;
    while (*v35)
    {
      if (++v35 >= v34)
        goto LABEL_45;
    }
  }
  else
  {
LABEL_45:
    v33 = 0;
  }
  if (!(v28 | v33))
    return 0;
  if (v33)
    v39 = 0;
  else
    v39 = v28 != 0;
  if (v33)
    v40 = v28 == 0;
  else
    v40 = 0;
  v36 = 0xFFFFFFFFLL;
  if (!v40 && !v39)
  {
    if (!strcmp((const char *)v28, (const char *)v33))
      return 0;
    return 0xFFFFFFFFLL;
  }
  return v36;
}

BOOL CompactCookieArray::assertCookiesValid(CompactCookieArray *this)
{
  const UInt8 *v1;
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  unint64_t v5;
  unint64_t v6;
  __int128 *v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v12;
  char *v13;
  unsigned int v14;
  int v16;
  const char *EnumeratedString;
  const char *v18;
  BOOL v19;
  unsigned int v21;
  uint8_t v23[8];
  uint64_t v24;
  uint8_t buf[15];
  unsigned __int8 v26;

  v24 = 0;
  v1 = CompactCookieArray::peekData(this, &v24);
  v2 = 0;
  if (v1)
  {
    v3 = v24;
    if (v24 >= 12)
    {
      v4 = v1;
      if ((v1 & 7) != 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v23 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "this must always be 16 byte aligned", v23, 2u);
      }
      if (*v4 == 0x10000)
      {
        v5 = v4[1];
        v2 = 1;
        if ((_DWORD)v5)
        {
          v6 = 0;
          v7 = (__int128 *)&unk_18411E210;
LABEL_9:
          if (v6 == v5)
          {
            v8 = v5;
          }
          else
          {
            v8 = v6++;
            v9 = v3;
            if (v6 < v5)
              v9 = v4[v6 + 2];
            v10 = v4[v8 + 2];
            if (v3 >= v10 && v3 >= v9)
            {
              v12 = v9 - v10;
              if (v12 >= 5)
              {
                v13 = (char *)v4 + v10;
                v14 = *(_DWORD *)((char *)v4 + v10);
                if (v14 <= 0x8000 && v14 <= v12)
                {
                  if (*(_DWORD *)v13 != v14 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "end calculation wrong", buf, 2u);
                  }
                  v26 = 0;
                  while (2)
                  {
                    v16 = *((_DWORD *)v7 - 5);
                    switch(v16)
                    {
                      case 0:
                      case 1:
                      case 13:
                      case 15:
                        EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString((CompactCookieHeader *)v13, v16, &v26);
                        if (!EnumeratedString || !(strlen(EnumeratedString) >> 15))
                          goto LABEL_31;
                        break;
                      case 3:
                        if (*(_DWORD *)v13 < 0xCu
                          || (*((_DWORD *)v13 + 2) & 2) == 0
                          || *(_DWORD *)v13 >= 0xCu && (*((_DWORD *)v13 + 2) & 2) != 0)
                        {
                          goto LABEL_31;
                        }
                        break;
                      case 4:
                      case 8:
                      case 10:
                        v18 = (const char *)CompactCookieHeader::getEnumeratedString((CompactCookieHeader *)v13, v16, &v26);
                        if (v18 && strlen(v18) < 0x8000)
                          goto LABEL_31;
                        break;
                      case 6:
                        if (*(_DWORD *)v13 < 0xCu
                          || (*((_DWORD *)v13 + 2) & 4) == 0
                          || *(_DWORD *)v13 >= 0xCu && (*((_DWORD *)v13 + 2) & 4) != 0)
                        {
                          goto LABEL_31;
                        }
                        break;
                      case 11:
                        if (*(_DWORD *)v13 <= 0xFu)
                        {
                          v26 = 1;
                          goto LABEL_31;
                        }
                        v21 = *((_DWORD *)v13 + 3);
                        if (v21 <= 0x3FF && (!v21 || 2 * v21 + 56 <= *(_DWORD *)v13))
                          goto LABEL_31;
                        break;
                      case 12:
                        if (*(_DWORD *)v13 < 0xCu
                          || (*((_DWORD *)v13 + 2) & 1) == 0
                          || *(_DWORD *)v13 >= 0xCu && (*((_DWORD *)v13 + 2) & 1) != 0)
                        {
                          goto LABEL_31;
                        }
                        break;
                      case 17:
                        if (*(_DWORD *)v13 < 0xCu
                          || (*((_DWORD *)v13 + 2) & 0x20) == 0
                          || *(_DWORD *)v13 >= 0xCu && (*((_DWORD *)v13 + 2) & 0x20) != 0)
                        {
                          goto LABEL_31;
                        }
                        break;
                      case 18:
                        if (*(_DWORD *)v13 < 0xCu
                          || (*((_DWORD *)v13 + 2) & 0x40) == 0
                          || *(_DWORD *)v13 >= 0xCu && (*((_DWORD *)v13 + 2) & 0x40) != 0)
                        {
                          goto LABEL_31;
                        }
                        break;
                      default:
LABEL_31:
                        v19 = v7 >= &xmmword_18411E378;
                        v7 = (__int128 *)((char *)v7 + 20);
                        if (!v19 && v26 == 0)
                          continue;
                        v7 = (__int128 *)&unk_18411E210;
                        if (!v26)
                          goto LABEL_9;
                        break;
                    }
                    break;
                  }
                }
              }
            }
          }
          return v8 >= v5;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v2;
}

const UInt8 *CompactCookieHeader::getEnumeratedString(CompactCookieHeader *a1, int a2, unsigned __int8 *a3)
{
  const UInt8 *BytePtr;
  uint64_t v5;
  uint64_t v6;
  const UInt8 *v7;
  const UInt8 *v8;
  uint64_t v9;
  uint64_t v10;
  const UInt8 *v11;
  const UInt8 *v12;
  uint64_t v13;
  uint64_t v14;
  const UInt8 *v15;
  const UInt8 *v16;
  uint64_t v17;
  uint64_t v18;
  const UInt8 *v19;
  const UInt8 *v20;
  uint64_t v21;
  uint64_t v22;
  const UInt8 *v23;
  const UInt8 *v24;
  uint64_t v25;
  uint64_t v26;
  const UInt8 *v27;
  const UInt8 *v28;
  const __CFDictionary *v29;
  const __CFDictionary *v30;
  const __CFString *Value;
  const __CFString *v32;
  const char *CStringPtr;
  uint64_t Length;
  CFIndex v36;
  __CFData *Mutable;
  char *MutableBytePtr;

  BytePtr = 0;
  switch(a2)
  {
    case 0:
      if (*(_DWORD *)a1 < 0x24u)
        return 0;
      v5 = *((unsigned int *)a1 + 8);
      if (!(_DWORD)v5)
        return 0;
      v6 = *(_DWORD *)a1;
      if (v6 <= v5)
        goto LABEL_43;
      BytePtr = (const UInt8 *)a1 + v5;
      v7 = (const UInt8 *)a1 + v6;
      v8 = BytePtr;
      while (*v8)
      {
        if (++v8 >= v7)
          goto LABEL_43;
      }
      return BytePtr;
    case 1:
      if (*(_DWORD *)a1 < 0x28u)
        return 0;
      v9 = *((unsigned int *)a1 + 9);
      if (!(_DWORD)v9)
        return 0;
      v10 = *(_DWORD *)a1;
      if (v10 <= v9)
        goto LABEL_43;
      BytePtr = (const UInt8 *)a1 + v9;
      v11 = (const UInt8 *)a1 + v10;
      v12 = BytePtr;
      while (*v12)
      {
        if (++v12 >= v11)
          goto LABEL_43;
      }
      return BytePtr;
    case 4:
      if (*(_DWORD *)a1 < 0x14u)
        return 0;
      v13 = *((unsigned int *)a1 + 4);
      if (!(_DWORD)v13)
        return 0;
      v14 = *(_DWORD *)a1;
      if (v14 <= v13)
        goto LABEL_43;
      BytePtr = (const UInt8 *)a1 + v13;
      v15 = (const UInt8 *)a1 + v14;
      v16 = BytePtr;
      while (*v16)
      {
        if (++v16 >= v15)
          goto LABEL_43;
      }
      return BytePtr;
    case 8:
      if (*(_DWORD *)a1 < 0x18u)
        return 0;
      v17 = *((unsigned int *)a1 + 5);
      if (!(_DWORD)v17)
        return 0;
      v18 = *(_DWORD *)a1;
      if (v18 <= v17)
        goto LABEL_43;
      BytePtr = (const UInt8 *)a1 + v17;
      v19 = (const UInt8 *)a1 + v18;
      v20 = BytePtr;
      while (*v20)
      {
        if (++v20 >= v19)
          goto LABEL_43;
      }
      return BytePtr;
    case 10:
      if (*(_DWORD *)a1 < 0x1Cu)
        return 0;
      v21 = *((unsigned int *)a1 + 6);
      if (!(_DWORD)v21)
        return 0;
      v22 = *(_DWORD *)a1;
      if (v22 <= v21)
        goto LABEL_43;
      BytePtr = (const UInt8 *)a1 + v21;
      v23 = (const UInt8 *)a1 + v22;
      v24 = BytePtr;
      while (*v24)
      {
        if (++v24 >= v23)
          goto LABEL_43;
      }
      return BytePtr;
    case 13:
      if (*(_DWORD *)a1 < 0x20u)
        return 0;
      v25 = *((unsigned int *)a1 + 7);
      if (!(_DWORD)v25)
        return 0;
      v26 = *(_DWORD *)a1;
      if (v26 <= v25)
      {
LABEL_43:
        if (!a3)
          return 0;
        BytePtr = 0;
        *a3 = 1;
      }
      else
      {
        BytePtr = (const UInt8 *)a1 + v25;
        v27 = (const UInt8 *)a1 + v26;
        v28 = BytePtr;
        while (*v28)
        {
          if (++v28 >= v27)
            goto LABEL_43;
        }
      }
      return BytePtr;
    case 15:
      v29 = (const __CFDictionary *)CompactCookieHeader::copyExtraInfo(a1, a3);
      if (!v29)
        return 0;
      v30 = v29;
      Value = (const __CFString *)CFDictionaryGetValue(v29, &gConstantCFStringValueTable[7* ((CookieData::sCookieFieldInfo[5 * a2 + 1] >> 20) & 0x3FF)]);
      if (!Value)
        goto LABEL_53;
      v32 = Value;
      CStringPtr = CFStringGetCStringPtr(Value, 0x8000100u);
      if (CStringPtr)
      {
        BytePtr = (const UInt8 *)CStringPtr;
        CFRetain(v32);
        CFAutorelease(v32);
      }
      else
      {
        Length = CFStringGetLength(v32);
        if (Length < 1)
        {
LABEL_53:
          BytePtr = 0;
        }
        else
        {
          v36 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
          Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v36);
          MutableBytePtr = (char *)CFDataGetMutableBytePtr(Mutable);
          CFStringGetCString(v32, MutableBytePtr, v36, 0x8000100u);
          CFAutorelease(Mutable);
          BytePtr = CFDataGetBytePtr(Mutable);
        }
      }
      CFRelease(v30);
      return BytePtr;
    default:
      return BytePtr;
  }
}

CFPropertyListRef CompactCookieHeader::copyExtraInfo(CompactCookieHeader *this, unsigned __int8 *a2)
{
  unint64_t v2;
  const UInt8 *v3;
  CFPropertyListRef v4;
  const __CFAllocator *v6;
  const __CFData *v7;

  if (*(_DWORD *)this < 0xCu)
    return 0;
  v2 = *((unsigned int *)this + 2);
  if (v2 < 0x100)
    return 0;
  v3 = (const UInt8 *)this + *(_DWORD *)this - (v2 >> 8);
  if (v3 < (const UInt8 *)this || __CFADD__(v2 >> 8, v3))
  {
    if (a2)
    {
      v4 = 0;
      *a2 = 1;
      return v4;
    }
    return 0;
  }
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v3, v2 >> 8, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v4 = CFPropertyListCreateWithData(v6, v7, 0, 0, 0);
  if (v7)
    CFRelease(v7);
  return v4;
}

const UInt8 *CompactCookieArray::peekData(CompactCookieArray *this, uint64_t *a2)
{
  const UInt8 *result;

  result = (const UInt8 *)*((_QWORD *)this + 2);
  if (result)
  {
    *a2 = CFDataGetLength((CFDataRef)result);
    return CFDataGetBytePtr(*((CFDataRef *)this + 2));
  }
  return result;
}

CFErrorRef readEntirely(CFReadStreamRef stream, UInt8 *buffer, uint64_t a3)
{
  UInt8 *v3;
  UInt8 *v5;
  CFIndex v6;
  const __CFAllocator *v8;

  if (a3 < 1)
    return 0;
  v3 = buffer;
  v5 = &buffer[a3];
  while (1)
  {
    v6 = CFReadStreamRead(stream, v3, v5 - v3);
    if (!v6)
    {
      v8 = CFGetAllocator(stream);
      return CFErrorCreate(v8, CFSTR("kCFErrorDomainCFNetwork"), -4000, 0);
    }
    if (v6 == -1)
      break;
    v3 += v6;
    if (v3 >= v5)
      return 0;
  }
  return CFReadStreamCopyError(stream);
}

CompactCookieArray *CompactCookieArray::makeCompactCookieArray(CompactCookieArray *this, const __CFAllocator *a2, const __CFData *a3)
{
  _QWORD *Instance;
  CompactCookieArray *v5;
  CFTypeRef v6;

  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  v5 = (CompactCookieArray *)Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    v5 = (CompactCookieArray *)(Instance + 2);
    Instance[4] = 0;
  }
  *(_QWORD *)v5 = &off_1E14E92A8;
  *((_QWORD *)v5 + 1) = &unk_1E14E92F0;
  if (a2)
    v6 = CFRetain(a2);
  else
    v6 = 0;
  *((_QWORD *)v5 + 2) = v6;
  if (!CompactCookieArray::assertCookiesValid(v5))
  {
    CFRelease((char *)v5 - 16);
    return 0;
  }
  return v5;
}

void sub_183F60470(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

const __CFArray *HTTPCookieStorage::copyCookiesForURL(HTTPCookieStorage *this, const HTTPCookieStoragePolicy *a2, unsigned int a3)
{
  char *v6;
  const __CFAllocator *v7;
  const __CFArray *Mutable;
  const __CFURL *v9;
  const __CFString *v10;
  SInt32 v11;
  unsigned __int16 v12;
  const __CFString *v13;
  int CanonicalString;
  const __CFURL *v15;
  const __CFAllocator *v16;
  char *v17;
  const __CFString *v18;
  uint64_t v19;
  CFAbsoluteTime Current;
  const char *v21;
  CookieUtils *v22;
  char *v23;
  const __CFString *v24;
  uint64_t v25;
  char *v26;
  const __CFString *v27;
  uint64_t v28;
  CFAbsoluteTime v29;
  CFAbsoluteTime v30;
  const __CFDictionary *v31;
  __CFArray *v32;
  CFIndex Count;
  const __CFAllocator *i;
  void *ValueAtIndex;
  uint64_t v36;
  _DWORD *v37;
  char v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const __CFURL *v44;
  double v45;
  const __CFDictionary *v46;
  const __CFNumber *v47;
  CFIndex v48;
  unint64_t v49;
  const __CFNumber *v50;
  uint64_t v51;
  uint64_t v52;
  const __CFArray *v53;
  CompactCookieArray *CompactCookieArray;
  _QWORD v56[3];
  uint64_t v57;
  void *v58;
  _QWORD v59[3];
  uint64_t v60;
  void *v61;
  _QWORD v62[3];
  _BYTE v63[256];
  void *v64;
  _QWORD v65[3];
  uint64_t v66;
  void *v67;
  _QWORD v68[3];
  uint64_t v69;
  void *v70;
  CFAllocatorRef allocator;
  void *value;
  void *ptr;
  UInt8 v74[1024];
  void (**v75)(CookieHostName *__hidden);
  char *v76;
  uint64_t v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  CFRange v81;

  v80 = *MEMORY[0x1E0C80C00];
  v6 = (char *)this - 16;
  v7 = CFGetAllocator((char *)this - 16);
  Mutable = CFArrayCreateMutable(v7, 0, MEMORY[0x1E0C9B378]);
  v9 = CFURLCopyAbsoluteURL(*((CFURLRef *)a2 + 2));
  v10 = CFURLCopyPath(v9);
  CFRelease(v9);
  v11 = CFURLGetPortNumber(*((CFURLRef *)a2 + 2));
  v12 = v11;
  if ((v11 & 0x80000000) == 0)
    goto LABEL_11;
  v13 = CFURLCopyScheme(*((CFURLRef *)a2 + 2));
  CanonicalString = _findCanonicalString(v13, 0xFu);
  v12 = 0;
  if (CanonicalString <= 592469427)
  {
    if (CanonicalString != 587242915)
    {
      if (CanonicalString != 588299686)
      {
LABEL_9:
        if (!v13)
          goto LABEL_11;
        goto LABEL_10;
      }
      goto LABEL_50;
    }
LABEL_8:
    v12 = 80;
    goto LABEL_9;
  }
  if (CanonicalString != 593526198)
  {
    if (CanonicalString != 592469428)
      goto LABEL_9;
    goto LABEL_8;
  }
LABEL_50:
  v12 = 443;
  if (v13)
LABEL_10:
    CFRelease(v13);
LABEL_11:
  if (v10)
  {
    if (CFStringGetLength(v10))
      goto LABEL_15;
    CFRelease(v10);
  }
  v10 = (const __CFString *)CFRetain(CFSTR("/"));
LABEL_15:
  CFGetAllocator(v6);
  CookieHostName::CookieHostName((CookieHostName *)&v75, *((CFURLRef *)a2 + 2), v15);
  if (v77)
  {
    v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    allocator = (CFAllocatorRef)*MEMORY[0x1E0C9AE00];
    value = (void *)1023;
    if (v10)
    {
      ptr = _CFStringGetOrCreateCString(v16, v10, v74, (uint64_t *)&value, 0x8000100u);
      if (v77)
        v17 = v76 + 1;
      else
        v17 = 0;
    }
    else
    {
      v74[0] = 0;
      value = 0;
      ptr = v74;
      v17 = v76 + 1;
    }
    v18 = (const __CFString *)*((_QWORD *)a2 + 4);
    if (*((_BYTE *)a2 + 56))
    {
      v19 = *((_QWORD *)a2 + 8);
    }
    else
    {
      *((_BYTE *)a2 + 56) = 1;
      Current = CFAbsoluteTimeGetCurrent();
      *((CFAbsoluteTime *)a2 + 8) = Current;
      v19 = *(_QWORD *)&Current;
    }
    DomainAndPartition::DomainAndPartition(v68, v17, v18, *((_QWORD *)a2 + 7), v19);
    DomainAndPartition::DomainAndPartition((uint64_t)v65, (uint64_t)v68);
    HTTPCookieStorage::lookupAndCopyCookies(*((_QWORD **)this + 2), (uint64_t)v65, (const char *)ptr, a3, v12, Mutable);
    v65[0] = &off_1E14E9488;
    if (v67 && v67 != &v66)
      free(v67);
    if (v77)
      v22 = (CookieUtils *)(v76 + 1);
    else
      v22 = 0;
    if (CookieUtils::looksLikeIPAddress(v22, v21))
    {
      if (v77)
        v23 = v76;
      else
        v23 = 0;
      v24 = (const __CFString *)*((_QWORD *)a2 + 4);
      if (*((_BYTE *)a2 + 56))
      {
        v25 = *((_QWORD *)a2 + 8);
      }
      else
      {
        *((_BYTE *)a2 + 56) = 1;
        v30 = CFAbsoluteTimeGetCurrent();
        *((CFAbsoluteTime *)a2 + 8) = v30;
        v25 = *(_QWORD *)&v30;
      }
      DomainAndPartition::DomainAndPartition(v62, v23, v24, *((_QWORD *)a2 + 7), v25);
      DomainAndPartition::DomainAndPartition((uint64_t)v56, (uint64_t)v62);
      HTTPCookieStorage::lookupAndCopyCookies(*((_QWORD **)this + 2), (uint64_t)v56, (const char *)ptr, a3, v12, Mutable);
      v56[0] = &off_1E14E9488;
      if (v58 && v58 != &v57)
        free(v58);
      v62[0] = &off_1E14E9488;
      if (v64 && v64 != v63)
        free(v64);
    }
    else
    {
      do
      {
        if (v77)
          v26 = v76;
        else
          v26 = 0;
        v27 = (const __CFString *)*((_QWORD *)a2 + 4);
        if (*((_BYTE *)a2 + 56))
        {
          v28 = *((_QWORD *)a2 + 8);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          v29 = CFAbsoluteTimeGetCurrent();
          *((CFAbsoluteTime *)a2 + 8) = v29;
          v28 = *(_QWORD *)&v29;
        }
        DomainAndPartition::DomainAndPartition(v62, v26, v27, *((_QWORD *)a2 + 7), v28);
        DomainAndPartition::DomainAndPartition((uint64_t)v59, (uint64_t)v62);
        HTTPCookieStorage::lookupAndCopyCookies(*((_QWORD **)this + 2), (uint64_t)v59, (const char *)ptr, a3, v12, Mutable);
        v59[0] = &off_1E14E9488;
        if (v61 && v61 != &v60)
          free(v61);
        v62[0] = &off_1E14E9488;
        if (v64 && v64 != v63)
          free(v64);
      }
      while (CookieHostName::trimFirstComponent((CookieHostName *)&v75));
    }
    v68[0] = &off_1E14E9488;
    if (v70 && v70 != &v69)
      free(v70);
    if (ptr && v74 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  if (v10)
    CFRelease(v10);
  v81.length = CFArrayGetCount(Mutable);
  v81.location = 0;
  CFArraySortValues(Mutable, v81, (CFComparatorFunction)_CookieSortForCopy, 0);
  v31 = (const __CFDictionary *)*((_QWORD *)a2 + 10);
  if (v31 && CFDictionaryGetValue(v31, CFSTR("_kCFHTTPCookiePolicyPropertySiteForCookies")))
  {
    v32 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    Count = CFArrayGetCount(Mutable);
    if (Count >= 1)
    {
      for (i = 0; (const __CFAllocator *)Count != i; i = (const __CFAllocator *)((char *)i + 1))
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(Mutable, (CFIndex)i);
        v36 = objc_msgSend(ValueAtIndex, "_inner");
        v37 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v36 + 16))(v36);
        if (*v37 >= 0xCu)
          v38 = v37[2] & 0x7F;
        else
          v38 = 0;
        if ((v38 & 0x10) != 0)
          v39 = 3;
        else
          v39 = 1;
        if ((v38 & 8) != 0)
          v40 = v39;
        else
          v40 = ((v38 & 0x10) >> 3) ^ 2;
        v41 = objc_msgSend(ValueAtIndex, "_inner");
        v42 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v41 + 16))(v41);
        v45 = 0.0;
        if (*(_DWORD *)v42 >= 0x38u)
        {
          allocator = *(CFAllocatorRef *)(v42 + 48);
          v45 = floor(*(double *)&allocator);
        }
        if (v40)
        {
          if (v40 != 1)
          {
            if (v40 == 3)
              goto LABEL_92;
            continue;
          }
        }
        else if (CFAbsoluteTimeGetCurrent() - v45 <= 120.0
               && HTTPCookieStoragePolicy::isTopLevelNavigation(*((HTTPCookieStoragePolicy **)a2 + 10)))
        {
          continue;
        }
        LODWORD(allocator) = 1;
        v46 = (const __CFDictionary *)*((_QWORD *)a2 + 10);
        if (v46
          && (v47 = (const __CFNumber *)CFDictionaryGetValue(v46, CFSTR("_kCFHTTPCookiePolicyPropertyIsSafeRequest"))) != 0
          && (CFNumberGetValue(v47, kCFNumberIntType, &allocator), !(_BYTE)allocator)
          || !HTTPCookieStoragePolicy::isTopLevelNavigation(*((HTTPCookieStoragePolicy **)a2 + 10)))
        {
LABEL_92:
          if (!HTTPCookieStoragePolicy::isURLInSiteForCookie(a2, v43, v44))
          {
            AutoScalar::AutoScalar((AutoScalar *)&allocator, i);
            CFArrayAppendValue(v32, value);
            allocator = (CFAllocatorRef)&off_1E14E47E8;
            if (value)
              CFRelease(value);
          }
        }
      }
    }
    v48 = CFArrayGetCount(v32);
    if (v48 >= 1)
    {
      v49 = v48 + 1;
      do
      {
        v50 = (const __CFNumber *)CFArrayGetValueAtIndex(v32, v49 - 2);
        LODWORD(allocator) = 0;
        CFNumberGetValue(v50, kCFNumberIntType, &allocator);
        CFArrayRemoveValueAtIndex(Mutable, (int)allocator);
        --v49;
      }
      while (v49 > 1);
    }
    if (v32)
      CFRelease(v32);
  }
  v51 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_31_9801, 3);
  v52 = v51;
  if (v51
    && (*(unsigned int (**)(uint64_t, const char *, HTTPCookieStorage *))(*(_QWORD *)v51 + 24))(v51, "HTTPCookieStorage::copyCookiesForURL", this))
  {
    (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v52 + 40))(v52, "Request URL", *((_QWORD *)a2 + 2));
    (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v52 + 40))(v52, "MainDocument URL", *((_QWORD *)a2 + 3));
    CompactCookieArray = CompactCookieArray::makeCompactCookieArray((CompactCookieArray *)*MEMORY[0x1E0C9AE00], Mutable, v53);
    logCookieArray(v52, (uint64_t)CompactCookieArray);
    CFRelease((char *)CompactCookieArray - 16);
    (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
  }
  v75 = &off_1E14E6B50;
  if (v79 != &v78)
    free(v79);
  return Mutable;
}

void sub_183F60BDC(_Unwind_Exception *a1)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  STACK[0xA70] = (unint64_t)&off_1E14E6B50;
  if ((unint64_t *)STACK[0xB88] != &STACK[0xA88])
    free((void *)STACK[0xB88]);
  _Unwind_Resume(a1);
}

void HTTPCookieStorage::lookupAndCopyCookies(_QWORD *a1, uint64_t a2, const char *a3, unsigned int a4, int a5, const __CFArray *a6)
{
  uint64_t v9;
  BOOL v10;
  int64_t v11;
  unint64_t v12;
  unsigned __int8 *v13;
  const __CFData *v14;
  const UInt8 *BytePtr;
  unint64_t v16;
  const __CFData *v17;
  const UInt8 *v18;
  const UInt8 *v19;
  uint64_t v20;
  const UInt8 *v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  const UInt8 *v25;
  size_t v26;
  int v27;
  BOOL v28;
  const char *v29;
  uint64_t v30;
  unint64_t v31;
  BOOL v32;
  unsigned int i;
  unint64_t v34;
  const UInt8 *v35;
  uint64_t v36;
  int v38;
  int v39;
  const char *v40;
  const char *v41;
  int v42;
  const char *v43;
  const char *v44;
  int v45;
  id v46;
  double v47;
  CFIndex Count;
  CFIndex v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  double v53;
  void *ValueAtIndex;
  void *v55;
  uint64_t v56;
  int v57;
  int v58;
  _QWORD v62[3];
  uint64_t v63;
  void *v64;
  uint64_t v65;
  CFRange v66;

  v65 = *MEMORY[0x1E0C80C00];
  DomainAndPartition::DomainAndPartition((uint64_t)v62, a2);
  v9 = PrivateHTTPCookieStorage::copyDomainCookieArray(a1, (uint64_t)v62, a4);
  v62[0] = &off_1E14E9488;
  if (v64)
    v10 = v64 == &v63;
  else
    v10 = 1;
  if (!v10)
    free(v64);
  if (v9)
  {
    v11 = strlen(a3);
    v12 = 0;
    v13 = (unsigned __int8 *)&a3[v11];
    while (1)
    {
      v14 = *(const __CFData **)(v9 + 16);
      if (v14 && (BytePtr = CFDataGetBytePtr(v14)) != 0)
        v16 = *((unsigned int *)BytePtr + 1);
      else
        v16 = 0;
      if (v12 >= v16)
      {
        CFRelease((CFTypeRef)(v9 - 16));
        return;
      }
      v17 = *(const __CFData **)(v9 + 16);
      if (v17 && CFDataGetBytePtr(v17))
      {
        v18 = CFDataGetBytePtr(*(CFDataRef *)(v9 + 16));
        v19 = *(const UInt8 **)(v9 + 16);
        v20 = *(unsigned int *)&v18[4 * v12 + 8];
        if (v19)
          v19 = CFDataGetBytePtr((CFDataRef)v19);
        v21 = &v19[v20];
      }
      else
      {
        v21 = 0;
      }
      if (*(_DWORD *)v21 >= 0x1Cu
        && (v22 = *((unsigned int *)v21 + 6), (_DWORD)v22)
        && (v23 = (const char *)&v21[v22],
            v24 = *(unsigned int *)v21,
            v25 = &v21[v22],
            v24 > v22))
      {
        while (*v25)
        {
          if (++v25 >= &v21[v24])
            goto LABEL_24;
        }
        v26 = strlen(v23);
        v27 = 0;
      }
      else
      {
LABEL_24:
        v23 = 0;
        v26 = 0;
        v27 = 1;
      }
      if (!v26)
        v27 = 1;
      v28 = v27 == 0;
      v29 = "/";
      if (v28)
        v29 = v23;
      v30 = v28 ? v26 : 1;
      if (*(_DWORD *)v21 < 0x10u || !*((_DWORD *)v21 + 3))
        goto LABEL_51;
      v31 = 0;
      v32 = 0;
      for (i = 56; ; i += 2)
      {
        v34 = *(_DWORD *)v21 >= 0x10u ? *((unsigned int *)v21 + 3) : 0;
        if (v31 >= v34 || v32)
          break;
        v35 = &v21[i];
        v36 = *(unsigned int *)v21;
        if (v36 <= i || v35 + 2 > &v21[v36])
          v38 = 0;
        else
          v38 = *(unsigned __int16 *)v35;
        v32 = v38 == a5;
        ++v31;
      }
      if (v32)
      {
LABEL_51:
        if (v30 <= v11 && a3 && v29)
          break;
      }
LABEL_100:
      ++v12;
    }
    if (v30 != 1 || *v29 != 47)
    {
      v39 = 0;
      v40 = &v29[v30];
      if (v30 < 1)
      {
        v41 = a3;
LABEL_63:
        v42 = v39;
      }
      else
      {
        v41 = a3;
        v42 = 0;
        if (v11 >= 1)
        {
          v43 = v29 + 1;
          v44 = a3 + 1;
          do
          {
            v41 = v44;
            v29 = v43;
            v39 = *((unsigned __int8 *)v43 - 1);
            v42 = *((unsigned __int8 *)v44 - 1);
            if (v39 != v42)
              break;
            if (v43 >= v40)
              goto LABEL_63;
            ++v44;
            ++v43;
            v42 = v39;
          }
          while (v41 < (const char *)v13);
        }
      }
      if (v29 < v40)
      {
        if (v41 != (const char *)v13 || v29 + 1 != v40 || v39 != v42)
          goto LABEL_100;
        v45 = *(unsigned __int8 *)v29;
        goto LABEL_74;
      }
      if (v41 == (const char *)v13 || v39 != v42)
      {
        if (v41 != (const char *)v13 || v39 != v42)
          goto LABEL_100;
        goto LABEL_78;
      }
      if (v39 != 47)
      {
        if (v41 >= (const char *)v13)
          goto LABEL_100;
        v45 = *(unsigned __int8 *)v41;
LABEL_74:
        if (v45 != 47)
          goto LABEL_100;
      }
    }
LABEL_78:
    if (a4 || *(_DWORD *)v21 < 0xCu || (*((_DWORD *)v21 + 2) & 1) == 0)
    {
      v46 = -[NSHTTPCookie _initWithReference:index:]([NSHTTPCookie alloc], "_initWithReference:index:", v9, v12);
      v47 = *(double *)(a2 + 16);
      Count = CFArrayGetCount(a6);
      v66.location = 0;
      v66.length = Count;
      v49 = CFArrayBSearchValues(a6, v66, v46, (CFComparatorFunction)_cookiePathDomainAndNameComparator, 0);
      v50 = objc_msgSend(v46, "_inner");
      v51 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v50 + 16))(v50);
      if (*(_DWORD *)v51 >= 0xCu && (*(_DWORD *)(v51 + 8) & 2) != 0)
      {
        v53 = 0.0;
        v52 = 1;
      }
      else
      {
        v52 = 0;
        if (*(_DWORD *)v51 >= 0x30u)
          v53 = floor(*(double *)(v51 + 40));
        else
          v53 = 0.0;
      }
      if (v49 >= Count)
      {
        if (v53 > v47)
          v58 = 1;
        else
          v58 = v52;
        if (v58 == 1)
          CFArrayAppendValue(a6, v46);
      }
      else
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(a6, v49);
        v56 = _cookiePathDomainAndNameComparator(ValueAtIndex, v46, v55);
        if (v53 > v47)
          v57 = 1;
        else
          v57 = v52;
        if (v56 && v57)
          CFArrayInsertValueAtIndex(a6, v49, v46);
      }

    }
    goto LABEL_100;
  }
}

void sub_183F61210(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50)
{
  uint64_t v50;
  BOOL v52;

  if (a50)
    v52 = a50 == (void *)(v50 + 24);
  else
    v52 = 1;
  if (!v52)
    free(a50);
  _Unwind_Resume(exception_object);
}

void sub_183F61398(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  MEMORY[0x186DB748C](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

uint64_t PrivateHTTPCookieStorage::copyDomainCookieArray(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[6];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[3];
  uint64_t v16;
  void *v17;
  _QWORD v18[3];
  uint64_t v19;
  void *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v14 = 0;
  v6 = dispatch_semaphore_create(0);
  DomainAndPartition::DomainAndPartition((uint64_t)v15, a2);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN24PrivateHTTPCookieStorage21copyDomainCookieArrayE18DomainAndPartitionh_block_invoke;
  v10[3] = &unk_1E14FB320;
  v10[4] = v6;
  v10[5] = &v11;
  v7 = a1[4];
  if (v7)
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 8));
  DomainAndPartition::DomainAndPartition((uint64_t)v18, (uint64_t)v15);
  (*(void (**)(_QWORD *, _QWORD *, uint64_t, _QWORD *))(*a1 + 112))(a1, v18, a3, v10);
  v18[0] = &off_1E14E9488;
  if (v20 && v20 != &v19)
    free(v20);
  if (v7)
    pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  v15[0] = &off_1E14E9488;
  if (v17 && v17 != &v16)
    free(v17);
  dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v6);
  v8 = v12[3];
  _Block_object_dispose(&v11, 8);
  return v8;
}

void sub_183F6157C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55)
{
  a20 = (uint64_t)&off_1E14E9488;
  if (a55)
  {
    if (a55 != &a23)
      free(a55);
  }
  _Block_object_dispose(&a16, 8);
  _Unwind_Resume(a1);
}

uint64_t DomainAndPartition::DomainAndPartition(uint64_t a1, uint64_t a2)
{
  __int128 *v4;
  size_t v5;
  void *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  *(_QWORD *)a1 = &off_1E14E9488;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  v4 = *(__int128 **)(a2 + 280);
  if (v4 == (__int128 *)(a2 + 24))
  {
    *(_QWORD *)(a1 + 280) = a1 + 24;
    v7 = *v4;
    v8 = v4[1];
    v9 = v4[2];
    *(_OWORD *)(a1 + 72) = v4[3];
    *(_OWORD *)(a1 + 56) = v9;
    *(_OWORD *)(a1 + 40) = v8;
    *(_OWORD *)(a1 + 24) = v7;
    v10 = v4[4];
    v11 = v4[5];
    v12 = v4[6];
    *(_OWORD *)(a1 + 136) = v4[7];
    *(_OWORD *)(a1 + 120) = v12;
    *(_OWORD *)(a1 + 104) = v11;
    *(_OWORD *)(a1 + 88) = v10;
    v13 = v4[8];
    v14 = v4[9];
    v15 = v4[10];
    *(_OWORD *)(a1 + 200) = v4[11];
    *(_OWORD *)(a1 + 184) = v15;
    *(_OWORD *)(a1 + 168) = v14;
    *(_OWORD *)(a1 + 152) = v13;
    v16 = v4[12];
    v17 = v4[13];
    v18 = v4[14];
    *(_OWORD *)(a1 + 264) = v4[15];
    *(_OWORD *)(a1 + 248) = v18;
    *(_OWORD *)(a1 + 232) = v17;
    *(_OWORD *)(a1 + 216) = v16;
  }
  else
  {
    v5 = *(_QWORD *)(a2 + 288);
    *(_QWORD *)(a1 + 288) = v5;
    v6 = malloc_type_malloc(v5, 0x4DAEACD7uLL);
    *(_QWORD *)(a1 + 280) = v6;
    memcpy(v6, *(const void **)(a2 + 280), *(_QWORD *)(a1 + 288));
  }
  v19 = *(_QWORD *)(a2 + 296);
  if (v19)
    *(_QWORD *)(a1 + 296) = *(_QWORD *)(a1 + 280) + v19 - *(_QWORD *)(a2 + 280);
  v20 = *(_QWORD *)(a2 + 304);
  if (v20)
    *(_QWORD *)(a1 + 304) = *(_QWORD *)(a1 + 280) + v20 - *(_QWORD *)(a2 + 280);
  v21 = *(_QWORD *)(a2 + 312);
  if (v21)
    *(_QWORD *)(a1 + 312) = *(_QWORD *)(a1 + 280) + v21 - *(_QWORD *)(a2 + 280);
  return a1;
}

_QWORD *DomainAndPartition::DomainAndPartition(_QWORD *a1, char *__s, CFStringRef theString, uint64_t a4, uint64_t a5)
{
  const __CFData *ExternalRepresentation;
  const __CFData *v11;
  const UInt8 *BytePtr;
  CFIndex Length;

  *a1 = &off_1E14E9488;
  if (theString
    && CFStringGetLength(theString)
    && (ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theString, 0x8000100u, 0x2Eu)) != 0)
  {
    v11 = ExternalRepresentation;
    BytePtr = CFDataGetBytePtr(ExternalRepresentation);
    Length = CFDataGetLength(v11);
    DomainAndPartition::init(a1, a4, a5, __s, (uint64_t)BytePtr, Length);
    CFRelease(v11);
  }
  else
  {
    DomainAndPartition::init(a1, a4, a5, __s);
  }
  return a1;
}

void DiskCookieStorage::copyDomainCookieArrayLocked(DiskCookieStorage *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void (**v11)(DomainAndPartition *__hidden);
  uint64_t v12;
  void *v13;
  const void *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  DiskCookieStorage::rereadFromDiskIfNecessaryLocked(a1);
  v8 = *((_QWORD *)a1 + 37);
  if (v8)
  {
    DomainAndPartition::DomainAndPartition((uint64_t)&v11, a2);
    MemoryCookies::copyCookiesInDomain(*(const __CFDictionary **)(v8 + 24), v14, a3);
    v10 = v9;
    v11 = &off_1E14E9488;
    if (v13 && v13 != &v12)
      free(v13);
    (*(void (**)(uint64_t, uint64_t))(a4 + 16))(a4, v10);
    if (v10)
      CFRelease((CFTypeRef)(v10 - 16));
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
  }
}

void sub_183F61920(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t *a45)
{
  if (a45)
  {
    if (a45 != &a13)
      free(a45);
  }
  _Unwind_Resume(exception_object);
}

void MemoryCookies::copyCookiesInDomain(const __CFDictionary *a1, const void *a2, int a3)
{
  CFDataRef *Value;
  CFDataRef *v5;
  const __CFData *v6;
  const UInt8 *BytePtr;
  unint64_t v8;
  uint64_t v9;
  const __CFData *v10;
  const UInt8 *v11;
  const UInt8 *v12;
  uint64_t v13;
  const UInt8 *v14;
  int v15;
  const CompactCookieHeader **v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  const __CFData *v21;
  const UInt8 *v22;
  const UInt8 *v23;
  uint64_t v24;
  const CompactCookieHeader *v25;
  _QWORD *Instance;
  CompactCookieArray *v27;
  _OWORD v28[32];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    Value = (CFDataRef *)CFDictionaryGetValue(a1, a2);
    if (Value)
    {
      v5 = Value;
      if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
        dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
      if (a3)
        goto LABEL_6;
      v6 = v5[4];
      if (!v6)
        goto LABEL_6;
      BytePtr = CFDataGetBytePtr(v6);
      if (!BytePtr)
        goto LABEL_6;
      v8 = *((unsigned int *)BytePtr + 1);
      if (!(_DWORD)v8)
        goto LABEL_6;
      v9 = 2;
      do
      {
        v10 = v5[4];
        if (v10 && CFDataGetBytePtr(v10))
        {
          v11 = CFDataGetBytePtr(v5[4]);
          v12 = (const UInt8 *)v5[4];
          v13 = *(unsigned int *)&v11[4 * v9];
          if (v12)
            v12 = CFDataGetBytePtr((CFDataRef)v12);
          v14 = &v12[v13];
        }
        else
        {
          v14 = 0;
        }
        if (*(_DWORD *)v14 >= 0xCu)
          v15 = *((_DWORD *)v14 + 2) & 1;
        else
          v15 = 0;
        if (v9 - 1 >= v8)
          break;
        ++v9;
      }
      while (!v15);
      if (v15)
      {
        memset(v28, 0, sizeof(v28));
        if (v8 < 0x41)
          v16 = (const CompactCookieHeader **)v28;
        else
          v16 = (const CompactCookieHeader **)operator new[]();
        v17 = 0;
        v18 = 0;
        if (v8 <= 1)
          v19 = 1;
        else
          v19 = v8;
        v20 = 4 * v19;
        do
        {
          v21 = v5[4];
          if (v21 && CFDataGetBytePtr(v21))
          {
            v22 = CFDataGetBytePtr(v5[4]);
            v23 = (const UInt8 *)v5[4];
            v24 = *(unsigned int *)&v22[v17 + 8];
            if (v23)
              v23 = CFDataGetBytePtr((CFDataRef)v23);
            v25 = (const CompactCookieHeader *)&v23[v24];
          }
          else
          {
            v25 = 0;
          }
          if (*(_DWORD *)v25 < 0xCu || (*((_DWORD *)v25 + 2) & 1) == 0)
            v16[v18++] = v25;
          v17 += 4;
        }
        while (v20 != v17);
        CFGetAllocator(v5);
        if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
          dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
        Instance = (_QWORD *)_CFRuntimeCreateInstance();
        v27 = (CompactCookieArray *)Instance;
        if (Instance)
        {
          Instance[2] = 0;
          Instance[3] = 0;
          v27 = (CompactCookieArray *)(Instance + 2);
          Instance[4] = 0;
        }
        CompactCookieArray::CompactCookieArray(v27, v16, v18);
        if (v16 != (const CompactCookieHeader **)v28)
          MEMORY[0x186DB7474](v16, 0x60C8044C4A2DFLL);
      }
      else
      {
LABEL_6:
        CFRetain(v5);
      }
    }
    else
    {
      CompactCookieArray::newEmptyArray(0);
    }
  }
}

void DiskCookieStorage::rereadFromDiskIfNecessaryLocked(DiskCookieStorage *this)
{
  NSObject *v2;
  _QWORD v3[5];

  if (*((_BYTE *)this + 324))
  {
    v2 = dispatch_semaphore_create(0);
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = ___ZN17DiskCookieStorage31rereadFromDiskIfNecessaryLockedEv_block_invoke;
    v3[3] = &unk_1E14FE118;
    v3[4] = v2;
    (*(void (**)(DiskCookieStorage *, uint64_t, _QWORD *))(*(_QWORD *)this + 152))(this, 1, v3);
    dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v2);
  }
}

intptr_t ___ZN24PrivateHTTPCookieStorage21copyDomainCookieArrayE18DomainAndPartitionh_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2;
  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v3)
    CFRetain((CFTypeRef)(v3 - 16));
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

BOOL CookieHostName::trimFirstComponent(CookieHostName *this)
{
  uint64_t v2;
  unint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  unint64_t v6;
  BOOL v7;

  if (!*((_BYTE *)this + 296))
  {
    *((_QWORD *)this + 36) = _CFHostGetTopLevelDomain(*((_QWORD *)this + 35), *((_QWORD *)this + 2), 1);
    *((_BYTE *)this + 296) = 1;
  }
  v2 = *((_QWORD *)this + 1);
  v3 = v2 + *((_QWORD *)this + 2);
  v4 = (_BYTE *)(v2 + 1);
  do
  {
    v5 = v4;
    if ((unint64_t)v4 >= v3)
      break;
    ++v4;
  }
  while (*v5 != 46);
  v6 = v3 - (_QWORD)v5;
  *((_QWORD *)this + 1) = v5;
  *((_QWORD *)this + 2) = v6;
  if (v6)
    v7 = v5 + 1 == *((_BYTE **)this + 36);
  else
    v7 = 1;
  return !v7;
}

void CompactCookieArray::newEmptyArray(CompactCookieArray *this)
{
  uint64_t Instance;

  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = 0;
    *(_QWORD *)(Instance + 24) = 0;
    Instance += 16;
    *(_QWORD *)(Instance + 16) = 0;
  }
  CompactCookieArray::CompactCookieArray((CompactCookieArray *)Instance, 0, 0);
}

void CookieHostName::CookieHostName(CookieHostName *this, CFURLRef anURL, const __CFURL *a3)
{
  char *v5;
  __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  const char *CStringPtr;

  *((_BYTE *)this + 24) = 0;
  v5 = (char *)this + 24;
  *((_QWORD *)this + 35) = (char *)this + 24;
  *(_QWORD *)this = &off_1E14E6B50;
  *((_QWORD *)this + 1) = (char *)this + 24;
  *((_QWORD *)this + 2) = 0;
  *((_BYTE *)this + 296) = 0;
  v6 = (__CFString *)CFURLCopyHostName(anURL);
  v7 = CFURLCopyScheme(anURL);
  v9 = v7;
  if (!v7 || _findCanonicalString(v7, 0xFu) != 584097179)
  {
    if (!v6)
      goto LABEL_8;
    CookieHostName::initializeFromString(this, v6, v8);
LABEL_7:
    CFRelease(v6);
LABEL_8:
    if (!v9)
      return;
    goto LABEL_9;
  }
  CStringPtr = CFStringGetCStringPtr(CFSTR(".^filecookies^"), 0x600u);
  *((_QWORD *)this + 2) = snprintf(v5, 0x100uLL, ".%s", CStringPtr);
  if (v6)
    goto LABEL_7;
LABEL_9:
  CFRelease(v9);
}

void CookieHostName::initializeFromString(CookieHostName *this, __CFString *a2, const __CFString *a3)
{
  const __CFString *IDNAEncodedDomain;
  const char *CStringPtr;
  const char *v6;
  int v7;
  uint64_t Length;
  CFRange v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  size_t v15;

  IDNAEncodedDomain = createIDNAEncodedDomain(a2);
  CStringPtr = CFStringGetCStringPtr(IDNAEncodedDomain, 0x600u);
  if (CStringPtr)
  {
    if (*CStringPtr == 46)
      v6 = CStringPtr + 1;
    else
      v6 = CStringPtr;
    v7 = snprintf((char *)this + 24, 0x100uLL, ".%s", v6);
    *((_QWORD *)this + 2) = v7;
    if (v7 > 0xFF)
      asprintf((char **)this + 35, ".%s", v6);
  }
  else
  {
    Length = CFStringGetLength(IDNAEncodedDomain);
    if (Length < 1)
    {
      v9.location = 0;
    }
    else
    {
      v9.location = CFStringGetCharacterAtIndex(IDNAEncodedDomain, 0) == 46;
      Length -= v9.location;
    }
    *((_BYTE *)this + 24) = 46;
    v9.length = Length;
    CFStringGetBytes(IDNAEncodedDomain, v9, 0x600u, 0, 0, (UInt8 *)this + 25, 254, (CFIndex *)this + 2);
    v10 = *((_QWORD *)this + 2) + 1;
    *((_QWORD *)this + 2) = v10;
    *((_BYTE *)this + v10 + 24) = 0;
  }
  v11 = *((_QWORD *)this + 2);
  if (v11)
  {
    v12 = *((_QWORD *)this + 35);
    v13 = v11 - 1;
    if (*(_BYTE *)(v12 + v11 - 1) == 46)
    {
      *((_QWORD *)this + 2) = v13;
      *(_BYTE *)(v12 + v13) = 0;
      v11 = *((_QWORD *)this + 2);
    }
  }
  v14 = (const char *)*((_QWORD *)this + 35);
  *((_QWORD *)this + 1) = v14;
  v15 = strlen(v14);
  if (v15 != v11)
    *((_QWORD *)this + 2) = v15;
  if (IDNAEncodedDomain)
    CFRelease(IDNAEncodedDomain);
}

void sub_183F62078(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t CookieUtils::looksLikeIPAddress(CookieUtils *this, const char *a2)
{
  int64_t v3;
  uint64_t result;
  int v5;
  _BYTE v6[255];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3 = strlen((const char *)this);
  result = 0;
  if (v3 && v3 <= 23)
  {
    v5 = *(char *)this;
    if (v5 == 58
      || v5 < 0
      || *(_BYTE *)this != 46
      || v3 != 1
      || (*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * *(unsigned __int8 *)this + 60) & 0x10000) != 0)
    {
      result = inet_pton(2, (const char *)this, v6);
      if ((_DWORD)result != 1)
        return inet_pton(30, (const char *)this, v6) == 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void MemoryCookieStorage::copyDomainCookieArrayLocked(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  void (**v10)(DomainAndPartition *__hidden);
  uint64_t v11;
  void *v12;
  const void *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 72);
  DomainAndPartition::DomainAndPartition((uint64_t)&v10, a2);
  MemoryCookies::copyCookiesInDomain(*(const __CFDictionary **)(v6 + 24), v13, a3);
  v8 = v7;
  v10 = &off_1E14E9488;
  if (v12)
    v9 = v12 == &v11;
  else
    v9 = 1;
  if (!v9)
    free(v12);
  (*(void (**)(uint64_t, uint64_t))(a4 + 16))(a4, v8);
  if (v8)
    CFRelease((CFTypeRef)(v8 - 16));
}

void sub_183F62230(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t *a45)
{
  BOOL v46;

  if (a45)
    v46 = a45 == &a13;
  else
    v46 = 1;
  if (!v46)
    free(a45);
  _Unwind_Resume(exception_object);
}

void HTTPProtocol::handleStreamError(HTTPProtocol *this, CFStreamError a2, CFTypeRef cf)
{
  CFStreamError v4;

  v4 = a2;
  if (cf && !*((_QWORD *)this + 50))
    *((_QWORD *)this + 50) = CFRetain(cf);
  HTTPProtocol::streamError(this, &v4);
}

void HTTPProtocol::streamError(HTTPProtocol *this, CFStreamError *a2)
{
  void *v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  CFIndex domain;
  int v9;
  SInt32 error;
  uint64_t v11;
  __CFDictionary *v12;
  __CFDictionary *Mutable;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  const void *v16;
  uint64_t v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  void (*v24)(uint64_t);
  CFIndex v25;
  const __CFAllocator *v26;
  CFErrorRef CFErrorWithStreamError;
  __CFError *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t TLSFallbackMethod;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unsigned int v38;
  CFIndex v39;
  uint64_t v40;
  unint64_t v41;
  const __CFAllocator *v42;
  void *v43;
  uint64_t v44;
  const __CFAllocator *v45;
  const __CFAllocator *v46;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  const __CFAllocator *v49;
  uint64_t v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  const __CFAllocator *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  __CFDictionary *valuePtr;
  uint64_t v64;
  CFErrorRef (*v65)(uint64_t);
  void *v66;
  HTTPProtocol *v67;
  __int128 v68;
  void *values;
  std::__shared_weak_count *v70;
  _QWORD v71[2];
  void (*v72)(uint64_t);
  void *v73;
  const void *v74;
  _QWORD v75[2];
  void (*v76)(uint64_t);
  void *v77;
  const void *v78;
  _QWORD v79[2];
  void (*v80)(uint64_t);
  void *v81;
  const void *v82;
  _QWORD v83[5];
  _QWORD v84[2];
  void (*v85)(uint64_t);
  void *v86;
  const void *v87;
  _QWORD v88[2];
  void (*v89)(uint64_t);
  void *v90;
  const void *v91;
  _QWORD v92[2];
  void (*v93)(uint64_t);
  void *v94;
  const void *v95;
  __CFDictionary *v96;
  std::__shared_weak_count *v97;
  __int128 v98;
  _BYTE buf[24];
  __int128 v100;
  __int128 v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  v4 = (void *)*((_QWORD *)this + 10);
  if (v4)
    objc_msgSend(v4, "_releasePreventIdleSleepAssertionIfAppropriate");
  v5 = (*(uint64_t (**)(HTTPProtocol *, CFStreamError *, uint64_t))(*(_QWORD *)this + 272))(this, a2, 1);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *((_QWORD *)this + 99);
    domain = a2->domain;
    if ((v5 - 5) >= 6)
      v9 = 78;
    else
      v9 = 89;
    error = a2->error;
    *(_DWORD *)buf = 138544386;
    *(_QWORD *)&buf[4] = v7;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v9;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v5;
    LOWORD(v100) = 2048;
    *(_QWORD *)((char *)&v100 + 2) = domain;
    WORD5(v100) = 1024;
    HIDWORD(v100) = error;
    _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "%{public}@ can retry(%c) with reason(%d) for error [%ld:%d]", buf, 0x28u);
  }
  switch(v5)
  {
    case 4:
      v11 = *((_QWORD *)this + 93);
      if (v11)
        -[__NSURLSessionLocal _withConnectionCache_setCurrentSSLMethod:forKey:scheduling:](v11, 0, *((_QWORD *)this + 35), *((const void **)this + 3));
      HTTPProtocol::cleanupStreams(this);
      goto LABEL_15;
    case 5:
      TLSFallbackMethod = HTTPProtocol::nextTLSFallbackMethod(this);
      v34 = *((_QWORD *)this + 93);
      if (v34)
        -[__NSURLSessionLocal _withConnectionCache_setCurrentSSLMethod:forKey:scheduling:](v34, TLSFallbackMethod, *((_QWORD *)this + 35), *((const void **)this + 3));
      HTTPProtocol::cleanupStreams(this);
      if (*((_QWORD *)this + 11))
        (*(void (**)(HTTPProtocol *, _QWORD))(*(_QWORD *)this + 88))(this, 0);
      return;
    case 6:
    case 7:
    case 9:
      HTTPProtocol::destroyReadStream(this);
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((_QWORD *)this + 104), 1025, 0);
      HTTPProtocol::createAndOpenStream(this, 0);
      return;
    case 8:
      CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 37), 0);
      HTTPProtocol::destroyReadStream(this);
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((_QWORD *)this + 104), 1026, 0);
      HTTPProtocol::createAndOpenStream(this, 0);
      return;
    case 10:
      HTTPProtocol::destroyReadStream(this);
      *((_QWORD *)this + 6) = 0;
      *((_QWORD *)this + 7) = 0;
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((_QWORD *)this + 104), 1025, 0);
      HTTPProtocol::createAndOpenStream(this, 0);
      return;
    default:
LABEL_15:
      if (*((_DWORD *)this + 206) == 1)
        return;
      v98 = (__int128)*a2;
      v12 = (__CFDictionary *)MEMORY[0x1E0C809B0];
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke;
      *(_QWORD *)&v100 = &__block_descriptor_56_e90_v32__0____CFError__8_shared_ptr___CFDictionary______CFDictionary_____shared_weak_count__16l;
      *((_QWORD *)&v100 + 1) = this;
      v101 = v98;
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v96 = Mutable;
      v14 = (std::__shared_weak_count *)operator new();
      v14->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      v14->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1588;
      v14->__shared_weak_owners_ = 0;
      v14[1].__vftable = (std::__shared_weak_count_vtbl *)Mutable;
      v97 = v14;
      v16 = (const void *)*((_QWORD *)this + 59);
      if (v16)
        CFDictionarySetValue(Mutable, CFSTR("NSErrorPeerAddressKey"), v16);
      v17 = *((_QWORD *)this + 111);
      if (v17)
      {
        v18 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v17 + 64))(v17, 0x1EDCF9530);
        v92[0] = v12;
        v92[1] = 3221225472;
        v93 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_2_162;
        v94 = &__block_descriptor_40_e5_v8__0l;
        v95 = v18;
        if (v18)
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CB3310], v18);
        v19 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, const void *))(**((_QWORD **)this + 111) + 64))(*((_QWORD *)this + 111), 0x1EDCF95D8, v18);
        v88[0] = v12;
        v88[1] = 3221225472;
        v89 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_3;
        v90 = &__block_descriptor_40_e5_v8__0l;
        v91 = v19;
        if (v19)
          CFDictionarySetValue(Mutable, CFSTR("_NSURLErrorPrivacyProxyFailureKey"), v19);
        v20 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, const void *))(**((_QWORD **)this + 111) + 64))(*((_QWORD *)this + 111), 0x1EDCF9568, v19);
        v84[0] = v12;
        v84[1] = 3221225472;
        v85 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_4;
        v86 = &__block_descriptor_40_e5_v8__0l;
        v87 = v20;
        if (v20)
        {
          v83[0] = v12;
          v83[1] = 3221225472;
          v83[2] = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_5;
          v83[3] = &unk_1E14FE118;
          v83[4] = nw_path_copy_parameters();
          nw_parameters_clear_proxy_options();
          CFDictionarySetValue(Mutable, CFSTR("_NSURLErrorNWPathKey"), v20);
          ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_5((uint64_t)v83);
        }
        v21 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 111) + 64))(*((_QWORD *)this + 111), 0x1EDCF94F8);
        v79[0] = v12;
        v79[1] = 3221225472;
        v80 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_6;
        v81 = &__block_descriptor_40_e5_v8__0l;
        v82 = v21;
        if (v21)
          CFDictionarySetValue(Mutable, CFSTR("_NSURLErrorBlockedTrackerFailureKey"), v21);
        v22 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, const void *))(**((_QWORD **)this + 111) + 64))(*((_QWORD *)this + 111), 0x1EDCF95A0, v21);
        v75[0] = v12;
        v75[1] = 3221225472;
        v76 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_7;
        v77 = &__block_descriptor_40_e5_v8__0l;
        v78 = v22;
        if (v22)
          CFDictionarySetValue(Mutable, CFSTR("_NSURLErrorNWResolutionReportKey"), v22);
        v23 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, const void *))(**((_QWORD **)this + 111) + 64))(*((_QWORD *)this + 111), 0x1EDCF9610, v22);
        v71[0] = v12;
        v71[1] = 3221225472;
        v24 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_8;
        v72 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_8;
        v73 = &__block_descriptor_40_e5_v8__0l;
        v74 = v23;
        if (v23)
        {
          CFDictionarySetValue(Mutable, CFSTR("_NSURLErrorVPNInactiveFailureKey"), v23);
          v24 = v72;
        }
        v24((uint64_t)v71);
        v76((uint64_t)v75);
        v80((uint64_t)v79);
        v85((uint64_t)v84);
        v89((uint64_t)v88);
        v93((uint64_t)v92);
      }
      v25 = a2->domain;
      if (a2->domain == 1)
      {
        v35 = *(_QWORD *)&a2->error;
        values = Mutable;
        v70 = v14;
        do
          v36 = __ldxr(p_shared_owners);
        while (__stxr(v36 + 1, p_shared_owners));
        valuePtr = v12;
        v64 = 3221225472;
        v65 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_9;
        v66 = &__block_descriptor_56_e17_____CFError__8__0l;
        v67 = this;
        v68 = v98;
        HTTPProtocol::asyncTransformError((std::__shared_weak_count_vtbl *)this, 1, v35, (uint64_t *)&values, (uint64_t)&valuePtr, (uint64_t)buf);
        do
          v37 = __ldaxr(p_shared_owners);
        while (__stlxr(v37 - 1, p_shared_owners));
      }
      else
      {
        if (v25 == 15 || v25 == 4)
        {
          v26 = CFGetAllocator((char *)this - 16);
          CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v26, (int *)a2);
LABEL_36:
          v28 = CFErrorWithStreamError;
LABEL_37:
          if (v28)
            HTTPProtocol::logLoadFailure(this, v28, a2);
          valuePtr = Mutable;
          v64 = (uint64_t)v14;
          do
            v29 = __ldxr(p_shared_owners);
          while (__stxr(v29 + 1, p_shared_owners));
          (*(void (**)(_BYTE *, __CFError *, __CFDictionary **))&buf[16])(buf, v28, &valuePtr);
          v30 = (std::__shared_weak_count *)v64;
          if (v64)
          {
            v31 = (unint64_t *)(v64 + 8);
            do
              v32 = __ldaxr(v31);
            while (__stlxr(v32 - 1, v31));
            if (!v32)
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
          }
          if (v28)
            CFRelease(v28);
          goto LABEL_82;
        }
        if (v25 == *MEMORY[0x1E0C9B298])
        {
          v38 = a2->error + 9853;
          if (v38 > 0x2E)
            v39 = -1200;
          else
            v39 = qword_18411DF98[v38];
          valuePtr = (__CFDictionary *)a2->error;
          HTTPProtocol::constructSSLCertContext(this);
          v42 = CFGetAllocator((char *)this - 16);
          v43 = CFNumberCreate(v42, kCFNumberCFIndexType, &valuePtr);
          values = v43;
          v44 = *((_QWORD *)this + 50);
          v45 = CFGetAllocator((char *)this - 16);
          v46 = v45;
          if (v44)
          {
            Count = CFDictionaryGetCount(*((CFDictionaryRef *)this + 50));
            MutableCopy = CFDictionaryCreateMutableCopy(v46, Count + 1, *((CFDictionaryRef *)this + 50));
            CFDictionarySetValue(MutableCopy, CFSTR("_kCFNetworkCFStreamSSLErrorOriginalValue"), v43);
          }
          else
          {
            MutableCopy = CFDictionaryCreate(v45, (const void **)&_kCFNetworkCFStreamSSLErrorOriginalValue, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v43 = values;
          }
          if (v43)
            CFRelease(v43);
          v49 = CFGetAllocator((char *)this - 16);
          v28 = CFErrorCreate(v49, CFSTR("kCFErrorDomainCFNetwork"), v39, MutableCopy);
          if (MutableCopy)
            CFRelease(MutableCopy);
          goto LABEL_37;
        }
        switch(v25)
        {
          case 13:
            v50 = *(_QWORD *)&a2->error;
            values = Mutable;
            v70 = v14;
            do
              v51 = __ldxr(p_shared_owners);
            while (__stxr(v51 + 1, p_shared_owners));
            valuePtr = v12;
            v64 = 3221225472;
            v65 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_12;
            v66 = &__block_descriptor_40_e17_____CFError__8__0l;
            v67 = this;
            HTTPProtocol::asyncTransformError((std::__shared_weak_count_vtbl *)this, 13, v50, (uint64_t *)&values, (uint64_t)&valuePtr, (uint64_t)buf);
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&values);
            goto LABEL_82;
          case 12:
            v55 = *(_QWORD *)&a2->error;
            values = Mutable;
            v70 = v14;
            do
              v56 = __ldxr(p_shared_owners);
            while (__stxr(v56 + 1, p_shared_owners));
            valuePtr = v12;
            v64 = 3221225472;
            v65 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_11;
            v66 = &__block_descriptor_40_e17_____CFError__8__0l;
            v67 = this;
            HTTPProtocol::asyncTransformError((std::__shared_weak_count_vtbl *)this, 12, v55, (uint64_t *)&values, (uint64_t)&valuePtr, (uint64_t)buf);
            do
              v37 = __ldaxr(p_shared_owners);
            while (__stlxr(v37 - 1, p_shared_owners));
            break;
          case 10:
            v40 = *(_QWORD *)&a2->error;
            values = Mutable;
            v70 = v14;
            do
              v41 = __ldxr(p_shared_owners);
            while (__stxr(v41 + 1, p_shared_owners));
            valuePtr = v12;
            v64 = 3221225472;
            v65 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_10;
            v66 = &__block_descriptor_40_e17_____CFError__8__0l;
            v67 = this;
            HTTPProtocol::asyncTransformError((std::__shared_weak_count_vtbl *)this, 10, v40, (uint64_t *)&values, (uint64_t)&valuePtr, (uint64_t)buf);
            do
              v37 = __ldaxr(p_shared_owners);
            while (__stlxr(v37 - 1, p_shared_owners));
            break;
          default:
            v57 = CFGetAllocator((char *)this - 16);
            CFErrorWithStreamError = __cfnCreateCFError(v57, CFSTR("kCFErrorDomainCFNetwork"), -998, v58, v59, v60, v61, v62, 0);
            goto LABEL_36;
        }
      }
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
LABEL_82:
      v52 = v97;
      if (v97)
      {
        v53 = (unint64_t *)&v97->__shared_owners_;
        do
          v54 = __ldaxr(v53);
        while (__stlxr(v54 - 1, v53));
        if (!v54)
        {
          ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
          std::__shared_weak_count::__release_weak(v52);
        }
      }
      return;
  }
}

void sub_183F62C34(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 - 208);
  _Unwind_Resume(a1);
}

CFTypeRef Tube::copyConnectionProperty(Tube *this, const __CFString *a2)
{
  uint64_t v3;
  const __CFDictionary *v5;
  const void *Value;

  v3 = *((_QWORD *)this + 17);
  if (v3)
    return (CFTypeRef)(*(uint64_t (**)(uint64_t, const __CFString *))(*(_QWORD *)v3 + 216))(v3, a2);
  v5 = (const __CFDictionary *)*((_QWORD *)this + 28);
  if (v5 && (Value = CFDictionaryGetValue(v5, a2)) != 0)
    return CFRetain(Value);
  else
    return 0;
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_8(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_7(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_6(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_5(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_4(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_3(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

uint64_t HTTPProtocol::canRetryRequestAfterError(HTTPProtocol *this, const CFStreamError *a2, int a3)
{
  void *v6;
  void *v7;
  StrictSecurityPolicy *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  CFIndex domain;
  SInt32 v14;
  _BOOL4 v15;
  uint64_t v16;
  SInt32 v17;
  uint64_t v18;
  const __CFString *v19;
  const __CFString *v20;
  int v21;
  const __CFArray *v22;
  SInt32 v23;
  SInt32 error;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CFIndex v28;
  int v29;
  SInt32 v30;
  const char *v31;
  NSObject *v32;
  uint32_t v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  const __CFString *v37;
  const __CFString *v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v43;
  const __CFString *v44;
  const __CFString *v45;
  char v46;
  int v47;
  int v48;
  NSObject *v49;
  uint64_t v50;
  int v51;
  int v52;
  NSObject *v53;
  uint64_t v54;
  int v55;
  int v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  NSObject *v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint8_t buf[4];
  uint64_t v68;
  __int16 v69;
  int v70;
  __int16 v71;
  int v72;
  __int16 v73;
  CFIndex v74;
  __int16 v75;
  SInt32 v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v6 = (void *)*((_QWORD *)this + 11);
  if (!v6)
  {
    v16 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_81, 1);
    v11 = v16;
    if (!v16)
      goto LABEL_59;
    if ((*(unsigned int (**)(uint64_t, const char *, HTTPProtocol *))(*(_QWORD *)v16 + 24))(v16, "Stream Error", this))
    {
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v11 + 72))(v11, "HTTPProtocol", CFSTR("Task and request are both nullptr; Error: %p [%ld:%d]"));
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    }
    goto LABEL_56;
  }
  if ((*((_DWORD *)this + 48) & 2) == 0)
  {
    if (objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_allowsTLSFallback"))
    {
      v7 = (void *)*((_QWORD *)this + 11);
      if ((!v7
         || (v8 = (StrictSecurityPolicy *)*((_QWORD *)this + 92)) == 0
         || StrictSecurityPolicy::strictSecurityPolicyInEffectForURL(v8, (CFURLRef)objc_msgSend(*((id *)this + 11), "cfURL"), *(const __CFDictionary **)(objc_msgSend(v7, "_inner") + 192)) != 2)&& a2->domain == *MEMORY[0x1E0C9B298])
      {
        v9 = a2->error + 9850;
        if (v9 > 0x2B || ((1 << v9) & 0xC7803E80081) == 0)
        {
          if (HTTPProtocol::nextTLSFallbackMethod(this))
            v11 = 5;
          else
            v11 = 4;
          if ((a3 & 1) != 0)
            goto LABEL_69;
LABEL_60:
          v25 = CFNLog::onceToken;
          goto LABEL_61;
        }
      }
    }
  }
  v10 = *((_QWORD *)this + 111);
  if (v10
    && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 96))(v10)
    && a2->domain == 4
    && a2->error == -2200)
  {
    v11 = 9;
    if ((a3 & 1) != 0)
      goto LABEL_69;
    goto LABEL_60;
  }
  LOWORD(v12) = *((_DWORD *)this + 48);
  if ((*((_DWORD *)this + 48) & 2) != 0)
  {
LABEL_44:
    if ((v12 & 2) != 0)
    {
      v11 = 1;
      if ((a3 & 1) != 0)
        goto LABEL_69;
      goto LABEL_60;
    }
    if (a2->domain == 1)
    {
      error = a2->error;
      if (((error - 53) > 0x2B || ((1 << (error - 53)) & 0x80000000003) == 0)
        && error != 32)
      {
        goto LABEL_58;
      }
    }
    else if (a2->domain != 4
           || ((v23 = a2->error, (v23 + 5) > 4) || ((1 << (v23 + 5)) & 0x13) == 0) && v23 != -2200)
    {
LABEL_58:
      v11 = 2;
LABEL_59:
      if ((a3 & 1) != 0)
        goto LABEL_69;
      goto LABEL_60;
    }
LABEL_56:
    v11 = 0;
    if ((a3 & 1) != 0)
      goto LABEL_69;
    goto LABEL_60;
  }
  domain = a2->domain;
  if (a2->domain == 1)
  {
    v11 = 0;
    v17 = a2->error;
    if ((v17 - 53) <= 0x2B && ((1 << (v17 - 53)) & 0x80000000003) != 0)
    {
      v15 = 0;
      goto LABEL_30;
    }
    v15 = 0;
    if (v17 == 32)
      goto LABEL_30;
    goto LABEL_37;
  }
  if (domain != 4 || ((v14 = a2->error, (v14 + 5) > 4) || ((1 << (v14 + 5)) & 0x13) == 0) && v14 != -2200)
  {
LABEL_37:
    if (domain != *MEMORY[0x1E0C9B298] && a2->error != -2098)
    {
      v22 = (const __CFArray *)*((_QWORD *)this + 37);
      if (v22)
      {
        if (CFArrayGetCount(v22) > 1)
        {
          v11 = 8;
          if ((a3 & 1) != 0)
            goto LABEL_69;
          goto LABEL_60;
        }
        v12 = *((_DWORD *)this + 48);
      }
    }
    goto LABEL_44;
  }
  v11 = v14 == -2200;
  v15 = v14 == -4;
LABEL_30:
  if ((*((_DWORD *)this + 48) & 0x200) == 0)
  {
    v18 = *(_QWORD *)(objc_msgSend(v6, "_inner") + 56);
    if (!v18
      || (v19 = *(const __CFString **)(v18 + 152)) != 0
      && (CFStringCompare(v19, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo
       || ((v20 = *(const __CFString **)(v18 + 152)) != 0
        || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
        && (*(_WORD *)buf = 0,
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (v20 = *(const __CFString **)(v18 + 152)) != 0))&& CFStringCompare(v20, (CFStringRef)&gConstantCFStringValueTable[2597], 0) == kCFCompareEqualTo))
    {
      v11 = 6;
      v21 = 1;
      goto LABEL_103;
    }
  }
  v43 = *(_QWORD *)(objc_msgSend(v6, "_inner") + 56);
  if (!v43)
    goto LABEL_102;
  v44 = *(const __CFString **)(v43 + 152);
  if (v44)
  {
    if (CFStringCompare(v44, (CFStringRef)&gConstantCFStringValueTable[2590], 0) == kCFCompareEqualTo)
    {
LABEL_102:
      v21 = 0;
      v11 = 7;
      goto LABEL_103;
    }
    v45 = *(const __CFString **)(v43 + 152);
    if (v45
      || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
      && (*(_WORD *)buf = 0,
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (v45 = *(const __CFString **)(v43 + 152)) != 0))
    {
      if (CFStringCompare(v45, (CFStringRef)&gConstantCFStringValueTable[2597], 0))
        v46 = v11;
      else
        v46 = 1;
      if ((v46 & 1) == 0)
      {
        v21 = 0;
        v11 = 0;
        goto LABEL_103;
      }
      goto LABEL_102;
    }
  }
  if ((_DWORD)v11)
    goto LABEL_102;
  v21 = 0;
LABEL_103:
  v47 = *((_DWORD *)this + 120);
  if (v47 >= 2)
  {
    if ((v15 & v21) == 1 && (v48 = *((_DWORD *)this + 121), v48 == v47) && v48 <= 7)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v49 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v50 = *((_QWORD *)this + 99);
        v51 = *((_DWORD *)this + 121);
        v52 = *((_DWORD *)this + 120);
        *(_DWORD *)buf = 138543874;
        v68 = v50;
        v69 = 1024;
        v70 = v51;
        v71 = 1024;
        v72 = v52;
        _os_log_impl(&dword_183ECA000, v49, OS_LOG_TYPE_DEFAULT, "%{public}@ RetryReason::Permit_ConnectionLost fNumConnectionLossRetries=%d, fNumRetries=%d", buf, 0x18u);
      }
      v11 = 6;
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v53 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v54 = *((_QWORD *)this + 99);
        v55 = *((_DWORD *)this + 121);
        v56 = *((_DWORD *)this + 120);
        *(_DWORD *)buf = 138543874;
        v68 = v54;
        v69 = 1024;
        v70 = v55;
        v71 = 1024;
        v72 = v56;
        _os_log_impl(&dword_183ECA000, v53, OS_LOG_TYPE_DEFAULT, "%{public}@ RetryReason::Deny_MaxRetriesReached fNumConnectionLossRetries=%d, fNumRetries=%d", buf, 0x18u);
      }
      v11 = 3;
    }
  }
  v57 = (void *)*((_QWORD *)this + 10);
  if (objc_msgSend((id)objc_msgSend(v57, "resumableUploadState"), "isResumable"))
  {
    v58 = objc_msgSend(v57, "resumableUploadState");
    if (v58)
      *(_DWORD *)(v58 + 12) = 2;
    v59 = objc_msgSend(v57, "resumableUploadState");
    if (v59)
      ++*(_BYTE *)(v59 + 8);
    v11 = 10;
    goto LABEL_130;
  }
  v60 = !v15;
  if ((_DWORD)v11 != 6)
    v60 = 1;
  if ((v60 & 1) != 0)
  {
LABEL_130:
    v25 = CFNLog::onceToken;
    if (a3)
      goto LABEL_131;
LABEL_61:
    if (v25 != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v26 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v27 = *((_QWORD *)this + 99);
      v28 = a2->domain;
      if ((v11 - 5) >= 6)
        v29 = 78;
      else
        v29 = 89;
      v30 = a2->error;
      *(_DWORD *)buf = 138544386;
      v68 = v27;
      v69 = 1024;
      v70 = v29;
      v71 = 1024;
      v72 = v11;
      v73 = 2048;
      v74 = v28;
      v75 = 1024;
      v76 = v30;
      v31 = "%{public}@ could retry(%c) with reason(%d) if issued error [%ld:%d]";
      v32 = v26;
      v33 = 40;
      goto LABEL_68;
    }
    goto LABEL_69;
  }
  ++*((_DWORD *)this + 121);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v25 = CFNLog::onceToken;
  v61 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v62 = *((_QWORD *)this + 99);
    v63 = *((_DWORD *)this + 121);
    *(_DWORD *)buf = 138543618;
    v68 = v62;
    v69 = 1024;
    v70 = v63;
    _os_log_impl(&dword_183ECA000, v61, OS_LOG_TYPE_DEFAULT, "%{public}@ fNumConnectionLossRetries=%d", buf, 0x12u);
    v11 = 6;
    goto LABEL_130;
  }
  v11 = 6;
  if (!a3)
    goto LABEL_61;
LABEL_131:
  ++*((_DWORD *)this + 120);
  if (v25 != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v64 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v65 = *((_QWORD *)this + 99);
    v66 = *((_DWORD *)this + 120);
    *(_DWORD *)buf = 138543618;
    v68 = v65;
    v69 = 1024;
    v70 = v66;
    v31 = "%{public}@ incrementRetryCount fNumRetries=%d";
    v32 = v64;
    v33 = 18;
LABEL_68:
    _os_log_impl(&dword_183ECA000, v32, OS_LOG_TYPE_DEFAULT, v31, buf, v33);
  }
LABEL_69:
  if (v6 && !(_DWORD)v11)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v34 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v35 = *((_QWORD *)this + 99);
      v36 = *(_QWORD *)(objc_msgSend(v6, "_inner") + 56);
      if (v36)
      {
        v37 = *(const __CFString **)(v36 + 152);
        if (!v37)
        {
LABEL_83:
          v39 = 78;
          goto LABEL_84;
        }
        if (CFStringCompare(v37, (CFStringRef)&gConstantCFStringValueTable[2590], 0))
        {
          v38 = *(const __CFString **)(v36 + 152);
          if (v38
            || os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
            && (*(_WORD *)buf = 0,
                _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (v38 = *(const __CFString **)(v36 + 152)) != 0))
          {
            if (CFStringCompare(v38, (CFStringRef)&gConstantCFStringValueTable[2597], 0))
              v39 = 78;
            else
              v39 = 89;
            goto LABEL_84;
          }
          goto LABEL_83;
        }
      }
      v39 = 89;
LABEL_84:
      v40 = *((_QWORD *)this + 34);
      v41 = 89;
      if (v40)
      {
        if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v40 + 96))(v40))
          v41 = 89;
        else
          v41 = 78;
      }
      *(_DWORD *)buf = 138544130;
      v68 = v35;
      v69 = 1024;
      v70 = v39;
      v71 = 1024;
      v72 = 0;
      v73 = 1024;
      LODWORD(v74) = v41;
      _os_log_impl(&dword_183ECA000, v34, OS_LOG_TYPE_DEFAULT, "%{public}@ idempotent(%c) retry reason(%d) bytes written(%c)", buf, 0x1Eu);
    }
  }
  return v11;
}

void HTTPProtocol::asyncTransformError(std::__shared_weak_count_vtbl *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  NSObject *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD block[10];
  std::__shared_weak_count *v28;
  std::__shared_weak_count_vtbl *v29;
  std::__shared_weak_count *v30;

  if (HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::onceToken == -1)
  {
    if (!a1)
      goto LABEL_4;
    goto LABEL_3;
  }
  dispatch_once(&HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::onceToken, &__block_literal_global_166);
  if (a1)
LABEL_3:
    CFRetain(&a1[-1].__get_deleter);
LABEL_4:
  v12 = (std::__shared_weak_count *)operator new();
  v12->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  v12->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
  v12->__shared_weak_owners_ = 0;
  v12[1].__vftable = a1;
  v14 = HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::q;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke_2;
  block[3] = &unk_1E14F21A8;
  block[6] = a1;
  block[7] = a2;
  block[4] = a5;
  block[5] = a6;
  v16 = *a4;
  v15 = (std::__shared_weak_count *)a4[1];
  block[8] = a3;
  block[9] = v16;
  v28 = v15;
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v29 = a1;
  v30 = v12;
  do
    v19 = __ldxr(p_shared_owners);
  while (__stxr(v19 + 1, p_shared_owners));
  dispatch_async(v14, block);
  v20 = v30;
  if (v30)
  {
    v21 = (unint64_t *)&v30->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = v28;
  if (v28)
  {
    v24 = (unint64_t *)&v28->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  do
    v26 = __ldaxr(p_shared_owners);
  while (__stlxr(v26 - 1, p_shared_owners));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

void HTTPEngine::_chunkedReadTrailer(HTTPEngine *this)
{
  _OWORD *Instance;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  NSObject *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v13[2];
  HTTPBodyData **v14[3];
  std::__shared_weak_count *v15;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v3 = (uint64_t)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v3 = (uint64_t)(Instance + 1);
    Instance[18] = 0u;
    Instance[19] = 0u;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  HTTPMessage::HTTPMessage((HTTPMessage *)v3, "httpresponse");
  *(_QWORD *)v3 = &off_1E14E9F38;
  *(_QWORD *)(v3 + 8) = &unk_1E14E9FA8;
  *(_QWORD *)(v3 + 16) = &unk_1E14E9FC8;
  *(_DWORD *)(v3 + 128) = -1;
  *(_QWORD *)(v3 + 136) = 0;
  *(_OWORD *)(v3 + 160) = 0u;
  *(_OWORD *)(v3 + 176) = 0u;
  *(_OWORD *)(v3 + 192) = 0u;
  *(_OWORD *)(v3 + 208) = 0u;
  *(_OWORD *)(v3 + 224) = 0u;
  *(_OWORD *)(v3 + 240) = 0u;
  *(_OWORD *)(v3 + 256) = 0u;
  *(_OWORD *)(v3 + 272) = 0u;
  *(_BYTE *)(v3 + 296) = 0;
  v14[2] = (HTTPBodyData **)v3;
  v4 = operator new();
  *(_QWORD *)(v4 + 8) = 0;
  v5 = (unint64_t *)(v4 + 8);
  *(_QWORD *)v4 = &off_1E14F1710;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 24) = v3;
  v15 = (std::__shared_weak_count *)v4;
  HTTPMessage::appendBytes((HTTPMessage *)v3, "HTTP/1.0 200 OK\r\n", 17);
  v6 = *((_QWORD *)this + 24);
  if (v6 && dispatch_data_get_size(v6))
  {
    v14[0] = (HTTPBodyData **)v3;
    v14[1] = (HTTPBodyData **)v4;
    do
      v7 = __ldxr(v5);
    while (__stxr(v7 + 1, v5));
    HTTPEngine::_chunkedReadTrailerDoParse((dispatch_data_t *)this, v14, 0, 0, 0);
    do
      v8 = __ldaxr(v5);
    while (__stlxr(v8 - 1, v5));
  }
  else
  {
    v13[0] = v3;
    v13[1] = v4;
    do
      v9 = __ldxr(v5);
    while (__stxr(v9 + 1, v5));
    HTTPEngine::_chunkedReadTrailerDoRead(this, v13);
    do
      v8 = __ldaxr(v5);
    while (__stlxr(v8 - 1, v5));
  }
  if (!v8)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v4);
  }
  v10 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_183F63BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void HTTPEngine::_chunkedReadTrailerDoParse(dispatch_data_t *a1, HTTPBodyData ***a2, uint64_t a3, uint64_t a4, char a5)
{
  NSObject *v10;
  size_t size;
  char v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  BOOL v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  HTTPBodyData **v23;
  HTTPBodyData **v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  HTTPBodyData **v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  HTTPBodyData **v36[2];
  uint64_t v37[2];
  HTTPBodyData **v38[2];
  _QWORD applier[6];
  std::__shared_weak_count *v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;

  v10 = a1[24];
  if (v10)
  {
    size = dispatch_data_get_size(a1[24]);
    if ((_DWORD)a4 == 57)
      v12 = 1;
    else
      v12 = a5;
    if (!size && (v12 & 1) != 0)
    {
      v13 = 0xFFFFFFFFLL;
      v14 = 4;
      goto LABEL_31;
    }
    if (size)
      v15 = 1;
    else
      v15 = (_DWORD)a4 == 0;
    if (!v15)
      goto LABEL_29;
    v41 = 0;
    v42 = &v41;
    v43 = 0x2020000000;
    v44 = 0;
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3321888768;
    applier[2] = ___ZN10HTTPEngine26_chunkedReadTrailerDoParseENSt3__110shared_ptrI19HTTPResponseMessageEE13CFStreamErrorb_block_invoke;
    applier[3] = &unk_1E14F3270;
    v16 = (std::__shared_weak_count *)a2[1];
    applier[5] = *a2;
    v40 = v16;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        v18 = __ldxr(p_shared_owners);
      while (__stxr(v18 + 1, p_shared_owners));
    }
    applier[4] = &v41;
    v19 = dispatch_data_apply(v10, applier);
    HTTPEngine::_readBufferConsume((HTTPEngine *)a1, v42[3]);
    v20 = v40;
    if (!v40)
      goto LABEL_24;
    v21 = (unint64_t *)&v40->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
      if (v19)
        goto LABEL_25;
    }
    else
    {
LABEL_24:
      if (v19)
      {
LABEL_25:
        a4 = 0;
        a3 = 0;
LABEL_28:
        _Block_object_dispose(&v41, 8);
        goto LABEL_29;
      }
    }
LABEL_27:
    a3 = 4;
    a4 = 0xFFFFFFFFLL;
    goto LABEL_28;
  }
  v13 = 0xFFFFFFFFLL;
  v14 = 4;
  if ((_DWORD)a4 == 57 || (a5 & 1) != 0)
  {
LABEL_31:
    v23 = *a2;
    v24 = a2[1];
    v38[0] = v23;
    v38[1] = v24;
    if (v24)
    {
      v25 = (unint64_t *)(v24 + 1);
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
    }
    HTTPEngine::_chunkedReadTrailerFinish((HTTPMessage **)a1, v38, v14, v13);
    if (v24)
    {
      v27 = (unint64_t *)(v24 + 1);
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
LABEL_37:
      if (!v28)
      {
        (*((void (**)(HTTPBodyData **))*v24 + 2))(v24);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v24);
      }
      return;
    }
    return;
  }
  if (!(_DWORD)a4)
  {
    v41 = 0;
    v42 = &v41;
    v43 = 0x2020000000;
    v44 = 0;
    goto LABEL_27;
  }
LABEL_29:
  if ((_DWORD)a4)
  {
    v14 = a3;
    v13 = a4;
    goto LABEL_31;
  }
  v29 = *a2;
  if ((*a2)[11])
  {
    v24 = a2[1];
    v37[0] = (uint64_t)v29;
    v37[1] = (uint64_t)v24;
    if (v24)
    {
      v30 = (unint64_t *)(v24 + 1);
      do
        v31 = __ldxr(v30);
      while (__stxr(v31 + 1, v30));
    }
    HTTPEngine::_chunkedReadTrailerDoRead(a1, v37);
    if (v24)
    {
      v32 = (unint64_t *)(v24 + 1);
      do
        v28 = __ldaxr(v32);
      while (__stlxr(v28 - 1, v32));
      goto LABEL_37;
    }
  }
  else
  {
    v24 = a2[1];
    v36[0] = v29;
    v36[1] = v24;
    if (v24)
    {
      v33 = (unint64_t *)(v24 + 1);
      do
        v34 = __ldxr(v33);
      while (__stxr(v34 + 1, v33));
    }
    HTTPEngine::_chunkedReadTrailerFinish((HTTPMessage **)a1, v36, a3, a4);
    if (v24)
    {
      v35 = (unint64_t *)(v24 + 1);
      do
        v28 = __ldaxr(v35);
      while (__stlxr(v28 - 1, v35));
      goto LABEL_37;
    }
  }
}

void sub_183F63EC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL ___ZN10HTTPEngine26_chunkedReadTrailerDoParseENSt3__110shared_ptrI19HTTPResponseMessageEE13CFStreamErrorb_block_invoke(uint64_t a1, int a2, int a3, const char *a4, CFIndex a5)
{
  int appended;

  appended = HTTPMessage::appendBytes(*(HTTPMessage **)(a1 + 40), a4, a5);
  if (appended)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += a5;
  return appended != 0;
}

void HTTPEngine::_chunkedReadTrailerFinish(HTTPMessage **this, HTTPBodyData ***a2, uint64_t a3, uint64_t a4)
{
  CFMutableDictionaryRef v8;

  if ((_DWORD)a4)
  {
    HTTPEngine::_deliverBodyBytes((HTTPEngine *)this, 0, a3, a4, 0);
  }
  else
  {
    HTTPEngine::_readBufferCaptureBody((uint64_t)this, *a2);
    v8 = HTTPMessage::copyAllHeaderFields((HTTPMessage *)*a2);
    HTTPMessage::setTrailerFields(this[16], v8);
    HTTPEngine::_deliverBodyBytes((HTTPEngine *)this, 0, a3, a4 & 0xFFFFFFFF00000000, 1);
    if (v8)
      CFRelease(v8);
  }
}

void sub_183F6400C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

CFErrorRef __cfnCreateCFErrorWithStreamError(CFAllocatorRef alloc, int *valuePtr)
{
  uint64_t v4;
  uint64_t v5;
  const __CFString **v6;
  const __CFString *v7;
  CFIndex v8;
  uint64_t v9;
  const __CFDictionary *v10;
  CFErrorRef v11;
  unint64_t v12;
  int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int valuePtra;
  void *values[2];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  void *keys[2];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v33 = 0;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  *(_OWORD *)keys = 0u;
  v25 = 0;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  *(_OWORD *)values = 0u;
  v4 = *(_QWORD *)valuePtr;
  if (*(_QWORD *)valuePtr == 2)
    goto LABEL_5;
  if (v4 == 1)
  {
    v5 = 0;
    v6 = (const __CFString **)MEMORY[0x1E0C9AFD0];
    goto LABEL_6;
  }
  if (v4 == *MEMORY[0x1E0C9B298])
  {
LABEL_5:
    v5 = 0;
    v6 = (const __CFString **)MEMORY[0x1E0C9AFC8];
LABEL_6:
    v7 = *v6;
LABEL_7:
    v8 = valuePtr[2];
    goto LABEL_8;
  }
  if (v4 == 15)
  {
    v5 = 0;
    v8 = valuePtr[2];
LABEL_19:
    v7 = CFSTR("kCFErrorDomainCFNetwork");
    goto LABEL_8;
  }
  if (v4 == 4)
  {
    v14 = valuePtr[2];
    if (v14 > -1003)
    {
      v5 = 0;
      v7 = CFSTR("kCFErrorDomainCFNetwork");
      v8 = -1017;
      switch(v14)
      {
        case -5:
        case -4:
          v5 = 0;
          v8 = -1005;
          break;
        case -3:
          v5 = 0;
          v8 = 305;
          break;
        case -2:
          v5 = 0;
          v8 = 304;
          break;
        case -1:
          goto LABEL_8;
        default:
          if ((v14 + 1002) >= 2)
          {
            if (v14 == -1000)
            {
              v5 = 0;
              v7 = CFSTR("kCFErrorDomainCFNetwork");
              v8 = 300;
            }
            else
            {
LABEL_50:
              v5 = 0;
              v7 = CFSTR("kCFErrorDomainCFNetwork");
              v8 = 303;
            }
          }
          else
          {
            v5 = 0;
            v7 = CFSTR("kCFErrorDomainCFNetwork");
            v8 = 301;
          }
          break;
      }
    }
    else
    {
      switch(v14)
      {
        case -2106:
        case -2104:
        case -2102:
        case -2101:
        case -2100:
          v5 = 0;
          v7 = CFSTR("kCFErrorDomainCFNetwork");
          v8 = -1001;
          break;
        case -2105:
        case -2103:
          goto LABEL_50;
        case -2099:
          v5 = 0;
          v7 = CFSTR("kCFErrorDomainCFNetwork");
          v8 = 307;
          break;
        case -2098:
        case -2097:
          v5 = 0;
          v7 = CFSTR("kCFErrorDomainCFNetwork");
          v8 = 311;
          break;
        case -2096:
          v5 = 0;
          v7 = CFSTR("kCFErrorDomainCFNetwork");
          v8 = 310;
          break;
        case -2095:
          v5 = 0;
          v7 = CFSTR("kCFErrorDomainCFNetwork");
          v8 = -2;
          break;
        case -2094:
          v5 = 0;
          v7 = CFSTR("kCFErrorDomainCFNetwork");
          v8 = 306;
          break;
        default:
          if (v14 != -2200)
            goto LABEL_50;
          v5 = 0;
          v7 = CFSTR("kCFErrorDomainCFNetwork");
          v8 = -1004;
          break;
      }
    }
    goto LABEL_8;
  }
  if (v4 == *MEMORY[0x1E0C9B290])
  {
    v15 = HIWORD(valuePtr[2]);
    valuePtra = (unsigned __int16)valuePtr[2];
    keys[0] = CFSTR("kCFSOCKSStatusCodeKey");
    values[0] = CFNumberCreate(alloc, kCFNumberSInt32Type, &valuePtra);
    switch(v15)
    {
      case 0u:
        v5 = valuePtra;
        if (valuePtra == 1)
        {
          v8 = 121;
        }
        else
        {
          if (valuePtra == 2)
            goto LABEL_24;
          v5 = 1;
          v8 = 100;
        }
        break;
      case 1u:
        keys[1] = CFSTR("kCFSOCKSVersionKey");
        values[1] = CFNumberCreate(alloc, kCFNumberSInt32Type, valuePtr + 2);
        v5 = 2;
        v8 = 101;
        break;
      case 2u:
        v16 = valuePtra - 91;
        if (v16 < 3)
        {
          v8 = v16 + 110;
          goto LABEL_36;
        }
        v5 = 1;
        v8 = 113;
        break;
      case 3u:
        v5 = 1;
        v8 = 122;
        break;
      case 4u:
        if (valuePtra == 255)
        {
          v5 = 1;
          v8 = 124;
        }
        else
        {
          keys[1] = CFSTR("kCFSOCKSNegotiationMethodKey");
          values[1] = CFNumberCreate(alloc, kCFNumberSInt32Type, &valuePtra);
          v5 = 2;
          v8 = 123;
        }
        break;
      case 5u:
LABEL_24:
        v5 = 1;
        v8 = 120;
        break;
      default:
        v8 = 0;
LABEL_36:
        v5 = 1;
        break;
    }
    goto LABEL_19;
  }
  v5 = 0;
  v7 = CFSTR("kCFErrorDomainCFNetwork");
  v8 = -1;
  switch(v4)
  {
    case 6:
      keys[0] = CFSTR("kCFFTPStatusCodeKey");
      values[0] = (void *)CFStringCreateWithFormat(alloc, 0, CFSTR("%d"), valuePtr[2]);
      v5 = 1;
      v8 = 200;
      break;
    case 7:
      v5 = 0;
      v8 = valuePtr[2];
      v7 = CFSTR("kCFErrorDomainWinSock");
      break;
    case 10:
      v5 = 0;
      goto LABEL_7;
    case 11:
      v5 = 0;
      v6 = (const __CFString **)MEMORY[0x1E0C9AFC0];
      goto LABEL_6;
    case 12:
      if (valuePtr[2] == 1)
      {
        v5 = 0;
        v8 = 1;
      }
      else
      {
        keys[0] = CFSTR("kCFGetAddrInfoFailureKey");
        values[0] = CFNumberCreate(alloc, kCFNumberSInt32Type, valuePtr + 2);
        v5 = 1;
        v8 = 2;
      }
      break;
    case 13:
      v5 = 0;
      v6 = (const __CFString **)MEMORY[0x1E0CE8B08];
      goto LABEL_6;
    default:
      break;
  }
LABEL_8:
  v9 = v5;
  keys[v5] = CFSTR("_kCFStreamErrorDomainKey");
  values[v5] = CFNumberCreate(alloc, kCFNumberCFIndexType, valuePtr);
  keys[v9 + 1] = CFSTR("_kCFStreamErrorCodeKey");
  values[v9 + 1] = CFNumberCreate(alloc, kCFNumberSInt32Type, valuePtr + 2);
  v10 = CFDictionaryCreate(alloc, (const void **)keys, (const void **)values, v5 + 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v11 = CFErrorCreate(alloc, v7, v8, v10);
  if (v10)
    CFRelease(v10);
  v12 = 0;
  do
  {
    CFRelease(values[v12 / 8]);
    v12 += 8;
  }
  while (v9 * 8 + 16 != v12);
  return v11;
}

void destroy_header_block_read_ctx(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = *a2;
  v3 = (_QWORD *)a2[1];
  if (*a2)
  {
    *(_QWORD *)(v2 + 8) = v3;
    v3 = (_QWORD *)a2[1];
  }
  else
  {
    *(_QWORD *)(a1 + 88) = v3;
  }
  *v3 = v2;
  if ((a2[13] & 4) != 0)
  {
    v4 = a2[2];
    if (v4)
      *(_QWORD *)(v4 + 24) = a2[3];
    else
      *(_QWORD *)(a1 + 16 * (a2[8] & 7) + 104) = a2[3];
    *(_QWORD *)a2[3] = v4;
    --*(_DWORD *)(a1 + 224);
  }
  free(a2);
}

uint64_t ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  unsigned __int8 *v6;
  uint64_t v7;
  FILE *v8;
  unint64_t v9;
  int v10;
  _DWORD *v11;
  char v12;
  int v13;
  int v14;
  uint64_t (*v15)(uint64_t, unint64_t);
  int v16;
  uint64_t v18;
  unsigned __int8 *v19;

  v6 = a4;
  v7 = *(_QWORD *)(a1 + 32);
  v19 = a4;
  v8 = *(FILE **)(v7 + 232);
  if (v8)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
    fprintf(*(FILE **)(v7 + 232), "got %zu bytes of decoder stream", a5);
    fputc(10, *(FILE **)(v7 + 232));
  }
  if (a5 < 1)
  {
LABEL_18:
    *(_DWORD *)(v7 + 228) += a5;
    return 1;
  }
  v9 = (unint64_t)&v6[a5];
  v18 = 0;
  v11 = (_DWORD *)(v7 + 192);
  v10 = *(_DWORD *)(v7 + 192);
  v12 = -1;
  while (1)
  {
    if (v10 != 1)
    {
      if (v10)
        goto LABEL_17;
      v13 = (char)*v6;
      if (v13 < 0)
      {
        v12 = 7;
        v15 = enc_proc_header_ack;
      }
      else
      {
        v14 = v13 & 0xC0;
        if (v14)
        {
          if (v14 != 64)
            __assert_rtn("lsqpack_enc_decoder_in", "lsqpack.c", 2459, "(buf[0] & 0xC0) == 0x40");
          v12 = 6;
          v15 = enc_proc_stream_cancel;
        }
        else
        {
          v12 = 6;
          v15 = enc_proc_ici;
        }
      }
      *(_QWORD *)(v7 + 216) = v15;
    }
    v16 = lsqpack_dec_int(&v19, v9, v12, &v18, (int *)(v7 + 192));
    if (v16)
      break;
    if ((*(unsigned int (**)(uint64_t, uint64_t))(v7 + 216))(v7 + 32, v18))
      goto LABEL_22;
    v10 = 0;
    *v11 = 0;
    v6 = v19;
LABEL_17:
    if ((unint64_t)v6 >= v9)
      goto LABEL_18;
  }
  if (v16 == -1)
  {
    *v11 = 1;
    return 1;
  }
LABEL_22:
  HTTP3Connection::_cleanupConnection((HTTP3Connection *)v7, 514, 0);
  HTTP3Connection::reportServerProtocolViolation(v7, 32, -1);
  return 0;
}

uint64_t enc_proc_header_ack(uint64_t a1, unint64_t a2)
{
  FILE *v4;
  unint64_t v6;
  FILE *v7;

  v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got Header Ack instruction, stream=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (!(a2 >> 62))
  {
    v6 = a1 + 96;
    while (1)
    {
      v6 = *(_QWORD *)v6;
      if (!v6)
        break;
      if (*(_QWORD *)(v6 + 40) == a2)
      {
        if (*(_DWORD *)(v6 + 60) > *(_DWORD *)(a1 + 4))
        {
          qenc_remove_from_risked_list(a1, (_QWORD *)v6);
          *(_DWORD *)(a1 + 4) = *(_DWORD *)(v6 + 60);
          qenc_update_risked_list(a1);
          v7 = *(FILE **)(a1 + 200);
          if (v7)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
            fprintf(*(FILE **)(a1 + 200), "max acked ID is now %u", *(_DWORD *)(a1 + 4));
            fputc(10, *(FILE **)(a1 + 200));
          }
        }
        enc_free_hinfo(a1, v6);
        return 0;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t enc_free_hinfo(uint64_t result, unint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;

  v2 = (_QWORD *)(result + 80);
  do
  {
    v2 = (_QWORD *)*v2;
    if (!v2)
      __assert_rtn("enc_free_hinfo", "lsqpack.c", 347, "0");
    v3 = v2 + 2;
  }
  while ((unint64_t)(v2 + 2) > a2 || (unint64_t)(v2 + 514) <= a2);
  v2[1] &= ~(1 << ((a2 - (unint64_t)v3) >> 6));
  v5 = &v2[8 * (unint64_t)((a2 - (unint64_t)v3) >> 6)];
  v6 = v5[2];
  v7 = (_QWORD *)v5[3];
  v8 = v5 + 2;
  if (v6)
  {
    *(_QWORD *)(v6 + 8) = v7;
    v7 = (_QWORD *)v8[1];
  }
  else
  {
    *(_QWORD *)(result + 104) = v7;
  }
  *v7 = v6;
  return result;
}

void ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke(_QWORD *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[6];
  std::__shared_weak_count *v16;
  const void *v17;

  v4 = a1[4];
  v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_108, 2);
  if (v5)
  {
    v6 = v5;
    if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)v5 + 24))(v5, "_kCFStreamPropertyHTTPFilterEstablishedConnectionBlock called", v4))
    {
      (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v6 + 48))(v6, "Request", *(_QWORD *)(v4 + 88));
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  if (a2)
    CFRetain(a2);
  v8 = a1[5];
  v7 = (std::__shared_weak_count *)a1[6];
  v9 = *(_QWORD *)(v8 + 24);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3321888768;
  v15[2] = ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_3;
  v15[3] = &__block_descriptor_64_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  v15[4] = v4;
  v15[5] = v8;
  v16 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  v17 = a2;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v9 + 96))(v9, v15);
  v12 = v16;
  if (v16)
  {
    v13 = (unint64_t *)&v16->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_183F64DF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void HTTP3ConnectionCacheWrapper::enqueueRequestForProtocol(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  const HTTPConnectionCacheKey *v6;
  const void *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  __int128 v11;
  uint64_t v12;
  _QWORD *v13;
  std::__shared_weak_count *v14;

  v6 = *(const HTTPConnectionCacheKey **)(a1 + 32);
  v11 = *a4;
  v12 = *((_QWORD *)a4 + 2);
  v7 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  HTTP3ConnectionCache::_entryFindOrCreate((HTTP3ConnectionCache *)&v13, v6, v7);
  HTTP3ConnectionCacheEntry::enqueueRequestForProtocol(v13, a2, a3, (uint64_t)&v11);
  HTTP3ConnectionCache::_timersStart(v6);
  v8 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_183F64EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  unint64_t *p_shared_owners;
  unint64_t v16;

  if (a14)
  {
    p_shared_owners = (unint64_t *)&a14->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))a14->__on_zero_shared)(a14);
      std::__shared_weak_count::__release_weak(a14);
    }
  }
  _Unwind_Resume(exception_object);
}

void HTTP2ConnectionCache::enableCellTimer(HTTP2ConnectionCache *this)
{
  NSObject *v2;
  dispatch_time_t v3;

  v2 = *((_QWORD *)this + 15);
  v3 = dispatch_time(0, (uint64_t)((double)*((int *)this + 19) * 1000000000.0));
  dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  dispatch_resume(*((dispatch_object_t *)this + 15));
}

uint64_t BrotliDataDecoder::isInitialized(BrotliDataDecoder *this)
{
  return *((unsigned __int8 *)this + 48);
}

dispatch_data_t BrotliDataDecoder::decodeData(BrotliDataDecoder *this, const __CFAllocator *a2, CFDataRef theData, unsigned __int8 *a4)
{
  const UInt8 *BytePtr;
  uint64_t alloc;
  NSObject *v9;
  unint64_t v10;
  compression_status v11;
  NSObject *v12;
  NSObject *v13;
  dispatch_data_t concat;
  dispatch_data_t subrange;
  size_t size;

  *a4 = 0;
  *((_QWORD *)this + 4) = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  *((_QWORD *)this + 2) = 0x4000;
  *((_QWORD *)this + 3) = BytePtr;
  alloc = dispatch_data_create_alloc();
  if (!alloc)
    return 0;
  v9 = alloc;
  v10 = 0x4000;
  while (1)
  {
    v11 = compression_stream_process((compression_stream *)((char *)this + 8), 0);
    if (v11)
      break;
    if (*((_QWORD *)this + 2))
    {
      *a4 = 1;
      goto LABEL_11;
    }
    v10 <<= v10 >> 26 == 0;
    *((_QWORD *)this + 2) = v10;
    v12 = dispatch_data_create_alloc();
    if (!v12)
      goto LABEL_9;
    v13 = v12;
    concat = dispatch_data_create_concat(v9, v12);
    dispatch_release(v13);
    dispatch_release(v9);
    v9 = concat;
  }
  if (v11 == COMPRESSION_STATUS_ERROR)
  {
LABEL_9:
    subrange = 0;
    goto LABEL_12;
  }
LABEL_11:
  size = dispatch_data_get_size(v9);
  subrange = dispatch_data_create_subrange(v9, 0, size - *((_QWORD *)this + 2));
LABEL_12:
  dispatch_release(v9);
  return subrange;
}

void HTTP3Connection::_decoderUnblocked(HTTP3Connection *this, void *a2)
{
  int v3;
  int v4;
  id v5;
  void *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  if (*((_DWORD *)this + 29) != 9)
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v10, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
    v3 = *((_DWORD *)this + 29);
    switch(v3)
    {
      case 2:
        v4 = 1;
        break;
      case 8:
        v4 = 7;
        break;
      case 5:
        v4 = 4;
        break;
      default:
        __assert_rtn("responseUnblocked", "HTTP3Stream.mm", 440, "false");
    }
    *((_DWORD *)this + 29) = v4;
    v5 = *((id *)this + 19);
    v6 = (void *)*((_QWORD *)this + 19);
    *((_QWORD *)this + 19) = 0;

    if (!HTTP3Stream::_handleHeaders((uint64_t)this, 0, v5, *((unsigned __int8 *)this + 131)))
      HTTP3Stream::_read(this, 0);

    v7 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_183F651A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t infoToString(int a1)
{
  uint64_t *v1;
  uint64_t result;

  switch(a1)
  {
    case -1:
      v1 = &_kCFNullHostInfoTypeString;
      goto LABEL_13;
    case 0:
      v1 = &kCFHostAddressesString;
      goto LABEL_13;
    case 1:
      v1 = &kCFHostNamesString;
      goto LABEL_13;
    case 2:
      v1 = &kCFHostReachabilityString;
LABEL_13:
      result = *v1;
      break;
    default:
      switch(a1)
      {
        case 65531:
          v1 = &_kCFHostByPassMasterAddressLookupString;
          goto LABEL_13;
        case 65532:
          v1 = &_kCFHostMasterAddressLookupString;
          goto LABEL_13;
        case 65533:
          v1 = &_kCFHostIPv6AddressesString;
          goto LABEL_13;
        case 65534:
          v1 = &_kCFHostIPv4AddressesString;
          goto LABEL_13;
        default:
          result = 0;
          break;
      }
      break;
  }
  return result;
}

__CFArray *CFHTTPCookieStorageCopyCookies(char *a1)
{
  HTTPCookieStorage *v3;

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
    return (__CFArray *)(id)objc_msgSend(a1, "cookies");
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
  if (a1)
    v3 = (HTTPCookieStorage *)(a1 + 16);
  else
    v3 = 0;
  return HTTPCookieStorage::copyCookiesMatching(v3, 0, 32, 0);
}

CFStringRef _CFStringCreateRFC2616DateStringWithGregorianDate(const __CFAllocator *a1, CFGregorianDate *a2, const __CFTimeZone *a3)
{
  CFAbsoluteTime AbsoluteTime;
  SInt32 DayOfWeek;

  if (!CFGregorianDateIsValid(*a2, 0xFFFFFFuLL))
    return 0;
  AbsoluteTime = CFGregorianDateGetAbsoluteTime(*a2, a3);
  DayOfWeek = CFAbsoluteTimeGetDayOfWeek(AbsoluteTime, 0);
  return CFStringCreateWithFormat(a1, 0, CFSTR("%s, %02d %s %04d %02d:%02d:%02d GMT"), kDayStrs[DayOfWeek + 6], a2->day, kMonthStrs[a2->month + 11], a2->year, a2->hour, a2->minute, (int)a2->second);
}

uint64_t CFURLResponseGetTextEncodingName(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  const __CFString *HeaderFieldValue;
  const __CFString *v4;
  CFIndex Length;
  __CFString *v6;
  CFCharacterSetRef Predefined;
  CFIndex v8;
  const __CFCharacterSet *v9;
  CFIndex v10;
  uint64_t v11;
  int CharacterAtIndex;
  uint64_t v13;
  const __CFAllocator *v14;
  __CFString *MutableCopy;
  const void *v16;
  CFRange v18;
  CFRange v19;
  CFRange v20;
  CFRange v21;

  v1 = objc_msgSend(a1, "_inner");
  v2 = *(_QWORD *)(v1 + 88);
  if (v2 && (*(_WORD *)(v2 + 297) & 0x400) == 0)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    HeaderFieldValue = HTTPMessage::copyLastHeaderFieldValue((HTTPMessage *)v2, 0x11F192E0u);
    if (HeaderFieldValue)
    {
      v4 = HeaderFieldValue;
      Length = CFStringGetLength(HeaderFieldValue);
      v21.location = 0;
      v21.length = Length;
      v6 = 0;
      if (CFStringFindWithOptions(v4, CFSTR("charset="), v21, 1uLL, &v18) && v18.length)
      {
        Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
        v8 = v18.length + v18.location;
        if (v18.length + v18.location >= Length)
          goto LABEL_22;
        v9 = Predefined;
        v10 = -1;
        v11 = -1;
        do
        {
          CharacterAtIndex = CFStringGetCharacterAtIndex(v4, v8);
          if (CharacterAtIndex == 44 || CharacterAtIndex == 59)
            break;
          if (CFCharacterSetIsCharacterMember(v9, CharacterAtIndex))
          {
            v13 = -1;
          }
          else
          {
            v11 = v8;
            v13 = v8;
          }
          if (v10 == -1)
            v10 = v13;
          ++v8;
        }
        while (v8 < Length);
        if (v10 == -1)
        {
LABEL_22:
          v6 = 0;
        }
        else
        {
          v14 = CFGetAllocator(v4);
          MutableCopy = CFStringCreateMutableCopy(v14, Length, v4);
          v6 = MutableCopy;
          if (v11 != Length)
          {
            v19.location = v11 + 1;
            v19.length = Length + ~v11;
            CFStringDelete(MutableCopy, v19);
          }
          v20.location = 0;
          v20.length = v10;
          CFStringDelete(v6, v20);
          CFStringLowercase(v6, 0);
        }
      }
      CFRelease(v4);
      v16 = *(const void **)(v1 + 24);
      if (v16)
        CFRelease(v16);
      *(_QWORD *)(v1 + 24) = v6;
    }
    *(_WORD *)(*(_QWORD *)(v1 + 88) + 297) |= 0x400u;
  }
  return *(_QWORD *)(v1 + 24);
}

void CFURLResponseSetMIMEType(void *a1, const __CFString *Copy)
{
  uint64_t v3;
  const void *v4;
  uint64_t v5;

  v3 = objc_msgSend(a1, "_inner");
  if (Copy)
    Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Copy);
  v4 = *(const void **)(v3 + 16);
  if (v4)
    CFRelease(v4);
  *(_QWORD *)(v3 + 16) = Copy;
  v5 = *(_QWORD *)(v3 + 88);
  if (v5)
  {
    *(_WORD *)(v5 + 297) |= 0x200u;
    *(_WORD *)(*(_QWORD *)(v3 + 88) + 297) |= 0x4000u;
  }
}

void ___ZNK13MemoryCookies7isEmptyEv_block_invoke(uint64_t a1, CFTypeRef cf)
{
  unint64_t Count;
  const void **v5;
  uint64_t v6;
  const void *v7;
  const __CFData *v8;
  const UInt8 *BytePtr;
  CFTypeRef v10;
  uint64_t v11;
  const void **v12;
  _BYTE v13[248];
  uint64_t v14;

  if (!cf)
  {
    v10 = 0;
    v11 = 0;
    v12 = (const void **)v13;
    goto LABEL_9;
  }
  v10 = CFRetain(cf);
  Count = CFDictionaryGetCount((CFDictionaryRef)cf);
  v11 = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v12 = 0;
    goto LABEL_9;
  }
  if (Count > 0x1E)
  {
    v5 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v12 = v5;
    if (!v5)
      goto LABEL_9;
  }
  else
  {
    v5 = (const void **)v13;
    v12 = (const void **)v13;
  }
  CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, 0, v5);
LABEL_9:
  v14 = 0;
  if (v11 >= 1)
  {
    v6 = 0;
    do
    {
      if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
        break;
      v14 = v6 + 1;
      v7 = v12[v6];
      if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
        dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
      v8 = (const __CFData *)*((_QWORD *)v7 + 4);
      if (v8)
      {
        BytePtr = CFDataGetBytePtr(v8);
        if (BytePtr)
        {
          if (*((_DWORD *)BytePtr + 1))
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
        }
      }
      v6 = v14;
    }
    while (v14 < v11);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v10);
}

void sub_183F659E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN25TransportConnectionObjCPP4readEjjU13block_pointerFvP11objc_objectb13CFStreamErrorPU32objcproto21OS_nw_content_context8NSObjectE_block_invoke_4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t (*v7)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v8;
  _QWORD *v9;

  v6 = *(_QWORD *)(result + 32);
  if (v6)
  {
    v7 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 8);
    v8 = *(_QWORD *)(v6 + 16);
    v9 = (_QWORD *)(v6 + (v8 >> 1));
    if ((v8 & 1) != 0)
      v7 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*v9 + v7);
    return v7(v9, 1, a3, a4, a5, a6, a2);
  }
  return result;
}

uint64_t ___ZN25TransportConnectionObjCPP4readEjjU13block_pointerFvP11objc_objectb13CFStreamErrorPU32objcproto21OS_nw_content_context8NSObjectE_block_invoke(uint64_t a1, int a2)
{
  NSObject *v4;
  uint8_t v5[16];

  if (a2)
    return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v5 = 0;
    _os_log_error_impl(&dword_183ECA000, v4, OS_LOG_TYPE_ERROR, "NSURLSessionStreamTask: Connection read invalidated by closed connection", v5, 2u);
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN18RunLoopMultiplexer19sourceForSchedulingEPK17CoreSchedulingSeth_block_invoke(uint64_t a1, CFRunLoopRef rl, const __CFString *a3)
{
  CFRunLoopAddSource(rl, *(CFRunLoopSourceRef *)(a1 + 32), a3);
}

uint64_t ___ZN14TCPIO_Delegate13bufferedRead0EjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;

  v5 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v5 + 48) = a4;
  *(_QWORD *)(v5 + 56) = a5;
  if (!a2)
    *(_BYTE *)(v5 + 64) = 1;
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke(uint64_t a1, uint64_t a2, CFStreamError a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unint64_t v7;
  uint64_t v8;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(a1 + 48);
  result = HTTP3Stream::_handleSendError((HTTP3Stream *)v4, a3, *(unsigned __int8 *)(a1 + 56));
  if (!(_DWORD)result)
  {
    v7 = *(_QWORD *)(v4 + 144) - 1;
    *(_QWORD *)(v4 + 144) = v7;
    v8 = *(_QWORD *)(v4 + 344);
    if (v8)
      *(_QWORD *)(v8 + 112) += v5 + a2;
    if (*(_DWORD *)(v4 + 112) == 3 && v7 <= 2)
    {
      *(_DWORD *)(v4 + 112) = 2;
      return HTTP3Stream::_resumeRequestBody((HTTP3Stream *)v4);
    }
  }
  return result;
}

void ___ZN11HTTP3Stream18_resumeRequestBodyEv_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8;
  NSObject *v9;
  void *v10;
  size_t size;
  size_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  _QWORD v42[5];
  std::__shared_weak_count *v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  _QWORD v46[5];
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  __n128 (*v50)(_QWORD *, uint64_t);
  void (*v51)(_QWORD *);
  std::__shared_weak_count *v52;
  void *v53[3];
  void *__p;
  void *v55;
  void (*v56)(_QWORD *);
  uint64_t v57;
  uint64_t (*v58)(uint64_t, uint64_t, CFStreamError);
  void *v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  size_t v62;
  char v63;

  v8 = *(_QWORD *)(a1 + 32);
  v9 = a2;
  if (*(_DWORD *)(v8 + 112) == 4)
    goto LABEL_60;
  if (a5)
    v10 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v8 + 96) + 32))(*(_QWORD *)(v8 + 96), 0x1EDCFA528);
  else
    v10 = 0;
  if (v10)
    a5 = 0;
  if (v9 && (size = dispatch_data_get_size(v9)) != 0)
  {
    v12 = size;
    -[__CFN_TransactionMetrics requestBody:](*(_QWORD *)(v8 + 344), v9);
    ++*(_QWORD *)(v8 + 144);
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v47, *(_QWORD *)(v8 + 8), *(std::__shared_weak_count **)(v8 + 16));
    v13 = *(_QWORD *)(v8 + 24);
    v56 = (void (*)(_QWORD *))MEMORY[0x1E0C809B0];
    v57 = 3321888768;
    v58 = ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke;
    v59 = &__block_descriptor_57_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e16_v32__0Q8___qi_16l;
    v60 = v47;
    v61 = (std::__shared_weak_count *)v48;
    if (v48)
    {
      v14 = (unint64_t *)(v48 + 8);
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v62 = v12;
    v63 = a5;
    HTTP3Framer::writeFrame(v13, 0, v9, a5, &v56);
    if (*(_DWORD *)(v8 + 112) == 2 && *(_QWORD *)(v8 + 144) >= 4uLL)
    {
      *(_DWORD *)(v8 + 112) = 3;
      (*(void (**)(_QWORD))(**(_QWORD **)(v8 + 96) + 24))(*(_QWORD *)(v8 + 96));
    }
    v16 = v61;
    if (v61)
    {
      p_shared_owners = (unint64_t *)&v61->__shared_owners_;
      do
        v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
    v19 = (std::__shared_weak_count *)v48;
    if (v48)
    {
      v20 = (unint64_t *)(v48 + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
  else if (a5)
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v56, *(_QWORD *)(v8 + 8), *(std::__shared_weak_count **)(v8 + 16));
    v22 = *(_QWORD *)(v8 + 24);
    v47 = MEMORY[0x1E0C809B0];
    v48 = 3321888768;
    v49 = (uint64_t)___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_28;
    v50 = (__n128 (*)(_QWORD *, uint64_t))&__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e13_v24__0___qi_8l;
    v51 = v56;
    v52 = (std::__shared_weak_count *)v57;
    if (v57)
    {
      v23 = (unint64_t *)(v57 + 8);
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }
    v25 = &v47;
    nw_content_context_set_is_final(*(nw_content_context_t *)(v22 + 56), 1);
    (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t *))(**(_QWORD **)(v22 + 16) + 32))(*(_QWORD *)(v22 + 16), *(_QWORD *)(v22 + 56), 0, 0, v25);

    v26 = v52;
    if (v52)
    {
      v27 = (unint64_t *)&v52->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v29 = (std::__shared_weak_count *)v57;
    if (v57)
    {
      v30 = (unint64_t *)(v57 + 8);
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    goto LABEL_57;
  }
  if (v10)
  {
    v47 = 0;
    v48 = (uint64_t)&v47;
    v49 = 0x6012000000;
    v50 = __Block_byref_object_copy__5408;
    v51 = __Block_byref_object_dispose__5409;
    v52 = (std::__shared_weak_count *)&unk_18422E08D;
    HTTP3Fields::HTTP3Fields((HTTP3Fields *)v53);
    v32 = MEMORY[0x1E0C809B0];
    v46[0] = MEMORY[0x1E0C809B0];
    v46[1] = 3221225472;
    v46[2] = ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_32;
    v46[3] = &unk_1E14F90B0;
    v46[4] = &v47;
    objc_msgSend(v10, "enumerateKeysAndObjectsUsingBlock:", v46);
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v44, *(_QWORD *)(v8 + 8), *(std::__shared_weak_count **)(v8 + 16));
    v33 = (_QWORD *)(v48 + 48);
    v42[0] = v32;
    v42[1] = 3321888768;
    v42[2] = ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_2;
    v42[3] = &__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e16_v32__0Q8___qi_16l;
    v42[4] = v44;
    v43 = v45;
    if (v45)
    {
      v34 = (unint64_t *)&v45->__shared_owners_;
      do
        v35 = __ldxr(v34);
      while (__stxr(v35 + 1, v34));
    }
    HTTP3Stream::_sendHEADERS((_QWORD *)v8, v33, 1, v42);
    v36 = v43;
    if (v43)
    {
      v37 = (unint64_t *)&v43->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    v39 = v45;
    if (v45)
    {
      v40 = (unint64_t *)&v45->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    _Block_object_dispose(&v47, 8);
    if (__p)
    {
      v55 = __p;
      operator delete(__p);
    }
    if (v53[0])
    {
      v53[1] = v53[0];
      operator delete(v53[0]);
    }
  }
LABEL_57:
  if ((_DWORD)a4)
  {
    HTTP3Stream::_cleanupStream(v8, 258, 0);
    *(_QWORD *)(v8 + 264) = a3;
    *(_QWORD *)(v8 + 272) = a4;
    HTTP3Stream::_protocolCallback((HTTP3Stream *)v8);
  }

LABEL_60:
}

void sub_183F66070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33)
{
  void *v33;
  void *v34;
  uint64_t v35;
  std::__shared_weak_count *v37;
  unint64_t *p_shared_owners;
  unint64_t v39;
  unint64_t *v40;
  unint64_t v41;

  v37 = *(std::__shared_weak_count **)(v35 - 88);
  if (v37)
  {
    p_shared_owners = (unint64_t *)&v37->__shared_owners_;
    do
      v39 = __ldaxr(p_shared_owners);
    while (__stlxr(v39 - 1, p_shared_owners));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  if (a24)
  {
    v40 = (unint64_t *)&a24->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))a24->__on_zero_shared)(a24);
      std::__shared_weak_count::__release_weak(a24);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t ___ZN10HTTPEngine18_chunkedReadHeaderEv_block_invoke(uint64_t a1, CFIndex a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  size_t size;
  uint64_t v9;
  uint64_t v11;
  unsigned int v12;
  NSObject *map;
  int v14;
  BOOL v15;
  void *buffer_ptr;
  CFStreamError v18;

  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(NSObject **)(v6 + 192);
  if (v7)
  {
    size = dispatch_data_get_size(*(dispatch_data_t *)(v6 + 192));
    v9 = *(_QWORD *)(a1 + 40);
    if (size != v9 || v9 != 2)
    {
      if (size == v9)
        goto LABEL_15;
LABEL_9:
      v12 = a3;
      goto LABEL_22;
    }
    buffer_ptr = 0;
    map = dispatch_data_create_map(v7, (const void **)&buffer_ptr, 0);
    if (!map)
      __assert_rtn("_chunkedReadHeader_block_invoke", "HTTPEngine.cpp", 2731, "bufContainer");
    if (*(_BYTE *)buffer_ptr == 13)
    {
      v14 = *((unsigned __int8 *)buffer_ptr + 1);
      dispatch_release(map);
      if (v14 == 10)
      {
        *(_QWORD *)(v6 + 176) = 0;
        *(_QWORD *)(v6 + 184) = 0;
        *(_DWORD *)(v6 + 32) |= 0x8000u;
        LODWORD(v11) = 1;
        goto LABEL_16;
      }
    }
    else
    {
      dispatch_release(map);
    }
LABEL_15:
    LODWORD(v11) = 0;
    goto LABEL_16;
  }
  v11 = *(_QWORD *)(a1 + 40);
  if (v11)
    goto LABEL_9;
LABEL_16:
  if ((_DWORD)a3)
    LODWORD(v11) = 1;
  v15 = (_DWORD)v11 == 0;
  if (!(_DWORD)v11)
    a2 = 4;
  v12 = -1;
  if (!v15)
    v12 = a3;
LABEL_22:
  v18.domain = a2;
  *(_QWORD *)&v18.error = a3 & 0xFFFFFFFF00000000 | v12;
  return HTTPEngine::_chunkedParseHeader(*(HTTPEngine **)(a1 + 48), v18);
}

void sub_183F66B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  void *v12;
  void *v13;
  void *v14;

  a12(&a10);
  _Unwind_Resume(a1);
}

void sub_183F66DB0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<HTTP2Connection *,Deleter_release<HTTP2Connection>,std::allocator<HTTP2Connection>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
    CFRelease((CFTypeRef)(v1 - 16));
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*> *,SmartBlockWithArgs<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::Deleter,std::allocator<BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  int v5;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if ((uint64_t (*)(_QWORD *))v3 == BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_initial
    && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      (*(void (**)(_QWORD *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*v7
                                                                                       + BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_initial))(v7, 0, 0, 0, 0, 0, 0);
    else
      ((void (*)(_QWORD *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_initial)(v7, 0, 0, 0, 0, 0, 0);
  }
  _Block_release(*(const void **)v1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_emplace<__CoalescingConnectionKey>::__on_zero_shared(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = *(const void **)(a1 + 64);
  *(_QWORD *)(a1 + 64) = 0;
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 56);
  *(_QWORD *)(a1 + 56) = 0;
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  if (v4)
    CFRelease(v4);
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
}

void std::__shared_ptr_emplace<IOConnWrapper>::__on_zero_shared(uint64_t a1)
{
  int v1;
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  __int128 v8;

  v1 = *(_DWORD *)(a1 + 24);
  if (v1 == 2)
  {
    v5 = *(std::__shared_weak_count **)(a1 + 40);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  else
  {
    if (v1 != 1)
      __assert_rtn("~IOConnWrapper", "TCPIOConnectionTest.hpp", 185, "false");
    v8 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 32, &v8);
    v2 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
    if (*((_QWORD *)&v8 + 1))
    {
      v3 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
      do
        v4 = __ldaxr(v3);
      while (__stlxr(v4 - 1, v3));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
  }
}

uint64_t std::__shared_ptr_emplace<__CFURLCache>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

BOOL CFAllocatedReferenceCountedObject::equals(CFAllocatedReferenceCountedObject *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

void *NSXURLCache::getMaxCacheableEntrySize(NSXURLCache *this)
{
  void *result;

  result = (void *)*((_QWORD *)this + 1);
  if (result)
    return (void *)_CFURLCacheGetMaxCacheableEntrySize((_QWORD *)objc_msgSend(result, "_CFURLCache"));
  return result;
}

void NSXURLCache::addCachedResponseForTask(id *this, const _CFCachedURLResponse *a2, NSURLSessionTask *a3)
{
  id v5;

  v5 = -[NSCachedURLResponse _initWithCFCachedURLResponse:]([NSCachedURLResponse alloc], "_initWithCFCachedURLResponse:", a2);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    objc_msgSend(this[1], "storeCachedResponse:forRequest:", v5, -[NSURLSessionTask currentRequest](a3, "currentRequest"));
  else
    objc_msgSend(this[1], "storeCachedResponse:forDataTask:", v5, a3);

}

uint64_t PersistentCredentialStorage::initialize(PersistentCredentialStorage *this, CFTypeRef cf)
{
  CFTypeRef v3;

  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  *((_QWORD *)this + 4) = v3;
  return 1;
}

uint64_t RequestBodyStream::copyProperty(RequestBodyStream *this, const __CFString *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  if (a2 && (v2 = *((_QWORD *)this + 15)) != 0)
  {
    v3 = *((_QWORD *)this + 17);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN17RequestBodyStream12copyPropertyEPK10__CFString_block_invoke;
    v6[3] = &unk_1E14FD7A8;
    v6[4] = &v7;
    v6[5] = v2;
    v6[6] = a2;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 104))(v3, v6);
    v4 = v8[3];
  }
  else
  {
    v4 = 0;
  }
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_183F67198(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void CoreSchedulingSet::performSync(CoreSchedulingSet *this, uint64_t a2)
{
  int v4;
  NSObject *v5;
  NSObject *v6;
  os_unfair_lock_s *v7;
  _QWORD v8[6];

  v4 = *((_DWORD *)this + 10);
  if ((v4 - 1) < 2)
  {
    if (!CoreSchedulingSet::currentlyInContext(this))
    {
      v5 = dispatch_semaphore_create(0);
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 3221225472;
      v8[2] = ___ZNK17CoreSchedulingSet11performSyncEU13block_pointerFvvE_block_invoke;
      v8[3] = &unk_1E14FDF00;
      v8[4] = v5;
      v8[5] = a2;
      (*(void (**)(CoreSchedulingSet *, _QWORD *))(*(_QWORD *)this + 96))(this, v8);
      dispatch_semaphore_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v5);
      return;
    }
LABEL_10:
    (*(void (**)(uint64_t))(a2 + 16))(a2);
    return;
  }
  if (v4 == 3)
  {
    v6 = *((_QWORD *)this + 7);
    if (v6 != dispatch_get_current_queue())
    {
      v7 = (os_unfair_lock_s *)((char *)this + 64);
      os_unfair_lock_lock(v7);
      (*(void (**)(uint64_t))(a2 + 16))(a2);
      os_unfair_lock_unlock(v7);
      return;
    }
    goto LABEL_10;
  }
  if (!v4)
    abort();
}

BOOL CoreSchedulingSet::currentlyInContext(CoreSchedulingSet *this)
{
  int v2;
  __CFRunLoop *Current;
  __CFRunLoop *v4;
  void *v5;
  uint64_t v6;
  void (*v8[7])(_QWORD, _QWORD, _QWORD);
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v2 = *((_DWORD *)this + 10);
  if ((v2 - 1) >= 2)
  {
    return v2 == 3 && dispatch_get_current_queue() == *((dispatch_queue_t *)this + 7);
  }
  else
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2020000000;
    v12 = 0;
    Current = CFRunLoopGetCurrent();
    v4 = Current;
    if (!Current || (v5 = (void *)CFRunLoopCopyCurrentMode(Current)) == 0)
    {
      if (*MEMORY[0x1E0C9B280])
        v5 = (void *)CFRetain((CFTypeRef)*MEMORY[0x1E0C9B280]);
      else
        v5 = 0;
    }
    v8[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v8[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v8[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZNK17CoreSchedulingSet18currentlyInContextEv_block_invoke;
    v8[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FD858;
    v8[4] = (void (*)(_QWORD, _QWORD, _QWORD))&v9;
    v8[5] = (void (*)(_QWORD, _QWORD, _QWORD))v4;
    v8[6] = (void (*)(_QWORD, _QWORD, _QWORD))v5;
    CoreSchedulingSet::applyBlock((uint64_t)this, v8);
    if (v5)
      CFRelease(v5);
    v6 = *((unsigned __int8 *)v10 + 24);
    _Block_object_dispose(&v9, 8);
  }
  return v6;
}

void sub_183F673E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK17CoreSchedulingSet18currentlyInContextEv_block_invoke(uint64_t result, uint64_t a2, CFTypeRef cf2)
{
  uint64_t v3;

  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24))
  {
    v3 = result;
    if (*(_QWORD *)(result + 40) == a2)
    {
      if (cf2 && (result = *(_QWORD *)(result + 48)) != 0 && (result = CFEqual((CFTypeRef)result, cf2), (_DWORD)result)
        || (CFTypeRef)*MEMORY[0x1E0C9B270] == cf2 && *(_QWORD *)(v3 + 48) && (result = _CFRunLoop01(), (_DWORD)result))
      {
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = 1;
      }
    }
  }
  return result;
}

uint64_t BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_initial(_QWORD *a1)
{
  a1[1] = BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void __CFURLCache::~__CFURLCache(__CFURLCache *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  NSObject *v5;
  const void *v6;
  const void *v7;
  uint64_t v8;
  NSObject *v9;
  sqlite3 *v10;
  std::__shared_weak_count *v11;
  _QWORD block[5];

  *(_QWORD *)this = &off_1E14E6600;
  __CFURLCache::PurgeMemoryCache(this);
  v2 = (const void *)*((_QWORD *)this + 27);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 27) = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  CFSetRemoveAllValues(*((CFMutableSetRef *)this + 56));
  v3 = (const void *)*((_QWORD *)this + 56);
  if (v3)
    CFRelease(v3);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 376));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 376));
  v4 = (const void *)*((_QWORD *)this + 4);
  if (v4)
  {
    _Block_release(v4);
    *((_QWORD *)this + 4) = 0;
  }
  v5 = *((_QWORD *)this + 3);
  if (v5)
  {
    dispatch_release(v5);
    *((_QWORD *)this + 3) = 0;
  }
  if (*((_QWORD *)this + 65))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 65));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
    v6 = (const void *)*((_QWORD *)this + 65);
    if (v6)
      CFRelease(v6);
    *((_QWORD *)this + 65) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456));
  if (*((_QWORD *)this + 67))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 552));
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 67));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 552));
    v7 = (const void *)*((_QWORD *)this + 67);
    if (v7)
      CFRelease(v7);
    *((_QWORD *)this + 67) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 552));
  v8 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v8)
  {
    v9 = *((_QWORD *)this + 17);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZN12__CFURLCacheD2Ev_block_invoke;
    block[3] = &unk_1E14FE118;
    block[4] = v8;
    dispatch_async(v9, block);
  }
  dispatch_release(*((dispatch_object_t *)this + 17));

  v10 = (sqlite3 *)*((_QWORD *)this + 78);
  if (v10)
    sqlite3_close(v10);
  std::deque<__CFURLCacheNode *>::~deque[abi:nn180100]((uint64_t)this + 264);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)this + 224);
  *((_QWORD *)this + 6) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 56));
  v11 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
}

{
  __CFURLCache::~__CFURLCache(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183F67658(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v3;

  std::deque<__CFURLCacheNode *>::~deque[abi:nn180100](v1 + 264);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table(v1 + 224);
  *(_QWORD *)(v1 + 48) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 56));
  v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(a1);
}

uint64_t __CFURLCache::PurgeMemoryCache(__CFURLCache *this)
{
  pthread_mutex_t *v2;
  _QWORD *i;
  _QWORD *NodeFromHashMap;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t j;
  void **v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = (pthread_mutex_t *)((char *)this + 312);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 312));
  for (i = (_QWORD *)*((_QWORD *)this + 30); i; i = (_QWORD *)*i)
  {
    NodeFromHashMap = __CFURLCache::GetNodeFromHashMap(this, i[2]);
    if (NodeFromHashMap)
      (*(void (**)(_QWORD *))(*NodeFromHashMap + 8))(NodeFromHashMap);
  }
  if (*((_QWORD *)this + 31))
  {
    v5 = (_QWORD *)*((_QWORD *)this + 30);
    if (v5)
    {
      do
      {
        v6 = (_QWORD *)*v5;
        operator delete(v5);
        v5 = v6;
      }
      while (v6);
    }
    *((_QWORD *)this + 30) = 0;
    v7 = *((_QWORD *)this + 29);
    if (v7)
    {
      for (j = 0; j != v7; ++j)
        *(_QWORD *)(*((_QWORD *)this + 28) + 8 * j) = 0;
    }
    *((_QWORD *)this + 31) = 0;
  }
  v9 = (void **)*((_QWORD *)this + 34);
  v10 = *((_QWORD *)this + 35);
  *((_QWORD *)this + 38) = 0;
  v11 = v10 - (_QWORD)v9;
  if (v11 >= 0x11)
  {
    do
    {
      operator delete(*v9);
      v12 = *((_QWORD *)this + 35);
      v9 = (void **)(*((_QWORD *)this + 34) + 8);
      *((_QWORD *)this + 34) = v9;
      v11 = v12 - (_QWORD)v9;
    }
    while (v11 > 0x10);
  }
  if (v11 >> 3 == 1)
  {
    v13 = 256;
    goto LABEL_18;
  }
  if (v11 >> 3 == 2)
  {
    v13 = 512;
LABEL_18:
    *((_QWORD *)this + 37) = v13;
  }
  *((_QWORD *)this + 18) = 0;
  return pthread_mutex_unlock(v2);
}

void HTTP3Stream::_resumeRequestBody(HTTP3Stream *this)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[5];
  std::__shared_weak_count *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v21, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v2 = *((_QWORD *)this + 12);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 13);
  v19 = v2;
  v20 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3321888768;
  v17[2] = ___ZN11HTTP3Stream18_resumeRequestBodyEv_block_invoke;
  v17[3] = &__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
  v17[4] = v21;
  v18 = v22;
  if (v22)
  {
    v6 = (unint64_t *)&v22->__shared_owners_;
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 16))(v2, v17);
  v8 = v18;
  if (v18)
  {
    v9 = (unint64_t *)&v18->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v20;
  if (v20)
  {
    v12 = (unint64_t *)&v20->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v22;
  if (v22)
  {
    v15 = (unint64_t *)&v22->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_183F678FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  uint64_t v8;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v8 - 32);
  _Unwind_Resume(a1);
}

void HTTPEngine::_chunkedReadHeader(HTTPEngine *this)
{
  NSObject *v2;
  size_t size;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[7];
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  v2 = *((_QWORD *)this + 24);
  if (v2)
    size = dispatch_data_get_size(v2);
  else
    size = 0;
  v16 = 0;
  v17 = 0;
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (v4 && (v4 = std::__shared_weak_count::lock(v4), (v17 = v4) != 0))
  {
    v5 = *((_QWORD *)this + 5);
    v16 = v5;
  }
  else
  {
    v5 = 0;
  }
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3321888768;
  v14[2] = ___ZN10HTTPEngine18_chunkedReadHeaderEv_block_invoke;
  v14[3] = &__block_descriptor_64_e8_48c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e16_v28__0___qi_8B24l;
  v14[4] = this;
  v14[5] = size;
  v14[6] = v5;
  v15 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  HTTPEngine::_readBlob((uint64_t)this, 132000, (uint64_t)v14);
  v8 = v15;
  if (v15)
  {
    v9 = (unint64_t *)&v15->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v17;
  if (v17)
  {
    v12 = (unint64_t *)&v17->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_183F67A5C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

void HTTPEngine::_readHeadersDoRead(HTTPEngine *this)
{
  int v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  int v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[5];
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  if (*((_QWORD *)this + 24))
    __assert_rtn("_readHeadersDoRead", "HTTPEngine.cpp", 836, "!_inData");
  v2 = *((_DWORD *)this + 8);
  if ((v2 & 0x400) != 0)
  {
    *((_DWORD *)this + 8) = v2 | 0x800;
  }
  else
  {
    v16 = 0;
    v17 = 0;
    v3 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
    if (v3 && (v3 = std::__shared_weak_count::lock(v3), (v17 = v3) != 0))
    {
      v4 = *((_QWORD *)this + 5);
      v16 = v4;
    }
    else
    {
      v4 = 0;
    }
    if ((*((_DWORD *)this + 8) & 0x400000) != 0)
      v5 = 0x10000;
    else
      v5 = 0x4000;
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3321888768;
    v14[2] = ___ZN10HTTPEngine18_readHeadersDoReadEv_block_invoke;
    v14[3] = &__block_descriptor_48_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e16_v28__0___qi_8B24l;
    v14[4] = v4;
    v15 = v3;
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    HTTPEngine::_readBlob((uint64_t)this, v5, (uint64_t)v14);
    v8 = v15;
    if (v15)
    {
      v9 = (unint64_t *)&v15->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v11 = v17;
    if (v17)
    {
      v12 = (unint64_t *)&v17->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
}

void sub_183F67BE0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

void HTTPEngine::_readBlob(uint64_t a1, int a2, uint64_t a3)
{
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  _QWORD v19[8];
  std::__shared_weak_count *v20;
  int v21;
  int v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  _QWORD v25[6];
  __int128 v26;

  v25[0] = 0;
  v25[1] = v25;
  v25[2] = 0x4012000000;
  v25[3] = __Block_byref_object_copy__15809;
  v25[4] = __Block_byref_object_dispose__15810;
  v26 = 0uLL;
  v25[5] = &unk_18422E08D;
  if (!*(_QWORD *)(a1 + 56) || (*(_BYTE *)(a1 + 32) & 1) != 0)
  {
    v26 = *(_OWORD *)(a1 + 96);
    if (DWORD2(v26))
    {
      v9 = v26;
    }
    else
    {
      v9 = 4;
      *(_QWORD *)&v26 = 4;
      DWORD2(v26) = -4;
    }
    (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a3 + 16))(a3, v9, *((_QWORD *)&v26 + 1), 1);
    goto LABEL_10;
  }
  v23 = 0;
  v24 = 0;
  v6 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v6)
  {
    v7 = 0;
    goto LABEL_12;
  }
  v7 = std::__shared_weak_count::lock(v6);
  v24 = v7;
  if (!v7)
  {
LABEL_12:
    v8 = 0;
    goto LABEL_13;
  }
  v8 = *(_QWORD *)(a1 + 40);
  v23 = v8;
LABEL_13:
  v10 = *(_QWORD *)(a1 + 112);
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 3321888768;
  v19[2] = ___ZN10HTTPEngine9_readBlobEjU13block_pointerFv13CFStreamErrorbE_block_invoke;
  v19[3] = &unk_1E14F4588;
  v21 = 1;
  v22 = a2;
  v19[6] = a1;
  v19[7] = v8;
  v20 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v19[4] = a3;
  v19[5] = v25;
  ConnectionReadAggregator::read(v10, 1, a2, v19, 0.0);
  v13 = v20;
  if (v20)
  {
    v14 = (unint64_t *)&v20->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v24;
  if (v24)
  {
    v17 = (unint64_t *)&v24->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
LABEL_10:
  _Block_object_dispose(v25, 8);
}

void sub_183F67DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t CFHTTPCookieStorageCopySharedHTTPCookieStorage(void)
{
  uint64_t v0;
  NSHTTPCookieStorage *v1;
  _QWORD block[5];

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
    return 0;
  pthread_mutex_lock(&gSharedCookieStorageLock);
  v1 = (NSHTTPCookieStorage *)gSharedCookieStorageInstance;
  if (!gSharedCookieStorageInstance)
  {
    if (newCookieStorageEnabled(void)::onceToken != -1)
      dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
    if (newCookieStorageEnabled(void)::enabled)
    {
      v1 = +[NSHTTPCookieStorage sharedHTTPCookieStorage](NSHTTPCookieStorageToCookie2Storage, "sharedHTTPCookieStorage");
    }
    else
    {
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZL33_CFHTTPCookieStorageCreateDefaultPK13__CFAllocator_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = 0;
      if (_CFHTTPCookieStorageCreateDefault(__CFAllocator const*)::onceToken != -1)
        dispatch_once(&_CFHTTPCookieStorageCreateDefault(__CFAllocator const*)::onceToken, block);
      v1 = (NSHTTPCookieStorage *)_CFHTTPCookieStorageCreateDefault(__CFAllocator const*)::cookieStorage;
    }
    gSharedCookieStorageInstance = (uint64_t)v1;
  }
  CFRetain(v1);
  v0 = gSharedCookieStorageInstance;
  pthread_mutex_unlock(&gSharedCookieStorageLock);
  return v0;
}

CFURLCacheFS *_CFURLCacheCreateFS2(const __CFString *a1)
{
  CFURLCacheFS *v2;

  if (!a1)
    return 0;
  v2 = (CFURLCacheFS *)operator new();
  CFURLCacheFS::CFURLCacheFS(v2, a1);
  return v2;
}

void sub_183F67F94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10F1C4059CE80F0);
  _Unwind_Resume(a1);
}

void CFURLCacheFS::CFURLCacheFS(CFURLCacheFS *this, const __CFString *a2)
{
  const __CFString *v4;
  NSObject *v5;
  uint8_t buf[16];

  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), 0);
  *(_QWORD *)this = &off_1E14E5790;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_BYTE *)this + 120) = 0;
  if (a2)
  {
    *((_QWORD *)this + 9) = CFRetain(a2);
    *((_QWORD *)this + 10) = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@/%@"), a2, CFSTR("fsCachedData"));
    v4 = (const __CFString *)*((_QWORD *)this + 9);
    if (v4)
      *((_QWORD *)this + 14) = _ExtractCStringfromCFStringRef(v4, (BOOL *)this + 120);
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_183ECA000, v5, OS_LOG_TYPE_ERROR, "ERROR(3): attempt to create CFURLCacheFS object with NULL path.", buf, 2u);
    }
  }
}

void sub_183F680F4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  pthread_mutex_t *v2;
  uint64_t v3;

  *v1 = v3;
  pthread_mutex_destroy(v2);
  _Unwind_Resume(a1);
}

void CFURLConnectionCancel(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  v2 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  if (a1)
    v3 = a1 + 16;
  else
    v3 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)(v3 + 8) + 48))(v3 + 8);
  objc_autoreleasePoolPop(v2);
}

void sub_183F69734(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  _Unwind_Resume(a1);
}

void sub_183F697C0()
{
  JUMPOUT(0x183F697ACLL);
}

void sub_183F697D0()
{
  JUMPOUT(0x183F697B4);
}

uint64_t volumeSupportsFileProtection(const char *a1)
{
  char *v1;
  char v3[1024];
  statfs v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v1 = dirname_r(a1, v3);
  if (statfs(v1, &v4) == -1)
    return 0;
  else
    return (v4.f_flags >> 7) & 1;
}

void sub_183F69B24(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_183F69D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void sub_183F69E14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183F69EE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void sub_183F6A014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  pthread_mutex_t *v11;

  pthread_mutex_unlock(v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void CFHTTPCookieStorageSetCookieAcceptPolicy(char *a1, uint64_t a2)
{
  char *v4;
  _QWORD *v5;
  uint64_t v6;

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    objc_msgSend(a1, "setCookieAcceptPolicy:", (int)a2);
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    if (a2 <= 3)
    {
      v4 = a1 + 16;
      if (!a1)
        v4 = 0;
      v5 = (_QWORD *)*((_QWORD *)v4 + 2);
      if (v5)
      {
        v6 = v5[4];
        if (v6)
          pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
        (*(void (**)(_QWORD *, uint64_t))(*v5 + 168))(v5, a2);
        if (v6)
          pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
      }
    }
  }
}

void sub_183F6A174(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t qenc_update_risked_list(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(result + 112);
  if (v1)
  {
    v2 = result;
    do
    {
      v3 = *(_QWORD *)(v1 + 16);
      if (*(_DWORD *)(v1 + 60) <= *(_DWORD *)(v2 + 4))
        result = qenc_remove_from_risked_list(v2, (_QWORD *)v1);
      v1 = v3;
    }
    while (v3);
  }
  return result;
}

uint64_t qenc_remove_from_risked_list(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  int v8;
  FILE *v9;

  v2 = result;
  if (*(_QWORD *)(result + 112))
  {
    v3 = a2[2];
    v4 = (_QWORD *)a2[3];
    if (v3)
    {
      *(_QWORD *)(v3 + 24) = v4;
      v4 = (_QWORD *)a2[3];
    }
    else
    {
      *(_QWORD *)(result + 120) = v4;
    }
    *v4 = v3;
    v5 = (_QWORD *)a2[4];
    if (v5 == a2)
    {
      v8 = *(_DWORD *)(result + 40);
      if (!v8)
        __assert_rtn("qenc_remove_from_risked_list", "lsqpack.c", 1174, "enc->qpe_cur_streams_at_risk > 0");
      *(_DWORD *)(result + 40) = v8 - 1;
      v9 = *(FILE **)(result + 200);
      if (v9)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v9);
        fprintf(*(FILE **)(v2 + 200), "streams at risk: %u", *(_DWORD *)(v2 + 40));
        return fputc(10, *(FILE **)(v2 + 200));
      }
    }
    else
    {
      v6 = (_QWORD *)a2[4];
      do
      {
        v7 = v6;
        v6 = (_QWORD *)v6[4];
      }
      while (v6 != a2);
      v7[4] = v5;
      a2[4] = a2;
    }
  }
  else if (*(_DWORD *)(result + 40))
  {
    __assert_rtn("qenc_remove_from_risked_list", "lsqpack.c", 1168, "enc->qpe_cur_streams_at_risk == 0");
  }
  return result;
}

uint64_t ___ZN25TransportConnectionObjCPP5writeEP11objc_objectU13block_pointerFv13CFStreamErrorE_block_invoke_7(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t (*v4)(_QWORD *, uint64_t, uint64_t, uint64_t);
  uint64_t v5;
  _QWORD *v6;

  v3 = *(_QWORD *)(result + 32);
  if (v3)
  {
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(v3 + 8);
    v5 = *(_QWORD *)(v3 + 16);
    v6 = (_QWORD *)(v3 + (v5 >> 1));
    if ((v5 & 1) != 0)
      v4 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v6 + v4);
    return v4(v6, 1, a2, a3);
  }
  return result;
}

uint64_t ___ZN25TransportConnectionObjCPP5writeEP11objc_objectU13block_pointerFv13CFStreamErrorE_block_invoke(uint64_t a1, int a2)
{
  NSObject *v4;
  uint8_t v5[16];

  if (a2)
    return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v5 = 0;
    _os_log_error_impl(&dword_183ECA000, v4, OS_LOG_TYPE_ERROR, "NSURLSessionStreamTask: Connection write invalidated by closed connection", v5, 2u);
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN22__NSCFTCPIOWriteStream17_streamImpl_WriteEP15__CFWriteStreamPKhlP13CFStreamError_block_invoke(uint64_t a1)
{
  const void *v2;

  CFWriteStreamSignalEvent();
  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
}

void ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2(uint64_t a1, void *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  id v10;
  NSObject *v11;
  HTTP3Connection *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;
  CFStreamError v26;

  v25 = *MEMORY[0x1E0C80C00];
  v10 = a2;
  v11 = a3;
  if (v11 && !(_DWORD)a6)
  {
    v12 = *(HTTP3Connection **)(a1 + 40);
    if (*((_QWORD *)v12 + 124))
    {
      HTTP3Connection::_stopStallRecovery(v12);
      v12 = *(HTTP3Connection **)(a1 + 40);
    }
    HTTP3Connection::_readDecoderStream((int)v12, v11);
    goto LABEL_19;
  }
  if (!(_DWORD)a6)
  {
    v13 = *(_QWORD *)(a1 + 40);
    if ((*(_BYTE *)(v13 + 920) & 4) == 0)
    {
      v14 = *(_QWORD *)(v13 + 1008);
      if (v14)
      {
        if ((*(uint64_t (**)(_QWORD))(*(_QWORD *)v14 + 120))(*(_QWORD *)(v13 + 1008)) != -1)
          goto LABEL_10;
        v13 = *(_QWORD *)(a1 + 40);
      }
      *(_QWORD *)(v13 + 1160) = 4;
      *(_DWORD *)(v13 + 1168) = -1;
      HTTP3Connection::_cleanupConnection((HTTP3Connection *)v13, 260, 0);
      HTTP3Connection::reportServerProtocolViolation(*(_QWORD *)(a1 + 40), 34, -1);
      CFN_LOG_h3connection();
      v15 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      {
        v19 = *(_QWORD *)(a1 + 40);
        v20 = *(_QWORD *)(v19 + 1216);
        v21 = 134218240;
        v22 = v19;
        v23 = 2048;
        v24 = v20;
        _os_log_fault_impl(&dword_183ECA000, v15, OS_LOG_TYPE_FAULT, "%p %llu Decoder stream closed but connection is alive", (uint8_t *)&v21, 0x16u);
      }
      goto LABEL_18;
    }
  }
LABEL_10:
  v26.domain = a5;
  *(_QWORD *)&v26.error = a6;
  if (HTTP3Connection::checkAndPerformFallback(*(HTTP3Connection **)(a1 + 40), v26))
  {
    CFN_LOG_h3connection();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_QWORD *)(a1 + 40);
      v17 = *(_QWORD *)(v16 + 1216);
      v21 = 134218240;
      v22 = v16;
      v23 = 2048;
      v24 = v17;
      _os_log_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEFAULT, "%p %llu Decoder stream fallback triggered", (uint8_t *)&v21, 0x16u);
    }
LABEL_18:

    goto LABEL_19;
  }
  v18 = *(_QWORD *)(a1 + 40);
  *(_BYTE *)(v18 + 920) |= 2u;
  if (*(_QWORD *)(v18 + 1136) == *(_QWORD *)(v18 + 1144))
    HTTP3Connection::_cleanupConnection((HTTP3Connection *)v18, 256, 0);
LABEL_19:

}

void sub_183F6A63C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t ___ZN14TCPIO_Delegate18_onqueue_writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v3 + 72) = a2;
  *(_QWORD *)(v3 + 80) = a3;
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void `non-virtual thunk to'ClassicURLConnection::cancel(ClassicURLConnection *this)
{
  ClassicURLConnection::cancel((ClassicURLConnection *)((char *)this - 8));
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolCacheResponseIsValid(URLConnectionLoader_Classic *this, const _CFCachedURLResponse *a2)
{
  URLConnectionLoader_Classic::protocolCacheResponseIsValid((URLConnectionLoader_Classic *)((char *)this - 56), a2);
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,CFStreamError> *,SmartBlockWithArgs<BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<BOOL,CFStreamError>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  int v5;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if ((uint64_t (*)(_QWORD *))v3 == BlockHolderVar<BOOL,CFStreamError>::invoke_initial && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      (*(void (**)(_QWORD *, _QWORD, _QWORD, _QWORD))(*v7
                                                               + BlockHolderVar<BOOL,CFStreamError>::invoke_initial))(v7, 0, 0, 0);
    else
      ((void (*)(_QWORD *, _QWORD, _QWORD, _QWORD))BlockHolderVar<BOOL,CFStreamError>::invoke_initial)(v7, 0, 0, 0);
  }
  _Block_release(*(const void **)v1);
  JUMPOUT(0x186DB748CLL);
}

BOOL HTTPConnectionCacheEntry::EnqueuedRequest::equals(HTTPConnectionCacheEntry::EnqueuedRequest *this, const CFAllocatedReferenceCountedObject *a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  const CFAllocatedReferenceCountedObject *v12;
  const void *v13;

  if (this == a2)
    return 1;
  if (*((_QWORD *)this + 3) != *((_QWORD *)a2 + 3))
    return 0;
  v3 = *((_QWORD *)this + 5);
  v4 = &HSTSCache::defaultStoreURL(void)::once;
  if (v3)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    {
      v10 = *((_QWORD *)this + 5);
      v12 = a2;
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v3 = v10;
      a2 = v12;
      v4 = &HSTSCache::defaultStoreURL(void)::once;
    }
    if (!*(_BYTE *)(v3 + 40))
    {
      v5 = v3 + 16;
LABEL_11:
      v6 = (const void *)(v5 - 16);
      goto LABEL_13;
    }
  }
  else
  {
    v5 = *((_QWORD *)this + 4);
    if (v5)
      goto LABEL_11;
  }
  v6 = 0;
LABEL_13:
  v7 = *((_QWORD *)a2 + 5);
  if (!v7)
  {
    v8 = *((_QWORD *)a2 + 4);
    if (v8)
      goto LABEL_19;
LABEL_20:
    v9 = 0;
    return CFEqual(v6, v9) != 0;
  }
  if (v4[127] != -1)
  {
    v11 = *((_QWORD *)a2 + 5);
    v13 = v6;
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v7 = v11;
    v6 = v13;
  }
  if (*(_BYTE *)(v7 + 40))
    goto LABEL_20;
  v8 = v7 + 16;
LABEL_19:
  v9 = (const void *)(v8 - 16);
  return CFEqual(v6, v9) != 0;
}

void URLConnectionLoader_Classic::protocolCacheResponseIsValid(URLConnectionLoader_Classic *this, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[6];
  _QWORD block[6];

  if (cf)
    CFRetain(cf);
  v4 = MEMORY[0x1E0C809B0];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN27URLConnectionLoader_Classic28protocolCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke;
  v7[3] = &__block_descriptor_48_e5_v8__0l;
  v7[4] = this;
  v7[5] = cf;
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v6 = *((_QWORD *)this + 5);
  block[0] = v4;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v7;
  block[5] = v5;
  dispatch_async(v6, block);
}

void ClassicURLConnection::cancel(ClassicURLConnection *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[5];
  _QWORD v7[6];
  _QWORD v8[6];
  _QWORD block[6];

  if (!(*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3)))
  {
    v2 = MEMORY[0x1E0C809B0];
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN20ClassicURLConnection6cancelEv_block_invoke;
    v6[3] = &__block_descriptor_40_e39_v16__0__ConnectionClientInterface_____8l;
    v6[4] = this;
    CFRetain((char *)this - 16);
    v3 = *((_QWORD *)this + 3);
    v7[0] = v2;
    v7[1] = 3221225472;
    v7[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
    v7[3] = &unk_1E14F78D0;
    v7[4] = v6;
    v7[5] = this;
    v8[0] = v2;
    v8[1] = 3221225472;
    v8[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
    v8[3] = &unk_1E14FDA90;
    v8[4] = v7;
    v8[5] = v3;
    v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 32) + 64))(*(_QWORD *)(v3 + 32));
    v5 = *(NSObject **)(v3 + 40);
    block[0] = v2;
    block[1] = 3221225472;
    block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
    block[3] = &unk_1E14FDA90;
    block[4] = v8;
    block[5] = v4;
    dispatch_async(v5, block);
  }
}

uint64_t ClassicURLConnection::getNetworkServiceTypeString(int a1)
{
  uint64_t *v1;
  uint64_t result;

  switch(a1)
  {
    case 1:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVoIP;
      goto LABEL_14;
    case 2:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVideo;
      goto LABEL_14;
    case 3:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeBackground;
      goto LABEL_14;
    case 4:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVoice;
      goto LABEL_14;
    case 5:
      v1 = &kCFStreamNetworkServiceTypeBackgroundSystemInitiated;
      goto LABEL_14;
    case 6:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeResponsiveData;
      goto LABEL_14;
    case 7:
      v1 = &kCFStreamNetworkServiceTypeOAM;
      goto LABEL_14;
    case 8:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeAVStreaming;
      goto LABEL_14;
    case 9:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeResponsiveAV;
      goto LABEL_14;
    case 10:
      v1 = &kCFStreamNetworkServiceTypeNetworkControl;
      goto LABEL_14;
    case 11:
      v1 = (uint64_t *)&kCFStreamNetworkServiceTypeCallSignaling;
LABEL_14:
      result = *v1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t URLConnectionClient::_markClientAsCanceledAndAskIfItAlreadyWas(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t os_unfair_lock_opaque_low;

  v2 = this + 32;
  os_unfair_lock_lock(this + 32);
  os_unfair_lock_opaque_low = LOBYTE(this[33]._os_unfair_lock_opaque);
  LOBYTE(this[33]._os_unfair_lock_opaque) = 1;
  os_unfair_lock_unlock(v2);
  return os_unfair_lock_opaque_low;
}

uint64_t MetaNetStreamInfo::getHTTPConnectionInfo(MetaNetStreamInfo *this)
{
  return 0;
}

void HTTPCookieStorage::scheduleWithRunLoop(HTTPCookieStorage *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6;
  __CFRunLoopTimer *v7;
  const __CFAllocator *v8;
  double Current;
  double v10;
  BOOL v11;
  double v12;
  CFRunLoopTimerContext context;

  v6 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = v6 + 1;
  if (v6)
  {
    v7 = (__CFRunLoopTimer *)*((_QWORD *)this + 4);
    if (!v7)
      return;
    goto LABEL_10;
  }
  context.version = 0;
  context.info = (char *)this - 16;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  context.copyDescription = (CFStringRef (__cdecl *)(const void *))MEMORY[0x1E0C98350];
  v8 = CFGetAllocator((char *)this - 16);
  Current = CFAbsoluteTimeGetCurrent();
  v10 = *((double *)this + 6);
  v11 = v10 + 10.0 < Current || v10 == 0.0;
  v12 = 2.0;
  if (!v11)
    v12 = 10.0;
  v7 = CFRunLoopTimerCreate(v8, Current + v12, 1.0e30, 0, 0, (CFRunLoopTimerCallBack)HTTPCookieStorage::_syncTimerFired, &context);
  *((_QWORD *)this + 4) = v7;
  if (v7)
  {
LABEL_10:
    if (CFRunLoopTimerIsValid(v7))
      CFRunLoopAddTimer(a2, *((CFRunLoopTimerRef *)this + 4), a3);
  }
}

void DiskCookieStorage::setCookieAcceptPolicyLocked(DiskCookieStorage *this, int a2)
{
  const __CFAllocator *v4;
  const char *v5;
  size_t v6;
  CFURLRef v7;
  uint64_t v8;
  UInt8 bytes[4];
  UInt8 v10[4];

  if (*((_DWORD *)this + 80) != a2)
  {
    v4 = (const __CFAllocator *)*((_QWORD *)this + 1);
    v5 = (const char *)(*((_QWORD *)this + 9) + 1);
    v6 = strlen(v5);
    v7 = CFURLCreateFromFileSystemRepresentation(v4, (const UInt8 *)v5, v6, 0);
    CFLog();
    if (v7)
      CFRelease(v7);
    v8 = *((_QWORD *)this + 38);
    ++*((_QWORD *)this + 39);
    if (v8)
    {
      *(_DWORD *)bytes = 3;
      *(_DWORD *)v10 = a2;
      CFDataAppendBytes(*(CFMutableDataRef *)(v8 + 16), bytes, 4);
      CFDataAppendBytes(*(CFMutableDataRef *)(v8 + 16), v10, 4);
    }
    *((_DWORD *)this + 80) = a2;
  }
}

char *StorageSession::copyProcessDefault(StorageSession *this)
{
  char *v1;
  char *v2;

  if (StorageSession::copyProcessDefault(void)::sOnce != -1)
    dispatch_once(&StorageSession::copyProcessDefault(void)::sOnce, &__block_literal_global_3_16303);
  v1 = (char *)StorageSession::copyProcessDefault(void)::sProcessDefault;
  if (!StorageSession::copyProcessDefault(void)::sProcessDefault)
    return 0;
  if (StorageSession::Class(void)::sOnce_StorageSession != -1)
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
  v2 = v1 + 16;
  CFRetain(v1);
  return v2;
}

void HTTPConnection::suspendTransaction(uint64_t a1, _QWORD *a2, int a3)
{
  HTTPEngine *v4;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;

  if (*a2)
  {
    v4 = *(HTTPEngine **)(a1 + 64);
    if (v4)
    {
      v7 = *(_QWORD *)(a1 + 144);
      if (v7)
        v8 = *a2 == v7;
      else
        v8 = 0;
      if (v8)
        HTTPEngine::suspendWrites(v4, a3);
      v9 = *(_QWORD *)(a1 + 160);
      if (v9)
      {
        if (*a2 == v9)
          HTTPEngine::suspendReads(*(HTTPEngine **)(a1 + 64), a3);
      }
    }
  }
}

uint64_t BlockHolderVar<BOOL,CFStreamError>::invoke_initial(_QWORD *a1)
{
  a1[1] = BlockHolderVar<BOOL,CFStreamError>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

const _CFURLRequest *__CFURLCache::checkCacheEquivalency(__CFURLCache *this, const _CFCachedURLResponse *a2, const _CFURLRequest *a3, NSURLSession *a4)
{
  const _CFURLRequest *v4;
  const _CFURLRequest *result;
  uint64_t v8;
  os_unfair_lock_s *v9;
  const void *v10;

  v4 = a3;
  if (a3 || (result = (const _CFURLRequest *)+[NSURLSession _sharedSessionForConnection](), (v4 = result) != 0))
  {
    v8 = *((_QWORD *)this + 2);
    v9 = (os_unfair_lock_s *)(v8 + 88);
    os_unfair_lock_lock((os_unfair_lock_t)(v8 + 88));
    v10 = *(const void **)(v8 + 112);
    os_unfair_lock_unlock(v9);
    return (const _CFURLRequest *)-[__NSURLSessionLocal _cfurlRequest:isCacheEquivalentTo:]((uint64_t)v4, v10, a2);
  }
  return result;
}

HTTPProtocol *HTTPProtocol::setSSLCertContextOnResponseOrCachedResponse(HTTPProtocol *this, HTTPProtocol *a2, const _CFCachedURLResponse *a3)
{
  const void *v3;
  CFTypeRef *v4;

  if (a2)
  {
    if ((*((_DWORD *)this + 48) & 0x4000) == 0)
      return this;
    v3 = (const void *)*((_QWORD *)this + 50);
    if (!v3)
      return this;
    this = a2;
  }
  else
  {
    if (!a3)
      return this;
    if ((*((_DWORD *)this + 48) & 0x4000) == 0)
      return this;
    v3 = (const void *)*((_QWORD *)this + 50);
    if (!v3)
      return this;
    this = (HTTPProtocol *)*((_QWORD *)a3->var1 + 4);
    if (!this)
      return this;
  }
  v4 = (CFTypeRef *)(-[HTTPProtocol _inner](this, "_inner", a3) + 64);
  if (*v4)
    CFRelease(*v4);
  this = (HTTPProtocol *)CFRetain(v3);
  *v4 = this;
  return this;
}

BOOL AwaitingTube::isValid(AwaitingTube *this)
{
  return (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 6) + 184))(*((_QWORD *)this + 6)) != 0;
}

CFTypeRef HTTPRequest::setBodyParts(HTTPRequest *this, CFTypeRef cf)
{
  CFTypeRef result;

  result = (CFTypeRef)*((_QWORD *)this + 26);
  if (result != cf)
  {
    if (result)
      CFRelease(result);
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *((_QWORD *)this + 26) = result;
  }
  return result;
}

void HTTPEngine::suspendReads(HTTPEngine *this, int a2)
{
  int v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  NSObject *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  NSObject *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  _QWORD v27[5];
  std::__shared_weak_count *v28;
  _QWORD block[5];
  std::__shared_weak_count *v30;

  v3 = *((_DWORD *)this + 8);
  if (a2)
  {
    *((_DWORD *)this + 8) = v3 | 0x400;
  }
  else
  {
    *((_DWORD *)this + 8) = v3 & 0xFFFFFBFF;
    if ((v3 & 0x400) != 0)
    {
      v4 = MEMORY[0x1E0C809B0];
      if ((v3 & 0x800) != 0)
      {
        *((_DWORD *)this + 8) = v3 & 0xFFFFF3FF;
        v5 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
        if (v5)
        {
          v6 = std::__shared_weak_count::lock(v5);
          if (v6)
            v7 = *((_QWORD *)this + 5);
          else
            v7 = 0;
        }
        else
        {
          v7 = 0;
          v6 = 0;
        }
        v8 = *((_QWORD *)this + 9);
        block[0] = v4;
        block[1] = 3321888768;
        block[2] = ___ZN10HTTPEngine12suspendReadsEb_block_invoke;
        block[3] = &__block_descriptor_48_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
        block[4] = v7;
        v30 = v6;
        if (v6)
        {
          p_shared_owners = (unint64_t *)&v6->__shared_owners_;
          do
            v10 = __ldxr(p_shared_owners);
          while (__stxr(v10 + 1, p_shared_owners));
        }
        dispatch_async(v8, block);
        v11 = v30;
        if (v30)
        {
          v12 = (unint64_t *)&v30->__shared_owners_;
          do
            v13 = __ldaxr(v12);
          while (__stlxr(v13 - 1, v12));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }
        if (v6)
        {
          v14 = (unint64_t *)&v6->__shared_owners_;
          do
            v15 = __ldaxr(v14);
          while (__stlxr(v15 - 1, v14));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
        }
      }
      if ((v3 & 0x1000) != 0)
      {
        *((_DWORD *)this + 8) &= ~0x1000u;
        v16 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
        if (v16)
        {
          v17 = std::__shared_weak_count::lock(v16);
          if (v17)
            v18 = *((_QWORD *)this + 5);
          else
            v18 = 0;
        }
        else
        {
          v18 = 0;
          v17 = 0;
        }
        v19 = *((_QWORD *)this + 9);
        v27[0] = v4;
        v27[1] = 3321888768;
        v27[2] = ___ZN10HTTPEngine12suspendReadsEb_block_invoke_14;
        v27[3] = &__block_descriptor_48_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
        v27[4] = v18;
        v28 = v17;
        if (v17)
        {
          v20 = (unint64_t *)&v17->__shared_owners_;
          do
            v21 = __ldxr(v20);
          while (__stxr(v21 + 1, v20));
        }
        dispatch_async(v19, v27);
        v22 = v28;
        if (v28)
        {
          v23 = (unint64_t *)&v28->__shared_owners_;
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
        if (v17)
        {
          v25 = (unint64_t *)&v17->__shared_owners_;
          do
            v26 = __ldaxr(v25);
          while (__stlxr(v26 - 1, v25));
          if (!v26)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
      }
    }
  }
}

void sub_183F6B43C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void CFURLConnectionStart(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  v2 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  if (a1)
    v3 = a1 + 16;
  else
    v3 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
  objc_autoreleasePoolPop(v2);
}

void CFURLConnectionScheduleWithRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;

  v6 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  if (a1)
    v7 = a1 + 16;
  else
    v7 = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 104))(v7, a2, a3);
  objc_autoreleasePoolPop(v6);
}

_OWORD *CFURLConnectionCreateWithProperties(uint64_t a1, void *a2, _QWORD *a3, const __CFDictionary *a4)
{
  _CFURLRequest *v6;
  const __CFDictionary *Value;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  uint64_t v10;
  const void *v11;
  const void *v12;
  uint64_t v13;
  const void *v14;
  _OWORD *Instance;
  _OWORD *v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  __CFDictionary *UpdatedSocketPropertiesForRequest;
  uint64_t v20;
  CONNECTION_SessionTask *v21;
  const __CFAllocator *v22;
  uint64_t v23;
  NSObject *v24;
  _OWORD *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint8_t v29;
  URLConnectionLoader_Classic *v30;
  _CFURLRequest *cf;
  void *context;
  uint8_t buf[8];
  uint64_t v36;
  uint64_t (*v37)(uint64_t, uint64_t);
  void *v38;
  _OWORD *v39;

  context = (void *)MEMORY[0x186DB8C8C]();
  if (!a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFURLConnectionCreate(): Asked to create from a NULL request!", buf, 2u);
  }
  v6 = (_CFURLRequest *)objc_msgSend(a2, "mutableCopy");
  if (a4)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(a4, CFSTR("kCFURLConnectionSocketStreamProperties"));
    if (Value)
    {
      v8 = (const __CFDictionary *)CFDictionaryGetValue(Value, &unk_1EDCFB868);
      if (v8)
      {
        v9 = v8;
        if (CFDictionaryContainsKey(v8, CFSTR("kConditionalConnectionRequirementTimeWindowDelay"))
          || CFDictionaryContainsKey(v9, CFSTR("kConditionalConnectionRequirementTimeWindowStartTime")))
        {
          v10 = -[_CFURLRequest _inner](v6, "_inner");
          *(_WORD *)(v10 + 64) |= 0x400u;
          *(_QWORD *)(v10 + 16) = 1;
        }
      }
    }
    v11 = CFDictionaryGetValue(a4, &unk_1EDCFE620);
    if (v11)
    {
      v12 = v11;
      v13 = -[_CFURLRequest _inner](v6, "_inner");
      CFRetain(v12);
      v14 = *(const void **)(v13 + 192);
      if (v14)
        CFRelease(v14);
      *(_QWORD *)(v13 + 192) = v12;
    }
  }
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v16 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v16 = Instance + 1;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
  }
  *((_QWORD *)v16 + 1) = &unk_1E14EB2D8;
  *(_QWORD *)v16 = &off_1E14EB1E8;
  *((_QWORD *)v16 + 2) = &unk_1E14EB338;
  if (a4)
  {
    v17 = (const __CFDictionary *)CFDictionaryGetValue(a4, CFSTR("kCFURLConnectionSocketStreamProperties"));
    v18 = (const __CFDictionary *)CFDictionaryGetValue(a4, CFSTR("kCFURLConnectionURLConnectionProperties"));
    UpdatedSocketPropertiesForRequest = createUpdatedSocketPropertiesForRequest(v6, v17, v18);
  }
  else
  {
    UpdatedSocketPropertiesForRequest = createUpdatedSocketPropertiesForRequest(v6, 0, 0);
    v18 = 0;
  }
  v20 = +[NSURLSession _sharedSessionForConnection]();
  if (v20)
  {
    v21 = -[CONNECTION_SessionTask initWithRequest:mutableCurrent:connProps:sockProps:session:]([CONNECTION_SessionTask alloc], "initWithRequest:mutableCurrent:connProps:sockProps:session:", a2, v6, v18, UpdatedSocketPropertiesForRequest, v20);
    if (!UpdatedSocketPropertiesForRequest)
      goto LABEL_24;
    goto LABEL_23;
  }
  v21 = 0;
  if (UpdatedSocketPropertiesForRequest)
LABEL_23:
    CFRelease(UpdatedSocketPropertiesForRequest);
LABEL_24:
  *((_QWORD *)v16 + 7) = v21;
  v22 = CFGetAllocator(v16 - 1);
  v23 = objc_msgSend(*((id *)v16 + 7), "session");
  cf = v6;
  if (v23)
    v24 = *(NSObject **)(v23 + 120);
  else
    v24 = 0;
  v25 = CFAllocatorAllocate(v22, 288, 0);
  *v25 = 0u;
  v25[1] = 0u;
  v25[2] = 0u;
  v25[3] = 0u;
  v25[4] = 0u;
  v25[5] = 0u;
  v25[6] = 0u;
  v25[7] = 0u;
  v25[8] = 0u;
  v25[9] = 0u;
  v25[10] = 0u;
  v25[11] = 0u;
  v25[12] = 0u;
  v25[13] = 0u;
  v25[14] = 0u;
  v25[15] = 0u;
  v25[16] = 0u;
  v25[17] = 0u;
  v26 = (void *)*((_QWORD *)v16 + 7);
  v27 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v16 + 1) + 56))((uint64_t)v16 + 8);
  *(_QWORD *)v25 = off_1E14ED770;
  *((_QWORD *)v25 + 1) = v27;
  *((_QWORD *)v25 + 2) = &unk_1E14ED798;
  *((_BYTE *)v25 + 25) = 0;
  *((_QWORD *)v25 + 4) = (char *)v16 + 8;
  *((_QWORD *)v25 + 5) = v24;
  dispatch_retain(v24);
  *((_BYTE *)v25 + 24) = 0;
  *(_QWORD *)v25 = off_1E14EA888;
  *((_QWORD *)v25 + 2) = &unk_1E14EA9D0;
  *((_QWORD *)v25 + 6) = &unk_1E14EA9F0;
  *((_QWORD *)v25 + 7) = &unk_1E14EAAA8;
  *((_QWORD *)v25 + 8) = &unk_1E14EAB00;
  *((_QWORD *)v25 + 27) = v16;
  *((_QWORD *)v25 + 11) = v26;
  *((_QWORD *)v25 + 15) = 1;
  v28 = MEMORY[0x1E0C809B0];
  *((_BYTE *)v25 + 232) = 0;
  *(_QWORD *)buf = v28;
  v36 = 3221225472;
  v37 = ___ZN19URLConnectionClientC2EP20ClassicURLConnectionP16NSURLSessionTaskPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
  v38 = &__block_descriptor_40_e24_v16__0r__XURLCache_____8l;
  v39 = v25;
  objc_msgSend(v26, "_withXURLCache:", buf);
  *((_BYTE *)v25 + 132) = 0;
  *((_DWORD *)v25 + 32) = 0;
  *((_BYTE *)v25 + 140) = 0;
  *((_DWORD *)v25 + 34) = 0;
  *((_QWORD *)v25 + 25) = 0;
  *((_DWORD *)v25 + 52) = 0;
  *((_BYTE *)v25 + 24) = 1;
  *(_QWORD *)v25 = off_1E14EDED8;
  *((_QWORD *)v25 + 2) = &unk_1E14EE0B8;
  *((_QWORD *)v25 + 6) = &unk_1E14EE0D8;
  *((_QWORD *)v25 + 7) = &unk_1E14EE190;
  *((_QWORD *)v25 + 8) = &unk_1E14EE1E8;
  *((_QWORD *)v25 + 33) = 0;
  *((_QWORD *)v25 + 31) = 0;
  URLConnectionClient_Classic::setDelegate((uint64_t)v25, a3);
  *((_QWORD *)v16 + 3) = v25;
  buf[0] = 0x80;
  if (a3)
  {
    v29 = 0x80;
    switch(*a3)
    {
      case 3:
      case 4:
        goto LABEL_38;
      case 5:
      case 6:
        goto LABEL_36;
      case 7:
        goto LABEL_34;
      case 8:
        goto LABEL_32;
      case 9:
        if (a3[23])
        {
          v29 = -112;
          buf[0] = -112;
        }
        if (a3[22])
        {
          v29 |= 0x20u;
          buf[0] = v29;
        }
LABEL_32:
        if (a3[21])
        {
          v29 |= 8u;
          buf[0] = v29;
        }
LABEL_34:
        if (a3[19])
          CFLog();
LABEL_36:
        if (a3[17])
        {
          v29 |= 1u;
          buf[0] = v29;
        }
LABEL_38:
        if (a3[13])
          buf[0] = v29 | 2;
        if (a3[14])
          *(_WORD *)(*((_QWORD *)v16 + 3) + 76) |= 0x100u;
        break;
      default:
        break;
    }
  }
  v30 = (URLConnectionLoader_Classic *)CFAllocatorAllocate(v22, 224, 0);
  *(_OWORD *)v30 = 0u;
  *((_OWORD *)v30 + 1) = 0u;
  *((_OWORD *)v30 + 2) = 0u;
  *((_OWORD *)v30 + 3) = 0u;
  *((_OWORD *)v30 + 4) = 0u;
  *((_OWORD *)v30 + 5) = 0u;
  *((_OWORD *)v30 + 6) = 0u;
  *((_OWORD *)v30 + 7) = 0u;
  *((_OWORD *)v30 + 8) = 0u;
  *((_OWORD *)v30 + 9) = 0u;
  *((_OWORD *)v30 + 10) = 0u;
  *((_OWORD *)v30 + 11) = 0u;
  *((_OWORD *)v30 + 12) = 0u;
  *((_OWORD *)v30 + 13) = 0u;
  URLConnectionLoader_Classic::URLConnectionLoader_Classic(v30, (InterfaceRequiredForLoader *)((char *)v16 + 8), (const ConfigFlags *)buf, (__NSURLSessionLocal *)objc_msgSend(*((id *)v16 + 7), "session"), v24);
  *((_QWORD *)v16 + 4) = v30;

  if (cf)
    CFRelease(cf);
  objc_autoreleasePoolPop(context);
  return v16 - 1;
}

void sub_183F6BC08(_Unwind_Exception *a1)
{
  URLConnectionClient *v1;

  URLConnectionClient::~URLConnectionClient(v1);
  _Unwind_Resume(a1);
}

CFHostRef CFHostCreateCopy(CFAllocatorRef alloc, CFHostRef host)
{
  _OWORD *Instance;
  HostBase *v4;
  const HostBase *v5;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v4 = (HostBase *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v4 = (HostBase *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  if (host)
  {
    if (HostBase::Class(void)::sOnce_HostBase != -1)
      dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
    v5 = (CFHostRef)((char *)host + 16);
  }
  else
  {
    v5 = 0;
  }
  HostBase::HostBase(v4, v5);
  *(_QWORD *)v4 = &off_1E14E59B8;
  *((_QWORD *)v4 + 1) = &unk_1E14E5A28;
  *((_QWORD *)v4 + 18) = copyHostQueue();
  *((_QWORD *)v4 + 19) = dispatch_group_create();
  return (HostBase *)((char *)v4 - 16);
}

void sub_183F6BD3C(_Unwind_Exception *a1)
{
  HostBase *v1;

  HostBase::~HostBase(v1);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t HTTPConnectionCacheKey::hash(HTTPConnectionCacheKey *this)
{
  return *((_QWORD *)this + 3);
}

void MultiplexerSource::_perform(MultiplexerSource *this, void *a2)
{
  os_unfair_lock_s *v3;
  const void *v4;
  const void *v5;
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  unint64_t Count;
  CFRange v9;
  const void **v10;
  CFIndex v11;
  const void *v12;
  uint64_t v13;
  __CFRunLoopSource *v14;
  uint64_t v15;
  CFTypeRef v16;
  CFIndex range;
  const void **v18;
  _BYTE v19[248];
  CFIndex v20;

  if (*((_BYTE *)this + 24))
    return;
  v3 = (os_unfair_lock_s *)((char *)this + 8);
  os_unfair_lock_lock((os_unfair_lock_t)this + 2);
  *((_QWORD *)this + 5) = 0;
  if (*((_BYTE *)this + 24))
  {
    os_unfair_lock_unlock(v3);
    return;
  }
  ++*((_QWORD *)this + 4);
  v5 = (const void *)*((_QWORD *)this + 8);
  v4 = (const void *)*((_QWORD *)this + 9);
  v6 = CFGetAllocator(v5);
  *((_QWORD *)this + 8) = CFSetCreateMutable(v6, 0, &MultiplexerSource::sClientSetContext);
  v7 = CFGetAllocator(*((CFTypeRef *)this + 9));
  *((_QWORD *)this + 9) = CFArrayCreateMutable(v7, 0, &MultiplexerSource::sClientArrayContext);
  if (v5)
  {
    if (v4)
    {
      v16 = CFRetain(v4);
      Count = CFArrayGetCount((CFArrayRef)v4);
      v9.length = Count;
      range = Count;
      if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v18 = 0;
      }
      else
      {
        if (Count <= 0x1E)
        {
          v10 = (const void **)v19;
          v18 = (const void **)v19;
LABEL_14:
          v9.location = 0;
          CFArrayGetValues((CFArrayRef)v4, v9, v10);
          goto LABEL_15;
        }
        v10 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
        v18 = v10;
        if (v10)
        {
          v9.length = range;
          goto LABEL_14;
        }
      }
    }
    else
    {
      v16 = 0;
      range = 0;
      v18 = (const void **)v19;
    }
LABEL_15:
    v20 = 0;
    if (range > 0)
    {
      v11 = 0;
      do
      {
        v20 = v11 + 1;
        v12 = v18[v11];
        os_unfair_lock_unlock(v3);
        (*(void (**)(const void *))(*(_QWORD *)v12 + 16))(v12);
        os_unfair_lock_lock(v3);
        v11 = v20;
      }
      while (v20 < range);
    }
    CFRelease(v5);
    if (v4)
      CFRelease(v4);
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v16);
  }
  v13 = *((_QWORD *)this + 4) - 1;
  *((_QWORD *)this + 4) = v13;
  if (v13 || !*((_BYTE *)this + 25))
  {
    os_unfair_lock_unlock(v3);
  }
  else
  {
    v14 = (__CFRunLoopSource *)*((_QWORD *)this + 7);
    if (v14)
    {
      CFRunLoopSourceInvalidate(v14);
      CFRelease(*((CFTypeRef *)this + 7));
      *((_QWORD *)this + 7) = 0;
    }
    v15 = *((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = v15 - 1;
    if (v15 <= 1)
      (*(void (**)(MultiplexerSource *))(*(_QWORD *)this + 8))(this);
  }
}

void sub_183F6BF9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'RunloopBlockContext::multiplexerClientPerform(RunloopBlockContext *this)
{
  RunloopBlockContext::perform((RunloopBlockContext *)((char *)this - 32));
}

void RunloopBlockContext::perform(RunloopBlockContext *this)
{
  BOOL v2;
  unint64_t i;
  const __CFArray *v4;
  CFRange v5;

  if (*((_BYTE *)this + 64))
  {
    if (*((_BYTE *)this + 44))
      abort();
  }
  else if (*((_BYTE *)this + 44))
  {
    return;
  }
  v2 = 0;
  for (i = 0; i != 5; ++i)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 10);
    v4 = (const __CFArray *)*((_QWORD *)this + 7);
    if (!v4)
    {
      *((_BYTE *)this + 45) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)this + 10);
      if (!i)
        return;
      goto LABEL_11;
    }
    *((_QWORD *)this + 7) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 10);
    *((_BYTE *)this + 44) = 1;
    v5.length = CFArrayGetCount(v4);
    v5.location = 0;
    CFArrayApplyFunction(v4, v5, (CFArrayApplierFunction)RunloopBlockContext::_invoke_block, this);
    *((_BYTE *)this + 44) = 0;
    CFRelease(v4);
    v2 = i > 3;
  }
  v2 = 1;
  os_unfair_lock_lock((os_unfair_lock_t)this + 10);
  if (!*((_QWORD *)this + 7))
  {
    *((_BYTE *)this + 45) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 10);
    goto LABEL_16;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 10);
  RunLoopMultiplexer::signal(gMuxer, *((const void **)this + 6), (char *)this + 32);
LABEL_11:
  if (v2)
    return;
LABEL_16:
  (*(void (**)(RunloopBlockContext *))(*(_QWORD *)this + 48))(this);
}

void RunloopBlockContext::~RunloopBlockContext(RunloopBlockContext *this)
{
  uint64_t v2;

  RunloopBlockContext::~RunloopBlockContext(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14EA5A8;
  *((_QWORD *)this + 3) = &unk_1E14EA608;
  *((_QWORD *)this + 4) = &unk_1E14EA628;
  RunLoopMultiplexer::unschedule(gMuxer, *((const void **)this + 6), (char *)this + 32);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 6) + 48))(*((_QWORD *)this + 6));
  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
  {
    *((_QWORD *)this + 7) = 0;
    CFRelease(v2);
  }
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

void sub_183F6C1A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void RunLoopSchedulingSet::~RunLoopSchedulingSet(RunLoopSchedulingSet *this)
{
  uint64_t v2;

  RunLoopSchedulingSet::~RunLoopSchedulingSet(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;
  const void *v3;
  const void *v4;

  *(_QWORD *)this = off_1E14EBA58;
  *((_QWORD *)this + 3) = &unk_1E14EBAE0;
  v2 = *((_QWORD *)this + 13);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 13) = 0;
  }
  if (*((_DWORD *)this + 10) == 2)
  {
    v3 = (const void *)*((_QWORD *)this + 6);
    if (!v3)
      goto LABEL_10;
    goto LABEL_9;
  }
  v4 = (const void *)*((_QWORD *)this + 9);
  if (v4)
    CFRelease(v4);
  v3 = (const void *)*((_QWORD *)this + 10);
  if (v3)
LABEL_9:
    CFRelease(v3);
LABEL_10:
  *(_QWORD *)this = off_1E14E8500;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

void sub_183F6C274(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)v1 = off_1E14E8500;
  *(_DWORD *)(v1 + 40) = 0;
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void RunLoopMultiplexer::unschedule(uint64_t a1, const void *a2, const void *a3)
{
  os_unfair_lock_s *v6;
  os_unfair_lock_s *Value;
  os_unfair_lock_s *v8;
  os_unfair_lock_s *v9;
  const __CFArray *v10;
  CFIndex FirstIndexOfValue;
  __CFRunLoopSource *v12;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  CFRange v16;

  v6 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
  Value = (os_unfair_lock_s *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    v8 = Value;
    v9 = Value + 2;
    os_unfair_lock_lock(Value + 2);
    CFSetRemoveValue(*(CFMutableSetRef *)&v8[20]._os_unfair_lock_opaque, a3);
    if (CFSetContainsValue(*(CFSetRef *)&v8[16]._os_unfair_lock_opaque, a3))
    {
      CFSetRemoveValue(*(CFMutableSetRef *)&v8[16]._os_unfair_lock_opaque, a3);
      v10 = *(const __CFArray **)&v8[18]._os_unfair_lock_opaque;
      v16.length = CFArrayGetCount(v10);
      v16.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v10, v16, a3);
      if (FirstIndexOfValue != -1)
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)&v8[18]._os_unfair_lock_opaque, FirstIndexOfValue);
    }
    if (CFSetGetCount(*(CFSetRef *)&v8[20]._os_unfair_lock_opaque))
    {
      os_unfair_lock_unlock(v9);
    }
    else
    {
      v12 = *(__CFRunLoopSource **)&v8[14]._os_unfair_lock_opaque;
      if (v12)
        CFRunLoopSourceInvalidate(v12);
      v13 = *(_QWORD *)&v8[8]._os_unfair_lock_opaque;
      if (v13)
      {
        BYTE1(v8[6]._os_unfair_lock_opaque) = 1;
      }
      else
      {
        LOBYTE(v8[6]._os_unfair_lock_opaque) = 1;
        v14 = *(const void **)&v8[14]._os_unfair_lock_opaque;
        if (v14)
        {
          CFRelease(v14);
          *(_QWORD *)&v8[14]._os_unfair_lock_opaque = 0;
        }
      }
      os_unfair_lock_unlock(v9);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), a2);
      if (!v13)
      {
        v15 = *(_QWORD *)&v8[12]._os_unfair_lock_opaque;
        *(_QWORD *)&v8[12]._os_unfair_lock_opaque = v15 - 1;
        if (v15 <= 1)
          (*(void (**)(os_unfair_lock_s *))(*(_QWORD *)&v8->_os_unfair_lock_opaque + 8))(v8);
      }
    }
  }
  os_unfair_lock_unlock(v6);
}

uint64_t __destroy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE56c52_ZTSNSt3__110shared_ptrI24HTTPConnectionCacheEntryEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 40;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

_QWORD *__copy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE56c52_ZTSNSt3__110shared_ptrI24HTTPConnectionCacheEntryEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void HTTPResponseMessage::~HTTPResponseMessage(HTTPResponseMessage *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  void *v5;

  *(_QWORD *)this = &off_1E14E9F38;
  *((_QWORD *)this + 1) = &unk_1E14E9FA8;
  *((_QWORD *)this + 2) = &unk_1E14E9FC8;
  v2 = (const void *)*((_QWORD *)this + 17);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 18);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 19);
  if (v4)
    CFRelease(v4);
  v5 = (void *)*((_QWORD *)this + 36);
  if (v5)
    free(v5);
  HTTPMessage::~HTTPMessage(this);
}

void sub_183F6C4DC(_Unwind_Exception *a1)
{
  HTTPMessage *v1;

  HTTPMessage::~HTTPMessage(v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __destroy_helper_block_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t __copy_helper_block_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t RetainableTypedArray<Tube *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2, a3);
}

void ___ZN14HTTPConnection22_onqueue_requestFinishE13CFStreamError_block_invoke(uint64_t a1)
{
  uint64_t v1;
  int v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  int v7;
  int v8;
  HTTPEngine *v9;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(unsigned __int16 *)(v1 + 32);
  v3 = v2 & 0xFFFFEFFF | (*(unsigned __int8 *)(v1 + 34) << 16);
  *(_WORD *)(v1 + 32) = v2 & 0xEFFF;
  *(_BYTE *)(v1 + 34) = BYTE2(v3);
  v4 = *(_QWORD *)(v1 + 144);
  v5 = v2 & 0x800;
  if (v4)
    v6 = 1;
  else
    v6 = v5 == 0;
  if (v6)
  {
    if (*(_QWORD *)(a1 + 56) == v4)
    {
      HTTPConnection::_onqueue_advanceCurrentRequest(*(HTTPConnection **)(a1 + 40));
      v7 = *(unsigned __int16 *)(v1 + 32);
      v8 = v7 | (*(unsigned __int8 *)(v1 + 34) << 16);
      if ((v7 & 0x4000) != 0)
      {
        *(_WORD *)(v1 + 32) = v7 & 0xBFFF;
        *(_BYTE *)(v1 + 34) = (v8 & 0xFFFFBFFF) >> 16;
        if ((v8 & 0x40) != 0 && (v8 & 0x100) == 0)
        {
          v9 = *(HTTPEngine **)(v1 + 64);
          if (v9)
          {
            *(_BYTE *)(v1 + 34) = (v8 & 0xFFFFBFFF) >> 16;
            *(_WORD *)(v1 + 32) = v7 & 0xBEFF | 0x100;
            HTTPEngine::_cleanupConnection(v9, 0);
          }
        }
        HTTPConnection::_onqueue_advanceCurrentResponse((HTTPConnection *)v1);
      }
    }
    if (*(_QWORD *)(v1 + 144))
    {
      if (*(_QWORD *)(v1 + 64))
        HTTPConnection::_onqueue_attemptNextRequest((HTTPConnection *)v1);
    }
  }
}

void HTTPConnection::_onqueue_advanceCurrentRequest(HTTPConnection *this)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *TransactionItr;
  uint64_t v5;
  void *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v10;

  v2 = (_QWORD *)((char *)this + 144);
  v1 = *((_QWORD *)this + 18);
  if (v1)
  {
    TransactionItr = HTTPConnection::_onqueue_getTransactionItr(*((_QWORD **)this + 15), *((_QWORD **)this + 16), v1);
    if (TransactionItr + 2 == *((_QWORD **)this + 16))
    {
      v10 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v10);
      v7 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
      if (*((_QWORD *)&v10 + 1))
      {
        v8 = (unint64_t *)(*((_QWORD *)&v10 + 1) + 8);
        do
          v9 = __ldaxr(v8);
        while (__stlxr(v9 - 1, v8));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
    else
    {
      std::shared_ptr<__CFString const>::operator=[abi:nn180100](v2, TransactionItr[2], TransactionItr[3]);
      v5 = *((_QWORD *)this + 8);
      v6 = (void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 18) + 40))(*((_QWORD *)this + 18));

      *(_QWORD *)(v5 + 336) = v6;
    }
  }
}

void HTTPConnection::_onqueue_advanceCurrentResponse(HTTPConnection *this)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *TransactionItr;
  uint64_t v5;
  void *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v10;

  v2 = (_QWORD *)((char *)this + 160);
  v1 = *((_QWORD *)this + 20);
  if (v1)
  {
    TransactionItr = HTTPConnection::_onqueue_getTransactionItr(*((_QWORD **)this + 15), *((_QWORD **)this + 16), v1);
    if (TransactionItr + 2 == *((_QWORD **)this + 16))
    {
      v10 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v10);
      v7 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
      if (*((_QWORD *)&v10 + 1))
      {
        v8 = (unint64_t *)(*((_QWORD *)&v10 + 1) + 8);
        do
          v9 = __ldaxr(v8);
        while (__stlxr(v9 - 1, v8));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
    else
    {
      std::shared_ptr<__CFString const>::operator=[abi:nn180100](v2, TransactionItr[2], TransactionItr[3]);
      v5 = *((_QWORD *)this + 8);
      v6 = (void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 20) + 40))(*((_QWORD *)this + 20));

      *(_QWORD *)(v5 + 328) = v6;
    }
  }
}

_QWORD *HTTPConnection::_onqueue_getTransactionItr(_QWORD *result, _QWORD *a2, uint64_t a3)
{
  if (result != a2)
  {
    while (*result != a3)
    {
      result += 2;
      if (result == a2)
      {
        result = a2;
        break;
      }
    }
  }
  if (result == a2)
    __assert_rtn("_onqueue_getTransactionItr", "HTTPConnection.cpp", 2177, "found != _transactions.end()");
  return result;
}

void sub_183F6C8E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

CFTypeRef ___ZN9HSTSCache22copyHSTSInfoDictionaryEPK10__CFString_block_invoke(uint64_t a1)
{
  CFTypeRef result;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 40) + 56), *(const void **)(a1 + 48));
  result = *(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t __copy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __copy_helper_block_e8_40c45_ZTSNSt3__110shared_ptrI17RequestBodyStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __copy_helper_block_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c45_ZTSNSt3__110shared_ptrI17RequestBodyStreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t __destroy_helper_block_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t __destroy_helper_block_e8_40c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t __copy_helper_block_e8_40c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_4(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

uint64_t __copy_helper_block_e8_40c52_ZTSNSt3__110shared_ptrI24ConnectionReadAggregatorEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c52_ZTSNSt3__110shared_ptrI24ConnectionReadAggregatorEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t ___ZNK23CoreSchedulingSetOneOff29performAsyncWithTrailingBlockEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void RunloopBlockContext::_invoke_block(void (**this)(RunloopBlockContext *), const void *a2, void *a3)
{
  void *v4;

  v4 = (void *)MEMORY[0x186DB8C8C](this, a2, a3);
  this[2]((RunloopBlockContext *)this);
  objc_autoreleasePoolPop(v4);
}

CFArrayRef CFHTTPCookieCopyPortArray(OpaqueCFHTTPCookie *a1)
{
  const __CFAllocator *v2;
  __CFArray *Mutable;
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  const __CFAllocator *v13;
  const __CFAllocator *v14;
  CFArrayRef Copy;
  void (**v17)(AutoScalar *__hidden);
  void *value;

  v2 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
  v4 = -[OpaqueCFHTTPCookie _inner](a1, "_inner");
  v5 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  if (*v5 >= 0x10u)
  {
    v6 = v5[3];
    if ((_DWORD)v6)
    {
      v7 = 0;
      v8 = 2 * v6;
      do
      {
        v9 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
        v10 = (v7 + 56);
        v11 = *v9;
        if (v11 <= v10 || (char *)v9 + v10 + 2 > (char *)v9 + v11)
          v13 = 0;
        else
          v13 = (const __CFAllocator *)*(unsigned __int16 *)((char *)v9 + v10);
        AutoScalar::AutoScalar((AutoScalar *)&v17, v13);
        if (value)
        {
          CFArrayAppendValue(Mutable, value);
          v17 = &off_1E14E47E8;
          if (value)
            CFRelease(value);
        }
        else
        {
          v17 = &off_1E14E47E8;
        }
        v7 += 2;
      }
      while (v8 != v7);
    }
  }
  v14 = CFGetAllocator(Mutable);
  Copy = CFArrayCreateCopy(v14, Mutable);
  if (Mutable)
    CFRelease(Mutable);
  return Copy;
}

void sub_183F6CC70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  const void *v10;

  if (v10)
    CFRelease(v10);
  _Unwind_Resume(exception_object);
}

void TransportConnection::RefCountedWrapper::~RefCountedWrapper(TransportConnection::RefCountedWrapper *this)
{
  *(_QWORD *)this = &off_1E14EFFD0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &off_1E14EFFD0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

uint64_t cf_nghttp2_data_source_read_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  _QWORD *stream_user_data;
  std::__shared_weak_count *v9;
  _QWORD *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int64_t size;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  _QWORD applier[5];
  char v36;
  _BYTE buf[18];
  __int16 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  stream_user_data = (_QWORD *)nghttp2_session_get_stream_user_data();
  if (!stream_user_data)
    return -521;
  v10 = (_QWORD *)*stream_user_data;
  v9 = (std::__shared_weak_count *)stream_user_data[1];
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v13 = v10[4];
  if (!v13 || !*(_DWORD *)(v13 + 40))
    goto LABEL_18;
  v14 = v10[33];
  if (v14 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 72))(v14) & 1) == 0)
  {
    v16 = v10[33];
    if (v16 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v16 + 80))(v16))
    {
      v17 = v10[33];
      if (!v17)
      {
        size = 0;
        goto LABEL_19;
      }
      v36 = 0;
      v18 = (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(_QWORD *)v17 + 88))(v17, a4, &v36);
      v19 = v18;
      if (v18)
      {
        size = dispatch_data_get_size(v18);
        if (size >= 1)
        {
          applier[0] = MEMORY[0x1E0C809B0];
          applier[1] = 3221225472;
          applier[2] = ___ZN11HTTP2Stream15provideBodyDataEPhmPj_block_invoke;
          applier[3] = &__block_descriptor_40_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
          applier[4] = a3;
          dispatch_data_apply(v19, applier);
          -[__CFN_TransactionMetrics requestBody:](v10[38], v19);
        }
        dispatch_release(v19);
      }
      else
      {
        size = 0;
      }
      if (!v36)
        goto LABEL_19;
      *a5 |= 1u;
      v23 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v10[33] + 56))(v10[33]);
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v24 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v25 = v10[27];
        if (v23 < 0)
          v26 = 83;
        else
          v26 = 68;
        v27 = v10[33];
        if (v27)
          v27 = *(_QWORD *)(v27 + 96);
        *(_DWORD *)buf = 138543874;
        *(_QWORD *)&buf[4] = v25;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v26;
        v38 = 2048;
        v39 = v27;
        _os_log_impl(&dword_183ECA000, v24, OS_LOG_TYPE_DEFAULT, "%{public}@ sent request, body %c %lld", buf, 0x1Cu);
      }
      v28 = v10[8];
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      v29 = (std::__shared_weak_count *)v10[36];
      if (v29)
      {
        v30 = std::__shared_weak_count::lock(v29);
        *(_QWORD *)&buf[8] = v30;
        if (v30)
        {
          v31 = v10[35];
          *(_QWORD *)buf = v31;
          goto LABEL_42;
        }
      }
      else
      {
        v30 = 0;
      }
      v31 = 0;
LABEL_42:
      HTTP2Connection::streamEnteredStallableState(v28, v31, v30);
      if (v30)
      {
        v32 = (unint64_t *)&v30->__shared_owners_;
        do
          v33 = __ldaxr(v32);
        while (__stlxr(v33 - 1, v32));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
      v34 = v10[38];
      if (v34)
        *(CFAbsoluteTime *)(v34 + 184) = CFAbsoluteTimeGetCurrent();
      goto LABEL_19;
    }
LABEL_18:
    size = -508;
    goto LABEL_19;
  }
  size = -521;
LABEL_19:
  if (v9)
  {
    v20 = (unint64_t *)&v9->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return size;
}

void sub_183F6D02C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL RequestBodyStream::errorEncountered(RequestBodyStream *this)
{
  int v1;

  v1 = *((_DWORD *)this + 44);
  if (v1)
    RequestBody::_onqueue_updateUploadStatus((RequestBody *)this, 0, 1);
  return v1 != 0;
}

BOOL RequestBodyStream::canProvideData(RequestBodyStream *this)
{
  return *((_QWORD *)this + 20) || *((_BYTE *)this + 184) != 0;
}

uint64_t ___ZN11HTTP2Stream15provideBodyDataEPhmPj_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  memcpy((void *)(*(_QWORD *)(a1 + 32) + a3), __src, __n);
  return 1;
}

NSObject *RequestBodyStream::provideData(RequestBodyStream *this, size_t a2, BOOL *a3)
{
  NSObject *v5;
  size_t size;
  size_t v8;
  dispatch_data_t subrange;
  _BOOL4 v10;

  v5 = *((_QWORD *)this + 20);
  if (v5)
  {
    size = dispatch_data_get_size(*((dispatch_data_t *)this + 20));
    v8 = size - a2;
    if (size <= a2)
    {
      *((_QWORD *)this + 20) = 0;
      a2 = size;
    }
    else
    {
      subrange = dispatch_data_create_subrange(v5, 0, a2);
      *((_QWORD *)this + 20) = dispatch_data_create_subrange(v5, a2, v8);
      dispatch_release(v5);
      v5 = subrange;
    }
  }
  else
  {
    a2 = 0;
  }
  if (*((_BYTE *)this + 184))
    v10 = *((_QWORD *)this + 20) == 0;
  else
    v10 = 0;
  *a3 = v10;
  RequestBody::_onqueue_updateUploadStatus((RequestBody *)this, a2, v10);
  if (!*((_BYTE *)this + 184))
    RequestBodyStream::_onqueue_resume(this);
  return v5;
}

void ___ZN11HTTP2Stream14didSendHeadersEv_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint8_t buf[4];
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = (_QWORD *)a1[4];
  v2 = a1[5];
  if (*(_DWORD *)(v2 + 56) != 1)
    *(_DWORD *)(v2 + 56) = 1;
  if (!v3[33])
  {
    v4 = v3[38];
    if (v4)
      *(CFAbsoluteTime *)(v4 + 184) = CFAbsoluteTimeGetCurrent();
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v6 = v3[27];
      *(_DWORD *)buf = 138543362;
      v15 = v6;
      _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@ sent request, body N 0", buf, 0xCu);
    }
    v7 = v3[8];
    v8 = a1[5];
    v9 = (std::__shared_weak_count *)a1[6];
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    HTTP2Connection::streamEnteredStallableState(v7, v8, v9);
    if (v9)
    {
      v12 = (unint64_t *)&v9->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
}

void sub_183F6D308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTP2Connection::streamEnteredStallableState(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  _QWORD *v3;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8[2];

  if (a2)
  {
    v3 = *(_QWORD **)(a1 + 648);
    if (v3)
    {
      v8[0] = a2;
      v8[1] = (uint64_t)a3;
      if (a3)
      {
        p_shared_owners = (unint64_t *)&a3->__shared_owners_;
        do
          v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
        HTTPStallTimer::add(v3, v8);
        do
          v7 = __ldaxr(p_shared_owners);
        while (__stlxr(v7 - 1, p_shared_owners));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
          std::__shared_weak_count::__release_weak(a3);
        }
      }
      else
      {
        HTTPStallTimer::add(v3, v8);
      }
    }
  }
}

void HTTPStallTimer::add(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_weak_owners;
  unint64_t v5;
  NSObject *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[5];
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v2 = a1[1];
  v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v5 = __ldxr(p_shared_weak_owners);
    while (__stxr(v5 + 1, p_shared_weak_owners));
  }
  v6 = a1[3];
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3321888768;
  v15[2] = ___ZN14HTTPStallTimer3addENSt3__110shared_ptrIvEE_block_invoke;
  v15[3] = &__block_descriptor_64_e8_32c39_ZTSNSt3__18weak_ptrI14HTTPStallTimerEE48c27_ZTSNSt3__110shared_ptrIvEE_e5_v8__0l;
  v15[4] = v2;
  v16 = v3;
  if (v3)
  {
    v7 = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = (std::__shared_weak_count *)a2[1];
  v17 = *a2;
  v18 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  dispatch_async(v6, v15);
  v12 = v18;
  if (v18)
  {
    v13 = (unint64_t *)&v18->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

uint64_t _HostLookup_Master_dispatch_GetAddrInfoCallBack(int a1, addrinfo *a2, void *a3)
{
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  uint64_t v8;
  __CFArray *Mutable;
  addrinfo *v10;
  sockaddr *ai_addr;
  int sa_family;
  CFDataRef v14;
  CFErrorRef v15;
  CFErrorRef CFErrorWithStreamError;
  uint64_t v18;
  int v19;

  v6 = CFGetAllocator((CFTypeRef)(*((_QWORD *)a3 + 1) - 16));
  v7 = v6;
  if (a1)
  {
    if (a1 == 11)
    {
      a1 = *__error();
      v8 = 1;
    }
    else
    {
      v8 = 12;
    }
    v18 = v8;
    v19 = a1;
    CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v7, (int *)&v18);
    DispatchHost::performCallback(*((DispatchHost **)a3 + 1), *((const __CFString **)a3 + 2), CFErrorWithStreamError);
    if (!CFErrorWithStreamError)
      goto LABEL_19;
    v15 = CFErrorWithStreamError;
  }
  else
  {
    Mutable = CFArrayCreateMutable(v6, 0, MEMORY[0x1E0C9B378]);
    if (a2)
    {
      v10 = a2;
      do
      {
        ai_addr = v10->ai_addr;
        sa_family = ai_addr->sa_family;
        if (sa_family == 30 || sa_family == 2)
        {
          v14 = CFDataCreate(v7, &ai_addr->sa_len, ai_addr->sa_len);
          CFArrayAppendValue(Mutable, v14);
          if (v14)
            CFRelease(v14);
        }
        v10 = v10->ai_next;
      }
      while (v10);
    }
    DispatchHost::performCallback(*((DispatchHost **)a3 + 1), *((const __CFString **)a3 + 2), Mutable);
    v15 = Mutable;
  }
  CFRelease(v15);
LABEL_19:
  if (a2)
    freeaddrinfo(a2);
  return (*(uint64_t (**)(void *))(*(_QWORD *)a3 + 8))(a3);
}

void sub_183F6D89C(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void DispatchHost::HostAndInfoTypeHelper::~HostAndInfoTypeHelper(DispatchHost::HostAndInfoTypeHelper *this)
{
  DispatchHost::HostAndInfoTypeHelper::~HostAndInfoTypeHelper(this);
  JUMPOUT(0x186DB748CLL);
}

{
  const void *v2;

  *(_QWORD *)this = &off_1E14EFF10;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)this = &off_1E14EFEF0;
  CFRelease((CFTypeRef)(*((_QWORD *)this + 1) - 16));
}

void sub_183F6D928(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14EFEF0;
  CFRelease((CFTypeRef)(v1[1] - 16));
  _Unwind_Resume(a1);
}

void DispatchHost::performCallback(DispatchHost *this, const __CFString *a2, const void *a3)
{
  char *v6;
  CFMutableDictionaryRef *v7;
  const __CFString *v8;
  const void *v9;
  __CFArray *Mutable;
  const __CFAllocator *v11;

  v6 = (char *)this - 16;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  if (a3)
  {
    v7 = (CFMutableDictionaryRef *)this;
    v8 = a2;
    v9 = a3;
  }
  else
  {
    v9 = (const void *)*MEMORY[0x1E0C9AE40];
    v7 = (CFMutableDictionaryRef *)this;
    v8 = a2;
  }
  HostBase::setInfoLocked(v7, v8, v9);
  dispatch_group_leave(*((dispatch_group_t *)this + 19));
  if (*((_QWORD *)this + 13))
  {
    Mutable = (__CFArray *)*((_QWORD *)this + 20);
    if (!Mutable)
    {
      v11 = CFGetAllocator(v6);
      Mutable = CFArrayCreateMutable(v11, 0, MEMORY[0x1E0C9B378]);
      *((_QWORD *)this + 20) = Mutable;
      if (Mutable)
      {
        CFRetain(v6);
        Mutable = (__CFArray *)*((_QWORD *)this + 20);
      }
    }
    CFArrayAppendValue(Mutable, a2);
    if (*((_QWORD *)this + 21))
      DispatchHost::signalKickerLocked(this);
  }
  HostBase::unlock(this);
}

__CFArray *HTTPCookieStorage::copyCookiesMatching(HTTPCookieStorage *this, const __CFDictionary *a2, uint64_t a3, const __CFArray *a4)
{
  char *v8;
  const __CFAllocator *v9;
  char *v10;
  CFAllocatorRef v11;
  CFTypeID *v12;
  uint64_t v13;
  const void *Value;
  unint64_t Count;
  CFRange v16;
  const void **v17;
  CFTypeID TypeID;
  CFTypeID v19;
  CFIndex v20;
  CFTypeID v21;
  NSObject *v22;
  const __CFString *v23;
  BOOL v24;
  CFIndex v25;
  const __CFString *ValueAtIndex;
  int CanonicalString;
  int *v28;
  uint64_t v29;
  const __CFAllocator *v30;
  __CFArray *Mutable;
  _QWORD *v32;
  NSObject *v33;
  uint64_t v34;
  CFContainerEnumeratorBase *v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t i;
  uint64_t v39;
  const __CFData *v40;
  const UInt8 *BytePtr;
  int v42;
  const __CFAllocator *v43;
  CFIndex v44;
  __CFArray *v45;
  unint64_t v46;
  CFRange v47;
  const void **v48;
  CFIndex v49;
  uint64_t v50;
  const __CFData *v51;
  const UInt8 *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  id v56;
  const void *v58;
  HTTPCookieStorage *v59;
  CFTypeRef v60;
  CFIndex range;
  intptr_t (*v62)(uint64_t, const void **);
  _QWORD v63[31];
  CFIndex v64;
  uint8_t buf[8];
  uint8_t *v66;
  uint64_t v67;
  uint64_t v68;
  CFRange v69;

  v8 = (char *)this - 16;
  v9 = CFGetAllocator((char *)this - 16);
  v10 = (char *)CFAllocatorAllocate(v9, 992, 0);
  bzero(v10, 0x3E0uLL);
  v11 = CFGetAllocator(v8);
  *(_QWORD *)v10 = off_1E14EF578;
  *((_QWORD *)v10 + 1) = v11;
  *((_DWORD *)v10 + 4) = 1;
  if (((unint64_t)(v10 + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)v10 = off_1E14E57B0;
  bzero(v10 + 40, 0x2F8uLL);
  v59 = this;
  if (a2)
  {
    *((_QWORD *)v10 + 3) = CFRetain(a2);
    v12 = (CFTypeID *)(v10 + 48);
    v13 = 1u;
    do
    {
      Value = CFDictionaryGetValue(*((CFDictionaryRef *)v10 + 3), &gConstantCFStringValueTable[7 * ((CookieData::sCookieFieldInfo[v13] >> 20) & 0x3FF)]);
      *(v12 - 1) = (CFTypeID)Value;
      if (Value)
        *v12 = CFGetTypeID(Value);
      v13 += 5;
      v12 += 5;
    }
    while (v13 != 96);
  }
  else
  {
    *((_QWORD *)v10 + 3) = 0;
  }
  *((_QWORD *)v10 + 100) = a3;
  if (!a4)
  {
    *((_QWORD *)v10 + 4) = 0;
    *((_QWORD *)v10 + 101) = 0;
    v60 = 0;
    range = 0;
    v62 = (intptr_t (*)(uint64_t, const void **))v63;
    goto LABEL_18;
  }
  *((_QWORD *)v10 + 4) = CFRetain(a4);
  *((_QWORD *)v10 + 101) = 0;
  v60 = CFRetain(a4);
  Count = CFArrayGetCount(a4);
  v16.length = Count;
  range = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v62 = 0;
    goto LABEL_18;
  }
  if (Count > 0x1E)
  {
    v17 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v62 = (intptr_t (*)(uint64_t, const void **))v17;
    if (!v17)
      goto LABEL_18;
    v16.length = range;
  }
  else
  {
    v17 = (const void **)v63;
    v62 = (intptr_t (*)(uint64_t, const void **))v63;
  }
  v16.location = 0;
  CFArrayGetValues(a4, v16, v17);
LABEL_18:
  v64 = 0;
  TypeID = CFStringGetTypeID();
  v19 = CFArrayGetTypeID();
  v20 = v64;
  if (v64 < range)
  {
    v21 = v19;
    v58 = (const void *)*MEMORY[0x1E0C9AE50];
    v22 = MEMORY[0x1E0C81028];
    do
    {
      v64 = v20 + 1;
      v23 = (const __CFString *)*((_QWORD *)v62 + v20);
      if (CFGetTypeID(v23) == TypeID)
      {
        v24 = 1;
        if (!v23)
          goto LABEL_75;
      }
      else
      {
        if (CFGetTypeID(v23) != v21)
          goto LABEL_75;
        v25 = CFArrayGetCount((CFArrayRef)v23);
        if (v25 < 1)
          goto LABEL_75;
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v23, 0);
        v24 = (unint64_t)v25 < 2 || CFArrayGetValueAtIndex((CFArrayRef)v23, 1) == v58;
        v23 = ValueAtIndex;
        if (!ValueAtIndex)
          goto LABEL_75;
      }
      CanonicalString = _findCanonicalString(v23, 3u);
      if (CanonicalString > 268472870)
      {
        if (CanonicalString <= 272699956)
        {
          if (CanonicalString > 270570030)
          {
            if (CanonicalString == 270570031)
            {
              v28 = (int *)&unk_18411E2C4;
LABEL_71:
              if (v28[1] != CanonicalString && os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_fault_impl(&dword_183ECA000, v22, OS_LOG_TYPE_FAULT, "string constant mismatch", buf, 2u);
              }
              v29 = *((_QWORD *)v10 + 101);
              *(_QWORD *)&v10[8 * v29 + 816] = v28;
              *((_QWORD *)v10 + 101) = v29 + 1;
              v10[v29 + 968] = v24;
              goto LABEL_75;
            }
            if (CanonicalString == 271618610)
            {
              v28 = (int *)&unk_18411E2D8;
              goto LABEL_71;
            }
          }
          else
          {
            if (CanonicalString == 268472871)
            {
              v28 = (int *)&unk_18411E29C;
              goto LABEL_71;
            }
            if (CanonicalString == 269562410)
            {
              v28 = (int *)&unk_18411E2B0;
              goto LABEL_71;
            }
          }
        }
        else if (CanonicalString <= 275911237)
        {
          if (CanonicalString == 272699957)
          {
            v28 = (int *)&unk_18411E33C;
            goto LABEL_71;
          }
          if (CanonicalString == 273732154)
          {
            v28 = (int *)&unk_18411E2EC;
            goto LABEL_71;
          }
        }
        else
        {
          switch(CanonicalString)
          {
            case 275911238:
              v28 = (int *)&unk_18411E328;
              goto LABEL_71;
            case 276869711:
              v28 = (int *)&unk_18411E300;
              goto LABEL_71;
            case 277934674:
              v28 = (int *)&unk_18411E314;
              goto LABEL_71;
          }
        }
      }
      else if (CanonicalString <= 263246352)
      {
        if (CanonicalString > 261157384)
        {
          if (CanonicalString == 261157385)
          {
            v28 = (int *)&unk_18411E224;
            goto LABEL_71;
          }
          if (CanonicalString == 262205965)
          {
            v28 = (int *)&unk_18411E238;
            goto LABEL_71;
          }
        }
        else
        {
          v28 = CookieData::sCookieFieldInfo;
          if (CanonicalString == 259060223)
            goto LABEL_71;
          if (CanonicalString == 260133379)
          {
            v28 = (int *)&unk_18411E210;
            goto LABEL_71;
          }
        }
      }
      else if (CanonicalString <= 265368088)
      {
        if (CanonicalString == 263246353)
        {
          v28 = (int *)&unk_18411E24C;
          goto LABEL_71;
        }
        if (CanonicalString == 264303125)
        {
          v28 = (int *)&unk_18411E260;
          goto LABEL_71;
        }
      }
      else
      {
        switch(CanonicalString)
        {
          case 265368089:
            v28 = (int *)&unk_18411E350;
            goto LABEL_71;
          case 266408478:
            v28 = (int *)&unk_18411E274;
            goto LABEL_71;
          case 267448867:
            v28 = (int *)&unk_18411E288;
            goto LABEL_71;
        }
      }
LABEL_75:
      v20 = v64;
    }
    while (v64 < range);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v60);
  v30 = CFGetAllocator(v8);
  Mutable = CFArrayCreateMutable(v30, 0, MEMORY[0x1E0C9B378]);
  v32 = (_QWORD *)*((_QWORD *)v59 + 2);
  *(_QWORD *)buf = 0;
  v66 = buf;
  v67 = 0x2020000000;
  v68 = 0;
  v33 = dispatch_semaphore_create(0);
  v60 = (CFTypeRef)MEMORY[0x1E0C809B0];
  range = 3221225472;
  v62 = ___ZN24PrivateHTTPCookieStorage24newCookieArrayEnumeratorEP12CookieSifter_block_invoke;
  v63[0] = &unk_1E14FB2F8;
  v63[1] = v33;
  v63[2] = buf;
  v34 = v32[4];
  if (v34)
    pthread_mutex_lock((pthread_mutex_t *)(v34 + 8));
  (*(void (**)(_QWORD *, char *, CFTypeRef *))(*v32 + 104))(v32, v10, &v60);
  if (v34)
    pthread_mutex_unlock((pthread_mutex_t *)(v34 + 8));
  dispatch_semaphore_wait(v33, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v33);
  v35 = (CFContainerEnumeratorBase *)*((_QWORD *)v66 + 3);
  _Block_object_dispose(buf, 8);
  if (v35)
  {
    v36 = *((_QWORD *)v35 + 1);
    if (v36 < 1)
    {
      v37 = 0;
    }
    else
    {
      v37 = 0;
      for (i = 0; i != v36; ++i)
      {
        v39 = *(_QWORD *)(*((_QWORD *)v35 + 2) + 8 * i);
        if (v39)
        {
          if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
            dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
          v39 += 16;
        }
        v40 = *(const __CFData **)(v39 + 16);
        if (v40 && (BytePtr = CFDataGetBytePtr(v40)) != 0)
          v42 = *((_DWORD *)BytePtr + 1);
        else
          v42 = 0;
        CFArrayAppendValue(Mutable, (const void *)(v39 - 16));
        v37 += v42;
      }
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v35);
    MEMORY[0x186DB748C]();
  }
  else
  {
    v37 = 0;
  }
  v43 = CFGetAllocator(v8);
  v44 = v37;
  v45 = CFArrayCreateMutable(v43, v37, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v60 = 0;
    range = 0;
    v62 = (intptr_t (*)(uint64_t, const void **))v63;
    goto LABEL_105;
  }
  v60 = CFRetain(Mutable);
  v46 = CFArrayGetCount(Mutable);
  v47.length = v46;
  range = v46;
  if (v46 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v62 = 0;
    goto LABEL_105;
  }
  if (v46 > 0x1E)
  {
    v48 = (const void **)malloc_type_malloc(8 * v46, 0x89ED541CuLL);
    v62 = (intptr_t (*)(uint64_t, const void **))v48;
    if (!v48)
      goto LABEL_105;
    v47.length = range;
  }
  else
  {
    v48 = (const void **)v63;
    v62 = (intptr_t (*)(uint64_t, const void **))v63;
  }
  v47.location = 0;
  CFArrayGetValues(Mutable, v47, v48);
LABEL_105:
  v64 = 0;
  if (range >= 1)
  {
    v49 = 0;
    do
    {
      v64 = v49 + 1;
      v50 = *((_QWORD *)v62 + v49);
      if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
        dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
      v51 = *(const __CFData **)(v50 + 32);
      if (v51)
      {
        v52 = CFDataGetBytePtr(v51);
        if (v52)
        {
          v53 = *((unsigned int *)v52 + 1);
          if ((_DWORD)v53)
          {
            v54 = 0;
            v55 = v50 + 16;
            do
            {
              v56 = -[NSHTTPCookie _initWithReference:index:]([NSHTTPCookie alloc], "_initWithReference:index:", v55, v54);
              CFArrayAppendValue(v45, v56);

              ++v54;
            }
            while (v53 != v54);
          }
        }
      }
      v49 = v64;
    }
    while (v64 < range);
  }
  if (*((uint64_t *)v10 + 101) >= 1)
  {
    v69.location = 0;
    v69.length = v44;
    CFArraySortValues(v45, v69, (CFComparatorFunction)_cmp_cookie, v10);
  }
  (*(void (**)(char *))(*(_QWORD *)v10 + 48))(v10);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v60);
  CFRelease(Mutable);
  return v45;
}

void sub_183F6E36C(_Unwind_Exception *a1)
{
  const void *v1;
  uint64_t v2;

  _Block_object_dispose((const void *)(v2 - 128), 8);
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t DiskCookieStorage::newCookieArrayEnumeratorLocked(DiskCookieStorage *a1, CookieSifter *a2, uint64_t a3)
{
  MemoryCookies *v6;
  CFContainerEnumeratorBase *v7;

  DiskCookieStorage::rereadFromDiskIfNecessaryLocked(a1);
  v6 = (MemoryCookies *)*((_QWORD *)a1 + 37);
  if (v6)
  {
    v7 = (CFContainerEnumeratorBase *)MemoryCookies::newCookieArrayEnumerator(v6, a2);
    (*(void (**)(uint64_t, CFContainerEnumeratorBase *))(a3 + 16))(a3, v7);
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v7);
    JUMPOUT(0x186DB748CLL);
  }
  return (*(uint64_t (**)(uint64_t, _QWORD))(a3 + 16))(a3, 0);
}

intptr_t ___ZN24PrivateHTTPCookieStorage24newCookieArrayEnumeratorEP12CookieSifter_block_invoke(uint64_t a1, const void **a2)
{
  _QWORD *v4;
  _QWORD *v5;
  const void *v6;
  unint64_t Count;
  CFRange v8;
  const void **v9;

  v4 = (_QWORD *)operator new();
  v5 = v4;
  v6 = *a2;
  if (v6)
  {
    *v4 = CFRetain(v6);
    Count = CFArrayGetCount((CFArrayRef)v6);
    v8.length = Count;
    v5[1] = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v5[2] = 0;
    }
    else
    {
      if (Count <= 0x1E)
      {
        v9 = (const void **)(v5 + 3);
        v5[2] = v5 + 3;
LABEL_9:
        v8.location = 0;
        CFArrayGetValues((CFArrayRef)v6, v8, v9);
        goto LABEL_10;
      }
      v9 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
      v5[2] = v9;
      if (v9)
      {
        v8.length = v5[1];
        goto LABEL_9;
      }
    }
  }
  else
  {
    *v4 = 0;
    v4[1] = 0;
    v4[2] = v4 + 3;
  }
LABEL_10:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v5;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_183F6E57C(_Unwind_Exception *a1)
{
  CFContainerEnumeratorBase *v1;

  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v1);
  MEMORY[0x186DB748C]();
  _Unwind_Resume(a1);
}

void CookieSifter::~CookieSifter(CookieSifter *this)
{
  uint64_t v2;

  CookieSifter::~CookieSifter(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;
  const void *v3;
  uint64_t v4;

  *(_QWORD *)this = off_1E14E57B0;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
    CFRelease(v3);
  v4 = 760;
  do
  {
    CookieSifter::Term::cleanCache((CookieSifter *)((char *)this + v4));
    v4 -= 40;
  }
  while (v4);
}

void sub_183F6E62C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = 760;
  do
  {
    CookieSifter::Term::cleanCache((CookieSifter::Term *)(v1 + v3));
    v3 -= 40;
  }
  while (v3);
  _Unwind_Resume(a1);
}

void CookieSifter::Term::cleanCache(CookieSifter::Term *this)
{
  int v2;
  uint64_t v3;

  v2 = *((_DWORD *)this + 8);
  if (v2 == 3)
  {
    v3 = *((_QWORD *)this + 2);
    if (v3)
      MEMORY[0x186DB748C](v3, 0x1000C40EEF2B9B0);
  }
  else if (v2 == 2)
  {
    free(*((void **)this + 2));
  }
  *((_DWORD *)this + 8) = 0;
}

void ___ZN15HTTP2Connection4stopEb_block_invoke(uint64_t a1)
{
  HTTP2Connection *v1;

  v1 = *(HTTP2Connection **)(a1 + 32);
  HTTP2Connection::_onqueue_closeConnection(v1, 0, *(_BYTE *)(a1 + 40));
  CFRelease((char *)v1 - 16);
}

void HTTP2Connection::_onqueue_closeConnection(HTTP2Connection *this, char a2, uint64_t a3)
{
  const __CFArray *Copy;
  CFIndex v7;
  char *v8;
  const void *ValueAtIndex;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t v14;
  const __CFAllocator *v15;
  CFNumberRef v16;
  HTTPStallTimer *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  BOOL v21;
  int v22;
  char v23;
  uint64_t v24;
  int **v25;
  int v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  __int128 v35;
  void (*v36)(uint64_t);
  void *v37;
  uint64_t v38;
  HTTP2Connection *v39;

  if (*((_DWORD *)this + 44) != 3)
  {
    Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *((CFArrayRef *)this + 29));
    v7 = 0;
    v8 = (char *)this - 16;
    while (v7 < CFArrayGetCount(Copy))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 29), v7);
      v10 = *((_QWORD *)ValueAtIndex + 3);
      v11 = (std::__shared_weak_count *)*((_QWORD *)ValueAtIndex + 4);
      if (v11)
      {
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
        do
          v14 = __ldaxr(p_shared_owners);
        while (__stlxr(v14 - 1, p_shared_owners));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      if (*(_QWORD *)(v10 + 432))
      {
        LODWORD(v35) = *(_DWORD *)(v10 + 80);
        v15 = CFGetAllocator((char *)this - 16);
        v16 = CFNumberCreate(v15, kCFNumberSInt32Type, &v35);
        __NSURLSessionTaskDependency_RemoveRequest(*(void **)(v10 + 432), (uint64_t)v16, *((void **)this + 5), *(_QWORD *)(v10 + 48));
        if (v16)
          CFRelease(v16);
      }
      HTTP2Stream::breakStreamUserDataCycle(v10);
      if (*(_DWORD *)(v10 + 56) != 3)
      {
        if (*((_DWORD *)this + 38))
          HTTP2Stream::setError((HTTP2Stream *)v10, *((CFStreamError *)this + 9));
        HTTP2Stream::closeStreamWithErrorCode((HTTP2Stream *)v10);
      }
      if (*((_QWORD *)this + 20))
        nghttp2_session_set_stream_user_data();
      ++v7;
    }
    CFRelease(Copy);
    if (*((_QWORD *)this + 90))
      HTTP2Connection::stopStallRecovery((dispatch_source_t *)this);
    v17 = (HTTPStallTimer *)*((_QWORD *)this + 81);
    if (v17)
    {
      HTTPStallTimer::invalidate(v17);
      v35 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 648, &v35);
      v18 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
      if (*((_QWORD *)&v35 + 1))
      {
        v19 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
    }
    *((_BYTE *)this + 640) = 1;
    v21 = (a2 & 1) == 0 && *((_DWORD *)this + 44) != 4;
    if (*((_QWORD *)this + 20))
    {
      v22 = nghttp2_session_terminate_session();
      v23 = !v21;
      if (v22)
        v23 = 1;
      if ((v23 & 1) == 0)
        HTTP2Connection::_onqueue_scheduleIO(this);
      nghttp2_session_del();
      *((_QWORD *)this + 20) = 0;
    }
    v25 = (int **)((char *)this + 56);
    v24 = *((_QWORD *)this + 7);
    *((_DWORD *)this + 44) = 3;
    if (v24)
    {
      if (*(_DWORD *)v24 == 1)
      {
        TransportConnection::rstConnectionDelegate(*(TransportConnection **)(v24 + 8));
        v26 = **v25;
        if (v26 != 2)
        {
          if (v26 != 1)
            __assert_rtn("close", "TCPIOConnectionTest.hpp", 276, "false");
          (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)*v25 + 1) + 152))(*((_QWORD *)*v25 + 1), a3);
        }
      }
      else if (*(_DWORD *)v24 != 2)
      {
        __assert_rtn("rstConnectionDelegate", "TCPIOConnectionTest.hpp", 266, "false");
      }
      _Block_release(*((const void **)this + 14));
      _Block_release(*((const void **)this + 15));
      _Block_release(*((const void **)this + 16));
      *((_QWORD *)this + 16) = 0;
      v35 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 56, &v35);
      v27 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
      if (*((_QWORD *)&v35 + 1))
      {
        v28 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }
    v30 = *((_QWORD *)this + 30);
    if (*(_QWORD *)(v30 + 72))
    {
      CFRetain((CFTypeRef)(v30 - 16));
      v31 = *(_QWORD *)(v30 + 72);
      *(_QWORD *)&v35 = MEMORY[0x1E0C809B0];
      *((_QWORD *)&v35 + 1) = 3221225472;
      v36 = ___ZN25HTTP2ConnectionCacheEntry16connectionClosedEP15HTTP2Connection_block_invoke;
      v37 = &__block_descriptor_48_e5_v8__0l;
      v38 = v30;
      v39 = this;
      (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v31 + 96))(v31, &v35);
    }
    v35 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 272, &v35);
    v32 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
    if (*((_QWORD *)&v35 + 1))
    {
      v33 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    CFRelease(v8);
  }
}

void sub_183F6EAAC(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

CFHostRef CFHostCreateWithName(CFAllocatorRef allocator, CFStringRef hostname)
{
  _OWORD *Instance;
  DispatchHost *v5;
  __CFArray *Array;
  _OWORD *v7;
  __CFArray *v8;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v5 = (DispatchHost *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v5 = (DispatchHost *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  Array = cfTypeCreateArray(allocator, hostname, 0, 0, 0);
  DispatchHost::DispatchHost(v5, (const __CFString *)&unk_1EDCFF6F8, Array, 0);
  if (Array)
    CFRelease(Array);
  if (v5)
    return (DispatchHost *)((char *)v5 - 16);
  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  v7 = (_OWORD *)_CFRuntimeCreateInstance();
  v5 = (DispatchHost *)v7;
  if (v7)
  {
    v7[1] = 0u;
    v5 = (DispatchHost *)(v7 + 1);
    v7[8] = 0u;
    v7[9] = 0u;
    v7[6] = 0u;
    v7[7] = 0u;
    v7[4] = 0u;
    v7[5] = 0u;
    v7[2] = 0u;
    v7[3] = 0u;
  }
  v8 = cfTypeCreateArray(allocator, hostname, 0, 0, 0);
  Host::Host(v5, (const __CFString *)&unk_1EDCFF6F8, v8, 0);
  if (v8)
    CFRelease(v8);
  if (v5)
    return (DispatchHost *)((char *)v5 - 16);
  else
    return 0;
}

void sub_183F6EFC4(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void DispatchHost::DispatchHost(DispatchHost *this, const __CFString *a2, const void *a3, ...)
{
  _QWORD *v6;
  va_list va;

  va_start(va, a3);
  HostBase::HostBase(this, 0);
  *v6 = &off_1E14E59B8;
  v6[1] = &unk_1E14E5A28;
  *((_QWORD *)this + 18) = copyHostQueue();
  *((_QWORD *)this + 19) = dispatch_group_create();
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  HostBase::setInfoLocked((CFMutableDictionaryRef *)this, a2, a3);
  HostBase::setInfoLocked((CFMutableDictionaryRef *)this, va);
  HostBase::unlock(this);
}

void sub_183F6F088(_Unwind_Exception *a1)
{
  HostBase *v1;

  HostBase::~HostBase(v1);
  _Unwind_Resume(a1);
}

void HostBase::setInfoLocked(CFMutableDictionaryRef *this, const __CFString *a2, const void *a3)
{
  if (!CFDictionaryGetValue(this[12], a2))
    CFDictionarySetValue(this[12], a2, a3);
}

void HostBase::HostBase(HostBase *this, const HostBase *a2)
{
  _QWORD *v4;
  const __CFAllocator *v5;
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  const __CFAllocator *v8;

  *(_QWORD *)this = &off_1E14EFCD8;
  *((_QWORD *)this + 1) = &unk_1E14EFD48;
  _CoreLockable::_CoreLockable((HostBase *)((char *)this + 24), 1);
  *v4 = &off_1E14E5818;
  if (a2)
  {
    CFRetain((char *)a2 - 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 32));
    ++*((_QWORD *)a2 + 2);
    v5 = CFGetAllocator((char *)this - 16);
    *((_QWORD *)this + 12) = CFDictionaryCreateMutableCopy(v5, 0, *((CFDictionaryRef *)a2 + 12));
    v6 = CFGetAllocator((char *)this - 16);
    *((_QWORD *)this + 15) = CFArrayCreateMutableCopy(v6, 0, *((CFArrayRef *)a2 + 15));
    HostBase::unlock(a2);
  }
  else
  {
    v7 = CFGetAllocator((char *)this - 16);
    *((_QWORD *)this + 12) = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v8 = CFGetAllocator((char *)this - 16);
    *((_QWORD *)this + 15) = CFArrayCreateMutable(v8, 0, MEMORY[0x1E0C9B378]);
  }
  *((_QWORD *)this + 16) = 0;
}

void sub_183F6F1EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

void HostBase::setInfoLocked(CFMutableDictionaryRef *this, char *a2)
{
  unint64_t v3;
  char *v4;
  unint64_t v5;
  const __CFString **v6;
  const __CFString *v7;
  char *v8;
  const __CFString **v9;

  v8 = a2;
  v9 = (const __CFString **)a2;
  v3 = -1;
  do
  {
    v4 = v8;
    v8 += 8;
    ++v3;
  }
  while (*(_QWORD *)v4);
  if (v3 >= 2)
  {
    v5 = (v3 >> 1) + 1;
    do
    {
      v6 = v9;
      v7 = *v9;
      v9 += 2;
      HostBase::setInfoLocked(this, v7, v6[1]);
      --v5;
    }
    while (v5 > 1);
  }
}

dispatch_queue_t copyHostQueue(void)
{
  uint64_t v0;

  v0 = copyHostQueue(void)::gQueueCreate;
  if (!(copyHostQueue(void)::gQueue | copyHostQueue(void)::gQueueCreate))
  {
    if (copyHostQueue(void)::sOnce != -1)
      dispatch_once(&copyHostQueue(void)::sOnce, &__block_literal_global_14866);
    v0 = copyHostQueue(void)::gQueueCreate;
  }
  if (v0)
    return dispatch_queue_create("com.apple.DispatchHost", 0);
  dispatch_retain((dispatch_object_t)copyHostQueue(void)::gQueue);
  return (dispatch_queue_t)copyHostQueue(void)::gQueue;
}

void ___ZN20ClassicURLConnection6cancelEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  NSObject *global_queue;
  NSObject *v3;
  NSObject **v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  _QWORD v26[5];
  NSObject **v27;
  std::__shared_weak_count *v28;
  NSObject **v29;
  uint64_t v30;
  void (*v31)(_QWORD *);
  void *v32;
  uint64_t v33;
  NSObject **v34;
  std::__shared_weak_count *v35;
  NSObject **v36;
  std::__shared_weak_count *v37;
  NSObject **v38;
  std::__shared_weak_count *v39;

  v1 = *(_QWORD *)(a1 + 32);
  global_queue = dispatch_get_global_queue(0, 0);
  v3 = global_queue;
  v4 = (NSObject **)MEMORY[0x1E0C809B0];
  v26[0] = MEMORY[0x1E0C809B0];
  v26[1] = 3221225472;
  v26[2] = ___ZN20ClassicURLConnection6cancelEv_block_invoke_3;
  v26[3] = &__block_descriptor_40_e5_v8__0l;
  v26[4] = v1;
  if (!*(_QWORD *)(v1 + 32) && !*(_QWORD *)(v1 + 24))
  {
    dispatch_async(global_queue, v26);
    return;
  }
  std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject  {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>(&v38, global_queue, v26);
  if (*(_QWORD *)(v1 + 32))
  {
    v29 = v4;
    v30 = 3321888768;
    v31 = ___ZN20ClassicURLConnection25invalidateConnectionAsyncEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
    v32 = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
    v33 = v1;
    v34 = v38;
    v35 = v39;
    if (v39)
    {
      p_shared_owners = (unint64_t *)&v39->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject  {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>(&v36, v3, &v29);
    v7 = *(_QWORD *)(v1 + 32);
    v27 = v36;
    v28 = v37;
    if (v37)
    {
      v8 = (unint64_t *)&v37->__shared_owners_;
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    (*(void (**)(uint64_t, NSObject ***))(*(_QWORD *)v7 + 16))(v7, &v27);
    v10 = v28;
    if (v28)
    {
      v11 = (unint64_t *)&v28->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v13 = v37;
    if (v37)
    {
      v14 = (unint64_t *)&v37->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    v16 = v35;
    if (!v35)
      goto LABEL_32;
    v17 = (unint64_t *)&v35->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
  }
  else
  {
    v19 = *(_QWORD *)(v1 + 24);
    v29 = v38;
    v30 = (uint64_t)v39;
    if (v39)
    {
      v20 = (unint64_t *)&v39->__shared_owners_;
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    (*(void (**)(uint64_t, NSObject ***))(*(_QWORD *)v19 + 16))(v19, &v29);
    v16 = (std::__shared_weak_count *)v30;
    if (!v30)
      goto LABEL_32;
    v22 = (unint64_t *)(v30 + 8);
    do
      v18 = __ldaxr(v22);
    while (__stlxr(v18 - 1, v22));
  }
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
LABEL_32:
  v23 = v39;
  if (v39)
  {
    v24 = (unint64_t *)&v39->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

void sub_183F6F58C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  uint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;

  if (a17)
  {
    p_shared_owners = (unint64_t *)&a17->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))a17->__on_zero_shared)(a17);
      std::__shared_weak_count::__release_weak(a17);
    }
  }
  v26 = *(std::__shared_weak_count **)(v22 - 40);
  if (v26)
  {
    v27 = (unint64_t *)&v26->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  _Unwind_Resume(exception_object);
}

void ClassicURLConnection::withLoaderClientAsync(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[6];
  _QWORD v9[6];
  _QWORD block[6];

  CFRetain((CFTypeRef)(a1 - 16));
  v4 = *(_QWORD *)(a1 + 24);
  v5 = MEMORY[0x1E0C809B0];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN20ClassicURLConnection21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke;
  v8[3] = &unk_1E14F78F8;
  v8[4] = a2;
  v8[5] = a1;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN19URLConnectionClient21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke;
  v9[3] = &unk_1E14FDA90;
  v9[4] = v8;
  v9[5] = v4;
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 32) + 64))(*(_QWORD *)(v4 + 32));
  v7 = *(NSObject **)(v4 + 40);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v9;
  block[5] = v6;
  dispatch_async(v7, block);
}

_QWORD *IOLogger::_initLogger(IOLogger *this)
{
  char *v1;
  char *v2;
  CoreLogFileSink *v3;
  __sFILE **v4;
  _QWORD *v5;
  _QWORD *result;
  uint64_t v7;
  const char *v8;
  char *v9;
  char *v10;
  pid_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uid_t v16;
  gid_t v17;
  int *v18;
  char v19;
  FILE *v20;
  uint64_t v21;
  _QWORD *v22;
  char *v23;

  v1 = getenv("CFNETWORK_IO_LOG_FILE");
  if (v1)
  {
    v2 = v1;
    if (!issetugid())
    {
      v7 = operator new();
      if (strrchr(v2, 47))
        v8 = v2 + 1;
      else
        v8 = v2;
      *(_QWORD *)v7 = off_1E14E4D78;
      snprintf((char *)(v7 + 8), 0x100uLL, "com.apple.CFNetwork.LogSink[%s]", v8);
      *(_QWORD *)(v7 + 264) = dispatch_queue_create((const char *)(v7 + 8), 0);
      *(_QWORD *)v7 = off_1E14E7460;
      v23 = 0;
      v9 = strstr(v2, "%d");
      if (v9)
      {
        v10 = v9;
        v11 = getpid();
        asprintf(&v23, "%.*s%d%s", (_DWORD)v10 - (_DWORD)v2, v2, v11, v10 + 2);
      }
      else
      {
        v23 = v2;
      }
      v12 = 0;
      v13 = -1;
      while (2)
      {
        switch(v12)
        {
          case 0:
            if (unlink(v23))
            {
              v14 = *__error();
              if (v14 == 2)
                v15 = 0;
              else
                v15 = v14;
            }
            else
            {
              v15 = 0;
            }
            goto LABEL_32;
          case 1:
            v13 = open(v23, 2817, 384);
            if (v13 != -1)
            {
              v15 = 0;
              goto LABEL_32;
            }
            v18 = __error();
            v13 = -1;
            goto LABEL_30;
          case 2:
            v16 = getuid();
            v17 = getgid();
            if (fchown(v13, v16, v17))
            {
              v18 = __error();
LABEL_30:
              v15 = *v18;
            }
            else
            {
              v15 = 0;
            }
LABEL_32:
            ++v12;
            if (!v15)
              continue;
LABEL_33:
            CFLog();
            v19 = 0;
            *(_QWORD *)(v7 + 272) = *MEMORY[0x1E0C80C10];
LABEL_34:
            *(_BYTE *)(v7 + 280) = v19;
            if (v23 != v2)
              free(v23);
            break;
          case 3:
            v20 = fdopen(v13, "w");
            *(_QWORD *)(v7 + 272) = v20;
            if (!v20 && *__error())
              goto LABEL_33;
            CFLog();
            v19 = 1;
            goto LABEL_34;
          default:
            v15 = 0;
            goto LABEL_32;
        }
        goto LABEL_9;
      }
    }
  }
  if (getenv("CFNETWORK_IO_LOG_STDOUT"))
  {
    v3 = (CoreLogFileSink *)operator new();
    v4 = (__sFILE **)MEMORY[0x1E0C80C20];
LABEL_8:
    CoreLogFileSink::CoreLogFileSink(v3, *v4);
LABEL_9:
    v5 = (_QWORD *)operator new();
    *v5 = &off_1E14E48A8;
    result = (_QWORD *)operator new();
    *result = &off_1E14ECA50;
    result[1] = v5;
    gIOLogger = (uint64_t)result;
    return result;
  }
  if (getenv("CFNETWORK_IO_LOG_STDERR") || getenv("CFNETWORK_IO_LOG"))
  {
    v3 = (CoreLogFileSink *)operator new();
    v4 = (__sFILE **)MEMORY[0x1E0C80C10];
    goto LABEL_8;
  }
  result = (_QWORD *)DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_17226, 2);
  if (result)
  {
    v21 = (uint64_t)result;
    result = (_QWORD *)(*(uint64_t (**)(_QWORD *, const char *, _QWORD))(*result + 16))(result, "SocketStream IO Logging", 0);
    if ((_DWORD)result)
    {
      v22 = (_QWORD *)operator new();
      *v22 = &off_1E14EE808;
      gIOLogger = (uint64_t)v22;
      return (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
    }
  }
  return result;
}

void sub_183F6FBE4()
{
  _QWORD *v0;

  *v0 = off_1E14E4D78;
  abort();
}

void sub_183F709A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void HTTPConnectionCacheKey::~HTTPConnectionCacheKey(HTTPConnectionCacheKey *this)
{
  uint64_t v2;

  HTTPConnectionCacheKey::~HTTPConnectionCacheKey(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  *(_QWORD *)this = off_1E14EC400;
  v2 = (const void *)*((_QWORD *)this + 4);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 6);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 8);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 10);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v8)
    CFRelease(v8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 104);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 88);
}

void sub_183F71104(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;
  const void *v4;

  v3 = *(const void **)(v1 + 136);
  *(_QWORD *)(v1 + 136) = 0;
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(v1 + 128);
  *(_QWORD *)(v1 + 128) = 0;
  if (v4)
    CFRelease(v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 104);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 88);
  _Unwind_Resume(a1);
}

void CFXCookieStorage::parseAndStoreCookiesForTask(id *this, const __CFArray *a2, NSURLSessionTask *a3)
{
  int v6;
  NSURLRequest *v7;
  uint64_t v8;
  const __CFURL *v9;
  const __CFAllocator *v10;
  __CFArray *CookiesWithCookieStrings;
  uint64_t v12;
  char *v13;
  int CookieAcceptPolicy;
  int v15;
  const __CFURL *v16;
  const void *v17;
  const __CFAllocator *v18;
  __CFArray *v19;
  NSURL *PolicyPropertiesFromTask;
  const __CFDictionary *v21;
  uint64_t (**v22)(id, __CFArray *);
  __CFArray *v23;
  char *v24;
  HTTPCookieStorage *v25;
  _BYTE v26[104];

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  v6 = newCookieStorageEnabled(void)::enabled;
  v7 = -[NSURLSessionTask currentRequest](a3, "currentRequest");
  v8 = -[NSURLRequest _inner](v7, "_inner");
  if (v6)
  {
    v9 = *(const __CFURL **)(v8 + 8);
    v10 = CFGetAllocator(a2);
    CookiesWithCookieStrings = _createCookiesWithCookieStrings(v10, a2, v9, -[NSURLSessionTask _storagePartitionIdentifier](a3, "_storagePartitionIdentifier"), 1);
    objc_msgSend(this[4], "storeCookies:forTask:", CookiesWithCookieStrings, a3);
    if (CookiesWithCookieStrings)
      CFRelease(CookiesWithCookieStrings);
  }
  else
  {
    v12 = *(_QWORD *)(v8 + 56);
    if (v12 && (v13 = *(char **)(v12 + 192)) != 0)
      CookieAcceptPolicy = CFHTTPCookieStorageGetCookieAcceptPolicy(v13);
    else
      CookieAcceptPolicy = (*((uint64_t (**)(id *))*this + 12))(this);
    v15 = CookieAcceptPolicy;
    v16 = *(const __CFURL **)(-[NSURLRequest _inner](v7, "_inner") + 8);
    v17 = *(const void **)(-[NSURLRequest _inner](-[NSURLSessionTask currentRequest](a3, "currentRequest"), "_inner")
                         + 32);
    v18 = CFGetAllocator(a2);
    v19 = _createCookiesWithCookieStrings(v18, a2, v16, -[NSURLSessionTask _storagePartitionIdentifier](a3, "_storagePartitionIdentifier"), 1);
    PolicyPropertiesFromTask = getPolicyPropertiesFromTask(a3);
    if (v19)
    {
      v21 = (const __CFDictionary *)PolicyPropertiesFromTask;
      if (CFArrayGetCount(v19) < 1)
        goto LABEL_20;
      v22 = -[NSURLSessionTask _cookieTransformCallback](a3, "_cookieTransformCallback");
      if (v22)
      {
        v23 = (__CFArray *)(id)v22[2](v22, v19);
        CFRelease(v19);
        v19 = v23;
      }
      HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v26, v16, v17, (uint64_t)-[NSURLSessionTask _storagePartitionIdentifier](a3, "_storagePartitionIdentifier"), v15, 1, v21);
      v24 = (char *)this[3];
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
      v25 = v24 ? (HTTPCookieStorage *)(v24 + 16) : 0;
      HTTPCookieStorage::setCookiesWithPolicy(v25, v19, (const HTTPCookieStoragePolicy *)v26);
      HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v26);
      if (v19)
LABEL_20:
        CFRelease(v19);
    }
  }
}

void sub_183F713E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

uint64_t CFXCookieStorage::getCookieAcceptPolicy(CFXCookieStorage *this)
{
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
    return objc_msgSend(*((id *)this + 4), "cookieAcceptPolicy");
  else
    return CFHTTPCookieStorageGetCookieAcceptPolicy(*((char **)this + 3));
}

void HTTPCookieStorage::setCookiesWithPolicy(HTTPCookieStorage *this, const __CFArray *a2, const HTTPCookieStoragePolicy *a3)
{
  uint64_t v6;
  const __CFURL *v7;
  uint64_t v8;
  const __CFAllocator *v9;
  int v10;
  uint64_t v11;
  CFStringRef v12;
  const __CFArray *v13;
  CompactCookieArray *CompactCookieArray;
  CFStringRef v15;
  CFStringRef v16;
  BOOL v17;
  const __CFString *v18;
  const __CFAllocator *v19;
  CFIndex Length;
  const __CFAllocator *v21;
  double Current;
  char *v23;
  const __CFArray *v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t v27;
  const __CFData *v28;
  const UInt8 *BytePtr;
  unint64_t v30;
  _BOOL4 v31;
  const __CFData *v32;
  const UInt8 *v33;
  const UInt8 *v34;
  uint64_t v35;
  const UInt8 *v36;
  double v37;
  int v38;
  char *v39;
  char *v40;
  _BOOL4 v41;
  const __CFAllocator *v42;
  const __CFURL *v43;
  void *v44;
  void *v45;
  __CFArray *Mutable;
  const __CFURL *v47;
  CFStringRef v48;
  unint64_t v49;
  CFRange v50;
  const void **v51;
  const __CFArray *v52;
  const __CFArray *v53;
  CFIndex Count;
  CFIndex v55;
  OpaqueCFHTTPCookie *v56;
  uint64_t v57;
  unsigned int *v58;
  uint64_t v59;
  _BYTE *v60;
  uint64_t v61;
  _BYTE *v62;
  unsigned int v63;
  unsigned __int8 *v64;
  BOOL v65;
  BOOL v66;
  unsigned int v67;
  unsigned int *v68;
  uint64_t v69;
  _BYTE *v70;
  uint64_t v71;
  _BYTE *v72;
  unsigned int v73;
  unsigned __int8 *v74;
  BOOL v75;
  BOOL v76;
  unsigned int v77;
  uint64_t v78;
  _DWORD *v79;
  int v80;
  uint64_t v81;
  const __CFURL *v82;
  id v83;
  uint64_t v84;
  unsigned int *v85;
  uint64_t v86;
  uint64_t v87;
  _BYTE *v88;
  id v89;
  char v90;
  uint64_t v91;
  _DWORD *v92;
  const __CFURL *v93;
  const __CFString *v94;
  uint64_t v95;
  _DWORD *v96;
  unsigned int v97;
  uint64_t v98;
  _DWORD *v99;
  int v100;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  NSObject *v105;
  id v106;
  uint64_t v107;
  unsigned int *v108;
  uint64_t v109;
  uint64_t v110;
  _BYTE *v111;
  uint64_t v112;
  unsigned int *v113;
  const unsigned __int8 *v114;
  uint64_t v115;
  const char *v116;
  uint64_t v117;
  _BYTE *v118;
  OpaqueCFHTTPCookie *v119;
  unsigned int *v120;
  uint64_t v121;
  uint64_t v122;
  _BYTE *v123;
  unsigned int *v124;
  uint64_t v125;
  uint64_t v126;
  _BYTE *v127;
  unsigned int *v128;
  uint64_t v129;
  char *v130;
  uint64_t v131;
  _BYTE *v132;
  NSMutableDictionary *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t j;
  NSHTTPCookie *v137;
  void *v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t k;
  uint64_t v142;
  NSObject *v143;
  CFIndex i;
  void *ValueAtIndex;
  char *cf;
  const char *CStringPtr;
  char *v148;
  char *ptr;
  char *ptra;
  CFMutableStringRef theString;
  CookieUtils *lock;
  id obj;
  _QWORD block[6];
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  _QWORD v163[10];
  CFDictionaryRef theDict;
  uint64_t v165;
  __int16 v166;
  _QWORD v167[2];
  void (*v168)(uint64_t);
  void *v169;
  const __CFArray *v170;
  double v171[2];
  void (*v172)(uint64_t);
  void *v173;
  const __CFString *v174;
  _BYTE v175[128];
  _BYTE v176[128];
  void (**v177)(AutoString *__hidden);
  CFIndex range;
  const void **v179;
  _QWORD v180[31];
  CFIndex v181;
  void *v182;
  void (**v183)(AutoString *__hidden);
  CFStringRef v184;
  unint64_t v185;
  _QWORD v186[32];
  void *v187;
  uint8_t buf[4];
  void *v189;
  __int16 v190;
  char *v191;
  __int16 v192;
  char *v193;
  uint64_t v194;

  v194 = *MEMORY[0x1E0C80C00];
  v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_11_9843, 3);
  if (v6)
  {
    v8 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, HTTPCookieStorage *))(*(_QWORD *)v6 + 24))(v6, "HTTPCookieStorage::setCookiesWithPolicies", this))
    {
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v10 = *((_DWORD *)a3 + 10);
      if (v10 == -1)
      {
        v10 = 3;
        *((_DWORD *)a3 + 10) = 3;
      }
      v11 = v10;
      v183 = &off_1E14E4818;
      v186[0] = 0;
      v184 = CFStringCreateWithCString(v9, "AcceptPolicy", 0x8000100u);
      v185 = 0;
      v12 = CFStringCreateWithFormat(v9, 0, CFSTR("%ld"), v11);
      (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v8 + 64))(v8, v184, v12);
      if (v12)
        CFRelease(v12);
      AutoString::~AutoString((AutoString *)&v183);
      (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v8 + 40))(v8, "URL", *((_QWORD *)a3 + 2));
      (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v8 + 40))(v8, "MainDocumentURL", *((_QWORD *)a3 + 3));
      if (!a2)
        goto LABEL_14;
      if (CFArrayGetCount(a2))
      {
        CompactCookieArray = CompactCookieArray::makeCompactCookieArray((CompactCookieArray *)v9, a2, v13);
        if (CompactCookieArray)
        {
          logCookieArray(v8, (uint64_t)CompactCookieArray);
          CFRelease((char *)CompactCookieArray - 16);
LABEL_14:
          (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
          goto LABEL_15;
        }
        v183 = &off_1E14E4818;
        v16 = CFStringCreateWithCString(v9, "Cookies", 0x8000100u);
        v186[0] = 0;
        v184 = v16;
        v185 = 0;
        v177 = &off_1E14E4818;
        v180[0] = 0;
        range = (CFIndex)CFStringCreateWithCString(v9, "corrupt?", 0x8000100u);
        v179 = 0;
        (*(void (**)(uint64_t, CFStringRef, CFIndex))(*(_QWORD *)v8 + 64))(v8, v184, range);
      }
      else
      {
        v183 = &off_1E14E4818;
        v15 = CFStringCreateWithCString(v9, "Cookies", 0x8000100u);
        v186[0] = 0;
        v184 = v15;
        v185 = 0;
        v177 = &off_1E14E4818;
        v180[0] = 0;
        range = (CFIndex)CFStringCreateWithCString(v9, "empty cookie array", 0x8000100u);
        v179 = 0;
        (*(void (**)(uint64_t, CFStringRef, CFIndex))(*(_QWORD *)v8 + 64))(v8, v184, range);
      }
      AutoString::~AutoString((AutoString *)&v177);
      AutoString::~AutoString((AutoString *)&v183);
      goto LABEL_14;
    }
  }
LABEL_15:
  v17 = 0;
  switch(*((_DWORD *)a3 + 10))
  {
    case 0xFFFFFFFF:
      *((_DWORD *)a3 + 10) = 3;
      goto LABEL_67;
    case 1:
      v17 = 1;
      goto LABEL_71;
    case 2:
      v18 = CFURLCopyHostName(*((CFURLRef *)a3 + 2));
      if (!v18)
        goto LABEL_67;
      cf = (char *)this - 16;
      v19 = CFGetAllocator((char *)this - 16);
      theString = CFStringCreateMutableCopy(v19, 0, v18);
      CFRelease(v18);
      if (!theString)
        goto LABEL_67;
      CFStringLowercase(theString, 0);
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
      ptr = (char *)CStringPtr;
      if (!CStringPtr)
      {
        Length = CFStringGetLength(theString);
        v21 = CFGetAllocator(cf);
        ptr = (char *)CFAllocatorAllocate(v21, Length + 1, 0);
        CFStringGetCString(theString, ptr, Length + 1, 0x600u);
        if (!ptr)
        {
          CFRelease(theString);
          v38 = 0;
          ptr = 0;
          goto LABEL_65;
        }
      }
      Current = CFAbsoluteTimeGetCurrent();
      v23 = ptr;
      break;
    case 3:
      goto LABEL_67;
    default:
      goto LABEL_71;
  }
  do
  {
    v183 = &off_1E14E9488;
    DomainAndPartition::init(&v183, 1, *(uint64_t *)&Current, v23);
    v24 = a2;
    v25 = (_QWORD *)*((_QWORD *)this + 2);
    DomainAndPartition::DomainAndPartition((uint64_t)&v177, (uint64_t)&v183);
    v26 = PrivateHTTPCookieStorage::copyDomainCookieArray(v25, (uint64_t)&v177, 1);
    v177 = &off_1E14E9488;
    if (v182 && v182 != v180)
      free(v182);
    if (v26)
    {
      v27 = 0;
      while (1)
      {
        v28 = *(const __CFData **)(v26 + 16);
        if (v28 && (BytePtr = CFDataGetBytePtr(v28)) != 0)
          v30 = *((unsigned int *)BytePtr + 1);
        else
          v30 = 0;
        v31 = v27 >= v30;
        if (v27 >= v30)
          break;
        v32 = *(const __CFData **)(v26 + 16);
        if (v32 && CFDataGetBytePtr(v32))
        {
          v33 = CFDataGetBytePtr(*(CFDataRef *)(v26 + 16));
          v34 = *(const UInt8 **)(v26 + 16);
          v35 = *(unsigned int *)&v33[4 * v27 + 8];
          if (v34)
            v34 = CFDataGetBytePtr((CFDataRef)v34);
          v36 = &v34[v35];
        }
        else
        {
          v36 = 0;
        }
        if (*(_DWORD *)v36 < 0xCu || (*((_DWORD *)v36 + 2) & 2) == 0)
        {
          v37 = 0.0;
          if (*(_DWORD *)v36 >= 0x30u)
          {
            v171[0] = *((double *)v36 + 5);
            v37 = floor(v171[0]);
          }
          ++v27;
          if (Current >= v37)
            continue;
        }
        v38 = 1;
        goto LABEL_53;
      }
      if (*v23 == 46)
        v40 = v23 + 1;
      else
        v40 = v23;
      v23 = strchr(v40, 46);
      v38 = 0;
LABEL_53:
      CFRelease((CFTypeRef)(v26 - 16));
    }
    else
    {
      if (*v23 == 46)
        v39 = v23 + 1;
      else
        v39 = v23;
      v23 = strchr(v39, 46);
      v38 = 0;
      v31 = 1;
    }
    v183 = &off_1E14E9488;
    if (v187 && v187 != v186)
      free(v187);
    if (v23)
      v41 = v31;
    else
      v41 = 0;
    a2 = v24;
  }
  while (v41 && *v23);
  CFRelease(theString);
  if (CStringPtr)
    goto LABEL_66;
LABEL_65:
  v42 = CFGetAllocator(cf);
  CFAllocatorDeallocate(v42, ptr);
LABEL_66:
  if (v38)
    goto LABEL_69;
LABEL_67:
  v43 = (const __CFURL *)*((_QWORD *)a3 + 3);
  if (!v43 || HTTPCookieStorage::isURLInMainDocumentDomain(*((HTTPCookieStorage **)a3 + 2), v43, v7))
  {
LABEL_69:
    v17 = 0;
    goto LABEL_71;
  }
  v17 = *((_QWORD *)a3 + 4) == 0;
LABEL_71:
  obj = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  if (v17)
    goto LABEL_214;
  v44 = (void *)*((_QWORD *)a3 + 2);
  if (v44
    && (v45 = (void *)objc_msgSend(v44, "scheme")) != 0
    && !objc_msgSend(v45, "caseInsensitiveCompare:", 0x1EDD00AA8))
  {
    v52 = HTTPCookieStorage::copyCookiesForURL(this, a3, 1u);
    v53 = v52;
    if (v52)
      Count = CFArrayGetCount(v52);
    else
      Count = 0;
    v167[0] = MEMORY[0x1E0C809B0];
    v167[1] = 3221225472;
    v168 = ___ZN17HTTPCookieStorage20setCookiesWithPolicyEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke_2;
    v169 = &__block_descriptor_40_e5_v8__0l;
    v170 = v53;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v53, i);
        if (objc_msgSend(ValueAtIndex, "isSecure"))
          CFArrayAppendValue(Mutable, ValueAtIndex);
      }
    }
    v168((uint64_t)v167);
  }
  else
  {
    Mutable = 0;
  }
  CFGetAllocator((char *)this - 16);
  CookieHostName::CookieHostName((CookieHostName *)&v183, *((CFURLRef *)a3 + 2), v47);
  if (v185 >= 2)
  {
    v48 = v184;
    if (a2)
    {
      v177 = (void (**)(AutoString *__hidden))CFRetain(a2);
      v49 = CFArrayGetCount(a2);
      v50.length = v49;
      range = v49;
      if (v49 - 1 > 0x1FFFFFFFFFFFFFFDLL)
      {
        v179 = 0;
      }
      else
      {
        if (v49 <= 0x1E)
        {
          v51 = (const void **)v180;
          v179 = (const void **)v180;
LABEL_87:
          v50.location = 0;
          CFArrayGetValues(a2, v50, v51);
          goto LABEL_88;
        }
        v51 = (const void **)malloc_type_malloc(8 * v49, 0x89ED541CuLL);
        v179 = v51;
        if (v51)
        {
          v50.length = range;
          goto LABEL_87;
        }
      }
    }
    else
    {
      range = 0;
      v177 = 0;
      v179 = (const void **)v180;
    }
LABEL_88:
    v181 = 0;
    if (range >= 1)
    {
      v55 = 0;
      lock = (CookieUtils *)((char *)&v48->isa + 1);
      do
      {
        v181 = v55 + 1;
        v56 = (OpaqueCFHTTPCookie *)v179[v55];
        v57 = -[OpaqueCFHTTPCookie _inner](v56, "_inner");
        v58 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v57 + 16))(v57);
        if (*v58 >= 0x18
          && (v59 = v58[5], (_DWORD)v59)
          && (v60 = (char *)v58 + v59, v61 = *v58, v62 = (char *)v58 + v59, v61 > v59))
        {
          while (*v62)
          {
            if (++v62 >= (_BYTE *)v58 + v61)
              goto LABEL_95;
          }
        }
        else
        {
LABEL_95:
          v60 = 0;
        }
        v63 = *v60;
        if (*v60)
        {
          v64 = v60 + 1;
          do
          {
            v65 = v63 >= 0x20 || v63 == 9;
            v66 = !v65;
            if (v63 == 127 || v66)
              goto LABEL_178;
            v67 = *v64++;
            v63 = v67;
          }
          while (v67);
        }
        v68 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v57 + 16))(v57);
        if (*v68 >= 0x20
          && (v69 = v68[7], (_DWORD)v69)
          && (v70 = (char *)v68 + v69, v71 = *v68, v72 = (char *)v68 + v69, v71 > v69))
        {
          while (*v72)
          {
            if (++v72 >= (_BYTE *)v68 + v71)
              goto LABEL_112;
          }
        }
        else
        {
LABEL_112:
          v70 = 0;
        }
        v73 = *v70;
        if (*v70)
        {
          v74 = v70 + 1;
          do
          {
            v75 = v73 >= 0x20 || v73 == 9;
            v76 = !v75;
            if (v73 == 127 || v76)
              goto LABEL_178;
            v77 = *v74++;
            v73 = v77;
          }
          while (v77);
        }
        if (!CFHTTPCookie_domainMatches(v56, *((const __CFURL **)a3 + 2)))
          goto LABEL_178;
        v163[0] = &off_1E14ECAE8;
        theDict = 0;
        v165 = 0;
        v166 = 0;
        HTTPCookieStoragePolicy::init((uint64_t)v163, *((CFTypeRef *)a3 + 2), *((const void **)a3 + 3), *((_QWORD *)a3 + 4), *((_DWORD *)a3 + 10), *((_DWORD *)a3 + 18), *((_QWORD *)a3 + 7), *((_QWORD *)a3 + 8), *((const __CFDictionary **)a3 + 10));
        v78 = -[OpaqueCFHTTPCookie _inner](v56, "_inner");
        v79 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v78 + 16))(v78);
        if (*v79 >= 0xCu)
        {
          v80 = v79[2];
          if (theDict && CFDictionaryGetValue(theDict, CFSTR("_kCFHTTPCookiePolicyPropertySiteForCookies")))
          {
            if ((v80 & 0x18) == 0)
              goto LABEL_149;
            if (!HTTPCookieStoragePolicy::isTopLevelNavigation(theDict))
            {
              v100 = HTTPCookieStoragePolicy::isURLInSiteForCookie((HTTPCookieStoragePolicy *)v163, v81, v82) != 0;
LABEL_153:
              HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v163);
              if (!v100)
                goto LABEL_178;
              goto LABEL_134;
            }
          }
        }
        else if (theDict && CFDictionaryGetValue(theDict, CFSTR("_kCFHTTPCookiePolicyPropertySiteForCookies")))
        {
LABEL_149:
          v98 = -[OpaqueCFHTTPCookie _inner](v56, "_inner");
          v99 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v98 + 16))(v98);
          if (*v99 <= 0xBu)
          {
            HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v163);
            goto LABEL_178;
          }
          v100 = v99[2] & 1;
          goto LABEL_153;
        }
        HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v163);
LABEL_134:
        v83 = objc_alloc(MEMORY[0x1E0CB3940]);
        v84 = -[OpaqueCFHTTPCookie _inner](v56, "_inner");
        v85 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v84 + 16))(v84);
        if (*v85 >= 0x18)
        {
          v86 = v85[5];
          if ((_DWORD)v86)
          {
            v87 = *v85;
            v88 = (char *)v85 + v86;
            if (v87 > v86)
            {
              do
              {
                if (!*v88)
                  break;
                ++v88;
              }
              while (v88 < (_BYTE *)v85 + v87);
            }
          }
        }
        v89 = (id)objc_msgSend(v83, "initWithCString:encoding:");
        v90 = objc_msgSend(v89, "hasPrefix:", CFSTR("__Secure-"));
        if ((v90 & 1) == 0 && !objc_msgSend(v89, "hasPrefix:", CFSTR("__Host-")))
          goto LABEL_171;
        v91 = -[OpaqueCFHTTPCookie _inner](v56, "_inner");
        v92 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v91 + 16))(v91);
        if (*v92 >= 0xCu && (v92[2] & 1) != 0)
        {
          v93 = (const __CFURL *)*((_QWORD *)a3 + 2);
          if (!v93)
            goto LABEL_171;
          v94 = CFURLCopyScheme(v93);
          *(_QWORD *)&v171[0] = MEMORY[0x1E0C809B0];
          *(_QWORD *)&v171[1] = 3221225472;
          v172 = ___ZL36shouldAllowCookieBasedOnCookiePrefixPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicy_block_invoke;
          v173 = &__block_descriptor_40_e5_v8__0l;
          v174 = v94;
          if (_findCanonicalString(v94, 0xFu) == 588299686
            || _findCanonicalString(v94, 0xFu) == 593526198)
          {
            if ((v90 & 1) != 0)
              goto LABEL_170;
            v95 = -[OpaqueCFHTTPCookie _inner](v56, "_inner");
            v96 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v95 + 16))(v95);
            if (*v96 >= 0xCu)
              v97 = v96[2] & 0x20;
            else
              v97 = 0;
            v101 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v95 + 16))(v95);
            v102 = v97 >> 5;
            v103 = *(unsigned int *)(v101 + 16);
            v104 = v101 + v103;
            do
              ++v104;
            while (*(_BYTE *)(v104 - 1));
            if (v102 != (*(_BYTE *)(v101 + v103) != 46))
            {
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v105 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
              {
                v120 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v95 + 16))(v95);
                if (*v120 >= 0x18
                  && (v121 = v120[5], (_DWORD)v121)
                  && (v122 = *v120, v123 = (char *)v120 + v121, v122 > v121))
                {
                  while (*v123)
                  {
                    if (++v123 >= (_BYTE *)v120 + v122)
                      goto LABEL_193;
                  }
                  ptra = (char *)v120 + v121;
                }
                else
                {
LABEL_193:
                  ptra = 0;
                }
                v124 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v95 + 16))(v95);
                if (*v124 >= 0x20
                  && (v125 = v124[7], (_DWORD)v125)
                  && (v126 = *v124, v127 = (char *)v124 + v125, v126 > v125))
                {
                  while (*v127)
                  {
                    if (++v127 >= (_BYTE *)v124 + v126)
                      goto LABEL_199;
                  }
                  v148 = (char *)v124 + v125;
                }
                else
                {
LABEL_199:
                  v148 = 0;
                }
                v128 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v95 + 16))(v95);
                if (*v128 >= 0x14
                  && (v129 = v128[4], (_DWORD)v129)
                  && (v130 = (char *)v128 + v129,
                      v131 = *v128,
                      v132 = (char *)v128 + v129,
                      v131 > v129))
                {
                  while (*v132)
                  {
                    if (++v132 >= (_BYTE *)v128 + v131)
                      goto LABEL_205;
                  }
                }
                else
                {
LABEL_205:
                  v130 = 0;
                }
                *(_DWORD *)buf = 136315650;
                v189 = ptra;
                v190 = 2080;
                v191 = v148;
                v192 = 2080;
                v193 = v130;
                _os_log_fault_impl(&dword_183ECA000, v105, OS_LOG_TYPE_FAULT, "Cookie hostOnly flag and domain pattern is inconsistent. @{%s:%s; domain=%s}",
                  buf,
                  0x20u);
              }
              v102 = v97 == 0;
            }
            if (v102)
            {
              v106 = objc_alloc(MEMORY[0x1E0CB3940]);
              v107 = -[OpaqueCFHTTPCookie _inner](v56, "_inner");
              v108 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v107 + 16))(v107);
              if (*v108 >= 0x1C)
              {
                v109 = v108[6];
                if ((_DWORD)v109)
                {
                  v110 = *v108;
                  v111 = (char *)v108 + v109;
                  if (v110 > v109)
                  {
                    do
                    {
                      if (!*v111)
                        break;
                      ++v111;
                    }
                    while (v111 < (_BYTE *)v108 + v110);
                  }
                }
              }
              if ((objc_msgSend((id)objc_msgSend(v106, "initWithCString:encoding:"), "isEqualToString:", CFSTR("/")) & 1) != 0)
              {
LABEL_170:
                v172((uint64_t)v171);
LABEL_171:
                v112 = -[OpaqueCFHTTPCookie _inner](v56, "_inner");
                v113 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v112 + 16))(v112);
                if (*v113 >= 0x14)
                {
                  v115 = v113[4];
                  if ((_DWORD)v115)
                  {
                    v116 = (char *)v113 + v115;
                    v117 = *v113;
                    v118 = (char *)v113 + v115;
                    if (v117 > v115)
                    {
                      while (*v118)
                      {
                        if (++v118 >= (_BYTE *)v113 + v117)
                          goto LABEL_178;
                      }
                      if (lock == (CookieUtils *)v116 || CookieUtils::web_domainMatches_LCC_LCC(lock, v116, v114))
                      {
                        if (*((_QWORD *)a3 + 4))
                        {
                          v119 = -[NSHTTPCookie _initWithCookie:partition:]([NSHTTPCookie alloc], "_initWithCookie:partition:", v56, *((_QWORD *)a3 + 4));
                          if (HTTPCookieStorage::setCookie(this, v119, a3, Mutable, 0) == 1)
                            objc_msgSend(obj, "addObject:", v119);

                        }
                        else if (HTTPCookieStorage::setCookie(this, v56, a3, Mutable, 0) == 1)
                        {
                          objc_msgSend(obj, "addObject:", v56);
                        }
                      }
                    }
                  }
                }
                goto LABEL_178;
              }
            }
          }
          v172((uint64_t)v171);
        }
LABEL_178:
        v55 = v181;
      }
      while (v181 < range);
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v177);
  }
  if (Mutable)
    CFRelease(Mutable);
  v183 = &off_1E14E6B50;
  if (v187 != v186)
    free(v187);
LABEL_214:
  os_unfair_lock_lock((os_unfair_lock_t)this + 30);
  if (*((_QWORD *)this + 13))
  {
    v133 = (NSMutableDictionary *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v161 = 0u;
    v162 = 0u;
    v159 = 0u;
    v160 = 0u;
    v134 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v159, v176, 16);
    if (v134)
    {
      v135 = *(_QWORD *)v160;
      do
      {
        for (j = 0; j != v134; ++j)
        {
          if (*(_QWORD *)v160 != v135)
            objc_enumerationMutation(obj);
          v137 = *(NSHTTPCookie **)(*((_QWORD *)&v159 + 1) + 8 * j);
          v138 = (void *)objc_msgSend(*((id *)this + 10), "objectForKeyedSubscript:", -[NSHTTPCookie domain](v137, "domain"));
          v157 = 0u;
          v158 = 0u;
          v155 = 0u;
          v156 = 0u;
          v139 = objc_msgSend(v138, "countByEnumeratingWithState:objects:count:", &v155, v175, 16);
          if (v139)
          {
            v140 = *(_QWORD *)v156;
            do
            {
              for (k = 0; k != v139; ++k)
              {
                if (*(_QWORD *)v156 != v140)
                  objc_enumerationMutation(v138);
                addCookieToSubscriberDictionaryForDomain(v137, v133, *(NSString **)(*((_QWORD *)&v155 + 1) + 8 * k));
              }
              v139 = objc_msgSend(v138, "countByEnumeratingWithState:objects:count:", &v155, v175, 16);
            }
            while (v139);
          }
        }
        v134 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v159, v176, 16);
      }
      while (v134);
    }
    if (-[NSMutableDictionary count](v133, "count"))
    {
      v142 = *((_QWORD *)this + 13);
      v143 = *((_QWORD *)this + 11);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZN17HTTPCookieStorage20setCookiesWithPolicyEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke_3;
      block[3] = &unk_1E14FDF00;
      block[4] = v133;
      block[5] = v142;
      dispatch_async(v143, block);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 30);
}

void sub_183F72530(_Unwind_Exception *a1)
{
  AutoString::~AutoString((AutoString *)&STACK[0x2B0]);
  AutoString::~AutoString((AutoString *)&STACK[0x3F0]);
  _Unwind_Resume(a1);
}

BOOL CookieUtils::web_domainMatches_LCC_LCC(CookieUtils *this, const char *a2, const unsigned __int8 *a3)
{
  const __CFAllocator *v4;
  const __CFString *v5;
  __CFString *MutableCopy;
  const __CFAllocator *v7;
  CFIndex Length;
  __CFString *v9;
  const __CFAllocator *v10;
  CFIndex v11;
  CFComparisonResult v12;
  const __CFString *v13;
  _BOOL8 v14;
  _QWORD v16[19];
  void (**v17)(AutoString *__hidden);
  CFStringRef theString1;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[8];
  CFTypeRef v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v17 = &off_1E14E4818;
  v19 = 0;
  v20 = 0;
  theString1 = CFStringCreateWithCString(v4, (const char *)this, 0x8000100u);
  v16[0] = &off_1E14E4818;
  v5 = CFStringCreateWithCString(v4, a2, 0x8000100u);
  v16[2] = 0;
  v16[3] = 0;
  v16[1] = v5;
  if (CFStringCompare(theString1, v5, 0) == kCFCompareEqualTo)
    goto LABEL_17;
  if (CFStringHasSuffix(theString1, CFSTR(".")))
  {
    MutableCopy = (__CFString *)CFRetain(theString1);
  }
  else
  {
    v7 = CFGetAllocator(theString1);
    Length = CFStringGetLength(theString1);
    MutableCopy = CFStringCreateMutableCopy(v7, Length + 1, theString1);
    CFStringAppend(MutableCopy, CFSTR("."));
  }
  if (CFStringHasSuffix(v5, CFSTR(".")))
  {
    if (v5)
      v9 = (__CFString *)CFRetain(v5);
    else
      v9 = 0;
  }
  else
  {
    v10 = CFGetAllocator(v5);
    v11 = CFStringGetLength(v5);
    v9 = CFStringCreateMutableCopy(v10, v11 + 1, v5);
    CFStringAppend(v9, CFSTR("."));
  }
  v12 = CFStringCompare(MutableCopy, v9, 0);
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (v9)
    CFRelease(v9);
  if (v12)
  {
    if (CFStringGetCharacterAtIndex(theString1, 0) == 46)
    {
      v13 = (const __CFString *)CFRetain(theString1);
    }
    else
    {
      AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)v21, 0, CFSTR(".%@"), theString1);
      if (v22)
        v13 = (const __CFString *)CFRetain(v22);
      else
        v13 = 0;
      AutoString::~AutoString((AutoString *)v21);
    }
    if (CFStringHasSuffix(v13, v5))
    {
      v14 = !isTopLevelDomain(v5, 1);
      if (!v13)
        goto LABEL_27;
      goto LABEL_26;
    }
    v14 = 0;
    if (v13)
LABEL_26:
      CFRelease(v13);
  }
  else
  {
LABEL_17:
    v14 = 1;
  }
LABEL_27:
  AutoString::~AutoString((AutoString *)v16);
  AutoString::~AutoString((AutoString *)&v17);
  return v14;
}

void sub_183F728B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  uint64_t v30;

  AutoString::~AutoString((AutoString *)(v30 - 208));
  AutoString::~AutoString((AutoString *)&a11);
  AutoString::~AutoString((AutoString *)&a30);
  _Unwind_Resume(a1);
}

__CFArray *_createCookiesWithCookieStrings(const __CFAllocator *a1, const void *a2, const __CFURL *a3, const void *a4, int a5)
{
  __CFArray *Mutable;
  uint64_t (*v11)(const __CFAllocator *, char **, CFTypeRef *, const __CFURL *, const void *);
  unint64_t Count;
  CFRange v13;
  const void **v14;
  CFIndex v15;
  const __CFString *v16;
  CFIndex Length;
  unsigned __int8 *v18;
  CFIndex Bytes;
  unsigned int v20;
  BOOL v21;
  BOOL v22;
  CFIndex v23;
  unsigned int v24;
  _BOOL4 v26;
  NSObject *v28;
  const __CFArray *v29;
  CFIndex v30;
  int v31;
  NSObject *v32;
  const void *ValueAtIndex;
  char *v34;
  char *v35;
  char *v36;
  CFIndex i;
  void *v38;
  uint64_t v39;
  _DWORD *v40;
  const __CFString *v41;
  const __CFString *v42;
  uint64_t v43;
  _DWORD *v44;
  _BOOL4 v45;
  char *v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  int v52;
  uint64_t j;
  uint64_t v54;
  int theString2;
  CFArrayRef theArray;
  unsigned __int8 *v58;
  CFTypeRef v59;
  CFIndex range;
  const void **v61;
  _BYTE v62[248];
  CFIndex v63;
  uint8_t buf[4];
  _BYTE v65[14];
  uint64_t v66;
  CFRange v67;
  CFRange v68;

  v66 = *MEMORY[0x1E0C80C00];
  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  theString2 = a5;
  if (a5)
    v11 = SingleCookieParser_parse;
  else
    v11 = CookieParser_parse;
  if (a2)
  {
    v59 = CFRetain(a2);
    Count = CFArrayGetCount((CFArrayRef)a2);
    v13.length = Count;
    range = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v61 = 0;
    }
    else
    {
      if (Count <= 0x1E)
      {
        v14 = (const void **)v62;
        v61 = (const void **)v62;
LABEL_12:
        v13.location = 0;
        CFArrayGetValues((CFArrayRef)a2, v13, v14);
        goto LABEL_13;
      }
      v14 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
      v61 = v14;
      if (v14)
      {
        v13.length = range;
        goto LABEL_12;
      }
    }
  }
  else
  {
    v59 = 0;
    range = 0;
    v61 = (const void **)v62;
  }
LABEL_13:
  v63 = 0;
  if (range >= 1)
  {
    v15 = 0;
    while (1)
    {
      v63 = v15 + 1;
      v16 = (const __CFString *)v61[v15];
      Length = CFStringGetLength(v16);
      v18 = (unsigned __int8 *)CFAllocatorAllocate(a1, Length + 4, 0);
      bzero(v18, Length + 4);
      v67.location = 0;
      v67.length = Length;
      Bytes = CFStringGetBytes(v16, v67, 0x201u, 0, 0, v18, Length, 0);
      v58 = v18;
      if (Bytes < 1)
        goto LABEL_38;
      v20 = *v18;
      v21 = v20 >= 0x20 || v20 == 9;
      v22 = !v21;
      if (v20 != 127 && !v22)
        break;
LABEL_56:
      CFAllocatorDeallocate(a1, v18);
LABEL_57:
      v15 = v63;
      if (v63 >= range)
        goto LABEL_58;
    }
    v23 = 0;
    while (Bytes - 1 != v23)
    {
      v24 = v18[v23 + 1];
      v26 = v24 < 0x20 && v24 != 9;
      ++v23;
      if (v24 == 127 || v26)
      {
        if (v23 >= Bytes)
          break;
        goto LABEL_56;
      }
    }
LABEL_38:
    theArray = 0;
    if (v11(a1, (char **)&v58, (CFTypeRef *)&theArray, a3, a4))
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v28 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v65 = v18;
        _os_log_error_impl(&dword_183ECA000, v28, OS_LOG_TYPE_ERROR, "Cookie parser failed: %s", buf, 0xCu);
      }
    }
    v29 = theArray;
    if (theArray)
    {
      if (theString2)
      {
        v30 = CFArrayGetCount(theArray);
        v31 = v30;
        if (v30 >= 1)
        {
          if (v30 != 1)
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v32 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109378;
              *(_DWORD *)v65 = v31;
              *(_WORD *)&v65[4] = 2080;
              *(_QWORD *)&v65[6] = v18;
              _os_log_error_impl(&dword_183ECA000, v32, OS_LOG_TYPE_ERROR, "Only using the first cookie out of %d parsed: %s", buf, 0x12u);
            }
          }
          ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
          CFArrayAppendValue(Mutable, ValueAtIndex);
        }
      }
      else
      {
        v68.length = CFArrayGetCount(theArray);
        v68.location = 0;
        CFArrayAppendArray(Mutable, v29, v68);
      }
      if (theArray)
        CFRelease(theArray);
    }
    if (!v18)
      goto LABEL_57;
    goto LABEL_56;
  }
LABEL_58:
  v34 = 0;
  v35 = 0;
  v36 = 0;
  for (i = 0; CFArrayGetCount(Mutable) > i; ++i)
  {
    v38 = (void *)CFArrayGetValueAtIndex(Mutable, i);
    v39 = objc_msgSend(v38, "_inner");
    v40 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v39 + 16))(v39);
    if (*v40 < 0xCu || (v40[2] & 1) == 0)
      goto LABEL_72;
    if (a3)
    {
      v41 = CFURLCopyScheme(a3);
      v42 = v41;
      if (!v41)
        goto LABEL_72;
      v45 = 0;
      if (CFStringCompare(v41, CFSTR("http"), 1uLL) == kCFCompareEqualTo
        || CFStringCompare(v42, CFSTR("ws"), 1uLL) == kCFCompareEqualTo)
      {
        v43 = objc_msgSend(v38, "_inner");
        v44 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v43 + 16))(v43);
        if (*v44 >= 0xCu && (v44[2] & 1) != 0)
          v45 = 1;
      }
      CFRelease(v42);
      if (!v45)
        goto LABEL_72;
    }
    if (v35 < v36)
    {
      *(_DWORD *)v35 = i;
      v35 += 4;
LABEL_72:
      v46 = v35;
      goto LABEL_73;
    }
    v47 = (v35 - v34) >> 2;
    v48 = v47 + 1;
    if ((unint64_t)(v47 + 1) >> 62)
      abort();
    if ((v36 - v34) >> 1 > v48)
      v48 = (v36 - v34) >> 1;
    if ((unint64_t)(v36 - v34) >= 0x7FFFFFFFFFFFFFFCLL)
      v49 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v49 = v48;
    if (v49)
    {
      if (v49 >> 62)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v50 = (char *)operator new(4 * v49);
    }
    else
    {
      v50 = 0;
    }
    v51 = &v50[4 * v47];
    *(_DWORD *)v51 = i;
    v46 = v51 + 4;
    while (v35 != v34)
    {
      v52 = *((_DWORD *)v35 - 1);
      v35 -= 4;
      *((_DWORD *)v51 - 1) = v52;
      v51 -= 4;
    }
    v36 = &v50[4 * v49];
    if (v34)
      operator delete(v34);
    v34 = v51;
LABEL_73:
    v35 = v46;
  }
  for (j = (v35 - v34) >> 2; j > 0; j = v54)
  {
    v54 = j - 1;
    CFArrayRemoveValueAtIndex(Mutable, *(int *)&v34[4 * j - 4]);
  }
  if (v34)
    operator delete(v34);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v59);
  return Mutable;
}

void sub_183F72EB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  void *v18;

  if (v18)
    operator delete(v18);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a18);
  _Unwind_Resume(a1);
}

BOOL CFHTTPCookie_domainMatches(OpaqueCFHTTPCookie *a1, const __CFURL *a2)
{
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  const char *v9;
  const char *v10;
  _BOOL8 v11;
  size_t v12;
  size_t v13;
  const __CFAllocator *v14;
  const __CFString *v15;
  uint64_t Length;
  CFIndex v17;
  CFIndex v18;
  int CharacterFromSet;
  uint64_t v20;
  BOOL v21;
  const __CFURL *v22;
  const char *v23;
  CookieUtils *v24;
  const unsigned __int8 *v25;
  int v26;
  CookieUtils *v28;
  const char *v29;
  CFRange v30;
  void (**v31)(AutoString *__hidden);
  __CFString *v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  CFRange v37;
  CFRange v38;

  v36 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 1;
  v4 = -[OpaqueCFHTTPCookie _inner](a1, "_inner");
  v5 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  if (*v5 < 0x14)
    return 0;
  v6 = v5[4];
  if (!(_DWORD)v6)
    return 0;
  v7 = *v5;
  if (v7 <= v6)
    return 0;
  v8 = (char *)v5 + v6;
  v9 = (char *)v5 + v7;
  v10 = v8;
  while (*v10)
  {
    if (++v10 >= v9)
      return 0;
  }
  v12 = strlen(v8);
  if (!v12)
    return 0;
  v13 = v12;
  v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v31 = &off_1E14E4818;
  v15 = CFStringCreateWithCString(v14, v8, 0x8000100u);
  v33 = 0;
  v34 = 0;
  v32 = (__CFString *)v15;
  Length = CFStringGetLength(v15);
  if (CFStringCompare(CFSTR(".^filecookies^"), v15, 0))
  {
    if (!looksLikeDomainName(__CFString const*)::allowedSymbolsSet)
      looksLikeDomainName(__CFString const*)::allowedSymbolsSet = (uint64_t)CFCharacterSetCreateWithCharactersInString(0, CFSTR("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-_[]:"));
    if (Length >= 1)
    {
      v17 = 0;
      v18 = 0;
      while (1)
      {
        v30.location = 0;
        v30.length = 0;
        v37.location = v17;
        v37.length = Length;
        CharacterFromSet = CFStringFindCharacterFromSet(v15, (CFCharacterSetRef)looksLikeDomainName(__CFString const*)::allowedSymbolsSet, v37, 0, &v30);
        if (Length != 1 && !CharacterFromSet)
          break;
        if (v30.location > v17 + 2)
          break;
        if (v30.location == v17 + 2)
        {
          v38.location = v17;
          v38.length = 2;
          if (CFStringCompareWithOptions(v15, CFSTR("--"), v38, 0))
            break;
          v17 += 3;
          v20 = -3;
        }
        else if (v30.location == v17)
        {
          if (v18 == v17 && CFStringGetCharacterAtIndex(v15, v17) == 45)
            break;
          ++v17;
          v20 = -1;
        }
        else
        {
          if (CFStringGetCharacterAtIndex(v15, v17) != 46 || v17 && CFStringGetCharacterAtIndex(v15, v17 - 1) == 45)
            break;
          v18 = v17 + 1;
          v20 = -2;
          v17 += 2;
        }
        v21 = __OFADD__(v20, Length);
        Length += v20;
        if ((Length < 0) ^ v21 | (Length == 0))
          goto LABEL_32;
      }
      AutoString::~AutoString((AutoString *)&v31);
      return 0;
    }
  }
LABEL_32:
  AutoString::~AutoString((AutoString *)&v31);
  CFGetAllocator(a1);
  CookieHostName::CookieHostName((CookieHostName *)&v31, a2, v22);
  if (v33)
    v24 = (CookieUtils *)((char *)&v32->isa + 1);
  else
    v24 = 0;
  if (CookieUtils::looksLikeIPAddress(v24, v23))
  {
    v26 = strcmp(v8, (const char *)&v32->isa + 1);
  }
  else
  {
    if (*v8 == 46)
    {
      if (v33)
        v28 = (CookieUtils *)v32;
      else
        v28 = 0;
      v11 = CookieUtils::web_domainMatches_LCC_LCC(v28, v8, v25);
      goto LABEL_50;
    }
    if (v33)
      v29 = (char *)&v32->isa + 1;
    else
      v29 = 0;
    v26 = strncmp(v29, v8, v13 - (v8[v13] == 46));
  }
  v11 = v26 == 0;
LABEL_50:
  v31 = &off_1E14E6B50;
  if (v35 != &v34)
    free(v35);
  return v11;
}

void sub_183F73214(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46)
{
  _Unwind_Resume(exception_object);
}

uint64_t CookieParser_parse(const __CFAllocator *a1, char **a2, CFTypeRef *a3, const __CFURL *a4, const void *a5)
{
  uint64_t v6;
  signed int v7;
  unint64_t v8;
  __int16 *v9;
  char *v10;
  CFTypeRef *v11;
  uint64_t v12;
  uint64_t v13;
  __int16 *v14;
  __int16 *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int v20;
  uint64_t v21;
  signed int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  const __CFString *v26;
  signed int v27;
  int v28;
  __CFArray *Mutable;
  const void *v30;
  int v31;
  int v32;
  CFMutableArrayRef v33;
  const __CFString *Cookie;
  const void *ValueAtIndex;
  const void *v36;
  CFTypeRef v37;
  CFAbsoluteTime AbsoluteTime;
  CFDateRef v39;
  char v40;
  const void *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  CFTypeRef *v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  __int16 *v53;
  CFTypeRef *v54;
  uint64_t v55;
  uint64_t v57;
  CFTypeRef *v58;
  CFDateRef cf;
  __CFDictionary *theDicta;
  int theDict;
  int v66;
  _BYTE *__src;
  int64_t v68;
  CFTimeZoneRef tz;
  CFStringRef v70;
  void *v71;
  const __CFString *v72;
  CFGregorianDate values;
  _BYTE v74[1600];
  _BYTE v75[400];
  uint64_t v76;

  v66 = 0;
  v6 = 0;
  v7 = 0u;
  __src = v74;
  v76 = *MEMORY[0x1E0C80C00];
  v8 = 200;
  v70 = 0;
  v9 = (__int16 *)v75;
  v10 = v75;
  v11 = (CFTypeRef *)v74;
  v12 = 4294967294;
  while (1)
  {
    *(_WORD *)v10 = v7;
    if (&v9[v8 - 1] <= (__int16 *)v10)
    {
      if (v8 >> 4 > 0x270
        || (2 * v8 >= 0x2710 ? (v13 = 10000) : (v13 = 2 * v8),
            (v14 = (__int16 *)malloc_type_malloc(10 * v13 + 7, 0x2EE69A94uLL)) == 0))
      {
        LODWORD(v25) = 0;
        v57 = 2;
        goto LABEL_91;
      }
      v15 = v14;
      v16 = v12;
      v12 = v6;
      v17 = (v10 - (char *)v9) >> 1;
      v18 = v17 + 1;
      memcpy(v14, v9, 2 * (v17 + 1));
      v68 = v13;
      v19 = (char *)v15 + ((2 * v13 + 7) & 0xFFFFFFFFFFFFFFF8);
      memcpy(v19, __src, 8 * (v17 + 1));
      if (v9 != (__int16 *)v75)
        free(v9);
      v10 = (char *)&v15[v17];
      v11 = (CFTypeRef *)&v19[8 * v18 - 8];
      if (v68 <= v18)
      {
        LODWORD(v25) = 0;
        v57 = 1;
        v9 = v15;
        LODWORD(v6) = v12;
        LODWORD(v12) = v16;
        goto LABEL_91;
      }
      v9 = v15;
      __src = v19;
      v6 = v12;
      v12 = v16;
    }
    else
    {
      v68 = v8;
    }
    if (((0x5CB2FF9BCD0FFCuLL >> v7) & 1) != 0)
      break;
    v20 = yypact_19733[v7];
    if ((_DWORD)v12 == -2)
      v12 = CookieParser_lex(&v70, a1, a2);
    if ((int)v12 < 1)
    {
      v6 = 0;
      v12 = 0u;
    }
    else
    {
      v6 = v12 > 0x10D ? 2 : yytranslate_19734[v12];
    }
    v21 = (v6 + v20);
    if (v21 > 0x57 || (_DWORD)v6 != yycheck_19735[v21])
      break;
    v22 = yytable_19736[v21];
    if (!yytable_19736[v21])
      goto LABEL_34;
    if ((_DWORD)v21 == 6)
    {
      LODWORD(v25) = 0;
      v57 = 0;
      goto LABEL_91;
    }
    v23 = v66 - 1;
    if (!v66)
      v23 = 0;
    v66 = v23;
    if ((_DWORD)v12)
      v12 = 4294967294;
    else
      v12 = 0;
    v11[1] = v70;
    ++v11;
    v7 = v22;
LABEL_85:
    v10 += 2;
    v8 = v68;
  }
  if (((0x20010000129003uLL >> v7) & 1) == 0)
  {
    v24 = yydefact_19737[v7];
    v25 = yyr2_19738[v24];
    switch(v7)
    {
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 22:
      case 24:
      case 28:
      case 29:
      case 31:
      case 32:
      case 41:
      case 49:
      case 51:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124:
      case 125:
      case 126:
      case 127:
      case 128:
      case 129:
      case 130:
      case 131:
      case 132:
      case 133:
      case 134:
      case 135:
      case 136:
      case 137:
      case 138:
      case 139:
      case 140:
      case 141:
      case 142:
        goto LABEL_33;
      case 13:
      case 60:
      case 61:
      case 64:
      case 67:
      case 68:
      case 71:
      case 73:
        v58 = v11;
        goto LABEL_105;
      case 14:
      case 63:
        v28 = yyr2_19738[yydefact_19737[v7]];
        Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
        v26 = (const __CFString *)Mutable;
        if (!*v11)
          goto LABEL_80;
        CFArrayAppendValue(Mutable, *v11);
        goto LABEL_78;
      case 16:
        v32 = yyr2_19738[yydefact_19737[v7]];
        v33 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
        goto LABEL_55;
      case 19:
      case 56:
      case 57:
      case 62:
      case 66:
      case 69:
      case 72:
      case 96:
        v58 = v11 - 1;
LABEL_105:
        v57 = 0;
        *a3 = *v58;
        goto LABEL_91;
      case 21:
      case 26:
      case 30:
      case 42:
        v32 = yyr2_19738[yydefact_19737[v7]];
        v33 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
LABEL_55:
        LODWORD(v25) = v32;
        v26 = (const __CFString *)v33;
        break;
      case 23:
        v30 = *(v11 - 2);
        if (v30)
        {
          v31 = yyr2_19738[yydefact_19737[v7]];
          CFArrayInsertValueAtIndex((CFMutableArrayRef)*v11, 0, v30);
          CFRelease(*(v11 - 2));
          LODWORD(v25) = v31;
        }
LABEL_33:
        v26 = (const __CFString *)*v11;
        break;
      case 25:
        v26 = CFSTR("=");
        break;
      case 27:
        v28 = yyr2_19738[yydefact_19737[v7]];
        Cookie = (const __CFString *)_makeCookie(a1, *(v11 - 2), &stru_1E1500C68, (const __CFDictionary *)*v11, a4, a5);
        goto LABEL_66;
      case 33:
        v42 = yyr2_19738[yydefact_19737[v7]];
        CFRelease(*v11);
        LODWORD(v25) = v42;
        v26 = (const __CFString *)&unk_1EDCFC630;
        break;
      case 34:
        v43 = yyr2_19738[yydefact_19737[v7]];
        CFRelease(*v11);
        LODWORD(v25) = v43;
        v26 = (const __CFString *)&unk_1EDCFC710;
        break;
      case 35:
        v44 = yyr2_19738[yydefact_19737[v7]];
        CFRelease(*v11);
        LODWORD(v25) = v44;
        v26 = (const __CFString *)&unk_1EDCFC7F0;
        break;
      case 36:
        v48 = yyr2_19738[yydefact_19737[v7]];
        CFRelease(*v11);
        LODWORD(v25) = v48;
        v26 = (const __CFString *)&unk_1EDCFC898;
        break;
      case 37:
        v45 = yyr2_19738[yydefact_19737[v7]];
        CFRelease(*v11);
        LODWORD(v25) = v45;
        v26 = (const __CFString *)&unk_1EDCFC940;
        break;
      case 38:
        v47 = yyr2_19738[yydefact_19737[v7]];
        CFRelease(*v11);
        LODWORD(v25) = v47;
        v26 = (const __CFString *)&unk_1EDCFC7B8;
        break;
      case 39:
        v46 = yyr2_19738[yydefact_19737[v7]];
        CFRelease(*v11);
        LODWORD(v25) = v46;
        v26 = (const __CFString *)&unk_1EDCFCA20;
        break;
      case 43:
        *(_QWORD *)&values.year = 0;
        values.second = 0.0;
        *(_QWORD *)&values.year = *v11;
        *(_QWORD *)&values.second = &stru_1E1500C68;
        v28 = v25;
        v26 = (const __CFString *)CFArrayCreate(a1, (const void **)&values, 2, MEMORY[0x1E0C9B378]);
        goto LABEL_78;
      case 44:
        v28 = yyr2_19738[v24];
        v26 = CFStringCreateWithFormat(a1, 0, CFSTR("%@%@"), *(v11 - 1), *v11);
        goto LABEL_76;
      case 45:
        v28 = yyr2_19738[yydefact_19737[v7]];
        v26 = (const __CFString *)_makeCookie(a1, *(v11 - 3), *(v11 - 1), (const __CFDictionary *)*v11, a4, a5);
        CFRelease(*(v11 - 3));
LABEL_76:
        v41 = *(v11 - 1);
        goto LABEL_77;
      case 46:
      case 48:
        *(_QWORD *)&values.year = 0;
        values.second = 0.0;
        *(_QWORD *)&values.year = *(v11 - 1);
        *(_QWORD *)&values.second = &stru_1E1500C68;
        v28 = v25;
        v26 = (const __CFString *)CFArrayCreate(a1, (const void **)&values, 2, MEMORY[0x1E0C9B378]);
        goto LABEL_57;
      case 47:
        theDicta = (__CFDictionary *)*v11;
        v28 = yyr2_19738[v24];
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)*(v11 - 1), 0);
        v36 = CFArrayGetValueAtIndex((CFArrayRef)*(v11 - 1), 1);
        CFDictionaryAddValue(theDicta, ValueAtIndex, v36);
        v26 = (const __CFString *)*v11;
LABEL_57:
        v37 = *(v11 - 1);
        goto LABEL_79;
      case 50:
        theDict = yyr2_19738[yydefact_19737[v7]];
        *(_QWORD *)&values.year = 0;
        values.second = 0.0;
        tz = 0;
        v71 = &unk_1EDCFC748;
        v72 = &stru_1E1500C68;
        _CFGregorianDateCreateWithString(a1, (CFStringRef)*v11, (uint64_t)&values, (CFTypeRef *)&tz);
        if (!values.year)
          goto LABEL_86;
        AbsoluteTime = CFGregorianDateGetAbsoluteTime(values, tz);
        v39 = CFDateCreate(a1, AbsoluteTime);
        if (tz)
          CFRelease(tz);
        if (v39)
        {
          v40 = 0;
          cf = v39;
          v72 = (const __CFString *)v39;
        }
        else
        {
LABEL_86:
          cf = 0;
          v40 = 1;
        }
        v26 = (const __CFString *)CFArrayCreate(a1, (const void **)&v71, 2, MEMORY[0x1E0C9B378]);
        CFRelease(*(v11 - 2));
        CFRelease(*v11);
        if ((v40 & 1) == 0)
          CFRelease(cf);
        LODWORD(v25) = theDict;
        break;
      case 52:
        *(_QWORD *)&values.year = 0;
        values.second = 0.0;
        *(_QWORD *)&values.year = *(v11 - 2);
        *(_QWORD *)&values.second = *v11;
        v28 = v25;
        Cookie = (const __CFString *)CFArrayCreate(a1, (const void **)&values, 2, MEMORY[0x1E0C9B378]);
        goto LABEL_66;
      case 54:
      case 100:
        v28 = yyr2_19738[v24];
        Cookie = CFStringCreateWithFormat(a1, 0, CFSTR("%@, %@"), *(v11 - 2), *v11);
LABEL_66:
        v26 = Cookie;
        v41 = *(v11 - 2);
LABEL_77:
        CFRelease(v41);
LABEL_78:
        v37 = *v11;
LABEL_79:
        CFRelease(v37);
LABEL_80:
        LODWORD(v25) = v28;
        break;
      default:
        v26 = (const __CFString *)v11[1 - v25];
        break;
    }
    v49 = &v11[-v25];
    v10 -= 2 * v25;
    v49[1] = v26;
    v11 = v49 + 1;
    v50 = yyr1_19750[v24] - 18;
    v51 = (*(__int16 *)v10 + yypgoto_19751[v50]);
    if (v51 <= 0x57 && *(unsigned __int16 *)v10 == (unsigned __int16)yycheck_19735[v51])
      v7 = yytable_19736[v51];
    else
      v7 = yydefgoto_19752[v50];
    goto LABEL_85;
  }
LABEL_34:
  if (v66 == 3)
  {
    if ((int)v12 > 0)
    {
      yydestruct_19755(v6, (CFTypeRef *)&v70);
      v12 = 4294967294;
      goto LABEL_39;
    }
    if (!(_DWORD)v12)
    {
      LODWORD(v25) = 0;
      v57 = 1;
      goto LABEL_94;
    }
  }
  while (1)
  {
LABEL_39:
    if (((0x5CB2FF9BCD0FFCuLL >> v7) & 1) == 0 && ((0x234D006432D003uLL >> v7) & 1) != 0 && yypact_19733[v7] == 2)
    {
      v11[1] = v70;
      ++v11;
      v7 = 1u;
      v66 = 3;
      goto LABEL_85;
    }
    if (v10 == (char *)v9)
      break;
    yydestruct_19755(yystos_19756[v7], v11--);
    v27 = *((__int16 *)v10 - 1);
    v10 -= 2;
    v7 = v27;
  }
  LODWORD(v25) = 0;
  v57 = 1;
  v10 = (char *)v9;
LABEL_91:
  if ((_DWORD)v12 != -2 && (_DWORD)v12)
  {
    v52 = v25;
    yydestruct_19755(v6, (CFTypeRef *)&v70);
    LODWORD(v25) = v52;
  }
LABEL_94:
  v53 = (__int16 *)&v10[-2 * v25];
  if (v53 != v9)
  {
    v54 = &v11[-v25];
    do
    {
      v55 = *v53--;
      yydestruct_19755(yystos_19756[v55], v54--);
    }
    while (v53 != v9);
  }
  if (v9 != (__int16 *)v75)
    free(v9);
  return v57;
}

uint64_t SingleCookieParser_parse(const __CFAllocator *a1, char **a2, CFTypeRef *a3, const __CFURL *a4, const void *a5)
{
  uint64_t v6;
  signed int v7;
  unint64_t v8;
  __int16 *v9;
  char *v10;
  CFTypeRef *v11;
  uint64_t v12;
  uint64_t v13;
  __int16 *v14;
  __int16 *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int v20;
  uint64_t v21;
  signed int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  const __CFString *Cookie;
  signed int v27;
  __CFArray *Mutable;
  CFMutableArrayRef v29;
  const __CFString *v30;
  const void *ValueAtIndex;
  const void *v32;
  CFTypeRef v33;
  const __CFString *v34;
  CFAbsoluteTime AbsoluteTime;
  CFDateRef v36;
  char v37;
  const void *v38;
  CFTypeRef *v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  __int16 *v43;
  CFTypeRef *v44;
  uint64_t v45;
  uint64_t v47;
  CFTypeRef *v48;
  __CFDictionary *theDicta;
  CFMutableDictionaryRef theDict;
  int v51;
  int v56;
  _BYTE *__src;
  int64_t v58;
  CFTimeZoneRef tz;
  CFStringRef v60;
  void *v61;
  const __CFString *v62;
  CFGregorianDate values;
  _BYTE v64[1600];
  _BYTE v65[400];
  uint64_t v66;

  v56 = 0;
  v6 = 0;
  v7 = 0u;
  __src = v64;
  v66 = *MEMORY[0x1E0C80C00];
  v8 = 200;
  v60 = 0;
  v9 = (__int16 *)v65;
  v10 = v65;
  v11 = (CFTypeRef *)v64;
  v12 = 4294967294;
  while (1)
  {
    *(_WORD *)v10 = v7;
    if (&v9[v8 - 1] <= (__int16 *)v10)
    {
      if (v8 >> 4 > 0x270
        || (2 * v8 >= 0x2710 ? (v13 = 10000) : (v13 = 2 * v8),
            (v14 = (__int16 *)malloc_type_malloc(10 * v13 + 7, 0x309D3248uLL)) == 0))
      {
        LODWORD(v25) = 0;
        v47 = 2;
        goto LABEL_92;
      }
      v15 = v14;
      v16 = v12;
      v12 = v6;
      v17 = (v10 - (char *)v9) >> 1;
      v18 = v17 + 1;
      memcpy(v14, v9, 2 * (v17 + 1));
      v58 = v13;
      v19 = (char *)v15 + ((2 * v13 + 7) & 0xFFFFFFFFFFFFFFF8);
      memcpy(v19, __src, 8 * (v17 + 1));
      if (v9 != (__int16 *)v65)
        free(v9);
      v10 = (char *)&v15[v17];
      v11 = (CFTypeRef *)&v19[8 * v18 - 8];
      if (v58 <= v18)
      {
        LODWORD(v25) = 0;
        v47 = 1;
        v9 = v15;
        LODWORD(v6) = v12;
        LODWORD(v12) = v16;
        goto LABEL_92;
      }
      v9 = v15;
      __src = v19;
      v6 = v12;
      v12 = v16;
    }
    else
    {
      v58 = v8;
    }
    if (((0x5CB97FD3274FFCuLL >> v7) & 1) != 0)
      break;
    v20 = yypact[v7];
    if ((_DWORD)v12 == -2)
      v12 = CookieParser_lex(&v60, a1, a2);
    if ((int)v12 < 1)
    {
      v6 = 0;
      v12 = 0u;
    }
    else
    {
      v6 = v12 > 0x10D ? 2 : yytranslate[v12];
    }
    v21 = (v6 + v20);
    if (v21 > 0x67 || (_DWORD)v6 != yycheck[v21])
      break;
    v22 = yytable[v21];
    if (!yytable[v21])
      goto LABEL_34;
    if ((_DWORD)v21 == 18)
    {
      LODWORD(v25) = 0;
      v47 = 0;
      goto LABEL_92;
    }
    v23 = v56 - 1;
    if (!v56)
      v23 = 0;
    v56 = v23;
    if ((_DWORD)v12)
      v12 = 4294967294;
    else
      v12 = 0;
    v11[1] = v60;
    ++v11;
    v7 = v22;
LABEL_85:
    v10 += 2;
    v8 = v58;
  }
  if (((0x20008000009003uLL >> v7) & 1) == 0)
  {
    v24 = yydefact[v7];
    v25 = yyr2[v24];
    switch((int)v24)
    {
      case 2:
        v48 = v11 - 1;
        goto LABEL_106;
      case 3:
        v48 = v11;
LABEL_106:
        v47 = 0;
        *a3 = *v48;
        goto LABEL_92;
      case 4:
        Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
        Cookie = (const __CFString *)Mutable;
        if (!*v11)
          break;
        CFArrayAppendValue(Mutable, *v11);
        goto LABEL_79;
      case 5:
        v29 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
        goto LABEL_54;
      case 6:
        Cookie = (const __CFString *)_makeCookie(a1, *(v11 - 3), *(v11 - 1), (const __CFDictionary *)*v11, a4, a5);
        CFRelease(*(v11 - 3));
        goto LABEL_74;
      case 7:
        v30 = (const __CFString *)_makeCookie(a1, *(v11 - 2), &stru_1E1500C68, (const __CFDictionary *)*v11, a4, a5);
        goto LABEL_65;
      case 8:
        v29 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
LABEL_54:
        Cookie = (const __CFString *)v29;
        break;
      case 9:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 35:
      case 36:
      case 38:
      case 40:
      case 45:
        Cookie = (const __CFString *)*v11;
        break;
      case 10:
        theDicta = (__CFDictionary *)*v11;
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)*(v11 - 1), 0);
        v32 = CFArrayGetValueAtIndex((CFArrayRef)*(v11 - 1), 1);
        CFDictionaryAddValue(theDicta, ValueAtIndex, v32);
        Cookie = (const __CFString *)*v11;
        goto LABEL_56;
      case 11:
        *(_QWORD *)&values.year = 0;
        values.second = 0.0;
        *(_QWORD *)&values.year = *(v11 - 2);
        *(_QWORD *)&values.second = *v11;
        v30 = (const __CFString *)CFArrayCreate(a1, (const void **)&values, 2, MEMORY[0x1E0C9B378]);
        goto LABEL_65;
      case 12:
      case 15:
        *(_QWORD *)&values.year = 0;
        values.second = 0.0;
        *(_QWORD *)&values.year = *(v11 - 1);
        *(_QWORD *)&values.second = &stru_1E1500C68;
        Cookie = (const __CFString *)CFArrayCreate(a1, (const void **)&values, 2, MEMORY[0x1E0C9B378]);
LABEL_56:
        v33 = *(v11 - 1);
        goto LABEL_80;
      case 13:
        *(_QWORD *)&values.year = 0;
        values.second = 0.0;
        *(_QWORD *)&values.year = *v11;
        *(_QWORD *)&values.second = &stru_1E1500C68;
        v34 = (const __CFString *)CFArrayCreate(a1, (const void **)&values, 2, MEMORY[0x1E0C9B378]);
        goto LABEL_78;
      case 14:
        *(_QWORD *)&values.year = 0;
        values.second = 0.0;
        tz = 0;
        v61 = &unk_1EDCFC748;
        v62 = &stru_1E1500C68;
        _CFGregorianDateCreateWithString(a1, (CFStringRef)*v11, (uint64_t)&values, (CFTypeRef *)&tz);
        v51 = v25;
        if (!values.year)
          goto LABEL_87;
        AbsoluteTime = CFGregorianDateGetAbsoluteTime(values, tz);
        v36 = CFDateCreate(a1, AbsoluteTime);
        if (tz)
          CFRelease(tz);
        if (v36)
        {
          v37 = 0;
          theDict = v36;
          v62 = (const __CFString *)v36;
        }
        else
        {
LABEL_87:
          theDict = 0;
          v37 = 1;
        }
        Cookie = (const __CFString *)CFArrayCreate(a1, (const void **)&v61, 2, MEMORY[0x1E0C9B378]);
        CFRelease(*(v11 - 2));
        CFRelease(*v11);
        if ((v37 & 1) == 0)
          CFRelease(theDict);
        LODWORD(v25) = v51;
        break;
      case 16:
        v30 = CFStringCreateWithFormat(a1, 0, CFSTR("%@, %@"), *(v11 - 2), *v11);
LABEL_65:
        Cookie = v30;
        v38 = *(v11 - 2);
        goto LABEL_75;
      case 28:
        CFRelease(*v11);
        Cookie = (const __CFString *)&unk_1EDCFC630;
        break;
      case 29:
        CFRelease(*v11);
        Cookie = (const __CFString *)&unk_1EDCFC710;
        break;
      case 30:
        CFRelease(*v11);
        Cookie = (const __CFString *)&unk_1EDCFC7F0;
        break;
      case 31:
        CFRelease(*v11);
        Cookie = (const __CFString *)&unk_1EDCFC940;
        break;
      case 32:
        CFRelease(*v11);
        Cookie = (const __CFString *)&unk_1EDCFCA20;
        break;
      case 33:
        CFRelease(*v11);
        Cookie = (const __CFString *)&unk_1EDCFC7B8;
        break;
      case 34:
        CFRelease(*v11);
        Cookie = (const __CFString *)&unk_1EDCFC898;
        break;
      case 37:
      case 44:
        Cookie = CFSTR("=");
        break;
      case 39:
        Cookie = CFStringCreateWithFormat(a1, 0, CFSTR("%@%@"), *(v11 - 1), *v11);
LABEL_74:
        v38 = *(v11 - 1);
LABEL_75:
        CFRelease(v38);
        goto LABEL_79;
      case 41:
        v34 = CFStringCreateWithFormat(a1, 0, CFSTR(",%@"), *v11);
        goto LABEL_78;
      case 42:
        v34 = CFStringCreateWithFormat(a1, 0, CFSTR("=%@"), *v11);
LABEL_78:
        Cookie = v34;
LABEL_79:
        v33 = *v11;
LABEL_80:
        CFRelease(v33);
        break;
      case 43:
        Cookie = CFSTR(",");
        break;
      default:
        Cookie = (const __CFString *)v11[1 - v25];
        break;
    }
    v39 = &v11[-v25];
    v10 -= 2 * v25;
    v39[1] = Cookie;
    v11 = v39 + 1;
    v40 = yyr1[v24] - 18;
    v41 = (*(__int16 *)v10 + yypgoto[v40]);
    if (v41 <= 0x67 && *(unsigned __int16 *)v10 == (unsigned __int16)yycheck[v41])
      v7 = yytable[v41];
    else
      v7 = yydefgoto[v40];
    goto LABEL_85;
  }
LABEL_34:
  if (v56 == 3)
  {
    if ((int)v12 > 0)
    {
      yydestruct(v6, (CFTypeRef *)&v60);
      v12 = 4294967294;
      goto LABEL_39;
    }
    if (!(_DWORD)v12)
    {
      LODWORD(v25) = 0;
      v47 = 1;
      goto LABEL_95;
    }
  }
  while (1)
  {
LABEL_39:
    if (((0x5CB97FD3274FFCuLL >> v7) & 1) == 0 && ((0x2346802CD8B001uLL >> v7) & 1) != 0 && yypact[v7] == 65)
    {
      v11[1] = v60;
      ++v11;
      v7 = 1u;
      v56 = 3;
      goto LABEL_85;
    }
    if (v10 == (char *)v9)
      break;
    yydestruct(yystos[v7], v11--);
    v27 = *((__int16 *)v10 - 1);
    v10 -= 2;
    v7 = v27;
  }
  LODWORD(v25) = 0;
  v47 = 1;
  v10 = (char *)v9;
LABEL_92:
  if ((_DWORD)v12 != -2 && (_DWORD)v12)
    yydestruct(v6, (CFTypeRef *)&v60);
LABEL_95:
  v42 = v25;
  v43 = (__int16 *)&v10[-2 * v25];
  if (v43 != v9)
  {
    v44 = &v11[-v42];
    do
    {
      v45 = *v43--;
      yydestruct(yystos[v45], v44--);
    }
    while (v43 != v9);
  }
  if (v9 != (__int16 *)v65)
    free(v9);
  return v47;
}

uint64_t CookieParser_lex(CFStringRef *a1, CFAllocatorRef alloc, char **a3)
{
  const UInt8 *v6;
  char *v7;
  uint64_t result;
  char *v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  char *v23;
  char *v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  char *v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  BOOL v42;
  char *v43;
  CFStringRef v44;
  CFStringRef v45;
  CFStringRef v46;
  CFStringRef v47;
  CFStringRef v48;
  CFStringRef v49;
  CFStringRef v50;
  CFStringRef v51;
  CFStringRef v52;
  char v53;
  int v54;
  CFStringRef v55;
  CFStringRef v56;
  uint64_t v57;
  unsigned int v58;
  char v59;

  v6 = (const UInt8 *)*a3;
  *a1 = 0;
  while (2)
  {
    switch(*v6)
    {
      case 0u:
        goto LABEL_112;
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 0xBu:
      case 0xCu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x2Cu:
      case 0x3Bu:
      case 0x3Du:
      case 0x7Fu:
        v7 = (char *)(v6 + 1);
        result = *(char *)v6;
        goto LABEL_229;
      case 9u:
      case 0x20u:
        ++v6;
        continue;
      case 0xAu:
        v7 = (char *)(v6 + 1);
        if (*((char *)v6 + 1) < 1)
          goto LABEL_111;
        result = 10;
        goto LABEL_229;
      case 0xDu:
        v7 = (char *)(v6 + 1);
        if (v6[1])
        {
          if (v6[1] != 10 || (v21 = *((char *)v6 + 2), v6 += 2, v21 >= 1))
          {
            result = 13;
            goto LABEL_229;
          }
        }
        else
        {
LABEL_111:
          v6 = (const UInt8 *)v7;
        }
LABEL_112:
        v7 = (char *)(v6 + 1);
        result = 261;
        goto LABEL_229;
      case 0x22u:
        v9 = (char *)v6;
LABEL_93:
        while (2)
        {
          while (2)
          {
            v7 = v9 + 1;
            v22 = v9[1];
            v23 = v9;
            v9 = v7;
            v24 = v7;
            switch(v22)
            {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 10:
              case 11:
              case 12:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
              case 22:
              case 23:
              case 24:
              case 25:
              case 26:
              case 27:
              case 28:
              case 29:
              case 30:
              case 31:
                goto LABEL_225;
              case 9:
              case 32:
                v9 = v23 + 2;
                while (2)
                {
                  LODWORD(v24) = *v9;
                  switch(*v9)
                  {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 10:
                    case 11:
                    case 12:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                      goto LABEL_225;
                    case 9:
                    case 32:
                      ++v9;
                      continue;
                    case 13:
                      goto LABEL_141;
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 58:
                    case 60:
                      goto LABEL_93;
                    case 34:
                      goto LABEL_161;
                    case 44:
                      v24 = v9;
                      goto LABEL_101;
                    case 59:
                    case 61:
                      goto LABEL_144;
                    default:
                      goto LABEL_98;
                  }
                }
              case 13:
                v9 = v7;
                goto LABEL_141;
              case 33:
              case 35:
              case 36:
              case 37:
              case 38:
              case 39:
              case 40:
              case 41:
              case 42:
              case 43:
              case 45:
              case 46:
              case 47:
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 58:
              case 60:
                continue;
              case 34:
                goto LABEL_161;
              case 44:
                goto LABEL_101;
              case 59:
              case 61:
                goto LABEL_144;
              default:
                v9 = v7;
LABEL_98:
                if ((_DWORD)v24 == 127)
                  goto LABEL_225;
                continue;
            }
          }
LABEL_101:
          v9 = v24 + 1;
          switch(v24[1])
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 10:
            case 11:
            case 12:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              goto LABEL_103;
            case 9:
            case 32:
            case 59:
              goto LABEL_144;
            case 13:
              v33 = (char *)v24[2];
              v9 = v24 + 2;
              if (v24[2] > 0x3D)
                goto LABEL_172;
              if (((1 << v24[2]) & 0x28000000FFFFF9FFLL) != 0)
                goto LABEL_157;
              if (v33 == (char *)10)
              {
                v7 = v24 + 2;
LABEL_142:
                v37 = *++v9;
                v36 = v37;
                if (v37 != 9 && v36 != 32)
                  goto LABEL_225;
                while (1)
                {
LABEL_144:
                  v39 = *++v9;
                  v38 = v39;
                  if (v39 <= 0x22)
                  {
                    if (((1 << v38) & 0xFFFFDDFFLL) != 0)
                      goto LABEL_225;
                    if (v38 == 13)
                    {
LABEL_141:
                      v35 = *++v9;
                      if (v35 != 10)
                        goto LABEL_225;
                      goto LABEL_142;
                    }
                    if (v38 == 34)
                      goto LABEL_154;
                  }
                  if ((_DWORD)v38 == 127)
                    goto LABEL_225;
                }
              }
LABEL_172:
              if ((_DWORD)v33 == 127)
                goto LABEL_157;
              v13 = 2;
              result = 34;
              break;
            case 33:
            case 35:
            case 36:
            case 37:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
              continue;
            case 34:
              goto LABEL_161;
            default:
              if (v24[1] != 127)
                continue;
LABEL_103:
              result = 34;
              goto LABEL_250;
          }
          goto LABEL_169;
        }
      case 0x27u:
        v7 = (char *)v6;
        break;
      case 0x28u:
      case 0x29u:
      case 0x2Fu:
      case 0x3Au:
      case 0x3Cu:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x5Bu:
      case 0x5Cu:
      case 0x5Du:
      case 0x7Bu:
      case 0x7Du:
        result = *(char *)v6;
        v9 = (char *)v6;
        goto LABEL_250;
      case 0x43u:
      case 0x63u:
        v7 = (char *)(v6 + 1);
        v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x6F)
          goto LABEL_82;
        v7 = (char *)(v6 + 2);
        v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x6D)
          goto LABEL_82;
        v7 = (char *)(v6 + 3);
        v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x6D)
          goto LABEL_82;
        v7 = (char *)(v6 + 4);
        v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x65)
          goto LABEL_82;
        v7 = (char *)(v6 + 5);
        v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6E)
          goto LABEL_82;
        v7 = (char *)(v6 + 6);
        v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x74)
          goto LABEL_82;
        v7 = (char *)(v6 + 7);
        v11 = *((char *)v6 + 7);
        if ((v11 > 0x3D || ((1 << v11) & 0x28000000FFFFFDFFLL) == 0) && v11 != 127)
        {
          LOBYTE(v12) = v6[7];
          v13 = 7;
          goto LABEL_84;
        }
LABEL_188:
        v49 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_206:
        *a1 = v49;
        result = 262;
        goto LABEL_229;
      case 0x44u:
      case 0x64u:
        v7 = (char *)(v6 + 1);
        v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x6F)
          goto LABEL_82;
        v7 = (char *)(v6 + 2);
        v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x6D)
          goto LABEL_82;
        v7 = (char *)(v6 + 3);
        v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x61)
          goto LABEL_82;
        v7 = (char *)(v6 + 4);
        v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x69)
          goto LABEL_82;
        v7 = (char *)(v6 + 5);
        v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6E)
          goto LABEL_82;
        v7 = (char *)(v6 + 6);
        v14 = *((char *)v6 + 6);
        if ((v14 > 0x3D || ((1 << v14) & 0x28000000FFFFFDFFLL) == 0) && v14 != 127)
        {
          LOBYTE(v12) = v6[6];
          v13 = 5;
          goto LABEL_84;
        }
LABEL_184:
        v47 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_202:
        *a1 = v47;
        result = 263;
        goto LABEL_229;
      case 0x45u:
      case 0x65u:
        v7 = (char *)(v6 + 1);
        v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x78)
          goto LABEL_82;
        v7 = (char *)(v6 + 2);
        v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x70)
          goto LABEL_82;
        v7 = (char *)(v6 + 3);
        v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x69)
          goto LABEL_82;
        v7 = (char *)(v6 + 4);
        v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x72)
          goto LABEL_82;
        v7 = (char *)(v6 + 5);
        v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x65)
          goto LABEL_82;
        v7 = (char *)(v6 + 6);
        v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x73)
          goto LABEL_82;
        v7 = (char *)(v6 + 7);
        v15 = *((char *)v6 + 7);
        if ((v15 > 0x3D || ((1 << v15) & 0x28000000FFFFFDFFLL) == 0) && v15 != 127)
        {
          LOBYTE(v12) = v6[7];
          v13 = 8;
          goto LABEL_84;
        }
LABEL_190:
        v50 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_208:
        *a1 = v50;
        result = 269;
        goto LABEL_229;
      case 0x48u:
      case 0x68u:
        v7 = (char *)(v6 + 1);
        v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x74)
          goto LABEL_82;
        v7 = (char *)(v6 + 2);
        v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x74)
          goto LABEL_82;
        v7 = (char *)(v6 + 3);
        v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x70)
          goto LABEL_82;
        v7 = (char *)(v6 + 4);
        v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x6F)
          goto LABEL_82;
        v7 = (char *)(v6 + 5);
        v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6E)
          goto LABEL_82;
        v7 = (char *)(v6 + 6);
        v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x6C)
          goto LABEL_82;
        v7 = (char *)(v6 + 7);
        v10 = *((char *)v6 + 7);
        if ((v10 | 0x20) != 0x79)
          goto LABEL_82;
        v7 = (char *)(v6 + 8);
        v16 = *((char *)v6 + 8);
        if ((v16 > 0x3D || ((1 << v16) & 0x28000000FFFFFDFFLL) == 0) && v16 != 127)
        {
          LOBYTE(v12) = v6[8];
          v13 = 11;
          goto LABEL_84;
        }
LABEL_180:
        v45 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_198:
        *a1 = v45;
        result = 267;
        goto LABEL_229;
      case 0x4Du:
      case 0x6Du:
        v7 = (char *)(v6 + 1);
        v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x61)
          goto LABEL_82;
        v7 = (char *)(v6 + 2);
        v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x78)
          goto LABEL_82;
        v7 = (char *)(v6 + 3);
        v12 = v6[3];
        if (v12 != 45)
          goto LABEL_83;
        v7 = (char *)(v6 + 4);
        v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x61
          || (v7 = (char *)(v6 + 5), v10 = *((char *)v6 + 5), (v10 | 0x20) != 0x67)
          || (v7 = (char *)(v6 + 6), v10 = *((char *)v6 + 6), (v10 | 0x20) != 0x65))
        {
LABEL_82:
          LOBYTE(v12) = v10;
LABEL_83:
          v13 = 1;
          goto LABEL_84;
        }
        v7 = (char *)(v6 + 7);
        v17 = *((char *)v6 + 7);
        if ((v17 > 0x3D || ((1 << v17) & 0x28000000FFFFFDFFLL) == 0) && v17 != 127)
        {
          LOBYTE(v12) = v6[7];
          v13 = 9;
          goto LABEL_84;
        }
LABEL_192:
        v51 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_210:
        *a1 = v51;
        result = 264;
        goto LABEL_229;
      case 0x50u:
      case 0x70u:
        v7 = (char *)(v6 + 1);
        v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x61)
          goto LABEL_82;
        v7 = (char *)(v6 + 2);
        v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x74)
          goto LABEL_82;
        v7 = (char *)(v6 + 3);
        v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x68)
          goto LABEL_82;
        v7 = (char *)(v6 + 4);
        v18 = *((char *)v6 + 4);
        if ((v18 > 0x3D || ((1 << v18) & 0x28000000FFFFFDFFLL) == 0) && v18 != 127)
        {
          LOBYTE(v12) = v6[4];
          v13 = 4;
          goto LABEL_84;
        }
LABEL_182:
        v46 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_200:
        *a1 = v46;
        result = 265;
        goto LABEL_229;
      case 0x53u:
      case 0x73u:
        v7 = (char *)(v6 + 1);
        v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x65)
          goto LABEL_82;
        v7 = (char *)(v6 + 2);
        v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x63)
          goto LABEL_82;
        v7 = (char *)(v6 + 3);
        v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x75)
          goto LABEL_82;
        v7 = (char *)(v6 + 4);
        v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x72)
          goto LABEL_82;
        v7 = (char *)(v6 + 5);
        v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x65)
          goto LABEL_82;
        v7 = (char *)(v6 + 6);
        v19 = *((char *)v6 + 6);
        if ((v19 > 0x3D || ((1 << v19) & 0x28000000FFFFFDFFLL) == 0) && v19 != 127)
        {
          LOBYTE(v12) = v6[6];
          v13 = 6;
          goto LABEL_84;
        }
LABEL_186:
        v48 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_204:
        *a1 = v48;
        result = 266;
        goto LABEL_229;
      case 0x56u:
      case 0x76u:
        v7 = (char *)(v6 + 1);
        v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x65)
          goto LABEL_82;
        v7 = (char *)(v6 + 2);
        v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x72)
          goto LABEL_82;
        v7 = (char *)(v6 + 3);
        v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x73)
          goto LABEL_82;
        v7 = (char *)(v6 + 4);
        v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x69)
          goto LABEL_82;
        v7 = (char *)(v6 + 5);
        v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6F)
          goto LABEL_82;
        v7 = (char *)(v6 + 6);
        v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x6E)
          goto LABEL_82;
        v7 = (char *)(v6 + 7);
        v20 = *((char *)v6 + 7);
        if (v20 <= 0x3D && ((1 << v20) & 0x28000000FFFFFDFFLL) != 0 || v20 == 127)
        {
LABEL_194:
          v52 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_212:
          *a1 = v52;
          result = 268;
        }
        else
        {
          LOBYTE(v12) = v6[7];
          v13 = 10;
LABEL_84:
          result = *(char *)v6;
          while (1)
          {
            v54 = (char)v12;
            if ((char)v12 <= 122)
            {
              v43 = v7;
              v9 = v7;
              switch(v54)
              {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 59:
                case 61:
                  goto LABEL_216;
                case 9:
                case 32:
                  goto LABEL_238;
                case 34:
                case 40:
                case 41:
                case 47:
                case 58:
                case 60:
                case 62:
                case 63:
                case 64:
                case 91:
                case 92:
                case 93:
                  goto LABEL_250;
                case 44:
                  goto LABEL_244;
                default:
                  goto LABEL_213;
              }
            }
            if ((char)v12 == 123 || (char)v12 == 125)
            {
              v9 = v7;
              goto LABEL_250;
            }
            if ((char)v12 == 127)
              break;
LABEL_213:
            v53 = *++v7;
            LOBYTE(v12) = v53;
            v13 = 1;
          }
LABEL_216:
          if (v6 >= (const UInt8 *)v7)
            v55 = &stru_1E1500C68;
          else
            v55 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
          *a1 = v55;
          result = 258;
        }
        goto LABEL_229;
      default:
        result = *(char *)v6;
        v7 = (char *)v6;
        goto LABEL_213;
    }
    break;
  }
  while (2)
  {
    v25 = *++v7;
    result = v25;
    switch(v25)
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x7Fu:
        goto LABEL_216;
      case 9u:
      case 0x20u:
        v13 = 1;
LABEL_114:
        v9 = v7 + 1;
        while (2)
        {
          switch(*v9)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 10:
            case 11:
            case 12:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              goto LABEL_117;
            case 9:
            case 32:
              ++v9;
              continue;
            case 13:
              goto LABEL_122;
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 40:
            case 41:
            case 42:
            case 43:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 60:
              goto LABEL_107;
            case 39:
LABEL_161:
              v40 = *++v9;
              LODWORD(v33) = v40;
              v41 = (1 << v40) & 0x28000000FFFFFDFFLL;
              v42 = v40 > 0x3D || v41 == 0;
              if (v42 && (_DWORD)v33 != 127)
              {
                v13 = 3;
                result = *(char *)v6;
                goto LABEL_169;
              }
              v7 = v9;
LABEL_177:
              if (v6 >= (const UInt8 *)v7)
                v44 = &stru_1E1500C68;
              else
                v44 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
              *a1 = v44;
              result = 259;
              break;
            case 44:
              v33 = v9;
              goto LABEL_133;
            case 59:
            case 61:
              goto LABEL_125;
            default:
              if (*v9 == 127)
                goto LABEL_117;
              goto LABEL_107;
          }
          break;
        }
        break;
      case 0xDu:
        v13 = 1;
LABEL_121:
        v9 = v7;
        goto LABEL_122;
      case 0x22u:
      case 0x28u:
      case 0x29u:
      case 0x2Fu:
      case 0x3Au:
      case 0x3Cu:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x5Bu:
      case 0x5Cu:
      case 0x5Du:
      case 0x7Bu:
      case 0x7Du:
        v9 = v7;
LABEL_107:
        v7 = v9;
        while (2)
        {
          v27 = *++v7;
          v26 = v27;
          switch(v27)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 10:
            case 11:
            case 12:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              goto LABEL_225;
            case 9:
            case 32:
              v13 = 2;
              goto LABEL_114;
            case 13:
              v13 = 2;
              goto LABEL_121;
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 40:
            case 41:
            case 42:
            case 43:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 60:
              continue;
            case 39:
              v9 = v7;
              goto LABEL_161;
            case 44:
              v13 = 2;
              goto LABEL_132;
            case 59:
            case 61:
              v13 = 2;
              goto LABEL_119;
            default:
              if (v26 == 127)
                goto LABEL_225;
              continue;
          }
        }
      case 0x27u:
        goto LABEL_213;
      case 0x2Cu:
        v13 = 1;
LABEL_132:
        v33 = v7;
LABEL_133:
        v9 = v33 + 1;
        result = 39;
        switch(v33[1])
        {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 10:
          case 11:
          case 12:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
            goto LABEL_250;
          case 9:
          case 32:
          case 59:
            goto LABEL_125;
          case 13:
            v34 = v33[2];
            v9 = v33 + 2;
            v13 = 2;
            if (v33[2] > 0x3D)
              goto LABEL_174;
            if (((1 << v33[2]) & 0x28000000FFFFF9FFLL) != 0)
              goto LABEL_157;
            if (v34 == 10)
            {
              v7 = v33 + 2;
LABEL_123:
              v30 = *++v9;
              v29 = v30;
              if (v30 != 9 && v29 != 32)
              {
LABEL_117:
                result = 39;
                goto LABEL_176;
              }
              while (1)
              {
LABEL_125:
                v32 = *++v9;
                v31 = v32;
                if (v32 <= 0x27)
                {
                  if (((1 << v31) & 0xFFFFDDFFLL) != 0)
                    goto LABEL_117;
                  if (v31 == 13)
                  {
LABEL_122:
                    v28 = *++v9;
                    if (v28 != 10)
                      goto LABEL_117;
                    goto LABEL_123;
                  }
                  if (v31 == 39)
                  {
LABEL_154:
                    v7 = v9 + 1;
                    goto LABEL_177;
                  }
                }
                if ((_DWORD)v31 == 127)
                  goto LABEL_117;
              }
            }
LABEL_174:
            if ((_DWORD)v34 != 127)
            {
              result = 39;
              LODWORD(v33) = v33[2];
LABEL_169:
              v43 = v9;
              while (1)
              {
                if (v33 > 0x3D)
                  goto LABEL_249;
                if (((1 << (char)v33) & 0x100000200) == 0)
                  break;
                v7 = v9;
LABEL_238:
                LODWORD(v33) = v7[1];
                v9 = v7 + 1;
              }
              if (((1 << (char)v33) & 0x28000000FFFFFDFFLL) != 0)
              {
                v7 = v43;
              }
              else if (v33 == 44)
              {
                v7 = v9;
LABEL_244:
                while (1)
                {
                  v59 = v7[1];
                  v9 = v7 + 1;
                  if (v59 <= 0x3B)
                  {
                    v7 = v43;
                    if (((1 << v59) & 0x800000100000200) != 0)
                      break;
                  }
LABEL_250:
                  v7 = v9;
                  while (1)
                  {
                    v58 = *++v7;
                    v57 = v58;
                    if (v58 <= 0x3D)
                    {
                      if (((1 << v57) & 0x28000000FFFFFDFFLL) != 0)
                        goto LABEL_225;
                      if (((1 << v57) & 0x100000200) != 0)
                      {
                        v13 = 2;
                        v43 = v7;
                        goto LABEL_238;
                      }
                      if (v57 == 44)
                        break;
                    }
                    if ((_DWORD)v57 == 127)
                      goto LABEL_225;
                  }
                  v13 = 2;
                  v43 = v7;
                }
              }
              else
              {
LABEL_249:
                v7 = v43;
                if ((_DWORD)v33 != 127)
                  goto LABEL_250;
              }
LABEL_176:
              switch(v13)
              {
                case 0:
                  goto LABEL_229;
                case 1:
                  goto LABEL_216;
                case 2:
                  goto LABEL_225;
                case 3:
                  goto LABEL_177;
                case 4:
                  if (v6 < (const UInt8 *)v7)
                    goto LABEL_182;
                  v46 = &stru_1E1500C68;
                  goto LABEL_200;
                case 5:
                  if (v6 < (const UInt8 *)v7)
                    goto LABEL_184;
                  v47 = &stru_1E1500C68;
                  goto LABEL_202;
                case 6:
                  if (v6 < (const UInt8 *)v7)
                    goto LABEL_186;
                  v48 = &stru_1E1500C68;
                  goto LABEL_204;
                case 7:
                  if (v6 < (const UInt8 *)v7)
                    goto LABEL_188;
                  v49 = &stru_1E1500C68;
                  goto LABEL_206;
                case 8:
                  if (v6 < (const UInt8 *)v7)
                    goto LABEL_190;
                  v50 = &stru_1E1500C68;
                  goto LABEL_208;
                case 9:
                  if (v6 < (const UInt8 *)v7)
                    goto LABEL_192;
                  v51 = &stru_1E1500C68;
                  goto LABEL_210;
                case 10:
                  if (v6 < (const UInt8 *)v7)
                    goto LABEL_194;
                  v52 = &stru_1E1500C68;
                  goto LABEL_212;
                default:
                  if (v6 < (const UInt8 *)v7)
                    goto LABEL_180;
                  v45 = &stru_1E1500C68;
                  goto LABEL_198;
              }
            }
LABEL_157:
            v7 = v9;
LABEL_225:
            if (v6 >= (const UInt8 *)v7)
              v56 = &stru_1E1500C68;
            else
              v56 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
            *a1 = v56;
            result = 260;
            break;
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
            goto LABEL_107;
          case 39:
            goto LABEL_161;
          default:
            if (v33[1] == 127)
              goto LABEL_250;
            goto LABEL_107;
        }
        break;
      case 0x3Bu:
      case 0x3Du:
        v13 = 1;
LABEL_119:
        v9 = v7;
        goto LABEL_125;
      default:
        continue;
    }
    break;
  }
LABEL_229:
  *a3 = v7;
  return result;
}

id _makeCookie(const __CFAllocator *a1, const void *a2, const void *a3, const __CFDictionary *a4, const __CFURL *a5, const void *a6)
{
  __CFDictionary *Mutable;
  CFIndex Count;
  const void **v14;
  const void **v15;
  CFStringRef *v16;
  const void **v17;
  unsigned int CanonicalString;
  CFStringRef v19;
  const void *v20;
  CFStringRef v21;
  const __CFString *v22;
  CFStringRef v23;
  CFStringRef v24;
  const __CFString *v25;
  uint64_t location;
  CFStringRef v27;
  const __CFString *v28;
  const __CFString *v29;
  CFStringRef v30;
  CFStringRef v31;
  id v32;
  CFIndex Length;
  const __CFString *v35;
  const __CFString *v36;
  CFIndex v37;
  int CharacterAtIndex;
  CFIndex v39;
  const __CFString *v40;
  CFStringRef v41;
  const void *v42;
  CFStringRef theString;
  void *value;
  CFRange v45;
  CFRange v46;
  CFRange v47;

  theString = 0;
  value = 0;
  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, &unk_1EDCFC828, a2);
  CFDictionarySetValue(Mutable, &unk_1EDCFC9E8, a3);
  if (a4)
  {
    v42 = a6;
    Count = CFDictionaryGetCount(a4);
    v14 = (const void **)CFAllocatorAllocate(a1, 8 * Count, 0);
    v15 = (const void **)CFAllocatorAllocate(a1, 8 * Count, 0);
    CFDictionaryGetKeysAndValues(a4, v14, v15);
    if (Count >= 1)
    {
      v16 = (CFStringRef *)v14;
      v17 = v15;
      do
      {
        CanonicalString = _findCanonicalString(*v16, 3u);
        if (CanonicalString == 568)
          v19 = *v16;
        else
          v19 = (CFStringRef)&gConstantCFStringValueTable[7 * ((CanonicalString >> 20) & 0x3FF)];
        v20 = *v17++;
        CFDictionaryAddValue(Mutable, v19, v20);
        ++v16;
        --Count;
      }
      while (Count);
    }
    CFAllocatorDeallocate(a1, v14);
    CFAllocatorDeallocate(a1, v15);
    a6 = v42;
  }
  if (a5)
    v21 = CFURLCopyHostName(a5);
  else
    v21 = 0;
  if (!CFDictionaryGetValueIfPresent(Mutable, &unk_1EDCFC710, (const void **)&value)
    || !CFStringGetLength((CFStringRef)value))
  {
    if (!v21)
    {
LABEL_22:
      CFDictionarySetValue(Mutable, &unk_1EDCFC710, CFSTR(".^filecookies^"));
      goto LABEL_23;
    }
LABEL_20:
    if (CFStringGetLength(v21) >= 1)
    {
      CFDictionarySetValue(Mutable, &unk_1EDCFC710, v21);
LABEL_24:
      CFRelease(v21);
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  if (v21 && isTopLevelDomain(v21, 1))
    goto LABEL_20;
  if (!CFStringHasPrefix((CFStringRef)value, CFSTR("."))
    && !CookieUtils::looksLikeIPAddress((const __CFString *)value, v22))
  {
    v23 = CFStringCreateWithFormat(a1, 0, CFSTR(".%@"), value);
    CFDictionarySetValue(Mutable, &unk_1EDCFC710, v23);
    CFRelease(v23);
  }
LABEL_23:
  if (v21)
    goto LABEL_24;
LABEL_25:
  if (CFDictionaryGetValueIfPresent(Mutable, &unk_1EDCFC898, (const void **)&theString)
    && CFStringGetLength(theString)
    && !CFEqual(theString, CFSTR("\"\""))
    && !CFEqual(theString, CFSTR("''")))
  {
    Length = CFStringGetLength(theString);
    v35 = theString;
    if (Length < 3)
      goto LABEL_54;
    if (CFStringGetCharacterAtIndex(theString, 0) == 34)
    {
      v36 = theString;
      v37 = CFStringGetLength(theString);
      if (CFStringGetCharacterAtIndex(v36, v37 - 1) == 34)
        goto LABEL_51;
    }
    CharacterAtIndex = CFStringGetCharacterAtIndex(theString, 0);
    v35 = theString;
    if (CharacterAtIndex != 39)
      goto LABEL_54;
    v39 = CFStringGetLength(theString);
    if (CFStringGetCharacterAtIndex(v35, v39 - 1) == 39)
    {
LABEL_51:
      v40 = theString;
      v47.length = CFStringGetLength(theString) - 2;
      v47.location = 1;
      v41 = CFStringCreateWithSubstring(a1, v40, v47);
      v35 = (const __CFString *)CFAutorelease(v41);
      theString = v35;
    }
    else
    {
      v35 = theString;
    }
LABEL_54:
    v28 = CFURLCreateStringByAddingPercentEscapes(a1, v35, CFSTR("%"), 0, 0x8000100u);
    if (!v28)
      goto LABEL_37;
    goto LABEL_35;
  }
  if (!a5)
    goto LABEL_34;
  v24 = CFURLCopyPath(a5);
  if (!v24)
    goto LABEL_34;
  v25 = v24;
  if (!CFEqual(CFSTR("/"), v24))
  {
    location = CFStringFind(v25, CFSTR("/"), 4uLL).location;
    if (location <= 0)
    {
      CFRelease(v25);
      v25 = CFSTR("/");
      goto LABEL_36;
    }
    v45.length = location;
    v45.location = 0;
    v27 = CFStringCreateWithSubstring(a1, v25, v45);
    CFRelease(v25);
    v25 = v27;
    if (!v27)
    {
LABEL_34:
      v28 = (const __CFString *)CFRetain(CFSTR("/"));
LABEL_35:
      v25 = v28;
    }
  }
LABEL_36:
  CFDictionarySetValue(Mutable, &unk_1EDCFC898, v25);
  CFRelease(v25);
LABEL_37:
  v29 = (const __CFString *)CFDictionaryGetValue(Mutable, &unk_1EDCFC898);
  theString = v29;
  if (v29)
  {
    if (CFStringGetLength(v29) >= 2)
    {
      if (CFStringHasPrefix(theString, CFSTR("\"")))
      {
        if (CFStringHasSuffix(theString, CFSTR("\"")))
        {
          v46.length = CFStringGetLength(theString) - 2;
          v46.location = 1;
          v30 = CFStringCreateWithSubstring(a1, theString, v46);
          if (v30)
          {
            v31 = v30;
            CFDictionarySetValue(Mutable, &unk_1EDCFC898, v30);
            CFRelease(v31);
          }
        }
      }
    }
  }
  if (a6)
    CFDictionarySetValue(Mutable, &unk_1EDCFC9B0, a6);
  v32 = -[NSHTTPCookie _initWithProperties:fromString:]([NSHTTPCookie alloc], "_initWithProperties:fromString:", Mutable, 1);
  CFRelease(Mutable);
  return v32;
}

void ___ZN27URLConnectionClient_Classic18_withDelegateAsyncEPKcU13block_pointerFvP16_CFURLConnectionPK33CFURLConnectionClientCurrent_VMaxE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void (*v5)(void);
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  void (*v9)(void);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  _QWORD v14[6];
  _QWORD block[6];

  v2 = a1[5];
  v3 = (void *)MEMORY[0x186DB8C8C]();
  v4 = URLConnectionClient_Classic::copyDelegate((os_unfair_lock_s *)v2);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 304))(v2) || *(_DWORD *)(v4 + 196))
    v5 = *(void (**)(void))(a1[4] + 16);
  else
    v5 = *(void (**)(void))(a1[4] + 16);
  v5();
  v6 = (unsigned int *)(v4 + 192);
  do
  {
    v7 = __ldaxr(v6);
    v8 = v7 - 1;
  }
  while (__stlxr(v8, v6));
  if (!v8)
  {
    if (*(_QWORD *)(v4 + 8))
    {
      v9 = *(void (**)(void))(v4 + 24);
      if (v9)
        v9();
    }
    MEMORY[0x186DB748C](v4, 0x10C0C4063EE03C6);
  }
  v10 = MEMORY[0x1E0C809B0];
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3221225472;
  v14[2] = ___ZN27URLConnectionClient_Classic18_withDelegateAsyncEPKcU13block_pointerFvP16_CFURLConnectionPK33CFURLConnectionClientCurrent_VMaxE_block_invoke_2;
  v14[3] = &__block_descriptor_48_e5_v8__0l;
  v11 = a1[6];
  v14[4] = v2;
  v14[5] = v11;
  v12 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 64))(*(_QWORD *)(v2 + 32));
  v13 = *(NSObject **)(v2 + 40);
  block[0] = v10;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v14;
  block[5] = v12;
  dispatch_async(v13, block);
  objc_autoreleasePoolPop(v3);
}

uint64_t URLConnectionClient_Classic::copyDelegate(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;

  v2 = this + 59;
  os_unfair_lock_lock(this + 59);
  v3 = *(_QWORD *)&this[60]._os_unfair_lock_opaque;
  if (v3)
  {
    v4 = (unsigned int *)(v3 + 192);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

void URLConnectionClient_Classic::_withDelegateAsync(uint64_t a1, uint64_t a2, void (**a3)(_QWORD, _QWORD, _QWORD))
{
  void *v6;
  uint64_t v7;
  __CFArray *v8;
  int v9;
  const __CFAllocator *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[7];
  CFArrayCallBacks callBacks;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 304))(a1)
    || (v7 = *(_QWORD *)(a1 + 240)) == 0
    || *(_DWORD *)(v7 + 196))
  {
    v6 = (void *)MEMORY[0x186DB8C8C]();
    a3[2](a3, 0, 0);
    objc_autoreleasePoolPop(v6);
    return;
  }
  v8 = *(__CFArray **)(a1 + 248);
  if (v8)
    goto LABEL_6;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 136));
  v9 = *(unsigned __int8 *)(a1 + 140);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 136));
  if (v9)
  {
    v8 = *(__CFArray **)(a1 + 248);
    if (!v8)
    {
      v10 = *(const __CFAllocator **)(a1 + 8);
      *(_OWORD *)&callBacks.version = xmmword_1E14FD5B0;
      *(_OWORD *)&callBacks.release = *(_OWORD *)&off_1E14FD5C0;
      callBacks.equal = 0;
      v8 = CFArrayCreateMutable(v10, 0, &callBacks);
      *(_QWORD *)(a1 + 248) = v8;
      v11 = *(_QWORD *)(a1 + 264);
      *(_QWORD *)(a1 + 264) = v11 + 1;
      if (!v11)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
        v8 = *(__CFArray **)(a1 + 248);
      }
    }
LABEL_6:
    CFArrayAppendValue(v8, a3);
    return;
  }
  v12 = *(_QWORD *)(a1 + 264);
  *(_QWORD *)(a1 + 264) = v12 + 1;
  if (!v12)
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  v13 = *(_QWORD *)(a1 + 256);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3221225472;
  v14[2] = ___ZN27URLConnectionClient_Classic18_withDelegateAsyncEPKcU13block_pointerFvP16_CFURLConnectionPK33CFURLConnectionClientCurrent_VMaxE_block_invoke;
  v14[3] = &unk_1E14FDB30;
  v14[4] = a3;
  v14[5] = a1;
  v14[6] = a2;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 96))(v13, v14);
}

BOOL URLConnectionClient_Classic::isInvalidatingOrInvalid(URLConnectionClient_Classic *this)
{
  return *((_BYTE *)this + 272)
      || (*((_WORD *)this + 38) & 0x40) != 0
      || (*(unsigned int (**)(URLConnectionClient_Classic *))(*(_QWORD *)this + 64))(this) != 0;
}

uint64_t URLConnectionClient::cancelRequested(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t os_unfair_lock_opaque_low;

  v2 = this + 32;
  os_unfair_lock_lock(this + 32);
  os_unfair_lock_opaque_low = LOBYTE(this[33]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2);
  return os_unfair_lock_opaque_low;
}

void formFinalize(__CFReadStream *a1, CFTypeRef *a2)
{
  const __CFAllocator *v4;

  closeCurrentStream((uint64_t)a2);
  if (*a2)
    (*(void (**)(CFTypeRef))(*(_QWORD *)*a2 + 48))(*a2);
  *a2 = 0;
  CFRelease(a2[1]);
  a2[1] = 0;
  v4 = CFGetAllocator(a1);
  CFAllocatorDeallocate(v4, a2);
}

uint64_t formOpen(__CFReadStream *a1, __CFError **a2, unsigned __int8 *a3, _QWORD *a4)
{
  openNextStream(a4);
  *a3 = 1;
  if (a2)
    *a2 = 0;
  return 1;
}

CFIndex formRead(__CFReadStream *a1, UInt8 *buffer, CFIndex bufferLength, __CFError **a4, unsigned __int8 *a5, _QWORD *a6)
{
  __CFReadStream *v8;
  CFIndex v12;
  CFIndex v13;

  v8 = (__CFReadStream *)a6[2];
  if (v8)
  {
    while (1)
    {
      v12 = CFReadStreamRead(v8, buffer, bufferLength);
      if (v12 < 0)
      {
        if (a4)
          *a4 = CFReadStreamCopyError((CFReadStreamRef)a6[2]);
        return -1;
      }
      v13 = v12;
      if (v12)
        break;
      openNextStream(a6);
      v8 = (__CFReadStream *)a6[2];
      if (!v8)
        goto LABEL_5;
    }
    if (a4)
      *a4 = 0;
    if (CFReadStreamGetStatus((CFReadStreamRef)a6[2]) != kCFStreamStatusAtEnd)
    {
      *a5 = 0;
      return v13;
    }
    openNextStream(a6);
    if (a6[2])
      return v13;
  }
  else
  {
LABEL_5:
    if (a4)
      *a4 = 0;
    v13 = 0;
  }
  *a5 = 1;
  return v13;
}

__CFReadStream *openNextStream(_QWORD *a1)
{
  _QWORD *i;
  __CFReadStream *result;

  for (i = a1; ; a1 = i)
  {
    advanceCurrentStream(a1);
    result = (__CFReadStream *)i[2];
    if (!result)
      break;
    result = (__CFReadStream *)CFReadStreamOpen(result);
    if ((_DWORD)result)
      break;
  }
  return result;
}

void advanceCurrentStream(_QWORD *a1)
{
  const __CFAllocator *v2;
  const __CFString *ValueAtIndex;
  CFTypeID v4;
  CFIndex Length;
  CFIndex v6;
  const UInt8 *BytePtr;
  CFReadStreamRef v8;
  CFTypeID v9;
  const __CFURL *v10;
  CFReadStreamRef v11;
  uint64_t v12;
  CFNumberRef v13;
  CFTypeID v14;
  CFTypeRef v15;
  CoreSchedulingSet *v16;
  CFStreamClientContext clientContext;

  clientContext.version = 0;
  clientContext.info = a1;
  memset(&clientContext.retain, 0, 24);
  closeCurrentStream((uint64_t)a1);
  if (CFArrayGetCount((CFArrayRef)a1[1]))
  {
    v2 = CFGetAllocator((CFTypeRef)a1[1]);
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a1[1], 0);
    v4 = CFGetTypeID(ValueAtIndex);
    if (v4 == CFDataGetTypeID())
    {
      Length = CFDataGetLength((CFDataRef)ValueAtIndex);
      v6 = a1[6];
      BytePtr = CFDataGetBytePtr((CFDataRef)ValueAtIndex);
      if (v6 >= Length)
      {
        v8 = CFReadStreamCreateWithBytesNoCopy(v2, &BytePtr[Length], 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
        a1[6] -= Length;
      }
      else
      {
        v8 = CFReadStreamCreateWithBytesNoCopy(v2, &BytePtr[a1[6]], Length - a1[6], (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
      }
      a1[2] = v8;
      a1[3] = ValueAtIndex;
      CFRetain(ValueAtIndex);
    }
    else
    {
      v9 = CFGetTypeID(ValueAtIndex);
      if (v9 == CFStringGetTypeID())
      {
        v10 = CFURLCreateWithFileSystemPath(v2, ValueAtIndex, kCFURLPOSIXPathStyle, 0);
        v11 = CFReadStreamCreateWithFile(v2, v10);
        v12 = a1[6];
        a1[2] = v11;
        if (v12 >= 1)
        {
          v13 = CFNumberCreate(v2, kCFNumberSInt64Type, a1 + 6);
          CFReadStreamSetProperty((CFReadStreamRef)a1[2], (CFStreamPropertyKey)*MEMORY[0x1E0C9B2B0], v13);
          if (v13)
            CFRelease(v13);
        }
        CFRelease(v10);
      }
      else
      {
        v14 = CFGetTypeID(ValueAtIndex);
        if (v14 == CFReadStreamGetTypeID())
        {
          if (ValueAtIndex)
            v15 = CFRetain(ValueAtIndex);
          else
            v15 = 0;
          a1[2] = v15;
        }
      }
    }
    CFArrayRemoveValueAtIndex((CFMutableArrayRef)a1[1], 0);
    CFReadStreamSetClient((CFReadStreamRef)a1[2], 0x1AuLL, (CFReadStreamClientCallBack)formEventCallback, &clientContext);
    v16 = (CoreSchedulingSet *)*a1;
    if (!*a1)
    {
      if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
        dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
      v16 = (CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
    }
    CoreSchedulingSet::scheduleStream(v16, (__CFReadStream *)a1[2]);
  }
}

void closeCurrentStream(uint64_t a1)
{
  __CFReadStream *v2;
  const void *v3;

  v2 = *(__CFReadStream **)(a1 + 16);
  if (v2)
  {
    CFReadStreamClose(v2);
    CFReadStreamSetClient(*(CFReadStreamRef *)(a1 + 16), 0, 0, 0);
    CFRelease(*(CFTypeRef *)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
  }
  v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void sub_183F760B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

__CFArray *HTTPCookieStorage::createArchive(HTTPCookieStorage *this, CFAllocatorRef allocator)
{
  __CFArray *Mutable;
  PrivateHTTPCookieStorage *v4;
  uint64_t CookieAcceptPolicy;
  AutoArray *v6;
  const void *EmptyArray;
  uint64_t v8;
  uint64_t v9;
  const __CFString *v10;
  void (**v12)(AutoScalar *__hidden);
  void *value;

  Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
  AutoScalar::AutoScalar((AutoScalar *)&v12, 0);
  CFArrayAppendValue(Mutable, value);
  v12 = &off_1E14E47E8;
  if (value)
    CFRelease(value);
  v4 = (PrivateHTTPCookieStorage *)*((_QWORD *)this + 2);
  if (v4)
    CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v4);
  else
    CookieAcceptPolicy = 2;
  AutoScalar::AutoScalar((AutoScalar *)&v12, (const __CFAllocator *)CookieAcceptPolicy);
  CFArrayAppendValue(Mutable, value);
  v12 = &off_1E14E47E8;
  v6 = (AutoArray *)value;
  if (value)
    CFRelease(value);
  EmptyArray = (const void *)AutoArray::getEmptyArray(v6);
  CFArrayAppendValue(Mutable, EmptyArray);
  v8 = *((_QWORD *)this + 2);
  v9 = *(_QWORD *)(v8 + 32);
  if (v9)
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  v10 = *(const __CFString **)(v8 + 56);
  if (v10)
    PrivateHTTPCookieStorage::addIdentifierToArchiveInternalLocked(Mutable, *(__CFArray **)(v8 + 48), v10, (const __CFString *)*(unsigned __int8 *)(v8 + 64));
  else
    (*(void (**)(uint64_t, __CFArray *))(*(_QWORD *)v8 + 160))(v8, Mutable);
  if (v9)
    pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
  return Mutable;
}

void sub_183F761E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  uint64_t v10;

  if (v10)
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
  _Unwind_Resume(exception_object);
}

void sub_183F76978(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v8 = v6;

  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE64c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = a1 + 32;
  v2 = a1 + 48;
  v3 = a1 + 64;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

BOOL URLProtectionSpace::initializeFromPropertyList(URLProtectionSpace *this, CFDictionaryRef *a2)
{
  _BOOL8 result;
  const void *Value;
  const __CFNumber *v6;
  int v7;
  const __CFNumber *v8;
  int v9;
  const void *v10;
  const __CFNumber *v11;
  int v12;
  CFTypeID TypeID;
  CFTypeID v14;
  const void *valuePtr;

  result = Serializable::initializeFromPropertyList((uint64_t)this + 8, a2);
  if (result)
  {
    Value = CFDictionaryGetValue(*a2, CFSTR("host"));
    if (Value)
      Value = CFRetain(Value);
    *((_QWORD *)this + 4) = Value;
    v6 = (const __CFNumber *)CFDictionaryGetValue(*a2, CFSTR("port"));
    if (v6)
    {
      valuePtr = 0;
      CFNumberGetValue(v6, kCFNumberCFIndexType, &valuePtr);
      v7 = (int)valuePtr;
    }
    else
    {
      v7 = 0;
    }
    *((_DWORD *)this + 10) = v7;
    v8 = (const __CFNumber *)CFDictionaryGetValue(*a2, CFSTR("type"));
    if (v8)
    {
      valuePtr = 0;
      CFNumberGetValue(v8, kCFNumberCFIndexType, &valuePtr);
      v9 = (int)valuePtr;
    }
    else
    {
      v9 = 0;
    }
    *((_DWORD *)this + 11) = v9;
    v10 = CFDictionaryGetValue(*a2, CFSTR("realm"));
    if (v10)
      v10 = CFRetain(v10);
    *((_QWORD *)this + 6) = v10;
    v11 = (const __CFNumber *)CFDictionaryGetValue(*a2, CFSTR("scheme"));
    if (v11)
    {
      valuePtr = 0;
      CFNumberGetValue(v11, kCFNumberCFIndexType, &valuePtr);
      v12 = (int)valuePtr;
    }
    else
    {
      v12 = 0;
    }
    *((_DWORD *)this + 14) = v12;
    valuePtr = 0;
    TypeID = CFArrayGetTypeID();
    DeserializableArchive::decant((DeserializableArchive *)a2, CFSTR("distnames"), TypeID, &valuePtr);
    *((_QWORD *)this + 8) = valuePtr;
    valuePtr = 0;
    v14 = SecTrustGetTypeID();
    DeserializableArchive::decant((DeserializableArchive *)a2, CFSTR("trust"), v14, &valuePtr);
    *((_QWORD *)this + 9) = valuePtr;
    URLProtectionSpace::calcHash(this);
    return 1;
  }
  return result;
}

void DeserializableArchive::deserialize(DeserializableArchive *this, CFTypeRef *a2, __SecTrust **a3)
{
  CFTypeRef v5;
  CFTypeID TypeID;
  CFTypeRef v7;
  CFTypeID v8;
  CFTypeRef v9;
  _QWORD v10[2];
  CFTypeRef certificates;

  v10[1] = CFGetAllocator(this);
  v5 = CFRetain(this);
  v10[0] = v5;
  certificates = 0;
  TypeID = CFArrayGetTypeID();
  DeserializableArchive::decant((DeserializableArchive *)v10, CFSTR("policies"), TypeID, &certificates);
  v7 = certificates;
  certificates = 0;
  v8 = CFArrayGetTypeID();
  DeserializableArchive::decant((DeserializableArchive *)v10, CFSTR("certs"), v8, &certificates);
  v9 = certificates;
  if (SecTrustCreateWithCertificates(certificates, v7, (SecTrustRef *)a2))
  {
    if (*a2)
      CFRelease(*a2);
    *a2 = 0;
  }
  if (v7)
    CFRelease(v7);
  if (v9)
    CFRelease(v9);
  if (v5)
    CFRelease(v5);
}

void sub_183F76D0C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::decant(CFDictionaryRef *this, const __CFString *a2, uint64_t a3, CFErrorRef *a4)
{
  __CFString *v7;
  __CFString *v8;
  __CFError *v9;
  CFTypeRef v10;
  CFTypeID TypeID;
  const __CFArray *v12;
  CFTypeID v13;
  const __CFArray *v14;
  CFIndex Count;
  CFIndex v16;
  const __CFNumber *v17;
  uint64_t v18;
  __CFError **v19;
  const __CFAllocator *v20;
  __CFDictionary *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v24;
  const __CFURL **v25;
  const __CFAllocator *v26;
  CFMutableArrayRef v27;
  uint64_t v28;
  NSObject *v29;
  const __CFAllocator *v30;
  const void *v31;
  const void *v32;
  const __CFDictionary *v33;
  const __CFNumber *v34;
  CFTypeID v35;
  objc_class *v36;
  void *v37;
  __SecAccessControl **v38;
  __SecTrust **v39;
  const __CFAllocator *v40;
  __SecPolicy **v41;
  void *value;
  _BYTE v43[22];
  _BYTE valuePtr[154];
  _BYTE buf[12];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  v7 = (__CFString *)CFDictionaryGetValue(*this, a2);
  if (!v7)
    return;
  v8 = v7;
  if (CFBooleanGetTypeID() == a3 && CFGetTypeID(v8) == a3
    || CFNumberGetTypeID() == a3 && CFGetTypeID(v8) == a3
    || CFStringGetTypeID() == a3 && CFGetTypeID(v8) == a3
    || CFDataGetTypeID() == a3 && CFGetTypeID(v8) == a3
    || CFDateGetTypeID() == a3 && CFGetTypeID(v8) == a3)
  {
    v9 = (__CFError *)CFRetain(v8);
LABEL_13:
    *a4 = v9;
    return;
  }
  if (CFDictionaryGetTypeID() == a3)
  {
    *(_QWORD *)&valuePtr[8] = CFGetAllocator(v8);
    v10 = CFRetain(v8);
    *(_QWORD *)valuePtr = v10;
    *(_QWORD *)v43 = 0;
    TypeID = CFArrayGetTypeID();
    DeserializableArchive::decant((DeserializableArchive *)valuePtr, CFSTR("keys"), TypeID, (const void **)v43);
    v12 = *(const __CFArray **)v43;
    *(_QWORD *)v43 = 0;
    v13 = CFArrayGetTypeID();
    DeserializableArchive::decant((DeserializableArchive *)valuePtr, CFSTR("vals"), v13, (const void **)v43);
    v14 = *(const __CFArray **)v43;
    if (v12)
    {
      Count = CFArrayGetCount(v12);
      if (v14)
      {
LABEL_18:
        v16 = CFArrayGetCount(v14);
        goto LABEL_26;
      }
    }
    else
    {
      Count = 0;
      if (*(_QWORD *)v43)
        goto LABEL_18;
    }
    v16 = 0;
LABEL_26:
    if (Count == v16)
    {
      v20 = CFGetAllocator(v8);
      Mutable = CFDictionaryCreateMutable(v20, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v12, i);
          v24 = CFArrayGetValueAtIndex(v14, i);
          CFDictionarySetValue(Mutable, ValueAtIndex, v24);
        }
      }
      *a4 = Mutable;
    }
    if (v12)
      CFRelease(v12);
    if (v14)
      CFRelease(v14);
    if (!v10)
      return;
LABEL_102:
    CFRelease(v10);
    return;
  }
  if (CFArrayGetTypeID() == a3)
  {
    CFGetAllocator(v8);
    v10 = CFRetain(v8);
    v17 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v10, CFSTR("count"));
    if (v17)
    {
      *(_QWORD *)valuePtr = 0;
      CFNumberGetValue(v17, kCFNumberCFIndexType, valuePtr);
      v18 = *(_QWORD *)valuePtr;
    }
    else
    {
      v18 = 0;
    }
    v26 = CFGetAllocator(v8);
    v27 = CFArrayCreateMutable(v26, 0, MEMORY[0x1E0C9B378]);
    if (v18 < 1)
    {
LABEL_101:
      *a4 = v27;
      if (!v10)
        return;
      goto LABEL_102;
    }
    v28 = 0;
    v29 = MEMORY[0x1E0C81028];
    while (1)
    {
      v30 = CFGetAllocator(v8);
      AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)valuePtr, v30, CFSTR("ix%ld"), v28);
      value = 0;
      v31 = CFDictionaryGetValue((CFDictionaryRef)v10, *(const void **)&valuePtr[8]);
      v32 = v31;
      if (v31)
        break;
LABEL_95:
      if (value)
      {
        CFArrayAppendValue(v27, value);
        if (value)
          CFRelease(value);
      }
      else if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)v43 = 134218242;
        *(_QWORD *)&v43[4] = v28;
        *(_WORD *)&v43[12] = 2112;
        *(_QWORD *)&v43[14] = v8;
        _os_log_fault_impl(&dword_183ECA000, v29, OS_LOG_TYPE_FAULT, "Deserialize error on index %ld of array %@", v43, 0x16u);
      }
      AutoString::~AutoString((AutoString *)valuePtr);
      if (v18 == ++v28)
        goto LABEL_101;
    }
    *(_QWORD *)&v43[8] = CFGetAllocator(v31);
    v33 = (const __CFDictionary *)CFRetain(v32);
    *(_QWORD *)v43 = v33;
    v34 = (const __CFNumber *)CFDictionaryGetValue(v33, CFSTR("kind"));
    if (v34)
    {
      *(_QWORD *)buf = 0;
      CFNumberGetValue(v34, kCFNumberCFIndexType, buf);
      if (*(uint64_t *)buf <= 3014658)
      {
        if (*(uint64_t *)buf <= 2162690)
        {
          if (*(uint64_t *)buf > 2031618)
          {
            if (*(_QWORD *)buf == 2031619)
            {
              v35 = CFStringGetTypeID();
              goto LABEL_92;
            }
            if (*(_QWORD *)buf == 2097155)
            {
              v35 = CFDataGetTypeID();
              goto LABEL_92;
            }
          }
          else
          {
            if (*(_QWORD *)buf == 1900547)
            {
              v35 = CFBooleanGetTypeID();
              goto LABEL_92;
            }
            if (*(_QWORD *)buf == 1966083)
            {
              v35 = CFNumberGetTypeID();
              goto LABEL_92;
            }
          }
        }
        else if (*(uint64_t *)buf <= 2555906)
        {
          if (*(_QWORD *)buf == 2162691)
          {
            v35 = CFDateGetTypeID();
            goto LABEL_92;
          }
          if (*(_QWORD *)buf == 2490371)
          {
            v35 = CFDictionaryGetTypeID();
            goto LABEL_92;
          }
        }
        else
        {
          switch(*(_QWORD *)buf)
          {
            case 0x270003:
              v35 = CFArrayGetTypeID();
              goto LABEL_92;
            case 0x280003:
              v35 = CFErrorGetTypeID();
              goto LABEL_92;
            case 0x290003:
              v35 = CFURLGetTypeID();
              goto LABEL_92;
          }
        }
      }
      else if (*(uint64_t *)buf > 4128770)
      {
        if (*(uint64_t *)buf <= 5111810)
        {
          if (*(_QWORD *)buf == 4128771)
          {
            v35 = SecPolicyGetTypeID();
            goto LABEL_92;
          }
          if (*(_QWORD *)buf == 4194307)
          {
            v35 = SecKeyGetTypeID();
            goto LABEL_92;
          }
        }
        else if (*(_QWORD *)buf == 5111811 || *(_QWORD *)buf == 5177347 || *(_QWORD *)buf == 5242883)
        {
          *(_QWORD *)buf = 0;
          DeserializableArchive::decant((const __CFAllocator **)v43, CFSTR("valu"), (Serializable **)buf);
          if (*(_QWORD *)buf)
            v37 = (void *)(*(_QWORD *)buf - 24);
          else
            v37 = 0;
          value = v37;
LABEL_93:
          if (v33)
            CFRelease(v33);
          goto LABEL_95;
        }
      }
      else if (*(uint64_t *)buf <= 3735554)
      {
        if (*(_QWORD *)buf == 3014659 || *(_QWORD *)buf == 3080195)
        {
          v36 = (objc_class *)objc_opt_class();
          DeserializableArchive::decantClass((CFDictionaryRef *)v43, CFSTR("valu"), v36, &value);
          goto LABEL_93;
        }
      }
      else
      {
        switch(*(_QWORD *)buf)
        {
          case 0x390003:
            v35 = SecAccessControlGetTypeID();
            goto LABEL_92;
          case 0x3C0003:
            v35 = SecTrustGetTypeID();
            goto LABEL_92;
          case 0x3E0003:
            v35 = SecCertificateGetTypeID();
LABEL_92:
            DeserializableArchive::decant((DeserializableArchive *)v43, CFSTR("valu"), v35, (const void **)&value);
            goto LABEL_93;
        }
      }
    }
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v32;
      _os_log_fault_impl(&dword_183ECA000, v29, OS_LOG_TYPE_FAULT, "Unable to deserialize %@", buf, 0xCu);
    }
    goto LABEL_93;
  }
  if (CFErrorGetTypeID() == a3)
  {
    DeserializableArchive::deserialize((DeserializableArchive *)v8, a4, v19);
    return;
  }
  if (CFURLGetTypeID() == a3)
  {
    DeserializableArchive::deserialize(v8, a4, v25);
    return;
  }
  if (SecAccessControlGetTypeID() == a3)
  {
    DeserializableArchive::deserialize((DeserializableArchive *)v8, (uint64_t *)a4, v38);
    return;
  }
  if (SecTrustGetTypeID() == a3)
  {
    DeserializableArchive::deserialize((DeserializableArchive *)v8, (CFTypeRef *)a4, v39);
    return;
  }
  if (SecCertificateGetTypeID() == a3)
  {
    v40 = CFGetAllocator(v8);
    v9 = SecCertificateCreateWithData(v40, (CFDataRef)v8);
    goto LABEL_13;
  }
  if (SecPolicyGetTypeID() == a3)
  {
    DeserializableArchive::deserialize((DeserializableArchive *)v8, a4, v41);
  }
  else if (SecKeyGetTypeID() == a3)
  {
    *a4 = 0;
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)valuePtr = 138412546;
    *(_QWORD *)&valuePtr[4] = a2;
    *(_WORD *)&valuePtr[12] = 2048;
    *(_QWORD *)&valuePtr[14] = a3;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Unable to deserialize key %@ as type %lu - is there a specialization", valuePtr, 0x16u);
  }
}

void sub_183F77644(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  const void *v21;
  const void *v22;

  if (v22)
    CFRelease(v22);
  AutoString::~AutoString((AutoString *)&a21);
  if (v21)
    CFRelease(v21);
  _Unwind_Resume(a1);
}

uint64_t ___ZN19URLConnectionLoader26_private_followRedirectionEP12NSURLRequest_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  v2 = *(_QWORD *)(a1 + 40);
  URLConnectionLoader::replayOrConsumeRedirections((URLConnectionLoader *)v2);
  objc_msgSend(*(id *)(v2 + 64), "updateCurrentRequest:", *(_QWORD *)(a1 + 32));
  -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*(_QWORD *)(v2 + 72), 2, *(void **)(a1 + 32));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 56))(v2, *(_QWORD *)(v2 + 64));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 72))(*(_QWORD *)(v2 + 32));
}

URLConnectionLoader *URLConnectionLoader::replayOrConsumeRedirections(URLConnectionLoader *this)
{
  URLConnectionLoader *v1;
  RedirectionRecorder *var12;
  CFArrayRef *v3;
  void ***p_var8;
  NSObject *var6;

  v1 = this;
  if (this->var14)
  {
    var12 = this->var12;
    if (var12)
    {
      this->var12 = 0;
      if (this->var13)
      {
        v3 = (CFArrayRef *)var12;
        p_var8 = 0;
        var6 = 0;
      }
      else
      {
        p_var8 = &this->var8;
        var6 = this->var6;
        v3 = (CFArrayRef *)var12;
      }
      RedirectionRecorder::playbackMessages(v3, (uint64_t)p_var8, var6);
      this = (URLConnectionLoader *)(*(uint64_t (**)(RedirectionRecorder *))(*(_QWORD *)var12 + 48))(var12);
    }
    *(_WORD *)&v1->var13 = 0;
  }
  else
  {
    this->var15 = 1;
  }
  return this;
}

void RedirectionRecorder::~RedirectionRecorder(RedirectionRecorder *this)
{
  uint64_t v2;

  RedirectionRecorder::~RedirectionRecorder(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14EA1A0;
  *((_QWORD *)this + 3) = &unk_1E14EA288;
  *((_QWORD *)this + 4) = &unk_1E14EA348;
  v2 = (const void *)*((_QWORD *)this + 5);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 4) = &off_1E14E5838;
}

void sub_183F77D84(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 32) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void RedirectionRecorder::playbackMessages(CFArrayRef *a1, uint64_t a2, NSObject *a3)
{
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  uint64_t v10;
  void (**ValueAtIndex)(const void *, _QWORD);
  void (**v12)(const void *, _QWORD);
  _QWORD block[7];

  v4 = a1[5];
  if (v4)
  {
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v8 = Count;
      v9 = 0;
      v10 = MEMORY[0x1E0C809B0];
      do
      {
        ValueAtIndex = (void (**)(const void *, _QWORD))CFArrayGetValueAtIndex(a1[5], v9);
        v12 = ValueAtIndex;
        if (a3)
        {
          (*((void (**)(CFArrayRef *))*a1 + 5))(a1);
          (*(void (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
          block[0] = v10;
          block[1] = 3221225472;
          block[2] = ___ZN19RedirectionRecorder16playbackMessagesEP17URLProtocolClientPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
          block[3] = &unk_1E14FDB30;
          block[4] = v12;
          block[5] = a1;
          block[6] = a2;
          dispatch_async(a3, block);
        }
        else
        {
          ValueAtIndex[2](ValueAtIndex, 0);
        }
        ++v9;
      }
      while (v8 != v9);
    }
  }
}

void ___ZN19RedirectionRecorder26protocolDidReceiveResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 64))(a2, *(_QWORD *)(a1 + 32));

}

uint64_t ___ZN19RedirectionRecorder24protocolDidFinishLoadingEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 88))(a2);
  return result;
}

void ___ZN19RedirectionRecorder19protocolDidLoadDataEPK8__CFDatax_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

void sub_183F783EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *))
{
  void *v14;

  a14(&a12);
  _Unwind_Resume(a1);
}

void URLProtocol::~URLProtocol(URLProtocol *this)
{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = &off_1E14E5548;
  *((_QWORD *)this + 1) = &unk_1E14E5648;
  *((_QWORD *)this + 2) = &unk_1E14E5668;
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 3) = 0;
  }
  v3 = (void *)*((_QWORD *)this + 10);
  if (v3)
  {

    *((_QWORD *)this + 10) = 0;
  }

  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_183F784CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_183F7861C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_183F78A14(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_183F78B5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL33_CFHTTPCookieStorageCreateDefaultPK13__CFAllocator_block_invoke(uint64_t a1)
{
  NSObject *v2;
  const char **v3;
  const char *v4;
  _BOOL4 v5;
  __CFBundle *MainBundle;
  const __CFString *Identifier;
  const __CFString *v8;
  NSObject *v9;
  void *v10;
  CFTypeRef v11;
  __CFDictionary *MutableDictionary;
  NSObject *v13;
  __CFBundle *v14;
  CFStringRef v15;
  const __CFAllocator *v16;
  const char **v17;
  uint8_t v18[16];
  uint8_t v19[16];
  uint8_t buf[16];

  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEFAULT, "Initializing CFHTTPCookieStorage singleton", buf, 2u);
  }
  if ((_xpc_runtime_is_app_sandboxed() & 1) != 0)
    goto LABEL_21;
  v3 = (const char **)_CFGetProgname();
  if (v3 && (v4 = *v3) != 0)
    v5 = !strncmp(*v3, "com.apple.WebKit", 0x10uLL) || !strcmp(v4, "MobileSafari") || strcmp(v4, "DashboardClient") == 0;
  else
    v5 = 0;
  MainBundle = CFBundleGetMainBundle();
  Identifier = CFBundleGetIdentifier(MainBundle);
  if (!v5)
  {
    v8 = Identifier;
    if (Identifier)
      v5 = CFStringCompare(Identifier, CFSTR("com.apple.webapp"), 0) == kCFCompareEqualTo
        || CFStringCompare(v8, CFSTR("com.apple.webapp1"), 0) == kCFCompareEqualTo
        || CFStringCompare(v8, CFSTR("com.apple.WebSheet"), 0) == kCFCompareEqualTo
        || CFStringCompare(v8, CFSTR("com.apple.NanoWebSheet"), 0) == kCFCompareEqualTo;
  }
  if (v5)
  {
LABEL_21:
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v9 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v19 = 0;
      _os_log_impl(&dword_183ECA000, v9, OS_LOG_TYPE_DEFAULT, "Creating default cookie storage with default identifier", v19, 2u);
    }
    v10 = (void *)CFRetain(CFSTR("com.apple.CFNetwork.defaultStorageSession"));
    goto LABEL_26;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v13 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v18 = 0;
    _os_log_impl(&dword_183ECA000, v13, OS_LOG_TYPE_DEFAULT, "Creating default cookie storage with process/bundle identifier", v18, 2u);
  }
  v14 = CFBundleGetMainBundle();
  v15 = CFBundleGetIdentifier(v14);
  if (!v15 || (v11 = CFRetain(v15)) == 0)
  {
    v16 = *(const __CFAllocator **)(a1 + 32);
    v17 = (const char **)_CFGetProgname();
    v10 = (void *)CFStringCreateWithCString(v16, *v17, 0x8000100u);
LABEL_26:
    v11 = v10;
  }
  MutableDictionary = cfTypeCreateMutableDictionary((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CFSTR("ident"), v11, CFSTR("persistent"), *MEMORY[0x1E0C9AE50], 0, 0);
  _CFHTTPCookieStorageCreateDefault(__CFAllocator const*)::cookieStorage = (uint64_t)_CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(*(const __CFAllocator **)(a1 + 32), MutableDictionary, 1);
  if (MutableDictionary)
    CFRelease(MutableDictionary);
  if (v11)
    CFRelease(v11);
}

char *_CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(const __CFAllocator *a1, CFDictionaryRef theDict, int a3)
{
  const __CFURL *Value;
  const __CFURL *v7;
  const __CFString *v8;
  const void *v9;
  CFURLRef v10;
  const __CFString *v11;
  CFTypeRef v12;
  const void *v13;
  __CFDictionary *MutableDictionary;
  char *v15;
  const void *v17;
  OpaqueCFHTTPCookieStorage *v18;
  const void *v19;
  CFTypeRef v20;
  __CFDictionary *MutableDict;
  const void *v22;
  const void *v23;
  __CFDictionary *v24;
  const __CFNumber *v25;
  uint64_t v26;
  const void *v27;
  CFTypeRef v28;
  __CFDictionary *v29;
  const void *v30;
  __CFDictionary *v31;
  const void *v32;
  __CFDictionary *v33;
  const void *v34;
  __CFDictionary *v35;
  const __CFDictionary *v36;
  void (**v37)(AutoScalar *__hidden);
  CFTypeRef v38;
  void (**valuePtr)(AutoDict *__hidden);
  CFTypeRef cf;
  uint64_t v41;
  uint64_t v42;

  if (!theDict)
    return (char *)_CookieStorageCreateInMemory(a1, 0);
  CFDictionaryGetValue(theDict, CFSTR("base"));
  Value = (const __CFURL *)CFDictionaryGetValue(theDict, CFSTR("url"));
  if (Value)
  {
    v7 = Value;
    v8 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("type"));
    v9 = CFDictionaryGetValue(theDict, CFSTR("policy"));
    v10 = CFURLCopyAbsoluteURL(v7);
    if (v8)
      v11 = v8;
    else
      v11 = CFSTR("binary");
    v12 = v9;
    if (!v9)
    {
      AutoScalar::AutoScalar((AutoScalar *)&valuePtr, (const __CFAllocator *)2);
      v12 = cf;
    }
    v13 = CFDictionaryGetValue(theDict, CFSTR("base"));
    MutableDictionary = cfTypeCreateMutableDictionary((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CFSTR("url"), v10, CFSTR("type"), v11, CFSTR("policy"), v12, CFSTR("base"), v13, 0, 0);
    if (!v9)
    {
      valuePtr = &off_1E14E47E8;
      if (cf)
        CFRelease(cf);
    }
    v15 = (char *)cacheOrCreate(MutableDictionary, (PrivateHTTPCookieStorage *(*)(const __CFDictionary *))_createByFile, a3);
    CFRelease(MutableDictionary);
    if (v10)
      CFRelease(v10);
  }
  else
  {
    v17 = CFDictionaryGetValue(theDict, CFSTR("ident"));
    if (v17)
    {
      v19 = v17;
      v20 = (CFTypeRef)*MEMORY[0x1E0C9AE00];
      valuePtr = &off_1E14EFC70;
      if (v20)
        v20 = CFRetain(v20);
      v41 = 0;
      v42 = 0;
      cf = v20;
      MutableDict = AutoDict::getMutableDict((AutoDict *)&valuePtr);
      CFDictionarySetValue(MutableDict, CFSTR("ident"), v19);
      v22 = CFDictionaryGetValue(theDict, CFSTR("persistent"));
      if (v22)
        v23 = v22;
      else
        v23 = (const void *)*MEMORY[0x1E0C9AE50];
      v24 = AutoDict::getMutableDict((AutoDict *)&valuePtr);
      if (v23)
        CFDictionarySetValue(v24, CFSTR("persistent"), v23);
      else
        CFDictionaryRemoveValue(v24, CFSTR("persistent"));
      v27 = CFDictionaryGetValue(theDict, CFSTR("policy"));
      v28 = v27;
      if (!v27)
      {
        AutoScalar::AutoScalar((AutoScalar *)&v37, (const __CFAllocator *)2);
        v28 = v38;
      }
      v29 = AutoDict::getMutableDict((AutoDict *)&valuePtr);
      if (v28)
        CFDictionarySetValue(v29, CFSTR("policy"), v28);
      else
        CFDictionaryRemoveValue(v29, CFSTR("policy"));
      if (!v27)
      {
        v37 = &off_1E14E47E8;
        if (v38)
          CFRelease(v38);
      }
      v30 = CFDictionaryGetValue(theDict, CFSTR("kCFURLStorageSessionAppIdentifier"));
      if (v30)
      {
        v31 = AutoDict::getMutableDict((AutoDict *)&valuePtr);
        CFDictionarySetValue(v31, CFSTR("kCFURLStorageSessionAppIdentifier"), v30);
      }
      v32 = CFDictionaryGetValue(theDict, CFSTR("kCFHTTPCookieStorageGroupContainerURL"));
      if (v32)
      {
        v33 = AutoDict::getMutableDict((AutoDict *)&valuePtr);
        CFDictionarySetValue(v33, CFSTR("kCFHTTPCookieStorageGroupContainerURL"), v32);
      }
      v34 = CFDictionaryGetValue(theDict, CFSTR("base"));
      if (v34)
      {
        v35 = AutoDict::getMutableDict((AutoDict *)&valuePtr);
        CFDictionarySetValue(v35, CFSTR("base"), v34);
      }
      v36 = AutoDict::copyDictAndSetEmpty((AutoDict *)&valuePtr);
      v15 = (char *)cacheOrCreate(v36, (PrivateHTTPCookieStorage *(*)(const __CFDictionary *))_createByIdentifier, a3);
      CFRelease(v36);
      AutoDict::~AutoDict((AutoDict *)&valuePtr);
    }
    else
    {
      v15 = (char *)_CookieStorageCreateInMemory(a1, v18);
      if (v15)
      {
        v25 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("policy"));
        if (v25)
        {
          LODWORD(valuePtr) = 0;
          if (CFNumberGetValue(v25, kCFNumberIntType, &valuePtr))
            v26 = valuePtr;
          else
            v26 = 0;
          CFHTTPCookieStorageSetCookieAcceptPolicy(v15, v26);
        }
      }
    }
  }
  return v15;
}

void sub_183F79258(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf,uint64_t a21,CFTypeRef a22)
{
  AutoDict::~AutoDict((AutoDict *)&a21);
  _Unwind_Resume(a1);
}

uint64_t cacheOrCreate(CFDictionaryRef theDict, PrivateHTTPCookieStorage *(*a2)(const __CFDictionary *), int a3)
{
  const __CFAllocator *v6;
  __CFDictionary *MutableCopy;
  unsigned __int8 *Value;
  unsigned __int8 *v9;
  uint64_t v10;
  pthread_mutex_t *v11;
  int v12;
  _QWORD *v13;
  PrivateHTTPCookieStorage *v14;
  const __CFNumber *v15;
  uint64_t Instance;
  int valuePtr;

  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theDict);
  CFDictionaryRemoveValue(MutableCopy, CFSTR("policy"));
  pthread_mutex_lock(&sLock);
  if (sStorageDict)
  {
    Value = (unsigned __int8 *)CFDictionaryGetValue(*(CFDictionaryRef *)(sStorageDict + 8), MutableCopy);
    if (Value)
    {
      v9 = Value;
      v10 = *((_QWORD *)Value + 4);
      if (v10)
      {
        v11 = (pthread_mutex_t *)(v10 + 8);
        pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
        v12 = v9[40];
        pthread_mutex_unlock(v11);
        if (v12)
        {
LABEL_5:
          (*(void (**)(unsigned __int8 *))(*(_QWORD *)v9 + 40))(v9);
          goto LABEL_12;
        }
      }
      else if (Value[40])
      {
        goto LABEL_5;
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(sStorageDict + 8), MutableCopy);
    }
  }
  else
  {
    v13 = (_QWORD *)operator new();
    *v13 = &off_1E14EA448;
    v13[1] = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
    sStorageDict = (uint64_t)v13;
    atexit((void (*)(void))CFHTTPCookieStorageFlushCookieStores);
  }
  v14 = a2(theDict);
  v9 = (unsigned __int8 *)v14;
  if (a3 && v14)
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(sStorageDict + 8), MutableCopy, v14);
LABEL_12:
  if (MutableCopy)
    CFRelease(MutableCopy);
  pthread_mutex_unlock(&sLock);
  if (!v9)
    return 0;
  v15 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("policy"));
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 112) = 0u;
  *(_OWORD *)(Instance + 128) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_QWORD *)(Instance + 16) = &off_1E14E8888;
  *(_QWORD *)(Instance + 24) = &unk_1E14E88D0;
  *(_DWORD *)(Instance + 136) = 0;
  if (v15)
  {
    valuePtr = 0;
    CFNumberGetValue(v15, kCFNumberIntType, &valuePtr);
  }
  HTTPCookieStorage::initialize((HTTPCookieStorage *)(Instance + 16), (PrivateHTTPCookieStorage *)v9);
  (*(void (**)(unsigned __int8 *))(*(_QWORD *)v9 + 48))(v9);
  return Instance;
}

void sub_183F79550(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

_OWORD *_createByIdentifier(const __CFDictionary *a1)
{
  const __CFString *Value;
  const void *v3;
  const void *v4;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  CFURLRef v8;
  const void *v9;
  CFTypeRef v10;
  const void *v11;
  __CFDictionary *MutableDictionary;
  _OWORD *v13;
  void (**v15)(AutoScalar *__hidden);
  CFTypeRef v16;

  Value = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("ident"));
  v3 = CFDictionaryGetValue(a1, CFSTR("persistent"));
  v4 = (const void *)*MEMORY[0x1E0C9AE40];
  CFDictionaryGetValue(a1, CFSTR("kCFURLStorageSessionAppIdentifier"));
  v5 = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("kCFHTTPCookieStorageGroupContainerURL"));
  if (v3 == v4)
  {
    v13 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 88, 0);
    *v13 = 0u;
    v13[1] = 0u;
    v13[2] = 0u;
    v13[3] = 0u;
    v13[4] = 0u;
    *((_QWORD *)v13 + 10) = 0;
    MemoryCookieStorage::MemoryCookieStorage((MemoryCookieStorage *)v13, 1);
  }
  else
  {
    v8 = copyParameterizedCookieStorageLocation(v5, Value, v6, v7);
    v9 = CFDictionaryGetValue(a1, CFSTR("policy"));
    v10 = v9;
    if (!v9)
    {
      AutoScalar::AutoScalar((AutoScalar *)&v15, (const __CFAllocator *)2);
      v10 = v16;
    }
    v11 = CFDictionaryGetValue(a1, CFSTR("base"));
    MutableDictionary = cfTypeCreateMutableDictionary((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CFSTR("url"), v8, CFSTR("safeparent"), *MEMORY[0x1E0C9AE50], CFSTR("type"), CFSTR("binary"), CFSTR("policy"), v10, CFSTR("base"), v11, 0, 0);
    if (!v9)
    {
      v15 = &off_1E14E47E8;
      if (v16)
        CFRelease(v16);
    }
    v13 = _createByFile(MutableDictionary);
    CFRelease(v8);
    CFRelease(MutableDictionary);
  }
  return v13;
}

void sub_183F79724(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  const void *v4;

  if (!v1)
  {
    *(_QWORD *)(v2 - 64) = &off_1E14E47E8;
    v4 = *(const void **)(v2 - 56);
    if (v4)
      CFRelease(v4);
  }
  _Unwind_Resume(exception_object);
}

__CFDictionary *cfTypeCreateMutableDictionary(const __CFAllocator *a1, ...)
{
  unint64_t v1;
  uint64_t v2;
  __CFDictionary *Mutable;
  unint64_t v4;
  const void **v5;
  const void *v6;
  const void *v7;
  va_list v10;
  const void **v11;
  va_list va;

  va_start(va, a1);
  va_copy(v10, va);
  va_copy((va_list)v11, va);
  v1 = -1;
  do
  {
    v2 = va_arg(v10, _QWORD);
    ++v1;
  }
  while (v2);
  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v1 >= 2)
  {
    v4 = v1 >> 1;
    while (1)
    {
      v5 = v11;
      v6 = *v11;
      v11 += 2;
      v7 = v5[1];
      if (!v6 || v7 == 0)
        break;
      CFDictionarySetValue(Mutable, v6, v7);
      if (!--v4)
        return Mutable;
    }
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

CFURLRef copyParameterizedCookieStorageLocation(const __CFString *a1, CFStringRef theString1, const __CFString *a3, const __CFString *a4)
{
  const __CFString *v5;
  const __CFAllocator *v7;
  const void *v8;
  const void *v9;
  const __CFString *v10;
  CFStringRef v11;
  const __CFURL *v12;
  CFURLRef v13;

  v5 = CFSTR("Cookies");
  if (theString1 && CFStringCompare(theString1, CFSTR("com.apple.CFNetwork.defaultStorageSession"), 0))
    v5 = theString1;
  if (a1)
  {
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v8 = (const void *)MEMORY[0x186DB694C](*MEMORY[0x1E0C9AE00], CFSTR("Library/Cookies/"), 0, 1, a1);
    v5 = CFSTR("Cookies");
  }
  else
  {
    v9 = (const void *)CFCopyHomeDirectoryURLForUser();
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v8 = (const void *)MEMORY[0x186DB694C](*MEMORY[0x1E0C9AE00], CFSTR("Library/Cookies/"), 0, 1, v9);
    if (v9)
      CFRelease(v9);
  }
  v10 = CFStringCreateWithFormat(v7, 0, CFSTR("%@.%@"), v5, CFSTR("binarycookies"));
  v11 = CFURLCreateStringByAddingPercentEscapes(0, v10, 0, CFSTR("/"), 0x8000100u);
  v12 = (const __CFURL *)MEMORY[0x186DB694C](v7, v11, 0, 0, v8);
  if (v8)
    CFRelease(v8);
  if (v10)
    CFRelease(v10);
  if (v11)
    CFRelease(v11);
  v13 = CFURLCopyAbsoluteURL(v12);
  if (v12)
    CFRelease(v12);
  return v13;
}

uint64_t __CFURLCacheCreateInternal(const __CFAllocator *a1, uint64_t a2, uint64_t a3, const __CFString *a4, char a5, int a6, char a7)
{
  uint64_t Instance;
  const __CFString *Copy;
  _QWORD *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  _QWORD *block;
  uint64_t block_8;
  uint64_t (*v22)(uint64_t);
  void *v23;
  uint64_t (*v24)(void);

  block = (_QWORD *)MEMORY[0x1E0C809B0];
  block_8 = 3221225472;
  v22 = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2382;
  v23 = &__block_descriptor_40_e5_v8__0l;
  v24 = _URLCacheRegisterClass;
  if (_CFURLCacheClassRegistration != -1)
    dispatch_once(&_CFURLCacheClassRegistration, &block);
  Instance = _CFRuntimeCreateInstance();
  *(_QWORD *)(Instance + 16) = 0;
  *(_QWORD *)(Instance + 24) = 0;
  if (a4)
  {
    if (a6)
      Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a4);
    else
      Copy = __CreatePathToCacheDirectory(a4, a5);
    a4 = Copy;
  }
  v15 = operator new(0x298uLL);
  v15[1] = 0;
  v15[2] = 0;
  *v15 = &off_1E14F08A0;
  __CFURLCache::__CFURLCache((__CFURLCache *)(v15 + 3), (const _CFURLCache *)Instance, a2, a3, a4, a7);
  block = v15 + 3;
  block_8 = (uint64_t)v15;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&block, v15 + 4, (uint64_t)(v15 + 3));
  v16 = (std::__shared_weak_count *)block_8;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(Instance + 16), (uint64_t)block, block_8);
  if (a4)
    CFRelease(a4);
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  return Instance;
}

void sub_183F79D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;
  void *v11;

  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void __CFURLCache::__CFURLCache(__CFURLCache *this, const _CFURLCache *a2, uint64_t a3, uint64_t a4, const __CFString *a5, char a6)
{
  NSObject *v12;
  const __CFAllocator *v13;
  BOOL v14;
  int v15;
  int64x2_t v16;
  __CFString *PathToCacheDirectory;
  id v18;
  double v19;
  uint64_t block;
  uint64_t v21;
  void (*v22)(uint64_t);
  void *v23;
  __CFURLCache *v24;
  char buffer[1024];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E14E6600;
  *((_QWORD *)this + 6) = &off_1E14E6990;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 56), 0);
  *((_OWORD *)this + 14) = 0u;
  *((_QWORD *)this + 6) = &off_1E14E5818;
  *((_OWORD *)this + 15) = 0u;
  *((_DWORD *)this + 64) = 1065353216;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((_BYTE *)this + 632) = a6;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 18) = 0;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((_QWORD *)this + 55) = a2;
  *((_BYTE *)this + 40) = 0;
  *((_QWORD *)this + 25) = 0x3FA999999999999ALL;
  *((_QWORD *)this + 27) = 0;
  *((_BYTE *)this + 528) = 0;
  *((_QWORD *)this + 65) = 0;
  *((_WORD *)this + 60) = 0;
  *((_DWORD *)this + 31) = 0;
  *((_QWORD *)this + 16) = 0;
  *(_OWORD *)((char *)this + 536) = 0u;
  v12 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *((_QWORD *)this + 17) = dispatch_queue_create("com.apple.CFNetwork.CacheDB-write", v12);
  if (pthread_mutex_init((pthread_mutex_t *)((char *)this + 456), 0)
    || pthread_mutex_init((pthread_mutex_t *)((char *)this + 312), 0)
    || pthread_mutex_init((pthread_mutex_t *)((char *)this + 376), 0)
    || pthread_mutex_init((pthread_mutex_t *)((char *)this + 552), 0))
  {
    return;
  }
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *((_QWORD *)this + 56) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  *((_QWORD *)this + 65) = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)this + 67) = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (a5)
    *((_QWORD *)this + 27) = CFStringCreateCopy(v13, a5);
  if (a4)
    v14 = a4 < 15001;
  else
    v14 = 0;
  v15 = v14;
  if (a3 && a3 < 1025)
  {
    *((_QWORD *)this + 21) = 0x400000;
    if (v15)
    {
      *((_QWORD *)this + 22) = 20971520;
      v16 = (int64x2_t)xmmword_1841E3880;
LABEL_25:
      *(int64x2_t *)((char *)this + 184) = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(v16), *((double *)this + 25)));
      goto LABEL_26;
    }
    *((_QWORD *)this + 22) = a4;
    a3 = 0x400000;
LABEL_23:
    if (a4)
    {
      v16.i64[0] = a3;
      v16.i64[1] = a4;
      goto LABEL_25;
    }
    goto LABEL_26;
  }
  *((_QWORD *)this + 21) = a3;
  if ((v15 & 1) == 0)
  {
    *((_QWORD *)this + 22) = a4;
    if (!a3)
      goto LABEL_26;
    goto LABEL_23;
  }
  *((_QWORD *)this + 22) = 20971520;
  if (a3)
  {
    v16 = vdupq_n_s64(0x1400000uLL);
    v16.i64[0] = a3;
    goto LABEL_25;
  }
LABEL_26:
  *(_OWORD *)((char *)this + 616) = 0u;
  block = MEMORY[0x1E0C809B0];
  v21 = 3221225472;
  v22 = ___ZN12__CFURLCacheC2EPK11_CFURLCachellPK10__CFStringb_block_invoke;
  v23 = &__block_descriptor_40_e5_v8__0l;
  v24 = this;
  if (__CFURLCache::__CFURLCache(_CFURLCache const*,long,long,__CFString const*,BOOL)::onceToken != -1)
    dispatch_once(&__CFURLCache::__CFURLCache(_CFURLCache const*,long,long,__CFString const*,BOOL)::onceToken, &block);
  if (*((_BYTE *)this + 632))
  {
    PathToCacheDirectory = (__CFString *)*((_QWORD *)this + 27);
    if (!PathToCacheDirectory)
    {
      PathToCacheDirectory = __CreatePathToCacheDirectory(0, 0);
      *((_QWORD *)this + 27) = PathToCacheDirectory;
    }
    if (CFStringGetFileSystemRepresentation(PathToCacheDirectory, buffer, 1024))
      __BuildPath(buffer);
    v18 = (id)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@/VaryState.db"), *((_QWORD *)this + 27), block, v21, v22, v23, v24);
    *((_QWORD *)this + 77) = v18;
    if (sqlite3_open((const char *)objc_msgSend(v18, "UTF8String"), (sqlite3 **)this + 78))
    {
      *((_QWORD *)this + 78) = 0;
    }
    else
    {
      __retainStorageAssertion(*((void **)this + 17));
      __CFURLCache::_createVaryStateTable((sqlite3 **)this);
      __releaseStorageAssertion(v19);
    }
  }
}

void sub_183F7A0B0(_Unwind_Exception *a1)
{
  uint64_t v1;
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v7;

  std::deque<__CFURLCacheNode *>::~deque[abi:nn180100](v4);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table(v3);
  *(_QWORD *)(v1 + 48) = v5;
  pthread_mutex_destroy(v2);
  v7 = *(std::__shared_weak_count **)(v1 + 16);
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
  _Unwind_Resume(a1);
}

void *_createByFile(const __CFDictionary *a1)
{
  const __CFURL *Value;
  const void *v3;
  const __CFAllocator *v4;
  void *v5;
  CFTypeID v6;
  uint64_t v7;
  const __CFAllocator *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  const __CFURL *v15;
  CFStringRef v16;
  CFStringRef v17;
  uint64_t v18;
  CFStringRef v19;
  CFStringRef v20;
  double v21;
  CFStringRef v22;
  const char *v23;
  CFStringRef v24;
  double v25;
  CFStringRef v26;
  const char *v27;
  CFStringRef v28;
  size_t v29;
  const __CFURL *v30;
  CFStringRef v31;
  const __CFAllocator *v32;
  const __CFData *ExternalRepresentation;
  const __CFData *v34;
  const UInt8 *BytePtr;
  CC_LONG Length;
  __CFString *Mutable;
  uint64_t i;
  __CFNotificationCenter *DarwinNotifyCenter;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  CFURLRef v43;
  const __CFAllocator *v44;
  _QWORD *v45;
  char cStr[128];
  UInt8 buffer[1032];
  void (**v49)(AutoString *__hidden);
  CFStringRef v50;
  uint64_t v51;
  uint64_t v52;
  void (**v53)(AutoString *__hidden);
  uint64_t v54;
  void (*v55)(uint64_t, CFDictionaryRef);
  void *v56;
  char *v57;
  int v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  Value = (const __CFURL *)CFDictionaryGetValue(a1, CFSTR("url"));
  v3 = CFDictionaryGetValue(a1, CFSTR("safeparent"));
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 336, 0);
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  *((_OWORD *)v5 + 11) = 0u;
  *((_OWORD *)v5 + 12) = 0u;
  *((_OWORD *)v5 + 13) = 0u;
  *((_OWORD *)v5 + 14) = 0u;
  *((_OWORD *)v5 + 15) = 0u;
  *((_OWORD *)v5 + 16) = 0u;
  *((_OWORD *)v5 + 17) = 0u;
  *((_OWORD *)v5 + 18) = 0u;
  *((_OWORD *)v5 + 19) = 0u;
  *((_OWORD *)v5 + 20) = 0u;
  if (v3)
  {
    v6 = CFGetTypeID(v3);
    if (v6 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buffer = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buffer, 2u);
    }
    LODWORD(v3) = *MEMORY[0x1E0C9AE50] == (_QWORD)v3;
  }
  PrivateHTTPCookieStorage::PrivateHTTPCookieStorage((PrivateHTTPCookieStorage *)v5, 1);
  *(_QWORD *)v5 = off_1E14E85A8;
  *((_QWORD *)v5 + 3) = &unk_1E14E8690;
  v7 = operator new();
  FilePathStorage<unsigned char>::FilePathStorage(v7, Value, (int)v3, (int)v3, 1u);
  *((_QWORD *)v5 + 9) = v7;
  *(_QWORD *)v5 = off_1E14E9B38;
  *((_QWORD *)v5 + 3) = &unk_1E14E9C20;
  *((_DWORD *)v5 + 80) = 2;
  v8 = (const __CFAllocator *)*((_QWORD *)v5 + 1);
  v9 = CFAllocatorAllocate(v8, 32, 0);
  *v9 = off_1E14E6620;
  v9[1] = v8;
  v9[2] = &unk_1E14E6648;
  v9[3] = 0;
  v9[3] = CFDictionaryCreateMutable(v8, 0, &CStringKeyCallbacks::caseInsensitiveCallbacks(void)::sCallbacks, MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)v5 + 35) = v9;
  v10 = CFAllocatorAllocate(v8, 32, 0);
  *v10 = off_1E14E6620;
  v10[1] = v8;
  v10[2] = &unk_1E14E6648;
  v10[3] = 0;
  v10[3] = CFDictionaryCreateMutable(v8, 0, &CStringKeyCallbacks::caseInsensitiveCallbacks(void)::sCallbacks, MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)v5 + 36) = v10;
  v11 = CFAllocatorAllocate(v8, 32, 0);
  *v11 = off_1E14E6620;
  v11[1] = v8;
  v11[2] = &unk_1E14E6648;
  v11[3] = 0;
  v11[3] = CFDictionaryCreateMutable(v8, 0, &CStringKeyCallbacks::caseInsensitiveCallbacks(void)::sCallbacks, MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)v5 + 37) = v11;
  DiskCookieStorage::readFileToCookies((DiskCookieStorage *)v5, *((MemoryCookies **)v5 + 36));
  *((_QWORD *)v5 + 10) = dispatch_queue_create("diskcookies", 0);
  v12 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_10170, 1);
  v13 = v12;
  if (v12
    && (*(unsigned int (**)(uint64_t, const char *, void *))(*(_QWORD *)v12 + 32))(v12, "DiskCookieStorage Construction", v5))
  {
    v14 = strlen((const char *)(*((_QWORD *)v5 + 9) + 1));
    v15 = CFURLCreateFromFileSystemRepresentation(*((CFAllocatorRef *)v5 + 1), (const UInt8 *)(*((_QWORD *)v5 + 9) + 1), v14, 0);
    (*(void (**)(uint64_t, const char *, const __CFURL *))(*(_QWORD *)v13 + 40))(v13, "Accessing", v15);
    if (CFURLGetFileSystemRepresentation(v15, 1u, buffer, 1023))
    {
      v53 = &off_1E14E4818;
      v16 = CFStringCreateWithCString(v4, "Path", 0x8000100u);
      v55 = 0;
      v56 = 0;
      v54 = (uint64_t)v16;
      v49 = &off_1E14E4818;
      v17 = CFStringCreateWithCString(v4, (const char *)buffer, 0x8000100u);
      v52 = 0;
      v50 = v17;
      v51 = 0;
      (*(void (**)(uint64_t, uint64_t, CFStringRef))(*(_QWORD *)v13 + 64))(v13, v54, v17);
      AutoString::~AutoString((AutoString *)&v49);
      AutoString::~AutoString((AutoString *)&v53);
    }
    else
    {
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v13 + 72))(v13, "Path", CFSTR("can't create filesystem path for %@"));
    }
    if (v15)
      CFRelease(v15);
    v18 = *((_QWORD *)v5 + 36);
    v53 = (void (**)(AutoString *__hidden))MEMORY[0x1E0C809B0];
    v54 = 3221225472;
    v55 = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
    v56 = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
    v57 = cStr;
    v58 = 128;
    MemoryCookies::withImmutableDomains(v18, (uint64_t)&v53);
    v53 = &off_1E14E4818;
    v19 = CFStringCreateWithCString(v4, "Read from disk", 0x8000100u);
    v55 = 0;
    v56 = 0;
    v54 = (uint64_t)v19;
    v49 = &off_1E14E4818;
    v20 = CFStringCreateWithCString(v4, cStr, 0x8000100u);
    v52 = 0;
    v50 = v20;
    v51 = 0;
    (*(void (**)(uint64_t, uint64_t, CFStringRef))(*(_QWORD *)v13 + 64))(v13, v54, v20);
    AutoString::~AutoString((AutoString *)&v49);
    AutoString::~AutoString((AutoString *)&v53);
    os_unfair_lock_lock((os_unfair_lock_t)v5 + 22);
    v21 = *((double *)v5 + 12);
    os_unfair_lock_unlock((os_unfair_lock_t)v5 + 22);
    v53 = &off_1E14E4818;
    v22 = CFStringCreateWithCString(v4, "Dirty", 0x8000100u);
    v55 = 0;
    v56 = 0;
    if (v21 == 0.0)
      v23 = "NO";
    else
      v23 = "YES";
    v54 = (uint64_t)v22;
    v49 = &off_1E14E4818;
    v24 = CFStringCreateWithCString(v4, v23, 0x8000100u);
    v52 = 0;
    v50 = v24;
    v51 = 0;
    (*(void (**)(uint64_t, uint64_t, CFStringRef))(*(_QWORD *)v13 + 64))(v13, v54, v24);
    AutoString::~AutoString((AutoString *)&v49);
    AutoString::~AutoString((AutoString *)&v53);
    os_unfair_lock_lock((os_unfair_lock_t)v5 + 22);
    v25 = *((double *)v5 + 14);
    os_unfair_lock_unlock((os_unfair_lock_t)v5 + 22);
    v53 = &off_1E14E4818;
    v26 = CFStringCreateWithCString(v4, "Writing", 0x8000100u);
    v55 = 0;
    v56 = 0;
    if (v25 == 0.0)
      v27 = "NO";
    else
      v27 = "YES";
    v54 = (uint64_t)v26;
    v49 = &off_1E14E4818;
    v28 = CFStringCreateWithCString(v4, v27, 0x8000100u);
    v52 = 0;
    v50 = v28;
    v51 = 0;
    (*(void (**)(uint64_t, uint64_t, CFStringRef))(*(_QWORD *)v13 + 64))(v13, v54, v28);
    AutoString::~AutoString((AutoString *)&v49);
    AutoString::~AutoString((AutoString *)&v53);
    (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v13 + 72))(v13, "Policy", CFSTR("%d"));
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  }
  MemoryCookies::mergeCookiesFrom(*((CFAllocatorRef **)v5 + 37), *((_QWORD *)v5 + 36));
  *((_WORD *)v5 + 162) = 0;
  v29 = strlen((const char *)(*((_QWORD *)v5 + 9) + 1));
  v30 = CFURLCreateFromFileSystemRepresentation(*((CFAllocatorRef *)v5 + 1), (const UInt8 *)(*((_QWORD *)v5 + 9) + 1), v29, 0);
  v31 = CFURLCopyPath(v30);
  v32 = CFGetAllocator(v31);
  ExternalRepresentation = CFStringCreateExternalRepresentation(v32, v31, 0x8000100u, 0);
  v34 = ExternalRepresentation;
  if (ExternalRepresentation)
  {
    BytePtr = CFDataGetBytePtr(ExternalRepresentation);
    Length = CFDataGetLength(v34);
    CC_SHA1(BytePtr, Length, buffer);
    Mutable = CFStringCreateMutable(v4, 40);
    for (i = 0; i != 20; ++i)
      CFStringAppendFormat(Mutable, 0, CFSTR("%02x"), buffer[i]);
    CFRelease(v34);
  }
  else
  {
    Mutable = 0;
  }
  *((_QWORD *)v5 + 41) = CFStringCreateWithFormat(*((CFAllocatorRef *)v5 + 1), 0, CFSTR("com.apple.CFNetwork.CookiesChanged.%@"), Mutable);
  if (Mutable)
    CFRelease(Mutable);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  if (DarwinNotifyCenter)
    CFNotificationCenterAddObserver(DarwinNotifyCenter, v5, (CFNotificationCallback)DiskCookieStorage::_handleCookiesChangedNotification, *((CFStringRef *)v5 + 41), 0, CFNotificationSuspensionBehaviorCoalesce);
  if (v31)
    CFRelease(v31);
  if (v30)
    CFRelease(v30);
  v40 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_88_10191, 1);
  v41 = v40;
  if (v40
    && (*(unsigned int (**)(uint64_t, const char *, void *))(*(_QWORD *)v40 + 32))(v40, "DiskCookieStorage Journaling On", v5))
  {
    v42 = strlen((const char *)(*((_QWORD *)v5 + 9) + 1));
    v43 = CFURLCreateFromFileSystemRepresentation(*((CFAllocatorRef *)v5 + 1), (const UInt8 *)(*((_QWORD *)v5 + 9) + 1), v42, 0);
    (*(void (**)(uint64_t, const char *, CFURLRef))(*(_QWORD *)v41 + 40))(v41, "File", v43);
    if (v43)
      CFRelease(v43);
    (*(void (**)(uint64_t))(*(_QWORD *)v41 + 8))(v41);
  }
  if (!*((_QWORD *)v5 + 38))
  {
    v44 = (const __CFAllocator *)*((_QWORD *)v5 + 1);
    v45 = CFAllocatorAllocate(v44, 24, 0);
    v45[1] = v44;
    v45[2] = 0;
    *v45 = off_1E14EFF60;
    v45[2] = CFDataCreateMutable(v44, 0);
    *((_QWORD *)v5 + 38) = v45;
  }
  return v5;
}

void sub_183F7AB20(_Unwind_Exception *a1)
{
  DiskCookieStorage *v1;
  uint64_t v2;

  AutoString::~AutoString((AutoString *)&STACK[0x498]);
  AutoString::~AutoString((AutoString *)(v2 - 256));
  DiskCookieStorage::~DiskCookieStorage(v1);
  _Unwind_Resume(a1);
}

_QWORD *_CookieStorageCreateInMemory(const __CFAllocator *a1, OpaqueCFHTTPCookieStorage *a2)
{
  uint64_t Instance;

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
    return -[NSHTTPCookieStorageToCookie2Storage initMemoryCookieStore]([NSHTTPCookieStorageToCookie2Storage alloc]);
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 112) = 0u;
  *(_OWORD *)(Instance + 128) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_QWORD *)(Instance + 16) = &off_1E14E8888;
  *(_QWORD *)(Instance + 24) = &unk_1E14E88D0;
  *(_DWORD *)(Instance + 136) = 0;
  HTTPCookieStorage::initialize((HTTPCookieStorage *)(Instance + 16), 0);
  return (_QWORD *)Instance;
}

uint64_t HTTPCookieStorage::initialize(HTTPCookieStorage *this, PrivateHTTPCookieStorage *a2)
{
  _OWORD *v3;
  const __CFAllocator *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  if (a2)
  {
    *((_QWORD *)this + 2) = a2;
    (*(void (**)(PrivateHTTPCookieStorage *))(*(_QWORD *)a2 + 40))(a2);
    v3 = (_OWORD *)*((_QWORD *)this + 2);
  }
  else
  {
    v4 = CFGetAllocator((char *)this - 16);
    v3 = CFAllocatorAllocate(v4, 88, 0);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    v3[4] = 0u;
    *((_QWORD *)v3 + 10) = 0;
    MemoryCookieStorage::MemoryCookieStorage((MemoryCookieStorage *)v3, 0);
    *((_QWORD *)this + 2) = v5;
  }
  v6 = *((_QWORD *)v3 + 4);
  if (v6)
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  result = (*(uint64_t (**)(_OWORD *))(*(_QWORD *)v3 + 72))(v3);
  if (v6)
    result = pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  *((_QWORD *)this + 7) = 0;
  *((_BYTE *)this + 64) = 0;
  *((_QWORD *)this + 9) = -1;
  return result;
}

void sub_183F7AD68(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

void MemoryCookieStorage::MemoryCookieStorage(MemoryCookieStorage *this, int a2)
{
  uint64_t v3;
  _OWORD *v4;
  const __CFAllocator *v5;

  PrivateHTTPCookieStorage::PrivateHTTPCookieStorage(this, a2);
  *(_QWORD *)v3 = off_1E14E9FF8;
  *(_QWORD *)(v3 + 24) = &unk_1E14EA0D0;
  v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(v3 + 8), 32, 0);
  *v4 = 0u;
  v4[1] = 0u;
  v5 = (const __CFAllocator *)*((_QWORD *)this + 1);
  *(_QWORD *)v4 = off_1E14E6620;
  *((_QWORD *)v4 + 1) = v5;
  *((_QWORD *)v4 + 2) = &unk_1E14E6648;
  *((_QWORD *)v4 + 3) = CFDictionaryCreateMutable(v5, 0, &CStringKeyCallbacks::caseInsensitiveCallbacks(void)::sCallbacks, MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)this + 9) = v4;
  *((_DWORD *)this + 20) = 2;
}

void sub_183F7AE20(_Unwind_Exception *a1)
{
  PrivateHTTPCookieStorage *v1;
  uint64_t v2;

  *(_QWORD *)(v2 + 16) = &off_1E14E5838;
  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(v1);
  _Unwind_Resume(a1);
}

void PrivateHTTPCookieStorage::PrivateHTTPCookieStorage(PrivateHTTPCookieStorage *this, int a2)
{
  uint64_t v2;
  _CoreLockable *v4;

  v2 = *MEMORY[0x1E0C9AE00];
  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = v2;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14ED120;
  *((_QWORD *)this + 3) = &unk_1E14ED1F8;
  if (a2)
  {
    v4 = (_CoreLockable *)operator new();
    _CoreLockable::_CoreLockable(v4, 1);
    *(_QWORD *)v4 = &off_1E14E5818;
    *((_QWORD *)this + 4) = v4;
  }
  *((_BYTE *)this + 40) = 1;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
}

void sub_183F7AF14(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x186DB748C](v2, 0x1081C4076DFA842);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t FilePathStorage<unsigned char>::FilePathStorage(uint64_t a1, CFURLRef url, int a3, int a4, Boolean a5)
{
  const __CFURL *v9;
  const __CFURL *v10;
  const __CFURL *v11;
  const __CFAllocator *v12;
  const __CFURL *PathComponent;
  const __CFString *v14;
  const __CFString *v15;
  int v16;

  *(_BYTE *)a1 = CFURLGetFileSystemRepresentation(url, a5, (UInt8 *)(a1 + 1), 1024);
  *(_DWORD *)(a1 + 1028) = a3;
  v9 = (const __CFURL *)CFCopyHomeDirectoryURLForUser();
  if (!v9)
  {
    *(_DWORD *)(a1 + 1032) = a4;
    return a1;
  }
  v10 = v9;
  v11 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, CFSTR("Library/Cookies"), 1u);
  v12 = CFGetAllocator(url);
  PathComponent = CFURLCreateCopyDeletingLastPathComponent(v12, url);
  if (PathComponent && v11)
  {
    v14 = CFURLGetString(v11);
    v15 = CFURLGetString(PathComponent);
    if (CFStringCompare(v14, v15, 1uLL))
      v16 = a4;
    else
      v16 = 1;
    *(_DWORD *)(a1 + 1032) = v16;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 1032) = a4;
  if (v11)
LABEL_10:
    CFRelease(v11);
  if (PathComponent)
    CFRelease(PathComponent);
  CFRelease(v10);
  return a1;
}

void DiskCookieStorage::readFileToCookies(DiskCookieStorage *this, MemoryCookies *a2)
{
  const __CFAllocator *v4;
  const char *v5;
  size_t v6;
  const __CFURL *v7;
  __CFReadStream *v8;
  const void *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  CFTypeID v12;
  const __CFNumber *Value;
  const __CFNumber *v14;
  CFTypeID v15;
  const __CFAllocator *v16;
  CFStringRef v17;
  std::error_code *v18;
  int v19;
  const char *v20;
  int v21;
  CFTypeRef cf;
  uint64_t v23;
  int v24;
  void *v25;
  CFDataRef data;
  stat valuePtr[7];
  _QWORD v28[20];

  v28[19] = *MEMORY[0x1E0C80C00];
  *((_BYTE *)this + 324) = 0;
  v4 = (const __CFAllocator *)*((_QWORD *)this + 1);
  v5 = (const char *)(*((_QWORD *)this + 9) + 1);
  v6 = strlen(v5);
  v7 = CFURLCreateFromFileSystemRepresentation(v4, (const UInt8 *)v5, v6, 0);
  v8 = CFReadStreamCreateWithFile(*((CFAllocatorRef *)this + 1), v7);
  CFRelease(v7);
  if (v8)
  {
    if (CFReadStreamOpen(v8))
    {
      data = 0;
      v9 = (const void *)(*(uint64_t (**)(DiskCookieStorage *, __CFReadStream *, MemoryCookies *, CFDataRef *))(*(_QWORD *)this + 208))(this, v8, a2, &data);
      CFReadStreamClose(v8);
      if (data)
      {
        v10 = (const __CFDictionary *)CFPropertyListCreateWithData(*((CFAllocatorRef *)this + 1), data, 0, 0, 0);
        v11 = v10;
        if (v10)
        {
          v12 = CFGetTypeID(v10);
          if (v12 == CFDictionaryGetTypeID())
          {
            Value = (const __CFNumber *)CFDictionaryGetValue(v11, CFSTR("NSHTTPCookieAcceptPolicy"));
            v14 = Value;
            if (Value)
            {
              v15 = CFGetTypeID(Value);
              if (v15 == CFNumberGetTypeID())
              {
                valuePtr[0].st_dev = 0;
                CFNumberGetValue(v14, kCFNumberIntType, valuePtr);
                *((_DWORD *)this + 80) = valuePtr[0].st_dev;
              }
            }
          }
          CFRelease(v11);
        }
        if (data)
          CFRelease(data);
        if (!v9)
          goto LABEL_22;
        goto LABEL_15;
      }
      *((_DWORD *)this + 80) = 2;
      if (v9)
      {
LABEL_15:
        if (!lstat((const char *)(*((_QWORD *)this + 9) + 1), valuePtr))
        {
          v20 = "readFileToCookies";
          v21 = 0;
          v25 = 0;
          cf = 0;
          v23 = 0;
          v24 = 0;
          TracerData::set((TracerData *)&v20, 0, v9, "CantParseData", 352, (const char *)(*((_QWORD *)this + 9) + 1));
          DiskCookieStorage::traceError(this, (const TracerData *)&v20);
          v16 = (const __CFAllocator *)*((_QWORD *)this + 1);
          v28[0] = &off_1E14E4818;
          v17 = CFStringCreateWithCString(v16, " - corrupt", 0x8000100u);
          v28[2] = 0;
          v28[3] = 0;
          v28[1] = v17;
          FilePath::FilePath((uint64_t)valuePtr, *((_QWORD *)this + 9), (uint64_t)v17);
          rename((const std::__fs::filesystem::path *)(*((_QWORD *)this + 9) + 1), (const std::__fs::filesystem::path *)((char *)&valuePtr[0].st_dev + 1), v18);
          if (v19 < 0)
            __error();
          AutoString::~AutoString((AutoString *)v28);
          if (cf)
            CFRelease(cf);
          free(v25);
        }
        CFRelease(v9);
      }
    }
LABEL_22:
    CFRelease(v8);
  }
}

void sub_183F7B2D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  AutoString::~AutoString((AutoString *)(v2 - 224));
  TracerData::clearError((TracerData *)va);
  _Unwind_Resume(a1);
}

void DiskCookieStorage::syncStorageWithCompletionLocked(uint64_t a1, int a2, void (**a3)(void))
{
  uint64_t v5;
  const __CFAllocator **v6;
  uint64_t v7;
  const __CFAllocator *v8;
  const char *v9;
  double v10;
  const char *v11;
  CFStringRef v12;
  CFStringRef v13;
  double v14;
  const char *v15;
  CFStringRef v16;
  CFStringRef v17;
  size_t v18;
  CFURLRef v19;
  const char *v20;
  CFStringRef v21;
  CFStringRef v22;
  double v23;
  double v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  CFURLRef v29;
  int v30;
  double v31;
  uint64_t tv_nsec;
  __darwin_time_t tv_sec;
  CFDateRef v34;
  const __CFAllocator *v35;
  __darwin_ino64_t st_ino;
  CFStringRef v37;
  BOOL v38;
  CFDateRef v39;
  __darwin_ino64_t v40;
  CFStringRef v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  CFStringRef v45;
  CFStringRef v46;
  uint64_t v47;
  CFStringRef v48;
  CFStringRef v49;
  CFStringRef v50;
  CFStringRef v51;
  CFStringRef v52;
  CFStringRef v53;
  CFStringRef v54;
  _BOOL4 v55;
  uint64_t v56;
  const __CFAllocator *v57;
  MemoryCookies *v58;
  __int128 v59;
  timespec st_mtimespec;
  timespec st_birthtimespec;
  __int128 v62;
  uint64_t v63;
  const UInt8 *BytePtr;
  CFIndex Length;
  unint64_t v66;
  NSObject *v67;
  CompactCookieHeader *v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  CompactCookieHeader *v73;
  uint64_t v74;
  const __CFAllocator *v75;
  __CFDictionary *MutableDictionary;
  CFDataRef Data;
  _DWORD *v78;
  CFAllocatorRef *v79;
  void *v80;
  NSObject *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  stat v86;
  stat cStr;
  void (**v88)(AutoString *__hidden);
  CFStringRef v89;
  uint64_t v90;
  uint64_t v91;
  _BYTE buf[24];
  void *v93;
  stat *p_cStr;
  int v95;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_70_10083, 1);
  v6 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
  if (v5)
  {
    v7 = v5;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v5 + 16))(v5, "DiskCookieStorage Sync Request", 0))
    {
      v8 = *v6;
      if (a2)
        v9 = "yes";
      else
        v9 = "no";
      *(_QWORD *)&cStr.st_dev = &off_1E14E4818;
      *(_QWORD *)&cStr.st_uid = 0;
      *(_QWORD *)&cStr.st_rdev = 0;
      cStr.st_ino = (__darwin_ino64_t)CFStringCreateWithCString(v8, "Forced", 0x8000100u);
      *(_QWORD *)buf = &off_1E14E4818;
      v93 = 0;
      *(_QWORD *)&buf[8] = CFStringCreateWithCString(v8, v9, 0x8000100u);
      *(_QWORD *)&buf[16] = 0;
      (*(void (**)(uint64_t, __darwin_ino64_t, _QWORD))(*(_QWORD *)v7 + 64))(v7, cStr.st_ino, *(_QWORD *)&buf[8]);
      AutoString::~AutoString((AutoString *)buf);
      AutoString::~AutoString((AutoString *)&cStr);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
      v10 = *(double *)(a1 + 96);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      if (v10 == 0.0)
        v11 = "no";
      else
        v11 = "yes";
      *(_QWORD *)&cStr.st_dev = &off_1E14E4818;
      v12 = CFStringCreateWithCString(v8, "isDirty", 0x8000100u);
      *(_QWORD *)&cStr.st_uid = 0;
      *(_QWORD *)&cStr.st_rdev = 0;
      cStr.st_ino = (__darwin_ino64_t)v12;
      *(_QWORD *)buf = &off_1E14E4818;
      v13 = CFStringCreateWithCString(v8, v11, 0x8000100u);
      v93 = 0;
      *(_QWORD *)&buf[8] = v13;
      *(_QWORD *)&buf[16] = 0;
      (*(void (**)(uint64_t, __darwin_ino64_t, CFStringRef))(*(_QWORD *)v7 + 64))(v7, cStr.st_ino, v13);
      AutoString::~AutoString((AutoString *)buf);
      AutoString::~AutoString((AutoString *)&cStr);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
      v14 = *(double *)(a1 + 112);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      if (v14 == 0.0)
        v15 = "no";
      else
        v15 = "yes";
      *(_QWORD *)&cStr.st_dev = &off_1E14E4818;
      v16 = CFStringCreateWithCString(v8, "isWriting", 0x8000100u);
      *(_QWORD *)&cStr.st_uid = 0;
      *(_QWORD *)&cStr.st_rdev = 0;
      cStr.st_ino = (__darwin_ino64_t)v16;
      *(_QWORD *)buf = &off_1E14E4818;
      v17 = CFStringCreateWithCString(v8, v15, 0x8000100u);
      v93 = 0;
      *(_QWORD *)&buf[8] = v17;
      *(_QWORD *)&buf[16] = 0;
      (*(void (**)(uint64_t, __darwin_ino64_t, CFStringRef))(*(_QWORD *)v7 + 64))(v7, cStr.st_ino, v17);
      AutoString::~AutoString((AutoString *)buf);
      AutoString::~AutoString((AutoString *)&cStr);
      v18 = strlen((const char *)(*(_QWORD *)(a1 + 72) + 1));
      v19 = CFURLCreateFromFileSystemRepresentation(*(CFAllocatorRef *)(a1 + 8), (const UInt8 *)(*(_QWORD *)(a1 + 72) + 1), v18, 0);
      (*(void (**)(uint64_t, const char *, CFURLRef))(*(_QWORD *)v7 + 40))(v7, "File", v19);
      CFRelease(v19);
      if (*(_QWORD *)(a1 + 304))
        v20 = "yes";
      else
        v20 = "no";
      *(_QWORD *)&cStr.st_dev = &off_1E14E4818;
      v21 = CFStringCreateWithCString(v8, "Journal", 0x8000100u);
      *(_QWORD *)&cStr.st_uid = 0;
      *(_QWORD *)&cStr.st_rdev = 0;
      cStr.st_ino = (__darwin_ino64_t)v21;
      *(_QWORD *)buf = &off_1E14E4818;
      v22 = CFStringCreateWithCString(v8, v20, 0x8000100u);
      v93 = 0;
      *(_QWORD *)&buf[8] = v22;
      *(_QWORD *)&buf[16] = 0;
      (*(void (**)(uint64_t, __darwin_ino64_t, CFStringRef))(*(_QWORD *)v7 + 64))(v7, cStr.st_ino, v22);
      AutoString::~AutoString((AutoString *)buf);
      AutoString::~AutoString((AutoString *)&cStr);
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v7 + 72))(v7, "Mutations", CFSTR("%ld"));
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  if (a2)
  {
    v23 = *(double *)(a1 + 112);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
    if (v23 != 0.0)
      dispatch_sync_f(*(dispatch_queue_t *)(a1 + 80), (void *)a1, (dispatch_function_t)DiskCookieStorage::_waitUntilDone);
  }
  else
  {
    v24 = *(double *)(a1 + 96);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
    if (v24 == 0.0)
      goto LABEL_102;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
    v25 = *(double *)(a1 + 112);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
    if (v25 != 0.0)
      goto LABEL_102;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v83 = *(_QWORD *)(a1 + 176);
  v84 = *(_QWORD *)(a1 + 184);
  v82 = *(_QWORD *)(a1 + 224);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
  v26 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_82_10094, 2);
  v27 = v26;
  if (v26
    && (*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)v26 + 32))(v26, "DiskCookieStorage Checking", a1))
  {
    v28 = strlen((const char *)(*(_QWORD *)(a1 + 72) + 1));
    v29 = CFURLCreateFromFileSystemRepresentation(*(CFAllocatorRef *)(a1 + 8), (const UInt8 *)(*(_QWORD *)(a1 + 72) + 1), v28, 0);
    (*(void (**)(uint64_t, const char *, CFURLRef))(*(_QWORD *)v27 + 40))(v27, "File", v29);
    CFRelease(v29);
    v30 = stat((const char *)(*(_QWORD *)(a1 + 72) + 1), &v86);
    v31 = *MEMORY[0x1E0C9ADF8];
    if (v30)
    {
      tv_nsec = 0;
      tv_sec = 0;
      memset(&v86, 0, sizeof(v86));
    }
    else
    {
      tv_sec = v86.st_mtimespec.tv_sec;
      tv_nsec = v86.st_mtimespec.tv_nsec;
    }
    v34 = CFDateCreate(*(CFAllocatorRef *)(a1 + 8), (double)tv_sec - v31 + (double)tv_nsec / 1000000000.0);
    v35 = *v6;
    *(_QWORD *)&cStr.st_dev = &off_1E14E4818;
    st_ino = (__darwin_ino64_t)CFStringCreateWithCString(v35, "Disk Mod", 0x8000100u);
    *(_QWORD *)&cStr.st_uid = 0;
    *(_QWORD *)&cStr.st_rdev = 0;
    cStr.st_ino = st_ino;
    if (v34)
    {
      v37 = CFCopyDescription(v34);
      st_ino = cStr.st_ino;
    }
    else
    {
      v37 = CFSTR("null");
    }
    (*(void (**)(uint64_t, __darwin_ino64_t, CFStringRef))(*(_QWORD *)v27 + 64))(v27, st_ino, v37);
    if (v34)
      v38 = v37 == 0;
    else
      v38 = 1;
    if (!v38)
      CFRelease(v37);
    AutoString::~AutoString((AutoString *)&cStr);
    CFRelease(v34);
    v39 = CFDateCreate(*(CFAllocatorRef *)(a1 + 8), (double)v84 / 1000000000.0 + (double)v83 - v31);
    *(_QWORD *)&cStr.st_dev = &off_1E14E4818;
    v40 = (__darwin_ino64_t)CFStringCreateWithCString(v35, "Last Sync", 0x8000100u);
    *(_QWORD *)&cStr.st_uid = 0;
    *(_QWORD *)&cStr.st_rdev = 0;
    cStr.st_ino = v40;
    if (v39)
    {
      v41 = CFCopyDescription(v39);
      v40 = cStr.st_ino;
    }
    else
    {
      v41 = CFSTR("null");
    }
    (*(void (**)(uint64_t, __darwin_ino64_t, CFStringRef))(*(_QWORD *)v27 + 64))(v27, v40, v41);
    if (v39)
      v42 = v41 == 0;
    else
      v42 = 1;
    if (!v42)
      CFRelease(v41);
    AutoString::~AutoString((AutoString *)&cStr);
    CFRelease(v39);
    v43 = *(_QWORD *)(a1 + 288);
    v44 = MEMORY[0x1E0C809B0];
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
    v93 = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
    p_cStr = &cStr;
    v95 = 256;
    MemoryCookies::withImmutableDomains(v43, (uint64_t)buf);
    *(_QWORD *)buf = &off_1E14E4818;
    v45 = CFStringCreateWithCString(v35, "Persistent Cookies", 0x8000100u);
    v93 = 0;
    *(_QWORD *)&buf[8] = v45;
    *(_QWORD *)&buf[16] = 0;
    v88 = &off_1E14E4818;
    v46 = CFStringCreateWithCString(v35, (const char *)&cStr, 0x8000100u);
    v90 = 0;
    v91 = 0;
    v89 = v46;
    (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)&buf[8], v46);
    AutoString::~AutoString((AutoString *)&v88);
    AutoString::~AutoString((AutoString *)buf);
    v47 = *(_QWORD *)(a1 + 280);
    *(_QWORD *)buf = v44;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
    v93 = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
    p_cStr = &cStr;
    v95 = 256;
    MemoryCookies::withImmutableDomains(v47, (uint64_t)buf);
    *(_QWORD *)buf = &off_1E14E4818;
    v48 = CFStringCreateWithCString(v35, "Session Cookies", 0x8000100u);
    v93 = 0;
    *(_QWORD *)&buf[8] = v48;
    *(_QWORD *)&buf[16] = 0;
    v88 = &off_1E14E4818;
    v49 = CFStringCreateWithCString(v35, (const char *)&cStr, 0x8000100u);
    v90 = 0;
    v91 = 0;
    v89 = v49;
    (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)&buf[8], v49);
    AutoString::~AutoString((AutoString *)&v88);
    AutoString::~AutoString((AutoString *)buf);
    if (*(_QWORD *)(a1 + 304))
    {
      *(_QWORD *)buf = &off_1E14E4818;
      if ((double)v86.st_mtimespec.tv_sec - v31 + (double)v86.st_mtimespec.tv_nsec / 1000000000.0 == (double)v84 / 1000000000.0 + (double)v83 - v31)
      {
        v54 = CFStringCreateWithCString(v35, "Journal", 0x8000100u);
        v93 = 0;
        *(_QWORD *)&buf[8] = v54;
        *(_QWORD *)&buf[16] = 0;
        v88 = &off_1E14E4818;
        v51 = CFStringCreateWithCString(v35, "not required", 0x8000100u);
      }
      else
      {
        v50 = CFStringCreateWithCString(v35, "Journal", 0x8000100u);
        v93 = 0;
        *(_QWORD *)&buf[8] = v50;
        *(_QWORD *)&buf[16] = 0;
        v88 = &off_1E14E4818;
        v51 = CFStringCreateWithCString(v35, "must replay", 0x8000100u);
      }
      v90 = 0;
      v91 = 0;
      v89 = v51;
      (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)&buf[8], v51);
    }
    else
    {
      *(_QWORD *)buf = &off_1E14E4818;
      v52 = CFStringCreateWithCString(v35, "Journal", 0x8000100u);
      v93 = 0;
      *(_QWORD *)&buf[8] = v52;
      *(_QWORD *)&buf[16] = 0;
      v88 = &off_1E14E4818;
      v53 = CFStringCreateWithCString(v35, "none", 0x8000100u);
      v90 = 0;
      v91 = 0;
      v89 = v53;
      (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)&buf[8], v53);
    }
    AutoString::~AutoString((AutoString *)&v88);
    AutoString::~AutoString((AutoString *)buf);
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  }
  if (a2)
  {
    v55 = *(_QWORD *)(a1 + 312) == 0;
    if (!*(_QWORD *)(a1 + 312))
      goto LABEL_60;
  }
  else
  {
    v55 = 0;
  }
  if (*(_QWORD *)(a1 + 304))
  {
    if (*(_BYTE *)(a1 + 324))
      goto LABEL_61;
    if (!stat((const char *)(*(_QWORD *)(a1 + 72) + 1), &cStr))
    {
      if ((double)cStr.st_mtimespec.tv_sec - *MEMORY[0x1E0C9ADF8] + (double)cStr.st_mtimespec.tv_nsec / 1000000000.0 != (double)v84 / 1000000000.0 + (double)v83 - *MEMORY[0x1E0C9ADF8]
        || cStr.st_size != v82)
      {
        goto LABEL_61;
      }
      goto LABEL_56;
    }
    v55 = 0;
  }
LABEL_60:
  if (v55)
  {
LABEL_61:
    v57 = *(const __CFAllocator **)(a1 + 8);
    v58 = (MemoryCookies *)CFAllocatorAllocate(v57, 32, 0);
    *(_QWORD *)v58 = off_1E14E6620;
    *((_QWORD *)v58 + 1) = v57;
    *((_QWORD *)v58 + 2) = &unk_1E14E6648;
    *((_QWORD *)v58 + 3) = 0;
    *((_QWORD *)v58 + 3) = CFDictionaryCreateMutable(v57, 0, &CStringKeyCallbacks::caseInsensitiveCallbacks(void)::sCallbacks, MEMORY[0x1E0C9B3A0]);
    DiskCookieStorage::readFileToCookies((DiskCookieStorage *)a1, v58);
    if (!stat((const char *)(*(_QWORD *)(a1 + 72) + 1), &cStr))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
      v59 = *(_OWORD *)&cStr.st_blksize;
      *(_OWORD *)(a1 + 224) = *(_OWORD *)&cStr.st_size;
      *(_OWORD *)(a1 + 240) = v59;
      *(_OWORD *)(a1 + 256) = *(_OWORD *)cStr.st_qspare;
      st_mtimespec = cStr.st_mtimespec;
      *(timespec *)(a1 + 160) = cStr.st_atimespec;
      *(timespec *)(a1 + 176) = st_mtimespec;
      st_birthtimespec = cStr.st_birthtimespec;
      *(timespec *)(a1 + 192) = cStr.st_ctimespec;
      *(timespec *)(a1 + 208) = st_birthtimespec;
      v62 = *(_OWORD *)&cStr.st_uid;
      *(_OWORD *)(a1 + 128) = *(_OWORD *)&cStr.st_dev;
      *(_OWORD *)(a1 + 144) = v62;
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
    }
    v63 = *(_QWORD *)(a1 + 304);
    if (v63)
    {
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v63 + 16));
      Length = CFDataGetLength(*(CFDataRef *)(v63 + 16));
      if (Length >= 1)
      {
        v66 = (unint64_t)&BytePtr[Length];
        v67 = MEMORY[0x1E0C81028];
        v68 = (CompactCookieHeader *)BytePtr;
        do
        {
          v70 = *(_DWORD *)v68;
          v68 = (CompactCookieHeader *)((char *)v68 + 4);
          v69 = v70;
          if ((unint64_t)v68 > v66 && os_log_type_enabled(v67, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = v68;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v66;
            _os_log_fault_impl(&dword_183ECA000, v67, OS_LOG_TYPE_FAULT, "overflow %p < %p", buf, 0x16u);
          }
          if (v69 == 2)
          {
            MemoryCookies::deleteAllCookies(v58);
          }
          else if (v69 == 3)
          {
            v71 = *((_DWORD *)BytePtr + 1);
            v68 = (CompactCookieHeader *)(BytePtr + 8);
            if ((unint64_t)(BytePtr + 8) > v66 && os_log_type_enabled(v67, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = BytePtr + 8;
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v66;
              _os_log_fault_impl(&dword_183ECA000, v67, OS_LOG_TYPE_FAULT, "overflow %p < %p - policy", buf, 0x16u);
            }
            *(_DWORD *)(a1 + 320) = v71;
          }
          else
          {
            if (*(_DWORD *)v68 >= 4u)
              v72 = *(_DWORD *)v68;
            else
              v72 = 0;
            v73 = (CompactCookieHeader *)((char *)v68 + v72);
            if ((unint64_t)v68 + v72 > v66 && os_log_type_enabled(v67, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_183ECA000, v67, OS_LOG_TYPE_FAULT, "overflow", buf, 2u);
            }
            if (v69 == 1)
            {
              MemoryCookies::deleteCookie(v58, v68);
            }
            else if (!v69)
            {
              MemoryCookies::setCookie((CompactCookieArray **)v58, v68);
            }
            v68 = v73;
          }
          BytePtr = (const UInt8 *)v68;
        }
        while ((unint64_t)v68 < v66);
      }
      CFDataSetLength(*(CFMutableDataRef *)(*(_QWORD *)(a1 + 304) + 16), 0);
    }
    v74 = *(_QWORD *)(a1 + 288);
    if (v74)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v74 + 8))(v74);
      *(_QWORD *)(a1 + 288) = 0;
    }
    *(_QWORD *)(a1 + 288) = v58;
    MemoryCookies::deleteAllCookies(*(MemoryCookies **)(a1 + 296));
    MemoryCookies::mergeCookiesFrom(*(CFAllocatorRef **)(a1 + 296), *(_QWORD *)(a1 + 288));
    MemoryCookies::mergeCookiesFrom(*(CFAllocatorRef **)(a1 + 296), *(_QWORD *)(a1 + 280));
    goto LABEL_92;
  }
LABEL_56:
  v56 = *(_QWORD *)(a1 + 304);
  if (v56)
    CFDataSetLength(*(CFMutableDataRef *)(v56 + 16), 0);
LABEL_92:
  if (!a2 || *(_QWORD *)(a1 + 312))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
    v75 = *(const __CFAllocator **)(a1 + 8);
    AutoScalar::AutoScalar((AutoScalar *)&cStr, (const __CFAllocator *)*(unsigned int *)(a1 + 320));
    MutableDictionary = cfTypeCreateMutableDictionary(v75, CFSTR("NSHTTPCookieAcceptPolicy"), cStr.st_ino, 0, 0);
    *(_QWORD *)&cStr.st_dev = &off_1E14E47E8;
    if (cStr.st_ino)
      CFRelease((CFTypeRef)cStr.st_ino);
    Data = CFPropertyListCreateData(*(CFAllocatorRef *)(a1 + 8), MutableDictionary, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (MutableDictionary)
      CFRelease(MutableDictionary);
    *(CFAbsoluteTime *)(a1 + 112) = CFAbsoluteTimeGetCurrent();
    v78 = (_DWORD *)operator new();
    v79 = *(CFAllocatorRef **)(a1 + 288);
    *(_BYTE *)v78 = 1;
    v78[257] = 0;
    *((_QWORD *)v78 + 130) = a1;
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    *((_QWORD *)v78 + 131) = MemoryCookies::clone(v79);
    v80 = a3;
    if (a3)
      v80 = _Block_copy(a3);
    *((_QWORD *)v78 + 133) = v80;
    if (Data)
    {
      *((_QWORD *)v78 + 132) = CFRetain(Data);
      CFRelease(Data);
    }
    else
    {
      *((_QWORD *)v78 + 132) = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
    *(_QWORD *)(a1 + 312) = 0;
    v81 = *(NSObject **)(a1 + 80);
    if (a2)
      dispatch_sync_f(v81, v78, (dispatch_function_t)DiskCookieStorage::_asyncWriteFileCompletely);
    else
      dispatch_async_f(v81, v78, (dispatch_function_t)DiskCookieStorage::_asyncWriteFileCompletely);
    return;
  }
LABEL_102:
  if (a3)
    a3[2]();
}

void sub_183F7C0FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,CFTypeRef cf,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a70;

  AutoString::~AutoString((AutoString *)&a70);
  AutoString::~AutoString((AutoString *)&STACK[0x280]);
  _Unwind_Resume(a1);
}

void MemoryCookies::mergeCookiesFrom(CFAllocatorRef *a1, uint64_t a2)
{
  CFAllocatorRef v4;

  if (CFDictionaryGetCount(a1[3]))
  {
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a2 + 24), (CFDictionaryApplierFunction)MemoryCookies::_mergeCookiesFrom, a1);
  }
  else
  {
    v4 = a1[3];
    a1[3] = CFDictionaryCreateMutableCopy(a1[1], 0, *(CFDictionaryRef *)(a2 + 24));
    if (v4)
      CFRelease(v4);
  }
}

void MemoryCookies::deleteAllCookies(MemoryCookies *this)
{
  const void *v1;

  v1 = (const void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CStringKeyCallbacks::caseInsensitiveCallbacks(void)::sCallbacks, MEMORY[0x1E0C9B3A0]);
  if (v1)
    CFRelease(v1);
}

_OWORD *MemoryCookies::clone(CFAllocatorRef *this)
{
  _OWORD *v2;
  const __CFAllocator *v3;
  const __CFDictionary *v4;

  v2 = CFAllocatorAllocate(this[1], 32, 0);
  *v2 = 0u;
  v2[1] = 0u;
  v3 = this[1];
  v4 = this[3];
  *(_QWORD *)v2 = off_1E14E6620;
  *((_QWORD *)v2 + 1) = v3;
  *((_QWORD *)v2 + 2) = &unk_1E14E6648;
  *((_QWORD *)v2 + 3) = CFDictionaryCreateMutableCopy(v3, 0, v4);
  return v2;
}

void sub_183F7C314(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void DiskCookieStorage::_asyncWriteFileCompletely(DiskCookieStorage *this, void *a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFAllocator *v10;
  uint64_t v11;
  int v12;
  __CFWriteStream *v13;
  uint64_t v14;
  const UInt8 *v15;
  size_t v16;
  const __CFURL *v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  int v21;
  size_t v22;
  CFURLRef v23;
  CFErrorRef v24;
  std::error_code *v25;
  int v26;
  int v27;
  __CFNotificationCenter *DarwinNotifyCenter;
  uint64_t v29;
  const void *v30;
  uint64_t v31;
  CFTypeRef v32;
  const __CFAllocator *allocator;
  stat v34;
  const char *v35;
  int v36;
  CFTypeRef cf;
  uint64_t v38;
  int v39;
  void *v40;
  stat v41;
  int v42;
  _BYTE v43[152];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  char v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v35 = "_asyncWriteFileCompletely";
  v36 = 0;
  v40 = 0;
  cf = 0;
  v38 = 0;
  v39 = 0;
  v3 = *((_QWORD *)this + 131);
  if (v3)
  {
    v55 = 0;
    v56 = &v55;
    v57 = 0x2020000000;
    v58 = 1;
    *(_QWORD *)&v44 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v44 + 1) = 3221225472;
    *(_QWORD *)&v45 = ___ZNK13MemoryCookies7isEmptyEv_block_invoke;
    *((_QWORD *)&v45 + 1) = &unk_1E14FB3D8;
    *(_QWORD *)&v46 = &v55;
    MemoryCookies::withImmutableDomains(v3, (uint64_t)&v44);
    v4 = *((unsigned __int8 *)v56 + 24);
    _Block_object_dispose(&v55, 8);
    if (v4)
    {
      v5 = *((_QWORD *)this + 130);
      if (*(_DWORD *)(v5 + 320) == 2)
      {
        if (unlink((const char *)(*(_QWORD *)(v5 + 72) + 1)))
          __error();
        v51 = 0u;
        v52 = 0u;
        v49 = 0u;
        v50 = 0u;
        v47 = 0u;
        v48 = 0u;
        v45 = 0u;
        v46 = 0u;
        v44 = 0u;
        DiskCookieStorage::writeCompleted(*((_QWORD *)this + 130), &v44, *((_QWORD *)this + 131));
        goto LABEL_44;
      }
    }
  }
  v6 = 3;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (1)
  {
    v7 = *((_QWORD *)this + 130);
    v8 = *((_QWORD *)this + 131);
    v9 = *((_QWORD *)this + 132);
    v10 = *(const __CFAllocator **)(v7 + 8);
    v11 = getpid();
    AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)&v55, v10, CFSTR("_tmp_%d.dat"), v11);
    FilePath::FilePath((uint64_t)&v44, *(_QWORD *)(v7 + 72), (uint64_t)v56);
    v12 = open_dprotected_np((const char *)&v44 + 1, 1537, 3, 0, 438);
    if (v12 < 0)
    {
      v21 = *__error();
      v42 = v21;
      if (v12 != -1 || v21 != 2)
        goto LABEL_23;
      v22 = strlen((const char *)&v44 + 1);
      v23 = CFURLCreateFromFileSystemRepresentation(allocator, (const UInt8 *)&v44 + 1, v22, 0);
      FilePathStorage<unsigned char>::mkParentDirs(v23, v53, v54, &v42);
      if (v23)
        CFRelease(v23);
      v21 = v42;
      if (v42)
        goto LABEL_23;
      v12 = open_dprotected_np((const char *)&v44 + 1, 1537, 3, 0, 438);
      if (v12 < 0)
      {
        v21 = *__error();
LABEL_23:
        TracerData::set((TracerData *)&v35, v21, 0, "CantOpen", 625, (const char *)&v44 + 1);
        goto LABEL_41;
      }
    }
    v13 = (__CFWriteStream *)_CFWriteStreamCreateFromFileDescriptor();
    if (!v13)
    {
      if (close(v12))
        __error();
      TracerData::set((TracerData *)&v35, 2, 0, "CantCreateWriteStream", 632, (const char *)&v44 + 1);
      goto LABEL_41;
    }
    v14 = *(_QWORD *)(v7 + 72);
    if (*(_DWORD *)(v14 + 1028) == 1)
    {
      v15 = (const UInt8 *)(v14 + 1);
      v16 = strlen((const char *)(v14 + 1));
      v17 = CFURLCreateFromFileSystemRepresentation(*(CFAllocatorRef *)(v7 + 8), v15, v16, 0);
      if (v17)
      {
        v18 = operator new();
        FilePathStorage<unsigned char>::FilePathStorage(v18, v17, 0, 1, 1u);
        CFRelease(v17);
        v19 = *(_QWORD *)(v7 + 72);
        if (v19)
          MEMORY[0x186DB748C](v19, 0x1000C4048165BC6);
        *(_QWORD *)(v7 + 72) = v18;
      }
    }
    if (!CFWriteStreamOpen(v13))
    {
      v24 = CFWriteStreamCopyError(v13);
      if (v24)
      {
        TracerData::set((TracerData *)&v35, 0, v24, "CantOpenWriteStream", 659, (const char *)&v44 + 1);
        CFRelease(v24);
      }
      else
      {
        TracerData::set((TracerData *)&v35, 2, 0, "CantOpenWriteStream", 657, (const char *)&v44 + 1);
      }
      CFRelease(v13);
      goto LABEL_41;
    }
    v20 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t, __CFWriteStream *, uint64_t))(*(_QWORD *)v7 + 200))(v7, v8, v13, v9);
    if (!v20)
      break;
    TracerData::set((TracerData *)&v35, 0, v20, "WriteCookiesToStream", 672, (const char *)&v44 + 1);
    CFRelease(v20);
    CFWriteStreamClose(v13);
    CFRelease(v13);
LABEL_41:
    AutoString::~AutoString((AutoString *)&v55);
    if (!--v6)
    {
      if (v38)
        DiskCookieStorage::traceError(*((DiskCookieStorage **)this + 130), (const TracerData *)&v35);
      goto LABEL_44;
    }
  }
  fstat(v12, &v41);
  CFWriteStreamClose(v13);
  CFRelease(v13);
  rename((const std::__fs::filesystem::path *)((char *)&v44 + 1), (const std::__fs::filesystem::path *)(*(_QWORD *)(v7 + 72) + 1), v25);
  if (v26 < 0)
    v27 = *__error();
  else
    v27 = 0;
  *(_BYTE *)(v7 + 325) = 1;
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  if (DarwinNotifyCenter)
    CFNotificationCenterPostNotification(DarwinNotifyCenter, *(CFNotificationName *)(v7 + 328), 0, 0, 1u);
  if (v27)
  {
    AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)v43, allocator, CFSTR("Error renaming the temporary file to %s"), *(_QWORD *)(v7 + 72) + 1);
    AutoString::getCString((AutoString *)v43);
    TracerData::set((TracerData *)&v35, v27, 0, "CantRename", 752, (const char *)&v44 + 1);
    AutoString::~AutoString((AutoString *)v43);
    if (unlink((const char *)&v44 + 1))
      __error();
    goto LABEL_41;
  }
  v34 = v41;
  AutoString::~AutoString((AutoString *)&v55);
  v36 = 0;
  v32 = cf;
  cf = 0;
  if (v32)
    CFRelease(v32);
  v38 = 0;
  v39 = 0;
  free(v40);
  v40 = 0;
  DiskCookieStorage::writeCompleted(*((_QWORD *)this + 130), &v34, *((_QWORD *)this + 131));
LABEL_44:
  v29 = *((_QWORD *)this + 133);
  if (v29)
  {
    (*(void (**)(void))(v29 + 16))();
    _Block_release(*((const void **)this + 133));
  }
  (*(void (**)(_QWORD))(**((_QWORD **)this + 130) + 48))(*((_QWORD *)this + 130));
  v30 = (const void *)*((_QWORD *)this + 132);
  if (v30)
    CFRelease(v30);
  v31 = *((_QWORD *)this + 131);
  if (v31)
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
  MEMORY[0x186DB748C](this, 0x10E0C408C693DC2);
  if (cf)
    CFRelease(cf);
  free(v40);
}

void sub_183F7C920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  TracerData::clearError((TracerData *)&a29);
  _Unwind_Resume(a1);
}

void HTTPCookieStorage::~HTTPCookieStorage(HTTPCookieStorage *this)
{
  _QWORD *v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  NSObject *v9;
  NSObject *v10;

  *(_QWORD *)this = &off_1E14E8888;
  *((_QWORD *)this + 1) = &unk_1E14E88D0;
  v2 = (_QWORD *)*((_QWORD *)this + 2);
  v3 = v2[4];
  if (v3)
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 8));
  (*(void (**)(_QWORD *))(*v2 + 80))(v2);
  if (v3)
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  (*(void (**)(_QWORD))(**((_QWORD **)this + 2) + 48))(*((_QWORD *)this + 2));
  v4 = (const void *)*((_QWORD *)this + 3);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 7);
  if (v5)
  {
    _Block_release(v5);
    *((_QWORD *)this + 7) = 0;
  }
  if (*((_QWORD *)this + 9) != -1)
  {
    sandbox_extension_release();
    *((_QWORD *)this + 9) = -1;
  }
  v6 = (const void *)*((_QWORD *)this + 10);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 13);
  if (v7)
    _Block_release(v7);
  v8 = (const void *)*((_QWORD *)this + 14);
  if (v8)
    _Block_release(v8);
  v9 = *((_QWORD *)this + 11);
  if (v9)
    dispatch_release(v9);
  v10 = *((_QWORD *)this + 12);
  if (v10)
    dispatch_release(v10);
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_183F7CAB0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  if (v2)
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 8));
  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

void MemoryCookieStorage::~MemoryCookieStorage(MemoryCookieStorage *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_1E14E9FF8;
  *((_QWORD *)this + 3) = &unk_1E14EA0D0;
  v2 = *((_QWORD *)this + 9);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(this);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E14E9FF8;
  *((_QWORD *)this + 3) = &unk_1E14EA0D0;
  v2 = *((_QWORD *)this + 9);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(this);
}

void PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(PrivateHTTPCookieStorage *this)
{
  const void *v2;
  const void *v3;
  uint64_t v4;

  *(_QWORD *)this = off_1E14ED120;
  *((_QWORD *)this + 3) = &unk_1E14ED1F8;
  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 6);
  if (v3)
    CFRelease(v3);
  v4 = *((_QWORD *)this + 4);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

void sub_183F7CBA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void MemoryCookies::~MemoryCookies(MemoryCookies *this)
{
  const void *v2;

  *(_QWORD *)this = off_1E14E6620;
  *((_QWORD *)this + 2) = &unk_1E14E6648;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 2) = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

{
  const void *v2;

  *(_QWORD *)this = off_1E14E6620;
  *((_QWORD *)this + 2) = &unk_1E14E6648;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 2) = &off_1E14E5838;
}

void sub_183F7CC00(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

intptr_t ___ZN17DiskCookieStorage31rereadFromDiskIfNecessaryLockedEv_block_invoke(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

CFErrorRef BinaryCookieStorage::writeCookiesToStream(BinaryCookieStorage *this, const MemoryCookies *a2, __CFWriteStream *a3, const __CFData *a4)
{
  _QWORD *v6;
  const __CFData *Mutable;
  CFErrorRef v8;
  uint64_t v9;
  UInt8 *v10;
  uint64_t i;
  uint64_t v12;
  CompactCookieArray *v13;
  const UInt8 *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  CompactCookieArray *v20;
  UInt8 *v21;
  uint64_t v22;
  UInt8 *v23;
  int v24;
  UInt8 *v25;
  CFIndex v26;
  UInt8 *BytePtr;
  CFIndex Length;
  UInt8 v30[8];
  UInt8 buffer[8];
  _QWORD v32[2];
  void (*v33)(uint64_t);
  void *v34;
  const __CFData *v35;

  v6 = MemoryCookies::newCookieArrayEnumerator(a2, 0);
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0x4000);
  v32[1] = 3221225472;
  v33 = ___ZN19BinaryCookieStorage20writeCookiesToStreamEPK13MemoryCookiesP15__CFWriteStreamPK8__CFData_block_invoke;
  v34 = &__block_descriptor_40_e5_v8__0l;
  v35 = Mutable;
  *(_QWORD *)buffer = 1802465123;
  v32[0] = MEMORY[0x1E0C809B0];
  *(_DWORD *)&buffer[4] = bswap32(*((_DWORD *)v6 + 2));
  v8 = writeEntirelyWithBuffer(a3, buffer, 8, Mutable);
  if (!v8)
  {
    v9 = v6[1];
    v10 = (UInt8 *)operator new[]();
    if (v9 >= 1)
    {
      for (i = 0; i != v9; ++i)
      {
        v12 = *(_QWORD *)(v6[2] + 8 * i);
        *(_QWORD *)v30 = 0;
        if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
          dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
        if (v12)
          v13 = (CompactCookieArray *)(v12 + 16);
        else
          v13 = 0;
        v14 = CompactCookieArray::peekData(v13, (uint64_t *)v30);
        v15 = *(_DWORD *)v30;
        if (!v14)
          v15 = 0;
        *(_DWORD *)&v10[4 * i] = bswap32(v15);
      }
    }
    v8 = writeEntirelyWithBuffer(a3, v10, 4 * v9, Mutable);
    MEMORY[0x186DB7474](v10, 0x1000C8052888210);
    if (!v8)
    {
      v16 = v6[1];
      if (v16 < 1)
      {
        v18 = 0;
LABEL_30:
        *(_DWORD *)v30 = bswap32(v18);
        *(_DWORD *)&v30[4] = 85989127;
        v8 = writeEntirelyWithBuffer(a3, v30, 8, Mutable);
      }
      else
      {
        v17 = 0;
        v18 = 0;
        while (1)
        {
          v19 = *(_QWORD *)(v6[2] + 8 * v17);
          *(_QWORD *)v30 = 0;
          if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1)
            dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_11470);
          v20 = v19 ? (CompactCookieArray *)(v19 + 16) : 0;
          v21 = (UInt8 *)CompactCookieArray::peekData(v20, (uint64_t *)v30);
          v22 = v21 ? *(_QWORD *)v30 : 0;
          v8 = writeEntirelyWithBuffer(a3, v21, v22, Mutable);
          if (v8)
            break;
          if (v22 >= 1)
          {
            v23 = &v21[v22];
            do
            {
              v24 = *v21;
              v21 += 4;
              v18 += v24;
            }
            while (v21 < v23);
          }
          if (++v17 == v16)
            goto LABEL_30;
        }
      }
    }
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v6);
  MEMORY[0x186DB748C]();
  if (!a4
    || v8
    || (*(_DWORD *)buffer = bswap32(CFDataGetLength(a4)), (v8 = writeEntirelyWithBuffer(a3, buffer, 4, Mutable)) != 0))
  {
    if (v8)
      goto LABEL_41;
  }
  else
  {
    BytePtr = (UInt8 *)CFDataGetBytePtr(a4);
    Length = CFDataGetLength(a4);
    v8 = writeEntirelyWithBuffer(a3, BytePtr, Length, Mutable);
    if (v8)
      goto LABEL_41;
  }
  if (Mutable)
  {
    if (CFDataGetLength(Mutable))
    {
      v25 = (UInt8 *)CFDataGetBytePtr(Mutable);
      v26 = CFDataGetLength(Mutable);
      v8 = writeEntirely(a3, v25, v26);
      CFDataSetLength(Mutable, 0);
    }
    else
    {
      v8 = 0;
    }
  }
LABEL_41:
  v33((uint64_t)v32);
  return v8;
}

void sub_183F7CF84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *))
{
  a14(&a12);
  _Unwind_Resume(a1);
}

CFErrorRef writeEntirelyWithBuffer(CFWriteStreamRef stream, UInt8 *buffer, uint64_t a3, CFDataRef theData)
{
  const UInt8 *v4;
  UInt8 *v7;
  CFIndex v8;
  UInt8 *BytePtr;
  CFErrorRef result;

  v4 = buffer;
  if (!theData)
    return writeEntirely(stream, buffer, a3);
  if (a3 >= 1)
  {
    v7 = &buffer[a3];
    do
    {
      v8 = v7 - v4;
      if (v7 - v4 >= 0x4000 - CFDataGetLength(theData))
        v8 = 0x4000 - CFDataGetLength(theData);
      CFDataAppendBytes(theData, v4, v8);
      if (CFDataGetLength(theData) == 0x4000)
      {
        BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
        result = writeEntirely(stream, BytePtr, 0x4000);
        if (result)
          return result;
        CFDataSetLength(theData, 0);
      }
      v4 += v8;
    }
    while (v4 < v7);
  }
  return 0;
}

CFErrorRef writeEntirely(CFWriteStreamRef stream, UInt8 *buffer, uint64_t a3)
{
  const UInt8 *v3;
  UInt8 *v5;
  CFIndex v6;
  const __CFAllocator *v8;

  if (a3 < 1)
    return 0;
  v3 = buffer;
  v5 = &buffer[a3];
  while (1)
  {
    v6 = CFWriteStreamWrite(stream, v3, v5 - v3);
    if (!v6)
    {
      v8 = CFGetAllocator(stream);
      return CFErrorCreate(v8, CFSTR("kCFErrorDomainCFNetwork"), -4000, 0);
    }
    if (v6 == -1)
      break;
    v3 += v6;
    if (v3 >= v5)
      return 0;
  }
  return CFWriteStreamCopyError(stream);
}

_QWORD *MemoryCookies::newCookieArrayEnumerator(MemoryCookies *this, CookieSifter *a2)
{
  const __CFDictionary *v4;
  int v5;
  CFMutableArrayRef Mutable;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t Count;
  CFRange v10;
  const void **v11;
  _QWORD v13[6];
  char v14;

  if (a2)
  {
    v4 = (const __CFDictionary *)*((_QWORD *)a2 + 3);
    if (v4 && CFDictionaryGetCount(v4))
      LOBYTE(v5) = 0;
    else
      v5 = (*((unsigned __int8 *)a2 + 800) >> 5) & 1;
  }
  else
  {
    LOBYTE(v5) = 1;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = ___ZNK13MemoryCookies24newCookieArrayEnumeratorEP12CookieSifter_block_invoke;
  v13[3] = &__block_descriptor_49_e25_v16__0____CFDictionary__8l;
  v14 = v5;
  v13[4] = Mutable;
  v13[5] = a2;
  MemoryCookies::withImmutableDomains((uint64_t)this, (uint64_t)v13);
  v7 = (_QWORD *)operator new();
  v8 = v7;
  if (Mutable)
  {
    *v7 = CFRetain(Mutable);
    Count = CFArrayGetCount(Mutable);
    v10.length = Count;
    v8[1] = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v8[2] = 0;
    }
    else
    {
      if (Count <= 0x1E)
      {
        v11 = (const void **)(v8 + 3);
        v8[2] = v8 + 3;
LABEL_15:
        v10.location = 0;
        CFArrayGetValues(Mutable, v10, v11);
        goto LABEL_16;
      }
      v11 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
      v8[2] = v11;
      if (v11)
      {
        v10.length = v8[1];
        goto LABEL_15;
      }
    }
LABEL_16:
    CFRelease(Mutable);
    return v8;
  }
  *v7 = 0;
  v7[1] = 0;
  v7[2] = v7 + 3;
  return v8;
}

void sub_183F7D2A0(_Unwind_Exception *a1)
{
  CFContainerEnumeratorBase *v1;

  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v1);
  MEMORY[0x186DB748C]();
  _Unwind_Resume(a1);
}

void ___ZN19BinaryCookieStorage20writeCookiesToStreamEPK13MemoryCookiesP15__CFWriteStreamPK8__CFData_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void DiskCookieStorage::writeCompleted(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  void (**v8)(AutoString *__hidden);
  const __CFAllocator *v9;
  CFStringRef v10;
  char *v11;
  CFStringRef v12;
  uint64_t v13;
  CFStringRef v14;
  CFStringRef v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  char cStr[256];
  void (**v23)(AutoString *__hidden);
  CFStringRef v24;
  uint64_t v25;
  uint64_t v26;
  void (**v27)(AutoString *__hidden);
  uint64_t v28;
  void (*v29)(uint64_t, CFDictionaryRef);
  void *v30;
  char *v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_60_10138, 1);
  if (v6)
  {
    v7 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)v6 + 32))(v6, "DiskCookieStorage Updated", a1))
    {
      v8 = (void (**)(AutoString *__hidden))MEMORY[0x1E0C809B0];
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (a3)
      {
        v27 = (void (**)(AutoString *__hidden))MEMORY[0x1E0C809B0];
        v28 = 3221225472;
        v29 = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
        v30 = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
        v31 = cStr;
        v32 = 256;
        MemoryCookies::withImmutableDomains(a3, (uint64_t)&v27);
        v27 = &off_1E14E4818;
        v10 = CFStringCreateWithCString(v9, "Persistent Cookies", 0x8000100u);
        v11 = cStr;
      }
      else
      {
        v27 = &off_1E14E4818;
        v10 = CFStringCreateWithCString(v9, "Persistent Cookies", 0x8000100u);
        v11 = "null";
      }
      v29 = 0;
      v30 = 0;
      v28 = (uint64_t)v10;
      v23 = &off_1E14E4818;
      v12 = CFStringCreateWithCString(v9, v11, 0x8000100u);
      v25 = 0;
      v26 = 0;
      v24 = v12;
      (*(void (**)(uint64_t, uint64_t, CFStringRef))(*(_QWORD *)v7 + 64))(v7, v28, v12);
      AutoString::~AutoString((AutoString *)&v23);
      AutoString::~AutoString((AutoString *)&v27);
      v13 = *(_QWORD *)(a1 + 280);
      v27 = v8;
      v28 = 3221225472;
      v29 = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
      v30 = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
      v31 = cStr;
      v32 = 256;
      MemoryCookies::withImmutableDomains(v13, (uint64_t)&v27);
      v27 = &off_1E14E4818;
      v14 = CFStringCreateWithCString(v9, "Session Cookies", 0x8000100u);
      v29 = 0;
      v30 = 0;
      v28 = (uint64_t)v14;
      v23 = &off_1E14E4818;
      v15 = CFStringCreateWithCString(v9, cStr, 0x8000100u);
      v25 = 0;
      v26 = 0;
      v24 = v15;
      (*(void (**)(uint64_t, uint64_t, CFStringRef))(*(_QWORD *)v7 + 64))(v7, v28, v15);
      AutoString::~AutoString((AutoString *)&v23);
      AutoString::~AutoString((AutoString *)&v27);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
      CFAbsoluteTimeGetCurrent();
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v7 + 72))(v7, "Time from first dirty", CFSTR("%g"));
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v7 + 72))(v7, "Time from last  dirty", CFSTR("%g"));
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v7 + 72))(v7, "Total time to write", CFSTR("%g"));
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(_OWORD *)(a1 + 128) = *a2;
  v16 = a2[1];
  v17 = a2[2];
  v18 = a2[4];
  *(_OWORD *)(a1 + 176) = a2[3];
  *(_OWORD *)(a1 + 192) = v18;
  *(_OWORD *)(a1 + 144) = v16;
  *(_OWORD *)(a1 + 160) = v17;
  v19 = a2[5];
  v20 = a2[6];
  v21 = a2[8];
  *(_OWORD *)(a1 + 240) = a2[7];
  *(_OWORD *)(a1 + 256) = v21;
  *(_OWORD *)(a1 + 208) = v19;
  *(_OWORD *)(a1 + 224) = v20;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

void sub_183F7D614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
  AutoString::~AutoString((AutoString *)&a43);
  AutoString::~AutoString((AutoString *)&a62);
  _Unwind_Resume(a1);
}

__CFString *__CreatePathToCacheDirectory(const __CFString *a1, char a2)
{
  const __CFArray *v4;
  const __CFArray *v5;
  const __CFURL *ValueAtIndex;
  const __CFAllocator *v7;
  size_t v8;
  const __CFString *v9;
  __CFString *MutableCopy;
  __CFBundle *MainBundle;
  CFStringRef Identifier;
  const __CFString *v13;
  const void *v14;
  const char *v16;
  CFStringRef v17;
  const __CFString *v18;
  UInt8 buffer[1024];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFArray *)CFCopySearchPathForDirectoriesInDomains();
  if (!v4)
    return 0;
  v5 = v4;
  if (CFArrayGetCount(v4) < 1
    || (ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v5, 0)) == 0
    || !CFURLGetFileSystemRepresentation(ValueAtIndex, 1u, buffer, 1024))
  {
    v14 = v5;
LABEL_13:
    CFRelease(v14);
    return 0;
  }
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = strlen((const char *)buffer);
  v9 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], buffer, v8, 0x8000100u, 0);
  MutableCopy = CFStringCreateMutableCopy(v7, 0, v9);
  if (v9)
    CFRelease(v9);
  CFRelease(v5);
  if (MutableCopy)
  {
    if ((a2 & 1) != 0)
      goto LABEL_19;
    MainBundle = CFBundleGetMainBundle();
    if (MainBundle)
    {
      Identifier = CFBundleGetIdentifier(MainBundle);
      if (Identifier)
      {
        v13 = Identifier;
        CFStringAppend(MutableCopy, CFSTR("/"));
        CFStringAppend(MutableCopy, v13);
        goto LABEL_19;
      }
    }
    v16 = *(const char **)_CFGetProgname();
    if (v16)
    {
      v17 = CFStringCreateWithCString(v7, v16, 0x8000100u);
      if (v17)
      {
        v18 = v17;
        CFStringAppend(MutableCopy, CFSTR("/"));
        CFStringAppend(MutableCopy, v18);
        CFRelease(v18);
LABEL_19:
        if (a1)
        {
          CFStringAppend(MutableCopy, CFSTR("/"));
          CFStringAppend(MutableCopy, a1);
        }
        return MutableCopy;
      }
    }
    v14 = MutableCopy;
    goto LABEL_13;
  }
  return MutableCopy;
}

uint64_t URLProtectionSpace::serializeToPropertyList(URLProtectionSpace *this, SerializableArchive **a2)
{
  const void *v4;
  CFTypeRef v5;
  CFTypeRef v6;
  const void *v7;
  CFTypeRef v8;
  void (**v10)(AutoScalar *__hidden);
  CFTypeRef cf;

  Serializable::serializeToPropertyList((URLProtectionSpace *)((char *)this + 8), a2);
  v4 = (const void *)*((_QWORD *)this + 4);
  SerializableArchive::assertEmpty(*a2, CFSTR("host"));
  if (v4)
    CFDictionarySetValue(*a2, CFSTR("host"), v4);
  AutoScalar::AutoScalar((AutoScalar *)&v10, (const __CFAllocator *)*((unsigned int *)this + 10));
  v5 = cf;
  SerializableArchive::assertEmpty(*a2, CFSTR("port"));
  if (v5)
    CFDictionarySetValue(*a2, CFSTR("port"), v5);
  v10 = &off_1E14E47E8;
  if (cf)
    CFRelease(cf);
  AutoScalar::AutoScalar((AutoScalar *)&v10, (const __CFAllocator *)*((unsigned int *)this + 11));
  v6 = cf;
  SerializableArchive::assertEmpty(*a2, CFSTR("type"));
  if (v6)
    CFDictionarySetValue(*a2, CFSTR("type"), v6);
  v10 = &off_1E14E47E8;
  if (cf)
    CFRelease(cf);
  v7 = (const void *)*((_QWORD *)this + 6);
  SerializableArchive::assertEmpty(*a2, CFSTR("realm"));
  if (v7)
    CFDictionarySetValue(*a2, CFSTR("realm"), v7);
  AutoScalar::AutoScalar((AutoScalar *)&v10, (const __CFAllocator *)*((unsigned int *)this + 14));
  v8 = cf;
  SerializableArchive::assertEmpty(*a2, CFSTR("scheme"));
  if (v8)
    CFDictionarySetValue(*a2, CFSTR("scheme"), v8);
  v10 = &off_1E14E47E8;
  if (cf)
    CFRelease(cf);
  SerializableArchive::add((CFTypeRef *)a2, CFSTR("distnames"), *((const __CFArray **)this + 8));
  SerializableArchive::add((CFTypeRef *)a2, CFSTR("trust"), *((__SecTrust **)this + 9));
  return 1;
}

void sub_183F7D9B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(CFTypeRef *this, __CFString *a2, const __CFArray *a3)
{
  CFIndex Count;
  const __CFAllocator *v7;
  SerializableArchive *Mutable;
  CFTypeRef v9;
  CFIndex v10;
  const __CFAllocator *v11;
  const __CFAllocator *v12;
  const __CFString *v13;
  __CFString *ValueAtIndex;
  __CFString *v15;
  CFTypeID v16;
  const __CFAllocator *v17;
  SerializableArchive *v18;
  CFNumberRef v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  const __CFURL *v23;
  NSURLRequest *v24;
  __SecAccessControl *v25;
  __SecCertificate *v26;
  __SecPolicy *v27;
  const __CFString *v28;
  __SecKey *v29;
  _CFURLAuthChallenge *v30;
  __CFString *v31;
  SerializableArchive *v32;
  void (**v33)(AutoScalar *__hidden);
  CFTypeRef cf;
  int valuePtr;
  const __CFString *v36;
  __int16 v37;
  __CFString *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    Count = CFArrayGetCount(a3);
    v7 = CFGetAllocator(*this);
    Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    AutoScalar::AutoScalar((AutoScalar *)&v33, (const __CFAllocator *)Count);
    v9 = cf;
    SerializableArchive::assertEmpty(Mutable, CFSTR("count"));
    if (v9)
      CFDictionarySetValue(Mutable, CFSTR("count"), v9);
    v31 = a2;
    v33 = &off_1E14E47E8;
    if (cf)
      CFRelease(cf);
    if (Count >= 1)
    {
      v10 = 0;
      v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      while (1)
      {
        v12 = CFGetAllocator(*this);
        AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)&v33, v12, CFSTR("ix%ld"), v10);
        v13 = (const __CFString *)cf;
        ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(a3, v10);
        v15 = ValueAtIndex;
        if (!ValueAtIndex)
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(valuePtr) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Should be trying to serialize something thats nil", (uint8_t *)&valuePtr, 2u);
          }
          goto LABEL_30;
        }
        v16 = CFGetTypeID(ValueAtIndex);
        v17 = CFGetAllocator(v15);
        v18 = CFDictionaryCreateMutable(v17, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v32 = v18;
        if (CFBooleanGetTypeID() == v16)
          break;
        if (CFNumberGetTypeID() == v16)
        {
          valuePtr = 1966083;
          v19 = CFNumberCreate(v11, kCFNumberSInt32Type, &valuePtr);
          SerializableArchive::assertEmpty(v18, CFSTR("kind"));
          if (!v19)
            goto LABEL_26;
          goto LABEL_25;
        }
        if (CFStringGetTypeID() == v16)
        {
          valuePtr = 2031619;
          v19 = CFNumberCreate(v11, kCFNumberSInt32Type, &valuePtr);
          SerializableArchive::assertEmpty(v18, CFSTR("kind"));
          if (!v19)
            goto LABEL_26;
          goto LABEL_25;
        }
        if (CFDataGetTypeID() == v16)
        {
          valuePtr = 2097155;
          v19 = CFNumberCreate(v11, kCFNumberSInt32Type, &valuePtr);
          SerializableArchive::assertEmpty(v18, CFSTR("kind"));
          if (!v19)
            goto LABEL_26;
          goto LABEL_25;
        }
        if (CFDateGetTypeID() == v16)
        {
          valuePtr = 2162691;
          v19 = CFNumberCreate(v11, kCFNumberSInt32Type, &valuePtr);
          SerializableArchive::assertEmpty(v18, CFSTR("kind"));
          if (v19)
            goto LABEL_25;
LABEL_26:
          SerializableArchive::assertEmpty(v18, CFSTR("valu"));
          CFDictionarySetValue(v18, CFSTR("valu"), v15);
          goto LABEL_27;
        }
        if (CFDictionaryGetTypeID() == v16)
        {
          valuePtr = 2490371;
          v20 = CFNumberCreate(v11, kCFNumberSInt32Type, &valuePtr);
          SerializableArchive::assertEmpty(v18, CFSTR("kind"));
          if (v20)
          {
            CFDictionarySetValue(v18, CFSTR("kind"), v20);
            CFRelease(v20);
          }
          SerializableArchive::add((CFTypeRef *)&v32, CFSTR("valu"), (CFDictionaryRef)v15);
        }
        else if (CFArrayGetTypeID() == v16)
        {
          valuePtr = 2555907;
          v21 = CFNumberCreate(v11, kCFNumberSInt32Type, &valuePtr);
          SerializableArchive::assertEmpty(v18, CFSTR("kind"));
          if (v21)
          {
            CFDictionarySetValue(v18, CFSTR("kind"), v21);
            CFRelease(v21);
          }
          SerializableArchive::add((SerializableArchive *)&v32, CFSTR("valu"), (const __CFArray *)v15);
        }
        else if (CFErrorGetTypeID() == v16)
        {
          valuePtr = 2621443;
          v22 = CFNumberCreate(v11, kCFNumberSInt32Type, &valuePtr);
          SerializableArchive::assertEmpty(v18, CFSTR("kind"));
          if (v22)
          {
            CFDictionarySetValue(v18, CFSTR("kind"), v22);
            CFRelease(v22);
          }
          SerializableArchive::add((CFTypeRef *)&v32, CFSTR("valu"), (__CFError *)v15);
        }
        else if (CFURLGetTypeID() == v16)
        {
          SerializableArchive::add(&v32, (const __CFString *)0x290003);
          SerializableArchive::add(&v32, (CFURLRef)v15, v23);
        }
        else
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            SerializableArchive::add(&v32, (const __CFString *)0x2E0003);
            SerializableArchive::add(&v32, CFSTR("valu"), v15);
          }
          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x2F0003);
              SerializableArchive::add((CFTypeRef *)&v32, v15, v24);
            }
            else if (SecAccessControlGetTypeID() == v16)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x390003);
              SerializableArchive::add((CFTypeRef *)&v32, v15, v25);
            }
            else if (SecTrustGetTypeID() == v16)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x3C0003);
              SerializableArchive::add((CFTypeRef *)&v32, CFSTR("valu"), (__SecTrust *)v15);
            }
            else if (SecCertificateGetTypeID() == v16)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x3E0003);
              SerializableArchive::add(&v32, (SecCertificateRef)v15, v26);
            }
            else if (SecPolicyGetTypeID() == v16)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x3F0003);
              SerializableArchive::add(&v32, v15, v27);
            }
            else if (SecKeyGetTypeID() == v16)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x400003);
              SerializableArchive::add(&v32, v28, v29);
            }
            else
            {
              if (URLCredential::Class(void)::sOnce_URLCredential != -1)
                dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
              if (*(_QWORD *)(URLCredential::Class(void)::sClass_OBJTYPE + 96) == v16)
              {
                SerializableArchive::add(&v32, (const __CFString *)0x4E0003);
                SerializableArchive::add(&v32, CFSTR("valu"), (const _CFURLCredential *)v15);
              }
              else
              {
                if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
                  dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
                if (*(_QWORD *)(URLAuthChallenge::Class(void)::sClass_OBJTYPE + 96) == v16)
                {
                  SerializableArchive::add(&v32, (const __CFString *)0x4F0003);
                  SerializableArchive::add(&v32, v15, v30);
                }
                else
                {
                  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
                    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
                  if (*(_QWORD *)(URLProtectionSpace::Class(void)::sClass_OBJTYPE + 96) != v16)
                  {
                    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
                    {
                      valuePtr = 138412546;
                      v36 = v13;
                      v37 = 2112;
                      v38 = v15;
                      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Unable to serialize key %@ as object %@", (uint8_t *)&valuePtr, 0x16u);
                    }
                    goto LABEL_28;
                  }
                  SerializableArchive::add(&v32, (const __CFString *)0x500003);
                  SerializableArchive::add(&v32, CFSTR("valu"), (_CFURLProtectionSpace *)v15);
                }
              }
            }
          }
        }
LABEL_27:
        SerializableArchive::assertEmpty(Mutable, v13);
        CFDictionarySetValue(Mutable, v13, v18);
LABEL_28:
        if (v18)
          CFRelease(v18);
LABEL_30:
        AutoString::~AutoString((AutoString *)&v33);
        if (Count == ++v10)
          goto LABEL_74;
      }
      valuePtr = 1900547;
      v19 = CFNumberCreate(v11, kCFNumberSInt32Type, &valuePtr);
      SerializableArchive::assertEmpty(v18, CFSTR("kind"));
      if (!v19)
        goto LABEL_26;
LABEL_25:
      CFDictionarySetValue(v18, CFSTR("kind"), v19);
      CFRelease(v19);
      goto LABEL_26;
    }
LABEL_74:
    SerializableArchive::assertEmpty((SerializableArchive *)*this, v31);
    CFDictionarySetValue((CFMutableDictionaryRef)*this, v31, Mutable);
    if (Mutable)
      CFRelease(Mutable);
  }
}

void sub_183F7E28C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef cf)
{
  const void *v17;
  const void *v18;
  const void *v19;

  CFRelease(v18);
  if (v19)
    CFRelease(v19);
  AutoString::~AutoString((AutoString *)&a16);
  if (v17)
    CFRelease(v17);
  _Unwind_Resume(a1);
}

void SerializableArchive::assertEmpty(SerializableArchive *this, const __CFString *a2)
{
  int v3;
  const __CFString *v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (CFDictionaryGetValue(this, a2))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      v3 = 138412290;
      v4 = a2;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Key %@ already present", (uint8_t *)&v3, 0xCu);
    }
  }
}

void AutoScalar::AutoScalar(AutoScalar *this, const __CFAllocator *a2)
{
  void *v3;
  uint64_t v4;
  CFNumberRef v5;
  int valuePtr;
  int v7;

  valuePtr = (int)a2;
  *(_QWORD *)this = &off_1E14E47E8;
  if (((_DWORD)a2 - 16) > 0xFFFFFFEC)
  {
    v7 = (int)a2;
    v4 = ((_DWORD)a2 + 3);
    v5 = (CFNumberRef)copyInternedInt(int)::sInterned[v4];
    if (!v5)
    {
      v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v7);
      copyInternedInt(int)::sInterned[v4] = v5;
    }
    v3 = (void *)CFRetain(v5);
  }
  else
  {
    v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  }
  *((_QWORD *)this + 1) = v3;
}

void AutoStringWithFormat::AutoStringWithFormat(AutoStringWithFormat *this, CFAllocatorRef alloc, const __CFString *a3, ...)
{
  CFStringRef v4;
  va_list va;

  va_start(va, a3);
  *(_QWORD *)this = &off_1E14EB098;
  v4 = CFStringCreateWithFormatAndArguments(alloc, 0, a3, va);
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 1) = v4;
}

void sub_183F7E4E0(_Unwind_Exception *a1)
{
  AutoString *v1;

  AutoString::~AutoString(v1);
  _Unwind_Resume(a1);
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2)
{
  CFTypeRef v3;
  void (**v4)(AutoScalar *__hidden);
  CFTypeRef cf;

  AutoScalar::AutoScalar((AutoScalar *)&v4, (const __CFAllocator *)a2);
  v3 = cf;
  SerializableArchive::assertEmpty(*this, CFSTR("kind"));
  if (v3)
    CFDictionarySetValue(*this, CFSTR("kind"), v3);
  v4 = &off_1E14E47E8;
  if (cf)
    CFRelease(cf);
}

void sub_183F7E564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(SerializableArchive **this, SecCertificateRef certificate, __SecCertificate *a3)
{
  CFDataRef v4;
  CFDataRef v5;

  v4 = SecCertificateCopyData(certificate);
  if (v4)
  {
    v5 = v4;
    SerializableArchive::assertEmpty(*this, CFSTR("valu"));
    CFDictionarySetValue(*this, CFSTR("valu"), v5);
    CFRelease(v5);
  }
}

uint64_t Serializable::serializeToPropertyList(Serializable *this, SerializableArchive **a2)
{
  CFTypeRef v4;
  const void *v5;
  void (**v7)(AutoScalar *__hidden);
  CFTypeRef cf;

  AutoScalar::AutoScalar((AutoScalar *)&v7, (const __CFAllocator *)3);
  v4 = cf;
  SerializableArchive::assertEmpty(*a2, CFSTR("_version"));
  if (v4)
    CFDictionarySetValue(*a2, CFSTR("_version"), v4);
  v7 = &off_1E14E47E8;
  if (cf)
    CFRelease(cf);
  v5 = (const void *)*((_QWORD *)this + 1);
  SerializableArchive::assertEmpty(*a2, CFSTR("_kind"));
  if (v5)
    CFDictionarySetValue(*a2, CFSTR("_kind"), v5);
  return 1;
}

void sub_183F7E6A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(SerializableArchive **this, void *cf, __SecPolicy *a3)
{
  const __CFAllocator *v5;
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v7;
  CFMutableDictionaryRef v8;

  v5 = CFGetAllocator(cf);
  Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v8 = Mutable;
  v7 = SecPolicyCopyProperties((SecPolicyRef)cf);
  if (v7)
  {
    SerializableArchive::add((CFTypeRef *)&v8, CFSTR("properties"), v7);
    CFRelease(v7);
  }
  SerializableArchive::assertEmpty(*this, CFSTR("valu"));
  CFDictionarySetValue(*this, CFSTR("valu"), Mutable);
  if (Mutable)
    CFRelease(Mutable);
}

void sub_183F7E78C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(CFTypeRef *this, const __CFString *a2, CFDictionaryRef theDict)
{
  CFIndex Count;
  const void **v7;
  const void **v8;
  const __CFAllocator *v9;
  const CFArrayCallBacks *v10;
  const __CFArray *v11;
  const __CFAllocator *v12;
  const __CFArray *v13;
  const __CFAllocator *v14;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v16;

  if (theDict)
  {
    Count = CFDictionaryGetCount(theDict);
    v7 = (const void **)operator new[]();
    v8 = &v7[Count];
    CFDictionaryGetKeysAndValues(theDict, v7, v8);
    v9 = CFGetAllocator(*this);
    v10 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    v11 = CFArrayCreate(v9, v7, Count, MEMORY[0x1E0C9B378]);
    v12 = CFGetAllocator(*this);
    v13 = CFArrayCreate(v12, v8, Count, v10);
    v14 = CFGetAllocator(*this);
    Mutable = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v16 = Mutable;
    SerializableArchive::add((SerializableArchive *)&v16, CFSTR("keys"), v11);
    SerializableArchive::add((SerializableArchive *)&v16, CFSTR("vals"), v13);
    if (v11)
      CFRelease(v11);
    if (v13)
      CFRelease(v13);
    MEMORY[0x186DB7474](v7, 0xC0C80B8AA526DLL);
    SerializableArchive::assertEmpty((SerializableArchive *)*this, a2);
    CFDictionarySetValue((CFMutableDictionaryRef)*this, a2, Mutable);
    if (Mutable)
      CFRelease(Mutable);
  }
}

void sub_183F7E918(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(CFTypeRef *this, const __CFString *a2, __SecTrust *a3)
{
  const __CFAllocator *v6;
  CFMutableDictionaryRef Mutable;
  const __CFArray *v8;
  CFTypeRef cf;
  CFMutableDictionaryRef v10;

  if (a3)
  {
    v6 = CFGetAllocator(*this);
    Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v10 = Mutable;
    SecTrustEvaluateWithError(a3, 0);
    cf = 0;
    SecTrustCopyPolicies(a3, (CFArrayRef *)&cf);
    v8 = SecTrustCopyCertificateChain(a3);
    if (cf)
    {
      SerializableArchive::add((SerializableArchive *)&v10, CFSTR("policies"), (const __CFArray *)cf);
      if (cf)
        CFRelease(cf);
    }
    if (v8)
      SerializableArchive::add((SerializableArchive *)&v10, CFSTR("certs"), v8);
    SerializableArchive::assertEmpty((SerializableArchive *)*this, a2);
    CFDictionarySetValue((CFMutableDictionaryRef)*this, a2, Mutable);
    if (v8)
      CFRelease(v8);
    if (Mutable)
      CFRelease(Mutable);
  }
}

void sub_183F7EA28(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTPConnection::_onqueue_requestStart(HTTPConnection *this)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t (***v7)();
  uint64_t v8;
  int v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  uint64_t v14;
  int v15;
  std::__shared_weak_count *v16;
  HTTPRequestMessage *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  const char *v48;
  int v49;
  const char *v50;
  _QWORD v51[2];
  _QWORD aBlock[5];
  std::__shared_weak_count *v53;
  _QWORD v54[2];
  uint64_t v55[2];
  uint64_t v56;
  std::__shared_weak_count *v57;
  uint64_t (**v58)();
  std::__shared_weak_count *v59;
  uint64_t (***v60)();
  uint64_t v61;
  CFStreamError v62;

  v61 = *MEMORY[0x1E0C80C00];
  *((_WORD *)this + 16) |= 0x400u;
  v2 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_11611, 2);
  if (v2)
  {
    v3 = v2;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v2 + 16))(v2, "Prepare Transmission", 0))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    }
  }
  v4 = HTTPConnection::_onqueue_willEnqueueRequests(this, 0, 0);
  v5 = 0;
  if (v4 != 2)
  {
    if (!HTTPTransaction::requestPermitsConnectionReuse(*((HTTPTransaction **)this + 18)))
    {
LABEL_18:
      v62.domain = 4;
      *(_QWORD *)&v62.error = 4294967292;
      HTTPConnection::_onqueue_doNotAllowMoreRequests(this, v62, 0);
      v5 = 0;
      goto LABEL_19;
    }
    if ((*((_WORD *)this + 16) & 8) == 0)
    {
LABEL_17:
      v5 = 1;
      goto LABEL_19;
    }
    v6 = *((_QWORD *)this + 22);
    if (v6)
      pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
    LOBYTE(v56) = 1;
    v58 = &off_1E14F06C0;
    v59 = (std::__shared_weak_count *)&v56;
    v60 = &v58;
    AuthenticationState::_foreachAuthenticationInfo(v6, (uint64_t)&v58);
    v7 = v60;
    if (v60 == &v58)
    {
      v8 = 4;
      v7 = &v58;
    }
    else
    {
      if (!v60)
        goto LABEL_14;
      v8 = 5;
    }
    (*v7)[v8]();
LABEL_14:
    v9 = v56;
    if (v6)
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
    if (v9)
      goto LABEL_17;
    goto LABEL_18;
  }
LABEL_19:
  v10 = *((_QWORD *)this + 18);
  if (*(_QWORD *)(v10 + 192))
  {
    v11 = (std::__shared_weak_count *)*((_QWORD *)this + 19);
    if (v11)
    {
      p_shared_weak_owners = (unint64_t *)&v11->__shared_weak_owners_;
      do
        v13 = __ldxr(p_shared_weak_owners);
      while (__stxr(v13 + 1, p_shared_weak_owners));
      v14 = *((_QWORD *)this + 18);
    }
    else
    {
      v14 = *((_QWORD *)this + 18);
    }
  }
  else
  {
    v11 = 0;
    v14 = *((_QWORD *)this + 18);
    v10 = 0;
  }
  if (*(int *)(v14 + 80) > 3)
  {
    v48 = "_state <= State::Negotiating";
    v49 = 304;
    v50 = "getPreparedRequest";
    goto LABEL_88;
  }
  HTTPTransaction::_onqueue_prepareRequest((HTTPTransaction *)v14, v5, ((*((unsigned __int16 *)this + 16) | (*((unsigned __int8 *)this + 34) << 16)) >> 9) & 1);
  v15 = *(_DWORD *)(v14 + 80);
  if (v15 == 11)
    goto LABEL_30;
  if (v15 >= 5)
  {
    v48 = "newState >= _state";
    v49 = 1664;
    v50 = "_onqueue_changeState";
LABEL_88:
    __assert_rtn(v50, "HTTPTransaction.cpp", v49, v48);
  }
  *(_DWORD *)(v14 + 80) = 4;
LABEL_30:
  v17 = *(HTTPRequestMessage **)(v14 + 160);
  v16 = *(std::__shared_weak_count **)(v14 + 168);
  v58 = (uint64_t (**)())v17;
  v59 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v19 = __ldxr(p_shared_owners);
    while (__stxr(v19 + 1, p_shared_owners));
  }
  if ((*((_WORD *)this + 16) & 8) == 0
    && AuthenticationState::canApplyHeadersToRequest(*((AuthenticationState **)this + 22), v17))
  {
    (*(void (**)(_QWORD, HTTPRequestMessage *, HTTPConnection *, uint64_t))(**((_QWORD **)this + 22) + 24))(*((_QWORD *)this + 22), v17, this, 1);
  }
  v20 = *((_QWORD *)this + 18);
  v21 = *(_QWORD *)(v20 + 152);
  if (v21)
  {
    (*(void (**)(uint64_t, _QWORD))(v21 + 16))(v21, 0);
    _Block_release(*(const void **)(v20 + 152));
    *(_QWORD *)(v20 + 152) = 0;
  }
  v56 = 0;
  v57 = 0;
  v22 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (v22 && (v22 = std::__shared_weak_count::lock(v22), (v57 = v22) != 0))
  {
    v23 = *((_QWORD *)this + 5);
    v56 = v23;
  }
  else
  {
    v23 = 0;
  }
  v24 = *((_QWORD *)this + 8);
  v55[0] = (uint64_t)v17;
  v55[1] = (uint64_t)v16;
  if (v16)
  {
    v25 = (unint64_t *)&v16->__shared_owners_;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  v54[0] = v10;
  v54[1] = v11;
  if (v11)
  {
    v27 = (unint64_t *)&v11->__shared_weak_owners_;
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN14HTTPConnection21_onqueue_requestStartEv_block_invoke_2;
  aBlock[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e13_v24__0___qi_8l;
  aBlock[4] = v23;
  v53 = v22;
  if (v22)
  {
    v29 = (unint64_t *)&v22->__shared_owners_;
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
  }
  HTTPEngine::writeRequest(v24, v55, v54, aBlock);
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
  if (v16)
  {
    v31 = (unint64_t *)&v16->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v33 = *(_QWORD *)(*((_QWORD *)this + 18) + 216);
  if (!v33 || !*(_DWORD *)(v33 + 40))
  {
    v34 = (std::__shared_weak_count *)*((_QWORD *)this + 19);
    v51[0] = *((_QWORD *)this + 18);
    v51[1] = v34;
    if (v34)
    {
      v35 = (unint64_t *)&v34->__shared_owners_;
      do
        v36 = __ldxr(v35);
      while (__stxr(v36 + 1, v35));
    }
    HTTPConnection::suspendTransaction((uint64_t)this, v51, 1);
    if (v34)
    {
      v37 = (unint64_t *)&v34->__shared_owners_;
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
  }
  HTTPConnection::_onqueue_attemptNextResponse(this);
  v39 = v53;
  if (v53)
  {
    v40 = (unint64_t *)&v53->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  v42 = v57;
  if (v57)
  {
    v43 = (unint64_t *)&v57->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v45 = v59;
  if (v59)
  {
    v46 = (unint64_t *)&v59->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
}

void sub_183F7EF68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22)
{
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v26;
  uint64_t v27;

  v26 = *(_QWORD **)(v24 - 64);
  if (v26 == v23)
  {
    v27 = 4;
    v26 = (_QWORD *)(v24 - 88);
  }
  else
  {
    if (!v26)
      goto LABEL_6;
    v27 = 5;
  }
  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_6:
  if (v22)
    pthread_mutex_unlock((pthread_mutex_t *)(v22 + 8));
  _Unwind_Resume(exception_object);
}

BOOL HTTPTransaction::requestPermitsConnectionReuse(HTTPTransaction *this)
{
  HTTPMessage *v2;
  const __CFString *v3;
  const __CFString *v4;
  _BOOL8 v5;

  v2 = (HTTPMessage *)*((_QWORD *)this + 20);
  if (!v2)
    return 1;
  if ((*((_WORD *)this + 16) & 1) == 0)
    return 1;
  v3 = HTTPMessage::copyHeaderFieldValue(v2, 0x119152ADu);
  if (!v3)
    return 1;
  v4 = v3;
  v5 = CFStringCompare(v3, (CFStringRef)&unk_1EDCFDC10, 1uLL) != kCFCompareEqualTo;
  CFRelease(v4);
  return v5;
}

void sub_183F7F08C(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTPConnection::_onqueue_attemptNextResponse(HTTPConnection *this)
{
  int v2;
  int v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count_vtbl *v15;
  void (__cdecl *ByteHeadroomInfoBlock)(std::__shared_weak_count *__hidden);
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  _QWORD v42[2];
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t);
  void *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  uint64_t v50;
  void (*v51)(uint64_t, dispatch_object_t, CFStreamError, unsigned int);
  void *v52;
  uint64_t v53;
  std::__shared_weak_count *v54;
  _QWORD v55[5];
  std::__shared_weak_count *v56;
  uint64_t v57;
  std::__shared_weak_count *v58;
  uint64_t v59;
  std::__shared_weak_count *v60;

  if (!*((_QWORD *)this + 8))
    return;
  v2 = *((unsigned __int16 *)this + 16);
  v3 = v2 | (*((unsigned __int8 *)this + 34) << 16);
  if ((v2 & 0x100) != 0 || *((_QWORD *)this + 15) == *((_QWORD *)this + 16))
    return;
  if ((v2 & 0x6000) != 0 || *((_QWORD *)this + 20) == 0)
    return;
  *((_BYTE *)this + 34) = BYTE2(v3);
  *((_WORD *)this + 16) = v3 | 0x2000;
  v59 = 0;
  v60 = 0;
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (!v5)
  {
    v6 = 0;
    goto LABEL_12;
  }
  v6 = std::__shared_weak_count::lock(v5);
  v60 = v6;
  if (!v6)
  {
LABEL_12:
    v7 = 0;
    goto LABEL_13;
  }
  v7 = *((_QWORD *)this + 5);
  v59 = v7;
LABEL_13:
  v8 = *((_QWORD *)this + 8);
  v9 = (_QWORD *)*((_QWORD *)this + 20);
  v11 = v9[20];
  v10 = (std::__shared_weak_count *)v9[21];
  v57 = v11;
  v58 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    v9 = (_QWORD *)*((_QWORD *)this + 20);
  }
  v14 = v9[26];
  if (v14 && (v15 = *(std::__shared_weak_count_vtbl **)(v14 - 112)) != 0)
    ByteHeadroomInfoBlock = Throttler::getByteHeadroomInfoBlock(v15);
  else
    ByteHeadroomInfoBlock = 0;
  v17 = MEMORY[0x1E0C809B0];
  v55[0] = MEMORY[0x1E0C809B0];
  v55[1] = 3321888768;
  v55[2] = ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke;
  v55[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e93_v40__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8___qi_24l;
  v55[4] = v7;
  v56 = v6;
  if (v6)
  {
    v18 = (unint64_t *)&v6->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
    v49 = v17;
    v50 = 3321888768;
    v51 = ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke_26;
    v52 = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
    v53 = v7;
    v54 = v6;
    do
      v20 = __ldxr(v18);
    while (__stxr(v20 + 1, v18));
    v44 = 3321888768;
    v45 = ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke_29;
    v46 = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e85_v24__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8l;
    v47 = v7;
    v48 = v6;
    do
      v21 = __ldxr(v18);
    while (__stxr(v21 + 1, v18));
  }
  else
  {
    v49 = MEMORY[0x1E0C809B0];
    v50 = 3321888768;
    v51 = ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke_26;
    v52 = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
    v53 = v7;
    v54 = 0;
    v44 = 3321888768;
    v45 = ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke_29;
    v46 = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e85_v24__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8l;
    v47 = v7;
    v48 = 0;
  }
  v43 = v17;
  HTTPEngine::readResponse(v8, v11, (uint64_t)v10, ByteHeadroomInfoBlock, v55, &v49, &v43);
  if (v10)
  {
    v22 = (unint64_t *)&v10->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  if (!HTTPTransaction::requestExpectsResponseBody(*(HTTPTransaction **)(*((_QWORD *)this + 20) + 160)))
    HTTPEngine::setProperty(*((HTTPEngine **)this + 8), (CFStringRef)&unk_1EDCFE508, (const void *)*MEMORY[0x1E0C9AE50]);
  HTTPConnection::_onqueue_checkAndUpdateLargeDownload((uint64_t)this);
  v24 = *(_QWORD *)(*((_QWORD *)this + 20) + 216);
  if (!v24 || !*(_DWORD *)(v24 + 40))
  {
    v25 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
    v42[0] = *((_QWORD *)this + 20);
    v42[1] = v25;
    if (v25)
    {
      v26 = (unint64_t *)&v25->__shared_owners_;
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    HTTPConnection::suspendTransaction((uint64_t)this, v42, 1);
    if (v25)
    {
      v28 = (unint64_t *)&v25->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
  }
  v30 = v48;
  if (v48)
  {
    v31 = (unint64_t *)&v48->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = v54;
  if (v54)
  {
    v34 = (unint64_t *)&v54->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  v36 = v56;
  if (v56)
  {
    v37 = (unint64_t *)&v56->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  v39 = v60;
  if (v60)
  {
    v40 = (unint64_t *)&v60->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
}

void sub_183F7F498(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 - 112);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 - 96);
  _Unwind_Resume(a1);
}

void (__cdecl *Throttler::getByteHeadroomInfoBlock(std::__shared_weak_count_vtbl *this))(std::__shared_weak_count *__hidden this)
{
  void (__cdecl *result)(std::__shared_weak_count *__hidden);
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD v12[5];
  std::__shared_weak_count *v13;
  Throttler *v14;
  std::__shared_weak_count *v15;

  result = this[2].__on_zero_shared_weak;
  if (!result)
  {
    if ((uint64_t)this[2].__get_deleter < 1)
    {
      return 0;
    }
    else
    {
      (*((void (**)(std::__shared_weak_count_vtbl *))this->~__shared_weak_count + 5))(this);
      v14 = (Throttler *)this;
      v3 = (std::__shared_weak_count *)operator new();
      v3->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1940;
      v3->__shared_weak_owners_ = 0;
      v3[1].__vftable = this;
      v15 = v3;
      v12[4] = this;
      v13 = v3;
      v3->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      v12[0] = MEMORY[0x1E0C809B0];
      v12[1] = 3321888768;
      v12[2] = ___ZN9Throttler24getByteHeadroomInfoBlockEv_block_invoke;
      v12[3] = &__block_descriptor_48_e8_32c36_ZTSNSt3__110shared_ptrI9ThrottlerEE_e5_q8__0l;
      do
        v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
      this[2].__on_zero_shared_weak = (void (__cdecl *)(std::__shared_weak_count *__hidden))_Block_copy(v12);
      v6 = v13;
      if (v13)
      {
        v7 = (unint64_t *)&v13->__shared_owners_;
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
      v9 = v15;
      if (v15)
      {
        v10 = (unint64_t *)&v15->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      return this[2].__on_zero_shared_weak;
    }
  }
  return result;
}

void sub_183F7F650(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

BOOL HTTPTransaction::requestExpectsResponseBody(HTTPTransaction *this)
{
  const void *v1;
  CFTypeRef v2;
  const void *v3;
  _BOOL8 v4;

  if (!this)
    return 1;
  v1 = (const void *)*((_QWORD *)this + 19);
  if (!v1)
    return 1;
  v2 = CFRetain(v1);
  if (!v2)
    return 1;
  v3 = v2;
  v4 = CFEqual(v2, &unk_1EDCFE150) == 0;
  CFRelease(v3);
  return v4;
}

void sub_183F7F6C8(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTPEngine::writeRequest(uint64_t a1, uint64_t *a2, _QWORD *a3, void *aBlock)
{
  int v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  NSObject *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  NSObject *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  NSObject *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t *v37;
  NSObject *v38;
  unint64_t *p_shared_owners;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t *v44;
  _QWORD v45[5];
  std::__shared_weak_count *v46;
  _QWORD v47[5];
  std::__shared_weak_count *v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD block[5];
  std::__shared_weak_count *v52;
  uint64_t v53;
  uint64_t v54;
  __int128 v55;

  if (!*a2)
    __assert_rtn("writeRequest", "HTTPEngine.cpp", 507, "request");
  if (*(_QWORD *)(a1 + 312))
    __assert_rtn("writeRequest", "HTTPEngine.cpp", 510, "!_outCB");
  *(_QWORD *)(a1 + 312) = _Block_copy(aBlock);
  if (*(_QWORD *)(a1 + 56) && (v7 = *(_DWORD *)(a1 + 32), (v7 & 3) == 0))
  {
    if (!*(_QWORD *)(a1 + 240) || (v7 & 0x1000010) == 0x1000010)
    {
      std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 240), *a2, a2[1]);
      v55 = 0uLL;
      v21 = (std::__shared_weak_count *)a3[1];
      if (v21)
      {
        *((_QWORD *)&v55 + 1) = std::__shared_weak_count::lock(v21);
        if (*((_QWORD *)&v55 + 1))
          *(_QWORD *)&v55 = *a3;
      }
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 256, &v55);
      v22 = (std::__shared_weak_count *)*((_QWORD *)&v55 + 1);
      if (*((_QWORD *)&v55 + 1))
      {
        v23 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      if (!*(_QWORD *)(a1 + 256))
      {
        v55 = 0uLL;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 256, &v55);
        v28 = (std::__shared_weak_count *)*((_QWORD *)&v55 + 1);
        if (*((_QWORD *)&v55 + 1))
        {
          v29 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
      }
      *(_QWORD *)(a1 + 288) = 0;
      *(_QWORD *)(a1 + 296) = 0;
      v25 = *(NSObject **)(a1 + 304);
      if (v25)
      {
        dispatch_release(v25);
        *(_QWORD *)(a1 + 304) = 0;
      }
      *(_DWORD *)(a1 + 32) &= 0xF07FFFFF;
      v26 = *(std::__shared_weak_count **)(a1 + 48);
      if (v26)
      {
        v9 = std::__shared_weak_count::lock(v26);
        if (v9)
          v27 = *(_QWORD *)(a1 + 40);
        else
          v27 = 0;
      }
      else
      {
        v27 = 0;
        v9 = 0;
      }
      v38 = *(NSObject **)(a1 + 72);
      v45[0] = MEMORY[0x1E0C809B0];
      v45[1] = 3321888768;
      v45[2] = ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke_3;
      v45[3] = &__block_descriptor_48_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
      v45[4] = v27;
      v46 = v9;
      if (v9)
      {
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v40 = __ldxr(p_shared_owners);
        while (__stxr(v40 + 1, p_shared_owners));
      }
      dispatch_async(v38, v45);
      v41 = v46;
      if (v46)
      {
        v42 = (unint64_t *)&v46->__shared_owners_;
        do
          v43 = __ldaxr(v42);
        while (__stlxr(v43 - 1, v42));
        if (!v43)
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }
      if (v9)
      {
        v44 = (unint64_t *)&v9->__shared_owners_;
        do
          v20 = __ldaxr(v44);
        while (__stlxr(v20 - 1, v44));
        goto LABEL_26;
      }
    }
    else
    {
      v11 = *(std::__shared_weak_count **)(a1 + 48);
      if (v11)
      {
        v9 = std::__shared_weak_count::lock(v11);
        if (v9)
          v12 = *(_QWORD *)(a1 + 40);
        else
          v12 = 0;
      }
      else
      {
        v12 = 0;
        v9 = 0;
      }
      v31 = *(NSObject **)(a1 + 72);
      v47[0] = MEMORY[0x1E0C809B0];
      v47[1] = 3321888768;
      v47[2] = ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke_2;
      v47[3] = &__block_descriptor_64_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
      v47[4] = v12;
      v48 = v9;
      if (v9)
      {
        v32 = (unint64_t *)&v9->__shared_owners_;
        do
          v33 = __ldxr(v32);
        while (__stxr(v33 + 1, v32));
      }
      v49 = 4;
      v50 = 4294965201;
      dispatch_async(v31, v47);
      v34 = v48;
      if (v48)
      {
        v35 = (unint64_t *)&v48->__shared_owners_;
        do
          v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
      if (v9)
      {
        v37 = (unint64_t *)&v9->__shared_owners_;
        do
          v20 = __ldaxr(v37);
        while (__stlxr(v20 - 1, v37));
        goto LABEL_26;
      }
    }
  }
  else
  {
    v8 = *(std::__shared_weak_count **)(a1 + 48);
    if (v8)
    {
      v9 = std::__shared_weak_count::lock(v8);
      if (v9)
        v10 = *(_QWORD *)(a1 + 40);
      else
        v10 = 0;
    }
    else
    {
      v10 = 0;
      v9 = 0;
    }
    v13 = *(NSObject **)(a1 + 72);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke;
    block[3] = &__block_descriptor_64_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
    block[4] = v10;
    v52 = v9;
    if (v9)
    {
      v14 = (unint64_t *)&v9->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v53 = 4;
    v54 = 4294967292;
    dispatch_async(v13, block);
    v16 = v52;
    if (v52)
    {
      v17 = (unint64_t *)&v52->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
    if (v9)
    {
      v19 = (unint64_t *)&v9->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
LABEL_26:
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
}

void HTTPEngine::readResponse(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, const void *a5, const void *a6, const void *a7)
{
  _QWORD *v8;
  uint64_t v9;
  int v14;
  _OWORD *Instance;
  HTTPMessage *v16;
  _QWORD *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  NSObject *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  NSObject *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  _QWORD v43[6];
  std::__shared_weak_count *v44;
  _QWORD block[5];
  std::__shared_weak_count *v46;
  uint64_t v47;
  uint64_t v48;
  __int128 v49;

  v9 = *(_QWORD *)(a1 + 144);
  v8 = (_QWORD *)(a1 + 144);
  if (v9)
    __assert_rtn("readResponse", "HTTPEngine.cpp", 407, "!_inResponseAssociatedRequest");
  if (*(_QWORD *)(a1 + 160))
    __assert_rtn("readResponse", "HTTPEngine.cpp", 408, "!_inHeadroomInfo");
  if (*(_QWORD *)(a1 + 200))
    __assert_rtn("readResponse", "HTTPEngine.cpp", 409, "!_inCBHeaders");
  if (*(_QWORD *)(a1 + 208))
    __assert_rtn("readResponse", "HTTPEngine.cpp", 410, "!_inCBData");
  std::shared_ptr<__CFString const>::operator=[abi:nn180100](v8, a2, a3);
  if (a4)
    *(_QWORD *)(a1 + 160) = _Block_copy(a4);
  *(_QWORD *)(a1 + 200) = _Block_copy(a5);
  *(_QWORD *)(a1 + 208) = _Block_copy(a6);
  *(_QWORD *)(a1 + 216) = _Block_copy(a7);
  if (!*(_QWORD *)(a1 + 56) || (v14 = *(_DWORD *)(a1 + 32), (v14 & 1) != 0))
  {
    v26 = *(std::__shared_weak_count **)(a1 + 48);
    if (v26)
    {
      v24 = std::__shared_weak_count::lock(v26);
      if (v24)
        v27 = *(_QWORD *)(a1 + 40);
      else
        v27 = 0;
    }
    else
    {
      v27 = 0;
      v24 = 0;
    }
    v28 = *(NSObject **)(a1 + 72);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZN10HTTPEngine12readResponseENSt3__110shared_ptrI18HTTPRequestMessageEEU13block_pointerFxvEU13block_pointerFvNS1_I19HTTPResponseMessageEE13CFStreamErrorEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectS8_bEU13block_pointerFvS7_E_block_invoke;
    block[3] = &__block_descriptor_64_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
    block[4] = v27;
    v46 = v24;
    if (v24)
    {
      p_shared_owners = (unint64_t *)&v24->__shared_owners_;
      do
        v30 = __ldxr(p_shared_owners);
      while (__stxr(v30 + 1, p_shared_owners));
    }
    v47 = 4;
    v48 = 4294967292;
    dispatch_async(v28, block);
    v31 = v46;
    if (v46)
    {
      v32 = (unint64_t *)&v46->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    if (v24)
    {
      v34 = (unint64_t *)&v24->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      goto LABEL_55;
    }
  }
  else
  {
    if ((~v14 & 0x50) == 0)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      Instance = (_OWORD *)_CFRuntimeCreateInstance();
      v16 = (HTTPMessage *)Instance;
      if (Instance)
      {
        Instance[1] = 0u;
        v16 = (HTTPMessage *)(Instance + 1);
        Instance[18] = 0u;
        Instance[19] = 0u;
        Instance[16] = 0u;
        Instance[17] = 0u;
        Instance[14] = 0u;
        Instance[15] = 0u;
        Instance[12] = 0u;
        Instance[13] = 0u;
        Instance[10] = 0u;
        Instance[11] = 0u;
        Instance[8] = 0u;
        Instance[9] = 0u;
        Instance[6] = 0u;
        Instance[7] = 0u;
        Instance[4] = 0u;
        Instance[5] = 0u;
        Instance[2] = 0u;
        Instance[3] = 0u;
      }
      HTTPMessage::HTTPMessage(v16, "httpresponse");
      *(_QWORD *)v16 = &off_1E14E9F38;
      *((_QWORD *)v16 + 1) = &unk_1E14E9FA8;
      *((_QWORD *)v16 + 2) = &unk_1E14E9FC8;
      *((_DWORD *)v16 + 32) = -1;
      *((_QWORD *)v16 + 17) = 0;
      *((_OWORD *)v16 + 10) = 0u;
      *((_OWORD *)v16 + 11) = 0u;
      *((_OWORD *)v16 + 12) = 0u;
      *((_OWORD *)v16 + 13) = 0u;
      *((_OWORD *)v16 + 14) = 0u;
      *((_OWORD *)v16 + 15) = 0u;
      *((_OWORD *)v16 + 16) = 0u;
      *((_OWORD *)v16 + 17) = 0u;
      *((_BYTE *)v16 + 296) = 0;
      *(_QWORD *)&v49 = v16;
      v17 = (_QWORD *)operator new();
      *v17 = &off_1E14F1710;
      v17[1] = 0;
      v17[2] = 0;
      v17[3] = v16;
      *((_QWORD *)&v49 + 1) = v17;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 128, &v49);
      v18 = (std::__shared_weak_count *)*((_QWORD *)&v49 + 1);
      if (*((_QWORD *)&v49 + 1))
      {
        v19 = (unint64_t *)(*((_QWORD *)&v49 + 1) + 8);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      *(_OWORD *)(a1 + 176) = xmmword_1841E3800;
      v21 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 32) = v21 & 0xFFF003BF;
      if ((v21 & 0x100000) != 0)
      {
        *(_DWORD *)(a1 + 32) = v21 & 0xFFE003BF;
        v22 = *(_QWORD *)(a1 + 56);
        if (v22)
          (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v22 + 200))(v22, 0x1EDCFA5D0, *MEMORY[0x1E0C9AE40]);
      }
    }
    v23 = *(std::__shared_weak_count **)(a1 + 48);
    if (v23)
    {
      v24 = std::__shared_weak_count::lock(v23);
      if (v24)
        v25 = *(_QWORD *)(a1 + 40);
      else
        v25 = 0;
    }
    else
    {
      v25 = 0;
      v24 = 0;
    }
    v36 = *(NSObject **)(a1 + 72);
    v43[0] = MEMORY[0x1E0C809B0];
    v43[1] = 3321888768;
    v43[2] = ___ZN10HTTPEngine12readResponseENSt3__110shared_ptrI18HTTPRequestMessageEEU13block_pointerFxvEU13block_pointerFvNS1_I19HTTPResponseMessageEE13CFStreamErrorEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectS8_bEU13block_pointerFvS7_E_block_invoke_11;
    v43[3] = &__block_descriptor_56_e8_40c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
    v43[4] = a1;
    v43[5] = v25;
    v44 = v24;
    if (v24)
    {
      v37 = (unint64_t *)&v24->__shared_owners_;
      do
        v38 = __ldxr(v37);
      while (__stxr(v38 + 1, v37));
    }
    dispatch_async(v36, v43);
    v39 = v44;
    if (v44)
    {
      v40 = (unint64_t *)&v44->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    if (v24)
    {
      v42 = (unint64_t *)&v24->__shared_owners_;
      do
        v35 = __ldaxr(v42);
      while (__stlxr(v35 - 1, v42));
LABEL_55:
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
}

void HTTPProtocol::~HTTPProtocol(HTTPProtocol *this)
{
  ProxyConnectionEstablishment *v2;
  uint64_t v3;
  uint64_t v4;
  __CFRunLoopSource *v5;
  const void *v6;
  NSObject *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  uint64_t v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  uint64_t v22;
  const void *v23;
  void (**v24)(_QWORD, _QWORD, _QWORD);
  const void *v25;
  void (**v26)(_QWORD, _QWORD, _QWORD);
  uint64_t *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  uint64_t v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  void *v39;
  uint64_t v40;
  const void *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  const void *v46;
  const void *v47;
  const void *v48;
  const void *v49;
  const void *v50;
  const void *v51;
  const void *v52;
  const void *v53;
  const void *v54;
  __int128 v55;

  *(_QWORD *)this = &off_1E14E5A68;
  *((_QWORD *)this + 1) = &unk_1E14E5D68;
  *((_QWORD *)this + 2) = &unk_1E14E5D88;
  *((_QWORD *)this + 14) = &unk_1E14E5DC8;
  v2 = (ProxyConnectionEstablishment *)((char *)this + 112);
  *((_QWORD *)this + 15) = &unk_1E14E5E70;
  *((_QWORD *)this + 22) = &unk_1E14E5ED8;
  *((_QWORD *)this + 23) = &unk_1E14E6010;
  v3 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_14_7106, 1);
  v4 = v3;
  if (v3
    && (*(unsigned int (**)(uint64_t, const char *, HTTPProtocol *))(*(_QWORD *)v3 + 24))(v3, "~HTTPProtocol", this))
  {
    (*(void (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v4 + 48))(v4, "Request", *((_QWORD *)this + 11));
    (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v4 + 72))(v4, "sent", CFSTR("%lld"));
    (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v4 + 72))(v4, "received", CFSTR("%lld"));
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  v5 = (__CFRunLoopSource *)*((_QWORD *)this + 38);
  if (v5)
  {
    CFRunLoopSourceInvalidate(v5);
    v6 = (const void *)*((_QWORD *)this + 38);
    if (v6)
      CFRelease(v6);
  }
  v7 = *((_QWORD *)this + 90);
  if (v7)
    dispatch_release(v7);

  v8 = (const void *)*((_QWORD *)this + 29);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 30);
  if (v9)
    CFRelease(v9);
  v10 = (const void *)*((_QWORD *)this + 31);
  if (v10)
    CFRelease(v10);
  v11 = (const void *)*((_QWORD *)this + 32);
  if (v11)
    CFRelease(v11);
  v12 = (const void *)*((_QWORD *)this + 28);
  if (v12)
    CFRelease(v12);
  v13 = (const void *)*((_QWORD *)this + 55);
  if (v13)
    CFRelease(v13);
  HTTPProtocol::cleanupStreams(this);
  v14 = (const void *)*((_QWORD *)this + 44);
  if (v14)
    CFRelease(v14);
  v15 = *((_QWORD *)this + 46);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 48))(v15);
  v16 = (const void *)*((_QWORD *)this + 47);
  if (v16)
    CFRelease(v16);
  v17 = (const void *)*((_QWORD *)this + 45);
  if (v17)
    CFRelease(v17);
  v18 = (const void *)*((_QWORD *)this + 48);
  if (v18)
    CFRelease(v18);
  v19 = (const void *)*((_QWORD *)this + 49);
  if (v19)
    CFRelease(v19);
  v20 = (const void *)*((_QWORD *)this + 50);
  if (v20)
    CFRelease(v20);
  v21 = (const void *)*((_QWORD *)this + 37);
  if (v21)
    CFRelease(v21);
  v22 = *((_QWORD *)this + 35);
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 48))(v22);
  v23 = (const void *)*((_QWORD *)this + 51);
  *((_QWORD *)this + 51) = 0;
  if (v23)
    CFRelease(v23);
  v24 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 52);
  if (v24)
  {
    *((_QWORD *)this + 52) = 0;
    v24[2](v24, 0, 1);
    _Block_release(v24);
  }
  v25 = (const void *)*((_QWORD *)this + 53);
  *((_QWORD *)this + 53) = 0;
  if (v25)
    CFRelease(v25);
  v26 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 54);
  if (v26)
  {
    *((_QWORD *)this + 54) = 0;
    v26[2](v26, 0, 1);
    _Block_release(v26);
  }
  v27 = (uint64_t *)*((_QWORD *)this + 92);
  if (v27)
  {

    v28 = (const void *)v27[3];
    v27[3] = 0;
    if (v28)
      CFRelease(v28);
    v29 = (const void *)v27[2];
    v27[2] = 0;
    if (v29)
      CFRelease(v29);
    v30 = (const void *)v27[1];
    v27[1] = 0;
    if (v30)
      CFRelease(v30);
    v31 = *v27;
    *v27 = 0;
    if (v31)
      CFRelease((CFTypeRef)(v31 - 16));
    MEMORY[0x186DB748C](v27, 0x10E0C40084E53DELL);
  }
  v32 = (const void *)*((_QWORD *)this + 57);
  if (v32)
    CFRelease(v32);
  v33 = (const void *)*((_QWORD *)this + 58);
  if (v33)
    CFRelease(v33);
  v34 = (const void *)*((_QWORD *)this + 62);
  *((_QWORD *)this + 62) = 0;
  if (v34)
    CFRelease(v34);
  v35 = (const void *)*((_QWORD *)this + 59);
  if (v35)
    CFRelease(v35);
  v36 = (const void *)*((_QWORD *)this + 67);
  if (v36)
    CFRelease(v36);
  v37 = (const void *)*((_QWORD *)this + 68);
  if (v37)
    CFRelease(v37);
  v38 = (const void *)*((_QWORD *)this + 73);
  if (v38)
    CFRelease(v38);
  v39 = (void *)*((_QWORD *)this + 69);
  if (v39)
    free(v39);
  v40 = *((_QWORD *)this + 87);
  if (v40)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v40 + 48))(v40);
    *((_QWORD *)this + 87) = 0;
  }

  v41 = (const void *)*((_QWORD *)this + 94);
  *((_QWORD *)this + 93) = 0;
  *((_QWORD *)this + 94) = 0;
  if (v41)
    CFRelease(v41);
  v55 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 776, &v55);
  v42 = (std::__shared_weak_count *)*((_QWORD *)&v55 + 1);
  if (*((_QWORD *)&v55 + 1))
  {
    v43 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v45 = *((_QWORD *)this + 111);
  if (v45)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v45 + 48))(v45);
    *((_QWORD *)this + 111) = 0;
  }

  v46 = (const void *)*((_QWORD *)this + 110);
  if (v46)
    _Block_release(v46);
  v47 = (const void *)*((_QWORD *)this + 112);
  *((_QWORD *)this + 112) = 0;
  if (v47)
    CFRelease(v47);
  v48 = (const void *)*((_QWORD *)this + 106);
  *((_QWORD *)this + 106) = 0;
  if (v48)
    CFRelease(v48);
  v49 = (const void *)*((_QWORD *)this + 105);
  *((_QWORD *)this + 105) = 0;
  if (v49)
    CFRelease(v49);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 808);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 792);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 776);
  v50 = (const void *)*((_QWORD *)this + 89);
  *((_QWORD *)this + 89) = 0;
  if (v50)
    CFRelease(v50);
  v51 = (const void *)*((_QWORD *)this + 88);
  *((_QWORD *)this + 88) = 0;
  if (v51)
    CFRelease(v51);
  std::deque<SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::~deque[abi:nn180100]((uint64_t)this + 640);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 624);
  v52 = (const void *)*((_QWORD *)this + 76);
  *((_QWORD *)this + 76) = 0;
  if (v52)
    CFRelease(v52);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 592);
  v53 = (const void *)*((_QWORD *)this + 42);
  *((_QWORD *)this + 42) = 0;
  if (v53)
    CFRelease(v53);
  v54 = (const void *)*((_QWORD *)this + 39);
  *((_QWORD *)this + 39) = 0;
  if (v54)
    CFRelease(v54);
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(v2);
  URLProtocol::~URLProtocol((URLProtocol *)this);
}

void sub_183F80D00(_Unwind_Exception *exception_object)
{
  uint64_t *v1;
  uint64_t *v2;
  const void *v4;
  uint64_t *v5;
  const void *v6;
  const void *v7;
  uint64_t v8;

  v2 = v1;
  v4 = (const void *)v2[3];
  v5 = v2;
  v2[3] = 0;
  if (v4)
    CFRelease(v4);
  v6 = (const void *)v5[2];
  v5[2] = 0;
  if (v6)
    CFRelease(v6);
  v7 = (const void *)v5[1];
  v5[1] = 0;
  if (v7)
    CFRelease(v7);
  v8 = *v5;
  *v5 = 0;
  if (v8)
    CFRelease((CFTypeRef)(v8 - 16));
  _Unwind_Resume(exception_object);
}

void NSXCredentialStorage::~NSXCredentialStorage(NSXCredentialStorage *this)
{
  const void *v2;

  *(_QWORD *)this = off_1E14EB958;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

{
  const void *v1;

  *(_QWORD *)this = off_1E14EB958;
  v1 = (const void *)*((_QWORD *)this + 3);
  if (v1)
    CFRelease(v1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke(_QWORD *a1, int a2, NSObject *a3)
{
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  int v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  NSObject *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  void *v32;
  int v33;
  int v34;
  NSObject *v35;
  const char *description;
  NSObject *v37;
  int v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  CFIndex v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  const char *v47;
  NSObject *v48;
  const char *hostname;
  uint64_t v50;
  uint64_t v51;
  const void *Value;
  const void *v53;
  CFTypeID v54;
  const __CFAllocator *v55;
  CFStringRef v56;
  CFTypeRef v57;
  uint64_t v58;
  const __CFDictionary *v59;
  uint64_t i;
  const void *v61;
  IOReturn v62;
  NSObject *v63;
  uint64_t v64;
  NSObject *v65;
  uint64_t v66;
  uint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *p_shared_weak_owners;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t *v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  std::__shared_weak_count *v77;
  IOPMAssertionID AssertionID;
  int v79;
  int valuePtr;
  _BYTE buf[24];
  CFNumberRef v82;
  uint64_t v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  uint8_t v86[4];
  uint64_t v87;
  __int16 v88;
  IOPMAssertionID v89;
  uint64_t v90;
  CFStreamError v91;

  v90 = *MEMORY[0x1E0C80C00];
  v76 = 0;
  v77 = 0;
  v6 = (std::__shared_weak_count *)a1[6];
  if (v6 && (v77 = std::__shared_weak_count::lock(v6)) != 0)
  {
    v7 = a1[5];
    v76 = v7;
  }
  else
  {
    v7 = 0;
  }
  if (a2 == 5)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(a1[4] + 8) + 48, (__int128 *)buf);
    v8 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v9 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    if (v76)
    {
      v11 = *(_WORD *)(v76 + 248) & 0xFF9F | (*(unsigned __int8 *)(v76 + 250) << 16);
      *(_WORD *)(v76 + 248) = *(_WORD *)(v76 + 248) & 0xFF9F | 0x40;
      *(_BYTE *)(v76 + 250) = BYTE2(v11);
      v12 = *(_DWORD *)(v76 + 136);
      if (v12 == 7)
      {
LABEL_15:
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v13 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          v14 = *(_QWORD *)(v76 + 288);
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v14;
          _os_log_impl(&dword_183ECA000, v13, OS_LOG_TYPE_DEFAULT, "Connection %llu: done", buf, 0xCu);
        }
        goto LABEL_22;
      }
      if (v12 <= 6)
      {
        *(_DWORD *)(v76 + 136) = 6;
        goto LABEL_15;
      }
LABEL_130:
      __assert_rtn("_changeState", "TransportConnection.cpp", 288, "newState >= _state");
    }
  }
  else
  {
    if (!v7)
      goto LABEL_22;
    v15 = *(unsigned __int16 *)(v7 + 248);
    v16 = v15 | (*(unsigned __int8 *)(v7 + 250) << 16);
    if ((v15 & 0x60) != 0)
      goto LABEL_22;
    v17 = *(_DWORD *)(v7 + 136);
    if ((v17 - 5) < 2)
      goto LABEL_22;
    switch(a2)
    {
      case 1:
        if ((v16 & 0x20000) == 0)
        {
          NWIOConnection::_connectionAttemptTimerCancel((NWIOConnection *)v7);
          if (*(int *)(v7 + 136) > 2)
          {
            v43 = NWIOConnection::_convertError(v7, a3);
            v45 = v44;
            v91.domain = v43;
            *(_QWORD *)&v91.error = v45;
            NWIOConnection::_handleError((NWIOConnection *)v7, v91);
          }
          else
          {
            v38 = NWIOConnection::_captureEstablishmentFailureReason((NWIOConnection *)v7);
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v39 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
            {
              v40 = *(_QWORD *)(v7 + 288);
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = v40;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v38;
              _os_log_impl(&dword_183ECA000, v39, OS_LOG_TYPE_DEFAULT, "Connection %llu: is waiting to connect, reason %d", buf, 0x12u);
            }
            v41 = *(_QWORD *)(v7 + 144);
            if (v41)
              (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v41 + 72))(v41, 10000);
            v42 = *(_QWORD *)(v7 + 616);
            if (v42)
              (*(void (**)(uint64_t, _QWORD, uint64_t))(v42 + 16))(v42, 0, 10000);
          }
        }
        break;
      case 4:
        if (!a3 || (v16 & 0x20000) == 0 || nw_error_get_error_code(a3) != 89)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v37 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            v58 = *(_QWORD *)(v7 + 288);
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = v58;
            _os_log_error_impl(&dword_183ECA000, v37, OS_LOG_TYPE_ERROR, "Connection %llu: received failure notification", buf, 0xCu);
          }
          NWIOConnection::_handleEvent_Disconnected(v7, a3);
        }
        break;
      case 3:
        if (v17 > 2)
        {
          if ((v16 & 0x1800) == 0x800)
          {
            NWIOConnection::_tlsProcessHandshakeComplete((NWIOConnection *)v7);
            v17 = *(_DWORD *)(v7 + 136);
          }
          if (v17 <= 3)
            NWIOConnection::_completeEndpointSetup((NWIOConnection *)v7);
        }
        else
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v20 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v21 = *(_QWORD *)(v7 + 288);
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = v21;
            _os_log_impl(&dword_183ECA000, v20, OS_LOG_TYPE_DEFAULT, "Connection %llu: connected successfully", buf, 0xCu);
          }
          v22 = *(_DWORD *)(v7 + 136);
          if (v22 != 7)
          {
            if (v22 >= 4)
              goto LABEL_130;
            *(_DWORD *)(v7 + 136) = 3;
          }
          if (nw_settings_get_signposts_enabled())
            kdebug_trace();
          v23 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_90, 2);
          v24 = v23;
          if (v23
            && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v23 + 16))(v23, "Connection Ready", 0))
          {
            NWIOConnection::_toDiagnosticLog((NSObject **)v7, v24);
            (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
          }
          v25 = nw_connection_copy_connected_path();
          v26 = *(void **)(v7 + 336);
          *(_QWORD *)(v7 + 336) = v25;
          if (v26)
            nw_release(v26);
          v27 = nw_connection_copy_connected_local_endpoint();
          v28 = *(void **)(v7 + 344);
          *(_QWORD *)(v7 + 344) = v27;
          if (v28)
            nw_release(v28);
          v29 = nw_connection_copy_connected_remote_endpoint();
          v30 = *(void **)(v7 + 352);
          *(_QWORD *)(v7 + 352) = v29;
          if (v30)
            nw_release(v30);
          if (*(_QWORD *)(v7 + 336))
          {
            v31 = nw_path_copy_parameters();
            v32 = *(void **)(v7 + 328);
            *(_QWORD *)(v7 + 328) = v31;
            if (v32)
              nw_release(v32);
          }
          if (*(_QWORD *)(v7 + 392))
          {
            v33 = *(unsigned __int16 *)(v7 + 248);
            v34 = v33 | (*(unsigned __int8 *)(v7 + 250) << 16);
            if ((v33 & 4) == 0)
            {
              *(_BYTE *)(v7 + 250) = BYTE2(v34);
              *(_WORD *)(v7 + 248) = v34 | 4;
              v35 = *(NSObject **)(v7 + 344);
              if (v35 && nw_endpoint_get_type(v35) == nw_endpoint_type_address)
                description = (const char *)nw_endpoint_get_description();
              else
                description = "";
              v46 = *(NSObject **)(v7 + 352);
              if (v46 && nw_endpoint_get_type(v46) == nw_endpoint_type_address)
                v47 = (const char *)nw_endpoint_get_description();
              else
                v47 = "";
              v48 = *(NSObject **)(v7 + 304);
              if (v48 && nw_endpoint_get_type(v48) == nw_endpoint_type_host)
                hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(v7 + 304));
              else
                hostname = "";
              v50 = *(_QWORD *)(v7 + 392);
              v51 = *(_QWORD *)(v7 + 288);
              *(_DWORD *)(v50 + 8) = v51;
              snprintf((char *)(v50 + 12), 0x100uLL, "{ fd: %d, local %s => peer %s %s}", v51, description, v47, hostname);
            }
          }
          NWIOConnection::_kickTimerCancel((NWIOConnection *)v7);
          NWIOConnection::_watchdogTouch((NWIOConnection *)v7, 0);
          NWIOConnection::_connectionAttemptTimerCancel((NWIOConnection *)v7);
          NWIOConnection::_conditionalSchedulingSIMCancel((NWIOConnection *)v7);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v7 + 368), &unk_1EDCF9530);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v7 + 368), &unk_1EDCF95D8);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v7 + 368), &unk_1EDCF9568);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v7 + 368), &unk_1EDCF94F8);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v7 + 368), &unk_1EDCF95A0);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v7 + 368), &unk_1EDCF9610);
          Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_1EDCF9C30);
          v53 = Value;
          if (Value)
          {
            v54 = CFGetTypeID(Value);
            if (v54 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
            }
            if ((const void *)*MEMORY[0x1E0C9AE50] == v53)
            {
              v55 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              v56 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("NWIOConnection %p"), v7);
              v79 = 60;
              valuePtr = 255;
              *(_QWORD *)buf = CFRetain(CFSTR("PreventUserIdleSystemSleep"));
              *(_QWORD *)&buf[8] = CFNumberCreate(v55, kCFNumberIntType, &valuePtr);
              if (v56)
                v57 = CFRetain(v56);
              else
                v57 = 0;
              *(_QWORD *)&buf[16] = v57;
              v82 = CFNumberCreate(v55, kCFNumberIntType, &v79);
              v83 = (uint64_t)CFRetain(CFSTR("TimeoutActionTurnOff"));
              v59 = CFDictionaryCreate(v55, (const void **)NWIOConnection::_powerAssertionTake(unsigned int *,__CFString const*,__CFString const*)::keys, (const void **)buf, 5, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              for (i = 0; i != 40; i += 8)
              {
                v61 = *(const void **)&buf[i];
                if (v61)
                  CFRelease(v61);
              }
              AssertionID = 0;
              v62 = IOPMAssertionCreateWithProperties(v59, &AssertionID);
              if (v62)
              {
                if (CFNLog::onceToken != -1)
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
                v63 = CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                {
                  v64 = *(_QWORD *)(v7 + 288);
                  *(_DWORD *)v86 = 134218240;
                  v87 = v64;
                  v88 = 1024;
                  v89 = v62;
                  _os_log_error_impl(&dword_183ECA000, v63, OS_LOG_TYPE_ERROR, "Connection %llu: failed to take assertion, result(%d)", v86, 0x12u);
                }
              }
              else
              {
                if (CFNLog::onceToken != -1)
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
                v65 = CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
                {
                  v75 = *(_QWORD *)(v7 + 288);
                  *(_DWORD *)v86 = 134218240;
                  v87 = v75;
                  v88 = 1024;
                  v89 = AssertionID;
                  _os_log_debug_impl(&dword_183ECA000, v65, OS_LOG_TYPE_DEBUG, "Connection %llu: sucessfully took assertion(%d)", v86, 0x12u);
                }
                *(_DWORD *)(v7 + 576) = AssertionID;
              }
              if (v59)
                CFRelease(v59);
              if (v56)
                CFRelease(v56);
            }
          }
          v66 = *(_QWORD *)(v7 + 400);
          if (v66)
            *(_BYTE *)(v66 + 40) = 1;
          *(_WORD *)(v7 + 248) |= 8u;
          v67 = *(_QWORD *)(v7 + 256);
          v68 = *(std::__shared_weak_count **)(v7 + 264);
          if (v68)
          {
            p_shared_weak_owners = (unint64_t *)&v68->__shared_weak_owners_;
            do
              v70 = __ldxr(p_shared_weak_owners);
            while (__stxr(v70 + 1, p_shared_weak_owners));
          }
          v71 = *(_QWORD *)(v7 + 144);
          if (!v71)
            __assert_rtn("_handleEvent_ReadyFinish", "NWIOConnection.cpp", 2658, "_establishmentDelegate");
          v72 = *(_QWORD *)(v7 + 328);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3321888768;
          *(_QWORD *)&buf[16] = ___ZN14NWIOConnection24_handleEvent_ReadyFinishEv_block_invoke;
          v82 = (CFNumberRef)&__block_descriptor_56_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
          v83 = v7;
          v84 = v67;
          v85 = v68;
          if (v68)
          {
            v73 = (unint64_t *)&v68->__shared_weak_owners_;
            do
              v74 = __ldxr(v73);
            while (__stxr(v74 + 1, v73));
          }
          (*(void (**)(uint64_t, _QWORD, uint64_t, _BYTE *))(*(_QWORD *)v71 + 24))(v71, 0, v72, buf);
          if (v85)
            std::__shared_weak_count::__release_weak(v85);
          if (v68)
            std::__shared_weak_count::__release_weak(v68);
        }
        break;
      default:
        break;
    }
  }
LABEL_22:
  if (v77)
  {
    p_shared_owners = (unint64_t *)&v77->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
      std::__shared_weak_count::__release_weak(v77);
    }
  }
}

void sub_183F81960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23)
{
  const void *v23;
  const void *v24;

  if (v24)
    CFRelease(v24);
  if (v23)
    CFRelease(v23);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'Tube::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  Tube::postConnectConfiguration(a1 - 40, a2, a3, a4);
}

{
  Tube::postConnectConfiguration(a1 - 32, a2, a3, a4);
}

void NWIOConnection::_cleanupConnection(CFMutableDictionaryRef *this, char a2)
{
  NSObject *v4;
  NSObject *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  int v9;
  int v10;
  NSObject *v11;
  CFMutableDictionaryRef v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  const char *v19;
  id v20;
  int v21;
  NSObject *v22;
  uint64_t v23;
  unsigned int v24;
  NSObject *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  int v31;
  CFMutableDictionaryRef v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  CFMutableDictionaryRef v45;
  double v46;
  int v47;
  NSObject *v48;
  _BOOL4 v49;
  double v50;
  CFMutableDictionaryRef v51;
  CFMutableDictionaryRef v52;
  const char *v53;
  CFMutableDictionaryRef v54;
  CFMutableDictionaryRef v55;
  CFMutableDictionaryRef v56;
  double Helper_x8__OBJC_CLASS____DASScheduler;
  uint64_t v58;
  void *v59;
  CFMutableDictionaryRef v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  nw_connection_t connection[2];
  __int128 v65;
  _BYTE buf[22];
  __int16 v67;
  int v68;
  __int16 v69;
  int v70;
  __int16 v71;
  int v72;
  __int16 v73;
  _BOOL4 v74;
  __int16 v75;
  unsigned int v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  NWIOConnection::_kickTimerCancel((NWIOConnection *)this);
  v4 = this[70];
  if (v4)
  {
    dispatch_source_cancel(v4);
    v5 = this[70];
    this[70] = 0;
    if (v5)
      dispatch_release(v5);
  }
  NWIOConnection::_connectionAttemptTimerCancel((NWIOConnection *)this);
  NWIOConnection::_conditionalSchedulingSIMCancel((NWIOConnection *)this);
  if ((*((_DWORD *)this + 34) - 6) >= 0xFFFFFFFD)
  {
    v6 = (const void *)(*((uint64_t (**)(CFMutableDictionaryRef *, uint64_t))*this + 27))(this, 0x1EDCFAD40);
    if (v6)
      CFDictionarySetValue(this[46], &unk_1EDCFAD40, v6);
    v7 = (const void *)(*((uint64_t (**)(CFMutableDictionaryRef *, void *))*this + 27))(this, &unk_1EDCFB948);
    if (v7)
      CFRelease(v7);
    v8 = (const void *)(*((uint64_t (**)(CFMutableDictionaryRef *, uint64_t))*this + 27))(this, 0x1EDCFB8A0);
    if (v8)
    {
      CFDictionarySetValue(this[46], &unk_1EDCFB8A0, v8);
      CFRelease(v8);
    }
    if (v6)
      CFRelease(v6);
  }
  if (this[34])
  {
    v9 = *((unsigned __int16 *)this + 124);
    v10 = v9 | (*((unsigned __int8 *)this + 250) << 16);
    if ((v9 & 0x20) == 0)
    {
      *((_BYTE *)this + 250) = BYTE2(v10);
      *((_WORD *)this + 124) = v10 | 0x20;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v11 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v12 = this[36];
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v12;
        _os_log_impl(&dword_183ECA000, v11, OS_LOG_TYPE_DEFAULT, "Connection %llu: cleaning up", buf, 0xCu);
      }
      v13 = (uint64_t)this[25];
      if (v13)
      {
        *(CFAbsoluteTime *)(v13 + 112) = CFAbsoluteTimeGetCurrent();
        os_unfair_lock_lock((os_unfair_lock_t)(v13 + 8));
        if (*(_BYTE *)(v13 + 12))
        {
          -[__CFN_ConnectionMetrics _tcpInfo](v13);
          v14 = objc_claimAutoreleasedReturnValue();
          v15 = *(void **)(v13 + 48);
          *(_QWORD *)(v13 + 48) = v14;

        }
        if (*(_BYTE *)(v13 + 13))
        {
          -[__CFN_ConnectionMetrics _subflowCounts](v13);
          v16 = objc_claimAutoreleasedReturnValue();
          v17 = *(void **)(v13 + 56);
          *(_QWORD *)(v13 + 56) = v16;

        }
        v18 = *(void **)(v13 + 40);
        *(_QWORD *)(v13 + 40) = 0;

        os_unfair_lock_unlock((os_unfair_lock_t)(v13 + 8));
        if (!*(_BYTE *)(v13 + 23) && !*(_BYTE *)(v13 + 24))
        {
          v20 = objc_getProperty((id)v13, v19, 160, 1);
          *(_OWORD *)connection = 0u;
          v65 = 0u;
          connectionTimingFromMetrics((__CFN_ConnectionMetrics *)connection, (void *)v13);
          v21 = *(_DWORD *)(v13 + 32);
          summaryLog();
          v22 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            v23 = *(_QWORD *)(v13 + 72);
            v24 = ((*(double *)(v13 + 112) - *(double *)(v13 + 96)) * 1000.0);
            *(_DWORD *)buf = 134219522;
            *(_QWORD *)&buf[4] = v23;
            *(_WORD *)&buf[12] = 2114;
            *(_QWORD *)&buf[14] = v20;
            v67 = 1024;
            v68 = v65;
            v69 = 1024;
            v70 = DWORD1(v65);
            v71 = 1024;
            v72 = DWORD2(v65);
            v73 = 1024;
            v74 = v21 == 2;
            v75 = 1024;
            v76 = v24;
            _os_log_impl(&dword_183ECA000, v22, OS_LOG_TYPE_DEFAULT, "Connection %llu: summary for unused connection {protocol=\"%{public}@\", domain_lookup_duration_ms=%u, connect_duration_ms=%u, secure_connection_duration_ms=%u, private_relay=%{BOOL}d, idle_duration_ms=%u}", buf, 0x34u);
          }

        }
      }
      v25 = this[35];
      connection[0] = (nw_connection_t)this[34];
      connection[1] = v25;
      if (v25)
      {
        v26 = (unint64_t *)&v25[1];
        do
          v27 = __ldxr(v26);
        while (__stxr(v27 + 1, v26));
      }
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(this + 34), (__int128 *)buf);
      v28 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v29 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
      v31 = *((_DWORD *)this + 34);
      if (v31 != 7)
      {
        if (v31 >= 6)
          __assert_rtn("_changeState", "TransportConnection.cpp", 288, "newState >= _state");
        *((_DWORD *)this + 34) = 5;
      }
      v32 = this[50];
      if (v32)
      {
        v33 = (uint64_t *)*((_QWORD *)v32 + 6);
        v34 = (uint64_t *)v33[1];
        if (*((_BYTE *)v32 + 41))
          v34 = (uint64_t *)v34[1];
        if (v34 != v33)
        {
          do
          {
            v35 = v34[2];
            if (v35)
            {
              v36 = *(_QWORD *)(v35 + 64);
              if (v36)
              {
                (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(v36 + 16))(v36, 0, 1, 89);
                _Block_release(*(const void **)(v35 + 64));
                *(_QWORD *)(v35 + 64) = 0;
              }
            }
            else
            {
              v37 = v34[4];
              if (v37)
              {
                v38 = *(_QWORD *)(v37 + 64);
                if (v38)
                {
                  *(_QWORD *)buf = 0;
                  *(_QWORD *)&buf[8] = 0;
                  (*(void (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(v38 + 16))(v38, buf, 1, 89);
                  v39 = *(std::__shared_weak_count **)&buf[8];
                  if (*(_QWORD *)&buf[8])
                  {
                    v40 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
                    do
                      v41 = __ldaxr(v40);
                    while (__stlxr(v41 - 1, v40));
                    if (!v41)
                    {
                      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
                      std::__shared_weak_count::__release_weak(v39);
                    }
                  }
                  _Block_release(*(const void **)(v37 + 64));
                  *(_QWORD *)(v37 + 64) = 0;
                }
              }
            }
            v42 = *((_QWORD *)v32 + 6);
            v43 = *v34;
            v44 = (uint64_t *)v34[1];
            *(_QWORD *)(v43 + 8) = v44;
            *(_QWORD *)v34[1] = v43;
            --*(_QWORD *)(v42 + 16);
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v34 + 4));
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v34 + 2));
            operator delete(v34);
            v34 = v44;
          }
          while (*((uint64_t **)v32 + 6) != v44);
        }
      }
      if ((a2 & 1) != 0)
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          v45 = this[25];
          if (v45)
            v45 = (CFMutableDictionaryRef)*((_QWORD *)v45 + 9);
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v45;
          _os_log_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "nw_connection_force_cancel connection=%llu", buf, 0xCu);
        }
        nw_connection_force_cancel(connection[0]);
      }
      else
      {
        nw_connection_cancel(connection[0]);
      }
      if (!CFDictionaryGetValue(this[46], &unk_1EDCFB868))
        goto LABEL_80;
      gotLoadHelper_x8__OBJC_CLASS____DASActivity(v46);
      if (objc_opt_class())
      {
        if (this[73])
        {
          v47 = *((unsigned __int8 *)this + 592);
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v48 = CFNLog::logger;
          v49 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
          if (v47)
          {
            if (!v49)
              goto LABEL_75;
            v51 = this[36];
            v52 = this[73];
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = v51;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v52;
            v53 = "Connection %llu: activity(%p) will be completed";
          }
          else
          {
            if (!v49)
              goto LABEL_75;
            v54 = this[36];
            v55 = this[73];
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = v54;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v55;
            v53 = "Connection %llu: activity(%p) will be canceled";
          }
          _os_log_impl(&dword_183ECA000, v48, OS_LOG_TYPE_DEFAULT, v53, buf, 0x16u);
LABEL_75:
          v56 = this[73];
          Helper_x8__OBJC_CLASS____DASScheduler = gotLoadHelper_x8__OBJC_CLASS____DASScheduler(v50);
          v59 = (void *)objc_msgSend(*(id *)(v58 + 2352), "sharedScheduler", Helper_x8__OBJC_CLASS____DASScheduler);
          if (v47)
            objc_msgSend(v59, "activityCompleted:", v56);
          else
            objc_msgSend(v59, "activityCanceled:", v56);
          v60 = this[73];
          this[73] = 0;
          if (v60)
            CFRelease(v60);
        }
      }
      else
      {
        NWIOConnection::_conditionalSchedulingSIMCancel((NWIOConnection *)this);
      }
LABEL_80:
      v61 = (std::__shared_weak_count *)connection[1];
      if (connection[1])
      {
        v62 = (unint64_t *)&connection[1][1];
        do
          v63 = __ldaxr(v62);
        while (__stlxr(v63 - 1, v62));
        if (!v63)
        {
          ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
          std::__shared_weak_count::__release_weak(v61);
        }
      }
    }
  }
}

void sub_183F820E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void NWIOConnection::_conditionalSchedulingSIMCancel(NWIOConnection *this)
{
  ConditionalConnectionSIMScheduler *v2;
  char *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  v2 = (ConditionalConnectionSIMScheduler *)*((_QWORD *)this + 75);
  if (v2)
  {
    v3 = (char *)this + 600;
    ConditionalConnectionSIMScheduler::cancel(v2);
    v7 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v7);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
    if (*((_QWORD *)&v7 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void NWIOConnection::_connectionAttemptTimerCancel(NWIOConnection *this)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *((_QWORD *)this + 71);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = *((_QWORD *)this + 71);
    *((_QWORD *)this + 71) = 0;
    if (v3)
      dispatch_release(v3);
  }
}

void NWIOConnection::_kickTimerCancel(NWIOConnection *this)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *((_QWORD *)this + 68);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = *((_QWORD *)this + 68);
    *((_QWORD *)this + 68) = 0;
    if (v3)
      dispatch_release(v3);
  }
}

void NWIOConnection::_handleEvent_Disconnected(uint64_t a1, NSObject *a2)
{
  int v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  CFIndex v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE buf[22];
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;
  CFStreamError v27;
  CFStreamError v28;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = *(_DWORD *)(a1 + 136);
  if (v3 == 4)
  {
    if ((*(_WORD *)(a1 + 248) & 0x10) != 0)
    {
      v4 = *(_QWORD *)(a1 + 160);
      if (v4)
      {
        v5 = *(std::__shared_weak_count **)(a1 + 168);
        *(_QWORD *)buf = v4;
        *(_QWORD *)&buf[8] = v5;
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldxr(p_shared_owners);
          while (__stxr(v7 + 1, p_shared_owners));
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 32))(v4);
        if (v5)
        {
          v8 = (unint64_t *)&v5->__shared_owners_;
          do
            v9 = __ldaxr(v8);
          while (__stlxr(v9 - 1, v8));
          if (!v9)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        return;
      }
    }
LABEL_22:
    v17 = NWIOConnection::_convertError(a1, a2);
    v19 = v18;
    v28.domain = v17;
    *(_QWORD *)&v28.error = v19;
    NWIOConnection::_handleError((NWIOConnection *)a1, v28);
    return;
  }
  if (v3 > 2)
    goto LABEL_22;
  v10 = NWIOConnection::_convertError(a1, a2);
  v12 = v11;
  v13 = NWIOConnection::_captureEstablishmentFailureReason((NWIOConnection *)a1);
  v14 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_97, 2);
  if (v14)
  {
    v15 = v14;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v14 + 16))(v14, "Connection Failed", 0))
    {
      NWIOConnection::_toDiagnosticLog((NSObject **)a1, v15);
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v15 + 72))(v15, "Error", CFSTR("%s"));
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
    }
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v16 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v20 = *(_QWORD *)(a1 + 288);
    *(_DWORD *)buf = 134218752;
    *(_QWORD *)&buf[4] = v20;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v10;
    v22 = 1024;
    v23 = v12;
    v24 = 1024;
    v25 = v13;
    _os_log_error_impl(&dword_183ECA000, v16, OS_LOG_TYPE_ERROR, "Connection %llu: failed to connect %ld:%d, reason %d", buf, 0x22u);
  }
  v27.domain = v10;
  *(_QWORD *)&v27.error = v12;
  NWIOConnection::_handleError((NWIOConnection *)a1, v27);
}

void sub_183F82504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::_captureEstablishmentFailureReason(NWIOConnection *this)
{
  uint64_t v2;
  NSObject *v3;
  nw_path_t v4;
  int reason;
  const void *Value;
  const void *v7;
  CFTypeID v8;
  int v9;
  _BOOL4 v10;
  int privacy_stance;
  int v12;
  void *v13;
  CFNumberRef v14;
  unsigned int valuePtr;
  uint8_t buf[16];

  v2 = 0xFFFFFFFFLL;
  valuePtr = -1;
  v3 = *((_QWORD *)this + 34);
  if (!v3)
    return v2;
  v4 = nw_connection_copy_current_path(v3);
  if (!v4)
    goto LABEL_11;
  reason = nw_path_get_reason();
  if (reason > 25)
  {
    if (reason != 26)
    {
      v9 = 0;
      v10 = reason == 30;
      goto LABEL_17;
    }
    v10 = 0;
    valuePtr = 2;
  }
  else
  {
    if (reason == 5)
    {
      v10 = 0;
      v9 = 1;
      valuePtr = 1;
      goto LABEL_17;
    }
    if (reason != 6)
      goto LABEL_11;
    Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFBC58);
    v7 = Value;
    if (!Value)
      goto LABEL_11;
    v8 = CFGetTypeID(Value);
    if (v8 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
    }
    if ((const void *)*MEMORY[0x1E0C9AE50] != v7)
    {
LABEL_11:
      v9 = 0;
      v10 = 0;
      goto LABEL_17;
    }
    v10 = 0;
    valuePtr = 0;
  }
  v9 = 1;
LABEL_17:
  privacy_stance = nw_connection_get_privacy_stance();
  v12 = nw_connection_failed_due_to_blocked_tracker();
  v13 = (void *)nw_connection_copy_failed_resolution_report();
  if (v9)
  {
    v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCF9530, v14);
    if (v14)
      CFRelease(v14);
  }
  if (privacy_stance == 3)
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCF95D8, (const void *)*MEMORY[0x1E0C9AE50]);
  if (v4)
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCF9568, v4);
  if (v12)
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCF94F8, (const void *)*MEMORY[0x1E0C9AE50]);
  if (v13)
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCF95A0, v13);
  if (v10)
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_1EDCF9610, (const void *)*MEMORY[0x1E0C9AE50]);
  v2 = valuePtr;
  if (v13)
    nw_release(v13);
  if (v4)
    nw_release(v4);
  return v2;
}

void sub_183F827B0(_Unwind_Exception *exception_object)
{
  void *v1;
  void *v2;
  const void *v3;

  if (v3)
  {
    CFRelease(v3);
    if (!v2)
    {
LABEL_3:
      if (!v1)
LABEL_8:
        _Unwind_Resume(exception_object);
LABEL_7:
      nw_release(v1);
      goto LABEL_8;
    }
  }
  else if (!v2)
  {
    goto LABEL_3;
  }
  nw_release(v2);
  if (!v1)
    goto LABEL_8;
  goto LABEL_7;
}

uint64_t NWIOConnection::_convertError(uint64_t a1, nw_error_t error)
{
  __CFError *v3;
  uint64_t v4;
  int v5;
  int v6;
  NSObject *v7;
  const __CFDictionary *Value;
  const __CFDictionary *v10;
  const void *v11;
  const __CFNumber *v12;
  double v14;
  double v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE v22[12];
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (error)
  {
    v3 = nw_error_copy_cf_error(error);
    v4 = _CFStreamErrorFromCFError(v3);
    v6 = v5;
    if (v3)
      CFRelease(v3);
  }
  else if (*(_QWORD *)(a1 + 272))
  {
    v6 = 0;
    v4 = 0;
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v21 = *(_QWORD *)(a1 + 288);
      *(_DWORD *)v22 = 134217984;
      *(_QWORD *)&v22[4] = v21;
      _os_log_debug_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEBUG, "Connection %llu: generating ENOTCONN, since in an error state with no error and no connection", v22, 0xCu);
    }
    v4 = 1;
    v6 = 57;
  }
  if (*(int *)(a1 + 136) <= 2 && v4 == 1 && v6 == 57)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFB868);
    v10 = Value;
    if (Value)
    {
      v11 = CFDictionaryGetValue(Value, CFSTR("kConditionalConnectionRequirementTimeWindowStartTime"));
      v12 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("kConditionalConnectionRequirementTimeWindowDuration"));
      if (v11 && v12 != 0)
      {
        *(_QWORD *)v22 = 0;
        if (CFNumberGetValue(v12, kCFNumberDoubleType, v22))
        {
          v14 = MEMORY[0x186DB5F80](v11);
          v15 = *(double *)v22;
          if (v14 + v15 <= CFAbsoluteTimeGetCurrent())
            v6 = 60;
        }
      }
    }
  }
  if (!v6)
  {
    if (*(int *)(a1 + 136) >= 3)
    {
      if ((*(_WORD *)(a1 + 248) & 0x1800) == 0x800)
      {
        v4 = (int)*MEMORY[0x1E0C9B298];
        v6 = -9806;
      }
      else
      {
        v4 = 1;
        v6 = 53;
      }
    }
    else
    {
      v4 = 1;
      v6 = 2;
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v16 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v19 = *(_QWORD *)(a1 + 288);
      *(_DWORD *)v22 = 134218496;
      *(_QWORD *)&v22[4] = v19;
      v23 = 2048;
      v24 = v4;
      v25 = 1024;
      v26 = v6;
      _os_log_error_impl(&dword_183ECA000, v16, OS_LOG_TYPE_ERROR, "Connection %llu: missing error, so heuristics synthesized error(%ld:%d)", v22, 0x1Cu);
    }
  }
  if (v4 == 1 && v6 == 54)
  {
    if ((*(_WORD *)(a1 + 248) & 0x1800) == 0x800)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v17 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v20 = *(_QWORD *)(a1 + 288);
        *(_DWORD *)v22 = 134217984;
        *(_QWORD *)&v22[4] = v20;
        _os_log_error_impl(&dword_183ECA000, v17, OS_LOG_TYPE_ERROR, "Connection %llu: received ECONNRESET with incomplete TLS handshake - generating errSSLClosedNoNotify", v22, 0xCu);
      }
      return (int)*MEMORY[0x1E0C9B298];
    }
    else
    {
      return 1;
    }
  }
  return v4;
}

void sub_183F82B80(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void NWIOConnection::_handleError(NWIOConnection *this, CFStreamError a2)
{
  uint64_t v2;
  CFIndex domain;
  NSObject *v5;
  int v6;
  uint64_t v7;
  uint8_t buf[4];
  uint64_t v9;
  __int16 v10;
  CFIndex v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*((int *)this + 34) > 5)
    return;
  v2 = *(_QWORD *)&a2.error;
  domain = a2.domain;
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v7 = *((_QWORD *)this + 36);
    *(_DWORD *)buf = 134218496;
    v9 = v7;
    v10 = 2048;
    v11 = domain;
    v12 = 1024;
    v13 = v2;
    _os_log_error_impl(&dword_183ECA000, v5, OS_LOG_TYPE_ERROR, "Connection %llu: encountered error(%ld:%d)", buf, 0x1Cu);
  }
  v6 = *((_DWORD *)this + 34);
  if (v6 == 7)
  {
    *((_QWORD *)this + 47) = domain;
    *((_QWORD *)this + 48) = v2;
LABEL_12:
    if ((*((_WORD *)this + 124) & 0x10) == 0)
    {
      NWIOConnection::_cleanupConnection((CFMutableDictionaryRef *)this, 0);
      goto LABEL_14;
    }
    NWIOConnection::_signalError(this);
    return;
  }
  if (v6 >= 8)
    __assert_rtn("_changeState", "TransportConnection.cpp", 288, "newState >= _state");
  *((_DWORD *)this + 34) = 7;
  *((_QWORD *)this + 47) = domain;
  *((_QWORD *)this + 48) = v2;
  if (v6 >= 4)
    goto LABEL_12;
  NWIOConnection::_cleanupConnection((CFMutableDictionaryRef *)this, 0);
  if (v6 >= 1)
LABEL_14:
    NWIOConnection::_signalEstablished(this);
}

void sub_183F82D7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t cf_nghttp2_before_frame_send_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  _QWORD *stream_user_data;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  NSObject *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  NSObject *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  uint64_t block;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  std::__shared_weak_count *v39;

  v4 = *(unsigned __int8 *)(a2 + 12);
  if (v4 == 3)
  {
    stream_user_data = (_QWORD *)nghttp2_session_get_stream_user_data();
    if (stream_user_data)
    {
      v11 = (_QWORD *)*stream_user_data;
      if (*stream_user_data)
      {
        v12 = (std::__shared_weak_count *)v11[36];
        if (v12)
        {
          v13 = std::__shared_weak_count::lock(v12);
          if (v13)
            v14 = v11[35];
          else
            v14 = 0;
        }
        else
        {
          v14 = 0;
          v13 = 0;
        }
        v17 = v11[9];
        block = MEMORY[0x1E0C809B0];
        v34 = 3321888768;
        v35 = ___ZN11HTTP2Stream16didSendRSTStreamEv_block_invoke;
        v36 = &__block_descriptor_48_e8_32c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
        v37 = v14;
        v38 = v13;
        if (v13)
        {
          p_shared_owners = (unint64_t *)&v13->__shared_owners_;
          do
            v19 = __ldxr(p_shared_owners);
          while (__stxr(v19 + 1, p_shared_owners));
        }
        dispatch_async(v17, &block);
        v20 = v38;
        if (v38)
        {
          v21 = (unint64_t *)&v38->__shared_owners_;
          do
            v22 = __ldaxr(v21);
          while (__stlxr(v22 - 1, v21));
          if (!v22)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
        if (v13)
        {
          v23 = (unint64_t *)&v13->__shared_owners_;
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
LABEL_43:
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
      }
    }
  }
  else if (v4 == 1)
  {
    v5 = (_QWORD *)nghttp2_session_get_stream_user_data();
    if (v5)
    {
      v6 = *v5;
      if (*v5)
      {
        v7 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v6 + 24))(*v5);
        v8 = *(_QWORD *)(a3 + 56);
        if (*(_DWORD *)v8 == 1)
          v9 = (void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v8 + 8) + 248))(*(_QWORD *)(v8 + 8));
        else
          v9 = 0;
        -[__CFN_TransactionMetrics requestBeginOnConnection:reusedAfterTime:](v7, v9, *(double *)(v6 + 440));
        v15 = *(std::__shared_weak_count **)(v6 + 288);
        if (v15)
        {
          v13 = std::__shared_weak_count::lock(v15);
          if (v13)
            v16 = *(std::__shared_weak_count **)(v6 + 280);
          else
            v16 = 0;
        }
        else
        {
          v16 = 0;
          v13 = 0;
        }
        v25 = *(NSObject **)(v6 + 72);
        block = MEMORY[0x1E0C809B0];
        v34 = 3321888768;
        v35 = ___ZN11HTTP2Stream14didSendHeadersEv_block_invoke;
        v36 = &__block_descriptor_56_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
        v37 = v6;
        v38 = v16;
        v39 = v13;
        if (v13)
        {
          v26 = (unint64_t *)&v13->__shared_owners_;
          do
            v27 = __ldxr(v26);
          while (__stxr(v27 + 1, v26));
        }
        dispatch_async(v25, &block);
        v28 = v39;
        if (v39)
        {
          v29 = (unint64_t *)&v39->__shared_owners_;
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
        if (v13)
        {
          v31 = (unint64_t *)&v13->__shared_owners_;
          do
            v24 = __ldaxr(v31);
          while (__stlxr(v24 - 1, v31));
          goto LABEL_43;
        }
      }
    }
  }
  return 0;
}

uint64_t cf_nghttp2_on_frame_send_callback(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  unint64_t v9;
  CFAbsoluteTime *v10;
  NSObject *v11;
  _QWORD *stream_user_data;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  std::string *v22;
  std::string::size_type size;
  std::string *v24;
  std::string::size_type v25;
  void **v26;
  std::string::size_type v27;
  std::string *v28;
  std::string::size_type v29;
  uint64_t v30;
  std::string::size_type v32;
  uint64_t v33;
  std::string v34;
  std::string __p;
  void *__dst[2];
  unsigned __int8 v37;
  std::string v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_6, 2);
  if (v5)
  {
    v6 = v5;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v5 + 16))(v5, "h2 frame", 0))
    {
      HTTP2Diagnostic::LOG_FRAME(v6, a2, 1, a3[9], 0);
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  v7 = *(unsigned __int8 *)(a2 + 12);
  if (v7 == 7)
  {
    v8 = *(_DWORD *)(a2 + 20);
    if (!v8)
      goto LABEL_15;
    HTTP2Connection::setErrorOnAllStreams((HTTP2Connection *)a3, v8);
    HTTP2Connection::closeConnection((HTTP2Connection *)a3, 1);
    v7 = *(unsigned __int8 *)(a2 + 12);
  }
  if (v7 == 6 && (*(_BYTE *)(a2 + 13) & 1) == 0)
  {
    v9 = *(_QWORD *)(a2 + 16);
    v10 = (CFAbsoluteTime *)std::__hash_table<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>>>::find<unsigned long long>(a3 + 84, v9);
    if (v10)
    {
      v10[3] = CFAbsoluteTimeGetCurrent();
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v11 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
      {
        v32 = a3[9];
        LODWORD(v38.__r_.__value_.__l.__data_) = 134218240;
        *(std::string::size_type *)((char *)v38.__r_.__value_.__r.__words + 4) = v9;
        WORD2(v38.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&v38.__r_.__value_.__r.__words[1] + 6) = v32;
        _os_log_fault_impl(&dword_183ECA000, v11, OS_LOG_TYPE_FAULT, "PING called with unknown seed (%llu) on connectionID = %llu", (uint8_t *)&v38, 0x16u);
      }
    }
  }
LABEL_15:
  stream_user_data = (_QWORD *)nghttp2_session_get_stream_user_data();
  if (stream_user_data)
  {
    v13 = *stream_user_data;
    if (*stream_user_data)
    {
      v14 = *(_QWORD *)a2 + 9;
      v15 = *(unsigned __int8 *)(a2 + 12);
      if (v15 == 1)
      {
        v16 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v13 + 24))(*stream_user_data);
        if (v16)
          *(_QWORD *)(v16 + 96) += v14;
        v17 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_7, 2);
        if (v17)
        {
          v18 = v17;
          if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v17 + 16))(v17, "h2 headers", 0))
          {
            v19 = a3[9];
            memset(&v38, 0, sizeof(v38));
            if (*(_QWORD *)(a2 + 48))
            {
              v33 = v14;
              v20 = 0;
              v21 = 0;
              do
              {
                std::string::basic_string[abi:nn180100](__dst, *(void **)(*(_QWORD *)(a2 + 40) + v20), *(_QWORD *)(*(_QWORD *)(a2 + 40) + v20 + 16));
                std::string::basic_string[abi:nn180100](&__p, *(void **)(*(_QWORD *)(a2 + 40) + v20 + 8), *(_QWORD *)(*(_QWORD *)(a2 + 40) + v20 + 24));
                std::string::append(&v38, "[");
                std::to_string(&v34, v19);
                if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v22 = &v34;
                else
                  v22 = (std::string *)v34.__r_.__value_.__r.__words[0];
                if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  size = HIBYTE(v34.__r_.__value_.__r.__words[2]);
                else
                  size = v34.__r_.__value_.__l.__size_;
                std::string::append(&v38, (const std::string::value_type *)v22, size);
                if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v34.__r_.__value_.__l.__data_);
                std::string::append(&v38, "] sent (stream_id=");
                std::to_string(&v34, *(_DWORD *)(a2 + 8));
                if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v24 = &v34;
                else
                  v24 = (std::string *)v34.__r_.__value_.__r.__words[0];
                if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v25 = HIBYTE(v34.__r_.__value_.__r.__words[2]);
                else
                  v25 = v34.__r_.__value_.__l.__size_;
                std::string::append(&v38, (const std::string::value_type *)v24, v25);
                if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v34.__r_.__value_.__l.__data_);
                std::string::append(&v38, ") ");
                if ((v37 & 0x80u) == 0)
                  v26 = __dst;
                else
                  v26 = (void **)__dst[0];
                if ((v37 & 0x80u) == 0)
                  v27 = v37;
                else
                  v27 = (std::string::size_type)__dst[1];
                std::string::append(&v38, (const std::string::value_type *)v26, v27);
                std::string::append(&v38, ": ");
                if (__CFNCanLogSensitiveContent::onceToken != -1)
                  dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4798);
                if (__CFNCanLogSensitiveContent::ok)
                {
                  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                    std::string::__init_copy_ctor_external(&v34, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
                  else
                    v34 = __p;
                }
                else
                {
                  std::string::basic_string[abi:nn180100]<0>(&v34, "<redacted>");
                }
                if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v28 = &v34;
                else
                  v28 = (std::string *)v34.__r_.__value_.__r.__words[0];
                if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v29 = HIBYTE(v34.__r_.__value_.__r.__words[2]);
                else
                  v29 = v34.__r_.__value_.__l.__size_;
                std::string::append(&v38, (const std::string::value_type *)v28, v29);
                if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v34.__r_.__value_.__l.__data_);
                std::string::append(&v38, "\n");
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p.__r_.__value_.__l.__data_);
                if ((char)v37 < 0)
                  operator delete(__dst[0]);
                ++v21;
                v20 += 40;
              }
              while (*(_QWORD *)(a2 + 48) > v21);
              v14 = v33;
            }
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v18 + 72))(v18, "h2 hdrs", CFSTR("%s"));
            if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v38.__r_.__value_.__l.__data_);
            (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
          }
        }
        v15 = *(unsigned __int8 *)(a2 + 12);
      }
      if (!v15)
      {
        v30 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13);
        if (v30)
          *(_QWORD *)(v30 + 112) += v14;
      }
    }
  }
  return 0;
}

void sub_183F83538(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t cf_nghttp2_on_frame_recv_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE **stream_user_data;
  _BYTE *v8;
  uint64_t v9;
  char v10;
  int v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  double v23;
  void (**v24)(_QWORD, _QWORD, double);
  CFAbsoluteTime Current;
  int8x8_t v26;
  unint64_t v27;
  uint8x8_t v28;
  int v29;
  NSObject *v30;
  uint64_t v31;
  HTTP2Stream **v32;
  HTTP2Stream *v33;
  HTTP2Connection *v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  BOOL v40;
  int v41;
  int *v42;
  int v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  int v54;
  int v55;
  uint64_t v56;
  NSObject *v57;
  NSObject *v58;
  _BYTE *v59;
  int v60;
  CFIndex Count;
  CFIndex v62;
  CFIndex i;
  const void *ValueAtIndex;
  std::__shared_weak_count *v65;
  HTTP2Stream *v66;
  unint64_t *p_shared_owners;
  unint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  uint64_t *v71;
  int v72;
  uint64_t *v73;
  uint64_t *v74;
  _QWORD *v75;
  _QWORD *v76;
  unint64_t v77;
  CFIndex v78;
  uint64_t v79;
  uint64_t v80;
  NSObject *v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  void *v88;
  uint64_t v90;
  uint64_t v91;
  _OWORD v92[2];
  int v93;
  _BYTE buf[32];
  uint64_t v95;
  int v96;
  BOOL v97;
  __int16 v98;
  char v99;
  int v100;
  int v101;
  int v102;
  int v103;
  uint64_t v104;
  CFStreamError v105;
  CFStreamError v106;

  v104 = *MEMORY[0x1E0C80C00];
  v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_84, 2);
  if (v5)
  {
    v6 = v5;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v5 + 16))(v5, "h2 frame", 0))
    {
      HTTP2Diagnostic::LOG_FRAME(v6, a2, 0, *(_QWORD *)(a3 + 72), 0);
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  if (!a2)
    __assert_rtn("handleFrame", "HTTP2Connection.cpp", 883, "frame");
  switch(*(_BYTE *)(a2 + 12))
  {
    case 0:
      stream_user_data = (_BYTE **)nghttp2_session_get_stream_user_data();
      if (!stream_user_data)
      {
        v8 = 0;
        goto LABEL_75;
      }
      v8 = *stream_user_data;
      if (!*stream_user_data)
      {
LABEL_75:
        v10 = 1;
        goto LABEL_76;
      }
      *((_QWORD *)v8 + 13) -= *(_QWORD *)a2;
      v9 = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v8 + 24))(v8);
      v10 = 0;
      if (v9)
        *(_QWORD *)(v9 + 136) += *(_QWORD *)a2 + 9;
LABEL_76:
      v54 = *(_DWORD *)(a2 + 8);
      if (v54 && (v54 & 1) == 0 && (*(_BYTE *)(a2 + 13) & 1) != 0)
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = HTTP2ServerPushStream::safe_data_deleter;
        HTTP2ServerPush::appendDataForStream((uint64_t *)(a3 + 288), (uint64_t)buf, v54, 1);
        if (*(_QWORD *)buf)
          (*(void (**)(void))&buf[8])();
        v56 = *(int *)(a3 + 304);
        if (!(CFArrayGetCount(*(CFArrayRef *)(a3 + 232)) + v56))
        {
          *(CFAbsoluteTime *)(a3 + 248) = CFAbsoluteTimeGetCurrent();
          if (*(_BYTE *)(a3 + 264))
            HTTP2Connection::stop((HTTP2Connection *)a3, 0);
        }
      }
      else if ((v10 & 1) == 0)
      {
        goto LABEL_80;
      }
LABEL_163:
      if (*(_QWORD *)(a3 + 720) && *(_BYTE *)(a2 + 12) != 6)
        HTTP2Connection::stopStallRecovery((dispatch_source_t *)a3);
      return 0;
    case 1:
      v11 = *(_DWORD *)(a2 + 8);
      if (!v11 || (v11 & 1) != 0)
      {
        v50 = (_QWORD *)nghttp2_session_get_stream_user_data();
        if (v50)
        {
          v8 = (_BYTE *)*v50;
          if (*v50)
          {
            if (*(_DWORD *)(a2 + 56) == 1)
            {
              v51 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v8 + 24))(*v50);
              if (v51)
                *(_QWORD *)(v51 + 200) = 0x7FF8000000000000;
            }
            v52 = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v8 + 24))(v8);
            if (v52)
              *(_QWORD *)(v52 + 120) += *(_QWORD *)a2 + 9;
            if ((*(_DWORD *)(a2 + 56) | 2) == 3)
            {
              v53 = *(_BYTE *)(a2 + 13);
              if ((v53 & 4) != 0)
              {
                HTTP2Stream::endHeaders((HTTP2Stream *)v8);
LABEL_80:
                v53 = *(_BYTE *)(a2 + 13);
              }
              if ((v53 & 1) != 0)
              {
                HTTP2Connection::flushBatchedDataForStream((uint64_t **)a3, (HTTP2Stream *)v8);
                v8[131] = 1;
                HTTP2Stream::closeStreamWithErrorCode((HTTP2Stream *)v8);
              }
            }
          }
        }
      }
      else if (*(_DWORD *)(a2 + 56) == 2 && (*(_BYTE *)(a2 + 13) & 4) != 0)
      {
        v12 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)(a3 + 336), v11);
        if (v12)
        {
          v13 = v12[3];
          if (v13)
            *(_BYTE *)(v13 + 144) = 1;
        }
        if (DiagnosticLogging::userDiagnosticLevel(void)::onceToken != -1)
          dispatch_once(&DiagnosticLogging::userDiagnosticLevel(void)::onceToken, &__block_literal_global_13840);
        if (DiagnosticLogging::userDiagnosticLevel(void)::sChecked >= 2)
        {
          v14 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)(a3 + 336), *(_DWORD *)(a2 + 8));
          if (v14)
          {
            v15 = v14[3];
            if (v15)
            {
              memset(buf, 0, 24);
              v16 = *(_QWORD *)(v15 + 120);
              v17 = *(_QWORD *)(v15 + 128);
              while (v16 != v17)
              {
                v18 = v16 + 24;
                HTTP2Diagnostic::APPEND_RECV_HEADER((std::string *)buf, v16, v16 + 24, *(_DWORD *)(a2 + 8), *(_QWORD *)(a3 + 72));
                v16 = v18 + 24;
              }
              v90 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_46, 2);
              v91 = v90;
              if (v90
                && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v90 + 16))(v90, "h2 push response headers", 0))
              {
                (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v91 + 72))(v91, "h2 hdrs", CFSTR("%s"));
                (*(void (**)(uint64_t))(*(_QWORD *)v91 + 8))(v91);
              }
              if ((buf[23] & 0x80000000) != 0)
              {
                v88 = *(void **)buf;
                goto LABEL_162;
              }
            }
          }
        }
      }
      goto LABEL_163;
    case 3:
      v32 = (HTTP2Stream **)nghttp2_session_get_stream_user_data();
      if (!v32 || (v33 = *v32) == 0)
      {
        v49 = *(_DWORD *)(a2 + 8);
        if (v49 && (v49 & 1) == 0)
          HTTP2ServerPush::removeAsRefusedStream((HTTP2ServerPush *)(a3 + 288), v49);
        goto LABEL_163;
      }
      v34 = (HTTP2Connection *)*(unsigned int *)(a2 + 16);
      if ((_DWORD)v34 == 13)
      {
        HTTP2Stream::handle_HTTP_1_1_REQUIRED_error(*v32);
      }
      else if (!(_DWORD)v34)
      {
        HTTP2Stream::didReceiveRSTStream(*v32);
        goto LABEL_134;
      }
      v78 = HTTP2Connection::http2ErrorCodeToCFStreamError(v34);
      v80 = v79;
      v106.domain = v78;
      *(_QWORD *)&v106.error = v80;
      HTTP2Stream::setError(v33, v106);
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v81 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v82 = *(_QWORD *)(a3 + 72);
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v82;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = (_DWORD)v34;
        _os_log_impl(&dword_183ECA000, v81, OS_LOG_TYPE_DEFAULT, "Connection %llu: received H2 RST_STREAM with error code: %u", buf, 0x12u);
      }
      HTTP2Stream::didReceiveRSTStream(v33);
      if (v34 > 0xB || ((1 << (char)v34) & 0x981) == 0)
        goto LABEL_163;
LABEL_134:
      *((_BYTE *)v33 + 131) = 1;
      goto LABEL_163;
    case 4:
      if ((*(_BYTE *)(a2 + 13) & 1) == 0)
      {
        v35 = *(_QWORD *)(a2 + 16);
        if (v35)
        {
          v36 = 0;
          v37 = 0;
          v38 = 0;
          v39 = 0;
          v40 = 0;
          v41 = 0;
          v42 = (int *)(*(_QWORD *)(a2 + 24) + 4);
          do
          {
            switch(*(v42 - 1))
            {
              case 1:
                v41 = *v42;
                break;
              case 2:
                v40 = *v42 == 1;
                break;
              case 3:
                v39 = *v42;
                break;
              case 4:
                v38 = *v42;
                break;
              case 5:
                v37 = *v42;
                break;
              case 6:
                v36 = *v42;
                break;
              default:
                break;
            }
            v42 += 2;
            --v35;
          }
          while (v35);
        }
        else
        {
          v41 = 0;
          v40 = 0;
          v39 = 0;
          v38 = 0;
          v37 = 0;
          v36 = 0;
        }
        CFRetain((CFTypeRef)(a3 - 16));
        v58 = *(NSObject **)(a3 + 168);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___ZN15HTTP2Connection19handleSETTINGSFrameEPK13nghttp2_frame_block_invoke;
        *(_QWORD *)&buf[24] = &__block_descriptor_64_e5_v8__0l;
        v95 = a3;
        v96 = v41;
        v97 = v40;
        v98 = 0;
        v99 = 0;
        v100 = v39;
        v101 = v38;
        v102 = v37;
        v103 = v36;
        v59 = buf;
        goto LABEL_149;
      }
      goto LABEL_163;
    case 5:
      if ((*(_BYTE *)(a2 + 13) & 4) != 0)
      {
        v43 = *(_DWORD *)(a2 + 40);
        if (DiagnosticLogging::userDiagnosticLevel(void)::onceToken != -1)
          dispatch_once(&DiagnosticLogging::userDiagnosticLevel(void)::onceToken, &__block_literal_global_13840);
        if (DiagnosticLogging::userDiagnosticLevel(void)::sChecked >= 2)
        {
          v44 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((_QWORD *)(a3 + 336), v43);
          if (v44)
          {
            v45 = v44[3];
            if (v45)
            {
              memset(buf, 0, 24);
              v46 = *(_QWORD *)(v45 + 48);
              v47 = *(_QWORD *)(v45 + 56);
              while (v46 != v47)
              {
                v48 = v46 + 24;
                HTTP2Diagnostic::APPEND_RECV_HEADER((std::string *)buf, v46, v46 + 24, *(_DWORD *)(a2 + 8), *(_QWORD *)(a3 + 72));
                v46 = v48 + 24;
              }
              v84 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_41, 2);
              v85 = v84;
              if (v84
                && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v84 + 16))(v84, "h2 push promise headers", 0))
              {
                (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v85 + 72))(v85, "h2 hdrs", CFSTR("%s"));
                (*(void (**)(uint64_t))(*(_QWORD *)v85 + 8))(v85);
              }
              if ((buf[23] & 0x80000000) != 0)
                operator delete(*(void **)buf);
            }
          }
        }
        if ((HTTP2ServerPush::endPromisedHeadersWithCheckTheCacheBlock((uint64_t *)(a3 + 288), v43) & 1) == 0)
        {
          nghttp2_submit_rst_stream();
          v59 = *(_BYTE **)(a3 + 128);
          if (v59)
          {
            v58 = *(NSObject **)(a3 + 168);
LABEL_149:
            dispatch_async(v58, v59);
          }
        }
      }
      goto LABEL_163;
    case 6:
      if ((*(_BYTE *)(a2 + 13) & 1) != 0)
      {
        v19 = *(_QWORD *)(a2 + 16);
        v20 = (_QWORD *)(a3 + 672);
        v21 = std::__hash_table<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::tuple<double,void({block_pointer})(__CFError *,double)>>>>::find<unsigned long long>((_QWORD *)(a3 + 672), v19);
        if (v21)
        {
          v22 = v21;
          v23 = *((double *)v21 + 3);
          v24 = (void (**)(_QWORD, _QWORD, double))v21[4];
          Current = CFAbsoluteTimeGetCurrent();
          v24[2](v24, 0, Current - v23);
          _Block_release(v24);
          v26 = *(int8x8_t *)(a3 + 680);
          v27 = v22[1];
          v28 = (uint8x8_t)vcnt_s8(v26);
          v28.i16[0] = vaddlv_u8(v28);
          if (v28.u32[0] > 1uLL)
          {
            if (v27 >= *(_QWORD *)&v26)
              v27 %= *(_QWORD *)&v26;
          }
          else
          {
            v27 &= *(_QWORD *)&v26 - 1;
          }
          v75 = *(_QWORD **)(*v20 + 8 * v27);
          do
          {
            v76 = v75;
            v75 = (_QWORD *)*v75;
          }
          while (v75 != v22);
          if (v76 == (_QWORD *)(a3 + 688))
            goto LABEL_152;
          v77 = v76[1];
          if (v28.u32[0] > 1uLL)
          {
            if (v77 >= *(_QWORD *)&v26)
              v77 %= *(_QWORD *)&v26;
          }
          else
          {
            v77 &= *(_QWORD *)&v26 - 1;
          }
          if (v77 != v27)
          {
LABEL_152:
            if (!*v22)
              goto LABEL_153;
            v83 = *(_QWORD *)(*v22 + 8);
            if (v28.u32[0] > 1uLL)
            {
              if (v83 >= *(_QWORD *)&v26)
                v83 %= *(_QWORD *)&v26;
            }
            else
            {
              v83 &= *(_QWORD *)&v26 - 1;
            }
            if (v83 != v27)
LABEL_153:
              *(_QWORD *)(*v20 + 8 * v27) = 0;
          }
          v86 = *v22;
          if (*v22)
          {
            v87 = *(_QWORD *)(v86 + 8);
            if (v28.u32[0] > 1uLL)
            {
              if (v87 >= *(_QWORD *)&v26)
                v87 %= *(_QWORD *)&v26;
            }
            else
            {
              v87 &= *(_QWORD *)&v26 - 1;
            }
            if (v87 != v27)
            {
              *(_QWORD *)(*v20 + 8 * v87) = v76;
              v86 = *v22;
            }
          }
          *v76 = v86;
          *v22 = 0;
          --*(_QWORD *)(a3 + 696);
          v88 = v22;
LABEL_162:
          operator delete(v88);
        }
        else
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v57 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = v19;
            _os_log_error_impl(&dword_183ECA000, v57, OS_LOG_TYPE_ERROR, "Got an unknown PING with ack bit. Ping Seed = %llu", buf, 0xCu);
          }
        }
      }
      goto LABEL_163;
    case 7:
      v29 = *(_DWORD *)(a2 + 20);
      if (v29)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v30 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          v31 = *(_QWORD *)(a3 + 72);
          *(_DWORD *)buf = 134218240;
          *(_QWORD *)&buf[4] = v31;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v29;
          _os_log_impl(&dword_183ECA000, v30, OS_LOG_TYPE_DEFAULT, "Connection %llu received H2 GOAWAY with error code: %u", buf, 0x12u);
        }
        goto LABEL_34;
      }
      v55 = *(_DWORD *)(a2 + 16);
      if (v55 == 0x7FFFFFFF)
      {
        *(_BYTE *)(a3 + 264) = 1;
      }
      else
      {
        if (v55 < 1)
        {
LABEL_34:
          HTTP2Connection::setErrorOnAllStreams((HTTP2Connection *)a3, v29);
          HTTP2Connection::closeConnection((HTTP2Connection *)a3, 1);
          goto LABEL_163;
        }
        *(_BYTE *)(a3 + 264) = 1;
        v60 = *(_DWORD *)(a2 + 16);
        Count = CFArrayGetCount(*(CFArrayRef *)(a3 + 232));
        if (Count >= 1)
        {
          v62 = Count;
          for (i = 0; i != v62; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 232), i);
            v66 = (HTTP2Stream *)*((_QWORD *)ValueAtIndex + 3);
            v65 = (std::__shared_weak_count *)*((_QWORD *)ValueAtIndex + 4);
            if (v65)
            {
              p_shared_owners = (unint64_t *)&v65->__shared_owners_;
              do
                v68 = __ldxr(p_shared_owners);
              while (__stxr(v68 + 1, p_shared_owners));
            }
            if (*((_DWORD *)v66 + 20) > v60)
            {
              v105.domain = 4;
              *(_QWORD *)&v105.error = 4294965096;
              HTTP2Stream::setError(v66, v105);
              HTTP2Stream::closeStreamWithErrorCode(v66);
            }
            if (v65)
            {
              v69 = (unint64_t *)&v65->__shared_owners_;
              do
                v70 = __ldaxr(v69);
              while (__stlxr(v70 - 1, v69));
              if (!v70)
              {
                ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
                std::__shared_weak_count::__release_weak(v65);
              }
            }
          }
        }
        memset(buf, 0, sizeof(buf));
        LODWORD(v95) = 1065353216;
        v71 = *(uint64_t **)(a3 + 352);
        if (v71)
        {
          do
          {
            v72 = *((_DWORD *)v71 + 4);
            if (v72 > v60)
              std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((uint64_t)buf, v72, *((_DWORD *)v71 + 4));
            v71 = (uint64_t *)*v71;
          }
          while (v71);
          v73 = *(uint64_t **)&buf[16];
          if (*(_QWORD *)&buf[16])
          {
            do
            {
              HTTP2ServerPush::removeAsRefusedStream((HTTP2ServerPush *)(a3 + 288), *((_DWORD *)v73 + 4));
              v73 = (uint64_t *)*v73;
            }
            while (v73);
          }
        }
        memset(v92, 0, sizeof(v92));
        v93 = v95;
        std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>((uint64_t)v92, *(size_t *)&buf[8]);
        v74 = *(uint64_t **)&buf[16];
        if (*(_QWORD *)&buf[16])
        {
          do
          {
            std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((uint64_t)v92, *((_DWORD *)v74 + 4), *((_DWORD *)v74 + 4));
            v74 = (uint64_t *)*v74;
          }
          while (v74);
        }
        std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)buf);
        std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)v92);
      }
      HTTP2Connection::stopIfNoOutstandingRequests((HTTP2Connection *)a3);
      goto LABEL_163;
    default:
      goto LABEL_163;
  }
}

void sub_183F84190(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t HTTP2Stream::getTransactionMetrics(HTTP2Stream *this)
{
  return *((_QWORD *)this + 38);
}

void HTTP2Stream::endHeaders(HTTP2Stream *this)
{
  BOOL v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  const char *v6;
  uint64_t v7;
  HTTPMessage *v8;
  uint64_t v9;
  HTTPMessage *v10;
  uint64_t v11;
  HTTPMessage *v12;
  CFMutableDictionaryRef v13;
  CFIndex v14;
  CFAllocatorRef *v15;
  int v16;
  uint64_t v17;
  _QWORD *v18;
  _OWORD *Instance;
  HTTPMessage *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  const void *v23;
  unint64_t v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  const void *v29;
  const void *v30;
  uint64_t v31;
  HTTPHeaderDict *v32;
  uint64_t v33;
  uint64_t v34;
  HTTPMessage *v35;
  uint64_t v36;
  os_unfair_lock_s *v37;
  CFIndex ResponseStatusCode;
  os_unfair_lock_s *v39;
  os_unfair_lock_s *v40;
  int hasHeaderField;
  NSObject *v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  NSObject *v49;
  unint64_t *p_shared_owners;
  unint64_t v51;
  uint64_t v52;
  void (**v53)(StringSerializable *__hidden);
  CFTypeRef cf;
  _BYTE buf[22];
  __int16 v56;
  int v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 20))
    v2 = (*((_DWORD *)this + 20) & 1) == 0;
  else
    v2 = 0;
  if (!v2)
  {
    v3 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_8438, 2);
    if (v3)
    {
      v4 = v3;
      v5 = *((_BYTE *)this + 353) ? "h2 trailers" : "h2 headers";
      if ((*(unsigned int (**)(uint64_t, char *, _QWORD))(*(_QWORD *)v3 + 16))(v3, v5, 0))
      {
        if (*((_BYTE *)this + 353))
          v6 = "h2 trls";
        else
          v6 = "h2 hdrs";
        (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v4 + 72))(v4, v6, CFSTR("%s"));
        if (*((char *)this + 351) < 0)
        {
          **((_BYTE **)this + 41) = 0;
          *((_QWORD *)this + 42) = 0;
        }
        else
        {
          *((_BYTE *)this + 328) = 0;
          *((_BYTE *)this + 351) = 0;
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
      }
    }
  }
  if (*((_BYTE *)this + 352))
  {
    *((_BYTE *)this + 353) = 1;
    if (*((_BYTE *)this + 152))
    {
      HTTP2Stream::_onqueue_processRawHeaders(this);
      v7 = *((_QWORD *)this + 18);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (v7)
        v8 = (HTTPMessage *)(v7 + 16);
      else
        v8 = 0;
      HTTPMessage::replaceHeaderFieldsWithExternalHeaderDict(v8, *((HTTPHeaderDict **)this + 20));
      v9 = *((_QWORD *)this + 15);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (v9)
        v10 = (HTTPMessage *)(v9 + 16);
      else
        v10 = 0;
      v11 = *((_QWORD *)this + 18);
      if (v11)
        v12 = (HTTPMessage *)(v11 + 16);
      else
        v12 = 0;
      v13 = HTTPMessage::copyAllHeaderFields(v12);
      HTTPMessage::setTrailerFields(v10, v13);
      if (v13)
        CFRelease(v13);
      *((_BYTE *)this + 153) = 1;
      return;
    }
    HTTP2Stream::_onqueue_processRawHeaders(this);
    v34 = *((_QWORD *)this + 15);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (v34)
      v35 = (HTTPMessage *)(v34 + 16);
    else
      v35 = 0;
    HTTPMessage::replaceHeaderFieldsWithExternalHeaderDict(v35, *((HTTPHeaderDict **)this + 17));
    v36 = *((_QWORD *)this + 15);
    if (v36)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (*(_BYTE *)(v36 + 40))
        v37 = (os_unfair_lock_s *)(v36 + 16);
      else
        v37 = 0;
    }
    else
    {
      v37 = 0;
    }
    if ((HTTPResponseMessage::isValid(v37) & 1) != 0)
    {
      *((_DWORD *)this + 14) = 1;
      *((_BYTE *)this + 129) = 1;
      ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(*((CFHTTPMessageRef *)this + 15));
      v39 = (os_unfair_lock_s *)*((_QWORD *)this + 15);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      if (v39)
        v40 = v39 + 4;
      else
        v40 = 0;
      hasHeaderField = HTTPMessage::hasHeaderField(v40, 0x11D1D2CFu);
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v42 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v43 = *((_QWORD *)this + 27);
        if (hasHeaderField)
          v44 = 75;
        else
          v44 = 85;
        *(_DWORD *)buf = 138543874;
        *(_QWORD *)&buf[4] = v43;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = ResponseStatusCode;
        v56 = 1024;
        v57 = v44;
        _os_log_impl(&dword_183ECA000, v42, OS_LOG_TYPE_DEFAULT, "%{public}@ received response, status %ld content %c", buf, 0x1Cu);
      }
      v45 = *((_QWORD *)this + 8);
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      v46 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
      if (v46)
      {
        v47 = std::__shared_weak_count::lock(v46);
        *(_QWORD *)&buf[8] = v47;
        if (v47)
        {
          v48 = *((_QWORD *)this + 35);
          *(_QWORD *)buf = v48;
LABEL_102:
          HTTP2Connection::streamExitedStallableState(v45, v48, v47);
          if (v47)
          {
            p_shared_owners = (unint64_t *)&v47->__shared_owners_;
            do
              v51 = __ldaxr(p_shared_owners);
            while (__stlxr(v51 - 1, p_shared_owners));
            if (!v51)
            {
              ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
              std::__shared_weak_count::__release_weak(v47);
            }
          }
          return;
        }
      }
      else
      {
        v47 = 0;
      }
      v48 = 0;
      goto LABEL_102;
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v49 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v52 = *((_QWORD *)this + 27);
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v52;
      _os_log_error_impl(&dword_183ECA000, v49, OS_LOG_TYPE_ERROR, "%{public}@ rejecting invalid response header due to multiple values", buf, 0xCu);
    }
    *((_QWORD *)this + 23) = 4;
    *((_DWORD *)this + 48) = -1;
    HTTP2Stream::closeStreamWithErrorCode(this);
  }
  else
  {
    HTTP2Stream::_onqueue_processRawHeaders(this);
    v14 = CFHTTPMessageGetResponseStatusCode(*((CFHTTPMessageRef *)this + 15));
    v15 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    if ((unint64_t)(v14 - 100) <= 0x63)
    {
      v16 = v14;
      v17 = *((_QWORD *)this + 2);
      if (v17)
        v18 = (_QWORD *)(v17 - 176);
      else
        v18 = 0;
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      Instance = (_OWORD *)_CFRuntimeCreateInstance();
      v20 = (HTTPMessage *)Instance;
      if (Instance)
      {
        Instance[1] = 0u;
        v20 = (HTTPMessage *)(Instance + 1);
        Instance[18] = 0u;
        Instance[19] = 0u;
        Instance[16] = 0u;
        Instance[17] = 0u;
        Instance[14] = 0u;
        Instance[15] = 0u;
        Instance[12] = 0u;
        Instance[13] = 0u;
        Instance[10] = 0u;
        Instance[11] = 0u;
        Instance[8] = 0u;
        Instance[9] = 0u;
        Instance[6] = 0u;
        Instance[7] = 0u;
        Instance[4] = 0u;
        Instance[5] = 0u;
        Instance[2] = 0u;
        Instance[3] = 0u;
      }
      HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v53, CFSTR("HTTP/2.0"));
      HTTPMessage::HTTPMessage(v20, "httpresponse", cf);
      *(_QWORD *)v20 = &off_1E14E9F38;
      *((_QWORD *)v20 + 1) = &unk_1E14E9FA8;
      *((_QWORD *)v20 + 2) = &unk_1E14E9FC8;
      *((_DWORD *)v20 + 32) = v16;
      *((_QWORD *)v20 + 17) = 0;
      *((_OWORD *)v20 + 10) = 0u;
      *((_OWORD *)v20 + 11) = 0u;
      *((_OWORD *)v20 + 12) = 0u;
      *((_OWORD *)v20 + 13) = 0u;
      *((_OWORD *)v20 + 14) = 0u;
      *((_OWORD *)v20 + 15) = 0u;
      *((_OWORD *)v20 + 16) = 0u;
      *((_OWORD *)v20 + 17) = 0u;
      *((_BYTE *)v20 + 296) = 0;
      *(_QWORD *)buf = v20;
      v21 = (std::__shared_weak_count *)operator new();
      v21->__shared_owners_ = 0;
      v22 = (unint64_t *)&v21->__shared_owners_;
      v21->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1710;
      v21->__shared_weak_owners_ = 0;
      v21[1].__vftable = (std::__shared_weak_count_vtbl *)v20;
      *(_QWORD *)&buf[8] = v21;
      v53 = &off_1E14E9A00;
      if (cf)
        CFRelease(cf);
      HTTPMessage::ensureParserFinished(v20);
      v23 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*((_QWORD *)this + 5) + 128));
      HTTPResponseMessage::setResponseURL(v20, v23, 0);
      HTTPMessage::replaceHeaderFieldsWithExternalHeaderDict(v20, *((HTTPHeaderDict **)this + 17));
      v53 = (void (**)(StringSerializable *__hidden))v20;
      cf = v21;
      do
        v24 = __ldxr(v22);
      while (__stxr(v24 + 1, v22));
      HTTPProtocol::handleInformationalResponse(v18, (uint64_t)&v53);
      do
        v25 = __ldaxr(v22);
      while (__stlxr(v25 - 1, v22));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
      v26 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v27 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
    }
    v29 = (const void *)*((_QWORD *)this + 15);
    if (v29)
      CFRelease(v29);
    *((_QWORD *)this + 15) = CFHTTPMessageCreateEmpty(*v15, 0);
    v30 = (const void *)*((_QWORD *)this + 30);
    *((_QWORD *)this + 30) = 0;
    if (v30)
      CFRelease(v30);
    v31 = *((_QWORD *)this + 17);
    if (v31)
      CFRelease((CFTypeRef)(v31 - 16));
    if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
      dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
    v32 = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
    if (v32)
    {
      *((_QWORD *)v32 + 2) = 0;
      *((_QWORD *)v32 + 3) = 0;
      v32 = (HTTPHeaderDict *)((char *)v32 + 16);
    }
    HTTPHeaderDict::HTTPHeaderDict(v32);
    *((_QWORD *)this + 17) = v33;
  }
}

void sub_183F849A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf, char a13)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void HTTPMessage::replaceHeaderFieldsWithExternalHeaderDict(HTTPMessage *this, HTTPHeaderDict *a2)
{
  uint64_t v4;
  HTTPHeaderDict *Instance;
  uint64_t v6;
  uint64_t v7;

  v4 = *((_QWORD *)this + 12);
  if (!v4)
  {
    CFGetAllocator((char *)this - 16);
    if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
      dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
    Instance = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
    if (Instance)
    {
      *((_QWORD *)Instance + 2) = 0;
      *((_QWORD *)Instance + 3) = 0;
      Instance = (HTTPHeaderDict *)((char *)Instance + 16);
    }
    HTTPHeaderDict::HTTPHeaderDict(Instance);
    *((_QWORD *)this + 12) = v4;
    v6 = *((_QWORD *)this + 13);
    if (v6)
    {
      CFRelease((CFTypeRef)(v6 - 16));
      *((_QWORD *)this + 13) = 0;
      v4 = *((_QWORD *)this + 12);
    }
  }
  v7 = *((_QWORD *)a2 + 1);
  *((_QWORD *)a2 + 1) = *(_QWORD *)(v4 + 8);
  *(_QWORD *)(v4 + 8) = v7;
}

void HTTP2Stream::_onqueue_processRawHeaders(HTTP2Stream *this)
{
  uint64_t v1;
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const __CFString *ValueAtIndex;
  CFIndex v8;
  const __CFString *v9;
  uint64_t v10;
  uint64_t v11;
  UInt8 *CStringFromCFString;
  std::string *v13;
  std::string::size_type size;
  CFURLRef v15;
  void (**v16)(StringSerializable *__hidden);
  CFTypeRef cf;
  std::string v18;

  v1 = 248;
  if (!*((_BYTE *)this + 129))
    v1 = 240;
  v2 = *(const __CFArray **)((char *)this + v1);
  if (v2)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)((char *)this + v1));
    v5 = Count;
    if ((Count & 1) != 0)
      __assert_rtn("_onqueue_processRawHeaders", "HTTP2Stream.cpp", 873, "(count % 2) == 0");
    if (Count >= 1)
    {
      v6 = 0;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v2, v6);
        v8 = v6 + 1;
        v9 = (const __CFString *)CFArrayGetValueAtIndex(v2, v8);
        if (CFStringCompare(ValueAtIndex, CFSTR(":status"), 0))
        {
          v10 = 160;
          if (!*((_BYTE *)this + 129))
            v10 = 136;
          v11 = *(_QWORD *)((char *)this + v10);
          HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v18, ValueAtIndex);
          HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue((HTTPHeaderValueMixedValue *)&v16, v9);
          HTTPHeaderDict::addValue(v11, (uint64_t)&v18, (uint64_t)&v16);
          v16 = &off_1E14E9A00;
          if (cf)
            CFRelease(cf);
          v18.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E14E9A00;
          if (v18.__r_.__value_.__l.__size_)
            CFRelease((CFTypeRef)v18.__r_.__value_.__l.__size_);
        }
        else
        {
          CStringFromCFString = http2CreateCStringFromCFString(v9, 0);
          memset(&v18, 0, sizeof(v18));
          std::string::append(&v18, "HTTP/2.0 ");
          std::string::append(&v18, (const std::string::value_type *)CStringFromCFString);
          std::string::append(&v18, "\r\n\r\n");
          free(CStringFromCFString);
          if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v13 = &v18;
          else
            v13 = (std::string *)v18.__r_.__value_.__r.__words[0];
          if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(v18.__r_.__value_.__r.__words[2]);
          else
            size = v18.__r_.__value_.__l.__size_;
          CFHTTPMessageAppendBytes(*((CFHTTPMessageRef *)this + 15), (const UInt8 *)v13, size);
          v15 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(*((_QWORD *)this + 5) - 16));
          _CFHTTPMessageSetResponseURL(*((_QWORD *)this + 15), v15);
          if (v15)
            CFRelease(v15);
          if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v18.__r_.__value_.__l.__data_);
        }
        v6 = v8 + 1;
      }
      while (v6 < v5);
    }
  }
}

void sub_183F84CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFTypeRef cf, void *__p, CFTypeRef a13, int a14, __int16 a15, char a16, char a17)
{
  if (cf)
    CFRelease(cf);
  if (a13)
    CFRelease(a13);
  _Unwind_Resume(exception_object);
}

uint64_t cf_nghttp2_on_stream_close_callback(int a1, int a2, HTTP2Connection *a3, uint64_t a4)
{
  uint64_t stream_user_data;
  std::__shared_weak_count *v10;
  HTTP2Stream *v11;
  HTTP2Stream *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;

  if ((!a2 || (a2 & 1) != 0) && !*(_BYTE *)(a4 + 640))
  {
    stream_user_data = nghttp2_session_get_stream_user_data();
    if (stream_user_data)
    {
      v11 = *(HTTP2Stream **)stream_user_data;
      v10 = *(std::__shared_weak_count **)(stream_user_data + 8);
      v12 = *(HTTP2Stream **)stream_user_data;
      if (v10)
      {
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v14 = __ldxr(p_shared_owners);
        while (__stxr(v14 + 1, p_shared_owners));
        v12 = *(HTTP2Stream **)stream_user_data;
      }
      HTTP2Connection::flushBatchedDataForStream((uint64_t **)a4, v12);
      HTTP2Stream::cleanUpInUserDataResetCallback(v11, a1, a2, a3, a4);
      if (v10)
      {
        v15 = (unint64_t *)&v10->__shared_owners_;
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
    }
  }
  return 0;
}

void sub_183F84DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTP2Stream::cleanUpInUserDataResetCallback(HTTP2Stream *this, int a2, int a3, HTTP2Connection *a4, uint64_t a5)
{
  CFNumberRef v8;
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;
  int valuePtr;
  CFStreamError v14;

  valuePtr = a3;
  if (*((_QWORD *)this + 54))
  {
    v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
    __NSURLSessionTaskDependency_RemoveRequest(*((void **)this + 54), (uint64_t)v8, *(void **)(a5 + 40), *((_QWORD *)this + 6));
    if (v8)
      CFRelease(v8);
  }
  if ((_DWORD)a4 && !*((_QWORD *)this + 23) && !*((_DWORD *)this + 48))
  {
    v9 = HTTP2Connection::http2ErrorCodeToCFStreamError(a4);
    v11 = v10;
    v14.domain = v9;
    *(_QWORD *)&v14.error = v11;
    HTTP2Stream::setError(this, v14);
  }
  HTTP2Stream::closeStreamWithErrorCode(this);
  HTTP2Stream::breakStreamUserDataCycle((uint64_t)this);
  return nghttp2_session_set_stream_user_data();
}

void sub_183F84EE4(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void HTTP2Stream::closeStreamWithErrorCode(HTTP2Stream *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  NSObject *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19[2];
  _QWORD block[6];
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  if (*((_BYTE *)this + 256))
    return;
  *((_BYTE *)this + 256) = 1;
  v22 = 0;
  v23 = 0;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
  if (!v2)
  {
    v3 = 0;
    goto LABEL_7;
  }
  v3 = std::__shared_weak_count::lock(v2);
  v23 = v3;
  if (!v3)
  {
LABEL_7:
    v4 = 0;
    goto LABEL_8;
  }
  v4 = *((_QWORD *)this + 35);
  v22 = v4;
LABEL_8:
  v5 = *((_QWORD *)this + 9);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN11HTTP2Stream24closeStreamWithErrorCodeEi_block_invoke;
  block[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
  block[4] = this;
  block[5] = v4;
  v21 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  dispatch_async(v5, block);
  v8 = *((_QWORD *)this + 8);
  v19[0] = v4;
  v19[1] = (uint64_t)v3;
  if (v3)
  {
    v9 = (unint64_t *)&v3->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  HTTP2Connection::didCloseStream(v8, v19, *((_BYTE *)this + 131) != 0);
  if (v3)
  {
    v11 = (unint64_t *)&v3->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v13 = v21;
  if (v21)
  {
    v14 = (unint64_t *)&v21->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = v23;
  if (v23)
  {
    v17 = (unint64_t *)&v23->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void sub_183F850A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 48);
  _Unwind_Resume(a1);
}

void HTTP2Connection::didCloseStream(uint64_t a1, uint64_t *a2, char a3)
{
  NSObject *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[6];
  std::__shared_weak_count *v15;
  char v16;

  CFRetain((CFTypeRef)(a1 - 16));
  v6 = *(NSObject **)(a1 + 168);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3321888768;
  v14[2] = ___ZN15HTTP2Connection14didCloseStreamENSt3__110shared_ptrI11HTTP2StreamEEb_block_invoke;
  v14[3] = &__block_descriptor_57_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
  v8 = *a2;
  v7 = (std::__shared_weak_count *)a2[1];
  v14[4] = a1;
  v14[5] = v8;
  v15 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v16 = a3;
  dispatch_async(v6, v14);
  v11 = v15;
  if (v15)
  {
    v12 = (unint64_t *)&v15->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void __NSURLSessionTaskDependency_RemoveRequest(void *a1, uint64_t a2, void *a3, uint64_t a4)
{
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v8 = (void *)MEMORY[0x186DB8C8C]();
  v9 = (void *)objc_msgSend(a3, "objectForKeyedSubscript:", CFSTR("TaskIDs"));
  v10 = objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("TaskIdentifier"));
  v11 = objc_msgSend(v9, "objectForKeyedSubscript:", v10);
  -[__NSCFURLSessionTaskActiveStreamDependencyInfo removeStreamWithStreamID:requestURLString:](v11, a2, a4);
  if (-[__NSCFURLSessionTaskActiveStreamDependencyInfo isEmpty](v11))
    objc_msgSend(v9, "setObject:forKeyedSubscript:", 0, v10);
  v12 = objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("MainDocumentTaskIdentifier"));
  if (v12)
  {
    v13 = v12;
    v14 = objc_msgSend(v9, "objectForKeyedSubscript:", v12);
    -[__NSCFURLSessionTaskActiveStreamDependencyInfo removeStreamWithStreamID:requestURLString:](v14, a2, a4);
    if (-[__NSCFURLSessionTaskActiveStreamDependencyInfo isEmpty](v14))
      objc_msgSend(v9, "setObject:forKeyedSubscript:", 0, v13);
  }
  objc_autoreleasePoolPop(v8);
}

void sub_183F866DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_183F875FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_183F876C8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::_loaderInterface_release(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(unint64_t))(*(_QWORD *)this[-1].var33 + 72))(this[-1].var33);
}

uint64_t ___ZN25SessionConnectionLoadable48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_4(uint64_t a1, const void *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  URLConnectionLoader::protocolWasRedirected_final((URLConnectionLoader *)v2, a2);
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 72))(*(_QWORD *)(v2 + 32));
}

void URLConnectionLoader::protocolWasRedirected_final(URLConnectionLoader *this, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *var6;
  _QWORD v7[6];
  _QWORD block[6];

  if (!this->var4)
  {
    if (cf)
      CFRetain(cf);
    v4 = MEMORY[0x1E0C809B0];
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZN19URLConnectionLoader27protocolWasRedirected_finalEP12NSURLRequest_block_invoke;
    v7[3] = &unk_1E14FE140;
    v7[4] = cf;
    v7[5] = this;
    v5 = (*(uint64_t (**)(InterfaceRequiredForLoader *))(*(_QWORD *)this->var5 + 64))(this->var5);
    var6 = this->var6;
    block[0] = v4;
    block[1] = 3221225472;
    block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
    block[3] = &unk_1E14FDA90;
    block[4] = v7;
    block[5] = v5;
    dispatch_async(var6, block);
  }
}

uint64_t ___ZN25SessionConnectionLoadable58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN19URLConnectionLoader29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke_3(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[6];
  _QWORD block[6];

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 25))
  {
    if (cf)
      CFRetain(cf);
    v4 = MEMORY[0x1E0C809B0];
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZN19URLConnectionLoader29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke_4;
    v7[3] = &unk_1E14FE140;
    v7[4] = cf;
    v7[5] = v2;
    v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 64))(*(_QWORD *)(v2 + 32));
    v6 = *(NSObject **)(v2 + 40);
    block[0] = v4;
    block[1] = 3221225472;
    block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
    block[3] = &unk_1E14FDA90;
    block[4] = v7;
    block[5] = v5;
    dispatch_async(v6, block);
  }
}

uint64_t ___ZN25SessionConnectionLoadable21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 72))(v1);
}

void SessionConnectionLoadable::_loaderClientEvent_DidReceiveData(uint64_t a1, NSArray *a2, dispatch_object_t object)
{
  NSObject *DispatchDataFromDataArray;

  DispatchDataFromDataArray = object;
  if (!a2)
  {
    if (!object)
      return;
    dispatch_retain(object);
LABEL_7:
    objc_msgSend(*(id *)(a1 + 24), "_didReceiveData:", DispatchDataFromDataArray);
    dispatch_release(DispatchDataFromDataArray);
    return;
  }
  if (object)
    __assert_rtn("_loaderClientEvent_DidReceiveData", "SessionConnection.mm", 166, "dispatchData == nullptr");
  DispatchDataFromDataArray = createDispatchDataFromDataArray(a2);
  if (DispatchDataFromDataArray)
    goto LABEL_7;
}

void conCatData(dispatch_object_t *a1, dispatch_object_t object)
{
  NSObject *v3;
  dispatch_data_t concat;

  v3 = *a1;
  if (v3)
  {
    concat = dispatch_data_create_concat(v3, object);
    dispatch_release(*a1);
    *a1 = concat;
  }
  else
  {
    *a1 = object;
    dispatch_retain(object);
  }
}

void `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidReceiveData(uint64_t a1, NSArray *a2, NSObject *a3)
{
  SessionConnectionLoadable::_loaderClientEvent_DidReceiveData(a1 - 8, a2, a3);
}

void sub_183F88610(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void `non-virtual thunk to'URLConnectionLoader::_loaderEvent_StartLoad(URLConnectionLoader *this, NSURLSessionTask *a2)
{
  URLConnectionLoader::_loaderEvent_StartLoad((URLConnectionLoader *)((char *)this - 48), a2);
}

void ___ZN19URLConnectionLoader26protocolDidReceiveResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 72))(a2, *(_QWORD *)(a1 + 32));

}

uint64_t ___ZN19URLConnectionLoader24protocolDidFinishLoadingEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  return result;
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidFinishLoading(SessionConnectionLoadable *this)
{
  return objc_msgSend(this->var2, "_didFinishWithError:", 0);
}

const void *URLResponse::createArchiveList(URLResponse *this, CFAllocatorRef allocator, uint64_t *a3, const void ***a4, uint64_t *a5)
{
  uint64_t v10;
  const void **v11;
  const void *fURL;
  HTTPResponse *fHTTP;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  const void *fMIMEType;
  const void *fTextEncodingName;
  const void *result;
  CFIndex ResponseStatusCode;
  int valuePtr;

  v10 = 5;
  if (!this->fHTTP)
    v10 = 7;
  *a5 = v10;
  v11 = (const void **)CFAllocatorAllocate(allocator, 56, 0);
  *a4 = v11;
  fURL = this->fURL;
  if (fURL)
    fURL = CFRetain(fURL);
  *v11 = fURL;
  v11[1] = CFNumberCreate(allocator, kCFNumberDoubleType, &this->fCreationTime);
  valuePtr = this->fRecommendedPolicy;
  v11[2] = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
  fHTTP = this->fHTTP;
  if (!fHTTP)
  {
    *a3 = 0;
    fMIMEType = this->fMIMEType;
    if (fMIMEType)
      fMIMEType = CFRetain(fMIMEType);
    v11[3] = fMIMEType;
    fTextEncodingName = this->fTextEncodingName;
    if (fTextEncodingName)
      fTextEncodingName = CFRetain(fTextEncodingName);
    v11[4] = fTextEncodingName;
    v11[5] = CFNumberCreate(allocator, kCFNumberLongLongType, &this->fExpectedContentLength);
    result = CFNumberCreate(allocator, kCFNumberDoubleType, &this->fExpiration);
    goto LABEL_20;
  }
  *a3 = 1;
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)((char *)fHTTP - 16));
  v11[3] = CFNumberCreate(allocator, kCFNumberCFIndexType, &ResponseStatusCode);
  v14 = (const __CFDictionary *)HTTPMessage::copyHeadersWithShadowedArrayValues((HTTPMessage *)this->fHTTP);
  v11[5] = 0;
  v11[4] = v14;
  v11[6] = 0;
  if (((*(unsigned __int16 *)((char *)this->fHTTP + 297) | (*((unsigned __int8 *)this->fHTTP + 299) << 16)) & 0x10000) != 0)
  {
    v15 = v14;
    if (v14)
    {
      Count = CFDictionaryGetCount(v14);
      MutableCopy = CFDictionaryCreateMutableCopy(allocator, Count + 1, v15);
      CFDictionarySetValue(MutableCopy, &unk_1EDCFD9E0, CFSTR("CFNetwork"));
      v11[4] = MutableCopy;
      CFRelease(v15);
    }
    else
    {
      v11[4] = CFDictionaryCreate(allocator, (const void **)&kCFHTTPHeaderCFNetworkDataIsEncoded, (const void **)kCFHTTPCFNetworkProduct, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
  }
  if ((*(_WORD *)((char *)this->fHTTP + 297) & 0x2000) != 0)
  {
    *a5 = 7;
    v11[5] = CFNumberCreate(allocator, kCFNumberLongLongType, &this->fExpectedContentLength);
  }
  result = URLResponse::getMIMEType(this);
  if (result)
  {
    *a5 = 7;
LABEL_19:
    result = CFRetain(result);
LABEL_20:
    v11[6] = result;
    return result;
  }
  if ((*(_WORD *)((char *)this->fHTTP + 297) & 0x4000) != 0)
  {
    *a5 = 7;
    result = (const void *)*MEMORY[0x1E0C9AE40];
    if (!*MEMORY[0x1E0C9AE40])
      goto LABEL_20;
    goto LABEL_19;
  }
  return result;
}

BOOL HTTPSniffing::checkRequestAndUpdateResponseForSniffingPurposes(HTTPSniffing *this, _CFURLRequest *a2, _CFURLResponse *a3)
{
  CFURLRef v5;
  CFURLRef v6;
  const __CFURL *v7;
  uint64_t v8;
  __CFString *MIMEType;
  uint64_t v10;
  const __CFString *v11;
  const __CFString *v12;
  _BOOL4 v13;
  uint64_t v14;
  const void *v15;
  const __CFString *v16;
  _CFURLResponse *v17;
  uint64_t v18;
  const void *v19;
  _CFURLResponse *v20;
  uint64_t v21;
  const void *v22;
  __CFString *v24;
  const __CFString *v25;
  int CanonicalString;
  int v27;
  const __CFString *TextEncodingName;
  int v29;

  v5 = _CFURLRequestCopyProtocolPropertyForKey(this, (const __CFString *)&unk_1EDCFE700);
  if (v5)
  {
    v6 = v5;
    v7 = (const __CFURL *)*MEMORY[0x1E0C9AE50];
    CFRelease(v5);
    if (v6 == v7)
    {
      v8 = 1;
    }
    else
    {
      v8 = 0;
      if (v6 == (CFURLRef)*MEMORY[0x1E0C9AE40])
        return v8;
    }
  }
  else
  {
    v8 = 0;
  }
  MIMEType = URLResponse::getMIMEType((URLResponse *)-[_CFURLRequest _inner](a2, "_inner"));
  v10 = *(_QWORD *)(-[_CFURLRequest _inner](a2, "_inner") + 88);
  if (v10
    && (v11 = CFHTTPMessageCopyHeaderFieldValue((CFHTTPMessageRef)(v10 - 16), CFSTR("X-Content-Type-Options"))) != 0)
  {
    v12 = v11;
    v13 = CFStringCompare(v11, (CFStringRef)&unk_1EDCFDEB0, 1uLL) == kCFCompareEqualTo;
    CFRelease(v12);
  }
  else
  {
    v13 = 0;
  }
  if ((dyld_program_sdk_at_least() & 1) == 0
    && !v13
    && MIMEType
    && _findCanonicalString(MIMEType, 0xBu) == 502471272)
  {
    v14 = -[_CFURLRequest _inner](a2, "_inner");
    v15 = *(const void **)(v14 + 16);
    if (v15)
      CFRelease(v15);
    MIMEType = 0;
    *(_QWORD *)(v14 + 16) = 0;
  }
  v16 = *(const __CFString **)(-[_CFURLRequest _inner](a2, "_inner") + 16);
  if (v16 && CFStringFind(v16, CFSTR("/"), 0).location == -1)
  {
    v21 = -[_CFURLRequest _inner](a2, "_inner");
    v22 = *(const void **)(v21 + 16);
    if (v22)
      CFRelease(v22);
    *(_QWORD *)(v21 + 16) = 0;
    if (!HTTPSniffing::shouldFullySniffProtocol((uint64_t)this, a2, v20))
      return 1;
LABEL_29:
    if ((v8 & 1) != 0)
      return 1;
    if (v13)
      return 0;
    v24 = URLResponse::getMIMEType((URLResponse *)-[_CFURLRequest _inner](a2, "_inner"));
    if (!v24)
      return 1;
    v25 = v24;
    if (!CFStringGetLength(v24))
      return 1;
    CanonicalString = _findCanonicalString(v25, 0xBu);
    v8 = 0;
    if (CanonicalString > 528563039)
    {
      if (CanonicalString > 541154223)
      {
        if (CanonicalString == 546438101 || CanonicalString == 545332176)
          return 1;
        if (CanonicalString != 541154224)
          return v8;
        TextEncodingName = (const __CFString *)CFURLResponseGetTextEncodingName(a2);
        if (!TextEncodingName)
          return 1;
        v29 = _findCanonicalString(TextEncodingName, 8u);
        return v29 == 461420664 || v29 == 434198364;
      }
      if (CanonicalString == 528563040 || CanonicalString == 532880247)
        return 1;
      v27 = 539048867;
    }
    else if (CanonicalString > 524368714)
    {
      if (CanonicalString == 524368715 || CanonicalString == 525417296)
        return 1;
      v27 = 526474069;
    }
    else
    {
      if (CanonicalString == 494959143 || CanonicalString == 507673245)
        return 1;
      v27 = 518126373;
    }
    if (CanonicalString != v27)
      return v8;
    return 1;
  }
  if (HTTPSniffing::shouldFullySniffProtocol((uint64_t)this, a2, v17))
    goto LABEL_29;
  if (!MIMEType)
    return 1;
  if (_findCanonicalString(MIMEType, 0xBu) == 502471272)
  {
    v18 = -[_CFURLRequest _inner](a2, "_inner");
    v19 = *(const void **)(v18 + 16);
    if (v19)
      CFRelease(v19);
    *(_QWORD *)(v18 + 16) = 0;
    return 1;
  }
  return v8;
}

__CFString *URLResponse::getMIMEType(URLResponse *this)
{
  HTTPResponse *fHTTP;
  __CFString *fMIMEType;
  URLResponse *HeaderFieldValue;
  const __CFString *v5;
  URLResponse *v6;

  fHTTP = this->fHTTP;
  if (fHTTP && (*(_WORD *)((char *)fHTTP + 297) & 0x200) == 0)
  {
    fMIMEType = this->fMIMEType;
    if (fMIMEType)
    {
      CFRelease(fMIMEType);
      this->fMIMEType = 0;
      fHTTP = this->fHTTP;
    }
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    HeaderFieldValue = (URLResponse *)HTTPMessage::copyLastHeaderFieldValue((HTTPMessage *)fHTTP, 0x11F192E0u);
    if (HeaderFieldValue)
    {
      v6 = HeaderFieldValue;
      this->fMIMEType = (__CFString *)URLResponse::copyMIMETypeFromContentHeader(HeaderFieldValue, v5);
      CFRelease(v6);
    }
    *(_WORD *)((char *)this->fHTTP + 297) |= 0x200u;
  }
  return this->fMIMEType;
}

CFStringRef HTTPMessage::copyLastHeaderFieldValue(HTTPMessage *a1, unsigned int a2)
{
  uint64_t v4;
  const __CFAllocator *v5;
  CFTypeRef v6;
  const __CFArray *Value;
  const __CFArray *v8;
  CFIndex Count;
  const __CFString *ValueAtIndex;
  CFStringRef Copy;
  void (**v13)(StringSerializable *__hidden);
  CFTypeRef cf;

  HTTPMessage::ensureParserFinished(a1);
  v4 = HTTPMessage::headers((os_unfair_lock_s *)a1);
  v5 = CFGetAllocator((char *)a1 - 16);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(&v13, a2);
  CFGetAllocator((CFTypeRef)(v4 - 16));
  if (cf)
    v6 = CFRetain(cf);
  else
    v6 = 0;
  Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 8), v6);
  v8 = Value;
  if (!Value || (Count = CFArrayGetCount(Value), Count < 1))
  {
    Copy = 0;
    if (!v6)
      goto LABEL_10;
    goto LABEL_9;
  }
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, Count - 1);
  Copy = CFStringCreateCopy(v5, ValueAtIndex);
  if (v6)
LABEL_9:
    CFRelease(v6);
LABEL_10:
  v13 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  return Copy;
}

void sub_183F89CF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t HTTPSniffing::shouldFullySniffProtocol(uint64_t this, _CFURLRequest *a2, _CFURLResponse *a3)
{
  const __CFURL *v4;
  const __CFString *v5;
  const __CFString *v6;
  int CanonicalString;
  int v8;

  if (!a2 || !*(_QWORD *)(-[_CFURLRequest _inner](a2, "_inner", a3) + 88))
  {
    if (!this)
      return this;
    v4 = *(const __CFURL **)(objc_msgSend((id)this, "_inner", a3) + 8);
    if (!v4)
      return 0;
    v5 = CFURLCopyScheme(v4);
    if (!v5)
      return 0;
    v6 = v5;
    CanonicalString = _findCanonicalString(v5, 0xFu);
    this = 1;
    if (CanonicalString > 587242914)
    {
      if (CanonicalString != 587242915)
      {
        v8 = 588299686;
LABEL_13:
        if (CanonicalString != v8)
          this = 0;
      }
    }
    else if (CanonicalString != 583048600)
    {
      v8 = 585137566;
      goto LABEL_13;
    }
    CFRelease(v6);
    return this;
  }
  return 1;
}

uint64_t CFCachedURLResponseCreateWithUserInfo(uint64_t a1, const void *a2, const void *a3, const void *a4, int a5)
{
  uint64_t Instance;
  uint64_t v10;
  CFTypeRef v11;
  const void *v13[6];

  v13[5] = *(const void **)MEMORY[0x1E0C80C00];
  v13[0] = (const void *)MEMORY[0x1E0C809B0];
  v13[1] = (const void *)3221225472;
  v13[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2382;
  v13[3] = &__block_descriptor_40_e5_v8__0l;
  v13[4] = _CachedURLResponseRegisterClass;
  if (_CFCachedURLResponseClassRegistration != -1)
    dispatch_once(&_CFCachedURLResponseClassRegistration, v13);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v10 = operator new();
    *(_QWORD *)v10 = &off_1E14EC248;
    v11 = CFRetain(a2);
    *(_QWORD *)(v10 + 40) = 0;
    *(_QWORD *)(v10 + 32) = v11;
    *(_QWORD *)(v10 + 48) = 0;
    *(_QWORD *)(v10 + 72) = 0;
    *(_QWORD *)(v10 + 80) = 0;
    *(_QWORD *)(v10 + 64) = 0;
    *(_DWORD *)(v10 + 88) = 0;
    *(_QWORD *)(v10 + 104) = 0;
    *(_QWORD *)(v10 + 112) = 0;
    *(_QWORD *)(v10 + 96) = 0;
    if (a4)
      *(_QWORD *)(v10 + 40) = CFRetain(a4);
    if (a3)
    {
      v13[0] = a3;
      *(_QWORD *)(v10 + 72) = CFRetain(a3);
      *(_QWORD *)(v10 + 80) = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v13, 1, MEMORY[0x1E0C9B378]);
    }
    *(_DWORD *)(v10 + 56) = a5;
    *(_BYTE *)(v10 + 120) = 0;
    *(_QWORD *)(v10 + 128) = 0;
    *(_QWORD *)(v10 + 8) = 0;
    *(_QWORD *)(v10 + 16) = 0;
    __CFCachedURLResponse::Encode((__CFCachedURLResponse *)v10);
    *(_QWORD *)(Instance + 16) = v10;
  }
  return Instance;
}

void sub_183F8A170(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10E1C40D8EAFA61);
  _Unwind_Resume(a1);
}

CFIndex __CFCachedURLResponse::EncodeReceiverData(__CFCachedURLResponse *this)
{
  CFIndex result;
  CFIndex v3;
  const __CFArray *v4;
  CFIndex v5;
  CFIndex v6;
  const __CFData *ValueAtIndex;

  *((_QWORD *)this + 12) = 0;
  result = *((_QWORD *)this + 9);
  if (result)
  {
    result = CFDataGetLength((CFDataRef)result);
    v3 = result;
LABEL_3:
    *((_QWORD *)this + 12) = v3;
    return result;
  }
  v4 = (const __CFArray *)*((_QWORD *)this + 10);
  if (v4)
  {
    result = CFArrayGetCount(*((CFArrayRef *)this + 10));
    if (result < 1)
    {
      v3 = 0;
    }
    else
    {
      v5 = result;
      v6 = 0;
      v3 = 0;
      do
      {
        ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v4, v6);
        result = CFDataGetLength(ValueAtIndex);
        v3 += result;
        ++v6;
      }
      while (v5 != v6);
    }
    goto LABEL_3;
  }
  return result;
}

void __CFCachedURLResponse::Encode(__CFCachedURLResponse *this)
{
  __CFWriteStream *v2;
  __CFWriteStream *v3;
  const void *v4;
  CFIndex v5;
  BOOL v6;
  const __CFData *v7;
  CFErrorRef error;

  if (*((_QWORD *)this + 5))
  {
    v2 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
    if (v2)
    {
      v3 = v2;
      if (!CFWriteStreamOpen(v2))
      {
LABEL_15:
        CFRelease(v3);
        goto LABEL_16;
      }
      v4 = (const void *)*((_QWORD *)this + 5);
      if (v4)
      {
        error = 0;
        v5 = CFPropertyListWrite(v4, v3, kCFPropertyListXMLFormat_v1_0, 0, &error);
        if (v5)
          v6 = 1;
        else
          v6 = error == 0;
        if (!v6)
        {
          CFErrorCopyDescription(error);
          CFRelease(error);
          goto LABEL_15;
        }
        if (!v5 || CFWriteStreamWrite(v3, byte_18411E1F8, 1) != 1)
          goto LABEL_15;
        *((_QWORD *)this + 6) = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
      }
      CFRelease(v3);
      v7 = (const __CFData *)*((_QWORD *)this + 6);
      if (v7)
        CFDataGetLength(v7);
    }
  }
LABEL_16:
  if (*((_QWORD *)this + 9) || *((_QWORD *)this + 10))
    __CFCachedURLResponse::EncodeReceiverData(this);
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidReceiveResponse(SessionConnectionLoadable *this, _CFURLResponse *a2)
{
  return objc_msgSend(this->var2, "_didReceiveResponse:sniff:", +[NSURLResponse _responseWithCFURLResponse:](NSHTTPURLResponse, "_responseWithCFURLResponse:", a2), 1);
}

const __CFString *URLResponse::copyMIMETypeFromContentHeader(URLResponse *this, const __CFString *a2)
{
  const __CFAllocator *v3;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v5;
  uint64_t Count;
  const __CFString *ValueAtIndex;
  const __CFString *v8;
  uint64_t v9;
  __CFArray *Mutable;
  CFIndex v11;
  const __CFString *v12;
  __CFString *v13;
  __CFString *v14;
  CFIndex v15;
  CFIndex v16;
  CFIndex v17;
  CFIndex Length;
  CFIndex v19;
  CFRange v21;
  CFRange v22;

  v3 = CFGetAllocator(this);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v3, (CFStringRef)this, CFSTR(","));
  if (!ArrayBySeparatingStrings)
    return 0;
  v5 = ArrayBySeparatingStrings;
  Count = CFArrayGetCount(ArrayBySeparatingStrings);
  if (Count == 1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, 0);
    v8 = copyMIMETypeFromContentTypeComponent(ValueAtIndex);
  }
  else
  {
    v9 = Count;
    if (Count < 2)
    {
      v8 = 0;
    }
    else
    {
      Mutable = CFArrayCreateMutable(v3, Count, MEMORY[0x1E0C9B378]);
      v11 = 0;
      do
      {
        v12 = (const __CFString *)CFArrayGetValueAtIndex(v5, v11);
        v13 = copyMIMETypeFromContentTypeComponent(v12);
        if (v13)
        {
          v14 = v13;
          CFArrayAppendValue(Mutable, v13);
          CFRelease(v14);
        }
        ++v11;
      }
      while (v9 != v11);
      v15 = CFArrayGetCount(Mutable);
      if (v15 < 1)
      {
        v8 = 0;
      }
      else
      {
        v16 = v15;
        v17 = 0;
        while (1)
        {
          v8 = (const __CFString *)CFArrayGetValueAtIndex(Mutable, v17);
          Length = CFStringGetLength((CFStringRef)&unk_1EDCFFFF0);
          if (CFStringGetLength(v8) < Length
            || (v21.location = 0,
                v21.length = Length,
                CFStringCompareWithOptions(v8, (CFStringRef)&unk_1EDCFFFF0, v21, 1uLL)))
          {
            v19 = CFStringGetLength((CFStringRef)&unk_1EDCFF7A0);
            if (CFStringGetLength(v8) < v19
              || (v22.location = 0,
                  v22.length = v19,
                  CFStringCompareWithOptions(v8, (CFStringRef)&unk_1EDCFF7A0, v22, 1uLL)))
            {
              if (CFStringFind(v8, CFSTR("/"), 0).location != -1)
                break;
            }
          }
          if (v16 == ++v17)
            goto LABEL_22;
        }
        if (v8)
          goto LABEL_23;
LABEL_22:
        v8 = (const __CFString *)CFArrayGetValueAtIndex(Mutable, 0);
        if (!v8)
          goto LABEL_24;
LABEL_23:
        CFRetain(v8);
      }
LABEL_24:
      CFRelease(Mutable);
    }
  }
  CFRelease(v5);
  return v8;
}

__CFString *copyMIMETypeFromContentTypeComponent(const __CFString *a1)
{
  uint64_t Length;
  const __CFCharacterSet *Predefined;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v6;
  uint64_t v7;
  CFIndex v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  UniChar v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFAllocator *v21;
  __CFString *MutableCopy;
  __CFString *v23;
  UniChar v25[64];
  CFStringRef theString;
  const UniChar *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CFRange v33;
  CFRange v34;
  CFRange v35;

  Length = CFStringGetLength(a1);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  theString = a1;
  v29 = 0;
  v30 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v27 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v31 = 0;
  v32 = 0;
  v28 = CStringPtr;
  if (Length < 1)
    return 0;
  v6 = 0;
  v7 = 0;
  v8 = -1;
  v9 = 64;
  v10 = -1;
  while (1)
  {
    v11 = (unint64_t)v7 >= 4 ? 4 : v7;
    v12 = v30;
    if (v30 > v7)
      break;
    v13 = 0;
LABEL_25:
    if (CFCharacterSetIsCharacterMember(Predefined, v13))
    {
      v20 = -1;
    }
    else
    {
      v10 = v7;
      v20 = v7;
    }
    if (v8 == -1)
      v8 = v20;
    ++v7;
    --v6;
    ++v9;
    if (Length == v7)
      goto LABEL_31;
  }
  if (v27)
  {
    v13 = v27[v7 + v29];
  }
  else if (v28)
  {
    v13 = v28[v29 + v7];
  }
  else
  {
    v14 = v31;
    if (v32 <= v7 || v31 > v7)
    {
      v16 = v11 + v6;
      v17 = v9 - v11;
      v18 = v7 - v11;
      v19 = v18 + 64;
      if (v18 + 64 >= v30)
        v19 = v30;
      v31 = v18;
      v32 = v19;
      if (v30 >= v17)
        v12 = v17;
      v33.length = v12 + v16;
      v33.location = v18 + v29;
      CFStringGetCharacters(theString, v33, v25);
      v14 = v31;
    }
    v13 = v25[v7 - v14];
  }
  if (v13 != 59)
    goto LABEL_25;
LABEL_31:
  if (v8 == -1)
    return 0;
  v21 = CFGetAllocator(a1);
  MutableCopy = CFStringCreateMutableCopy(v21, Length, a1);
  v23 = MutableCopy;
  if (v10 != Length - 1)
  {
    v34.location = v10 + 1;
    v34.length = Length + ~v10;
    CFStringDelete(MutableCopy, v34);
  }
  if (v8 >= 1)
  {
    v35.location = 0;
    v35.length = v8;
    CFStringDelete(v23, v35);
  }
  CFStringLowercase(v23, 0);
  return v23;
}

void ___ZN19URLConnectionLoader41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke_3(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 40))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidReceiveChallenge(SessionConnectionLoadable *this, _CFURLAuthChallenge *a2)
{
  return objc_msgSend(this->var2, "_didReceiveChallenge:", +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:](NSURLAuthenticationChallenge, "_authenticationChallengeForCFAuthChallenge:sender:", a2, this->var2));
}

void sub_183F8ADE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

BOOL isSessionChallenge(NSURLAuthenticationChallenge *a1)
{
  NSString *v1;

  v1 = -[NSURLProtectionSpace authenticationMethod](-[NSURLAuthenticationChallenge protectionSpace](a1, "protectionSpace"), "authenticationMethod");
  return -[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodNTLM"))
      || -[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodNegotiate"))
      || -[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodClientCertificate"))
      || -[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("NSURLAuthenticationMethodServerTrust"));
}

uint64_t ___ZN19URLConnectionLoader23protocolDidSendBodyDataExxx_block_invoke_2(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  __int128 v3;
  uint64_t v4;

  if (a2)
  {
    v2 = *(_QWORD *)(result + 48);
    v3 = *(_OWORD *)(result + 32);
    v4 = v2;
    return (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)a2 + 88))(a2, &v3);
  }
  return result;
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidSendBodyData(SessionConnectionLoadable *this, UploadProgressInfo *a2)
{
  void **var2;
  UploadProgressInfo v4;

  var2 = this->var2;
  v4 = *a2;
  return objc_msgSend(var2, "_didSendBodyData:", &v4);
}

void sub_183F8BD68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

dispatch_object_t createDispatchDataFromDataArray(NSArray *a1)
{
  dispatch_object_t result;
  dispatch_object_t v3;
  uint64_t v4;
  dispatch_object_t i;
  NSObject *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  dispatch_object_t v11;
  _BYTE v12[128];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  result = (dispatch_object_t)-[NSArray countByEnumeratingWithState:objects:count:](a1, "countByEnumeratingWithState:objects:count:", &v7, v12, 16);
  if (result)
  {
    v3 = result;
    v4 = *(_QWORD *)v8;
    do
    {
      for (i = 0; i != v3; i = (dispatch_object_t)((char *)i + 1))
      {
        if (*(_QWORD *)v8 != v4)
          objc_enumerationMutation(a1);
        v6 = objc_msgSend(*(id *)(*((_QWORD *)&v7 + 1) + 8 * (_QWORD)i), "_createDispatchData");
        conCatData(&v11, v6);
        dispatch_release(v6);
      }
      v3 = (dispatch_object_t)-[NSArray countByEnumeratingWithState:objects:count:](a1, "countByEnumeratingWithState:objects:count:", &v7, v12, 16);
    }
    while (v3);
    return v11;
  }
  return result;
}

void ___ZN19URLConnectionLoader16loadWithWhatToDoEP12NSURLRequestPK20_CFCachedURLResponselNS_8WhatToDoE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 96))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_HandleCacheResponseIsValid(SessionConnectionLoadable *this, const _CFCachedURLResponse *a2)
{
  return SessionConnectionLoadable::_loaderClientEvent_HandleCacheResponseIsValid((SessionConnectionLoadable *)((char *)this - 8), a2);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_HandleCacheResponseIsValid(SessionConnectionLoadable *this, const _CFCachedURLResponse *a2)
{
  uint64_t v4;
  CFTypeRef v5;
  const void *v6;

  objc_msgSend(this->var3, "_didUseCachedResponse");
  if (a2)
    v4 = *((_QWORD *)a2->var1 + 4);
  else
    v4 = 0;
  (*((void (**)(SessionConnectionLoadable *, uint64_t))this->var0 + 16))(this, v4);
  v5 = CFCachedURLResponseCopyReceiverDataArray((uint64_t)a2);
  if (v5)
  {
    v6 = v5;
    (*((void (**)(SessionConnectionLoadable *, CFTypeRef, _QWORD))this->var0 + 17))(this, v5, 0);
    CFRelease(v6);
  }
  return (*((uint64_t (**)(SessionConnectionLoadable *))this->var0 + 20))(this);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidReceiveResponse(SessionConnectionLoadable *this, _CFURLResponse *a2)
{
  return objc_msgSend(this->var3, "_didReceiveResponse:sniff:", +[NSURLResponse _responseWithCFURLResponse:](NSHTTPURLResponse, "_responseWithCFURLResponse:", a2), 1);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidFinishLoading(SessionConnectionLoadable *this)
{
  return objc_msgSend(this->var3, "_didFinishWithError:", 0);
}

void sub_183F8C248(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void URLResponse::guessMIMEType(URLResponse *this, const __CFData *a2)
{
  __CFString *fMIMEType;
  int CanonicalString;
  int v6;
  __CFString *v7;
  const void *MIMETypeForRuleArray;
  const __CFString *v9;
  CFIndex v10;
  uint64_t v11;
  const UInt8 *v12;
  const UInt8 *v13;
  uint64_t v14;
  const __CFString *v15;
  const UInt8 *v16;
  uint64_t v18;
  const UInt8 *v19;
  int v21;
  int v22;
  int v23;
  uint64_t v25;
  int v27;
  int v28;
  int v30;
  int v31;
  const __CFString *v34;
  uint64_t *v35;
  CFIndex Length;
  uint64_t v37;
  const UInt8 *BytePtr;
  const __CFData *MIMETypeForComplexNonScriptableTypeRules;
  __CFURL *fURL;
  const __CFString *v41;
  const __CFString *v42;
  int v43;
  const __CFString *v44;
  const __CFString *v45;
  const __CFString *v46;
  __CFURL *v47;
  const __CFString *v48;
  const __CFString *v49;
  __CFString *v50;
  __CFString *v51;
  __CFString *v52;
  uint8_t v53[16];

  fMIMEType = this->fMIMEType;
  if (!fMIMEType || !CFStringGetLength(fMIMEType))
    goto LABEL_36;
  CanonicalString = _findCanonicalString(this->fMIMEType, 0xBu);
  if (CanonicalString <= 528563039)
  {
    if (CanonicalString <= 524368714)
    {
      if (CanonicalString != 494959143 && CanonicalString != 507673245)
      {
        v6 = 518126373;
        goto LABEL_22;
      }
LABEL_36:
      v15 = (const __CFString *)copyMIMETypeForUnknown(a2);
LABEL_134:
      v9 = v15;
      goto LABEL_135;
    }
    if (CanonicalString != 524368715 && CanonicalString != 525417296 && CanonicalString != 526474069)
    {
LABEL_120:
      MIMETypeForRuleArray = this->fMIMEType;
      if (MIMETypeForRuleArray)
        goto LABEL_133;
      goto LABEL_18;
    }
LABEL_15:
    v7 = this->fMIMEType;
    MIMETypeForRuleArray = getMIMETypeForRuleArray(a2, sImageTypeRules, 0);
    if (!MIMETypeForRuleArray)
      MIMETypeForRuleArray = v7;
    if (MIMETypeForRuleArray)
      goto LABEL_133;
LABEL_18:
    v9 = 0;
    goto LABEL_135;
  }
  if (CanonicalString > 541154223)
  {
    if (CanonicalString != 541154224)
    {
      if (CanonicalString == 546438101)
        goto LABEL_36;
      v6 = 545332176;
      goto LABEL_22;
    }
    if (!a2)
    {
      MIMETypeForRuleArray = &unk_1EDD00108;
      goto LABEL_133;
    }
    Length = CFDataGetLength(a2);
    if (Length >= 512)
      v37 = 512;
    else
      v37 = Length;
    BytePtr = CFDataGetBytePtr(a2);
    if (v37 > 2)
    {
      if (*(__int16 *)BytePtr == -2 || *(__int16 *)BytePtr == -257)
      {
        MIMETypeForComplexNonScriptableTypeRules = (const __CFData *)&unk_1EDD00108;
      }
      else
      {
        MIMETypeForComplexNonScriptableTypeRules = (const __CFData *)&unk_1EDD00108;
        if (*(unsigned __int16 *)BytePtr ^ 0xBBEF | BytePtr[2] ^ 0xBF)
          goto LABEL_126;
      }
LABEL_130:
      if (MIMETypeForComplexNonScriptableTypeRules)
        MIMETypeForRuleArray = MIMETypeForComplexNonScriptableTypeRules;
      else
        MIMETypeForRuleArray = &unk_1EDCFF8F0;
      goto LABEL_133;
    }
    MIMETypeForComplexNonScriptableTypeRules = (const __CFData *)&unk_1EDD00108;
LABEL_126:
    if (!isAllText(a2))
    {
      MIMETypeForComplexNonScriptableTypeRules = getMIMETypeForRuleArray(a2, sNonScriptableTypeRules, 0);
      if (!MIMETypeForComplexNonScriptableTypeRules)
      {
        MIMETypeForComplexNonScriptableTypeRules = getMIMETypeForRuleArray(a2, sImageTypeRules, 0);
        if (!MIMETypeForComplexNonScriptableTypeRules)
          MIMETypeForComplexNonScriptableTypeRules = (const __CFData *)getMIMETypeForComplexNonScriptableTypeRules(a2);
      }
    }
    goto LABEL_130;
  }
  if (CanonicalString == 528563040 || CanonicalString == 532880247)
    goto LABEL_15;
  v6 = 539048867;
LABEL_22:
  if (CanonicalString != v6)
    goto LABEL_120;
  if (this->fMIMEType)
    v9 = this->fMIMEType;
  else
    v9 = (const __CFString *)&unk_1EDD00098;
  if (!a2)
    goto LABEL_109;
  v10 = CFDataGetLength(a2);
  if (v10 >= 512)
    v11 = 512;
  else
    v11 = v10;
  v12 = CFDataGetBytePtr(a2);
  v13 = v12;
  if (v11 >= 3 && *v12 == 239 && v12[1] == 187)
  {
    if (v12[2] == 191)
      v14 = 3;
    else
      v14 = 0;
  }
  else
  {
    v14 = 0;
  }
  if (v14 >= v11)
    goto LABEL_106;
  v16 = v12 + 2;
  while (1)
  {
    while (1)
    {
      if ((char)v12[v14] <= 0x20 && ((1 << v12[v14]) & 0x100002600) != 0)
      {
        v18 = v14 + 1;
        goto LABEL_45;
      }
      if (v12[v14] != 60 || v14 + 3 >= v11)
        goto LABEL_106;
      v18 = v14 + 1;
      v19 = &v12[v14 + 1];
      if (*(_WORD *)v19 != 11553 || v19[2] != 45)
        break;
      if (v14 + 6 >= v11)
        goto LABEL_106;
      v14 += 4;
      while (*(_WORD *)&v12[v14] != 11565 || v12[v14 + 2] != 62)
      {
        v25 = v14 + 3;
        ++v14;
        if (v25 >= v11)
          goto LABEL_106;
      }
LABEL_57:
      v14 += 3;
LABEL_61:
      if (v14 >= v11)
        goto LABEL_106;
    }
    v21 = *v19;
    if (v21 == 33)
    {
      do
      {
        if (v14 + 2 >= v11)
          goto LABEL_106;
        v23 = v16[v14++];
      }
      while (v23 != 62);
      v14 += 2;
      goto LABEL_61;
    }
    if (v21 == 63)
    {
      while (v14 + 3 < v11)
      {
        v22 = *(unsigned __int16 *)&v16[v14++];
        if (v22 == 15935)
          goto LABEL_57;
      }
LABEL_106:
      v34 = 0;
      goto LABEL_107;
    }
    if (*(_WORD *)v19 == 29554 && v19[2] == 115)
      break;
    if (v14 + 4 >= v11)
      goto LABEL_106;
    if (*(_DWORD *)v19 == 1684366694)
    {
      v35 = &kCFMIMETypeApplicationAtomXML;
      goto LABEL_169;
    }
    if (v14 + 7 >= v11)
      goto LABEL_106;
    v27 = *(_DWORD *)v19;
    v28 = *(_DWORD *)(v19 + 3);
    if (v27 == 979788914 && v28 == 1178882618)
    {
      v30 = 0;
      v31 = 0;
      while (1)
      {
        if (v31)
        {
          v31 = 1;
        }
        else
        {
          if (v18 + 23 >= v11)
            goto LABEL_106;
          if (*(_QWORD *)&v13[v18] == 0x702F2F3A70747468
            && *(_QWORD *)&v13[v18 + 8] == 0x2F67726F2E6C7275
            && *(_QWORD *)&v13[v18 + 16] == 0x2F302E312F737372)
          {
            v31 = 1;
            v18 += 23;
          }
          else
          {
            v31 = 0;
          }
        }
        if (v30)
        {
          if (v31)
            goto LABEL_105;
        }
        else
        {
          if (v18 + 42 >= v11)
            goto LABEL_106;
          if (memcmp(&v13[v18], "http://www.w3.org/1999/02/22-rdf-syntax-ns#", 0x2BuLL))
          {
            v30 = 0;
            goto LABEL_102;
          }
          v18 += 42;
          if (v31)
            goto LABEL_105;
        }
        v30 = 1;
LABEL_102:
        v34 = 0;
        if (++v18 >= v11)
          goto LABEL_107;
      }
    }
LABEL_45:
    v14 = v18;
    if (v18 >= v11)
      goto LABEL_106;
  }
LABEL_105:
  v35 = &kCFMIMETypeApplicationRSSXML;
LABEL_169:
  v34 = (const __CFString *)*v35;
LABEL_107:
  if (v34)
    v9 = v34;
LABEL_109:
  if (v9)
  {
    MIMETypeForRuleArray = v9;
LABEL_133:
    v15 = (const __CFString *)CFRetain(MIMETypeForRuleArray);
    goto LABEL_134;
  }
LABEL_135:
  fURL = this->fURL;
  if (fURL)
  {
    v41 = CFURLCopyScheme(fURL);
    if (v41)
    {
      v42 = v41;
      if (_findCanonicalString(v41, 0xFu) != 585137566)
        goto LABEL_151;
      v43 = _findCanonicalString(v9, 0xBu);
      if (v43 != 541154224 && v43 != 502471272)
        goto LABEL_151;
      v44 = URLResponse::copySuggestedFilename(this);
      if (v44)
      {
        v45 = v44;
        v46 = copyExtensionFromName(v44);
        CFRelease(v45);
        if (!v46)
        {
LABEL_151:
          CFRelease(v42);
          goto LABEL_152;
        }
      }
      else
      {
        v47 = this->fURL;
        if (!v47)
          goto LABEL_151;
        v46 = _CFURLCopyPathExtension_WorksWithMoreSchemes(v47);
        if (!v46)
          goto LABEL_151;
      }
      if (CFStringGetLength(v46) >= 1 && (v48 = copyMIMETypeForExtension(v46)) != 0)
      {
        v49 = v48;
        if (v9)
          CFRelease(v9);
      }
      else
      {
        v49 = v9;
      }
      CFRelease(v46);
      v9 = v49;
      goto LABEL_151;
    }
  }
LABEL_152:
  if (!v9)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v53 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Sniffing on a resource resulted in a NULL MIME type, which means the sniffing algorithm was coded incorrectly", v53, 2u);
    }
    v50 = this->fMIMEType;
    if (!v50)
      v50 = (__CFString *)&unk_1EDCFF8F0;
    v9 = (const __CFString *)CFRetain(v50);
  }
  v51 = this->fMIMEType;
  if (v51 != v9)
  {
    if (v51)
      CFRelease(v51);
    if (v9)
      v52 = (__CFString *)CFRetain(v9);
    else
      v52 = 0;
    this->fMIMEType = v52;
  }
  if (v9)
    CFRelease(v9);
}

void ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  _QWORD v8[5];

  if (a2)
  {
    v3 = *(_QWORD *)(a1 + 40);
    if (!*(_BYTE *)(v3 + 25))
    {
      (*(void (**)(_QWORD))(**(_QWORD **)(v3 + 32) + 64))(*(_QWORD *)(v3 + 32));
      v5 = *(_QWORD *)(a1 + 32);
      v6 = *(_QWORD *)(a1 + 48);
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 3221225472;
      v8[2] = ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_4;
      v8[3] = &__block_descriptor_40_e22_v16__0__NSURLRequest_8l;
      v8[4] = v3;
      (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a2 + 24))(a2, v5, v6, v8);
    }
  }
  v7 = *(const void **)(a1 + 32);
  if (v7)
    CFRelease(v7);

}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForRedirection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForRedirection(a1 - 8, a2, a3, a4);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForRedirection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v7;
  void *v8;
  _QWORD v10[5];

  if (a3)
    v7 = +[NSURLResponse _responseWithCFURLResponse:](NSHTTPURLResponse, "_responseWithCFURLResponse:");
  else
    v7 = 0;
  v8 = *(void **)(a1 + 24);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN25SessionConnectionLoadable48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke;
  v10[3] = &unk_1E14F9A58;
  v10[4] = a4;
  return objc_msgSend(v8, "_redirectRequest:redirectResponse:completion:", a2, v7, v10);
}

void sub_183F8D0AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

CFTypeRef copyMIMETypeForUnknown(const __CFData *a1)
{
  const __CFData *MIMETypeForRuleArray;

  if (a1)
  {
    MIMETypeForRuleArray = getMIMETypeForRuleArray(a1, sScriptableTypeRules, 1);
    if (!MIMETypeForRuleArray)
    {
      MIMETypeForRuleArray = getMIMETypeForRuleArray(a1, sNonScriptableTypeRules, 1);
      if (!MIMETypeForRuleArray)
      {
        MIMETypeForRuleArray = getMIMETypeForRuleArray(a1, sImageTypeRules, 1);
        if (!MIMETypeForRuleArray)
        {
          MIMETypeForRuleArray = (const __CFData *)getMIMETypeForComplexNonScriptableTypeRules(a1);
          if (!MIMETypeForRuleArray)
          {
            if (isAllText(a1))
              MIMETypeForRuleArray = (const __CFData *)&unk_1EDD00108;
            else
              MIMETypeForRuleArray = 0;
          }
        }
      }
    }
    if (!MIMETypeForRuleArray)
      MIMETypeForRuleArray = (const __CFData *)&unk_1EDCFF8F0;
  }
  else
  {
    MIMETypeForRuleArray = (const __CFData *)&unk_1EDD00108;
  }
  return CFRetain(MIMETypeForRuleArray);
}

const __CFData *getMIMETypeForRuleArray(const __CFData *result, _QWORD *a2, int a3)
{
  const __CFData *v5;
  CFIndex Length;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  const UInt8 *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  const UInt8 *BytePtr;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  int v26;

  if (result)
  {
    v5 = result;
    Length = CFDataGetLength(result);
    v25 = Length;
    if (Length >= 512)
      v7 = 512;
    else
      v7 = Length;
    v8 = a2 + 1;
    if (!a2[1])
      return 0;
    v9 = 0;
    v24 = 0;
    v10 = 0;
    v26 = 0;
    if (v7 <= 1)
      v11 = 1;
    else
      v11 = v7;
    v12 = a2;
    while (1)
    {
      v13 = &a2[4 * v9];
      v15 = v13[2];
      v14 = v13 + 2;
      if (v7 >= v15)
      {
        BytePtr = CFDataGetBytePtr(v5);
        v17 = *(unsigned __int8 *)*v8;
        if (v17 == 60)
        {
          if (v26)
          {
            if (!v10)
              goto LABEL_35;
          }
          else
          {
            if (v25 < 1)
              goto LABEL_34;
            v22 = 0;
            while (1)
            {
              v10 = &BytePtr[v22];
              if ((char)BytePtr[v22] > 0x20 || ((1 << BytePtr[v22]) & 0x100003600) == 0)
                break;
              if (v11 == ++v22)
                goto LABEL_34;
            }
            if (BytePtr[v22] != 60)
            {
LABEL_34:
              v10 = 0;
LABEL_35:
              v26 = 1;
              goto LABEL_41;
            }
            v24 = v7 - v22;
          }
          v18 = *v14;
          v26 = 1;
          BytePtr = v10;
          if (v24 < *v14)
            goto LABEL_41;
        }
        else
        {
          v18 = *v14;
        }
        v19 = 0;
        if (v18 >= 1)
        {
          while (1)
          {
            if (a3)
            {
              v20 = BytePtr[v19];
              if (*v12)
                v20 = (*(_BYTE *)(*v12 + v19) & v20);
            }
            else
            {
              v20 = BytePtr[v19];
            }
            v21 = *(unsigned __int8 *)(*v8 + v19);
            if (v17 == 60 && v20 != v21)
              break;
            if (v20 != v21)
              goto LABEL_40;
            if (v18 == ++v19)
              return (const __CFData *)&gConstantCFStringValueTable[7 * ((LODWORD(a2[4 * v9 + 3]) >> 20) & 0x3FF)];
          }
          if (v18 - 1 == v19 && v21 == 32 && (v20 == 32 || v20 == 62))
            return (const __CFData *)&gConstantCFStringValueTable[7 * ((LODWORD(a2[4 * v9 + 3]) >> 20) & 0x3FF)];
        }
LABEL_40:
        if (v19 == v18)
          return (const __CFData *)&gConstantCFStringValueTable[7 * ((LODWORD(a2[4 * v9 + 3]) >> 20) & 0x3FF)];
      }
LABEL_41:
      ++v9;
      v12 = &a2[4 * v9];
      v8 = v12 + 1;
      if (!v12[1])
        return 0;
    }
  }
  return result;
}

uint64_t isAllText(const __CFData *a1)
{
  CFIndex Length;
  uint64_t v3;
  const UInt8 *BytePtr;
  unint64_t v5;
  unsigned int v6;
  BOOL v7;
  BOOL v8;

  Length = CFDataGetLength(a1);
  if (Length < 1)
    return 1;
  if (Length >= 512)
    v3 = 512;
  else
    v3 = Length;
  BytePtr = CFDataGetBytePtr(a1);
  v5 = (unint64_t)&BytePtr[v3 - 1];
  while (1)
  {
    v6 = *BytePtr;
    v7 = (v6 & 0xFC) != 0x1C && v6 >= 9;
    v8 = !v7 || v6 == 11;
    if (v8 || v6 - 14 <= 0xC)
      break;
    if ((unint64_t)++BytePtr > v5)
      return 1;
  }
  return 0;
}

uint64_t getMIMETypeForComplexNonScriptableTypeRules(const __CFData *a1)
{
  CFIndex Length;
  uint64_t v3;
  const UInt8 *BytePtr;
  uint64_t v6;
  _BOOL4 v7;
  _BOOL4 v8;
  int v11;
  uint64_t *v15;
  int v16;
  unsigned int v17;
  uint64_t v18;

  Length = CFDataGetLength(a1);
  if (Length >= 512)
    v3 = 512;
  else
    v3 = Length;
  BytePtr = CFDataGetBytePtr(a1);
  if (v3 < 4)
    goto LABEL_56;
  if (*(_WORD *)BytePtr == 17481 && BytePtr[2] == 51)
  {
    if (*((char *)BytePtr + 3) >= 32)
      v6 = 0;
    else
      v6 = 0x1EDCFFD18;
  }
  else
  {
    v6 = 0;
  }
  v7 = (unint64_t)v3 > 7;
  if (!v6 && (unint64_t)v3 >= 8)
  {
    if (*((_DWORD *)BytePtr + 1) == 1987014509
      || *((_DWORD *)BytePtr + 1) == 1952539757
      || *((_DWORD *)BytePtr + 1) == 1701079415)
    {
      v6 = 0x1EDD00370;
    }
    else
    {
      v6 = 0;
    }
  }
  v8 = (unint64_t)v3 > 0xB;
  if (!v6 && (unint64_t)v3 >= 0xC)
  {
    if (*BytePtr || BytePtr[1] || *((_DWORD *)BytePtr + 1) != 1887007846)
      goto LABEL_25;
    if (*((_WORD *)BytePtr + 4) == 28781 && BytePtr[10] == 52)
    {
      if (BytePtr[11] - 49 >= 2)
        v6 = 0;
      else
        v6 = 0x1EDD00338;
      goto LABEL_26;
    }
    if (*((_WORD *)BytePtr + 4) == 29545 && BytePtr[10] == 111)
    {
      v16 = BytePtr[11];
      if (v16 == 109 || v16 == 50)
      {
        v15 = &kCFMIMETypeVideoMP4;
        goto LABEL_118;
      }
LABEL_25:
      v6 = 0;
LABEL_26:
      v8 = 1;
LABEL_27:
      v7 = 1;
      goto LABEL_28;
    }
    if (*((_WORD *)BytePtr + 4) != 13389 || BytePtr[10] != 86)
    {
      if (*((_DWORD *)BytePtr + 2) == 541144141)
      {
        v15 = &kCFMIMETypeAudioMP4;
        goto LABEL_118;
      }
      if (*((_WORD *)BytePtr + 4) == 26419)
      {
        if (*((_WORD *)BytePtr + 5) == 24882)
        {
          v15 = &kCFMIMETypeVideo3GPP2;
          goto LABEL_118;
        }
        if (BytePtr[10] - 101 <= 0xE
          && (BytePtr[11] & 0xFC) == 0x34
          && (*((_WORD *)BytePtr + 5) == 13925
           || *((_WORD *)BytePtr + 5) == 14181
           || *((_WORD *)BytePtr + 5) == 13927
           || *((_WORD *)BytePtr + 5) == 13424
           || *((_WORD *)BytePtr + 5) == 13680
           || *((_WORD *)BytePtr + 5) == 13936
           || *((_WORD *)BytePtr + 5) == 13938
           || *((_WORD *)BytePtr + 5) == 13939
           || *((_WORD *)BytePtr + 5) == 14195))
        {
          v15 = &kCFMIMETypeVideo3GPP;
LABEL_118:
          v6 = *v15;
          goto LABEL_26;
        }
      }
      goto LABEL_25;
    }
    v6 = 0;
    v8 = 1;
    v17 = BytePtr[11] - 32;
    if (v17 > 0x30)
      goto LABEL_27;
    v18 = 1 << v17;
    v7 = 1;
    if ((v18 & 0x1010000000001) != 0)
      v6 = 0x1EDD00300;
  }
LABEL_28:
  if (!v6 && v8)
  {
    if (*(_DWORD *)BytePtr == 1179011410)
    {
      if (*((_DWORD *)BytePtr + 2) == 1163280727)
      {
        v6 = 0x1EDCFFD50;
      }
      else if (*((_DWORD *)BytePtr + 2) == 541677121)
      {
        v6 = 0x1EDD002C8;
      }
      else
      {
        v6 = 0;
      }
    }
    else
    {
      v6 = 0;
    }
  }
  if (v6)
    v8 = 0;
  if (v8)
  {
    if (*(_DWORD *)BytePtr == 1297239878 && *((_WORD *)BytePtr + 4) == 18753 && BytePtr[10] == 70)
    {
      v11 = BytePtr[11];
      if (v11 == 70 || v11 == 67)
      {
        v6 = 0x1EDCFFCA8;
        goto LABEL_51;
      }
    }
    v6 = 0;
  }
  if (v6 || (unint64_t)v3 < 5)
    goto LABEL_51;
  if (!BytePtr[3] && !BytePtr[4])
  {
    if (BytePtr[1])
    {
      if (BytePtr[1] != 1 || (BytePtr[2] & 0xF7) != 1)
        goto LABEL_50;
    }
    else if ((BytePtr[2] & 0xF6) != 2)
    {
      goto LABEL_50;
    }
    v6 = 0x1EDCFFF10;
    goto LABEL_51;
  }
LABEL_50:
  v6 = 0;
LABEL_51:
  if (v6)
    v7 = 0;
  if (!v7)
    goto LABEL_57;
  if (*((_DWORD *)BytePtr + 1) == 1668506729 || *((_DWORD *)BytePtr + 1) == 1952539753)
  {
    v6 = 0x1EDCFFFB8;
    goto LABEL_62;
  }
LABEL_56:
  v6 = 0;
LABEL_57:
  if (!v6 && v3 >= 2)
  {
    if (*(_WORD *)BytePtr == 759)
      v6 = 0x1EDCFFAB0;
    else
      v6 = 0;
  }
LABEL_62:
  if (v3 >= 4 && !v6)
  {
    if (*(unsigned __int16 *)BytePtr == 55809 && BytePtr[2] <= 1u)
    {
      if (BytePtr[3] - 1 >= 0xF)
        return 0;
      else
        return 0x1EDCFFEA0;
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

void ___ZN19URLConnectionLoader15protocolDidFailEP9__CFError_block_invoke_2(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 112))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidFailWithError(SessionConnectionLoadable *this, __CFError *a2)
{
  return objc_msgSend(this->var2, "_didFinishWithError:", a2);
}

void ___ZN19URLConnectionLoader29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  _QWORD v6[5];

  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    v3 = *(_QWORD *)(a1 + 40);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN19URLConnectionLoader29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke_3;
    v6[3] = &__block_descriptor_40_e22_v16__0__NSURLRequest_8l;
    v6[4] = v4;
    (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a2 + 32))(a2, v3, v6);
  }
  v5 = *(const void **)(a1 + 40);
  if (v5)
    CFRelease(v5);
}

uint64_t `non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForEstablishedConnection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  _QWORD v5[5];

  v3 = *(void **)(a1 + 16);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN25SessionConnectionLoadable58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke;
  v5[3] = &unk_1E14F9A58;
  v5[4] = a3;
  return objc_msgSend(v3, "_willSendRequestForEstablishedConnection:completion:", a2, v5);
}

void sub_183F8DF80(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_183F8E15C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183F8E490(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZN19URLConnectionLoader28protocolCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 96))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

uint64_t ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 72))(*(_QWORD *)(a1 + 40));
}

void ___ZN27URLConnectionLoader_Classic19protocolDidLoadDataEPK8__CFDatax_block_invoke(uint64_t a1)
{
  const void *v2;

  URLConnectionLoader::protocolDidLoadData(*(URLConnectionLoader **)(a1 + 32), *(CFDataRef *)(a1 + 40), *(_QWORD *)(a1 + 48));
  v2 = *(const void **)(a1 + 40);
  if (v2)
    CFRelease(v2);
}

void URLConnectionLoader::protocolDidLoadData(URLConnectionLoader *this, CFDataRef theData, uint64_t a3)
{
  RedirectionRecorder *var12;
  CFIndex Length;
  uint64_t v7;
  double v8;
  uint64_t v9;
  const __CFAllocator *v10;
  const void *v11;
  double v12;
  uint64_t v13;
  __CFArray *Array;
  InterfaceRequiredForLoader *var5;
  _QWORD v16[6];
  void (**v17)(AutoString *__hidden);
  CFStringRef v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (theData && this->var21)
  {
    var12 = this->var12;
    if (var12)
    {
      (*(void (**)(RedirectionRecorder *, CFDataRef, uint64_t))(*(_QWORD *)var12 + 112))(var12, theData, a3);
    }
    else
    {
      Length = CFDataGetLength(theData);
      v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_24_9629, 2);
      if (v7)
      {
        v9 = v7;
        if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v7 + 16))(v7, "Load Data", 0))
        {
          v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v11 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))this->var0 + 3))(this);
          v17 = &off_1E14E4818;
          v19 = 0;
          v20 = 0;
          v18 = CFStringCreateWithCString(v10, "Loader", 0x8000100u);
          (*(void (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)v9 + 64))(v9, v18, v11);
          AutoString::~AutoString((AutoString *)&v17);
          if (v11)
            CFRelease(v11);
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v9 + 72))(v9, "Length", CFSTR("%ld"));
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v9 + 72))(v9, "Original Length", CFSTR("%lld"));
          (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
        }
      }
      this->var27 += Length;
      if (this->var35)
        entr_act_modify_delayInitStub(v8);
      v12 = URLConnectionLoader::touchConnection(this);
      if (Length)
      {
        if (this->var36)
        {
          v13 = -[__CFData _createDispatchData](theData, "_createDispatchData", v12);
          Array = 0;
        }
        else
        {
          Array = cfTypeCreateArray(this->var1, v12, theData, 0);
          v13 = 0;
        }
        var5 = this->var5;
        v16[0] = MEMORY[0x1E0C809B0];
        v16[1] = 3221225472;
        v16[2] = ___ZN19URLConnectionLoader19protocolDidLoadDataEPK8__CFDatax_block_invoke_32;
        v16[3] = &unk_1E14FACE8;
        v16[4] = v13;
        v16[5] = Array;
        (*(void (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v16);
      }
    }
  }
}

void sub_183F8E954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

CFAbsoluteTime URLConnectionLoader::touchConnection(URLConnectionLoader *this)
{
  uint64_t v2;
  CFAbsoluteTime result;
  uint64_t v4;
  const __CFAllocator *v5;
  const void *v6;
  void (**v7)(AutoString *__hidden);
  CFStringRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_123_9575, 1);
  if (v2)
  {
    v4 = v2;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v2 + 16))(v2, "touchConnection", 0))
    {
      v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v6 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))this->var0 + 3))(this);
      v7 = &off_1E14E4818;
      v9 = 0;
      v10 = 0;
      v8 = CFStringCreateWithCString(v5, "Loader", 0x8000100u);
      (*(void (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)v4 + 64))(v4, v8, v6);
      AutoString::~AutoString((AutoString *)&v7);
      if (v6)
        CFRelease(v6);
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v4 + 72))(v4, "Timeout Interval", CFSTR("%.3f seconds"));
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    }
  }
  if (this->var22)
  {
    result = this->var18;
    if (result > 0.0)
    {
      this->var20 = 1;
      result = CFAbsoluteTimeGetCurrent() + this->var18;
      this->var19 = result;
    }
  }
  return result;
}

void sub_183F8EAD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

uint64_t DiagnosticLogging::newMsg(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;
  __int128 v6;
  const __CFAllocator *v7;
  unsigned int v8;
  unsigned int v9;
  long double Current;
  const __CFTimeZone *v11;
  CFGregorianDate GregorianDate;
  long double v13;
  _OWORD v15[3];
  uint64_t v16;
  long double __y;

  if (DiagnosticLogging::userDiagnosticLevel(void)::onceToken != -1)
    dispatch_once(&DiagnosticLogging::userDiagnosticLevel(void)::onceToken, &__block_literal_global_13840);
  v4 = DiagnosticLogging::userDiagnosticLevel(void)::sChecked;
  if (DiagnosticLogging::userDiagnosticLevel(void)::sChecked < a2)
    return 0;
  v5 = operator new();
  (*(void (**)(_OWORD *__return_ptr, uint64_t))(a1 + 16))(v15, a1);
  *(_DWORD *)(v5 + 8) = v4;
  *(_QWORD *)v5 = &off_1E14E4CF0;
  v6 = v15[1];
  *(_OWORD *)(v5 + 32) = v15[0];
  *(_OWORD *)(v5 + 48) = v6;
  *(_OWORD *)(v5 + 64) = v15[2];
  *(_QWORD *)(v5 + 80) = v16;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(_QWORD *)(v5 + 24) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(v5 + 16) = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  do
  {
    v8 = __ldxr((unsigned int *)&CoreDiagMsg::CoreDiagMsg(LogFormatter::LineInfo const&,DiagnosticLogging::Level)::gMsgNum);
    v9 = v8 + 1;
  }
  while (__stxr(v9, (unsigned int *)&CoreDiagMsg::CoreDiagMsg(LogFormatter::LineInfo const&,DiagnosticLogging::Level)::gMsgNum));
  *(_DWORD *)(v5 + 88) = v9;
  Current = CFAbsoluteTimeGetCurrent();
  v11 = CFTimeZoneCopySystem();
  GregorianDate = CFAbsoluteTimeGetGregorianDate(Current, v11);
  if (v11)
    CFRelease(v11);
  v13 = modf(Current, &__y);
  snprintf((char *)(v5 + 92), 0x40uLL, "%02d:%02d:%02d.%03d", (int)(*(_QWORD *)&GregorianDate.year >> 24) >> 24, *(uint64_t *)&GregorianDate.year >> 56, (int)GregorianDate.second, vcvtmd_s64_f64(v13 * 1000.0));
  return v5;
}

void sub_183F8EC9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10F1C407AB0D7E0);
  _Unwind_Resume(a1);
}

void HTTPProtocol::sendDidLoadData(HTTPProtocol *this, char *theData, uint64_t a3)
{
  void *v6;
  id Property;
  id v8;
  NSObject *v9;
  Throttler *v10;
  CFIndex Length;
  uint64_t v12;
  uint64_t v13;
  void *v14;

  v6 = (void *)*((_QWORD *)this + 104);
  if (v6)
  {
    Property = objc_getProperty(v6, theData, 96, 1);
    if (Property)
    {
      v8 = Property;
      v9 = objc_msgSend(theData, "_createDispatchData");
      *((_QWORD *)v8 + 16) += dispatch_data_get_size(v9);
      logHARResponseBody(*((void **)v8 + 6), *((_DWORD *)v8 + 4), v9);

    }
  }
  if (theData)
  {
    v10 = (Throttler *)*((_QWORD *)this + 8);
    if (v10)
    {
      Length = CFDataGetLength((CFDataRef)theData);
      Throttler::noteOutstandingBytes(v10, Length);
    }
  }
  v12 = *((_QWORD *)this + 12);
  if (v12)
  {
    v13 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v12 + 16))(*((_QWORD *)this + 12));
    v14 = (void *)MEMORY[0x186DB8C8C](v13);
    (*(void (**)(_QWORD, char *, uint64_t))(**((_QWORD **)this + 12) + 72))(*((_QWORD *)this + 12), theData, a3);
    objc_autoreleasePoolPop(v14);
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
  }
}

uint64_t ___ZNK18QCoreSchedulingSet12performAsyncEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = *(os_unfair_lock_s **)(a1 + 40);
  os_unfair_lock_lock(v2 + 16);
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
    (*(void (**)(void))(v3 + 16))();
  os_unfair_lock_unlock(v2 + 16);
  return (*(uint64_t (**)(os_unfair_lock_s *))(*(_QWORD *)&v2->_os_unfair_lock_opaque + 48))(v2);
}

void SessionConnectionLoadable::_irl_release(SessionConnectionLoadable *this)
{

}

uint64_t `non-virtual thunk to'URLConnectionLoader_Classic::protocolReleaseClient(URLConnectionLoader_Classic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 3) + 72))(*((_QWORD *)this - 3));
}

uint64_t `non-virtual thunk to'URLConnectionLoader_Classic::protocolRetainClient(URLConnectionLoader_Classic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 3) + 64))(*((_QWORD *)this - 3));
}

void logHARResponseBody(void *a1, int a2, void *a3)
{
  id v5;
  id v6;
  NSObject *v7;
  _QWORD v8[4];
  id v9;
  id v10;

  v5 = a1;
  v6 = a3;
  if (HARLoggingEnabled(a2) && HARBodySizeLimit)
  {
    v7 = HARQueue;
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = __logHARResponseBody_block_invoke;
    v8[3] = &unk_1E14FDE88;
    v9 = v5;
    v10 = v6;
    dispatch_async(v7, v8);

  }
}

BOOL HARLoggingEnabled(int a1)
{
  _BOOL8 result;

  if (HARLoggingEnabled(int)::onceToken != -1)
    dispatch_once(&HARLoggingEnabled(int)::onceToken, &__block_literal_global_119);
  result = 0;
  if (a1 && HAREnabled)
    return !HARPIDSpecific || HARPIDSpecific == a1;
  return result;
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolDidLoadData(URLConnectionLoader_Classic *this, const __CFData *a2, uint64_t a3)
{
  URLConnectionLoader_Classic::protocolDidLoadData((URLConnectionLoader_Classic *)((char *)this - 56), a2, a3);
}

void Throttler::noteOutstandingBytes(Throttler *this, uint64_t a2)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  dispatch_time_t v16;

  v5 = (char *)this + 80;
  v4 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 11) = *((_QWORD *)v5 + 1) + a2;
  v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, *((_QWORD *)this + 13));
  *((_QWORD *)this + 13) = v6;
  if (v6)
  {
    if (*((_QWORD *)this + 11) > v6)
    {
      v7 = *((_QWORD *)this + 8);
      *((_QWORD *)this + 8) = v7 + 1;
      if (!v7)
      {
        if (*((_QWORD *)this + 10))
        {
          if (nw_settings_get_signposts_enabled())
            kdebug_trace();
          (*(void (**)(_QWORD))(**((_QWORD **)this + 10) + 16))(*((_QWORD *)this + 10));
        }
        v8 = *((_QWORD *)this + 4);
        if (v8)
          dispatch_source_set_timer(v8, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      }
    }
  }
  *((_QWORD *)this + 7) += a2;
  if (*((double *)this + 6) == 0.0 && *((_QWORD *)this + 12))
  {
    v9 = CFAbsoluteTimeGetCurrent() - *((double *)this + 5);
    if (v9 == 0.0)
    {
      v10 = *((_QWORD *)this + 12);
      v11 = *((_QWORD *)this + 7);
    }
    else
    {
      v11 = *((_QWORD *)this + 7);
      v10 = *((_QWORD *)this + 12);
      if ((double)v11 / v9 < (double)v10)
        return;
    }
    v12 = (double)(v11 / v10) - v9;
    *((double *)this + 6) = v12;
    v13 = *((_QWORD *)this + 10);
    if (v13)
    {
      if (v12 >= (*(double (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13))
        v12 = (*(double (**)(_QWORD))(**((_QWORD **)this + 10) + 40))(*((_QWORD *)this + 10));
      else
        v12 = *((double *)this + 6);
      *((double *)this + 6) = v12;
    }
    if (v12 >= 0.05)
    {
      v14 = *((_QWORD *)this + 10);
      if (v14)
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 16))(v14);
      v15 = *((_QWORD *)this + 4);
      if (v15)
      {
        v16 = dispatch_time(0x8000000000000000, (uint64_t)(*((double *)this + 6) * 1000000000.0));
        dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
      }
    }
    else
    {
      *((_QWORD *)this + 6) = 0;
    }
  }
}

uint64_t `non-virtual thunk to'URLProtocol::_throttle_getCurrentSuspensionThreshold(URLProtocol *this)
{
  return (*(uint64_t (**)(char *))(*((_QWORD *)this - 2) + 168))((char *)this - 16);
}

void URLConnectionLoader_Classic::protocolDidLoadData(URLConnectionLoader_Classic *this, CFTypeRef cf, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[7];
  _QWORD block[6];

  if (cf)
    CFRetain(cf);
  v6 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN27URLConnectionLoader_Classic19protocolDidLoadDataEPK8__CFDatax_block_invoke;
  v9[3] = &__block_descriptor_56_e5_v8__0l;
  v9[4] = this;
  v9[5] = cf;
  v9[6] = a3;
  v7 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v8 = *((_QWORD *)this + 5);
  block[0] = v6;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v9;
  block[5] = v7;
  dispatch_async(v8, block);
}

uint64_t HTTPProtocol::getCurrentSuspensionThreshold(HTTPProtocol *this, uint64_t a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 34);
  if (v2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 168))(v2);
  else
    return a2;
}

uint64_t ___ZNK19URLConnectionLoader25withExistingProtocolAsyncEU13block_pointerFvP11URLProtocolE_block_invoke(_QWORD *a1)
{
  uint64_t v2;

  v2 = a1[5];
  (*(void (**)(void))(a1[4] + 16))();
  CFRelease((CFTypeRef)(a1[6] - 16));
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 72))(*(_QWORD *)(v2 + 32));
}

void ___ZN24HTTPConnectionCacheEntry20connActivityOccurredENSt3__110shared_ptrI14HTTPConnectionEE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  __int128 v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  __int128 v22;

  v1 = *(unsigned int *)(*(_QWORD *)(a1 + 32) + 120);
  if ((int)v1 >= 1)
  {
    do
    {
      if ((((_DWORD)v1 - 1) & 0x80000000) == 0)
      {
        v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 104) + 8);
        if ((v1 - 1) <= (unint64_t)((*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 104) + 16)
                                                         - v3) >> 4))
        {
          v4 = *(_OWORD *)(v3 + 16 * (v1 - 1));
          v22 = v4;
          v5 = *(std::__shared_weak_count **)(v3 + 16 * (v1 - 1) + 8);
          if (*((_QWORD *)&v4 + 1))
          {
            v6 = (unint64_t *)(*((_QWORD *)&v4 + 1) + 8);
            do
              v7 = __ldxr(v6);
            while (__stxr(v7 + 1, v6));
          }
          if ((_QWORD)v4)
          {
            v8 = *(_QWORD *)(v4 + 24) - *(_QWORD *)(v4 + 16);
            if (v8 >= 1)
            {
              v9 = 0;
              v10 = (unint64_t)v8 >> 4;
              if (v10 <= 1)
                v11 = 1;
              else
                v11 = v10;
              do
              {
                v12 = *(__n128 *)(*(_QWORD *)(v22 + 16) + 16 * v9);
                v13 = *(std::__shared_weak_count **)(*(_QWORD *)(v22 + 16) + 16 * v9 + 8);
                if (v12.n128_u64[1])
                {
                  v14 = (unint64_t *)(v12.n128_u64[1] + 8);
                  do
                    v15 = __ldxr(v14);
                  while (__stxr(v15 + 1, v14));
                }
                v16 = (*(uint64_t (**)(unint64_t, __n128))(*(_QWORD *)v12.n128_u64[0] + 80))(v12.n128_u64[0], v12);
                (*(void (**)(uint64_t))(*(_QWORD *)v16 + 192))(v16);
                if (v13)
                {
                  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
                  do
                    v18 = __ldaxr(p_shared_owners);
                  while (__stlxr(v18 - 1, p_shared_owners));
                  if (!v18)
                  {
                    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
                    std::__shared_weak_count::__release_weak(v13);
                  }
                }
                ++v9;
              }
              while (v9 != v11);
              v5 = (std::__shared_weak_count *)*((_QWORD *)&v22 + 1);
            }
          }
          if (v5)
          {
            v19 = (unint64_t *)&v5->__shared_owners_;
            do
              v20 = __ldaxr(v19);
            while (__stlxr(v20 - 1, v19));
            if (!v20)
            {
              ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
              std::__shared_weak_count::__release_weak(v5);
            }
          }
        }
      }
    }
    while (v1-- > 1);
  }
}

void sub_183F8F3F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t MetaNetStreamInfo::getCurrentSuspensionThreshold(MetaNetStreamInfo *this, uint64_t a2)
{
  return a2;
}

void ___ZN19URLConnectionLoader21_loaderEvent_AckBytesEx_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 64);
  if (v2)
  {
    if (*(_QWORD *)(v2 + 72))
    {
      v4 = *(_QWORD *)(a1 + 40);
      v5 = *(_QWORD *)(v2 + 88);
      *(_QWORD *)(v2 + 88) = v5 - v4;
      if (v5 <= v4 && *(uint64_t *)(v2 + 64) >= 1)
      {
        *(_QWORD *)(v2 + 64) = 0;
        *(CFAbsoluteTime *)(v2 + 40) = CFAbsoluteTimeGetCurrent();
        *(_QWORD *)(v2 + 56) = 0;
        v6 = *(NSObject **)(v2 + 32);
        if (v6)
        {
          dispatch_source_set_timer(v6, 0, 0xFFFFFFFFFFFFFFFFLL, 0);
        }
        else
        {
          if (nw_settings_get_signposts_enabled())
            kdebug_trace();
          *(_QWORD *)(v2 + 48) = 0;
          v7 = *(_QWORD *)(v2 + 80);
          if (v7)
            (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
        }
      }
    }
    v1 = *(_QWORD *)(a1 + 32);
  }
  CFRelease((CFTypeRef)(v1 - 16));
}

void `non-virtual thunk to'HTTPProtocol::hcc_touchProtocol(HTTPProtocol *this)
{
  *((CFAbsoluteTime *)this - 18) = CFAbsoluteTimeGetCurrent();
}

uint64_t ___ZN9Throttler10invalidateEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  NSObject *v3;
  uint64_t v4;
  const void *v5;
  _QWORD v7[6];

  v2 = *(_QWORD **)(a1 + 40);
  v3 = v2[4];
  v2[4] = 0;
  if (v3)
  {
    dispatch_source_cancel(v3);
    if (v2[8])
    {
      (*(void (**)(_QWORD *))(*v2 + 40))(v2);
      v4 = v2[9];
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = ___ZN9Throttler10invalidateEU13block_pointerFvvE_block_invoke_2;
      v7[3] = &unk_1E14FE140;
      v7[4] = v3;
      v7[5] = v2;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v7);
    }
    else
    {
      dispatch_release(v3);
    }
  }
  if (v2[10])
    v2[10] = 0;
  v5 = (const void *)v2[14];
  if (v5)
  {
    _Block_release(v5);
    v2[14] = 0;
  }
  (*(void (**)(_QWORD *))(*v2 + 48))(v2);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void Throttler::~Throttler(Throttler *this)
{
  uint64_t v2;

  Throttler::~Throttler(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E14EFE68;
  *((_QWORD *)this + 3) = &unk_1E14EFEB0;
  if (*((_QWORD *)this + 10))
    *((_QWORD *)this + 10) = 0;
  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 9) = 0;
  }
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

void sub_183F8F674(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ___ZN19URLConnectionLoader27_private_ScheduleOriginLoadEP12NSURLRequestPK20_CFCachedURLResponse_block_invoke_2(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  const void *v7;

  if (a2)
  {
    v4 = a2[3];
    v5 = *(_QWORD *)(a1[5] + 168);
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    a2[3] = v5;
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*a2 + 192))(a2, v4, v5);
    (*(void (**)(_QWORD *, _QWORD))(*a2 + 88))(a2, a1[6]);
  }
  v6 = (const void *)a1[6];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[4];
  if (v7)
    CFRelease(v7);
}

HTTPProtocol *HTTPProtocol::subclassUpdateScheduling(HTTPProtocol *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  if (!*((_DWORD *)this + 122))
  {
    this = (HTTPProtocol *)*((_QWORD *)this + 34);
    if (this)
      return (HTTPProtocol *)(*(uint64_t (**)(HTTPProtocol *, const CoreSchedulingSet *))(*(_QWORD *)this
                                                                                                  + 72))(this, a3);
  }
  return this;
}

unsigned int *EmptyCoreSchedulingSet::release(unsigned int *this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = this + 4;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (this)
  {
    if (v2 == 1)
      return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)this + 8))(this);
  }
  return this;
}

void ___ZN19URLConnectionLoader15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  CFArrayRef *v3;
  NSObject *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD v16[7];
  _QWORD v17[6];
  std::__shared_weak_count *v18;

  v2 = a1[4];
  v3 = *(CFArrayRef **)(v2 + 88);
  if (v3)
  {
    *(_QWORD *)(v2 + 88) = 0;
    RedirectionRecorder::playbackMessages(v3, 0, 0);
    (*((void (**)(CFArrayRef *))*v3 + 6))(v3);
  }
  *(_BYTE *)(v2 + 201) = 0;
  v4 = *(NSObject **)(v2 + 152);
  if (v4)
  {
    dispatch_source_set_timer(v4, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 152));
    dispatch_release(*(dispatch_object_t *)(v2 + 152));
    *(_QWORD *)(v2 + 152) = 0;
    *(_BYTE *)(v2 + 136) = 0;
  }
  v5 = MEMORY[0x1E0C809B0];
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3321888768;
  v17[2] = ___ZN19URLConnectionLoader15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2;
  v17[3] = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  v7 = a1[5];
  v6 = (std::__shared_weak_count *)a1[6];
  v17[4] = v2;
  v17[5] = v7;
  v18 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = *(_QWORD *)(v2 + 144);
  if (v10)
  {
    *(_QWORD *)(v2 + 144) = 0;
    v11 = *(_QWORD *)(v2 + 168);
    if (!v11 || !*(_DWORD *)(v11 + 40))
      __assert_rtn("invalidateAsync_block_invoke", "URLConnectionLoader.cpp", 320, "fLoaderSchedulingSet && !fLoaderSchedulingSet->isEmpty()");
    (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 64))(*(_QWORD *)(v2 + 32));
    v12 = *(_QWORD *)(v2 + 168);
    v16[0] = v5;
    v16[1] = 3221225472;
    v16[2] = ___ZN19URLConnectionLoader15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2_5;
    v16[3] = &unk_1E14FDB30;
    v16[5] = v2;
    v16[6] = v10;
    v16[4] = v17;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v12 + 96))(v12, v16);
  }
  else
  {
    ___ZN19URLConnectionLoader15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2(v17, COERCE_DOUBLE(3321888768));
  }
  v13 = v18;
  if (v18)
  {
    v14 = (unint64_t *)&v18->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_183F8F95C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol35asynchronouslyAddCookiesAndContinueEP15__CFHTTPMessage_block_invoke_3(uint64_t a1)
{
  HTTPProtocol *v2;
  const void *v3;

  v2 = *(HTTPProtocol **)(a1 + 32);
  HTTPProtocol::asynchronouslyAddAuthenticatorHeadersAndContinue(v2, *(CFTypeRef *)(a1 + 40));
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  CFRelease((char *)v2 - 16);
}

void HTTPProtocol::asynchronouslyAddAuthenticatorHeadersAndContinue(HTTPProtocol *this, CFTypeRef cf)
{
  __CFHTTPMessage *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t *v6;
  unint64_t v7;
  const __CFDictionary *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  void *v11;
  unint64_t v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  _QWORD v23[5];
  std::__shared_weak_count *v24;
  __CFHTTPMessage *v25;
  std::__shared_weak_count *v26;
  HTTPProtocol *v27;
  std::__shared_weak_count *v28;
  __CFHTTPMessage *v29;
  std::__shared_weak_count *v30;

  if (cf)
    v3 = (__CFHTTPMessage *)CFRetain(cf);
  else
    v3 = 0;
  v29 = v3;
  v4 = (std::__shared_weak_count *)operator new();
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1630;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  v30 = v4;
  if (*((_BYTE *)this + 42)
    || !*((_DWORD *)this + 182)
    || !(*(unsigned int (**)(HTTPProtocol *))(*(_QWORD *)this + 696))(this)
    || *((_DWORD *)this + 206) == 1)
  {
    goto LABEL_5;
  }
  v8 = (const __CFDictionary *)*((_QWORD *)this + 88);
  if (v8)
  {
    _CFHTTPMessageSetMultipleHeaderFields(v3, v8);
LABEL_5:
    HTTPProtocol::asynchronouslyCreateAndOpenStream_WithMessage_AfterCookiesAndAuthenticatorHeaders(this, (os_unfair_lock_s *)v3);
LABEL_6:
    v6 = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    return;
  }
  CFRetain((char *)this - 16);
  v27 = this;
  v9 = (std::__shared_weak_count *)operator new();
  v9->__shared_owners_ = 0;
  v10 = (unint64_t *)&v9->__shared_owners_;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F10F0;
  v9->__shared_weak_owners_ = 0;
  v9[1].__vftable = (std::__shared_weak_count_vtbl *)this;
  v28 = v9;
  v11 = (void *)*((_QWORD *)this + 10);
  v23[0] = MEMORY[0x1E0C809B0];
  v23[1] = 3321888768;
  v23[2] = ___ZN12HTTPProtocol48asynchronouslyAddAuthenticatorHeadersAndContinueEP15__CFHTTPMessage_block_invoke;
  v23[3] = &__block_descriptor_64_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE_e47_v28__0C8____CFDictionary__12___CFURLRequest__20l;
  v23[4] = this;
  v24 = v9;
  do
    v12 = __ldxr(v10);
  while (__stxr(v12 + 1, v10));
  v25 = v3;
  v26 = v4;
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  objc_msgSend(v11, "_getAuthenticationHeadersForResponse:completionHandler:", 0, v23);
  v14 = v26;
  if (v26)
  {
    v15 = (unint64_t *)&v26->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v24;
  if (v24)
  {
    v18 = (unint64_t *)&v24->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v28;
  if (v28)
  {
    v21 = (unint64_t *)&v28->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v4 = v30;
  if (v30)
    goto LABEL_6;
}

void sub_183F8FC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va;

  va_start(va, a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v11 - 64);
  _Unwind_Resume(a1);
}

void ___ZN19URLConnectionLoader15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2(_QWORD *a1, double a2)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10[2];

  v3 = a1[4];
  if (*(_BYTE *)(v3 + 220))
    entr_act_end_delayInitStub(a2);

  *(_QWORD *)(v3 + 104) = 0;
  v4 = a1[5];
  v5 = (std::__shared_weak_count *)a1[6];
  v10[0] = v4;
  v10[1] = (uint64_t)v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  URLConnectionInstanceData::invalidateAsync(v3, v10);
  if (v5)
  {
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_183F8FD2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void URLConnectionInstanceData::invalidateAsync(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[6];
  std::__shared_weak_count *v14;
  uint64_t v15;

  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  v5 = *(NSObject **)(a1 + 40);
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3321888768;
  v13[2] = ___ZN25URLConnectionInstanceData15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke;
  v13[3] = &__block_descriptor_64_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  v7 = *a2;
  v6 = (std::__shared_weak_count *)a2[1];
  v13[4] = a1;
  v13[5] = v7;
  v14 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v15 = v4;
  dispatch_async(v5, v13);
  v10 = v14;
  if (v14)
  {
    v11 = (unint64_t *)&v14->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_183F908B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void SessionConnectionLoadable::withLoaderClientAsync(_QWORD *a1, uint64_t a2)
{
  dispatch_queue_t *v4;
  _QWORD v5[6];

  (*(void (**)(_QWORD *))(*a1 + 64))(a1);
  v4 = (dispatch_queue_t *)a1[3];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN25SessionConnectionLoadable21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke;
  v5[3] = &unk_1E14FDA90;
  v5[4] = a2;
  v5[5] = a1;
  -[__NSCFURLSessionConnection withWorkQueueAsync:](v4, (const char *)v5);
}

URLConnectionLoader *`non-virtual thunk to'URLConnectionLoader::_loaderInterface_retain(URLConnectionLoader *this)
{
  (*(void (**)(unint64_t))(*(_QWORD *)this[-1].var33 + 64))(this[-1].var33);
  return this;
}

SessionConnectionLoadable *SessionConnectionLoadable::_irl_retain(SessionConnectionLoadable *this)
{
  id v2;

  v2 = this->var3;
  return this;
}

URLConnectionLoader *`non-virtual thunk to'URLConnectionLoader::_loaderEvent_AckBytes(URLConnectionLoader *this, uint64_t a2)
{
  return URLConnectionLoader::_loaderEvent_AckBytes((URLConnectionLoader *)((char *)this - 48), a2);
}

URLConnectionLoader *URLConnectionLoader::_loaderEvent_AckBytes(URLConnectionLoader *this, uint64_t a2)
{
  URLProtocol *var21;
  URLConnectionLoader *v3;
  CoreSchedulingSet *var24;
  CoreSchedulingSet *v6;
  _QWORD v7[6];

  var21 = this->var21;
  if (var21)
  {
    v3 = this;
    var24 = this->var24;
    if (!var24 || !*((_DWORD *)var24 + 10))
      __assert_rtn("_loaderEvent_AckBytes", "URLConnectionLoader.cpp", 1031, "fLoaderSchedulingSet && !fLoaderSchedulingSet->isEmpty()");
    CFRetain((char *)var21 - 16);
    v6 = v3->var24;
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZN19URLConnectionLoader21_loaderEvent_AckBytesEx_block_invoke;
    v7[3] = &__block_descriptor_48_e5_v8__0l;
    v7[4] = var21;
    v7[5] = a2;
    return (URLConnectionLoader *)(*(uint64_t (**)(CoreSchedulingSet *, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v7);
  }
  return this;
}

void sub_183F90F60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

void URLConnectionLoader::invalidateAsync(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[6];
  std::__shared_weak_count *v14;
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3321888768;
  v13[2] = ___ZN19URLConnectionLoader15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke;
  v13[3] = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  v5 = *a2;
  v4 = (std::__shared_weak_count *)a2[1];
  v13[4] = a1;
  v13[5] = v5;
  v14 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  v9 = *(NSObject **)(a1 + 40);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v13;
  block[5] = v8;
  dispatch_async(v9, block);
  v10 = v14;
  if (v14)
  {
    v11 = (unint64_t *)&v14->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_183F91084(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::getCurrentSuspensionThreshold(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 144))(*((_QWORD *)this + 2));
}

uint64_t HTTP2Stream::getCurrentSuspensionThreshold(HTTP2Stream *this)
{
  return *((_QWORD *)this + 14);
}

RedirectionRecorder *URLConnectionLoader::protocolDidFinishLoading(URLConnectionLoader *this)
{
  RedirectionRecorder *result;
  uint64_t v3;
  uint64_t v4;
  const __CFAllocator *v5;
  const void *v6;
  CFAbsoluteTime v7;
  URLProtocol *var21;
  CoreSchedulingSet *var24;
  _QWORD v10[5];
  void (**v11)(AutoString *__hidden);
  CFStringRef v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  result = 0;
  if (this->var21)
  {
    result = this->var12;
    if (result)
    {
      (*(void (**)(RedirectionRecorder *))(*(_QWORD *)result + 128))(result);
      return (RedirectionRecorder *)URLConnectionLoader::replayOrConsumeRedirections(this);
    }
    else if (!this->var23)
    {
      this->var23 = 1;
      v3 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_70_9619, 1);
      if (v3)
      {
        v4 = v3;
        if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v3 + 16))(v3, "Did Finish", 0))
        {
          v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v6 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))this->var0 + 3))(this);
          v11 = &off_1E14E4818;
          v13 = 0;
          v14 = 0;
          v12 = CFStringCreateWithCString(v5, "Loader", 0x8000100u);
          (*(void (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)v4 + 64))(v4, v12, v6);
          AutoString::~AutoString((AutoString *)&v11);
          if (v6)
            CFRelease(v6);
          URLConnectionLoader::logTimings((uint64_t)this, v4);
          (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
        }
      }
      v7 = URLConnectionLoader::touchConnection(this);
      result = (RedirectionRecorder *)(*(uint64_t (**)(InterfaceRequiredForLoader *, void *, CFAbsoluteTime))(*(_QWORD *)this->var5 + 40))(this->var5, &__block_literal_global_72, v7);
      var21 = this->var21;
      if (var21)
      {
        this->var21 = 0;
        var24 = this->var24;
        if (!var24 || !*((_DWORD *)var24 + 10))
          __assert_rtn("protocolDidFinishLoading", "URLConnectionLoader.cpp", 1090, "fLoaderSchedulingSet && !fLoaderSchedulingSet->isEmpty()");
        v10[0] = MEMORY[0x1E0C809B0];
        v10[1] = 3221225472;
        v10[2] = ___ZN19URLConnectionLoader24protocolDidFinishLoadingEv_block_invoke_3;
        v10[3] = &__block_descriptor_40_e5_v8__0l;
        v10[4] = var21;
        return (RedirectionRecorder *)(*(uint64_t (**)(CoreSchedulingSet *, _QWORD *))(*(_QWORD *)var24 + 96))(var24, v10);
      }
    }
  }
  return result;
}

void sub_183F91324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void ___ZN27URLConnectionLoader_Classic26protocolDidReceiveResponseEP14_CFURLResponse_block_invoke(uint64_t a1)
{
  URLConnectionLoader::protocolDidReceiveResponse(*(URLConnectionLoader **)(a1 + 32), *(_CFURLResponse **)(a1 + 40));

}

uint64_t URLConnectionLoader::protocolDidReceiveResponse(URLConnectionLoader *this, _CFURLResponse *a2)
{
  uint64_t result;
  RedirectionRecorder *var12;
  _CFURLResponse *v6;
  InterfaceRequiredForLoader *var5;
  _QWORD v8[5];
  uint8_t buf[16];

  result = 0;
  if (this->var21)
  {
    var12 = this->var12;
    if (var12)
    {
      return (*(uint64_t (**)(RedirectionRecorder *, _CFURLResponse *))(*(_QWORD *)var12 + 104))(var12, a2);
    }
    else
    {
      if (!a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "connDidReceiveResponse(): NULL response provided!", buf, 2u);
      }
      URLConnectionLoader::touchConnection(this);
      v6 = a2;
      var5 = this->var5;
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 3221225472;
      v8[2] = ___ZN19URLConnectionLoader26protocolDidReceiveResponseEP14_CFURLResponse_block_invoke;
      v8[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
      v8[4] = a2;
      return (*(uint64_t (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v8);
    }
  }
  return result;
}

void ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke(uint64_t a1)
{
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
}

uint64_t ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_2_26(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  HTTPProtocol *v4;
  NSObject *v5;
  _QWORD block[7];

  v3 = (_QWORD *)a1[6];
  v2 = a1[7];
  if (v2)
    v4 = (HTTPProtocol *)(v2 - 176);
  else
    v4 = 0;
  *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = HTTPProtocol::copyProtocolPropertiesForStream(v4);
  (*(void (**)(_QWORD *))(*v3 + 40))(v3);
  v5 = v3[20];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_3_28;
  block[3] = &unk_1E14FDB30;
  block[4] = a1[4];
  block[5] = v3;
  block[6] = a1[7];
  dispatch_async(v5, block);
  return (*(uint64_t (**)(_QWORD *))(*v3 + 48))(v3);
}

void ___ZN19URLConnectionLoader24protocolDidFinishLoadingEv_block_invoke_3(uint64_t a1)
{
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
}

uint64_t URLProtocol::forgetProtocolClient(URLProtocol *this)
{
  uint64_t result;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v6[5];
  _QWORD v7[6];

  result = *((_QWORD *)this + 12);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    *((_QWORD *)this + 12) = 0;
  }
  v3 = (_QWORD *)*((_QWORD *)this + 8);
  if (v3)
  {
    *((_QWORD *)this + 8) = 0;
    CFRetain((char *)this - 16);
    v4 = MEMORY[0x1E0C809B0];
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke_3854;
    v6[3] = &__block_descriptor_40_e5_v8__0l;
    v6[4] = this;
    (*(void (**)(_QWORD *))(*v3 + 40))(v3);
    v5 = v3[9];
    v7[0] = v4;
    v7[1] = 3221225472;
    v7[2] = ___ZN9Throttler10invalidateEU13block_pointerFvvE_block_invoke;
    v7[3] = &unk_1E14FDA90;
    v7[4] = v6;
    v7[5] = v3;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v5 + 96))(v5, v7);
    return (*(uint64_t (**)(_QWORD *))(*v3 + 48))(v3);
  }
  return result;
}

void URLConnectionLoader_Classic::~URLConnectionLoader_Classic(URLConnectionLoader *this)
{
  uint64_t v2;

  URLConnectionLoader::~URLConnectionLoader(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

void URLConnectionLoader::~URLConnectionLoader(URLConnectionLoader *this)
{
  CoreSchedulingSet *var24;
  NSObject *var6;
  uint8_t v4[16];

  this->var0 = (void **)off_1E14EABC0;
  this->var2 = (void **)&unk_1E14EAD20;
  this->var7 = (void **)&unk_1E14EAD40;
  this->var8 = (void **)&unk_1E14EADF0;
  if (*((_BYTE *)&this->var28 + 1) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "should've been invalidated", v4, 2u);
  }
  var24 = this->var24;
  if (var24)
  {
    (*(void (**)(CoreSchedulingSet *))(*(_QWORD *)var24 + 48))(var24);
    this->var24 = 0;
  }
  this->var0 = (void **)off_1E14ED770;
  this->var2 = (void **)&unk_1E14ED798;
  var6 = this->var6;
  if (var6)
  {
    dispatch_release(var6);
    this->var6 = 0;
  }
  this->var5 = 0;
  this->var2 = (void **)&off_1E14E5838;
}

{
  uint64_t v2;

  URLConnectionLoader::~URLConnectionLoader(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

void sub_183F91824(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  NSObject *v3;

  *v1 = off_1E14ED770;
  v1[2] = &unk_1E14ED798;
  v3 = v1[5];
  if (v3)
  {
    dispatch_release(v3);
    v1[5] = 0;
  }
  v1[4] = 0;
  v1[2] = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

void SessionConnectionLoadable::~SessionConnectionLoadable(SessionConnectionLoadable *this)
{
  this->var0 = (void **)&off_1E14ED570;
  this->var1 = (void **)&unk_1E14ED670;
  this->var2 = (void **)&off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

{
  this->var0 = (void **)&off_1E14ED570;
  this->var1 = (void **)&unk_1E14ED670;
  this->var2 = (void **)&off_1E14E5838;
}

void ___ZN11HTTP2Stream28_onqueue_notifyDataAvailableEv_block_invoke(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  BOOL v3;

  v1 = *(NSObject **)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  if (v1)
    v3 = *(_BYTE *)(v2 + 176) == 0;
  else
    v3 = 0;
  if (v3)
  {
    (*(void (**)(_QWORD, _QWORD, NSObject *))(*(_QWORD *)(v2 + 24) + 16))(*(_QWORD *)(v2 + 24), *(_QWORD *)(v2 + 120), v1);
    *(_QWORD *)(v2 + 208) += dispatch_data_get_size(v1);
    v1 = *(NSObject **)(a1 + 32);
  }
  if (v1)
    dispatch_release(v1);
}

void ___ZN19URLConnectionLoader42_loaderInterface_setConnectionPoolPriorityEPK10__CFNumber_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 144))(a2, *(_QWORD *)(a1 + 32));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::_loaderInterface_setConnectionPoolPriority(URLConnectionLoader *this, const __CFNumber *a2)
{
  return URLConnectionLoader::_loaderInterface_setConnectionPoolPriority((URLConnectionLoader *)((char *)this - 48), a2);
}

uint64_t URLConnectionLoader::_loaderInterface_setConnectionPoolPriority(URLConnectionLoader *this, CFTypeRef cf)
{
  _QWORD v5[5];

  if (cf)
    CFRetain(cf);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN19URLConnectionLoader42_loaderInterface_setConnectionPoolPriorityEPK10__CFNumber_block_invoke;
  v5[3] = &__block_descriptor_40_e9_v16__0_v8l;
  v5[4] = cf;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)v5);
}

void HTTPProtocol::setConnectionPoolPriority(HTTPProtocol *this, CFTypeRef cf)
{
  const void *v4;
  CFTypeRef v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  uint64_t v11;
  _QWORD v12[7];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v4 = (const void *)*((_QWORD *)this + 73);
  *((_QWORD *)this + 73) = 0;
  if (v4)
    CFRelease(v4);
  if (cf)
    v5 = CFRetain(cf);
  else
    v5 = 0;
  *((_QWORD *)this + 73) = v5;
  v6 = *((_QWORD *)this + 34);
  if (v6)
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 40))(v6, 27);
  }
  else if (*((_QWORD *)this + 10))
  {
    v7 = *((_QWORD *)this + 93);
    if (v7)
    {
      v8 = *((_QWORD *)this + 35);
      if (v8)
      {
        v9 = *(_QWORD *)(v7 + 168);
        if (v9)
        {
          v10 = (const void *)*((_QWORD *)this + 3);
          v13 = 0;
          v14 = &v13;
          v15 = 0x2020000000;
          v16 = 0;
          v12[0] = MEMORY[0x1E0C809B0];
          v12[1] = 3221225472;
          v12[2] = ___ZN12XTubeManager25getPendingTubeForProtocolEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKeyPK17CoreSchedulingSet_block_invoke;
          v12[3] = &unk_1E14F9760;
          v12[4] = &v13;
          v12[5] = (char *)this + 176;
          v12[6] = v8;
          XTubeManager::withTubeManager(v9, v10, (uint64_t)v12);
          v11 = v14[3];
          _Block_object_dispose(&v13, 8);
          if (v11)
            (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v11 + 56))(v11, 0x1EDCFA250, *((_QWORD *)this + 73));
        }
      }
    }
  }
}

void sub_183F91C18(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t Tube::setConnectionProperty(Tube *this, CFTypeRef cf, CFTypeRef a3)
{
  uint64_t v6;
  _QWORD v8[8];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v12 = 0;
  if (cf)
    CFRetain(cf);
  if (a3)
    CFRetain(a3);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN4Tube21setConnectionPropertyEPK10__CFStringPKv_block_invoke;
  v8[3] = &unk_1E14F9870;
  v8[4] = &v9;
  v8[5] = this;
  v8[6] = cf;
  v8[7] = a3;
  ___ZN4Tube21setConnectionPropertyEPK10__CFStringPKv_block_invoke(v8);
  v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_183F91CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN4Tube21setConnectionPropertyEPK10__CFStringPKv_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = *(_QWORD *)(a1[5] + 136);
  if (v2)
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v2 + 200))(v2, a1[6], a1[7]);
  v3 = (const void *)a1[6];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[7];
  if (v4)
    CFRelease(v4);
}

void HTTPProtocol::createAndOpenStream(HTTPProtocol *this, const _CFCachedURLResponse *a2)
{
  void *v4;
  _BYTE *Property;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  __int128 v9;

  if ((*((_DWORD *)this + 48) & 0x20) != 0)
  {
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC0CLL);
  }
  else
  {
    if (!*((_QWORD *)this + 97))
    {
      _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((std::__shared_weak_count_vtbl **)&v9);
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 776, &v9);
      v6 = (std::__shared_weak_count *)*((_QWORD *)&v9 + 1);
      if (*((_QWORD *)&v9 + 1))
      {
        v7 = (unint64_t *)(*((_QWORD *)&v9 + 1) + 8);
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }
    v4 = (void *)*((_QWORD *)this + 104);
    if (v4)
    {
      Property = objc_getProperty(v4, (SEL)a2, 96, 1);
      if (Property)
        Property[8] = 1;
    }
    HTTPProtocol::asynchronouslyCreateAndOpenStream(this, a2);
  }
}

void AuthenticationState::AuthenticationState(AuthenticationState *this)
{
  uint64_t v2;
  uint64_t v3;

  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *(_QWORD *)this = &off_1E14E6990;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), 0);
  *(_QWORD *)this = &off_1E14E9AE8;
  *((_QWORD *)this + 11) = &unk_1E14E9B18;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  v2 = operator new();
  *(_QWORD *)v2 = &off_1E14EDAF8;
  *(_BYTE *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  v3 = *((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = v2;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
}

void sub_183F91F14(_Unwind_Exception *a1)
{
  _QWORD *v1;
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  std::__shared_weak_count *v8;

  v7 = v1[18];
  v1[18] = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  v1[11] = &off_1E14E5838;
  *v1 = v5;
  pthread_mutex_destroy(v2);
  v8 = (std::__shared_weak_count *)v1[10];
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[5];
  _QWORD block[5];
  int v8;
  char v9;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(int *)(v1 + 220) < 10)
  {
    v3 = *(_QWORD *)(a1 + 40);
    v4 = *(_QWORD *)(v1 + 256);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke_3;
    v6[3] = &__block_descriptor_40_e11_v16__0i8B12l;
    v6[4] = v1;
    (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v3 + 32))(v3, v4, v6);
  }
  else
  {
    (*(void (**)(_QWORD))(*(_QWORD *)v1 + 40))(*(_QWORD *)(a1 + 32));
    v2 = *(NSObject **)(v1 + 160);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZN4Tube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicyb_block_invoke;
    block[3] = &__block_descriptor_45_e5_v8__0l;
    block[4] = v1;
    v8 = 0;
    v9 = 1;
    dispatch_async(v2, block);
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void `non-virtual thunk to'HTTPProtocol::needServerTrust(uint64_t a1, const void *a2, void (**a3)(_QWORD, _QWORD, _QWORD))
{
  HTTPProtocol::needServerTrust(a1 - 120, a2, a3);
}

{
  HTTPProtocol::needServerTrust(a1 - 112, a2, a3);
}

void HTTPProtocol::needServerTrust(uint64_t a1, const void *a2, void (**a3)(_QWORD, _QWORD, _QWORD))
{
  NSObject *v6;
  uint64_t v7;
  void *v8;
  const __CFURL *v9;
  const __CFString *v10;
  SInt32 v11;
  int v12;
  uint64_t v13;
  uint64_t Challenge;
  const void *v15;
  CFTypeRef v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[5];
  __int128 buf;
  CFTypeRef (*v23)(uint64_t, uint64_t);
  void *v24;
  const void *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 808))
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(a1 + 792);
      LODWORD(buf) = 138543362;
      *(_QWORD *)((char *)&buf + 4) = v7;
      _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "%{public}@ HTTP forwarding trust evaluation to terminalDelegate", (uint8_t *)&buf, 0xCu);
    }
    (*(void (**)(_QWORD, const void *, _QWORD))(**(_QWORD **)(a1 + 808) + 32))(*(_QWORD *)(a1 + 808), a2, a3);
  }
  else if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 520))(a1) || (v8 = *(void **)(a1 + 88)) == 0)
  {
    a3[2](a3, 0, 1);
  }
  else
  {
    if (*(_QWORD *)(a1 + 424))
      __assert_rtn("needServerTrust", "HTTPProtocol.cpp", 7302, "fServerTrustChallenge == nullptr");
    if (*(_QWORD *)(a1 + 432))
      __assert_rtn("needServerTrust", "HTTPProtocol.cpp", 7303, "fServerTrustChallengeCompletion == nullptr");
    v9 = *(const __CFURL **)(objc_msgSend(v8, "_inner") + 8);
    v10 = CFURLCopyHostName(v9);
    v11 = CFURLGetPortNumber(v9);
    if (v11 == -1)
      v12 = 443;
    else
      v12 = v11;
    v13 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 3221225472;
    v23 = ___ZN22HTTPProtocolSSLSupport35CreateTrustChallengeWithHostAndPortEPK10__CFStringlP10__SecTrust_block_invoke;
    v24 = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
    v25 = a2;
    Challenge = createChallenge(8, v10, v12, (uint64_t)&buf);
    if (v10)
      CFRelease(v10);
    *(_QWORD *)(a1 + 424) = Challenge;
    *(_QWORD *)(a1 + 432) = _Block_copy(a3);
    v15 = *(const void **)(a1 + 456);
    if (v15 != a2)
    {
      if (v15)
        CFRelease(v15);
      if (a2)
        v16 = CFRetain(a2);
      else
        v16 = 0;
      *(_QWORD *)(a1 + 456) = v16;
    }
    if (*(_QWORD *)(a1 + 744)
      && (v17 = (void *)objc_msgSend(*(id *)(a1 + 80), "_effectiveConfiguration")) != 0
      && objc_msgSend(v17, "_alwaysPerformDefaultTrustEvaluation"))
    {
      CFRetain((CFTypeRef)(a1 - 16));
      v18 = *(_QWORD *)(a1 + 24);
      v21[0] = v13;
      v21[1] = 3221225472;
      v21[2] = ___ZN12HTTPProtocol15needServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicybE_block_invoke;
      v21[3] = &__block_descriptor_40_e5_v8__0l;
      v21[4] = a1;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v18 + 96))(v18, v21);
    }
    else
    {
      v19 = *(_QWORD *)(a1 + 424);
      if (v19)
      {
        if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
          dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
        v20 = *(_QWORD *)(v19 + 40);
        if (v20)
        {
          if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
            dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
          *(_OWORD *)(v20 + 104) = *(_OWORD *)(a1 + 864);
        }
      }
      HTTPProtocol::sendDidReceiveAuthChallenge((HTTPProtocol *)a1, *(_CFURLAuthChallenge **)(a1 + 424));
    }
  }
}

uint64_t createChallenge(int a1, const __CFString *cf, int a3, uint64_t a4)
{
  CFAllocatorRef v8;
  const void *v9;
  CFAllocatorRef v10;
  uint64_t v11;

  v8 = CFGetAllocator(cf);
  v9 = (const void *)CFURLProtectionSpaceCreate((uint64_t)v8, cf, a3, 2, 0, a1);
  (*(void (**)(uint64_t, const void *))(a4 + 16))(a4, v9);
  v10 = CFGetAllocator(cf);
  v11 = CFURLAuthChallengeCreate((uint64_t)v10, v9, 0, 0, 0, 0);
  if (v9)
    CFRelease(v9);
  return v11;
}

CFTypeRef ___ZN22HTTPProtocolSSLSupport35CreateTrustChallengeWithHostAndPortEPK10__CFStringlP10__SecTrust_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeRef result;

  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  if (a2)
    v4 = a2 + 16;
  else
    v4 = 0;
  v5 = *(CFTypeRef *)(a1 + 32);
  result = *(CFTypeRef *)(v4 + 72);
  if (result != v5)
  {
    if (result)
      CFRelease(result);
    if (v5)
      result = CFRetain(v5);
    else
      result = 0;
    *(_QWORD *)(v4 + 72) = result;
  }
  return result;
}

uint64_t ___ZN24HTTPConnectionCacheEntry20connCompletedRequestENSt3__110shared_ptrI14HTTPConnectionEEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  HTTPConnection *v3;
  unint64_t *v4;
  unint64_t v5;
  _BOOL4 canPipelineOnConnection;
  BOOL v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD v17[2];
  HTTPConnection *v18[2];

  v2 = *(_QWORD *)(a1 + 40);
  if (!HTTPConnection::willEnqueueRequests(*(HTTPConnection **)(a1 + 48), 0)
    && (*(_BYTE *)(v2 + 32) & 8) != 0
    && ((*(_BYTE *)(v2 + 32) & 0x10) == 0 || (*(_BYTE *)(v2 + 32) & 0x60) == 0x20))
  {
    v3 = *(HTTPConnection **)(a1 + 56);
    v18[0] = *(HTTPConnection **)(a1 + 48);
    v18[1] = v3;
    if (v3)
    {
      v4 = (unint64_t *)((char *)v3 + 8);
      do
        v5 = __ldxr(v4);
      while (__stxr(v5 + 1, v4));
    }
    canPipelineOnConnection = HTTPConnectionCacheEntry::_canPipelineOnConnection(v2, v18);
    v7 = canPipelineOnConnection;
    if (!v3)
      goto LABEL_12;
    v8 = (unint64_t *)((char *)v3 + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      (*(void (**)(HTTPConnection *))(*(_QWORD *)v3 + 16))(v3);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v3);
      if (!v7)
        return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    }
    else
    {
LABEL_12:
      if (!canPipelineOnConnection)
        return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    }
    v11 = *(std::__shared_weak_count **)(a1 + 56);
    v10 = *(_QWORD *)(a1 + 64);
    v17[0] = *(_QWORD *)(a1 + 48);
    v17[1] = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    HTTPConnectionCacheEntry::_notifyNextProtocolOfOpenConnection(v10, v17, 0);
    if (v11)
    {
      v14 = (unint64_t *)&v11->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_183F9262C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN27URLConnectionLoader_Classic41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1)
{
  const void *v2;

  URLConnectionLoader::protocolDidReceiveAuthenticationChallenge(*(URLConnectionLoader **)(a1 + 32), *(_CFURLAuthChallenge **)(a1 + 40));
  v2 = *(const void **)(a1 + 40);
  if (v2)
    CFRelease(v2);
}

URLConnectionLoader *URLConnectionLoader::protocolDidReceiveAuthenticationChallenge(URLConnectionLoader *this, _CFURLAuthChallenge *a2)
{
  URLConnectionLoader *v3;
  RedirectionRecorder *var12;
  uint64_t v5;
  uint64_t v6;
  const __CFAllocator *v7;
  const void *v8;
  CFStringRef v9;
  char *v10;
  const __CFString *v11;
  CFStringRef v12;
  uint64_t v13;
  InterfaceRequiredForLoader *var5;
  _QWORD v15[5];
  _QWORD v16[6];
  void (**v17)(AutoString *__hidden);
  CFStringRef v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (this->var21)
  {
    v3 = this;
    var12 = this->var12;
    if (var12)
    {
      return (URLConnectionLoader *)(*(uint64_t (**)(RedirectionRecorder *, _CFURLAuthChallenge *))(*(_QWORD *)var12 + 144))(var12, a2);
    }
    else
    {
      v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_17_9604, 1);
      if (v5)
      {
        v6 = v5;
        if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v5 + 16))(v5, "Authentication Challenge", 0))
        {
          v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v8 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))v3->var0 + 3))(v3);
          v17 = &off_1E14E4818;
          v19 = 0;
          v20 = 0;
          v18 = CFStringCreateWithCString(v7, "Loader", 0x8000100u);
          (*(void (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)v6 + 64))(v6, v18, v8);
          AutoString::~AutoString((AutoString *)&v17);
          if (v8)
            CFRelease(v8);
          if (a2)
          {
            if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
              dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
            v17 = &off_1E14E4818;
            v9 = CFStringCreateWithCString(v7, "Challenge", 0x8000100u);
            v10 = (char *)a2 + 16;
            v19 = 0;
            v20 = 0;
            v18 = v9;
            v11 = (const __CFString *)(*(uint64_t (**)(char *))(*((_QWORD *)a2 + 2) + 32))((char *)a2 + 16);
            v12 = v18;
          }
          else
          {
            v17 = &off_1E14E4818;
            v12 = CFStringCreateWithCString(v7, "Challenge", 0x8000100u);
            v10 = 0;
            v19 = 0;
            v20 = 0;
            v11 = CFSTR("null");
            v18 = v12;
          }
          (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v6 + 64))(v6, v12, v11);
          if (v10 && v11)
            CFRelease(v11);
          AutoString::~AutoString((AutoString *)&v17);
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
        }
      }
      if (v3->var22)
        v3->var20 = 0;
      v13 = MEMORY[0x1E0C809B0];
      v16[0] = MEMORY[0x1E0C809B0];
      v16[1] = 3221225472;
      v16[2] = ___ZN19URLConnectionLoader41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke_2;
      v16[3] = &__block_descriptor_48_e5_v8__0l;
      v16[4] = v3;
      v16[5] = a2;
      __CFNetworkLogForAuthTimeoutIssueSync((uint64_t)v16);
      if (a2)
        CFRetain(a2);
      var5 = v3->var5;
      v15[0] = v13;
      v15[1] = 3221225472;
      v15[2] = ___ZN19URLConnectionLoader41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke_3;
      v15[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
      v15[4] = a2;
      return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v15);
    }
  }
  return this;
}

void sub_183F92960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void ___ZN24HTTPConnectionCacheEntry21connCompletedResponseENSt3__110shared_ptrI14HTTPConnectionEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  __int16 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[2];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  BOOL v19;

  v2 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v2 + 32) |= 0x20u;
  if (!HTTPConnection::willEnqueueRequests(*(HTTPConnection **)(a1 + 40), 0))
  {
    if ((*(_BYTE *)(v2 + 32) & 8) == 0 || (*(_BYTE *)(v2 + 32) & 0x10) != 0 && (*(_BYTE *)(v2 + 32) & 0x60) != 0x20)
      goto LABEL_8;
    v3 = *(_QWORD *)(a1 + 40);
    v16 = 0;
    v17 = &v16;
    v18 = 0x2020000000;
    LOWORD(v3) = *(unsigned __int8 *)(v3 + 34);
    v4 = (unsigned __int16)v3 >> 1;
    v19 = (v3 & 2) != 0;
    _Block_object_dispose(&v16, 8);
    if ((v4 & 1) == 0
      || (v5 = *(_QWORD *)(a1 + 40),
          v16 = 0,
          v17 = &v16,
          v18 = 0x2020000000,
          v6 = *(_QWORD *)(v5 + 160),
          v19 = v6 != 0,
          _Block_object_dispose(&v16, 8),
          !v6))
    {
LABEL_8:
      v7 = *(_QWORD *)(a1 + 40);
      v10 = a1 + 48;
      v9 = *(std::__shared_weak_count **)(a1 + 48);
      v8 = *(_QWORD *)(v10 + 8);
      v15[0] = v7;
      v15[1] = v9;
      if (v9)
      {
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v12 = __ldxr(p_shared_owners);
        while (__stxr(v12 + 1, p_shared_owners));
      }
      HTTPConnectionCacheEntry::_notifyNextProtocolOfOpenConnection(v8, v15, 0);
      if (v9)
      {
        v13 = (unint64_t *)&v9->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
  }
}

void sub_183F92BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'URLConnectionLoader::_loaderInterface_performDefaultHandlingForChallenge(URLConnectionLoader *this, _CFURLAuthChallenge *a2)
{
  URLConnectionLoader::_loaderInterface_performDefaultHandlingForChallenge((URLConnectionLoader *)((char *)this - 48), a2);
}

void URLConnectionLoader::_loaderInterface_performDefaultHandlingForChallenge(URLConnectionLoader *this, _CFURLAuthChallenge *a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[6];

  if (!this->var23)
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZN19URLConnectionLoader51_loaderInterface_performDefaultHandlingForChallengeEP19_CFURLAuthChallenge_block_invoke;
    v7[3] = &__block_descriptor_48_e5_v8__0l;
    v7[4] = this;
    v7[5] = a2;
    __CFNetworkLogForAuthTimeoutIssueSync((uint64_t)v7);
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
    if (a2)
      v4 = (char *)a2 + 16;
    else
      v4 = 0;
    v5 = *((_QWORD *)v4 + 3);
    if (v5)
    {
      if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
      {
        v6 = *((_QWORD *)v4 + 3);
        dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
        v5 = v6;
      }
      if (*(_DWORD *)(v5 + 72) == 9)
      {
        (*((void (**)(URLConnectionLoader *, _CFURLAuthChallenge *))this->var0 + 33))(this, a2);
      }
      else
      {
        if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
          dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
        (*((void (**)(URLConnectionLoader *, _QWORD, _CFURLAuthChallenge *))this->var0 + 32))(this, *((_QWORD *)v4 + 4), a2);
      }
    }
  }
}

void URLConnectionLoader::_loaderInterface_useCredential(URLConnectionLoader *this, const _CFURLCredential *a2, _CFURLAuthChallenge *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  const __CFAllocator *v10;
  CFStringRef v11;
  CFStringRef v12;
  char *v13;
  const __CFString *v14;
  CFStringRef v15;
  _QWORD v16[6];
  _QWORD v17[7];
  void (**v18)(AutoString *__hidden);
  const __CFString *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!this->var23)
  {
    v6 = MEMORY[0x1E0C809B0];
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 3221225472;
    v17[2] = ___ZN19URLConnectionLoader30_loaderInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke;
    v17[3] = &__block_descriptor_56_e5_v8__0l;
    v17[4] = this;
    v17[5] = a3;
    v17[6] = a2;
    __CFNetworkLogForAuthTimeoutIssueSync((uint64_t)v17);
    v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_91_9569, 1);
    v8 = v7;
    if (v7
      && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v7 + 16))(v7, "Use Credential", 0))
    {
      v9 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))this->var0 + 3))(this);
      v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v18 = &off_1E14E4818;
      v11 = CFStringCreateWithCString(v10, "Loader", 0x8000100u);
      v20 = 0;
      v21 = 0;
      v19 = v11;
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 64))(v8);
      AutoString::~AutoString((AutoString *)&v18);
      if (v9)
        CFRelease(v9);
      if (a2)
      {
        if (URLCredential::Class(void)::sOnce_URLCredential != -1)
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
        v18 = &off_1E14E4818;
        v12 = CFStringCreateWithCString(v10, "Credential", 0x8000100u);
        v13 = (char *)a2 + 16;
        v20 = 0;
        v21 = 0;
        v19 = v12;
        v14 = (const __CFString *)(*(uint64_t (**)(char *))(*((_QWORD *)a2 + 2) + 32))((char *)a2 + 16);
        v15 = v19;
      }
      else
      {
        v18 = &off_1E14E4818;
        v15 = CFStringCreateWithCString(v10, "Credential", 0x8000100u);
        v13 = 0;
        v20 = 0;
        v21 = 0;
        v14 = CFSTR("null");
        v19 = v15;
      }
      (*(void (**)(uint64_t, CFStringRef, const __CFString *))(*(_QWORD *)v8 + 64))(v8, v15, v14);
      if (v13 && v14)
        CFRelease(v14);
      AutoString::~AutoString((AutoString *)&v18);
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    }
    URLConnectionLoader::touchConnection(this);
    if (a3)
    {
      CFRetain(a3);
      if (a2)
        CFRetain(a2);
      v16[0] = v6;
      v16[1] = 3221225472;
      v16[2] = ___ZN19URLConnectionLoader30_loaderInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke_3;
      v16[3] = &__block_descriptor_48_e9_v16__0_v8l;
      v16[4] = a2;
      v16[5] = a3;
      URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)v16);
    }
  }
}

void sub_183F92FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void __CFNetworkLogForAuthTimeoutIssueSync(uint64_t a1)
{
  if (__CFNetworkLogForAuthTimeoutIssueSync::sCheckDefault != -1)
    dispatch_once(&__CFNetworkLogForAuthTimeoutIssueSync::sCheckDefault, &__block_literal_global_60_4894);
  if (__CFNetworkLogForAuthTimeoutIssueSync::shouldLog)
    (*(void (**)(uint64_t))(a1 + 16))(a1);
}

void ___ZN19URLConnectionLoader30_loaderInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke_3(uint64_t a1, uint64_t a2)
{
  const void *v3;
  const void *v4;

  if (a2)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 120))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 32);
  if (v4)
    CFRelease(v4);
}

void HTTPProtocol::_protocolInterface_useCredential(HTTPProtocol *this, _CFURLCredential *a2, CFTypeRef *a3)
{
  uint64_t v6;
  void *v7;
  const __CFURL *v8;
  StrictSecurityPolicy *v9;
  uint64_t v10;
  const void *v11;
  void (**v12)(_QWORD, _QWORD, _QWORD);
  void (**v13)(_QWORD, _QWORD, _QWORD);
  char *v14;
  const void *v15;
  const __CFAllocator *v16;
  __CFArray *Mutable;
  const __CFArray *v18;
  const __CFArray *v19;
  unint64_t Count;
  CFRange v21;
  const void **v22;
  _DWORD *v23;
  _DWORD *v24;
  void *v25;
  _DWORD *v26;
  uint64_t v27;
  NSObject *v28;
  _BOOL4 v29;
  uint64_t *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  void (*v36)(_QWORD *, _CFURLCredential *, uint64_t);
  uint64_t v37;
  _QWORD *v38;
  unint64_t *v39;
  unint64_t v40;
  void *v41;
  const __CFURL *v42;
  const __CFString *v43;
  CFIndex Length;
  CFIndex v45;
  uint64_t v46;
  _DWORD *v47;
  double v48;
  double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher;
  uint64_t v50;
  void *v51;
  CFStringRef v52;
  NSObject *v53;
  void *v54;
  uint64_t Auth;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  __CFArray *v60;
  BOOL isFirstPartyResource;
  uint64_t v62;
  uint64_t v63;
  const char *v64;
  NSObject *v65;
  uint32_t v66;
  CFTypeRef *v67;
  AuthenticationState *v68;
  NSObject *v69;
  CFTypeRef *v70;
  uint64_t ProtectionSpace;
  AuthenticationState *v72;
  unint64_t v73;
  const _CFURLCredential *v74;
  NSObject *v75;
  const __CFAllocator *v76;
  const void *v77;
  uint64_t v78;
  unint64_t v79;
  _DWORD *v80;
  int v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  unint64_t *p_shared_owners;
  unint64_t v85;
  char *v86;
  unsigned int v87;
  uint64_t v88;
  NSObject *v89;
  NSObject *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void *v94;
  void *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  _QWORD v102[2];
  _BYTE buf[24];
  CFTypeRef *v104;
  __int16 v105;
  _QWORD v106[29];
  uint64_t v107;
  uint64_t v108;
  CFRange v109;

  v108 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 41))
  {
    v6 = *((_QWORD *)this + 97);
    if (v6)
      AuthenticationState::setOption(v6, 0, *((_BYTE *)this + 40) != 0);
  }
  if (isLikeChallenge(a3, *((CFTypeRef **)this + 53)))
  {
    v7 = (void *)*((_QWORD *)this + 11);
    v8 = (const __CFURL *)objc_msgSend(v7, "cfURL");
    if (v8
      && (v9 = (StrictSecurityPolicy *)*((_QWORD *)this + 92)) != 0
      && StrictSecurityPolicy::strictSecurityPolicyInEffectForURL(v9, v8, *(const __CFDictionary **)(objc_msgSend(v7, "_inner") + 192)))
    {
      v10 = 2;
    }
    else
    {
      v10 = a2 != 0;
    }
    v11 = (const void *)*((_QWORD *)this + 53);
    v12 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 54);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 54) = 0;
    if (v11)
      CFRelease(v11);
    if (v12)
    {
      v12[2](v12, v10, 0);
      _Block_release(v12);
    }
    HTTPProtocol::applyPreAuthenticationToCurrentRequest(this, 0, *((NSURLRequest **)this + 11), (const __CFURL *)objc_msgSend(*((id *)this + 11), "cfURL"));
    return;
  }
  if (isLikeChallenge(a3, *((CFTypeRef **)this + 51)))
  {
    v13 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 52);
    *((_QWORD *)this + 52) = 0;
    if (a2)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1)
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
      if (*((_DWORD *)a2 + 12) == 3)
      {
        v14 = (char *)a2 + 16;
        v15 = (const void *)(*(uint64_t (**)(char *))(*((_QWORD *)a2 + 2) + 120))((char *)a2 + 16);
        if (v15)
        {
          v16 = CFGetAllocator((char *)this - 16);
          Mutable = CFArrayCreateMutable(v16, 0, MEMORY[0x1E0C9B378]);
          CFArrayAppendValue(Mutable, v15);
          v18 = (const __CFArray *)(*(uint64_t (**)(char *))(*(_QWORD *)v14 + 112))(v14);
          v19 = v18;
          if (!v18 || CFArrayGetCount(v18) < 1)
            goto LABEL_130;
          *(_QWORD *)buf = CFRetain(v19);
          Count = CFArrayGetCount(v19);
          v21.length = Count;
          *(_QWORD *)&buf[8] = Count;
          if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
          {
            *(_QWORD *)&buf[16] = 0;
            goto LABEL_166;
          }
          if (Count > 0x1E)
          {
            v22 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
            *(_QWORD *)&buf[16] = v22;
            if (!v22)
              goto LABEL_166;
            v21.length = *(_QWORD *)&buf[8];
          }
          else
          {
            v22 = (const void **)&v104;
            *(_QWORD *)&buf[16] = &v104;
          }
          v21.location = 0;
          CFArrayGetValues(v19, v21, v22);
LABEL_166:
          v107 = 0;
          while (1)
          {
            v92 = v107;
            if (v107 >= *(uint64_t *)&buf[8])
              break;
            ++v107;
            CFArrayAppendValue(Mutable, *(const void **)(*(_QWORD *)&buf[16] + 8 * v92));
          }
          CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)buf);
          goto LABEL_130;
        }
      }
    }
    else
    {
      v41 = (void *)*((_QWORD *)this + 11);
      if (v41 && (objc_msgSend(*((id *)this + 10), "_shouldSkipPreferredClientCertificateLookup") & 1) == 0)
      {
        v42 = CFURLCopyAbsoluteURL(*(CFURLRef *)(objc_msgSend(v41, "_inner") + 8));
        v43 = CFURLGetString(v42);
        Length = CFStringGetLength(v43);
        v45 = Length - 1;
        if (Length < 1)
          goto LABEL_77;
        v46 = Length;
        while (CFStringGetCharacterAtIndex(v43, --v46) == 47)
        {
          if (v46 <= 0)
          {
            v46 = -1;
            break;
          }
        }
        if (v46 == v45)
        {
LABEL_77:
          CFRetain(v43);
        }
        else
        {
          v76 = CFGetAllocator(v41);
          v109.length = v46 + 1;
          v109.location = 0;
          v43 = CFStringCreateWithSubstring(v76, v43, v109);
        }
        if (v42)
          CFRelease(v42);
        if (v43)
          CFRelease(v43);
      }
    }
    Mutable = 0;
LABEL_130:
    v77 = (const void *)*((_QWORD *)this + 51);
    *((_QWORD *)this + 51) = 0;
    if (v77)
      CFRelease(v77);
    if (v13)
    {
      ((void (**)(_QWORD, __CFArray *, _QWORD))v13)[2](v13, Mutable, 0);
      _Block_release(v13);
    }
    if (Mutable)
      CFRelease(Mutable);
    return;
  }
  if (!a3)
  {
LABEL_100:
    if (a2)
    {
      if (*((_QWORD *)this + 47))
      {
        setTypeProperty<_CFURLAuthChallenge *>((CFTypeRef *)this + 47, a3);
        v67 = (CFTypeRef *)*((_QWORD *)this + 47);
      }
      else
      {
        v67 = 0;
      }
      if (isLikeChallenge(a3, v67))
      {
        setTypeProperty<_CFURLCredential const*>((CFTypeRef *)this + 44, a2);
        *((_DWORD *)this + 48) |= 0x10000u;
        v68 = (AuthenticationState *)*((_QWORD *)this + 97);
        if (!v68
          || !AuthenticationState::updateState(v68, 0, *((_QWORD *)this + 47), *((const _CFURLCredential **)this + 44), *((__SecTrust **)this + 57)))
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v69 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
          {
            v96 = *((_QWORD *)this + 99);
            *(_DWORD *)buf = 138543362;
            *(_QWORD *)&buf[4] = v96;
            _os_log_fault_impl(&dword_183ECA000, v69, OS_LOG_TYPE_FAULT, "%{public}@ invalid authentication state", buf, 0xCu);
          }
          goto LABEL_162;
        }
      }
      else
      {
        v70 = (CFTypeRef *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 648))(this);
        if (isLikeChallenge(a3, v70))
        {
          if ((*((_DWORD *)this + 48) & 0x400000) == 0)
          {
            ProtectionSpace = CFURLAuthChallengeGetProtectionSpace((uint64_t)a3);
            (*(void (**)(_QWORD, _CFURLCredential *, uint64_t, _QWORD))(**((_QWORD **)this + 87) + 64))(*((_QWORD *)this + 87), a2, ProtectionSpace, *((_QWORD *)this + 10));
          }
          (*(void (**)(HTTPProtocol *, _CFURLCredential *))(*(_QWORD *)this + 624))(this, a2);
          v72 = (AuthenticationState *)*((_QWORD *)this + 97);
          if (!v72
            || (v73 = (*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 648))(this),
                v74 = (const _CFURLCredential *)(*(uint64_t (**)(HTTPProtocol *))(*(_QWORD *)this + 616))(this),
                !AuthenticationState::updateState(v72, 0, v73, v74, 0)))
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v75 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
            {
              v99 = *((_QWORD *)this + 99);
              *(_DWORD *)buf = 138543362;
              *(_QWORD *)&buf[4] = v99;
              _os_log_fault_impl(&dword_183ECA000, v75, OS_LOG_TYPE_FAULT, "%{public}@ invalid proxy authentication state", buf, 0xCu);
            }
            goto LABEL_162;
          }
        }
        else if (isLikeChallenge(a3, *((CFTypeRef **)this + 48)))
        {
          setTypeProperty<_CFURLCredential const*>((CFTypeRef *)this + 45, a2);
          HTTPProtocol::executePACQuery(this, *((void **)this + 49), 0);
          return;
        }
      }
    }
    else
    {
      *((_DWORD *)this + 48) |= 0x8000u;
    }
    v78 = *((unsigned int *)this + 48);
    v79 = v78 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    if ((v79 & 0x8000000000) != 0)
    {
      v82 = *((_QWORD *)this + 97);
      v83 = (std::__shared_weak_count *)*((_QWORD *)this + 98);
      v102[0] = v82;
      v102[1] = v83;
      if (v83)
      {
        p_shared_owners = (unint64_t *)&v83->__shared_owners_;
        do
          v85 = __ldxr(p_shared_owners);
        while (__stxr(v85 + 1, p_shared_owners));
      }
      SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(*((_QWORD *)this + 78), v82, v83);
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v102);
      SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs((uint64_t *)buf, 0);
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 624, (__int128 *)buf);
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)buf);
      v87 = *((_DWORD *)this + 48);
      v86 = (char *)this + 192;
      v88 = *((unsigned __int16 *)v86 + 2);
      *(_DWORD *)v86 = v87;
      *((_WORD *)v86 + 2) = ((v87 | (unint64_t)(v88 << 32)) & 0xFFFFFF7FFFFFFFFFLL) >> 32;
    }
    else
    {
      *((_DWORD *)this + 48) = v78 & 0xFFFFFFFD;
      *((_WORD *)this + 98) = (v79 & 0xFFFFFFFFFFFFFFFDLL) >> 32;
      if ((v79 & 1) != 0)
      {
        if (!a3)
          goto LABEL_152;
        if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
          dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
        v80 = a3[5];
        if (v80)
        {
          if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
            dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
          v81 = v80[18];
        }
        else
        {
LABEL_152:
          v81 = 0;
        }
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v89 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
        {
          v97 = *((_QWORD *)this + 99);
          *(_DWORD *)buf = 138544386;
          *(_QWORD *)&buf[4] = v97;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = a2;
          *(_WORD *)&buf[22] = 2048;
          v104 = a3;
          v105 = 1024;
          LODWORD(v106[0]) = v81;
          WORD2(v106[0]) = 2112;
          *(_QWORD *)((char *)v106 + 6) = a3;
          _os_log_fault_impl(&dword_183ECA000, v89, OS_LOG_TYPE_FAULT, "%{public}@ in invalid state when supplying credential %p for challenge %p %d: %@", buf, 0x30u);
        }
      }
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((_QWORD *)this + 104), 3, 0);
      HTTPProtocol::createAndOpenStream(this, 0);
    }
    return;
  }
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v23 = a3[5];
  if (v23)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
    if (v23[18] == 8)
      return;
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  }
  v24 = a3[5];
  if (v24)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
    if (v24[18] == 7)
      return;
  }
  v25 = (void *)*((_QWORD *)this + 10);
  if (!v25 || (objc_msgSend(v25, "_requiresSecureHTTPSProxyConnection") & 1) == 0)
  {
    if (__CFNUseNWHTTPSProxies::useProxyOnce != -1)
      dispatch_once(&__CFNUseNWHTTPSProxies::useProxyOnce, &__block_literal_global_11_4775);
    if (!__CFNUseNWHTTPSProxies::useNWHTTPSProxy)
      goto LABEL_78;
  }
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v26 = a3[5];
  if (v26)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
    if (v26[15] == 6)
    {
      v27 = *((_QWORD *)this + 85);
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v28 = CFNLog::logger;
      v29 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG);
      if (v27)
      {
        if (v29)
        {
          v100 = *((_QWORD *)this + 99);
          v101 = *((_QWORD *)this + 85);
          *(_DWORD *)buf = 138544130;
          *(_QWORD *)&buf[4] = v100;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v101;
          *(_WORD *)&buf[22] = 2112;
          v104 = (CFTypeRef *)a2;
          v105 = 2112;
          v106[0] = a3;
          _os_log_debug_impl(&dword_183ECA000, v28, OS_LOG_TYPE_DEBUG, "%{public}@ useCredential for proxy (%lu) creds %@ challenge %@", buf, 0x2Au);
        }
        v30 = (uint64_t *)(*(_QWORD *)(*((_QWORD *)this + 81) + ((*((_QWORD *)this + 84) >> 5) & 0x7FFFFFFFFFFFFF8))
                        + 16 * *((_QWORD *)this + 84));
        v31 = *v30;
        *(_QWORD *)buf = *v30;
        v32 = (std::__shared_weak_count *)v30[1];
        *(_QWORD *)&buf[8] = v32;
        if (v32)
        {
          v33 = (unint64_t *)&v32->__shared_owners_;
          do
            v34 = __ldxr(v33);
          while (__stxr(v34 + 1, v33));
        }
        if (a2)
        {
          (*(void (**)(HTTPProtocol *, _CFURLCredential *))(*(_QWORD *)this + 624))(this, a2);
        }
        else
        {
          v94 = (void *)*((_QWORD *)this + 10);
          if (v94)
          {
            if (objc_msgSend(v94, "_requiresSecureHTTPSProxyConnection"))
            {
              v95 = (void *)*((_QWORD *)this + 10);
              if (v95)
              {
                v35 = objc_msgSend(v95, "_preventsSystemHTTPProxyAuthentication");
                if (v31)
                  goto LABEL_61;
                goto LABEL_64;
              }
            }
          }
        }
        v35 = 0;
        if (v31)
        {
LABEL_61:
          v36 = *(void (**)(_QWORD *, _CFURLCredential *, uint64_t))(v31 + 8);
          v37 = *(_QWORD *)(v31 + 16);
          v38 = (_QWORD *)(v31 + (v37 >> 1));
          if ((v37 & 1) != 0)
            v36 = *(void (**)(_QWORD *, _CFURLCredential *, uint64_t))(*v38 + v36);
          v36(v38, a2, v35);
        }
LABEL_64:
        std::deque<SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::pop_front((uint64_t)this + 640);
        if (v32)
        {
          v39 = (unint64_t *)&v32->__shared_owners_;
          do
            v40 = __ldaxr(v39);
          while (__stlxr(v40 - 1, v39));
          if (!v40)
          {
            ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
            std::__shared_weak_count::__release_weak(v32);
          }
        }
        return;
      }
      if (!v29)
        return;
      v93 = *((_QWORD *)this + 99);
      *(_DWORD *)buf = 138543618;
      *(_QWORD *)&buf[4] = v93;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = a3;
      v64 = "%{public}@ ignoring stale proxy challenge %@";
      v65 = v28;
      v66 = 22;
LABEL_172:
      _os_log_debug_impl(&dword_183ECA000, v65, OS_LOG_TYPE_DEBUG, v64, buf, v66);
      return;
    }
LABEL_78:
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  }
  v47 = a3[5];
  if (!v47)
    goto LABEL_100;
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  if (v47[18] != 11)
    goto LABEL_100;
  if (!HTTPConnectionCacheKey::isFirstPartyResource(*((HTTPConnectionCacheKey **)this + 35))
    && (objc_msgSend(*((id *)this + 11), "_allowPrivateAccessTokensForThirdParty") & 1) == 0)
  {
    Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(v48);
    v51 = *(void **)(v50 + 2736);
    v52 = CFURLCopyHostName(*(CFURLRef *)(objc_msgSend(*((id *)this + 11), "_inner", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher)+ 8));
    if (!objc_msgSend(v51, "checkOriginAllowedAsThirdParty:", (id)CFMakeCollectable(v52)))goto LABEL_100;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v53 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v98 = *((_QWORD *)this + 99);
    *(_DWORD *)buf = 138543362;
    *(_QWORD *)&buf[4] = v98;
    _os_log_debug_impl(&dword_183ECA000, v53, OS_LOG_TYPE_DEBUG, "%{public}@ handling PAT Challenge after use cred", buf, 0xCu);
  }
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v54 = (void *)a3[8];
  Auth = AuthenticationState::getAuth(*((AuthenticationState **)this + 97), 0);
  if (!v54 || (v56 = Auth, v57 = objc_msgSend(v54, "_inner"), !v56) || (v58 = *(_QWORD *)(v57 + 88)) == 0)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v90 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v91 = *((_QWORD *)this + 99);
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v91;
      _os_log_impl(&dword_183ECA000, v90, OS_LOG_TYPE_DEFAULT, "%{public}@ unable to handle PAT challenge", buf, 0xCu);
    }
LABEL_162:
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC0BLL);
    return;
  }
  v59 = (void *)*((_QWORD *)this + 11);
  v60 = *(__CFArray **)(v56 + 232);
  isFirstPartyResource = HTTPConnectionCacheKey::isFirstPartyResource(*((HTTPConnectionCacheKey **)this + 35));
  HTTPProtocol::askPATForCreds(this, (__CFHTTPMessage *)(v58 - 16), v60, !isFirstPartyResource, objc_msgSend(v59, "_allowPrivateAccessTokensForThirdParty"), *(const __CFURL **)(objc_msgSend(v59, "_inner") + 32));
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v62 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v63 = *((_QWORD *)this + 99);
    *(_DWORD *)buf = 138543362;
    *(_QWORD *)&buf[4] = v63;
    v64 = "%{public}@ will wait on PAT for creds";
    v65 = v62;
    v66 = 12;
    goto LABEL_172;
  }
}

void sub_183F93F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke_3(uint64_t a1, int a2, char a3)
{
  _QWORD *v5;
  NSObject *v6;
  _QWORD v8[5];
  int v9;
  char v10;

  v5 = *(_QWORD **)(a1 + 32);
  (*(void (**)(_QWORD *))(*v5 + 40))(v5);
  v6 = v5[20];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN4Tube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicyb_block_invoke;
  v8[3] = &__block_descriptor_45_e5_v8__0l;
  v8[4] = v5;
  v9 = a2;
  v10 = a3;
  dispatch_async(v6, v8);
  return (*(uint64_t (**)(_QWORD *))(*v5 + 48))(v5);
}

uint64_t AuthenticationState::setOption(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  char v7;
  uint64_t (***v8)();
  uint64_t v9;
  _QWORD v11[3];
  uint64_t (***v12)();
  uint64_t (**v13)();
  char v14;
  uint64_t (***v15)();
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v6 = *(_QWORD *)(a1 + 144);
  if (a2 != 1 || a3)
  {
    AuthenticationConfiguration::setOption(v6, a2, a3);
    if (a2)
      return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
    v13 = &off_1E14F05E8;
    v14 = a3;
    v15 = &v13;
    AuthenticationState::_foreachAuthenticationInfo(a1, (uint64_t)&v13);
    v8 = v15;
    if (v15 == &v13)
    {
      v9 = 4;
      v8 = &v13;
      goto LABEL_13;
    }
  }
  else
  {
    v7 = *(_BYTE *)(v6 + 8);
    *(_BYTE *)(v6 + 8) = v7 & 0xFD;
    if ((v7 & 2) == 0)
      return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
    v11[0] = &off_1E14F0630;
    v12 = (uint64_t (***)())v11;
    AuthenticationState::_foreachAuthenticationInfo(a1, (uint64_t)v11);
    v8 = v12;
    if (v12 == v11)
    {
      v9 = 4;
      v8 = (uint64_t (***)())v11;
LABEL_13:
      (*v8)[v9]();
      return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
    }
  }
  if (v8)
  {
    v9 = 5;
    goto LABEL_13;
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
}

void sub_183F94124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  uint64_t v17;
  char *v18;
  char *v20;
  uint64_t v21;

  v20 = a17;
  if (a17 == v18)
  {
    v21 = 4;
    v20 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:
  pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
  _Unwind_Resume(a1);
}

uint64_t AuthenticationConfiguration::setOption(uint64_t result, int a2, int a3)
{
  char v3;
  char v4;
  char v5;
  char v6;

  if (a2 == 2)
  {
    v5 = *(_BYTE *)(result + 8);
    if (a3)
      v4 = v5 | 4;
    else
      v4 = v5 & 0xFB;
  }
  else if (a2 == 1)
  {
    v6 = *(_BYTE *)(result + 8);
    if (a3)
      v4 = v6 | 2;
    else
      v4 = v6 & 0xFD;
  }
  else
  {
    if (a2)
      return result;
    v3 = *(_BYTE *)(result + 8);
    if (a3)
      v4 = v3 | 1;
    else
      v4 = v3 & 0xFE;
  }
  *(_BYTE *)(result + 8) = v4;
  return result;
}

uint64_t isLikeChallenge(CFTypeRef *a1, CFTypeRef *a2)
{
  if (!a1 || !a2)
    return 0;
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  return CFEqual(a1[5], a2[5]);
}

void HTTPProtocol::sendDidReceiveAuthChallenge(HTTPProtocol *this, _CFURLAuthChallenge *a2)
{
  uint64_t v3;
  uint64_t v5;
  void *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = *((_QWORD *)this + 12);
    if (v3)
    {
      v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v3 + 16))(*((_QWORD *)this + 12));
      v6 = (void *)MEMORY[0x186DB8C8C](v5);
      (*(void (**)(_QWORD, _CFURLAuthChallenge *))(**((_QWORD **)this + 12) + 104))(*((_QWORD *)this + 12), a2);
      objc_autoreleasePoolPop(v6);
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    }
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v8 = *((_QWORD *)this + 99);
      v9 = 138543362;
      v10 = v8;
      _os_log_error_impl(&dword_183ECA000, v7, OS_LOG_TYPE_ERROR, "%{public}@ does not have a valid challenge so canceling", (uint8_t *)&v9, 0xCu);
    }
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC19);
  }
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolDidReceiveAuthenticationChallenge(URLConnectionLoader_Classic *this, _CFURLAuthChallenge *a2)
{
  URLConnectionLoader_Classic::protocolDidReceiveAuthenticationChallenge((URLConnectionLoader_Classic *)((char *)this - 56), a2);
}

void URLConnectionLoader_Classic::protocolDidReceiveAuthenticationChallenge(URLConnectionLoader_Classic *this, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[6];
  _QWORD block[6];

  if (cf)
    CFRetain(cf);
  v4 = MEMORY[0x1E0C809B0];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN27URLConnectionLoader_Classic41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke;
  v7[3] = &__block_descriptor_48_e5_v8__0l;
  v7[4] = this;
  v7[5] = cf;
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v6 = *((_QWORD *)this + 5);
  block[0] = v4;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v7;
  block[5] = v5;
  dispatch_async(v6, block);
}

void ___ZN19URLConnectionLoader29continueWithCacheLookupResultEP12NSURLRequestPK20_CFCachedURLResponse23NSURLRequestCachePolicy_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  const void *v5;
  int v6;
  const void *v7;

  v4 = *(void **)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  if (a2)
  {
    v5 = *(const void **)(a1 + 48);
    v6 = (*(uint64_t (**)(uint64_t, const void *))(*(_QWORD *)a2 + 136))(a2, v5);
    URLConnectionLoader::loadWithCacheValidity(v3, v4, v5, v6);
  }
  else
  {
    objc_msgSend(*(id *)(v3 + 64), "_cachePolicy");
    URLConnectionLoader::loadWithWhatToDo(v3, v4, 0, 0, 0);
  }

  v7 = *(const void **)(a1 + 48);
  if (v7)
    CFRelease(v7);
}

uint64_t URLConnectionLoader::loadWithCacheValidity(uint64_t a1, void *a2, const void *a3, int a4)
{
  uint64_t v8;
  int v9;
  uint64_t v10;

  v8 = objc_msgSend(*(id *)(a1 + 64), "_cachePolicy");
  if (a4 == 1)
  {
    v10 = 0;
    v9 = 1;
  }
  else if (a4)
  {
    v9 = 0;
    v10 = 0;
  }
  else
  {
    a3 = 0;
    v9 = 2 * (v8 == 3);
    if (v8 == 3)
      v10 = -1008;
    else
      v10 = 0;
  }
  return URLConnectionLoader::loadWithWhatToDo(a1, a2, a3, v10, v9);
}

uint64_t HTTPProtocol::_protocolInterface_isCachedResponseValidNonBlocking(HTTPProtocol *this, const _CFCachedURLResponse *a2)
{
  return dword_1841E3A90[HTTPProtocol::validateCachedResponseForLoad(this, a2)];
}

void `non-virtual thunk to'URLConnection::_irl_release(URLConnection *this)
{
  CFRelease((char *)this - 24);
}

URLConnection *`non-virtual thunk to'URLConnection::_irl_retain(URLConnection *this)
{
  CFRetain((char *)this - 24);
  return this;
}

void ___ZN27URLConnectionLoader_Classic23protocolDidSendBodyDataExxx_block_invoke(uint64_t a1)
{
  URLConnectionLoader::protocolDidSendBodyData(*(URLConnectionLoader **)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
}

uint64_t ___ZN19URLConnectionLoader15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2_5(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 40);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 96))(*(_QWORD *)(a1 + 48));
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 64))(*(_QWORD *)(a1 + 48));
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 48) - 16));
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 72))(*(_QWORD *)(v2 + 32));
}

void HTTPProtocol::_protocolInterface_cancelLoad(HTTPProtocol *this)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  void (**v5)(_QWORD, _QWORD, _QWORD);
  void (**v6)(_QWORD, _QWORD, _QWORD);

  v2 = *((unsigned int *)this + 48);
  v3 = v2 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
  if ((v2 & 0x100000) == 0)
  {
    *((_WORD *)this + 98) = WORD2(v3);
    *((_DWORD *)this + 48) = v2 | 0x100000;
    if ((v3 & 0x80) == 0)
    {
      v4 = *((_QWORD *)this + 34);
      if (v4)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 128))(v4);
    }
    HTTPProtocol::cleanupStreams(this);
  }
  v5 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 54);
  if (v5)
  {
    *((_QWORD *)this + 54) = 0;
    v5[2](v5, 0, 1);
    _Block_release(v5);
  }
  v6 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 52);
  if (v6)
  {
    *((_QWORD *)this + 52) = 0;
    v6[2](v6, 0, 1);
    _Block_release(v6);
  }
}

void ___ZN11RequestBody27_onqueue_updateUploadStatusElb_block_invoke_2(uint64_t a1)
{
  URLProtocol::uploadActivityOccurred(*(URLProtocol **)(a1 + 32), *(_QWORD *)(a1 + 40));
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
}

void URLConnectionLoader::protocolDidSendBodyData(URLConnectionLoader *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  RedirectionRecorder *var12;
  uint64_t v9;
  uint64_t v10;
  const __CFAllocator *v11;
  const void *v12;
  InterfaceRequiredForLoader *var5;
  _QWORD v14[7];
  void (**v15)(AutoString *__hidden);
  CFStringRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (this->var21)
  {
    var12 = this->var12;
    if (var12)
    {
      (*(void (**)(RedirectionRecorder *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)var12 + 120))(var12, a2, a3, a4);
    }
    else
    {
      v9 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_33_9621, 2);
      if (v9)
      {
        v10 = v9;
        if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v9 + 16))(v9, "Did Send Body", 0))
        {
          v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v12 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))this->var0 + 3))(this);
          v15 = &off_1E14E4818;
          v17 = 0;
          v18 = 0;
          v16 = CFStringCreateWithCString(v11, "Loader", 0x8000100u);
          (*(void (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)v10 + 64))(v10, v16, v12);
          AutoString::~AutoString((AutoString *)&v15);
          if (v12)
            CFRelease(v12);
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v10 + 72))(v10, "Bytes Written", CFSTR("%lld"));
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v10 + 72))(v10, "Total Written", CFSTR("%lld"));
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v10 + 72))(v10, "Total Expected", CFSTR("%lld"));
          (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
        }
      }
      URLConnectionLoader::touchConnection(this);
      if (a2 >= 1 && (*(_BYTE *)&this->var28 & 2) != 0)
      {
        var5 = this->var5;
        v14[0] = MEMORY[0x1E0C809B0];
        v14[1] = 3221225472;
        v14[2] = ___ZN19URLConnectionLoader23protocolDidSendBodyDataExxx_block_invoke_2;
        v14[3] = &__block_descriptor_56_e35_v16__0__LoaderClientInterface_____8l;
        v14[4] = a2;
        v14[5] = a3;
        v14[6] = a4;
        (*(void (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v14);
      }
    }
  }
}

void sub_183F94B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void URLProtocol::uploadActivityOccurred(URLProtocol *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  *((CFAbsoluteTime *)this + 4) = CFAbsoluteTimeGetCurrent();
  if (a2 >= 1)
  {
    v4 = *((_QWORD *)this + 12);
    if (v4)
    {
      v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4 + 16))(*((_QWORD *)this + 12));
      v6 = (void *)MEMORY[0x186DB8C8C](v5);
      *((_QWORD *)this + 6) += a2;
      (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 12) + 80))(*((_QWORD *)this + 12), a2);
      objc_autoreleasePoolPop(v6);
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    }
  }
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolDidSendBodyData(URLConnectionLoader_Classic *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[8];
  _QWORD block[6];

  v5 = MEMORY[0x1E0C809B0];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN27URLConnectionLoader_Classic23protocolDidSendBodyDataExxx_block_invoke;
  v8[3] = &__block_descriptor_64_e5_v8__0l;
  v8[4] = (char *)this - 56;
  v8[5] = a2;
  v8[6] = a3;
  v8[7] = a4;
  v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 3) + 64))(*((_QWORD *)this - 3));
  v7 = *((_QWORD *)this - 2);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v8;
  block[5] = v6;
  dispatch_async(v7, block);
}

uint64_t HTTPConnectionCacheEntry::_notifyNextProtocolOfOpenConnection(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  BOOL v13;
  __int128 v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  HTTPConnectionCacheEntry::RequestQueue *v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  HTTPConnectionCacheEntry::EnqueuedRequest *v22;
  HTTPConnectionCacheEntry::EnqueuedRequest *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  BOOL doesConnAuthApply;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  _QWORD *v39;
  HTTPConnectionCacheEntry::EnqueuedRequest *v40;
  uint64_t v41;
  uint64_t v42;
  HTTPRequestMessage *v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  char v58;
  unint64_t *v59;
  unint64_t v60;
  uint64_t v61;
  HTTPConnectionCacheEntry::EnqueuedRequest *v63[2];
  uint64_t v64;
  std::__shared_weak_count *v65;
  HTTPConnectionCacheEntry::EnqueuedRequest *v66[3];
  std::__shared_weak_count *v67;
  __int128 v68;
  HTTPConnectionCacheEntry::RequestQueue *v69[2];
  uint64_t v70;
  BOOL v71;

  v6 = *(_QWORD *)(*(_QWORD *)(*a2 + 64) + 56);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 88))(v6, 1);
  v7 = *(_DWORD *)(a1 + 120);
  v8 = (v7 - 1);
  if (v7 < 1)
  {
    v12 = 0;
    goto LABEL_82;
  }
  do
  {
    v9 = *a2;
    if (v8 > *(int *)(*a2 + 240)
      && (v69[0] = 0,
          v69[1] = (HTTPConnectionCacheEntry::RequestQueue *)v69,
          v70 = 0x2020000000,
          v10 = *(_QWORD *)(v9 + 160),
          v71 = v10 != 0,
          _Block_object_dispose(v69, 8),
          v10)
      || (v8 & 0x80000000) != 0
      || (v11 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8),
          v8 > (unint64_t)((*(_QWORD *)(*(_QWORD *)(a1 + 104) + 16) - v11) >> 4)))
    {
      v12 = 0;
      goto LABEL_7;
    }
    v14 = *(_OWORD *)(v11 + 16 * v8);
    *(_OWORD *)v69 = v14;
    v15 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
    if (*((_QWORD *)&v14 + 1))
    {
      v16 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
      do
        v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }
    v18 = (HTTPConnectionCacheEntry::RequestQueue *)v14;
    if (!(_QWORD)v14 || (v19 = *(_QWORD *)(v14 + 16), *(_QWORD *)(v14 + 24) - v19 < 16))
    {
      v12 = 0;
      if (*((_QWORD *)&v14 + 1))
        goto LABEL_77;
      goto LABEL_7;
    }
    v20 = 0;
    do
    {
      if (v20 < 0)
      {
        v22 = 0;
        v23 = 0;
        v68 = 0uLL;
      }
      else
      {
        v21 = *(_OWORD *)(v19 + 16 * v20);
        v68 = v21;
        v22 = (HTTPConnectionCacheEntry::EnqueuedRequest *)*((_QWORD *)&v21 + 1);
        v23 = (HTTPConnectionCacheEntry::EnqueuedRequest *)v21;
        if (*((_QWORD *)&v21 + 1))
        {
          v24 = (unint64_t *)(*((_QWORD *)&v21 + 1) + 8);
          do
            v25 = __ldxr(v24);
          while (__stxr(v25 + 1, v24));
        }
      }
      v26 = (*(uint64_t (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(_QWORD *)v23 + 80))(v23);
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v26 + 176))(v26))
      {
        HTTPConnectionCacheEntry::RequestQueue::removeRequest(v18, v20);
        v12 = 0;
      }
      else
      {
        v27 = *a2;
        v28 = (std::__shared_weak_count *)a2[1];
        v66[2] = *(HTTPConnectionCacheEntry::EnqueuedRequest **)a2;
        v67 = v28;
        if (v28)
        {
          p_shared_owners = (unint64_t *)&v28->__shared_owners_;
          do
            v30 = __ldxr(p_shared_owners);
          while (__stxr(v30 + 1, p_shared_owners));
        }
        v66[0] = v23;
        v66[1] = v22;
        if (v22)
        {
          v31 = (unint64_t *)((char *)v22 + 8);
          do
            v32 = __ldxr(v31);
          while (__stxr(v32 + 1, v31));
        }
        doesConnAuthApply = HTTPConnectionCacheEntry::_doesConnAuthApply(*(_QWORD *)(v27 + 176), *(std::__shared_weak_count **)(v27 + 184), v66);
        if (v22)
        {
          v34 = (unint64_t *)((char *)v22 + 8);
          do
            v35 = __ldaxr(v34);
          while (__stlxr(v35 - 1, v34));
          if (!v35)
          {
            (*(void (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(_QWORD *)v22 + 16))(v22);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v22);
          }
        }
        v36 = v67;
        if (!v67)
          goto LABEL_41;
        v37 = (unint64_t *)&v67->__shared_owners_;
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
          if (!doesConnAuthApply)
          {
LABEL_49:
            v12 = 0;
            ++v20;
            goto LABEL_67;
          }
        }
        else
        {
LABEL_41:
          if (!doesConnAuthApply)
            goto LABEL_49;
        }
        v39 = *(_QWORD **)(a1 + 112);
        v40 = (HTTPConnectionCacheEntry::EnqueuedRequest *)v68;
        v41 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v68 + 80))(v68);
        v42 = HTTPConnectionCacheEntry::EnqueuedRequest::mutableRequest(v40);
        if (v42)
        {
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          if (*(_BYTE *)(v42 + 40))
            v43 = 0;
          else
            v43 = (HTTPRequestMessage *)(v42 + 16);
        }
        else
        {
          v43 = 0;
        }
        AuthenticationCache::processRequest(v39, v41, v43);
        HTTPConnectionCacheEntry::RequestQueue::removeRequest(v69[0], v20);
        v44 = (std::__shared_weak_count *)a2[1];
        v64 = *a2;
        v65 = v44;
        if (v44)
        {
          v45 = (unint64_t *)&v44->__shared_owners_;
          do
            v46 = __ldxr(v45);
          while (__stxr(v46 + 1, v45));
        }
        v47 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
        v63[0] = v40;
        v63[1] = *((HTTPConnectionCacheEntry::EnqueuedRequest **)&v68 + 1);
        if (*((_QWORD *)&v68 + 1))
        {
          v48 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
          do
            v49 = __ldxr(v48);
          while (__stxr(v49 + 1, v48));
        }
        v12 = HTTPConnectionCacheEntry::_dispatchConnectionToProtocol(a1, &v64, v63, a3);
        if (v47)
        {
          v50 = (unint64_t *)&v47->__shared_owners_;
          do
            v51 = __ldaxr(v50);
          while (__stlxr(v51 - 1, v50));
          if (!v51)
          {
            ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
            std::__shared_weak_count::__release_weak(v47);
          }
        }
        v52 = v65;
        if (v65)
        {
          v53 = (unint64_t *)&v65->__shared_owners_;
          do
            v54 = __ldaxr(v53);
          while (__stlxr(v54 - 1, v53));
          if (!v54)
          {
            ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
            std::__shared_weak_count::__release_weak(v52);
          }
        }
      }
LABEL_67:
      v55 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
      if (*((_QWORD *)&v68 + 1))
      {
        v56 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
        do
          v57 = __ldaxr(v56);
        while (__stlxr(v57 - 1, v56));
        if (!v57)
        {
          ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
          std::__shared_weak_count::__release_weak(v55);
        }
      }
      v18 = v69[0];
      v19 = *((_QWORD *)v69[0] + 2);
      if (v20 >= (*((_QWORD *)v69[0] + 3) - v19) >> 4)
        v58 = 1;
      else
        v58 = v12;
    }
    while ((v58 & 1) == 0);
    v15 = (std::__shared_weak_count *)v69[1];
    if (v69[1])
    {
LABEL_77:
      v59 = (unint64_t *)&v15->__shared_owners_;
      do
        v60 = __ldaxr(v59);
      while (__stlxr(v60 - 1, v59));
      if (!v60)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
LABEL_7:
    v13 = v8-- < 1;
  }
  while (!v13 && (v12 & 1) == 0);
LABEL_82:
  if ((*(_BYTE *)(a1 + 32) & 4) != 0
    && (HTTPConnectionCacheEntry::hasRequestsEnqueued((HTTPConnectionCacheEntry *)a1) & 1) == 0)
  {
    HTTPConnectionCacheEntry::_removeAllConnections((HTTPConnectionCacheEntry *)a1, 0);
  }
  v61 = *(_QWORD *)(*(_QWORD *)(*a2 + 64) + 56);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v61 + 88))(v61, v12 ^ 1u);
}

void sub_183F95110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void NWIOConnection::setIsIdle(NWIOConnection *this, int a2)
{
  NSObject *v4;
  double Current;
  uint64_t v6;
  NSObject *v7;
  nw_protocol_metadata_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v9 = *((_QWORD *)this + 36);
    v10 = 134218240;
    v11 = v9;
    v12 = 1024;
    v13 = a2;
    _os_log_debug_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEBUG, "Connection %llu: set is idle %{BOOL}d", (uint8_t *)&v10, 0x12u);
  }
  if (*((_QWORD *)this + 34))
  {
    nw_connection_add_client_event();
    if (a2)
    {
      Current = CFAbsoluteTimeGetCurrent();
      v6 = *((_QWORD *)this + 25);
      if (v6)
        *(double *)(v6 + 176) = Current;
    }
    if (*((_BYTE *)this + 680))
    {
      v7 = nw_protocol_copy_tcp_definition();
      v8 = nw_connection_copy_protocol_metadata(*((nw_connection_t *)this + 34), v7);
      if (v8)
      {
        nw_tcp_set_no_wake_from_sleep();
        nw_release(v8);
      }
      if (v7)
        nw_release(v7);
    }
  }
}

void sub_183F952B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  nw_release(v1);
  if (v2)
    nw_release(v2);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12XTubeManager24invalidateAllConnectionsEb_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  void *v5;
  NSObject *v6;
  uint64_t i;
  const __CFArray *v8;
  CFMutableDictionaryRef *v9;
  uint64_t j;
  CFMutableDictionaryRef v11;
  const __CFArray *v12;
  uint64_t v13;
  CFMutableDictionaryRef *v14;
  CFMutableDictionaryRef v15;
  __int128 v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  void *v19;
  char v20;
  uint64_t v21;
  CFRange v22;
  CFRange v23;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v2 + 32);
  if (v3)
  {
    v4 = *(_BYTE *)(a1 + 40);
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v3 + 112));
    v5 = *(void **)(v3 + 160);
    if (H2CoalescingLog(void)::onceToken != -1)
      dispatch_once(&H2CoalescingLog(void)::onceToken, &__block_literal_global_6187);
    v6 = H2CoalescingLog(void)::onceLog;
    if (os_log_type_enabled((os_log_t)H2CoalescingLog(void)::onceLog, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v17) = 134217984;
      *(_QWORD *)((char *)&v17 + 4) = v5;
      _os_log_debug_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEBUG, "removing all entries config %p", (uint8_t *)&v17, 0xCu);
    }
    objc_msgSend(v5, "removeAllObjects");
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v3 + 128));
    *(_QWORD *)&v17 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v17 + 1) = 3221225472;
    v18 = ___ZN11TubeManager24invalidateAllConnectionsEb_block_invoke;
    v19 = &__block_descriptor_33_e51_v16__0__MetaConnectionCache________CFAllocator_i__8l;
    v20 = v4;
    for (i = 80; i != 104; i += 8)
    {
      if (*(_QWORD *)(v3 + i))
        ((void (*)(__int128 *))v18)(&v17);
    }
    v8 = *(const __CFArray **)(v3 + 144);
    v22.length = CFArrayGetCount(v8);
    v22.location = 0;
    CFArrayApplyFunction(v8, v22, (CFArrayApplierFunction)RetainableTypedArray<Tube *>::_invoke, &__block_literal_global_6_5526);
    TubeManager::releaseConnectionCaches((TubeManager *)v3);
  }
  v9 = *(CFMutableDictionaryRef **)(v2 + 40);
  if (v9)
  {
    CFDictionaryRemoveAllValues(v9[14]);
    CFDictionaryRemoveAllValues(v9[16]);
    for (j = 0; j != 3; ++j)
    {
      v11 = v9[j + 10];
      if (v11)
        (*(void (**)(CFMutableDictionaryRef, _QWORD))(*(_QWORD *)v11 + 120))(v11, 0);
    }
    v12 = v9[18];
    v23.length = CFArrayGetCount(v12);
    v23.location = 0;
    CFArrayApplyFunction(v12, v23, (CFArrayApplierFunction)RetainableTypedArray<STube *>::_invoke, &__block_literal_global_6_16835);
    v13 = 0;
    v14 = v9 + 10;
    do
    {
      v15 = v14[v13];
      if (v15)
      {
        (*(void (**)(CFMutableDictionaryRef))(*(_QWORD *)v15 + 48))(v15);
        v14[v13] = 0;
      }
      ++v13;
    }
    while (v13 != 3);
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

uint64_t TubeManager::releaseConnectionCaches(TubeManager *this)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t result;

  v2 = 0;
  v3 = (char *)this + 80;
  do
  {
    v4 = *(_QWORD *)&v3[v2];
    if (v4)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
      *(_QWORD *)&v3[v2] = 0;
    }
    v2 += 8;
  }
  while (v2 != 24);
  result = *((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t `non-virtual thunk to'URLConnectionLoader::_loaderEvent_ResumeProtocolLoad(URLConnectionLoader *this)
{
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)&__block_literal_global_96);
}

void ___ZN11HTTP2Stream27_onqueue_notifyStreamClosedEv_block_invoke_2(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 176))
  {
    _Block_release(*(const void **)(v2 + 24));
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) = 0;
  }
  else
  {
    (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) + 16))();
  }
}

uint64_t `non-virtual thunk to'URLConnectionLoader::_loaderEvent_SuspendProtocolLoad(URLConnectionLoader *this)
{
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)&__block_literal_global_95_9562);
}

void ___ZN24HTTPConnectionCacheEntry18connLostConnectionENSt3__110shared_ptrI14HTTPConnectionEE_block_invoke(_QWORD *a1)
{
  HTTPConnectionCacheEntry *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8[2];

  v2 = (HTTPConnectionCacheEntry *)a1[6];
  v3 = (std::__shared_weak_count *)a1[5];
  v8[0] = a1[4];
  v8[1] = (uint64_t)v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  HTTPConnectionCacheEntry::_connectionWasLost(v2, v8);
  if (v3)
  {
    v6 = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_183F95708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL HTTPConnectionCacheEntry::_removeConnection(HTTPConnectionCacheEntry::ConnectionArray **a1, uint64_t *a2)
{
  HTTPConnectionCacheEntry::ConnectionArray *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v22[2];

  v4 = a1[12];
  v5 = *a2;
  v6 = (std::__shared_weak_count *)a2[1];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  if (!v5)
  {
    v12 = -1;
    if (!v6)
      goto LABEL_19;
    goto LABEL_15;
  }
  v10 = (char *)*((_QWORD *)v4 + 1);
  v9 = (char *)*((_QWORD *)v4 + 2);
  v11 = v10;
  if (v10 != v9)
  {
    while (*(_QWORD *)v11 != v5)
    {
      v11 += 16;
      if (v11 == v9)
      {
        v11 = v9;
        break;
      }
    }
  }
  if (v11 == v9)
    v12 = -1;
  else
    v12 = (v11 - v10) >> 4;
  if (v6)
  {
LABEL_15:
    v13 = (unint64_t *)&v6->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
LABEL_19:
  if (v12 != -1)
  {
    HTTPConnectionCacheEntry::ConnectionArray::stopAndRemove(a1[12], v12, 0);
    v15 = *a2;
    v16 = (std::__shared_weak_count *)a2[1];
    v22[0] = v15;
    v22[1] = (uint64_t)v16;
    if (v16)
    {
      v17 = (unint64_t *)&v16->__shared_owners_;
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }
    HTTPConnectionCacheEntry::_connectionWasLost((HTTPConnectionCacheEntry *)a1, v22);
    if (v16)
    {
      v19 = (unint64_t *)&v16->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  return v12 != -1;
}

void sub_183F9586C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTPConnectionCacheEntry::_connectionWasLost(HTTPConnectionCacheEntry *this, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  char v7;
  char v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  BOOL v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  HTTPConnectionCacheEntry::RequestQueue *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  void *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  char v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  char v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  int v53;
  const char *v54;
  HTTPConnectionCacheEntry::EnqueuedRequest *v55[2];
  uint64_t v56;
  std::__shared_weak_count *v57;
  __CFString v58;
  std::__shared_weak_count *v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  uint64_t v62;
  uint64_t v63;

  if (*a2)
  {
    v4 = (std::__shared_weak_count *)a2[1];
    v58.length = *a2;
    v59 = v4;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    v7 = HTTPConnectionCacheEntry::_removeConnection(this, &v58.length);
    v8 = v7;
    if (!v4)
      goto LABEL_9;
    v9 = (unint64_t *)&v4->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      if ((v8 & 1) != 0)
        return;
    }
    else
    {
LABEL_9:
      if ((v7 & 1) != 0)
        return;
    }
    if ((*((_BYTE *)this + 32) & 8) != 0
      && ((*((_BYTE *)this + 32) & 0x10) == 0 || (*((_BYTE *)this + 32) & 0x60) == 0x20))
    {
      v11 = *a2;
      v60 = 0;
      v61 = (std::__shared_weak_count *)&v60;
      v62 = 0x2020000000;
      v63 = *(_QWORD *)(v11 + 232);
      v12 = v63;
      _Block_object_dispose(&v60, 8);
      if (v12 <= 1 && (int)HTTPConnection::getPendingResponseCount((HTTPConnection *)*a2) >= 1)
        *((_BYTE *)this + 32) |= 0x40u;
    }
  }
  v13 = *((_DWORD *)this + 30);
  v14 = (v13 - 1);
  if (v13 >= 1)
  {
    do
    {
      if ((v14 & 0x80000000) != 0
        || (v15 = *(_QWORD *)(*((_QWORD *)this + 13) + 8),
            v14 > (unint64_t)((*(_QWORD *)(*((_QWORD *)this + 13) + 16) - v15) >> 4)))
      {
        v16 = 0;
      }
      else
      {
        v18 = v15 + 16 * v14;
        v20 = *(HTTPConnectionCacheEntry::RequestQueue **)v18;
        v19 = *(std::__shared_weak_count **)(v18 + 8);
        if (v19)
        {
          v21 = (unint64_t *)&v19->__shared_owners_;
          do
            v22 = __ldxr(v21);
          while (__stxr(v22 + 1, v21));
        }
        if (v20 && (v23 = *((_QWORD *)v20 + 2), *((_QWORD *)v20 + 3) - v23 >= 16))
        {
          v26 = 0;
          do
          {
            if (v26 < 0)
            {
              v29 = 0;
              v28 = 0;
            }
            else
            {
              v27 = v23 + 16 * v26;
              v29 = *(void **)v27;
              v28 = *(std::__shared_weak_count **)(v27 + 8);
              if (v28)
              {
                v30 = (unint64_t *)&v28->__shared_owners_;
                do
                  v31 = __ldxr(v30);
                while (__stxr(v31 + 1, v30));
              }
            }
            v32 = (*(uint64_t (**)(void *))(*(_QWORD *)v29 + 80))(v29);
            if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v32 + 176))(v32))
            {
              HTTPConnectionCacheEntry::RequestQueue::removeRequest(v20, v26);
              v16 = 0;
            }
            else
            {
              HIDWORD(v58.data) = 0;
              v58.isa = v29;
              v58.info = (uint64_t)v28;
              if (v28)
              {
                v36 = (unint64_t *)&v28->__shared_owners_;
                do
                  v37 = __ldxr(v36);
                while (__stxr(v37 + 1, v36));
              }
              HTTPConnectionCacheEntry::_findOrCreateEmptyConnection(&v60, (uint64_t)this, &v58, (int *)&v58.data + 1);
              if (v28)
              {
                v38 = (unint64_t *)&v28->__shared_owners_;
                do
                  v39 = __ldaxr(v38);
                while (__stlxr(v39 - 1, v38));
                if (!v39)
                {
                  ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
                  std::__shared_weak_count::__release_weak(v28);
                }
              }
              v16 = 0;
              v40 = 1;
              switch(HIDWORD(v58.data))
              {
                case 0:
                  v40 = 0;
                  ++v26;
                  goto LABEL_80;
                case 1:
                  if (!v60)
                  {
                    v53 = 1460;
                    v54 = "conn";
LABEL_93:
                    __assert_rtn("_connectionWasLost", "HTTPConnectionCacheEntry.cpp", v53, v54);
                  }
                  HTTPConnectionCacheEntry::RequestQueue::removeRequest(v20, v26);
                  v56 = v60;
                  v57 = v61;
                  if (v61)
                  {
                    v41 = (unint64_t *)&v61->__shared_owners_;
                    do
                      v42 = __ldxr(v41);
                    while (__stxr(v42 + 1, v41));
                  }
                  v55[0] = (HTTPConnectionCacheEntry::EnqueuedRequest *)v29;
                  v55[1] = (HTTPConnectionCacheEntry::EnqueuedRequest *)v28;
                  if (v28)
                  {
                    v43 = (unint64_t *)&v28->__shared_owners_;
                    do
                      v44 = __ldxr(v43);
                    while (__stxr(v44 + 1, v43));
                  }
                  v40 = HTTPConnectionCacheEntry::_dispatchConnectionToProtocol((uint64_t)this, &v56, v55, 0);
                  if (v28)
                  {
                    v45 = (unint64_t *)&v28->__shared_owners_;
                    do
                      v46 = __ldaxr(v45);
                    while (__stlxr(v46 - 1, v45));
                    if (!v46)
                    {
                      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
                      std::__shared_weak_count::__release_weak(v28);
                    }
                  }
                  v47 = v57;
                  if (v57)
                  {
                    v48 = (unint64_t *)&v57->__shared_owners_;
                    do
                      v49 = __ldaxr(v48);
                    while (__stlxr(v49 - 1, v48));
                    if (!v49)
                    {
                      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
                      std::__shared_weak_count::__release_weak(v47);
                    }
                  }
LABEL_80:
                  v16 = v40;
LABEL_81:
                  v50 = v61;
                  if (v61)
                  {
                    v51 = (unint64_t *)&v61->__shared_owners_;
                    do
                      v52 = __ldaxr(v51);
                    while (__stlxr(v52 - 1, v51));
                    if (!v52)
                    {
                      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
                      std::__shared_weak_count::__release_weak(v50);
                    }
                  }
                  break;
                case 2:
                  goto LABEL_80;
                case 3:
                  goto LABEL_81;
                default:
                  v53 = 1500;
                  v54 = "status == ConnectionSearchStatus::NoConnection";
                  goto LABEL_93;
              }
            }
            if (v28)
            {
              v33 = (unint64_t *)&v28->__shared_owners_;
              do
                v34 = __ldaxr(v33);
              while (__stlxr(v34 - 1, v33));
              if (!v34)
              {
                ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
                std::__shared_weak_count::__release_weak(v28);
              }
            }
            v23 = *((_QWORD *)v20 + 2);
            if (v26 >= (*((_QWORD *)v20 + 3) - v23) >> 4)
              v35 = 1;
            else
              v35 = v16;
          }
          while ((v35 & 1) == 0);
        }
        else
        {
          v16 = 0;
        }
        if (v19)
        {
          v24 = (unint64_t *)&v19->__shared_owners_;
          do
            v25 = __ldaxr(v24);
          while (__stlxr(v25 - 1, v24));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
        }
      }
      v17 = v14-- < 1;
    }
    while (!v17 && (v16 & 1) == 0);
  }
  if ((*((_BYTE *)this + 32) & 4) != 0 && (HTTPConnectionCacheEntry::hasRequestsEnqueued(this) & 1) == 0)
    HTTPConnectionCacheEntry::_removeAllConnections(this, 0);
}

void sub_183F95D0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN19URLConnectionLoader23_loaderEvent_CancelLoadENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  void *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t block;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  void *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;

  v1 = a1[4];
  v2 = *(_QWORD *)(v1 + 144);
  if (v2)
  {
    *(_QWORD *)(v1 + 144) = 0;
    v4 = (void *)a1[5];
    v3 = (std::__shared_weak_count *)a1[6];
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    v7 = *(_QWORD *)(v1 + 168);
    if (!v7 || !*(_DWORD *)(v7 + 40))
      __assert_rtn("_onqueue_loaderEvent_CancelLoad", "URLConnectionLoader.cpp", 1326, "fLoaderSchedulingSet && !fLoaderSchedulingSet->isEmpty()");
    CFRetain((CFTypeRef)(v2 - 16));
    (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 32) + 64))(*(_QWORD *)(v1 + 32));
    v8 = *(_QWORD *)(v1 + 168);
    block = MEMORY[0x1E0C809B0];
    v20 = 3321888768;
    v21 = ___ZN19URLConnectionLoader31_onqueue_loaderEvent_CancelLoadENSt3__110shared_ptrI23CoreSchedulingSetOneOffEEP11URLProtocol_block_invoke;
    v22 = &__block_descriptor_64_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
    v23 = v1;
    v24 = v4;
    v25 = v3;
    if (v3)
    {
      v9 = (unint64_t *)&v3->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v26 = v2;
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v8 + 96))(v8, &block);
    v11 = v25;
    if (v25)
    {
      v12 = (unint64_t *)&v25->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    if (v3)
    {
      v14 = (unint64_t *)&v3->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    CFRelease((CFTypeRef)(v2 - 16));
  }
  else
  {
    v16 = a1[5];
    v17 = *(NSObject **)v16;
    v18 = *(_QWORD *)(v16 + 8);
    block = MEMORY[0x1E0C809B0];
    v20 = 3221225472;
    v21 = ___ZNK23CoreSchedulingSetOneOff29performAsyncWithTrailingBlockEU13block_pointerFvvE_block_invoke_9666;
    v22 = &unk_1E14FB138;
    v23 = v18;
    v24 = &__block_literal_global_80;
    dispatch_async(v17, &block);
  }
}

void sub_183F95FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11TubeManager24invalidateAllConnectionsEb_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 120))(a2, *(unsigned __int8 *)(a1 + 32));
}

void HTTPConnectionCacheEntry::ConnectionArray::stopAndRemove(HTTPConnectionCacheEntry::ConnectionArray *this, uint64_t a2, unsigned int a3)
{
  uint64_t v5;
  __int128 v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  __int128 *v11;
  __int128 *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  CFStreamError v17;

  if ((a2 & 0x8000000000000000) == 0)
  {
    v5 = *((_QWORD *)this + 1);
    if (a2 < (*((_QWORD *)this + 2) - v5) >> 4)
    {
      v7 = *(_OWORD *)(v5 + 16 * a2);
      v8 = *(std::__shared_weak_count **)(v5 + 16 * a2 + 8);
      if (*((_QWORD *)&v7 + 1))
      {
        v9 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      if ((_QWORD)v7)
      {
        v17.domain = 4;
        *(_QWORD *)&v17.error = 4294967292;
        HTTPConnection::_onqueue_doNotAllowMoreRequests((HTTPConnection *)v7, v17, a3);
        v11 = (__int128 *)*((_QWORD *)this + 2);
        v12 = (__int128 *)(*((_QWORD *)this + 1) + 16 * a2);
        v13 = (uint64_t)(v12 + 1);
        if (v12 + 1 != v11)
        {
          do
            v14 = (uint64_t)v12++;
          while ((__int128 *)(std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v14, v12) + 32) != v11);
          v13 = *((_QWORD *)this + 2);
        }
        while ((__int128 *)v13 != v12)
          v13 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v13 - 16);
        *((_QWORD *)this + 2) = v12;
      }
      if (v8)
      {
        p_shared_owners = (unint64_t *)&v8->__shared_owners_;
        do
          v16 = __ldaxr(p_shared_owners);
        while (__stlxr(v16 - 1, p_shared_owners));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
  }
}

void sub_183F96130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN19URLConnectionLoader32_loaderEvent_SuspendProtocolLoadEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  return result;
}

uint64_t ___ZN19URLConnectionLoader31_onqueue_loaderEvent_CancelLoadENSt3__110shared_ptrI23CoreSchedulingSetOneOffEEP11URLProtocol_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD block[6];

  v2 = a1[4];
  v3 = a1[5];
  v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = a1[7];
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 96))(v7);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 64))(v7);
  v8 = *(NSObject **)v3;
  v9 = *(_QWORD *)(v3 + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZNK23CoreSchedulingSetOneOff29performAsyncWithTrailingBlockEU13block_pointerFvvE_block_invoke_9666;
  block[3] = &unk_1E14FB138;
  block[4] = v9;
  block[5] = &__block_literal_global_83;
  dispatch_async(v8, block);
  if (v4)
  {
    v10 = (unint64_t *)&v4->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  CFRelease((CFTypeRef)(a1[7] - 16));
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 72))(*(_QWORD *)(v2 + 32));
}

void sub_183F96268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

HTTPProtocol *HTTPProtocol::_protocolInterface_haltLoad(HTTPProtocol *this)
{
  int v1;
  HTTPProtocol *v2;

  v1 = *((_DWORD *)this + 122);
  *((_DWORD *)this + 122) = v1 + 1;
  if (!v1)
  {
    this = (HTTPProtocol *)*((_QWORD *)this + 34);
    if (this)
    {
      if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
      {
        v2 = this;
        dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
        this = v2;
      }
      return (HTTPProtocol *)(*(uint64_t (**)(HTTPProtocol *, uint64_t))(*(_QWORD *)this + 72))(this, CoreSchedulingSet::getEmptySet(void)::sEmptySet);
    }
  }
  return this;
}

uint64_t ___ZN19URLConnectionLoader31_loaderEvent_ResumeProtocolLoadEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 112))(a2);
  return result;
}

void ___ZN27URLConnectionLoader_Classic21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke(uint64_t a1)
{
  const void *v2;

  URLConnectionLoader::protocolWasRedirected(*(URLConnectionLoader **)(a1 + 40), *(NSURLRequest **)(a1 + 32), *(_CFURLResponse **)(a1 + 48));
  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);

}

void ___ZN19URLConnectionLoader27protocolWasRedirected_finalEP12NSURLRequest_block_invoke(uint64_t a1)
{
  URLConnectionLoader *v2;
  id var9;
  void *v4;
  const void *v5;

  v2 = *(URLConnectionLoader **)(a1 + 40);
  v2->var14 = 1;
  if (*(_QWORD *)(a1 + 32) && (var9 = v2->var9) != 0)
  {
    v4 = (void *)objc_msgSend(var9, "originalRequest");
    if (!v4 || !haveTheSameOrigin((NSURL *)objc_msgSend(v4, "cfURL"), (NSURL *)objc_msgSend(*(id *)(a1 + 32), "cfURL")))
      objc_msgSend(v2->var9, "_releasePreventIdleSleepAssertionIfAppropriate");
    URLConnectionLoader::_private_followRedirection(v2, *(CFTypeRef *)(a1 + 32));
  }
  else if (v2->var15)
  {
    v2->var15 = 0;
    URLConnectionLoader::replayOrConsumeRedirections(v2);
  }
  v5 = *(const void **)(a1 + 32);
  if (v5)
    CFRelease(v5);
}

BOOL haveTheSameOrigin(NSURL *a1, NSURL *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int BestPortValue;

  v4 = -[NSURL host](a1, "host");
  v5 = -[NSURL host](a2, "host");
  if (v4 && v5)
  {
    if (!objc_msgSend((id)v4, "caseInsensitiveCompare:", v5))
      goto LABEL_6;
    return 0;
  }
  if (v4 | v5)
    return 0;
LABEL_6:
  v6 = -[NSURL scheme](a1, "scheme");
  v7 = -[NSURL scheme](a2, "scheme");
  if (v6 && v7)
  {
    if (objc_msgSend((id)v6, "caseInsensitiveCompare:", v7))
      return 0;
  }
  else if (v6 | v7)
  {
    return 0;
  }
  BestPortValue = getBestPortValue(a1);
  return BestPortValue == getBestPortValue(a2);
}

void URLConnectionLoader::_private_followRedirection(URLConnectionLoader *this, CFTypeRef cf)
{
  NSObject *current_queue;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  NSObject **v13;
  std::__shared_weak_count *v14;
  _QWORD v15[6];
  NSObject **v16;
  std::__shared_weak_count *v17;

  this->var13 = 1;
  if (cf)
    CFRetain(cf);
  (*(void (**)(InterfaceRequiredForLoader *))(*(_QWORD *)this->var5 + 64))(this->var5);
  current_queue = dispatch_get_current_queue();
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v15[2] = ___ZN19URLConnectionLoader26_private_followRedirectionEP12NSURLRequest_block_invoke;
  v15[3] = &unk_1E14FE140;
  v15[4] = cf;
  v15[5] = this;
  std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject  {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>(&v16, current_queue, v15);
  v13 = v16;
  v14 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  (*((void (**)(URLConnectionLoader *, NSObject ***))this->var0 + 4))(this, &v13);
  v7 = v14;
  if (v14)
  {
    v8 = (unint64_t *)&v14->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = v17;
  if (v17)
  {
    v11 = (unint64_t *)&v17->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_183F965F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32);
  _Unwind_Resume(a1);
}

void URLConnectionLoader::_loaderEvent_CancelLoad(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  NSObject **v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  NSObject *v13;
  _QWORD *v14;
  _QWORD v15[6];
  std::__shared_weak_count *v16;
  uint64_t block;
  uint64_t v18;
  uint64_t (*v19)(uint64_t);
  void *v20;
  _QWORD *v21;
  void *v22;

  if (*(_QWORD *)(a1 + 144))
  {
    v3 = MEMORY[0x1E0C809B0];
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3321888768;
    v15[2] = ___ZN19URLConnectionLoader23_loaderEvent_CancelLoadENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2;
    v15[3] = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
    v5 = *(NSObject ***)a2;
    v4 = *(std::__shared_weak_count **)(a2 + 8);
    v15[4] = a1;
    v15[5] = v5;
    v16 = v4;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
    v9 = *(NSObject **)(a1 + 40);
    block = v3;
    v18 = 3221225472;
    v19 = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
    v20 = &unk_1E14FDA90;
    v21 = v15;
    v22 = (void *)v8;
    dispatch_async(v9, &block);
    v10 = v16;
    if (v16)
    {
      v11 = (unint64_t *)&v16->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  else
  {
    v13 = **(NSObject ***)a2;
    v14 = *(_QWORD **)(*(_QWORD *)a2 + 8);
    block = MEMORY[0x1E0C809B0];
    v18 = 3221225472;
    v19 = ___ZNK23CoreSchedulingSetOneOff29performAsyncWithTrailingBlockEU13block_pointerFvvE_block_invoke_9666;
    v20 = &unk_1E14FB138;
    v21 = v14;
    v22 = &__block_literal_global_79;
    dispatch_async(v13, &block);
  }
}

void sub_183F96768(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void URLConnectionLoader::protocolWasRedirected(URLConnectionLoader *this, NSURLRequest *a2, _CFURLResponse *a3)
{
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  _BYTE *var10;
  RedirectionRecorder *var12;
  uint64_t v12;
  uint64_t v13;
  const __CFAllocator *v14;
  const void *v15;
  int64_t var11;
  RedirectionRecorder *v17;
  RedirectionRecorder *v18;
  _CFURLResponse *v19;
  InterfaceRequiredForLoader *var5;
  _QWORD v21[7];
  __int128 buf;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if ((objc_msgSend(this->var9, "_appSSOFallback") & 1) != 0
    || objc_msgSend(this->var9, "_appleIDContextRedirect"))
  {
    if (objc_msgSend(this->var9, "_appSSOFallback"))
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v6 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        goto LABEL_14;
      v7 = objc_msgSend(this->var9, "_loggableDescription");
      LODWORD(buf) = 138543362;
      *(_QWORD *)((char *)&buf + 4) = v7;
      v8 = "%{public}@ performing AppSSO fallback";
    }
    else
    {
      if (!objc_msgSend(this->var9, "_appleIDContextRedirect"))
        goto LABEL_14;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v6 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        goto LABEL_14;
      v9 = objc_msgSend(this->var9, "_loggableDescription");
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v9;
      v8 = "%{pubic}@ performing AppleIDContext redirect";
    }
    _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&buf, 0xCu);
LABEL_14:
    var10 = this->var10;
    if (var10)
      var10[13] = 1;
    this->var14 = 1;
    URLConnectionLoader::protocolWasRedirected_final(this, a2);
    return;
  }
  var12 = this->var12;
  if (var12)
  {
    (*(void (**)(RedirectionRecorder *, NSURLRequest *, _CFURLResponse *))(*(_QWORD *)var12 + 80))(var12, a2, a3);
  }
  else if (!this->var23 && !this->var4)
  {
    v12 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_9639, 1);
    if (v12)
    {
      v13 = v12;
      if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v12 + 16))(v12, "Redirection", 0))
      {
        v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v15 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))this->var0 + 3))(this);
        *(_QWORD *)&buf = &off_1E14E4818;
        v23 = 0;
        v24 = 0;
        *((_QWORD *)&buf + 1) = CFStringCreateWithCString(v14, "Loader", 0x8000100u);
        (*(void (**)(uint64_t, _QWORD, const void *))(*(_QWORD *)v13 + 64))(v13, *((_QWORD *)&buf + 1), v15);
        AutoString::~AutoString((AutoString *)&buf);
        if (v15)
          CFRelease(v15);
        (*(void (**)(uint64_t, const char *, NSURLRequest *))(*(_QWORD *)v13 + 48))(v13, "New Request", a2);
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
      }
    }
    var11 = this->var11;
    this->var11 = var11 + 1;
    if (var11 <= 19)
    {
      v17 = (RedirectionRecorder *)CFAllocatorAllocate(this->var1, 48, 0);
      *((_OWORD *)v17 + 1) = 0u;
      *((_OWORD *)v17 + 2) = 0u;
      *(_OWORD *)v17 = 0u;
      RedirectionRecorder::RedirectionRecorder(v17, this->var1);
      this->var12 = v18;
      if (a2)
        CFRetain(a2);
      v19 = a3;
      var5 = this->var5;
      v21[0] = MEMORY[0x1E0C809B0];
      v21[1] = 3221225472;
      v21[2] = ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_3;
      v21[3] = &unk_1E14FAC60;
      v21[4] = a2;
      v21[5] = this;
      v21[6] = a3;
      (*(void (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v21);
    }
    else
    {
      (*(void (**)(InterfaceRequiredForLoader *, void *))(*(_QWORD *)this->var5 + 40))(this->var5, &__block_literal_global_15_9642);
    }
  }
}

void sub_183F96B14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void RedirectionRecorder::RedirectionRecorder(RedirectionRecorder *this, CFAllocatorRef allocator)
{
  CFArrayCallBacks v2;

  *(_QWORD *)this = off_1E14EF578;
  *((_QWORD *)this + 1) = allocator;
  *((_DWORD *)this + 4) = 1;
  if ((((unint64_t)this + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)this = off_1E14EA1A0;
  *((_QWORD *)this + 3) = &unk_1E14EA288;
  *((_QWORD *)this + 4) = &unk_1E14EA348;
  *(_OWORD *)&v2.version = xmmword_1E14FD5B0;
  *(_OWORD *)&v2.release = *(_OWORD *)&off_1E14FD5C0;
  v2.equal = 0;
  *((_QWORD *)this + 5) = CFArrayCreateMutable(allocator, 0, &v2);
}

void sub_183F96BDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 32) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

HTTPProtocol *HTTPProtocol::_protocolInterface_resumeLoad(HTTPProtocol *this)
{
  uint64_t v1;

  if (*((int *)this + 122) >= 1)
  {
    *((_DWORD *)this + 122) = 0;
    if (*((_BYTE *)this + 72))
    {
      *((_DWORD *)this + 122) = 1;
    }
    else
    {
      v1 = *((_QWORD *)this + 34);
      if (v1)
        return (HTTPProtocol *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v1 + 72))(*((_QWORD *)this + 34), *((_QWORD *)this + 3));
    }
  }
  return this;
}

__CFArray *cfTypeCreateArray(const __CFAllocator *a1, ...)
{
  CFIndex v1;
  uint64_t v2;
  __CFArray *Mutable;
  const void **v4;
  va_list v6;
  va_list v7;
  va_list va;

  va_start(va, a1);
  va_copy(v6, va);
  v1 = -1;
  do
  {
    v2 = va_arg(v6, _QWORD);
    ++v1;
  }
  while (v2);
  Mutable = CFArrayCreateMutable(a1, v1, MEMORY[0x1E0C9B378]);
  va_copy(v7, va);
  for (; v1; --v1)
  {
    v4 = (const void **)v7;
    v7 += 8;
    CFArrayAppendValue(Mutable, *v4);
  }
  return Mutable;
}

void RedirectionRecorder::protocolDidReceiveResponse(RedirectionRecorder *this, _CFURLResponse *a2)
{
  _CFURLResponse *v4;
  _QWORD value[5];

  v4 = a2;
  value[0] = MEMORY[0x1E0C809B0];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder26protocolDidReceiveResponseEP14_CFURLResponse_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void RedirectionRecorder::protocolDidFinishLoading(RedirectionRecorder *this)
{
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), &__block_literal_global_133);
}

void RedirectionRecorder::protocolDidLoadData(RedirectionRecorder *this, CFTypeRef cf, uint64_t a3)
{
  _QWORD v6[6];

  if (cf)
    CFRetain(cf);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN19RedirectionRecorder19protocolDidLoadDataEPK8__CFDatax_block_invoke;
  v6[3] = &__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
  v6[4] = cf;
  v6[5] = a3;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), v6);
}

uint64_t ___ZN20HTTP2ConnectionCache24invalidateAllConnectionsEb_block_invoke(uint64_t a1)
{
  uint64_t v1;
  char v2;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 128))
  {
    v2 = *(_BYTE *)(a1 + 40);
    *(_BYTE *)(v1 + 128) = 1;
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 112));
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 120));
    HTTP2ConnectionCache::_onqueue_base_remove_connections((HTTP2ConnectionCache *)v1, 1, v2);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 104) + 48))(*(_QWORD *)(v1 + 104));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void HTTP3ConnectionCacheWrapper::~HTTP3ConnectionCacheWrapper(HTTP3ConnectionCacheWrapper *this)
{
  *(_QWORD *)this = off_1E14EDCE0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
  *(_QWORD *)this = off_1E14EA0F0;

  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

void HTTP3ConnectionCacheWrapper::invalidateAllConnections(HTTP3ConnectionCacheWrapper *this, char a2)
{
  CFTypeRef *v3;
  const __CFAllocator *v4;
  const __CFDictionary *MutableCopy;
  _QWORD v6[5];
  char v7;

  v3 = (CFTypeRef *)*((_QWORD *)this + 4);
  HTTP3ConnectionCache::_timersStop((HTTP3ConnectionCache *)v3);
  v4 = CFGetAllocator(v3[11]);
  MutableCopy = CFDictionaryCreateMutableCopy(v4, 0, (CFDictionaryRef)v3[11]);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN20HTTP3ConnectionCache21_connectionsRemoveAllEb_block_invoke;
  v6[3] = &__block_descriptor_41_e14_v24__0r_v8_v16l;
  v6[4] = v3;
  v7 = a2;
  CFDictionaryApplyFunction(MutableCopy, (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit, v6);
  CFRelease(MutableCopy);
}

void sub_183F96F14(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTP2ConnectionCache::_onqueue_base_remove_connections(HTTP2ConnectionCache *this, int a2, char a3)
{
  double Current;
  int v7;
  double v8;
  double v9;
  const __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  _QWORD v13[8];
  _QWORD context[5];
  char v15;

  if (CFDictionaryGetCount(*((CFDictionaryRef *)this + 12)))
  {
    Current = CFAbsoluteTimeGetCurrent();
    v7 = *((_DWORD *)this + 18);
    v8 = CFAbsoluteTimeGetCurrent();
    if (a2)
    {
      context[0] = MEMORY[0x1E0C809B0];
      context[1] = 3221225472;
      context[2] = ___ZN20HTTP2ConnectionCache32_onqueue_base_remove_connectionsEbb_block_invoke;
      context[3] = &__block_descriptor_41_e14_v24__0r_v8_v16l;
      context[4] = this;
      v15 = a3;
      CFDictionaryApplyFunction(*((CFDictionaryRef *)this + 12), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::_visit, context);
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 12));
    }
    else
    {
      v9 = v8 - (double)*((int *)this + 19);
      Mutable = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, 0);
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 3221225472;
      v13[2] = ___ZN20HTTP2ConnectionCache32_onqueue_base_remove_connectionsEbb_block_invoke_2;
      v13[3] = &__block_descriptor_64_e14_v24__0r_v8_v16l;
      v13[4] = this;
      *(double *)&v13[5] = Current - (double)v7;
      *(double *)&v13[6] = v9;
      v13[7] = Mutable;
      CFDictionaryApplyFunction(*((CFDictionaryRef *)this + 12), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::_visit, v13);
      for (i = 0; i < CFArrayGetCount(Mutable); ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Mutable, i);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 12), ValueAtIndex);
      }
      if (Mutable)
        CFRelease(Mutable);
    }
  }
}

uint64_t HTTP2ConnectionCache::invalidateAllConnections(HTTP2ConnectionCache *this, char a2)
{
  uint64_t v4;
  _QWORD v6[5];
  char v7;

  (*(void (**)(HTTP2ConnectionCache *))(*(_QWORD *)this + 40))(this);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 13) + 40))(*((_QWORD *)this + 13));
  v4 = *((_QWORD *)this + 10);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN20HTTP2ConnectionCache24invalidateAllConnectionsEb_block_invoke;
  v6[3] = &__block_descriptor_41_e5_v8__0l;
  v6[4] = this;
  v7 = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v6);
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit(uint64_t a1, uint64_t a2, void *aBlock)
{
  void (**v5)(id, uint64_t, uint64_t);

  v5 = (void (**)(id, uint64_t, uint64_t))_Block_copy(aBlock);
  v5[2](v5, a1, a2);

}

void sub_183F97160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZN20HTTP3ConnectionCache21_connectionsRemoveAllEb_block_invoke(uint64_t a1, const HTTPConnectionCacheKey *a2, uint64_t a3)
{
  HTTP3ConnectionCache *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v4 = *(HTTP3ConnectionCache **)(a1 + 32);
  v5 = *(_QWORD *)(a3 + 24);
  v6 = *(std::__shared_weak_count **)(a3 + 32);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  HTTP3ConnectionCacheEntry::stopConnections(*(HTTP3ConnectionCacheEntry **)(v5 + 104), *(HTTP3ConnectionCacheEntry **)(v5 + 112), *(_BYTE *)(a1 + 40));
  HTTP3ConnectionCache::_entryRemove(v4, a2);
  if (v6)
  {
    v9 = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_183F97220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTP3ConnectionCacheEntry::stopConnections(HTTP3ConnectionCacheEntry *this, HTTP3ConnectionCacheEntry *a2, char a3)
{
  HTTP3ConnectionCacheEntry *v5;
  HTTP3Connection *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  if (this != a2)
  {
    v5 = this;
    do
    {
      v6 = *(HTTP3Connection **)v5;
      v7 = (std::__shared_weak_count *)*((_QWORD *)v5 + 1);
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v9 = __ldxr(p_shared_owners);
        while (__stxr(v9 + 1, p_shared_owners));
      }
      HTTP3Connection::stop(v6, a3);
      if (v7)
      {
        v10 = (unint64_t *)&v7->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      v5 = (HTTP3ConnectionCacheEntry *)((char *)v5 + 16);
    }
    while (v5 != a2);
  }
}

void sub_183F972D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTP3ConnectionCache::_entryRemove(HTTP3ConnectionCache *this, const HTTPConnectionCacheKey *a2)
{
  _QWORD v5[2];
  uint64_t (*v6)(uint64_t);
  void *v7;
  const HTTPConnectionCacheKey *v8;

  (*(void (**)(const HTTPConnectionCacheKey *))(*(_QWORD *)a2 + 40))(a2);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v6 = ___ZN20HTTP3ConnectionCache12_entryRemoveEPK22HTTPConnectionCacheKey_block_invoke;
  v7 = &__block_descriptor_40_e5_v8__0l;
  v8 = a2;
  if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 11), a2))
  {
    TubeManager::invalidateKey(*((_QWORD *)this + 9), a2, 1, 2u);
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 11), a2);
    if (!CFDictionaryGetCount(*((CFDictionaryRef *)this + 11)))
      HTTP3ConnectionCache::_timersStop(this);
  }
  return v6((uint64_t)v5);
}

void sub_183F973A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void HTTP3ConnectionCache::_timersStop(HTTP3ConnectionCache *this)
{
  if (*((_BYTE *)this + 96))
  {
    *((_BYTE *)this + 96) = 0;
    dispatch_source_set_timer(*((dispatch_source_t *)this + 13), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_timer(*((dispatch_source_t *)this + 14), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
}

void TubeManager::invalidateKey(uint64_t a1, void *a2, char a3, unsigned int a4)
{
  uint64_t v7;
  const void *Value;
  int v9;
  void *v10;
  CFAllocatorRef v11;
  void *v12;
  uint64_t v13;
  uint64_t **v14;
  uint64_t **v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  const void *ValidAwaitingTubeForKey;
  uint64_t v26;
  int v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t **v30;
  uint64_t **v31;
  uint64_t **v32;
  uint64_t *v33;
  uint64_t **v34;
  uint64_t **v35;
  uint64_t *v36;
  _BOOL4 v37;
  uint64_t **v38;
  uint64_t *v39;
  uint64_t **v40;
  uint64_t *v41;
  BOOL v42;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t *v46;
  uint64_t *v47;
  uint64_t *v48;
  uint64_t *v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t *v52;
  uint64_t *v53;
  uint64_t **v54;
  uint64_t *v55;
  uint64_t *v56;
  uint64_t *v57;
  _BOOL4 v58;
  uint64_t **v59;
  uint64_t *v60;
  uint64_t *v61;
  uint64_t *v62;
  uint64_t *v63;
  uint64_t *v64;
  uint64_t *v65;
  _BOOL4 v66;
  uint64_t **v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t *v70;
  uint64_t *v71;
  uint64_t *v72;
  unint64_t *v73;
  unint64_t v74;
  uint64_t v75;
  NSObject *v76;
  const char *v77;
  CFIndex Count;
  CFIndex v79;
  CFIndex i;
  Tube **ValueAtIndex;
  uint64_t v82;
  void *v83;
  void *v84;
  char v85;
  uint64_t v86;
  _QWORD *v87;
  std::__shared_weak_count *v88;
  uint64_t **v89;
  uint64_t **v90;
  uint64_t **v91;
  uint64_t *v92;
  uint64_t **v93;
  uint64_t v94;
  std::__shared_weak_count *v95;
  _BYTE __p[22];
  unsigned __int8 v97;
  uint64_t v98;

  v7 = a1;
  v98 = *MEMORY[0x1E0C80C00];
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), a2);
  if (!Value || Value != *(const void **)(v7 + 8 * a4 + 80))
    return;
  v9 = (*(uint64_t (**)(void *))(*(_QWORD *)a2 + 88))(a2);
  if (a4 != 1 || v9 != 1)
  {
    if (!a4
      && ((*(unsigned int (**)(void *))(*(_QWORD *)a2 + 88))(a2) == 1
       || (*(unsigned int (**)(void *))(*(_QWORD *)a2 + 88))(a2) == 3))
    {
      ValidAwaitingTubeForKey = TubeManager::_onqueue_getValidAwaitingTubeForKey((CFArrayRef *)v7, (const HTTPConnectionCacheKey *)a2);
      if (ValidAwaitingTubeForKey)
      {
        v26 = (*(uint64_t (**)(const void *))(*(_QWORD *)ValidAwaitingTubeForKey + 80))(ValidAwaitingTubeForKey);
        TubeManager::addNewFastPathCache(v7, (uint64_t)a2, v26);
      }
    }
    goto LABEL_123;
  }
  v10 = *(void **)(v7 + 160);
  v11 = HTTPConnectionCacheKey::hostlessKey((CFAllocatorRef *)a2);
  v12 = (void *)(*(uint64_t (**)(void *))(*(_QWORD *)a2 + 72))(a2);
  v13 = objc_msgSend(v10, "objectForKeyedSubscript:", v11);
  if (!v13)
  {
    v75 = H2CoalescingLog(void)::onceToken;
LABEL_120:
    if (v75 != -1)
      dispatch_once(&H2CoalescingLog(void)::onceToken, &__block_literal_global_6187);
    v76 = H2CoalescingLog(void)::onceLog;
    if (!os_log_type_enabled((os_log_t)H2CoalescingLog(void)::onceLog, OS_LOG_TYPE_DEBUG))
      goto LABEL_123;
    *(_DWORD *)__p = 138412546;
    *(_QWORD *)&__p[4] = v12;
    *(_WORD *)&__p[12] = 2048;
    *(_QWORD *)&__p[14] = v10;
    v77 = "error removing entry for host %@ config %p";
    goto LABEL_132;
  }
  v14 = (uint64_t **)v13;
  std::string::basic_string[abi:nn180100]<0>(__p, (char *)objc_msgSend(v12, "UTF8String"));
  if (!std::__tree<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>>>::__count_unique<std::string>(v14[11], __p))
  {
    v27 = 0;
    goto LABEL_112;
  }
  v93 = v14 + 11;
  v90 = v14 + 10;
  v15 = std::__tree<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v14 + 10, __p, (uint64_t)__p);
  v17 = (uint64_t)v15[7];
  v16 = (std::__shared_weak_count *)v15[8];
  v94 = v17;
  v95 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v19 = __ldxr(p_shared_owners);
    while (__stxr(v19 + 1, p_shared_owners));
  }
  v20 = *(unsigned __int8 *)(v17 + 23);
  if ((v20 & 0x80u) == 0)
    v21 = *(unsigned __int8 *)(v17 + 23);
  else
    v21 = *(_QWORD *)(v17 + 8);
  v22 = v97;
  if ((v97 & 0x80u) != 0)
    v22 = *(_QWORD *)&__p[8];
  if (v21 != v22)
  {
LABEL_32:
    v27 = 0;
    if (!v16)
      goto LABEL_112;
    goto LABEL_108;
  }
  if ((v97 & 0x80u) == 0)
    v23 = __p;
  else
    v23 = *(unsigned __int8 **)__p;
  if ((v20 & 0x80) != 0)
  {
    if (memcmp(*(const void **)v17, v23, *(_QWORD *)(v17 + 8)))
      goto LABEL_32;
  }
  else if (*(_BYTE *)(v17 + 23))
  {
    v24 = (unsigned __int8 *)v17;
    while (*v24 == *v23)
    {
      ++v24;
      ++v23;
      if (!--v20)
        goto LABEL_34;
    }
    goto LABEL_32;
  }
LABEL_34:
  v83 = v12;
  v84 = v10;
  v85 = a3;
  v86 = v7;
  v91 = v14;
  v87 = v14 + 7;
  v88 = v16;
  v28 = std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__emplace_unique_key_args<std::shared_ptr<__CoalescingConnectionKey>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<__CoalescingConnectionKey> const&>,std::tuple<>>(v14 + 7, (_QWORD *)v17, &v94);
  v29 = (uint64_t *)v28[6];
  v92 = v28 + 7;
  if (v29 != v28 + 7)
  {
    v30 = v14 + 4;
    v89 = v14 + 5;
    do
    {
      v31 = std::__tree<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v30, v29 + 4, (uint64_t)(v29 + 4));
      v32 = v31;
      v34 = v31 + 8;
      v33 = v31[8];
      if (v33)
      {
        v35 = v31 + 8;
        v36 = v31[8];
        do
        {
          v37 = std::less<std::string>::operator()[abi:nn180100]((_QWORD *)v36[4], (_QWORD *)v17);
          v38 = (uint64_t **)(v36 + 1);
          if (!v37)
          {
            v38 = (uint64_t **)v36;
            v35 = (uint64_t **)v36;
          }
          v36 = *v38;
        }
        while (*v38);
        if (v35 != v34 && !std::less<std::string>::operator()[abi:nn180100]((_QWORD *)v17, v35[4]))
        {
          v39 = v35[1];
          v40 = v35;
          if (v39)
          {
            do
            {
              v41 = v39;
              v39 = (uint64_t *)*v39;
            }
            while (v39);
          }
          else
          {
            do
            {
              v41 = v40[2];
              v42 = *v41 == (_QWORD)v40;
              v40 = (uint64_t **)v41;
            }
            while (!v42);
          }
          if (v32[7] == (uint64_t *)v35)
            v32[7] = v41;
          v32[9] = (uint64_t *)((char *)v32[9] - 1);
          std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v33, (uint64_t *)v35);
          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 4));
          operator delete(v35);
        }
      }
      if (!std::__tree<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v30, v29 + 4, (uint64_t)(v29 + 4))[9])
      {
        v43 = std::__tree<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>>>::find<std::string>((uint64_t)v30, v29 + 4);
        if (v89 != (uint64_t **)v43)
        {
          v44 = v43;
          v45 = (uint64_t *)v43[1];
          if (v45)
          {
            do
            {
              v46 = v45;
              v45 = (uint64_t *)*v45;
            }
            while (v45);
          }
          else
          {
            v47 = v43;
            do
            {
              v46 = (uint64_t *)v47[2];
              v42 = *v46 == (_QWORD)v47;
              v47 = v46;
            }
            while (!v42);
          }
          if (*v30 == v43)
            *v30 = v46;
          v48 = v91[5];
          v91[6] = (uint64_t *)((char *)v91[6] - 1);
          std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v48, v44);
          std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,0>((uint64_t)(v44 + 4));
          operator delete(v44);
        }
      }
      v49 = (uint64_t *)v29[1];
      if (v49)
      {
        do
        {
          v50 = v49;
          v49 = (uint64_t *)*v49;
        }
        while (v49);
      }
      else
      {
        do
        {
          v50 = (uint64_t *)v29[2];
          v42 = *v50 == (_QWORD)v29;
          v29 = v50;
        }
        while (!v42);
      }
      v29 = v50;
    }
    while (v50 != v92);
  }
  std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__erase_unique<std::shared_ptr<__CoalescingConnectionKey>>(v87, (_QWORD *)v17);
  v51 = std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__emplace_unique_key_args<std::shared_ptr<__CoalescingConnectionKey>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<__CoalescingConnectionKey> const&>,std::tuple<>>(v91 + 13, (_QWORD *)v17, &v94);
  v52 = (uint64_t *)v51[6];
  v53 = v51 + 7;
  if (v52 != v51 + 7)
  {
    v54 = v91 + 2;
    do
    {
      v55 = *v54;
      if (*v54)
      {
        v56 = (uint64_t *)(v91 + 2);
        v57 = *v54;
        do
        {
          v58 = std::less<std::string>::operator()[abi:nn180100](v57 + 4, v52 + 4);
          v59 = (uint64_t **)(v57 + 1);
          if (!v58)
          {
            v59 = (uint64_t **)v57;
            v56 = v57;
          }
          v57 = *v59;
        }
        while (*v59);
        if (v56 != (uint64_t *)v54 && !std::less<std::string>::operator()[abi:nn180100](v52 + 4, v56 + 4))
        {
          v60 = (uint64_t *)v56[1];
          v61 = v56;
          if (v60)
          {
            do
            {
              v62 = v60;
              v60 = (uint64_t *)*v60;
            }
            while (v60);
          }
          else
          {
            do
            {
              v62 = (uint64_t *)v61[2];
              v42 = *v62 == (_QWORD)v61;
              v61 = v62;
            }
            while (!v42);
          }
          if (v91[1] == v56)
            v91[1] = v62;
          v91[3] = (uint64_t *)((char *)v91[3] - 1);
          std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v55, v56);
          std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>((uint64_t)(v56 + 4));
          operator delete(v56);
        }
      }
      v63 = *v93;
      if (*v93)
      {
        v64 = (uint64_t *)v93;
        v65 = *v93;
        do
        {
          v66 = std::less<std::string>::operator()[abi:nn180100](v65 + 4, v52 + 4);
          v67 = (uint64_t **)(v65 + 1);
          if (!v66)
          {
            v67 = (uint64_t **)v65;
            v64 = v65;
          }
          v65 = *v67;
        }
        while (*v67);
        if (v64 != (uint64_t *)v93 && !std::less<std::string>::operator()[abi:nn180100](v52 + 4, v64 + 4))
        {
          v68 = (uint64_t *)v64[1];
          v69 = v64;
          if (v68)
          {
            do
            {
              v70 = v68;
              v68 = (uint64_t *)*v68;
            }
            while (v68);
          }
          else
          {
            do
            {
              v70 = (uint64_t *)v69[2];
              v42 = *v70 == (_QWORD)v69;
              v69 = v70;
            }
            while (!v42);
          }
          if (*v90 == v64)
            *v90 = v70;
          v91[12] = (uint64_t *)((char *)v91[12] - 1);
          std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v63, v64);
          std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::shared_ptr<__CoalescingConnectionKey>>,0>((uint64_t)(v64 + 4));
          operator delete(v64);
        }
      }
      v71 = (uint64_t *)v52[1];
      if (v71)
      {
        do
        {
          v72 = v71;
          v71 = (uint64_t *)*v71;
        }
        while (v71);
      }
      else
      {
        do
        {
          v72 = (uint64_t *)v52[2];
          v42 = *v72 == (_QWORD)v52;
          v52 = v72;
        }
        while (!v42);
      }
      v52 = v72;
    }
    while (v72 != v53);
    v17 = v94;
    v88 = v95;
  }
  std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__erase_unique<std::shared_ptr<__CoalescingConnectionKey>>(v91 + 13, (_QWORD *)v17);
  v27 = 1;
  v7 = v86;
  a3 = v85;
  v12 = v83;
  v10 = v84;
  v16 = v88;
  if (v88)
  {
LABEL_108:
    v73 = (unint64_t *)&v16->__shared_owners_;
    do
      v74 = __ldaxr(v73);
    while (__stlxr(v74 - 1, v73));
    if (!v74)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
LABEL_112:
  if ((char)v97 < 0)
    operator delete(*(void **)__p);
  v75 = H2CoalescingLog(void)::onceToken;
  if (!v27)
    goto LABEL_120;
  if (H2CoalescingLog(void)::onceToken != -1)
    dispatch_once(&H2CoalescingLog(void)::onceToken, &__block_literal_global_6187);
  v76 = H2CoalescingLog(void)::onceLog;
  if (!os_log_type_enabled((os_log_t)H2CoalescingLog(void)::onceLog, OS_LOG_TYPE_DEBUG))
    goto LABEL_123;
  *(_DWORD *)__p = 138412546;
  *(_QWORD *)&__p[4] = v12;
  *(_WORD *)&__p[12] = 2048;
  *(_QWORD *)&__p[14] = v10;
  v77 = "success removing entry for host %@ config %p";
LABEL_132:
  _os_log_debug_impl(&dword_183ECA000, v76, OS_LOG_TYPE_DEBUG, v77, __p, 0x16u);
LABEL_123:
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v7 + 112), a2);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v7 + 128), a2);
  if ((a3 & 1) == 0
    && !TubeManager::_onqueue_getValidAwaitingTubeForKey((CFArrayRef *)v7, (const HTTPConnectionCacheKey *)a2))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(v7 + 144));
    if (Count >= 1)
    {
      v79 = Count;
      for (i = 0; i != v79; ++i)
      {
        ValueAtIndex = (Tube **)CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 144), i);
        v82 = Tube::copyKey(ValueAtIndex[13]);
        if ((*(unsigned int (**)(uint64_t, void *))(*(_QWORD *)v82 + 24))(v82, a2))
          Tube::_onqueue_cancel((Tube *)ValueAtIndex);
        (*(void (**)(uint64_t))(*(_QWORD *)v82 + 48))(v82);
      }
    }
  }
}

void sub_183F97C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  if (a28 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20HTTP3ConnectionCache12_entryRemoveEPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

void HTTP3Connection::stop(HTTP3Connection *this, char a2)
{
  NSObject *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD block[5];
  std::__shared_weak_count *v14;
  char v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v16, *((_QWORD *)this + 1), *((std::__shared_weak_count **)this + 2));
  v4 = *((_QWORD *)this + 125);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN15HTTP3Connection4stopEb_block_invoke;
  block[3] = &__block_descriptor_49_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e5_v8__0l;
  block[4] = v16;
  v14 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v15 = a2;
  dispatch_async(v4, block);
  v7 = v14;
  if (v14)
  {
    v8 = (unint64_t *)&v14->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = v17;
  if (v17)
  {
    v11 = (unint64_t *)&v17->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_183F980C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void URLConnectionLoader_Classic::URLConnectionLoader_Classic(URLConnectionLoader_Classic *this, InterfaceRequiredForLoader *a2, const ConfigFlags *a3, __NSURLSessionLocal *a4, NSObject *a5)
{
  uint64_t v10;
  CoreSchedulingSet *v11;

  v10 = (*(uint64_t (**)(InterfaceRequiredForLoader *))(*(_QWORD *)a2 + 56))(a2);
  *(_QWORD *)this = off_1E14ED770;
  *((_QWORD *)this + 1) = v10;
  *((_QWORD *)this + 2) = &unk_1E14ED798;
  *((_BYTE *)this + 25) = 0;
  *((_QWORD *)this + 4) = a2;
  *((_QWORD *)this + 5) = a5;
  dispatch_retain(a5);
  *((_BYTE *)this + 24) = 0;
  *(_QWORD *)this = off_1E14EABC0;
  *((_QWORD *)this + 2) = &unk_1E14EAD20;
  *((_QWORD *)this + 6) = &unk_1E14EAD40;
  *((_QWORD *)this + 7) = &unk_1E14EADF0;
  *((_BYTE *)this + 200) = *(_BYTE *)a3;
  *((CFAbsoluteTime *)this + 22) = CFAbsoluteTimeGetCurrent();
  *((_QWORD *)this + 13) = a4;
  *(_WORD *)((char *)this + 201) = 1;
  *((_BYTE *)this + 203) = 1;
  *((_BYTE *)this + 136) = 0;
  v11 = (CoreSchedulingSet *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 32))(*((_QWORD *)this + 4));
  *((_BYTE *)this + 221) = (_BYTE)v11;
  *((_QWORD *)this + 21) = CoreSchedulingSet::copyLoaderQueueSet(v11);
  *((_BYTE *)this + 24) = 1;
  *(_QWORD *)this = off_1E14EE2A8;
  *((_QWORD *)this + 2) = &unk_1E14EE408;
  *((_QWORD *)this + 6) = &unk_1E14EE428;
  *((_QWORD *)this + 7) = &unk_1E14EE4D8;
}

void sub_183F98AF0(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v5;

  *v1 = v2;
  v1[2] = v3;
  v5 = v1[5];
  if (v5)
  {
    dispatch_release(v5);
    v1[5] = 0;
  }
  v1[4] = 0;
  v1[2] = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

uint64_t SessionConnectionLoadable::_loaderClient_SupportsDispatchData(SessionConnectionLoadable *this)
{
  return 1;
}

uint64_t SessionConnectionLoadable::loaderClientSupportsDispatchData(SessionConnectionLoadable *this)
{
  return (*((uint64_t (**)(SessionConnectionLoadable *))this->var0 + 10))(this);
}

CFAllocatorRef SessionConnectionLoadable::_irl_allocator(SessionConnectionLoadable *this)
{
  return CFGetAllocator(this->var3);
}

void ___ZN27URLConnectionLoader_Classic15protocolDidFailEP9__CFError_block_invoke(uint64_t a1)
{
  const void *v2;

  URLConnectionLoader::protocolDidFail(*(URLConnectionLoader **)(a1 + 32), *(__CFError **)(a1 + 40));
  v2 = *(const void **)(a1 + 40);
  if (v2)
    CFRelease(v2);
}

void ___ZN12HTTPProtocol48asynchronouslyAddAuthenticatorHeadersAndContinueEP15__CFHTTPMessage_block_invoke_2(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  const __CFDictionary *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 792);
    v4 = *(unsigned __int8 *)(a1 + 96);
    v5 = *(_QWORD *)(a1 + 48);
    v6 = *(_QWORD *)(a1 + 64);
    v10 = 138544130;
    v11 = v3;
    v12 = 1024;
    v13 = v4;
    v14 = 2112;
    v15 = v5;
    v16 = 2112;
    v17 = v6;
    _os_log_impl(&dword_183ECA000, v2, OS_LOG_TYPE_DEFAULT, "%{public}@ protocol received continueLoad=%d, headers=%@ req=%@", (uint8_t *)&v10, 0x26u);
  }
  if (*(_BYTE *)(a1 + 96))
  {
    v7 = *(const __CFDictionary **)(a1 + 48);
    if (v7)
    {
      if (CFDictionaryGetCount(v7))
        _CFHTTPMessageSetMultipleHeaderFields(*(__CFHTTPMessage **)(a1 + 80), *(CFDictionaryRef *)(a1 + 48));
    }
    HTTPProtocol::asynchronouslyCreateAndOpenStream_WithMessage_AfterCookiesAndAuthenticatorHeaders(*(HTTPProtocol **)(a1 + 32), *(os_unfair_lock_s **)(a1 + 80));
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v8 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 792);
      v10 = 138543362;
      v11 = v9;
      _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@ authentication client does not want to continue load", (uint8_t *)&v10, 0xCu);
    }
    HTTPProtocol::sendError(*(HTTPProtocol **)(a1 + 32), (const __CFString *)0xFFFFFFFFFFFFFC19);
  }
}

void ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke_3(uint64_t a1)
{
  __CFError *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  v2 = *(__CFError **)(a1 + 48);
  if (v2)
  {
    HTTPProtocol::logLoadFailure(*(HTTPProtocol **)(a1 + 40), v2, (const CFStreamError *)(a1 + 64));
    v2 = *(__CFError **)(a1 + 48);
  }
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(std::__shared_weak_count **)(a1 + 88);
  v10 = *(_QWORD *)(a1 + 80);
  v11 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, __CFError *, uint64_t *))(v3 + 16))(v3, v2, &v10);
  v7 = v11;
  if (v11)
  {
    v8 = (unint64_t *)&v11->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_183F99060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke(_QWORD *a1, void *cf, const __CFDictionary **a3)
{
  uint64_t v6;
  const __CFDictionary *v7;
  const __CFAllocator *v8;
  __CFDictionary *MutableCopy;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  const __CFAllocator *v12;
  CFNumberRef v13;
  const __CFAllocator *v14;
  CFNumberRef v15;
  const __CFDictionary *v16;
  unint64_t v17;
  const __CFAllocator *v18;
  const __CFString *Domain;
  CFIndex Code;
  __CFError *v21;
  uint64_t v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  void *v30;
  _QWORD context[5];
  std::__shared_weak_count *v32;
  __CFDictionary *v33;
  std::__shared_weak_count *v34;

  if (cf)
  {
    v6 = a1[4];
    v30 = (void *)CFRetain(cf);
    v7 = CFErrorCopyUserInfo((CFErrorRef)cf);
    v8 = CFGetAllocator((CFTypeRef)(v6 - 16));
    if (v7)
      MutableCopy = CFDictionaryCreateMutableCopy(v8, 0, v7);
    else
      MutableCopy = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v33 = MutableCopy;
    v10 = (std::__shared_weak_count *)operator new();
    v10->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    v10->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1588;
    v10->__shared_weak_owners_ = 0;
    v10[1].__vftable = (std::__shared_weak_count_vtbl *)MutableCopy;
    v34 = v10;
    v12 = CFGetAllocator((CFTypeRef)(v6 - 16));
    v13 = CFNumberCreate(v12, kCFNumberCFIndexType, a1 + 5);
    v14 = CFGetAllocator((CFTypeRef)(v6 - 16));
    v15 = CFNumberCreate(v14, kCFNumberSInt32Type, a1 + 6);
    CFDictionarySetValue(MutableCopy, CFSTR("_kCFStreamErrorDomainKey"), v13);
    CFDictionarySetValue(MutableCopy, CFSTR("_kCFStreamErrorCodeKey"), v15);
    v16 = *a3;
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 3321888768;
    context[2] = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_2;
    context[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE_e25_v24__0____CFString__8_v16l;
    context[4] = MutableCopy;
    v32 = v10;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
    CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)_apply_block, context);
    if (MutableCopy)
    {
      v18 = CFGetAllocator((CFTypeRef)(v6 - 16));
      Domain = CFErrorGetDomain((CFErrorRef)cf);
      Code = CFErrorGetCode((CFErrorRef)cf);
      v21 = CFErrorCreate(v18, Domain, Code, MutableCopy);
      if (v30)
        CFRelease(v30);
    }
    else
    {
      v21 = (__CFError *)v30;
    }
    v22 = *(unsigned int *)(v6 + 192);
    v23 = v22 | ((unint64_t)*(unsigned __int16 *)(v6 + 196) << 32) | 0x4000000000;
    *(_DWORD *)(v6 + 192) = v22;
    *(_WORD *)(v6 + 196) = WORD2(v23);
    URLProtocol::sendDidFail((URLProtocol *)v6, v21);
    v24 = v32;
    if (v32)
    {
      v25 = (unint64_t *)&v32->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    if (v15)
      CFRelease(v15);
    if (v13)
      CFRelease(v13);
    v27 = v34;
    if (v34)
    {
      v28 = (unint64_t *)&v34->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    if (v7)
      CFRelease(v7);
    if (v21)
      CFRelease(v21);
  }
}

void sub_183F99358(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  uint64_t v21;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v21);
  if (v20)
    CFRelease(v20);
  if (v18)
    CFRelease(v18);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  if (v17)
    CFRelease(v17);
  if (v19)
    CFRelease(v19);
  _Unwind_Resume(a1);
}

URLConnectionLoader *URLConnectionLoader::protocolDidFail(URLConnectionLoader *this, __CFError *a2)
{
  URLConnectionLoader *v3;
  uint64_t v4;
  uint64_t v5;
  const __CFAllocator *v6;
  const void *v7;
  InterfaceRequiredForLoader *var5;
  _QWORD v9[5];
  void (**v10)(AutoString *__hidden);
  CFStringRef v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (this->var21)
  {
    v3 = this;
    this = (URLConnectionLoader *)this->var12;
    if (this)
    {
      (*((void (**)(URLConnectionLoader *, __CFError *))this->var0 + 17))(this, a2);
      return URLConnectionLoader::replayOrConsumeRedirections(v3);
    }
    else if (!v3->var23)
    {
      v3->var23 = 1;
      v4 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_74, 1);
      if (v4)
      {
        v5 = v4;
        if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v4 + 16))(v4, "Did Fail", 0))
        {
          v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v7 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))v3->var0 + 3))(v3);
          v10 = &off_1E14E4818;
          v12 = 0;
          v13 = 0;
          v11 = CFStringCreateWithCString(v6, "Loader", 0x8000100u);
          (*(void (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)v5 + 64))(v5, v11, v7);
          AutoString::~AutoString((AutoString *)&v10);
          if (v7)
            CFRelease(v7);
          (*(void (**)(uint64_t, const char *, __CFError *))(*(_QWORD *)v5 + 56))(v5, "Error", a2);
          URLConnectionLoader::logTimings((uint64_t)v3, v5);
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
        }
      }
      if ((nw_settings_get_signposts_enabled() & 1) != 0)
        kdebug_trace();
      if (a2)
        CFRetain(a2);
      var5 = v3->var5;
      v9[0] = MEMORY[0x1E0C809B0];
      v9[1] = 3221225472;
      v9[2] = ___ZN19URLConnectionLoader15protocolDidFailEP9__CFError_block_invoke_2;
      v9[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
      v9[4] = a2;
      return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v9);
    }
  }
  return this;
}

void sub_183F99620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void HTTPProtocol::logLoadFailure(HTTPProtocol *this, CFErrorRef err, const CFStreamError *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFIndex Code;
  NSObject *v10;
  uint64_t v11;
  CFIndex v12;
  CFIndex domain;
  SInt32 error;
  uint64_t v15;
  CFIndex v16;
  CFIndex v17;
  SInt32 v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  CFIndex v26;
  __int16 v27;
  CFIndex v28;
  __int16 v29;
  SInt32 v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v6 = *((_QWORD *)this + 71);
  v7 = *((_QWORD *)this + 72);
  v8 = *((_QWORD *)this + 34);
  if (v8)
  {
    v6 += (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 96))(v8);
    v7 += (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 34) + 104))(*((_QWORD *)this + 34));
  }
  Code = CFErrorGetCode(err);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v10 = CFNLog::logger;
  if (Code == -999)
  {
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *((_QWORD *)this + 99);
      v12 = CFErrorGetCode(err);
      domain = a3->domain;
      error = a3->error;
      v19 = 138544642;
      v20 = v11;
      v21 = 2048;
      v22 = v6;
      v23 = 2048;
      v24 = v7;
      v25 = 2048;
      v26 = v12;
      v27 = 2048;
      v28 = domain;
      v29 = 1024;
      v30 = error;
      _os_log_impl(&dword_183ECA000, v10, OS_LOG_TYPE_DEFAULT, "%{public}@ HTTP load canceled, %lld/%lld bytes (error code: %ld [%ld:%d])", (uint8_t *)&v19, 0x3Au);
    }
  }
  else if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v15 = *((_QWORD *)this + 99);
    v16 = CFErrorGetCode(err);
    v17 = a3->domain;
    v18 = a3->error;
    v19 = 138544642;
    v20 = v15;
    v21 = 2048;
    v22 = v6;
    v23 = 2048;
    v24 = v7;
    v25 = 2048;
    v26 = v16;
    v27 = 2048;
    v28 = v17;
    v29 = 1024;
    v30 = v18;
    _os_log_error_impl(&dword_183ECA000, v10, OS_LOG_TYPE_ERROR, "%{public}@ HTTP load failed, %lld/%lld bytes (error code: %ld [%ld:%d])", (uint8_t *)&v19, 0x3Au);
  }
}

void URLProtocol::sendDidFail(URLProtocol *this, __CFError *a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  _QWORD *v12;
  uint64_t v13;
  id v14;
  _QWORD v15[2];
  uint64_t (*v16)(uint64_t, uint64_t);
  void *v17;
  __CFError *v18;
  _QWORD v19[5];
  _QWORD v20[6];

  v4 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_15_2208, 1);
  if (v4)
  {
    v5 = v4;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v4 + 16))(v4, "Response Error", 0))
    {
      v6 = *((id *)this + 11);
      (*(void (**)(uint64_t, const char *, id))(*(_QWORD *)v5 + 48))(v5, "Request", v6);

      (*(void (**)(uint64_t, const char *, __CFError *))(*(_QWORD *)v5 + 56))(v5, "Error", a2);
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    }
  }
  if (!a2)
  {
    v14 = *((id *)this + 11);
    CFLog();

    abort();
  }
  v7 = MEMORY[0x1E0C809B0];
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v16 = ___ZN11URLProtocol11sendDidFailEP9__CFError_block_invoke_2;
  v17 = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  v18 = a2;
  v8 = v15;
  v9 = *((_QWORD *)this + 12);
  if (v9)
  {
    v10 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v9 + 16))(*((_QWORD *)this + 12));
    v11 = (void *)MEMORY[0x186DB8C8C](v10);
    v16((uint64_t)v8, *((_QWORD *)this + 12));
    objc_autoreleasePoolPop(v11);
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  }

  v12 = (_QWORD *)*((_QWORD *)this + 8);
  if (v12)
  {
    *((_QWORD *)this + 8) = 0;
    CFRetain((char *)this - 16);
    v19[0] = v7;
    v19[1] = 3221225472;
    v19[2] = ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke_2213;
    v19[3] = &__block_descriptor_40_e5_v8__0l;
    v19[4] = this;
    (*(void (**)(_QWORD *))(*v12 + 40))(v12);
    v13 = v12[9];
    v20[0] = v7;
    v20[1] = 3221225472;
    v20[2] = ___ZN9Throttler10invalidateEU13block_pointerFvvE_block_invoke;
    v20[3] = &unk_1E14FDA90;
    v20[4] = v19;
    v20[5] = v12;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 96))(v13, v20);
    (*(void (**)(_QWORD *))(*v12 + 48))(v12);
  }
}

void sub_183F99A44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZN11URLProtocol11sendDidFailEP9__CFError_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 96))(a2, *(_QWORD *)(a1 + 32));
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolDidFail(URLConnectionLoader_Classic *this, __CFError *a2)
{
  URLConnectionLoader_Classic::protocolDidFail((URLConnectionLoader_Classic *)((char *)this - 56), a2);
}

void URLConnectionLoader_Classic::protocolDidFail(URLConnectionLoader_Classic *this, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[6];
  _QWORD block[6];

  if (cf)
    CFRetain(cf);
  v4 = MEMORY[0x1E0C809B0];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN27URLConnectionLoader_Classic15protocolDidFailEP9__CFError_block_invoke;
  v7[3] = &__block_descriptor_48_e5_v8__0l;
  v7[4] = this;
  v7[5] = cf;
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
  v6 = *((_QWORD *)this + 5);
  block[0] = v4;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v7;
  block[5] = v5;
  dispatch_async(v6, block);
}

void ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_3(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  const void *v8;

  v2 = a1[4];
  v3 = a1[5];
  v4 = *(_QWORD *)(v3 + 96);
  if (v4)
  {
    v5 = a1[7];
    v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4 + 16))(*(_QWORD *)(v3 + 96));
    v7 = (void *)MEMORY[0x186DB8C8C](v6);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 96) + 128))(*(_QWORD *)(v3 + 96), v5);
    objc_autoreleasePoolPop(v7);
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  }
  if (*(_BYTE *)(v2 + 42))
    HTTPProtocol::cleanupStreams((HTTPProtocol *)v2);
  *(CFAbsoluteTime *)(v2 + 32) = CFAbsoluteTimeGetCurrent();
  v8 = (const void *)a1[7];
  if (v8)
    CFRelease(v8);
}

uint64_t `non-virtual thunk to'HTTP2StreamBridge::updateScheduling(HTTP2StreamBridge *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(_QWORD, const CoreSchedulingSet *))(**((_QWORD **)this + 2) + 56))(*((_QWORD *)this + 2), a2);
}

void `non-virtual thunk to'URLConnectionLoader_Classic::protocolConnectionEstablished(URLConnectionLoader_Classic *this, const __CFDictionary *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[6];
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN27URLConnectionLoader_Classic29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = (char *)this - 56;
  v6[5] = a2;
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this - 3) + 64))(*((_QWORD *)this - 3));
  v5 = *((_QWORD *)this - 2);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v6;
  block[5] = v4;
  dispatch_async(v5, block);
}

void HTTP2Stream::updateScheduling(HTTP2Stream *this, const CoreSchedulingSet *a2)
{
  _DWORD *v4;
  _BOOL4 v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v4 = (_DWORD *)*((_QWORD *)this + 4);
  if (v4)
  {
    v5 = v4[10] == 0;
    v6 = *((_QWORD *)this + 33);
    if (v6 && (!a2 || !*((_DWORD *)a2 + 10)))
    {
      (*(void (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)v6 + 40))(*((_QWORD *)this + 33), 0, 1);
      v4 = (_DWORD *)*((_QWORD *)this + 4);
    }
    (*(void (**)(_DWORD *))(*(_QWORD *)v4 + 48))(v4);
  }
  else
  {
    v5 = 1;
  }
  *((_QWORD *)this + 4) = a2;
  if (a2)
  {
    (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 40))(a2);
    if (*(_DWORD *)(*((_QWORD *)this + 4) + 40))
    {
      v7 = *((_QWORD *)this + 33);
      if (v7)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
        HTTP2Stream::resumeData(this);
        if (!v5)
          return;
      }
      else if (!v5)
      {
        return;
      }
      v8 = *((_DWORD *)this + 50);
      if ((v8 & 4) != 0)
      {
        HTTP2Stream::_onqueue_sendWindowUpdate(this);
        v8 = *((_DWORD *)this + 50);
        if ((v8 & 2) == 0)
        {
LABEL_16:
          if ((v8 & 1) == 0)
          {
LABEL_18:
            *((_DWORD *)this + 50) = 0;
            return;
          }
LABEL_17:
          HTTP2Stream::_onqueue_notifyStreamClosed(this);
          goto LABEL_18;
        }
      }
      else if ((v8 & 2) == 0)
      {
        goto LABEL_16;
      }
      HTTP2Stream::_onqueue_notifyDataAvailable(this);
      if ((*((_DWORD *)this + 50) & 1) == 0)
        goto LABEL_18;
      goto LABEL_17;
    }
  }
}

void ___ZN11HTTP2Stream24closeStreamWithErrorCodeEi_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;

  v2 = *(_QWORD *)(a1 + 32);
  v1 = *(_QWORD *)(a1 + 40);
  v3 = *(_DWORD *)(v1 + 56);
  if (v3 != 2)
  {
    v3 = 3;
    *(_DWORD *)(v1 + 56) = 3;
  }
  if (*(_BYTE *)(v1 + 129))
  {
    HTTP2Stream::_onqueue_notifyDataAvailable((HTTP2Stream *)v1);
    v3 = *(_DWORD *)(v1 + 56);
  }
  if (v3 == 3)
    HTTP2Stream::_onqueue_notifyStreamClosed((HTTP2Stream *)v1);
  if (*(_BYTE *)(v2 + 232))
  {
    v4 = *(_QWORD *)(v2 + 64);
    if (v4)
    {
      v5 = *(_QWORD *)(v4 + 56);
      if (v5)
      {
        if (*(_DWORD *)v5 == 1)
        {
          v6 = *(_QWORD *)(v5 + 8);
          v7 = *(std::__shared_weak_count **)(v5 + 16);
          if (v7)
          {
            p_shared_owners = (unint64_t *)&v7->__shared_owners_;
            do
              v9 = __ldxr(p_shared_owners);
            while (__stxr(v9 + 1, p_shared_owners));
          }
          v10 = *(_QWORD *)(v2 + 16);
          if (v10)
            v11 = v6 == 0;
          else
            v11 = 1;
          if (!v11)
          {
            if (*(_BYTE *)(v2 + 320))
              v12 = 6;
            else
              v12 = 8;
            (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v6 + 280))(v6, *(_QWORD *)(v10 - 96), v12, *(_QWORD *)(v2 + 304));
            *(_BYTE *)(v2 + 232) = 0;
          }
          if (v7)
          {
            v13 = (unint64_t *)&v7->__shared_owners_;
            do
              v14 = __ldaxr(v13);
            while (__stlxr(v14 - 1, v13));
            if (!v14)
            {
              ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
              std::__shared_weak_count::__release_weak(v7);
            }
          }
        }
      }
    }
  }
}

void sub_183F99F84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTP2Stream::_onqueue_notifyStreamClosed(HTTP2Stream *this)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD v18[6];
  std::__shared_weak_count *v19;
  _QWORD v20[6];
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  v2 = *((_QWORD *)this + 4);
  if ((!v2 || !*(_DWORD *)(v2 + 40)) && !*((_BYTE *)this + 176))
  {
    *((_DWORD *)this + 50) |= 1u;
    return;
  }
  if (!*((_BYTE *)this + 130) && *((_QWORD *)this + 3))
  {
    v22 = 0;
    v23 = 0;
    v3 = (std::__shared_weak_count *)*((_QWORD *)this + 36);
    if (v3)
    {
      v4 = std::__shared_weak_count::lock(v3);
      v23 = v4;
      if (v4)
      {
        v5 = *((_QWORD *)this + 35);
        v22 = v5;
        goto LABEL_12;
      }
    }
    else
    {
      v4 = 0;
    }
    v5 = 0;
LABEL_12:
    if (*((_BYTE *)this + 129))
    {
      v6 = *((_QWORD *)this + 4);
    }
    else
    {
      v6 = *((_QWORD *)this + 4);
      if (*((_DWORD *)this + 14) == 3)
      {
        v20[0] = MEMORY[0x1E0C809B0];
        v20[1] = 3321888768;
        v20[2] = ___ZN11HTTP2Stream27_onqueue_notifyStreamClosedEv_block_invoke;
        v20[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
        v20[4] = this;
        v20[5] = v5;
        v21 = v4;
        if (v4)
        {
          p_shared_owners = (unint64_t *)&v4->__shared_owners_;
          do
            v8 = __ldxr(p_shared_owners);
          while (__stxr(v8 + 1, p_shared_owners));
        }
        (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v20);
        *((_BYTE *)this + 130) = 1;
        v9 = v21;
        if (!v21)
          goto LABEL_30;
        v10 = (unint64_t *)&v21->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        goto LABEL_28;
      }
    }
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3321888768;
    v18[2] = ___ZN11HTTP2Stream27_onqueue_notifyStreamClosedEv_block_invoke_2;
    v18[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
    v18[4] = this;
    v18[5] = v5;
    v19 = v4;
    if (v4)
    {
      v12 = (unint64_t *)&v4->__shared_owners_;
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v18);
    v9 = v19;
    if (!v19)
      goto LABEL_30;
    v14 = (unint64_t *)&v19->__shared_owners_;
    do
      v11 = __ldaxr(v14);
    while (__stlxr(v11 - 1, v14));
LABEL_28:
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
LABEL_30:
    v15 = v23;
    if (v23)
    {
      v16 = (unint64_t *)&v23->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
}

void sub_183F9A1A4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

void ___ZN27URLConnectionLoader_Classic29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke(uint64_t a1)
{
  URLConnectionLoader::protocolConnectionEstablished(*(URLConnectionLoader **)(a1 + 32), *(const __CFDictionary **)(a1 + 40));
}

void ___ZN25HTTP2ConnectionCacheEntry16connectionClosedEP15HTTP2Connection_block_invoke(uint64_t a1)
{
  const void *v1;
  uint64_t v2;
  const __CFArray *v3;
  CFIndex FirstIndexOfValue;
  CFIndex v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD v8[6];
  CFRange v9;

  v2 = *(_QWORD *)(a1 + 32);
  v1 = *(const void **)(a1 + 40);
  v3 = *(const __CFArray **)(v2 + 88);
  v9.length = CFArrayGetCount(v3);
  v9.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v3, v9, v1);
  if ((FirstIndexOfValue & 0x8000000000000000) == 0)
  {
    v5 = FirstIndexOfValue;
    CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 88), FirstIndexOfValue);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v2 + 88), v5);
  }
  if (!CFArrayGetCount(*(CFArrayRef *)(v2 + 88)))
  {
    v6 = *(_QWORD **)(v2 + 16);
    (*(void (**)(_QWORD *))(*v6 + 40))(v6);
    CFRetain((CFTypeRef)(v2 - 16));
    v7 = v6[10];
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___ZN20HTTP2ConnectionCache27cacheEntryDidBecomeUnusableEP25HTTP2ConnectionCacheEntry_block_invoke;
    v8[3] = &__block_descriptor_48_e5_v8__0l;
    v8[4] = v6;
    v8[5] = v2;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v7 + 96))(v7, v8);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t ___ZN20HTTP2ConnectionCache27cacheEntryDidBecomeUnusableEP25HTTP2ConnectionCacheEntry_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  if (!*(_BYTE *)(v2 + 128))
    TubeManager::invalidateKey(*(_QWORD *)(v2 + 104), *(void **)(v3 + 24), 1, 1u);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v2 + 96), *(const void **)(v3 + 24));
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 40) - 16));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN19URLConnectionLoader29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke_4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(a1 + 32))
  {
    v3 = *(_QWORD *)(v2 + 72);
    if (v3)
      *(_BYTE *)(v3 + 13) = 1;
    *(_BYTE *)(v2 + 97) = 1;
    URLConnectionLoader::_private_followRedirection((URLConnectionLoader *)v2, *(CFTypeRef *)(a1 + 32));
  }
  else
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 48))(*(_QWORD *)(v2 + 32));
  }
  v4 = *(const void **)(a1 + 32);
  if (v4)
    CFRelease(v4);
}

uint64_t ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

CFAllocatorRef `non-virtual thunk to'URLConnection::_irl_allocator(URLConnection *this)
{
  return CFGetAllocator((char *)this - 24);
}

void URLConnectionLoader::protocolConnectionEstablished(URLConnectionLoader *this, const __CFDictionary *a2)
{
  RedirectionRecorder *var12;
  uint64_t v5;
  uint64_t v6;
  const __CFAllocator *v7;
  const void *v8;
  CFStringRef v9;
  CFStringRef v10;
  InterfaceRequiredForLoader *var5;
  _QWORD v12[6];
  void (**v13)(AutoString *__hidden);
  CFStringRef v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (this->var21)
  {
    var12 = this->var12;
    if (var12)
    {
      (*(void (**)(RedirectionRecorder *, const __CFDictionary *))(*(_QWORD *)var12 + 168))(var12, a2);
    }
    else
    {
      v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_39_9601, 2);
      if (v5)
      {
        v6 = v5;
        if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v5 + 16))(v5, "Connection Established", 0))
        {
          v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v8 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))this->var0 + 3))(this);
          v13 = &off_1E14E4818;
          v15 = 0;
          v16 = 0;
          v14 = CFStringCreateWithCString(v7, "Loader", 0x8000100u);
          (*(void (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)v6 + 64))(v6, v14, v8);
          AutoString::~AutoString((AutoString *)&v13);
          if (v8)
            CFRelease(v8);
          v13 = &off_1E14E4818;
          v9 = CFStringCreateWithCString(v7, "Connection Properties", 0x8000100u);
          v15 = 0;
          v16 = 0;
          v14 = v9;
          if (a2)
          {
            v10 = CFCopyDescription(a2);
            v9 = v14;
          }
          else
          {
            v10 = CFSTR("null");
          }
          (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(_QWORD *)v6 + 64))(v6, v9, v10);
          if (a2 && v10)
            CFRelease(v10);
          AutoString::~AutoString((AutoString *)&v13);
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
        }
      }
      URLConnectionLoader::touchConnection(this);
      if (!this->var29 && (*(_BYTE *)&this->var28 & 8) != 0)
      {
        if (a2)
          CFRetain(a2);
        var5 = this->var5;
        v12[0] = MEMORY[0x1E0C809B0];
        v12[1] = 3221225472;
        v12[2] = ___ZN19URLConnectionLoader29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke_2;
        v12[3] = &__block_descriptor_48_e35_v16__0__LoaderClientInterface_____8l;
        v12[4] = this;
        v12[5] = a2;
        (*(void (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v12);
      }
      this->var29 = 1;
    }
  }
}

void sub_183F9A628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void ___ZN27URLConnectionLoader_Classic28protocolCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke(uint64_t a1)
{
  const void *v2;

  URLConnectionLoader::protocolCacheResponseIsValid(*(URLConnectionLoader **)(a1 + 32), *(CFTypeRef *)(a1 + 40));
  v2 = *(const void **)(a1 + 40);
  if (v2)
    CFRelease(v2);
}

uint64_t ___ZN27URLConnectionClient_Classic18_withDelegateAsyncEPKcU13block_pointerFvP16_CFURLConnectionPK33CFURLConnectionClientCurrent_VMaxE_block_invoke_2(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(result + 32);
  v2 = *(_QWORD *)(v1 + 264) - 1;
  *(_QWORD *)(v1 + 264) = v2;
  if (!v2)
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 32) + 72))(*(_QWORD *)(v1 + 32));
  return result;
}

void ___ZN20ClassicURLConnection21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN19URLConnectionClient21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN12HTTPProtocol15needServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicybE_block_invoke(uint64_t a1)
{
  _QWORD *v1;

  v1 = *(_QWORD **)(a1 + 32);
  if (v1[53])
    (*(void (**)(_QWORD, _QWORD))(*v1 + 120))(*(_QWORD *)(a1 + 32), 0);
  CFRelease(v1 - 2);
}

void sub_183F9A840(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'URLConnectionLoader::_loaderInterface_useCredential(URLConnectionLoader *this, const _CFURLCredential *a2, _CFURLAuthChallenge *a3)
{
  URLConnectionLoader::_loaderInterface_useCredential((URLConnectionLoader *)((char *)this - 48), a2, a3);
}

void `non-virtual thunk to'URLConnectionLoader::_loaderEvent_CancelLoad(uint64_t a1, uint64_t a2)
{
  URLConnectionLoader::_loaderEvent_CancelLoad(a1 - 48, a2);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::updateScheduling(HTTPTransactionWrapper *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(_QWORD, const CoreSchedulingSet *))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1), a2);
}

uint64_t `non-virtual thunk to'HTTP3StreamWrapper::updateScheduling(HTTP3StreamWrapper *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(_QWORD, const CoreSchedulingSet *))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1), a2);
}

void std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__erase_unique<std::shared_ptr<__CoalescingConnectionKey>>(_QWORD *a1, _QWORD *a2)
{
  uint64_t *v2;
  _QWORD *v3;
  _QWORD *v6;
  uint64_t v7;
  _BOOL4 v8;
  uint64_t *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  BOOL v13;

  v3 = a1 + 1;
  v2 = (uint64_t *)a1[1];
  if (v2)
  {
    v6 = a1 + 1;
    v7 = a1[1];
    do
    {
      v8 = std::less<std::string>::operator()[abi:nn180100](*(_QWORD **)(v7 + 32), a2);
      v9 = (uint64_t *)(v7 + 8);
      if (!v8)
      {
        v9 = (uint64_t *)v7;
        v6 = (_QWORD *)v7;
      }
      v7 = *v9;
    }
    while (*v9);
    if (v6 != v3 && !std::less<std::string>::operator()[abi:nn180100](a2, (_QWORD *)v6[4]))
    {
      v10 = (_QWORD *)v6[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
      else
      {
        v12 = v6;
        do
        {
          v11 = (_QWORD *)v12[2];
          v13 = *v11 == (_QWORD)v12;
          v12 = v11;
        }
        while (!v13);
      }
      if ((_QWORD *)*a1 == v6)
        *a1 = v11;
      --a1[2];
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v2, v6);
      std::__tree<std::string>::destroy((char *)v6[7]);
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v6 + 4));
      operator delete(v6);
    }
  }
}

void TubeManagerFastPathCache::~TubeManagerFastPathCache(CFTypeRef *this)
{
  *this = &off_1E14ED218;
  CFRelease(this[1]);
  *this = &off_1E14E5838;
  JUMPOUT(0x186DB748CLL);
}

{
  *this = &off_1E14ED218;
  CFRelease(this[1]);
  *this = &off_1E14E5838;
}

URLConnectionLoader *URLConnectionLoader::protocolCacheResponseIsValid(URLConnectionLoader *this, CFTypeRef cf)
{
  URLConnectionLoader *v3;
  InterfaceRequiredForLoader *var5;
  _QWORD v5[5];

  if (this->var21)
  {
    v3 = this;
    this = (URLConnectionLoader *)this->var12;
    if (this)
    {
      (*((void (**)(URLConnectionLoader *, CFTypeRef))this->var0 + 11))(this, cf);
      return URLConnectionLoader::replayOrConsumeRedirections(v3);
    }
    else if (!v3->var23)
    {
      if (cf)
        CFRetain(cf);
      var5 = v3->var5;
      v5[0] = MEMORY[0x1E0C809B0];
      v5[1] = 3221225472;
      v5[2] = ___ZN19URLConnectionLoader28protocolCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke;
      v5[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
      v5[4] = cf;
      return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, _QWORD *))(*(_QWORD *)var5 + 40))(var5, v5);
    }
  }
  return this;
}

void HTTPConnectionCache::~HTTPConnectionCache(HTTPConnectionCache *this)
{
  uint64_t v2;

  HTTPConnectionCache::~HTTPConnectionCache(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E14E9E58;
  *((_QWORD *)this + 4) = &unk_1E14E9F18;
  v2 = *((_QWORD *)this + 5);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 12) + 48))(*((_QWORD *)this + 12));
  *((_QWORD *)this + 13) = 0;
  CFRelease(*((CFTypeRef *)this + 6));
  *((_QWORD *)this + 4) = &off_1E14E5838;
  *(_QWORD *)this = off_1E14EA0F0;

}

void sub_183F9AB40(_Unwind_Exception *a1)
{
  uint64_t v1;

  CFRelease(*(CFTypeRef *)(v1 + 48));
  *(_QWORD *)(v1 + 32) = &off_1E14E5838;
  *(_QWORD *)v1 = off_1E14EA0F0;

  _Unwind_Resume(a1);
}

void HTTPConnectionCacheDictionary::~HTTPConnectionCacheDictionary(HTTPConnectionCacheDictionary *this)
{
  *(_QWORD *)this = off_1E14EEC90;
  *((_QWORD *)this + 2) = &unk_1E14EECB0;
  *((_QWORD *)this + 3) = &off_1E14EA4E8;
  CFRelease(*((CFTypeRef *)this + 4));
  *((_QWORD *)this + 2) = &off_1E14E5838;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

{
  *(_QWORD *)this = off_1E14EEC90;
  *((_QWORD *)this + 2) = &unk_1E14EECB0;
  *((_QWORD *)this + 3) = &off_1E14EA4E8;
  CFRelease(*((CFTypeRef *)this + 4));
  *((_QWORD *)this + 2) = &off_1E14E5838;
}

void HTTPConnectionCache::invalidateAllConnections(HTTPConnectionCache *this, char a2)
{
  uint64_t v3;
  _QWORD context[4];
  char v5;

  v3 = *((_QWORD *)this + 5);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 3221225472;
  context[2] = ___ZN29HTTPConnectionCacheDictionary18forgetCacheEntriesEb_block_invoke;
  context[3] = &__block_descriptor_33_e14_v24__0r_v8_v16l;
  v5 = a2;
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(v3 + 32), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTPConnectionCacheEntryWrapper *>::_visit, context);
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(*((_QWORD *)this + 5) + 32));
  CFSetRemoveAllValues(*((CFMutableSetRef *)this + 6));
  HTTPConnectionCache::disableTimer(this);
  HTTPConnectionCache::disableCellTimer(this);
}

uint64_t HTTPConnectionCache::timeoutIdleConnections(HTTPConnectionCache *this)
{
  uint64_t result;

  HTTPConnectionCache::disableTimer(this);
  HTTPConnectionCache::purgeExcessiveConnections(this);
  result = HTTPConnectionCache::performIdleSweep(this);
  if (result)
    return HTTPConnectionCache::enableTimer(this);
  return result;
}

uint64_t ___ZN19HTTPConnectionCache15enableCellTimerEv_block_invoke(uint64_t a1)
{
  HTTPConnectionCache *v1;
  uint64_t result;

  v1 = *(HTTPConnectionCache **)(a1 + 32);
  HTTPConnectionCache::disableCellTimer(v1);
  HTTPConnectionCache::purgeExcessiveConnections(v1);
  result = HTTPConnectionCache::performIdleSweep(v1);
  if (result)
    return (*(uint64_t (**)(HTTPConnectionCache *))(*(_QWORD *)v1 + 152))(v1);
  return result;
}

uint64_t HTTPConnectionCache::performIdleSweep(HTTPConnectionCache *this)
{
  uint64_t v1;
  double Current;
  int v4;
  int v5;
  uint64_t v6;
  const void **v7;
  const void **v8;
  const __CFDictionary *v9;
  unint64_t Count;
  const void **v11;
  uint64_t v12;
  CFTypeRef *v13;
  const __CFDictionary *v14;
  unint64_t v15;
  const void **v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  double v20;
  uint64_t v21;
  HTTPConnectionCacheEntry *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  CFIndex v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  CFRange v41;
  const void **v42;
  CFIndex v43;
  void *v44;
  uint64_t v45;
  HTTPConnectionCacheEntry **Value;
  HTTPConnectionCacheEntry **v47;
  HTTPConnectionCacheEntry *v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  __CFArray *theArray;
  CFTypeRef v56;
  CFIndex range;
  const void **v58;
  _BYTE v59[248];
  CFIndex v60;
  HTTPConnectionCacheEntry *v61;
  std::__shared_weak_count *v62;

  v1 = *((_QWORD *)this + 5);
  if (!v1)
    return 0;
  theArray = CFArrayCreateMutable(*(CFAllocatorRef *)(v1 + 8), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  Current = CFAbsoluteTimeGetCurrent();
  v5 = *((_DWORD *)this + 20);
  v4 = *((_DWORD *)this + 21);
  v6 = *((_QWORD *)this + 5);
  v7 = (const void **)operator new();
  v8 = v7;
  v9 = *(const __CFDictionary **)(v6 + 32);
  if (!v9)
  {
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v7 + 3;
    goto LABEL_11;
  }
  *v7 = CFRetain(*(CFTypeRef *)(v6 + 32));
  Count = CFDictionaryGetCount(v9);
  v8[1] = (const void *)Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v8[2] = 0;
    goto LABEL_11;
  }
  if (Count > 0x1E)
  {
    v11 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v8[2] = v11;
    if (!v11)
      goto LABEL_11;
  }
  else
  {
    v11 = v8 + 3;
    v8[2] = v8 + 3;
  }
  CFDictionaryGetKeysAndValues(v9, v11, 0);
LABEL_11:
  v13 = v8 + 34;
  v14 = *(const __CFDictionary **)(v6 + 32);
  if (!v14)
  {
    *v13 = 0;
    v8[35] = 0;
    v8[36] = v8 + 37;
    goto LABEL_19;
  }
  *v13 = CFRetain(*(CFTypeRef *)(v6 + 32));
  v15 = CFDictionaryGetCount(v14);
  v8[35] = (const void *)v15;
  if (v15 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v8[36] = 0;
    goto LABEL_19;
  }
  if (v15 > 0x1E)
  {
    v16 = (const void **)malloc_type_malloc(8 * v15, 0x89ED541CuLL);
    v8[36] = v16;
    if (!v16)
      goto LABEL_19;
  }
  else
  {
    v16 = v8 + 37;
    v8[36] = v8 + 37;
  }
  CFDictionaryGetKeysAndValues(v14, 0, v16);
LABEL_19:
  v17 = (uint64_t)v8[35];
  if (v17 < 1)
  {
    v12 = 0;
  }
  else
  {
    v18 = 0;
    v12 = 0;
    v19 = Current - (double)v5;
    v20 = Current - (double)v4;
    do
    {
      v21 = *((_QWORD *)v8[36] + v18);
      v22 = *(HTTPConnectionCacheEntry **)(v21 + 24);
      v23 = *(std::__shared_weak_count **)(v21 + 32);
      v56 = v22;
      range = (CFIndex)v23;
      if (v23)
      {
        p_shared_owners = (unint64_t *)&v23->__shared_owners_;
        do
          v25 = __ldxr(p_shared_owners);
        while (__stxr(v25 + 1, p_shared_owners));
      }
      HTTPConnectionCacheEntry::purgeIdleConnections(v22, v19, v20);
      if (v23)
      {
        v26 = (unint64_t *)&v23->__shared_owners_;
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      v28 = *(_QWORD *)(v21 + 24);
      v29 = *(std::__shared_weak_count **)(v21 + 32);
      v56 = (CFTypeRef)v28;
      range = (CFIndex)v29;
      if (v29)
      {
        v30 = (unint64_t *)&v29->__shared_owners_;
        do
          v31 = __ldxr(v30);
        while (__stxr(v31 + 1, v30));
      }
      v32 = CFArrayGetCount(*(CFArrayRef *)(v28 + 80));
      v34 = *(_QWORD *)(v28 + 88);
      v33 = *(_QWORD *)(v28 + 96);
      v35 = *(_QWORD *)(v33 + 8);
      v36 = *(_QWORD *)(v33 + 16);
      if (v29)
      {
        v37 = (unint64_t *)&v29->__shared_owners_;
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
      v39 = v34 + v32 + ((v36 - v35) >> 4);
      if (v39)
        v12 += v39;
      else
        CFArrayAppendValue(theArray, *((const void **)v8[2] + v18));
      ++v18;
    }
    while (v18 != v17);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)(v8 + 34));
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v8);
  MEMORY[0x186DB748C]();
  if (theArray)
  {
    v56 = CFRetain(theArray);
    v40 = CFArrayGetCount(theArray);
    v41.length = v40;
    range = v40;
    if (v40 - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      v58 = 0;
    }
    else
    {
      if (v40 <= 0x1E)
      {
        v42 = (const void **)v59;
        v58 = (const void **)v59;
LABEL_51:
        v41.location = 0;
        CFArrayGetValues(theArray, v41, v42);
        goto LABEL_52;
      }
      v42 = (const void **)malloc_type_malloc(8 * v40, 0x89ED541CuLL);
      v58 = v42;
      if (v42)
      {
        v41.length = range;
        goto LABEL_51;
      }
    }
  }
  else
  {
    v56 = 0;
    range = 0;
    v58 = (const void **)v59;
  }
LABEL_52:
  v60 = 0;
  if (range >= 1)
  {
    v43 = 0;
    do
    {
      v60 = v43 + 1;
      v44 = (void *)v58[v43];
      TubeManager::invalidateKey(*((_QWORD *)this + 13), v44, 0, 0);
      v45 = *((_QWORD *)this + 5);
      Value = (HTTPConnectionCacheEntry **)CFDictionaryGetValue(*(CFDictionaryRef *)(v45 + 32), v44);
      v47 = Value;
      if (Value)
      {
        v48 = Value[3];
        v49 = (std::__shared_weak_count *)v47[4];
        v61 = v48;
        v62 = v49;
        if (v49)
        {
          v50 = (unint64_t *)&v49->__shared_owners_;
          do
            v51 = __ldxr(v50);
          while (__stxr(v51 + 1, v50));
        }
        HTTPConnectionCacheEntry::setHasBeenForgotten(v48, 0);
        if (v49)
        {
          v52 = (unint64_t *)&v49->__shared_owners_;
          do
            v53 = __ldaxr(v52);
          while (__stlxr(v53 - 1, v52));
          if (!v53)
          {
            ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
            std::__shared_weak_count::__release_weak(v49);
          }
        }
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v45 + 32), v44);
      }
      if (CFSetContainsValue(*((CFSetRef *)this + 6), v44))
        CFSetRemoveValue(*((CFMutableSetRef *)this + 6), v44);
      v43 = v60;
    }
    while (v60 < range);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v56);
  CFRelease(theArray);
  return v12;
}

void sub_183F9B188(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf, char a11)
{
  CFRelease(cf);
  _Unwind_Resume(a1);
}

void HTTPConnectionCacheEntry::purgeIdleConnections(HTTPConnectionCacheEntry *this, double a2, double a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  _OWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  char *v35;
  __int128 v36;
  int64x2_t v37;
  double Current;
  double v39;
  _BOOL4 v40;
  char *v41;
  unint64_t *v42;
  unint64_t v43;
  double v44;
  double *v45;
  double v46;
  int v47;
  unint64_t *p_shared_owners;
  unint64_t v49;
  void ***i;
  void ***v51;
  void **v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  void **v62;
  std::__shared_weak_count *v63;
  __int128 v64;
  __int128 v65;
  int64x2_t v66;
  char *v67;
  void **v68;
  int64x2_t v69;
  char *v70;
  char **v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t v75;
  char v76;

  v67 = 0;
  v66 = 0uLL;
  v3 = *(_QWORD *)(*((_QWORD *)this + 12) + 16) - *(_QWORD *)(*((_QWORD *)this + 12) + 8);
  if (v3 < 1)
    goto LABEL_81;
  v7 = 0;
  v8 = (unint64_t)v3 >> 4;
  if (v8 <= 1)
    v9 = 1;
  else
    v9 = v8;
  do
  {
    v10 = *(_QWORD *)(*((_QWORD *)this + 12) + 8);
    if (v7 >= (*(_QWORD *)(*((_QWORD *)this + 12) + 16) - v10) >> 4)
    {
      v65 = 0uLL;
    }
    else
    {
      v11 = *(_OWORD *)(v10 + 16 * v7);
      v65 = v11;
      v12 = *((_QWORD *)&v11 + 1);
      if (*((_QWORD *)&v11 + 1))
      {
        v13 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
        v15 = v11;
        if (!(_QWORD)v11)
          goto LABEL_14;
        v64 = v11;
        do
          v16 = __ldxr(v13);
        while (__stxr(v16 + 1, v13));
        v17 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
      }
      else
      {
        v15 = v11;
        if (!(_QWORD)v11)
          goto LABEL_14;
        v17 = 0;
        v64 = (unint64_t)v11;
      }
      v68 = 0;
      v69.i64[0] = (uint64_t)&v68;
      v69.i64[1] = 0x2020000000;
      LOBYTE(v70) = 0;
      Current = CFAbsoluteTimeGetCurrent();
      v39 = *(double *)(v15 + 216);
      *(_BYTE *)(v69.i64[0] + 24) = Current < v39;
      _Block_object_dispose(&v68, 8);
      if (Current >= v39)
      {
        CFAbsoluteTimeGetCurrent();
        v68 = 0;
        v69.i64[0] = (uint64_t)&v68;
        v69.i64[1] = 0x2020000000;
        v70 = 0;
        if (*(_QWORD *)(v15 + 120) == *(_QWORD *)(v15 + 128))
        {
          v44 = *(double *)(v15 + 208);
          v45 = (double *)&v70;
        }
        else
        {
          v44 = CFAbsoluteTimeGetCurrent();
          v45 = (double *)(v69.i64[0] + 24);
        }
        *v45 = v44;
        _Block_object_dispose(&v68, 8);
        v46 = a2;
        if (a2 != a3)
        {
          v73 = 0;
          v74 = &v73;
          v75 = 0x2020000000;
          v76 = 0;
          v68 = (void **)MEMORY[0x1E0C809B0];
          v69.i64[0] = 3221225472;
          v69.i64[1] = (uint64_t)___ZN14HTTPConnection10isCellularEv_block_invoke;
          v70 = (char *)&unk_1E14FDA68;
          v71 = (char **)&v73;
          v72 = v15;
          ___ZN14HTTPConnection10isCellularEv_block_invoke((uint64_t)&v68);
          v47 = *((unsigned __int8 *)v74 + 24);
          _Block_object_dispose(&v73, 8);
          if (v47)
            v46 = a3;
          else
            v46 = a2;
        }
        v40 = v46 > v44;
        if (!v12)
        {
LABEL_58:
          if (!v40)
            goto LABEL_40;
          goto LABEL_14;
        }
      }
      else
      {
        v40 = 0;
        if (!v12)
          goto LABEL_58;
      }
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        v49 = __ldaxr(p_shared_owners);
      while (__stlxr(v49 - 1, p_shared_owners));
      if (v49)
        goto LABEL_58;
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
      if (!v40)
        goto LABEL_40;
    }
LABEL_14:
    v18 = v66.i64[1];
    if (v66.i64[1] >= (unint64_t)v67)
    {
      v23 = (v66.i64[1] - v66.i64[0]) >> 4;
      v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 60)
        abort();
      v25 = (uint64_t)&v67[-v66.i64[0]];
      if ((uint64_t)&v67[-v66.i64[0]] >> 3 > v24)
        v24 = v25 >> 3;
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF0)
        v26 = 0xFFFFFFFFFFFFFFFLL;
      else
        v26 = v24;
      v71 = &v67;
      v27 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>(v26);
      v29 = &v27[16 * v23];
      v30 = *((_QWORD *)&v65 + 1);
      *(_OWORD *)v29 = v65;
      if (v30)
      {
        v31 = (unint64_t *)(v30 + 8);
        do
          v32 = __ldxr(v31);
        while (__stxr(v32 + 1, v31));
      }
      v33 = (_QWORD *)v66.i64[1];
      v34 = (_QWORD *)v66.i64[0];
      if (v66.i64[1] == v66.i64[0])
      {
        v37 = vdupq_n_s64(v66.u64[1]);
        v35 = &v27[16 * v23];
      }
      else
      {
        v35 = &v27[16 * v23];
        do
        {
          v36 = *((_OWORD *)v33 - 1);
          v33 -= 2;
          *((_OWORD *)v35 - 1) = v36;
          v35 -= 16;
          *v33 = 0;
          v33[1] = 0;
        }
        while (v33 != v34);
        v37 = v66;
      }
      v22 = v29 + 16;
      v66.i64[0] = (uint64_t)v35;
      v66.i64[1] = (uint64_t)(v29 + 16);
      v69 = v37;
      v41 = v67;
      v67 = &v27[16 * v28];
      v70 = v41;
      v68 = (void **)v37.i64[0];
      std::__split_buffer<std::shared_ptr<HTTPConnection>>::~__split_buffer((uint64_t)&v68);
    }
    else
    {
      *(_QWORD *)v66.i64[1] = v65;
      v19 = *((_QWORD *)&v65 + 1);
      *(_QWORD *)(v18 + 8) = *((_QWORD *)&v65 + 1);
      if (v19)
      {
        v20 = (unint64_t *)(v19 + 8);
        do
          v21 = __ldxr(v20);
        while (__stxr(v21 + 1, v20));
      }
      v22 = (_OWORD *)(v18 + 16);
    }
    v66.i64[1] = (uint64_t)v22;
LABEL_40:
    if (*((_QWORD *)&v65 + 1))
    {
      v42 = (unint64_t *)(*((_QWORD *)&v65 + 1) + 8);
      do
        v43 = __ldaxr(v42);
      while (__stlxr(v43 - 1, v42));
      if (!v43)
      {
        (*(void (**)(_QWORD))(**((_QWORD **)&v65 + 1) + 16))(*((_QWORD *)&v65 + 1));
        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v65 + 1));
      }
    }
    ++v7;
  }
  while (v7 != v9);
  v51 = (void ***)v66.i64[1];
  for (i = (void ***)v66.i64[0]; i != v51; i += 2)
  {
    v52 = *i;
    v53 = (std::__shared_weak_count *)i[1];
    v68 = *i;
    v69.i64[0] = (uint64_t)v53;
    if (v53)
    {
      v54 = (unint64_t *)&v53->__shared_owners_;
      do
        v55 = __ldxr(v54);
      while (__stxr(v55 + 1, v54));
      v63 = v53;
      do
        v56 = __ldxr(v54);
      while (__stxr(v56 + 1, v54));
    }
    else
    {
      v63 = 0;
    }
    v62 = v52;
    HTTPConnectionCacheEntry::_removeConnection((HTTPConnectionCacheEntry::ConnectionArray **)this, (uint64_t *)&v62);
    if (v53)
    {
      v57 = (unint64_t *)&v53->__shared_owners_;
      do
        v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }
    }
    v59 = (std::__shared_weak_count *)v69.i64[0];
    if (v69.i64[0])
    {
      v60 = (unint64_t *)(v69.i64[0] + 8);
      do
        v61 = __ldaxr(v60);
      while (__stlxr(v61 - 1, v60));
      if (!v61)
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
    }
  }
LABEL_81:
  v68 = (void **)&v66;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&v68);
}

void sub_183F9B6A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void **a26)
{
  _Block_object_dispose(&a26, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a15);
  a26 = (void **)&a17;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a26);
  _Unwind_Resume(a1);
}

void HTTPConnectionCache::disableCellTimer(HTTPConnectionCache *this)
{
  NSObject *v2;

  v2 = *((_QWORD *)this + 15);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 15));
    *((_QWORD *)this + 15) = 0;
  }
}

void ___ZN14HTTPConnection10isCellularEv_block_invoke(uint64_t a1)
{
  HTTPEngine *v2;
  CFTypeRef v3;
  const void *v4;
  CFTypeID v5;
  uint8_t v6[16];

  v2 = *(HTTPEngine **)(*(_QWORD *)(a1 + 40) + 64);
  if (v2)
  {
    v3 = HTTPEngine::copyProperty(v2, CFSTR("kCFStreamPropertyConnectionIsCellular"));
    if (v3)
    {
      v4 = v3;
      v5 = CFGetTypeID(v3);
      if (v5 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v6 = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v6, 2u);
      }
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *MEMORY[0x1E0C9AE50] == (_QWORD)v4;
      CFRelease(v4);
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
  }
}

void HTTPConnectionCache::disableTimer(HTTPConnectionCache *this)
{
  NSObject *v2;

  v2 = *((_QWORD *)this + 14);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 14));
    *((_QWORD *)this + 14) = 0;
  }
}

void HTTPTransaction::updateScheduling(HTTPTransaction *this, const CoreSchedulingSet *a2)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;

  if (a2)
    (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 40))(a2);
  v12 = 0;
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (v4)
  {
    v4 = std::__shared_weak_count::lock(v4);
    v5 = v4;
    v12 = v4;
    if (v4)
      v4 = (std::__shared_weak_count *)*((_QWORD *)this + 5);
  }
  else
  {
    v5 = 0;
  }
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  HTTPTransaction::_onqueue_updateScheduling((HTTPTransaction *)v4, a2, 1);
  if (a2)
    (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 48))(a2);
  if (v5)
  {
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (v12)
  {
    v10 = (unint64_t *)&v12->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_183F9B9C0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 48);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTPTransaction16updateSchedulingEPK17CoreSchedulingSet_block_invoke(uint64_t a1)
{
  uint64_t result;

  HTTPTransaction::_onqueue_updateScheduling(*(HTTPTransaction **)(a1 + 32), *(const CoreSchedulingSet **)(a1 + 48), 1);
  result = *(_QWORD *)(a1 + 48);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

void GlueTubeManager::~GlueTubeManager(GlueTubeManager *this)
{
  uint64_t v2;

  GlueTubeManager::~GlueTubeManager(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = off_1E14E7760;
  *((_QWORD *)this + 3) = &unk_1E14E77A8;
  v2 = *((_QWORD *)this + 6);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 6) = 0;
  }
  v3 = *((_QWORD *)this + 4);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
    *((_QWORD *)this + 4) = 0;
  }
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    *((_QWORD *)this + 5) = 0;
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 96);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

void sub_183F9BADC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 96);
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void TubeManager::~TubeManager(TubeManager *this)
{
  uint64_t v2;

  TubeManager::~TubeManager(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  const void *v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E14E5390;
  *((_QWORD *)this + 3) = &unk_1E14E53E0;
  TubeManager::releaseConnectionCaches(this);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 4) + 48))(*((_QWORD *)this + 4));
  *((_QWORD *)this + 4) = 0;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 168);
  v2 = (const void *)*((_QWORD *)this + 20);
  *((_QWORD *)this + 20) = 0;
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  CFRelease(*((CFTypeRef *)this + 18));
  CFRelease(*((CFTypeRef *)this + 17));
  *((_QWORD *)this + 15) = &off_1E14EA528;
  CFRelease(*((CFTypeRef *)this + 16));
  *((_QWORD *)this + 13) = &off_1E14EA488;
  CFRelease(*((CFTypeRef *)this + 14));
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

void sub_183F9BBE4(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;
  uint64_t v4;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 168);
  v3 = *(const void **)(v1 + 160);
  *(_QWORD *)(v1 + 160) = 0;
  if (v3)
    CFRelease(v3);
  v4 = *(_QWORD *)(v1 + 152);
  *(_QWORD *)(v1 + 152) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  CFRelease(*(CFTypeRef *)(v1 + 144));
  CFRelease(*(CFTypeRef *)(v1 + 136));
  *(_QWORD *)(v1 + 120) = &off_1E14EA528;
  CFRelease(*(CFTypeRef *)(v1 + 128));
  *(_QWORD *)(v1 + 104) = &off_1E14EA488;
  CFRelease(*(CFTypeRef *)(v1 + 112));
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void HTTP3Stream::updateScheduling(HTTP3Stream *this, const CoreSchedulingSet *a2)
{
  char *v4;
  uint64_t v5;
  _BOOL8 v6;
  _QWORD *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  char v17;
  char v18;
  __int128 v19;

  v4 = (char *)this + 312;
  v5 = *((_QWORD *)this + 39);
  if (!v5)
  {
    v6 = 0;
    if (!a2)
      goto LABEL_4;
    goto LABEL_3;
  }
  v6 = *(_DWORD *)(v5 + 40) != 0;
  if (a2)
LABEL_3:
    (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 40))(a2);
LABEL_4:
  *(_QWORD *)&v19 = a2;
  v7 = (_QWORD *)operator new();
  *v7 = &off_1E14F1668;
  v7[1] = 0;
  v7[2] = 0;
  v7[3] = a2;
  *((_QWORD *)&v19 + 1) = v7;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v4, &v19);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
  if (*((_QWORD *)&v19 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = *((_QWORD *)this + 12);
  v12 = (std::__shared_weak_count *)*((_QWORD *)this + 13);
  *(_QWORD *)&v19 = v11;
  *((_QWORD *)&v19 + 1) = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  if (v11)
    (*(void (**)(uint64_t, const CoreSchedulingSet *, _BOOL8))(*(_QWORD *)v11 + 40))(v11, a2, v6);
  if (v12)
  {
    v15 = (unint64_t *)&v12->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v17 = *((_BYTE *)this + 127);
  v18 = *((_BYTE *)this + 128);
  *(_WORD *)((char *)this + 127) = 0;
  if ((v17 & 1) != 0)
    HTTP3Stream::_read(this, 0);
  if ((v18 & 1) != 0)
    HTTP3Stream::_protocolCallback(this);
}

void sub_183F9BDE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void XTubeManager::~XTubeManager(XTubeManager *this)
{
  uint64_t v2;

  XTubeManager::~XTubeManager(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  *(_QWORD *)this = off_1E14E65B8;
  XTubeManager::invalidateAllConnections((CFDictionaryRef *)this, 0);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 40));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 144);
  *((_QWORD *)this + 3) = &off_1E14EA468;
  CFRelease(*((CFTypeRef *)this + 4));
}

void sub_183F9BF50(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 144);
  *(_QWORD *)(v1 + 24) = &off_1E14EA468;
  CFRelease(*(CFTypeRef *)(v1 + 32));
  _Unwind_Resume(a1);
}

uint64_t XTubeManager::invalidateAllConnections(CFDictionaryRef *this, char a2)
{
  pthread_mutex_t *v4;
  _QWORD context[4];
  char v7;

  v4 = (pthread_mutex_t *)(this + 5);
  pthread_mutex_lock((pthread_mutex_t *)(this + 5));
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 3221225472;
  context[2] = ___ZN12XTubeManager24invalidateAllConnectionsEb_block_invoke;
  context[3] = &__block_descriptor_33_e136_v24__0r__CoreSchedulingSet________CFAllocator_i______opaque_pthread_t_i____CFSet___os_unfair_lock_s_I_____CFRunLoop_____CFString_i_8_v16l;
  v7 = a2;
  CFDictionaryApplyFunction(this[4], (CFDictionaryApplierFunction)RetainableTypedDict<CoreSchedulingSet const*,GlueTubeManager *>::_visit, context);
  return pthread_mutex_unlock(v4);
}

void sub_183F9C804(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&_lock);
  _Unwind_Resume(a1);
}

void sub_183F9CBDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *))
{
  void *v14;
  void *v15;

  a14(&a12);
  _Unwind_Resume(a1);
}

void sub_183F9DD00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,void (*a25)(char *))
{
  uint64_t v25;
  const void *v27;

  _Block_object_dispose((const void *)(v25 - 176), 8);
  v27 = *(const void **)(v25 - 128);
  *(_QWORD *)(v25 - 128) = 0;
  if (v27)
    CFRelease(v27);
  a25(&a23);
  _Unwind_Resume(a1);
}

void ___ZL8getDafsav_block_invoke()
{
  void *v0;
  void *v1;
  NSObject *v2;
  CFURLRef v3;
  CFURLRef v4;
  unsigned __int8 v5;
  NSObject *v6;
  NSObject *v7;
  uint8_t buf[4];
  const __CFString *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  objc_msgSend(CFSTR("com.apple.nsurlsessiond"), "UTF8String");
  objc_msgSend(CFSTR("systemgroup.com.apple.nsurlstoragedresources"), "UTF8String");
  v0 = (void *)container_system_group_path_for_identifier();
  if (v0)
  {
    v1 = (void *)objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:", v0, 1, 0);
    free(v0);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v9 = CFSTR("systemgroup.com.apple.nsurlstoragedresources");
      _os_log_debug_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "Error getting the system group container for Group ID %@ ", buf, 0xCu);
    }
    v1 = 0;
  }
  if ((mmapDafsaFileAtLocation((const char *)objc_msgSend((id)objc_msgSend(v1, "URLByAppendingPathComponent:isDirectory:", CFSTR("Library/dafsaData.bin"), 0), "fileSystemRepresentation")) & 1) == 0)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v2 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_183ECA000, v2, OS_LOG_TYPE_INFO, "TLD info from asset location is unavailable or too old. Falling back to builtin", buf, 2u);
    }
    if (__CFNGetCFNetworkBundle::onceToken != -1)
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4752);
    v3 = CFBundleCopyResourceURL((CFBundleRef)__CFNGetCFNetworkBundle::bundle, CFSTR("DafsaData"), CFSTR("bin"), 0);
    v4 = v3;
    if (v3)
    {
      v5 = mmapDafsaFileAtLocation((const char *)-[__CFURL fileSystemRepresentation](v3, "fileSystemRepresentation"));
      CFRelease(v4);
      if ((v5 & 1) != 0)
        return;
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v6 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
        goto LABEL_20;
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, v6, OS_LOG_TYPE_FAULT, "Failed to get builtin TLD URL", buf, 2u);
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
LABEL_20:
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, v7, OS_LOG_TYPE_FAULT, "Failed to mmap TLD info", buf, 2u);
    }
  }
}

void sub_183F9E058(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

const char *mmapDafsaFileAtLocation(const char *result)
{
  const char *v1;
  int v2;
  int v3;
  off_t st_size;
  unsigned int *v5;
  NSObject *v6;
  NSObject *v7;
  unint64_t v8;
  unint64_t v9;
  NSObject *v10;
  NSObject *v11;
  unsigned int *v12;
  unint64_t v13;
  NSObject *v14;
  int v15;
  stat v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    v2 = open(result, 0);
    if (v2 == -1)
      return 0;
    v3 = v2;
    stat(v1, &v16);
    st_size = v16.st_size;
    if (v16.st_size <= 3uLL)
    {
      close(v3);
      return 0;
    }
    v5 = (unsigned int *)mmap(0, v16.st_size, 1, 1, v3, 0);
    close(v3);
    if (v5 == (unsigned int *)-1)
      return 0;
    if (*v5 > 0x1002A)
    {
      if ((st_size & 0xFFFFFFFFFFFFFFFCLL) == 4)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v7 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
        {
          LOWORD(v16.st_dev) = 0;
          _os_log_fault_impl(&dword_183ECA000, v7, OS_LOG_TYPE_FAULT, "Corrupted dafsa data", (uint8_t *)&v16, 2u);
        }
        result = (const char *)munmap(v5, st_size);
        if ((_DWORD)result)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v6 = CFNLog::logger;
          result = (const char *)os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
          if ((_DWORD)result)
            goto LABEL_51;
        }
      }
      else
      {
        v8 = v5[1];
        v9 = st_size - 8 - v8;
        if (st_size - 8 >= v8)
        {
          if (v9 > 3)
          {
            v12 = (unsigned int *)((char *)v5 + v8 + 8);
            v13 = *v12;
            if (v9 - 4 >= v13)
            {
              getDafsa(void)::dafsaToBeReturned = (uint64_t)(v5 + 2);
              getDafsa(void)::dafsaToBeReturned = v8;
              getDafsa(void)::dafsaToBeReturned = (uint64_t)(v12 + 1);
              getDafsa(void)::dafsaToBeReturned = v13;
              return (const char *)1;
            }
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v14 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
            {
              LOWORD(v16.st_dev) = 0;
              _os_log_fault_impl(&dword_183ECA000, v14, OS_LOG_TYPE_FAULT, "Corrupted dafsa data", (uint8_t *)&v16, 2u);
            }
            result = (const char *)munmap(v5, st_size);
            if ((_DWORD)result)
            {
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v6 = CFNLog::logger;
              result = (const char *)os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
              if ((_DWORD)result)
                goto LABEL_51;
            }
          }
          else
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v11 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
            {
              LOWORD(v16.st_dev) = 0;
              _os_log_fault_impl(&dword_183ECA000, v11, OS_LOG_TYPE_FAULT, "Corrupted dafsa data", (uint8_t *)&v16, 2u);
            }
            result = (const char *)munmap(v5, st_size);
            if ((_DWORD)result)
            {
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v6 = CFNLog::logger;
              result = (const char *)os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
              if ((_DWORD)result)
                goto LABEL_51;
            }
          }
        }
        else
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v10 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
          {
            LOWORD(v16.st_dev) = 0;
            _os_log_fault_impl(&dword_183ECA000, v10, OS_LOG_TYPE_FAULT, "Corrupted dafsa data", (uint8_t *)&v16, 2u);
          }
          result = (const char *)munmap(v5, st_size);
          if ((_DWORD)result)
          {
            if (CFNLog::onceToken != -1)
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
            v6 = CFNLog::logger;
            result = (const char *)os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
            if ((_DWORD)result)
              goto LABEL_51;
          }
        }
      }
    }
    else
    {
      result = (const char *)munmap(v5, st_size);
      if ((_DWORD)result)
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v6 = CFNLog::logger;
        result = (const char *)os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
LABEL_51:
          v15 = *__error();
          v16.st_dev = 67109120;
          *(_DWORD *)&v16.st_mode = v15;
          _os_log_error_impl(&dword_183ECA000, v6, OS_LOG_TYPE_ERROR, "Failed to munmap TLD dafsa %{error}d", (uint8_t *)&v16, 8u);
          return 0;
        }
      }
    }
  }
  return result;
}

BOOL _CFHostIsDomainTopLevelForCertificatePolicy(const __CFString *a1)
{
  return isTopLevelDomain(a1, 0);
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke(_QWORD *a1, NSObject *a2)
{
  std::__shared_weak_count *v3;
  uint64_t v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint8_t buf[4];
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    v5 = a1[4];
    v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      v7 = v6;
      v8 = a1[5];
      if (v8)
      {
        if ((*(_WORD *)(v8 + 248) & 0x60) != 0 || (*(_DWORD *)(v8 + 136) - 5) <= 2)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v9 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v10 = *(_QWORD *)(v5 + 288);
            *(_DWORD *)buf = 134217984;
            v14 = v10;
            _os_log_impl(&dword_183ECA000, v9, OS_LOG_TYPE_DEFAULT, "Connection %llu: Ignoring sec configuration block - connection canceled", buf, 0xCu);
          }
        }
        else
        {
          NWIOConnection::_tlsConfigure(v8, a2);
        }
      }
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_183F9E738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void NWIOConnection::_tlsConfigure(uint64_t a1, sec_protocol_options_t options)
{
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  const __CFDictionary *Value;
  const void *v14;
  const void *v15;
  CFTypeID v16;
  NSObject *v17;
  const char *hostname;
  NSObject *v19;
  CFNumberRef v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  const __CFAllocator *v25;
  CFStringRef v26;
  uint64_t identifier;
  const __CFString *v28;
  CFTypeRef v29;
  _QWORD *v30;
  unint64_t *v31;
  unint64_t v32;
  CFDataRef ExternalRepresentation;
  const void *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  const __CFDictionary *v38;
  const __CFDictionary *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  BOOL v44;
  SSLCiphersuiteGroup **v46;
  SSLCiphersuiteGroup *v47;
  SSLCiphersuiteGroup *v48;
  SSLCiphersuiteGroup *v49;
  int v50;
  CFTypeID v51;
  SSLCiphersuiteGroup *v52;
  SSLCiphersuiteGroup *v53;
  SSLCiphersuiteGroup *v54;
  SSLCiphersuiteGroup *v55;
  SSLCiphersuiteGroup *v56;
  SSLCiphersuiteGroup *v57;
  SSLCiphersuiteGroup *v58;
  SSLCiphersuiteGroup *v59;
  const void **v60;
  const void *v61;
  const void *v62;
  CFTypeID v63;
  BOOL v64;
  const void *v65;
  const void *v66;
  CFTypeID v67;
  int v68;
  const void *v69;
  const void *v70;
  CFTypeID v71;
  unsigned int v72;
  const char *v73;
  const __CFString *v74;
  const __CFString *v75;
  const __CFString *v76;
  CFComparisonResult v77;
  unsigned int v78;
  const void *v79;
  const __CFAllocator *v80;
  const __CFString *v81;
  UInt8 *CString;
  const void *v83;
  const void *v84;
  CFTypeID v85;
  const void *v86;
  const void *v87;
  CFTypeID v88;
  BOOL v89;
  const void *v90;
  const void *v91;
  CFTypeID v92;
  const void *v93;
  CFTypeID v94;
  const void *v95;
  const void *v96;
  CFTypeID v97;
  const void *v98;
  CFTypeID v99;
  const void *v100;
  const __CFArray *v101;
  unint64_t *v102;
  unint64_t v103;
  unint64_t *v104;
  unint64_t v105;
  NSObject *v106;
  NSObject *v107;
  uint64_t v108;
  const __CFArray *Count;
  const void *v110;
  NSObject *v111;
  NSObject *v112;
  BOOL v113;
  const UInt8 *BytePtr;
  size_t Length;
  NSObject *v116;
  NSObject *v117;
  const UInt8 *v118;
  size_t v119;
  NSObject *v120;
  NSObject *v121;
  const __CFData *v122;
  const __CFData *v123;
  const UInt8 *v124;
  unint64_t v125;
  unint64_t v126;
  SSLCipherSuite v127;
  const __CFData *v128;
  const __CFData *v129;
  const UInt8 *v130;
  size_t v131;
  NSObject *v132;
  NSObject *v133;
  const __CFArray *v134;
  const __CFArray *v135;
  const __CFDictionary *v136;
  const __CFDictionary *v137;
  const void *v138;
  unint64_t v139;
  const __CFNumber *v140;
  const __CFNumber *v141;
  SSLProtocol v142;
  const __CFString *v143;
  int ExactString;
  SSLProtocol v145;
  SSLProtocol v146;
  SSLCiphersuiteGroup *v147;
  SSLCiphersuiteGroup *v148;
  SSLCiphersuiteGroup *v149;
  SSLCiphersuiteGroup *v150;
  SSLCiphersuiteGroup *v151;
  SSLCiphersuiteGroup *v152;
  NSObject *v153;
  uint64_t v154;
  BOOL v155;
  _QWORD challenge_block[5];
  std::__shared_weak_count *v157;
  _QWORD verify_block[6];
  std::__shared_weak_count *v159;
  _QWORD v160[5];
  sec_identity_t destructor[5];
  CFArrayRef v162[2];
  _BYTE valuePtr[24];
  _QWORD v164[131];

  v164[128] = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 256);
  v4 = *(std::__shared_weak_count **)(a1 + 264);
  if (v4)
  {
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v7 = __ldxr(p_shared_weak_owners);
    while (__stxr(v7 + 1, p_shared_weak_owners));
  }
  v8 = MEMORY[0x1E0C809B0];
  verify_block[0] = MEMORY[0x1E0C809B0];
  verify_block[1] = 3321888768;
  verify_block[2] = ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke;
  verify_block[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e81_v32__0__NSObject_OS_sec_protocol_metadata__8__NSObject_OS_sec_trust__16___v__B_24l;
  verify_block[4] = a1;
  verify_block[5] = v5;
  v159 = v4;
  if (v4)
  {
    v9 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  sec_protocol_options_set_verify_block(options, verify_block, *(dispatch_queue_t *)(a1 + 120));
  challenge_block[0] = v8;
  challenge_block[1] = 3321888768;
  challenge_block[2] = ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_136;
  challenge_block[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e81_v24__0__NSObject_OS_sec_protocol_metadata__8___v____NSObject_OS_sec_identity___16l;
  challenge_block[4] = v5;
  v157 = v4;
  if (v4)
  {
    v11 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  sec_protocol_options_set_challenge_block(options, challenge_block, *(dispatch_queue_t *)(a1 + 120));
  NWIOConnection::_tlsCreatePeerName((NWIOConnection *)a1);
  if (!*(_QWORD *)(a1 + 432))
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFC080);
    if (!Value)
      goto LABEL_17;
    v14 = CFDictionaryGetValue(Value, &unk_1EDCFB2B8);
    v15 = v14;
    if (!v14)
      goto LABEL_17;
    v16 = CFGetTypeID(v14);
    if (v16 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)valuePtr = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
    }
    if ((const void *)*MEMORY[0x1E0C9AE40] != v15)
    {
LABEL_17:
      v17 = *(NSObject **)(a1 + 304);
      if (v17)
      {
        if (nw_endpoint_get_type(v17) == nw_endpoint_type_host)
          hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 304));
        else
          hostname = 0;
        v19 = *(NSObject **)(a1 + 304);
        if (v19
          && (nw_endpoint_get_type(v19) == nw_endpoint_type_host
           || nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 304)) == nw_endpoint_type_address))
        {
          *(_WORD *)valuePtr = 0;
          *(_WORD *)valuePtr = nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 304));
          v20 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt16Type, valuePtr);
LABEL_27:
          NWIOConnection::_tlsCreatePeerName((NWIOConnection *)a1);
          v21 = *(_QWORD *)(a1 + 416);
          v22 = *(std::__shared_weak_count **)(a1 + 424);
          *(_QWORD *)valuePtr = v21;
          *(_QWORD *)&valuePtr[8] = v22;
          if (v22)
          {
            p_shared_owners = (unint64_t *)&v22->__shared_owners_;
            do
              v24 = __ldxr(p_shared_owners);
            while (__stxr(v24 + 1, p_shared_owners));
          }
          if (!v21)
          {
            v29 = CFRetain(CFSTR("nulldomain"));
            v30 = (_QWORD *)operator new();
            *v30 = &off_1E14F19E8;
            v30[1] = 0;
            v30[2] = 0;
            v30[3] = v29;
            *(_QWORD *)valuePtr = v29;
            *(_QWORD *)&valuePtr[8] = v30;
            if (v22)
            {
              v31 = (unint64_t *)&v22->__shared_owners_;
              do
                v32 = __ldaxr(v31);
              while (__stlxr(v32 - 1, v31));
              if (!v32)
              {
                ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
                std::__shared_weak_count::__release_weak(v22);
              }
            }
          }
          v25 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("{%s:%@}%@"), hostname, v20, *(_QWORD *)valuePtr);
          if (*(_QWORD *)(a1 + 176))
          {
            identifier = nw_context_get_identifier();
            v28 = CFStringCreateWithFormat(v25, 0, CFSTR("%s{%@}"), identifier, v26);
            if (v26)
              CFRelease(v26);
          }
          else
          {
            v28 = v26;
          }
          ExternalRepresentation = CFStringCreateExternalRepresentation(v25, v28, 0x8000100u, 0x2Eu);
          v34 = *(const void **)(a1 + 432);
          *(_QWORD *)(a1 + 432) = ExternalRepresentation;
          if (v34)
            CFRelease(v34);
          if (v28)
            CFRelease(v28);
          v35 = *(std::__shared_weak_count **)&valuePtr[8];
          if (*(_QWORD *)&valuePtr[8])
          {
            v36 = (unint64_t *)(*(_QWORD *)&valuePtr[8] + 8);
            do
              v37 = __ldaxr(v36);
            while (__stlxr(v37 - 1, v36));
            if (!v37)
            {
              ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
              std::__shared_weak_count::__release_weak(v35);
            }
          }
          if (v20)
            CFRelease(v20);
          goto LABEL_51;
        }
      }
      else
      {
        hostname = 0;
      }
      v20 = 0;
      goto LABEL_27;
    }
  }
LABEL_51:
  v38 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFC080);
  v39 = v38;
  if (!v38)
    goto LABEL_207;
  v40 = CFDictionaryGetValue(v38, &unk_1EDCFC550);
  v41 = CFDictionaryGetValue(v39, &unk_1EDCFB248);
  v42 = CFDictionaryGetValue(v39, &unk_1EDCFAF00);
  v43 = v42;
  v155 = v42 != 0;
  if (v40)
    v44 = 0;
  else
    v44 = v41 == 0;
  if (!v44 || v42 != 0)
  {
    v46 = (SSLCiphersuiteGroup **)operator new();
    *v46 = 0;
    if (!v40)
      goto LABEL_68;
    if (CFEqual(v40, (CFTypeRef)*MEMORY[0x1E0CD6888])
      || CFEqual(v40, (CFTypeRef)*MEMORY[0x1E0CD6870])
      || CFEqual(v40, (CFTypeRef)*MEMORY[0x1E0CD6848])
      || CFEqual(v40, (CFTypeRef)*MEMORY[0x1E0CD6860]))
    {
      v47 = *v46;
      v48 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
      *(_QWORD *)v48 = v47;
      *((_DWORD *)v48 + 2) = 1;
      *v46 = v48;
      v49 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
      v50 = 0;
      *(_QWORD *)v49 = v48;
    }
    else if (CFEqual(v40, (CFTypeRef)*MEMORY[0x1E0CD6878]) || CFEqual(v40, (CFTypeRef)*MEMORY[0x1E0CD6880]))
    {
      v147 = *v46;
      v148 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
      *(_QWORD *)v148 = v147;
      *((_DWORD *)v148 + 2) = 2;
      *v46 = v148;
      v149 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
      *(_QWORD *)v149 = v148;
      *((_DWORD *)v149 + 2) = 1;
      *v46 = v149;
      v49 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
      v50 = 0;
      *(_QWORD *)v49 = v149;
    }
    else if (CFEqual(v40, (CFTypeRef)*MEMORY[0x1E0CD6850]))
    {
      v150 = *v46;
      v49 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
      *(_QWORD *)v49 = v150;
      v50 = 3;
    }
    else
    {
      if (!CFEqual(v40, (CFTypeRef)*MEMORY[0x1E0CD6858]))
      {
LABEL_68:
        if (v41)
        {
          v51 = CFGetTypeID(v41);
          if (v51 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)valuePtr = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
          }
          v52 = *v46;
          if ((const void *)*MEMORY[0x1E0C9AE40] == v41)
          {
            if (v52)
            {
              do
              {
                v56 = *(SSLCiphersuiteGroup **)v52;
                operator delete(v52);
                v52 = v56;
              }
              while (v56);
            }
            *v46 = 0;
            v57 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
            *(_QWORD *)v57 = 0;
            *((_DWORD *)v57 + 2) = 2;
            *v46 = v57;
            v58 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
            *(_QWORD *)v58 = v57;
            *((_DWORD *)v58 + 2) = 1;
            *v46 = v58;
            v52 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
            *(_QWORD *)v52 = v58;
            *((_DWORD *)v52 + 2) = 0;
            *v46 = v52;
            if (v43)
              goto LABEL_74;
          }
          else if (v43)
          {
LABEL_74:
            if (v52)
            {
              do
              {
                v53 = *(SSLCiphersuiteGroup **)v52;
                operator delete(v52);
                v52 = v53;
              }
              while (v53);
            }
            *v46 = 0;
            if (ATSTLSCiphers::DefaultPFSCipherSuites(void)::cipherDataToken != -1)
              dispatch_once(&ATSTLSCiphers::DefaultPFSCipherSuites(void)::cipherDataToken, &__block_literal_global_40);
            if (CFEqual(v43, (CFTypeRef)ATSTLSCiphers::DefaultPFSCipherSuites(void)::cipherData))
            {
              v54 = *v46;
              v55 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
            }
            else
            {
              if (ATSTLSCiphers::DefaultNonPFSCipherSuites(void)::cipherDataToken != -1)
                dispatch_once(&ATSTLSCiphers::DefaultNonPFSCipherSuites(void)::cipherDataToken, &__block_literal_global_39_9077);
              if (!CFEqual(v43, (CFTypeRef)ATSTLSCiphers::DefaultNonPFSCipherSuites(void)::cipherData))
              {
                if (CFNLog::onceToken != -1)
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
                v153 = CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                {
                  v154 = *(_QWORD *)(a1 + 288);
                  *(_DWORD *)valuePtr = 134217984;
                  *(_QWORD *)&valuePtr[4] = v154;
                  _os_log_error_impl(&dword_183ECA000, v153, OS_LOG_TYPE_ERROR, "Connection %llu: unknown cipher set specified by ATS", valuePtr, 0xCu);
                }
                abort();
              }
              v59 = *v46;
              v54 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
              *(_QWORD *)v54 = v59;
              *((_DWORD *)v54 + 2) = 4;
              *v46 = v54;
              v55 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
            }
            v52 = v55;
            *(_QWORD *)v55 = v54;
            *((_DWORD *)v55 + 2) = 3;
            *v46 = v55;
            goto LABEL_92;
          }
        }
        else
        {
          v52 = *v46;
          if (v43)
            goto LABEL_74;
        }
        if (!v52)
        {
LABEL_93:
          std::default_delete<std::forward_list<SSLCiphersuiteGroup>>::operator()[abi:nn180100]((_QWORD **)v46);
          goto LABEL_94;
        }
        do
        {
LABEL_92:
          sec_protocol_options_add_tls_ciphersuite_group(options, v52[2]);
          v52 = *(SSLCiphersuiteGroup **)v52;
        }
        while (v52);
        goto LABEL_93;
      }
      v151 = *v46;
      v152 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
      *(_QWORD *)v152 = v151;
      *((_DWORD *)v152 + 2) = 4;
      *v46 = v152;
      v49 = (SSLCiphersuiteGroup *)operator new(0x10uLL);
      *(_QWORD *)v49 = v152;
      v50 = 3;
    }
    *((_DWORD *)v49 + 2) = v50;
    *v46 = v49;
    goto LABEL_68;
  }
  v155 = 0;
LABEL_94:
  v60 = (const void **)MEMORY[0x1E0C9AE50];
  v61 = CFDictionaryGetValue(v39, &unk_1EDCFB280);
  v62 = v61;
  if (!v61)
    goto LABEL_99;
  v63 = CFGetTypeID(v61);
  if (v63 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)valuePtr = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
  }
  if (*v60 == v62)
    v64 = 1;
  else
LABEL_99:
    v64 = 0;
  sec_protocol_options_set_tls_is_fallback_attempt(options, v64);
  v65 = CFDictionaryGetValue(v39, &unk_1EDCFB328);
  v66 = v65;
  if (!v65)
    goto LABEL_105;
  v67 = CFGetTypeID(v65);
  if (v67 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)valuePtr = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
  }
  if (*v60 == v66)
  {
    *(_WORD *)(a1 + 248) |= 0x2000u;
  }
  else
  {
LABEL_105:
    v68 = *(_WORD *)(a1 + 248) & 0xDFFF | (*(unsigned __int8 *)(a1 + 250) << 16);
    *(_WORD *)(a1 + 248) &= ~0x2000u;
    *(_BYTE *)(a1 + 250) = BYTE2(v68);
  }
  v69 = CFDictionaryGetValue(v39, &unk_1EDCFB360);
  v70 = v69;
  if (!v69)
    goto LABEL_111;
  v71 = CFGetTypeID(v69);
  if (v71 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)valuePtr = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
  }
  if (*v60 == v70)
  {
    v72 = *(unsigned __int16 *)(a1 + 248) | (*(unsigned __int8 *)(a1 + 250) << 16) | 0x6000;
    *(_WORD *)(a1 + 248) |= 0x6000u;
  }
  else
  {
LABEL_111:
    v72 = *(_WORD *)(a1 + 248) & 0xBFFF | (*(unsigned __int8 *)(a1 + 250) << 16);
    *(_WORD *)(a1 + 248) &= ~0x4000u;
    *(_BYTE *)(a1 + 250) = BYTE2(v72);
  }
  if ((v72 & 0x6000) != 0x2000)
    goto LABEL_124;
  NWIOConnection::_copyNetworkSignature((uint64_t)valuePtr, a1);
  v74 = *(const __CFString **)valuePtr;
  if (*(_QWORD *)valuePtr)
  {
    v75 = CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore(*(CFNA **)valuePtr, (const __CFString *)"TLSFalseStart", v73);
    v76 = v75;
    if (v75)
    {
      v77 = CFStringCompare(v75, CFSTR("TRUE"), 0);
      CFRelease(v76);
      CFRelease(v74);
      v72 = *(unsigned __int16 *)(a1 + 248) | (*(unsigned __int8 *)(a1 + 250) << 16);
      if (v77 == kCFCompareEqualTo)
      {
        v78 = HIWORD(v72);
        v72 |= 0x4000u;
        *(_BYTE *)(a1 + 250) = v78;
        *(_WORD *)(a1 + 248) = v72;
      }
      goto LABEL_124;
    }
    if (CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once != -1)
      dispatch_once(&CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once, &__block_literal_global_9684);
    CFNA::CFNetworkAgentClient::executeLegacyQuery((CFNA::CFNetworkAgentClient *)CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client, v74, 2);
    CFRelease(v74);
  }
  v72 = *(unsigned __int16 *)(a1 + 248) | (*(unsigned __int8 *)(a1 + 250) << 16);
LABEL_124:
  sec_protocol_options_set_tls_false_start_enabled(options, (~v72 & 0x6000) == 0);
  NWIOConnection::_tlsCreatePeerName((NWIOConnection *)a1);
  v79 = *(const void **)(a1 + 416);
  if (v79)
  {
    if (CFEqual(v79, (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
    {
      sec_protocol_options_set_tls_sni_disabled();
    }
    else
    {
      v80 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v81 = *(const __CFString **)(a1 + 416);
      *(_QWORD *)valuePtr = *MEMORY[0x1E0C9AE00];
      *(_QWORD *)&valuePtr[8] = 1023;
      if (v81)
      {
        CString = _CFStringGetOrCreateCString(v80, v81, (UInt8 *)v164, (uint64_t *)&valuePtr[8], 0x8000100u);
      }
      else
      {
        LOBYTE(v164[0]) = 0;
        *(_QWORD *)&valuePtr[8] = 0;
        CString = (UInt8 *)v164;
      }
      *(_QWORD *)&valuePtr[16] = CString;
      sec_protocol_options_set_tls_server_name(options, (const char *)CString);
      if (*(_QWORD *)&valuePtr[16] && v164 != *(_QWORD **)&valuePtr[16])
        CFAllocatorDeallocate(*(CFAllocatorRef *)valuePtr, *(void **)&valuePtr[16]);
    }
  }
  v83 = CFDictionaryGetValue(v39, &unk_1EDCFB2B8);
  v84 = v83;
  if (v83)
  {
    v85 = CFGetTypeID(v83);
    if (v85 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)valuePtr = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
    }
    if ((const void *)*MEMORY[0x1E0C9AE40] == v84)
      goto LABEL_144;
  }
  v86 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCF9ED0);
  v87 = v86;
  if (!v86)
    goto LABEL_143;
  v88 = CFGetTypeID(v86);
  if (v88 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)valuePtr = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
  }
  if ((const void *)*MEMORY[0x1E0C9AE40] == v87)
LABEL_144:
    v89 = 0;
  else
LABEL_143:
    v89 = 1;
  sec_protocol_options_set_tls_resumption_enabled(options, v89);
  v90 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCF9F08);
  v91 = v90;
  if (v90)
  {
    v92 = CFGetTypeID(v90);
    if (v92 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)valuePtr = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
    }
    v93 = *v60;
    if (*v60 == v91)
      goto LABEL_154;
    v94 = CFGetTypeID(v91);
    if (v94 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)valuePtr = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
    }
    if ((const void *)*MEMORY[0x1E0C9AE40] == v91)
LABEL_154:
      sec_protocol_options_set_tls_tickets_enabled(options, v93 == v91);
  }
  v95 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCF9F78);
  v96 = v95;
  if (v95)
  {
    v97 = CFGetTypeID(v95);
    if (v97 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)valuePtr = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
    }
    v98 = *v60;
    if (*v60 == v96)
      goto LABEL_164;
    v99 = CFGetTypeID(v96);
    if (v99 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)valuePtr = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
    }
    if ((const void *)*MEMORY[0x1E0C9AE40] == v96)
LABEL_164:
      sec_protocol_options_set_enable_encrypted_client_hello(options, v98 == v96);
  }
  v100 = CFDictionaryGetValue(v39, &unk_1EDCFC3C8);
  if (v100)
  {
    *(_QWORD *)valuePtr = CFRetain(v100);
    std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>((_QWORD *)(a1 + 512), (uint64_t *)valuePtr);
    if (*(_QWORD *)valuePtr)
      CFRelease(*(CFTypeRef *)valuePtr);
  }
  if (*(_QWORD *)(a1 + 512))
  {
    v101 = *(const __CFArray **)(a1 + 520);
    v162[0] = *(CFArrayRef *)(a1 + 512);
    v162[1] = v101;
    if (v101)
    {
      v102 = (unint64_t *)((char *)v101 + 8);
      do
        v103 = __ldxr(v102);
      while (__stxr(v103 + 1, v102));
    }
    NWIOConnection::_tlsCreateIdentityFromClientCertificates(destructor, v162);
    if (v101)
    {
      v104 = (unint64_t *)((char *)v101 + 8);
      do
        v105 = __ldaxr(v104);
      while (__stlxr(v105 - 1, v104));
      if (!v105)
      {
        (*(void (**)(const __CFArray *))(*(_QWORD *)v101 + 16))(v101);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v101);
      }
    }
    v106 = destructor[0];
    if (destructor[0])
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v107 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v108 = *(_QWORD *)(a1 + 288);
        Count = *(const __CFArray **)(a1 + 512);
        if (Count)
          Count = (const __CFArray *)CFArrayGetCount(Count);
        *(_DWORD *)valuePtr = 134218240;
        *(_QWORD *)&valuePtr[4] = v108;
        *(_WORD *)&valuePtr[12] = 2048;
        *(_QWORD *)&valuePtr[14] = Count;
        _os_log_impl(&dword_183ECA000, v107, OS_LOG_TYPE_DEFAULT, "Connection %llu: providing TLS Client Identity (%ld elements)", valuePtr, 0x16u);
      }
      sec_protocol_options_set_local_identity(options, v106);
      if (*(int *)(a1 + 528) <= 1)
        *(_DWORD *)(a1 + 528) = 2;
      sec_release(v106);
    }
  }
  v110 = CFDictionaryGetValue(v39, &unk_1EDCFC518);
  v111 = CFDictionaryGetValue(v39, &unk_1EDCFC4E0);
  v112 = v111;
  if (v110)
    v113 = v111 == 0;
  else
    v113 = 1;
  if (!v113)
  {
    CFRetain(v110);
    BytePtr = CFDataGetBytePtr((CFDataRef)v110);
    Length = CFDataGetLength((CFDataRef)v110);
    v116 = *(NSObject **)(a1 + 120);
    *(_QWORD *)valuePtr = MEMORY[0x1E0C809B0];
    *(_QWORD *)&valuePtr[8] = 3221225472;
    *(_QWORD *)&valuePtr[16] = ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke;
    v164[0] = &__block_descriptor_40_e5_v8__0l;
    v164[1] = v110;
    v117 = dispatch_data_create(BytePtr, Length, v116, valuePtr);
    CFRetain(v112);
    v118 = CFDataGetBytePtr((CFDataRef)v112);
    v119 = CFDataGetLength((CFDataRef)v112);
    v120 = *(NSObject **)(a1 + 120);
    destructor[0] = (sec_identity_t)MEMORY[0x1E0C809B0];
    destructor[1] = (sec_identity_t)3221225472;
    destructor[2] = (sec_identity_t)___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_2;
    destructor[3] = (sec_identity_t)&__block_descriptor_40_e5_v8__0l;
    destructor[4] = v112;
    v121 = dispatch_data_create(v118, v119, v120, destructor);
    sec_protocol_options_add_pre_shared_key(options, v117, v121);
    *(_WORD *)(a1 + 248) |= 0x400u;
    if (v121)
      dispatch_release(v121);
    if (v117)
      dispatch_release(v117);
  }
  if (!v155)
  {
    v122 = (const __CFData *)CFDictionaryGetValue(v39, &unk_1EDCFC400);
    v123 = v122;
    if (v122)
    {
      v124 = CFDataGetBytePtr(v122);
      v125 = CFDataGetLength(v123);
      if (v125 >= 2)
      {
        v126 = v125 >> 1;
        do
        {
          v127 = *(_WORD *)v124;
          v124 += 2;
          sec_protocol_options_add_tls_ciphersuite(options, v127);
          --v126;
        }
        while (v126);
      }
    }
  }
  v128 = (const __CFData *)CFDictionaryGetValue(v39, &unk_1EDCFC0B8);
  v129 = v128;
  if (v128)
  {
    CFRetain(v128);
    v130 = CFDataGetBytePtr(v129);
    v131 = CFDataGetLength(v129);
    v132 = *(NSObject **)(a1 + 120);
    v160[0] = MEMORY[0x1E0C809B0];
    v160[1] = 3221225472;
    v160[2] = ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_3;
    v160[3] = &__block_descriptor_40_e5_v8__0l;
    v160[4] = v129;
    v133 = dispatch_data_create(v130, v131, v132, v160);
    sec_protocol_options_set_tls_diffie_hellman_parameters(options, v133);
    if (v133)
      dispatch_release(v133);
  }
  v134 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFA6E8);
  if (v134)
    addTransportSpecificALPN((int)options, v134);
  v135 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCF9D80);
  if (v135)
    addTransportSpecificALPN((int)options, v135);
LABEL_207:
  v136 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EDCFC080);
  v137 = v136;
  if (!v136)
    goto LABEL_242;
  v138 = CFDictionaryGetValue(v136, &unk_1EDCFC550);
  v139 = (unint64_t)v138;
  if (v138
    && (CFEqual(v138, (CFTypeRef)*MEMORY[0x1E0CD6870])
     || CFEqual((CFTypeRef)v139, (CFTypeRef)*MEMORY[0x1E0CD6860])
     || CFEqual((CFTypeRef)v139, (CFTypeRef)*MEMORY[0x1E0CD6868])))
  {
    sec_protocol_options_set_tls_max_version(options, kTLSProtocol1);
  }
  v140 = (const __CFNumber *)CFDictionaryGetValue(v137, &unk_1EDCFB3D0);
  v141 = (const __CFNumber *)CFDictionaryGetValue(v137, &unk_1EDCFB398);
  if ((unint64_t)v140 | (unint64_t)v141)
  {
    if (v140)
    {
      *(_QWORD *)valuePtr = 0;
      CFNumberGetValue(v140, kCFNumberCFIndexType, valuePtr);
      if (*(int *)valuePtr < 5)
      {
        v142 = kTLSProtocol1;
      }
      else
      {
        *(_QWORD *)valuePtr = 0;
        CFNumberGetValue(v140, kCFNumberCFIndexType, valuePtr);
        v142 = *(_DWORD *)valuePtr;
      }
      sec_protocol_options_set_tls_min_version(options, v142);
    }
    if (!v141)
      goto LABEL_242;
    *(_QWORD *)valuePtr = 0;
    CFNumberGetValue(v141, kCFNumberCFIndexType, valuePtr);
    v146 = *(_DWORD *)valuePtr;
    if (!*(_DWORD *)valuePtr)
      goto LABEL_242;
LABEL_241:
    sec_protocol_options_set_tls_max_version(options, v146);
    goto LABEL_242;
  }
  v143 = (const __CFString *)CFDictionaryGetValue(v137, &unk_1EDCFC470);
  if (!(v139 | (unint64_t)v143))
    v143 = (const __CFString *)&unk_1EDCFC1D0;
  if (v143)
  {
    ExactString = _findExactString(v143, 2u);
    v145 = kTLSProtocol1;
    v146 = kTLSProtocol12;
    if (ExactString <= 240455928)
    {
      if (ExactString <= 237252804)
      {
        if (ExactString != 236204212)
        {
          if (ExactString == 235147427)
            abort();
          goto LABEL_240;
        }
      }
      else if (ExactString != 237252805 && ExactString != 239366375)
      {
        goto LABEL_240;
      }
      goto LABEL_239;
    }
    switch(ExactString)
    {
      case 240455929:
        v146 = kTLSProtocol1;
        break;
      case 241463566:
        v145 = kTLSProtocol11;
        goto LABEL_239;
      case 242512160:
        v145 = kTLSProtocol12;
LABEL_239:
        v146 = v145;
        break;
    }
LABEL_240:
    sec_protocol_options_set_tls_min_version(options, v145);
    goto LABEL_241;
  }
LABEL_242:
  if (v157)
    std::__shared_weak_count::__release_weak(v157);
  if (v159)
    std::__shared_weak_count::__release_weak(v159);
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
}

void sub_183F9FDEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,CFAllocatorRef allocator,uint64_t a40,void *ptr)
{
  std::__shared_weak_count *v41;
  _QWORD **v42;

  std::default_delete<std::forward_list<SSLCiphersuiteGroup>>::operator()[abi:nn180100](v42);
  if (a19)
    std::__shared_weak_count::__release_weak(a19);
  if (a26)
    std::__shared_weak_count::__release_weak(a26);
  if (v41)
    std::__shared_weak_count::__release_weak(v41);
  _Unwind_Resume(a1);
}

void NWIOConnection::_tlsCreatePeerName(NWIOConnection *this)
{
  _QWORD *v2;
  const __CFDictionary *Value;
  const void *v4;
  CFTypeRef v5;
  _QWORD *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  const void *v10;
  CFTypeRef v11;
  _QWORD *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  NSObject *v16;
  const __CFAllocator *v17;
  const char *hostname;
  CFStringRef v19;
  _QWORD *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  __int128 v24;

  if (!*((_QWORD *)this + 52))
  {
    v2 = (_QWORD *)((char *)this + 416);
    Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFC080);
    v4 = CFDictionaryGetValue(Value, &unk_1EDCFC4A8);
    if (v4)
      v5 = CFRetain(v4);
    else
      v5 = 0;
    *(_QWORD *)&v24 = v5;
    v6 = (_QWORD *)operator new();
    *v6 = &off_1E14F19E8;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = v5;
    *((_QWORD *)&v24 + 1) = v6;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v24);
    v7 = (std::__shared_weak_count *)*((_QWORD *)&v24 + 1);
    if (*((_QWORD *)&v24 + 1))
    {
      v8 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    if (!*v2)
    {
      v10 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_1EDCFA9C0);
      if (v10)
        v11 = CFRetain(v10);
      else
        v11 = 0;
      *(_QWORD *)&v24 = v11;
      v12 = (_QWORD *)operator new();
      *v12 = &off_1E14F19E8;
      v12[1] = 0;
      v12[2] = 0;
      v12[3] = v11;
      *((_QWORD *)&v24 + 1) = v12;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v24);
      v13 = (std::__shared_weak_count *)*((_QWORD *)&v24 + 1);
      if (*((_QWORD *)&v24 + 1))
      {
        v14 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
      if (!*v2)
      {
        v16 = *((_QWORD *)this + 38);
        if (v16)
        {
          if (nw_endpoint_get_type(v16) == nw_endpoint_type_host)
          {
            v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            hostname = nw_endpoint_get_hostname(*((nw_endpoint_t *)this + 38));
            v19 = CFStringCreateWithCString(v17, hostname, 0x8000100u);
            *(_QWORD *)&v24 = v19;
            v20 = (_QWORD *)operator new();
            *v20 = &off_1E14F19E8;
            v20[1] = 0;
            v20[2] = 0;
            v20[3] = v19;
            *((_QWORD *)&v24 + 1) = v20;
            std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v24);
            v21 = (std::__shared_weak_count *)*((_QWORD *)&v24 + 1);
            if (*((_QWORD *)&v24 + 1))
            {
              v22 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
              do
                v23 = __ldaxr(v22);
              while (__stlxr(v23 - 1, v22));
              if (!v23)
              {
                ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
                std::__shared_weak_count::__release_weak(v21);
              }
            }
          }
        }
      }
    }
  }
}

CFIndex addTransportSpecificALPN(int a1, CFArrayRef theArray)
{
  CFIndex i;
  CFIndex result;

  for (i = 0; ; ++i)
  {
    result = CFArrayGetCount(theArray);
    if (i >= result)
      break;
    objc_msgSend((id)CFArrayGetValueAtIndex(theArray, i), "UTF8String");
    sec_protocol_options_add_transport_specific_application_protocol();
  }
  return result;
}

BOOL _CFHostIsDomainTopLevel(const __CFString *a1)
{
  return isTopLevelDomain(a1, 1);
}

BOOL isTopLevelDomain(const __CFString *a1, int a2)
{
  __CFString *IDNAEncodedDomain;
  const char *v4;
  size_t v5;
  uint64_t v6;
  _BOOL8 v7;

  if (!a1)
    return 0;
  IDNAEncodedDomain = (__CFString *)createIDNAEncodedDomain(a1);
  v4 = (const char *)-[__CFString UTF8String](IDNAEncodedDomain, "UTF8String");
  v5 = strlen(v4);
  if (!v4)
  {
    v7 = 0;
    if (!IDNAEncodedDomain)
      return v7;
    goto LABEL_14;
  }
  if (v5 && (*v4 != 46 || (++v4, --v5, v5)))
  {
    if (v4[v5 - 1] == 46)
      v6 = v5 - 1;
    else
      v6 = v5;
  }
  else
  {
    v6 = 0;
  }
  v7 = _CFHostGetTopLevelDomain((unint64_t)v4, v6, a2) == v4;
  if (IDNAEncodedDomain)
LABEL_14:
    CFRelease(IDNAEncodedDomain);
  return v7;
}

void sub_183FA0300(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

CFStringRef createIDNAEncodedDomain(const __CFString *a1)
{
  CFIndex Length;
  uint64_t v4;
  uint64_t v5;
  UniChar *v6;
  uint64_t v7;
  char v8;
  char v9;
  int v10;
  const __CFAllocator *v11;
  const UniChar *v12;
  CFIndex v13;
  int32_t v14;
  __int128 v15;
  int v16;
  UChar v17[256];
  uint64_t v18;
  CFRange v19;

  v18 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  if (Length >= 257)
    return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1);
  v4 = Length;
  MEMORY[0x1E0C80A78]();
  v6 = (UniChar *)((char *)&v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  v19.location = 0;
  v19.length = v4;
  CFStringGetCharacters(a1, v19, v6);
  if (v4 < 1)
    goto LABEL_11;
  v7 = 0;
  v8 = 0;
  v9 = 1;
  do
  {
    v10 = v6[v7];
    if ((v10 - 65) <= 0x19)
    {
      v10 += 32;
      v6[v7] = v10;
      v8 = 1;
    }
    v9 &= (v10 - 32) < 0x60;
    ++v7;
  }
  while (v4 != v7);
  if ((v9 & 1) == 0)
  {
    if (createIDNAEncodedDomain(__CFString const*)::onceToken != -1)
      dispatch_once(&createIDNAEncodedDomain(__CFString const*)::onceToken, &__block_literal_global_1798);
    v16 = 0;
    v15 = xmmword_1841E3A60;
    v14 = uidna_nameToASCII((const UIDNA *)createIDNAEncodedDomain(__CFString const*)::idna, v6, v4, v17, 256, (UIDNAInfo *)&v15, (UErrorCode *)&v16);
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v16 <= 0 && DWORD1(v15) < 0x40)
    {
      v13 = v14;
      v12 = v17;
      return CFStringCreateWithCharacters(v11, v12, v13);
    }
    return CFStringCreateCopy(v11, a1);
  }
  if ((v8 & 1) == 0)
  {
LABEL_11:
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    return CFStringCreateCopy(v11, a1);
  }
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v12 = v6;
  v13 = v4;
  return CFStringCreateWithCharacters(v11, v12, v13);
}

void __CFCachedURLResponse::~__CFCachedURLResponse(__CFCachedURLResponse *this)
{
  __CFCachedURLResponse::~__CFCachedURLResponse(this);
  JUMPOUT(0x186DB748CLL);
}

{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  NSObject *v8;
  const void *v9;
  const void *v10;

  *(_QWORD *)this = &off_1E14EC248;
  v2 = (const void *)*((_QWORD *)this + 9);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 9) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 10);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 10) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 6);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 6) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 4);
  if (v5)
  {
    CFRelease(v5);
    *((_QWORD *)this + 4) = 0;
  }
  v6 = (const void *)*((_QWORD *)this + 5);
  if (v6)
  {
    CFRelease(v6);
    *((_QWORD *)this + 5) = 0;
  }
  v7 = (const void *)*((_QWORD *)this + 14);
  if (v7)
  {
    CFRelease(v7);
    *((_QWORD *)this + 14) = 0;
  }
  if (*((_QWORD *)this + 13))
    *((_QWORD *)this + 13) = 0;
  v8 = *((_QWORD *)this + 1);
  if (v8)
  {
    dispatch_release(v8);
    *((_QWORD *)this + 1) = 0;
  }
  v9 = (const void *)*((_QWORD *)this + 2);
  if (v9)
  {
    _Block_release(v9);
    *((_QWORD *)this + 2) = 0;
  }
  v10 = (const void *)*((_QWORD *)this + 16);
  if (v10)
    CFRelease(v10);
}

uint64_t ___ZN14HTTPConnection10initializeEP22HTTPConnectionCacheKeyP4TubeNSt3__18weak_ptrINS_20HTTPActivityDelegateEEE_block_invoke_2(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  HTTPEngine::initialize(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 64), *(_DWORD *)(a1 + 56));
  return HTTPEngine::setProperty(*(HTTPEngine **)(v1 + 64), (CFStringRef)&unk_1EDCFE3B8, (const void *)*MEMORY[0x1E0C9AE50]);
}

void HTTPEngine::initialize(uint64_t a1, int a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  _OWORD *Instance;
  HTTPMessage *v12;
  _QWORD *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_weak_owners;
  unint64_t v26;
  _QWORD *v27;
  NSObject *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  NSObject *v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  _QWORD aBlock[6];
  std::__shared_weak_count *v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v48, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v48 + 1);
  v4 = v48;
  if (*((_QWORD *)&v48 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v48 + 1) + 16);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = *(std::__shared_weak_count **)(a1 + 48);
  *(_QWORD *)(a1 + 40) = v4;
  *(_QWORD *)(a1 + 48) = v5;
  if (v8)
  {
    std::__shared_weak_count::__release_weak(v8);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v48 + 1);
  }
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v12 = (HTTPMessage *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v12 = (HTTPMessage *)(Instance + 1);
    Instance[18] = 0u;
    Instance[19] = 0u;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  HTTPMessage::HTTPMessage(v12, "httpresponse");
  *(_QWORD *)v12 = &off_1E14E9F38;
  *((_QWORD *)v12 + 1) = &unk_1E14E9FA8;
  *((_QWORD *)v12 + 2) = &unk_1E14E9FC8;
  *((_DWORD *)v12 + 32) = -1;
  *((_QWORD *)v12 + 17) = 0;
  *((_OWORD *)v12 + 10) = 0u;
  *((_OWORD *)v12 + 11) = 0u;
  *((_OWORD *)v12 + 12) = 0u;
  *((_OWORD *)v12 + 13) = 0u;
  *((_OWORD *)v12 + 14) = 0u;
  *((_OWORD *)v12 + 15) = 0u;
  *((_OWORD *)v12 + 16) = 0u;
  *((_OWORD *)v12 + 17) = 0u;
  *((_BYTE *)v12 + 296) = 0;
  *(_QWORD *)&v48 = v12;
  v13 = (_QWORD *)operator new();
  *v13 = &off_1E14F1710;
  v13[1] = 0;
  v13[2] = 0;
  v13[3] = v12;
  *((_QWORD *)&v48 + 1) = v13;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 128, &v48);
  v14 = (std::__shared_weak_count *)*((_QWORD *)&v48 + 1);
  if (*((_QWORD *)&v48 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v48 + 1) + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  *(_QWORD *)(a1 + 176) = -2;
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v47, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
  v48 = v47;
  v17 = *(_QWORD *)(a1 + 56);
  v46 = v47;
  if (*((_QWORD *)&v47 + 1))
  {
    v18 = (unint64_t *)(*((_QWORD *)&v47 + 1) + 8);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v17 + 184))(v17, &v46);
  v20 = (std::__shared_weak_count *)*((_QWORD *)&v46 + 1);
  if (*((_QWORD *)&v46 + 1))
  {
    v21 = (unint64_t *)(*((_QWORD *)&v46 + 1) + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  if (a2 == 2)
    *(_DWORD *)(a1 + 32) |= 4u;
  *(_DWORD *)(a1 + 344) = a2;
  v23 = *(_QWORD *)(a1 + 40);
  v24 = *(std::__shared_weak_count **)(a1 + 48);
  if (v24)
  {
    p_shared_weak_owners = (unint64_t *)&v24->__shared_weak_owners_;
    do
      v26 = __ldxr(p_shared_weak_owners);
    while (__stxr(v26 + 1, p_shared_weak_owners));
  }
  v27 = *(_QWORD **)(a1 + 112);
  v28 = *(NSObject **)(a1 + 72);
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN10HTTPEngine10initializeE21_CFHTTPConnectionType_block_invoke;
  aBlock[3] = &__block_descriptor_56_e8_40c35_ZTSNSt3__18weak_ptrI10HTTPEngineEE_e56_v24__0I8I12___v____NSObject_OS_dispatch_data__B___qi__16l;
  aBlock[4] = a1;
  aBlock[5] = v23;
  v45 = v24;
  if (v24)
  {
    v29 = (unint64_t *)&v24->__shared_weak_owners_;
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
  }
  v31 = (std::__shared_weak_count *)v27[2];
  if (v31 && (v32 = v27[1], (v33 = std::__shared_weak_count::lock(v31)) != 0))
  {
    v34 = v33;
    v35 = (unint64_t *)&v33->__shared_weak_owners_;
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
    v37 = (std::__shared_weak_count *)v27[4];
    v27[3] = v32;
    v27[4] = v34;
    if (v37)
      std::__shared_weak_count::__release_weak(v37);
    v38 = (unint64_t *)&v34->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
    dispatch_retain(v28);
    v40 = v27[5];
    v27[5] = v28;
    if (v40)
      dispatch_release(v40);
    v27[6] = _Block_copy(aBlock);
    if (v45)
      std::__shared_weak_count::__release_weak(v45);
    if (v24)
      std::__shared_weak_count::__release_weak(v24);
    v41 = (std::__shared_weak_count *)*((_QWORD *)&v48 + 1);
    if (*((_QWORD *)&v48 + 1))
    {
      v42 = (unint64_t *)(*((_QWORD *)&v48 + 1) + 8);
      do
        v43 = __ldaxr(v42);
      while (__stlxr(v43 - 1, v42));
      if (!v43)
      {
        ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
        std::__shared_weak_count::__release_weak(v41);
      }
    }
  }
  else
  {
    std::__throw_bad_weak_ptr[abi:nn180100]();
    __break(1u);
  }
}

void sub_183FA0BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, char a17)
{
  uint64_t v17;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v17 - 64);
  _Unwind_Resume(a1);
}

void HTTPMessage::HTTPMessage(HTTPMessage *this, const char *a2)
{
  *(_QWORD *)this = &off_1E14E50B0;
  *((_QWORD *)this + 1) = &unk_1E14E5120;
  *((_QWORD *)this + 2) = &unk_1E14E5140;
  *((_QWORD *)this + 4) = &off_1E14EBF58;
  *((_QWORD *)this + 5) = 0;
  HTTPMessage::commonInitialization((uint64_t)this, a2 == "httpresponse", 0);
}

void sub_183FA0C84(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  v1[4] = &off_1E14E9A00;
  v3 = (const void *)v1[5];
  if (v3)
    CFRelease(v3);
  v1[1] = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

void NWIOConnection::setConnectionDelegate(NWIOConnection *a1, uint64_t *a2)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7[2];

  v3 = (std::__shared_weak_count *)a2[1];
  v7[0] = *a2;
  v7[1] = (uint64_t)v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    TransportConnection::setConnectionDelegate((uint64_t)a1, v7);
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    TransportConnection::setConnectionDelegate((uint64_t)a1, v7);
  }
  if ((*((_WORD *)a1 + 124) & 2) != 0)
    NWIOConnection::_signalError(a1);
}

void std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::destroy(a1[1]);
    std::__tree<std::string>::destroy((char *)a1[7]);
    std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::shared_ptr<__CoalescingConnectionKey>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t __destroy_helper_block_e8_72c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 72);
}

uint64_t __copy_helper_block_e8_72c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(result + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(result + 80) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void URLResponse::~URLResponse(URLResponse *this)
{
  __CFURL *fURL;
  __CFString *fMIMEType;
  __CFString *fTextEncodingName;
  __CFDictionary *fDownloadAssessment;
  __CFDictionary *fSSLCertContext;
  __CFData *fPeerAddress;
  HTTPResponse *fHTTP;

  this->_vptr$CoreLoggable = (void **)&off_1E14E56A8;
  fURL = this->fURL;
  if (fURL)
    CFRelease(fURL);
  fMIMEType = this->fMIMEType;
  if (fMIMEType)
    CFRelease(fMIMEType);
  fTextEncodingName = this->fTextEncodingName;
  if (fTextEncodingName)
    CFRelease(fTextEncodingName);
  fDownloadAssessment = this->fDownloadAssessment;
  if (fDownloadAssessment)
    CFRelease(fDownloadAssessment);
  fSSLCertContext = this->fSSLCertContext;
  if (fSSLCertContext)
    CFRelease(fSSLCertContext);
  fPeerAddress = this->fPeerAddress;
  if (fPeerAddress)
    CFRelease(fPeerAddress);
  fHTTP = this->fHTTP;
  if (fHTTP)
    CFRelease((char *)fHTTP - 16);
  this->_vptr$CoreLoggable = (void **)&off_1E14E5838;
}

{
  URLResponse::~URLResponse(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183FA0F44(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14HTTPStallTimerEE48c27_ZTSNSt3__110shared_ptrIvEE(uint64_t a1)
{
  std::__shared_weak_count *v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

uint64_t ___Z27connectionTimingFromMetricsP23__CFN_ConnectionMetrics_block_invoke_3(uint64_t a1, void *a2, uint64_t a3)
{
  id v6;

  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), a2);
  v6 = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a3;

  return 1;
}

void ___ZL27ConnectionProtocolConnectedP11nw_protocolS0__block_invoke(uint64_t a1)
{
  (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 64) + 288))(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  nw_release(*(void **)(a1 + 32));
  nw_release(*(void **)(a1 + 40));
  nw_release(*(void **)(a1 + 48));
  nw_release(*(void **)(a1 + 56));
}

void NWIOConnection::handleEvent_Connected(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(a1 + 248) & 0x60) == 0 && (*(_DWORD *)(a1 + 136) - 5) >= 2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 320));
    if (!*(_QWORD *)(a1 + 312))
      *(_QWORD *)(a1 + 312) = a2;
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 320));
  }
}

uint64_t __destroy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t __copy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t coreSchedulingSetHash(const void *a1)
{
  return (*(uint64_t (**)(const void *))(*(_QWORD *)a1 + 32))(a1);
}

void ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_3(uint64_t a1, CFStringRef theString1, const void *a3)
{
  const __CFDictionary *Value;
  CFMutableDictionaryRef MutableCopy;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[5];
  std::__shared_weak_count *v18;
  CFMutableDictionaryRef v19;
  std::__shared_weak_count *v20;

  if (CFStringCompare(theString1, (CFStringRef)&unk_1EDCFBEC0, 1uLL) == kCFCompareEqualTo)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
LABEL_18:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), theString1, a3);
    return;
  }
  if (CFStringCompare(theString1, (CFStringRef)&unk_1EDCFC080, 1uLL))
    goto LABEL_18;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), &unk_1EDCFC080);
  if (!Value)
    goto LABEL_18;
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, Value);
  v19 = MutableCopy;
  v8 = (std::__shared_weak_count *)operator new();
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1588;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)MutableCopy;
  v20 = v8;
  v17[4] = MutableCopy;
  v18 = v8;
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3321888768;
  v17[2] = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_4;
  v17[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE_e25_v24__0____CFString__8_v16l;
  do
    v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  CFDictionaryApplyFunction((CFDictionaryRef)a3, (CFDictionaryApplierFunction)_apply_block, v17);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), theString1, MutableCopy);
  v11 = v18;
  if (v18)
  {
    v12 = (unint64_t *)&v18->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v20;
  if (v20)
  {
    v15 = (unint64_t *)&v20->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_183FA141C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14HTTPStallTimerEE48c27_ZTSNSt3__110shared_ptrIvEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t ___ZN4Tube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicyb_block_invoke(uint64_t a1)
{
  Tube *v1;

  v1 = *(Tube **)(a1 + 32);
  Tube::_onqueue_complete_needServerTrust(v1, *(unsigned int *)(a1 + 40), *(unsigned __int8 *)(a1 + 44));
  return (*(uint64_t (**)(Tube *))(*(_QWORD *)v1 + 48))(v1);
}

void Tube::_onqueue_complete_needServerTrust(Tube *this, uint64_t a2, uint64_t a3)
{
  void (**v6)(_QWORD, _QWORD, _QWORD);
  const void *v7;

  v6 = (void (**)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 39);
  *((_QWORD *)this + 39) = 0;
  v7 = (const void *)*((_QWORD *)this + 32);
  *((_QWORD *)this + 32) = 0;
  if (v7)
    CFRelease(v7);
  if (v6)
  {
    v6[2](v6, a2, a3);
    _Block_release(v6);
  }
  if ((_DWORD)a3)
    Tube::_onqueue_cancel(this);
}

void ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_2(uint64_t a1, int a2, char a3)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[4];
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  int v18;
  char v19;

  v4 = *(_QWORD *)(a1 + 48);
  v5 = *(_QWORD *)(a1 + 56);
  v6 = *(NSObject **)(v5 + 120);
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3321888768;
  v13[2] = ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_3;
  v13[3] = &unk_1E14F4550;
  v19 = a3;
  v14 = *(_OWORD *)(a1 + 32);
  v15 = v4;
  v16 = v5;
  v7 = *(std::__shared_weak_count **)(a1 + 64);
  v17 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v18 = a2;
  dispatch_async(v6, v13);
  v10 = v17;
  if (v17)
  {
    v11 = (unint64_t *)&v17->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

uint64_t ConnectionProtocolFinalizeOutputFrames(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  NSObject *v4;
  uint32_t v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v2 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      return 0;
    LOWORD(v7) = 0;
    v3 = "protocol is nullptr";
    v4 = v2;
    v5 = 2;
    goto LABEL_13;
  }
  if (*(_QWORD *)(a1 + 40))
    return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) + 96))();
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v7 = 136315138;
    v8 = "ConnectionProtocolFinalizeOutputFrames";
    v3 = "Connection is invalid in %s";
    v4 = v6;
    v5 = 12;
LABEL_13:
    _os_log_error_impl(&dword_183ECA000, v4, OS_LOG_TYPE_ERROR, v3, (uint8_t *)&v7, v5);
  }
  return 0;
}

uint64_t ConnectionProtocolGetOutputFrames(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  NSObject *v4;
  uint32_t v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v2 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      return 0;
    LOWORD(v7) = 0;
    v3 = "protocol is nullptr";
    v4 = v2;
    v5 = 2;
    goto LABEL_13;
  }
  if (*(_QWORD *)(a1 + 40))
    return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) + 88))();
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v7 = 136315138;
    v8 = "ConnectionProtocolGetOutputFrames";
    v3 = "Connection is invalid in %s";
    v4 = v6;
    v5 = 12;
LABEL_13:
    _os_log_error_impl(&dword_183ECA000, v4, OS_LOG_TYPE_ERROR, v3, (uint8_t *)&v7, v5);
  }
  return 0;
}

void ___ZN14NWIOConnection37_tlsCopyPeerCertificatesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke(uint64_t a1, sec_certificate_t certificate)
{
  SecCertificateRef v3;

  v3 = sec_certificate_copy_ref(certificate);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), v3);
  if (v3)
    CFRelease(v3);
}

void sub_183FA1BF0(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void ConnectionProtocolConnected(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  void *v13;
  _QWORD *v14;
  uint64_t (*v15)(uint64_t);
  void *v16;
  uint64_t (*v17)(uint64_t);
  void *v18;
  uint64_t (*v19)(uint64_t);
  void *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  NSObject *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  _QWORD block[9];
  std::__shared_weak_count *v34;
  _QWORD *v35;
  uint8_t buf[4];
  const char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = (_QWORD *)a1[5];
    if (v3)
    {
      v5 = a1[6];
      (*(void (**)(uint64_t))(*(_QWORD *)(v5 + 24) + 40))(v5);
      if (a1[4] == a2)
      {
        if (((*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)(a2 + 24) + 216))(a2, a1) & 1) != 0)
        {
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v6 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_debug_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEBUG, "Output handler is waiting for output (TFO), suppressing connected event", buf, 2u);
          }
        }
        else
        {
          v12 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a2 + 24) + 200);
          if (v12)
            v13 = (void *)v12(a2);
          else
            v13 = 0;
          v14 = *(_QWORD **)(v5 + 24);
          v15 = (uint64_t (*)(uint64_t))v14[17];
          if (v15)
          {
            v16 = (void *)v15(v5);
            v14 = *(_QWORD **)(v5 + 24);
          }
          else
          {
            v16 = 0;
          }
          v17 = (uint64_t (*)(uint64_t))v14[14];
          if (v17)
          {
            v18 = (void *)v17(v5);
            v14 = *(_QWORD **)(v5 + 24);
          }
          else
          {
            v18 = 0;
          }
          v19 = (uint64_t (*)(uint64_t))v14[15];
          if (v19)
            v20 = (void *)v19(v5);
          else
            v20 = 0;
          nw_retain(v13);
          nw_retain(v16);
          nw_retain(v18);
          nw_retain(v20);
          v21 = v3[8];
          v22 = (std::__shared_weak_count *)v3[9];
          if (v22)
          {
            p_shared_owners = (unint64_t *)&v22->__shared_owners_;
            do
              v24 = __ldxr(p_shared_owners);
            while (__stxr(v24 + 1, p_shared_owners));
          }
          v25 = v3[10];
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3321888768;
          block[2] = ___ZL27ConnectionProtocolConnectedP11nw_protocolS0__block_invoke;
          block[3] = &unk_1E14F4830;
          block[8] = v21;
          v34 = v22;
          if (v22)
          {
            v26 = (unint64_t *)&v22->__shared_owners_;
            do
              v27 = __ldxr(v26);
            while (__stxr(v27 + 1, v26));
          }
          v35 = a1;
          block[4] = v13;
          block[5] = v16;
          block[6] = v18;
          block[7] = v20;
          dispatch_async(v25, block);
          v28 = v34;
          if (v34)
          {
            v29 = (unint64_t *)&v34->__shared_owners_;
            do
              v30 = __ldaxr(v29);
            while (__stlxr(v30 - 1, v29));
            if (!v30)
            {
              ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
              std::__shared_weak_count::__release_weak(v28);
            }
          }
          if (v22)
          {
            v31 = (unint64_t *)&v22->__shared_owners_;
            do
              v32 = __ldaxr(v31);
            while (__stlxr(v32 - 1, v31));
            if (!v32)
            {
              ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
              std::__shared_weak_count::__release_weak(v22);
            }
          }
        }
        (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)(v5 + 24) + 40))(v5, a1);
      }
      return;
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v11 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      v37 = "ConnectionProtocolConnected";
      v8 = "Connection is invalid in %s";
      v9 = v11;
      v10 = 12;
      goto LABEL_17;
    }
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v8 = "protocol is nullptr";
      v9 = v7;
      v10 = 2;
LABEL_17:
      _os_log_error_impl(&dword_183ECA000, v9, OS_LOG_TYPE_ERROR, v8, buf, v10);
    }
  }
}

void ___ZN25URLConnectionInstanceData15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke(_QWORD *a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  _QWORD v4[5];
  _QWORD block[6];

  *(_WORD *)(a1[4] + 24) = 256;
  v1 = a1[5];
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN25URLConnectionInstanceData15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = a1[7];
  v2 = *(NSObject **)v1;
  v3 = *(_QWORD *)(v1 + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZNK23CoreSchedulingSetOneOff29performAsyncWithTrailingBlockEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FB138;
  block[4] = v3;
  block[5] = v4;
  dispatch_async(v2, block);
}

void ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke(uint64_t a1, sec_certificate_t certificate)
{
  SecCertificateRef v3;

  v3 = sec_certificate_copy_ref(certificate);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), v3);
  if (v3)
    CFRelease(v3);
}

void sub_183FA20BC(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN25URLConnectionInstanceData15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 72))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZN19URLConnectionLoader29ensureLoaderHasProtocolNoLockEP12NSURLRequest_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 32) + 72))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32));
}

uint64_t _CFCachedURLResponseDeallocate(_QWORD *a1)
{
  uint64_t result;

  result = a1[2];
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t __copy_helper_block_e8_56c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 64) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_56c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
}

uint64_t SocketStream::_SecurityReadFunc_NoLock(SocketStream *this, void *a2, size_t *a3, unint64_t *a4)
{
  char *v7;
  size_t v8;
  _QWORD *v9;
  size_t v10;
  uint64_t v11;
  size_t v12;
  const __CFAllocator *v13;
  CFAllocatorRef v14;
  uint64_t v15;
  unint64_t v16;
  SInt32 v17;
  __CFSocket *v18;
  uint64_t v19;
  size_t v20;
  CFAllocatorRef *v21;
  char *v22;
  size_t v23;
  size_t v24;
  __CFSocket *v25;
  unsigned int v26;
  unsigned __int128 v28;

  v7 = (char *)this - 16;
  CFRetain((char *)this - 16);
  v8 = *a3;
  v28 = 0uLL;
  v9 = (_QWORD *)*((_QWORD *)this + 65);
  if (v9)
  {
    v11 = v9[2];
    v10 = v9[3];
    v12 = v8;
  }
  else
  {
    v13 = CFGetAllocator(v7);
    v9 = CFAllocatorAllocate(v13, 32824, 0);
    bzero(v9, 0x8038uLL);
    v14 = CFGetAllocator(v7);
    v10 = 0;
    v9[4] = ((unint64_t)(v9 + 5) & 0xFFFFFFFFFFFFFFF0) + 16;
    *((_OWORD *)v9 + 1) = xmmword_1841E3900;
    *v9 = &off_1E14EB0B8;
    v9[1] = v14;
    *((_QWORD *)this + 65) = v9;
    v12 = *a3;
    v11 = 0x8000;
  }
  if (v10 >= v12)
  {
    *((_DWORD *)this + 62) |= 0x2000000u;
  }
  else
  {
    v15 = SocketStream::recvBytes(this, (unsigned __int8 *)(v9[4] + v10), v11 - v10, (CFStreamError *)&v28);
    v16 = *((_DWORD *)this + 62) & 0xFDFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) &= ~0x2000000u;
    *((_WORD *)this + 126) = WORD2(v16);
    v17 = DWORD2(v28);
    if (DWORD2(v28))
    {
      *a3 = 0;
      if (v17 == 35 && (_QWORD)v28 == 1)
      {
        v18 = (__CFSocket *)*((_QWORD *)this + 36);
        if (v18 && CFSocketIsValid(v18))
          CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
        v19 = 4294957493;
      }
      else
      {
        *((_OWORD *)this + 16) = v28;
        v19 = 4294957486;
      }
      goto LABEL_29;
    }
    v20 = v15;
    v21 = (CFAllocatorRef *)*((_QWORD *)this + 75);
    if (v21)
      SSLDecoder::processBytes(v21, v21 + 3, (UInt8 *)(*(_QWORD *)(*((_QWORD *)this + 65) + 32) + v10), v20, "READ");
    v10 += v20;
  }
  v22 = *(char **)(*((_QWORD *)this + 65) + 32);
  if (*a3 >= v10)
    v23 = v10;
  else
    v23 = *a3;
  *a3 = v23;
  v24 = v10 - v23;
  memmove(a2, v22, v23);
  memmove(v22, &v22[*a3], v24);
  bzero(&v22[v24], v11 - v24);
  *(_QWORD *)(*((_QWORD *)this + 65) + 24) = v24;
  if (*a3)
  {
    v25 = (__CFSocket *)*((_QWORD *)this + 36);
    if (v25)
    {
      if (CFSocketIsValid(v25))
        CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
    }
  }
  if (v8 == *a3)
    v26 = 0;
  else
    v26 = -9803;
  if (*a3)
    v19 = v26;
  else
    v19 = 4294957490;
LABEL_29:
  CFRelease(v7);
  return v19;
}

uint64_t SocketStream::recvBytes(SocketStream *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  __CFSocket *v6;

  a4->domain = 0;
  *(_QWORD *)&a4->error = 0;
  v6 = (__CFSocket *)*((_QWORD *)this + 36);
  if (v6 && CFSocketIsValid(v6))
    return SocketStream::socketRead(this, a2, a3, a4);
  a4->domain = 1;
  a4->error = 22;
  return -1;
}

uint64_t SocketStream::socketRead(SocketStream *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  uint64_t v7;
  double v8;
  IOLogger *v9;
  _BOOL4 v10;
  BOOL v11;

  v7 = __CFSocketRead();
  if (v7 < 0)
  {
    a4->domain = 1;
    a4->error = 0;
  }
  else
  {
    v9 = (IOLogger *)*((_QWORD *)this + 27);
    v10 = v7 != 0;
    if (v9)
      v11 = v7 == 0;
    else
      v11 = 1;
    if (!v11)
    {
      IOLogger::logBytes(v9, "RAW-READ", 0x3Cu, a2, v7);
      v10 = 1;
    }
    if (*((_BYTE *)this + 644) && v10)
      entr_act_modify_delayInitStub(v8);
  }
  return v7;
}

uint64_t SocketStream::_SecurityWriteFunc_NoLock(CFAllocatorRef **this, unsigned __int8 *a2, size_t *a3, unint64_t *a4)
{
  CFAllocatorRef **v7;
  size_t v8;
  uint64_t v9;
  SInt32 v10;
  uint64_t v12;
  size_t v13;
  CFAllocatorRef *v14;
  unsigned __int128 v16;

  v7 = this - 2;
  CFRetain(this - 2);
  v16 = 0uLL;
  v8 = *a3;
  v9 = SocketStream::sendToSocket((SocketStream *)this, a2, *a3, (CFStreamError *)&v16);
  *a3 = v9;
  v10 = DWORD2(v16);
  if (DWORD2(v16))
  {
    *a3 = 0;
    if (v10 == 35 && (_QWORD)v16 == 1)
    {
      v12 = 4294957493;
    }
    else
    {
      *((_OWORD *)this + 16) = v16;
      v12 = 4294957486;
    }
  }
  else
  {
    v13 = v9;
    v14 = this[75];
    if (v14)
    {
      SSLDecoder::processBytes(v14, v14 + 2, a2, v13, "SENT");
      v13 = *a3;
    }
    if (v8 == v13)
      v12 = 0;
    else
      v12 = 4294957493;
  }
  CFRelease(v7);
  return v12;
}

uint64_t SocketStream::sendToSocket(SocketStream *this, const unsigned __int8 *a2, size_t a3, CFStreamError *a4)
{
  __CFSocket *v5;
  CFSocketNativeHandle Native;
  ssize_t v10;
  double v11;
  uint64_t v12;
  IOLogger *v13;
  _BOOL4 v14;
  SInt32 v15;

  v5 = (__CFSocket *)*((_QWORD *)this + 36);
  a4->domain = 0;
  *(_QWORD *)&a4->error = 0;
  if (!v5 || !CFSocketIsValid(v5))
  {
    v15 = 22;
LABEL_12:
    a4->domain = 1;
    a4->error = v15;
    return -1;
  }
  Native = CFSocketGetNative(v5);
  v10 = write(Native, a2, a3);
  if (v10 < 0)
  {
    v15 = *__error();
    goto LABEL_12;
  }
  v12 = v10;
  v13 = (IOLogger *)*((_QWORD *)this + 27);
  v14 = v12 != 0;
  if (v13 && v12)
  {
    IOLogger::logBytes(v13, "RAW-SEND", 0x3Eu, a2, v12);
    v14 = 1;
  }
  if (*((_BYTE *)this + 644) && v14)
  {
    *((_QWORD *)this + 78) += v12;
    entr_act_modify_delayInitStub(v11);
  }
  return v12;
}

uint64_t __copy_helper_block_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __copy_helper_block_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void _CFNetworkErrorInitLocalizedStringsDictionary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const __CFString *a9)
{
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  const __CFString *v31;
  const __CFString *v32;
  const __CFString *v33;
  const __CFString *v34;
  const __CFString *v35;
  const __CFString *v36;
  const __CFString *v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  const __CFString *v42;
  const __CFString *v43;
  const __CFString *v44;
  const __CFString *v45;
  const __CFString *v46;
  const __CFString *v47;
  const __CFString *v48;
  const __CFString *v49;
  const __CFString *v50;
  const __CFString *v51;
  const __CFString *v52;
  const __CFString *v53;
  const __CFString *v54;
  const __CFString *v55;
  const __CFString *v56;
  const __CFString *v57;
  const __CFString *v58;
  const __CFString *v59;
  const __CFString *v60;
  const __CFString *v61;
  const __CFString *v62;
  const __CFString *v63;
  const __CFString *v64;
  const __CFString *v65;
  const __CFString *v66;
  const __CFString *v67;
  const __CFString *v68;
  const __CFString *v69;
  const __CFString *v70;
  const __CFString *v71;
  const __CFString *v72;
  const __CFString *v73;
  const __CFString *v74;
  const __CFString *v75;
  const __CFString *v76;
  const __CFString *v77;
  const __CFString *v78;
  const __CFString *v79;
  const __CFString *v80;
  const __CFString *v81;
  const __CFString *v82;
  const __CFString *v83;
  const __CFString *v84;
  const __CFString *v85;
  const __CFString *v86;
  const __CFString *v87;
  const __CFString *v88;
  const __CFString *v89;
  const __CFString *v90;
  const __CFString *v91;
  const __CFString *v92;
  const __CFString *v93;
  const __CFString *v94;
  const __CFString *v95;
  const __CFString *v96;
  const __CFString *v97;
  const __CFString *v98;
  const __CFString *v99;
  const __CFString *v100;
  const __CFString *v101;
  const __CFString *v102;
  const __CFString *v103;
  const __CFString *v104;
  const __CFString *v105;
  const __CFString *v106;
  const __CFString *v107;

  if (!_CFNetworkErrorLocalizedDescriptionsDict)
  {
    _CFNetworkErrorLocalizedDescriptionsDict = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    _CFNetworkErrorMapErrorCode(306, CFSTR("Err306"), CFSTR("There was a problem communicating with the web proxy server (HTTP)."), 0, 0, CFSTR("Please check your proxy settings. For help with this problem, contact your system administrator."), CFSTR("Please check your proxy settings. For help with this problem, contact your system administrator."), v9, v59);
    _CFNetworkErrorMapErrorCode(310, CFSTR("Err310"), CFSTR("There was a problem communicating with the secure web proxy server (HTTPS)."), 0, 0, CFSTR("Please check your proxy settings. For help with this problem, contact your system administrator."), CFSTR("Please check your proxy settings. For help with this problem, contact your system administrator."), v10, v60);
    _CFNetworkErrorMapErrorCode(311, CFSTR("Err311"), CFSTR("There was a problem establishing a secure tunnel through the web proxy server."), 0, 0, CFSTR("Please check your proxy settings. For help with this problem, contact your system administrator."), CFSTR("Please check your proxy settings. For help with this problem, contact your system administrator."), v11, v61);
    _CFNetworkErrorMapErrorCode(-996, CFSTR("Err-996"), CFSTR("Could not communicate with background transfer service"), 0, 0, 0, 0, v12, v62);
    _CFNetworkErrorMapErrorCode(-997, CFSTR("Err-997"), CFSTR("Lost connection to background transfer service"), 0, 0, 0, 0, v13, v63);
    _CFNetworkErrorMapErrorCode(-1, CFSTR("Err-998"), CFSTR("unknown error"), 0, 0, 0, 0, v14, v64);
    _CFNetworkErrorMapErrorCode(-998, CFSTR("Err-998"), CFSTR("unknown error"), 0, 0, 0, 0, v15, v65);
    _CFNetworkErrorMapErrorCode(-999, CFSTR("Err-999"), CFSTR("cancelled"), 0, 0, 0, 0, v16, v66);
    _CFNetworkErrorMapErrorCode(-1000, CFSTR("Err-1000"), CFSTR("bad URL"), 0, 0, 0, 0, v17, v67);
    _CFNetworkErrorMapErrorCode(-1001, CFSTR("Err-1001"), CFSTR("The request timed out."), 0, 0, 0, 0, v18, v68);
    _CFNetworkErrorMapErrorCode(-1002, CFSTR("Err-1002"), CFSTR("unsupported URL"), 0, 0, 0, 0, v19, v69);
    _CFNetworkErrorMapErrorCode(-1003, CFSTR("Err-1003"), CFSTR("A server with the specified hostname could not be found."), 0, 0, 0, 0, v20, v70);
    _CFNetworkErrorMapErrorCode(-1004, CFSTR("Err-1004"), CFSTR("Could not connect to the server."), 0, 0, 0, 0, v21, v71);
    _CFNetworkErrorMapErrorCode(-1005, CFSTR("Err-1005"), CFSTR("The network connection was lost."), 0, 0, 0, 0, v22, v72);
    _CFNetworkErrorMapErrorCode(-1006, CFSTR("Err-1006"), CFSTR("DNS lookup error"), 0, 0, 0, 0, v23, v73);
    _CFNetworkErrorMapErrorCode(-1007, CFSTR("Err-1007"), CFSTR("too many HTTP redirects"), 0, 0, 0, 0, v24, v74);
    _CFNetworkErrorMapErrorCode(-1008, CFSTR("Err-1008"), CFSTR("resource unavailable"), 0, 0, 0, 0, v25, v75);
    _CFNetworkErrorMapErrorCode(-1009, CFSTR("Err-1009"), CFSTR("The Internet connection appears to be offline."), 0, 0, 0, 0, v26, v76);
    _CFNetworkErrorMapErrorCode(-1010, CFSTR("Err-1010"), CFSTR("redirected to nowhere"), 0, 0, 0, 0, v27, v77);
    _CFNetworkErrorMapErrorCode(-1011, CFSTR("Err-1011"), CFSTR("There was a bad response from the server."), 0, 0, 0, 0, v28, v78);
    _CFNetworkErrorMapErrorCode(-1014, CFSTR("Err-1014"), CFSTR("zero byte resource"), 0, 0, 0, 0, v29, v79);
    _CFNetworkErrorMapErrorCode(-1015, CFSTR("Err-1015"), CFSTR("cannot decode raw data"), 0, 0, 0, 0, v30, v80);
    _CFNetworkErrorMapErrorCode(-1016, CFSTR("Err-1016"), CFSTR("cannot decode content data"), 0, 0, 0, 0, v31, v81);
    _CFNetworkErrorMapErrorCode(-1017, CFSTR("Err-1017"), CFSTR("cannot parse response"), 0, 0, 0, 0, v32, v82);
    _CFNetworkErrorMapErrorCode(-1018, CFSTR("Err-1018"), CFSTR("International roaming is currently off."), 0, 0, 0, 0, v33, v83);
    _CFNetworkErrorMapErrorCode(-1019, CFSTR("Err-1019"), CFSTR("A data connection cannot be established since a call is currently active."), 0, 0, 0, 0, v34, v84);
    _CFNetworkErrorMapErrorCode(-1020, CFSTR("Err-1020"), CFSTR("A data connection is not currently allowed."), 0, 0, 0, 0, v35, v85);
    _CFNetworkErrorMapErrorCode(-1021, CFSTR("Err-1021"), CFSTR("request body stream exhausted"), 0, 0, 0, 0, v36, v86);
    _CFNetworkErrorMapErrorCode(-1022, CFSTR("Err-1022"), CFSTR("The resource could not be loaded because the App Transport Security policy requires the use of a secure connection."), 0, 0, 0, 0, v37, v87);
    _CFNetworkErrorMapErrorCode(-1100, CFSTR("Err-1100"), CFSTR("The requested URL was not found on this server."), 0, 0, 0, 0, v38, v88);
    _CFNetworkErrorMapErrorCode(-1101, CFSTR("Err-1101"), CFSTR("file is directory"), 0, 0, 0, 0, v39, v89);
    _CFNetworkErrorMapErrorCode(-1102, CFSTR("Err-1102"), CFSTR("You do not have permission to access the requested resource."), 0, 0, 0, 0, v40, v90);
    _CFNetworkErrorMapErrorCode(-1103, CFSTR("Err-1103"), CFSTR("resource exceeds maximum size"), 0, 0, 0, 0, v41, v91);
    _CFNetworkErrorMapErrorCode(-1104, CFSTR("Err-1104"), CFSTR("file is outside of the safe area"), 0, 0, 0, 0, v42, v92);
    _CFNetworkErrorMapErrorCode(-1200, CFSTR("Err-1200"), CFSTR("An SSL error has occurred and a secure connection to the server cannot be made."), 0, 0, CFSTR("Would you like to connect to the server anyway?"), CFSTR("Would you like to connect to the server anyway?"), v43, v93);
    _CFNetworkErrorMapErrorCode(-1201, CFSTR("Err-1201"), CFSTR("The certificate for this server has expired."), CFSTR("Err-1201.w"), CFSTR("The certificate for this server has expired. You might be connecting to a server that is pretending to be \"%@\" which could put your confidential information at risk."), CFSTR("Would you like to connect to the server anyway?"), CFSTR("Would you like to connect to the server anyway?"), v44, v94);
    _CFNetworkErrorMapErrorCode(-1202, CFSTR("Err-1202"), CFSTR("The certificate for this server is invalid."), CFSTR("Err-1202.w"), CFSTR("The certificate for this server is invalid. You might be connecting to a server that is pretending to be \"%@\" which could put your confidential information at risk."), CFSTR("Would you like to connect to the server anyway?"), CFSTR("Would you like to connect to the server anyway?"), v45, v95);
    _CFNetworkErrorMapErrorCode(-1203, CFSTR("Err-1203"), CFSTR("The certificate for this server was signed by an unknown certifying authority."), CFSTR("Err-1203.w"), CFSTR("The certificate for this server was signed by an unknown certifying authority. You might be connecting to a server that is pretending to be \"%@\" which could put your confidential information at risk."), CFSTR("Would you like to connect to the server anyway?"), CFSTR("Would you like to connect to the server anyway?"), v46, v96);
    _CFNetworkErrorMapErrorCode(-1204, CFSTR("Err-1204"), CFSTR("The certificate for this server is not yet valid."), CFSTR("Err-1204.w"), CFSTR("The certificate for this server is not yet valid. You might be connecting to a server that is pretending to be \"%@\" which could put your confidential information at risk."), CFSTR("Would you like to connect to the server anyway?"), CFSTR("Would you like to connect to the server anyway?"), v47, v97);
    _CFNetworkErrorMapErrorCode(-1205, CFSTR("Err-1205"), CFSTR("The server did not accept the certificate."), CFSTR("Err-1205.w"), CFSTR("The server \"%@\" did not accept the certificate."), 0, 0, v48, v98);
    _CFNetworkErrorMapErrorCode(-1206, CFSTR("Err-1206"), CFSTR("The server requires a client certificate."), CFSTR("Err-1206.w"), CFSTR("The server \"%@\" requires a client certificate."), 0, 0, v49, v99);
    _CFNetworkErrorMapErrorCode(-2000, CFSTR("Err-2000"), CFSTR("can't load from network"), 0, 0, 0, 0, v50, v100);
    _CFNetworkErrorMapErrorCode(-3000, CFSTR("Err-3000"), CFSTR("Cannot create file"), 0, 0, 0, 0, v51, v101);
    _CFNetworkErrorMapErrorCode(-3001, CFSTR("Err-3001"), CFSTR("Cannot open file"), 0, 0, 0, 0, v52, v102);
    _CFNetworkErrorMapErrorCode(-3002, CFSTR("Err-3002"), CFSTR("Failure occurred while closing file"), 0, 0, 0, 0, v53, v103);
    _CFNetworkErrorMapErrorCode(-3003, CFSTR("Err-3003"), CFSTR("Cannot write file"), 0, 0, 0, 0, v54, v104);
    _CFNetworkErrorMapErrorCode(-3004, CFSTR("Err-3004"), CFSTR("Cannot remove file"), 0, 0, 0, 0, v55, v105);
    _CFNetworkErrorMapErrorCode(-3005, CFSTR("Err-3005"), CFSTR("Cannot move file"), 0, 0, 0, 0, v56, v106);
    _CFNetworkErrorMapErrorCode(-3006, CFSTR("Err-3006"), CFSTR("Download decoding failed"), 0, 0, 0, 0, v57, v107);
    _CFNetworkErrorMapErrorCode(-3007, CFSTR("Err-3007"), CFSTR("Download decoding failed"), 0, 0, 0, 0, v58, a9);
  }
}

void _CFNetworkErrorMapErrorCode(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, const __CFString *a8, const __CFString *a9)
{
  CFNumberRef v15;
  const void **v16;
  __CFString *v17;
  CFStringRef v18;
  const __CFString *v19;
  CFStringRef v20;
  CFArrayRef v21;
  uint64_t v26;
  void *values;
  CFTypeRef cf;
  CFTypeRef v29;
  CFTypeRef v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v26 = a1;
  v15 = CFNumberCreate(0, kCFNumberCFIndexType, &v26);
  v16 = (const void **)MEMORY[0x1E0C9B0D0];
  if (a2)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1)
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4752);
    v17 = (__CFString *)CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, a2, a3, CFSTR("Localizable"));
  }
  else
  {
    v17 = (__CFString *)*MEMORY[0x1E0C9B0D0];
  }
  values = v17;
  if (a4)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1)
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4752);
    v18 = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, a4, a5, CFSTR("Localizable"));
    v19 = (const __CFString *)*v16;
  }
  else
  {
    v19 = (const __CFString *)*v16;
    v18 = (CFStringRef)*v16;
  }
  cf = v18;
  v29 = v19;
  v20 = v19;
  if (a6)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1)
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4752);
    v20 = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, a6, a7, CFSTR("Localizable"));
  }
  v30 = v20;
  v21 = CFArrayCreate(0, (const void **)&values, 4, MEMORY[0x1E0C9B378]);
  if (values != v19 && values != 0)
    CFRelease(values);
  if (cf != v19 && cf != 0)
    CFRelease(cf);
  if (v29 != v19 && v29 != 0)
    CFRelease(v29);
  if (v30 != v19 && v30 != 0)
    CFRelease(v30);
  CFDictionaryAddValue((CFMutableDictionaryRef)_CFNetworkErrorLocalizedDescriptionsDict, v15, v21);
  if (v15)
    CFRelease(v15);
  if (v21)
    CFRelease(v21);
}

uint64_t __destroy_helper_block_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void HTTPCookieStorage::setDefaultNotificationHandler(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  const void *v5;

  v4 = (os_unfair_lock_s *)(a1 + 120);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 120));
  v5 = *(const void **)(a1 + 56);
  if (v5 != a2)
  {
    if (v5)
    {
      _Block_release(v5);
      *(_QWORD *)(a1 + 56) = 0;
    }
    if (a2)
      *(_QWORD *)(a1 + 56) = _Block_copy(a2);
  }
  os_unfair_lock_unlock(v4);
}

uint64_t ___ZN14CFNetworkTrust19strictEvaluateAsyncEN14StrictSecurity21SessionStrengthPolicyENS_26SignatureAlgorithmStrengthEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFviE_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = CFNetworkTrust::processStrictEvaluateResult(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(unsigned int *)(a1 + 56), a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 16))(v3, v4);
}

uint64_t CFNetworkTrust::processStrictEvaluateResult(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  __SecKey *v5;
  __SecKey *v6;
  size_t BlockSize;
  uint64_t v8;
  const __CFArray *v9;
  const __CFArray *v10;

  if (a4 != 4 && a4 != 1)
    return 4294957494;
  if (a2 < 1)
    return 0;
  v5 = SecTrustCopyKey(*(SecTrustRef *)(a1 + 8));
  if (!v5)
    return 4294957494;
  v6 = v5;
  BlockSize = SecKeyGetBlockSize(v5);
  switch(SecKeyGetAlgorithmId())
  {
    case 0:
    case 2:
      goto LABEL_6;
    case 1:
      if (BlockSize >= 0x100)
        goto LABEL_11;
      goto LABEL_6;
    case 3:
      if (BlockSize > 0x1F)
        goto LABEL_11;
LABEL_6:
      CFRelease(v6);
      return 4294957494;
    default:
LABEL_11:
      CFRelease(v6);
      v9 = SecTrustCopyCertificateChain(*(SecTrustRef *)(a1 + 8));
      if (!v9)
        return 0;
      v10 = v9;
      if (CFArrayGetCount(v9) >= 1 && CFArrayGetValueAtIndex(v10, 0))
      {
        if (SecCertificateGetSignatureHashAlgorithm() >= 6)
          v8 = 0;
        else
          v8 = 4294957494;
      }
      else
      {
        v8 = 0;
      }
      CFRelease(v10);
      break;
  }
  return v8;
}

void sub_183FA3C2C(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection12copyPropertyEPK10__CFString_block_invoke(uint64_t a1, const char *a2)
{
  CFStringRef v3;
  CFStringRef v4;

  v3 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0x8000100u);
  if (v3)
  {
    v4 = v3;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v3);
    CFRelease(v4);
  }
  return 1;
}

uint64_t ___Z27connectionTimingFromMetricsP23__CFN_ConnectionMetrics_block_invoke(uint64_t a1, void *a2)
{
  NSObject *v3;

  v3 = a2;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 64) += nw_resolution_report_get_milliseconds(v3);

  return 1;
}

void sub_183FA3CE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t SocketStream::write(SocketStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, int64_t a4, CFStreamError *a5)
{
  int64_t v9;
  CFStreamError *v10;
  int v11;
  unint64_t v12;
  CFRunLoopRef Current;
  const __CFAllocator *v14;
  CFRunLoopSourceRef v15;
  const __CFNumber *Value;
  double v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  IOLogger *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  __CFSocket *v36;
  const __CFAllocator *v37;
  _QWORD *v38;
  CFAllocatorRef v39;
  int64_t v40;
  uint64_t v41;
  __CFSocket *v42;
  unint64_t v43;
  uint64_t v44;
  CFTypeRef v46;
  const __CFDictionary *v47;
  const __CFDictionary *v48;
  const __CFDictionary *ATSVersion;
  const void *v50;
  uint64_t v51;
  CFTypeRef v52;
  int v53;
  unint64_t v54;
  __CFSocket *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  __CFSocket *v59;
  __CFSocket *v60;
  unint64_t v61;
  NSObject *v62;
  id WeakRetained;
  const void *v64;
  __CFSocket *v65;
  CFIndex v67;
  void *v68;
  int v69;
  unint64_t v70;
  uint64_t v71;
  char *cf;
  CFRunLoopRef v73;
  uint64_t v74;
  void (*v75)(uint64_t, const void *);
  void *v76;
  SocketStream *v77;
  uint64_t v78;
  CFTypeRef v79;
  double valuePtr;
  CFRunLoopSourceContext context;
  uint64_t v82;
  CFRange v83;
  CFRange v84;

  v82 = *MEMORY[0x1E0C80C00];
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  a5->domain = 0;
  *(_QWORD *)&a5->error = 0;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  v9 = 0;
  v10 = (CFStreamError *)((char *)this + 256);
  cf = (char *)this - 16;
  v71 = (int)*MEMORY[0x1E0C9B298];
  while (1)
  {
    while (1)
    {
      v11 = *((_DWORD *)this + 66);
      v12 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if (v11)
        goto LABEL_91;
      if ((*((_DWORD *)this + 62) & 8) != 0)
        goto LABEL_23;
      Current = CFRunLoopGetCurrent();
      context.version = 0;
      context.info = Current;
      memset(&context.retain, 0, 56);
      context.perform = (void (__cdecl *)(void *))emptyPerform;
      v14 = CFGetAllocator(cf);
      v15 = CFRunLoopSourceCreate(v14, 0, &context);
      *((_QWORD *)this + 73) = v15;
      if (!v15)
      {
        *((_QWORD *)this + 32) = 1;
        *((_DWORD *)this + 66) = 12;
        v61 = *((_DWORD *)this + 62) & 0xFFFFFFF7 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        *((_DWORD *)this + 62) &= ~8u;
        *((_WORD *)this + 126) = WORD2(v61);
        goto LABEL_113;
      }
      valuePtr = 0.0;
      Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFAEC8);
      if (!Value || !CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr))
      {
        valuePtr = 75.0;
LABEL_12:
        v17 = CFAbsoluteTimeGetCurrent() + valuePtr;
        goto LABEL_13;
      }
      if (valuePtr != 0.0)
        goto LABEL_12;
      v17 = 1.79769313e308;
LABEL_13:
      _SchedulesAddRunLoopAndMode(*((const __CFArray **)this + 39), Current, CFSTR("_kCFStreamSocketWritePrivateMode"));
      v18 = *((_QWORD *)this + 41);
      v73 = Current;
      v74 = 0x1EDCFB210;
      v83.length = *(_QWORD *)(v18 + 24);
      v83.location = 0;
      CFArrayApplyFunction(*(CFArrayRef *)(v18 + 16), v83, (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction, &v73);
      CFRunLoopAddSource(Current, *((CFRunLoopSourceRef *)this + 73), CFSTR("_kCFStreamSocketWritePrivateMode"));
      do
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
        CFRunLoopRunInMode(CFSTR("_kCFStreamSocketWritePrivateMode"), valuePtr, 1u);
        pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
        if (*((_DWORD *)this + 66))
          break;
        if ((*((_DWORD *)this + 62) & 8) != 0)
          break;
        valuePtr = v17 - CFAbsoluteTimeGetCurrent();
      }
      while (valuePtr > 0.0);
      CFRunLoopRemoveSource(Current, *((CFRunLoopSourceRef *)this + 73), CFSTR("_kCFStreamSocketWritePrivateMode"));
      v19 = *((_QWORD *)this + 41);
      v73 = Current;
      v74 = 0x1EDCFB210;
      v84.length = *(_QWORD *)(v19 + 24);
      v84.location = 0;
      CFArrayApplyFunction(*(CFArrayRef *)(v19 + 16), v84, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction, &v73);
      _SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 39), Current, CFSTR("_kCFStreamSocketWritePrivateMode"));
      v20 = (const void *)*((_QWORD *)this + 73);
      *((_QWORD *)this + 73) = 0;
      if (v20)
        CFRelease(v20);
      v12 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      v11 = *((_DWORD *)this + 66);
      if ((*((_DWORD *)this + 62) & 8) == 0)
        break;
      if (v11)
        goto LABEL_91;
LABEL_23:
      if ((v12 & 0x2000) == 0)
      {
        if ((v12 & 0x1000000) != 0)
        {
          v31 = (_QWORD *)*((_QWORD *)this + 66);
          if (v31)
          {
            v32 = v31[2];
            v33 = v31[3];
            v34 = v31[4];
          }
          else
          {
            v37 = CFGetAllocator(cf);
            v38 = CFAllocatorAllocate(v37, 36056, 0);
            bzero(v38, 0x8CD8uLL);
            v39 = CFGetAllocator(cf);
            v33 = 0;
            v34 = ((unint64_t)(v38 + 5) & 0xFFFFFFFFFFFFFFF0) + 16;
            v38[4] = v34;
            *((_OWORD *)v38 + 1) = xmmword_1841E38F0;
            *v38 = &off_1E14EB0D8;
            v38[1] = v39;
            *((_QWORD *)this + 66) = v38;
            v32 = 36000;
          }
          v40 = v32 - v33;
          if (v40 >= a4)
            v9 = a4;
          else
            v9 = v40;
          memcpy((void *)(v34 + v33), a3, v9);
          v41 = *((_QWORD *)this + 66);
          *(_QWORD *)(v41 + 24) = v9 + v33;
          if (*(_QWORD *)(v41 + 16) == v9 + v33)
            SocketStream::flushTransmissionBuffer_NoLock((CFStreamError *)this);
          else
            CFWriteStreamSignalEvent();
        }
        else
        {
          v9 = SocketStream::sendToSocket(this, a3, a4, (CFStreamError *)this + 16);
        }
LABEL_90:
        v11 = *((_DWORD *)this + 66);
        v12 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        goto LABEL_91;
      }
      valuePtr = 0.0;
      v21 = (IOLogger *)*((_QWORD *)this + 27);
      if (v21)
        IOLogger::logBytesSent(v21, 1, a3, a4);
      while (1)
      {
        while (1)
        {
          v22 = SSLWrite(*((SSLContextRef *)this + 37), a3, a4, (size_t *)&valuePtr);
          v23 = v22;
          v24 = *((unsigned int *)this + 62);
          v25 = v24 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          v9 = *(_QWORD *)&valuePtr;
          if ((v24 & 0x20000) == 0 && valuePtr != 0.0)
          {
            v26 = HIDWORD(v25);
            v25 |= 0x20000uLL;
            *((_WORD *)this + 126) = v26;
            *((_DWORD *)this + 62) = v25;
          }
          if (*((_DWORD *)this + 66))
            goto LABEL_89;
          if ((_DWORD)v22 == -9803 && v9 != 0)
            goto LABEL_51;
          if ((int)v22 > -9842)
            break;
          if ((_DWORD)v22 != -9842)
            goto LABEL_88;
          *((_WORD *)this + 126) = WORD2(v25);
          *((_DWORD *)this + 62) = v25 | 0x20000000;
          v29 = (*(uint64_t (**)(SocketStream *))(*(_QWORD *)this + 184))(this);
          if (v29)
          {
            v51 = v29;
            v79 = 0;
            if (SSLCopyDistinguishedNames(*((SSLContextRef *)this + 37), (CFArrayRef *)&v79))
            {
              v52 = v79;
              v79 = 0;
              if (v52)
                CFRelease(v52);
            }
            CFRetain(cf);
            v73 = (CFRunLoopRef)MEMORY[0x1E0C809B0];
            v74 = 3221225472;
            v75 = ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_3;
            v76 = &__block_descriptor_40_e20_v16__0____CFArray__8l;
            v77 = this;
            (*(void (**)(uint64_t, CFTypeRef, CFRunLoopRef *))(*(_QWORD *)v51 + 48))(v51, v79, &v73);
            if (v79)
              CFRelease(v79);
            (*(void (**)(uint64_t))(*(_QWORD *)v51 + 24))(v51);
            SocketStream::unscheduleFromSSL(this);
            goto LABEL_89;
          }
          v30 = *((_DWORD *)this + 62) & 0xDFFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          *((_DWORD *)this + 62) &= ~0x20000000u;
          *((_WORD *)this + 126) = WORD2(v30);
        }
        if ((int)v22 > -9807)
          break;
        if ((_DWORD)v22 != -9841)
          goto LABEL_88;
        v28 = (*(uint64_t (**)(SocketStream *))(*(_QWORD *)this + 184))(this);
        if (v28)
        {
          v44 = v28;
          *((_DWORD *)this + 62) |= 0x40000000u;
          v79 = 0;
          if (SocketStream::_copyPeerTrustWithPinning_NoLock((CFDictionaryRef *)this, *((SSLContextRef *)this + 37), (SecTrustRef *)&v79))
          {
            v46 = v79;
            v79 = 0;
            if (v46)
              CFRelease(v46);
          }
          v47 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), CFSTR("kCFStreamPropertySSLSettings"));
          ATSVersion = StrictSecurity::getATSVersion(v47, v48);
          StrictSecurity::cloneSecTrust(&v78, (uint64_t)ATSVersion, (uint64_t)v79);
          v50 = (const void *)*((_QWORD *)this + 86);
          *((_QWORD *)this + 86) = v78;
          if (v50)
            CFRelease(v50);
          logPeerCertAvailable(*((SSLContext **)this + 37));
          CFRetain(cf);
          context.version = MEMORY[0x1E0C809B0];
          context.info = (void *)3221225472;
          context.retain = (const void *(__cdecl *)(const void *))___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke;
          context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e8_v12__0i8l;
          context.copyDescription = (CFStringRef (__cdecl *)(const void *))this;
          (*(void (**)(uint64_t, CFTypeRef, CFRunLoopSourceContext *))(*(_QWORD *)v44 + 40))(v44, v79, &context);
          (*(void (**)(uint64_t))(*(_QWORD *)v44 + 24))(v44);
          SocketStream::unscheduleFromSSL(this);
          if (v79)
            CFRelease(v79);
          goto LABEL_89;
        }
      }
      if ((v22 + 9806) < 2)
      {
        *((_WORD *)this + 126) = WORD2(v25);
        *((_DWORD *)this + 62) = v25 | 0x100000;
        goto LABEL_90;
      }
      if (!(_DWORD)v22)
        goto LABEL_90;
      if ((_DWORD)v22 != -9803)
        goto LABEL_88;
      if ((v25 & 0x28000) != 0x8000)
      {
        v23 = 4294957493;
LABEL_88:
        v53 = translateSSLContextError(*((SSLContext **)this + 37), v23);
        *((_QWORD *)this + 32) = v71;
        *((_DWORD *)this + 66) = v53;
LABEL_89:
        v9 = -1;
        goto LABEL_90;
      }
LABEL_51:
      v35 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if (v9 >= 1)
      {
        if ((*((_DWORD *)this + 62) & 0x2000) == 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(context.version) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "we're blocked on SSLWrite, so we must be using SSL", (uint8_t *)&context, 2u);
          v56 = *((unsigned int *)this + 62);
          v35 = v56 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          if ((v56 & 2) == 0)
            goto LABEL_55;
        }
        else if ((v35 & 2) == 0)
        {
LABEL_55:
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            LOWORD(context.version) = 0;
            _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "we've written bytes, so the socket must have been opened", (uint8_t *)&context, 2u);
            v35 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          }
        }
        *((_WORD *)this + 126) = (v35 & 0xFFFFFFFFFFFFFFF7) >> 32;
        *((_DWORD *)this + 62) = v35 & 0xFFFFBFF7 | 0x4000;
        v36 = (__CFSocket *)*((_QWORD *)this + 36);
        if (v36 && CFSocketIsValid(v36))
          CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 9uLL);
        goto LABEL_90;
      }
      if ((*((_DWORD *)this + 62) & 0x28000) != 0x8000)
        goto LABEL_90;
      v42 = (__CFSocket *)*((_QWORD *)this + 36);
      if (v42 && CFSocketIsValid(v42))
        CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
      v43 = *((_DWORD *)this + 62) & 0xFFFFFFF7 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      *((_DWORD *)this + 62) &= ~8u;
      *((_WORD *)this + 126) = WORD2(v43);
    }
    if (!v11)
    {
      *((_QWORD *)this + 32) = 1;
      v11 = 60;
      *((_DWORD *)this + 66) = 60;
    }
LABEL_91:
    v54 = v12 & 0xFFFFFFFFFFFFFFF7;
    *((_DWORD *)this + 62) = v54;
    *((_WORD *)this + 126) = WORD2(v54);
    if (v11 != 35)
      break;
    if (v10->domain != 1)
      goto LABEL_113;
    v55 = (__CFSocket *)*((_QWORD *)this + 36);
    if (v55)
    {
      if (CFSocketIsValid(v55))
        CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 8uLL);
    }
    v10->domain = 0;
    *((_QWORD *)this + 33) = 0;
  }
  if (v11)
  {
LABEL_113:
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v62 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v67 = *((_QWORD *)this + 70);
      v68 = (void *)*((_QWORD *)this + 32);
      v69 = *((_DWORD *)this + 66);
      LODWORD(context.version) = 134218496;
      *(CFIndex *)((char *)&context.version + 4) = v67;
      WORD2(context.info) = 2048;
      *(void **)((char *)&context.info + 6) = v68;
      HIWORD(context.retain) = 1024;
      LODWORD(context.release) = v69;
      _os_log_error_impl(&dword_183ECA000, v62, OS_LOG_TYPE_ERROR, "SocketStream write error [%p]: %ld %d", (uint8_t *)&context, 0x1Cu);
    }
    if (!*((_QWORD *)this + 29) || *((uint64_t *)this + 28) <= 0)
    {
      *a5 = *v10;
      WeakRetained = objc_loadWeakRetained((id *)this + 34);
      if (WeakRetained)
      {
        v64 = WeakRetained;
        if ((*((_DWORD *)this + 62) & 0x200) != 0)
          _CFReadStreamSignalEventDelayed();
        CFRelease(v64);
      }
    }
    v65 = (__CFSocket *)*((_QWORD *)this + 36);
    if (v65 && CFSocketIsValid(v65))
      CFSocketDisableCallBacks(*((CFSocketRef *)this + 36), 9uLL);
    v9 = -1;
    goto LABEL_127;
  }
  if (!v9)
  {
    v60 = (__CFSocket *)*((_QWORD *)this + 36);
    if (v60 && CFSocketIsValid(v60))
      CFSocketDisableCallBacks(*((CFSocketRef *)this + 36), 8uLL);
    v9 = 0;
    goto LABEL_127;
  }
  SocketStream::touchWatchdogTimer_Locked(this, 0);
  if (*((_DWORD *)this + 103)
    || (v57 = *((unsigned int *)this + 62),
        v58 = v57 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32),
        (v57 & 0x4000) != 0))
  {
LABEL_127:
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
    goto LABEL_128;
  }
  if ((v57 & 0x100000) == 0)
  {
    v59 = (__CFSocket *)*((_QWORD *)this + 36);
    if (!v59 || !CFSocketIsValid(v59) || _CFSocketCan(*((__CFSocket **)this + 36), 1))
    {
      v58 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      goto LABEL_131;
    }
    CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 8uLL);
    goto LABEL_127;
  }
LABEL_131:
  v70 = v58 & 0xFFFFFFFFFFFFFFBFLL;
  *((_WORD *)this + 126) = WORD2(v70);
  *((_DWORD *)this + 62) = v70 | 8;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
  CFWriteStreamSignalEvent();
LABEL_128:
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  return v9;
}

BOOL _CFSocketCan(__CFSocket *a1, int a2)
{
  CFSocketNativeHandle Native;
  int v4;
  unsigned int v5;
  size_t v6;
  fd_set *v7;
  int v9;
  timeval v10;
  _OWORD v11[8];

  Native = CFSocketGetNative(a1);
  v4 = Native;
  if (a2)
  {
    v10.tv_sec = 0;
    *(_QWORD *)&v10.tv_usec = 0;
    memset(v11, 0, sizeof(v11));
    if (Native < 1024)
    {
      v7 = (fd_set *)v11;
    }
    else
    {
      v5 = (Native + 1) >> 5;
      if (((Native + 1) & 0x1F) != 0)
        ++v5;
      v6 = 4 * v5;
      v7 = (fd_set *)malloc_type_malloc(v6, 0x25A76F04uLL);
      bzero(v7, v6);
    }
    if (__darwin_check_fd_set_overflow(v4, v7, 0))
      *(__int32_t *)((char *)v7->fds_bits + (((unint64_t)v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v4;
    v9 = select(v4 + 1, 0, v7, 0, &v10);
    if (v7 != (fd_set *)v11)
      free(v7);
    return v9 > 0;
  }
  else
  {
    LODWORD(v11[0]) = 0;
    LODWORD(v10.tv_sec) = 4;
    getsockopt(Native, 0xFFFF, 4128, v11, (socklen_t *)&v10);
    return LODWORD(v11[0]) != 0;
  }
}

uint64_t SocketStream::canRead(SocketStream *this, __CFReadStream *a2)
{
  pthread_mutex_t *v4;
  int v5;
  _BOOL8 v6;
  uint64_t v8;

  v4 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  if (*((_DWORD *)this + 103))
    goto LABEL_3;
  v5 = *((_DWORD *)this + 62);
  if ((v5 & 0x800000) == 0)
    goto LABEL_3;
  if ((v5 & 0x100000) != 0 || *((_QWORD *)this + 29) && *((uint64_t *)this + 28) > 0)
  {
    v6 = 1;
LABEL_9:
    pthread_mutex_unlock(v4);
    return v6;
  }
  if ((v5 & 0x2000) != 0)
  {
    if ((*((_DWORD *)this + 62) & 0x60000000) != 0)
    {
      v6 = 0;
    }
    else
    {
      SocketStream::securityBufferedRead_NoLock(this);
      v6 = (*((_DWORD *)this + 62) & 0x100004) != 0;
    }
    goto LABEL_9;
  }
LABEL_3:
  pthread_mutex_unlock(v4);
  return SocketStream::streamCan((uint64_t)this, a2, 1, (const __CFString *)&unk_1EDCFB088, &v8);
}

uint64_t SocketStream::setProperty(SocketStream *this, const void *a2, const __CFString *a3, __CFString *a4)
{
  pthread_mutex_t *v8;
  int ExactString;
  const __CFDictionary *v10;
  uint64_t v11;
  char v12;
  const __CFDictionary *v13;
  char v14;
  CFTypeID v15;
  __CFDictionary *v16;
  int v17;
  __CFDictionary *v18;
  CFTypeID v19;
  int v20;
  CFTypeID v21;
  __CFSocket *v22;
  CFTypeID v23;
  BOOL v24;
  __CFSocket *v25;
  __CFDictionary *v26;
  uint64_t v27;
  int v28;
  const __CFNumber *Value;
  int v30;
  __CFSocket *v31;
  double v32;
  const __CFAllocator *v33;
  __CFDictionary *Mutable;
  const __CFDictionary *v35;
  int v36;
  __CFDictionary *v37;
  __CFDictionary *v38;
  CFTypeID v39;
  uint64_t v40;
  __CFString *v41;
  CFTypeRef v42;
  CFTypeID v43;
  xpc_object_t v44;
  CFTypeID v45;
  int v46;
  int v47;
  double v48;
  __CFSocket *v49;
  __CFDictionary *v50;
  __CFDictionary *v51;
  const __CFString *v52;
  const __CFString *length;
  uint64_t info;
  unint64_t *v55;
  unint64_t v56;
  CFTypeID v57;
  __CFSocket *v58;
  CFTypeID v59;
  SSLContextRef *BytePtr;
  const __CFDictionary *v61;
  CFTypeID v62;
  CFIndex Count;
  CFIndex v64;
  const void *ValueAtIndex;
  CFTypeID v66;
  CFTypeID v67;
  int v68;
  unint64_t v69;
  __int16 v70;
  CFTypeID v71;
  char *v72;
  unint64_t v73;
  __CFDictionary *v74;
  CFTypeID v75;
  SSLAuthenticate v76;
  CFTypeID v77;
  __CFSocket *v78;
  CFTypeID v79;
  CFTypeID v80;
  unsigned int v81;
  int v82;
  OSStatus v83;
  __CFSocket *v84;
  CFOptionFlags SocketFlags;
  CFOptionFlags v86;
  const __CFNumber *v87;
  const __CFNumber *v88;
  id WeakRetained;
  const void *v90;
  id v91;
  SocketStreamSignalHolder *v92;
  unint64_t v94;
  CFTypeID v95;
  __CFSocket *v96;
  __int16 v97;
  _QWORD v98[7];
  _QWORD v99[2];
  uint64_t valuePtr[2];
  _OWORD v101[4];
  uint64_t v102;

  v102 = 0;
  memset(v101, 0, sizeof(v101));
  v8 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  ExactString = _findExactString(a3, 0);
  v11 = 0;
  if (ExactString <= 131443042)
  {
    if (ExactString <= 97904391)
    {
      if (ExactString <= 84248065)
      {
        if (ExactString <= 77907339)
        {
          if (ExactString > 58057723)
          {
            if (ExactString == 58057724)
              goto LABEL_174;
            if (ExactString == 66307256)
            {
              if (a4)
              {
                if (*((_QWORD *)this + 70))
                {
                  valuePtr[0] = 3;
                  v43 = CFGetTypeID(a4);
                  if (v43 == CFNumberGetTypeID())
                  {
                    if (CFNumberGetValue((CFNumberRef)a4, kCFNumberSInt64Type, valuePtr))
                    {
                      v44 = xpc_uint64_create(valuePtr[0]);
                      if (v44)
                      {
                        tcp_connection_log_event();
                        xpc_release(v44);
                      }
                    }
                  }
                }
              }
              goto LABEL_278;
            }
            v17 = 76932468;
            goto LABEL_173;
          }
          if (ExactString == 22372625)
            goto LABEL_174;
          v28 = 32842260;
LABEL_137:
          if (ExactString == v28)
            goto LABEL_175;
          goto LABEL_311;
        }
        if (ExactString <= 80020909)
        {
          if (ExactString == 77907340)
            goto LABEL_174;
          v17 = 78857632;
          goto LABEL_173;
        }
        if (ExactString == 80020910)
          goto LABEL_174;
        if (ExactString != 82101715)
        {
          if (ExactString != 83273191)
            goto LABEL_311;
          goto LABEL_177;
        }
        if (CFBooleanGetValue((CFBooleanRef)a4))
        {
          v11 = 0;
          *((_DWORD *)this + 62) |= 0x1000000u;
          goto LABEL_311;
        }
        SocketStream::flushTransmissionBuffer_NoLock((CFStreamError *)this);
        v11 = 0;
        v72 = (char *)this + 248;
        v73 = *((_DWORD *)this + 62) & 0xFEFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        goto LABEL_330;
      }
      if (ExactString > 90506881)
      {
        if (ExactString <= 94627530)
        {
          if (ExactString != 90506882)
          {
            v17 = 93587130;
            goto LABEL_173;
          }
LABEL_177:
          if (*((const void **)this + 34) == a2)
          {
            v40 = 1;
          }
          else
          {
            v40 = 0;
            v11 = 0;
            if (*((const void **)this + 35) != a2)
              goto LABEL_311;
          }
          (*(void (**)(SocketStream *, uint64_t, const __CFString *, __CFString *))(*(_QWORD *)this + 216))(this, v40, a3, a4);
          goto LABEL_310;
        }
        if (ExactString == 94627531)
          goto LABEL_174;
        if (ExactString == 95782619)
        {
          if (a4)
          {
            v71 = CFGetTypeID(a4);
            if (v71 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              LOWORD(valuePtr[0]) = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
            }
            if ((__CFString *)*MEMORY[0x1E0C9AE50] == a4)
            {
              v11 = 0;
              v72 = (char *)this + 248;
              v97 = *((_WORD *)this + 126);
              *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
              LOWORD(v94) = v97 | 0x200;
              goto LABEL_331;
            }
          }
          v11 = 0;
          v72 = (char *)this + 248;
          v73 = (*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0xFFFFFDFFFFFFFFFFLL;
LABEL_330:
          *(_DWORD *)v72 = v73;
          v94 = HIDWORD(v73);
LABEL_331:
          *((_WORD *)v72 + 2) = v94;
          goto LABEL_311;
        }
        v20 = 96814834;
        goto LABEL_107;
      }
      if (ExactString <= 87361087)
      {
        if (ExactString != 84248066)
        {
          if (ExactString != 86279725)
            goto LABEL_311;
          v16 = (__CFDictionary *)*((_QWORD *)this + 42);
          if (!a4)
            goto LABEL_309;
          CFDictionarySetValue(v16, a3, a4);
          Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA250);
          SocketStream::updateTCPConnectionPoolPriority(this, a4, Value);
          goto LABEL_310;
        }
        goto LABEL_177;
      }
      if (ExactString == 87361088)
      {
        v16 = (__CFDictionary *)*((_QWORD *)this + 42);
        if (a4)
        {
          CFDictionarySetValue(v16, a3, a4);
          v52 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA218);
          SocketStream::updateTCPConnectionPoolPriority(this, v52, (const __CFNumber *)a4);
          goto LABEL_310;
        }
        goto LABEL_309;
      }
      if (ExactString != 88393301)
      {
        v20 = 89532009;
LABEL_107:
        if (ExactString != v20)
          goto LABEL_311;
LABEL_160:
        if ((*((_DWORD *)this + 62) & 3) != 0)
          goto LABEL_278;
        goto LABEL_177;
      }
LABEL_126:
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 42), a3, a4);
      goto LABEL_278;
    }
    if (ExactString <= 114509878)
    {
      if (ExactString > 106203044)
      {
        if (ExactString > 108242892)
        {
          if (ExactString == 108242893)
            goto LABEL_174;
          if (ExactString == 109373404)
          {
            if (a4)
            {
              v62 = CFGetTypeID(a4);
              if (v62 == CFArrayGetTypeID())
              {
                Count = CFArrayGetCount((CFArrayRef)a4);
                if (Count < 1)
                {
LABEL_241:
                  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 42), a3, a4);
                  goto LABEL_310;
                }
                v64 = 0;
                while (1)
                {
                  ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a4, v64);
                  v66 = CFGetTypeID(ValueAtIndex);
                  if (v66 != CFStringGetTypeID())
                    break;
                  if (Count == ++v64)
                    goto LABEL_241;
                }
              }
              goto LABEL_278;
            }
            v16 = (__CFDictionary *)*((_QWORD *)this + 42);
            goto LABEL_309;
          }
          v17 = 113535013;
          goto LABEL_173;
        }
        if (ExactString != 106203045)
        {
          if (ExactString == 107284408)
          {
            v38 = (__CFDictionary *)*((_QWORD *)this + 42);
            if (a4)
              CFDictionarySetValue(v38, a3, a4);
            else
              CFDictionaryRemoveValue(v38, a3);
            v11 = 1;
            SocketStream::setupMinimumThroughput((uint64_t)this, 1);
          }
          goto LABEL_311;
        }
        goto LABEL_160;
      }
      if (ExactString > 102123346)
      {
        if (ExactString == 102123347)
        {
          v16 = (__CFDictionary *)*((_QWORD *)this + 42);
          if (a4)
          {
            CFDictionarySetValue(v16, a3, a4);
            valuePtr[0] = 0;
            v45 = CFGetTypeID(a4);
            if (v45 == CFNumberGetTypeID()
              && CFNumberGetValue((CFNumberRef)a4, kCFNumberDoubleType, valuePtr)
              && *(double *)valuePtr > 0.0)
            {
              *((_QWORD *)this + 46) = valuePtr[0];
            }
            goto LABEL_310;
          }
          goto LABEL_309;
        }
        if (ExactString == 104064896)
        {
          if (!*((_BYTE *)this + 404))
          {
            v46 = CFEqual(a4, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
            v47 = v46 != 0;
            v48 = 0.1;
            if (!v46)
              v48 = 0.0;
            *((_DWORD *)this + 86) = v47 << 16;
            *((double *)this + 44) = v48;
            *((_DWORD *)this + 100) = v47;
            v49 = (__CFSocket *)*((_QWORD *)this + 36);
            if (v49 && CFSocketIsValid(v49))
              __CFSocketSetSocketReadBufferAttrs();
          }
          goto LABEL_310;
        }
        if (ExactString != 105187216)
          goto LABEL_311;
        if ((*((_DWORD *)this + 62) & 3) != 0)
          goto LABEL_278;
        goto LABEL_175;
      }
      if (ExactString == 97904392)
      {
        v74 = (__CFDictionary *)*((_QWORD *)this + 42);
        if (a4)
          CFDictionarySetValue(v74, a3, a4);
        else
          CFDictionaryRemoveValue(v74, a3);
        SocketStream::updateExcessiveKeepalivesParameters((uint64_t)this, a4);
        goto LABEL_310;
      }
      if (ExactString != 100902724)
        goto LABEL_311;
      goto LABEL_126;
    }
    if (ExactString <= 121940154)
    {
      if (ExactString > 118835318)
      {
        switch(ExactString)
        {
          case 118835319:
            if (ObserverHolder::Class(void)::sOnce_ObserverHolder != -1)
              dispatch_once(&ObserverHolder::Class(void)::sOnce_ObserverHolder, &__block_literal_global_10309);
            length = (const __CFString *)a4->length;
            info = a4[1].info;
            v99[0] = a4[1].isa;
            v99[1] = info;
            if (info)
            {
              v55 = (unint64_t *)(info + 8);
              do
                v56 = __ldxr(v55);
              while (__stxr(v56 + 1, v55));
            }
            v98[0] = MEMORY[0x1E0C809B0];
            v98[1] = 3221225472;
            v98[2] = ___ZN12SocketStream11setPropertyEPKvPK10__CFStringS1__block_invoke;
            v98[3] = &__block_descriptor_56_e6__v8__0l;
            v98[4] = this;
            v98[5] = a2;
            v98[6] = &a4->data;
            NotificationStation::registerForPropertyUpdates((uint64_t)this + 104, length, v99, (uint64_t)v98);
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v99);
            goto LABEL_278;
          case 119892109:
            LODWORD(valuePtr[0]) = 0;
            if (!a4)
              goto LABEL_278;
            v57 = CFGetTypeID(a4);
            if (v57 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)a4, kCFNumberSInt32Type, valuePtr))
              goto LABEL_278;
            v11 = 1;
            *((_BYTE *)this + 404) = 1;
            *((_DWORD *)this + 86) = valuePtr[0];
            v58 = (__CFSocket *)*((_QWORD *)this + 36);
            if (!v58 || !CFSocketIsValid(v58))
              goto LABEL_311;
            break;
          case 120965283:
            valuePtr[0] = 0;
            if (!a4)
              goto LABEL_278;
            v21 = CFGetTypeID(a4);
            if (v21 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)a4, kCFNumberDoubleType, valuePtr))
              goto LABEL_278;
            v11 = 1;
            *((_BYTE *)this + 404) = 1;
            *((_QWORD *)this + 44) = valuePtr[0];
            v22 = (__CFSocket *)*((_QWORD *)this + 36);
            if (!v22 || !CFSocketIsValid(v22))
              goto LABEL_311;
            break;
          default:
            goto LABEL_311;
        }
        __CFSocketSetSocketReadBufferAttrs();
        goto LABEL_311;
      }
      if (ExactString == 114509879)
        goto LABEL_174;
      v28 = 117680232;
      goto LABEL_137;
    }
    if (ExactString > 125004018)
    {
      if (ExactString != 125004019 && ExactString != 128272675)
      {
        if (ExactString != 129296697)
          goto LABEL_311;
        SocketStream::securitySetPeerCert_NoLock(this, (const __CFArray *)a4, (SocketStreamSignalHolder *)v101);
        goto LABEL_310;
      }
      goto LABEL_175;
    }
    if (ExactString != 121940155)
    {
      if (ExactString != 122947790)
        goto LABEL_311;
      v16 = (__CFDictionary *)*((_QWORD *)this + 42);
      if (a4)
      {
        a3 = (const __CFString *)&unk_1EDCFA9C0;
        goto LABEL_176;
      }
      a3 = CFSTR("kCFStreamPropertySSLSettings");
LABEL_309:
      CFDictionaryRemoveValue(v16, a3);
      goto LABEL_310;
    }
    *((_DWORD *)this + 100) = 0;
    *((_BYTE *)this + 404) = 1;
    if (CFEqual(a4, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
    {
      v82 = 1;
    }
    else
    {
      v95 = CFGetTypeID(a4);
      if (v95 != CFNumberGetTypeID()
        || (LODWORD(valuePtr[0]) = 0, !CFNumberGetValue((CFNumberRef)a4, kCFNumberSInt32Type, valuePtr)))
      {
LABEL_335:
        v96 = (__CFSocket *)*((_QWORD *)this + 36);
        if (v96 && CFSocketIsValid(v96))
          _CFSocketSetTrafficMgtBackground(*((__CFSocket **)this + 36), *((_DWORD *)this + 100) == 1);
        goto LABEL_310;
      }
      v82 = valuePtr[0];
    }
    *((_DWORD *)this + 100) = v82;
    goto LABEL_335;
  }
  if (ExactString <= 200625709)
  {
    if (ExactString > 161713009)
    {
      if (ExactString > 191171949)
      {
        if (ExactString <= 193334679)
        {
          if (ExactString != 191171950)
          {
            if (ExactString != 192228739)
              goto LABEL_311;
            v41 = (__CFString *)*((_QWORD *)this + 67);
            if (v41 != a4)
            {
              if (v41)
                CFRelease(v41);
              if (a4)
                v42 = CFRetain(a4);
              else
                v42 = 0;
              *((_QWORD *)this + 67) = v42;
            }
            goto LABEL_310;
          }
          goto LABEL_175;
        }
        if (ExactString == 193334680 || ExactString == 195382725)
          goto LABEL_174;
        v17 = 196464091;
      }
      else
      {
        if (ExactString <= 186928406)
        {
          if (ExactString == 161713010)
          {
            if (a4)
            {
              v77 = CFGetTypeID(a4);
              if (v77 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
              {
                LOWORD(valuePtr[0]) = 0;
                _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
              }
              v24 = *MEMORY[0x1E0C9AE50] == (_QWORD)a4;
              *((_BYTE *)this + 406) = v24;
              if (v24)
              {
                v78 = (__CFSocket *)*((_QWORD *)this + 36);
                if (v78)
                {
                  if (CFSocketIsValid(v78))
                    _CFSocketSetRecvAnyIf(*((__CFSocket **)this + 36));
                }
              }
            }
            else
            {
              *((_BYTE *)this + 406) = 0;
            }
          }
          else
          {
            if (ExactString != 174287922)
              goto LABEL_311;
            v30 = stringToServiceType((uint64_t)a4);
            if (v30 != -1 && *((_DWORD *)this + 102) != v30)
            {
              *((_DWORD *)this + 102) = v30;
              if (*((_QWORD *)this + 70))
              {
                v31 = (__CFSocket *)*((_QWORD *)this + 36);
                if (v31 && CFSocketIsValid(v31))
                {
                  if (*((_DWORD *)this + 102) == 1)
                    SocketStream::checkInVoIPSocket(this);
                  else
                    SocketStream::checkOutVoIPSocket(this, v32);
                }
                if (*((_QWORD *)this + 70))
                  tcp_connection_set_traffic_class();
              }
            }
          }
          goto LABEL_310;
        }
        if (ExactString == 186928407 || ExactString == 188075305)
          goto LABEL_174;
        v17 = 189107521;
      }
    }
    else
    {
      if (ExactString > 142936630)
      {
        if (ExactString <= 147049083)
        {
          if (ExactString != 142936631)
          {
            if (ExactString != 144976476)
              goto LABEL_311;
            v16 = (__CFDictionary *)*((_QWORD *)this + 42);
            if (a4)
            {
              CFDictionarySetValue(v16, a3, a4);
              valuePtr[0] = 0;
              v39 = CFGetTypeID(a4);
              if (v39 == CFNumberGetTypeID()
                && CFNumberGetValue((CFNumberRef)a4, kCFNumberDoubleType, valuePtr)
                && *(double *)valuePtr > 0.0)
              {
                *((_QWORD *)this + 45) = valuePtr[0];
              }
              goto LABEL_310;
            }
            goto LABEL_309;
          }
          if (a4)
          {
            v79 = CFGetTypeID(a4);
            if (v79 != CFDictionaryGetTypeID()
              || !CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("_kTCPKeepAliveParametersEnabled"))
              || !CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("_kTCPKeepAliveParametersEnabled"))
              || !CFDictionaryContainsKey((CFDictionaryRef)a4, CFSTR("_kTCPKeepAliveParametersEnabled")))
            {
              goto LABEL_278;
            }
            CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 42), a3, a4);
          }
          else
          {
            CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), a3);
          }
          SocketStream::updateTCPKeepalivesParameters((uint64_t)this, a4);
          goto LABEL_310;
        }
        if (ExactString != 147049084)
        {
          if (ExactString != 157494066)
          {
            if (ExactString != 160648036)
              goto LABEL_311;
            if (a4)
            {
              v23 = CFGetTypeID(a4);
              if (v23 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
              {
                LOWORD(valuePtr[0]) = 0;
                _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
              }
              v24 = *MEMORY[0x1E0C9AE50] == (_QWORD)a4;
              *((_BYTE *)this + 405) = v24;
              if (v24)
              {
                v25 = (__CFSocket *)*((_QWORD *)this + 36);
                if (v25)
                {
                  if (CFSocketIsValid(v25))
                    _CFSocketSetNoDelay(*((__CFSocket **)this + 36));
                }
              }
            }
            else
            {
              *((_BYTE *)this + 405) = 0;
            }
            goto LABEL_310;
          }
          goto LABEL_174;
        }
LABEL_175:
        v16 = (__CFDictionary *)*((_QWORD *)this + 42);
        if (a4)
        {
LABEL_176:
          CFDictionarySetValue(v16, a3, a4);
          goto LABEL_310;
        }
        goto LABEL_309;
      }
      if (ExactString > 137693656)
      {
        switch(ExactString)
        {
          case 137693657:
            v50 = (__CFDictionary *)*((_QWORD *)this + 42);
            if (a4)
            {
              CFDictionarySetValue(v50, a3, a4);
              SocketStream::updateTCPAdaptiveParamters(this, (CFNumberRef)a4, 0);
              goto LABEL_310;
            }
            CFDictionaryRemoveValue(v50, a3);
            v87 = 0;
            v88 = (const __CFNumber *)*MEMORY[0x1E0C9B0D0];
            break;
          case 138750446:
            v51 = (__CFDictionary *)*((_QWORD *)this + 42);
            if (a4)
            {
              CFDictionarySetValue(v51, a3, a4);
              SocketStream::updateTCPAdaptiveParamters(this, 0, (CFNumberRef)a4);
              goto LABEL_310;
            }
            CFDictionaryRemoveValue(v51, a3);
            v88 = 0;
            v87 = (const __CFNumber *)*MEMORY[0x1E0C9B0D0];
            break;
          case 141863460:
            v18 = (__CFDictionary *)*((_QWORD *)this + 42);
            if (a4)
            {
              CFDictionarySetValue(v18, a3, a4);
              if (!*((_QWORD *)this + 70))
                goto LABEL_310;
              v19 = CFGetTypeID(a4);
              if (v19 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
              {
                LOWORD(valuePtr[0]) = 0;
                _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
              }
            }
            else
            {
              CFDictionaryRemoveValue(v18, a3);
              if (!*((_QWORD *)this + 70))
                goto LABEL_310;
            }
            tcp_connection_set_keepalive_offload();
            goto LABEL_310;
          default:
            goto LABEL_311;
        }
        SocketStream::updateTCPAdaptiveParamters(this, v88, v87);
        goto LABEL_310;
      }
      if (ExactString == 131443043)
      {
        if (*((_QWORD *)this + 37))
        {
          LODWORD(valuePtr[0]) = 0;
          if (a4 && (v75 = CFGetTypeID(a4), v75 == CFNumberGetTypeID()))
          {
            CFNumberGetValue((CFNumberRef)a4, kCFNumberIntType, valuePtr);
            v76 = valuePtr[0];
          }
          else
          {
            v76 = kNeverAuthenticate;
            LODWORD(valuePtr[0]) = 0;
          }
          v83 = SSLSetClientSideAuthenticate(*((SSLContextRef *)this + 37), v76);
          if (v83)
          {
            v11 = 0;
            *((_QWORD *)this + 32) = (int)*MEMORY[0x1E0C9B298];
            *((_DWORD *)this + 66) = v83;
            goto LABEL_311;
          }
          goto LABEL_310;
        }
        goto LABEL_278;
      }
      v17 = 135580085;
    }
    goto LABEL_173;
  }
  if (ExactString <= 217460577)
  {
    if (ExactString > 212037385)
    {
      if (ExactString > 214216492)
      {
        if (ExactString != 214216493)
        {
          if (ExactString != 215166784)
          {
            if (ExactString != 216338253)
              goto LABEL_311;
            v26 = (__CFDictionary *)*((_QWORD *)this + 42);
            if (a4)
              CFDictionarySetValue(v26, a3, a4);
            else
              CFDictionaryRemoveValue(v26, a3);
            v84 = (__CFSocket *)*((_QWORD *)this + 36);
            if (v84 && CFSocketIsValid(v84))
            {
              SocketFlags = CFSocketGetSocketFlags(*((CFSocketRef *)this + 36));
              if (a4)
              {
                if ((__CFString *)*MEMORY[0x1E0C9AE40] == a4)
                  v86 = SocketFlags & 0xFFFFFFFFFFFFFF7FLL;
                else
                  v86 = SocketFlags | 0x80;
              }
              else if ((*((_DWORD *)this + 62) & 0x100) != 0)
              {
                v86 = SocketFlags & 0xFFFFFFFFFFFFFF7FLL;
              }
              else
              {
                v86 = SocketFlags | 0x80;
              }
              CFSocketSetSocketFlags(*((CFSocketRef *)this + 36), v86);
            }
            goto LABEL_310;
          }
          goto LABEL_174;
        }
        if ((*((_BYTE *)this + 248) & 1) != 0)
          goto LABEL_310;
        v11 = 1;
        if (a4 && (*((_BYTE *)this + 248) & 2) == 0)
        {
          v67 = CFGetTypeID(a4);
          if (v67 == CFBooleanGetTypeID())
          {
            v68 = CFBooleanGetValue((CFBooleanRef)a4);
            v69 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
            if (v68)
              v70 = WORD2(v69) | 1;
            else
              v70 = WORD2(v69) & 0xFFFE;
            *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
            *((_WORD *)this + 126) = v70;
          }
          goto LABEL_310;
        }
        goto LABEL_311;
      }
      if (ExactString == 212037386)
      {
        if ((*((_BYTE *)this + 248) & 1) != 0)
          goto LABEL_310;
        v11 = 1;
        if (a4 && (*((_BYTE *)this + 248) & 2) == 0)
        {
          v80 = CFGetTypeID(a4);
          if (v80 == CFBooleanGetTypeID())
          {
            if (CFBooleanGetValue((CFBooleanRef)a4))
              v81 = *((_DWORD *)this + 62) | 0x80000000;
            else
              v81 = *((_DWORD *)this + 62) & 0x7FFFFFFF;
            *((_WORD *)this + 126) = *((_WORD *)this + 126);
            *((_DWORD *)this + 62) = v81;
          }
          goto LABEL_310;
        }
        goto LABEL_311;
      }
      v17 = 213192472;
    }
    else if (ExactString <= 202673751)
    {
      if (ExactString == 200625710)
        goto LABEL_174;
      v17 = 201641540;
    }
    else
    {
      if (ExactString == 202673752 || ExactString == 203689579)
        goto LABEL_174;
      v17 = 205827726;
    }
LABEL_173:
    if (ExactString != v17)
      goto LABEL_311;
    goto LABEL_174;
  }
  if (ExactString <= 227954716)
  {
    if (ExactString <= 224669675)
    {
      if (ExactString == 217460578)
        goto LABEL_174;
      if (ExactString == 223645657)
      {
        v33 = CFGetAllocator((char *)this - 16);
        Mutable = CFDictionaryCreateMutable(v33, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v11 = (uint64_t)Mutable;
        if (Mutable)
        {
          CFDictionaryAddValue(Mutable, &unk_1EDCFC470, a4);
          v36 = SocketStream::securitySetInfo_NoLock((CFDictionaryRef *)this, (const __CFDictionary *)v11, v35);
          CFRelease((CFTypeRef)v11);
          if (v36)
          {
            v37 = (__CFDictionary *)*((_QWORD *)this + 42);
            if (a4)
              CFDictionarySetValue(v37, &unk_1EDCFBEC0, a4);
            else
              CFDictionaryRemoveValue(v37, &unk_1EDCFBEC0);
            goto LABEL_310;
          }
          goto LABEL_278;
        }
      }
      goto LABEL_311;
    }
    if (ExactString == 224669676)
    {
      v59 = CFGetTypeID(a4);
      if (v59 != CFDataGetTypeID())
        goto LABEL_278;
      BytePtr = (SSLContextRef *)CFDataGetBytePtr((CFDataRef)a4);
      v27 = SocketStream::securitySetContext_NoLock(this, *BytePtr, v61);
      goto LABEL_232;
    }
    if (ExactString == 225669117)
    {
      v27 = SocketStream::_SOCKSSetInfo_NoLock((CFDictionaryRef *)this, (const __CFDictionary *)a4);
      goto LABEL_232;
    }
    v17 = 226775051;
    goto LABEL_173;
  }
  if (ExactString <= 233173109)
  {
    if (ExactString != 227954717)
    {
      if (ExactString != 228814903)
      {
        if (ExactString != 231968871)
          goto LABEL_311;
        v12 = dyld_program_sdk_at_least();
        if (a4)
          v14 = v12;
        else
          v14 = 1;
        if ((v14 & 1) == 0)
        {
          v15 = CFGetTypeID(a4);
          if (v15 == CFStringGetTypeID())
            a4 = (__CFString *)MEMORY[0x1E0C9AA70];
        }
        if (SocketStream::securitySetInfo_NoLock((CFDictionaryRef *)this, (const __CFDictionary *)a4, v13))
        {
          v16 = (__CFDictionary *)*((_QWORD *)this + 42);
          a3 = CFSTR("kCFStreamPropertySSLSettings");
          if (!a4)
            goto LABEL_309;
          goto LABEL_176;
        }
LABEL_278:
        v11 = 0;
        goto LABEL_311;
      }
      v27 = SocketStream::securitySetContext_NoLock(this, (SSLContextRef)a4, v10);
LABEL_232:
      v11 = v27;
      goto LABEL_311;
    }
LABEL_174:
    if ((*((_DWORD *)this + 62) & 3) == 0)
      goto LABEL_175;
LABEL_310:
    v11 = 1;
    goto LABEL_311;
  }
  if (ExactString != 233173110)
  {
    if (ExactString != 257143274)
    {
      if (ExactString != 554941461)
        goto LABEL_311;
      v27 = SocketStream::_CONNECTSetInfo_NoLock((CFDictionaryRef *)this, (CFDictionaryRef)a4);
      goto LABEL_232;
    }
    goto LABEL_175;
  }
  v11 = *((_QWORD *)this + 37);
  if (v11)
  {
    if (a4)
    {
      CFDataGetBytePtr((CFDataRef)a4);
      CFDataGetLength((CFDataRef)a4);
    }
    v11 = _SSLSetDiffieHellmanParams() == 0;
  }
LABEL_311:
  if (!*((_DWORD *)this + 66))
    goto LABEL_323;
  WeakRetained = objc_loadWeakRetained((id *)this + 34);
  v90 = WeakRetained;
  if (*((_QWORD *)this + 29) && *((uint64_t *)this + 28) >= 1 || !WeakRetained)
  {
    if (!WeakRetained)
      goto LABEL_319;
  }
  else if ((*((_DWORD *)this + 62) & 0x200) != 0)
  {
    _CFReadStreamSignalEventDelayed();
  }
  CFRelease(v90);
LABEL_319:
  v91 = objc_loadWeakRetained((id *)this + 35);
  if (v91)
  {
    if ((*((_DWORD *)this + 62) & 0x400) != 0)
      _CFWriteStreamSignalEventDelayed();
    CFRelease(v91);
  }
LABEL_323:
  pthread_mutex_unlock(v8);
  SocketStream::dispatchSignalFromSocketCallbackUnlocked((CFRunLoopSourceRef *)v101, v92);
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)v101);
  return v11;
}

void sub_183FA5FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)va);
  _Unwind_Resume(a1);
}

void SocketStream::_SocketCallBack_stream(SocketStream *this, __CFSocket *a2, unint64_t a3, const __CFData *a4, char *cf, void *a6)
{
  SocketStreamSignalHolder *v10;
  unsigned int *v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  Schedulables *v15;
  uint64_t i;
  const void *v17;
  unsigned int v18;
  uint64_t j;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  __CFSocket *v29;
  CFOptionFlags v30;
  unint64_t v31;
  id v32;
  id WeakRetained;
  id v34;
  uint64_t Native;
  uint64_t v36;
  unint64_t v37;
  __CFSocket *v38;
  uint64_t v39;
  CFTypeRef v40[2];
  CFTypeRef cfa[2];
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  size_t processed[2];
  uint64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (cf)
  {
    if (TCFObject<SocketStream>::Class(void)::sOnce != -1)
      dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_233);
    CFRetain(cf);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    if ((*((_DWORD *)cf + 66) & 0x800) != 0)
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      goto LABEL_12;
    }
    if (*((SocketStream **)cf + 38) != this && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v40[0]) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "What socket signalled us?", (uint8_t *)v40, 2u);
    }
    v44 = 0;
    v42 = 0u;
    v43 = 0u;
    *(_OWORD *)v40 = 0u;
    *(_OWORD *)cfa = 0u;
    if (*((_DWORD *)cf + 70))
    {
LABEL_9:
      SocketStream::prepareSignalFromSocketCallbackLocked((SocketStream *)(cf + 16), (SocketStreamSignalHolder *)v40);
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      SocketStream::dispatchSignalFromSocketCallbackUnlocked((CFRunLoopSourceRef *)v40, v10);
      SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)v40);
LABEL_12:
      CFRelease(cf);
      return;
    }
    v11 = (unsigned int *)(cf + 264);
    if (a2 == (__CFSocket *)1)
    {
      SocketStream::socketCallbackReadLocked((SocketStream *)(cf + 16), (SocketStreamSignalHolder *)v40);
      if ((*v11 & 0x28000) != 0x8000)
        goto LABEL_9;
    }
    else if (a2 != (__CFSocket *)8)
    {
      if (a2 == (__CFSocket *)4)
      {
        v12 = *v11;
        v13 = v12 & 0xFFFFFFFFEFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
        *v11 = v12 & 0xEFFFFFFF;
        *((_WORD *)cf + 134) = WORD2(v13);
        if (a4 && (v14 = *(_DWORD *)a4) != 0)
        {
          *(_OWORD *)processed = *((_OWORD *)cf + 20);
          v15 = (Schedulables *)*((_QWORD *)cf + 43);
          v46 = *((_QWORD *)cf + 42);
          *((_DWORD *)cf + 70) = v14;
          *((_QWORD *)cf + 34) = 1;
          Schedulables::_remove(v15, *((const void **)cf + 38));
          for (i = 0; i != 3; ++i)
            _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 38), (const __CFArray *)processed[i]);
          _CFTypeInvalidate(*((char **)cf + 38));
          v17 = (const void *)*((_QWORD *)cf + 38);
          *((_QWORD *)cf + 38) = 0;
          if (v17)
            CFRelease(v17);
          if (SocketStream::attemptNextConnection_NoLock((SocketStream *)(cf + 16)))
          {
            *((_QWORD *)cf + 34) = 0;
            *((_QWORD *)cf + 35) = 0;
          }
        }
        else
        {
          if (*((_QWORD *)cf + 72))
            tcp_connection_set_traffic_class();
          SocketStream::checkInVoIPSocket((SocketStream *)(cf + 16));
          *v11 = *v11 & 0xFFFFFFEC | 2;
          v40[0] = (CFTypeRef)1;
          WeakRetained = objc_loadWeakRetained((id *)cf + 36);
          if (v40[1])
            CFRelease(v40[1]);
          v40[1] = WeakRetained;
          v34 = objc_loadWeakRetained((id *)cf + 37);
          if (cfa[0])
            CFRelease(cfa[0]);
          cfa[0] = v34;
          if ((*v11 & 0x8000000) == 0 && *((_QWORD *)cf + 72) && tcp_connection_is_cellular())
          {
            *v11 |= 0x8000000u;
            CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 44), CFSTR("_kCFStreamPropertyForcedConnection"), (const void *)*MEMORY[0x1E0C9AE50]);
          }
          if (*((_QWORD *)cf + 29))
          {
            Native = CFSocketGetNative(*((CFSocketRef *)cf + 38));
            SocketStream::setLoggerPrefixWithNativeHandle((SocketStream *)(cf + 16), Native);
          }
        }
      }
      goto LABEL_9;
    }
    v18 = *((_DWORD *)cf + 107);
    if (v18)
    {
      for (j = 0; j != 8; ++j)
      {
        if (((v18 >> j) & 1) != 0)
          break;
      }
      SocketStream::performHandshake((uint64_t)(cf + 16));
      goto LABEL_9;
    }
    v20 = *v11;
    v21 = v20 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
    if ((v20 & 0x4000) == 0)
    {
      v22 = *((_QWORD *)cf + 68);
      if (v22 && (v23 = *(_QWORD *)(v22 + 24), v23 >= 1) && ((v21 & 0x800000) == 0 || *(_QWORD *)(v22 + 16) == v23))
      {
        SocketStream::flushTransmissionBuffer_NoLock((CFStreamError *)cf + 1);
      }
      else
      {
        v31 = v21 & 0xFFFFFFFFFFFFFFBFLL;
        *((_WORD *)cf + 134) = WORD2(v31);
        *v11 = v31 | 8;
        v40[0] = (CFTypeRef)4;
        v32 = objc_loadWeakRetained((id *)cf + 37);
        if (cfa[0])
          CFRelease(cfa[0]);
        cfa[0] = v32;
      }
      goto LABEL_9;
    }
    v24 = *((_DWORD *)cf + 70);
    if (!v24 || (v25 = *((_QWORD *)cf + 34), v24 == 35) && v25 == 1 || v24 == -9803 && v25 == *MEMORY[0x1E0C9B298])
    {
      processed[0] = 0;
      v26 = SSLWrite(*((SSLContextRef *)cf + 39), 0, 0, processed);
      v27 = v26;
      if ((_DWORD)v26 != -9803 && (_DWORD)v26)
      {
        v28 = translateSSLContextError(*((SSLContext **)cf + 39), v26);
        *((_QWORD *)cf + 34) = (int)*MEMORY[0x1E0C9B298];
        *((_DWORD *)cf + 70) = v28;
      }
      if (v27 == -9803)
      {
        v29 = (__CFSocket *)*((_QWORD *)cf + 38);
        if (!v29 || !CFSocketIsValid(v29))
          goto LABEL_9;
        v30 = 8;
        goto LABEL_71;
      }
    }
    v36 = *v11;
    v37 = v36 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
    if ((v36 & 0x2000) == 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(processed[0]) = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "we're blocked on SSLWrite, so we must be using SSL", (uint8_t *)processed, 2u);
      v39 = *v11;
      v37 = v39 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
      if ((v39 & 2) == 0)
      {
LABEL_66:
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(processed[0]) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "we've written bytes, so the socket must have been opened", (uint8_t *)processed, 2u);
          v37 = *v11 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
        }
      }
    }
    else if ((v37 & 2) == 0)
    {
      goto LABEL_66;
    }
    *v11 = v37 & 0xFFFFBFFF;
    *((_WORD *)cf + 134) = (v37 & 0xFFFFFFFFFFFFBFFFLL) >> 32;
    v38 = (__CFSocket *)*((_QWORD *)cf + 38);
    if (!v38 || !CFSocketIsValid(v38))
      goto LABEL_9;
    v30 = 9;
LABEL_71:
    CFSocketEnableCallBacks(*((CFSocketRef *)cf + 38), v30);
    goto LABEL_9;
  }
}

void sub_183FA65FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)&a9);
  _Unwind_Resume(a1);
}

void SocketStreamSignalHolder::~SocketStreamSignalHolder(SocketStreamSignalHolder *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;

  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 2);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 5);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 6);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 7);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 8);
  if (v7)
    CFRelease(v7);
}

void SocketStream::dispatchSignalFromSocketCallbackUnlocked(CFRunLoopSourceRef *this, SocketStreamSignalHolder *a2)
{
  if (this[1])
  {
    if (this[5])
    {
      CFRunLoopSourceSignal(this[5]);
      CFRunLoopWakeUp(this[7]);
    }
    else
    {
      CFReadStreamSignalEvent();
    }
  }
  if (this[2])
  {
    if (this[6])
    {
      CFRunLoopSourceSignal(this[6]);
      CFRunLoopWakeUp(this[8]);
    }
    else
    {
      CFWriteStreamSignalEvent();
    }
  }
}

void SocketStream::prepareSignalFromSocketCallbackLocked(SocketStream *this, SocketStreamSignalHolder *a2)
{
  id WeakRetained;
  const void *v5;
  id v6;
  const void *v7;
  unint64_t v8;
  const void *v9;
  const void *v10;
  const void *v11;
  __CFRunLoopSource *v12;
  void *info;
  const void *v14;
  const void *v15;
  const void *v16;
  __CFRunLoopSource *v17;
  void *v18;
  CFRunLoopSourceContext cf;

  if (*((_DWORD *)this + 66))
  {
    *(_OWORD *)((char *)a2 + 24) = *((_OWORD *)this + 16);
    *(_QWORD *)a2 = 8;
    WeakRetained = objc_loadWeakRetained((id *)this + 34);
    v5 = (const void *)*((_QWORD *)a2 + 1);
    if (v5)
      CFRelease(v5);
    *((_QWORD *)a2 + 1) = WeakRetained;
    v6 = objc_loadWeakRetained((id *)this + 35);
    v7 = (const void *)*((_QWORD *)a2 + 2);
    if (v7)
      CFRelease(v7);
    *((_QWORD *)a2 + 2) = v6;
  }
  v8 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v8 & 0x1000000200) != 0x200)
  {
    v9 = (const void *)*((_QWORD *)a2 + 1);
    if (v9)
      CFRelease(v9);
    *((_QWORD *)a2 + 1) = 0;
    v8 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  }
  if ((v8 & 0x2000000400) != 0x400)
  {
    v10 = (const void *)*((_QWORD *)a2 + 2);
    if (v10)
      CFRelease(v10);
    *((_QWORD *)a2 + 2) = 0;
  }
  if (*(_QWORD *)a2)
  {
    v11 = (const void *)*((_QWORD *)this + 72);
    if (v11)
    {
      v12 = (__CFRunLoopSource *)CFRetain(v11);
      *((_QWORD *)a2 + 5) = v12;
      if (v12)
      {
        memset(&cf, 0, sizeof(cf));
        CFRunLoopSourceGetContext(v12, &cf);
        info = cf.info;
        if (cf.info)
          info = (void *)CFRetain(cf.info);
        *((_QWORD *)a2 + 7) = info;
      }
    }
    else
    {
      *((_QWORD *)a2 + 5) = 0;
    }
    v16 = (const void *)*((_QWORD *)this + 73);
    if (v16)
    {
      v17 = (__CFRunLoopSource *)CFRetain(v16);
      *((_QWORD *)a2 + 6) = v17;
      if (v17)
      {
        memset(&cf, 0, sizeof(cf));
        CFRunLoopSourceGetContext(v17, &cf);
        v18 = cf.info;
        if (cf.info)
          v18 = (void *)CFRetain(cf.info);
        *((_QWORD *)a2 + 8) = v18;
      }
    }
    else
    {
      *((_QWORD *)a2 + 6) = 0;
    }
    if (*((_QWORD *)a2 + 1) && *(_QWORD *)a2 == 8 && *((_QWORD *)this + 29) && *((uint64_t *)this + 28) >= 1)
    {
      *(_QWORD *)a2 = 2;
      *((_QWORD *)a2 + 3) = 0;
      *((_QWORD *)a2 + 4) = 0;
    }
  }
  else
  {
    v14 = (const void *)*((_QWORD *)a2 + 1);
    if (v14)
      CFRelease(v14);
    *((_QWORD *)a2 + 1) = 0;
    v15 = (const void *)*((_QWORD *)a2 + 2);
    if (v15)
      CFRelease(v15);
    *((_QWORD *)a2 + 2) = 0;
  }
}

void SocketStream::socketCallbackReadLocked(SocketStream *this, SocketStreamSignalHolder *a2)
{
  unsigned int v3;
  uint64_t i;
  uint64_t v6;
  unint64_t v7;
  __CFData *Mutable;
  int v9;
  const __CFAllocator *v10;
  UInt8 *MutableBytePtr;
  uint64_t v12;
  unint64_t v13;
  __CFSocket *v14;
  unint64_t v15;
  id WeakRetained;
  const void *v17;

  v3 = *((_DWORD *)this + 103);
  if (v3)
  {
    for (i = 0; i != 8; ++i)
    {
      if (((v3 >> i) & 1) != 0)
        break;
    }
    SocketStream::performHandshake((uint64_t)this);
    return;
  }
  v6 = *((unsigned int *)this + 62);
  v7 = v6 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v6 & 0x800000) != 0)
  {
    if ((v6 & 0x2000) != 0)
    {
      SocketStream::securityBufferedRead_NoLock(this);
      goto LABEL_23;
    }
    Mutable = (__CFData *)*((_QWORD *)this + 29);
    if (Mutable)
    {
      if (*((uint64_t *)this + 28) >= 0x8000)
      {
        v9 = v7 | 0x2000000;
LABEL_21:
        *((_WORD *)this + 126) = WORD2(v7);
        *((_DWORD *)this + 62) = v9;
        goto LABEL_23;
      }
    }
    else
    {
      v10 = CFGetAllocator((char *)this - 16);
      Mutable = CFDataCreateMutable(v10, 0x8000);
      *((_QWORD *)this + 28) = 0;
      *((_QWORD *)this + 29) = Mutable;
      if (!Mutable)
      {
        *((_QWORD *)this + 29) = 0;
        *((_QWORD *)this + 32) = 1;
        *((_DWORD *)this + 66) = 12;
        goto LABEL_23;
      }
    }
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v12 = SocketStream::recvBytes(this, &MutableBytePtr[*((_QWORD *)this + 28)], 0x8000 - *((_QWORD *)this + 28), (CFStreamError *)this + 16);
    v7 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    v13 = *((_DWORD *)this + 62) & 0xFDFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) &= ~0x2000000u;
    *((_WORD *)this + 126) = WORD2(v13);
    if (v12 < 1)
    {
      if (v12)
        goto LABEL_23;
      v9 = v7 & 0xFDEFFFDB | 0x100004;
      goto LABEL_21;
    }
    *((_QWORD *)this + 28) += v12;
    v14 = (__CFSocket *)*((_QWORD *)this + 36);
    if (v14 && CFSocketIsValid(v14))
      CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
    v15 = *((_DWORD *)this + 62) & 0xFFFFFFDF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = *((_DWORD *)this + 62) & 0xFFFFFFDB | 4;
    *((_WORD *)this + 126) = WORD2(v15);
LABEL_23:
    if ((*((_DWORD *)this + 62) & 4) == 0)
      return;
    goto LABEL_24;
  }
  *((_WORD *)this + 126) = (v6 & 0xFFFFFFFFFFFFFFDFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) >> 32;
  *((_DWORD *)this + 62) = v6 & 0xFFFFFFDB | 4;
LABEL_24:
  *(_QWORD *)a2 = 2;
  WeakRetained = objc_loadWeakRetained((id *)this + 34);
  v17 = (const void *)*((_QWORD *)a2 + 1);
  if (v17)
    CFRelease(v17);
  *((_QWORD *)a2 + 1) = WeakRetained;
}

uint64_t SocketStream::read(SocketStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  int64_t v11;
  CFStreamError *v12;
  int i;
  unint64_t v14;
  CFRunLoopRef Current;
  const __CFAllocator *v16;
  CFRunLoopSourceRef v17;
  const __CFNumber *Value;
  double v19;
  double v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  __CFData *v28;
  UInt8 *MutableBytePtr;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  __CFSocket *v33;
  unint64_t v34;
  __CFSocket *v35;
  unsigned int v36;
  uint64_t v37;
  NSObject *v38;
  id WeakRetained;
  const void *v40;
  __CFSocket *v41;
  uint64_t v42;
  char v43;
  unint64_t v44;
  __CFSocket *v45;
  unint64_t v46;
  __CFSocket *v47;
  __CFSocket *v48;
  uint64_t v49;
  unint64_t v50;
  CFIndex v52;
  void *v53;
  int v54;
  unsigned __int8 *v55;
  double valuePtr;
  CFRunLoopRef v57;
  uint64_t v58;
  CFRunLoopSourceContext context;
  uint64_t v60;
  CFRange v61;
  CFRange v62;

  v60 = *MEMORY[0x1E0C80C00];
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  v55 = a6;
  a5->domain = 0;
  *(_QWORD *)&a5->error = 0;
  *a6 = 0;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  v11 = 0;
  v12 = (CFStreamError *)((char *)this + 256);
  for (i = *((_DWORD *)this + 66); ; i = 0)
  {
    v14 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    if (i || (*((_DWORD *)this + 62) & 4) != 0 || *((_QWORD *)this + 29) && *((uint64_t *)this + 28) > 0)
      goto LABEL_28;
    Current = CFRunLoopGetCurrent();
    context.version = 0;
    context.info = Current;
    memset(&context.retain, 0, 56);
    context.perform = (void (__cdecl *)(void *))emptyPerform;
    v16 = CFGetAllocator((char *)this - 16);
    v17 = CFRunLoopSourceCreate(v16, 0, &context);
    *((_QWORD *)this + 72) = v17;
    if (!v17)
    {
      *((_QWORD *)this + 32) = 1;
      *((_DWORD *)this + 66) = 12;
      v27 = *((unsigned int *)this + 62);
      v14 = v27 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if ((v27 & 0x800000) == 0)
        goto LABEL_29;
LABEL_32:
      v28 = (__CFData *)*((_QWORD *)this + 29);
      if (v28)
      {
        MutableBytePtr = CFDataGetMutableBytePtr(v28);
        v30 = *((_QWORD *)this + 28);
        if (v30 >= a4)
          v11 = a4;
        else
          v11 = *((_QWORD *)this + 28);
        *((_QWORD *)this + 28) = v30 - v11;
        memmove(a3, MutableBytePtr, v11);
        memmove(MutableBytePtr, &MutableBytePtr[v11], *((_QWORD *)this + 28));
        bzero(&MutableBytePtr[*((_QWORD *)this + 28)], 0x8000 - *((_QWORD *)this + 28));
        if ((*((_DWORD *)this + 62) & 0x2000) != 0 && !*((_QWORD *)this + 28))
        {
          SocketStream::securityBufferedRead_NoLock(this);
          if (v11)
            goto LABEL_39;
        }
        else if (v11)
        {
LABEL_39:
          v31 = *((unsigned int *)this + 62);
          if ((v31 & 0x2000000) != 0)
          {
            v32 = v31 & 0xFFFFFFFFFDFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
            *((_DWORD *)this + 62) = v31 & 0xFDFFFFFF;
            *((_WORD *)this + 126) = WORD2(v32);
            v33 = (__CFSocket *)*((_QWORD *)this + 36);
            if (v33)
            {
              if (CFSocketIsValid(v33))
                CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
            }
          }
          goto LABEL_48;
        }
      }
      if (*((_DWORD *)this + 66) || (*((_DWORD *)this + 62) & 0x100000) != 0)
      {
        v11 = 0;
      }
      else
      {
        v11 = 0;
        *((_QWORD *)this + 32) = 1;
        *((_DWORD *)this + 66) = 35;
      }
      goto LABEL_48;
    }
    valuePtr = 0.0;
    Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA8A8);
    if (Value && CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr) && (v19 = valuePtr, valuePtr <= 75.0))
    {
      v20 = *((double *)this + 45);
      if (v20 > 0.0 && valuePtr == 0.0)
      {
        valuePtr = *((double *)this + 45);
        v19 = v20;
      }
      if (v19 == 0.0)
      {
        v21 = 1.79769313e308;
        goto LABEL_19;
      }
    }
    else
    {
      valuePtr = 75.0;
    }
    v21 = CFAbsoluteTimeGetCurrent() + valuePtr;
LABEL_19:
    _SchedulesAddRunLoopAndMode(*((const __CFArray **)this + 38), Current, CFSTR("_kCFStreamSocketReadPrivateMode"));
    v22 = *((_QWORD *)this + 41);
    v57 = Current;
    v58 = 0x1EDCFB168;
    v61.length = *(_QWORD *)(v22 + 24);
    v61.location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v22 + 16), v61, (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction, &v57);
    CFRunLoopAddSource(Current, *((CFRunLoopSourceRef *)this + 72), CFSTR("_kCFStreamSocketReadPrivateMode"));
    do
    {
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
      CFRunLoopRunInMode(CFSTR("_kCFStreamSocketReadPrivateMode"), valuePtr, 1u);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
      if (*((_DWORD *)this + 66))
        break;
      if ((*((_DWORD *)this + 62) & 4) != 0)
        break;
      valuePtr = v21 - CFAbsoluteTimeGetCurrent();
    }
    while (valuePtr > 0.0);
    CFRunLoopRemoveSource(Current, *((CFRunLoopSourceRef *)this + 72), CFSTR("_kCFStreamSocketReadPrivateMode"));
    v23 = *((_QWORD *)this + 41);
    v57 = Current;
    v58 = 0x1EDCFB168;
    v62.length = *(_QWORD *)(v23 + 24);
    v62.location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v23 + 16), v62, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction, &v57);
    _SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 38), Current, CFSTR("_kCFStreamSocketReadPrivateMode"));
    v24 = (const void *)*((_QWORD *)this + 72);
    *((_QWORD *)this + 72) = 0;
    if (v24)
      CFRelease(v24);
    v25 = *((unsigned int *)this + 62);
    v14 = v25 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    if ((v25 & 4) == 0 && !*((_DWORD *)this + 66))
    {
      *((_QWORD *)this + 32) = 1;
      *((_DWORD *)this + 66) = 60;
    }
LABEL_28:
    if ((v14 & 0x800000) != 0)
      goto LABEL_32;
LABEL_29:
    v26 = *((_DWORD *)this + 66);
    if (!v26)
    {
      v11 = SocketStream::recvBytes(this, a3, a4, (CFStreamError *)this + 16);
LABEL_48:
      v26 = *((_DWORD *)this + 66);
      v14 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    }
    v34 = v14 & 0xFFFFFFFFFFFFFFFBLL;
    *((_DWORD *)this + 62) = v34;
    *((_WORD *)this + 126) = WORD2(v34);
    if (v26 != 35)
      break;
    if (v12->domain != 1)
      break;
    v35 = (__CFSocket *)*((_QWORD *)this + 36);
    if (!v35 || !CFSocketIsValid(v35))
      break;
    CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
    v12->domain = 0;
    *((_QWORD *)this + 33) = 0;
  }
  if (v11 < 1)
  {
    if (*((_DWORD *)this + 66))
    {
      *a5 = *v12;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v38 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v52 = *((_QWORD *)this + 70);
        v53 = (void *)*((_QWORD *)this + 32);
        v54 = *((_DWORD *)this + 66);
        LODWORD(context.version) = 134218496;
        *(CFIndex *)((char *)&context.version + 4) = v52;
        WORD2(context.info) = 2048;
        *(void **)((char *)&context.info + 6) = v53;
        HIWORD(context.retain) = 1024;
        LODWORD(context.release) = v54;
        _os_log_error_impl(&dword_183ECA000, v38, OS_LOG_TYPE_ERROR, "SocketStream read error [%p]: %ld %d", (uint8_t *)&context, 0x1Cu);
      }
      WeakRetained = objc_loadWeakRetained((id *)this + 35);
      if (WeakRetained)
      {
        v40 = WeakRetained;
        if ((*((_DWORD *)this + 62) & 0x400) != 0)
          _CFWriteStreamSignalEventDelayed();
        CFRelease(v40);
      }
      *v55 = 1;
      v41 = (__CFSocket *)*((_QWORD *)this + 36);
      if (v41 && CFSocketIsValid(v41))
        CFSocketDisableCallBacks(*((CFSocketRef *)this + 36), 9uLL);
      v11 = -1;
    }
    else if (!v11)
    {
      *v55 = 1;
      v47 = (__CFSocket *)*((_QWORD *)this + 36);
      if (v47 && CFSocketIsValid(v47))
        CFSocketDisableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
      v11 = 0;
    }
    goto LABEL_100;
  }
  SocketStream::touchWatchdogTimer_Locked(this, 0);
  v36 = *((_DWORD *)this + 103);
  if (!v36)
  {
    v42 = *((unsigned int *)this + 62);
    if ((v42 & 0x800000) == 0)
      goto LABEL_78;
    if (*((_QWORD *)this + 29) && *((uint64_t *)this + 28) >= 1)
    {
      v43 = 0;
      v44 = v42 & 0xFFFFFFFFFFFFFFDFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      *((_WORD *)this + 126) = WORD2(v44);
      *((_DWORD *)this + 62) = v44 | 4;
    }
    else
    {
      v43 = 1;
      if ((v42 & 0x100000) != 0)
      {
        *v55 = 1;
        v48 = (__CFSocket *)*((_QWORD *)this + 36);
        if (v48 && CFSocketIsValid(v48))
          CFSocketDisableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
        v43 = 0;
      }
    }
    v49 = *((unsigned int *)this + 62);
    v46 = v49 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    if ((v49 & 0x100000) != 0 || *((_QWORD *)this + 29) && *((uint64_t *)this + 28) >= 1)
    {
LABEL_95:
      v50 = v46 & 0xFFFFFFFFFFFFFFDFLL;
      *((_WORD *)this + 126) = WORD2(v50);
      *((_DWORD *)this + 62) = v50 | 4;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
      if ((v43 & 1) != 0)
        goto LABEL_101;
    }
    _CFReadStreamSignalEventDelayed();
    goto LABEL_101;
  }
  v37 = 0;
  while (((v36 >> v37) & 1) == 0)
  {
    if (++v37 == 8)
      goto LABEL_100;
  }
  if ((_DWORD)v37 == 5)
  {
LABEL_78:
    v45 = (__CFSocket *)*((_QWORD *)this + 36);
    if (!v45 || !CFSocketIsValid(v45) || _CFSocketCan(*((__CFSocket **)this + 36), 0))
    {
      v46 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      goto LABEL_95;
    }
    CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
  }
LABEL_100:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
LABEL_101:
  if (nw_settings_get_signposts_enabled())
    kdebug_trace();
  return v11;
}

void SocketStream::securityBufferedRead_NoLock(SocketStream *this)
{
  __CFData *Mutable;
  uint64_t *v3;
  uint64_t v4;
  const __CFAllocator *v5;
  UInt8 *MutableBytePtr;
  int v7;
  uint64_t v8;
  int v9;
  UInt8 *v10;
  UInt8 *v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int64_t v16;
  unint64_t v17;
  IOLogger *v18;
  BOOL v19;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  CFArrayRef v24;
  __CFSocket *v25;
  char *v26;
  int v27;
  unint64_t v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  _QWORD v33[5];
  CFArrayRef names;
  size_t processed;

  Mutable = (__CFData *)*((_QWORD *)this + 29);
  if (Mutable)
  {
    v3 = (uint64_t *)((char *)this + 224);
    v4 = *((_QWORD *)this + 28);
    if (v4 >= 0x8000)
    {
LABEL_59:
      v30 = *((_DWORD *)this + 62);
      v26 = (char *)this + 248;
      v28 = v30 & 0xFFFFFFDF | ((unint64_t)*((unsigned __int16 *)v26 + 2) << 32);
      v29 = v30 & 0xFFFFFFDB | 4;
      goto LABEL_60;
    }
  }
  else
  {
    v5 = CFGetAllocator((char *)this - 16);
    Mutable = CFDataCreateMutable(v5, 0x8000);
    *((_QWORD *)this + 28) = 0;
    *((_QWORD *)this + 29) = Mutable;
    v3 = (uint64_t *)((char *)this + 224);
    if (!Mutable)
    {
      *((_QWORD *)this + 32) = 1;
      *((_DWORD *)this + 66) = 12;
      return;
    }
    v4 = 0;
  }
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  v7 = *((_DWORD *)this + 66);
  v8 = *((_QWORD *)this + 28);
  if (v7)
  {
    v9 = 0;
    v7 = 0;
  }
  else
  {
    v10 = MutableBytePtr;
    v9 = 0;
    v32 = (int)*MEMORY[0x1E0C9B298];
    do
    {
      if (v8 >= 0x8000)
        break;
      v11 = &v10[v8];
      v12 = 0x8000 - v8;
      processed = 0;
      while (1)
      {
        while (1)
        {
          v13 = SSLRead(*((SSLContextRef *)this + 37), v11, v12, &processed);
          v14 = *((unsigned int *)this + 62);
          v15 = v14 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          v16 = processed;
          if ((v14 & 0x40000) == 0 && processed)
          {
            v17 = HIDWORD(v15);
            v15 |= 0x40000uLL;
            *((_WORD *)this + 126) = v17;
            *((_DWORD *)this + 62) = v15;
          }
          v18 = (IOLogger *)*((_QWORD *)this + 27);
          if (v18)
            v19 = (_DWORD)v13 == 0;
          else
            v19 = 0;
          if (v19 && v16 != 0)
          {
            IOLogger::logBytesRead(v18, 1, v11, v16);
            v9 = 0;
            v7 = 0;
            v16 = processed;
            goto LABEL_37;
          }
          if ((int)v13 > -9842)
            break;
          if ((_DWORD)v13 != -9842)
            goto LABEL_33;
          *((_WORD *)this + 126) = WORD2(v15);
          *((_DWORD *)this + 62) = v15 | 0x20000000;
          v21 = (*(uint64_t (**)(SocketStream *))(*(_QWORD *)this + 184))(this);
          if (v21)
          {
            v23 = v21;
            names = 0;
            if (SSLCopyDistinguishedNames(*((SSLContextRef *)this + 37), &names))
            {
              v24 = names;
              names = 0;
              if (v24)
                CFRelease(v24);
            }
            CFRetain((char *)this - 16);
            v33[0] = MEMORY[0x1E0C809B0];
            v33[1] = 3221225472;
            v33[2] = ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke;
            v33[3] = &__block_descriptor_40_e20_v16__0____CFArray__8l;
            v33[4] = this;
            (*(void (**)(uint64_t, CFArrayRef, _QWORD *))(*(_QWORD *)v23 + 48))(v23, names, v33);
            if (names)
              CFRelease(names);
            (*(void (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23);
            SocketStream::unscheduleFromSSL(this);
            goto LABEL_47;
          }
          v22 = *((_DWORD *)this + 62) & 0xDFFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          *((_DWORD *)this + 62) &= ~0x20000000u;
          *((_WORD *)this + 126) = WORD2(v22);
        }
        if ((int)v13 > -9807)
          break;
        if ((_DWORD)v13 != -9841)
          goto LABEL_33;
        if (SocketStream::doSettingsOverrideTrustEvaluation((CFDictionaryRef *)this))
        {
          *((_QWORD *)this + 32) = v32;
          *((_DWORD *)this + 66) = -9807;
LABEL_47:
          v9 = 0;
          v7 = 0;
          v8 = *v3;
          goto LABEL_48;
        }
      }
      if ((v13 + 9806) < 2)
      {
        v7 = 0;
        v9 = 1;
      }
      else if ((_DWORD)v13 == -9803)
      {
        v9 = 0;
        v7 = 1;
      }
      else
      {
        if ((_DWORD)v13)
        {
LABEL_33:
          if (!*((_DWORD *)this + 66))
          {
            v31 = translateSSLContextError(*((SSLContext **)this + 37), v13);
            *((_QWORD *)this + 32) = v32;
            *((_DWORD *)this + 66) = v31;
            goto LABEL_47;
          }
        }
        v9 = 0;
        v7 = 0;
      }
LABEL_37:
      v8 = *v3;
      if (v16 < 1)
        break;
      v8 += v16;
      *((_QWORD *)this + 28) = v8;
    }
    while (!*((_DWORD *)this + 66));
  }
LABEL_48:
  if (v8 | v4 || (*((_DWORD *)this + 62) & 0x100000) != 0)
  {
    if (!v7)
      goto LABEL_56;
  }
  else if ((*((_DWORD *)this + 62) & 0x60000000) != 0)
  {
    goto LABEL_56;
  }
  v25 = (__CFSocket *)*((_QWORD *)this + 36);
  if (v25)
  {
    if (CFSocketIsValid(v25))
      CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
  }
LABEL_56:
  if (!v9)
  {
    if (!*v3)
      return;
    goto LABEL_59;
  }
  v27 = *((_DWORD *)this + 62);
  v26 = (char *)this + 248;
  v28 = v27 & 0xFFFFFFDF | ((unint64_t)*((unsigned __int16 *)v26 + 2) << 32);
  v29 = v27 & 0xFFEFFFDB | 0x100004;
LABEL_60:
  *(_DWORD *)v26 = v29;
  *((_WORD *)v26 + 2) = WORD2(v28);
}

void SocketStream::touchWatchdogTimer_Locked(SocketStream *this, int a2)
{
  double v2;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  double v8;
  NSObject *v9;
  dispatch_time_t v10;
  _QWORD v11[5];
  _QWORD handler[5];

  v2 = *((double *)this + 45);
  if (v2 > 0.0)
  {
    if (!*((_QWORD *)this + 48))
    {
      *((_QWORD *)this + 48) = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)this + 71));
      CFRetain((char *)this - 16);
      v5 = MEMORY[0x1E0C809B0];
      v6 = *((_QWORD *)this + 48);
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3221225472;
      handler[2] = ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke;
      handler[3] = &__block_descriptor_40_e5_v8__0l;
      handler[4] = this;
      dispatch_source_set_event_handler(v6, handler);
      v7 = *((_QWORD *)this + 48);
      v11[0] = v5;
      v11[1] = 3221225472;
      v11[2] = ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke_2;
      v11[3] = &__block_descriptor_40_e5_v8__0l;
      v11[4] = this;
      dispatch_source_set_cancel_handler(v7, v11);
      dispatch_resume(*((dispatch_object_t *)this + 48));
      v2 = *((double *)this + 45);
    }
    v8 = 10.0;
    if (v2 < 10.0)
      v8 = v2;
    if (a2)
      v2 = v8;
    v9 = *((_QWORD *)this + 48);
    v10 = dispatch_time(0, (uint64_t)(v2 * 1000000000.0));
    dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  }
}

uint64_t SocketStream::securitySetInfo_NoLock(CFDictionaryRef *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  const __CFBoolean *Value;
  const __CFAllocator *v6;
  _BOOL4 v7;
  uint64_t v8;
  SSLContextRef v9;
  SSLContext *v10;
  const void *v11;
  const void **v12;
  const void *v13;
  CFTypeID v14;
  uint64_t v15;
  unint64_t v16;
  const void *v17;
  const void *v18;
  CFTypeID v19;
  uint64_t v20;
  unint64_t v21;
  const void *v22;
  const void *v23;
  CFTypeID v24;
  uint64_t v25;
  unint64_t v26;
  const __CFString *v27;
  const __CFData *v28;
  const __CFData *v29;
  const UInt8 *BytePtr;
  unint64_t Length;
  OSStatus v32;
  const __CFNumber *v33;
  const __CFNumber *v34;
  SSLProtocol v35;
  int v36;
  _BOOL4 v37;
  const __CFString *v38;
  int v39;
  int ExactString;
  SSLProtocol v41;
  SSLProtocol v42;
  const __CFBoolean *v43;
  const __CFBoolean *v44;
  unint64_t v45;
  const __CFBoolean *v46;
  unint64_t v47;
  const void *v48;
  unint64_t v49;
  const __CFData *v50;
  const __CFData *v51;
  const __CFData *v52;
  int v53;
  const __CFData *v54;
  const __CFData *v55;
  const UInt8 *v56;
  unint64_t v57;
  const __CFBoolean *v58;
  uint64_t v60;
  const __CFBoolean *v61;
  const __CFBoolean *v62;
  const __CFBoolean *v63;
  const __CFBoolean *v64;
  const __CFArray *v65;
  const __CFString *v66;
  const void *v67;
  OSStatus v68;
  const __CFArray *Info;
  const __CFString *ValueAtIndex;
  const void *v71;
  const __CFBoolean *v72;
  int v73;
  const __CFData *v74;
  const __CFDictionary *v75;
  const __CFData *v76;
  const __CFAllocator *valuePtr;
  size_t v78;
  void *ptr;
  UInt8 v80[1024];
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  if (!SocketStream::securitySetContext_NoLock((SocketStream *)this, 0, a3))
    return 0;
  if (a2)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EDCFC438);
    v6 = CFGetAllocator(this - 2);
    if (Value)
      v7 = CFBooleanGetValue(Value) != 0;
    else
      v7 = 0;
    v9 = SSLCreateContext(v6, (SSLProtocolSide)!v7, kSSLStreamType);
    if (v9)
    {
      v10 = v9;
      v11 = CFDictionaryGetValue(a2, &unk_1EDCFAFE0);
      v12 = (const void **)MEMORY[0x1E0C9AE50];
      if (v11)
      {
        v13 = v11;
        v14 = CFGetTypeID(v11);
        if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&valuePtr, 2u);
        }
        if (*v12 == v13)
        {
          v15 = *((unsigned int *)this + 62);
          v16 = v15 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x40000000000;
          *((_DWORD *)this + 62) = v15;
          *((_WORD *)this + 126) = WORD2(v16);
        }
      }
      v17 = CFDictionaryGetValue(a2, &unk_1EDCFAFA8);
      v18 = v17;
      if (v17)
      {
        v19 = CFGetTypeID(v17);
        if (v19 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&valuePtr, 2u);
        }
        if (*v12 == v18)
        {
          v20 = *((unsigned int *)this + 62);
          v21 = v20 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x80000000000;
          *((_DWORD *)this + 62) = v20;
          *((_WORD *)this + 126) = WORD2(v21);
        }
      }
      v22 = CFDictionaryGetValue(a2, &unk_1EDCFAF70);
      v23 = v22;
      if (v22)
      {
        v24 = CFGetTypeID(v22);
        if (v24 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr) = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&valuePtr, 2u);
        }
        if (*v12 == v23)
        {
          v25 = *((unsigned int *)this + 62);
          v26 = v25 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x10000000000;
          *((_DWORD *)this + 62) = v25;
          *((_WORD *)this + 126) = WORD2(v26);
        }
      }
      v27 = (const __CFString *)CFDictionaryGetValue(a2, &unk_1EDCFC550);
      if (v27 && SSLSetSessionConfig(v10, v27))
        goto LABEL_96;
      v28 = (const __CFData *)CFDictionaryGetValue(a2, &unk_1EDCFAF00);
      v29 = v28;
      if (v28)
      {
        BytePtr = CFDataGetBytePtr(v28);
        Length = CFDataGetLength(v29);
        v32 = SSLSetEnabledCiphers(v10, (const SSLCipherSuite *)BytePtr, Length >> 1);
        if (v32)
          CFLog();
      }
      else
      {
        v32 = 0;
      }
      v33 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_1EDCFB3D0);
      v34 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_1EDCFB398);
      if ((unint64_t)v33 | (unint64_t)v34)
      {
        if (!v33)
          goto LABEL_41;
        valuePtr = 0;
        CFNumberGetValue(v33, kCFNumberCFIndexType, &valuePtr);
        if ((int)valuePtr <= 4)
          v35 = kTLSProtocol1;
        else
          v35 = (int)valuePtr;
        if (SSLSetProtocolVersionMin(v10, v35))
          goto LABEL_96;
        v36 = setTLSMaxVersion_ifNeeded(v27, v10, v34, v35);
        v8 = 0;
        if (!v36)
        {
          v32 = 0;
LABEL_41:
          if (v34)
          {
            valuePtr = 0;
            CFNumberGetValue(v34, kCFNumberCFIndexType, &valuePtr);
            if ((_DWORD)valuePtr)
            {
              valuePtr = 0;
              CFNumberGetValue(v34, kCFNumberCFIndexType, &valuePtr);
              v8 = 0;
              if (SSLSetProtocolVersionMax(v10, (SSLProtocol)valuePtr))
                goto LABEL_97;
            }
            v32 = 0;
          }
          goto LABEL_68;
        }
LABEL_97:
        CFRelease(v10);
        return v8;
      }
      v37 = v27 != 0;
      v38 = (const __CFString *)CFDictionaryGetValue(a2, &unk_1EDCFC470);
      if (v38)
        v39 = 1;
      else
        v39 = v37;
      if (!v39)
        v38 = (const __CFString *)&unk_1EDCFC1D0;
      if (!v38)
        goto LABEL_68;
      ExactString = _findExactString(v38, 2u);
      v41 = kTLSProtocol1;
      v42 = kTLSProtocol12;
      if (ExactString <= 239366374)
      {
        if (ExactString == 235147427)
        {
          v8 = 1;
          goto LABEL_97;
        }
        if (ExactString == 236204212 || ExactString == 237252805)
          goto LABEL_65;
      }
      else
      {
        if (ExactString <= 241463565)
        {
          if (ExactString != 239366375)
          {
            if (ExactString == 240455929)
              v42 = kTLSProtocol1;
            goto LABEL_66;
          }
          goto LABEL_65;
        }
        if (ExactString == 242512160)
        {
          v41 = kTLSProtocol12;
          goto LABEL_65;
        }
        if (ExactString == 241463566)
        {
          v41 = kTLSProtocol11;
LABEL_65:
          v42 = v41;
        }
      }
LABEL_66:
      if (SSLSetProtocolVersionMax(v10, v42))
        goto LABEL_96;
      v32 = SSLSetProtocolVersionMin(v10, v41);
LABEL_68:
      v43 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EDCFB280);
      if (v43 && CFBooleanGetValue(v43))
        SSLSetSessionOption(v10, kSSLSessionOptionFallback, 1u);
      v44 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EDCFB328);
      if (v44 && CFBooleanGetValue(v44))
      {
        *((_DWORD *)this + 62) |= 0x8000u;
      }
      else
      {
        v45 = (_DWORD)this[31] & 0xFFFF7FFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        *((_DWORD *)this + 62) &= ~0x8000u;
        *((_WORD *)this + 126) = WORD2(v45);
      }
      v46 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EDCFB360);
      if (v46 && CFBooleanGetValue(v46))
      {
        *((_DWORD *)this + 62) |= 0x18000u;
        SSLSetSessionOption(v10, kSSLSessionOptionFalseStart, 1u);
      }
      else
      {
        v47 = (_DWORD)this[31] & 0xFFFEFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        *((_DWORD *)this + 62) &= ~0x10000u;
        *((_WORD *)this + 126) = WORD2(v47);
      }
      v48 = CFDictionaryGetValue(a2, &unk_1EDCFB2B8);
      if (v48 && CFEqual(v48, (CFTypeRef)*MEMORY[0x1E0C9AE40]))
      {
        *((_DWORD *)this + 62) |= 0x80000u;
      }
      else
      {
        v49 = (_DWORD)this[31] & 0xFFF7FFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        *((_DWORD *)this + 62) &= ~0x80000u;
        *((_WORD *)this + 126) = WORD2(v49);
      }
      v50 = (const __CFData *)CFDictionaryGetValue(a2, &unk_1EDCFC518);
      v51 = (const __CFData *)CFDictionaryGetValue(a2, &unk_1EDCFC4E0);
      if (v50)
      {
        v52 = v51;
        if (v51)
        {
          CFDataGetBytePtr(v50);
          CFDataGetLength(v50);
          if (SSLSetPSKSharedSecret()
            || (CFDataGetBytePtr(v52), CFDataGetLength(v52), SSLSetPSKIdentity()))
          {
            CFLog();
            goto LABEL_96;
          }
          v32 = 0;
        }
      }
      if (v29 || (v54 = (const __CFData *)CFDictionaryGetValue(a2, &unk_1EDCFC400), (v55 = v54) == 0))
      {
        v53 = 1;
      }
      else
      {
        v56 = CFDataGetBytePtr(v54);
        v57 = CFDataGetLength(v55);
        v32 = SSLSetEnabledCiphers(v10, (const SSLCipherSuite *)v56, v57 >> 1);
        v53 = 0;
      }
      v58 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EDCFB248);
      if (v58)
      {
        CFBooleanGetValue(v58);
        SSLSetDHEEnabled();
      }
      if (v32)
        goto LABEL_96;
      v60 = (*((uint64_t (**)(CFDictionaryRef *))*this + 23))(this);
      if (v60)
      {
        SSLSetSessionOption(v10, kSSLSessionOptionBreakOnCertRequested, 1u);
        SSLSetSessionOption(v10, kSSLSessionOptionBreakOnServerAuth, 1u);
        (*(void (**)(uint64_t))(*(_QWORD *)v60 + 24))(v60);
      }
      v61 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EDCFC358);
      if (v61)
      {
        if (CFBooleanGetValue(v61) && _SSLSetAllowsExpiredCerts())
          goto LABEL_96;
      }
      v62 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EDCFC390);
      if (v62)
      {
        if (CFBooleanGetValue(v62) && _SSLSetAllowsExpiredRoots())
          goto LABEL_96;
      }
      v63 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EDCFC320);
      if (v63)
      {
        if (CFBooleanGetValue(v63) && _SSLSetAllowsAnyRoot())
          goto LABEL_96;
      }
      v64 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EDCFC588);
      if (v64)
      {
        if (!CFBooleanGetValue(v64) && SSLSetSessionOption(v10, kSSLSessionOptionBreakOnServerAuth, 1u))
          goto LABEL_96;
      }
      v65 = (const __CFArray *)CFDictionaryGetValue(a2, &unk_1EDCFC3C8);
      if (v65)
      {
        if (SSLSetCertificate(v10, v65))
          goto LABEL_96;
      }
      v66 = (const __CFString *)CFDictionaryGetValue(a2, &unk_1EDCFC4A8);
      if (!v66)
      {
        v66 = (const __CFString *)CFDictionaryGetValue(this[42], &unk_1EDCFA9C0);
        v67 = CFDictionaryGetValue(this[42], &unk_1EDCFBDE0);
        if (!v66)
        {
          if (v67)
          {
            Info = (const __CFArray *)CFHostGetInfo((uint64_t)v67, 1, 0);
            if (!Info)
              goto LABEL_132;
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(Info, 0);
          }
          else
          {
            v71 = CFDictionaryGetValue(this[42], &unk_1EDCFBE50);
            if (!v71)
              goto LABEL_132;
            ValueAtIndex = (const __CFString *)CFNetServiceGetInfo((uint64_t)v71, 5u);
          }
          v66 = ValueAtIndex;
          if (!ValueAtIndex)
            goto LABEL_132;
        }
      }
      if (CFEqual(v66, (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
      {
        if (!SSLSetPeerDomainName(v10, 0, 0))
          goto LABEL_132;
LABEL_96:
        v8 = 0;
        goto LABEL_97;
      }
      valuePtr = CFGetAllocator(this[42]);
      v78 = 1023;
      ptr = _CFStringGetOrCreateCString(valuePtr, v66, v80, (uint64_t *)&v78, 0x8000100u);
      v68 = SSLSetPeerDomainName(v10, (const char *)ptr, v78);
      if (ptr && v80 != ptr)
        CFAllocatorDeallocate(valuePtr, ptr);
      if (v68)
        goto LABEL_96;
LABEL_132:
      if (v29)
        goto LABEL_145;
      v72 = (const __CFBoolean *)CFDictionaryGetValue(this[42], &unk_1EDCFAAD8);
      v73 = v72 ? 1 : v53;
      if (v73 != 1)
        goto LABEL_145;
      if (v72)
        CFBooleanGetValue(v72);
      if (!SSLSetAllowAnonymousCiphers())
      {
LABEL_145:
        v74 = (const __CFData *)CFDictionaryGetValue(a2, &unk_1EDCFC0B8);
        v76 = v74;
        if (!v74 || (CFDataGetBytePtr(v74), CFDataGetLength(v76), !_SSLSetDiffieHellmanParams()))
        {
          v8 = SocketStream::securitySetContext_NoLock((SocketStream *)this, v10, v75);
          goto LABEL_97;
        }
      }
      goto LABEL_96;
    }
    return 0;
  }
  return 1;
}

void sub_183FA81F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  void *v13;

  if (ptr)
  {
    if (v13 != ptr)
      CFAllocatorDeallocate(allocator, ptr);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SocketStream::securitySetContext_NoLock(SocketStream *this, SSLContextRef context, const __CFDictionary *a3)
{
  SSLContext *v5;
  OSStatus v6;
  uint64_t result;
  SSLContextRef v8;
  uint64_t v9;
  OSStatus v10;
  const __CFArray *Value;
  const __CFArray *v12;
  int Count;
  CFIndex v14;
  uint64_t v15;
  const __CFString *ValueAtIndex;
  int Length;
  std::string::value_type v18;
  const __CFAllocator *v19;
  _OWORD *v20;
  CFAllocatorRef v21;
  uint64_t v22;
  uint64_t v23;
  __int128 *v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  std::string::value_type __s;
  std::string v30;
  SSLSessionState state[8];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = (SSLContext *)*((_QWORD *)this + 37);
  if (v5)
  {
    state[0] = kSSLIdle;
    v6 = SSLGetSessionState(v5, state);
    if (v6 | state[0])
      return 0;
    v8 = (SSLContextRef)*((_QWORD *)this + 37);
    if (v8 != context)
    {
      *((_QWORD *)this + 37) = 0;
      if (v8)
        CFRelease(v8);
    }
  }
  else if (context)
  {
    *((_QWORD *)this + 37) = 0;
  }
  v9 = *((_QWORD *)this + 75);
  if (v9)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    *((_QWORD *)this + 75) = 0;
  }
  if (context)
  {
    v10 = SSLSetIOFuncs(context, (SSLReadFunc)SocketStream::_SecurityReadFunc_NoLock, (SSLWriteFunc)SocketStream::_SecurityWriteFunc_NoLock);
    *((_DWORD *)this + 66) = v10;
    if (v10)
      goto LABEL_24;
    v10 = SSLSetConnection(context, this);
    *((_DWORD *)this + 66) = v10;
    if (v10)
      goto LABEL_24;
    Value = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA6E8);
    if (Value)
    {
      v12 = Value;
      SSLSetNPNFunc();
      memset(&v30, 0, sizeof(v30));
      Count = CFArrayGetCount(v12);
      if (Count >= 1)
      {
        v14 = 0;
        v15 = Count;
        do
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, v14);
          Length = CFStringGetLength(ValueAtIndex);
          v18 = Length;
          if (Length <= 31 && CFStringGetCString(ValueAtIndex, (char *)state, 32, 0x600u))
          {
            __s = v18;
            std::string::append(&v30, &__s, 1uLL);
            std::string::append(&v30, (const std::string::value_type *)state);
          }
          ++v14;
        }
        while (v15 != v14);
      }
      SSLSetALPNFunc();
      SSLSetALPNData();
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }
    v10 = *((_DWORD *)this + 66);
    if (v10)
    {
LABEL_24:
      result = 0;
      *((_QWORD *)this + 32) = (int)*MEMORY[0x1E0C9B298];
      *((_DWORD *)this + 66) = v10;
      return result;
    }
    if (*((_QWORD *)this + 27))
    {
      v19 = CFGetAllocator((char *)this - 16);
      v20 = CFAllocatorAllocate(v19, 96, 0);
      v20[4] = 0u;
      v20[5] = 0u;
      v20[2] = 0u;
      v20[3] = 0u;
      *v20 = 0u;
      v20[1] = 0u;
      v21 = CFGetAllocator((char *)this - 16);
      v22 = *((_QWORD *)this + 27);
      v23 = *(_QWORD *)(v22 + 272);
      v24 = (__int128 *)(v22 + 280);
      v25 = *(_QWORD *)(v22 + 328);
      v27 = v24[1];
      v26 = v24[2];
      v28 = *v24;
      *(_QWORD *)v20 = off_1E14E4BE8;
      *((_QWORD *)v20 + 1) = v21;
      *((_QWORD *)v20 + 3) = 0;
      *((_QWORD *)v20 + 4) = v23;
      *(_OWORD *)((char *)v20 + 40) = v28;
      *(_OWORD *)((char *)v20 + 56) = v27;
      *(_OWORD *)((char *)v20 + 72) = v26;
      *((_QWORD *)v20 + 11) = v25;
      *((_QWORD *)v20 + 2) = 0;
      *((_QWORD *)this + 75) = v20;
    }
    SocketStream::addHandshake_NoLock((uint64_t)this, 7);
    *((_QWORD *)this + 37) = CFRetain(context);
  }
  else
  {
    SocketStream::removeHandshake_NoLock((uint64_t)this, 7);
  }
  return 1;
}

void sub_183FA84FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SocketStream::copyConnectionEstablishment(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = this + 106;
  os_unfair_lock_lock(this + 106);
  v3 = *(_QWORD *)&this[104]._os_unfair_lock_opaque;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
  os_unfair_lock_unlock(v2);
  return v3;
}

void SocketStream::removeHandshake_NoLock(uint64_t a1, char a2)
{
  int v3;
  __CFSocket *v4;
  int v5;
  _BOOL4 v6;
  id WeakRetained;
  const void *v8;
  int v9;
  __CFSocket *v10;

  v3 = *(_DWORD *)(a1 + 248);
  *(_DWORD *)(a1 + 412) &= ~(1 << a2);
  *(_DWORD *)(a1 + 248) = v3 & 0xFDFFFFF3;
  v4 = *(__CFSocket **)(a1 + 288);
  if (!v4)
    return;
  if (!CFSocketIsValid(v4))
    return;
  v5 = *(_DWORD *)(a1 + 248);
  if ((v5 & 2) == 0)
    return;
  if ((v5 & 0x800000) == 0 || *(_DWORD *)(a1 + 412))
    goto LABEL_24;
  v6 = *(_QWORD *)(a1 + 232) && *(uint64_t *)(a1 + 224) >= 1;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 272));
  v8 = WeakRetained;
  if ((*(_DWORD *)(a1 + 248) >> 20) & 1 | v6)
  {
    if (!WeakRetained)
      goto LABEL_24;
    if ((*(_DWORD *)(a1 + 248) & 0x200) == 0)
      goto LABEL_23;
LABEL_13:
    _CFReadStreamSignalEventDelayed();
LABEL_23:
    CFRelease(v8);
    goto LABEL_24;
  }
  if ((*(_DWORD *)(a1 + 248) & 0x2000) != 0)
  {
    SocketStream::securityBufferedRead_NoLock((SocketStream *)a1);
    v9 = *(_DWORD *)(a1 + 248);
    if ((v9 & 4) != 0)
    {
      if (!v8)
        goto LABEL_24;
    }
    else if ((v9 & 0x100000) == 0 || !v8)
    {
      goto LABEL_15;
    }
    if ((v9 & 0x200) == 0)
      goto LABEL_23;
    goto LABEL_13;
  }
LABEL_15:
  if (v8)
    goto LABEL_23;
LABEL_24:
  v10 = *(__CFSocket **)(a1 + 288);
  if (v10)
  {
    if (CFSocketIsValid(v10))
      CFSocketEnableCallBacks(*(CFSocketRef *)(a1 + 288), 9uLL);
  }
}

void SocketStream::addHandshake_NoLock(uint64_t a1, int a2)
{
  uint64_t v3;
  unsigned int v4;
  __CFSocket *v5;

  v3 = 0;
  v4 = *(_DWORD *)(a1 + 412) | (1 << a2);
  *(_DWORD *)(a1 + 412) = v4;
  while (((v4 >> v3) & 1) == 0)
  {
    if (++v3 == 8)
    {
      LODWORD(v3) = 0;
      break;
    }
  }
  if ((_DWORD)v3 == a2)
  {
    *(_DWORD *)(a1 + 248) &= 0xFDFFFFF3;
    v5 = *(__CFSocket **)(a1 + 288);
    if (v5)
    {
      if (CFSocketIsValid(v5))
      {
        if ((*(_DWORD *)(a1 + 248) & 2) != 0)
          CFSocketEnableCallBacks(*(CFSocketRef *)(a1 + 288), 9uLL);
      }
    }
  }
}

void SocketStream::performHandshake(uint64_t a1)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  void *Value;
  __CFData *v5;
  const __CFData *v6;
  UInt8 *MutableBytePtr;
  CFIndex Length;
  int v9;
  int v10;
  __CFData *v11;
  const __CFData *v12;
  UInt8 *v13;
  CFIndex v14;
  uint64_t v15;
  int v16;
  __CFData *v17;
  __CFData *v18;
  const __CFData *v19;
  UInt8 *v20;
  CFIndex v21;
  CFIndex v22;
  uint64_t v23;
  SInt32 error;
  id WeakRetained;
  const void *v26;
  int v27;
  id v28;
  const void *v29;
  int v30;
  const __CFAllocator *v31;
  char *v32;
  char *v33;
  CFIndex v34;
  SInt32 v35;
  int v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  unint64_t v40;
  CFNA *v41;
  const char *v42;
  const __CFString *v43;
  const __CFString *v44;
  const __CFString *v45;
  CFComparisonResult v46;
  uint64_t v47;
  unint64_t v48;
  const __CFDictionary *v49;
  const __CFString *v50;
  const __CFString *v51;
  const __CFAllocator *v52;
  CFMutableDataRef Mutable;
  UInt8 *v54;
  const __CFDictionary *v55;
  const __CFString *v56;
  const __CFString *v57;
  const __CFAllocator *v58;
  CFMutableDataRef v59;
  UInt8 *v60;
  size_t v61;
  const unsigned __int8 *v62;
  uint64_t v63;
  uint64_t v64;
  size_t v65;
  const __CFAllocator *v66;
  CFMutableDataRef v67;
  const void *v68;
  size_t v69;
  const unsigned __int8 *v70;
  uint64_t v71;
  uint64_t v72;
  CFIndex v73;
  uint64_t v74;
  size_t v75;
  __CFSocket *v76;
  CFIndex v77;
  uint64_t v78;
  size_t v79;
  __CFSocket *v80;
  uint64_t v81;
  unint64_t v82;
  int v83;
  const __CFString *v84;
  const void *v85;
  const char *v86;
  const __CFData **v87;
  int v88;
  const void *v89;
  const void *v90;
  const __CFArray *Info;
  const __CFArray *ValueAtIndex;
  const __CFDictionary *v93;
  const __CFString *v94;
  CFStreamError *v95;
  const void *v96;
  const __CFString *v97;
  const __CFURL *v98;
  const __CFString *v99;
  uint64_t v100;
  char v101;
  UInt8 *v102;
  __CFSocket *v103;
  const __CFDictionary *v104;
  const void *v105;
  const void *v106;
  BOOL v107;
  __CFSocket *v108;
  CFHTTPMessageRef Empty;
  const UInt8 *v110;
  CFDataRef v111;
  __int128 v112;
  size_t v113;
  const unsigned __int8 *BytePtr;
  uint64_t v115;
  uint64_t v116;
  size_t v117;
  const __CFAllocator *v118;
  CFMutableDataRef v119;
  CFMutableDataRef v120;
  UInt8 *v121;
  __CFSocket *v122;
  __CFSocket *v123;
  CFStreamError v124;
  SSLContext *v125;
  const __CFAllocator *v126;
  CFStringRef v127;
  const __CFAllocator *v128;
  __CFData *v129;
  UInt8 *v130;
  const __CFArray *v131;
  const __CFArray *v132;
  const __CFAllocator *v133;
  CFIndex Count;
  CFIndex v135;
  uint64_t v136;
  const __CFData *v137;
  const UInt8 *v138;
  const __CFArray *v140;
  const __CFArray *v141;
  const __CFData *v142;
  UInt8 *v143;
  int v144;
  unint64_t v145;
  const __CFDictionary *v146;
  const __CFDictionary *v147;
  CFStreamError *v148;
  const void *v149;
  const void *v150;
  const __CFString *v151;
  const __CFAllocator *v152;
  CFStringRef v153;
  const __CFString *v154;
  CFSocketNativeHandle Native;
  const __CFAllocator *v156;
  CFStringRef v157;
  __CFSocket *v158;
  unint64_t v159;
  const __CFAllocator *v160;
  const __CFString *v161;
  const __CFAllocator *v162;
  NSObject *v163;
  uint64_t v164;
  uint64_t v165;
  unint64_t v166;
  uint64_t v167;
  int v168;
  uint64_t v169;
  const void *v170;
  const __CFDictionary *v171;
  const __CFDictionary *v172;
  const __CFDictionary *ATSVersion;
  const void *v174;
  CFArrayRef v175;
  const __CFDictionary *v176;
  const __CFAllocator *v177;
  __CFDictionary *MutableCopy;
  const __CFAllocator *v179;
  CFNumberRef v180;
  NSObject *v181;
  uint64_t v182;
  uint64_t v183;
  CFArrayRef v184;
  CFArrayRef v185;
  int v186;
  uint64_t v187;
  uint64_t v188;
  unint64_t v189;
  const void **v190;
  CFIndex v191;
  uint64_t i;
  const void *v193;
  const __CFAllocator *v194;
  CFStringRef v195;
  uint64_t v196;
  NSObject *v197;
  uint64_t v198;
  int v199;
  uint64_t v200;
  uint64_t v201;
  const char *v202;
  NSObject *v203;
  uint32_t v204;
  uint64_t v205;
  uint64_t v206;
  const void *domain;
  CFHTTPMessageRef context;
  _QWORD valuePtr[5];
  CFArrayRef names;
  size_t peerIDLen[5];
  CFStreamError __dst[64];
  _BYTE buf[24];
  UInt8 v214[4080];
  void (**v215)(AutoString *__hidden);
  CFStringRef v216;
  uint64_t v217;
  uint64_t v218;
  CFStreamError number;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  CFRange v223;

  v1 = MEMORY[0x1E0C80A78](a1);
  v222 = *MEMORY[0x1E0C80C00];
  v3 = v1;
  switch(v2)
  {
    case 1:
      Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v1 + 336), &unk_1EDCFAAA0);
      v5 = (__CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDCFAA68);
      if (v5)
      {
        v6 = v5;
        MutableBytePtr = CFDataGetMutableBytePtr(v5);
        Length = CFDataGetLength(v6);
        if (Length == 2)
          goto LABEL_4;
        v73 = Length;
        *(_QWORD *)&buf[8] = 0;
        *(_QWORD *)buf = 0;
        v74 = SocketStream::recvBytes((SocketStream *)v3, &MutableBytePtr[Length], 2 - Length, (CFStreamError *)buf);
        if (v74)
        {
          if (v74 >= 1)
          {
            v75 = v74 + v73;
            memcpy(__dst, MutableBytePtr, v75);
            CFDataSetLength(v6, v75);
            memcpy(MutableBytePtr, __dst, v75);
            v76 = *(__CFSocket **)(v3 + 288);
            if (v76 && CFSocketIsValid(v76))
              CFSocketEnableCallBacks(*(CFSocketRef *)(v3 + 288), 1uLL);
            if (v75 == 2)
            {
LABEL_4:
              v9 = MutableBytePtr[1];
              if (v9 == 2)
              {
                v104 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDCFBF30);
                v105 = CFDictionaryGetValue(v104, (const void *)*MEMORY[0x1E0C9B2D8]);
                v106 = CFDictionaryGetValue(v104, (const void *)*MEMORY[0x1E0C9B2B8]);
                CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAA68);
                if (v105)
                  v107 = v106 == 0;
                else
                  v107 = 1;
                if (!v107)
                {
                  SocketStream::addHandshake_NoLock(v3, 2);
LABEL_168:
                  SocketStream::addHandshake_NoLock(v3, 3);
                  v100 = v3;
                  v101 = 1;
LABEL_169:
                  SocketStream::removeHandshake_NoLock(v100, v101);
                  goto LABEL_170;
                }
                v9 = MutableBytePtr[1];
              }
              else if (!MutableBytePtr[1])
              {
                CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAA68);
                goto LABEL_168;
              }
              v16 = v9 | 0x40000;
              v15 = (int)*MEMORY[0x1E0C9B290];
              goto LABEL_135;
            }
LABEL_170:
            if (*(_DWORD *)(v3 + 264))
              SocketStream::removeHandshake_NoLock(v3, 1);
            return;
          }
          v16 = *(_DWORD *)&buf[8];
          v15 = *(_QWORD *)buf;
          if (*(_DWORD *)&buf[8] == 35 && *(_QWORD *)buf == 1)
            goto LABEL_170;
        }
        else
        {
          v16 = 57;
          v15 = 1;
        }
LABEL_135:
        *(_QWORD *)(v3 + 256) = v15;
      }
      else
      {
        *(_QWORD *)&buf[8] = 0;
        *(_QWORD *)buf = 0;
        if (Value)
          goto LABEL_155;
        v49 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDCFBF30);
        v50 = (const __CFString *)CFDictionaryGetValue(v49, (const void *)*MEMORY[0x1E0C9B2D8]);
        v51 = (const __CFString *)CFDictionaryGetValue(v49, (const void *)*MEMORY[0x1E0C9B2B8]);
        v52 = CFGetAllocator(*(CFTypeRef *)(v3 + 336));
        Mutable = CFDataCreateMutable(v52, 4);
        if (Mutable)
        {
          Value = Mutable;
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAAA0, Mutable);
          CFRelease(Value);
          v54 = CFDataGetMutableBytePtr((CFMutableDataRef)Value);
          CFDataSetLength((CFMutableDataRef)Value, 4);
          *(_DWORD *)v54 = 33554693;
          if (v50 && CFStringGetLength(v50) && v51 && CFStringGetLength(v51))
            v54[1] = 2;
          else
            CFDataSetLength((CFMutableDataRef)Value, 3);
LABEL_155:
          v113 = CFDataGetLength((CFDataRef)Value);
          BytePtr = CFDataGetBytePtr((CFDataRef)Value);
          v115 = SocketStream::sendToSocket((SocketStream *)v3, BytePtr, v113, (CFStreamError *)buf);
          v116 = v115;
          v117 = v113 - v115;
          if (v117)
          {
            if (v115 < 1)
            {
              if (*(_DWORD *)&buf[8] != 35 || *(_QWORD *)buf != 1)
              {
                v112 = *(_OWORD *)buf;
LABEL_167:
                *(_OWORD *)(v3 + 256) = v112;
              }
            }
            else
            {
              v121 = CFDataGetMutableBytePtr((CFMutableDataRef)Value);
              memmove(v121, &v121[v116], v117);
              CFDataSetLength((CFMutableDataRef)Value, v117);
              v122 = *(__CFSocket **)(v3 + 288);
              if (v122 && CFSocketIsValid(v122))
                CFSocketEnableCallBacks(*(CFSocketRef *)(v3 + 288), 8uLL);
            }
            goto LABEL_170;
          }
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAAA0);
          v118 = CFGetAllocator(*(CFTypeRef *)(v3 + 336));
          v119 = CFDataCreateMutable(v118, 2);
          if (v119)
          {
            v120 = v119;
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAA68, v119);
            CFRelease(v120);
            goto LABEL_170;
          }
        }
LABEL_162:
        *(_QWORD *)(v3 + 256) = 1;
        v16 = 12;
      }
LABEL_163:
      *(_DWORD *)(v3 + 264) = v16;
      goto LABEL_170;
    case 2:
      Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v1 + 336), &unk_1EDCFAAA0);
      v11 = (__CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDCFAA68);
      if (v11)
      {
        v12 = v11;
        v13 = CFDataGetMutableBytePtr(v11);
        v14 = CFDataGetLength(v12);
        if (v14 != 2)
        {
          v77 = v14;
          *(_QWORD *)&buf[8] = 0;
          *(_QWORD *)buf = 0;
          v78 = SocketStream::recvBytes((SocketStream *)v3, &v13[v14], 2 - v14, (CFStreamError *)buf);
          if (!v78)
          {
            *(_QWORD *)(v3 + 256) = 1;
            v16 = 57;
            goto LABEL_163;
          }
          if (v78 < 1)
          {
            if (*(_DWORD *)&buf[8] != 35 || *(_QWORD *)buf != 1)
            {
              v112 = *(_OWORD *)buf;
              goto LABEL_167;
            }
            goto LABEL_170;
          }
          v79 = v78 + v77;
          memcpy(__dst, v13, v79);
          CFDataSetLength(v12, v79);
          memcpy(v13, __dst, v79);
          v80 = *(__CFSocket **)(v3 + 288);
          if (v80 && CFSocketIsValid(v80))
            CFSocketEnableCallBacks(*(CFSocketRef *)(v3 + 288), 1uLL);
          if (v79 != 2)
            goto LABEL_170;
        }
        if (v13[1])
        {
          v15 = (int)*MEMORY[0x1E0C9B290];
          v16 = v13[1] | 0x30000;
          goto LABEL_135;
        }
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAA68);
        v100 = v3;
        v101 = 2;
        goto LABEL_169;
      }
      *(_QWORD *)&buf[8] = 0;
      *(_QWORD *)buf = 0;
      if (Value)
        goto LABEL_155;
      v55 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDCFBF30);
      v56 = (const __CFString *)CFDictionaryGetValue(v55, (const void *)*MEMORY[0x1E0C9B2D8]);
      v57 = (const __CFString *)CFDictionaryGetValue(v55, (const void *)*MEMORY[0x1E0C9B2B8]);
      v58 = CFGetAllocator(*(CFTypeRef *)(v3 + 336));
      v59 = CFDataCreateMutable(v58, 513);
      if (v59)
      {
        Value = v59;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAAA0, v59);
        CFRelease(Value);
        v60 = CFDataGetMutableBytePtr((CFMutableDataRef)Value);
        CFDataSetLength((CFMutableDataRef)Value, 513);
        *v60 = 1;
        CFStringGetPascalString(v56, v60 + 1, 256, 0x8000100u);
        CFStringGetPascalString(v57, &v60[v60[1] + 2], 256, 0x8000100u);
        CFDataSetLength((CFMutableDataRef)Value, v60[1] + v60[v60[1] + 2] + 3);
        goto LABEL_155;
      }
      goto LABEL_162;
    case 3:
      v17 = (__CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(v1 + 336), &unk_1EDCFAAA0);
      v18 = (__CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDCFAA68);
      if (v18)
      {
        v19 = v18;
        __dst[0] = 0uLL;
        v20 = CFDataGetMutableBytePtr(v18);
        v21 = CFDataGetLength(v19);
        v22 = v21;
        if (v21 > 1)
        {
          error = 0;
          v23 = 0;
        }
        else
        {
          v23 = SocketStream::recvBytes((SocketStream *)v3, &v20[v21], 2 - v21, __dst);
          error = __dst[0].error;
        }
        v81 = v23 & ~(v23 >> 63);
        v82 = v81 + v22;
        if (error || (uint64_t)v82 < 2)
          goto LABEL_284;
        if (*v20 != 5)
        {
          v83 = 327935;
          goto LABEL_106;
        }
        if (v20[1])
        {
          v83 = v20[1] | 0x50000;
LABEL_106:
          *(_QWORD *)(v3 + 256) = (int)*MEMORY[0x1E0C9B290];
LABEL_394:
          *(_DWORD *)(v3 + 264) = v83;
          goto LABEL_395;
        }
        if (v82 > 7)
        {
          error = 0;
        }
        else
        {
          v23 = SocketStream::recvBytes((SocketStream *)v3, &v20[v82], 8 - v82, __dst);
          v81 = v23 & ~(v23 >> 63);
          error = __dst[0].error;
        }
        v82 += v81;
        if (error || v82 < 5)
          goto LABEL_284;
        v144 = v20[3];
        switch(v144)
        {
          case 1:
            v145 = 10;
            break;
          case 4:
            v145 = 22;
            break;
          case 3:
            v145 = v20[4] + 7;
            break;
          default:
            v145 = 0;
            *(_QWORD *)(v3 + 256) = (int)*MEMORY[0x1E0C9B290];
            *(_DWORD *)(v3 + 264) = 327681;
            break;
        }
        if (!*(_DWORD *)(v3 + 264))
        {
          if (v145 <= v82
            || (v23 = SocketStream::recvBytes((SocketStream *)v3, &v20[v82], v145 - v82, __dst),
                (error = __dst[0].error) == 0))
          {
            if (v23 + v82 == v145)
            {
              CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAA68);
              SocketStream::removeHandshake_NoLock(v3, 3);
              return;
            }
            if (v23)
              goto LABEL_395;
            goto LABEL_393;
          }
LABEL_284:
          if (v23)
          {
            if (!error)
              goto LABEL_395;
            if (error == 35 && __dst[0].domain == 1)
            {
              memcpy(buf, v20, v82);
              CFDataSetLength(v19, v82);
              memcpy(v20, buf, v82);
              v158 = *(__CFSocket **)(v3 + 288);
              if (v158 && CFSocketIsValid(v158))
                CFSocketEnableCallBacks(*(CFSocketRef *)(v3 + 288), 1uLL);
              goto LABEL_395;
            }
            v124 = __dst[0];
LABEL_292:
            *(CFStreamError *)(v3 + 256) = v124;
            goto LABEL_395;
          }
LABEL_393:
          *(_QWORD *)(v3 + 256) = 1;
          v83 = 57;
          goto LABEL_394;
        }
LABEL_395:
        if (*(_DWORD *)(v3 + 264))
          SocketStream::removeHandshake_NoLock(v3, 1);
        return;
      }
      *(_QWORD *)&buf[8] = 0;
      *(_QWORD *)buf = 0;
      if (v17)
        goto LABEL_55;
      LODWORD(__dst[0].domain) = 0;
      v89 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDCFBDE0);
      v90 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDCFBE88);
      Info = (const __CFArray *)CFHostGetInfo((uint64_t)v89, 1, 0);
      ValueAtIndex = Info;
      if (Info)
      {
        if (CFArrayGetCount(Info))
          ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
        else
          ValueAtIndex = 0;
      }
      if (v90)
      {
        CFRetain(v90);
      }
      else
      {
        v131 = (const __CFArray *)CFHostGetInfo((uint64_t)v89, 0, 0);
        if (!v131)
          goto LABEL_229;
        v132 = v131;
        v133 = CFGetAllocator(v89);
        Count = CFArrayGetCount(v132);
        if (Count < 1)
          goto LABEL_229;
        v135 = Count;
        v136 = 1;
        do
        {
          v137 = (const __CFData *)CFArrayGetValueAtIndex(v132, v136 - 1);
          if (v137)
          {
            v138 = CFDataGetBytePtr(v137);
            LODWORD(number.domain) = 0;
            LODWORD(number.domain) = bswap32(*((unsigned __int16 *)v138 + 1)) >> 16;
            v90 = CFNumberCreate(v133, kCFNumberSInt32Type, &number);
            if (v90)
              break;
          }
          else
          {
            v90 = 0;
          }
        }
        while (v136++ < v135);
        if (!v90)
          goto LABEL_229;
      }
      if (ValueAtIndex)
      {
        CFRetain(ValueAtIndex);
      }
      else
      {
        v140 = (const __CFArray *)CFHostGetInfo((uint64_t)v89, 0, 0);
        v141 = v140;
        if (!v140)
          goto LABEL_228;
        if (!CFArrayGetCount(v140))
          goto LABEL_228;
        CFGetAllocator(v141);
        v142 = (const __CFData *)CFArrayGetValueAtIndex(v141, 0);
        ValueAtIndex = (const __CFArray *)_CFNetworkCFStringCreateWithCFDataAddress(v142);
        if (!ValueAtIndex)
          goto LABEL_228;
      }
      v128 = CFGetAllocator(*(CFTypeRef *)(v3 + 336));
      v129 = CFDataCreateMutable(v128, 262);
      v17 = v129;
      if (v129)
      {
        CFDataSetLength(v129, 262);
        v130 = CFDataGetMutableBytePtr(v17);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAAA0, v17);
        CFStringGetPascalString((CFStringRef)ValueAtIndex, v130 + 4, 256, 0x8000100u);
        *(_DWORD *)v130 = 50331909;
        CFNumberGetValue((CFNumberRef)v90, kCFNumberSInt32Type, __dst);
        *(_WORD *)&v130[v130[4] + 5] = bswap32(LOWORD(__dst[0].domain)) >> 16;
        CFDataSetLength(v17, v130[4] + 7);
        CFRelease(v17);
        CFRelease(v90);
        CFRelease(ValueAtIndex);
LABEL_55:
        v61 = CFDataGetLength(v17);
        v62 = CFDataGetBytePtr(v17);
        v63 = SocketStream::sendToSocket((SocketStream *)v3, v62, v61, (CFStreamError *)buf);
        v64 = v63;
        v65 = v61 - v63;
        if (v65)
        {
          if (v63 >= 1)
          {
            v102 = CFDataGetMutableBytePtr(v17);
            memmove(v102, &v102[v64], v65);
            CFDataSetLength(v17, v65);
            v103 = *(__CFSocket **)(v3 + 288);
            if (v103 && CFSocketIsValid(v103))
              CFSocketEnableCallBacks(*(CFSocketRef *)(v3 + 288), 8uLL);
            goto LABEL_395;
          }
          if (*(_DWORD *)&buf[8] != 35 || *(_QWORD *)buf != 1)
          {
            v124 = *(CFStreamError *)buf;
            goto LABEL_292;
          }
          goto LABEL_395;
        }
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAAA0);
        v66 = CFGetAllocator(*(CFTypeRef *)(v3 + 336));
        v67 = CFDataCreateMutable(v66, 262);
        if (v67)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFAA68, v67);
          CFRelease(v67);
          goto LABEL_395;
        }
LABEL_229:
        *(_QWORD *)(v3 + 256) = 1;
        v83 = 12;
        goto LABEL_394;
      }
      CFRelease(ValueAtIndex);
LABEL_228:
      CFRelease(v90);
      goto LABEL_229;
    case 4:
      SocketStream::_PerformSOCKSv4Handshake_NoLock((CFDictionaryRef *)v1);
      return;
    case 5:
      WeakRetained = objc_loadWeakRetained((id *)(v1 + 280));
      if (WeakRetained)
      {
        v26 = WeakRetained;
        v27 = *(_DWORD *)(v3 + 248);
        if ((v27 & 0x400) != 0)
        {
          *(_WORD *)(v3 + 252) = *(_WORD *)(v3 + 252);
          *(_DWORD *)(v3 + 248) = v27 | 8;
          _CFWriteStreamSignalEventDelayed();
        }
        CFRelease(v26);
      }
      v28 = objc_loadWeakRetained((id *)(v3 + 272));
      if (v28)
      {
        v29 = v28;
        v30 = *(_DWORD *)(v3 + 248);
        if ((v30 & 0x200) != 0)
        {
          *(_WORD *)(v3 + 252) = *(_WORD *)(v3 + 252);
          *(_DWORD *)(v3 + 248) = v30 | 4;
          _CFReadStreamSignalEventDelayed();
        }
        CFRelease(v29);
      }
      return;
    case 6:
      *(_QWORD *)&number.error = 0;
      number.domain = 0;
      v31 = CFGetAllocator(*(CFTypeRef *)(v1 + 336));
      v32 = (char *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDD00488);
      if (v32)
      {
        v33 = v32;
        v34 = SocketStream::socketRead((SocketStream *)v3, buf, 4096, &number);
        v35 = number.error;
        if (number.error)
        {
          if (number.error != 35 || number.domain != 1)
          {
            *(_QWORD *)(v3 + 256) = number.domain;
LABEL_175:
            *(_DWORD *)(v3 + 264) = v35;
          }
LABEL_176:
          v123 = *(__CFSocket **)(v3 + 288);
          if (v123 && CFSocketIsValid(v123))
            CFSocketEnableCallBacks(*(CFSocketRef *)(v3 + 288), 1uLL);
          return;
        }
        if (!v34)
        {
          *(_QWORD *)(v3 + 256) = 1;
          v35 = 32;
          goto LABEL_175;
        }
        if (!CFHTTPMessageAppendBytes((CFHTTPMessageRef)v33, buf, v34))
        {
          *(_QWORD *)(v3 + 256) = 4;
          v35 = -1;
          goto LABEL_175;
        }
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        if (*((_QWORD *)v33 + 13))
          goto LABEL_176;
        v84 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)(v33 + 16), 0x11D1D2CFu);
        v85 = v84;
        if (v84)
        {
          CFStringGetCString(v84, (char *)__dst, 1024, 0x600u);
          CFRelease(v85);
          v85 = (const void *)atol((const char *)__dst);
        }
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        HTTPMessage::removeHeaderFieldValue((HTTPMessage *)(v33 + 16), 0x141153BEu);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        HTTPMessage::removeHeaderFieldValue((HTTPMessage *)(v33 + 16), 0x142173C4u);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        if (v33[40])
        {
          HTTPMessage::ensureParserFinished((HTTPMessage *)(v33 + 16));
          if (*((_QWORD *)v33 + 8))
          {
            HTTPMessage::ensureParserFinished((HTTPMessage *)(v33 + 16));
            v87 = (const __CFData **)*((_QWORD *)v33 + 8);
            if (v87)
              v87 = (const __CFData **)HTTPBodyData::getLength(v87, v86);
            v85 = (const void *)((_BYTE *)v85 - (_BYTE *)v87);
          }
        }
        if (v85)
          goto LABEL_176;
        if ((unint64_t)(CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)v33) - 300) >= 0xFFFFFFFFFFFFFF9CLL)
        {
          v159 = *(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
          if ((v159 & 0x400000000) == 0 || !*(_QWORD *)(v3 + 296))
            goto LABEL_299;
          *(_DWORD *)(v3 + 248) = *(_DWORD *)(v3 + 248);
          *(_WORD *)(v3 + 252) = (v159 | 0x800000000) >> 32;
          v88 = 7;
        }
        else
        {
          v88 = 5;
        }
        SocketStream::addHandshake_NoLock(v3, v88);
LABEL_299:
        SocketStream::removeHandshake_NoLock(v3, 6);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDD004F8);
        goto LABEL_176;
      }
      v68 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDCFA330);
      if (v68)
        goto LABEL_59;
      *(_QWORD *)buf = 0;
      __dst[0].domain = 0;
      v93 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDD003E0);
      v94 = (const __CFString *)CFDictionaryGetValue(v93, &unk_1EDD004C0);
      if (!SocketStream::_CreateNameAndPortForCONNECTProxy(*(SocketStream **)(v3 + 336), (const __CFDictionary *)__dst, (const __CFString **)buf, (const __CFNumber **)(v3 + 256), v95))goto LABEL_180;
      LODWORD(v215) = 0;
      v96 = *(const void **)buf;
      if (CFNumberGetValue(*(CFNumberRef *)buf, kCFNumberSInt32Type, &v215)
        && (domain = (const void *)__dst[0].domain,
            (v97 = CFStringCreateWithFormat(v31, 0, CFSTR("%@:%d"), __dst[0].domain, (unsigned __int16)v215)) != 0))
      {
        v98 = CFURLCreateWithString(v31, v97, 0);
        if (v98)
        {
          if (v94)
            v99 = v94;
          else
            v99 = CFSTR("HTTP/1.1");
          context = CFHTTPMessageCreateRequest(v31, (CFStringRef)&unk_1EDCFE0A8, v98, v99);
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x13721369u, CFSTR("keep-alive"));
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x119152ADu, CFSTR("keep-alive"));
          CFRelease(v98);
        }
        else
        {
          context = 0;
        }
        CFRelease(v97);
        CFRelease(v96);
        if (context)
        {
          v146 = (const __CFDictionary *)CFDictionaryGetValue(v93, &unk_1EDD003A8);
          v147 = v146;
          if (v146)
          {
            if (!CFDictionaryGetValue(v146, &unk_1EDCFD0B0))
            {
              if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
              HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x12709302u, domain);
            }
            if (!CFDictionaryGetValue(v147, &unk_1EDCFD8C8))
            {
              if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
              pthread_once(&initControl, initializeUserAgentString);
              HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x14C15415u, (const void *)sUserAgentString);
            }
            CFDictionaryApplyFunction(v147, (CFDictionaryApplierFunction)_CONNECTHeaderApplier, context);
          }
          else
          {
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
            HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x12709302u, domain);
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
            pthread_once(&initControl, initializeUserAgentString);
            HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x14C15415u, (const void *)sUserAgentString);
          }
          CFRelease((CFTypeRef)__dst[0].domain);
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
          v68 = HTTPMessage::copySerializedHeaders((CFHTTPMessageRef)((char *)context + 16), 1);
          CFRelease(context);
          if (v68)
          {
            CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFA330, v68);
            CFRelease(v68);
LABEL_59:
            v69 = CFDataGetLength((CFDataRef)v68);
            v70 = CFDataGetBytePtr((CFDataRef)v68);
            v71 = SocketStream::sendToSocket((SocketStream *)v3, v70, v69, &number);
            if (number.error)
            {
              if (number.error != 35 || number.domain != 1)
              {
                *(CFStreamError *)(v3 + 256) = number;
                return;
              }
              v72 = 0;
            }
            else
            {
              v72 = v71;
            }
            v108 = *(__CFSocket **)(v3 + 288);
            if (v108 && CFSocketIsValid(v108))
              CFSocketEnableCallBacks(*(CFSocketRef *)(v3 + 288), 8uLL);
            if (v69 == v72)
            {
              CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFA330);
              Empty = CFHTTPMessageCreateEmpty(v31, 0);
              CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDD00488, Empty);
              CFRelease(Empty);
              goto LABEL_176;
            }
            if (!v72)
              return;
            v110 = CFDataGetBytePtr((CFDataRef)v68);
            v111 = CFDataCreate(v31, &v110[v72], v69 - v72);
            if (v111)
            {
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_1EDCFA330, v111);
              CFRelease(v111);
              return;
            }
          }
LABEL_183:
          *(_QWORD *)(v3 + 256) = 1;
          *(_DWORD *)(v3 + 264) = 12;
          return;
        }
      }
      else
      {
        CFRelease(v96);
      }
LABEL_180:
      if (__dst[0].domain)
        CFRelease((CFTypeRef)__dst[0].domain);
      if (!*(_DWORD *)(v3 + 264))
        goto LABEL_183;
      return;
    case 7:
      v36 = *(_DWORD *)(v1 + 264);
      if (v36)
      {
        v37 = *(_QWORD *)(v1 + 256);
        v38 = v36 == 35 && v37 == 1;
        if (!v38 && (v36 != -9803 || v37 != *MEMORY[0x1E0C9B298]))
        {
          SocketStream::removeSSLHandshake((SocketStream *)v1);
          return;
        }
      }
      v39 = *(unsigned int *)(v1 + 248);
      v40 = v39 | ((unint64_t)*(unsigned __int16 *)(v1 + 252) << 32);
      if ((v39 & 0x60000000) != 0)
        return;
      if ((v39 & 0x18000) != 0x8000)
        goto LABEL_192;
      CFSocketGetNative(*(CFSocketRef *)(v1 + 288));
      v41 = (CFNA *)SCNetworkSignatureCopyIdentifierForConnectedSocket();
      if (!v41)
        goto LABEL_190;
      v43 = (const __CFString *)v41;
      v44 = CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore(v41, (const __CFString *)"TLSFalseStart", v42);
      if (v44)
      {
        v45 = v44;
        v46 = CFStringCompare(v44, CFSTR("TRUE"), 0);
        CFRelease(v43);
        CFRelease(v45);
        v47 = *(unsigned int *)(v3 + 248);
        v48 = v47 | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
        if (v46 == kCFCompareEqualTo)
        {
          *(_DWORD *)(v3 + 248) = v47 | 0x10000;
          *(_WORD *)(v3 + 252) = WORD2(v48);
          SSLSetSessionOption(*(SSLContextRef *)(v3 + 296), kSSLSessionOptionFalseStart, 1u);
          v40 = *(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
          goto LABEL_192;
        }
      }
      else
      {
        if (CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once != -1)
          dispatch_once(&CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once, &__block_literal_global_9684);
        CFNA::CFNetworkAgentClient::executeLegacyQuery((CFNA::CFNetworkAgentClient *)CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client, v43, 2);
        CFRelease(v43);
LABEL_190:
        v48 = *(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
      }
      v40 = v48 & 0xFFFFFFFFFFFF7FFFLL;
      *(_DWORD *)(v3 + 248) = v40;
      *(_WORD *)(v3 + 252) = WORD2(v40);
LABEL_192:
      if ((v40 & 0x80000) != 0)
        goto LABEL_313;
      v125 = *(SSLContext **)(v3 + 296);
      v215 = 0;
      peerIDLen[0] = 0;
      if (SSLGetPeerID(v125, (const void **)&v215, peerIDLen) || v215)
        goto LABEL_312;
      v126 = CFGetAllocator(*(CFTypeRef *)(v3 + 336));
      __dst[0].domain = 0;
      if (SSLGetPeerDomainNameLength(v125, (size_t *)__dst))
      {
        v127 = 0;
      }
      else
      {
        if (__dst[0].domain >= 7uLL)
          v143 = (UInt8 *)CFAllocatorAllocate(v126, __dst[0].domain, 0);
        else
          v143 = buf;
        if (SSLGetPeerDomainName(v125, (char *)v143, (size_t *)__dst))
          v127 = 0;
        else
          v127 = CFStringCreateWithBytes(v126, v143, __dst[0].domain, 0x8000100u, 0);
        if (v143 != buf)
          CFAllocatorDeallocate(v126, v143);
      }
      if (!CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDD003E0)
        && !CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EDCFBF30))
      {
        goto LABEL_261;
      }
      __dst[0].domain = 0;
      number.domain = 0;
      SocketStream::_CreateNameAndPortForCONNECTProxy(*(SocketStream **)(v3 + 336), (const __CFDictionary *)__dst, (const __CFString **)&number, (const __CFNumber **)buf, v148);
      v149 = (const void *)__dst[0].domain;
      v150 = (const void *)number.domain;
      if (__dst[0].domain && number.domain)
      {
        LODWORD(valuePtr[0]) = 0;
        CFNumberGetValue((CFNumberRef)number.domain, kCFNumberSInt32Type, valuePtr);
        if (v127)
          v151 = v127;
        else
          v151 = CFSTR("nulldomain");
        v152 = CFGetAllocator((CFTypeRef)(v3 - 16));
        v153 = CFStringCreateWithFormat(v152, 0, CFSTR("{%@:%d}%@"), v149, LOWORD(valuePtr[0]), v151);
      }
      else
      {
        v153 = 0;
        if (!__dst[0].domain)
          goto LABEL_258;
      }
      CFRelease(v149);
LABEL_258:
      if (v150)
        CFRelease(v150);
      if (v153)
        goto LABEL_302;
LABEL_261:
      LODWORD(__dst[0].domain) = 255;
      if (v127)
        v154 = v127;
      else
        v154 = CFSTR("nulldomain");
      Native = CFSocketGetNative(*(CFSocketRef *)(v3 + 288));
      if (getpeername(Native, (sockaddr *)buf, (socklen_t *)__dst))
        goto LABEL_265;
      if (buf[1] == 30)
      {
        v160 = CFGetAllocator((CFTypeRef)(v3 - 16));
        v157 = CFStringCreateWithFormat(v160, 0, CFSTR("{%8.8x:%8.8x:%8.8x:%8.8x:%d}%@"), *(unsigned int *)&buf[8], *(unsigned int *)&buf[12], *(unsigned int *)&buf[16], *(unsigned int *)&buf[20], *(unsigned __int16 *)&buf[2], v154);
      }
      else
      {
        if (buf[1] != 2)
        {
LABEL_265:
          v153 = 0;
          goto LABEL_302;
        }
        v156 = CFGetAllocator((CFTypeRef)(v3 - 16));
        v157 = CFStringCreateWithFormat(v156, 0, CFSTR("{%d.%d.%d.%d:%d}%@"), buf[7], buf[6], buf[5], buf[4], *(unsigned __int16 *)&buf[2], v154);
      }
      v153 = v157;
LABEL_302:
      if (v153)
        v161 = v153;
      else
        v161 = v127;
      if (v153 && v127)
        CFRelease(v127);
      if (v161)
      {
        *(_QWORD *)buf = v126;
        *(_QWORD *)&buf[8] = 1023;
        *(_QWORD *)&buf[16] = _CFStringGetOrCreateCString(v126, v161, v214, (uint64_t *)&buf[8], 0x8000100u);
        CFRelease(v161);
        SSLSetPeerID(v125, *(const void **)&buf[16], *(size_t *)&buf[8]);
        if (*(_QWORD *)&buf[16])
        {
          if (v214 != *(UInt8 **)&buf[16])
            CFAllocatorDeallocate(*(CFAllocatorRef *)buf, *(void **)&buf[16]);
        }
      }
LABEL_312:
      v40 = *(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
LABEL_313:
      v162 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      while (2)
      {
        if ((v40 & 0x4000000000) == 0)
        {
          if ((v40 & 0x20000000000) != 0)
            *(CFAbsoluteTime *)(v3 + 680) = CFAbsoluteTimeGetCurrent();
          if (CFNLog::onceToken != -1)
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
          v163 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            v164 = *(_QWORD *)(v3 + 560);
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = v164;
            _os_log_impl(&dword_183ECA000, v163, OS_LOG_TYPE_DEFAULT, "TCP Conn %p starting SSL negotiation", buf, 0xCu);
          }
          if (nw_settings_get_signposts_enabled())
            kdebug_trace();
          v165 = *(unsigned int *)(v3 + 248);
          v166 = v165 | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32) | 0x4000000000;
          *(_DWORD *)(v3 + 248) = v165;
          *(_WORD *)(v3 + 252) = WORD2(v166);
        }
        v167 = SSLHandshake(*(SSLContextRef *)(v3 + 296));
        v168 = v167;
        if ((int)v167 > -9804)
        {
          if ((_DWORD)v167 != -9803)
          {
            if (!(_DWORD)v167)
            {
              SocketStream::removeSSLHandshake((SocketStream *)v3);
              if (((*(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32)) & 0x20000000000) != 0)
              {
                *(_DWORD *)buf = 0;
                *(_DWORD *)buf = (int)((CFAbsoluteTimeGetCurrent() - *(double *)(v3 + 680)) * 1000.0);
                v176 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3 + 112))(v3, v3 - 16, 0x1EDCFA288);
                if (v176)
                {
                  v177 = CFGetAllocator((CFTypeRef)(v3 - 16));
                  MutableCopy = CFDictionaryCreateMutableCopy(v177, 0, v176);
                  v179 = CFGetAllocator((CFTypeRef)(v3 - 16));
                  v180 = CFNumberCreate(v179, kCFNumberSInt32Type, buf);
                  CFDictionaryAddValue(MutableCopy, CFSTR("_kCFStreamStatsTLS_HandshakeTimeMs"), v180);
                  (*(void (**)(uint64_t, uint64_t, __CFDictionary *))(*(_QWORD *)v3 + 200))(v3, 0x1EDCFA288, MutableCopy);
                  CFRelease(v176);
                  if (v180)
                    CFRelease(v180);
                  if (MutableCopy)
                    CFRelease(MutableCopy);
                }
              }
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v181 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                v182 = *(_QWORD *)(v3 + 560);
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v182;
                _os_log_impl(&dword_183ECA000, v181, OS_LOG_TYPE_DEFAULT, "TCP Conn %p SSL Handshake DONE", buf, 0xCu);
              }
              if (nw_settings_get_signposts_enabled())
                kdebug_trace();
              goto LABEL_375;
            }
LABEL_383:
            v199 = translateSSLContextError(*(SSLContext **)(v3 + 296), v167);
            if (v199 == v168)
            {
              CFLog();
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v200 = CFNLog::logger;
              if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                goto LABEL_391;
              v201 = *(_QWORD *)(v3 + 560);
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = v201;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v168;
              v202 = "TCP Conn %p SSLHandshake failed (%d)";
              v203 = v200;
              v204 = 18;
            }
            else
            {
              CFLog();
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v205 = CFNLog::logger;
              if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                goto LABEL_391;
              v206 = *(_QWORD *)(v3 + 560);
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = v206;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v168;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v199;
              v202 = "TCP Conn %p SSLHandshake failed (%d -> %d)";
              v203 = v205;
              v204 = 24;
            }
            _os_log_error_impl(&dword_183ECA000, v203, OS_LOG_TYPE_ERROR, v202, buf, v204);
LABEL_391:
            *(_QWORD *)(v3 + 256) = (int)*MEMORY[0x1E0C9B298];
            *(_DWORD *)(v3 + 264) = v199;
            SocketStream::removeSSLHandshake((SocketStream *)v3);
            return;
          }
LABEL_375:
          v186 = 1;
          goto LABEL_376;
        }
        if ((_DWORD)v167 == -9842)
        {
          v183 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 184))(v3);
          if (!v183)
            goto LABEL_375;
          *(_DWORD *)(v3 + 248) |= 0x20000000u;
          names = 0;
          if (SSLCopyDistinguishedNames(*(SSLContextRef *)(v3 + 296), &names))
          {
            v184 = names;
            names = 0;
            if (!v184)
            {
              v185 = 0;
              goto LABEL_356;
            }
            CFRelease(v184);
          }
          v185 = names;
LABEL_356:
          v187 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_221, 1);
          v188 = v187;
          if (!v187
            || !(*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v187 + 16))(v187, "Client Cert Requested", 0))
          {
LABEL_373:
            CFRetain((CFTypeRef)(v3 - 16));
            valuePtr[0] = MEMORY[0x1E0C809B0];
            valuePtr[1] = 3221225472;
            valuePtr[2] = ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_3;
            valuePtr[3] = &__block_descriptor_40_e20_v16__0____CFArray__8l;
            valuePtr[4] = v3;
            (*(void (**)(uint64_t, CFArrayRef, _QWORD *))(*(_QWORD *)v183 + 48))(v183, names, valuePtr);
            (*(void (**)(uint64_t))(*(_QWORD *)v183 + 24))(v183);
            SocketStream::unscheduleFromSSL((SocketStream *)v3);
            v175 = names;
            if (names)
            {
LABEL_374:
              CFRelease(v175);
              goto LABEL_375;
            }
            goto LABEL_375;
          }
          if (!v185)
          {
LABEL_372:
            (*(void (**)(uint64_t))(*(_QWORD *)v188 + 8))(v188);
            goto LABEL_373;
          }
          *(_QWORD *)buf = CFRetain(v185);
          v189 = CFArrayGetCount(v185);
          v191 = v189;
          *(_QWORD *)&buf[8] = v189;
          if (v189 - 1 > 0x1FFFFFFFFFFFFFFDLL)
          {
            *(_QWORD *)&buf[16] = 0;
          }
          else
          {
            if (v189 <= 0x1E)
            {
              v190 = (const void **)v214;
              *(_QWORD *)&buf[16] = v214;
LABEL_364:
              v223.location = 0;
              v223.length = v191;
              CFArrayGetValues(v185, v223, v190);
              v191 = *(_QWORD *)&buf[8];
              goto LABEL_365;
            }
            v190 = (const void **)malloc_type_malloc(8 * v189, 0x89ED541CuLL);
            *(_QWORD *)&buf[16] = v190;
            v191 = *(_QWORD *)&buf[8];
            if (v190)
              goto LABEL_364;
          }
LABEL_365:
          if (v191 > 0)
          {
            (*(void (**)(uint64_t, const char *, const __CFString *, const void **))(*(_QWORD *)v188 + 72))(v188, "Distinguished Names", CFSTR("%ld"), v190);
            for (i = 0; i != v191; ++i)
            {
              v193 = *(const void **)(*(_QWORD *)&buf[16] + 8 * i);
              v194 = CFGetAllocator(v193);
              v195 = CFStringCreateWithFormat(v194, 0, CFSTR("<< DATA %@ >>"), v193);
              snprintf((char *)__dst, 0xFFuLL, "%d", i);
              number.domain = (CFIndex)&off_1E14E4818;
              *(_QWORD *)&number.error = CFStringCreateWithCString(v162, (const char *)__dst, 0x8000100u);
              v220 = 0;
              v221 = 0;
              if (v195)
              {
                (*(void (**)(uint64_t))(*(_QWORD *)v188 + 64))(v188);
                AutoString::~AutoString((AutoString *)&number);
                CFRelease(v195);
              }
              else
              {
                v215 = &off_1E14E4818;
                v216 = CFStringCreateWithCString(v162, "invalid name", 0x8000100u);
                v217 = 0;
                v218 = 0;
                (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v188 + 64))(v188, *(_QWORD *)&number.error, v216);
                AutoString::~AutoString((AutoString *)&v215);
                AutoString::~AutoString((AutoString *)&number);
              }
            }
          }
          CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)buf);
          goto LABEL_372;
        }
        if ((_DWORD)v167 != -9841)
          goto LABEL_383;
        v169 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 184))(v3);
        if (v169)
        {
          *(_DWORD *)(v3 + 248) |= 0x40000000u;
          *(_QWORD *)buf = 0;
          if (SocketStream::_copyPeerTrustWithPinning_NoLock((CFDictionaryRef *)v3, *(SSLContextRef *)(v3 + 296), (SecTrustRef *)buf))
          {
            v170 = *(const void **)buf;
            *(_QWORD *)buf = 0;
            if (v170)
              CFRelease(v170);
          }
          v171 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), CFSTR("kCFStreamPropertySSLSettings"));
          ATSVersion = StrictSecurity::getATSVersion(v171, v172);
          StrictSecurity::cloneSecTrust(&__dst[0].domain, (uint64_t)ATSVersion, *(uint64_t *)buf);
          v174 = *(const void **)(v3 + 688);
          *(_QWORD *)(v3 + 688) = __dst[0].domain;
          if (v174)
            CFRelease(v174);
          logPeerCertAvailable(*(SSLContext **)(v3 + 296));
          CFRetain((CFTypeRef)(v3 - 16));
          peerIDLen[0] = MEMORY[0x1E0C809B0];
          peerIDLen[1] = 3221225472;
          peerIDLen[2] = (size_t)___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke;
          peerIDLen[3] = (size_t)&__block_descriptor_40_e8_v12__0i8l;
          peerIDLen[4] = v3;
          (*(void (**)(uint64_t, _QWORD, size_t *))(*(_QWORD *)v169 + 40))(v169, *(_QWORD *)buf, peerIDLen);
          (*(void (**)(uint64_t))(*(_QWORD *)v169 + 24))(v169);
          SocketStream::unscheduleFromSSL((SocketStream *)v3);
          v175 = *(CFArrayRef *)buf;
          if (!*(_QWORD *)buf)
            goto LABEL_375;
          goto LABEL_374;
        }
        v186 = 0;
LABEL_376:
        v196 = *(unsigned int *)(v3 + 248);
        v40 = v196 | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
        if ((v196 & 0x8000) == 0)
        {
          if (v186)
            return;
          continue;
        }
        break;
      }
      SocketStream::removeSSLHandshake((SocketStream *)v3);
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v197 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v198 = *(_QWORD *)(v3 + 560);
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v198;
        _os_log_impl(&dword_183ECA000, v197, OS_LOG_TYPE_DEFAULT, "TCP Conn %p SSL Handshake DONE (fs)", buf, 0xCu);
      }
      return;
    default:
      v10 = v2;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v10;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "h = %d", buf, 8u);
      }
      return;
  }
}

void sub_183FAAA08(_Unwind_Exception *a1)
{
  void *v1;
  void *v3;

  v3 = (void *)STACK[0x4D0];
  if (STACK[0x4D0])
  {
    if (v1 != v3)
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x4C0], v3);
  }
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_e8_32c45_ZTSNSt3__110shared_ptrI17RequestBodyStreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __copy_helper_block_e8_32c45_ZTSNSt3__110shared_ptrI17RequestBodyStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN17RequestBodyStream33_bodyStreamEventOccurred_offqueueEv_block_invoke(uint64_t a1)
{
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 192) |= 0x10u;
  RequestBodyStream::_onqueue_resume(*(RequestBodyStream **)(a1 + 40));
}

void URLAuthChallenge::~URLAuthChallenge(URLAuthChallenge *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  *(_QWORD *)this = &off_1E14E8348;
  *((_QWORD *)this + 1) = &unk_1E14E83A0;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
    CFRelease(v3);

  v4 = (const void *)*((_QWORD *)this + 7);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 8);
  if (v5)
    CFRelease(v5);
}

uint64_t formCanRead(__CFReadStream *a1, __CFError **a2, _QWORD *a3)
{
  __CFReadStream *v4;
  __CFReadStream *v6;

  if (a2)
    *a2 = 0;
  while (1)
  {
    v4 = (__CFReadStream *)a3[2];
    if (!v4)
      goto LABEL_6;
    if (CFReadStreamGetStatus(v4) != kCFStreamStatusAtEnd)
      break;
    openNextStream(a3);
  }
  v6 = (__CFReadStream *)a3[2];
  if (!v6)
  {
LABEL_6:
    CFReadStreamSignalEvent();
    return 0;
  }
  return CFReadStreamHasBytesAvailable(v6);
}

uint64_t __copy_helper_block_e8_32c44_ZTSNSt3__18weak_ptrI19TransportConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN17RequestBodyStream37_bufferRequestBodyFromStream_offqueueEv_block_invoke_2(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  dispatch_data_t concat;
  BOOL v9;
  int v10;
  BOOL v11;
  NSObject *v12;

  v2 = *(NSObject **)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(_QWORD *)(a1 + 56);
  v5 = *(_QWORD *)(a1 + 64);
  v6 = *(unsigned __int8 *)(a1 + 72);
  if (v2)
  {
    v7 = *(NSObject **)(v3 + 160);
    if (v7)
    {
      concat = dispatch_data_create_concat(v7, v2);
      dispatch_release(*(dispatch_object_t *)(v3 + 160));
      *(_QWORD *)(v3 + 160) = concat;
    }
    else
    {
      *(_QWORD *)(v3 + 160) = v2;
      dispatch_retain(v2);
    }
  }
  if (*(_DWORD *)(v3 + 176))
    v9 = 1;
  else
    v9 = (_DWORD)v5 == 0;
  v10 = !v9;
  if (!v9)
  {
    *(_QWORD *)(v3 + 168) = v4;
    *(_QWORD *)(v3 + 176) = v5;
  }
  if (*(_BYTE *)(v3 + 184))
    v11 = 1;
  else
    v11 = v6 == 0;
  if (v11)
  {
    if (((*(_QWORD *)(v3 + 160) == 0) & ~v10) != 0)
      goto LABEL_20;
  }
  else
  {
    *(_BYTE *)(v3 + 184) = v6;
  }
  RequestBodyStream::_onqueue_provideRequestBodyFromBuffer((RequestBodyStream *)v3);
LABEL_20:
  v12 = *(NSObject **)(a1 + 32);
  if (v12)
    dispatch_release(v12);
}

void sub_183FAB488(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

_QWORD *ConnectionProtocolCreate()
{
  _QWORD *v0;
  _QWORD *v1;
  NSObject *v2;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v0 = malloc_type_calloc(1uLL, 0x58uLL, 0x10A0040924D544FuLL);
  v1 = v0;
  if (v0)
  {
    v0[2] = &g_ConnectionProtocolIdentifier;
    v0[3] = &g_ConnectionProtocolCallbacks;
    v0[5] = v0;
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v2 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v4 = 134217984;
      v5 = 88;
      _os_log_error_impl(&dword_183ECA000, v2, OS_LOG_TYPE_ERROR, "calloc(%zu) failed", (uint8_t *)&v4, 0xCu);
    }
  }
  return v1;
}

uint64_t __copy_helper_block_e8_40c89_ZTS18SmartBlockWithArgsIJP15__CFHTTPMessagejPK10__CFStringiS_IJPK16_CFURLCredentialbEEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN14HTTPStallTimer6removeENSt3__110shared_ptrIvEE_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t **v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  unint64_t v13;
  BOOL v14;
  uint64_t **v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  BOOL v19;
  unint64_t *p_shared_owners;
  unint64_t v21;

  v2 = (std::__shared_weak_count *)a1[5];
  if (!v2)
    return;
  v3 = std::__shared_weak_count::lock(v2);
  if (!v3)
    return;
  v4 = v3;
  v5 = a1[4];
  if (!v5)
    goto LABEL_32;
  v6 = *(uint64_t ***)(v5 + 40);
  v7 = v6[1];
  if (!v7)
    goto LABEL_32;
  v8 = a1[6];
  v9 = v6[1];
  while (1)
  {
    v10 = v9[4];
    if (v8 >= v10)
      break;
LABEL_9:
    v9 = (uint64_t *)*v9;
    if (!v9)
      goto LABEL_32;
  }
  if (v10 < v8)
  {
    ++v9;
    goto LABEL_9;
  }
  v11 = (uint64_t *)(v6 + 1);
  v12 = v6[1];
  do
  {
    v13 = v12[4];
    v14 = v13 >= v8;
    if (v13 >= v8)
      v15 = (uint64_t **)v12;
    else
      v15 = (uint64_t **)(v12 + 1);
    if (v14)
      v11 = v12;
    v12 = *v15;
  }
  while (*v15);
  if (v11 != (uint64_t *)(v6 + 1) && v8 >= v11[4])
  {
    v16 = (uint64_t *)v11[1];
    if (v16)
    {
      do
      {
        v17 = v16;
        v16 = (uint64_t *)*v16;
      }
      while (v16);
    }
    else
    {
      v18 = v11;
      do
      {
        v17 = (uint64_t *)v18[2];
        v19 = *v17 == (_QWORD)v18;
        v18 = v17;
      }
      while (!v19);
    }
    if (*v6 == v11)
      *v6 = v17;
    v6[2] = (uint64_t *)((char *)v6[2] - 1);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v7, v11);
    std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v11 + 4));
    operator delete(v11);
    v6 = *(uint64_t ***)(v5 + 40);
  }
  if (!v6[2])
    dispatch_source_set_timer(*(dispatch_source_t *)(v5 + 32), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
LABEL_32:
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v21 = __ldaxr(p_shared_owners);
  while (__stlxr(v21 - 1, p_shared_owners));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_3_28(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 24))(*(_QWORD *)(a1 + 48));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

uint64_t __destroy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __copy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN4TubeD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 48))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 152))(v2, 0);
      TransportConnection::rstConnectionEstablishmentDelegate(*(TransportConnection **)(a1 + 32));
    }
  }
}

uint64_t ConnectionProtocolSupportsExternalData()
{
  return 1;
}

uint64_t __destroy_helper_block_e8_64c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
}

uint64_t __copy_helper_block_e8_64c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(result + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(result + 72) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN14TCPIO_Delegate9writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[6];
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  v2 = a1[5];
  v3 = a1[6];
  v4 = a1[4];
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v16, *(_QWORD *)(v3 + 8), *(std::__shared_weak_count **)(v3 + 16));
  v5 = *(_QWORD *)(v3 + 24);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3321888768;
  v14[2] = ___ZN14TCPIO_Delegate18_onqueue_writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke;
  v14[3] = &unk_1E14F2F78;
  v14[5] = v16;
  v15 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v14[4] = v2;
  TransportConnectionObjCPP::write(v5, v4, (uint64_t)v14);
  v8 = v15;
  if (v15)
  {
    v9 = (unint64_t *)&v15->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v17;
  if (v17)
  {
    v12 = (unint64_t *)&v17->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  dispatch_release((dispatch_object_t)a1[4]);
}

void sub_183FAB9B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  uint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;

  if (a16)
  {
    p_shared_owners = (unint64_t *)&a16->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }
  v20 = *(std::__shared_weak_count **)(v16 - 40);
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  _Unwind_Resume(exception_object);
}

void TransportConnectionObjCPP::write(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  std::__shared_weak_count_vtbl *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  uint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[5];
  std::__shared_weak_count *v18;
  _QWORD aBlock[6];
  std::__shared_weak_count *v20;

  if (*(_BYTE *)(a1 + 40))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, 1, 57);
  }
  else
  {
    v5 = MEMORY[0x1E0C809B0];
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = ___ZN25TransportConnectionObjCPP5writeEP11objc_objectU13block_pointerFv13CFStreamErrorE_block_invoke;
    aBlock[3] = &unk_1E14FA400;
    aBlock[4] = a3;
    v6 = (std::__shared_weak_count_vtbl *)operator new();
    v6->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))BlockHolderVar<BOOL,CFStreamError>::invoke_initial;
    v6->__on_zero_shared = 0;
    v6->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))_Block_copy(aBlock);
    aBlock[5] = v6;
    v7 = (std::__shared_weak_count *)operator new();
    v7->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1438;
    v7->__shared_weak_owners_ = 0;
    v7[1].__vftable = v6;
    v20 = v7;
    v17[4] = v6;
    v18 = v7;
    v7->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    v9 = *(_QWORD *)(a1 + 24);
    v17[0] = v5;
    v17[1] = 3321888768;
    v17[2] = ___ZN25TransportConnectionObjCPP5writeEP11objc_objectU13block_pointerFv13CFStreamErrorE_block_invoke_7;
    v17[3] = &__block_descriptor_48_e8_32c44_ZTS18SmartBlockWithArgsIJb13CFStreamErrorEE_e13_v24__0___qi_8l;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v9 + 48))(v9, a2, v17);
    v11 = v18;
    if (v18)
    {
      v12 = (unint64_t *)&v18->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    v14 = v20;
    if (v20)
    {
      v15 = (unint64_t *)&v20->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
}

void sub_183FABBEC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 48);
  _Unwind_Resume(a1);
}

uint64_t ___ZN17CoreSchedulingSet23copyRunloopEmulationSetEv_block_invoke()
{
  __CFRunLoop *v0;
  const __CFString *v1;
  const __CFString *v2;
  _OWORD *v3;
  uint64_t v4;

  v0 = (__CFRunLoop *)_coreSchedulingSet_RLM();
  v2 = v1;
  v3 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 120, 0);
  *v3 = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  v3[4] = 0u;
  v3[5] = 0u;
  v3[6] = 0u;
  *((_QWORD *)v3 + 14) = 0;
  RunLoopSchedulingSet::RunLoopSchedulingSet((RunLoopSchedulingSet *)v3, v0, v2, "com.apple.CFNetwork.LoaderRL");
  CoreSchedulingSet::copyRunloopEmulationSet(void)::sEmulationSet = v4;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 112))(v4);
}

void ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke_2(uint64_t a1)
{
  CFTypeRef *v1;

  v1 = *(CFTypeRef **)(a1 + 32);
  __NSCFTCPIOReadStream::_onss_excite((__NSCFTCPIOReadStream *)v1);
  CFRelease(v1[1]);
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_3(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  int is_wake_packet;
  size_t size;
  dispatch_data_t concat;

  v3 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 48);
  v4 = *(NSObject **)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 112));
  v5 = *(NSObject **)(v2 + 104);
  if (v5)
  {
    if (v3)
    {
      is_wake_packet = nw_content_context_get_is_wake_packet();
      v5 = *(NSObject **)(v2 + 104);
      if (is_wake_packet)
      {
        size = dispatch_data_get_size(*(dispatch_data_t *)(v2 + 104));
        *(_QWORD *)(v2 + 136) = size;
        *(_QWORD *)(v2 + 144) = dispatch_data_get_size(v4) + size;
      }
    }
    concat = dispatch_data_create_concat(v5, v4);
    dispatch_release(*(dispatch_object_t *)(v2 + 104));
    *(_QWORD *)(v2 + 104) = concat;
  }
  else
  {
    *(_QWORD *)(v2 + 104) = v4;
    dispatch_retain(v4);
    if (v3 && nw_content_context_get_is_wake_packet())
    {
      *(_QWORD *)(v2 + 136) = 0;
      *(_QWORD *)(v2 + 144) = dispatch_data_get_size(v4);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 112));
  __NSCFTCPIOReadStream::_onss_excite((__NSCFTCPIOReadStream *)v2);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  CFRelease(*(CFTypeRef *)(v2 + 8));
}

void __NSCFTCPIOReadStream::_onss_excite(__NSCFTCPIOReadStream *this)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  char v7;
  _QWORD block[7];

  if (*(_DWORD *)(*((_QWORD *)this + 15) + 40)
    && (CFReadStreamGetStatus(*((CFReadStreamRef *)this + 1)) & 0xFFFFFFFFFFFFFFFELL) == 2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 28);
    v2 = *((_QWORD *)this + 13);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 28);
    if (v2)
    {
      CFReadStreamSignalEvent();
    }
    else
    {
      v7 = 0;
      v3 = *((_QWORD *)this + 11);
      v4 = *(NSObject **)(v3 + 40);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
      block[3] = &__block_descriptor_56_e5_v8__0l;
      block[4] = v3;
      block[5] = &v5;
      block[6] = &v7;
      dispatch_sync(v4, block);
      if (v7 || v5 && v6)
        CFReadStreamSignalEvent();
      else
        __NSCFTCPIOReadStream::issueDelegateRead(this);
    }
  }
}

void __NSCFTCPIOReadStream::issueDelegateRead(__NSCFTCPIOReadStream *this)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  uint64_t v8;
  int v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[6];
  _QWORD v18[6];
  std::__shared_weak_count *v19;
  __NSCFTCPIOReadStream *v20;
  std::__shared_weak_count *v21;

  v2 = (_DWORD *)*((_QWORD *)this + 15);
  if (v2[10])
  {
    v3 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v2 + 88))(v2);
    CFRetain(*((CFTypeRef *)this + 1));
    v4 = *((_QWORD *)this + 11);
    v5 = *((_DWORD *)this + 29);
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 3221225472;
    v17[2] = ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_261;
    v17[3] = &__block_descriptor_48_e72_v24__0__NSObject_OS_dispatch_data__8__NSObject_OS_nw_content_context__16l;
    v17[4] = this;
    v17[5] = v3;
    TCPIO_Delegate::bufferedRead(v4, v5, (uint64_t)v17);
  }
  else
  {
    CFRetain(*((CFTypeRef *)this + 1));
    v20 = this;
    v6 = (std::__shared_weak_count *)operator new();
    v6->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F17B8;
    v6->__shared_weak_owners_ = 0;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)this;
    v21 = v6;
    v19 = v6;
    v6->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    v8 = *((_QWORD *)this + 11);
    v9 = *((_DWORD *)this + 29);
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3321888768;
    v18[2] = ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke;
    v18[3] = &__block_descriptor_56_e8_40c49_ZTSNSt3__110shared_ptrI21__NSCFTCPIOReadStreamEE_e72_v24__0__NSObject_OS_dispatch_data__8__NSObject_OS_nw_content_context__16l;
    v18[4] = this;
    v18[5] = this;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    TCPIO_Delegate::bufferedRead(v8, v9, (uint64_t)v18);
    v11 = v19;
    if (v19)
    {
      v12 = (unint64_t *)&v19->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    v14 = v21;
    if (v21)
    {
      v15 = (unint64_t *)&v21->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
}

void sub_183FAC060(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32);
  _Unwind_Resume(a1);
}

void RunLoopSchedulingSet::RunLoopSchedulingSet(RunLoopSchedulingSet *this, __CFRunLoop *a2, const __CFString *a3, const char *a4)
{
  uint64_t v8;
  CFTypeRef v9;
  CFTypeRef v10;

  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, (const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
  *(_DWORD *)(v8 + 40) = 1;
  *(_QWORD *)v8 = off_1E14EBA58;
  *(_QWORD *)(v8 + 24) = &unk_1E14EBAE0;
  *(_QWORD *)(v8 + 96) = a4;
  if (a2)
    v9 = CFRetain(a2);
  else
    v9 = 0;
  *((_QWORD *)this + 9) = v9;
  if (a3)
    v10 = CFRetain(a3);
  else
    v10 = 0;
  *((_QWORD *)this + 10) = v10;
  *((_BYTE *)this + 116) = 0;
}

void sub_183FAC114(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)v1 = off_1E14E8500;
  *(_DWORD *)(v1 + 40) = 0;
  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void TCPIO_Delegate::bufferedRead(uint64_t a1, int a2, uint64_t a3)
{
  NSObject *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[6];
  std::__shared_weak_count *v16;
  int v17;
  uint64_t v18;
  std::__shared_weak_count *v19;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v18, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
  v6 = *(NSObject **)(a1 + 40);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3321888768;
  v15[2] = ___ZN14TCPIO_Delegate12bufferedReadEjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke;
  v15[3] = &unk_1E14F3AD0;
  v15[5] = v18;
  v16 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v17 = a2;
  v15[4] = a3;
  dispatch_async(v6, v15);
  v9 = v16;
  if (v16)
  {
    v10 = (unint64_t *)&v16->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v19;
  if (v19)
  {
    v13 = (unint64_t *)&v19->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void ___ZN14TCPIO_Delegate12bufferedReadEjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[6];
  std::__shared_weak_count *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;

  v1 = *(unsigned int *)(a1 + 56);
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v15, *(_QWORD *)(v3 + 8), *(std::__shared_weak_count **)(v3 + 16));
  v4 = *(_QWORD *)(v3 + 24);
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3321888768;
  v13[2] = ___ZN14TCPIO_Delegate13bufferedRead0EjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke;
  v13[3] = &unk_1E14F2FB0;
  v13[5] = v15;
  v14 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v13[4] = v2;
  TransportConnectionObjCPP::read(v4, 1, v1, (uint64_t)v13);
  v7 = v14;
  if (v14)
  {
    v8 = (unint64_t *)&v14->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = v16;
  if (v16)
  {
    v11 = (unint64_t *)&v16->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_183FAC354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  uint64_t v16;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;

  if (a16)
  {
    p_shared_owners = (unint64_t *)&a16->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }
  v20 = *(std::__shared_weak_count **)(v16 - 40);
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  _Unwind_Resume(exception_object);
}

void TransportConnectionObjCPP::read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  std::__shared_weak_count_vtbl *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  NSObject *v11;
  size_t size;
  int v13;
  uint64_t v14;
  void (__cdecl *v15)(std::__shared_weak_count *__hidden);
  uint64_t on_zero_shared;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  size_t v23;
  size_t v24;
  NSObject *subrange;
  dispatch_data_t v26;
  void (__cdecl *v27)(std::__shared_weak_count *__hidden);
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  _QWORD v37[5];
  std::__shared_weak_count *v38;
  _QWORD v39[6];
  std::__shared_weak_count *v40;
  _QWORD aBlock[6];
  std::__shared_weak_count *v42;

  if (*(_BYTE *)(a1 + 40))
  {
    (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD))(a4 + 16))(a4, 0, 1, 1, 57, 0);
    return;
  }
  v7 = MEMORY[0x1E0C809B0];
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN25TransportConnectionObjCPP4readEjjU13block_pointerFvP11objc_objectb13CFStreamErrorPU32objcproto21OS_nw_content_context8NSObjectE_block_invoke;
  aBlock[3] = &unk_1E14FA3D8;
  aBlock[4] = a4;
  v8 = (std::__shared_weak_count_vtbl *)operator new();
  v8->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_initial;
  v8->__on_zero_shared = 0;
  v8->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))_Block_copy(aBlock);
  aBlock[5] = v8;
  v9 = (std::__shared_weak_count *)operator new();
  v9->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F14E0;
  v9->__shared_weak_owners_ = 0;
  v9[1].__vftable = v8;
  v42 = v9;
  v11 = *(NSObject **)(a1 + 48);
  if (v11 && (size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 48))) != 0)
  {
    v13 = size;
    v14 = (a2 - size);
    if (a2 <= size && size <= a3)
    {
      v15 = v8->~__shared_weak_count_0;
      on_zero_shared = (uint64_t)v8->__on_zero_shared;
      v17 = (void (__cdecl **)(std::__shared_weak_count *__hidden))((char *)&v8->~__shared_weak_count
                                                                  + (on_zero_shared >> 1));
      if ((on_zero_shared & 1) != 0)
        v15 = *(void (__cdecl **)(std::__shared_weak_count *__hidden))(*v17 + v15);
      ((void (*)(_QWORD *, uint64_t, NSObject *, _QWORD, _QWORD, _QWORD, _QWORD))v15)(v17, 1, v11, 0, 0, 0, 0);
      dispatch_release(*(dispatch_object_t *)(a1 + 48));
      *(_QWORD *)(a1 + 48) = 0;
      goto LABEL_27;
    }
    v23 = (size - a3);
    if (size > a3)
    {
      v24 = a3;
      subrange = dispatch_data_create_subrange(v11, 0, a3);
      v26 = dispatch_data_create_subrange(*(dispatch_data_t *)(a1 + 48), v24, v23);
      dispatch_release(*(dispatch_object_t *)(a1 + 48));
      *(_QWORD *)(a1 + 48) = v26;
      v27 = v8->~__shared_weak_count_0;
      v28 = (uint64_t)v8->__on_zero_shared;
      v29 = (void (__cdecl **)(std::__shared_weak_count *__hidden))((char *)&v8->~__shared_weak_count + (v28 >> 1));
      if ((v28 & 1) != 0)
        v27 = *(void (__cdecl **)(std::__shared_weak_count *__hidden))(*v29 + v27);
      ((void (*)(_QWORD *, uint64_t, NSObject *, _QWORD, _QWORD, _QWORD, _QWORD))v27)(v29, 1, subrange, 0, 0, 0, 0);
      dispatch_release(subrange);
      goto LABEL_27;
    }
    v30 = *(_QWORD *)(a1 + 24);
    v31 = (a3 - v13);
    v39[0] = v7;
    v39[1] = 3321888768;
    v39[2] = ___ZN25TransportConnectionObjCPP4readEjjU13block_pointerFvP11objc_objectb13CFStreamErrorPU32objcproto21OS_nw_content_context8NSObjectE_block_invoke_2;
    v39[3] = &__block_descriptor_56_e8_40c124_ZTS18SmartBlockWithArgsIJbPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorPU32objcproto21OS_nw_content_contextS0_EE_e83_v44__0__NSObject_OS_nw_content_context__8__NSObject_OS_dispatch_data__16B24___qi_28l;
    v39[4] = a1;
    v39[5] = v8;
    v40 = v9;
    do
      v32 = __ldxr(p_shared_owners);
    while (__stxr(v32 + 1, p_shared_owners));
    (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v30 + 56))(v30, 0, v14, v31, v39);
    v20 = v40;
    if (v40)
    {
      v33 = (unint64_t *)&v40->__shared_owners_;
      do
        v22 = __ldaxr(v33);
      while (__stlxr(v22 - 1, v33));
      goto LABEL_15;
    }
  }
  else
  {
    v18 = *(_QWORD *)(a1 + 24);
    v37[0] = v7;
    v37[1] = 3321888768;
    v37[2] = ___ZN25TransportConnectionObjCPP4readEjjU13block_pointerFvP11objc_objectb13CFStreamErrorPU32objcproto21OS_nw_content_context8NSObjectE_block_invoke_4;
    v37[3] = &__block_descriptor_48_e8_32c124_ZTS18SmartBlockWithArgsIJbPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorPU32objcproto21OS_nw_content_contextS0_EE_e83_v44__0__NSObject_OS_nw_content_context__8__NSObject_OS_dispatch_data__16B24___qi_28l;
    v37[4] = v8;
    v38 = v9;
    do
      v19 = __ldxr(p_shared_owners);
    while (__stxr(v19 + 1, p_shared_owners));
    (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v18 + 56))(v18, 0, a2, a3, v37);
    v20 = v38;
    if (v38)
    {
      v21 = (unint64_t *)&v38->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
LABEL_15:
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
  }
LABEL_27:
  v34 = v42;
  if (v42)
  {
    v35 = (unint64_t *)&v42->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
}

void sub_183FAC72C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 80);
  _Unwind_Resume(a1);
}

size_t __NSCFTCPIOWriteStream::_streamImpl_Write(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, size_t a4, CFStreamError *a5)
{
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  _QWORD v25[5];
  uint64_t block;
  uint64_t v27;
  void *v28;
  void *v29;
  NSObject *v30;
  CFStreamError *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;

  v9 = *((_QWORD *)this + 13);
  v10 = *(NSObject **)(v9 + 40);
  v11 = MEMORY[0x1E0C809B0];
  block = MEMORY[0x1E0C809B0];
  v27 = 3221225472;
  v28 = ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke;
  v29 = &__block_descriptor_48_e5_v8__0l;
  v30 = v9;
  v31 = a5;
  dispatch_sync(v10, &block);
  if (a5->domain && a5->error)
    return -1;
  v12 = dispatch_data_create(a3, a4, 0, 0);
  v13 = *((_QWORD *)this + 1);
  if (v13)
    CFRetain(*((CFTypeRef *)this + 1));
  v14 = *((_QWORD *)this + 13);
  v25[0] = v11;
  v25[1] = 3221225472;
  v25[2] = ___ZN22__NSCFTCPIOWriteStream17_streamImpl_WriteEP15__CFWriteStreamPKhlP13CFStreamError_block_invoke;
  v25[3] = &__block_descriptor_40_e5_v8__0l;
  v25[4] = v13;
  dispatch_retain(v12);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v34, *(_QWORD *)(v14 + 8), *(std::__shared_weak_count **)(v14 + 16));
  v15 = *(NSObject **)(v14 + 40);
  block = v11;
  v27 = 3321888768;
  v28 = ___ZN14TCPIO_Delegate9writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke;
  v29 = &unk_1E14F3E48;
  v32 = v34;
  v33 = v35;
  if (v35)
  {
    p_shared_owners = (unint64_t *)&v35->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }
  v30 = v12;
  v31 = (CFStreamError *)v25;
  dispatch_async(v15, &block);
  v18 = v33;
  if (v33)
  {
    v19 = (unint64_t *)&v33->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v35;
  if (v35)
  {
    v22 = (unint64_t *)&v35->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  dispatch_release(v12);
  return a4;
}

void ___ZN8HostBase5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFHost");
  HostBase::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FAC99C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN11HTTPMessage5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFHTTPMessage");
  HTTPMessage::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FACA08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN20URLCredentialStorage5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFURLCredentialStorage");
  URLCredentialStorage::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FACA74(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN16URLAuthChallenge5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFURLAuthChallenge");
  URLAuthChallenge::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FACAE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN18CompactCookieArray5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CompactCookieArray");
  CompactCookieArray::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FACB4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN14HTTPHeaderDict5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "HTTPHeaderDict");
  HTTPHeaderDict::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FACBB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN18URLProtectionSpace5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFURLProtectionSpace");
  URLProtectionSpace::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FACC24(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN9HSTSCache5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "HSTSCache");
  HSTSCache::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FACC90(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN17HTTPCookieStorage5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFHTTPCookieStorage");
  HTTPCookieStorage::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FACCFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN14StorageSession5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFURLStorageSession");
  StorageSession::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FACD68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN10HSTSPolicy5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFHSTSPolicy");
  HSTSPolicy::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FACDD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void CFClass::CFClass(CFClass *this, const char *a2)
{
  uint64_t v3;
  uint8_t v4[16];

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = CFClass::FinalizeObj;
  *((_QWORD *)this + 5) = CFClass::EqualObj;
  *((_QWORD *)this + 6) = CFClass::HashObj;
  *((_QWORD *)this + 7) = CFClass::CopyFormattingDescObj;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = CFClass::CopyDebugDescObj;
  v3 = _CFRuntimeRegisterClass();
  *((_QWORD *)this + 12) = v3;
  if (!v3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Couldn't allocate a type ID", v4, 2u);
  }
}

uint64_t __copy_helper_block_e8_32c36_ZTSNSt3__110shared_ptrI9ThrottlerEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void sub_183FACF80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FAD034(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FAD0E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FAD328(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_e8_32c36_ZTSNSt3__110shared_ptrI9ThrottlerEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14__CFReadStreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __copy_helper_block_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __copy_helper_block_ea8_40c39_ZTSNSt3__110shared_ptrI11HTTP3FramerEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN15HTTP2Connection19resumeDataForStreamENSt3__110shared_ptrI11HTTP2StreamEE_block_invoke(uint64_t a1)
{
  HTTP2Connection *v1;

  v1 = *(HTTP2Connection **)(a1 + 32);
  if (*((_QWORD *)v1 + 20))
  {
    nghttp2_session_resume_data();
    HTTP2Connection::_onqueue_scheduleIO(v1);
  }
  CFRelease((char *)v1 - 16);
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14__CFReadStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t cf_nghttp2_on_begin_headers_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  int v5;
  BOOL v6;
  HTTP2Stream **v7;
  HTTP2Stream *v8;
  uint64_t stream_user_data;
  uint64_t v11;
  uint64_t v12;
  NSURLRequestCachePolicy v13;

  v4 = *(unsigned __int8 *)(a2 + 12);
  if (v4 == 5)
  {
    stream_user_data = nghttp2_session_get_stream_user_data();
    if (stream_user_data && *(_QWORD *)stream_user_data)
    {
      v11 = *(_QWORD *)(*(_QWORD *)stream_user_data + 16);
      if (v11)
        v12 = v11 - 176;
      else
        v12 = 0;
      v13 = objc_msgSend(*(id *)(v12 + 80), "_cachePolicy");
    }
    else
    {
      v13 = NSURLRequestUseProtocolCachePolicy;
    }
    HTTP2ServerPush::createNewForStreamId((HTTP2ServerPush *)(a3 + 288), *(_DWORD *)(a2 + 40), v13, 0);
  }
  else if (v4 == 1)
  {
    v5 = *(_DWORD *)(a2 + 8);
    if (v5)
      v6 = (v5 & 1) == 0;
    else
      v6 = 0;
    if (!v6)
    {
      v7 = (HTTP2Stream **)nghttp2_session_get_stream_user_data();
      if (v7)
      {
        v8 = *v7;
        if (v8)
          HTTP2Stream::beginHeaders(v8);
      }
    }
  }
  return 0;
}

void HTTP2Stream::beginHeaders(HTTP2Stream *this)
{
  HTTPHeaderDict *Instance;
  uint64_t v3;
  uint64_t v4;
  HTTPHeaderDict *v5;
  uint64_t v6;

  if (*((_BYTE *)this + 128))
  {
    if (*((_BYTE *)this + 129))
    {
      if (*((_BYTE *)this + 152))
        __assert_rtn("_onqueue_beginTrailers", "HTTP2Stream.cpp", 852, "!fTrailersBegan");
      *((_BYTE *)this + 152) = 1;
      *((_QWORD *)this + 18) = CFHTTPMessageCreateEmpty((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
      if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
        dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
      Instance = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
      if (Instance)
      {
        *((_QWORD *)Instance + 2) = 0;
        *((_QWORD *)Instance + 3) = 0;
        Instance = (HTTPHeaderDict *)((char *)Instance + 16);
      }
      HTTPHeaderDict::HTTPHeaderDict(Instance);
      v3 = *((_QWORD *)this + 20);
      *((_QWORD *)this + 20) = v4;
      if (v3)
        CFRelease((CFTypeRef)(v3 - 16));
    }
  }
  else
  {
    *((_BYTE *)this + 128) = 1;
    *((_QWORD *)this + 15) = CFHTTPMessageCreateEmpty((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
      dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
    v5 = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
    if (v5)
    {
      *((_QWORD *)v5 + 2) = 0;
      *((_QWORD *)v5 + 3) = 0;
      v5 = (HTTPHeaderDict *)((char *)v5 + 16);
    }
    HTTPHeaderDict::HTTPHeaderDict(v5);
    *((_QWORD *)this + 17) = v6;
  }
}

uint64_t __destroy_helper_block_ea8_40c39_ZTSNSt3__110shared_ptrI11HTTP3FramerEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void __destroy_helper_block_e8_40c47_ZTSNSt3__18weak_ptrI22TLSCallbackServerTrustEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void __destroy_helper_block_e8_32c41_ZTSNSt3__18weak_ptrI16TLSCallbackQueueEE48c50_ZTSNSt3__110shared_ptrI22TLSCallbackServerTrustEE(uint64_t a1)
{
  std::__shared_weak_count *v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

uint64_t __destroy_helper_block_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

_QWORD *__copy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE64c38_ZTSNSt3__110shared_ptrI10__SecTrustEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[9];
  result[8] = a2[8];
  result[9] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c82_ZTSNSt3__110shared_ptrIN19TransportConnection31ConnectionEstablishmentDelegateEEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE64c38_ZTSNSt3__110shared_ptrI10__SecTrustEE(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;

  v2 = a1 + 48;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

uint64_t __copy_helper_block_e8_40c82_ZTSNSt3__110shared_ptrIN19TransportConnection31ConnectionEstablishmentDelegateEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

_QWORD *__copy_helper_block_e8_32c41_ZTSNSt3__18weak_ptrI16TLSCallbackQueueEE48c50_ZTSNSt3__110shared_ptrI22TLSCallbackServerTrustEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void ___ZN10HTTPEngine18_writeHeadersStartEv_block_invoke_2(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

uint64_t __copy_helper_block_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __copy_helper_block_e8_40c47_ZTSNSt3__18weak_ptrI22TLSCallbackServerTrustEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN14HTTPStallTimer3addENSt3__110shared_ptrIvEE_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t **v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t *v17;
  NSObject *v18;
  dispatch_time_t v19;
  unint64_t *p_shared_owners;
  unint64_t v21;

  v2 = (std::__shared_weak_count *)a1[5];
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = a1[4];
      if (v5)
      {
        v6 = *(uint64_t ***)(v5 + 40);
        v8 = v6 + 1;
        v7 = v6[1];
        if (v7)
        {
          v9 = a1[6];
          while (1)
          {
            while (1)
            {
              v10 = (uint64_t **)v7;
              v11 = v7[4];
              if (v9 >= v11)
                break;
              v7 = *v10;
              v8 = v10;
              if (!*v10)
                goto LABEL_13;
            }
            if (v11 >= v9)
              break;
            v7 = v10[1];
            if (!v7)
            {
              v8 = v10 + 1;
              goto LABEL_13;
            }
          }
        }
        else
        {
          v10 = v6 + 1;
LABEL_13:
          v12 = (uint64_t *)operator new(0x30uLL);
          v13 = v12;
          v14 = a1[7];
          v12[4] = a1[6];
          v12[5] = v14;
          if (v14)
          {
            v15 = (unint64_t *)(v14 + 8);
            do
              v16 = __ldxr(v15);
            while (__stxr(v16 + 1, v15));
          }
          *v12 = 0;
          v12[1] = 0;
          v12[2] = (uint64_t)v10;
          *v8 = v12;
          v17 = (uint64_t *)**v6;
          if (v17)
          {
            *v6 = v17;
            v13 = *v8;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v6[1], v13);
          v6[2] = (uint64_t *)((char *)v6[2] + 1);
          v6 = *(uint64_t ***)(v5 + 40);
        }
        if (v6[2] == (uint64_t *)1)
        {
          v18 = *(NSObject **)(v5 + 32);
          v19 = dispatch_time(0x8000000000000000, 3000000000);
          dispatch_source_set_timer(v18, v19, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
        }
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v21 = __ldaxr(p_shared_owners);
      while (__stlxr(v21 - 1, p_shared_owners));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_183FADD04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE64c52_ZTSNSt3__110shared_ptrI24HTTPConnectionCacheEntryEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 48;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

uint64_t __destroy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE56c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 40;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

_QWORD *__copy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE64c52_ZTSNSt3__110shared_ptrI24HTTPConnectionCacheEntryEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[9];
  result[8] = a2[8];
  result[9] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

_QWORD *__copy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE56c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void ___ZN14HTTPConnection7enqueueENSt3__110shared_ptrI15HTTPTransactionEE_block_invoke(uint64_t a1)
{
  HTTPConnection::_onqueue_attemptNextRequest(*(HTTPConnection **)(a1 + 32));
}

uint64_t ___ZN14HTTPConnection26setShouldSkipPipelineProbeEb_block_invoke(uint64_t result)
{
  uint64_t v1;
  int v2;
  unsigned int v3;

  v1 = *(_QWORD *)(result + 32);
  v2 = *(unsigned __int16 *)(v1 + 32);
  v1 += 32;
  v3 = (v2 | (*(unsigned __int8 *)(v1 + 2) << 16)) & 0xFFF7FFFF | (*(unsigned __int8 *)(result + 48) << 19);
  *(_WORD *)v1 = v2;
  *(_BYTE *)(v1 + 2) = BYTE2(v3);
  return result;
}

uint64_t ___ZN14HTTPConnection22_onqueue_requestFinishE13CFStreamError_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN14HTTPConnection17setShouldPipelineEb_block_invoke(uint64_t a1)
{
  uint64_t v2;
  int v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(unsigned __int8 *)(a1 + 48);
  v4 = *(unsigned __int16 *)(v2 + 32) | (*(unsigned __int8 *)(v2 + 34) << 16);
  if (v3)
  {
    if ((v4 & 0x20000) != 0)
      return;
    if ((v4 & 0x80000) != 0)
      goto LABEL_11;
    if ((v4 & 0x40000) != 0)
    {
      if ((v4 & 0x10000) == 0)
        goto LABEL_11;
      v4 &= ~0x20000u;
    }
    else
    {
      v4 = v4 & 0xFFF8FFFF | 0x50000;
    }
    *(_WORD *)(v2 + 32) = v4;
    *(_BYTE *)(v2 + 34) = BYTE2(v4);
LABEL_11:
    if ((v4 & 0x10000) == 0)
    {
      *(_WORD *)(v2 + 32) = v4;
      *(_BYTE *)(v2 + 34) = BYTE2(v4) | 2;
      HTTPConnection::_onqueue_attemptNextRequest((HTTPConnection *)v2);
    }
    return;
  }
  if ((v4 & 0x20000) != 0)
  {
    v5 = v4 & 0xFFFDFFFF;
    *(_WORD *)(v2 + 32) = v5;
    *(_BYTE *)(v2 + 34) = BYTE2(v5);
  }
}

void ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke_3(uint64_t a1)
{
  uint64_t v2;
  const __CFString *v3;
  const __CFString *v4;
  CFIndex location;
  NSObject *v6;
  NSObject *v7;
  dispatch_time_t v8;
  _QWORD handler[5];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = HTTPMessage::copyHeaderFieldValue(*(HTTPMessage **)(v2 + 240), (const __CFString *)&unk_1EDCFD040);
  if (v3)
  {
    v4 = v3;
    location = CFStringFind(v3, (CFStringRef)&unk_1EDCFDAC0, 1uLL).location;
    CFRelease(v4);
    if (location != -1)
    {
      *(_DWORD *)(v2 + 32) |= 0x20u;
      v6 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(v2 + 72));
      *(_QWORD *)(v2 + 320) = v6;
      if (!v6)
        __assert_rtn("_100ContinueTimerStart", "HTTPEngine.cpp", 3192, "_100ContinueTimer");
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3221225472;
      handler[2] = ___ZN10HTTPEngine22_100ContinueTimerStartEv_block_invoke;
      handler[3] = &__block_descriptor_40_e5_v8__0l;
      handler[4] = v2;
      dispatch_source_set_event_handler(v6, handler);
      v7 = *(NSObject **)(v2 + 320);
      v8 = dispatch_time(0, 5000000000);
      dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
      dispatch_resume(*(dispatch_object_t *)(v2 + 320));
    }
  }
  HTTPEngine::_writeHeadersStart(*(HTTPEngine **)(a1 + 32));
}

uint64_t ___ZN10HTTPEngine12readResponseENSt3__110shared_ptrI18HTTPRequestMessageEEU13block_pointerFxvEU13block_pointerFvNS1_I19HTTPResponseMessageEE13CFStreamErrorEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectS8_bEU13block_pointerFvS7_E_block_invoke_11(uint64_t a1)
{
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 32) &= ~0x80u;
  return HTTPEngine::_readHeadersStart(*(HTTPEngine **)(a1 + 40));
}

void HTTPConnection::_onqueue_attemptNextRequest(HTTPConnection *this)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  HTTPTransaction **v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  _QWORD *v23;
  unsigned int v24;
  int v25;
  _BOOL4 v26;
  uint64_t v27;
  int v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  uint64_t v32;
  BOOL v33;
  NSObject *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  __int16 v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t *v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  uint64_t v69;
  std::__shared_weak_count *v70;
  unint64_t *v71;
  unint64_t v72;
  BOOL v73;
  unint64_t *v74;
  unint64_t v75;
  HTTPRequestMessage *v76;
  void *ConnectionIdentifier;
  int v78;
  int v79;
  unsigned int v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  std::__shared_weak_count *v86;
  uint64_t Auth;
  CFStreamError v88;
  std::__shared_weak_count *v89;
  unint64_t *v90;
  unint64_t v91;
  std::__shared_weak_count *v92;
  unint64_t *v93;
  unint64_t v94;
  std::__shared_weak_count *v95;
  unint64_t *v96;
  unint64_t v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t v100;
  unint64_t *v101;
  uint64_t Instance;
  HTTPRequestMessage *v103;
  _QWORD *v104;
  std::__shared_weak_count *v105;
  unint64_t *v106;
  unint64_t v107;
  uint64_t v108;
  std::__shared_weak_count *v109;
  unint64_t *v110;
  unint64_t v111;
  unint64_t *v112;
  unint64_t v113;
  __int128 block;
  void *v115;
  void *v116;
  _QWORD *v117;
  HTTPConnection *v118;
  uint64_t v119;
  std::__shared_weak_count *v120;
  uint64_t v121;
  std::__shared_weak_count *v122;
  uint64_t v123;
  std::__shared_weak_count *v124;
  uint64_t v125;
  std::__shared_weak_count *v126;
  _QWORD v127[3];
  char v128;
  uint64_t v129;
  std::__shared_weak_count *v130;
  __int128 aBlock;
  void (*v132)(uint64_t, CFStreamError);
  void *v133;
  uint64_t v134;
  _QWORD v135[2];
  uint64_t v136[2];
  CFStreamError v137;

  if (!*((_QWORD *)this + 8))
    return;
  v2 = *((unsigned __int16 *)this + 16);
  v3 = v2 | (*((unsigned __int8 *)this + 34) << 16);
  if ((v2 & 0x100) != 0 || *((_QWORD *)this + 15) == *((_QWORD *)this + 16))
    return;
  v4 = *((_QWORD *)this + 18);
  if ((v3 & 0x1400) != 0 || v4 == 0)
    return;
  v7 = (_QWORD *)((char *)this + 160);
  v6 = *((_QWORD *)this + 20);
  if ((v3 & 0x20000) == 0 && v4 != v6)
    return;
  if ((*(_WORD *)(v4 + 32) & 0x800) == 0)
  {
    if ((v3 & 0xA) != 2
      || (v9 = (HTTPTransaction **)((char *)this + 192), (v8 = *((_QWORD *)this + 24)) != 0) && v4 != v8)
    {
      HTTPConnection::_onqueue_requestStart(this);
      return;
    }
    if (v4 != v6)
    {
      *((_BYTE *)this + 34) = BYTE2(v3);
      *((_WORD *)this + 16) = v3 | 4;
      return;
    }
    v24 = v3 & 0xFFFFFFF3;
    *((_BYTE *)this + 34) = BYTE2(v24);
    *((_WORD *)this + 16) = v24 | 8;
    v25 = HTTPConnection::_onqueue_willEnqueueRequests(this, 1, 0);
    v26 = 0;
    if (v25 != 2)
      v26 = HTTPTransaction::requestPermitsConnectionReuse(*v9);
    v27 = *((_QWORD *)this + 24);
    if (*(_DWORD *)(v27 + 80) != 2)
      __assert_rtn("getNegotiateRequest", "HTTPTransaction.cpp", 286, "_state == State::EnqueuedOnConnection");
    HTTPTransaction::_onqueue_prepareRequest(*((HTTPTransaction **)this + 24), v26, ((*((unsigned __int16 *)this + 16) | (*((unsigned __int8 *)this + 34) << 16)) >> 9) & 1);
    v28 = *(_DWORD *)(v27 + 80);
    if (v28 != 11)
    {
      if (v28 >= 4)
        __assert_rtn("_onqueue_changeState", "HTTPTransaction.cpp", 1664, "newState >= _state");
      *(_DWORD *)(v27 + 80) = 3;
    }
    v29 = *(std::__shared_weak_count **)(v27 + 168);
    v129 = *(_QWORD *)(v27 + 160);
    v130 = v29;
    if (v29)
    {
      p_shared_owners = (unint64_t *)&v29->__shared_owners_;
      do
        v31 = __ldxr(p_shared_owners);
      while (__stxr(v31 + 1, p_shared_owners));
    }
    v32 = *((_QWORD *)*v9 + 27);
    if (v32)
      v33 = *(_DWORD *)(v32 + 40) != 0;
    else
      v33 = 0;
    aBlock = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 192, &aBlock);
    v45 = (std::__shared_weak_count *)*((_QWORD *)&aBlock + 1);
    if (*((_QWORD *)&aBlock + 1))
    {
      v46 = (unint64_t *)(*((_QWORD *)&aBlock + 1) + 8);
      do
        v47 = __ldaxr(v46);
      while (__stlxr(v47 - 1, v46));
      if (!v47)
      {
        ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
        std::__shared_weak_count::__release_weak(v45);
      }
    }
    v127[0] = 0;
    v127[1] = v127;
    v128 = 1;
    v48 = *((_WORD *)this + 16);
    v127[2] = 0x2020000000;
    *((_WORD *)this + 16) = v48 | 0x400;
    v125 = 0;
    v126 = 0;
    v49 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
    if (v49 && (v49 = std::__shared_weak_count::lock(v49), (v126 = v49) != 0))
    {
      v50 = *((_QWORD *)this + 5);
      v125 = v50;
    }
    else
    {
      v50 = 0;
    }
    v51 = *((_QWORD *)this + 22);
    v52 = v129;
    v53 = (uint64_t)v130;
    v123 = v129;
    v124 = v130;
    if (v130)
    {
      v54 = (unint64_t *)&v130->__shared_owners_;
      do
        v55 = __ldxr(v54);
      while (__stxr(v55 + 1, v54));
    }
    v56 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&block = MEMORY[0x1E0C809B0];
    *((_QWORD *)&block + 1) = 3321888768;
    v115 = ___ZN14HTTPConnection37_onqueue_negotiateAuthenticationStartEv_block_invoke;
    v116 = &unk_1E14F3F28;
    v117 = v127;
    v118 = this;
    v119 = v50;
    v120 = v49;
    if (v49)
    {
      v57 = (unint64_t *)&v49->__shared_owners_;
      do
        v58 = __ldxr(v57);
      while (__stxr(v58 + 1, v57));
    }
    SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::SmartBlockWithArgs(&v121, &block);
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v51 + 184), v52, v53);
    aBlock = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v51 + 200, &aBlock);
    v59 = (std::__shared_weak_count *)*((_QWORD *)&aBlock + 1);
    if (*((_QWORD *)&aBlock + 1))
    {
      v60 = (unint64_t *)(*((_QWORD *)&aBlock + 1) + 8);
      do
        v61 = __ldaxr(v60);
      while (__stlxr(v61 - 1, v60));
      if (!v61)
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
    }
    *(_BYTE *)(v51 + 248) = 0;
    v63 = v121;
    v62 = v122;
    if (v122)
    {
      v64 = (unint64_t *)&v122->__shared_owners_;
      do
        v65 = __ldxr(v64);
      while (__stxr(v65 + 1, v64));
    }
    v66 = *(std::__shared_weak_count **)(v51 + 240);
    *(_QWORD *)(v51 + 232) = v63;
    *(_QWORD *)(v51 + 240) = v62;
    if (v66)
    {
      v67 = (unint64_t *)&v66->__shared_owners_;
      do
        v68 = __ldaxr(v67);
      while (__stlxr(v68 - 1, v67));
      if (!v68)
      {
        ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
        std::__shared_weak_count::__release_weak(v66);
      }
    }
    *(_BYTE *)(v51 + 250) = !v33;
    v69 = *(_QWORD *)(v51 + 128);
    if (v69)
    {
      v70 = *(std::__shared_weak_count **)(v51 + 136);
      if (v70)
      {
        v71 = (unint64_t *)&v70->__shared_owners_;
        do
          v72 = __ldxr(v71);
        while (__stxr(v72 + 1, v71));
        v73 = *(_DWORD *)(v69 + 24) != 2;
        v74 = (unint64_t *)&v70->__shared_owners_;
        do
          v75 = __ldaxr(v74);
        while (__stlxr(v75 - 1, v74));
        if (!v75)
        {
          ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
          std::__shared_weak_count::__release_weak(v70);
        }
      }
      else
      {
        v73 = *(_DWORD *)(v69 + 24) != 2;
      }
      *(_BYTE *)(v51 + 249) = v73;
    }
    if (AuthenticationState::canApplyHeadersToRequest((AuthenticationState *)v51, *(HTTPRequestMessage **)(v51 + 184))
      && (v76 = *(HTTPRequestMessage **)(v51 + 184),
          ConnectionIdentifier = (void *)HTTPConnectionAuthenticator::getConnectionIdentifier((HTTPConnectionAuthenticator *)v51),
          AuthenticationState::applyToRequest((AuthenticationState *)v51, v76, ConnectionIdentifier, 1)))
    {
      v78 = *(unsigned __int8 *)(v51 + 249);
      pthread_mutex_lock((pthread_mutex_t *)(v51 + 8));
      if (v78)
        v79 = 2;
      else
        v79 = 1;
      if (AuthenticationState::_haveAuthenticationInfo(v51, v79))
      {
        AuthenticationState::_authForType(&aBlock, v51, v79);
        v80 = HTTPAuthentication::isKerberosThePreferredAuthScheme(*(const __CFDictionary **)(*(_QWORD *)(aBlock + 8) + 136));
        v81 = (std::__shared_weak_count *)*((_QWORD *)&aBlock + 1);
        if (*((_QWORD *)&aBlock + 1))
        {
          v82 = (unint64_t *)(*((_QWORD *)&aBlock + 1) + 8);
          do
            v83 = __ldaxr(v82);
          while (__stlxr(v83 - 1, v82));
          if (!v83)
          {
            v84 = v56;
            v85 = v81;
            ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
            v86 = v85;
            v56 = v84;
            std::__shared_weak_count::__release_weak(v86);
          }
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v51 + 8));
        if (v80)
        {
          aBlock = 0uLL;
          SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::operator()(*(_QWORD *)(v51 + 232), 0, 0, 0, 0, 0, 0);
          goto LABEL_125;
        }
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v51 + 8));
      }
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      Instance = _CFRuntimeCreateInstance();
      v103 = (HTTPRequestMessage *)Instance;
      if (Instance)
      {
        *(_OWORD *)(Instance + 16) = 0u;
        v103 = (HTTPRequestMessage *)(Instance + 16);
        *(_QWORD *)(Instance + 192) = 0;
        *(_OWORD *)(Instance + 160) = 0u;
        *(_OWORD *)(Instance + 176) = 0u;
        *(_OWORD *)(Instance + 128) = 0u;
        *(_OWORD *)(Instance + 144) = 0u;
        *(_OWORD *)(Instance + 96) = 0u;
        *(_OWORD *)(Instance + 112) = 0u;
        *(_OWORD *)(Instance + 64) = 0u;
        *(_OWORD *)(Instance + 80) = 0u;
        *(_OWORD *)(Instance + 32) = 0u;
        *(_OWORD *)(Instance + 48) = 0u;
      }
      HTTPRequestMessage::HTTPRequestMessage(v103, *(const HTTPRequestMessage **)(v51 + 184));
      *(_QWORD *)&aBlock = v103;
      v104 = (_QWORD *)operator new();
      *v104 = &off_1E14F16D8;
      v104[1] = 0;
      v104[2] = 0;
      v104[3] = v103;
      *((_QWORD *)&aBlock + 1) = v104;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v51 + 200, &aBlock);
      v105 = (std::__shared_weak_count *)*((_QWORD *)&aBlock + 1);
      if (*((_QWORD *)&aBlock + 1))
      {
        v106 = (unint64_t *)(*((_QWORD *)&aBlock + 1) + 8);
        do
          v107 = __ldaxr(v106);
        while (__stlxr(v107 - 1, v106));
        if (!v107)
        {
          ((void (*)(std::__shared_weak_count *))v105->__on_zero_shared)(v105);
          std::__shared_weak_count::__release_weak(v105);
        }
      }
      HTTPMessage::setHeaderFieldScalarValue(*(HTTPMessage **)(v51 + 200), 0);
      v108 = *(_QWORD *)(v51 + 168);
      v109 = *(std::__shared_weak_count **)(v51 + 208);
      v136[0] = *(_QWORD *)(v51 + 200);
      v136[1] = (uint64_t)v109;
      if (v109)
      {
        v110 = (unint64_t *)&v109->__shared_owners_;
        do
          v111 = __ldxr(v110);
        while (__stxr(v111 + 1, v110));
      }
      v135[0] = 0;
      v135[1] = 0;
      *(_QWORD *)&aBlock = v56;
      *((_QWORD *)&aBlock + 1) = 3221225472;
      v132 = ___ZN27HTTPConnectionAuthenticator12writeRequestEv_block_invoke;
      v133 = &__block_descriptor_40_e13_v24__0___qi_8l;
      v134 = v51;
      HTTPEngine::writeRequest(v108, v136, v135, &aBlock);
      if (v109)
      {
        v112 = (unint64_t *)&v109->__shared_owners_;
        do
          v113 = __ldaxr(v112);
        while (__stlxr(v113 - 1, v112));
        if (!v113)
        {
          ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
          std::__shared_weak_count::__release_weak(v109);
        }
      }
      if (*(_BYTE *)(v51 + 250))
        *(_DWORD *)(*(_QWORD *)(v51 + 168) + 32) |= 0x2000000u;
    }
    else
    {
      Auth = AuthenticationState::getAuth((AuthenticationState *)v51, *(unsigned __int8 *)(v51 + 249));
      if (Auth)
      {
        v88 = *(CFStreamError *)(Auth + 88);
      }
      else
      {
        v88.domain = 0;
        *(_QWORD *)&v88.error = 0;
      }
      HTTPConnectionAuthenticator::errorOccurred((HTTPConnectionAuthenticator *)v51, v88);
    }
LABEL_125:
    v89 = v122;
    if (v122)
    {
      v90 = (unint64_t *)&v122->__shared_owners_;
      do
        v91 = __ldaxr(v90);
      while (__stlxr(v91 - 1, v90));
      if (!v91)
      {
        ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
        std::__shared_weak_count::__release_weak(v89);
      }
    }
    v92 = v124;
    if (v124)
    {
      v93 = (unint64_t *)&v124->__shared_owners_;
      do
        v94 = __ldaxr(v93);
      while (__stlxr(v94 - 1, v93));
      if (!v94)
      {
        ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
        std::__shared_weak_count::__release_weak(v92);
      }
    }
    v95 = v120;
    if (v120)
    {
      v96 = (unint64_t *)&v120->__shared_owners_;
      do
        v97 = __ldaxr(v96);
      while (__stlxr(v97 - 1, v96));
      if (!v97)
      {
        ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
        std::__shared_weak_count::__release_weak(v95);
      }
    }
    v98 = v126;
    if (v126)
    {
      v99 = (unint64_t *)&v126->__shared_owners_;
      do
        v100 = __ldaxr(v99);
      while (__stlxr(v100 - 1, v99));
      if (!v100)
      {
        ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
        std::__shared_weak_count::__release_weak(v98);
      }
    }
    _Block_object_dispose(v127, 8);
    v42 = v130;
    if (v130)
    {
      v101 = (unint64_t *)&v130->__shared_owners_;
      do
        v44 = __ldaxr(v101);
      while (__stlxr(v44 - 1, v101));
LABEL_67:
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
      return;
    }
    return;
  }
  *((CFAbsoluteTime *)this + 27) = CFAbsoluteTimeGetCurrent() + 10.0;
  v10 = *((_QWORD *)this + 18);
  if (v10)
  {
    if (v10 == *v7)
    {
      block = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 160, &block);
      v11 = (std::__shared_weak_count *)*((_QWORD *)&block + 1);
      if (*((_QWORD *)&block + 1))
      {
        v12 = (unint64_t *)(*((_QWORD *)&block + 1) + 8);
        do
          v13 = __ldaxr(v12);
        while (__stlxr(v13 - 1, v12));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      v10 = *((_QWORD *)this + 18);
    }
    v14 = *((_QWORD *)this + 19);
    *(_QWORD *)&aBlock = v10;
    *((_QWORD *)&aBlock + 1) = v14;
    if (v14)
    {
      v15 = (unint64_t *)(v14 + 8);
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    if (*(int *)(v10 + 80) >= 3)
      __assert_rtn("cleanAbort", "HTTPTransaction.cpp", 537, "_state < State::Negotiating");
    v137.domain = 1;
    *(_QWORD *)&v137.error = 89;
    HTTPTransaction::_onqueue_handleError((HTTPTransaction *)v10, v137);
    HTTPTransaction::_onqueue_closeAndCleanup((HTTPTransaction *)v10);
    v17 = *(_QWORD *)(v10 + 152);
    if (v17)
    {
      (*(void (**)(uint64_t, _QWORD))(v17 + 16))(v17, 0);
      _Block_release(*(const void **)(v10 + 152));
      *(_QWORD *)(v10 + 152) = 0;
    }
    v18 = *((_QWORD *)this + 18);
    if (v18)
    {
      if (!*v7)
      {
        std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)this + 20, v18, *((_QWORD *)this + 19));
        v19 = *((_QWORD *)this + 8);
        v20 = (void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 20) + 40))(*((_QWORD *)this + 20));

        *(_QWORD *)(v19 + 328) = v20;
      }
      v21 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
      if (v21)
      {
        v22 = std::__shared_weak_count::lock(v21);
        if (v22)
          v23 = (_QWORD *)*((_QWORD *)this + 5);
        else
          v23 = 0;
      }
      else
      {
        v23 = 0;
        v22 = 0;
      }
      v34 = *((_QWORD *)this + 7);
      *(_QWORD *)&block = MEMORY[0x1E0C809B0];
      *((_QWORD *)&block + 1) = 3321888768;
      v115 = ___ZN14HTTPConnection38_onqueue_cleanAbortRequestTransmissionEv_block_invoke;
      v116 = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e5_v8__0l;
      v117 = v23;
      v118 = (HTTPConnection *)v22;
      if (v22)
      {
        v35 = (unint64_t *)&v22->__shared_owners_;
        do
          v36 = __ldxr(v35);
        while (__stxr(v36 + 1, v35));
      }
      dispatch_async(v34, &block);
      v37 = (std::__shared_weak_count *)v118;
      if (v118)
      {
        v38 = (unint64_t *)((char *)v118 + 8);
        do
          v39 = __ldaxr(v38);
        while (__stlxr(v39 - 1, v38));
        if (!v39)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
      if (v22)
      {
        v40 = (unint64_t *)&v22->__shared_owners_;
        do
          v41 = __ldaxr(v40);
        while (__stlxr(v41 - 1, v40));
        if (!v41)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
    }
    v42 = (std::__shared_weak_count *)*((_QWORD *)&aBlock + 1);
    if (*((_QWORD *)&aBlock + 1))
    {
      v43 = (unint64_t *)(*((_QWORD *)&aBlock + 1) + 8);
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      goto LABEL_67;
    }
  }
}

void sub_183FAEA94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v28 - 136);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a18);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a20);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
  _Block_object_dispose(&a24, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a28);
  _Unwind_Resume(a1);
}

uint64_t HTTPEngine::_readHeadersStart(HTTPEngine *this)
{
  NSObject *v2;
  CFStreamError v4;

  if (*((_QWORD *)this + 22) != -2)
    __assert_rtn("_readHeadersStart", "HTTPEngine.cpp", 813, "_inExpectedBytes == HEADERS_NOT_YET_CHECKED");
  v2 = *((_QWORD *)this + 24);
  if (!v2 || !dispatch_data_get_size(v2))
    return HTTPEngine::_readHeadersDoRead(this);
  v4.domain = 0;
  *(_QWORD *)&v4.error = 0;
  return HTTPEngine::_readHeadersDoParse(this, v4, 0);
}

uint64_t __destroy_helper_block_ea8_56c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
}

uint64_t __copy_helper_block_ea8_56c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 64) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void sub_183FAEC88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void ___ZN15HTTPTransaction24_onqueue_closeAndCleanupEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *v2;
  unint64_t v3;
  __int128 v4;

  v4 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, &v4);
  v1 = (std::__shared_weak_count *)*((_QWORD *)&v4 + 1);
  if (*((_QWORD *)&v4 + 1))
  {
    v2 = (unint64_t *)(*((_QWORD *)&v4 + 1) + 8);
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 - 1, v2));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void URLProtectionSpace::~URLProtectionSpace(URLProtectionSpace *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  *(_QWORD *)this = &off_1E14E9A20;
  *((_QWORD *)this + 1) = &unk_1E14E9A78;
  v2 = (const void *)*((_QWORD *)this + 4);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 6);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 8);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 9);
  if (v5)
    CFRelease(v5);
}

uint64_t __destroy_helper_block_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t __destroy_helper_block_e8_32c39_ZTSNSt3__110shared_ptrI11TubeManagerEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __copy_helper_block_e8_40c35_ZTSNSt3__18weak_ptrI10HTTPEngineEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

char *HTTP2StreamRetainCallBack(const __CFAllocator *a1, char *a2)
{
  CFRetain(a2 - 16);
  return a2;
}

void __destroy_helper_block_e8_32c44_ZTSNSt3__18weak_ptrI19TransportConnectionEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void sub_183FAF060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;

  a9.super_class = (Class)__NSCFDeallocBomb;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c39_ZTSNSt3__110shared_ptrI11TubeManagerEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t __destroy_helper_block_e8_48c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t __copy_helper_block_e8_48c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZL17HARLoggingEnabledi_block_invoke()
{
  void *v0;
  NSObject *v1;
  uint8_t v2[12];
  int out_token;

  v0 = (void *)MEMORY[0x186DB8C8C]();
  out_token = -1;
  if (notify_register_dispatch("com.apple.CFNetwork.har-capture-update", &out_token, MEMORY[0x1E0C80D38], &__block_literal_global_122_15074))
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v1 = (id)CFNLog::logger;
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v2 = 0;
      _os_log_error_impl(&dword_183ECA000, v1, OS_LOG_TYPE_ERROR, "Failed to dispatch registered notification", v2, 2u);
    }

  }
  readHARPreference();
  objc_autoreleasePoolPop(v0);
}

void readHARPreference(void)
{
  double v0;
  double v1;
  double v2;
  double v3;
  CFStringRef *v4;
  CFStringRef *v5;
  double v6;
  void *v7;
  double v8;
  double v9;
  NSObject *v10;
  const __CFString *v11;
  const __CFString *v12;
  void *v13;
  void *v14;
  char *v15;
  CFPropertyListRef v16;
  void *v17;
  CFPropertyListRef v18;
  void *v19;
  dispatch_time_t v20;
  int v21;
  double v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v0 = secondsToStopForHARLogging(CFSTR("har-capture-global"));
  v1 = 0.0;
  if (v0 > 0.0)
  {
    v2 = v0;
    if (__CFNIsInDevelopmentEnvironment::onceToken != -1)
      dispatch_once(&__CFNIsInDevelopmentEnvironment::onceToken, &__block_literal_global_21_4777);
    if (__CFNIsInDevelopmentEnvironment::ok
      || checkEntitlementForHARLogging(CFSTR("com.apple.private.cfnetwork.har-capture-delegation")))
    {
      HARPIDSpecific = 0;
      v1 = v2;
    }
  }
  v3 = secondsToStopForHARLogging(CFSTR("har-capture-pid-date"));
  v4 = (CFStringRef *)MEMORY[0x1E0C9B260];
  v5 = (CFStringRef *)MEMORY[0x1E0C9B230];
  if (v3 > v1)
  {
    v6 = v3;
    if (__CFNIsInDevelopmentEnvironment::onceToken != -1)
      dispatch_once(&__CFNIsInDevelopmentEnvironment::onceToken, &__block_literal_global_21_4777);
    if (__CFNIsInDevelopmentEnvironment::ok
      || checkEntitlementForHARLogging(CFSTR("com.apple.private.cfnetwork.har-capture-delegation")))
    {
      v7 = (void *)CFPreferencesCopyValue(CFSTR("har-capture-pid-specific"), CFSTR("com.apple.CFNetwork"), *v4, *v5);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        HARPIDSpecific = objc_msgSend(v7, "intValue");
        v1 = v6;
      }

    }
  }
  v8 = secondsToStopForHARLogging(CFSTR("har-capture-amp"));
  if (v8 > v1)
  {
    v9 = v8;
    if (checkEntitlementForHARLogging(CFSTR("com.apple.private.cfnetwork.har-capture-amp")))
    {
      HARPIDSpecific = 0;
      v1 = v9;
    }
  }
  if (os_variant_has_internal_diagnostics() && getenv("CFNETWORK_HAR_LOGGING"))
  {
    v1 = INFINITY;
LABEL_22:
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v10 = (id)CFNLog::logger;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v21 = 134217984;
      v22 = v1;
      _os_log_impl(&dword_183ECA000, v10, OS_LOG_TYPE_DEFAULT, "Starting HAR logging for %f seconds", (uint8_t *)&v21, 0xCu);
    }

    if (initializeHAR(void)::onceToken != -1)
      dispatch_once(&initializeHAR(void)::onceToken, &__block_literal_global_147);
    v11 = *v4;
    v12 = *v5;
    v13 = (void *)CFPreferencesCopyValue(CFSTR("har-body-size-limit"), CFSTR("com.apple.CFNetwork"), v11, v12);
    v14 = v13;
    if (v13)
      HARBodySizeLimit = objc_msgSend(v13, "unsignedIntegerValue");
    v15 = getenv("CFNETWORK_HAR_BODYSIZELIMIT");
    if (v15)
      HARBodySizeLimit = strtoul(v15, 0, 0);
    v16 = CFPreferencesCopyValue(CFSTR("har-path-denial-list"), CFSTR("com.apple.CFNetwork"), v11, v12);
    v17 = (void *)HARPathDenialList;
    HARPathDenialList = (uint64_t)v16;

    v18 = CFPreferencesCopyValue(CFSTR("har-host-denial-list"), CFSTR("com.apple.CFNetwork"), v11, v12);
    v19 = (void *)HARHostDenialList;
    HARHostDenialList = (uint64_t)v18;

    HAREnabled = 1;
    if (fabs(v1) != INFINITY)
    {
      v20 = dispatch_walltime(0, (uint64_t)(v1 * 1000000000.0));
      dispatch_after(v20, (dispatch_queue_t)HARQueue, &__block_literal_global_145);
    }

    return;
  }
  if (v1 > 1.0)
    goto LABEL_22;
  if (HAREnabled == 1)
    dispatch_async((dispatch_queue_t)HARQueue, &__block_literal_global_146);
}

void sub_183FAF650(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double secondsToStopForHARLogging(const __CFString *a1)
{
  void *v1;
  double v2;
  double v3;

  v1 = (void *)CFPreferencesCopyValue(a1, CFSTR("com.apple.CFNetwork"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  objc_opt_class();
  v2 = 0.0;
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v1, "timeIntervalSinceNow");
    v2 = v3;
  }

  return v2;
}

void sub_183FAF6F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c49_ZTSNSt3__18weak_ptrI24HTTPConnectionCacheEntryEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t ___ZN4Tube24overrideAllowedProtocolsEm_block_invoke(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 32);
  if (*(int *)(v1 + 220) <= 1)
  {
    *(_BYTE *)(v1 + 192) = 1;
    *(_QWORD *)(v1 + 200) = *(_QWORD *)(result + 40);
  }
  return result;
}

void ___ZN15HTTP2Connection20setupScheduleIOBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke(uint64_t a1)
{
  HTTP2Connection::_onqueue_scheduleIO(*(HTTP2Connection **)(a1 + 32));
}

void HTTP2StreamBridge::~HTTP2StreamBridge(HTTP2StreamBridge *this)
{
  *(_QWORD *)this = &off_1E14E86B0;
  *((_QWORD *)this + 1) = &unk_1E14E8798;
  *((_QWORD *)this + 2) = &unk_1E14E8868;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
  *((_QWORD *)this + 2) = &off_1E14E5838;
}

{
  *(_QWORD *)this = &off_1E14E86B0;
  *((_QWORD *)this + 1) = &unk_1E14E8798;
  *((_QWORD *)this + 2) = &unk_1E14E8868;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
  *((_QWORD *)this + 2) = &off_1E14E5838;
}

CoreSchedulingSet *formCreate(__CFReadStream *a1, const __CFArray *a2)
{
  const __CFAllocator *v4;
  CoreSchedulingSet *v5;
  CFIndex Count;
  const __CFArray *MutableCopy;
  uint64_t v8;

  v4 = CFGetAllocator(a1);
  v5 = (CoreSchedulingSet *)CFAllocatorAllocate(v4, 56, 0);
  *(_QWORD *)v5 = CoreSchedulingSet::createEmpty(v5);
  Count = CFArrayGetCount(a2);
  MutableCopy = CFArrayCreateMutableCopy(v4, Count, a2);
  *((_QWORD *)v5 + 1) = MutableCopy;
  v8 = FormContentLengthWithArray(MutableCopy);
  *((_QWORD *)v5 + 2) = 0;
  *((_QWORD *)v5 + 3) = 0;
  *((_QWORD *)v5 + 4) = a1;
  *((_QWORD *)v5 + 5) = v8;
  *((_QWORD *)v5 + 6) = 0;
  return v5;
}

void HTTP2StreamReleaseCallBack(const __CFAllocator *a1, char *a2)
{
  CFRelease(a2 - 16);
}

_DWORD *__copy_helper_block_ea8_48c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE64c17_ZTS11HTTP3Fields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  size_t v9;
  char *v10;

  v4 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  v8 = *(_BYTE **)(a2 + 64);
  v7 = *(_BYTE **)(a2 + 72);
  v9 = v7 - v8;
  if (v7 != v8)
  {
    std::vector<char>::__vallocate[abi:nn180100]((_QWORD *)(a1 + 64), v7 - v8);
    v10 = *(char **)(a1 + 72);
    memmove(v10, v8, v9);
    *(_QWORD *)(a1 + 72) = &v10[v9];
  }
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  return std::vector<std::pair<unsigned short,unsigned short>>::__init_with_size[abi:nn180100]<std::pair<unsigned short,unsigned short>*,std::pair<unsigned short,unsigned short>*>((_DWORD *)(a1 + 88), *(int **)(a2 + 88), *(int **)(a2 + 96), (uint64_t)(*(_QWORD *)(a2 + 96) - *(_QWORD *)(a2 + 88)) >> 2);
}

void sub_183FAFAA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZNK20StrictSecurityPolicy23reportATSExceptionEventEPK10__CFString_block_invoke(uint64_t a1)
{
  SecTrustReportNetworkingAnalytics();
  xpc_release(*(xpc_object_t *)(a1 + 32));
}

uint64_t ___ZN14CFNetworkTrust13evaluateAsyncEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvNS_14QuantizedErrorEE_block_invoke(uint64_t a1, int a2, SecTrustResultType a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = CFNetworkTrust::processEvaluateResult(*(SecTrustRef **)(a1 + 40), a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 16))(v3, v4);
}

uint64_t CFNetworkTrust::processEvaluateResult(SecTrustRef *this, SecTrustResultType a2)
{
  CFArrayRef v4;
  const __CFArray *v5;
  unint64_t Count;
  CFRange v7;
  const void **v8;
  CFIndex v9;
  const __CFDictionary *v10;
  const void *Value;
  const void *v12;
  char v13;
  int v14;
  char v15;
  CFArrayRef v16;
  const __CFArray *v17;
  const __CFArray *v18;
  __SecCertificate *ValueAtIndex;
  CFDataRef v20;
  SecTrustRef v21;
  unint64_t v22;
  CFIndex v23;
  const void **v24;
  CFIndex v25;
  CFDataRef v26;
  const void *v27;
  unsigned int v28;
  _BOOL4 v29;
  int v30;
  unsigned int v31;
  int v32;
  char v33;
  CFTypeRef v34;
  CFIndex range;
  const void **v36;
  _BYTE v37[248];
  CFIndex v38;
  CFRange v39;

  switch(a2)
  {
    case kSecTrustResultProceed:
      return 0;
    case kSecTrustResultDeny:
      return 2;
    case kSecTrustResultUnspecified:
      return 0;
  }
  v4 = SecTrustCopyProperties(this[1]);
  if (!v4)
  {
    *((_BYTE *)this + 32) |= 0x10u;
    *((_DWORD *)this + 9) = -9807;
    goto LABEL_28;
  }
  v5 = v4;
  v34 = CFRetain(v4);
  Count = CFArrayGetCount(v5);
  v7.length = Count;
  range = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    v36 = 0;
  }
  else
  {
    if (Count <= 0x1E)
    {
      v8 = (const void **)v37;
      v36 = (const void **)v37;
LABEL_13:
      v7.location = 0;
      CFArrayGetValues(v5, v7, v8);
      v7.length = range;
      goto LABEL_14;
    }
    v8 = (const void **)malloc_type_malloc(8 * Count, 0x89ED541CuLL);
    v36 = v8;
    v7.length = range;
    if (v8)
      goto LABEL_13;
  }
LABEL_14:
  v38 = 0;
  if (v7.length > 0)
  {
    v9 = 0;
    do
    {
      v38 = v9 + 1;
      v10 = (const __CFDictionary *)v36[v9];
      Value = CFDictionaryGetValue(v10, CFSTR("value"));
      v12 = CFDictionaryGetValue(v10, CFSTR("type"));
      if (CFEqual(v12, CFSTR("error")))
      {
        if (CFEqual(Value, CFSTR("Root certificate is not trusted.")))
        {
          v13 = *((_BYTE *)this + 32) | 1;
        }
        else if (CFEqual(Value, CFSTR("Hostname mismatch.")))
        {
          v13 = *((_BYTE *)this + 32) | 2;
        }
        else
        {
          v14 = CFEqual(Value, CFSTR("One or more certificates have expired or are not valid yet."));
          v15 = *((_BYTE *)this + 32);
          if (!v14)
          {
            *((_BYTE *)this + 32) = v15 | 0x10;
            *((_DWORD *)this + 9) = -9807;
            goto LABEL_24;
          }
          v13 = v15 | 4;
        }
        *((_BYTE *)this + 32) = v13;
      }
LABEL_24:
      v9 = v38;
    }
    while (v38 < range);
  }
  CFRelease(v5);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v34);
LABEL_28:
  v16 = this[2];
  if (!v16 && (v16 = SecTrustCopyCertificateChain(this[1]), (this[2] = v16) == 0)
    || (v17 = (const __CFArray *)CFRetain(v16)) == 0)
  {
    LODWORD(v20) = 0;
    goto LABEL_57;
  }
  v18 = v17;
  if (CFArrayGetCount(v17) < 1)
  {
    LODWORD(v20) = 0;
  }
  else
  {
    ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v18, 0);
    LODWORD(v20) = 0;
    if (ValueAtIndex)
    {
      v21 = this[3];
      if (v21)
      {
        v20 = SecCertificateCopyData(ValueAtIndex);
        if (v20)
        {
          v34 = CFRetain(v21);
          v22 = CFArrayGetCount(v21);
          v23 = v22;
          range = v22;
          if (v22 - 1 > 0x1FFFFFFFFFFFFFFDLL)
          {
            v36 = 0;
          }
          else
          {
            if (v22 <= 0x1E)
            {
              v24 = (const void **)v37;
              v36 = (const void **)v37;
LABEL_42:
              v39.location = 0;
              v39.length = v23;
              CFArrayGetValues(v21, v39, v24);
              v23 = range;
              goto LABEL_43;
            }
            v24 = (const void **)malloc_type_malloc(8 * v22, 0x89ED541CuLL);
            v36 = v24;
            v23 = range;
            if (v24)
              goto LABEL_42;
          }
LABEL_43:
          if (v23 <= 0)
          {
            v27 = 0;
          }
          else
          {
            v25 = 0;
            do
            {
              v26 = SecCertificateCopyData((SecCertificateRef)v36[v25]);
              if (v26)
              {
                if (CFEqual(v20, v26))
                  v27 = CFArrayGetValueAtIndex(v21, v25);
                else
                  v27 = 0;
                CFRelease(v26);
              }
              else
              {
                v27 = 0;
              }
              ++v25;
            }
            while (v25 < v23 && !v27);
          }
          CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v34);
          CFRelease(v20);
          LODWORD(v20) = v27 != 0;
        }
      }
    }
  }
  CFRelease(v18);
LABEL_57:
  v28 = *((unsigned __int8 *)this + 32);
  v29 = (_DWORD)v20 != 0;
  v30 = v29 & (v28 >> 4);
  if (v30)
    v31 = v28 & 0xFFFFFFEF;
  else
    v31 = *((unsigned __int8 *)this + 32);
  v32 = v29 & (v31 >> 3);
  if (v32)
    v33 = v31 & 0xF7;
  else
    v33 = v31;
  if ((v30 & 1) == 0 && (v32 & 1) == 0)
  {
    if ((v33 & 1) == 0)
      goto LABEL_66;
LABEL_69:
    if ((*((_BYTE *)this + 33) & 4) == 0 && !(_DWORD)v20)
      goto LABEL_74;
    LOBYTE(v28) = v33 & 0xFE;
    *((_BYTE *)this + 32) = v33 & 0xFE;
    v33 &= ~1u;
    if ((v33 & 2) == 0)
      goto LABEL_74;
LABEL_72:
    if ((_DWORD)v20)
    {
      LOBYTE(v28) = v33 & 0xFD;
      *((_BYTE *)this + 32) = v33 & 0xFD;
      v33 &= ~2u;
    }
    goto LABEL_74;
  }
  *((_BYTE *)this + 32) = v33;
  LOBYTE(v28) = v33;
  if ((v33 & 1) != 0)
    goto LABEL_69;
LABEL_66:
  if ((v33 & 2) != 0)
    goto LABEL_72;
LABEL_74:
  if ((v33 & 4) != 0 && ((*((_BYTE *)this + 33) & 1) != 0 || (_DWORD)v20))
  {
    LOBYTE(v28) = v33 & 0xFB;
    *((_BYTE *)this + 32) = v33 & 0xFB;
    v33 &= ~4u;
  }
  if ((v33 & 0x40) != 0 && ((*((_BYTE *)this + 33) & 4) != 0 || (_DWORD)v20))
  {
    LOBYTE(v28) = v33 & 0xBF;
    *((_BYTE *)this + 32) = v33 & 0xBF;
    v33 &= ~0x40u;
  }
  if (v33 < 0 && ((*((_BYTE *)this + 33) & 1) != 0 || (_DWORD)v20))
  {
    LOBYTE(v28) = v33 & 0x7F;
    *((_BYTE *)this + 32) = v33 & 0x7F;
  }
  return (v28 & 0xDF) != 0;
}

void sub_183FAFF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

BOOL ConnectionProtocolRemoveInputHandler(_QWORD *a1, uint64_t a2, int a3)
{
  _QWORD *v4;
  _BOOL8 result;
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  uint32_t v9;
  uint64_t v10;
  uint64_t v12;
  NSObject *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    result = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(v17) = 0;
    v7 = "protocol is nullptr";
    v8 = v6;
    v9 = 2;
LABEL_13:
    _os_log_error_impl(&dword_183ECA000, v8, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&v17, v9);
    return 0;
  }
  v4 = (_QWORD *)a1[5];
  if (!v4)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v10 = CFNLog::logger;
    result = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LODWORD(v17) = 136315138;
    *(_QWORD *)((char *)&v17 + 4) = "ConnectionProtocolRemoveInputHandler";
    v7 = "Connection is invalid in %s";
    v8 = v10;
    v9 = 12;
    goto LABEL_13;
  }
  *(_QWORD *)(a2 + 32) = 0;
  if (a1[6] != a2)
    return 0;
  v12 = a1[4];
  if (v12)
  {
    (*(void (**)(void))(*(_QWORD *)(v12 + 24) + 8))();
    a1[4] = 0;
  }
  a1[6] = 0;
  if (a3)
  {
    a1[5] = 0;
    v13 = v4[10];
    if (v13)
    {
      dispatch_release(v13);
      v4[10] = 0;
    }
    v17 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v4 + 8), &v17);
    v14 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
    if (*((_QWORD *)&v17 + 1))
    {
      v15 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    free(v4);
  }
  return 1;
}

void __destroy_helper_block_e8_40c49_ZTSNSt3__18weak_ptrI24HTTPConnectionCacheEntryEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void ___ZN17RequestBodyStream20_onqueue_setupStreamEv_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  int v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  NSObject *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD v12[6];
  std::__shared_weak_count *v13;
  char v14;

  v2 = a1[4];
  if (CFReadStreamGetStatus(*(CFReadStreamRef *)(v2 + 120)))
    __assert_rtn("_onqueue_setupStream_block_invoke", "HTTPRequestBody.cpp", 878, "CFReadStreamGetStatus(_stream.get()) == kCFStreamStatusNotOpen");
  CFReadStreamOpen(*(CFReadStreamRef *)(v2 + 120));
  if (CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)(v2 + 120)))
    v3 = (*(unsigned __int8 *)(v2 + 192) >> 2) & 1;
  else
    LOBYTE(v3) = 0;
  v5 = a1[5];
  v4 = (std::__shared_weak_count *)a1[6];
  v6 = *(NSObject **)(v5 + 48);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3321888768;
  v12[2] = ___ZN17RequestBodyStream20_onqueue_setupStreamEv_block_invoke_2;
  v12[3] = &__block_descriptor_57_e8_40c45_ZTSNSt3__110shared_ptrI17RequestBodyStreamEE_e5_v8__0l;
  v14 = v3;
  v12[4] = v2;
  v12[5] = v5;
  v13 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  dispatch_async(v6, v12);
  v9 = v13;
  if (v13)
  {
    v10 = (unint64_t *)&v13->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

uint64_t __copy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

const __CFAllocator *CFObject::_cfobj_retain(CFObject *this, const __CFAllocator *a2, const void *a3)
{
  CFRetain((char *)a2 - 16);
  return a2;
}

void ___ZN17RequestBodyStream20_onqueue_setupStreamEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  char v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_BYTE *)(v1 + 192);
  *(_BYTE *)(v1 + 192) = v2 | 8;
  if (*(_BYTE *)(a1 + 56))
    *(_BYTE *)(v1 + 192) = v2 | 0x18;
  RequestBodyStream::_onqueue_resume(*(RequestBodyStream **)(a1 + 40));
}

__CFReadStream *formEventCallback(__CFReadStream *result, uint64_t a2, _QWORD *a3)
{
  if (a2 == 16)
  {
    result = (__CFReadStream *)openNextStream(a3);
    if (a3[2])
      return result;
    return (__CFReadStream *)CFReadStreamSignalEvent();
  }
  if (a2 != 8)
  {
    if (a2 != 2)
      return result;
    return (__CFReadStream *)CFReadStreamSignalEvent();
  }
  CFReadStreamGetError(result);
  return (__CFReadStream *)CFReadStreamSignalEvent();
}

uint64_t __destroy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __copy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14HTTPStallTimerEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t SocketStream::open(SocketStream *this, const void *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  pthread_mutex_t *v8;
  uint64_t delayInitStub;
  double v10;
  uint64_t v11;
  double v12;
  double v13;
  const void *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFNumber *Value;
  int v20;
  CFStringRef (__cdecl *v21)(const void *);
  uint64_t *v22;
  dispatch_object_t v23;
  NSObject *v24;
  const __CFData *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  char *v31;
  int v32;
  unint64_t v33;
  __CFRunLoop *v34;
  uint64_t v36;
  NSObject *v37;
  const __CFDictionary *v38;
  const __CFDictionary *v39;
  const __CFString *v40;
  const __CFNumber *v41;
  const __CFNumber *v42;
  const __CFAllocator *v43;
  __CFHost *v44;
  const void *v45;
  __CFHost *v46;
  __CFHost *v47;
  const __CFArray *Info;
  const __CFArray *v49;
  const __CFAllocator *v50;
  __CFError *CFErrorWithStreamError;
  int v52;
  const __CFDictionary *v53;
  __CFHost *v54;
  const __CFDictionary *v55;
  const __CFNumber *v56;
  __CFNetService *v57;
  const __CFArray *v58;
  const __CFArray **v59;
  const __CFArray *v60;
  const __CFArray *v61;
  const __CFArray **v62;
  const __CFArray *v63;
  uint64_t v64;
  __int128 v65;
  void (*v66[5])(_QWORD, _QWORD, _QWORD);
  CFBooleanRef BOOLean[5];
  socklen_t v68;
  int v69;
  socklen_t v70;
  CFHostClientContext block[3];
  __int128 valuePtr;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  CFRange v76;

  v75 = *MEMORY[0x1E0C80C00];
  a3->domain = 0;
  *(_QWORD *)&a3->error = 0;
  *a4 = 0;
  v8 = (pthread_mutex_t *)((char *)this + 40);
  delayInitStub = pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  if (*((_DWORD *)this + 102) == 1 && (*((_DWORD *)this + 62) & 0x80000000) == 0)
  {
    block[0].version = 0;
    block[0].info = (char *)this - 16;
    block[0].retain = (CFAllocatorRetainCallBack)MEMORY[0x1E0C98BD0];
    block[0].release = (CFAllocatorReleaseCallBack)MEMORY[0x1E0C98BC0];
    block[0].copyDescription = (CFAllocatorCopyDescriptionCallBack)MEMORY[0x1E0C98350];
    gotLoadHelper_x8___CTServerConnectionCreate(v10);
    if (*(_QWORD *)(v11 + 3856))
    {
      CFGetAllocator((CFTypeRef)delayInitStub);
      delayInitStub = _CTServerConnectionCreate_delayInitStub(v12);
      v14 = (const void *)delayInitStub;
      if (delayInitStub)
      {
        BOOLean[0] = 0;
        _CTServerConnectionCarrierSettingsCopyValue_delayInitStub(v13);
        CFRelease(v14);
      }
    }
  }
  v15 = 1024;
  if (*((const void **)this + 34) == a2)
    v15 = 512;
  v16 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | v15;
  *((_DWORD *)this + 62) |= v15;
  if (*((_QWORD *)this + 30))
  {
    if ((v16 & 2) == 0)
      goto LABEL_10;
LABEL_14:
    *a3 = *((CFStreamError *)this + 16);
    *a4 = 1;
    goto LABEL_60;
  }
  v17 = CoreSchedulingSet::copyRunloopEmulationSet((CoreSchedulingSet *)delayInitStub);
  v66[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  v66[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
  v66[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN12SocketStream4openEPKvP13CFStreamErrorPh_block_invoke;
  v66[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v66[4] = (void (*)(_QWORD, _QWORD, _QWORD))this;
  CoreSchedulingSet::applyBlockWithPossibleEmulation(v17, v66);
  (*(void (**)(uint64_t))(*(_QWORD *)v17 + 48))(v17);
  v18 = *((unsigned int *)this + 62);
  v16 = v18 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v18 & 2) != 0)
    goto LABEL_14;
LABEL_10:
  if ((v16 & 1) != 0)
    goto LABEL_60;
  *((_WORD *)this + 126) = WORD2(v16);
  *((_DWORD *)this + 62) = v16 | 1;
  if (!*((_DWORD *)this + 66))
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA800);
    if (!Value)
      goto LABEL_43;
    LODWORD(valuePtr) = 0;
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    v20 = valuePtr;
    v21 = (CFStringRef (__cdecl *)(const void *))dispatch_queue_attr_make_with_qos_class(0, (dispatch_qos_class_t)valuePtr, 0);
    if (v20 > 20)
    {
      switch(v20)
      {
        case 21:
          block[0].version = MEMORY[0x1E0C809B0];
          block[0].info = (void *)3221225472;
          block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_3;
          block[0].release = (CFAllocatorReleaseCallBack)&unk_1E14FE118;
          block[0].copyDescription = v21;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1)
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
          v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sDefaultTCPConnWorkQueue;
          break;
        case 25:
          block[0].version = MEMORY[0x1E0C809B0];
          block[0].info = (void *)3221225472;
          block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_2;
          block[0].release = (CFAllocatorReleaseCallBack)&unk_1E14FE118;
          block[0].copyDescription = v21;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1)
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
          v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInitiatedTCPConnWorkQueue;
          break;
        case 33:
          block[0].version = MEMORY[0x1E0C809B0];
          block[0].info = (void *)3221225472;
          block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke;
          block[0].release = (CFAllocatorReleaseCallBack)&unk_1E14FE118;
          block[0].copyDescription = v21;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1)
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
          v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInteractiveTCPConnWorkQueue;
          break;
        default:
          goto LABEL_49;
      }
    }
    else if (v20)
    {
      if (v20 != 9)
      {
        if (v20 == 17)
        {
          block[0].version = MEMORY[0x1E0C809B0];
          block[0].info = (void *)3221225472;
          block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_4;
          block[0].release = (CFAllocatorReleaseCallBack)&unk_1E14FE118;
          block[0].copyDescription = v21;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1)
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
          v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUtilityTCPConnWorkQueue;
          goto LABEL_41;
        }
LABEL_49:
        v23 = (dispatch_object_t)copyGlobalTCPConnWorkQueue();
        if (!v23)
        {
LABEL_43:
          if (*((_QWORD *)this + 36))
            goto LABEL_54;
          if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBDA8))
          {
            LODWORD(valuePtr) = -1;
            v25 = (const __CFData *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBDA8);
            if (v25)
            {
              v76.location = 0;
              v76.length = 4;
              CFDataGetBytes(v25, v76, (UInt8 *)&valuePtr);
              v26 = valuePtr;
            }
            else
            {
              v26 = -1;
            }
            v70 = 128;
            if (!getsockname(v26, (sockaddr *)block, &v70)
              && (BYTE1(block[0].version) == 30 || BYTE1(block[0].version) == 2))
            {
              v68 = 4;
              v69 = 0;
              if (!getsockopt(valuePtr, 0xFFFF, 4104, &v69, &v68) && v69 == 1)
              {
                if (dup(valuePtr) != -1)
                {
                  v36 = tcp_connection_create_with_connected_fd();
                  *((_QWORD *)this + 70) = v36;
                  if (v36)
                  {
                    SocketStream::startTCPConnection(this);
                    CFRetain((char *)this - 16);
                    v37 = *((_QWORD *)this + 71);
                    BOOLean[0] = (CFBooleanRef)MEMORY[0x1E0C809B0];
                    BOOLean[1] = (CFBooleanRef)3221225472;
                    BOOLean[2] = (CFBooleanRef)___ZN12SocketStream25startLookupForOpen_NoLockEv_block_invoke;
                    BOOLean[3] = (CFBooleanRef)&__block_descriptor_40_e5_v8__0l;
                    BOOLean[4] = this;
                    dispatch_async(v37, BOOLean);
                    goto LABEL_56;
                  }
                }
                *((_QWORD *)this + 32) = 1;
                v52 = 9;
LABEL_87:
                *((_DWORD *)this + 66) = v52;
                goto LABEL_56;
              }
            }
            *((_BYTE *)this + 407) = 1;
LABEL_54:
            if (!*((_DWORD *)this + 66))
              SocketStream::attemptNextConnection_NoLock(this);
            goto LABEL_56;
          }
          v27 = *((_QWORD *)this + 74);
          if (v27)
          {
            *((_QWORD *)this + 70) = v27;
            *((_QWORD *)this + 74) = 0;
            tcp_connection_accept();
            SocketStream::startTCPConnection(this);
            goto LABEL_56;
          }
          v38 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBF30);
          v39 = v38;
          if (!v38)
          {
            v53 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDD003E0);
            if (v53)
            {
              SocketStream::startTCPConnection_Proxy_Connect(this, v53);
              goto LABEL_56;
            }
            v54 = (__CFHost *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBDE0);
            v55 = (const __CFDictionary *)*((_QWORD *)this + 42);
            if (v54)
            {
              v56 = (const __CFNumber *)CFDictionaryGetValue(v55, &unk_1EDCFBE88);
              SocketStream::startTCPConnection_Host(this, v54, v56);
              goto LABEL_56;
            }
            v57 = (__CFNetService *)CFDictionaryGetValue(v55, &unk_1EDCFBE50);
            if (v57)
            {
              SocketStream::startTCPConnection_NetService(this, v57);
              goto LABEL_56;
            }
            if (*__error())
            {
              v52 = *__error();
              *((_QWORD *)this + 32) = 1;
            }
            else
            {
              *((_QWORD *)this + 32) = 1;
              v52 = 12;
            }
            goto LABEL_87;
          }
          v40 = (const __CFString *)CFDictionaryGetValue(v38, (const void *)*MEMORY[0x1E0C9B2C8]);
          v41 = (const __CFNumber *)CFDictionaryGetValue(v39, (const void *)*MEMORY[0x1E0C9B2D0]);
          if (!v40
            || (v42 = v41, v43 = CFGetAllocator((char *)this - 16), (v44 = CFHostCreateWithName(v43, v40)) == 0))
          {
            *((_QWORD *)this + 32) = 1;
            v52 = 22;
            goto LABEL_87;
          }
          SocketStream::startTCPConnection_Host(this, v44, v42);
          v45 = CFDictionaryGetValue(v39, (const void *)*MEMORY[0x1E0C9B2E0]);
          if (!v45)
            v45 = (const void *)*MEMORY[0x1E0C9B318];
          if (CFEqual(v45, (CFTypeRef)*MEMORY[0x1E0C9B310]))
          {
            v46 = (__CFHost *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBDE0);
            v47 = v46;
            if (v46)
            {
              v65 = *((_OWORD *)this + 19);
              valuePtr = v65;
              v73 = *((_QWORD *)this + 40);
              v74 = 0;
              Info = (const __CFArray *)CFHostGetInfo((uint64_t)v46, 0, 0);
              v49 = Info;
              if (Info)
              {
                if (CFArrayGetCount(Info))
                  goto LABEL_105;
                v50 = CFGetAllocator(v49);
                *(_OWORD *)&block[0].version = xmmword_1841E38E0;
                CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v50, (int *)block);
              }
              else
              {
                block[0].version = 0;
                block[0].info = (char *)this - 16;
                block[0].retain = (CFAllocatorRetainCallBack)MEMORY[0x1E0C98BD0];
                block[0].release = (CFAllocatorReleaseCallBack)MEMORY[0x1E0C98BC0];
                block[0].copyDescription = (CFAllocatorCopyDescriptionCallBack)MEMORY[0x1E0C98350];
                _CFHostSetClientInfoCallback(v47, (unint64_t)SocketStream::_SocksHostCallBack, block);
                v58 = (const __CFArray *)v65;
                if ((_QWORD)v65)
                {
                  v59 = (const __CFArray **)&valuePtr + 1;
                  v60 = (const __CFArray *)v65;
                  do
                  {
                    _CFTypeScheduleOnMultipleRunLoops(v47, v60);
                    v61 = *v59++;
                    v60 = v61;
                  }
                  while (v61);
                }
                if (HostBase::Class(void)::sOnce_HostBase != -1)
                  dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
                CFErrorWithStreamError = (__CFError *)(*(uint64_t (**)(_QWORD *, uint64_t, _QWORD, _QWORD))(*((_QWORD *)v47 + 2) + 56))((_QWORD *)v47 + 2, 0x1EDCFF6C0, 0, 0);
                if (CFErrorWithStreamError)
                {
                  if ((_QWORD)v65)
                  {
                    v62 = (const __CFArray **)&valuePtr + 1;
                    do
                    {
                      _CFTypeUnscheduleFromMultipleRunLoops(v47, v58);
                      v63 = *v62++;
                      v58 = v63;
                    }
                    while (v63);
                  }
                  _CFTypeInvalidate((char *)v47);
                }
              }
              if (CFErrorWithStreamError)
              {
                *((_QWORD *)this + 32) = _CFStreamErrorFromCFError(CFErrorWithStreamError);
                *((_QWORD *)this + 33) = v64;
                CFRelease(CFErrorWithStreamError);
                goto LABEL_106;
              }
LABEL_105:
              Schedulables::_add(*((Schedulables **)this + 41), v47);
              goto LABEL_106;
            }
            *((_QWORD *)this + 32) = 1;
            *((_DWORD *)this + 66) = 22;
          }
LABEL_106:
          CFRelease(v44);
          goto LABEL_56;
        }
LABEL_42:
        v24 = *((_QWORD *)this + 71);
        *((_QWORD *)this + 71) = v23;
        dispatch_release(v24);
        goto LABEL_43;
      }
      block[0].version = MEMORY[0x1E0C809B0];
      block[0].info = (void *)3221225472;
      block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_5;
      block[0].release = (CFAllocatorReleaseCallBack)&unk_1E14FE118;
      block[0].copyDescription = v21;
      if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1)
        dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
      v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sBackgroundTCPConnWorkQueue;
    }
    else
    {
      block[0].version = MEMORY[0x1E0C809B0];
      block[0].info = (void *)3221225472;
      block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_6;
      block[0].release = (CFAllocatorReleaseCallBack)&unk_1E14FE118;
      block[0].copyDescription = v21;
      if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1)
        dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
      v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUnspecifiedTCPConnWorkQueue;
    }
LABEL_41:
    v23 = (dispatch_object_t)*v22;
    dispatch_retain((dispatch_object_t)*v22);
    if (!v23)
      goto LABEL_43;
    goto LABEL_42;
  }
  *((_WORD *)this + 126) = WORD2(v16);
  *((_DWORD *)this + 62) = v16 & 0xFFFFFFEC | 3;
LABEL_56:
  v28 = *((unsigned int *)this + 62);
  v29 = v28 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v28 & 2) != 0)
  {
    *((_WORD *)this + 126) = WORD2(v29);
    *((_DWORD *)this + 62) = v29 & 0xFFFFFFFE;
    *a4 = 1;
  }
  if (*((_DWORD *)this + 66))
    *a3 = *((CFStreamError *)this + 16);
LABEL_60:
  if (a3->error)
  {
    v30 = 0;
    v32 = *((_DWORD *)this + 62);
    v31 = (char *)this + 248;
    v33 = v32 & 0xFFFFFFEF | ((unint64_t)*((unsigned __int16 *)v31 + 2) << 32);
    *(_DWORD *)v31 = v32 & 0xFFFFFFED | 2;
    *((_WORD *)v31 + 2) = WORD2(v33);
    *a4 = 1;
  }
  else
  {
    v34 = (__CFRunLoop *)*((_QWORD *)this + 30);
    if (v34)
      SocketStream::schedule_NoLock(this, a2, v34, CFSTR("_kCFStreamSocketBogusPrivateMode"));
    v30 = 1;
  }
  pthread_mutex_unlock(v8);
  return v30;
}

uint64_t `virtual thunk to'SocketStream::schedule(SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  char *v7;

  v7 = (char *)this + *(_QWORD *)(*(_QWORD *)this - 88);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 40));
  SocketStream::schedule_NoLock((SocketStream *)v7, a2, a3, a4);
  return pthread_mutex_unlock((pthread_mutex_t *)(v7 + 40));
}

void SocketStream::schedule_NoLock(SocketStream *this, CFTypeRef cf, __CFRunLoop *a3, const __CFString *a4)
{
  CFTypeID v8;
  CFTypeID TypeID;
  CFTypeRef v10;
  uint64_t v11;
  uint64_t v12;
  const __CFArray *v13;
  const __CFArray *v14;
  uint64_t v15;
  const __CFArray *v16;
  uint64_t v17;
  int v18;
  CFIndex Count;
  CFIndex v20;
  _QWORD v21[2];
  CFRange v22;

  v8 = CFGetTypeID(cf);
  TypeID = CFReadStreamGetTypeID();
  if (v8 == TypeID)
    v10 = (CFTypeRef)*((_QWORD *)this + 34);
  else
    v10 = (CFTypeRef)*((_QWORD *)this + 35);
  if (v10 != cf && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v21[0]) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "What stream is this??", (uint8_t *)v21, 2u);
  }
  v11 = 312;
  if (v8 == TypeID)
    v12 = 304;
  else
    v12 = 312;
  if (v8 != TypeID)
    v11 = 304;
  v13 = *(const __CFArray **)((char *)this + v11);
  v14 = *(const __CFArray **)((char *)this + v12);
  if (_SchedulesFind(*((const __CFArray **)this + 40), a3, a4) == -1 && _SchedulesFind(v14, a3, a4) == -1)
  {
    v15 = _SchedulesFind(v13, a3, a4);
    v16 = v14;
    if (v15 != -1)
    {
      _SchedulesRemoveRunLoopAndMode(v13, a3, a4);
      v16 = (const __CFArray *)*((_QWORD *)this + 40);
    }
    _SchedulesAddRunLoopAndMode(v16, a3, a4);
    v17 = *((_QWORD *)this + 41);
    v21[0] = a3;
    v21[1] = a4;
    v22.length = *(_QWORD *)(v17 + 24);
    v22.location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v17 + 16), v22, (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction, v21);
    v18 = *((_DWORD *)this + 62);
    if (v8 == TypeID)
    {
      if ((v18 & 4) != 0)
      {
        Count = CFArrayGetCount(v14);
        if (CFArrayGetCount(*((CFArrayRef *)this + 40)) + Count == 4)
          CFReadStreamSignalEvent();
      }
    }
    else if ((v18 & 8) != 0)
    {
      v20 = CFArrayGetCount(v14);
      if (CFArrayGetCount(*((CFArrayRef *)this + 40)) + v20 == 4)
        CFWriteStreamSignalEvent();
    }
  }
}

uint64_t _SchedulesFind(const __CFArray *a1, const void *a2, const void *a3)
{
  CFIndex Count;
  CFIndex v7;
  CFRange v8;
  CFIndex FirstIndexOfValue;
  CFIndex v10;
  const void *ValueAtIndex;

  Count = CFArrayGetCount(a1);
  if (!Count)
    return -1;
  v7 = Count;
  v8.location = 0;
  v8.length = Count;
  while (1)
  {
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(a1, v8, a2);
    v10 = FirstIndexOfValue;
    if (FirstIndexOfValue == -1)
      break;
    ValueAtIndex = CFArrayGetValueAtIndex(a1, FirstIndexOfValue + 1);
    if (CFEqual(ValueAtIndex, a3))
      break;
    v8.location = v10 + 2;
    v8.length = v7 - (v10 + 2);
    if (v7 == v10 + 2)
      return -1;
  }
  return v10;
}

uint64_t _SchedulesAddRunLoopAndMode(const __CFArray *a1, const void *a2, const void *a3)
{
  CFIndex Count;
  CFIndex v7;
  CFRange v8;
  CFIndex FirstIndexOfValue;
  CFIndex v10;
  const void *ValueAtIndex;

  Count = CFArrayGetCount(a1);
  if (Count)
  {
    v7 = Count;
    v8.location = 0;
    v8.length = Count;
    do
    {
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(a1, v8, a2);
      if (FirstIndexOfValue == -1)
        break;
      v10 = FirstIndexOfValue;
      ValueAtIndex = CFArrayGetValueAtIndex(a1, FirstIndexOfValue + 1);
      if (CFEqual(ValueAtIndex, a3))
        return 0;
      v8.location = v10 + 2;
      v8.length = v7 - (v10 + 2);
    }
    while (v7 != v10 + 2);
  }
  CFArrayAppendValue(a1, a2);
  CFArrayAppendValue(a1, a3);
  return 1;
}

CFIndex _SchedulesRemoveRunLoopAndMode(const __CFArray *a1, const void *a2, const void *a3)
{
  CFIndex result;
  CFIndex v7;
  CFRange v8;
  CFIndex FirstIndexOfValue;
  CFIndex v10;
  const void *ValueAtIndex;
  CFRange v12;

  result = CFArrayGetCount(a1);
  if (result)
  {
    v7 = result;
    v8.location = 0;
    v8.length = result;
    while (1)
    {
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(a1, v8, a2);
      if (FirstIndexOfValue == -1)
        return 0;
      v10 = FirstIndexOfValue;
      ValueAtIndex = CFArrayGetValueAtIndex(a1, FirstIndexOfValue + 1);
      if (CFEqual(ValueAtIndex, a3))
        break;
      v8.location = v10 + 2;
      v8.length = v7 - (v10 + 2);
      if (v7 == v10 + 2)
        return 0;
    }
    v12.location = v10;
    v12.length = 2;
    CFArrayReplaceValues(a1, v12, 0, 0);
    return 1;
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t __copy_helper_block_ea8_32c45_ZTSNSt3__18weak_ptrI20HTTP3ConnectionCacheEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __copy_helper_block_ea8_32c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __copy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN14NWIOConnection7sendEOFEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 40);
  if ((*(_WORD *)(v1 + 248) & 0x60) == 0 && (*(_DWORD *)(v1 + 136) - 5) >= 2)
  {
    v2 = *(_QWORD *)(a1 + 32);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v3 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v4 = *(_QWORD *)(v2 + 288);
      v5 = 134217984;
      v6 = v4;
      _os_log_debug_impl(&dword_183ECA000, v3, OS_LOG_TYPE_DEBUG, "Connection %llu: sent EOF", (uint8_t *)&v5, 0xCu);
    }
  }
}

void ___ZN10HTTPEngine22_readBufferCaptureBodyERNSt3__110shared_ptrI19HTTPResponseMessageEE_block_invoke(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

void ActualCredentialStorage::~ActualCredentialStorage(ActualCredentialStorage *this)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;

  *(_QWORD *)this = &off_1E14EC860;
  *((_QWORD *)this + 1) = &unk_1E14EC900;
  *((_QWORD *)this + 2) = &unk_1E14EC968;
  *((_QWORD *)this + 3) = &unk_1E14EC988;
  v2 = *((_QWORD *)this + 13);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 14);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *(_QWORD *)this = &off_1E14EBBE0;
  *((_QWORD *)this + 1) = &unk_1E14EBC30;
  *((_QWORD *)this + 2) = &unk_1E14EBC98;
  *((_QWORD *)this + 3) = &unk_1E14EBCB8;
  v4 = (const void *)*((_QWORD *)this + 12);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 3) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  *((_QWORD *)this + 2) = &off_1E14E5838;
}

void sub_183FB2754(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 32));
  *(_QWORD *)(v1 + 16) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void MemoryCredentialStorage::~MemoryCredentialStorage(MemoryCredentialStorage *this)
{
  uint64_t v2;

  MemoryCredentialStorage::~MemoryCredentialStorage(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  *(_QWORD *)this = off_1E14ECBE0;
  *((_QWORD *)this + 2) = &unk_1E14ECC38;
  *((_QWORD *)this + 3) = &unk_1E14ECCA0;
  *((_QWORD *)this + 6) = &off_1E14EA408;
  CFRelease(*((CFTypeRef *)this + 7));
  *((_QWORD *)this + 4) = &off_1E14EA3E8;
  CFRelease(*((CFTypeRef *)this + 5));
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

uint64_t __destroy_helper_block_e8_40c89_ZTS18SmartBlockWithArgsIJP15__CFHTTPMessagejPK10__CFStringiS_IJPK16_CFURLCredentialbEEEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t RetainableTypedDict<CoreSchedulingSet const*,GlueTubeManager *>::_visit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void formClose(__CFReadStream *a1, uint64_t a2)
{
  closeCurrentStream(a2);
}

uint64_t mmapFileDeallocate(void *a1, _QWORD *a2)
{
  uint64_t v4;
  pthread_mutex_t *v5;
  __CFSet *v6;
  NSObject *v7;
  const void *v8;
  int v10;
  _DWORD v11[2];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  v5 = (pthread_mutex_t *)(*a2 + 376);
  pthread_mutex_lock(v5);
  if (a1)
  {
    v6 = *(__CFSet **)(v4 + 448);
    if (v6)
      CFSetRemoveValue(v6, a1);
  }
  pthread_mutex_unlock(v5);
  if (munmap(a1, a2[1]) == -1)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v10 = *__error();
      v11[0] = 67109120;
      v11[1] = v10;
      _os_log_error_impl(&dword_183ECA000, v7, OS_LOG_TYPE_ERROR, "===== munmap failed. errno = %{errno}d", (uint8_t *)v11, 8u);
    }
  }
  v8 = *(const void **)(*a2 + 440);
  if (v8)
    CFRelease(v8);
  return MEMORY[0x186DB748C](a2, 0x1020C40EDED9539);
}

void __destroy_helper_block_e8_40c35_ZTSNSt3__18weak_ptrI10HTTPEngineEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE48c52_ZTSNSt3__110shared_ptrI24HTTPConnectionCacheEntryEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

_QWORD *__copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE48c52_ZTSNSt3__110shared_ptrI24HTTPConnectionCacheEntryEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void std::__tree<std::__value_type<std::string,std::vector<std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::string>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::vector<std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::string>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::vector<std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::string>>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void HTTP2ConnectionCacheEntry::~HTTP2ConnectionCacheEntry(HTTP2ConnectionCacheEntry *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFArray *v6;
  uint64_t v7;
  CFRange v8;

  *(_QWORD *)this = &off_1E14ED400;
  *((_QWORD *)this + 1) = &unk_1E14ED448;
  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 9) = 0;
  }
  v3 = *((_QWORD *)this + 3);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
    *((_QWORD *)this + 3) = 0;
  }
  v4 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 2);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
    *((_QWORD *)this + 2) = 0;
  }
  v6 = (const __CFArray *)*((_QWORD *)this + 11);
  v8.length = CFArrayGetCount(v6);
  v8.location = 0;
  CFArrayApplyFunction(v6, v8, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, &__block_literal_global_5_6328);
  v7 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  CFRelease(*((CFTypeRef *)this + 11));
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_183FB2B8C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 96);
  *(_QWORD *)(v1 + 96) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  CFRelease(*(CFTypeRef *)(v1 + 88));
  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void HTTP2ConnectionCache::~HTTP2ConnectionCache(HTTP2ConnectionCache *this)
{
  uint64_t v2;

  HTTP2ConnectionCache::~HTTP2ConnectionCache(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;

  *(_QWORD *)this = off_1E14EB3C8;
  *((_QWORD *)this + 4) = &unk_1E14EB478;
  v2 = *((_QWORD *)this + 10);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v3 = *((_QWORD *)this + 14);
  if (v3)
    dispatch_release(v3);
  v4 = *((_QWORD *)this + 15);
  if (v4)
    dispatch_release(v4);
  *((_QWORD *)this + 11) = &off_1E14EA4A8;
  CFRelease(*((CFTypeRef *)this + 12));
  *((_QWORD *)this + 4) = &off_1E14E5838;
  *(_QWORD *)this = off_1E14EA0F0;

}

void sub_183FB2C80(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 88) = &off_1E14EA4A8;
  CFRelease(*(CFTypeRef *)(v1 + 96));
  *(_QWORD *)(v1 + 32) = &off_1E14E5838;
  *(_QWORD *)v1 = off_1E14EA0F0;

  _Unwind_Resume(a1);
}

uint64_t ___ZN12XTubeManager24invalidateAllConnectionsEb_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v7[5];
  char v8;

  (*(void (**)(uint64_t))(*(_QWORD *)a3 + 40))(a3);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN12XTubeManager24invalidateAllConnectionsEb_block_invoke_2;
  v7[3] = &__block_descriptor_41_e5_v8__0l;
  v7[4] = a3;
  v8 = *(_BYTE *)(a1 + 32);
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a2 + 96))(a2, v7);
}

void ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  uint64_t v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  _QWORD v26[7];
  std::__shared_weak_count *v27;
  __int128 v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v33 = v3;
  v4 = (std::__shared_weak_count *)operator new();
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19B0;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  v34 = v4;
  v6 = *(_QWORD *)(v2 + 24);
  v26[0] = MEMORY[0x1E0C809B0];
  v26[1] = 3321888768;
  v26[2] = ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke_3;
  v26[3] = &unk_1E14F2280;
  v26[5] = v2;
  v26[6] = v3;
  v27 = v4;
  do
    v7 = __ldxr(p_shared_owners);
  while (__stxr(v7 + 1, p_shared_owners));
  v28 = *(_OWORD *)(a1 + 56);
  v26[4] = *(_QWORD *)(a1 + 40);
  v8 = *(std::__shared_weak_count **)(a1 + 80);
  v29 = *(_QWORD *)(a1 + 72);
  v30 = v8;
  if (v8)
  {
    v9 = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = *(std::__shared_weak_count **)(a1 + 96);
  v31 = *(_QWORD *)(a1 + 88);
  v32 = v11;
  if (v11)
  {
    v12 = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v26);
  v14 = v32;
  if (v32)
  {
    v15 = (unint64_t *)&v32->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = v30;
  if (v30)
  {
    v18 = (unint64_t *)&v30->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v27;
  if (v27)
  {
    v21 = (unint64_t *)&v27->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = v34;
  if (v34)
  {
    v24 = (unint64_t *)&v34->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

void sub_183FB2FC0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4 - 48);
  _Unwind_Resume(a1);
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_11(uint64_t a1)
{
  const __CFAllocator *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = CFGetAllocator((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
  return __cfnCreateCFError(v1, CFSTR("kCFErrorDomainCFNetwork"), -1003, v2, v3, v4, v5, v6, 0);
}

CFErrorRef __cfnCreateCFError(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  __CFDictionary *Mutable;
  const void **v16;
  const void *v17;
  const void *v18;
  CFErrorRef v20;
  uint64_t *v22;
  const void **v23;

  v22 = &a9;
  v12 = -1;
  do
  {
    v13 = v22++;
    ++v12;
  }
  while (*v13);
  if (v12 <= 3)
    return CFErrorCreate(allocator, domain, code, 0);
  v14 = v12 >> 1;
  Mutable = CFDictionaryCreateMutable(allocator, v12 >> 1, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  v23 = (const void **)&a9;
  if (v14 <= 1)
    v14 = 1;
  while (1)
  {
    v16 = v23;
    v17 = *v23;
    v23 += 2;
    v18 = v16[1];
    if (!v17 || v18 == 0)
      break;
    CFDictionarySetValue(Mutable, v17, v18);
    if (!--v14)
      goto LABEL_14;
  }
  CFRelease(Mutable);
  Mutable = 0;
LABEL_14:
  v20 = CFErrorCreate(allocator, domain, code, Mutable);
  if (Mutable)
    CFRelease(Mutable);
  return v20;
}

void ___ZN12HTTPProtocol48asynchronouslyAddAuthenticatorHeadersAndContinueEP15__CFHTTPMessage_block_invoke(_QWORD *a1, char a2, CFTypeRef cf, const void *a4)
{
  std::__shared_weak_count_vtbl *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  std::__shared_weak_count_vtbl *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  _QWORD v41[5];
  std::__shared_weak_count *v42;
  std::__shared_weak_count_vtbl *v43;
  std::__shared_weak_count *v44;
  std::__shared_weak_count_vtbl *v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  char v49;
  std::__shared_weak_count_vtbl *v50;
  std::__shared_weak_count *v51;
  std::__shared_weak_count_vtbl *v52;
  std::__shared_weak_count *v53;

  if (cf)
    v7 = (std::__shared_weak_count_vtbl *)CFRetain(cf);
  else
    v7 = 0;
  v52 = v7;
  v8 = (std::__shared_weak_count *)operator new();
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A58;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = v7;
  v53 = v8;
  if (a4)
    v10 = (std::__shared_weak_count_vtbl *)CFRetain(a4);
  else
    v10 = 0;
  v50 = v10;
  v11 = (std::__shared_weak_count *)operator new();
  v11->__shared_owners_ = 0;
  v12 = (unint64_t *)&v11->__shared_owners_;
  v11->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1A20;
  v11->__shared_weak_owners_ = 0;
  v11[1].__vftable = v10;
  v51 = v11;
  v14 = a1[4];
  v13 = (std::__shared_weak_count *)a1[5];
  v15 = *(_QWORD *)(v14 + 24);
  v41[0] = MEMORY[0x1E0C809B0];
  v41[1] = 3321888768;
  v41[2] = ___ZN12HTTPProtocol48asynchronouslyAddAuthenticatorHeadersAndContinueEP15__CFHTTPMessage_block_invoke_2;
  v41[3] = &__block_descriptor_97_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE64c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE_e5_v8__0l;
  v41[4] = v14;
  v42 = v13;
  if (v13)
  {
    v16 = (unint64_t *)&v13->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v49 = a2;
  v43 = v7;
  v44 = v8;
  do
    v18 = __ldxr(p_shared_owners);
  while (__stxr(v18 + 1, p_shared_owners));
  v45 = v10;
  v46 = v11;
  do
    v19 = __ldxr(v12);
  while (__stxr(v19 + 1, v12));
  v20 = (std::__shared_weak_count *)a1[7];
  v47 = a1[6];
  v48 = v20;
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v15 + 96))(v15, v41);
  v23 = v48;
  if (v48)
  {
    v24 = (unint64_t *)&v48->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  v26 = v46;
  if (v46)
  {
    v27 = (unint64_t *)&v46->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = v44;
  if (v44)
  {
    v30 = (unint64_t *)&v44->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v42;
  if (v42)
  {
    v33 = (unint64_t *)&v42->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v51;
  if (v51)
  {
    v36 = (unint64_t *)&v51->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = v53;
  if (v53)
  {
    v39 = (unint64_t *)&v53->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
}

void sub_183FB3450(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 96);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 80);
  _Unwind_Resume(a1);
}

CFTypeRef CoreSchedulingSet::createNewPrivateRunLoopThread(uint64_t a1, uint64_t a2, const void *a3)
{
  __CFN_CoreSchedulingSetRunnable *v6;
  id v7;
  void *v8;
  const void *v9;
  CFTypeRef v10;
  objc_super v12;

  v6 = [__CFN_CoreSchedulingSetRunnable alloc];
  if (v6)
  {
    v12.receiver = v6;
    v12.super_class = (Class)__CFN_CoreSchedulingSetRunnable;
    v7 = objc_msgSendSuper2(&v12, sel_init);
    if (v7)
    {
      *((_QWORD *)v7 + 1) = dispatch_semaphore_create(0);
      if (a3)
        *((_QWORD *)v7 + 2) = _Block_copy(a3);
      *((_QWORD *)v7 + 4) = 0;
    }
  }
  else
  {
    v7 = 0;
  }
  v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3978]), "initWithTarget:selector:object:", objc_opt_self(), sel__run_, v7);
  if (a1)
    objc_msgSend(v8, "setName:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  if (a2)
    (*(void (**)(uint64_t, void *))(a2 + 16))(a2, v8);
  objc_msgSend(v8, "start");
  if (v7
    && (dispatch_semaphore_wait(*((dispatch_semaphore_t *)v7 + 1), 0xFFFFFFFFFFFFFFFFLL),
        dispatch_release(*((dispatch_object_t *)v7 + 1)),
        *((_QWORD *)v7 + 1) = 0,
        (v9 = (const void *)*((_QWORD *)v7 + 4)) != 0))
  {
    v10 = CFRetain(v9);
  }
  else
  {
    v10 = 0;
  }

  return v10;
}

void sub_183FB3AB8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

CFTypeRef StorageSession::copyCredStorage(StorageSession *this)
{
  os_unfair_lock_s *v2;
  const __CFAllocator *v3;
  CFTypeRef result;

  v2 = (os_unfair_lock_s *)((char *)this + 48);
  os_unfair_lock_lock((os_unfair_lock_t)this + 12);
  if (!*((_BYTE *)this + 54))
  {
    *((_BYTE *)this + 54) = 1;
    if (!*((_QWORD *)this + 4))
    {
      v3 = CFGetAllocator((char *)this - 16);
      *((_QWORD *)this + 4) = _CFURLCredentialStorageCreateWithProperties(v3, 0, *((CFDictionaryRef *)this + 10));
    }
  }
  os_unfair_lock_unlock(v2);
  result = (CFTypeRef)*((_QWORD *)this + 4);
  if (result)
    return CFRetain(result);
  return result;
}

void sub_183FB3EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_48c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE64c17_ZTS11HTTP3Fields(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[8];
  if (v3)
  {
    a1[9] = v3;
    operator delete(v3);
  }
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 6));
}

void __destroy_helper_block_ea8_32c45_ZTSNSt3__18weak_ptrI20HTTP3ConnectionCacheEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void __destroy_helper_block_ea8_32c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void HTTP3ConnectionCacheEntryWrapper::~HTTP3ConnectionCacheEntryWrapper(HTTP3ConnectionCacheEntryWrapper *this)
{
  uint64_t v2;

  HTTP3ConnectionCacheEntryWrapper::~HTTP3ConnectionCacheEntryWrapper(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_1E14EF530;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *((_QWORD *)this + 5) = 0;
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
}

void sub_183FB3FDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 24);
  _Unwind_Resume(a1);
}

void GZIPDataDecoderHolder::~GZIPDataDecoderHolder(GZIPDataDecoderHolder *this)
{
  *((_QWORD *)this + 1) = &off_1E14E7728;
  if (*((_BYTE *)this + 128))
    inflateEnd((z_streamp)((char *)this + 16));
  *((_QWORD *)this + 1) = &off_1E14E4DA0;
}

{
  *((_QWORD *)this + 1) = &off_1E14E7728;
  if (*((_BYTE *)this + 128))
    inflateEnd((z_streamp)((char *)this + 16));
  *((_QWORD *)this + 1) = &off_1E14E4DA0;
}

void sub_183FB4038(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

void __acquireAssertion_block_invoke(double a1)
{
  double Helper_x8__OBJC_CLASS___RBSDomainAttribute;
  uint64_t v2;
  void *v3;
  double v4;
  double Helper_x8__OBJC_CLASS___RBSAcquisitionCompletionAttribute;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  double v10;
  double Helper_x8__OBJC_CLASS___RBSTarget;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  _QWORD v15[3];

  v15[2] = *MEMORY[0x1E0C80C00];
  Helper_x8__OBJC_CLASS___RBSDomainAttribute = gotLoadHelper_x8__OBJC_CLASS___RBSDomainAttribute(a1);
  objc_msgSend(*(id *)(v2 + 3288), "attributeWithDomain:name:", CFSTR("com.apple.common"), CFSTR("FinishTaskUninterruptable"), Helper_x8__OBJC_CLASS___RBSDomainAttribute);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v15[0] = v3;
  Helper_x8__OBJC_CLASS___RBSAcquisitionCompletionAttribute = gotLoadHelper_x8__OBJC_CLASS___RBSAcquisitionCompletionAttribute(v4);
  objc_msgSend(*(id *)(v6 + 3208), "attributeWithCompletionPolicy:", 1, Helper_x8__OBJC_CLASS___RBSAcquisitionCompletionAttribute);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v15[1] = v7;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v15, 2);
  v8 = objc_claimAutoreleasedReturnValue();
  v9 = (void *)acquireAssertion_attributes;
  acquireAssertion_attributes = v8;

  Helper_x8__OBJC_CLASS___RBSTarget = gotLoadHelper_x8__OBJC_CLASS___RBSTarget(v10);
  objc_msgSend(*(id *)(v12 + 3568), "currentProcess", Helper_x8__OBJC_CLASS___RBSTarget);
  v13 = objc_claimAutoreleasedReturnValue();
  v14 = (void *)acquireAssertion_target;
  acquireAssertion_target = v13;

}

void sub_183FB45F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v7 = v6;

  _Unwind_Resume(a1);
}

BOOL typesNotEqualWithAppropriateNullChecks(const void *a1, const void *a2)
{
  return a1 && !a2 || !a1 && a2 || a1 && !CFEqual(a1, a2);
}

BOOL dictsNotEqualWithAppropriateNullAndEmptyDictionaryChecks(CFDictionaryRef theDict, const __CFDictionary *a2)
{
  int v4;
  int v5;

  if (!theDict)
  {
    v4 = 1;
    if (a2)
      goto LABEL_3;
LABEL_5:
    v5 = 1;
    return v5 != v4 || (v4 & 1) == 0 && !CFEqual(theDict, a2);
  }
  v4 = CFDictionaryGetCount(theDict) == 0;
  if (!a2)
    goto LABEL_5;
LABEL_3:
  v5 = CFDictionaryGetCount(a2) == 0;
  return v5 != v4 || (v4 & 1) == 0 && !CFEqual(theDict, a2);
}

uint64_t __destroy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __copy_helper_block_e8_40c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

CFStreamStatus ___ZN17RequestBodyStream19_onqueue_pollStreamEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  CFStreamStatus result;

  v2 = *(_QWORD *)(a1 + 32);
  if (CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)(v2 + 120)))
    return RequestBodyStream::_bodyStreamEventOccurred_offqueue(*(RequestBodyStream **)(a1 + 40));
  result = CFReadStreamGetStatus(*(CFReadStreamRef *)(v2 + 120));
  if ((result | 2) == 7)
    return RequestBodyStream::_bodyStreamEventOccurred_offqueue(*(RequestBodyStream **)(a1 + 40));
  return result;
}

void ___ZN15HTTP2Connection19handleSETTINGSFrameEPK13nghttp2_frame_block_invoke(uint64_t a1)
{
  uint64_t v1;
  __int128 v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_OWORD *)(a1 + 40);
  *(_QWORD *)(v1 + 196) = *(_QWORD *)(a1 + 56);
  *(_OWORD *)(v1 + 180) = v2;
  *(_BYTE *)(v1 + 228) = 1;
  HTTP2Connection::_onqueue_scheduleIO((HTTP2Connection *)v1);
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t __destroy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14HTTPStallTimerEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

uint64_t __copy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_2(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

unint64_t URLRequest::hash(URLRequest *this)
{
  CFHashCode fURL;

  fURL = (CFHashCode)this->fURL;
  if (fURL)
    fURL = CFHash((CFTypeRef)fURL);
  return fURL ^ (4 * this->fCachePolicy);
}

uint64_t __copy_helper_block_e8_32c36_ZTSNSt3__18weak_ptrI11HTTP2StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void sub_183FB5124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void BrotliDataDecoderHolder::~BrotliDataDecoderHolder(BrotliDataDecoderHolder *this)
{
  *((_QWORD *)this + 1) = &off_1E14E83F0;
  if (*((_BYTE *)this + 56))
    compression_stream_destroy((compression_stream *)((char *)this + 16));
  *((_QWORD *)this + 1) = &off_1E14E4DA0;
}

{
  *((_QWORD *)this + 1) = &off_1E14E83F0;
  if (*((_BYTE *)this + 56))
    compression_stream_destroy((compression_stream *)((char *)this + 16));
  *((_QWORD *)this + 1) = &off_1E14E4DA0;
}

void sub_183FB529C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E4DA0;
  _Unwind_Resume(a1);
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_Read(__NSCFTCPIOReadStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  os_unfair_lock_s *v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  size_t size;
  size_t v17;
  size_t v18;
  NSObject *v19;
  dispatch_data_t subrange;
  const void *v21;
  NSObject *v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  BOOL v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  SInt32 error;
  uint64_t v38;
  _QWORD v40[5];
  _QWORD applier[7];
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  __int128 buf;
  __n128 (*v47)(uint64_t);
  void *v48;
  uint64_t v49;
  CFStreamError *v50;
  unsigned __int8 *v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  a5->domain = 0;
  a5->error = 0;
  *a6 = 0;
  v42 = 0;
  v43 = &v42;
  v44 = 0x2020000000;
  v45 = 0;
  v12 = (os_unfair_lock_s *)((char *)this + 112);
  os_unfair_lock_lock((os_unfair_lock_t)this + 28);
  if (*((_BYTE *)this + 129))
  {
    v43[3] = 0;
    v13 = *((_QWORD *)this + 13);
    if (v13)
    {
      dispatch_release(v13);
      v14 = 0;
      *((_QWORD *)this + 13) = 0;
      goto LABEL_29;
    }
    goto LABEL_8;
  }
  v15 = *((_QWORD *)this + 13);
  if (v15)
  {
    size = dispatch_data_get_size(*((dispatch_data_t *)this + 13));
    if (!size)
    {
LABEL_8:
      v14 = 0;
      goto LABEL_29;
    }
    v17 = size;
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke;
    applier[3] = &unk_1E14FBC10;
    applier[4] = &v42;
    applier[5] = a4;
    applier[6] = a3;
    dispatch_data_apply(v15, applier);
    v18 = v43[3];
    v19 = *((_QWORD *)this + 13);
    if (v17 == v18)
    {
      subrange = 0;
      v14 = 1;
    }
    else
    {
      subrange = dispatch_data_create_subrange(v19, v18, v17 - v18);
      v14 = 0;
      v19 = *((_QWORD *)this + 13);
    }
    dispatch_release(v19);
    *((_QWORD *)this + 13) = subrange;
    v25 = v43;
    v26 = v43[3];
    v28 = *((_QWORD *)this + 17);
    v27 = *((_QWORD *)this + 18);
    v29 = v28 >= v26;
    v30 = v28 - v26;
    if (v30 != 0 && v29)
    {
      if (v27 != v28)
      {
        *((_QWORD *)this + 17) = v30;
        *((_QWORD *)this + 18) = v27 - v25[3];
      }
      goto LABEL_25;
    }
    if (v27 == v28)
    {
LABEL_25:
      TCPIO_Delegate::setProperty(*((TCPIO_Delegate **)this + 11), &unk_1EDCFAE20, (CFTypeRef)*MEMORY[0x1E0C9AE40]);
      goto LABEL_29;
    }
    TCPIO_Delegate::setProperty(*((TCPIO_Delegate **)this + 11), &unk_1EDCFAE20, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    *((_QWORD *)this + 17) = 0;
    v31 = v43[3];
    v32 = *((_QWORD *)this + 18);
    v29 = v32 >= v31;
    v33 = v32 - v31;
    if (!v29)
      v33 = 0;
    *((_QWORD *)this + 18) = v33;
  }
  else
  {
    v21 = (const void *)(*(uint64_t (**)(__NSCFTCPIOReadStream *, __CFReadStream *))(*(_QWORD *)this + 16))(this, a2);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v22 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v21;
      _os_log_impl(&dword_183ECA000, v22, OS_LOG_TYPE_INFO, "StreamTask polling read of %@", (uint8_t *)&buf, 0xCu);
    }
    if (v21)
      CFRelease(v21);
    v23 = *((_QWORD *)this + 11);
    v24 = *(NSObject **)(v23 + 40);
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 3221225472;
    v47 = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
    v48 = &__block_descriptor_56_e5_v8__0l;
    v49 = v23;
    v50 = a5;
    v51 = a6;
    dispatch_sync(v24, &buf);
    if (!a5->error && !a5->domain)
    {
      a5->domain = 1;
      a5->error = 57;
    }
    v14 = 0;
    *a6 = 1;
    v43[3] = -1;
  }
LABEL_29:
  if (*((_QWORD *)this + 13))
    goto LABEL_30;
  v35 = *((_QWORD *)this + 11);
  v36 = *(NSObject **)(v35 + 40);
  *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
  *((_QWORD *)&buf + 1) = 3221225472;
  v47 = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
  v48 = &__block_descriptor_56_e5_v8__0l;
  v49 = v35;
  v50 = a5;
  v51 = a6;
  dispatch_sync(v36, &buf);
  if (a5->domain)
  {
    error = a5->error;
    if (error)
    {
      if (a5->domain == 1 && error == 57)
      {
        a5->domain = 0;
        a5->error = 0;
        *a6 = 1;
      }
      goto LABEL_40;
    }
  }
  if (*a6)
  {
LABEL_40:
    os_unfair_lock_unlock(v12);
    goto LABEL_41;
  }
LABEL_30:
  os_unfair_lock_unlock(v12);
  if (*(_DWORD *)(*((_QWORD *)this + 15) + 40))
  {
    CFRetain(*((CFTypeRef *)this + 1));
    v34 = *((_QWORD *)this + 15);
    v40[0] = MEMORY[0x1E0C809B0];
    v40[1] = 3221225472;
    v40[2] = ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke_2;
    v40[3] = &__block_descriptor_40_e5_v8__0l;
    v40[4] = this;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v34 + 96))(v34, v40);
  }
  else if (v14)
  {
    __NSCFTCPIOReadStream::issueDelegateRead(this);
  }
LABEL_41:
  v38 = v43[3];
  _Block_object_dispose(&v42, 8);
  return v38;
}

void sub_183FB56F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke(_QWORD *a1, int a2, uint64_t a3, void *__src, size_t a5)
{
  size_t v5;
  size_t v8;

  v5 = a1[5] - *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  if (!v5)
    return 0;
  if (v5 >= a5)
    v8 = a5;
  else
    v8 = a1[5] - *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  memcpy((void *)(a1[6] + a3), __src, v8);
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += v8;
  return a1[5] > *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
}

void TCPIO_Delegate::setProperty(TCPIO_Delegate *this, CFTypeRef cf, CFTypeRef a3)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  NSObject *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD v18[5];
  std::__shared_weak_count *v19;
  CFTypeRef v20;
  CFTypeRef v21;

  if (cf)
    CFRetain(cf);
  if (a3)
    CFRetain(a3);
  v6 = *((_QWORD *)this + 3);
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = *((_QWORD *)this + 5);
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3321888768;
  v18[2] = ___ZN14TCPIO_Delegate11setPropertyEPK10__CFStringPKv_block_invoke;
  v18[3] = &__block_descriptor_64_e8_32c53_ZTSNSt3__110shared_ptrI25TransportConnectionObjCPPEE_e5_v8__0l;
  v18[4] = v6;
  v19 = v7;
  if (v7)
  {
    v11 = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v20 = cf;
  v21 = a3;
  dispatch_async(v10, v18);
  v13 = v19;
  if (!v19)
    goto LABEL_15;
  v14 = (unint64_t *)&v19->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    if (!v7)
      return;
  }
  else
  {
LABEL_15:
    if (!v7)
      return;
  }
  v16 = (unint64_t *)&v7->__shared_owners_;
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t __destroy_helper_block_e8_48c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void __destroy_helper_block_e8_32c36_ZTSNSt3__18weak_ptrI11HTTP2StreamEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

uint64_t __copy_helper_block_e8_48c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN17RequestBodyStream21bodyStopProvidingDataEv_block_invoke(uint64_t a1)
{
  _Block_release(*(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = 0;
}

__n128 ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke(uint64_t a1)
{
  __n128 *v1;
  __n128 result;

  v1 = *(__n128 **)(a1 + 32);
  result = v1[3];
  *(__n128 *)*(_QWORD *)(a1 + 40) = result;
  **(_BYTE **)(a1 + 48) = v1[4].n128_u8[0];
  return result;
}

void initializeUserAgentString(void)
{
  const __CFAllocator *v0;
  CFMutableStringRef Mutable;
  __CFString *v2;
  __CFBundle *MainBundle;
  const void **v4;
  __CFBundle *v5;
  const __CFDictionary *InfoDictionary;
  const __CFString *Value;
  const __CFURL *v9;
  const __CFURL *v10;
  const __CFString *PathComponent;
  const __CFString *v12;
  const __CFString *v13;
  CFStringRef v14;
  CFStringRef v15;
  CFTypeRef ValueForInfoDictionaryKey;
  const __CFString *v17;
  const __CFString *v18;
  CFStringRef v19;
  const __CFString *v20;
  const __CFString *v21;
  CFStringRef v22;
  CFStringRef Copy;
  int v25[2];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (sUserAgentString)
    return;
  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (Mutable)
  {
    v2 = Mutable;
    MainBundle = CFBundleGetMainBundle();
    v4 = (const void **)MEMORY[0x1E0C9AE90];
    if (!MainBundle)
      goto LABEL_23;
    v5 = MainBundle;
    InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
    if (dyld_program_sdk_at_least())
    {
      if (!InfoDictionary)
        goto LABEL_14;
      Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, (const void *)*MEMORY[0x1E0C9AE88]);
    }
    else
    {
      Value = (const __CFString *)CFBundleGetValueForInfoDictionaryKey(v5, (CFStringRef)*MEMORY[0x1E0C9AE88]);
    }
    if (Value)
    {
      appendEscaped(v2, Value);
      if (!InfoDictionary)
        goto LABEL_20;
      goto LABEL_17;
    }
LABEL_14:
    v9 = CFBundleCopyExecutableURL(v5);
    if (!v9)
      goto LABEL_23;
    v10 = v9;
    PathComponent = CFURLCopyLastPathComponent(v9);
    if (!PathComponent)
    {
      v15 = (CFStringRef)v10;
      goto LABEL_22;
    }
    v12 = PathComponent;
    appendEscaped(v2, PathComponent);
    CFRelease(v12);
    CFRelease(v10);
    if (!InfoDictionary)
    {
LABEL_20:
      CFStringAppendFormat(v2, 0, CFSTR(" %@"), CFSTR("(unknown version)"));
      goto LABEL_23;
    }
LABEL_17:
    v13 = (const __CFString *)CFDictionaryGetValue(InfoDictionary, *v4);
    if (v13)
    {
      v14 = CFURLCreateStringByAddingPercentEscapes(v0, v13, 0, CFSTR("()<>@,;:\\\"/[]?={} \t"), 0x8000100u);
      CFStringAppendFormat(v2, 0, CFSTR("/%@"), v14);
      v15 = v14;
LABEL_22:
      CFRelease(v15);
LABEL_23:
      if (CFStringGetLength(v2))
        CFStringAppendFormat(v2, 0, CFSTR(" %@"), CFSTR("CFNetwork"));
      else
        CFStringAppend(v2, CFSTR("CFNetwork"));
      if (__CFNGetCFNetworkBundle::onceToken != -1)
        dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4752);
      ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey((CFBundleRef)__CFNGetCFNetworkBundle::bundle, (CFStringRef)*v4);
      if (ValueForInfoDictionaryKey)
        CFStringAppendFormat(v2, 0, CFSTR("/%@"), ValueForInfoDictionaryKey);
      else
        CFStringAppendFormat(v2, 0, CFSTR(" %@"), CFSTR("(unknown version)"));
      *(_QWORD *)v25 = 0x100000001;
      v17 = copySysctl(v25);
      if (v17)
      {
        v18 = v17;
        v19 = CFURLCreateStringByAddingPercentEscapes(v0, v17, 0, CFSTR("()<>@,;:\\\"/[]?={} \t"), 0x8000100u);
        CFStringAppendFormat(v2, 0, CFSTR(" %@"), v19);
        CFRelease(v19);
        CFRelease(v18);
        *(_QWORD *)v25 = 0x200000001;
        v20 = copySysctl(v25);
        if (v20)
        {
          v21 = v20;
          v22 = CFURLCreateStringByAddingPercentEscapes(v0, v20, 0, CFSTR("()<>@,;:\\\"/[]?={} \t"), 0x8000100u);
          CFStringAppendFormat(v2, 0, CFSTR("/%@"), v22);
          CFRelease(v22);
          CFRelease(v21);
        }
        else
        {
          CFStringAppendFormat(v2, 0, CFSTR(" %@"), CFSTR("(unknown version)"));
        }
      }
      Copy = CFStringCreateCopy(v0, v2);
      while (!__ldaxr((unint64_t *)&sUserAgentString))
      {
        if (!__stlxr((unint64_t)Copy, (unint64_t *)&sUserAgentString))
          goto LABEL_41;
      }
      __clrex();
      if (Copy)
        CFRelease(Copy);
LABEL_41:
      CFRelease(v2);
      return;
    }
    goto LABEL_20;
  }
  while (!__ldaxr((unint64_t *)&sUserAgentString))
  {
    if (!__stlxr(0x1EDCFDB68uLL, (unint64_t *)&sUserAgentString))
      return;
  }
  __clrex();
}

CFStringRef copySysctl(int *a1)
{
  size_t v2;
  char cStr[128];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = 128;
  if (sysctl(a1, 2u, cStr, &v2, 0, 0) < 0)
    return 0;
  else
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
}

void sub_183FB62C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_183FB63B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void copyATSExceptionDomain(const void *a1, const void *a2, __CFDictionary *a3)
{
  CFTypeID v6;
  CFTypeID v7;

  v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    v7 = CFGetTypeID(a2);
    if (v7 == CFDictionaryGetTypeID())
      CFDictionarySetValue(a3, a1, a2);
  }
}

intptr_t ___ZNK17CoreSchedulingSet11performSyncEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

CFTypeRef ___ZN17RequestBodyStream12copyPropertyEPK10__CFString_block_invoke(uint64_t a1)
{
  CFTypeRef result;

  result = CFReadStreamCopyProperty(*(CFReadStreamRef *)(a1 + 40), *(CFStreamPropertyKey *)(a1 + 48));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t ___ZN20HTTP3ConnectionCache17_timersInitializeEv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZN20HTTP2ConnectionCache15initCacheTimersEv_block_invoke_4(uint64_t a1)
{
  _QWORD **v1;

  v1 = *(_QWORD ***)(a1 + 32);
  (*(void (**)(_QWORD *))(*v1[13] + 48))(v1[13]);
  return ((uint64_t (*)(_QWORD **))(*v1)[6])(v1);
}

uint64_t ___ZN20HTTP2ConnectionCache15initCacheTimersEv_block_invoke_2(uint64_t a1)
{
  _QWORD **v1;

  v1 = *(_QWORD ***)(a1 + 32);
  (*(void (**)(_QWORD *))(*v1[13] + 48))(v1[13]);
  return ((uint64_t (*)(_QWORD **))(*v1)[6])(v1);
}

uint64_t ___ZN19HTTPConnectionCache15enableCellTimerEv_block_invoke_2(uint64_t a1)
{
  _QWORD **v1;

  v1 = *(_QWORD ***)(a1 + 32);
  (*(void (**)(_QWORD *))(*v1[13] + 48))(v1[13]);
  return ((uint64_t (*)(_QWORD **))(*v1)[6])(v1);
}

void ___ZN15HTTP3Connection4stopEb_block_invoke(uint64_t a1)
{
  HTTP3Connection::_cleanupConnection(*(HTTP3Connection **)(a1 + 32), 256, *(unsigned __int8 *)(a1 + 48));
}

CFTypeRef ___ZL22_coreSchedulingSet_RLMv_block_invoke()
{
  __CFRunLoop *v0;
  CFTypeRef result;

  v0 = +[NSURLConnection resourceLoaderRunLoop](NSURLConnection, "resourceLoaderRunLoop");
  if (v0)
  {
    result = CFRetain(v0);
    _coreSchedulingSet_RLM(void)::sLoaderRunLoop = (uint64_t)result;
    if (result)
      return result;
  }
  else
  {
    _coreSchedulingSet_RLM(void)::sLoaderRunLoop = 0;
  }
  result = CoreSchedulingSet::createNewPrivateRunLoopThread((uint64_t)"com.apple.CFNetwork.LoaderRL", 0, 0);
  _coreSchedulingSet_RLM(void)::sLoaderRunLoop = (uint64_t)result;
  return result;
}

void sub_183FB6850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void DiskCookieStorage::_handleCookiesChangedNotification(DiskCookieStorage *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  if (*((_BYTE *)a2 + 325))
    *((_BYTE *)a2 + 325) = 0;
  else
    *((_BYTE *)a2 + 324) = 1;
}

void HTTP2Connection::~HTTP2Connection(HTTP2Connection *this)
{
  char *v2;
  HTTPStallTimer *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  const void *v7;
  NSObject *v8;
  uint64_t v9;
  _QWORD *v10;
  const __CFAllocator *v11;
  const __CFString *v12;
  uint64_t v13;
  void (**v14)(_QWORD, _QWORD, double);
  CFErrorRef v15;
  _QWORD *v16;
  NSObject *v17;
  const void *v18;
  _QWORD v19[2];
  void (*v20)(uint64_t);
  void *v21;
  CFErrorRef v22;
  __int128 v23;

  *(_QWORD *)this = &off_1E14E77C8;
  *((_QWORD *)this + 1) = &unk_1E14E7840;
  *((_QWORD *)this + 2) = &unk_1E14E7860;
  *((_QWORD *)this + 3) = &unk_1E14E78B0;
  v2 = (char *)this + 648;
  v3 = (HTTPStallTimer *)*((_QWORD *)this + 81);
  if (v3)
  {
    HTTPStallTimer::invalidate(v3);
    v23 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v23);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
    if (*((_QWORD *)&v23 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  HTTP2Connection::flushAllBatchedData(this);
  v7 = (const void *)*((_QWORD *)this + 29);
  if (v7)
  {
    CFRelease(v7);
    *((_QWORD *)this + 29) = 0;
  }
  v8 = *((_QWORD *)this + 21);
  if (v8)
  {
    dispatch_release(v8);
    *((_QWORD *)this + 21) = 0;
  }
  if (*((_QWORD *)this + 20))
  {
    nghttp2_session_del();
    *((_QWORD *)this + 20) = 0;
  }
  v9 = *((_QWORD *)this + 30);
  if (v9)
  {
    CFRelease((CFTypeRef)(v9 - 16));
    *((_QWORD *)this + 30) = 0;
  }
  v10 = (_QWORD *)*((_QWORD *)this + 86);
  if (v10)
  {
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v12 = (const __CFString *)*MEMORY[0x1E0C9AFD0];
    v13 = MEMORY[0x1E0C809B0];
    do
    {
      v14 = (void (**)(_QWORD, _QWORD, double))v10[4];
      v15 = CFErrorCreate(v11, v12, 57, 0);
      ((void (**)(_QWORD, CFErrorRef, double))v14)[2](v14, v15, 0.0);
      v19[0] = v13;
      v19[1] = 3221225472;
      v20 = ___ZN15HTTP2ConnectionD2Ev_block_invoke;
      v21 = &__block_descriptor_40_e5_v8__0l;
      v22 = v15;
      _Block_release(v14);
      v20((uint64_t)v19);
      v10 = (_QWORD *)*v10;
    }
    while (v10);
  }
  v16 = (_QWORD *)*((_QWORD *)this + 89);
  if (v16)
    v16[1] = 0;

  v17 = *((_QWORD *)this + 90);
  *((_QWORD *)this + 89) = 0;
  *((_QWORD *)this + 90) = 0;
  if (v17)
    dispatch_release(v17);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)this + 672);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v2);
  std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::destroy(*((_QWORD **)this + 77));
  v18 = (const void *)*((_QWORD *)this + 73);
  *((_QWORD *)this + 73) = 0;
  if (v18)
    CFRelease(v18);
  HTTP2ServerPush::~HTTP2ServerPush((HTTP2Connection *)((char *)this + 288));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 272);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 56);
  *((_QWORD *)this + 4) = &off_1E14EA428;
  CFRelease(*((CFTypeRef *)this + 5));
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_183FB6C70(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v4;
  const void *v5;

  v4 = *(NSObject **)(v1 + 720);
  *(_QWORD *)(v1 + 720) = 0;
  if (v4)
    dispatch_release(v4);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table(v1 + 672);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::destroy(*(_QWORD **)(v1 + 616));
  v5 = *(const void **)(v1 + 584);
  *(_QWORD *)(v1 + 584) = 0;
  if (v5)
    CFRelease(v5);
  HTTP2ServerPush::~HTTP2ServerPush((HTTP2ServerPush *)(v1 + 288));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 272);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 56);
  *(_QWORD *)(v1 + 32) = &off_1E14EA428;
  CFRelease(*(CFTypeRef *)(v1 + 40));
  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

BOOL SocketStream::canWrite(SocketStream *this, __CFWriteStream *a2)
{
  uint64_t v3;

  return (*((_DWORD *)this + 62) & 0x60000000) == 0
      && SocketStream::streamCan((uint64_t)this, a2, 2, (const __CFString *)&unk_1EDCFB0C0, &v3) != 0;
}

uint64_t SocketStream::streamCan(uint64_t a1, const void *a2, int a3, const __CFString *a4, _QWORD *a5)
{
  pthread_mutex_t *v10;
  CFTypeID TypeID;
  CFTypeID v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  BOOL v16;
  uint64_t v17;
  const __CFArray *v18;
  CFIndex Count;
  int v20;
  CFRunLoopRef Current;
  __CFSocket *v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  __CFSocket *v26;
  uint64_t v27;
  const void *v28;
  uint64_t v29;
  CFRunLoopRef v30;
  int v31;
  id WeakRetained;
  const void *v33;
  id v34;
  const void *v35;
  const __CFAllocator *v37;
  CFRunLoopSourceRef RunLoopSource;
  __CFRunLoopSource *v39;
  __CFRunLoop *v40;
  const __CFAllocator *v41;
  CFRunLoopSourceRef v42;
  __CFRunLoopSource *v43;
  __CFRunLoop *v44;
  CFRunLoopRef v45;
  const __CFString *v46;
  CFRange v47;
  CFRange v48;

  *a5 = 0;
  a5[1] = 0;
  v10 = (pthread_mutex_t *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
  TypeID = CFReadStreamGetTypeID();
  v12 = CFGetTypeID(a2);
  v13 = *(unsigned __int8 *)(a1 + 248);
  v14 = (v13 >> (a3 + 1)) & 1;
  v15 = *(_DWORD *)(a1 + 264);
  if (v15)
    v16 = 0;
  else
    v16 = (_DWORD)v14 == 0;
  if (v16)
  {
    v17 = 312;
    if (TypeID == v12)
      v17 = 304;
    v18 = *(const __CFArray **)(a1 + v17);
    if (((v13 >> a3) & 0x10) != 0
      || (Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 320)), CFArrayGetCount(v18) + Count < 3))
    {
      Current = CFRunLoopGetCurrent();
      _SchedulesAddRunLoopAndMode(v18, Current, a4);
      v22 = *(__CFSocket **)(a1 + 288);
      if (v22
        && CFSocketIsValid(v22)
        && (v23 = *(_QWORD *)(a1 + 328), *(_QWORD *)(v23 + 24) == 1)
        && (v24 = *(const void **)(a1 + 288), v24 == CFArrayGetValueAtIndex(*(CFArrayRef *)(v23 + 16), 0)))
      {
        v37 = CFGetAllocator((CFTypeRef)(a1 - 16));
        RunLoopSource = CFSocketCreateRunLoopSource(v37, *(CFSocketRef *)(a1 + 288), 0);
        if (RunLoopSource)
        {
          v39 = RunLoopSource;
          v40 = CFRunLoopGetCurrent();
          CFRunLoopAddSource(v40, v39, a4);
          CFRelease(v39);
        }
      }
      else
      {
        v25 = *(_QWORD *)(a1 + 328);
        v45 = CFRunLoopGetCurrent();
        v46 = a4;
        v47.length = *(_QWORD *)(v25 + 24);
        v47.location = 0;
        CFArrayApplyFunction(*(CFArrayRef *)(v25 + 16), v47, (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction, &v45);
      }
      pthread_mutex_unlock(v10);
      CFRunLoopRunInMode(a4, 0.0, 0);
      pthread_mutex_lock(v10);
      v26 = *(__CFSocket **)(a1 + 288);
      if (v26
        && CFSocketIsValid(v26)
        && (v27 = *(_QWORD *)(a1 + 328), *(_QWORD *)(v27 + 24) == 1)
        && (v28 = *(const void **)(a1 + 288), v28 == CFArrayGetValueAtIndex(*(CFArrayRef *)(v27 + 16), 0)))
      {
        v41 = CFGetAllocator((CFTypeRef)(a1 - 16));
        v42 = CFSocketCreateRunLoopSource(v41, *(CFSocketRef *)(a1 + 288), 0);
        if (v42)
        {
          v43 = v42;
          v44 = CFRunLoopGetCurrent();
          CFRunLoopRemoveSource(v44, v43, a4);
          CFRelease(v43);
        }
      }
      else
      {
        v29 = *(_QWORD *)(a1 + 328);
        v45 = CFRunLoopGetCurrent();
        v46 = a4;
        v48.length = *(_QWORD *)(v29 + 24);
        v48.location = 0;
        CFArrayApplyFunction(*(CFArrayRef *)(v29 + 16), v48, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction, &v45);
      }
      v30 = CFRunLoopGetCurrent();
      _SchedulesRemoveRunLoopAndMode(v18, v30, a4);
      v14 = (*(unsigned __int8 *)(a1 + 248) >> (a3 + 1)) & 1;
    }
    else
    {
      if (a3)
      {
        if (a3 == 2)
        {
          v20 = 64;
        }
        else
        {
          if (a3 != 1)
            goto LABEL_53;
          v20 = 32;
        }
      }
      else
      {
        v20 = 16;
      }
      v14 = 0;
      *(_DWORD *)(a1 + 248) |= v20;
    }
    v15 = *(_DWORD *)(a1 + 264);
  }
  if (!v15)
    goto LABEL_45;
  *(_OWORD *)a5 = *(_OWORD *)(a1 + 256);
  if (a3)
  {
    if (a3 != 2)
    {
      if (a3 == 1)
      {
        v31 = 4;
        goto LABEL_33;
      }
LABEL_53:
      abort();
    }
    v31 = 8;
  }
  else
  {
    v31 = 2;
  }
LABEL_33:
  *(_DWORD *)(a1 + 248) |= v31;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 272));
  v33 = WeakRetained;
  if ((!*(_QWORD *)(a1 + 232) || *(uint64_t *)(a1 + 224) < 1) && WeakRetained)
  {
    if ((*(_DWORD *)(a1 + 248) & 0x200) != 0)
      _CFReadStreamSignalEventDelayed();
    goto LABEL_39;
  }
  if (WeakRetained)
LABEL_39:
    CFRelease(v33);
  v34 = objc_loadWeakRetained((id *)(a1 + 280));
  if (v34)
  {
    v35 = v34;
    if ((*(_DWORD *)(a1 + 248) & 0x400) != 0)
      _CFWriteStreamSignalEventDelayed();
    CFRelease(v35);
  }
  v14 = 1;
LABEL_45:
  pthread_mutex_unlock(v10);
  return v14;
}

uint64_t __destroy_helper_block_e8_72c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE88c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 72;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 88);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

uint64_t __destroy_helper_block_e8_48c36_ZTSNSt3__110shared_ptrI9__CFErrorEE80c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE96c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = a1 + 48;
  v2 = a1 + 80;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 96);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

uint64_t __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

_QWORD *__copy_helper_block_e8_72c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE88c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[10];
  result[9] = a2[9];
  result[10] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[12];
  result[11] = a2[11];
  result[12] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

_QWORD *__copy_helper_block_e8_48c36_ZTSNSt3__110shared_ptrI9__CFErrorEE80c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE96c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[11];
  result[10] = a2[10];
  result[11] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[13];
  result[12] = a2[12];
  result[13] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  return result;
}

_QWORD *__copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE64c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = a2[9];
  result[8] = a2[8];
  result[9] = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = a2[11];
  result[10] = a2[10];
  result[11] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  return result;
}

_QWORD *__copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t `virtual thunk to'SocketStream::canRead(SocketStream *this, __CFReadStream *a2)
{
  return SocketStream::canRead((SocketStream *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 112)), a2);
}

uint64_t ReadStreamCallbacks::_canRead(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(_QWORD *)((char *)a2
                                                                              + *(_QWORD *)(*(_QWORD *)a2 - 136))
                                                                  + 96))((char *)a2 + *(_QWORD *)(*(_QWORD *)a2 - 136), this);
}

void CFObject::_cfobj_release(CFObject *this, const __CFAllocator *a2, const void *a3)
{
  CFRelease((char *)a2 - 16);
}

void sub_183FB7B9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FB7C90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *_CFHSTSPolicyCreateWithStorageLocation(CFURLRef url)
{
  uint64_t v2;
  CFURLRef v3;
  _QWORD *Instance;
  _QWORD *v5;
  CFTypeRef cf;

  v2 = *MEMORY[0x1E0C9AE00];
  if (url)
    v3 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], url, CFSTR("HSTS.plist"), 0);
  else
    v3 = 0;
  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  v5 = Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    v5 = Instance + 2;
    Instance[4] = 0;
  }
  cf = v3;
  HSTSPolicy::HSTSPolicy(v5, v2, url != 0, (uint64_t *)&cf);
  if (cf)
    CFRelease(cf);
  return v5 - 2;
}

void sub_183FB7DD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

_QWORD *HSTSPolicy::HSTSPolicy(_QWORD *a1, uint64_t a2, int a3, uint64_t *a4)
{
  _OWORD *Instance;
  _OWORD *v8;
  const void *v9;
  uint64_t v10;
  char v11;
  NSObject *v12;
  const __CFURL *v13;
  const __CFAllocator *v14;
  const __CFAllocator *v15;
  __CFReadStream *v16;
  __CFReadStream *v17;
  UInt8 *v18;
  CFIndex v19;
  const __CFData *v20;
  __CFError *v21;
  char v22;
  __CFError *v23;
  uint64_t v24;
  CFPropertyListRef v25;
  CFTypeID v26;
  const __CFDictionary *Mutable;
  const __CFAllocator *v28;
  const void *v29;
  const __CFDictionary *Value;
  _OWORD *v31;
  const __CFAllocator *v32;
  CFIndex Count;
  CFMutableDictionaryRef MutableCopy;
  const __CFAllocator *v35;
  CFMutableDictionaryRef v36;
  const void *v37;
  NSObject *v38;
  NSObject *v39;
  dispatch_queue_t v40;
  CFErrorRef v42;
  CFErrorRef error;
  CFIndex valuePtr;
  _BYTE propertyValueTypeRefPtr[12];
  __int16 v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  *a1 = &off_1E14E4908;
  a1[1] = &unk_1E14E4950;
  if (HSTSCache::Class(void)::sOnce_HSTSCache != -1)
    dispatch_once(&HSTSCache::Class(void)::sOnce_HSTSCache, &__block_literal_global_1_14738);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v8 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v8 = Instance + 1;
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
  }
  v9 = 0;
  v10 = *a4;
  *a4 = 0;
  *(_QWORD *)v8 = &off_1E14EFE00;
  *((_QWORD *)v8 + 1) = &unk_1E14EFE48;
  v8[1] = 0u;
  v8[2] = 0u;
  v8[3] = 0u;
  *((_QWORD *)v8 + 8) = v10;
  *((_BYTE *)v8 + 72) = 0;
  *((_BYTE *)v8 + 73) = a3;
  *((_QWORD *)v8 + 10) = 0;
  v11 = 1;
  *((_BYTE *)v8 + 88) = 0;
  if (!a3 || !v10)
  {
LABEL_53:
    v28 = CFGetAllocator(v8 - 1);
    Mutable = CFDictionaryCreateMutable(v28, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if ((v11 & 1) != 0)
      goto LABEL_55;
    goto LABEL_54;
  }
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v12 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v24 = *((_QWORD *)v8 + 8);
    *(_DWORD *)propertyValueTypeRefPtr = 134218242;
    *(_QWORD *)&propertyValueTypeRefPtr[4] = v8;
    v46 = 2112;
    v47 = v24;
    _os_log_debug_impl(&dword_183ECA000, v12, OS_LOG_TYPE_DEBUG, "Using HSTS %p path %@", propertyValueTypeRefPtr, 0x16u);
  }
  v42 = 0;
  error = 0;
  v13 = (const __CFURL *)*((_QWORD *)v8 + 8);
  *(_QWORD *)propertyValueTypeRefPtr = 0;
  if (!CFURLCopyResourcePropertyForKey(v13, (CFStringRef)*MEMORY[0x1E0C9B4A8], propertyValueTypeRefPtr, &error))
    goto LABEL_25;
  v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!*(_QWORD *)propertyValueTypeRefPtr)
  {
    error = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], 1, 0);
LABEL_25:
    v20 = 0;
LABEL_26:
    v9 = 0;
    v22 = 1;
    goto LABEL_43;
  }
  valuePtr = 0;
  if (!CFNumberGetValue(*(CFNumberRef *)propertyValueTypeRefPtr, kCFNumberCFIndexType, &valuePtr))
  {
    v23 = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 27, 0);
LABEL_30:
    v20 = 0;
    error = v23;
    goto LABEL_37;
  }
  if (!valuePtr)
  {
    v20 = CFDataCreate(v14, 0, 0);
    goto LABEL_37;
  }
  if (v14)
    v15 = v14;
  else
    v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE30];
  v16 = CFReadStreamCreateWithFile(v14, v13);
  v17 = v16;
  if (!v16)
  {
    v23 = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], 1, 0);
    goto LABEL_30;
  }
  if (CFReadStreamOpen(v16))
  {
    v18 = (UInt8 *)CFAllocatorAllocate(v15, valuePtr, 0);
    if (v18)
    {
      v19 = CFReadStreamRead(v17, v18, valuePtr);
      if (v19 < 0)
      {
        v21 = CFReadStreamCopyError(v17);
        goto LABEL_34;
      }
      v20 = CFDataCreateWithBytesNoCopy(v15, v18, v19, v15);
      if (!v20)
      {
        v21 = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 12, 0);
LABEL_34:
        error = v21;
        CFAllocatorDeallocate(v15, v18);
        v20 = 0;
      }
    }
    else
    {
      v20 = 0;
      error = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 12, 0);
    }
    CFReadStreamClose(v17);
    goto LABEL_36;
  }
  v20 = 0;
  error = CFReadStreamCopyError(v17);
LABEL_36:
  CFRelease(v17);
LABEL_37:
  CFRelease(*(CFTypeRef *)propertyValueTypeRefPtr);
  if (!v20)
    goto LABEL_26;
  v25 = CFPropertyListCreateWithData(v14, v20, 1uLL, 0, &v42);
  v9 = v25;
  if (v42 || (v26 = CFGetTypeID(v25), v26 == CFDictionaryGetTypeID()) || !v9)
  {
    v22 = 0;
  }
  else
  {
    CFRelease(v9);
    v22 = 0;
    v9 = 0;
  }
LABEL_43:
  if (error)
    CFRelease(error);
  if (v42)
    CFRelease(v42);
  if ((v22 & 1) == 0)
    CFRelease(v20);
  if (!v9)
  {
    v11 = 1;
    goto LABEL_53;
  }
  Mutable = (const __CFDictionary *)CFRetain(v9);
  if (!Mutable)
  {
    v11 = 0;
    goto LABEL_53;
  }
LABEL_54:
  CFRelease(v9);
LABEL_55:
  v29 = (const void *)*((_QWORD *)v8 + 6);
  *((_QWORD *)v8 + 6) = Mutable;
  if (v29)
  {
    CFRelease(v29);
    Mutable = (const __CFDictionary *)*((_QWORD *)v8 + 6);
  }
  if (Mutable)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(Mutable, CFSTR("com.apple.CFNetwork.defaultStorageSession"));
    v31 = v8 - 1;
    if (Value)
    {
      v32 = CFGetAllocator(v31);
      Count = CFDictionaryGetCount(Value);
      MutableCopy = CFDictionaryCreateMutableCopy(v32, Count, Value);
    }
    else
    {
      v35 = CFGetAllocator(v31);
      MutableCopy = CFDictionaryCreateMutable(v35, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    v36 = MutableCopy;
    v37 = (const void *)*((_QWORD *)v8 + 7);
    *((_QWORD *)v8 + 7) = v36;
    if (v37)
    {
      CFRelease(v37);
      v36 = (CFMutableDictionaryRef)*((_QWORD *)v8 + 7);
    }
    CFDictionarySetValue(*((CFMutableDictionaryRef *)v8 + 6), CFSTR("com.apple.CFNetwork.defaultStorageSession"), v36);
  }
  v38 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *((_QWORD *)v8 + 2) = dispatch_queue_create("com.apple.hstscache.workqueue", v38);
  if (*((_BYTE *)v8 + 73))
  {
    v39 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v40 = dispatch_queue_create("com.apple.hstscache.persistqueue", v39);
  }
  else
  {
    v40 = 0;
  }
  *((_QWORD *)v8 + 3) = v40;
  *((_BYTE *)v8 + 88) = 0;
  a1[2] = v8;
  return a1;
}

void sub_183FB8370(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  const void *v3;
  const void *v4;
  const void *v6;
  const void *v7;
  const void *v8;

  CFRelease(v4);
  if (v3)
    CFRelease(v3);
  v6 = (const void *)v2[8];
  v2[8] = 0;
  if (v6)
    CFRelease(v6);
  v7 = (const void *)v2[7];
  v2[7] = 0;
  if (v7)
    CFRelease(v7);
  v8 = (const void *)v2[6];
  v2[6] = 0;
  if (v8)
    CFRelease(v8);
  v2[1] = &off_1E14E5838;
  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void sub_183FB84B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FB8A48(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t withHostsSPILocked(uint64_t a1)
{
  void *v2;

  if (withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::sOnce != -1)
    dispatch_once(&withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::sOnce, &__block_literal_global_439);
  v2 = (void *)withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::gSyncObject;
  objc_sync_enter((id)withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::gSyncObject);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::allowAnyHTTPCertificateHostSet, withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::allowSpecificHTTPCertificateHostDict);
  return objc_sync_exit(v2);
}

void sub_183FB8C04(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_e8_40c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t __destroy_helper_block_e8_32c53_ZTSNSt3__110shared_ptrI25TransportConnectionObjCPPEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __destroy_helper_block_e8_32c124_ZTS18SmartBlockWithArgsIJbPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorPU32objcproto21OS_nw_content_contextS0_EE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __copy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c53_ZTSNSt3__110shared_ptrI25TransportConnectionObjCPPEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c124_ZTS18SmartBlockWithArgsIJbPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorPU32objcproto21OS_nw_content_contextS0_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t ___ZNK14TCPIO_Delegate12copyPropertyEPK10__CFString_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = a1[6];
  v3 = *(_QWORD *)(*(_QWORD *)(a1[5] + 24) + 24);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 216))(v3, v2);
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

void ___ZN20HTTP2ConnectionCache32_onqueue_base_remove_connectionsEbb_block_invoke(uint64_t a1, void *a2, HTTP2ConnectionCacheEntry *this)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 32);
  HTTP2ConnectionCacheEntry::stopConnections(this, *(_BYTE *)(a1 + 40));
  TubeManager::invalidateKey(*(_QWORD *)(v4 + 104), a2, 1, 1u);
}

void HTTP2ConnectionCacheEntry::stopConnections(HTTP2ConnectionCacheEntry *this, char a2)
{
  const __CFArray *v3;
  _QWORD context[4];
  char v5;
  CFRange v6;

  if (!*((_BYTE *)this + 105))
  {
    *((_BYTE *)this + 105) = 1;
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 3221225472;
    context[2] = ___ZN25HTTP2ConnectionCacheEntry15stopConnectionsEb_block_invoke;
    context[3] = &__block_descriptor_33_e9_v16__0_v8l;
    v5 = a2;
    v3 = (const __CFArray *)*((_QWORD *)this + 11);
    v6.length = CFArrayGetCount(v3);
    v6.location = 0;
    CFArrayApplyFunction(v3, v6, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, context);
    *((_BYTE *)this + 105) = 0;
  }
}

void ___ZN19RunloopBlockContextC2EPK17CoreSchedulingSet_block_invoke()
{
  RunLoopMultiplexer *v0;
  const char *v1;

  v0 = (RunLoopMultiplexer *)operator new();
  RunLoopMultiplexer::RunLoopMultiplexer(v0, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], v1);
  gMuxer = (uint64_t)v0;
}

void sub_183FB8FC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10F1C408D345D2BLL);
  _Unwind_Resume(a1);
}

void RunLoopMultiplexer::RunLoopMultiplexer(RunLoopMultiplexer *this, CFAllocatorRef allocator, const char *a3)
{
  *((_DWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E14E99E0;
  *((_QWORD *)this + 2) = "RunloopBlockContext";
  *((_QWORD *)this + 4) = allocator;
  *((_QWORD *)this + 3) = CFDictionaryCreateMutable(allocator, 0, &kCoreSchedulingSetCallbacks, 0);
}

void sub_183FB9048(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t ___ZN19HTTPConnectionCache11enableTimerEv_block_invoke_2(uint64_t a1)
{
  _QWORD **v1;

  v1 = *(_QWORD ***)(a1 + 32);
  (*(void (**)(_QWORD *))(*v1[13] + 48))(v1[13]);
  return ((uint64_t (*)(_QWORD **))(*v1)[6])(v1);
}

uint64_t ___ZN19HTTPConnectionCache11enableTimerEv_block_invoke(uint64_t a1)
{
  return HTTPConnectionCache::timeoutIdleConnections(*(HTTPConnectionCache **)(a1 + 32));
}

void ___ZN17DiagnosticLogging19userDiagnosticLevelEv_block_invoke()
{
  std::string *p_p;
  int v1;
  CFIndex AppIntegerValue;
  int v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  std::ios_base *v9;
  const std::ios_base *v10;
  std::locale::__imp *v11;
  std::locale::__imp *locale;
  std::locale::id *v13;
  const std::locale::facet *v14;
  unsigned __int8 v15;
  uint64_t v16;
  _QWORD *v17;
  _BYTE *v18;
  int v19;
  std::string::size_type size;
  std::string::size_type v21;
  std::locale::__imp *v22;
  void **v23;
  std::string *p_str;
  size_t v25;
  const char **v26;
  char *v27;
  size_t v28;
  std::string *v30;
  int v31;
  std::string v32;
  std::string __p;
  std::locale __dst[2];
  unint64_t v35;
  void *v36[2];
  unint64_t v37;
  std::string v38;
  std::string __str;
  Boolean keyExistsAndHasValidFormat[8];
  uint64_t v41;
  _BYTE v42[408];
  _QWORD v43[21];

  v43[19] = *MEMORY[0x1E0C80C00];
  p_p = (std::string *)getenv("CFNETWORK_DIAGNOSTICS");
  memset(&__p, 0, sizeof(__p));
  if (p_p)
  {
    v1 = 0;
    goto LABEL_3;
  }
  memset(&__str, 0, sizeof(__str));
  v4 = MEMORY[0x1E0DE4FA8];
  v5 = MEMORY[0x1E0DE4FA8] + 64;
  v6 = (_QWORD *)MEMORY[0x1E0DE4F40];
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 8);
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 16);
  v43[0] = MEMORY[0x1E0DE4FA8] + 64;
  *(_QWORD *)keyExistsAndHasValidFormat = v7;
  *(_QWORD *)&keyExistsAndHasValidFormat[*(_QWORD *)(v7 - 24)] = v8;
  v41 = 0;
  v9 = (std::ios_base *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)];
  std::ios_base::init(v9, v42);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  *(_QWORD *)keyExistsAndHasValidFormat = v4 + 24;
  v43[0] = v5;
  MEMORY[0x186DB7348](v42);
  memset(&v38, 0, sizeof(v38));
  v36[0] = 0;
  v36[1] = 0;
  v37 = 0;
  std::ifstream::open();
  v10 = (const std::ios_base *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)];
  if (v10->__rdstate_)
  {
    LOBYTE(v11) = 0;
    goto LABEL_63;
  }
  locale = 0;
  v11 = 0;
  v13 = (std::locale::id *)MEMORY[0x1E0DE4A90];
  do
  {
    std::ios_base::getloc(v10);
    v14 = std::locale::use_facet(__dst, v13);
    v15 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
    std::locale::~locale(__dst);
    MEMORY[0x186DB7360](__dst, keyExistsAndHasValidFormat, 1);
    if (!LOBYTE(__dst[0].__locale_))
      goto LABEL_30;
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      *__str.__r_.__value_.__l.__data_ = 0;
      __str.__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      __str.__r_.__value_.__s.__data_[0] = 0;
      *((_BYTE *)&__str.__r_.__value_.__s + 23) = 0;
    }
    v16 = 0;
    while (1)
    {
      v17 = *(_QWORD **)&v42[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24) + 24];
      v18 = (_BYTE *)v17[3];
      if (v18 != (_BYTE *)v17[4])
      {
        v17[3] = v18 + 1;
        LOBYTE(v17) = *v18;
        goto LABEL_21;
      }
      LODWORD(v17) = (*(uint64_t (**)(_QWORD *))(*v17 + 80))(v17);
      if ((_DWORD)v17 == -1)
        break;
LABEL_21:
      if (v15 == v17)
      {
        v19 = 0;
        goto LABEL_29;
      }
      std::string::push_back(&__str, (std::string::value_type)v17);
      ++v16;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0 && __str.__r_.__value_.__l.__size_ == 0x7FFFFFFFFFFFFFF7)
      {
        v19 = 4;
        goto LABEL_29;
      }
    }
    if (v16)
      v19 = 2;
    else
      v19 = 6;
LABEL_29:
    std::ios_base::clear((std::ios_base *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)], *(_DWORD *)&v42[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24) + 16] | v19);
LABEL_30:
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    else
      size = __str.__r_.__value_.__l.__size_;
    if (!size)
      goto LABEL_62;
    v21 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
    if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v21 = v38.__r_.__value_.__l.__size_;
    if (!v21)
    {
      v26 = (const char **)_CFGetProgname();
      if (v26)
      {
        v27 = (char *)*v26;
        if (*v26)
        {
          v28 = strlen(*v26);
          std::string::basic_string[abi:nn180100](__dst, v27, v28);
          if ((v11 & 0x80) != 0)
            operator delete(v36[0]);
          *(_OWORD *)v36 = *(_OWORD *)&__dst[0].__locale_;
          v37 = v35;
          v11 = (std::locale::__imp *)HIBYTE(v35);
          locale = __dst[1].__locale_;
          if ((v35 & 0x8000000000000000) == 0 ? (std::locale::__imp *)HIBYTE(v35) : __dst[1].__locale_)
          {
            std::string::operator=(&v38, &__str);
            goto LABEL_61;
          }
        }
      }
      break;
    }
    if ((char)v11 >= 0)
      v22 = v11;
    else
      v22 = locale;
    if ((char)v11 >= 0)
      v23 = v36;
    else
      v23 = (void **)v36[0];
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_str = &__str;
    else
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    if (size >= (unint64_t)v22)
      v25 = (size_t)v22;
    else
      v25 = size;
    if (!memcmp(v23, p_str, v25) && (std::locale::__imp *)size == v22)
    {
      v31 = 1;
      goto LABEL_64;
    }
LABEL_61:
    std::string::erase(&__str, 0, 0xFFFFFFFFFFFFFFFFLL);
LABEL_62:
    v10 = (const std::ios_base *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)];
  }
  while (!v10->__rdstate_);
LABEL_63:
  v31 = 0;
LABEL_64:
  if (!std::filebuf::close())
    std::ios_base::clear((std::ios_base *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)], *(_DWORD *)&v42[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24) + 16] | 4);
  if (v31)
  {
    v32 = v38;
    v30 = &v38;
  }
  else
  {
    v30 = &v32;
  }
  v30->__r_.__value_.__r.__words[0] = 0;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  if ((v11 & 0x80) != 0)
    operator delete(v36[0]);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v38.__r_.__value_.__l.__data_);
  *(_QWORD *)keyExistsAndHasValidFormat = *v6;
  *(_QWORD *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)] = v6[3];
  MEMORY[0x186DB7354](v42);
  std::istream::~istream();
  MEMORY[0x186DB7438](v43);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  __p = v32;
  v1 = SHIBYTE(v32.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__p.__r_.__value_.__l.__size_)
      goto LABEL_80;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!__p.__r_.__value_.__r.__words[0])
      goto LABEL_80;
LABEL_3:
    AppIntegerValue = atoi((const char *)p_p);
  }
  else
  {
    if (*((_BYTE *)&v32.__r_.__value_.__s + 23))
    {
      p_p = &__p;
      goto LABEL_3;
    }
LABEL_80:
    keyExistsAndHasValidFormat[0] = 0;
    AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("AppleCFNetworkDiagnosticLogging"), CFSTR("Apple Global Domain"), keyExistsAndHasValidFormat);
  }
  if ((unint64_t)(AppIntegerValue - 1) >= 3)
    v3 = 0;
  else
    v3 = AppIntegerValue;
  DiagnosticLogging::userDiagnosticLevel(void)::sChecked = v3;
  if (v1 < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_183FB954C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, std::locale a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  int v37;

  if (v37 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN17CoreSchedulingSet18copyLoaderQueueSetEv_block_invoke()
{
  NSObject *v0;
  uint64_t v1;
  void *v2;
  const __CFAllocator *v3;
  CFAllocatedReferenceCountedObject *v4;
  uint64_t v5;

  v0 = dispatch_queue_create("com.apple.CFNetwork.LoaderQ", 0);
  v1 = nw_context_copy_implicit_context();
  if (v1)
  {
    v2 = (void *)v1;
    nw_queue_context_target_dispatch_queue();
    nw_release(v2);
  }
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 96, 0);
  *(_OWORD *)v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  *((_OWORD *)v4 + 5) = 0u;
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v4, v3);
  *(_DWORD *)(v5 + 40) = 3;
  *(_QWORD *)v5 = off_1E14E9938;
  *(_QWORD *)(v5 + 24) = &unk_1E14E99C0;
  *(_DWORD *)(v5 + 64) = 0;
  *(_QWORD *)(v5 + 56) = v0;
  dispatch_retain(v0);
  CoreSchedulingSet::copyLoaderQueueSet(void)::sLoaderQueueSet = (uint64_t)v4;
  return (*(uint64_t (**)(CFAllocatedReferenceCountedObject *))(*(_QWORD *)v4 + 112))(v4);
}

__n128 ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke(uint64_t a1)
{
  __n128 result;

  result = *(__n128 *)(*(_QWORD *)(a1 + 32) + 72);
  *(__n128 *)*(_QWORD *)(a1 + 40) = result;
  return result;
}

void ___ZN14TCPIO_Delegate11setPropertyEPK10__CFStringPKv_block_invoke(_QWORD *a1)
{
  const void *v2;
  const void *v3;

  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1[4] + 24) + 200))(*(_QWORD *)(a1[4] + 24), a1[6], a1[7]);
  v2 = (const void *)a1[6];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[7];
  if (v3)
    CFRelease(v3);
}

void ___ZN12__CFURLCacheC2EPK11_CFURLCachellPK10__CFStringb_block_invoke(uint64_t a1)
{
  uint64_t v1;
  char *v2;
  char *p_p;
  unsigned __int8 v4;
  char *v5;
  _BYTE *v6;
  void *__p;
  uint64_t v9;
  unsigned __int8 v10;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = getenv("CFN_VARY_HEADER_SUPPORT");
  if (v2)
  {
    p_p = (char *)&__p;
    std::string::basic_string[abi:nn180100]<0>(&__p, v2);
    v4 = v10;
    if ((v10 & 0x80u) == 0)
      v5 = (char *)&__p + v10;
    else
      v5 = (char *)__p + v9;
    if ((v10 & 0x80u) != 0)
      p_p = (char *)__p;
    if (p_p != v5)
    {
      do
      {
        *p_p = __tolower(*p_p);
        ++p_p;
      }
      while (p_p != v5);
      v4 = v10;
    }
    if ((v4 & 0x80) != 0)
    {
      v6 = __p;
      switch(v9)
      {
        case 1:
          if (*(_BYTE *)__p != 48)
            break;
          goto LABEL_31;
        case 2:
          if (*(_WORD *)__p == 28526)
            goto LABEL_31;
          break;
        case 5:
          goto LABEL_18;
      }
LABEL_33:
      operator delete(v6);
      return;
    }
    if (v4 != 1)
    {
      if (v4 == 2)
      {
        if ((unsigned __int16)__p != 28526)
          return;
        goto LABEL_31;
      }
      if (v4 != 5)
        return;
      v6 = &__p;
LABEL_18:
      if (*(_DWORD *)v6 != 1936482662 || v6[4] != 101)
      {
        if ((v4 & 0x80) == 0)
          return;
LABEL_32:
        v6 = __p;
        goto LABEL_33;
      }
LABEL_31:
      *(_BYTE *)(v1 + 632) = 0;
      if ((v4 & 0x80) == 0)
        return;
      goto LABEL_32;
    }
    if (__p == 48)
      goto LABEL_31;
  }
}

void sub_183FB9858(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN12XTubeManager38invalidateUnpurgeableConnectionsForKeyEP22HTTPConnectionCacheKey_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[6];

  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 40))(*(_QWORD *)(a1 + 32));
  (*(void (**)(uint64_t))(*(_QWORD *)a3 + 40))(a3);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN12XTubeManager38invalidateUnpurgeableConnectionsForKeyEP22HTTPConnectionCacheKey_block_invoke_2;
  v8[3] = &__block_descriptor_48_e5_v8__0l;
  v6 = *(_QWORD *)(a1 + 32);
  v8[4] = a3;
  v8[5] = v6;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a2 + 96))(a2, v8);
}

os_log_t ___ZL6ATSLogv_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.CFNetwork", "ATS");
  ATSLog(void)::atsLog = (uint64_t)result;
  return result;
}

double ___Z28defaultConnectionCacheLimitsv_block_invoke()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  *(_OWORD *)v0 = xmmword_1841E37E0;
  *(_OWORD *)(v0 + 16) = xmmword_1841E37F0;
  *(_QWORD *)&result = 0x7800000078;
  *(_QWORD *)(v0 + 32) = 0x7800000078;
  defaultConnectionCacheLimits(void)::sImmutableLimits = v0;
  return result;
}

uint64_t ___Z23newCookieStorageEnabledv_block_invoke()
{
  uint64_t result;

  result = _os_feature_enabled_impl();
  newCookieStorageEnabled(void)::enabled = result;
  return result;
}

void sub_183FB9ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_183FB9B64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL `virtual thunk to'SocketStream::canWrite(SocketStream *this, __CFWriteStream *a2)
{
  return SocketStream::canWrite((SocketStream *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 128)), a2);
}

uint64_t `virtual thunk to'SocketStream::read(SocketStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  return SocketStream::read((SocketStream *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 104)), a2, a3, a4, a5, a6);
}

uint64_t TCPIO_Delegate::copyProperty(TCPIO_Delegate *this, const __CFString *a2)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD block[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  v2 = *((_QWORD *)this + 5);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZNK14TCPIO_Delegate12copyPropertyEPK10__CFString_block_invoke;
  block[3] = &unk_1E14FD7A8;
  block[4] = &v6;
  block[5] = this;
  block[6] = a2;
  dispatch_sync(v2, block);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_CanWrite(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2)
{
  return 1;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_CopyProperty(TCPIO_Delegate **this, __CFReadStream *a2, const __CFString *a3)
{
  return TCPIO_Delegate::copyProperty(this[11], a3);
}

uint64_t WriteStreamCallbacks::_canWrite(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(_QWORD *)((char *)a2
                                                                               + *(_QWORD *)(*(_QWORD *)a2 - 136))
                                                                   + 112))((char *)a2 + *(_QWORD *)(*(_QWORD *)a2 - 136), this);
}

uint64_t CFNetworkWriteStream::httpStreamCanWrite(CFNetworkWriteStream *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFWriteStream *, CFNetworkWriteStream *))(*(_QWORD *)a2 + 48))(a2, this);
}

uint64_t CFNetworkWriteStream::httpStreamWrite(CFNetworkWriteStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, void *a6)
{
  return (*(uint64_t (**)(CFStreamError *, CFNetworkWriteStream *, __CFWriteStream *, const unsigned __int8 *, uint64_t))(a5->domain + 40))(a5, this, a2, a3, a4);
}

uint64_t ReadStreamCallbacks::_read(ReadStreamCallbacks *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6, void *a7)
{
  return (*(uint64_t (**)(unsigned __int8 *, ReadStreamCallbacks *, __CFReadStream *, unsigned __int8 *, uint64_t, CFStreamError *))(*(_QWORD *)&a6[*(_QWORD *)(*(_QWORD *)a6 - 136)] + 88))(&a6[*(_QWORD *)(*(_QWORD *)a6 - 136)], this, a2, a3, a4, a5);
}

uint64_t CFNetworkReadStream::httpStreamCopyProperty(CFNetworkReadStream *this, __CFReadStream *a2, const __CFString *a3, void *a4)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkReadStream *, __CFReadStream *))a3->isa + 8))(a3, this, a2);
}

uint64_t CFNetworkReadStream::httpStreamRead(CFNetworkReadStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6, void *a7)
{
  if (a5)
    LOBYTE(a5->domain) = 0;
  return (*(uint64_t (**)(unsigned __int8 *, CFNetworkReadStream *, __CFReadStream *, unsigned __int8 *, uint64_t))(*(_QWORD *)a6 + 40))(a6, this, a2, a3, a4);
}

uint64_t MultiplexerSource::Retain(uint64_t this, const void *a2)
{
  ++*(_QWORD *)(this + 48);
  return this;
}

const void *coreSchedulingSetRetain(const __CFAllocator *a1, const void *a2)
{
  (*(void (**)(const void *))(*(_QWORD *)a2 + 40))(a2);
  return a2;
}

uint64_t _URLCacheRegisterClass(void)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  kCFURLCacheTypeID = result;
  return result;
}

uint64_t _CFURLCacheDeallocate(const void *a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 16);
}

CFStringRef formCopyProperty(__CFReadStream *a1, CFTypeRef cf1, _QWORD *a3)
{
  const __CFAllocator *v5;

  if (!CFEqual(cf1, &unk_1EDCFCE80))
    return 0;
  v5 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v5, 0, CFSTR("%lld"), a3[5]);
}

void sub_183FB9F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183FBA5B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62)
{
  uint64_t v62;
  uint64_t v63;
  uint64_t *v65;
  unint64_t *v66;

  ((void (*)(uint64_t *))a11)(&a9);
  a59 = v63;
  v65 = (uint64_t *)STACK[0x2A8];
  if (STACK[0x2A8] && v65 != &a62)
    free(v65);
  ((void (*)(char *))a16)(&a14);
  STACK[0x410] = v63;
  v66 = (unint64_t *)STACK[0x528];
  if (STACK[0x528] && v66 != &STACK[0x428])
    free(v66);
  STACK[0x550] = (unint64_t)&off_1E14E6B50;
  if (STACK[0x668] != v62)
    free((void *)STACK[0x668]);
  _Unwind_Resume(a1);
}

void ___ZN17HTTPCookieStorage20copyCookiesForDomainEPK10__CFString_block_invoke_2(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    CFRelease((CFTypeRef)(v1 - 16));
}

unsigned int *appendCompactCookieArray(const CompactCookieArray *a1, __CFArray *a2)
{
  unint64_t i;
  unsigned int *result;
  unint64_t v6;

  for (i = 0; ; ++i)
  {
    result = (unsigned int *)*((_QWORD *)a1 + 2);
    if (result && (result = (unsigned int *)CFDataGetBytePtr((CFDataRef)result)) != 0)
      v6 = result[1];
    else
      v6 = 0;
    if (i >= v6)
      break;
    CFArrayAppendValue(a2, -[NSHTTPCookie _initWithReference:index:]([NSHTTPCookie alloc], "_initWithReference:index:", a1, i));
  }
  return result;
}

const void *_CFNetworkErrorGetLocalizedRecoverySuggestion(uint64_t a1)
{
  return _CFNetworkErrorGetLocalizedString(a1, 3);
}

const void *_CFNetworkErrorGetLocalizedFailureReason(uint64_t a1)
{
  return _CFNetworkErrorGetLocalizedString(a1, 2);
}

uint64_t __destroy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t __destroy_helper_block_e8_32c44_ZTS18SmartBlockWithArgsIJb13CFStreamErrorEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __copy_helper_block_e8_32c44_ZTS18SmartBlockWithArgsIJb13CFStreamErrorEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN25HTTP2ConnectionCacheEntry15stopConnectionsEb_block_invoke(uint64_t a1, HTTP2Connection *this)
{
  HTTP2Connection::stop(this, *(_BYTE *)(a1 + 32));
}

uint64_t ___ZN20StrictSecurityPolicy15HardATSFailuresEv_block_invoke()
{
  uint64_t result;
  BOOL v1;
  Boolean keyExistsAndHasValidFormat;

  result = os_variant_allows_internal_security_policies();
  if ((_DWORD)result)
  {
    keyExistsAndHasValidFormat = 0;
    result = CFPreferencesGetAppBooleanValue(CFSTR("com.apple.cfnetwork.ats.hardfailures"), (CFStringRef)*MEMORY[0x1E0C9B248], &keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat)
      v1 = (_DWORD)result == 0;
    else
      v1 = 0;
    if (v1)
      StrictSecurityPolicy::HardATSFailures(void)::hardATSFailures = 1;
  }
  return result;
}

uint64_t ___ZN19TransportConnectionC2EPU28objcproto17OS_dispatch_queue8NSObject_block_invoke()
{
  int v0;
  uint64_t result;
  rlim_t v2;
  rlimit v3;
  size_t v4;
  int rlim_max;
  rlimit v6;
  int v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v0 = getrlimit(8, &v6);
  *(_QWORD *)v7 = 0x1D00000001;
  rlim_max = 0;
  v4 = 4;
  result = sysctl(v7, 2u, &rlim_max, &v4, 0, 0);
  if (result | v0)
  {
    if (v0)
      return result;
    LODWORD(v2) = rlim_max;
  }
  else
  {
    LODWORD(v2) = rlim_max;
    if (v6.rlim_max < rlim_max)
    {
      rlim_max = v6.rlim_max;
      LODWORD(v2) = v6.rlim_max;
    }
  }
  if (v6.rlim_cur < (int)v2)
  {
    v2 = (int)v2;
    v3 = v6;
    if (v6.rlim_cur + 2304 < (int)v2)
      v2 = v6.rlim_cur + 2304;
    v3.rlim_cur = v2;
    return setrlimit(8, &v3);
  }
  return result;
}

CFSetRef ___ZN19TransportConnection20observablePropertiesEv_block_invoke()
{
  CFSetRef result;

  if ((_ZGVZZN19TransportConnection20observablePropertiesEvEUb_E23observablePropertyNames & 1) == 0)
  {
    _ZZZN19TransportConnection20observablePropertiesEvEUb_E23observablePropertyNames = 0x1EDCF96B8;
    _ZGVZZN19TransportConnection20observablePropertiesEvEUb_E23observablePropertyNames = 1;
  }
  result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&_ZZZN19TransportConnection20observablePropertiesEvEUb_E23observablePropertyNames, 1, MEMORY[0x1E0C9B3B0]);
  TransportConnection::observableProperties(void)::observableProps = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZN17HTTPCookieStorage24notifyObserversOfChangesEv_block_invoke()
{
  NSObject *v0;
  NSObject *v1;
  dispatch_queue_t result;

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v1 = dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_UTILITY, 0);
  result = dispatch_queue_create("com.apple.NSHTTPCookieManagerNotification", v1);
  HTTPCookieStorage::notifyObserversOfChanges(void)::notificaionQueue = (uint64_t)result;
  return result;
}

void ___ZN17CoreSchedulingSet11getEmptySetEv_block_invoke()
{
  const __CFAllocator *v0;
  CFAllocatedReferenceCountedObject *v1;
  uint64_t v2;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v1 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 96, 0);
  *(_OWORD *)v1 = 0u;
  *((_OWORD *)v1 + 1) = 0u;
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  *((_OWORD *)v1 + 4) = 0u;
  *((_OWORD *)v1 + 5) = 0u;
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v1, v0);
  *(_DWORD *)(v2 + 40) = 0;
  *(_QWORD *)v2 = off_1E14EC358;
  *(_QWORD *)(v2 + 24) = &unk_1E14EC3E0;
  CoreSchedulingSet::getEmptySet(void)::sEmptySet = v2;
}

uint64_t ___ZN15HTTP3Connection36_newClientUnidirectionalStreamHandleEPKc_block_invoke()
{
  uint64_t stream_options;
  void *v1;

  stream_options = nw_quic_create_stream_options();
  v1 = (void *)HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::options;
  HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::options = stream_options;

  return nw_quic_stream_set_is_unidirectional();
}

void ___ZN15GlueTubeManager22_getIOPathFromDefaultsEv_block_invoke()
{
  const __CFString *v0;
  const __CFString *v1;
  CFTypeID v2;
  CFComparisonResult v3;
  NSObject *v4;
  _BOOL4 v5;
  const char *v6;
  NSObject *v7;
  __objc2_class **p_superclass;
  int v9;
  int v10;
  const __CFString *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v0 = (const __CFString *)CFPreferencesCopyValue(CFSTR("com.apple.CFNetwork.ForceIOPath"), (CFStringRef)*MEMORY[0x1E0C9B228], (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  if (!v0)
  {
    GlueTubeManager::_getIOPathFromDefaults(void)::ioPath = 0;
    return;
  }
  v1 = v0;
  v2 = CFGetTypeID(v0);
  if (v2 != CFStringGetTypeID())
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v4 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      goto LABEL_24;
    v10 = 138543362;
    v11 = v1;
    v6 = "CFNetwork I/O Path Preference(%{public}@) Invalid";
    goto LABEL_14;
  }
  if (CFStringCompare(v1, CFSTR("stream"), 1uLL) == kCFCompareEqualTo)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      _os_log_impl(&dword_183ECA000, v7, OS_LOG_TYPE_DEFAULT, "CFNetwork I/O Path Preference Forcing Stream I/O", (uint8_t *)&v10, 2u);
    }
    p_superclass = (__objc2_class **)(&OBJC_METACLASS_____CFN_TransactionMetrics + 8);
    v9 = 1;
    goto LABEL_23;
  }
  v3 = CFStringCompare(v1, CFSTR("nw"), 1uLL);
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v4 = CFNLog::logger;
  v5 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
  if (v3 == kCFCompareEqualTo)
  {
    if (v5)
    {
      LOWORD(v10) = 0;
      _os_log_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEFAULT, "CFNetwork I/O Path Preference Forcing NW", (uint8_t *)&v10, 2u);
    }
    p_superclass = &OBJC_METACLASS_____CFN_TransactionMetrics.superclass;
    v9 = 2;
LABEL_23:
    *((_DWORD *)p_superclass + 740) = v9;
    goto LABEL_24;
  }
  if (v5)
  {
    v10 = 138543362;
    v11 = v1;
    v6 = "CFNetwork I/O Path Preference Unrecognized(%{public}@)";
LABEL_14:
    _os_log_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v10, 0xCu);
  }
LABEL_24:
  CFRelease(v1);
}

CFStringRef ___ZN14StorageSession18copyProcessDefaultEv_block_invoke()
{
  uint64_t Instance;
  uint64_t v1;
  uint64_t v2;
  const __CFAllocator *v3;
  CFStringRef result;

  if (StorageSession::Class(void)::sOnce_StorageSession != -1)
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
  Instance = _CFRuntimeCreateInstance();
  v1 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v1 = Instance + 16;
    *(_QWORD *)(Instance + 96) = 0;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  *(_QWORD *)v1 = &off_1E14E72B0;
  *(_QWORD *)(v1 + 8) = &unk_1E14E72F8;
  *(_BYTE *)(v1 + 56) = 1;
  v2 = StorageSession::StorageSession(unsigned char)::gGenerations++;
  *(_QWORD *)(v1 + 64) = v2;
  *(_DWORD *)(v1 + 48) = 0;
  v3 = CFGetAllocator((CFTypeRef)(v1 - 16));
  result = CFStringCreateCopy(v3, CFSTR("com.apple.CFNetwork.defaultStorageSession"));
  *(_QWORD *)(v1 + 72) = result;
  *(_QWORD *)(v1 + 80) = 0;
  StorageSession::copyProcessDefault(void)::sProcessDefault = v1 - 16;
  return result;
}

void ___ZN14HTTPHeaderDict9emptyDictEv_block_invoke()
{
  HTTPHeaderDict *Instance;
  uint64_t v1;

  if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1)
    dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_14190);
  Instance = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    *((_QWORD *)Instance + 2) = 0;
    *((_QWORD *)Instance + 3) = 0;
    Instance = (HTTPHeaderDict *)((char *)Instance + 16);
  }
  HTTPHeaderDict::HTTPHeaderDict(Instance);
  HTTPHeaderDict::emptyDict(void)::gEmpty = v1;
}

CFDataRef ___ZN13ATSTLSCiphers22DefaultPFSCipherSuitesEv_block_invoke()
{
  CFDataRef result;

  result = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)kATSv1PFSCiphers, 38, 0);
  ATSTLSCiphers::DefaultPFSCipherSuites(void)::cipherData = (uint64_t)result;
  return result;
}

void ___ZN12DispatchHost26createAndEnqueuePortSourceEj_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  mach_port_name_t v3;
  mach_msg_size_t i;
  mach_msg_header_t *v5;
  mach_msg_return_t v6;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_DWORD *)(a1 + 48);
  for (i = 0x2000; ; i *= 2)
  {
    v5 = (mach_msg_header_t *)malloc_type_malloc(i, 0xA283135AuLL);
    v6 = mach_msg(v5, 67108870, i, i, v3, 0, 0);
    if (v6 != 268451844)
      break;
    free(v5);
  }
  if (!v6)
    getaddrinfo_async_handle_reply();
  free(v5);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN12DispatchHost26createAndEnqueuePortSourceEj_block_invoke(uint64_t a1)
{
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
}

double ___ZN11WeakTrackerI19TransportConnectionE15_trackedObjectsEv_block_invoke()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  result = 0.0;
  *(_OWORD *)v0 = 0u;
  *(_OWORD *)(v0 + 16) = 0u;
  *(_DWORD *)(v0 + 32) = 1065353216;
  WeakTracker<TransportConnection>::_trackedObjects(void)::trackedObjects = v0;
  return result;
}

double ___ZL19mutableGlobalLimitsv_block_invoke()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  *(_OWORD *)v0 = xmmword_1841E37E0;
  *(_OWORD *)(v0 + 16) = xmmword_1841E37F0;
  *(_QWORD *)&result = 0x7800000078;
  *(_QWORD *)(v0 + 32) = 0x7800000078;
  mutableGlobalLimits(void)::gLimits = v0;
  return result;
}

uint64_t `virtual thunk to'SocketStream::open(SocketStream *this, const void *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  return SocketStream::open((SocketStream *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 48)), a2, a3, a4);
}

uint64_t `virtual thunk to'SocketStream::write(SocketStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, int64_t a4, CFStreamError *a5)
{
  return SocketStream::write((SocketStream *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 120)), a2, a3, a4, a5);
}

void RunLoopSchedulingSet::markAsUniquable(RunLoopSchedulingSet *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  const void *v4;
  __CFDictionary *Mutable;
  _QWORD *v6;
  const __CFAllocator *v7;

  if (!*((_BYTE *)this + 116))
  {
    *((_BYTE *)this + 116) = 1;
    v2 = (os_unfair_lock_s *)((char *)this + 112);
    os_unfair_lock_lock((os_unfair_lock_t)this + 28);
    v3 = *((_QWORD *)this + 13);
    if (v3)
      *(_BYTE *)(v3 + 64) = 1;
    os_unfair_lock_unlock(v2);
    v4 = (const void *)*((_QWORD *)this + 9);
    os_unfair_lock_lock((os_unfair_lock_t)&sLoaderSetLock);
    if (sDict)
    {
      Mutable = *(__CFDictionary **)(sDict + 8);
    }
    else
    {
      v6 = (_QWORD *)operator new();
      v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      *v6 = &off_1E14EA3A8;
      Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
      v6[1] = Mutable;
      sDict = (uint64_t)v6;
    }
    CFDictionarySetValue(Mutable, v4, this);
    os_unfair_lock_unlock((os_unfair_lock_t)&sLoaderSetLock);
  }
}

void sub_183FBB6CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void HostBase::~HostBase(HostBase *this)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  *(_QWORD *)this = &off_1E14EFCD8;
  *((_QWORD *)this + 1) = &unk_1E14EFD48;
  v2 = *((_QWORD *)this + 13);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 32))(v2);
    *((_QWORD *)this + 13) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 12);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 16);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 15);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 14);
  if (v6)
    CFRelease(v6);
  *((_QWORD *)this + 3) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_183FBB78C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 32));
  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void URLCredentialServerTrust::~URLCredentialServerTrust(URLCredentialServerTrust *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E14ED238;
  *((_QWORD *)this + 1) = &unk_1E14ED2B8;
  *((_QWORD *)this + 3) = &unk_1E14ED2E8;
  v2 = (const void *)*((_QWORD *)this + 8);
  if (v2)
    CFRelease(v2);
  URLCredential::~URLCredential(this);
}

void sub_183FBB7FC(_Unwind_Exception *a1)
{
  URLCredential *v1;

  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t WriteStreamCallbacks::_write(WriteStreamCallbacks *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, void *a6)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *, __CFWriteStream *, const unsigned __int8 *, uint64_t))(*(CFIndex *)((char *)&a5->domain + *(_QWORD *)(a5->domain - 136)) + 104))((char *)a5 + *(_QWORD *)(a5->domain - 136), this, a2, a3, a4);
}

uint64_t RetainableTypedArray<HTTP2Connection *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::_visit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void HTTP2Connection::stop(HTTP2Connection *this, char a2)
{
  NSObject *v4;
  _QWORD v5[5];
  char v6;

  CFRetain((char *)this - 16);
  v4 = *((_QWORD *)this + 21);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN15HTTP2Connection4stopEb_block_invoke;
  v5[3] = &__block_descriptor_41_e5_v8__0l;
  v5[4] = this;
  v6 = a2;
  dispatch_async(v4, v5);
}

void URLCredential::~URLCredential(URLCredential *this)
{
  const void *v2;

  *(_QWORD *)this = &unk_1E14E68C0;
  *((_QWORD *)this + 1) = &unk_1E14E6940;
  *((_QWORD *)this + 3) = &unk_1E14E6970;
  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 3) = &off_1E14E5838;
}

void sub_183FBB92C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

uint64_t SocketStream::_onqueue_startTCPConnectionCompletion(SocketStream *this, int a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  double v8;
  double v9;
  unint64_t v10;
  int v11;
  unsigned int v12;
  double v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  dispatch_time_t v17;
  uint64_t result;
  uint64_t v19;
  BOOL v20;
  const __CFAllocator *v21;
  CFStringRef v22;
  CFStringRef v23;
  uint64_t v24;
  unint64_t v25;
  CFStringRef v26;
  CFStringRef v27;
  CFStringRef v28;
  CFStringRef v29;
  CFStringRef v30;
  CFStringRef v31;
  CFStringRef v32;
  CFStringRef v33;
  CFStringRef v34;
  CFStringRef v35;
  _QWORD handler[5];
  void (**v37)(AutoString *__hidden);
  CFStringRef v38;
  uint64_t v39;
  uint64_t v40;
  __int128 buf;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  *((_BYTE *)this + 656) = 1;
  if (*((_QWORD *)this + 70))
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *((_QWORD *)this + 70);
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v7;
      _os_log_impl(&dword_183ECA000, v6, OS_LOG_TYPE_DEFAULT, "TCP Conn %p started", (uint8_t *)&buf, 0xCu);
    }
    tcp_connection_start();
    SocketStream::touchWatchdogTimer_Locked(this, 1);
    if (entr_shouldtrace_delayInitStub(v8))
    {
      do
        v10 = __ldaxr(&gSocketStreamEnergyTraceIdentifier);
      while (__stlxr(v10 + 1, &gSocketStreamEnergyTraceIdentifier));
      *((_QWORD *)this + 79) = v10;
      *((_BYTE *)this + 644) = 1;
      v11 = ~(*((_DWORD *)this + 62) >> 30) & 2;
      *((_DWORD *)this + 160) = v11;
      v12 = *((_DWORD *)this + 102) - 1;
      if (v12 <= 9)
        *((_DWORD *)this + 160) = (v11 | (v12 << 20)) + 0x100000;
      entr_act_begin_delayInitStub(v9);
    }
  }
  v13 = *((double *)this + 46);
  if (v13 > 0.0)
  {
    *((double *)this + 47) = v13;
    v14 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)this + 71));
    v15 = MEMORY[0x1E0C809B0];
    *((_QWORD *)this + 49) = v14;
    handler[0] = v15;
    handler[1] = 3221225472;
    handler[2] = ___ZN12SocketStream37_onqueue_startTCPConnectionCompletionEhh_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = this;
    dispatch_source_set_event_handler(v14, handler);
    v16 = *((_QWORD *)this + 49);
    v17 = dispatch_time(0, (uint64_t)(*((double *)this + 47) * 1000000000.0));
    dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    dispatch_resume(*((dispatch_object_t *)this + 49));
  }
  result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_71, 2);
  v19 = result;
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)result + 16))(result, "TCP Connection Start", 0);
    if ((_DWORD)result)
    {
      v20 = a2 == 0;
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v19 + 72))(v19, "conn", CFSTR("%p"));
      v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (!v20)
      {
        *(_QWORD *)&buf = &off_1E14E4818;
        v22 = CFStringCreateWithCString(v21, "from existing connection", 0x8000100u);
        v42 = 0;
        v43 = 0;
        *((_QWORD *)&buf + 1) = v22;
        v37 = &off_1E14E4818;
        v23 = CFStringCreateWithCString(v21, "true", 0x8000100u);
        v39 = 0;
        v40 = 0;
        v38 = v23;
        (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v19 + 64))(v19, *((_QWORD *)&buf + 1), v23);
        AutoString::~AutoString((AutoString *)&v37);
        AutoString::~AutoString((AutoString *)&buf);
      }
      v24 = *((unsigned int *)this + 62);
      v25 = v24 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if ((v24 & 0x80000000) != 0)
      {
        *(_QWORD *)&buf = &off_1E14E4818;
        v26 = CFStringCreateWithCString(v21, "no cellular", 0x8000100u);
        v42 = 0;
        v43 = 0;
        *((_QWORD *)&buf + 1) = v26;
        v37 = &off_1E14E4818;
        v27 = CFStringCreateWithCString(v21, "true", 0x8000100u);
        v39 = 0;
        v40 = 0;
        v38 = v27;
        (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v19 + 64))(v19, *((_QWORD *)&buf + 1), v27);
        AutoString::~AutoString((AutoString *)&v37);
        AutoString::~AutoString((AutoString *)&buf);
        v25 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      }
      if ((v25 & 0x100000000) != 0)
      {
        *(_QWORD *)&buf = &off_1E14E4818;
        v28 = CFStringCreateWithCString(v21, "persistent connection", 0x8000100u);
        v42 = 0;
        v43 = 0;
        *((_QWORD *)&buf + 1) = v28;
        v37 = &off_1E14E4818;
        v29 = CFStringCreateWithCString(v21, "true", 0x8000100u);
        v39 = 0;
        v40 = 0;
        v38 = v29;
        (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v19 + 64))(v19, *((_QWORD *)&buf + 1), v29);
        AutoString::~AutoString((AutoString *)&v37);
        AutoString::~AutoString((AutoString *)&buf);
      }
      if (*((_QWORD *)this + 67))
        goto LABEL_25;
      if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB9F0))
      {
        *(_QWORD *)&buf = &off_1E14E4818;
        v30 = CFStringCreateWithCString(v21, "data connection service type", 0x8000100u);
        v42 = 0;
        v43 = 0;
        *((_QWORD *)&buf + 1) = v30;
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 64))(v19);
        AutoString::~AutoString((AutoString *)&buf);
      }
      if (*((_QWORD *)this + 67))
      {
LABEL_25:
        *(_QWORD *)&buf = &off_1E14E4818;
        v31 = CFStringCreateWithCString(v21, "scoped interface", 0x8000100u);
        v42 = 0;
        v43 = 0;
        *((_QWORD *)&buf + 1) = v31;
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 64))(v19);
        AutoString::~AutoString((AutoString *)&buf);
      }
      if (*((_BYTE *)this + 406))
      {
        *(_QWORD *)&buf = &off_1E14E4818;
        v32 = CFStringCreateWithCString(v21, "SO_RECV_ANYIF", 0x8000100u);
        v42 = 0;
        v43 = 0;
        *((_QWORD *)&buf + 1) = v32;
        v37 = &off_1E14E4818;
        v33 = CFStringCreateWithCString(v21, "set", 0x8000100u);
        v39 = 0;
        v40 = 0;
        v38 = v33;
        (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v19 + 64))(v19, *((_QWORD *)&buf + 1), v33);
        AutoString::~AutoString((AutoString *)&v37);
        AutoString::~AutoString((AutoString *)&buf);
      }
      if (a3)
      {
        *(_QWORD *)&buf = &off_1E14E4818;
        v34 = CFStringCreateWithCString(v21, "opportunistic", 0x8000100u);
        v42 = 0;
        v43 = 0;
        *((_QWORD *)&buf + 1) = v34;
        v37 = &off_1E14E4818;
        v35 = CFStringCreateWithCString(v21, "true", 0x8000100u);
        v39 = 0;
        v40 = 0;
        v38 = v35;
        (*(void (**)(uint64_t, _QWORD, CFStringRef))(*(_QWORD *)v19 + 64))(v19, *((_QWORD *)&buf + 1), v35);
        AutoString::~AutoString((AutoString *)&v37);
        AutoString::~AutoString((AutoString *)&buf);
      }
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    }
  }
  return result;
}

void sub_183FBBF04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  AutoString::~AutoString((AutoString *)&a35);
  _Unwind_Resume(a1);
}

uint64_t SocketStream::attemptNextConnection_NoLock(SocketStream *this)
{
  uint64_t result;
  const __CFData *v3;
  const __CFAllocator *v4;
  CFSocketNativeHandle *BytePtr;
  CFSocketRef v6;
  __CFSocket *v7;
  CFSocketNativeHandle Native;
  __CFSocket *v9;
  CFSocketNativeHandle v10;
  __CFSocket *v11;
  CFSocketNativeHandle v12;
  CFOptionFlags v13;
  const void *Value;
  CFOptionFlags v16;
  uint64_t i;
  const __CFAllocator *v18;
  CFRunLoopSourceRef RunLoopSource;
  __CFRunLoopSource *v20;
  uint64_t j;
  const __CFArray *v22;
  CFIndex Count;
  CFIndex v24;
  CFIndex k;
  __CFRunLoop *ValueAtIndex;
  const __CFString *v27;
  const __CFString *v28;
  int v29;
  int *v30;
  CFSocketContext context;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v32 = *((_OWORD *)this + 19);
  v33 = *((_QWORD *)this + 40);
  if (*((_QWORD *)this + 36))
    goto LABEL_2;
  result = (uint64_t)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBDA8);
  if (!result)
  {
    *((_QWORD *)this + 32) = 1;
    v29 = 22;
LABEL_37:
    *((_DWORD *)this + 66) = v29;
    return result;
  }
  v3 = (const __CFData *)result;
  context.version = 0;
  context.info = (char *)this - 16;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  context.copyDescription = (CFStringRef (__cdecl *)(const void *))MEMORY[0x1E0C98350];
  v4 = CFGetAllocator((char *)this - 16);
  BytePtr = (CFSocketNativeHandle *)CFDataGetBytePtr(v3);
  v6 = CFSocketCreateWithNative(v4, *BytePtr, 0xDuLL, (CFSocketCallBack)SocketStream::_SocketCallBack_stream, &context);
  *((_QWORD *)this + 36) = v6;
  if (!v6)
  {
    v30 = __error();
    result = 0;
    v29 = *v30;
    *((_QWORD *)this + 32) = 1;
    if (!v29)
      v29 = 12;
    goto LABEL_37;
  }
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), &unk_1EDCFBDA8);
LABEL_2:
  if (*((_QWORD *)this + 70))
    tcp_connection_set_traffic_class();
  SocketStream::checkInVoIPSocket(this);
  *((_DWORD *)this + 62) = *((_DWORD *)this + 62) & 0xFFFFF7ED | 2;
  v7 = (__CFSocket *)*((_QWORD *)this + 36);
  LODWORD(context.version) = 1;
  Native = CFSocketGetNative(v7);
  setsockopt(Native, 0xFFFF, 4130, &context, 4u);
  v9 = (__CFSocket *)*((_QWORD *)this + 36);
  LODWORD(context.version) = 1;
  v10 = CFSocketGetNative(v9);
  ioctl(v10, 0x8004667EuLL, &context);
  if (*((_DWORD *)this + 100) == 1)
  {
    v11 = (__CFSocket *)*((_QWORD *)this + 36);
    LODWORD(context.version) = 1;
    v12 = CFSocketGetNative(v11);
    setsockopt(v12, 0xFFFF, 4357, &context, 4u);
  }
  if (*((_DWORD *)this + 86) && *((double *)this + 44) != 0.0)
    __CFSocketSetSocketReadBufferAttrs();
  v13 = CFSocketGetSocketFlags(*((CFSocketRef *)this + 36)) & 0xFFFFFFFFFFFFFF76;
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBD38);
  if (Value != (const void *)*MEMORY[0x1E0C9AE40] || Value == 0)
    v16 = v13 | 0x80;
  else
    v16 = v13;
  CFSocketSetSocketFlags(*((CFSocketRef *)this + 36), v16);
  CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 0xDuLL);
  for (i = 0; i != 24; i += 8)
    _CFTypeScheduleOnMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)((char *)&v32 + i));
  Schedulables::_add(*((Schedulables **)this + 41), *((const void **)this + 36));
  v18 = CFGetAllocator(*((CFTypeRef *)this + 36));
  RunLoopSource = CFSocketCreateRunLoopSource(v18, *((CFSocketRef *)this + 36), 0);
  if (RunLoopSource)
  {
    v20 = RunLoopSource;
    for (j = 0; j != 3; ++j)
    {
      v22 = (const __CFArray *)*((_QWORD *)&v32 + j);
      if (v22)
      {
        Count = CFArrayGetCount(*((CFArrayRef *)&v32 + j));
        if (Count >= 1)
        {
          v24 = Count;
          for (k = 0; k < v24; k += 2)
          {
            ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v22, k);
            if (CFRunLoopIsWaiting(ValueAtIndex))
            {
              v27 = CFRunLoopCopyCurrentMode(ValueAtIndex);
              if (v27)
              {
                v28 = v27;
                if (CFRunLoopContainsSource(ValueAtIndex, v20, v27))
                  CFRunLoopWakeUp(ValueAtIndex);
                CFRelease(v28);
              }
            }
          }
        }
      }
    }
    CFRelease(v20);
  }
  SocketStream::touchWatchdogTimer_Locked(this, 0);
  return 1;
}

void _CFTypeScheduleOnMultipleRunLoops(void *a1, const __CFArray *a2)
{
  CFTypeID v4;
  void *RunLoopSource;
  CFTypeRef v6;
  void (*v7)(const void *, CFTypeRef, const void *);
  const __CFAllocator *v8;
  const __CFAllocator *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v14;
  void (*v15)(void *, const void *, const void *);
  CFIndex v16;
  CFIndex v17;
  CFIndex j;
  const void *v19;
  const void *v20;

  v4 = CFGetTypeID(a1);
  if (v4 == CFRunLoopSourceGetTypeID())
  {
    RunLoopSource = (void *)CFRetain(a1);
    goto LABEL_10;
  }
  if (v4 == CFRunLoopTimerGetTypeID())
  {
    v6 = CFRetain(a1);
    v7 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x1E0C98C00];
    if (!v6)
      return;
    goto LABEL_11;
  }
  if (v4 == CFMachPortGetTypeID())
  {
    v8 = CFGetAllocator(a1);
    RunLoopSource = CFMachPortCreateRunLoopSource(v8, (CFMachPortRef)a1, 0);
    goto LABEL_10;
  }
  if (v4 == CFSocketGetTypeID())
  {
    v9 = CFGetAllocator(a1);
    RunLoopSource = CFSocketCreateRunLoopSource(v9, (CFSocketRef)a1, 0);
LABEL_10:
    v6 = RunLoopSource;
    v7 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x1E0C98BF8];
    if (!RunLoopSource)
      return;
LABEL_11:
    Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      v11 = Count;
      for (i = 0; i < v11; i += 2)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
        v14 = CFArrayGetValueAtIndex(a2, i + 1);
        v7(ValueAtIndex, v6, v14);
      }
    }
    CFRelease(v6);
    return;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  if (v4 == *(_QWORD *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    v15 = (void (*)(void *, const void *, const void *))CoreReadStreamScheduleWithRunLoop;
  }
  else
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    if (v4 == *(_QWORD *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
    {
      v15 = (void (*)(void *, const void *, const void *))CoreWriteStreamScheduleWithRunLoop;
    }
    else if (v4 == CFReadStreamGetTypeID())
    {
      v15 = (void (*)(void *, const void *, const void *))MEMORY[0x1E0C98B90];
    }
    else if (v4 == CFWriteStreamGetTypeID())
    {
      v15 = (void (*)(void *, const void *, const void *))MEMORY[0x1E0C99658];
    }
    else
    {
      if (HostBase::Class(void)::sOnce_HostBase != -1)
        dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
      if (v4 == *(_QWORD *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
      {
        v15 = (void (*)(void *, const void *, const void *))CFHostScheduleWithRunLoop;
      }
      else if (v4 == CFNetServiceGetTypeID())
      {
        v15 = (void (*)(void *, const void *, const void *))CFNetServiceScheduleWithRunLoop;
      }
      else if (v4 == CFNetServiceBrowserGetTypeID())
      {
        v15 = (void (*)(void *, const void *, const void *))CFNetServiceBrowserScheduleWithRunLoop;
      }
      else if (v4 == CFNetServiceMonitorGetTypeID())
      {
        v15 = (void (*)(void *, const void *, const void *))CFNetServiceMonitorScheduleWithRunLoop;
      }
      else if (v4 == SCNetworkReachabilityGetTypeID())
      {
        v15 = (void (*)(void *, const void *, const void *))MEMORY[0x1E0CE88E8];
      }
      else
      {
        if (v4 != SCNetworkConnectionGetTypeID())
          return;
        v15 = (void (*)(void *, const void *, const void *))MEMORY[0x1E0CE8828];
      }
    }
  }
  v16 = CFArrayGetCount(a2);
  if (v16 >= 1)
  {
    v17 = v16;
    for (j = 0; j < v17; j += 2)
    {
      v19 = CFArrayGetValueAtIndex(a2, j);
      v20 = CFArrayGetValueAtIndex(a2, j + 1);
      v15(a1, v19, v20);
    }
  }
}

void SocketStream::removeSSLHandshake(SocketStream *this)
{
  SSLContext *v2;
  const void *Value;
  SSLCipherSuite cipherSuite;
  SSLProtocol protocol;

  *((_DWORD *)this + 62) |= 0x802000u;
  SocketStream::removeHandshake_NoLock((uint64_t)this, 7);
  v2 = (SSLContext *)*((_QWORD *)this + 37);
  if (v2)
  {
    protocol = kSSLProtocolUnknown;
    SSLGetNegotiatedProtocolVersion(v2, &protocol);
    setCFIndexProperty(*((__CFDictionary **)this + 42), CFSTR("_kCFStreamPropertySSLNegotiatedProtocol"), protocol);
    cipherSuite = 0;
    SSLGetNegotiatedCipher(*((SSLContextRef *)this + 37), &cipherSuite);
    setCFIndexProperty(*((__CFDictionary **)this + 42), CFSTR("_kCFStreamPropertySSLNegotiatedCipher"), cipherSuite);
    if ((((unint64_t)*((unsigned __int16 *)this + 126) << 32) & 0xC0000000000) != 0
      && (protocol < kTLSProtocol12 || !StrictSecurityPolicy::isATSCompliantCipher((StrictSecurityPolicy *)cipherSuite)))
    {
      Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA9C0);
      logAppleATSViolation((*((unsigned __int16 *)this + 126) >> 10) & 1, Value, protocol, cipherSuite);
    }
  }
  else
  {
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), CFSTR("_kCFStreamPropertySSLNegotiatedProtocol"));
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), CFSTR("_kCFStreamPropertySSLNegotiatedCipher"));
  }
  if ((*((_DWORD *)this + 62) & 0x8000000) == 0)
    ++gNonCellularSSLAttempts;
}

void setCFIndexProperty(__CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  CFNumberRef v5;
  uint64_t valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  if (v5)
    CFRelease(v5);
}

void DispatchHost::~DispatchHost(DispatchHost *this)
{
  char **v2;
  char *v3;
  NSObject *v4;
  NSObject *v5;
  const void *v6;
  const void *v7;

  *(_QWORD *)this = &off_1E14E59B8;
  *((_QWORD *)this + 1) = &unk_1E14E5A28;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  v2 = (char **)*((_QWORD *)this + 21);
  if (v2)
  {
    v3 = v2[2];
    if (v3)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v3, *((const __CFArray **)this + 15));
      _CFTypeInvalidate(v2[2]);
      CFRelease(v2[2]);
      v2[2] = 0;
      (*((void (**)(char **))*v2 + 8))(v2);
      v2 = (char **)*((_QWORD *)this + 21);
    }
    CFRelease(v2 - 2);
  }
  v4 = *((_QWORD *)this + 18);
  if (v4)
    dispatch_release(v4);
  v5 = *((_QWORD *)this + 19);
  if (v5)
    dispatch_release(v5);
  v6 = (const void *)*((_QWORD *)this + 20);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 17);
  if (v7)
    _Block_release(v7);
  HostBase::unlock(this);
  HostBase::~HostBase(this);
}

void sub_183FBC830(_Unwind_Exception *a1)
{
  HostBase *v1;

  HostBase::~HostBase(v1);
  _Unwind_Resume(a1);
}

_QWORD *_CFNetServiceRegisterClass(void)
{
  _QWORD *result;

  result = malloc_type_calloc(1uLL, 0x60uLL, 0x10D00408820D60FuLL);
  _kCFNetServiceClass = (uint64_t)result;
  if (result)
  {
    *result = 0;
    result[1] = "CFNetService";
    result[4] = _ServiceDestroy;
    result[5] = _ServiceEqual;
    result[6] = _ServiceHash;
    result[8] = _ServiceCopyDebugDesc;
    result = (_QWORD *)_CFRuntimeRegisterClass();
    _kCFNetServiceTypeID = (uint64_t)result;
  }
  return result;
}

_QWORD *CFURLCacheCurrentMemoryUsage(_QWORD *result)
{
  _QWORD *v1;
  uint64_t TypeID;
  const char *v3;

  if (result)
  {
    v1 = result;
    TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(v1))
    {
      return *(_QWORD **)(v1[2] + 144);
    }
    else
    {
      v3 = (const char *)CFURLCacheCurrentMemoryUsage(_CFURLCache const*)::s;
      if (!CFURLCacheCurrentMemoryUsage(_CFURLCache const*)::s)
      {
        v3 = sel_registerName("_nscfBridgeURLCacheCurrentMemoryUsage");
        CFURLCacheCurrentMemoryUsage(_CFURLCache const*)::s = (uint64_t)v3;
      }
      return objc_msgSend(v1, v3);
    }
  }
  return result;
}

void CFURLRequestAppendHTTPHeaderFieldValue(void *a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v5;
  HTTPMessage *fHTTPRequest;
  CFStringRef v7;
  CFStringRef v8;
  const __CFAllocator *v9;
  const __CFString *v10;
  URLRequest *v11;
  void (**v12)(StringSerializable *__hidden);
  CFTypeRef cf;

  v5 = objc_msgSend(a1, "_inner");
  fHTTPRequest = *(HTTPMessage **)(v5 + 56);
  if (!fHTTPRequest)
  {
    v11 = (URLRequest *)v5;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v12);
    URLRequest::createHTTPRequest(v11, (CFTypeRef *)&v12);
    v12 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    fHTTPRequest = (HTTPMessage *)v11->fHTTPRequest;
    if (a3)
      goto LABEL_3;
LABEL_10:
    HTTPMessage::removeHeaderFieldValue(fHTTPRequest, a2);
    return;
  }
  if (!a3)
    goto LABEL_10;
LABEL_3:
  v7 = HTTPMessage::copyHeaderFieldValue(fHTTPRequest, a2);
  if (v7)
  {
    v8 = v7;
    v9 = CFGetAllocator((char *)fHTTPRequest - 16);
    v10 = CFStringCreateWithFormat(v9, 0, CFSTR("%@,%@"), v8, a3);
    HTTPMessage::setHeaderFieldStringValue(fHTTPRequest, a2, v10);
    if (v10)
      CFRelease(v10);
    CFRelease(v8);
  }
  else
  {
    HTTPMessage::setHeaderFieldStringValue(fHTTPRequest, a2, a3);
  }
}

void sub_183FBD028(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t CFURLRequestGetRequestPriority(void *a1)
{
  return *(_QWORD *)(objc_msgSend(a1, "_inner") + 88);
}

CFTypeRef CFURLResponseCopyPeerAddress(void *a1)
{
  CFTypeRef result;

  result = *(CFTypeRef *)(objc_msgSend(a1, "_inner") + 80);
  if (result)
    return CFRetain(result);
  return result;
}

CFMutableStringRef _CFNetworkErrorCopyLocalizedDescriptionWithHostname(uint64_t a1, const __CFString *a2)
{
  const __CFString *v4;
  CFMutableStringRef MutableCopy;
  const void *LocalizedString;
  CFRange v8;

  if (a2 && (v4 = (const __CFString *)_CFNetworkErrorGetLocalizedString(a1, 1)) != 0)
  {
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v4);
    v8.length = CFStringGetLength(MutableCopy);
    v8.location = 0;
    CFStringFindAndReplace(MutableCopy, CFSTR("%@"), a2, v8, 0);
  }
  else
  {
    LocalizedString = _CFNetworkErrorGetLocalizedString(a1, 0);
    if (LocalizedString)
      return (CFMutableStringRef)CFRetain(LocalizedString);
    return 0;
  }
  return MutableCopy;
}

const void *_CFNetworkErrorGetLocalizedString(uint64_t a1, CFIndex a2)
{
  CFNumberRef v3;
  const __CFArray *Value;
  const void *result;
  uint64_t valuePtr;

  valuePtr = a1;
  pthread_once(&_CFNetworkErrorInitLocalizedDescriptionsDictionaryControl, (void (*)(void))_CFNetworkErrorInitLocalizedStringsDictionary);
  v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, &valuePtr);
  Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_CFNetworkErrorLocalizedDescriptionsDict, v3);
  if (v3)
    CFRelease(v3);
  if (!Value)
    return 0;
  result = CFArrayGetValueAtIndex(Value, a2);
  if (result == (const void *)*MEMORY[0x1E0C9B0D0])
    return 0;
  return result;
}

uint64_t CFURLRequestSetRequestPriority(void *a1, uint64_t a2)
{
  uint64_t result;

  result = objc_msgSend(a1, "_inner");
  *(_QWORD *)(result + 88) = a2;
  return result;
}

_QWORD *CFURLCacheDiskCapacity(_QWORD *result)
{
  _QWORD *v1;
  uint64_t TypeID;
  const char *v3;

  if (result)
  {
    v1 = result;
    TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(v1))
    {
      return *(_QWORD **)(v1[2] + 176);
    }
    else
    {
      v3 = (const char *)CFURLCacheDiskCapacity::s;
      if (!CFURLCacheDiskCapacity::s)
      {
        v3 = sel_registerName("_nscfBridgeURLCacheDiskCapacity");
        CFURLCacheDiskCapacity::s = (uint64_t)v3;
      }
      return objc_msgSend(v1, v3);
    }
  }
  return result;
}

CFTypeRef CFURLRequestSetMainDocumentURL(void *a1, CFTypeRef a2)
{
  uint64_t v3;
  CFTypeRef result;

  v3 = objc_msgSend(a1, "_inner");
  result = *(CFTypeRef *)(v3 + 32);
  if (result != a2)
  {
    if (result)
      CFRelease(result);
    if (a2)
      result = CFRetain(a2);
    else
      result = 0;
    *(_QWORD *)(v3 + 32) = result;
  }
  return result;
}

_QWORD *CFURLCacheMemoryCapacity(_QWORD *result)
{
  _QWORD *v1;
  uint64_t TypeID;
  const char *v3;

  if (result)
  {
    v1 = result;
    TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(v1))
    {
      return *(_QWORD **)(v1[2] + 168);
    }
    else
    {
      v3 = (const char *)CFURLCacheMemoryCapacity::s;
      if (!CFURLCacheMemoryCapacity::s)
      {
        v3 = sel_registerName("_nscfBridgeURLCacheMemoryCapacity");
        CFURLCacheMemoryCapacity::s = (uint64_t)v3;
      }
      return objc_msgSend(v1, v3);
    }
  }
  return result;
}

void CFURLCacheAddCachedResponseForRequest(_CFURLCache *a1, _CFCachedURLResponse *a2, _CFURLRequest *a3, const void *a4)
{
  uint64_t TypeID;
  Class Class;
  HTTPProtocol *v10;
  const char *v11;

  if (a1)
  {
    TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      Class = objc_getClass("__NSURLSessionLocal");
      v10 = (HTTPProtocol *)objc_msgSend(Class, sel_registerName("sharedSession"));
      __CFURLCacheAddCachedResponseForRequestWithSession(a1, v10, a2, a3, a4);
    }
    else
    {
      v11 = (const char *)CFURLCacheAddCachedResponseForRequest::s;
      if (!CFURLCacheAddCachedResponseForRequest::s)
      {
        v11 = sel_registerName("_nscfBridgeURLCacheStoreCachedResponse:forRequest:");
        CFURLCacheAddCachedResponseForRequest::s = (uint64_t)v11;
      }
      objc_msgSend(a1, v11, a2, a3);
    }
  }
}

uint64_t CFURLResponseGetHTTPResponse(void *a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(objc_msgSend(a1, "_inner") + 88);
  if (v1)
    return v1 - 16;
  else
    return 0;
}

CFDictionaryRef CFNetworkCopySystemProxySettings(void)
{
  const __CFDictionary *v0;
  uint64_t v1;
  BOOL v2;
  int v3;
  uint32_t v4;
  BOOL v5;
  CFDictionaryRef v6;
  int check;

  if (_CFNetworkCopySystemProxySettings::onceToken != -1)
    dispatch_once(&_CFNetworkCopySystemProxySettings::onceToken, &__block_literal_global_2882);
  pthread_mutex_lock(&__sCFNSystemProxyDictLock);
  if (!__sProxyOverrideDict || (v0 = (const __CFDictionary *)CFRetain((CFTypeRef)__sProxyOverrideDict)) == 0)
  {
    if (!_CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary)
      goto LABEL_22;
    v1 = _CFNetworkCopySystemProxySettings::configWatcher;
    check = 0;
    if (notify_check(*(_DWORD *)_CFNetworkCopySystemProxySettings::configWatcher, &check))
      v2 = 1;
    else
      v2 = check == 0;
    v3 = !v2;
    v4 = notify_check(*(_DWORD *)(v1 + 4), &check);
    if (check)
      v5 = v4 == 0;
    else
      v5 = 0;
    v6 = (CFDictionaryRef)_CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary;
    if (v5 || v3 != 0)
    {
      _CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary = 0;
      if (!v6)
        goto LABEL_22;
      CFRelease(v6);
      v6 = (CFDictionaryRef)_CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary;
    }
    if (v6)
    {
LABEL_23:
      v0 = (const __CFDictionary *)CFRetain(v6);
      goto LABEL_25;
    }
LABEL_22:
    v6 = SCDynamicStoreCopyProxies(0);
    _CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary = (uint64_t)v6;
    if (!v6)
    {
      v0 = 0;
      goto LABEL_25;
    }
    goto LABEL_23;
  }
LABEL_25:
  pthread_mutex_unlock(&__sCFNSystemProxyDictLock);
  return v0;
}

void _CFNetworkHTTPConnectionCacheSetLimit(int a1, int a2)
{
  int *v4;

  if (mutableGlobalLimits(void)::sOnce != -1)
    dispatch_once(&mutableGlobalLimits(void)::sOnce, &__block_literal_global_10_10234);
  v4 = (int *)mutableGlobalLimits(void)::gLimits;
  switch(a1)
  {
    case 0:
      goto LABEL_16;
    case 1:
      v4 = (int *)(mutableGlobalLimits(void)::gLimits + 4);
      goto LABEL_16;
    case 2:
      v4 = (int *)(mutableGlobalLimits(void)::gLimits + 8);
      goto LABEL_16;
    case 3:
      if (a2 < 1)
        return;
      v4 = (int *)(mutableGlobalLimits(void)::gLimits + 12);
      goto LABEL_16;
    case 4:
      if (a2 < 0 || *(_DWORD *)mutableGlobalLimits(void)::gLimits <= a2)
        return;
      v4 = (int *)(mutableGlobalLimits(void)::gLimits + 16);
      goto LABEL_16;
    case 5:
      v4 = (int *)(mutableGlobalLimits(void)::gLimits + 20);
      goto LABEL_16;
    case 6:
      *(_DWORD *)(mutableGlobalLimits(void)::gLimits + 24) = a2;
      if (a2 != 30)
        goto LABEL_13;
      return;
    case 7:
LABEL_13:
      v4 += 7;
      goto LABEL_16;
    case 8:
      *(_DWORD *)(mutableGlobalLimits(void)::gLimits + 32) = a2;
      if (a2 != 120)
        goto LABEL_15;
      return;
    case 9:
LABEL_15:
      v4 += 9;
LABEL_16:
      *v4 = a2;
      break;
    default:
      return;
  }
}

__CFString *CFURLResponseGetMIMEType(void *a1)
{
  return URLResponse::getMIMEType((URLResponse *)objc_msgSend(a1, "_inner"));
}

Boolean CFHostStartInfoResolution(CFHostRef theHost, CFHostInfoType info, CFStreamError *error)
{
  char *v6;
  uint64_t v7;
  __CFError *v8;
  __CFError *v9;
  uint64_t v10;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  if (theHost)
    v6 = (char *)theHost + 16;
  else
    v6 = 0;
  v7 = infoToString(info);
  v8 = (__CFError *)(*(uint64_t (**)(char *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v6 + 56))(v6, v7, 0, 0);
  if (v8)
  {
    v9 = v8;
    if (error)
    {
      error->domain = _CFStreamErrorFromCFError(v8);
      *(_QWORD *)&error->error = v10;
    }
    CFRelease(v9);
    return 0;
  }
  else
  {
    if (error)
    {
      error->error = 0;
      error->domain = 0;
    }
    return 1;
  }
}

void *DispatchHost::startInfoResolution(DispatchHost *this, __CFString *a2, const __CFString *a3, const __CFDictionary *a4)
{
  char *v7;
  int ExactString;
  const __CFData *v9;
  const __CFString *v10;
  uint64_t *v11;
  const __CFAllocator *v12;
  CFErrorRef CFErrorWithStreamError;
  __CFString *v14;
  dispatch_queue_t *v15;
  DispatchHost *v16;
  const __SCNetworkReachability *Reachability;
  void *v18;
  _QWORD *v19;
  int v20;
  __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  const void *Value;
  CFTypeID v25;
  const void *v26;
  int v28;
  const __CFAllocator *v29;
  const __CFAllocator *v30;
  int v31;
  uintptr_t v32;
  const __CFAllocator *v33;
  __CFString *v34;
  CFDataRef theData;
  _DWORD handle[5];
  void *ptr;
  UInt8 v38[1024];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v7 = (char *)this - 16;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((_QWORD *)this + 2);
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 12), a2);
  dispatch_group_enter(*((dispatch_group_t *)this + 19));
  ExactString = _findExactString(a2, 0xAu);
  if (!HostBase::calculateWantsLocked((uint64_t)this, ExactString, (CFIndex *)&v34))
  {
    v12 = CFGetAllocator(v7);
    *(_OWORD *)&handle[1] = xmmword_1841E3950;
    CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v12, &handle[1]);
    goto LABEL_21;
  }
  if (ExactString <= 489912819)
  {
    if (ExactString != 485767616 && ExactString != 487766494 && ExactString != 488815081)
      goto LABEL_32;
    v14 = v34;
    if (!v34)
      goto LABEL_32;
    v15 = (dispatch_queue_t *)this;
    v16 = (DispatchHost *)a2;
    goto LABEL_20;
  }
  if (ExactString <= 492935701)
  {
    if (ExactString == 489912820)
    {
      v11 = &_kCFHostMasterAddressLookupString;
    }
    else
    {
      if (ExactString != 491919885)
        goto LABEL_32;
      v11 = &kCFHostAddressesString;
    }
    v16 = (DispatchHost *)*v11;
    v14 = v34;
    v15 = (dispatch_queue_t *)this;
LABEL_20:
    CFErrorWithStreamError = HostLookup_Master::enqueueWithHost(v15, v16, v14, a3, v10);
    goto LABEL_21;
  }
  if (ExactString != 492935702)
  {
    if (ExactString != 494041629)
      goto LABEL_32;
    if (theData)
    {
      Reachability = HostLookup_Reachability::CreateReachability(theData, v9);
    }
    else
    {
      v21 = v34;
      if (!v34)
        goto LABEL_32;
      if (!HostLookup_ReachabilityFixed::isDottedIP(v34, (const __CFString *)v9))
      {
        CFErrorWithStreamError = HostLookup_Reachability::enqueueWithHost((dispatch_queue_t *)this, v21, v23);
        goto LABEL_21;
      }
      Reachability = HostLookup_Reachability::CreateReachability(v21, v22);
    }
    CFErrorWithStreamError = enqueueWithHost(this, Reachability);
LABEL_21:
    v18 = CFErrorWithStreamError;
    goto LABEL_22;
  }
  CFDataGetBytePtr(theData);
  v19 = (_QWORD *)operator new();
  *v19 = &off_1E14EFEF0;
  v19[1] = this;
  CFRetain(v7);
  handle[0] = 0;
  if (a3)
  {
    *(_QWORD *)&handle[1] = CFGetAllocator(v7);
    *(_QWORD *)&handle[3] = 1023;
    ptr = _CFStringGetOrCreateCString(*(const __CFAllocator **)&handle[1], a3, v38, (uint64_t *)&handle[3], 0x8000100u);
    v20 = _getnameinfo_interface_async_call();
    handle[0] = v20;
    if (ptr && v38 != ptr)
      CFAllocatorDeallocate(*(CFAllocatorRef *)&handle[1], ptr);
    v18 = 0;
LABEL_41:
    if (!v20)
    {
      v30 = CFGetAllocator(v7);
      v31 = *__error();
      *(_OWORD *)&handle[1] = xmmword_1841E3810;
      handle[3] = v31;
      v18 = __cfnCreateCFErrorWithStreamError(v30, &handle[1]);
    }
    goto LABEL_43;
  }
  v28 = getnameinfo_async_start();
  if (!v28)
  {
    v32 = handle[0];
    if (handle[0])
      goto LABEL_46;
    v28 = -1;
  }
  v29 = CFGetAllocator(v7);
  *(_OWORD *)&handle[1] = xmmword_1841E3930;
  handle[3] = v28;
  v18 = __cfnCreateCFErrorWithStreamError(v29, &handle[1]);
  v20 = handle[0];
  if (!v18)
    goto LABEL_41;
LABEL_43:
  if (v18)
    goto LABEL_22;
  v32 = handle[0];
LABEL_46:
  if (!DispatchHost::createAndEnqueuePortSource((dispatch_queue_t *)this, v32))
  {
    v33 = CFGetAllocator(v7);
    *(_OWORD *)&handle[1] = xmmword_1841E3810;
    handle[3] = 12;
    CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v33, &handle[1]);
    goto LABEL_21;
  }
  v18 = 0;
LABEL_22:
  if (v18)
  {
    dispatch_group_leave(*((dispatch_group_t *)this + 19));
    goto LABEL_38;
  }
  if (*((_QWORD *)this + 13))
    goto LABEL_37;
LABEL_32:
  do
  {
    HostBase::unlock(this);
    dispatch_group_wait(*((dispatch_group_t *)this + 19), 0xFFFFFFFFFFFFFFFFLL);
    CFRetain(v7);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    ++*((_QWORD *)this + 2);
  }
  while (!CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2));
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2);
  v25 = CFGetTypeID(Value);
  if (v25 == CFErrorGetTypeID() && (v26 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2)) != 0)
    v18 = (void *)CFRetain(v26);
  else
LABEL_37:
    v18 = 0;
LABEL_38:
  HostBase::unlock(this);
  return v18;
}

void sub_183FBDB4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFAllocatorRef allocator, uint64_t a14, void *ptr)
{
  _Unwind_Resume(exception_object);
}

BOOL HostBase::calculateWantsLocked(uint64_t a1, int a2, CFIndex *a3)
{
  _BOOL8 result;
  char v6;
  char v7;
  int v8;
  char v9;
  const __CFArray *v10;
  const __CFArray *Value;
  BOOL v12;
  const __CFArray *v13;
  CFIndex Count;
  const __CFArray *v15;
  BOOL v16;
  const __CFArray *v17;
  CFIndex ValueAtIndex;

  result = 0;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (a2 <= 489912819)
  {
    if (a2 != 485767616 && a2 != 487766494 && a2 != 488815081)
      return result;
    goto LABEL_13;
  }
  if (a2 <= 492935701)
  {
    v6 = 3;
    v7 = 1;
    if (a2 != 489912820 && a2 != 491919885)
      return result;
LABEL_14:
    Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), &unk_1EDCFF6F8);
    v10 = (const __CFArray *)*MEMORY[0x1E0C9B0D0];
    if (Value)
      v12 = Value == v10;
    else
      v12 = 1;
    if (v12)
    {
      Count = 0;
    }
    else
    {
      v13 = Value;
      Count = CFArrayGetCount(Value);
      if (Count)
        Count = (CFIndex)CFArrayGetValueAtIndex(v13, 0);
    }
    *a3 = Count;
    v8 = Count != 0;
    v9 = 1;
    if ((v7 & 1) != 0)
      return v8 && ((v6 & 2) == 0 || *a3) && ((v9 & 1) != 0 || a3[1]);
    goto LABEL_23;
  }
  if (a2 == 494041629)
  {
LABEL_13:
    v7 = 0;
    v6 = 5;
    goto LABEL_14;
  }
  if (a2 != 492935702)
    return result;
  v8 = 0;
  v9 = 0;
  v10 = (const __CFArray *)*MEMORY[0x1E0C9B0D0];
  v6 = 12;
LABEL_23:
  v15 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), &unk_1EDCFF6C0);
  if (v15)
    v16 = v15 == v10;
  else
    v16 = 1;
  if (v16)
  {
    ValueAtIndex = 0;
  }
  else
  {
    v17 = v15;
    ValueAtIndex = CFArrayGetCount(v15);
    if (ValueAtIndex)
      ValueAtIndex = (CFIndex)CFArrayGetValueAtIndex(v17, 0);
  }
  a3[1] = ValueAtIndex;
  v8 |= 4 * (ValueAtIndex != 0);
  return v8 && ((v6 & 2) == 0 || *a3) && ((v9 & 1) != 0 || a3[1]);
}

CFErrorRef HostLookup_Master::enqueueWithHost(dispatch_queue_t *this, DispatchHost *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  dispatch_queue_t *v9;
  const __CFAllocator *v10;
  const __CFAllocator *v11;
  UInt8 *v12;
  CFErrorRef CFErrorWithStreamError;
  CFErrorRef v14;
  _QWORD *v15;
  CFTypeRef v16;
  int v17;
  int v18;
  int v19;
  _DWORD handle[5];
  void *ptr;
  UInt8 v23[1032];
  CFAllocatorRef v24;
  uint64_t v25;
  void *v26;
  UInt8 v27[1024];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v9 = this - 2;
  v10 = CFGetAllocator(this - 2);
  v11 = v10;
  v24 = v10;
  v25 = 1023;
  if (a3)
  {
    v12 = _CFStringGetOrCreateCString(v10, a3, v27, &v25, 0x8000100u);
    a3 = (const __CFString *)v25;
  }
  else
  {
    v27[0] = 0;
    v25 = 0;
    v12 = v27;
  }
  v26 = v12;
  if (a3 != (const __CFString *)strlen((const char *)v12))
  {
    *(_OWORD *)&handle[1] = xmmword_1841E3920;
    CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v11, &handle[1]);
    goto LABEL_8;
  }
  handle[0] = 0;
  if (!CFEqual(a2, &unk_1EDCFF5E0))
    CFEqual(a2, &unk_1EDCFF618);
  v15 = (_QWORD *)operator new();
  *v15 = &off_1E14EFEF0;
  v15[1] = this;
  CFRetain(v9);
  *v15 = &off_1E14EFF10;
  if (a2)
    v16 = CFRetain(a2);
  else
    v16 = 0;
  v15[2] = v16;
  if (a4)
  {
    *(_QWORD *)&handle[1] = v11;
    *(_QWORD *)&handle[3] = 1023;
    ptr = _CFStringGetOrCreateCString(v11, a4, v23, (uint64_t *)&handle[3], 0x8000100u);
    v17 = _getaddrinfo_interface_async_call();
    handle[0] = v17;
    if (ptr && v23 != ptr)
      CFAllocatorDeallocate(*(CFAllocatorRef *)&handle[1], ptr);
    v14 = 0;
  }
  else
  {
    v18 = getaddrinfo_async_start();
    if (!v18)
      v18 = -1;
    *(_OWORD *)&handle[1] = xmmword_1841E3930;
    handle[3] = v18;
    v14 = __cfnCreateCFErrorWithStreamError(v11, &handle[1]);
    v17 = 0;
    if (v14)
      goto LABEL_23;
  }
  if (!v17)
  {
    v19 = *__error();
    *(_OWORD *)&handle[1] = xmmword_1841E3810;
    handle[3] = v19;
    v14 = __cfnCreateCFErrorWithStreamError(v11, &handle[1]);
  }
LABEL_23:
  if (v14)
    goto LABEL_26;
  if (DispatchHost::createAndEnqueuePortSource(this, handle[0]))
  {
    v14 = 0;
    goto LABEL_26;
  }
  *(_OWORD *)&handle[1] = xmmword_1841E3810;
  handle[3] = 12;
  CFErrorWithStreamError = __cfnCreateCFErrorWithStreamError(v11, &handle[1]);
LABEL_8:
  v14 = CFErrorWithStreamError;
LABEL_26:
  if (v26 && v27 != v26)
    CFAllocatorDeallocate(v24, v26);
  return v14;
}

void sub_183FBE0A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v3;

  v3 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    if (v1 != v3)
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x460], v3);
  }
  _Unwind_Resume(a1);
}

NSObject *DispatchHost::createAndEnqueuePortSource(dispatch_queue_t *this, uintptr_t handle)
{
  int v2;
  NSObject *result;
  NSObject *v5;
  uint64_t v6;
  _QWORD v7[6];
  int v8;
  _QWORD handler[5];

  v2 = handle;
  result = dispatch_source_create(MEMORY[0x1E0C80D98], handle, 0, this[18]);
  if (result)
  {
    v5 = result;
    CFRetain(this - 2);
    v6 = MEMORY[0x1E0C809B0];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = ___ZN12DispatchHost26createAndEnqueuePortSourceEj_block_invoke;
    handler[3] = &unk_1E14FE118;
    handler[4] = v5;
    dispatch_source_set_event_handler(v5, handler);
    v7[0] = v6;
    v7[1] = 3221225472;
    v7[2] = ___ZN12DispatchHost26createAndEnqueuePortSourceEj_block_invoke_2;
    v7[3] = &unk_1E14FCBB0;
    v8 = v2;
    v7[4] = v5;
    v7[5] = this;
    dispatch_source_set_cancel_handler(v5, v7);
    dispatch_resume(v5);
    return 1;
  }
  return result;
}

__n128 _CFURLConnectionSetFrameworkStubs(uint64_t a1)
{
  __n128 result;
  __int128 v2;

  if (*(_QWORD *)a1)
    __assert_rtn("_CFURLConnectionSetFrameworkStubs", "SecItem-shim.cpp", 13, "stubs->version == 0");
  result = *(__n128 *)a1;
  v2 = *(_OWORD *)(a1 + 16);
  off_1EDCF7EC8 = *(_UNKNOWN **)(a1 + 32);
  _gFwStubs = (__int128)result;
  *(_OWORD *)&off_1EDCF7EB8 = v2;
  return result;
}

BOOL CFURLProtocolRegisterImplementation(_BOOL8 result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *i;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  char __str[256];
  uint64_t v11;

  v1 = result;
  v11 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)result || *(_QWORD *)(result + 16) || *(_QWORD *)(result + 24))
  {
    CFLog();
    abort();
  }
  if (*(_QWORD *)(result + 8))
  {
    v2 = 0;
    for (i = &_translatedFileProtocol; *i; ++i)
    {
      if (++v2 == 8)
        return result;
    }
    v7 = operator new();
    *i = v7;
    *(_QWORD *)(v7 + 64) = *(_QWORD *)(v1 + 64);
    v8 = *(_OWORD *)(v1 + 48);
    *(_OWORD *)(v7 + 32) = *(_OWORD *)(v1 + 32);
    *(_OWORD *)(v7 + 48) = v8;
    v9 = *(_OWORD *)(v1 + 16);
    *(_OWORD *)v7 = *(_OWORD *)v1;
    *(_OWORD *)(v7 + 16) = v9;
    snprintf(__str, 0x100uLL, "_NSCFTranslatedFileURLProtocol_PIMPL_%d", v2);
    return +[NSURLProtocol registerClass:](NSURLProtocol, "registerClass:", objc_getClass(__str));
  }
  else
  {
    _wikipediaProtocol = *(_OWORD *)result;
    v4 = *(_OWORD *)(result + 16);
    v5 = *(_OWORD *)(result + 32);
    v6 = *(_OWORD *)(result + 48);
    off_1EDD011A8 = *(_UNKNOWN **)(result + 64);
    xmmword_1EDD01188 = v5;
    unk_1EDD01198 = v6;
    xmmword_1EDD01178 = v4;
    return +[NSURLProtocol registerClass:](NSURLProtocol, "registerClass:", objc_opt_class());
  }
}

void sub_183FBE4D4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&_localProtocolClassesForDefaultSessionLock);
  _Unwind_Resume(a1);
}

CFTypeRef _CFURLStorageSessionCopyCookieStorage(uint64_t a1, os_unfair_lock_s *a2)
{
  os_unfair_lock_s *v3;

  if (StorageSession::Class(void)::sOnce_StorageSession != -1)
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
  if (a2)
    v3 = a2 + 4;
  else
    v3 = 0;
  return StorageSession::copyCookieStorage(v3);
}

uint64_t _CFURLResponseGetSSLCertificateContext(void *a1)
{
  return *(_QWORD *)(objc_msgSend(a1, "_inner") + 64);
}

uint64_t CFURLResponseConnectionIsCellular(void *a1)
{
  return *(unsigned __int8 *)(objc_msgSend(a1, "_inner") + 97);
}

CFHTTPMessageRef CFHTTPMessageCreateResponse(CFAllocatorRef alloc, CFIndex statusCode, CFStringRef statusDescription, CFStringRef httpVersion)
{
  __int16 v6;
  _OWORD *Instance;
  uint64_t v8;
  void (**v10)(StringSerializable *__hidden);
  CFTypeRef cf;

  v6 = statusCode;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v8 = (uint64_t)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v8 = (uint64_t)(Instance + 1);
    Instance[18] = 0u;
    Instance[19] = 0u;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v10, httpVersion);
  HTTPResponseMessage::HTTPResponseMessage(v8, v6 & 0x3FF, statusDescription, cf);
  v10 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  return (CFHTTPMessageRef)(v8 - 16);
}

void sub_183FBE65C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

CFStringRef CFHTTPMessageCopyResponseStatusLine(CFHTTPMessageRef response)
{
  uint64_t v2;
  const char *v3;
  const char *v4;
  const __CFAllocator *v5;

  if (!response)
    return 0;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (!*((_BYTE *)response + 40))
    return 0;
  v2 = *((_QWORD *)response + 38);
  if (v2 || *((_BYTE *)response + 176))
  {
    if (v2)
      v3 = (const char *)*((_QWORD *)response + 38);
    else
      v3 = (char *)response + 176;
  }
  else
  {
    v3 = (const char *)(*(uint64_t (**)(char *, _QWORD))(*((_QWORD *)response + 2) + 88))((char *)response + 16, 0);
  }
  if (v3)
    v4 = v3;
  else
    v4 = "";
  v5 = CFGetAllocator(response);
  return CFStringCreateWithCString(v5, v4, 0x201u);
}

BOOL _CFNetworkSetATSContext(const void *a1)
{
  uint64_t v2;
  NSObject *v3;
  uint8_t v5[16];

  pthread_mutex_lock(&StrictSecurityPolicy::_Mutex);
  v2 = StrictSecurityPolicy::_ATSData;
  if (!StrictSecurityPolicy::_ATSData)
    StrictSecurityPolicy::_ATSData = (uint64_t)CFRetain(a1);
  pthread_mutex_unlock(&StrictSecurityPolicy::_Mutex);
  if (ATSLog(void)::onceToken != -1)
    dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
  v3 = ATSLog(void)::atsLog;
  if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v5 = 0;
    _os_log_debug_impl(&dword_183ECA000, v3, OS_LOG_TYPE_DEBUG, "Set custom context", v5, 2u);
  }
  return v2 == 0;
}

__CFArray *CFHTTPCookieStorageCreateIdentifyingData(CFAllocatorRef allocator, char *self)
{
  id Property;
  __CFArray *result;
  HTTPCookieStorage *v6;
  __CFArray *v7;
  CFDataRef Data;

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    if (self)
      Property = objc_getProperty(self, self, 40, 1);
    else
      Property = 0;
    return (__CFArray *)(id)objc_msgSend(Property, "identifyingData");
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    if (self)
      v6 = (HTTPCookieStorage *)(self + 16);
    else
      v6 = 0;
    result = HTTPCookieStorage::createArchive(v6, allocator);
    if (result)
    {
      v7 = result;
      Data = CFPropertyListCreateData(allocator, result, kCFPropertyListBinaryFormat_v1_0, 0, 0);
      CFRelease(v7);
      return Data;
    }
  }
  return result;
}

void _CFURLStorageSessionDisableCache(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  if (StorageSession::Class(void)::sOnce_StorageSession != -1)
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
  if (a1)
    v2 = a1 + 16;
  else
    v2 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 48));
  if (!*(_BYTE *)(v2 + 52))
  {
    *(_BYTE *)(v2 + 52) = 1;
    v3 = *(const void **)(v2 + 16);
    if (v3)
      CFRelease(v3);
    *(_QWORD *)(v2 + 16) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 48));
}

void CFURLCacheRemoveAllCachedResponses(_QWORD *a1)
{
  uint64_t TypeID;
  __CFURLCache *v3;
  const char *v4;

  if (a1)
  {
    TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      v3 = (__CFURLCache *)a1[2];
      __CFURLCache::PurgeMemoryCache(v3);
      __CFURLCache::PurgePersistentCache(v3);
    }
    else
    {
      v4 = (const char *)CFURLCacheRemoveAllCachedResponses::s;
      if (!CFURLCacheRemoveAllCachedResponses::s)
      {
        v4 = sel_registerName("_nscfBridgeURLCacheRemoveAllCachedResponses");
        CFURLCacheRemoveAllCachedResponses::s = (uint64_t)v4;
      }
      objc_msgSend(a1, v4);
    }
  }
}

char *CFHTTPCookieStorageCreateFromFile(char *a1, CFURLRef relativeURL, uint64_t a3)
{
  const __CFAllocator *v5;
  CFURLRef v7;
  __CFDictionary *MutableDictionary;
  char *v9;
  os_unfair_lock_s *v10;
  void (**v11)(AutoScalar *__hidden);
  CFTypeRef v12;

  v5 = (const __CFAllocator *)a1;
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
    return (char *)-[NSHTTPCookieStorageToCookie2Storage initWithPath:]([NSHTTPCookieStorageToCookie2Storage alloc], relativeURL);
  if (relativeURL)
  {
    v7 = CFURLCopyAbsoluteURL(relativeURL);
    AutoScalar::AutoScalar((AutoScalar *)&v11, (const __CFAllocator *)2);
    MutableDictionary = cfTypeCreateMutableDictionary(v5, CFSTR("url"), v7, CFSTR("type"), CFSTR("binary"), CFSTR("policy"), v12, CFSTR("base"), a3, 0, 0);
    v11 = &off_1E14E47E8;
    if (v12)
      CFRelease(v12);
    v9 = _CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(v5, MutableDictionary, 1);
    if (MutableDictionary)
      CFRelease(MutableDictionary);
    if (v7)
      CFRelease(v7);
    return v9;
  }
  else
  {
    v10 = (os_unfair_lock_s *)_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault;
    if (!_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault)
    {
      a1 = StorageSession::copyProcessDefault((StorageSession *)a1);
      v10 = (os_unfair_lock_s *)(a1 - 16);
      _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault = (uint64_t)(a1 - 16);
    }
    return (char *)_CFURLStorageSessionCopyCookieStorage((uint64_t)a1, v10);
  }
}

void sub_183FBEB60(_Unwind_Exception *exception_object)
{
  const void *v1;
  uint64_t v2;
  const void *v4;

  *(_QWORD *)(v2 - 48) = &off_1E14E47E8;
  v4 = *(const void **)(v2 - 40);
  if (v4)
    CFRelease(v4);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

CFTypeRef _CFURLStorageSessionCopyCache(uint64_t a1, os_unfair_lock_s *a2)
{
  os_unfair_lock_s *v3;

  if (StorageSession::Class(void)::sOnce_StorageSession != -1)
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
  if (a2)
    v3 = a2 + 4;
  else
    v3 = 0;
  return StorageSession::copyCacheStorage(v3);
}

_QWORD *CFHTTPCookieStorageCreateFromIdentifyingData(CFAllocatorRef allocator, CFDataRef data)
{
  const __CFArray *v5;
  const __CFArray *v6;
  CFTypeID v7;
  audit_token_t *v8;
  _QWORD *v9;

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
    return -[NSHTTPCookieStorageToCookie2Storage initWithIdentifyingData:]([NSHTTPCookieStorageToCookie2Storage alloc], data);
  v5 = (const __CFArray *)CFPropertyListCreateWithData(allocator, data, 0, 0, 0);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = CFGetTypeID(v5);
  if (v7 == CFArrayGetTypeID())
    v9 = _CFHTTPCookieStorageCreateFromArchive(allocator, v6, v8);
  else
    v9 = 0;
  CFRelease(v6);
  return v9;
}

void CFHTTPCookieStorageScheduleWithRunLoop(uint64_t a1, __CFRunLoop *a2, __CFString *a3)
{
  NSObject *v6;
  HTTPCookieStorage *v7;
  uint8_t v8[16];

  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v8 = 0;
      _os_log_error_impl(&dword_183ECA000, v6, OS_LOG_TYPE_ERROR, "CFHTTPCookieStorageScheduleWithRunLoop should no longer be called", v8, 2u);
    }
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
    if (a1)
      v7 = (HTTPCookieStorage *)(a1 + 16);
    else
      v7 = 0;
    HTTPCookieStorage::scheduleWithRunLoop(v7, a2, a3);
  }
}

void _CFSocketStreamCreatePair(__CFAllocator *a1, const __CFString *a2, const __CFAllocator *a3, int a4, const __CFData **a5, __CFReadStream **a6, __CFWriteStream **a7)
{
  __CFHost *v12;

  if (a2)
  {
    v12 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(a1, a2, (const __CFAllocator *)(unsigned __int16)a3);
    if (v12 || (v12 = CFHostCreateWithName(a1, a2)) != 0)
    {
      __CFStreamCreatePairWithSocketToCFHost(a1, v12, a3, a6, a7, 1);
      CFRelease(v12);
    }
    else
    {
      if (a6)
        *a6 = 0;
      if (a7)
        *a7 = 0;
    }
  }
  else if (a5)
  {
    _CFStreamCreatePairWithCFSocketSignaturePieces(a1, a5[2], (uint64_t)a6, (uint64_t)a7, (const __CFData *)a5, a6, a7);
  }
  else
  {
    _CFStreamCreatePairWithNativeSocket(a1, a4, a6, a7);
  }
}

uint64_t _CFURLStorageSessionCreate(uint64_t a1, const __CFString *a2, const __CFDictionary *a3)
{
  uint64_t Instance;
  uint64_t v6;
  uint64_t v7;
  const __CFString *v8;
  const __CFAllocator *v9;
  const char **Copy;
  const __CFAllocator *v11;
  CFDictionaryRef v12;
  const __CFString *Value;
  __CFBundle *MainBundle;
  CFStringRef Identifier;
  const __CFString *v17;
  const char *v18;
  size_t v19;

  if (StorageSession::Class(void)::sOnce_StorageSession != -1)
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_16297);
  Instance = _CFRuntimeCreateInstance();
  v6 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v6 = Instance + 16;
    *(_QWORD *)(Instance + 96) = 0;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  *(_QWORD *)v6 = &off_1E14E72B0;
  *(_QWORD *)(v6 + 8) = &unk_1E14E72F8;
  *(_BYTE *)(v6 + 56) = 0;
  v7 = StorageSession::StorageSession(unsigned char)::gGenerations++;
  *(_QWORD *)(v6 + 64) = v7;
  *(_DWORD *)(v6 + 48) = 0;
  if (a2)
    goto LABEL_6;
  if (a3)
  {
    Value = (const __CFString *)CFDictionaryGetValue(a3, CFSTR("kCFURLStorageSessionIdentifier"));
    if (Value)
    {
      a2 = Value;
LABEL_6:
      v8 = 0;
LABEL_7:
      v9 = CFGetAllocator((CFTypeRef)(v6 - 16));
      Copy = (const char **)CFStringCreateCopy(v9, a2);
      goto LABEL_8;
    }
  }
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    Identifier = CFBundleGetIdentifier(MainBundle);
    if (Identifier)
    {
      v17 = (const __CFString *)CFRetain(Identifier);
      goto LABEL_23;
    }
  }
  Copy = (const char **)_CFGetProgname();
  if (!Copy)
  {
    v8 = 0;
    goto LABEL_8;
  }
  v18 = *Copy;
  if (*Copy)
  {
    v19 = strlen(*Copy);
    v17 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v18, v19, 0x201u, 0);
LABEL_23:
    v8 = v17;
    a2 = v17;
    if (v17)
      goto LABEL_7;
    goto LABEL_27;
  }
  v8 = 0;
LABEL_27:
  Copy = 0;
LABEL_8:
  *(_QWORD *)(v6 + 72) = Copy;
  if (a3)
  {
    v11 = CFGetAllocator((CFTypeRef)(v6 - 16));
    v12 = CFDictionaryCreateCopy(v11, a3);
  }
  else
  {
    v12 = 0;
  }
  *(_QWORD *)(v6 + 80) = v12;
  if (v8)
    CFRelease(v8);
  return v6 - 16;
}

id CFURLCacheCurrentDiskUsage(__CFURLCache **a1)
{
  uint64_t TypeID;
  _QWORD *v3;
  const char *v4;
  _QWORD *v5;
  uint64_t v6;
  const char *v8;

  if (!a1)
    return 0;
  TypeID = CFURLCacheGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    v3 = __CFURLCache::createAndOpenCacheDB(a1[2]);
    if (v3)
    {
      v5 = v3;
      -[NSURLStorageURLCacheDB updateFSBackedCacheUsageOnDisk](v3, v4);
      -[NSURLStorageURLCacheDB updateSQLiteDBCacheUsageOnDisk](v5);
      v6 = v5[25];

      return (id)v6;
    }
    return 0;
  }
  v8 = (const char *)CFURLCacheCurrentDiskUsage::s;
  if (!CFURLCacheCurrentDiskUsage::s)
  {
    v8 = sel_registerName("_nscfBridgeURLCacheCurrentDiskUsage");
    CFURLCacheCurrentDiskUsage::s = (uint64_t)v8;
  }
  return objc_msgSend(a1, v8);
}

CFStringRef _CFNetworkCopyDefaultUserAgentString()
{
  const __CFAllocator *v0;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  pthread_once(&initControl, initializeUserAgentString);
  return CFStringCreateCopy(v0, (CFStringRef)sUserAgentString);
}

__CFError *cfnTranslateCFError(__CFError *a1, void *a2)
{
  __CFError *v3;
  CFIndex Code;
  CFErrorDomain Domain;
  const __CFDictionary *v6;
  uint64_t v7;
  const __CFString *v8;
  const void *Value;
  const void *v10;
  const void *v11;
  const void *LocalizedString;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  uint64_t v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  uint64_t v24;
  const void *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD v30[15];
  _QWORD v31[16];

  v3 = a1;
  v31[15] = *MEMORY[0x1E0C80C00];
  Code = CFErrorGetCode(a1);
  Domain = CFErrorGetDomain(v3);
  if (!CFEqual(Domain, CFSTR("kCFErrorDomainCFNetwork")) || Code > -998 || Code < -3999)
    return v3;
  v6 = CFErrorCopyUserInfo(v3);
  if (a2)
  {
    v31[0] = *MEMORY[0x1E0CB32F0];
    v30[0] = a2;
    if (objc_msgSend(a2, "absoluteString"))
    {
      v31[1] = *MEMORY[0x1E0CB3300];
      v30[1] = objc_msgSend(a2, "absoluteString");
      v7 = 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = CFURLCopyHostName((CFURLRef)a2);
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  Value = CFDictionaryGetValue(v6, (const void *)*MEMORY[0x1E0C9AFE0]);
  if (!Value || (v10 = CFRetain(Value)) == 0)
    v10 = _CFNetworkErrorCopyLocalizedDescriptionWithHostname(Code, v8);
  v30[v7] = v10;
  if (v8)
    CFRelease(v8);
  if (v10)
    v31[v7++] = *MEMORY[0x1E0CB2D50];
  v11 = CFDictionaryGetValue(v6, (const void *)*MEMORY[0x1E0C9AFE8]);
  if (v11)
  {
    v30[v7] = v11;
  }
  else
  {
    LocalizedString = _CFNetworkErrorGetLocalizedString(Code, 2);
    v30[v7] = LocalizedString;
    if (!LocalizedString)
      goto LABEL_21;
  }
  v31[v7++] = *MEMORY[0x1E0CB2D68];
LABEL_21:
  v13 = CFDictionaryGetValue(v6, (const void *)*MEMORY[0x1E0C9AFF0]);
  if (v13)
  {
    v30[v7] = v13;
LABEL_24:
    v31[v7++] = *MEMORY[0x1E0CB2D80];
    goto LABEL_25;
  }
  v14 = _CFNetworkErrorGetLocalizedString(Code, 3);
  v30[v7] = v14;
  if (v14)
    goto LABEL_24;
LABEL_25:
  if (v6)
  {
    v15 = CFDictionaryGetValue(v6, CFSTR("kCFStreamPropertySSLPeerCertificates"));
    v30[v7] = v15;
    if (v15)
    {
      v31[v7] = CFSTR("NSErrorPeerCertificateChainKey");
      v16 = CFDictionaryGetValue(v6, &unk_1EDCFAB10);
      v17 = v7 + 1;
      v30[v7 + 1] = v16;
      if (v16)
      {
        v31[v17] = CFSTR("NSErrorClientCertificateChainKey");
        v17 = v7 + 2;
      }
      v18 = CFDictionaryGetValue(v6, &unk_1EDCFAB48);
      v30[v17] = v18;
      if (v18)
      {
        v31[v17] = CFSTR("NSErrorClientCertificateStateKey");
        v7 = v17 + 1;
      }
      else
      {
        v7 = v17;
      }
    }
    v19 = CFDictionaryGetValue(v6, &unk_1EDCFC048);
    v30[v7] = v19;
    if (v19)
      v31[v7++] = *MEMORY[0x1E0CB32F8];
    v20 = CFDictionaryGetValue(v6, CFSTR("_kCFStreamErrorDomainKey"));
    v30[v7] = v20;
    if (v20)
      v31[v7++] = CFSTR("_kCFStreamErrorDomainKey");
    v21 = CFDictionaryGetValue(v6, CFSTR("_kCFStreamErrorCodeKey"));
    v30[v7] = v21;
    if (v21)
      v31[v7++] = CFSTR("_kCFStreamErrorCodeKey");
    v22 = CFDictionaryGetValue(v6, CFSTR("_kCFNetworkErrorConditionalRequestKey"));
    v30[v7] = v22;
    if (v22)
      v31[v7++] = CFSTR("_kCFNetworkErrorConditionalRequestKey");
    v23 = CFDictionaryGetValue(v6, CFSTR("_kCFNetworkErrorCachedResponseKey"));
    v30[v7] = v23;
    if (v23)
      v31[v7++] = CFSTR("_kCFNetworkErrorCachedResponseKey");
    v24 = *MEMORY[0x1E0CB3310];
    v25 = CFDictionaryGetValue(v6, (const void *)*MEMORY[0x1E0CB3310]);
    v30[v7] = v25;
    if (v25)
      v31[v7++] = v24;
  }
  v31[v7] = *MEMORY[0x1E0CB3388];
  v30[v7] = v3;
  v26 = (void *)MEMORY[0x1E0CB39B8];
  v27 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v30, v31, v7 + 1);
  if (Code == -998)
    v28 = -1;
  else
    v28 = Code;
  v3 = (__CFError *)objc_msgSend(v26, "errorWithDomain:code:userInfo:", *MEMORY[0x1E0CB32E8], v28, v27);
  if (v6)
    CFRelease(v6);
  if (v10)
    CFRelease(v10);
  return v3;
}

void sub_183FBF5B4(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t _CFStreamErrorFromCFError(__CFError *a1)
{
  CFErrorDomain Domain;
  uint64_t v3;

  if (!a1)
    return 0;
  Domain = CFErrorGetDomain(a1);
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E0C9AFD0]))
    goto LABEL_3;
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E0C9AFC8]))
  {
    if ((unint64_t)(CFErrorGetCode(a1) + 9899) >= 0x64)
      return 2;
    else
      return (int)*MEMORY[0x1E0C9B298];
  }
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E0C9AFC0]))
  {
    CFErrorGetCode(a1);
    return 11;
  }
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E0CE8B08]))
  {
    CFErrorGetCode(a1);
    return 13;
  }
  if (CFEqual(Domain, CFSTR("kCFErrorDomainWinSock")))
  {
    CFErrorGetCode(a1);
    return 7;
  }
  if (CFEqual(Domain, CFSTR("kCFErrorDomainCFNetwork")))
    return _CFStreamErrorFromCFNetworkErrorCode(a1);
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E0CB32E8]))
  {
    CFErrorGetCode(a1);
    return 15;
  }
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E0CCED48]))
  {
LABEL_3:
    CFErrorGetCode(a1);
    return 1;
  }
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E0CCED40]))
    return _CFStreamErrorFromNWDNSErrorCode(a1);
  if (!CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E0CCED50]))
    return -1;
  v3 = (int)*MEMORY[0x1E0C9B298];
  CFErrorGetCode(a1);
  return v3;
}

uint64_t _CFStreamErrorFromNWDNSErrorCode(__CFError *a1)
{
  CFIndex Code;

  Code = CFErrorGetCode(a1);
  if (Code == -65554)
    return 12;
  else
    return 10;
}

void __summaryLog_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.CFNetwork", "Summary");
  v1 = (void *)summaryLog::handle;
  summaryLog::handle = (uint64_t)v0;

}

CFMutableDictionaryRef __logAppleATSViolation_block_invoke()
{
  CFMutableDictionaryRef result;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  logAppleATSViolation::reportedDomains = (uint64_t)result;
  return result;
}

uint64_t __destroy_helper_block_e8_32c39_ZTSNSt3__110shared_ptrI11RequestBodyEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __copy_helper_block_e8_32c39_ZTSNSt3__110shared_ptrI11RequestBodyEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ____retainStorageAssertion_block_invoke()
{
  void *v0;

  os_unfair_lock_lock((os_unfair_lock_t)&lock);
  shouldHold = 0;
  if (!assertionCount)
  {
    objc_msgSend((id)assertion, "invalidate");
    v0 = (void *)assertion;
    assertion = 0;

  }
  os_unfair_lock_unlock((os_unfair_lock_t)&lock);
}

uint64_t ___ZNK11NSXURLCache18getResponseForTaskEP16NSURLSessionTaskhU13block_pointerFvPK20_CFCachedURLResponseE_block_invoke(uint64_t a1, void *a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), objc_msgSend(a2, "_CFCachedURLResponse"));
}

void ___ZN9TCFObjectI13URLConnectionE5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  qmemcpy(_PNAME<URLConnection>::GET(void)::p, "URLConnection", 13);
  CFClass::CFClass(v0, (const char *)_PNAME<URLConnection>::GET(void)::p);
  TCFObject<URLConnection>::Class(void)::clazz = (uint64_t)v0;
}

void sub_183FBF9DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  dword_1EDD01068 = 1835099506;
  _PNAME<SocketStream>::GET(void)::p = *(_QWORD *)"SocketStream>::GET() [OBJTYPE = SocketStream]";
  CFClass::CFClass(v0, (const char *)&_PNAME<SocketStream>::GET(void)::p);
  TCFObject<SocketStream>::Class(void)::clazz = (uint64_t)v0;
}

void sub_183FBFA64(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN9HSTSCache15defaultStoreURLEv_block_invoke()
{
  std::__shared_weak_count_vtbl *v0;
  std::__shared_weak_count *v1;
  void *PathToCacheDirectory;
  const void *v3;
  const __CFAllocator *v4;
  const __CFString *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count_vtbl *v8;
  std::__shared_weak_count *v9;

  v8 = 0;
  v9 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&HSTSPathOverrideLock);
  if (HSTSPathOverride)
  {
    v0 = (std::__shared_weak_count_vtbl *)CFRetain((CFTypeRef)HSTSPathOverride);
    v1 = (std::__shared_weak_count *)operator new();
    v1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F19E8;
    v1->__shared_owners_ = 0;
    v1->__shared_weak_owners_ = 0;
    v1[1].__vftable = v0;
    v8 = v0;
    v9 = v1;
    os_unfair_lock_unlock((os_unfair_lock_t)&HSTSPathOverrideLock);
    if (v0)
    {
      PathToCacheDirectory = (void *)CFRetain(v0);
      goto LABEL_6;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&HSTSPathOverrideLock);
    v1 = 0;
  }
  PathToCacheDirectory = __CreatePathToCacheDirectory(0, 0);
LABEL_6:
  v3 = PathToCacheDirectory;
  if (PathToCacheDirectory)
  {
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@/%@"), PathToCacheDirectory, CFSTR("HSTS.plist"), v8, v9);
    if (v5)
    {
      HSTSCache::defaultStoreURL(void)::cacheFileURL = (uint64_t)CFURLCreateWithFileSystemPath(v4, v5, kCFURLPOSIXPathStyle, 0);
      CFRelease(v5);
    }
    CFRelease(v3);
  }
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void sub_183FBFBE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  const void *v11;
  const void *v12;

  CFRelease(v12);
  CFRelease(v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t ___ZN6AppSSOL13ssoOptionFlagEv_block_invoke()
{
  uint64_t result;

  result = _CFGetProgname();
  if (result)
  {
    result = *(_QWORD *)result;
    if (result)
    {
      result = strcmp((const char *)result, "nsurlsessiond");
      if (!(_DWORD)result)
        AppSSO::ssoOptionFlag(void)::flag = 1;
    }
  }
  return result;
}

uint64_t ___ZN4Tube15_onqueue_cancelEv_block_invoke(uint64_t a1)
{
  Tube *v1;
  CFStreamError v3;

  v1 = *(Tube **)(a1 + 32);
  if (*((_QWORD *)v1 + 39))
    Tube::_onqueue_complete_needServerTrust(*(Tube **)(a1 + 32), 0, 1);
  if (*((_QWORD *)v1 + 38))
    Tube::_onqueue_complete_needClientCert(v1, 0, 1);
  Tube::_onqueue_cleanupConnection(v1);
  v3.domain = 1;
  *(_QWORD *)&v3.error = 89;
  Tube::_onqueue_invokeCB(v1, v3);
  return (*(uint64_t (**)(Tube *))(*(_QWORD *)v1 + 48))(v1);
}

xpc_object_t ___ZN28ProxyConnectionEstablishment10SetProxiesEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_PK14__CFDictionary_block_invoke()
{
  xpc_object_t result;

  result = xpc_dictionary_create(0, 0, 0);
  ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::emptyDict = (uint64_t)result;
  return result;
}

void ___ZN27URLConnectionClient_Classic51_delegate_willSendRequestForAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  void (*v7)(uint64_t, _QWORD, _QWORD);
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int (*v12)(uint64_t, uint64_t, _QWORD);
  uint64_t v13;
  uint64_t v14;
  URLAuthChallenge *v15;
  void (*v16)(uint64_t, uint64_t, uint64_t);
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void *v21;
  _QWORD v22[6];

  if (!a2 || !a3)
    goto LABEL_34;
  v5 = a2;
  v6 = *(_QWORD *)(a1 + 32);
  v7 = (void (*)(uint64_t, _QWORD, _QWORD))a3[17];
  if (v7)
  {
    v7(a2, *(_QWORD *)(a1 + 40), a3[1]);
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3221225472;
    v22[2] = ___ZN27URLConnectionClient_Classic51_delegate_willSendRequestForAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke_2;
    v22[3] = &__block_descriptor_48_e5_v8__0l;
    v8 = *(_QWORD *)(a1 + 40);
    v22[4] = v6;
    v22[5] = v8;
    __CFNetworkLogForAuthTimeoutIssueSync((uint64_t)v22);
    goto LABEL_34;
  }
  if (!a3[12] && !a3[16])
  {
LABEL_25:
    (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v6 + 216) + 64))(*(_QWORD *)(v6 + 216), 0, *(_QWORD *)(a1 + 40));
    goto LABEL_34;
  }
  while (1)
  {
    v9 = *(_QWORD *)(a1 + 40);
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
    v10 = v9 + 16;
    if (!v9)
      v10 = 0;
    v11 = *(_QWORD *)(v10 + 24);
    v12 = (unsigned int (*)(uint64_t, uint64_t, _QWORD))a3[16];
    if (!v12)
      break;
    if (v12(v5, v11, a3[1]))
      goto LABEL_26;
LABEL_19:
    v14 = *(_QWORD *)(a1 + 40);
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
    if (v14)
      v15 = (URLAuthChallenge *)(v14 + 16);
    else
      v15 = 0;
    if (!URLAuthChallenge::tryNextProtectionSpace(v15))
      goto LABEL_25;
  }
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  v13 = v11 + 16;
  if (!v11)
    v13 = 0;
  if ((*(_DWORD *)(v13 + 56) - 7) < 0xFFFFFFFA)
    goto LABEL_19;
LABEL_26:
  v16 = (void (*)(uint64_t, uint64_t, uint64_t))a3[12];
  if (v16)
  {
    v17 = *(_QWORD *)(a1 + 40);
    v18 = a3[1];
  }
  else
  {
    v5 = *(_QWORD *)(v6 + 216);
    v19 = *(_QWORD *)(a1 + 40);
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
    v20 = v19 + 16;
    if (!v19)
      v20 = 0;
    v17 = *(_QWORD *)(v20 + 32);
    v18 = *(_QWORD *)(a1 + 40);
    v16 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 64);
  }
  v16(v5, v17, v18);
LABEL_34:
  v21 = *(const void **)(a1 + 40);
  if (v21)
    CFRelease(v21);
}

void ___ZN27URLConnectionClient_Classic28_delegate_didReceiveResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  if (a2 && a3)
  {
    v5 = *(_QWORD *)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 40);
    ++*(_QWORD *)(v5 + 224);
    (*(void (**)(uint64_t, uint64_t, _QWORD))(a3 + 48))(a2, v4, *(_QWORD *)(a3 + 8));
    --*(_QWORD *)(v5 + 224);
  }

}

uint64_t ___ZN27URLConnectionClient_Classic26_delegate_didFinishLoadingEU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v4)(uint64_t, _QWORD);

  if (a2)
  {
    if (a3)
    {
      v4 = *(void (**)(uint64_t, _QWORD))(a3 + 72);
      if (v4)
        v4(a2, *(_QWORD *)(a3 + 8));
    }
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11[2];
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = (_QWORD *)a1[4];
  if (v2[31] && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "assertion failure", buf, 2u);
  }
  v3 = v2[33];
  if (v3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 134218240;
    v13 = v3;
    v14 = 2048;
    v15 = v2;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "fSendingCallbacks = %ld, which means we're suspended.  Check out *(URLConnectionClient_Classic*) %p", buf, 0x16u);
  }
  if (v2[30] && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "assertion failure", buf, 2u);
  }
  v4 = v2[32];
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    v2[32] = 0;
  }
  v5 = a1[5];
  v6 = (std::__shared_weak_count *)a1[6];
  v11[0] = v5;
  v11[1] = (uint64_t)v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  URLConnectionClient::invalidateAsync((uint64_t)v2, v11);
  if (v6)
  {
    v9 = (unint64_t *)&v6->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_183FC019C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _DWORD *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD v11[6];
  std::__shared_weak_count *v12;
  uint8_t buf[16];

  v2 = a1[4];
  if (*(_BYTE *)(v2 + 272) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "can't invalidate twice", buf, 2u);
  }
  *(_BYTE *)(v2 + 272) = 1;
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 136));
  *(_BYTE *)(v2 + 140) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 136));
  while (*(_QWORD *)(v2 + 248))
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 112))(v2);
  (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 32) + 64))(*(_QWORD *)(v2 + 32));
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3321888768;
  v11[2] = ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_22;
  v11[3] = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  v4 = a1[5];
  v3 = (std::__shared_weak_count *)a1[6];
  v11[4] = v2;
  v11[5] = v4;
  v12 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  if (*(_QWORD *)(v2 + 264) && (v7 = *(_DWORD **)(v2 + 256)) != 0 && v7[10])
    (*(void (**)(_DWORD *, _QWORD *))(*(_QWORD *)v7 + 96))(v7, v11);
  else
    ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_22(v11);
  v8 = v12;
  if (v12)
  {
    v9 = (unint64_t *)&v12->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_183FC0344(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN25HTTP2ConnectionCacheEntry5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "HTTP2ConnectionCacheEntry");
  HTTP2ConnectionCacheEntry::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FC03A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef ___ZN21TrustExceptionManager27sharedTrustExceptionManagerEv_block_invoke()
{
  uint64_t v0;
  const __CFAllocator *v1;
  CFMutableDictionaryRef result;

  v0 = operator new();
  *(_QWORD *)v0 = &off_1E14EC228;
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(_QWORD *)(v0 + 16) = &off_1E14EA568;
  result = CFDictionaryCreateMutable(v1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v0 + 24) = result;
  *(_DWORD *)(v0 + 8) = 0;
  TrustExceptionManager::sharedTrustExceptionManager(void)::singleton = v0;
  return result;
}

void sub_183FC0444(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  MEMORY[0x186DB748C](v1, 0x10A1C40914F2AA0);
  _Unwind_Resume(a1);
}

void ___ZN20URLDataDecoderHolder5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFURLDataDecoder");
  URLDataDecoderHolder::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FC04BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN20StrictSecurityPolicy20isATSCompliantCipherEt_block_invoke()
{
  unint64_t v0;
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  __int16 *v5;
  unint64_t v6;
  uint8x8_t v7;
  uint64_t ***v8;
  uint64_t **i;
  unint64_t v10;
  _QWORD *v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  int8x8_t prime;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint8x8_t v23;
  unint64_t v24;
  uint8x8_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v32;

  v1 = operator new();
  v2 = 0;
  v3 = 0;
  *(_OWORD *)v1 = 0u;
  *(_OWORD *)(v1 + 16) = 0u;
  v4 = (_QWORD *)(v1 + 16);
  *(_DWORD *)(v1 + 32) = 1065353216;
  StrictSecurityPolicy::isATSCompliantCipher(unsigned short)::compliantCiphers = v1;
  v5 = kATSv1PFSCiphers;
  do
  {
    v6 = (unsigned __int16)*v5;
    if (v2)
    {
      v7 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
      v7.i16[0] = vaddlv_u8(v7);
      if (v7.u32[0] > 1uLL)
      {
        v0 = (unsigned __int16)*v5;
        if (v2 <= v6)
          v0 = v6 % v2;
      }
      else
      {
        v0 = ((_DWORD)v2 - 1) & v6;
      }
      v8 = *(uint64_t ****)(*(_QWORD *)v1 + 8 * v0);
      if (v8)
      {
        for (i = *v8; i; i = (uint64_t **)*i)
        {
          v10 = (unint64_t)i[1];
          if (v10 == v6)
          {
            if (*((unsigned __int16 *)i + 8) == (_DWORD)v6)
              goto LABEL_74;
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v10 >= v2)
                v10 %= v2;
            }
            else
            {
              v10 &= v2 - 1;
            }
            if (v10 != v0)
              break;
          }
        }
      }
    }
    v11 = operator new(0x18uLL);
    *v11 = 0;
    v11[1] = v6;
    *((_WORD *)v11 + 8) = v6;
    v12 = (float)(unint64_t)(v3 + 1);
    v13 = *(float *)(v1 + 32);
    if (!v2 || (float)(v13 * (float)v2) < v12)
    {
      v14 = (v2 & (v2 - 1)) != 0;
      if (v2 < 3)
        v14 = 1;
      v15 = v14 | (2 * v2);
      v16 = vcvtps_u32_f32(v12 / v13);
      if (v15 <= v16)
        prime = (int8x8_t)v16;
      else
        prime = (int8x8_t)v15;
      if (*(_QWORD *)&prime == 1)
      {
        prime = (int8x8_t)2;
      }
      else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
      {
        prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
        v2 = *(_QWORD *)(v1 + 8);
      }
      if (*(_QWORD *)&prime > v2)
        goto LABEL_30;
      if (*(_QWORD *)&prime < v2)
      {
        v24 = vcvtps_u32_f32((float)*(unint64_t *)(v1 + 24) / *(float *)(v1 + 32));
        if (v2 < 3 || (v25 = (uint8x8_t)vcnt_s8((int8x8_t)v2), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
        {
          v24 = std::__next_prime(v24);
        }
        else
        {
          v26 = 1 << -(char)__clz(v24 - 1);
          if (v24 >= 2)
            v24 = v26;
        }
        if (*(_QWORD *)&prime <= v24)
          prime = (int8x8_t)v24;
        if (*(_QWORD *)&prime >= v2)
        {
          v2 = *(_QWORD *)(v1 + 8);
        }
        else
        {
          if (prime)
          {
LABEL_30:
            if (*(_QWORD *)&prime >> 61)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v18 = operator new(8 * *(_QWORD *)&prime);
            v19 = *(_QWORD **)v1;
            *(_QWORD *)v1 = v18;
            if (v19)
              operator delete(v19);
            v20 = 0;
            *(int8x8_t *)(v1 + 8) = prime;
            do
              *(_QWORD *)(*(_QWORD *)v1 + 8 * v20++) = 0;
            while (*(_QWORD *)&prime != v20);
            v21 = (_QWORD *)*v4;
            if (*v4)
            {
              v22 = v21[1];
              v23 = (uint8x8_t)vcnt_s8(prime);
              v23.i16[0] = vaddlv_u8(v23);
              if (v23.u32[0] > 1uLL)
              {
                if (v22 >= *(_QWORD *)&prime)
                  v22 %= *(_QWORD *)&prime;
              }
              else
              {
                v22 &= *(_QWORD *)&prime - 1;
              }
              *(_QWORD *)(*(_QWORD *)v1 + 8 * v22) = v4;
              v27 = (_QWORD *)*v21;
              if (*v21)
              {
                do
                {
                  v28 = v27[1];
                  if (v23.u32[0] > 1uLL)
                  {
                    if (v28 >= *(_QWORD *)&prime)
                      v28 %= *(_QWORD *)&prime;
                  }
                  else
                  {
                    v28 &= *(_QWORD *)&prime - 1;
                  }
                  if (v28 != v22)
                  {
                    if (!*(_QWORD *)(*(_QWORD *)v1 + 8 * v28))
                    {
                      *(_QWORD *)(*(_QWORD *)v1 + 8 * v28) = v21;
                      goto LABEL_55;
                    }
                    *v21 = *v27;
                    *v27 = **(_QWORD **)(*(_QWORD *)v1 + 8 * v28);
                    **(_QWORD **)(*(_QWORD *)v1 + 8 * v28) = v27;
                    v27 = v21;
                  }
                  v28 = v22;
LABEL_55:
                  v21 = v27;
                  v27 = (_QWORD *)*v27;
                  v22 = v28;
                }
                while (v27);
              }
            }
            v2 = (unint64_t)prime;
            goto LABEL_59;
          }
          v32 = *(_QWORD **)v1;
          *(_QWORD *)v1 = 0;
          if (v32)
            operator delete(v32);
          v2 = 0;
          *(_QWORD *)(v1 + 8) = 0;
        }
      }
LABEL_59:
      if ((v2 & (v2 - 1)) != 0)
      {
        if (v2 <= v6)
          v0 = v6 % v2;
        else
          v0 = v6;
      }
      else
      {
        v0 = ((_DWORD)v2 - 1) & v6;
      }
    }
    v29 = *(_QWORD **)v1;
    v30 = *(_QWORD **)(*(_QWORD *)v1 + 8 * v0);
    if (v30)
    {
      *v11 = *v30;
LABEL_72:
      *v30 = v11;
      goto LABEL_73;
    }
    *v11 = *v4;
    *v4 = v11;
    v29[v0] = v4;
    if (*v11)
    {
      v31 = *(_QWORD *)(*v11 + 8);
      if ((v2 & (v2 - 1)) != 0)
      {
        if (v31 >= v2)
          v31 %= v2;
      }
      else
      {
        v31 &= v2 - 1;
      }
      v30 = (_QWORD *)(*(_QWORD *)v1 + 8 * v31);
      goto LABEL_72;
    }
LABEL_73:
    v3 = *(_QWORD *)(v1 + 24) + 1;
    *(_QWORD *)(v1 + 24) = v3;
LABEL_74:
    ++v5;
  }
  while (v5 != (__int16 *)&kATSv1NonPFSCiphers);
}

void sub_183FC0904(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

CFIndex ___ZN20StrictSecurityPolicy11ATSLogLevelEv_block_invoke()
{
  CFIndex result;
  int v1;
  Boolean keyExistsAndHasValidFormat;

  keyExistsAndHasValidFormat = 0;
  result = CFPreferencesGetAppIntegerValue(CFSTR("com.apple.cfnetwork.ats.loglevel"), (CFStringRef)*MEMORY[0x1E0C9B228], &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
  {
    if (result == 1)
    {
      v1 = 1;
    }
    else
    {
      if (result != 2)
        return result;
      v1 = 2;
    }
    StrictSecurityPolicy::ATSLogLevel(void)::atslogLevel = v1;
  }
  return result;
}

void ___ZN20ClassicURLConnection6cancelEv_block_invoke_3(uint64_t a1)
{
  uint64_t v1;
  __CFRunLoopSource *v2;
  const void *v3;
  __CFRunLoop *v4;
  const void *v5;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(__CFRunLoopSource **)(v1 + 40);
  if (v2)
  {
    CFRunLoopSourceInvalidate(v2);
    v3 = *(const void **)(v1 + 40);
    *(_QWORD *)(v1 + 40) = 0;
    if (v3)
      CFRelease(v3);
    v4 = *(__CFRunLoop **)(v1 + 48);
    if (v4)
    {
      CFRunLoopWakeUp(v4);
      v5 = *(const void **)(v1 + 48);
      *(_QWORD *)(v1 + 48) = 0;
      if (v5)
        CFRelease(v5);
    }
  }
  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN20ClassicURLConnection6cancelEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  dispatch_queue_global_t global_queue;
  _QWORD v5[5];

  v3 = *(_QWORD *)(a1 + 32);
  CFRetain((CFTypeRef)(v3 - 16));
  global_queue = dispatch_get_global_queue(0, 0);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZN20ClassicURLConnection6cancelEv_block_invoke_2;
  v5[3] = &__block_descriptor_40_e5_v8__0l;
  v5[4] = v3;
  if (!(*(unsigned int (**)(uint64_t, dispatch_queue_global_t, _QWORD *))(*(_QWORD *)a2 + 48))(a2, global_queue, v5))CFRelease((CFTypeRef)(v3 - 16));
}

void ___ZN20ClassicURLConnection5startEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  const void *v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = objc_msgSend(*(id *)(v4 + 56), "_metrics");
  if (v5)
    v6.n128_u64[0] = *(_QWORD *)(v5 + 56);
  (*(void (**)(uint64_t, _QWORD, _QWORD, __n128))(*(_QWORD *)a2 + 40))(a2, *(_QWORD *)(a1 + 40), *MEMORY[0x1E0C9B280], v6);
  v7 = *(const void **)(a1 + 40);
  if (v7)
    CFRelease(v7);
  CFRelease((CFTypeRef)(v4 - 16));
}

void ___ZN20ClassicURLConnection25invalidateConnectionAsyncEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  v2 = a1[5];
  v3 = *(_QWORD *)(a1[4] + 24);
  v4 = (std::__shared_weak_count *)a1[6];
  v10 = v2;
  v11 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 16))(v3, &v10);
  v7 = v11;
  if (v11)
  {
    v8 = (unint64_t *)&v11->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_183FC0B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20ClassicURLConnection21setDelegateSchedulingEPK17CoreSchedulingSet_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2))
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 64))(a2, *(_QWORD *)(a1 + 32));
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

void ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN20ClassicURLConnection13useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;
  const void *v4;

  if (a2)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 80))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
}

uint64_t ___ZN19URLConnectionLoader39_loaderInterface_setBytesPerSecondLimitEx_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(result + 32));
  return result;
}

uint64_t ___ZN19URLConnectionLoader32_loaderInterface_setPriorityHintEfb_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(uint64_t, _QWORD, float))(*(_QWORD *)a2 + 152))(a2, *(unsigned __int8 *)(result + 36), *(float *)(result + 32));
  return result;
}

void ___ZN19URLConnectionLoader29ensureLoaderHasProtocolNoLockEP12NSURLRequest_block_invoke(uint64_t a1)
{
  URLConnectionLoader *v1;
  uint64_t v3;
  uint64_t v4;
  const __CFAllocator *v5;
  const void *v6;
  void (**v7)(AutoString *__hidden);
  CFStringRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v1 = *(URLConnectionLoader **)(a1 + 40);
  if (v1->var20 && v1->var19 <= CFAbsoluteTimeGetCurrent())
  {
    if (!v1->var23)
    {
      v3 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_117, 1);
      if (v3)
      {
        v4 = v3;
        if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v3 + 16))(v3, "Did Timeout", 0))
        {
          v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v6 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))v1->var0 + 3))(v1);
          v7 = &off_1E14E4818;
          v9 = 0;
          v10 = 0;
          v8 = CFStringCreateWithCString(v5, "Loader", 0x8000100u);
          (*(void (**)(uint64_t, CFStringRef, const void *))(*(_QWORD *)v4 + 64))(v4, v8, v6);
          AutoString::~AutoString((AutoString *)&v7);
          if (v6)
            CFRelease(v6);
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v4 + 72))(v4, "Timeout Interval", CFSTR("%.3f seconds"));
          URLConnectionLoader::logTimings((uint64_t)v1, v4);
          (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
        }
      }
      (*(void (**)(InterfaceRequiredForLoader *, void *))(*(_QWORD *)v1->var5 + 40))(v1->var5, &__block_literal_global_122);
    }
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
  }
  else
  {
    URLConnectionLoader::scheduleTimeoutTimer(v1);
  }
}

void sub_183FC0E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN19URLConnectionClientC2EP20ClassicURLConnectionP16NSURLSessionTaskPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 32);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  *(_QWORD *)(v2 + 160) = result;
  if (result >= 1)
  {
    result = (uint64_t)CFArrayCreateMutable(*(CFAllocatorRef *)(v2 + 8), 0, MEMORY[0x1E0C9B378]);
    *(_QWORD *)(v2 + 144) = result;
    *(_QWORD *)(v2 + 152) = 0;
    if (*(uint64_t *)(v2 + 160) >= 1)
      *(_BYTE *)(v2 + 232) = 1;
  }
  return result;
}

uint64_t ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_3(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 32) + 72))(*(_QWORD *)(v1 + 32));
}

void ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  _QWORD v15[6];
  NSObject **v16;
  std::__shared_weak_count *v17;
  _QWORD v18[6];
  NSObject **v19;
  std::__shared_weak_count *v20;

  v4 = *(_QWORD *)(a1 + 48);
  (*(void (**)(_QWORD))(**(_QWORD **)(v4 + 32) + 64))(*(_QWORD *)(v4 + 32));
  if (a2)
  {
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_3;
    v18[3] = &unk_1E14FDA90;
    v5 = *(NSObject **)(a1 + 32);
    v18[4] = *(_QWORD *)(a1 + 40);
    v18[5] = v4;
    std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject  {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>(&v19, v5, v18);
    v16 = v19;
    v17 = v20;
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    (*(void (**)(uint64_t, NSObject ***))(*(_QWORD *)a2 + 24))(a2, &v16);
    v8 = v17;
    if (v17)
    {
      v9 = (unint64_t *)&v17->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v11 = v20;
    if (v20)
    {
      v12 = (unint64_t *)&v20->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
  else
  {
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_4;
    v15[3] = &unk_1E14FDA90;
    v14 = *(NSObject **)(a1 + 32);
    v15[4] = *(_QWORD *)(a1 + 40);
    v15[5] = v4;
    dispatch_async(v14, v15);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void sub_183FC10AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7 - 48);
  _Unwind_Resume(a1);
}

void ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[4];
  __int128 v8;
  uint64_t v9;
  _QWORD v10[6];
  _QWORD v11[6];
  _QWORD block[6];

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(_QWORD *)(v1 + 216);
  v3 = MEMORY[0x1E0C809B0];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_2;
  v7[3] = &unk_1E14FA7E0;
  v9 = v1;
  v8 = *(_OWORD *)(a1 + 32);
  CFRetain((CFTypeRef)(v2 - 16));
  v4 = *(_QWORD *)(v2 + 32);
  v10[0] = v3;
  v10[1] = 3221225472;
  v10[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9489;
  v10[3] = &unk_1E14FABB8;
  v10[4] = v7;
  v10[5] = v2;
  v11[0] = v3;
  v11[1] = 3221225472;
  v11[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9490;
  v11[3] = &unk_1E14FDA90;
  v11[4] = v10;
  v11[5] = v4;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 32) + 64))(*(_QWORD *)(v4 + 32));
  v6 = *(NSObject **)(v4 + 40);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v11;
  block[5] = v5;
  dispatch_async(v6, block);
}

void ___ZN19URLConnectionClient37_internalEvent_WillSendRequestPartTwoEP12NSURLRequesth_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;

  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 40);
    if (*(_BYTE *)(a1 + 48))
      (*(void (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2);
    -[__CFN_TaskMetrics nextTransaction:withNewRequest:](objc_msgSend(*(id *)(v4 + 88), "_metrics"), 0, *(void **)(a1 + 32));
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)(v4 + 88));
  }
  v5 = *(const void **)(a1 + 32);
  if (v5)
    CFRelease(v5);
}

uint64_t ___ZN19URLConnectionClient35_loaderClientEvent_DidFinishLoadingEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) + 80))(*(_QWORD *)(a1 + 32) + 48);
}

void ___ZN19URLConnectionClient30_internalEvent_WillSendRequestEv_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  NSURLRequest *v3;
  const void *v4;
  _QWORD v5[6];

  v3 = *(NSURLRequest **)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  if ((*(_WORD *)(v2 + 76) & 0x100) != 0)
  {
    if (v3)
      CFRetain(*(CFTypeRef *)(a1 + 32));
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN19URLConnectionClient41_internal_WillSendRequestPartOnePointFiveEP12NSURLRequest_block_invoke;
    v5[3] = &unk_1E14FA8E8;
    v5[4] = v3;
    v5[5] = v2;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)(v2 + 48) + 160))(v2 + 48, v5);
  }
  else
  {
    URLConnectionClient::_internalEvent_WillSendRequestPartTwo(*(id **)(a1 + 40), v3, 0);
  }
  v4 = *(const void **)(a1 + 32);
  if (v4)
    CFRelease(v4);
}

void ___ZN19URLConnectionClient30_internalEvent_WillSendRequestEv_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[6];
  _QWORD block[6];

  v3 = *(_QWORD *)(a1 + 32);
  if (cf)
    CFRetain(cf);
  v4 = MEMORY[0x1E0C809B0];
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZN19URLConnectionClient30_internalEvent_WillSendRequestEv_block_invoke_2;
  v7[3] = &unk_1E14FE140;
  v7[4] = cf;
  v7[5] = v3;
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 32) + 64))(*(_QWORD *)(v3 + 32));
  v6 = *(NSObject **)(v3 + 40);
  block[0] = v4;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v7;
  block[5] = v5;
  dispatch_async(v6, block);
}

void ___ZN19URLConnectionClient15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  const void *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10[2];
  uint8_t buf[16];

  v2 = a1[4];
  if ((*(_WORD *)(v2 + 76) & 8) == 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "ERROR: end state not delivered for this connection client!", buf, 2u);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 72));
  v3 = *(const void **)(v2 + 144);
  *(_QWORD *)(v2 + 144) = 0;
  if (v3)
    CFRelease(v3);
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 72));
  v4 = a1[5];
  v5 = (std::__shared_weak_count *)a1[6];
  v10[0] = v4;
  v10[1] = (uint64_t)v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  URLConnectionInstanceData::invalidateAsync(v2, v10);
  if (v5)
  {
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_183FC14D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void ___ZN19URLConnectionClient13terminalEventEPKcU13block_pointerFvU13block_pointerFvvEE_block_invoke(uint64_t a1)
{
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 192))(*(_QWORD *)(a1 + 32));
  CFRelease((CFTypeRef)(*(_QWORD *)(a1 + 32) - 16));
}

void ___ZN17HTTPCookieStorage25syncStorageWithCompletionEhU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  *(CFAbsoluteTime *)(v2 + 48) = CFAbsoluteTimeGetCurrent();
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
    (*(void (**)(void))(v3 + 16))();
  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN17HTTPCookieStorage20copyCookiesForDomainEPK10__CFString_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN17HTTP2StreamBridge5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "HTTP2StreamBridge");
  HTTP2StreamBridge::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FC15B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTP3Connection35_newClientBidirectionalStreamHandleEPKc_block_invoke()
{
  uint64_t stream_options;
  void *v1;

  stream_options = nw_quic_create_stream_options();
  v1 = (void *)HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::options;
  HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::options = stream_options;

  return nw_quic_stream_set_is_unidirectional();
}

void ___ZN15HTTP2Connection5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "HTTP2Connection");
  HTTP2Connection::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FC1650(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN13URLCredential5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  CFClass::CFClass(v0, "CFURLCredential");
  URLCredential::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_183FC16BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t ___ZN13HTTPUtilities15isHeaderAllowedEPK10__CFString_block_invoke()
{
  uint64_t result;

  result = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E60]), "initWithObjects:", 0x1EDCFCDA0, 0x1EDCFD190, 0x1EDCFD430, 0x1EDCFD778, 0x1EDCFD0B0, 0);
  HTTPUtilities::isHeaderAllowed(__CFString const*)::disallowed = result;
  return result;
}

uint64_t ___ZN12XTubeManager38invalidateUnpurgeableConnectionsForKeyEP22HTTPConnectionCacheKey_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, uint64_t);
  void *v15;
  uint64_t v16;

  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  v4 = *(_QWORD *)(v3 + 32);
  v5 = MEMORY[0x1E0C809B0];
  if (v4)
  {
    v6 = 0;
    v12 = MEMORY[0x1E0C809B0];
    v13 = 3221225472;
    v14 = ___ZN11TubeManager38invalidateUnpurgeableConnectionsForKeyEPK22HTTPConnectionCacheKey_block_invoke;
    v15 = &__block_descriptor_40_e51_v16__0__MetaConnectionCache________CFAllocator_i__8l;
    v16 = v2;
    v7 = v4 + 80;
    do
    {
      if (*(_QWORD *)(v7 + v6))
        ((void (*)(uint64_t *))v14)(&v12);
      v6 += 8;
    }
    while (v6 != 24);
  }
  v8 = *(_QWORD *)(v3 + 40);
  if (v8)
  {
    v9 = 0;
    v12 = v5;
    v13 = 3221225472;
    v14 = ___ZN12STubeManager38invalidateUnpurgeableConnectionsForKeyEPK22HTTPConnectionCacheKey_block_invoke;
    v15 = &__block_descriptor_40_e51_v16__0__MetaConnectionCache________CFAllocator_i__8l;
    v16 = v2;
    v10 = v8 + 80;
    do
    {
      if (*(_QWORD *)(v10 + v9))
        ((void (*)(uint64_t *))v14)(&v12);
      v9 += 8;
    }
    while (v9 != 24);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 48))(*(_QWORD *)(a1 + 40));
}

CFTypeRef ___ZN12SocketStream4openEPKvP13CFStreamErrorPh_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2;
  CFTypeRef result;

  v2 = *(_QWORD *)(a1 + 32);
  if (cf)
    result = CFRetain(cf);
  else
    result = 0;
  *(_QWORD *)(v2 + 240) = result;
  return result;
}

CFSetRef ___ZN12SocketStream20observablePropertiesEv_block_invoke()
{
  CFSetRef result;

  if ((_ZGVZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable & 1) == 0)
  {
    _ZZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable = 0x1EDCF96B8;
    _ZGVZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable = 1;
  }
  result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&_ZZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable, 1, MEMORY[0x1E0C9B3B0]);
  SocketStream::observableProperties(void)::observableProps = (uint64_t)result;
  return result;
}

void ___ZN12SocketStream18startTCPConnectionEh_block_invoke(uint64_t a1, int a2)
{
  uint64_t v3;
  int v4;
  CFStreamError v5;
  SocketStream *v6;
  const __CFAllocator *v7;
  __CFDictionary *Mutable;
  char *v9;
  char *v10;
  uint64_t i;
  uint64_t j;
  const __CFAllocator *v13;
  CFNumberRef v14;
  NSObject *v15;
  uint64_t v16;
  int error;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  CFTypeRef v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t is_viable;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t unmet_reason;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  CFTypeRef v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE cf[12];
  __int16 v49;
  _BYTE v50[10];
  int v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 40));
  v4 = *(_DWORD *)(v3 + 248);
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 40));
  if ((v4 & 0x1000) == 0)
  {
    switch(a2)
    {
      case 1073741825:
        if (*(_QWORD *)(v3 + 464) || *(_QWORD *)(v3 + 472))
        {
          *(_QWORD *)cf = 0;
          v45 = 0;
          SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v45);
          v18 = *(_QWORD *)(v3 + 464);
          if (v18)
            v19 = *(_QWORD *)cf == 0;
          else
            v19 = 1;
          if (!v19)
            (*(void (**)(void))(v18 + 16))();
          v20 = *(_QWORD *)(v3 + 472);
          if (v20 && v45)
            (*(void (**)(void))(v20 + 16))();
          if (*(_QWORD *)cf)
            CFRelease(*(CFTypeRef *)cf);
          v21 = v45;
          if (v45)
            goto LABEL_107;
        }
        break;
      case 1073741826:
        if (*(_QWORD *)(v3 + 448) || *(_QWORD *)(v3 + 456))
        {
          v22 = tcp_connection_conditions_met();
          *(_QWORD *)cf = 0;
          v45 = 0;
          SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v45);
          v23 = *(_QWORD *)(v3 + 448);
          if (v23)
            v24 = *(_QWORD *)cf == 0;
          else
            v24 = 1;
          if (!v24)
            (*(void (**)(void))(v23 + 16))();
          v25 = *(_QWORD *)(v3 + 456);
          if (v25 && v45)
            (*(void (**)(uint64_t, CFTypeRef, uint64_t))(v25 + 16))(v25, v45, v22);
          if (*(_QWORD *)cf)
            CFRelease(*(CFTypeRef *)cf);
          v21 = v45;
          if (v45)
            goto LABEL_107;
        }
        break;
      case 1073741827:
      case 1073741831:
        return;
      case 1073741828:
      case 1073741829:
        if (a2 == 1073741828)
          *(_QWORD *)&v5.error = 4294965195;
        else
          *(_QWORD *)&v5.error = 4294965196;
        v6 = (SocketStream *)v3;
        v5.domain = 4;
        goto LABEL_68;
      case 1073741830:
        if (*(_QWORD *)(v3 + 480) || *(_QWORD *)(v3 + 488))
        {
          *(_QWORD *)cf = 0;
          v45 = 0;
          SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v45);
          v26 = *(_QWORD *)(v3 + 480);
          if (v26)
            v27 = *(_QWORD *)cf == 0;
          else
            v27 = 1;
          if (!v27)
            (*(void (**)(void))(v26 + 16))();
          v28 = *(_QWORD *)(v3 + 488);
          if (v28 && v45)
            (*(void (**)(void))(v28 + 16))();
          if (*(_QWORD *)cf)
            CFRelease(*(CFTypeRef *)cf);
          v21 = v45;
          if (v45)
LABEL_107:
            CFRelease(v21);
        }
        break;
      case 1073741832:
        v6 = (SocketStream *)v3;
        v5.domain = 4;
        *(_QWORD *)&v5.error = 4294965190;
LABEL_68:
        SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(v6, v5);
        break;
      case 1073741833:
        if (tcp_connection_get_connection_quality() == 1)
        {
          v30 = *(_DWORD *)(v3 + 248);
          v29 = v3 + 248;
          v31 = v30 | ((unint64_t)*(unsigned __int16 *)(v29 + 4) << 32) | 0x200000000;
          *(_DWORD *)v29 = v30;
          *(_WORD *)(v29 + 4) = WORD2(v31);
        }
        break;
      default:
        switch(a2)
        {
          case 1:
            v45 = 0;
            v46 = 0;
            v47 = 0;
            if (*(_QWORD *)(v3 + 560)
              && tcp_connection_get_statistics()
              && ((*(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32)) & 0x20000000000) != 0)
            {
              v7 = CFGetAllocator((CFTypeRef)(v3 - 16));
              Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              *(_QWORD *)cf = CFSTR("_kCFStreamStatsDNS_ResolutionTimeMs");
              *(_DWORD *)&cf[8] = (_DWORD)v45;
              *(_QWORD *)&v50[2] = CFSTR("_kCFStreamStatsConnectionEstablishmentTimeMs");
              v51 = v46;
              v9 = (char *)operator new(0x20uLL);
              v10 = v9;
              for (i = 0; i != 32; i += 16)
                *(_OWORD *)&v9[i] = *(_OWORD *)&cf[i];
              for (j = 0; j != 32; j += 16)
              {
                v13 = CFGetAllocator((CFTypeRef)(v3 - 16));
                v14 = CFNumberCreate(v13, kCFNumberSInt32Type, &v10[j + 8]);
                CFDictionaryAddValue(Mutable, *(const void **)&v10[j], v14);
                if (v14)
                  CFRelease(v14);
              }
              operator delete(v10);
              (*(void (**)(uint64_t, uint64_t, __CFDictionary *))(*(_QWORD *)v3 + 200))(v3, 0x1EDCFA288, Mutable);
              if (Mutable)
                CFRelease(Mutable);
            }
            goto LABEL_19;
          case 3:
LABEL_19:
            SocketStream::cancelSIMScheduler((SocketStream *)v3);
            if (*(_BYTE *)(v3 + 544))
            {
              if (CFNLog::onceToken != -1)
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
              v15 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                v16 = *(_QWORD *)(v3 + 560);
                if (v16)
                  error = tcp_connection_get_error();
                else
                  error = 0;
                *(_DWORD *)cf = 134218496;
                *(_QWORD *)&cf[4] = v16;
                v49 = 1024;
                *(_DWORD *)v50 = a2;
                *(_WORD *)&v50[4] = 1024;
                *(_DWORD *)&v50[6] = error;
                _os_log_impl(&dword_183ECA000, v15, OS_LOG_TYPE_DEFAULT, "TCP Conn %p event %d. err: %d", cf, 0x18u);
              }
              SocketStream::_onqueue_completeTCPConnection((SocketStream *)v3);
            }
            break;
          case 5:
            v32 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_69, 2);
            if (v32)
            {
              v33 = v32;
              if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v32 + 16))(v32, "better route detected", 0))
              {
                diagnosticLogTCPConnectionInfo(v33, *(_QWORD *)(v3 + 560));
                (*(void (**)(uint64_t))(*(_QWORD *)v33 + 8))(v33);
              }
            }
            v34 = *(_QWORD *)(v3 + 512);
            if (v34)
              (*(void (**)(void))(v34 + 16))();
            SocketStream::terminateConnectionIfAppropriate((SocketStream *)v3, 1);
            break;
          case 6:
            is_viable = tcp_connection_is_viable();
            v36 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_62, 2);
            if (v36)
            {
              v37 = v36;
              if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v36 + 16))(v36, "Connection viability changed", 0))
              {
                diagnosticLogTCPConnectionInfo(v37, *(_QWORD *)(v3 + 560));
                (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v37 + 72))(v37, "viable", CFSTR("%s"));
                (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
              }
            }
            if (*(_QWORD *)(v3 + 496) || *(_QWORD *)(v3 + 504))
            {
              *(_QWORD *)cf = 0;
              v45 = 0;
              SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v45);
              v38 = *(_QWORD *)(v3 + 496);
              if (v38 && *(_QWORD *)cf)
                (*(void (**)(uint64_t, _QWORD, uint64_t))(v38 + 16))(v38, *(_QWORD *)cf, is_viable);
              v39 = *(_QWORD *)(v3 + 504);
              if (v39 && v45)
                (*(void (**)(uint64_t, CFTypeRef, uint64_t))(v39 + 16))(v39, v45, is_viable);
              if (*(_QWORD *)cf)
                CFRelease(*(CFTypeRef *)cf);
              if (v45)
                CFRelease(v45);
            }
            if ((is_viable & 1) == 0)
              SocketStream::terminateConnectionIfAppropriate((SocketStream *)v3, 0);
            break;
          case 7:
            unmet_reason = tcp_connection_conditions_get_unmet_reason();
            v41 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 184))(v3);
            if (v41)
            {
              v42 = v41;
              (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v41 + 72))(v41, unmet_reason);
              (*(void (**)(uint64_t))(*(_QWORD *)v42 + 24))(v42);
            }
            if (*(_QWORD *)(v3 + 432) || *(_QWORD *)(v3 + 440))
            {
              *(_QWORD *)cf = 0;
              v45 = 0;
              SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v45);
              v43 = *(_QWORD *)(v3 + 432);
              if (v43 && *(_QWORD *)cf)
                (*(void (**)(uint64_t, _QWORD, uint64_t))(v43 + 16))(v43, *(_QWORD *)cf, unmet_reason);
              v44 = *(_QWORD *)(v3 + 440);
              if (v44 && v45)
                (*(void (**)(uint64_t, CFTypeRef, uint64_t))(v44 + 16))(v44, v45, unmet_reason);
              if (*(_QWORD *)cf)
                CFRelease(*(CFTypeRef *)cf);
              v21 = v45;
              if (v45)
                goto LABEL_107;
            }
            break;
          default:
            return;
        }
        break;
    }
  }
}

void sub_183FC207C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_9(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  CFIndex v3;
  const __CFString *v4;
  const __CFAllocator *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(int *)(a1 + 48);
  v3 = -1004;
  v4 = CFSTR("kCFErrorDomainCFNetwork");
  if (v2 > 31)
  {
    switch(*(_DWORD *)(a1 + 48))
    {
      case '1':
      case '3':
      case ';':
      case '=':
      case '@':
      case 'A':
        goto LABEL_21;
      case '2':
LABEL_3:
        v3 = -1009;
        goto LABEL_21;
      case '4':
      case '7':
      case '8':
      case ':':
      case '>':
      case '?':
        goto LABEL_20;
      case '5':
      case '6':
      case '9':
        goto LABEL_10;
      case '<':
LABEL_12:
        v3 = -1001;
        goto LABEL_21;
      default:
        if (v2 == 89)
        {
LABEL_18:
          v3 = -999;
          goto LABEL_21;
        }
        if (v2 != 32)
          goto LABEL_20;
LABEL_10:
        if ((*(_DWORD *)(v1 + 192) & 2) == 0)
        {
          switch(*(_DWORD *)(a1 + 48))
          {
            case '1':
            case '3':
            case ';':
            case '=':
            case '@':
            case 'A':
              goto LABEL_21;
            case '2':
              goto LABEL_3;
            case '4':
            case '7':
            case '8':
            case ':':
            case '>':
            case '?':
              goto LABEL_20;
            case '5':
            case '6':
            case '9':
              goto LABEL_19;
            case '<':
              goto LABEL_12;
            default:
              if (v2 == 32)
                goto LABEL_19;
              if (v2 == 89)
                goto LABEL_18;
              goto LABEL_20;
          }
        }
        break;
    }
    goto LABEL_19;
  }
  if (v2 > 12)
  {
    if (v2 != 13)
    {
      if (v2 != 22)
        goto LABEL_20;
      v3 = -1000;
    }
  }
  else if (v2 != -1)
  {
    if (v2 == 9)
    {
LABEL_19:
      v3 = -1005;
      goto LABEL_21;
    }
LABEL_20:
    v4 = (const __CFString *)*MEMORY[0x1E0C9AFD0];
    v3 = *(int *)(a1 + 48);
  }
LABEL_21:
  v5 = CFGetAllocator((CFTypeRef)(v1 - 16));
  return __cfnCreateCFError(v5, v4, v3, v6, v7, v8, v9, v10, 0);
}

dispatch_queue_t ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke()
{
  NSObject *v0;
  dispatch_queue_t result;

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  result = dispatch_queue_create("com.apple.CFNetwork.Async.SCNetworkReachability", v0);
  HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::q = (uint64_t)result;
  return result;
}

uint64_t ___ZN11TubeManager38invalidateUnpurgeableConnectionsForKeyEPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 128))(a2, *(_QWORD *)(a1 + 32));
}

void ___ZN10HSTSPolicy16getDefaultPolicyEv_block_invoke()
{
  uint64_t v0;
  _QWORD *Instance;
  _QWORD *v2;
  CFTypeRef v3;
  CFTypeRef cf;

  v0 = *MEMORY[0x1E0C9AE00];
  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  v2 = Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    v2 = Instance + 2;
    Instance[4] = 0;
  }
  if (HSTSCache::defaultStoreURL(void)::once != -1)
    dispatch_once(&HSTSCache::defaultStoreURL(void)::once, &__block_literal_global_7_14747);
  v3 = (CFTypeRef)HSTSCache::defaultStoreURL(void)::cacheFileURL;
  if (HSTSCache::defaultStoreURL(void)::cacheFileURL)
    v3 = CFRetain((CFTypeRef)HSTSCache::defaultStoreURL(void)::cacheFileURL);
  cf = v3;
  HSTSPolicy::HSTSPolicy(v2, v0, 1, (uint64_t *)&cf);
  HSTSPolicy::getDefaultPolicy(void)::sHSTSPolicy = (uint64_t)v2;
  if (cf)
    CFRelease(cf);
}

void sub_183FC233C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL35isIMRemoteURLConnectionAgentProcessv_block_invoke()
{
  const char **v0;
  uint64_t result;

  v0 = (const char **)_CFGetProgname();
  result = strcmp(*v0, "IMRemoteURLConnectionAgent");
  isIMRemoteURLConnectionAgentProcess(void)::isIMRemoteURLConnectionAgent = (_DWORD)result == 0;
  return result;
}

void ___ZL35__CFURLCacheCreateForStorageSessionPK13__CFAllocatorllPK10__CFStringhS4_hh_block_invoke()
{
  uint64_t started;
  uint64_t v1;
  const __CFAllocator *v2;
  size_t v3;
  const __CFURL *v4;
  const __CFURL *v5;
  const __CFURL *v6;
  char __s[1024];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  started = sysdir_start_search_path_enumeration_private();
  if ((_DWORD)started)
  {
    v1 = started;
    bzero(__s, 0x400uLL);
    MEMORY[0x186DB96D0](v1, __s);
    v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v3 = strlen(__s);
    v4 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)__s, v3, 1u);
    if (v4)
    {
      v5 = v4;
      v6 = CFURLCreateCopyAppendingPathComponent(v2, v4, CFSTR("Caches"), 1u);
      CFRelease(v5);
      if (v6)
      {
        __CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::sharedCachesDirectory = (uint64_t)CFURLCreateCopyAppendingPathComponent(v2, v6, CFSTR("sharedCaches"), 1u);
        CFRelease(v6);
      }
    }
  }
}

uint64_t ___ZL34_NSURLConnectionDidReceiveResponseP16_CFURLConnectionP14_CFURLResponsePKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "connection:didReceiveResponse:", a2, +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:", *(_QWORD *)(a1 + 32)));
}

uint64_t ___ZL32_NSURLConnectionDidFinishLoadingP16_CFURLConnectionPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "connectionDidFinishLoading:", a2);
}

void ___ZL27additionalPropertiesClassesv_block_invoke()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  v0 = (void *)MEMORY[0x1E0C99E60];
  v1 = objc_opt_class();
  v2 = objc_opt_class();
  v3 = objc_opt_class();
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, v7, v8, v9, objc_opt_class(), 0);
  v10 = objc_claimAutoreleasedReturnValue();
  v11 = (void *)additionalPropertiesClasses(void)::additionalPropertiesClasses;
  additionalPropertiesClasses(void)::additionalPropertiesClasses = v10;

}

dispatch_queue_t ___ZL26copyGlobalTCPConnWorkQueuev_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("shared_tcpConnWorkQueue", 0);
  copyGlobalTCPConnWorkQueue(void)::sTCPConnWorkQueue = (uint64_t)result;
  return result;
}

void ___ZL25ConnectionProtocolConnectP11nw_protocolS0__block_invoke_2(uint64_t a1, void *a2, char a3)
{
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[5];
  std::__shared_weak_count *v16;
  _QWORD v17[5];

  if (a2 && (a3 & 1) == 0)
  {
    v5 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 32) + 216))(*(_QWORD *)(a1 + 32), 0x1EDCF93E0);
    v6 = *(void **)(a1 + 48);
    v7 = *(_QWORD *)(a1 + 56);
    v8 = MEMORY[0x1E0C809B0];
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3321888768;
    v15[2] = ___ZL25ConnectionProtocolConnectP11nw_protocolS0__block_invoke_3;
    v15[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE_e66_v40__0____CFString__8____CFArray__16____CFData__24____CFString__32l;
    v9 = *(std::__shared_weak_count **)(a1 + 40);
    v15[4] = *(_QWORD *)(a1 + 32);
    v16 = v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    v17[0] = v8;
    v17[1] = 3221225472;
    v17[2] = ___ZN18H2CoalescingEngine29findCoalescingConnectionEntryEP14__CFDictionaryPKS0_PK10__CFStringPK9__CFArrayU13block_pointerFvS6_S9_PK8__CFDataS6_E_block_invoke;
    v17[3] = &unk_1E14FD470;
    v17[4] = v15;
    __NSURLSession_CoalescingGetCoalescingCCEntryHostWithDNSRecord(v6, v7, a2, v5, 1, (uint64_t)v17);
    v12 = v16;
    if (v16)
    {
      v13 = (unint64_t *)&v16->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    if (v5)
      CFRelease(v5);
  }
}

void sub_183FC273C(_Unwind_Exception *a1)
{
  const void *v1;
  uint64_t v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

void ___ZL25ConnectionProtocolConnectP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD v11[5];
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;

  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3321888768;
  v11[2] = ___ZL25ConnectionProtocolConnectP11nw_protocolS0__block_invoke_2;
  v11[3] = &__block_descriptor_64_e8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE_e24_v20__0____CFString__8B16l;
  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(std::__shared_weak_count **)(a1 + 40);
  v11[4] = v4;
  v12 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v13 = a2;
  v14 = a3;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 344))(v4, v11);
  v8 = v12;
  if (v12)
  {
    v9 = (unint64_t *)&v12->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_183FC2830(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZL20CFN_LOG_h3connectionv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.cfnetwork", "h3connection");
  v1 = (void *)CFN_LOG_h3connection(void)::log;
  CFN_LOG_h3connection(void)::log = (uint64_t)v0;

}

id ___ZL18withHostsSPILockedU13block_pointerFvP12NSMutableSetP19NSMutableDictionaryE_block_invoke()
{
  id result;

  withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::allowAnyHTTPCertificateHostSet = (uint64_t)objc_alloc_init(MEMORY[0x1E0C99E20]);
  withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::allowSpecificHTTPCertificateHostDict = (uint64_t)objc_alloc_init(MEMORY[0x1E0C99E08]);
  result = objc_alloc_init(MEMORY[0x1E0DE7910]);
  withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::gSyncObject = (uint64_t)result;
  return result;
}

void ___ZL18getDefaultATSStatev_block_invoke()
{
  const void *v0;
  const __CFAllocator *v1;
  __CFDictionary *Mutable;
  uint64_t i;
  __CFDictionary *v4;
  __CFDictionary *v5;
  _QWORD v6[2];
  uint64_t v7;
  const void *v8;
  _QWORD v9[40];

  v9[38] = *MEMORY[0x1E0C80C00];
  v6[0] = CFSTR("apple.com");
  v6[1] = CFSTR("TLSv1.2");
  v0 = (const void *)*MEMORY[0x1E0C9AE50];
  v7 = *MEMORY[0x1E0C9AE40];
  v8 = v0;
  v9[0] = v0;
  v9[2] = CFSTR("ls.apple.com");
  v9[3] = CFSTR("TLSv1.0");
  v9[4] = v7;
  v9[5] = v0;
  v9[6] = v0;
  v9[8] = CFSTR("gs.apple.com");
  v9[9] = CFSTR("TLSv1.0");
  v9[10] = v7;
  v9[11] = v0;
  v9[12] = v0;
  v9[14] = CFSTR("geo.apple.com");
  v9[15] = CFSTR("TLSv1.0");
  v9[16] = v7;
  v9[17] = v0;
  v9[18] = v0;
  v9[20] = CFSTR("is.autonavi.com");
  v9[21] = CFSTR("TLSv1.0");
  v9[22] = v7;
  v9[23] = v0;
  v9[24] = v0;
  v9[26] = CFSTR("apple-mapkit.com");
  v9[27] = CFSTR("TLSv1.0");
  v9[28] = v7;
  v9[29] = v0;
  v9[30] = v0;
  v9[32] = CFSTR("setup.icloud.com");
  v9[33] = CFSTR("TLSv1.2");
  v9[34] = v7;
  v9[35] = v0;
  v9[36] = v0;
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 7, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  for (i = 0; i != 42; i += 6)
  {
    v4 = CFDictionaryCreateMutable(v1, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(v4, CFSTR("NSExceptionMinimumTLSVersion"), (const void *)v6[i + 1]);
    CFDictionarySetValue(v4, CFSTR("NSExceptionAllowsInsecureHTTPLoads"), (const void *)v9[i - 1]);
    CFDictionarySetValue(v4, CFSTR("NSExceptionRequiresForwardSecrecy"), (const void *)v6[i + 2]);
    CFDictionarySetValue(v4, CFSTR("NSIncludesSubdomains"), (const void *)v9[i]);
    CFDictionarySetValue(v4, CFSTR("NSATSBuiltinOverride"), v0);
    CFDictionarySetValue(Mutable, (const void *)v6[i], v4);
    CFRelease(v4);
  }
  v5 = CFDictionaryCreateMutable(v1, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionaryAddValue(v5, CFSTR("NSExceptionDomains"), Mutable);
  CFRelease(Mutable);
  getDefaultATSState(void)::baseATSState = (uint64_t)CFDictionaryCreateCopy(v1, v5);
  CFRelease(v5);
}

uint64_t ___ZL16sessionCallbacksv_block_invoke()
{
  nghttp2_session_callbacks_new();
  nghttp2_session_callbacks_set_on_frame_recv_callback();
  nghttp2_session_callbacks_set_on_frame_recv_callback();
  nghttp2_session_callbacks_set_on_invalid_frame_recv_callback();
  nghttp2_session_callbacks_set_on_data_chunk_recv_callback();
  nghttp2_session_callbacks_set_before_frame_send_callback();
  nghttp2_session_callbacks_set_on_frame_send_callback();
  nghttp2_session_callbacks_set_on_frame_not_send_callback();
  nghttp2_session_callbacks_set_on_stream_close_callback();
  nghttp2_session_callbacks_set_on_begin_headers_callback();
  nghttp2_session_callbacks_set_on_header_callback();
  nghttp2_session_callbacks_set_on_invalid_header_callback();
  return nghttp2_session_callbacks_set_error_callback2();
}

void ___ZL16getSymptomHandlev_block_invoke(double a1)
{
  uint64_t v1;
  double v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  gotLoadHelper_x8__symptom_framework_init(a1);
  if (*(_QWORD *)(v1 + 304))
  {
    metricLog = (uint64_t)os_log_create("com.apple.symptomsd", "metricstream");
    if (configureLogQueue(void)::sInitLogQueue != -1)
      dispatch_once(&configureLogQueue(void)::sInitLogQueue, &__block_literal_global_26_17449);
    getSymptomHandle(void)::sSymptomReporter = symptom_framework_init_delayInitStub(v2);
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v3 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v4 = 134217984;
      v5 = getSymptomHandle(void)::sSymptomReporter;
      _os_log_debug_impl(&dword_183ECA000, v3, OS_LOG_TYPE_DEBUG, "Initialized symptom reporter %p", (uint8_t *)&v4, 0xCu);
    }
  }
}

void ___ZL16CFN_LOG_h3streamv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.cfnetwork", "h3stream");
  v1 = (void *)CFN_LOG_h3stream(void)::log;
  CFN_LOG_h3stream(void)::log = (uint64_t)v0;

}

dispatch_queue_t ___ZL15getMetricsQueuev_block_invoke()
{
  NSObject *v0;
  dispatch_queue_t result;

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  result = dispatch_queue_create("com.apple.cfnetwork.ats.metrics", v0);
  getMetricsQueue(void)::metricsQueue = (uint64_t)result;
  return result;
}

void ___ZL15_HSTSIsDisabledv_block_invoke()
{
  CFPropertyListRef v0;
  const void *v1;
  CFTypeID v2;
  BOOL v4;

  v0 = CFPreferencesCopyValue(CFSTR("com.apple.CFNetwork.HSTS.DisableHSTS"), (CFStringRef)*MEMORY[0x1E0C9B228], (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  if (v0)
  {
    v1 = v0;
    v2 = CFGetTypeID(v0);
    v4 = v2 == CFBooleanGetTypeID() && v1 == (const void *)*MEMORY[0x1E0C9AE50];
    _HSTSIsDisabled(void)::sHSTSIsDisabled = v4;
    CFRelease(v1);
  }
}

os_log_t ___ZL15H2CoalescingLogv_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.CFNetwork", "Coalescing");
  H2CoalescingLog(void)::onceLog = (uint64_t)result;
  return result;
}

void ___ZL13copyHostQueuev_block_invoke()
{
  char *v0;
  int v1;
  dispatch_queue_t global_queue;

  if (!(copyHostQueue(void)::gQueue | copyHostQueue(void)::gQueueCreate))
  {
    v0 = getenv("CFNETWORK_HOST_QUEUE_KIND");
    if (v0)
    {
      v1 = atoi(v0);
      if (v1 == 2)
      {
        global_queue = dispatch_queue_create("com.apple.DispatchHost-Shared", 0);
        goto LABEL_8;
      }
      if (v1 == 1)
      {
        copyHostQueue(void)::gQueueCreate = (uint64_t)MEMORY[0x1E0C82E48];
        return;
      }
    }
    global_queue = dispatch_get_global_queue(0, 0);
LABEL_8:
    copyHostQueue(void)::gQueue = (uint64_t)global_queue;
  }
}

uint64_t ___ZL12allowNewHTTPv_block_invoke()
{
  uint64_t result;
  const char *v1;
  BOOL v2;

  result = _CFGetProgname();
  if (result)
  {
    v1 = *(const char **)result;
    if (*(_QWORD *)result)
    {
      result = strncmp(*(const char **)result, "com.apple.WebKit", 0x10uLL);
      if ((_DWORD)result && (result = strcmp(v1, "MobileSafari"), (_DWORD)result))
      {
        result = strncmp(v1, "com.apple.Safari", 0x10uLL);
        v2 = (_DWORD)result == 0;
      }
      else
      {
        v2 = 1;
      }
      allowNewHTTP(void)::result = v2;
    }
  }
  return result;
}

uint64_t ___ZL11isSafariAppv_block_invoke()
{
  uint64_t result;
  const char *v1;
  BOOL v2;

  result = _CFGetProgname();
  if (result)
  {
    v1 = *(const char **)result;
    if (*(_QWORD *)result)
    {
      result = strcmp(*(const char **)result, "MobileSafari");
      if ((_DWORD)result && (result = strncmp(v1, "com.apple.Safari", 0x10uLL), (_DWORD)result))
      {
        result = strncmp(v1, "com.apple.WebKit.Networking", 0x1BuLL);
        v2 = (_DWORD)result == 0;
      }
      else
      {
        v2 = 1;
      }
      isSafariApp(void)::isSafariProcess = v2;
    }
  }
  return result;
}

CFStringRef ___ZL11getBundleIdv_block_invoke()
{
  CFStringRef result;

  getBundleId(void)::bundle = (uint64_t)CFBundleGetMainBundle();
  result = CFBundleGetIdentifier((CFBundleRef)getBundleId(void)::bundle);
  getBundleId(void)::bundleID = (uint64_t)result;
  return result;
}

void ___Z24_CFURLCacheCreateWithURLPK13__CFAllocatorllPK7__CFURL_block_invoke(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void sub_183FC31A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x1000C4000313F17);
  _Unwind_Resume(a1);
}

void __NSURLSession_CoalescingGetCoalescingCCEntryHostWithDNSRecord(void *a1, uint64_t a2, void *a3, void *a4, int a5, uint64_t a6)
{
  uint64_t v11;
  _QWORD *v12;
  NSObject *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  _OWORD *v18;
  __int128 v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  __int128 v29;
  int64x2_t v30;
  unint64_t v31;
  std::string *v32;
  std::__shared_weak_count *v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  const char *v38;
  CFStringRef v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  void *v45;
  _QWORD *v46;
  std::__shared_weak_count *v47;
  void *__p[2];
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  int64x2_t v54;
  std::string *v55;
  std::__split_buffer<std::string> v56;
  uint8_t buf[4];
  void *v58;
  __int16 v59;
  _QWORD *v60;
  __int16 v61;
  void *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v11 = objc_msgSend(a1, "objectForKeyedSubscript:", a2);
  if (a5)
  {
    -[__CFN_CoalescingDomainHolder coalescingCoalescingConnectionHost:ipAddrs:](&v46, v11, a3, a4);
    v12 = v46;
    if (!v46)
      goto LABEL_55;
    if (H2CoalescingLog(void)::onceToken != -1)
      dispatch_once(&H2CoalescingLog(void)::onceToken, &__block_literal_global_6187);
    v13 = H2CoalescingLog(void)::onceLog;
    if (!os_log_type_enabled((os_log_t)H2CoalescingLog(void)::onceLog, OS_LOG_TYPE_DEBUG))
      goto LABEL_51;
    if (*((char *)v12 + 23) < 0)
      v12 = (_QWORD *)*v12;
    *(_DWORD *)buf = 138412802;
    v58 = a3;
    v59 = 2080;
    v60 = v12;
    v61 = 2048;
    v62 = a1;
    v14 = "possible mapping %@ -> %s config %p";
    goto LABEL_64;
  }
  v44 = v11;
  if (!v11)
  {
    v46 = 0;
    v47 = 0;
    goto LABEL_55;
  }
  v45 = a3;
  v54 = 0uLL;
  v55 = 0;
  v50 = 0u;
  v51 = 0u;
  v52 = 0u;
  v53 = 0u;
  v15 = objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v50, buf, 16);
  if (v15)
  {
    v16 = *(_QWORD *)v51;
    do
    {
      for (i = 0; i != v15; ++i)
      {
        if (*(_QWORD *)v51 != v16)
          objc_enumerationMutation(a4);
        std::string::basic_string[abi:nn180100]<0>(__p, (char *)objc_msgSend(*(id *)(*((_QWORD *)&v50 + 1) + 8 * i), "UTF8String"));
        v18 = (_OWORD *)v54.i64[1];
        if (v54.i64[1] >= (unint64_t)v55)
        {
          v20 = 0xAAAAAAAAAAAAAAABLL * ((v54.i64[1] - v54.i64[0]) >> 3);
          v21 = v20 + 1;
          if (v20 + 1 > 0xAAAAAAAAAAAAAAALL)
            abort();
          if (0x5555555555555556 * (((uint64_t)v55 - v54.i64[0]) >> 3) > v21)
            v21 = 0x5555555555555556 * (((uint64_t)v55 - v54.i64[0]) >> 3);
          if (0xAAAAAAAAAAAAAAABLL * (((uint64_t)v55 - v54.i64[0]) >> 3) >= 0x555555555555555)
            v22 = 0xAAAAAAAAAAAAAAALL;
          else
            v22 = v21;
          v56.__end_cap_.__value_ = (std::allocator<std::string> *)&v55;
          if (v22)
            v22 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v22);
          else
            v23 = 0;
          v24 = v22 + 24 * v20;
          v25 = *(_OWORD *)__p;
          *(_QWORD *)(v24 + 16) = v49;
          *(_OWORD *)v24 = v25;
          __p[1] = 0;
          v49 = 0;
          __p[0] = 0;
          v26 = v54.i64[1];
          v27 = v54.i64[0];
          if (v54.i64[1] == v54.i64[0])
          {
            v30 = vdupq_n_s64(v54.u64[1]);
            v28 = v22 + 24 * v20;
          }
          else
          {
            v28 = v22 + 24 * v20;
            do
            {
              v29 = *(_OWORD *)(v26 - 24);
              *(_QWORD *)(v28 - 8) = *(_QWORD *)(v26 - 8);
              *(_OWORD *)(v28 - 24) = v29;
              v28 -= 24;
              *(_QWORD *)(v26 - 16) = 0;
              *(_QWORD *)(v26 - 8) = 0;
              *(_QWORD *)(v26 - 24) = 0;
              v26 -= 24;
            }
            while (v26 != v27);
            v30 = v54;
          }
          v31 = v24 + 24;
          v54.i64[0] = v28;
          v54.i64[1] = v24 + 24;
          *(int64x2_t *)&v56.__begin_ = v30;
          v32 = v55;
          v55 = (std::string *)(v22 + 24 * v23);
          v56.__end_cap_.__value_ = v32;
          v56.__first_ = (std::__split_buffer<std::string>::pointer)v30.i64[0];
          std::__split_buffer<std::string>::~__split_buffer(&v56);
          v54.i64[1] = v31;
          if (SHIBYTE(v49) < 0)
            operator delete(__p[0]);
        }
        else
        {
          v19 = *(_OWORD *)__p;
          *(_QWORD *)(v54.i64[1] + 16) = v49;
          *v18 = v19;
          v54.i64[1] = (uint64_t)v18 + 24;
        }
      }
      v15 = objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v50, buf, 16);
    }
    while (v15);
  }
  std::string::basic_string[abi:nn180100]<0>(&v56, (char *)objc_msgSend(v45, "UTF8String"));
  if (v54.i64[0] == v54.i64[1])
    __assert_rtn("updateCoalescingConnectionKeyWithHostWithDNSRecord", "HTTP2CoalescingSupport.mm", 151, "!DNSRecordIPAddresses.empty()");
  CoalescingDomain::_find_coalescing_connection_key(&v46, v44 + 8, (uint64_t)&v56, v54.i64[0], (_QWORD *)v54.i64[1]);
  if (v46)
  {
    v33 = v47;
    __p[0] = v46;
    __p[1] = v47;
    if (v47)
    {
      p_shared_owners = (unint64_t *)&v47->__shared_owners_;
      do
        v35 = __ldxr(p_shared_owners);
      while (__stxr(v35 + 1, p_shared_owners));
    }
    CoalescingDomain::_update_internal_mappings((uint64_t **)(v44 + 8), (uint64_t *)__p, (uint64_t)&v56, (__int128 **)&v54);
    if (v33)
    {
      v36 = (unint64_t *)&v33->__shared_owners_;
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
  }
  if (SHIBYTE(v56.__end_) < 0)
    operator delete(v56.__first_);
  v56.__first_ = (std::__split_buffer<std::string>::pointer)&v54;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v56);
  if (v46)
  {
    if (H2CoalescingLog(void)::onceToken != -1)
      dispatch_once(&H2CoalescingLog(void)::onceToken, &__block_literal_global_6187);
    v13 = H2CoalescingLog(void)::onceLog;
    if (!os_log_type_enabled((os_log_t)H2CoalescingLog(void)::onceLog, OS_LOG_TYPE_DEBUG))
      goto LABEL_51;
    v43 = v46;
    if (*((char *)v46 + 23) < 0)
      v43 = (_QWORD *)*v46;
    *(_DWORD *)buf = 138412802;
    v58 = v45;
    v59 = 2080;
    v60 = v43;
    v61 = 2048;
    v62 = a1;
    v14 = "updated mapping %@ -> %s config %p";
LABEL_64:
    _os_log_debug_impl(&dword_183ECA000, v13, OS_LOG_TYPE_DEBUG, v14, buf, 0x20u);
LABEL_51:
    v38 = (const char *)v46;
    if (*((char *)v46 + 23) < 0)
      v38 = (const char *)*v46;
    v39 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v38, 0);
    (*(void (**)(uint64_t, CFStringRef, _QWORD, _QWORD, _QWORD))(a6 + 16))(a6, v39, v46[3], v46[4], v46[5]);
    if (v39)
      CFRelease(v39);
  }
LABEL_55:
  v40 = v47;
  if (v47)
  {
    v41 = (unint64_t *)&v47->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
}

void sub_183FC3718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,char *a42)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  if (a39 < 0)
    operator delete(__p);
  a42 = &a30;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&a42);
  _Unwind_Resume(a1);
}

void sub_183FC3B5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FC3C28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_183FC3D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_183FC40A4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  if (a2 == 1)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 48) + 8) + 40) = objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x183FC4034);
  }
  _Unwind_Resume(a1);
}

uint64_t `virtual thunk to'SocketStream::setProperty(SocketStream *this, const void *a2, const __CFString *a3, __CFString *a4)
{
  return SocketStream::setProperty((SocketStream *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 80)), a2, a3, a4);
}

uint64_t `non-virtual thunk to'ClassicURLConnection::loaderClientSupportsDispatchData(ClassicURLConnection *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 24))(*((_QWORD *)this + 2));
}

void `non-virtual thunk to'ClassicURLConnection::withLoaderClientAsync(uint64_t a1, uint64_t a2)
{
  ClassicURLConnection::withLoaderClientAsync(a1 - 8, a2);
}

void `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidReceiveChallenge(URLConnectionClient *this, _CFURLAuthChallenge *a2)
{
  URLConnectionClient::_loaderClientEvent_DidReceiveChallenge((URLConnectionClient *)((char *)this - 64), a2);
}

void `non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidReceiveResponse(URLConnectionClient *this, _CFURLResponse *a2)
{
  URLConnectionClient::_loaderClientEvent_DidReceiveResponse((URLConnectionClient *)((char *)this - 64), a2);
}

URLConnectionClient *`non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidFinishLoading(URLConnectionClient *this)
{
  return URLConnectionClient::_loaderClientEvent_DidFinishLoading((URLConnectionClient *)((char *)this - 64));
}

uint64_t `non-virtual thunk to'URLConnectionClient_Classic::_connectionClientInterface_UpdateScheduling(URLConnectionClient_Classic *this, const CoreSchedulingSet *a2)
{
  return URLConnectionClient_Classic::_connectionClientInterface_UpdateScheduling((URLConnectionClient_Classic *)((char *)this - 56), a2);
}

uint64_t `non-virtual thunk to'URLConnectionClient::_connectionClientInterface_cancelConnection(uint64_t a1, NSObject *a2, uint64_t a3)
{
  return URLConnectionClient::_connectionClientInterface_cancelConnection(a1 - 56, a2, a3);
}

uint64_t `non-virtual thunk to'URLConnectionClient::_connectionClientInterface_startConnection(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  _WORD *v3;

  if ((*(_WORD *)(this + 20) & 1) == 0)
  {
    v3 = (_WORD *)(this - 56);
    (*(void (**)(uint64_t, __CFRunLoop *, const __CFString *))(*(_QWORD *)(this - 56) + 296))(this - 56, a2, a3);
    v3[38] |= 1u;
    return (*(uint64_t (**)(_WORD *))(*(_QWORD *)v3 + 280))(v3);
  }
  return this;
}

uint64_t `non-virtual thunk to'URLConnectionClient::_connectionClientInterface_hasBegunLoading(URLConnectionClient *this)
{
  return *((_WORD *)this + 10) & 1;
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_willSendRequestForAuthenticationChallenge(URLConnectionClient_Classic *this, _CFURLAuthChallenge *a2)
{
  URLConnectionClient_Classic::_delegate_willSendRequestForAuthenticationChallenge((URLConnectionClient_Classic *)((char *)this - 48), a2);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_didReceiveResponse(URLConnectionClient_Classic *this, _CFURLResponse *a2)
{
  URLConnectionClient_Classic::_delegate_didReceiveResponse((URLConnectionClient_Classic *)((char *)this - 48), a2);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_didFinishLoading(uint64_t a1, void (*a2)(_QWORD, _QWORD, _QWORD))
{
  URLConnectionClient_Classic::_delegate_didFinishLoading(a1 - 48, a2);
}

void `non-virtual thunk to'URLConnectionClient_Classic::_delegate_willSendRequest(uint64_t a1, const void *a2, void *a3, uint64_t a4)
{
  URLConnectionClient_Classic::_delegate_willSendRequest((_QWORD *)(a1 - 48), a2, a3, a4);
}

uint64_t `non-virtual thunk to'URLConnectionLoader::_loaderInterface_setBytesPerSecondLimit(URLConnectionLoader *this, uint64_t a2)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN19URLConnectionLoader39_loaderInterface_setBytesPerSecondLimitEx_block_invoke;
  v3[3] = &__block_descriptor_40_e9_v16__0_v8l;
  v3[4] = a2;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)v3);
}

URLConnectionLoader *`non-virtual thunk to'URLConnectionLoader::_loaderEvent_SetProtocolIsDownload(URLConnectionLoader *this, char a2)
{
  _QWORD v2[4];
  char v3;

  if (!this->var17)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = ___ZN19URLConnectionLoader34_loaderEvent_SetProtocolIsDownloadEh_block_invoke;
    v2[3] = &__block_descriptor_33_e9_v16__0_v8l;
    v3 = a2;
    return (URLConnectionLoader *)URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)v2);
  }
  return this;
}

uint64_t `non-virtual thunk to'URLConnectionLoader::_loaderInterface_setPriorityHint(URLConnectionLoader *this, float a2, char a3)
{
  _QWORD v4[4];
  float v5;
  char v6;

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN19URLConnectionLoader32_loaderInterface_setPriorityHintEfb_block_invoke;
  v4[3] = &__block_descriptor_37_e9_v16__0_v8l;
  v5 = a2;
  v6 = a3;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)v4);
}

uint64_t `non-virtual thunk to'HTTPTransactionWrapper::copyTrust(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 136))(*((_QWORD *)this + 1));
}

uint64_t `non-virtual thunk to'HTTPProtocol::waitsForConnectivity(HTTPProtocol *this)
{
  void *v1;

  if (*((_QWORD *)this + 71) && (v1 = (void *)objc_msgSend(*((id *)this - 12), "_effectiveConfiguration")) != 0)
    return objc_msgSend(v1, "waitsForConnectivity");
  else
    return 0;
}

const CoreSchedulingSet *EmptyCoreSchedulingSet::copyWithUpdatesReleaseSelf(EmptyCoreSchedulingSet *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 40))(a2);
  (*(void (**)(EmptyCoreSchedulingSet *))(*(_QWORD *)this + 48))(this);
  return a2;
}

uint64_t URLConnectionClient::_loaderClient_SupportsDispatchData(URLConnectionClient *this)
{
  return 0;
}

void CoreSchedulingSet::applyBlockWithPossibleEmulation(uint64_t a1, void (**a2)(_QWORD, _QWORD, _QWORD))
{
  int v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_DWORD *)(a1 + 40);
  if ((v3 - 1) >= 2)
  {
    if (v3 == 3)
    {
      v4 = _coreSchedulingSet_RLM();
      a2[2](a2, v4, v5);
    }
  }
  else
  {
    CoreSchedulingSet::applyBlock(a1, a2);
  }
}

CFTypeRef StorageSession::copyCookieStorage(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  const __CFDictionary *v3;
  const void *Value;
  CFTypeRef v5;
  const __CFDictionary *v6;
  const void *v7;
  const void *v8;
  uint64_t *v9;
  uint64_t v10;
  const __CFAllocator *v11;
  __CFDictionary *MutableDictionary;
  NSHTTPCookieStorage *v13;
  const __CFAllocator *v14;
  const __CFDictionary *v15;
  int v16;
  const __CFAllocator *v17;
  const void *v18;

  v2 = this + 12;
  os_unfair_lock_lock(this + 12);
  if (BYTE1(this[13]._os_unfair_lock_opaque))
    goto LABEL_30;
  BYTE1(this[13]._os_unfair_lock_opaque) = 1;
  if (*(_QWORD *)&this[6]._os_unfair_lock_opaque || LOBYTE(this[14]._os_unfair_lock_opaque))
    goto LABEL_30;
  v3 = *(const __CFDictionary **)&this[20]._os_unfair_lock_opaque;
  if (!v3)
  {
    v5 = 0;
LABEL_11:
    v7 = *(const void **)&this[18]._os_unfair_lock_opaque;
    if (v7)
      v8 = CFRetain(v7);
    else
      v8 = 0;
    v9 = (uint64_t *)MEMORY[0x1E0C9AE50];
    goto LABEL_15;
  }
  Value = CFDictionaryGetValue(v3, CFSTR("kCFURLStorageSessionAppIdentifier"));
  if (Value)
    v5 = CFRetain(Value);
  else
    v5 = 0;
  v6 = *(const __CFDictionary **)&this[20]._os_unfair_lock_opaque;
  if (!v6 || CFDictionaryGetValue(v6, CFSTR("kCFURLStorageSessionIsPrivate")) != (const void *)*MEMORY[0x1E0C9AE50])
    goto LABEL_11;
  v17 = CFGetAllocator(&this[-4]);
  v8 = CFStringCreateWithFormat(v17, 0, CFSTR("%@-%ld"), *(_QWORD *)&this[18]._os_unfair_lock_opaque, *(_QWORD *)&this[16]._os_unfair_lock_opaque);
  v9 = (uint64_t *)MEMORY[0x1E0C9AE40];
LABEL_15:
  v10 = *v9;
  v11 = CFGetAllocator(&this[-4]);
  MutableDictionary = cfTypeCreateMutableDictionary(v11, CFSTR("ident"), v8, CFSTR("persistent"), v10, CFSTR("url"), v5, 0, 0);
  if (v5)
    CFRelease(v5);
  if (v8)
    CFRelease(v8);
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (newCookieStorageEnabled(void)::enabled)
  {
    v13 = +[NSHTTPCookieStorage sharedHTTPCookieStorage](NSHTTPCookieStorageToCookie2Storage, "sharedHTTPCookieStorage");
  }
  else
  {
    v14 = CFGetAllocator(&this[-4]);
    v15 = *(const __CFDictionary **)&this[20]._os_unfair_lock_opaque;
    v16 = v15
       && CFDictionaryGetValue(v15, CFSTR("kCFURLStorageSessionProcessSharing")) == (const void *)*MEMORY[0x1E0C9AE50]
       || LOBYTE(this[14]._os_unfair_lock_opaque) != 0;
    v13 = (NSHTTPCookieStorage *)_CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(v14, MutableDictionary, v16);
  }
  *(_QWORD *)&this[6]._os_unfair_lock_opaque = v13;
  CFRelease(MutableDictionary);
LABEL_30:
  os_unfair_lock_unlock(v2);
  if (newCookieStorageEnabled(void)::onceToken != -1)
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1105);
  if (!newCookieStorageEnabled(void)::enabled && LOBYTE(this[14]._os_unfair_lock_opaque))
    return (CFTypeRef)CFHTTPCookieStorageCopySharedHTTPCookieStorage();
  v18 = *(const void **)&this[6]._os_unfair_lock_opaque;
  if (v18)
    return CFRetain(v18);
  else
    return 0;
}

CFTypeRef StorageSession::copyCacheStorage(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  const __CFDictionary *v3;
  const __CFString *v4;
  _BOOL4 v5;
  const __CFAllocator *v6;
  const __CFString *v7;
  uint64_t v8;
  const __CFURL *v9;
  const __CFURL *v10;
  const __CFString *v11;
  uint64_t Instance;
  _QWORD *v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  CFTypeRef result;
  const __CFString *v18;
  CFBooleanRef BOOLean;
  CFBooleanRef v20;
  void *value;
  _QWORD *block;
  uint64_t block_8;
  uint64_t (*v24)(uint64_t);
  void *v25;
  uint64_t (*v26)(void);

  v2 = this + 12;
  os_unfair_lock_lock(this + 12);
  if (!LOBYTE(this[13]._os_unfair_lock_opaque))
  {
    LOBYTE(this[13]._os_unfair_lock_opaque) = 1;
    if (!*(_QWORD *)&this[4]._os_unfair_lock_opaque && !LOBYTE(this[14]._os_unfair_lock_opaque))
    {
      CFGetAllocator(&this[-4]);
      v4 = *(const __CFString **)&this[18]._os_unfair_lock_opaque;
      v3 = *(const __CFDictionary **)&this[20]._os_unfair_lock_opaque;
      v20 = 0;
      value = 0;
      v18 = 0;
      BOOLean = 0;
      v5 = v3
        && ((CFDictionaryGetValueIfPresent(v3, CFSTR("kCFURLStorageSessionIsPrivate"), (const void **)&value),
             CFDictionaryGetValueIfPresent(v3, CFSTR("kCFURLStorageSessionIsDefault"), (const void **)&v20),
             CFDictionaryGetValueIfPresent(v3, CFSTR("kCFURLStorageSessionProcessSharing"), (const void **)&BOOLean),
             CFDictionaryGetValueIfPresent(v3, CFSTR("kCFURLStorageSessionAppIdentifier"), (const void **)&v18),
             !value)
          ? (LODWORD(v3) = 0)
          : (LODWORD(v3) = CFBooleanGetValue((CFBooleanRef)value)),
            BOOLean)
        && CFBooleanGetValue(BOOLean) == 1;
      v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v7 = v18;
      if (v20)
        CFBooleanGetValue(v20);
      if (!v7)
        v7 = v4;
      if ((_DWORD)v3)
        v8 = 0;
      else
        v8 = 20971520;
      if (v5)
      {
        if (__CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::onceToken != -1)
          dispatch_once(&__CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::onceToken, &__block_literal_global_2401);
        if (__CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::sharedCachesDirectory
          && (v9 = CFURLCreateCopyAppendingPathComponent(v6, (CFURLRef)__CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::sharedCachesDirectory, v7, 1u)) != 0&& (v10 = v9, v11 = CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle), CFRelease(v10), v11))
        {
          block = (_QWORD *)MEMORY[0x1E0C809B0];
          block_8 = 3221225472;
          v24 = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2382;
          v25 = &__block_descriptor_40_e5_v8__0l;
          v26 = _URLCacheRegisterClass;
          if (_CFURLCacheClassRegistration != -1)
            dispatch_once(&_CFURLCacheClassRegistration, &block);
          Instance = _CFRuntimeCreateInstance();
          *(_QWORD *)(Instance + 16) = 0;
          *(_QWORD *)(Instance + 24) = 0;
          v13 = operator new(0x298uLL);
          v13[1] = 0;
          v13[2] = 0;
          *v13 = &off_1E14F08A0;
          __CFURLCache::__CFURLCache((__CFURLCache *)(v13 + 3), (const _CFURLCache *)Instance, 0x400000, v8, v11, 0);
          block = v13 + 3;
          block_8 = (uint64_t)v13;
          std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&block, v13 + 4, (uint64_t)(v13 + 3));
          v14 = (std::__shared_weak_count *)block_8;
          std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(Instance + 16), (uint64_t)block, block_8);
          if (v14)
          {
            p_shared_owners = (unint64_t *)&v14->__shared_owners_;
            do
              v16 = __ldaxr(p_shared_owners);
            while (__stlxr(v16 - 1, p_shared_owners));
            if (!v16)
            {
              ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
              std::__shared_weak_count::__release_weak(v14);
            }
          }
          *(_BYTE *)(*(_QWORD *)(Instance + 16) + 528) = 1;
          CFRelease(v11);
        }
        else
        {
          Instance = 0;
        }
      }
      else
      {
        Instance = __CFURLCacheCreateInternal(v6, 0x400000, v8, v7, 0, 0, 0);
      }
      *(_QWORD *)&this[4]._os_unfair_lock_opaque = Instance;
    }
  }
  os_unfair_lock_unlock(v2);
  if (LOBYTE(this[14]._os_unfair_lock_opaque))
    return (CFTypeRef)CFURLCacheCopySharedURLCache();
  result = *(CFTypeRef *)&this[4]._os_unfair_lock_opaque;
  if (result)
    return CFRetain(result);
  return result;
}

void sub_183FC5C04(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t NSXURLCache::getResponseForTask(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  char isKindOfClass;
  void *v8;
  _QWORD v10[5];

  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZNK11NSXURLCache18getResponseForTaskEP16NSURLSessionTaskhU13block_pointerFvPK20_CFCachedURLResponseE_block_invoke;
  v10[3] = &unk_1E14FCFC8;
  v10[4] = a4;
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();
  v8 = *(void **)(a1 + 8);
  if ((isKindOfClass & 1) != 0)
    return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, objc_msgSend((id)objc_msgSend(v8, "cachedResponseForRequest:", objc_msgSend(a2, "currentRequest")), "_CFCachedURLResponse"));
  else
    return objc_msgSend(v8, "getCachedResponseForDataTask:completionHandler:", a2, v10);
}

void Tube::_onqueue_cancel(Tube *this)
{
  NSObject *v2;
  _QWORD block[5];

  if (*((_DWORD *)this + 55) != 10)
  {
    *((_DWORD *)this + 55) = 10;
    (*(void (**)(Tube *))(*(_QWORD *)this + 40))(this);
    v2 = *((_QWORD *)this + 20);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZN4Tube15_onqueue_cancelEv_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_async(v2, block);
  }
}

void Tube::clientCanceled(Tube *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *((_QWORD *)a1 + 14);
  if (v3)
  {
    if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 80))(v3) == a2)
      Tube::_onqueue_cancel(a1);
  }
}

CFAllocatedReferenceCountedObject *CFAllocatedReferenceCountedObject::_retainable_instance_retain(CFAllocatedReferenceCountedObject *this, const void *a2)
{
  (*(void (**)(CFAllocatedReferenceCountedObject *, const void *))(*(_QWORD *)this + 40))(this, a2);
  return this;
}

void URLCredentialInternetPassword::~URLCredentialInternetPassword(URLCredentialInternetPassword *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  *(_QWORD *)this = &off_1E14EECF8;
  *((_QWORD *)this + 1) = &unk_1E14EEDA0;
  *((_QWORD *)this + 3) = &unk_1E14EEDD0;
  v2 = (const void *)*((_QWORD *)this + 8);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 9);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 10);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 12);
  if (v5)
    CFRelease(v5);
  URLCredential::~URLCredential(this);
}

void sub_183FC5E48(_Unwind_Exception *a1)
{
  URLCredential *v1;

  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t URLCredentialInternetPassword::initialize(uint64_t a1, const __CFString *a2, const __CFString *a3, int a4, const __CFDictionary *a5)
{
  CFTypeID TypeID;
  CFTypeID v11;
  const __CFAllocator *v12;
  CFStringRef Copy;
  const __CFAllocator *v15;
  CFStringRef v16;
  const __CFAllocator *v17;
  CFDictionaryRef v18;

  if (a2)
  {
    TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(a2))
      return 0;
  }
  if (a3)
  {
    v11 = CFStringGetTypeID();
    if (v11 != CFGetTypeID(a3))
      return 0;
  }
  *(_DWORD *)(a1 + 36) = a4;
  if (a2)
  {
    v12 = CFGetAllocator((CFTypeRef)(a1 - 16));
    Copy = CFStringCreateCopy(v12, a2);
  }
  else
  {
    Copy = 0;
  }
  *(_QWORD *)(a1 + 64) = Copy;
  if (a3)
  {
    v15 = CFGetAllocator((CFTypeRef)(a1 - 16));
    v16 = CFStringCreateCopy(v15, a3);
  }
  else
  {
    v16 = 0;
  }
  *(_QWORD *)(a1 + 72) = v16;
  if (a5)
  {
    v17 = CFGetAllocator((CFTypeRef)(a1 - 16));
    v18 = CFDictionaryCreateCopy(v17, a5);
  }
  else
  {
    v18 = 0;
  }
  *(_QWORD *)(a1 + 80) = v18;
  *(_QWORD *)(a1 + 96) = 0;
  return 1;
}

void ProxyConnectionEstablishment::SetProxies(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  const char *v6;
  uint64_t (*v7)();
  NSObject *v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v5 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    v6 = "custom";
    v7 = (uint64_t (*)())MEMORY[0x1E0C86658];
  }
  else
  {
    if (ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::emptyProxyDictOnce != -1)
      dispatch_once(&ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::emptyProxyDictOnce, &__block_literal_global_12940);
    v5 = (void *)ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::emptyDict;
    v6 = "empty";
    v7 = ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::$_0::__invoke;
  }
  if (a1)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v8 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 134218498;
      v11 = tcp_connection_id();
      v12 = 2048;
      v13 = a1;
      v14 = 2080;
      v15 = v6;
      _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "TCP Conn [%llu:%p] using %s proxy configuration", (uint8_t *)&v10, 0x20u);
    }
    tcp_connection_set_proxies();
  }
  if (a2)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v9 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 136315138;
      v11 = (uint64_t)v6;
      _os_log_impl(&dword_183ECA000, v9, OS_LOG_TYPE_DEFAULT, "Parameters using %s proxy configuration", (uint8_t *)&v10, 0xCu);
    }
    if (v5)
    {
      if (MEMORY[0x186DB9C40](v5) == MEMORY[0x1E0C812F8] && !xpc_dictionary_get_count(v5))
        nw_parameters_set_no_proxy();
      else
        nw_parameters_set_proxy_configuration();
      goto LABEL_22;
    }
    nw_parameters_set_no_proxy();
    nw_parameters_set_proxy_configuration();
  }
  else if (v5)
  {
LABEL_22:
    ((void (*)(void *))v7)(v5);
  }
}

void sub_183FC619C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void (*v2)(uint64_t);

  if (v1)
    v2(v1);
  _Unwind_Resume(exception_object);
}

void URLConnectionClient_Classic::~URLConnectionClient_Classic(URLConnectionClient_Classic *this)
{
  uint8_t v2[16];

  *(_QWORD *)this = off_1E14EDED8;
  *((_QWORD *)this + 2) = &unk_1E14EE0B8;
  *((_QWORD *)this + 6) = &unk_1E14EE0D8;
  *((_QWORD *)this + 7) = &unk_1E14EE190;
  *((_QWORD *)this + 8) = &unk_1E14EE1E8;
  if (*((_QWORD *)this + 32) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "should've been invalidated", v2, 2u);
  }
  URLConnectionClient::~URLConnectionClient(this);
}

{
  uint64_t v2;

  URLConnectionClient_Classic::~URLConnectionClient_Classic(this);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 8), this);
}

void URLConnectionClient_Classic::_delegate_willSendRequestForAuthenticationChallenge(URLConnectionClient_Classic *this, _CFURLAuthChallenge *a2)
{
  uint64_t v4;
  void (*v5[6])(_QWORD, _QWORD, _QWORD);

  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(_QWORD *)this + 304))(this))
  {
    v4 = *((_QWORD *)this + 30);
    if (v4)
    {
      if (!*(_DWORD *)(v4 + 196))
      {
        if (a2)
          CFRetain(a2);
        v5[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
        v5[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
        v5[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic51_delegate_willSendRequestForAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke;
        v5[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_48_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
        v5[4] = (void (*)(_QWORD, _QWORD, _QWORD))this;
        v5[5] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_willSendRequestForAuthenticationChallenge", v5);
      }
    }
  }
}

uint64_t URLConnectionClient_Classic::_connectionClientInterface_UpdateScheduling(URLConnectionClient_Classic *this, const CoreSchedulingSet *a2)
{
  CoreSchedulingSet *v4;
  uint64_t Empty;
  uint64_t result;
  uint64_t v7;
  const __CFString *v8;
  char *v9;
  const __CFString *v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = (CoreSchedulingSet *)(*(uint64_t (**)(URLConnectionClient_Classic *))(*(_QWORD *)this + 80))(this);
  if ((_DWORD)v4)
  {
    v4 = (CoreSchedulingSet *)os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT);
    if ((_DWORD)v4)
    {
      v7 = *((_QWORD *)this + 27) - 16;
      v8 = (const __CFString *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 32) + 16))(*((_QWORD *)this + 32));
      v9 = _cfnAutoreleaseInDebug(v8);
      v10 = (const __CFString *)(*(uint64_t (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 16))(a2);
      v11 = 134218498;
      v12 = v7;
      v13 = 2080;
      v14 = v9;
      v15 = 2080;
      v16 = _cfnAutoreleaseInDebug(v10);
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "(1) Attempt to change scheduling of connection %p after its load has started [was %s, wants %s]!", (uint8_t *)&v11, 0x20u);
    }
  }
  Empty = *((_QWORD *)this + 32);
  if (!Empty)
  {
    Empty = CoreSchedulingSet::createEmpty(v4);
    *((_QWORD *)this + 32) = Empty;
  }
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
  result = (*(uint64_t (**)(uint64_t, const CoreSchedulingSet *, uint64_t))(*(_QWORD *)Empty + 72))(Empty, a2, CoreSchedulingSet::getEmptySet(void)::sEmptySet);
  *((_QWORD *)this + 32) = result;
  return result;
}

void URLConnectionClient_Classic::_internalEvent_WillSendRequest(URLConnectionClient_Classic *this)
{
  const void *v2;

  if (*((_BYTE *)this + 273))
  {
    URLConnectionClient::_internalEvent_WillSendRequestPartTwo((id *)this, *((NSURLRequest **)this + 35), *((_BYTE *)this + 274) != 1);
    *((_BYTE *)this + 273) = 0;
    v2 = (const void *)*((_QWORD *)this + 35);
    if (v2)
      CFRelease(v2);
    *((_QWORD *)this + 35) = 0;
  }
  else
  {
    URLConnectionClient::_internalEvent_WillSendRequest(this);
  }
}

_OWORD *URLConnectionClient_Classic::scheduleIfNotAlreadyScheduled(_OWORD *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  _OWORD *v3;

  if (!*((_QWORD *)this + 32))
  {
    v3 = this;
    this = CoreSchedulingSet::create(a2, cf1, cf1);
    *((_QWORD *)v3 + 32) = this;
  }
  return this;
}

void URLConnectionClient_Classic::_delegate_didReceiveResponse(URLConnectionClient_Classic *this, _CFURLResponse *a2)
{
  char v4;
  uint64_t v5;
  _CFURLResponse *v6;
  void (*v7[6])(_QWORD, _QWORD, _QWORD);
  uint8_t buf[16];

  v4 = *((_BYTE *)this + 80);
  if ((v4 & 2) != 0 && (*((_WORD *)this + 38) & 4) == 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "NSURLConnection ordering violation: didReceiveResponse to be scheduled after didReceiveData and not multipart/x-mixed-replace", buf, 2u);
    v4 = *((_BYTE *)this + 80);
  }
  *((_BYTE *)this + 80) = v4 | 1;
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(_QWORD *)this + 304))(this))
  {
    v5 = *((_QWORD *)this + 30);
    if (v5)
    {
      if (!*(_DWORD *)(v5 + 196))
      {
        if (*(_QWORD *)(v5 + 48))
        {
          v6 = a2;
          v7[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
          v7[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
          v7[2] = ___ZN27URLConnectionClient_Classic28_delegate_didReceiveResponseEP14_CFURLResponse_block_invoke;
          v7[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_48_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
          v7[4] = (void (*)(_QWORD, _QWORD, _QWORD))this;
          v7[5] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
          URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_didReceiveResponse", v7);
        }
      }
    }
  }
}

void URLConnectionClient_Classic::_delegate_didFinishLoading(uint64_t a1, void (*a2)(_QWORD, _QWORD, _QWORD))
{
  char v4;
  void (*v5)(_QWORD, _QWORD, _QWORD);
  void (*v6[5])(_QWORD, _QWORD, _QWORD);

  v4 = *(_BYTE *)(a1 + 80);
  if ((v4 & 1) == 0)
  {
    CFLog();
    v4 = *(_BYTE *)(a1 + 80);
  }
  v5 = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  *(_BYTE *)(a1 + 80) = v4 | 4;
  v6[0] = v5;
  v6[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
  v6[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN27URLConnectionClient_Classic26_delegate_didFinishLoadingEU13block_pointerFvvE_block_invoke;
  v6[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAAC8;
  v6[4] = a2;
  URLConnectionClient_Classic::_withDelegateAsync(a1, (uint64_t)"_delegate_didFinishLoading", v6);
}

void URLConnectionClient_Classic::_delegate_willSendRequest(_QWORD *a1, const void *a2, void *a3, uint64_t a4)
{
  uint64_t v8;
  id v9;
  void (*v10[7])(_QWORD, _QWORD, _QWORD);

  if ((*(unsigned int (**)(_QWORD *))(*a1 + 304))(a1)
    || (v8 = a1[30]) == 0
    || *(_DWORD *)(v8 + 196)
    || !*(_QWORD *)(v8 + 40))
  {
    (*(void (**)(uint64_t, const void *))(a4 + 16))(a4, a2);
  }
  else
  {
    if (a2)
      CFRetain(a2);
    v9 = a3;
    v10[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v10[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v10[2] = ___ZN27URLConnectionClient_Classic25_delegate_willSendRequestEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke;
    v10[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E14FAA58;
    v10[5] = (void (*)(_QWORD, _QWORD, _QWORD))a4;
    v10[6] = (void (*)(_QWORD, _QWORD, _QWORD))a3;
    v10[4] = (void (*)(_QWORD, _QWORD, _QWORD))a2;
    URLConnectionClient_Classic::_withDelegateAsync((uint64_t)a1, (uint64_t)"_delegate_willSendRequest", v10);
  }
}

void URLConnectionClient_Classic::invalidateAsync(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[6];
  std::__shared_weak_count *v14;
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3321888768;
  v13[2] = ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke;
  v13[3] = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  v5 = *a2;
  v4 = (std::__shared_weak_count *)a2[1];
  v13[4] = a1;
  v13[5] = v5;
  v14 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  v9 = *(NSObject **)(a1 + 40);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v13;
  block[5] = v8;
  dispatch_async(v9, block);
  v10 = v14;
  if (v14)
  {
    v11 = (unint64_t *)&v14->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_183FC6888(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void URLConnectionClient_Classic::setDelegate(uint64_t a1, _QWORD *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t (*v8)(void);
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  void (*v14)(void);
  uint8_t v15[16];

  v4 = (os_unfair_lock_s *)(a1 + 236);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 236));
  v5 = *(_QWORD *)(a1 + 240);
  *(_QWORD *)(a1 + 240) = 0;
  if (a2)
  {
    v6 = operator new();
    if (*a2 >= 0xAuLL && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v15 = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "update this", v15, 2u);
    }
    if ((((_BYTE)v6 - 64) & 3) != 0)
      __assert_rtn("ClassicDelegateHolder", "URLConnection.h", 102, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    v7 = ClassicDelegateHolder::ClassicDelegateHolder(CFURLConnectionClient_V1 const*)::kSizes[*a2];
    bzero((void *)(v6 + v7), 200 - v7);
    memcpy((void *)v6, a2, v7);
    if (*(_QWORD *)(v6 + 8))
    {
      v8 = *(uint64_t (**)(void))(v6 + 16);
      if (v8)
        *(_QWORD *)(v6 + 8) = v8();
    }
    *(_DWORD *)(v6 + 192) = 1;
    *(_QWORD *)(a1 + 240) = v6;
  }
  os_unfair_lock_unlock(v4);
  if (v5)
  {
    v9 = (unsigned int *)(v5 + 196);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 + 1, v9));
    v11 = (unsigned int *)(v5 + 192);
    do
    {
      v12 = __ldaxr(v11);
      v13 = v12 - 1;
    }
    while (__stlxr(v13, v11));
    if (!v13)
    {
      if (*(_QWORD *)(v5 + 8))
      {
        v14 = *(void (**)(void))(v5 + 24);
        if (v14)
          v14();
      }
      JUMPOUT(0x186DB748CLL);
    }
  }
}

void sub_183FC6A54(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10C0C4063EE03C6);
  _Unwind_Resume(a1);
}

void DeserializableArchive::deserialize(DeserializableArchive *this, SecPolicyRef *a2, __SecPolicy **a3)
{
  CFTypeRef v5;
  CFTypeID TypeID;
  const __CFDictionary *v7;
  const void *Value;
  _QWORD v9[2];
  CFDictionaryRef theDict;

  v9[1] = CFGetAllocator(this);
  v5 = CFRetain(this);
  v9[0] = v5;
  theDict = 0;
  TypeID = CFDictionaryGetTypeID();
  DeserializableArchive::decant((DeserializableArchive *)v9, CFSTR("properties"), TypeID, (const void **)&theDict);
  v7 = theDict;
  if (theDict)
  {
    Value = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0CD6FB0]);
    if (Value)
      *a2 = SecPolicyCreateWithProperties(Value, v7);
    CFRelease(v7);
  }
  if (!*a2)
    *a2 = SecPolicyCreateSSL(0, 0);
  if (v5)
    CFRelease(v5);
}

void sub_183FC6B38(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t WriteStreamCallbacks::_schedule(WriteStreamCallbacks *this, __CFWriteStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, WriteStreamCallbacks *, __CFWriteStream *, __CFRunLoop *))((char *)&a4->isa + *((_QWORD *)a4->isa - 17)))[9]((char *)a4 + *((_QWORD *)a4->isa - 17), this, a2, a3);
}

uint64_t WriteStreamCallbacks::_open(WriteStreamCallbacks *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(unsigned __int8 *, WriteStreamCallbacks *, __CFWriteStream *, CFStreamError *))(*(_QWORD *)&a4[*(_QWORD *)(*(_QWORD *)a4 - 136)] + 32))(&a4[*(_QWORD *)(*(_QWORD *)a4 - 136)], this, a2, a3);
}

uint64_t WriteStreamCallbacks::_setProperty(WriteStreamCallbacks *this, __CFWriteStream *a2, const __CFString *a3, char *a4, void *a5)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *, __CFWriteStream *, const __CFString *))(*(_QWORD *)&a4[*(_QWORD *)(*(_QWORD *)a4 - 136)] + 64))(&a4[*(_QWORD *)(*(_QWORD *)a4 - 136)], this, a2, a3);
}

CFDataRef StrictSecurityPolicy::CreateBinaryDataFromPropertyList(CFPropertyListRef propertyList, const void *a2)
{
  CFDataRef v2;
  CFErrorRef error;

  error = 0;
  v2 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], propertyList, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  if (error)
    CFRelease(error);
  return v2;
}

CFDataRef StrictSecurityPolicy::CreateDefaultSerializedATSState(StrictSecurityPolicy *this, int a2)
{
  int v3;
  const __CFAllocator *v4;
  __CFDictionary *Mutable;
  const void **v6;
  const __CFDictionary *v7;
  CFIndex Count;
  CFMutableDictionaryRef MutableCopy;
  NSObject *v10;
  const void *v11;
  CFDataRef BinaryDataFromPropertyList;
  _DWORD v14[2];
  __int16 v15;
  int v16;
  __int16 v17;
  __CFDictionary *v18;
  uint64_t v19;

  v3 = (int)this;
  v19 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v6 = (const void **)MEMORY[0x1E0C9AE50];
  if ((v3 & 1) != 0 || !dyld_program_sdk_at_least())
  {
    CFDictionaryAddValue(Mutable, CFSTR("NSAllowsArbitraryLoads"), *v6);
  }
  else
  {
    if (getDefaultATSState(void)::defaultStateToken != -1)
      dispatch_once(&getDefaultATSState(void)::defaultStateToken, &__block_literal_global_95);
    v7 = (const __CFDictionary *)getDefaultATSState(void)::baseATSState;
    if (getDefaultATSState(void)::baseATSState)
    {
      Count = CFDictionaryGetCount((CFDictionaryRef)getDefaultATSState(void)::baseATSState);
      MutableCopy = CFDictionaryCreateMutableCopy(v4, Count, v7);
      if (Mutable)
        CFRelease(Mutable);
      Mutable = MutableCopy;
    }
  }
  if (a2)
    CFDictionaryAddValue(Mutable, CFSTR("_ATSHasAppleBundleException"), *v6);
  if (ATSLog(void)::onceToken != -1)
    dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_84_8989);
  v10 = ATSLog(void)::atsLog;
  if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
  {
    v14[0] = 67109634;
    v14[1] = v3;
    v15 = 1024;
    v16 = a2;
    v17 = 2112;
    v18 = Mutable;
    _os_log_debug_impl(&dword_183ECA000, v10, OS_LOG_TYPE_DEBUG, "Created default configuration %d,%d %@", (uint8_t *)v14, 0x18u);
  }
  BinaryDataFromPropertyList = StrictSecurityPolicy::CreateBinaryDataFromPropertyList(Mutable, v11);
  if (Mutable)
    CFRelease(Mutable);
  return BinaryDataFromPropertyList;
}

void sub_183FC6E0C(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void ClassicURLConnection::~ClassicURLConnection(ClassicURLConnection *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6[16];
  uint8_t buf[16];

  *(_QWORD *)this = &off_1E14EB1E8;
  *((_QWORD *)this + 1) = &unk_1E14EB2D8;
  *((_QWORD *)this + 2) = &unk_1E14EB338;
  v2 = *((_QWORD *)this + 4);
  if (v2 && !*(_BYTE *)(v2 + 25) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "loader not invalidated", buf, 2u);
  }
  v3 = *((_QWORD *)this + 3);
  if (v3 && !*(_BYTE *)(v3 + 25) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "client not invalidated", v6, 2u);
  }
  v4 = *((_QWORD *)this + 4);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 3);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);

  *((_QWORD *)this + 2) = &off_1E14E5838;
}

void sub_183FC6F4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

void ClassicURLConnection::start(id *this)
{
  CFRunLoopRef Current;
  __CFRunLoop *v3;
  void *v4;
  uint64_t v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[6];
  _QWORD v10[6];
  _QWORD v11[6];
  _QWORD block[6];

  Current = CFRunLoopGetCurrent();
  v3 = Current;
  if (Current)
  {
    CFRetain(Current);
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(block[0]) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "CFRunLoopGetCurrent() unexpectedly returned NULL", (uint8_t *)block, 2u);
  }
  CFRetain(this - 2);
  if (!this[5])
    ClassicURLConnection::pinThisRunLoop((ClassicURLConnection *)this, v3, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
  v4 = (void *)objc_msgSend(this[7], "originalRequest");
  if (v4 && (*(_WORD *)(objc_msgSend(v4, "_inner") + 64) & 4) != 0)
    (*(void (**)(id))(*(_QWORD *)this[3] + 56))(this[3]);
  v5 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN20ClassicURLConnection5startEv_block_invoke;
  v9[3] = &__block_descriptor_48_e39_v16__0__ConnectionClientInterface_____8l;
  v9[4] = this;
  v9[5] = v3;
  CFRetain(this - 2);
  v6 = this[3];
  v10[0] = v5;
  v10[1] = 3221225472;
  v10[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v10[3] = &unk_1E14F78D0;
  v10[4] = v9;
  v10[5] = this;
  v11[0] = v5;
  v11[1] = 3221225472;
  v11[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v11[3] = &unk_1E14FDA90;
  v11[4] = v10;
  v11[5] = v6;
  v7 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v6 + 4) + 64))(*((_QWORD *)v6 + 4));
  v8 = *((_QWORD *)v6 + 5);
  block[0] = v5;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v11;
  block[5] = v7;
  dispatch_async(v8, block);
}

uint64_t ClassicURLConnection::setDelegateDispatchQueue(CoreSchedulingSet *a1, CoreSchedulingSet *this)
{
  CFAllocatedReferenceCountedObject *Empty;
  CFAllocatedReferenceCountedObject *v4;

  if (this)
    Empty = CoreSchedulingSet::createWithDispatchQueue(this, this);
  else
    Empty = (CFAllocatedReferenceCountedObject *)CoreSchedulingSet::createEmpty(a1);
  v4 = Empty;
  ClassicURLConnection::setDelegateScheduling((ClassicURLConnection *)a1, (const CoreSchedulingSet *)Empty);
  return (*(uint64_t (**)(CFAllocatedReferenceCountedObject *))(*(_QWORD *)v4 + 48))(v4);
}

void ClassicURLConnection::setDelegateScheduling(ClassicURLConnection *this, const CoreSchedulingSet *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[5];
  _QWORD v9[6];
  _QWORD v10[6];
  _QWORD block[6];

  (*(void (**)(const CoreSchedulingSet *))(*(_QWORD *)a2 + 40))(a2);
  v4 = MEMORY[0x1E0C809B0];
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN20ClassicURLConnection21setDelegateSchedulingEPK17CoreSchedulingSet_block_invoke;
  v8[3] = &__block_descriptor_40_e39_v16__0__ConnectionClientInterface_____8l;
  v8[4] = a2;
  CFRetain((char *)this - 16);
  v5 = *((_QWORD *)this + 3);
  v9[0] = v4;
  v9[1] = 3221225472;
  v9[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v9[3] = &unk_1E14F78D0;
  v9[4] = v8;
  v9[5] = this;
  v10[0] = v4;
  v10[1] = 3221225472;
  v10[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v10[3] = &unk_1E14FDA90;
  v10[4] = v9;
  v10[5] = v5;
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 32) + 64))(*(_QWORD *)(v5 + 32));
  v7 = *(NSObject **)(v5 + 40);
  block[0] = v4;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v10;
  block[5] = v6;
  dispatch_async(v7, block);
}

uint64_t ClassicURLConnection::scheduleWithRunLoop(ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  const __CFString *v5;
  const __CFString *v6;
  const CoreSchedulingSet *v7;

  if (a3)
    v5 = a3;
  else
    v5 = (const __CFString *)*MEMORY[0x1E0C9B280];
  ClassicURLConnection::pinThisRunLoop(this, a2, v5);
  v7 = (const CoreSchedulingSet *)CoreSchedulingSet::create((CoreSchedulingSet *)a2, v5, v6);
  ClassicURLConnection::setDelegateScheduling(this, v7);
  return (*(uint64_t (**)(const CoreSchedulingSet *))(*(_QWORD *)v7 + 48))(v7);
}

void ClassicURLConnection::pinThisRunLoop(ClassicURLConnection *this, CFRunLoopRef rl, CFRunLoopMode mode)
{
  __CFRunLoopSource *v5;
  const __CFAllocator *v7;
  CFRunLoopSourceContext v8;

  v5 = (__CFRunLoopSource *)*((_QWORD *)this + 5);
  if (!v5)
  {
    v8.version = 0;
    v8.info = (char *)this - 16;
    v8.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
    v8.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
    memset(&v8.copyDescription, 0, 40);
    v8.perform = (void (__cdecl *)(void *))_doNothingPerform;
    v7 = CFGetAllocator((char *)this - 16);
    v5 = CFRunLoopSourceCreate(v7, 0, &v8);
    *((_QWORD *)this + 5) = v5;
    if (!*((_QWORD *)this + 6))
    {
      *((_QWORD *)this + 6) = rl;
      if (rl)
      {
        CFRetain(rl);
        v5 = (__CFRunLoopSource *)*((_QWORD *)this + 5);
      }
    }
  }
  CFRunLoopAddSource(rl, v5, mode);
}

void ClassicURLConnection::useCredential(ClassicURLConnection *this, CFTypeRef cf, CFTypeRef a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  _QWORD v10[6];
  _QWORD v11[6];
  _QWORD v12[6];
  _QWORD block[6];

  if (cf)
    CFRetain(cf);
  if (a3)
    CFRetain(a3);
  v6 = MEMORY[0x1E0C809B0];
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN20ClassicURLConnection13useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke;
  v10[3] = &__block_descriptor_48_e29_v16__0__LoaderInterface_____8l;
  v10[4] = cf;
  v10[5] = a3;
  CFRetain((char *)this - 16);
  v7 = *((_QWORD *)this + 4);
  v11[0] = v6;
  v11[1] = 3221225472;
  v11[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v11[3] = &unk_1E14FABB8;
  v11[4] = v10;
  v11[5] = this;
  v12[0] = v6;
  v12[1] = 3221225472;
  v12[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v12[3] = &unk_1E14FDA90;
  v12[4] = v11;
  v12[5] = v7;
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v7 + 32) + 64))(*(_QWORD *)(v7 + 32));
  v9 = *(NSObject **)(v7 + 40);
  block[0] = v6;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v12;
  block[5] = v8;
  dispatch_async(v9, block);
}

URLConnectionLoader *URLConnectionLoader::_loaderEvent_SetProtocolIsDownload(URLConnectionLoader *this, char a2)
{
  _QWORD v2[4];
  char v3;

  if (!this->var23)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = ___ZN19URLConnectionLoader34_loaderEvent_SetProtocolIsDownloadEh_block_invoke;
    v2[3] = &__block_descriptor_33_e9_v16__0_v8l;
    v3 = a2;
    return (URLConnectionLoader *)URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)v2);
  }
  return this;
}

void URLConnectionClient::~URLConnectionClient(URLConnectionClient *this)
{
  void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  NSObject *v8;

  *(_QWORD *)this = off_1E14EA888;
  *((_QWORD *)this + 2) = &unk_1E14EA9D0;
  *((_QWORD *)this + 6) = &unk_1E14EA9F0;
  *((_QWORD *)this + 7) = &unk_1E14EAAA8;
  *((_QWORD *)this + 8) = &unk_1E14EAB00;
  *((_QWORD *)this + 11) = 0;
  v2 = (void *)*((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0;

  v3 = (const void *)*((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = 0;
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 22);
  *((_QWORD *)this + 22) = 0;
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 21);
  *((_QWORD *)this + 21) = 0;
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 25);
  if (v7)
    CFRelease(v7);
  *(_QWORD *)this = off_1E14ED770;
  *((_QWORD *)this + 2) = &unk_1E14ED798;
  v8 = *((_QWORD *)this + 5);
  if (v8)
  {
    dispatch_release(v8);
    *((_QWORD *)this + 5) = 0;
  }
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = &off_1E14E5838;
}

void sub_183FC75C4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  NSObject *v3;

  *v1 = off_1E14ED770;
  v1[2] = &unk_1E14ED798;
  v3 = v1[5];
  if (v3)
  {
    dispatch_release(v3);
    v1[5] = 0;
  }
  v1[4] = 0;
  v1[2] = &off_1E14E5838;
  _Unwind_Resume(exception_object);
}

uint64_t URLConnectionClient::_connectionClientInterface_cancelConnection(uint64_t a1, dispatch_object_t object, uint64_t a3)
{
  __int16 v3;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[6];
  _QWORD v11[7];

  v3 = *(_WORD *)(a1 + 76);
  if ((v3 & 0x40) != 0)
    return 0;
  *(_WORD *)(a1 + 76) = v3 | 0x40;
  dispatch_retain(object);
  v7 = MEMORY[0x1E0C809B0];
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  v11[3] = &unk_1E14FDBE0;
  v11[5] = a3;
  v11[6] = a1;
  v11[4] = object;
  if ((*(_BYTE *)(a1 + 76) & 8) != 0)
  {
    ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke((uint64_t)v11);
  }
  else
  {
    if ((objc_msgSend(*(id *)(a1 + 88), "_isAVAssetTask") & 1) == 0)
    {
      v8 = objc_msgSend(*(id *)(a1 + 88), "_metrics");
      -[__CFN_TaskMetrics completeWithError:](v8, (void *)objc_msgSend(MEMORY[0x1E0CB39B8], "errorWithDomain:code:userInfo:", *MEMORY[0x1E0CB32E8], -999, 0));
    }
    v10[0] = v7;
    v10[1] = 3221225472;
    v10[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_5;
    v10[3] = &unk_1E14FA830;
    v10[4] = v11;
    v10[5] = a1;
    URLConnectionClient::terminalEvent(a1, (uint64_t)v10);
  }
  return 1;
}

_WORD *URLConnectionClient::_connectionClientInterface_startConnection(_WORD *this, __CFRunLoop *a2, const __CFString *a3)
{
  _WORD *v3;

  if ((this[38] & 1) == 0)
  {
    v3 = this;
    (*(void (**)(_WORD *, __CFRunLoop *, const __CFString *))(*(_QWORD *)this + 296))(this, a2, a3);
    v3[38] |= 1u;
    return (_WORD *)(*(uint64_t (**)(_WORD *))(*(_QWORD *)v3 + 280))(v3);
  }
  return this;
}

uint64_t URLConnectionClient::_connectionClientInterface_hasBegunLoading(URLConnectionClient *this)
{
  return *((_WORD *)this + 38) & 1;
}

void URLConnectionClient::_loaderClientEvent_DidReceiveChallenge(URLConnectionClient *this, _CFURLAuthChallenge *a2)
{
  char *v4;
  uint64_t v5;
  __int16 v6;
  const __CFURL *v7;
  const __CFString *v8;
  const __CFString *v9;
  uint64_t v10;
  const __CFString *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  const char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((*((_WORD *)this + 38) & 8) != 0)
    return;
  if (!a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    v15 = 136315138;
    v16 = "_loaderClientEvent_DidReceiveChallenge";
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s: no challenge found to send!", (uint8_t *)&v15, 0xCu);
  }
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1)
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_8559);
  v4 = (char *)a2 + 16;
  if (!a2)
    v4 = 0;
  v5 = *((_QWORD *)v4 + 3);
  if (!v5)
    goto LABEL_22;
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  if ((*(_DWORD *)(v5 + 72) - 7) < 0xFFFFFFFA)
    goto LABEL_22;
  v6 = *((_WORD *)this + 38);
  if ((v6 & 0x10) != 0)
    goto LABEL_22;
  *((_WORD *)this + 38) = v6 | 0x10;
  v7 = (const __CFURL *)objc_msgSend((id)objc_msgSend(*((id *)this + 11), "currentRequest"), "URL");
  v8 = CFURLCopyUserName(v7);
  v9 = CFURLCopyPassword(v7);
  v11 = v9;
  if (v8 && v9)
  {
    v12 = CFURLCredentialCreate(*((_QWORD *)this + 1), v8, v9, v10, 2);
    (*(void (**)(_QWORD, uint64_t, _CFURLAuthChallenge *))(**((_QWORD **)this + 27) + 64))(*((_QWORD *)this + 27), v12, a2);
    v13 = 1;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    if (!v9)
      goto LABEL_19;
  }
  CFRelease(v11);
  v14 = v13;
LABEL_19:
  if (v8)
    CFRelease(v8);
  if (!v14)
LABEL_22:
    (*(void (**)(char *, _CFURLAuthChallenge *))(*((_QWORD *)this + 6) + 152))((char *)this + 48, a2);
}

void URLConnectionClient::_loaderClientEvent_DidReceiveResponse(URLConnectionClient *this, _CFURLResponse *a2)
{
  _CFURLResponse *v2;
  const void *v4;
  CFTypeRef v5;
  CFTypeRef v6;
  CFTypeRef v7;
  __int16 v8;
  const void *v9;
  _CFURLResponse *v10;
  uint64_t v11;
  uint64_t v12;
  HTTPSniffing *v13;
  _CFURLResponse *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((*((_WORD *)this + 38) & 8) == 0)
  {
    v2 = a2;
    v4 = *(const void **)(-[_CFURLResponse _inner](a2, "_inner") + 80);
    if (v4)
      v5 = CFRetain(v4);
    else
      v5 = 0;
    os_unfair_lock_lock((os_unfair_lock_t)this + 52);
    v6 = (CFTypeRef)*((_QWORD *)this + 25);
    if (v6 != v5)
    {
      if (v6)
        CFRelease(v6);
      if (v5)
        v7 = CFRetain(v5);
      else
        v7 = 0;
      *((_QWORD *)this + 25) = v7;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 52);
    if (v5)
      CFRelease(v5);
    v8 = *((_WORD *)this + 38);
    if ((v8 & 0x80) != 0)
    {
      if ((v8 & 4) == 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        LOWORD(v15) = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "_loaderClientEvent_DidReceiveResponse while sniffing but not multipart/x-mixed-replace", (uint8_t *)&v15, 2u);
      }
      URLConnectionClient::sniffAndSendDidReceiveResponse(this, 0);
      if (*((_QWORD *)this + 13))
      {
        (*(void (**)(char *))(*((_QWORD *)this + 6) + 128))((char *)this + 48);
        v9 = (const void *)*((_QWORD *)this + 13);
        *((_QWORD *)this + 13) = 0;
        if (v9)
          CFRelease(v9);
      }
    }
    v10 = (_CFURLResponse *)*((_QWORD *)this + 14);
    if (!v10)
    {
      v11 = *(_QWORD *)(-[_CFURLResponse _inner](v2, "_inner") + 88);
      if (v11 && (*(_WORD *)(v11 + 297) & 0x8000) != 0)
      {
        *((_WORD *)this + 38) |= 4u;
        *(_DWORD *)(-[_CFURLResponse _inner](v2, "_inner") + 72) = 2;
      }
      v10 = (_CFURLResponse *)*((_QWORD *)this + 14);
      if (!v10)
        goto LABEL_27;
    }
    if ((*((_WORD *)this + 38) & 4) != 0)
    {
LABEL_27:
      if (v10 != v2)
      {

        v2 = v2;
        *((_QWORD *)this + 14) = v2;
      }
      if ((*((_WORD *)this + 38) & 4) != 0)
      {
        v12 = *((_QWORD *)this + 12);
        if (v12 >= 1 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          v15 = 134217984;
          v16 = v12;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "response when we're still expecting bytes: %ld", (uint8_t *)&v15, 0xCu);
          v2 = (_CFURLResponse *)*((_QWORD *)this + 14);
        }
        *((_QWORD *)this + 12) = CFURLResponseGetExpectedContentLength(v2);
      }
      v13 = (HTTPSniffing *)objc_msgSend(*((id *)this + 11), "currentRequest");
      if (HTTPSniffing::checkRequestAndUpdateResponseForSniffingPurposes(v13, *((_CFURLRequest **)this + 14), v14))
        *((_WORD *)this + 38) |= 0x80u;
      else
        (*(void (**)(char *, _QWORD))(*((_QWORD *)this + 6) + 112))((char *)this + 48, *((_QWORD *)this + 14));
    }
  }
}

void URLConnectionClient::_internalEvent_WillSendRequestPartTwo(id *this, NSURLRequest *a2, char a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _QWORD v11[6];
  char v12;
  _QWORD v13[6];
  _QWORD v14[6];
  _QWORD block[6];

  objc_msgSend(this[11], "updateCurrentRequest:", a2);
  if (a2)
  {
    CFRetain(a2);
    v6 = this[27];
    v7 = MEMORY[0x1E0C809B0];
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = ___ZN19URLConnectionClient37_internalEvent_WillSendRequestPartTwoEP12NSURLRequesth_block_invoke;
    v11[3] = &unk_1E14FA898;
    v12 = a3;
    v11[4] = a2;
    v11[5] = this;
    CFRetain(v6 - 2);
    v8 = v6[4];
    v13[0] = v7;
    v13[1] = 3221225472;
    v13[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9489;
    v13[3] = &unk_1E14FABB8;
    v13[4] = v11;
    v13[5] = v6;
    v14[0] = v7;
    v14[1] = 3221225472;
    v14[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_9490;
    v14[3] = &unk_1E14FDA90;
    v14[4] = v13;
    v14[5] = v8;
    v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v8 + 32) + 64))(*(_QWORD *)(v8 + 32));
    v10 = *(NSObject **)(v8 + 40);
    block[0] = v7;
    block[1] = 3221225472;
    block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
    block[3] = &unk_1E14FDA90;
    block[4] = v14;
    block[5] = v9;
    dispatch_async(v10, block);
  }
  else
  {
    (*(void (**)(id))(*(_QWORD *)this[27] + 192))(this[27]);
  }
}

URLConnectionClient *URLConnectionClient::_loaderClientEvent_DidFinishLoading(URLConnectionClient *this)
{
  __int16 v1;
  uint64_t v2;
  __int16 v3;
  __int16 v4;
  uint64_t v5;
  const void *v6;
  __int16 v7;
  uint64_t v8;
  void *v9;
  int v10;
  uint64_t v11;
  __CFHTTPMessage *v12;
  __CFHTTPMessage *v13;
  CFStringRef v14;
  CFStringRef v15;
  CFURLRef v16;
  CFURLRef v17;
  _BOOL4 v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __CFCachedURLResponse **v23;
  const void *v24;
  _CFURLRequest *v25;
  _CFURLRequest *v26;
  const void *v27;
  os_unfair_lock_s *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  HTTPMessage *v32;
  CFStringRef v33;
  CFStringRef v34;
  const void *v35;
  HTTPMessage *v36;
  __CFString *v37;
  __CFString *CacheKeyForRequest;
  _QWORD v39[5];
  uint8_t buf[8];
  uint64_t v41;
  void (*v42)(uint64_t, _CFCachedURLResponse *);
  void *v43;
  uint64_t v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  void (*v48)(uint64_t);
  void *v49;
  os_unfair_lock_s *v50;

  v1 = *((_WORD *)this + 38);
  if ((v1 & 8) != 0)
    return this;
  v2 = (uint64_t)this;
  if ((v1 & 0x80) != 0)
  {
    URLConnectionClient::sniffAndSendDidReceiveResponse(this, 0);
    v3 = *(_WORD *)(v2 + 76);
    if ((v3 & 0x80) != 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "sniffForContentType should be cleared up by now", buf, 2u);
      if ((*(_WORD *)(v2 + 76) & 4) == 0)
      {
LABEL_6:
        os_unfair_lock_lock((os_unfair_lock_t)(v2 + 72));
        v4 = *(_WORD *)(v2 + 76);
        if ((v4 & 0x200) != 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "If we needed to sniff, we shouldn't have signaled that we had data", buf, 2u);
          v4 = *(_WORD *)(v2 + 76);
        }
        *(_WORD *)(v2 + 76) = v4 | 0x200;
        os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 72));
      }
    }
    else if ((v3 & 4) == 0)
    {
      goto LABEL_6;
    }
    v5 = *(_QWORD *)(v2 + 48);
    if (*(_QWORD *)(v2 + 104))
    {
      (*(void (**)(void))(v5 + 128))();
      v6 = *(const void **)(v2 + 104);
      *(_QWORD *)(v2 + 104) = 0;
      if (v6)
        CFRelease(v6);
    }
    else
    {
      (*(void (**)(void))(v5 + 120))();
    }
  }
  v7 = *(_WORD *)(v2 + 76);
  v8 = MEMORY[0x1E0C809B0];
  if ((v7 & 4) == 0 && (v7 & 8) == 0)
  {
    v9 = *(void **)(v2 + 112);
    if (v9)
    {
      v10 = *(_DWORD *)(objc_msgSend(v9, "_inner") + 72);
      if (v10 != 2)
      {
        v11 = *(_QWORD *)(objc_msgSend((id)objc_msgSend(*(id *)(v2 + 88), "currentRequest"), "_inner") + 56);
        if (v11)
        {
          v12 = (__CFHTTPMessage *)CFRetain((CFTypeRef)(v11 - 16));
          if (v12)
          {
            v13 = v12;
            v14 = CFHTTPMessageCopyRequestMethod(v12);
            if (v14)
            {
              v15 = v14;
              if (!CFEqual(v14, CFSTR("POST")))
              {
                v19 = 0;
                v18 = 1;
                goto LABEL_71;
              }
              v16 = _CFURLRequestCopyProtocolPropertyForKey((void *)objc_msgSend(*(id *)(v2 + 88), "currentRequest"), CFSTR("kCFURLRequestAllowAllPOSTCaching"));
              v17 = v16;
              if (!v16 || v16 == (CFURLRef)*MEMORY[0x1E0C9AE40])
              {
                v30 = *(_QWORD *)(objc_msgSend(*(id *)(v2 + 112), "_inner") + 88);
                if (v30)
                  v31 = v30 - 16;
                else
                  v31 = 0;
                if (v30)
                {
                  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
                  v32 = (HTTPMessage *)(v31 + 16);
                  v33 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)(v31 + 16), 0x1260F2FEu);
                  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
                  v34 = HTTPMessage::copyHeaderFieldValue(v32, 0x1181B2A6u);
                  v18 = ((unint64_t)v33 | (unint64_t)v34) != 0;
                  if (v33)
                    CFRelease(v33);
                  if (v34)
                    CFRelease(v34);
                }
                else
                {
                  v18 = 1;
                }
                if (!v17)
                  goto LABEL_70;
              }
              else
              {
                v18 = 1;
              }
              CFRelease(v17);
LABEL_70:
              v19 = 1;
LABEL_71:
              CFRelease(v15);
              CFRelease(v13);
              if (!v18)
                goto LABEL_72;
LABEL_29:
              if (!*(_QWORD *)(v2 + 144))
                goto LABEL_72;
              v20 = *(_QWORD *)(v2 + 152);
              if (!v20)
                goto LABEL_72;
              v21 = objc_msgSend(*(id *)(v2 + 112), "_inner");
              *(_QWORD *)(v21 + 32) = v20;
              v22 = *(_QWORD *)(v21 + 88);
              if (v22)
              {
                *(_WORD *)(v22 + 297) |= 0x100u;
                *(_WORD *)(*(_QWORD *)(v21 + 88) + 297) |= 0x2000u;
              }
              v23 = (__CFCachedURLResponse **)CFCachedURLResponseCreateWithDataArray(*MEMORY[0x1E0C9AE00], *(const void **)(v2 + 112), *(const void **)(v2 + 144), 0, v10);
              v24 = *(const void **)(v2 + 144);
              *(_QWORD *)(v2 + 144) = 0;
              if (v24)
                CFRelease(v24);
              if (!v23)
                goto LABEL_72;
              if (!v23[2])
                goto LABEL_66;
              v25 = (_CFURLRequest *)objc_msgSend(*(id *)(v2 + 88), "currentRequest");
              if (!v25)
                goto LABEL_66;
              v26 = v25;
              v27 = *(const void **)(-[_CFURLRequest _inner](v25, "_inner") + 224);
              if (v27)
              {
                v28 = (os_unfair_lock_s *)CFRetain(v27);
                v46 = v8;
                v47 = 3221225472;
                v48 = ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke;
                v49 = &__block_descriptor_40_e5_v8__0l;
                v50 = v28;
                if (v28)
                {
                  v29 = _CFURLStorageSessionCopyCache((uint64_t)v28, v28);
                  goto LABEL_56;
                }
              }
              else
              {
                v46 = v8;
                v47 = 3221225472;
                v48 = ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke;
                v49 = &__block_descriptor_40_e5_v8__0l;
                v50 = 0;
              }
              v29 = (_QWORD *)CFURLCacheCopySharedURLCache();
LABEL_56:
              v35 = v29;
              if (__CFURLCacheIsVaryHeaderSupportEnabled(v29)
                && (v36 = *(HTTPMessage **)(objc_msgSend(*(id *)(v2 + 112), "_inner") + 88)) != 0)
              {
                v37 = (__CFString *)HTTPMessage::copyHeaderFieldValue(v36, (const __CFString *)&unk_1EDCFD900);
              }
              else
              {
                v37 = 0;
              }
              CacheKeyForRequest = _createCacheKeyForRequest(v26, 0, v37);
              if (CacheKeyForRequest)
              {
                __CFCachedURLResponse::SetKey(v23[2], CacheKeyForRequest);
                CFRelease(CacheKeyForRequest);
              }
              v48((uint64_t)&v46);
              if (v37)
                CFRelease(v37);
              if (v35)
                CFRelease(v35);
LABEL_66:
              *(_QWORD *)buf = v8;
              v41 = 3221225472;
              v42 = ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke_2;
              v43 = &__block_descriptor_41_e76_v16__0___CFCachedURLResponse____CFRuntimeBase_QAQ_____CFCachedURLResponse__8l;
              v44 = v2;
              v45 = v19;
              (*(void (**)(uint64_t, __CFCachedURLResponse **, uint8_t *))(*(_QWORD *)(v2 + 48) + 72))(v2 + 48, v23, buf);
              CFRelease(v23);
              goto LABEL_72;
            }
            CFRelease(v13);
          }
        }
        v19 = 0;
        goto LABEL_29;
      }
    }
  }
LABEL_72:
  if ((objc_msgSend(*(id *)(v2 + 88), "_isAVAssetTask") & 1) == 0)
    -[__CFN_TaskMetrics completeWithError:](objc_msgSend(*(id *)(v2 + 88), "_metrics"), 0);
  v39[0] = v8;
  v39[1] = 3221225472;
  v39[2] = ___ZN19URLConnectionClient35_loaderClientEvent_DidFinishLoadingEv_block_invoke;
  v39[3] = &__block_descriptor_40_e14_v16__0___v___8l;
  v39[4] = v2;
  return (URLConnectionClient *)URLConnectionClient::terminalEvent(v2, (uint64_t)v39);
}

void sub_183FC8248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,void (*a24)(char *))
{
  const void *v24;

  a24(&a22);
  if (v24)
    CFRelease(v24);
  _Unwind_Resume(a1);
}

void URLConnectionClient::_internalEvent_WillSendRequest(URLConnectionClient *this)
{
  id v2;
  const void *v3;
  URLConnectionClient *v4;
  uint64_t v5;
  _QWORD v6[5];
  uint8_t buf[16];

  if ((*((_WORD *)this + 38) & 8) != 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "assertion failure", buf, 2u);
  }
  v2 = -[__NSURLSessionLocal _createCanonicalRequestForTask:]((id)objc_msgSend(*((id *)this + 11), "session"), *((void **)this + 11));
  if (v2)
  {
    v3 = v2;
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN19URLConnectionClient30_internalEvent_WillSendRequestEv_block_invoke;
    v6[3] = &__block_descriptor_40_e22_v16__0__NSURLRequest_8l;
    v6[4] = this;
    (*(void (**)(char *, id, _QWORD, _QWORD *))(*((_QWORD *)this + 6) + 24))((char *)this + 48, v2, 0, v6);
    CFRelease(v3);
  }
  else
  {
    if (objc_msgSend((id)objc_msgSend(*((id *)this + 11), "currentRequest"), "URL"))
    {
      v4 = this;
      v5 = -1002;
    }
    else
    {
      v4 = this;
      v5 = -1000;
    }
    (*(void (**)(URLConnectionClient *, const __CFString *, uint64_t))(*(_QWORD *)this + 104))(v4, CFSTR("kCFErrorDomainCFNetwork"), v5);
  }
}

void URLConnectionClient::invalidateAsync(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[6];
  std::__shared_weak_count *v14;
  _QWORD block[6];

  v3 = MEMORY[0x1E0C809B0];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3321888768;
  v13[2] = ___ZN19URLConnectionClient15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke;
  v13[3] = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  v5 = *a2;
  v4 = (std::__shared_weak_count *)a2[1];
  v13[4] = a1;
  v13[5] = v5;
  v14 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32));
  v9 = *(NSObject **)(a1 + 40);
  block[0] = v3;
  block[1] = 3221225472;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1E14FDA90;
  block[4] = v13;
  block[5] = v8;
  dispatch_async(v9, block);
  v10 = v14;
  if (v14)
  {
    v11 = (unint64_t *)&v14->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_183FC84C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t URLConnectionClient::terminalEvent(uint64_t result, uint64_t a2)
{
  __int16 v2;
  uint64_t v4;
  _QWORD v5[5];

  v2 = *(_WORD *)(result + 76);
  if ((v2 & 8) == 0)
  {
    *(_WORD *)(result + 76) = v2 | 8;
    v4 = *(_QWORD *)(result + 216);
    CFRetain((CFTypeRef)(v4 - 16));
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN19URLConnectionClient13terminalEventEPKcU13block_pointerFvU13block_pointerFvvEE_block_invoke;
    v5[3] = &__block_descriptor_40_e5_v8__0l;
    v5[4] = v4;
    return (*(uint64_t (**)(uint64_t, _QWORD *))(a2 + 16))(a2, v5);
  }
  return result;
}

uint64_t ReadStreamCallbacks::_schedule(ReadStreamCallbacks *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, ReadStreamCallbacks *, __CFReadStream *, __CFRunLoop *))((char *)&a4->isa + *((_QWORD *)a4->isa - 17)))[9]((char *)a4 + *((_QWORD *)a4->isa - 17), this, a2, a3);
}

uint64_t ReadStreamCallbacks::_open(ReadStreamCallbacks *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(unsigned __int8 *, ReadStreamCallbacks *, __CFReadStream *, CFStreamError *))(*(_QWORD *)&a4[*(_QWORD *)(*(_QWORD *)a4 - 136)] + 32))(&a4[*(_QWORD *)(*(_QWORD *)a4 - 136)], this, a2, a3);
}

uint64_t ReadStreamCallbacks::_setProperty(ReadStreamCallbacks *this, __CFReadStream *a2, const __CFString *a3, char *a4, void *a5)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *, __CFReadStream *, const __CFString *))(*(_QWORD *)&a4[*(_QWORD *)(*(_QWORD *)a4 - 136)] + 64))(&a4[*(_QWORD *)(*(_QWORD *)a4 - 136)], this, a2, a3);
}

uint64_t MemoryCookieStorage::setCookieAcceptPolicyLocked(uint64_t this, int a2)
{
  *(_DWORD *)(this + 80) = a2;
  return this;
}

__CFDictionary *HTTPConnectionCache::invalidateUnpurgeableConnectionsForKey(__CFDictionary *this, const HTTPConnectionCacheKey *a2)
{
  __CFDictionary *v3;
  __CFDictionary *v4;
  HTTPConnectionCacheEntry *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  if (a2)
  {
    v3 = this;
    HTTPConnectionCache::ensureEntries(this);
    this = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(*((_QWORD *)v3 + 5) + 32), a2);
    if (this)
    {
      v4 = this;
      (*(void (**)(__CFDictionary *))(*(_QWORD *)this + 40))(this);
      v5 = (HTTPConnectionCacheEntry *)*((_QWORD *)v4 + 3);
      v6 = (std::__shared_weak_count *)*((_QWORD *)v4 + 4);
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
      }
      HTTPConnectionCacheEntry::invalidateUnpurgeableConnections(v5);
      if (v6)
      {
        v9 = (unint64_t *)&v6->__shared_owners_;
        do
          v10 = __ldaxr(v9);
        while (__stlxr(v10 - 1, v9));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
      return (__CFDictionary *)(*(uint64_t (**)(__CFDictionary *))(*(_QWORD *)v4 + 48))(v4);
    }
  }
  return this;
}

void sub_183FC8690(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void MultiplexerSource::~MultiplexerSource(MultiplexerSource *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  __CFRunLoopSource *v5;
  const void *v6;

  *(_QWORD *)this = &off_1E14E9018;
  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 8);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 9);
  if (v4)
    CFRelease(v4);
  v5 = (__CFRunLoopSource *)*((_QWORD *)this + 7);
  if (v5)
  {
    CFRunLoopSourceInvalidate(v5);
    v6 = (const void *)*((_QWORD *)this + 7);
    if (v6)
      CFRelease(v6);
  }
  *(_QWORD *)this = &off_1E14E5838;
}

{
  MultiplexerSource::~MultiplexerSource(this);
  JUMPOUT(0x186DB748CLL);
}

void sub_183FC8744(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E14E5838;
  _Unwind_Resume(a1);
}

_QWORD *MultiplexerSource::Release(_QWORD *this, const void *a2)
{
  uint64_t v2;
  BOOL v3;
  uint64_t v4;

  v2 = this[6];
  v3 = __OFSUB__(v2, 1);
  v4 = v2 - 1;
  this[6] = v4;
  if (this)
  {
    if ((v4 < 0) ^ v3 | (v4 == 0))
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  return this;
}

uint64_t HTTPCookieStorage::syncStorageWithCompletion(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t result;
  _QWORD v9[6];

  CFRetain((CFTypeRef)(a1 - 16));
  v6 = *(_QWORD **)(a1 + 16);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___ZN17HTTPCookieStorage25syncStorageWithCompletionEhU13block_pointerFvvE_block_invoke;
  v9[3] = &unk_1E14FDA90;
  v9[4] = a3;
  v9[5] = a1;
  v7 = v6[4];
  if (v7)
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 8));
  result = (*(uint64_t (**)(_QWORD *, uint64_t, _QWORD *))(*v6 + 152))(v6, a2, v9);
  if (v7)
    return pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  return result;
}

void sub_183FC8840(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t HTTPCookieStorage::createFromArchive(HTTPCookieStorage *this, const __CFAllocator *a2, const __CFArray *a3, audit_token_t *a4)
{
  CFIndex Count;
  const __CFNumber *ValueAtIndex;
  uint64_t Instance;
  const __CFNumber *v9;
  const __CFAllocator *v10;
  const __CFArray *v11;
  audit_token_t *v12;
  const void *v13;
  const __CFString *v14;
  int ExactString;
  _OWORD *v16;
  const __CFNumber *v17;
  uint64_t v18;
  CFIndex v19;
  const __CFAllocator *v20;
  const __CFData *v21;
  CompactCookieArray *CompactCookieArray;
  CompactCookieArray *v23;
  const __CFData *v24;
  const UInt8 *BytePtr;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFData *v29;
  const UInt8 *v30;
  const UInt8 *v31;
  uint64_t v32;
  const UInt8 *v33;
  const __CFDictionary *v35;
  __CFDictionary *MutableCopy;
  const __CFString *Value;
  CFURLRef v38;
  const __CFData *v39;
  const __CFData *v40;
  int64_t Length;
  CFIndex v42;
  UInt8 *v43;
  uint64_t v44;
  const __CFString *v45;
  CFTypeID TypeID;
  const __CFNumber *v48;
  const void *v49;
  uint8_t valuePtr[112];
  uint8_t buf[4];
  CFRange v52;

  Count = CFArrayGetCount(a2);
  if (Count <= 1 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)valuePtr = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "not a valid archive", valuePtr, 2u);
  }
  ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a2, 0);
  *(_DWORD *)valuePtr = 0;
  if (!CFNumberGetValue(ValueAtIndex, kCFNumberIntType, valuePtr) || (Instance = 0, !*(_DWORD *)valuePtr))
  {
    v9 = (const __CFNumber *)CFArrayGetValueAtIndex(a2, 1);
    v10 = (const __CFAllocator *)CFArrayGetValueAtIndex(a2, 2);
    if (CFArrayGetCount(v10) < 1)
      v13 = 0;
    else
      v13 = (const void *)HTTPCookieStorage::createFromArchive(this, v10, v11, v12);
    v14 = (const __CFString *)CFArrayGetValueAtIndex(a2, 3);
    ExactString = _findExactString(v14, 4u);
    if (ExactString != 278983254)
    {
      if (ExactString == 280015450)
      {
        v48 = v9;
        v49 = v13;
        v16 = CFAllocatorAllocate(this, 88, 0);
        *v16 = 0u;
        v16[1] = 0u;
        v16[2] = 0u;
        v16[3] = 0u;
        v16[4] = 0u;
        *((_QWORD *)v16 + 10) = 0;
        MemoryCookieStorage::MemoryCookieStorage((MemoryCookieStorage *)v16, 1);
        HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)valuePtr, 0, 0, 0, 0, 0, 0);
        v17 = (const __CFNumber *)CFArrayGetValueAtIndex(a2, 4);
        *(_DWORD *)buf = 0;
        if (CFNumberGetValue(v17, kCFNumberIntType, buf) && *(int *)buf >= 1)
        {
          v18 = *(int *)buf + 4;
          v19 = 5;
          do
          {
            if (v19 >= Count && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "oob", buf, 2u);
            }
            v20 = (const __CFAllocator *)CFArrayGetValueAtIndex(a2, v19);
            CompactCookieArray = CompactCookieArray::makeCompactCookieArray((CompactCookieArray *)this, v20, v21);
            v23 = CompactCookieArray;
            if (CompactCookieArray)
            {
              v24 = (const __CFData *)*((_QWORD *)CompactCookieArray + 2);
              if (v24)
              {
                BytePtr = CFDataGetBytePtr(v24);
                if (BytePtr)
                {
                  v26 = *((unsigned int *)BytePtr + 1);
                  if ((_DWORD)v26)
                  {
                    v27 = 0;
                    v28 = 4 * v26;
                    do
                    {
                      v29 = (const __CFData *)*((_QWORD *)v23 + 2);
                      if (v29 && CFDataGetBytePtr(v29))
                      {
                        v30 = CFDataGetBytePtr(*((CFDataRef *)v23 + 2));
                        v31 = (const UInt8 *)*((_QWORD *)v23 + 2);
                        v32 = *(unsigned int *)&v30[v27 + 8];
                        if (v31)
                          v31 = CFDataGetBytePtr((CFDataRef)v31);
                        v33 = &v31[v32];
                      }
                      else
                      {
                        v33 = 0;
                      }
                      (*(void (**)(_OWORD *, const UInt8 *, uint8_t *))(*(_QWORD *)v16 + 120))(v16, v33, valuePtr);
                      v27 += 4;
                    }
                    while (v28 != v27);
                  }
                }
              }
              CFRelease((char *)v23 - 16);
            }
          }
          while (v19++ != v18);
        }
        HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)valuePtr);
        if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
          dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
        v13 = v49;
        Instance = _CFRuntimeCreateInstance();
        *(_OWORD *)(Instance + 112) = 0u;
        *(_OWORD *)(Instance + 128) = 0u;
        *(_OWORD *)(Instance + 32) = 0u;
        *(_OWORD *)(Instance + 48) = 0u;
        *(_OWORD *)(Instance + 64) = 0u;
        *(_OWORD *)(Instance + 80) = 0u;
        *(_OWORD *)(Instance + 16) = 0u;
        *(_OWORD *)(Instance + 96) = 0u;
        *(_QWORD *)(Instance + 16) = &off_1E14E8888;
        *(_QWORD *)(Instance + 24) = &unk_1E14E88D0;
        *(_DWORD *)(Instance + 136) = 0;
        *(_DWORD *)valuePtr = 0;
        CFNumberGetValue(v48, kCFNumberIntType, valuePtr);
        HTTPCookieStorage::initialize((HTTPCookieStorage *)(Instance + 16), (PrivateHTTPCookieStorage *)v16);
        if (v16)
          (*(void (**)(_OWORD *))(*(_QWORD *)v16 + 48))(v16);
      }
      else
      {
        Instance = 0;
      }
LABEL_54:
      if (v13)
        CFRelease(v13);
      return Instance;
    }
    v35 = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, 4);
    MutableCopy = CFDictionaryCreateMutableCopy(this, 0, v35);
    CFDictionarySetValue(MutableCopy, CFSTR("policy"), v9);
    if (v13)
      CFDictionarySetValue(MutableCopy, CFSTR("base"), v13);
    Value = (const __CFString *)CFDictionaryGetValue(v35, CFSTR("urlstring"));
    if (!Value)
    {
      v45 = (const __CFString *)CFDictionaryGetValue(v35, CFSTR("url"));
      if (!v45)
        goto LABEL_51;
      Value = v45;
      TypeID = CFStringGetTypeID();
      if (TypeID != CFGetTypeID(Value) && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)valuePtr = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "archived thingy not a string as expected", valuePtr, 2u);
      }
    }
    v38 = CFURLCreateWithFileSystemPath(this, Value, kCFURLPOSIXPathStyle, 0);
    CFDictionarySetValue(MutableCopy, CFSTR("url"), v38);
    CFRelease(v38);
    v39 = (const __CFData *)CFDictionaryGetValue(v35, CFSTR("sandbox_ext"));
    if (v39)
    {
      v40 = v39;
      Length = CFDataGetLength(v39);
      if (Length > 0)
      {
        v42 = Length;
        v43 = (UInt8 *)malloc_type_malloc(Length, 0x91CE84B9uLL);
        v52.location = 0;
        v52.length = v42;
        CFDataGetBytes(v40, v52, v43);
        v43[v42 - 1] = 0;
        v44 = sandbox_extension_consume();
        free(v43);
        Instance = (uint64_t)_CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(this, MutableCopy, 1);
        if (v44 != -1)
        {
          if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
            dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
          *(_QWORD *)(Instance + 88) = v44;
        }
        goto LABEL_52;
      }
    }
LABEL_51:
    Instance = (uint64_t)_CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(this, MutableCopy, 1);
LABEL_52:
    if (MutableCopy)
      CFRelease(MutableCopy);
    goto LABEL_54;
  }
  return Instance;
}

void sub_183FC8DE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void DiskCookieStorage::addToArchiveInternalLocked(DiskCookieStorage *this, CFMutableArrayRef theArray)
{
  const UInt8 *v4;
  const __CFAllocator *v5;
  size_t v6;
  const __CFURL *v7;
  CFStringRef v8;
  const __CFAllocator *v9;
  __CFDictionary *MutableDictionary;

  CFArrayAppendValue(theArray, &unk_1EDCFCA58);
  v4 = (const UInt8 *)*((_QWORD *)this + 9);
  v5 = CFGetAllocator(theArray);
  v6 = strlen((const char *)++v4);
  v7 = CFURLCreateFromFileSystemRepresentation(v5, v4, v6, 0);
  v8 = CFURLCopyFileSystemPath(v7, kCFURLPOSIXPathStyle);
  CFRelease(v7);
  v9 = CFGetAllocator(theArray);
  MutableDictionary = cfTypeCreateMutableDictionary(v9, CFSTR("urlstring"), v8, 0, 0);
  CFRelease(v8);
  CFArrayAppendValue(theArray, MutableDictionary);
  if (MutableDictionary)
    CFRelease(MutableDictionary);
}

uint64_t URLAuthChallenge::tryNextProtectionSpace(URLAuthChallenge *this)
{
  uint64_t result;
  CFIndex Count;
  CFIndex v4;
  const void *v5;

  result = *((_QWORD *)this + 8);
  if (result)
  {
    Count = CFArrayGetCount((CFArrayRef)result);
    v4 = *((_QWORD *)this + 9) + 1;
    if (v4 >= Count)
    {
      return 0;
    }
    else
    {
      v5 = (const void *)*((_QWORD *)this + 3);
      *((_QWORD *)this + 3) = 0;
      if (v5)
      {
        CFRelease(v5);
        v4 = *((_QWORD *)this + 9) + 1;
      }
      result = (uint64_t)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 8), v4);
      if (result)
      {
        *((_QWORD *)this + 3) = CFRetain((CFTypeRef)result);
        ++*((_QWORD *)this + 9);
        return 1;
      }
    }
  }
  return result;
}

CFTypeRef HTTPTransaction::copyTrust(HTTPTransaction *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  HTTPEngine *v6;
  CFTypeRef v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (!v2)
    return 0;
  v3 = std::__shared_weak_count::lock(v2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = *((_QWORD *)this + 7);
  if (v5 && (v6 = *(HTTPEngine **)(v5 + 64)) != 0)
    v7 = HTTPEngine::copyProperty(v6, CFSTR("kCFStreamPropertySSLPeerTrust"));
  else
    v7 = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return v7;
}

void sub_183FC9008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void HTTPTransaction::errorOccurred(HTTPTransaction *this, CFStreamError a2)
{
  if ((*((_DWORD *)this + 20) & 0xFFFFFFFE) != 0xA)
  {
    HTTPTransaction::_onqueue_handleError(this, a2);
    HTTPTransaction::_onqueue_invokeHandler(this);
    if ((*((_WORD *)this + 16) & 4) == 0)
      HTTPTransaction::_onqueue_closeAndCleanup(this);
  }
}

uint64_t __CFURLCache::GetDirectoryOfPersistentStore(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;

  v2 = this + 31;
  os_unfair_lock_lock(this + 31);
  if (!*(_QWORD *)&this[54]._os_unfair_lock_opaque)
    *(_QWORD *)&this[54]._os_unfair_lock_opaque = __CreatePathToCacheDirectory(0, 0);
  os_unfair_lock_unlock(v2);
  return *(_QWORD *)&this[54]._os_unfair_lock_opaque;
}

void __CFURLCache::PurgePersistentCache(__CFURLCache *this)
{
  pthread_mutex_t *v2;
  id v3;
  void *v4;
  uint64_t v5;
  dispatch_block_t v6;
  char v7;
  uint64_t v8;
  char v9;
  const char *v10;
  NSObject *v11;
  double v12;
  char *errmsg;
  _QWORD block[6];
  uint8_t buf[4];
  char *v16;
  _QWORD v17[3];

  v17[2] = *MEMORY[0x1E0C80C00];
  v2 = (pthread_mutex_t *)((char *)this + 552);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 552));
  CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 67));
  pthread_mutex_unlock(v2);
  v3 = __CFURLCache::createAndOpenCacheDB(this);
  if (v3)
  {
    v4 = v3;
    v5 = *((_QWORD *)this + 17);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZN12__CFURLCache20PurgePersistentCacheEv_block_invoke;
    block[3] = &unk_1E14FDE88;
    block[4] = v5;
    block[5] = v3;
    v6 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, QOS_CLASS_UTILITY, 0, block);
    dispatch_async(*((dispatch_queue_t *)this + 17), v6);
    _Block_release(v6);

  }
  if (*((_BYTE *)this + 632) && *((_QWORD *)this + 78))
  {
    __retainStorageAssertion(*((void **)this + 17));
    v7 = 0;
    v8 = 0;
    v17[0] = "DROP table IF EXISTS cfurl_vary_state;";
    v17[1] = "DROP TRIGGER IF EXISTS cfurl_vary_state_delete;";
    do
    {
      v9 = v7;
      v10 = (const char *)v17[v8];
      errmsg = 0;
      if (sqlite3_exec(*((sqlite3 **)this + 78), v10, 0, 0, &errmsg))
      {
        if (CFNLog::onceToken != -1)
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
        v11 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          v16 = errmsg;
          _os_log_impl(&dword_183ECA000, v11, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
        }
        sqlite3_free(errmsg);
      }
      v7 = 1;
      v8 = 1;
    }
    while ((v9 & 1) == 0);
    __CFURLCache::_createVaryStateTable((sqlite3 **)this);
    __releaseStorageAssertion(v12);
  }
}

void SocketStream::SocketStream(SocketStream *this, const char *a2)
{
  _QWORD *v3;

  *(_QWORD *)this = &off_1E14E8298;
  *((_QWORD *)this + 1) = &off_1E14E5838;
  *((_QWORD *)this + 2) = &unk_1E14E4760;
  *((_QWORD *)this + 3) = off_1E14E4668;
  _CoreLockable::_CoreLockable((SocketStream *)((char *)this + 32), 1);
  *v3 = &off_1E14E5818;
  if (SocketStream::observableProperties(void)::onceToken != -1)
    dispatch_once(&SocketStream::observableProperties(void)::onceToken, &__block_literal_global_5821);
  NotificationStation::NotificationStation((SocketStream *)((char *)this + 104), (CFTypeRef)SocketStream::observableProperties(void)::observableProps);
  *(_QWORD *)this = &off_1E14E6258;
  *((_QWORD *)this + 1) = &unk_1E14E6358;
  *((_QWORD *)this + 2) = &unk_1E14E63F0;
  *((_QWORD *)this + 3) = &unk_1E14E64F0;
  *((_QWORD *)this + 4) = &unk_1E14E6578;
  *((_DWORD *)this + 62) = 0;
  *((_WORD *)this + 126) = 0;
  *((_QWORD *)this + 81) = 0;
  *(_OWORD *)((char *)this + 664) = 0u;
  *((_QWORD *)this + 86) = 0;
  *((_DWORD *)this + 106) = 0;
  *((_QWORD *)this + 52) = 0;
}

void sub_183FC93AC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 32) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void SocketStream::_onqueue_startTCPConnectionConditional(SocketStream *this, int a2, int a3)
{
  const __CFDictionary *Value;
  double v7;
  const __CFDictionary *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  const void *v11;
  const void *v12;
  const __CFDictionary *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  const void *v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  uint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  ConditionalConnectionSIMScheduler **v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  __int128 v39;
  void (*v40)(uint64_t, int, CFTypeRef);
  void *v41;
  SocketStream *v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  void *v46;
  SocketStream *v47;
  SocketStream *v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t (*v52)(uint64_t);
  void *v53;
  SocketStream *v54;
  std::__shared_weak_count *v55;
  char v56;
  char v57;

  Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB868);
  if (Value)
  {
    v8 = Value;
    gotLoadHelper_x8__OBJC_CLASS____DASActivity(v7);
    if (objc_opt_class())
    {
      CFRetain((char *)this - 16);
      v9 = (std::__shared_weak_count *)operator new();
      v9->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1128;
      v9->__shared_weak_owners_ = 0;
      v9[1].__vftable = (std::__shared_weak_count_vtbl *)this;
      v11 = (const void *)tcp_connection_copy_endpoint();
      v12 = (const void *)tcp_connection_copy_parameters();
      v13 = (const __CFDictionary *)*((_QWORD *)this + 42);
      v14 = *((_QWORD *)this + 71);
      v15 = MEMORY[0x1E0C809B0];
      v50 = MEMORY[0x1E0C809B0];
      v51 = 3321888768;
      v52 = ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke;
      v53 = &__block_descriptor_50_e8_32c40_ZTSNSt3__110shared_ptrI12SocketStreamEE_e9_C16__0_v8l;
      v54 = this;
      v55 = v9;
      do
        v16 = __ldxr(p_shared_owners);
      while (__stxr(v16 + 1, p_shared_owners));
      v56 = a2;
      v57 = a3;
      v43 = v15;
      v44 = 3321888768;
      v45 = ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke_177;
      v46 = &__block_descriptor_56_e8_40c40_ZTSNSt3__110shared_ptrI12SocketStreamEE_e9_v16__0_v8l;
      v47 = this;
      v48 = this;
      v49 = v9;
      do
        v17 = __ldxr(p_shared_owners);
      while (__stxr(v17 + 1, p_shared_owners));
      *(_QWORD *)&v39 = v15;
      *((_QWORD *)&v39 + 1) = 3221225472;
      v40 = ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke_180;
      v41 = &__block_descriptor_40_e12_v20__0C8_v12l;
      v42 = this;
      __ConditionalConnectionDUETSupport_StartActivity(v13, v14, (uint64_t)v11, (uint64_t)v12, 0, (uint64_t)&v50, (uint64_t)&v43, (uint64_t)&v39);
      v18 = v49;
      if (v49)
      {
        v19 = (unint64_t *)&v49->__shared_owners_;
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      v21 = v55;
      if (v55)
      {
        v22 = (unint64_t *)&v55->__shared_owners_;
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      if (v12)
        CFRelease(v12);
      if (v11)
        CFRelease(v11);
      do
        v24 = __ldaxr(p_shared_owners);
      while (__stlxr(v24 - 1, p_shared_owners));
    }
    else
    {
      CFRetain((char *)this - 16);
      v9 = (std::__shared_weak_count *)operator new();
      v9->__shared_owners_ = 0;
      v25 = (unint64_t *)&v9->__shared_owners_;
      v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F1128;
      v9->__shared_weak_owners_ = 0;
      v9[1].__vftable = (std::__shared_weak_count_vtbl *)this;
      v26 = CFDictionaryGetValue(v8, CFSTR("kConditionalConnectionRequirementTimeWindowStartTime"));
      v27 = (const __CFNumber *)CFDictionaryGetValue(v8, CFSTR("kConditionalConnectionRequirementTimeWindowDelay"));
      v28 = (const __CFNumber *)CFDictionaryGetValue(v8, CFSTR("kConditionalConnectionRequirementTimeWindowDuration"));
      tcp_connection_set_indefinite();
      v29 = MEMORY[0x1E0C809B0];
      v43 = MEMORY[0x1E0C809B0];
      v44 = 3321888768;
      v45 = ___ZN12SocketStream17setupSIMSchedulerEPK14__CFDictionaryhh_block_invoke;
      v46 = &__block_descriptor_50_e8_32c40_ZTSNSt3__110shared_ptrI12SocketStreamEE_e5_v8__0l;
      v47 = this;
      v48 = (SocketStream *)v9;
      do
        v30 = __ldxr(v25);
      while (__stxr(v30 + 1, v25));
      LOBYTE(v49) = a2;
      BYTE1(v49) = a3;
      v50 = v29;
      v51 = 3221225472;
      v52 = ___ZN12SocketStream17setupSIMSchedulerEPK14__CFDictionaryhh_block_invoke_183;
      v53 = &__block_descriptor_40_e5_v8__0l;
      v54 = this;
      v31 = operator new(0x80uLL);
      v31[1] = 0;
      v31[2] = 0;
      *v31 = &off_1E14F0EF8;
      ConditionalConnectionSIMScheduler::ConditionalConnectionSIMScheduler((uint64_t)(v31 + 3), (uint64_t)v26, v27, v28, *((NSObject **)this + 71), &v43, &v50);
      *(_QWORD *)&v39 = v31 + 3;
      *((_QWORD *)&v39 + 1) = v31;
      std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v39, (_QWORD *)v39, v39);
      v32 = (ConditionalConnectionSIMScheduler **)((char *)this + 664);
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v32, &v39);
      v33 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
      if (*((_QWORD *)&v39 + 1))
      {
        v34 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
        do
          v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
      ConditionalConnectionSIMScheduler::start(*v32);
      v36 = (std::__shared_weak_count *)v48;
      if (v48)
      {
        v37 = (unint64_t *)((char *)v48 + 8);
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
      do
        v24 = __ldaxr(v25);
      while (__stlxr(v24 - 1, v25));
    }
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  else
  {
    SocketStream::_onqueue_startTCPConnectionCompletion(this, a2, a3);
  }
}

void sub_183FC981C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t *p_shared_owners;
  unint64_t v31;
  unint64_t v32;

  if (a20)
  {
    p_shared_owners = (unint64_t *)&a20->__shared_owners_;
    do
      v31 = __ldaxr(p_shared_owners);
    while (__stlxr(v31 - 1, p_shared_owners));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))a20->__on_zero_shared)(a20);
      std::__shared_weak_count::__release_weak(a20);
    }
  }
  do
    v32 = __ldaxr(v28);
  while (__stlxr(v32 - 1, v28));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  _Unwind_Resume(exception_object);
}

void SocketStream::_onqueue_completeTCPConnection0(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v3;
  NSObject *v4;
  uint64_t v5;
  int error;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  CFDataRef v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  const __CFDictionary *Value;
  const __CFDictionary *v16;
  const void *v17;
  const __CFNumber *v18;
  uint64_t v19;
  double v20;
  CFAbsoluteTime v21;
  uint64_t v22;
  int v23;
  int v24;
  id WeakRetained;
  const void *v26;
  id v27;
  const void *v28;
  UInt8 bytes[4];
  _BYTE buf[24];
  int v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "SocketStream doesn't know how to deal with leftover bytes here yet", buf, 2u);
  }
  if (*(_BYTE *)(a1 + 544))
  {
    if (!*(_QWORD *)(a1 + 560))
    {
LABEL_58:
      *(_BYTE *)(a1 + 544) = 0;
      CFRelease((CFTypeRef)(a1 - 16));
      return;
    }
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 336), &unk_1EDCFBDA8))
    {
      SocketStream::setupMinimumThroughput(a1, 0);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
      SocketStream::attemptNextConnection_NoLock((SocketStream *)a1);
      v3 = (pthread_mutex_t *)(a1 + 40);
LABEL_57:
      pthread_mutex_unlock(v3);
      goto LABEL_58;
    }
    *(_DWORD *)bytes = tcp_connection_get_socket();
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_QWORD *)(a1 + 560);
      error = tcp_connection_get_error();
      *(_DWORD *)buf = 134218496;
      *(_QWORD *)&buf[4] = v5;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = *(_DWORD *)bytes;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = error;
      _os_log_impl(&dword_183ECA000, v4, OS_LOG_TYPE_DEFAULT, "TCP Conn %p complete. fd: %d, err: %d", buf, 0x18u);
    }
    v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_28, 2);
    if (v7)
    {
      v8 = v7;
      if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v7 + 16))(v7, "SocketStream TCP Connection Complete", 0))
      {
        (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v8 + 72))(v8, "conn", CFSTR("%p"));
        (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v8 + 72))(v8, "fd", CFSTR("%d"));
        tcp_connection_get_error();
        (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v8 + 72))(v8, "error", CFSTR("%d"));
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
      }
    }
    if (*(_DWORD *)bytes != -1)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
      if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 336), &unk_1EDCFBDA8)
        && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Musn't have a native handle right now", buf, 2u);
      }
      v9 = CFGetAllocator((CFTypeRef)(a1 - 16));
      v10 = CFDataCreate(v9, bytes, 4);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 336), &unk_1EDCFBDA8, v10);
      if (v10)
        CFRelease(v10);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 336), &unk_1EDCFBD38, (const void *)*MEMORY[0x1E0C9AE50]);
      if (*(_BYTE *)(a1 + 405))
      {
        *(_DWORD *)buf = 1;
        setsockopt(*(int *)bytes, 6, 1, buf, 4u);
      }
      SocketStream::setupMinimumThroughput(a1, 0);
      SocketStream::attemptNextConnection_NoLock((SocketStream *)a1);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40));
      if (*(_DWORD *)bytes != -1)
        goto LABEL_58;
    }
    v11 = tcp_connection_get_error();
    v12 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_41_5747, 1);
    if (v12)
    {
      v13 = v12;
      if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v12 + 16))(v12, "TCP Connection Failed", 0))
      {
        tcp_connection_get_error();
        (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v13 + 72))(v13, "error", CFSTR("%d [%d]"));
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
      }
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v14 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      v22 = *(_QWORD *)(a1 + 560);
      v23 = tcp_connection_get_error();
      *(_DWORD *)buf = 134218752;
      *(_QWORD *)&buf[4] = v22;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = 0;
      *(_WORD *)&buf[22] = 1024;
      v31 = v11;
      v32 = 1024;
      v33 = v23;
      _os_log_error_impl(&dword_183ECA000, v14, OS_LOG_TYPE_ERROR, "TCP Conn %p Failed : error %ld:%d [%d]", buf, 0x22u);
      if (v11)
      {
LABEL_31:
        if (v11 == 536870913)
        {
LABEL_39:
          v11 = 57;
LABEL_47:
          v19 = 1;
          goto LABEL_48;
        }
        if (v11 == 57)
        {
          Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 336), &unk_1EDCFB868);
          if (Value)
          {
            v16 = Value;
            v17 = CFDictionaryGetValue(Value, CFSTR("kConditionalConnectionRequirementTimeWindowStartTime"));
            v18 = (const __CFNumber *)CFDictionaryGetValue(v16, CFSTR("kConditionalConnectionRequirementTimeWindowDuration"));
            v11 = 57;
            v19 = 1;
            if (!v17 || !v18)
              goto LABEL_48;
            *(_QWORD *)buf = 0;
            CFNumberGetValue(v18, kCFNumberDoubleType, buf);
            v20 = MEMORY[0x186DB5F80](v17);
            v21 = v20 + *(double *)buf;
            if (v21 <= CFAbsoluteTimeGetCurrent())
              v11 = 60;
            else
              v11 = 57;
            goto LABEL_47;
          }
          goto LABEL_39;
        }
        if (v11 > 0)
          goto LABEL_47;
        if (v11 > -65549)
        {
          if (v11 == -65548)
          {
            v11 = -72001;
            goto LABEL_66;
          }
          if (v11 == -65540)
          {
            v11 = -72004;
LABEL_66:
            v19 = 10;
            goto LABEL_48;
          }
        }
        else
        {
          if (v11 == -65555)
          {
            v11 = -72008;
            goto LABEL_66;
          }
          if (v11 == -65554)
          {
            v11 = 8;
            v19 = 12;
LABEL_48:
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
            v24 = *(_DWORD *)(a1 + 248);
            *(_QWORD *)(a1 + 256) = v19;
            *(_DWORD *)(a1 + 264) = v11;
            *(_DWORD *)(a1 + 248) = v24 & 0xFFFFFFEC | 2;
            *(_OWORD *)buf = *(_OWORD *)(a1 + 256);
            WeakRetained = objc_loadWeakRetained((id *)(a1 + 272));
            if (WeakRetained)
            {
              v26 = WeakRetained;
              if ((*(_DWORD *)(a1 + 248) & 0x200) != 0)
                _CFReadStreamSignalEventDelayed();
              CFRelease(v26);
            }
            v27 = objc_loadWeakRetained((id *)(a1 + 280));
            if (v27)
            {
              v28 = v27;
              if ((*(_DWORD *)(a1 + 248) & 0x400) != 0)
                _CFWriteStreamSignalEventDelayed();
              CFRelease(v28);
            }
            v3 = (pthread_mutex_t *)(a1 + 40);
            goto LABEL_57;
          }
        }
        v11 = -72000;
        goto LABEL_66;
      }
    }
    else if (v11)
    {
      goto LABEL_31;
    }
    v11 = 2;
    goto LABEL_47;
  }
}

void SocketStream::_onqueue_completeTCPConnection(SocketStream *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  const __CFBoolean *Value;
  const __CFAllocator *v6;
  CFStringRef v7;
  CFTypeRef v8;
  const __CFDictionary *v9;
  uint64_t i;
  const void *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[8];
  int v16;
  int valuePtr;
  void *values[5];
  void *keys[2];
  __int128 v20;
  const __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 49);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 49));
    *((_QWORD *)this + 49) = 0;
  }
  v3 = (*(uint64_t (**)(SocketStream *))(*(_QWORD *)this + 184))(this);
  if (v3)
  {
    v4 = v3;
    CFRetain((char *)this - 16);
    Value = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCF9C30);
    if (Value && CFBooleanGetValue(Value))
    {
      v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("SocketStream %p"), this);
      v16 = 60;
      valuePtr = 255;
      *(_OWORD *)keys = xmmword_1E14F9510;
      v20 = *(_OWORD *)off_1E14F9520;
      v21 = CFSTR("TimeoutAction");
      values[0] = (void *)CFRetain(CFSTR("PreventUserIdleSystemSleep"));
      values[1] = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      if (v7)
        v8 = CFRetain(v7);
      else
        v8 = 0;
      values[2] = (void *)v8;
      values[3] = CFNumberCreate(v6, kCFNumberIntType, &v16);
      values[4] = (void *)CFRetain(CFSTR("TimeoutActionTurnOff"));
      v9 = CFDictionaryCreate(v6, (const void **)keys, (const void **)values, 5, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      for (i = 0; i != 5; ++i)
      {
        v11 = values[i];
        if (v11)
          CFRelease(v11);
      }
      IOPMAssertionCreateWithProperties(v9, (IOPMAssertionID *)this + 153);
      if (v9)
        CFRelease(v9);
      if (v7)
        CFRelease(v7);
    }
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
    v12 = *((_QWORD *)this + 71);
    dispatch_retain(v12);
    v13 = *((_QWORD *)this + 70);
    tcp_connection_retain();
    v14 = *((_QWORD *)this + 70);
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke;
    v15[3] = &unk_1E14F93A8;
    v15[6] = this;
    v15[7] = v4;
    v15[4] = v12;
    v15[5] = v13;
    (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v4 + 56))(v4, v14, v15);
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  }
  else
  {
    SocketStream::_onqueue_completeTCPConnection0((uint64_t)this, 0);
  }
}

uint64_t SocketStream::startTCPConnection_Host(SocketStream *this, __CFHost *a2, const __CFNumber *a3)
{
  const __CFArray *Info;
  CFTypeRef v7;
  const __CFArray *v8;
  const __CFString *v9;
  const __CFString *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  int v14;
  const __CFData *ValueAtIndex;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFAllocator *v20;
  CFStringRef v21;
  __int16 valuePtr;
  CFAllocatorRef allocator;
  uint64_t v24;
  void *ptr;
  _QWORD v26[129];

  v26[128] = *MEMORY[0x1E0C80C00];
  Info = (const __CFArray *)CFHostGetInfo((uint64_t)a2, 0, 0);
  v7 = CFHostGetInfo((uint64_t)a2, 1, 0);
  if (!((unint64_t)Info | (unint64_t)v7))
  {
    result = 0;
    *((_QWORD *)this + 32) = 1;
    v14 = 22;
LABEL_15:
    *((_DWORD *)this + 66) = v14;
    return result;
  }
  v8 = (const __CFArray *)v7;
  valuePtr = 0;
  if (a3)
    CFNumberGetValue(a3, kCFNumberSInt16Type, &valuePtr);
  if (v8 && CFArrayGetCount(v8) >= 1 && (v9 = (const __CFString *)CFArrayGetValueAtIndex(v8, 0), (v10 = v9) != 0))
  {
    if (hostnameIsValid(v9))
    {
      allocator = CFGetAllocator((char *)this - 16);
      v24 = 1023;
      ptr = _CFStringGetOrCreateCString(allocator, v10, (UInt8 *)v26, &v24, 0x8000100u);
      *((_QWORD *)this + 70) = tcp_connection_create();
      v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_90_5716, 2);
      v12 = v11;
      if (v11
        && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v11 + 16))(v11, "TCP Connection Created", 0))
      {
        (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v12 + 72))(v12, "conn", CFSTR("%p for name %s, port %d"));
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
      }
      if (ptr && v26 != ptr)
        CFAllocatorDeallocate(allocator, ptr);
    }
    else
    {
      v18 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_94, 2);
      v19 = v18;
      if (v18
        && (*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v18 + 16))(v18, "TCP Connection Not Created - invalid host name", 0))
      {
        v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        allocator = (CFAllocatorRef)&off_1E14E4818;
        v21 = CFStringCreateWithCString(v20, "host", 0x8000100u);
        ptr = 0;
        v26[0] = 0;
        v24 = (uint64_t)v21;
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 64))(v19);
        AutoString::~AutoString((AutoString *)&allocator);
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
      }
      *((_QWORD *)this + 32) = 12;
      *((_DWORD *)this + 66) = 1;
    }
  }
  else if (Info)
  {
    if (CFArrayGetCount(Info) >= 1)
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Info, 0);
      if (ValueAtIndex)
      {
        if (CFDataGetBytePtr(ValueAtIndex))
        {
          *((_QWORD *)this + 70) = tcp_connection_create_with_sockaddr();
          v16 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_97_5720, 2);
          v17 = v16;
          if (v16)
          {
            if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v16 + 16))(v16, "TCP Connection Created", 0))
            {
              (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v17 + 72))(v17, "conn", CFSTR("%p for sockaddr %@"));
              (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
            }
          }
        }
      }
    }
  }
  if (*((_QWORD *)this + 70))
  {
    SocketStream::startTCPConnection(this);
    return 1;
  }
  if (!*((_DWORD *)this + 66))
  {
    result = 0;
    if (valuePtr)
      v14 = 12;
    else
      v14 = 49;
    *((_QWORD *)this + 32) = 1;
    goto LABEL_15;
  }
  return 0;
}

void sub_183FCA65C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFAllocatorRef allocator, uint64_t a14, void *ptr)
{
  AutoString::~AutoString((AutoString *)&allocator);
  _Unwind_Resume(a1);
}

uint64_t SocketStream::setupMinimumThroughput(uint64_t this, int a2)
{
  const __CFNumber *v3;
  CFTypeID v4;
  int valuePtr;

  if (*(_QWORD *)(this + 560))
  {
    valuePtr = 0;
    this = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(this + 336), &unk_1EDCFA678);
    if (this)
    {
      v3 = (const __CFNumber *)this;
      v4 = CFGetTypeID((CFTypeRef)this);
      this = CFNumberGetTypeID();
      if (v4 != this)
        return this;
      CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr);
    }
    else if (!a2)
    {
      return this;
    }
    return tcp_connection_set_minimum_throughput();
  }
  return this;
}

uint64_t SocketStream::commonInitialization(SocketStream *this)
{
  const __CFAllocator *v2;
  const CFArrayCallBacks *v3;
  _QWORD *v4;
  __CFDictionary *Mutable;
  _opaque_pthread_t *v6;
  const LineInfo *v7;
  uint64_t result;
  CFAbsoluteTime Current;
  mach_port_t v10;
  pid_t v11;
  const char *v12;
  const char *v13;
  uint64_t v14;
  SocketStream *v15;
  const char *v16;

  v2 = CFGetAllocator((char *)this - 16);
  v3 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  *((_QWORD *)this + 38) = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
  *((_QWORD *)this + 39) = CFArrayCreateMutable(v2, 0, v3);
  *((_QWORD *)this + 40) = CFArrayCreateMutable(v2, 0, v3);
  v4 = CFAllocatorAllocate(v2, 32, 0);
  v4[2] = 0;
  v4[3] = 0;
  *v4 = off_1E14E6230;
  v4[1] = v2;
  v4[2] = CFArrayCreateMutable(v2, 0, v3);
  v4[3] = 0;
  *((_QWORD *)this + 41) = v4;
  Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)this + 42) = Mutable;
  CFDictionarySetValue(Mutable, &unk_1EDCFBA60, (const void *)*MEMORY[0x1E0C9AE50]);
  Current = CFAbsoluteTimeGetCurrent();
  v6 = pthread_self();
  v10 = pthread_mach_thread_np(v6);
  v11 = getpid();
  v12 = "CFSocketStream";
  v13 = "ioLogger";
  v14 = 0;
  v15 = this;
  v16 = "socketstream";
  *((_QWORD *)this + 27) = IOLogger::newLogger((IOLogger *)&Current, v7);
  result = copyGlobalTCPConnWorkQueue();
  *((_QWORD *)this + 71) = result;
  return result;
}

void SocketStream::startTCPConnection(SocketStream *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  const __CFBoolean *v5;
  const __CFBoolean *v6;
  const __CFBoolean *v7;
  const __CFBoolean *v8;
  const __CFBoolean *v9;
  const __CFBoolean *v10;
  const __CFBoolean *v11;
  const __CFString *Value;
  const __CFString *v13;
  const __CFNumber *v14;
  double v15;
  const void *v16;
  uint64_t v17;
  double v18;
  const void *delayInitStub;
  double v20;
  CFTypeRef v21;
  CFTypeRef v22;
  CFTypeRef v23;
  const __CFBoolean *v24;
  const __CFBoolean *v25;
  const __CFBoolean *v26;
  int v27;
  const __CFNumber *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  const __CFBoolean *v33;
  int v34;
  const __CFBoolean *v35;
  const __CFBoolean *v36;
  const __CFBoolean *v37;
  const __CFBoolean *v38;
  const __CFAllocator *v39;
  const __CFString *v40;
  const __CFBoolean *v41;
  int v42;
  const __CFData *v43;
  const UInt8 *BytePtr;
  __int128 v45;
  const __CFString *v46;
  const __CFString *v47;
  const __CFBoolean *v48;
  const __CFNumber *v49;
  const __CFNumber *v50;
  CFTypeID v51;
  const void *v52;
  const void *v53;
  const void *v54;
  CFTypeID v55;
  const __CFNumber *v56;
  const __CFNumber *v57;
  uint64_t v58;
  NSObject *v59;
  uint64_t v60;
  uint64_t v61;
  NSObject *v62;
  uint64_t v63;
  NSObject *v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD v67[7];
  char v68;
  char v69;
  __int128 v70;
  __int128 v71;
  int valuePtr;
  CFTypeRef cf;
  uint64_t inited;
  uint64_t v75;
  uint64_t v76;
  uint64_t (*v77)(uint64_t);
  void *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void (*v82)(uint64_t, int);
  void *v83;
  SocketStream *v84;
  _BYTE allocator[24];
  _QWORD v86[129];

  v86[128] = *MEMORY[0x1E0C80C00];
  tcp_connection_allow_client_socket_access();
  v2 = tcp_connection_copy_parameters();
  v3 = MEMORY[0x1E0C809B0];
  v80 = MEMORY[0x1E0C809B0];
  v81 = 3221225472;
  v82 = ___ZN12SocketStream18startTCPConnectionEh_block_invoke;
  v83 = &__block_descriptor_40_e13_v20__0I8r_v12l;
  v84 = this;
  tcp_connection_set_event_handler();
  v4 = *((_QWORD *)this + 70);
  v75 = v3;
  v76 = 3221225472;
  v77 = ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2;
  v78 = &unk_1E14FE118;
  v79 = v4;
  tcp_connection_set_cancel_handler();
  if (!*((_QWORD *)this + 67))
  {
    Value = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB9F0);
    v13 = Value;
    if (Value && CFStringGetLength(Value) >= 1)
    {
      *(_QWORD *)allocator = CFGetAllocator((char *)this - 16);
      *(_QWORD *)&allocator[8] = 1023;
      *(_QWORD *)&allocator[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)allocator, v13, (UInt8 *)v86, (uint64_t *)&allocator[8], 0x8000100u);
      tcp_connection_set_cellular_service();
      if (*(_QWORD *)&allocator[16] && v86 != *(_QWORD **)&allocator[16])
        CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
    }
    else
    {
      v14 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBA28);
      if (v14)
      {
        *(_QWORD *)allocator = 0;
        *(_QWORD *)&allocator[8] = (char *)this - 16;
        *(_QWORD *)&allocator[16] = MEMORY[0x1E0C98BD0];
        v86[0] = MEMORY[0x1E0C98BC0];
        v86[1] = MEMORY[0x1E0C98350];
        gotLoadHelper_x8___CTServerConnectionCreate(v15);
        if (*(_QWORD *)(v17 + 3856))
        {
          CFGetAllocator(v16);
          delayInitStub = (const void *)_CTServerConnectionCreate_delayInitStub(v18);
          if (delayInitStub)
          {
            cf = 0;
            inited = 0;
            valuePtr = 0;
            CFNumberGetValue(v14, kCFNumberSInt32Type, &valuePtr);
            v21 = cf;
            cf = 0;
            if (v21)
              CFRelease(v21);
            inited = _CTServerConnectionCopyPacketContextInterfaceName_delayInitStub(v20);
            CFRelease(delayInitStub);
            if (cf)
            {
              v22 = CFRetain(cf);
              v23 = cf;
              *((_QWORD *)this + 67) = v22;
              if (v23)
                CFRelease(v23);
            }
            else
            {
              *((_QWORD *)this + 67) = 0;
            }
          }
        }
      }
    }
  }
  v5 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB788);
  v6 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA058);
  if (v5 && !CFBooleanGetValue(v5) || v6 && !CFBooleanGetValue(v6))
    tcp_connection_set_no_expensive();
  v7 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB750);
  v8 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA020);
  if (v2)
  {
    if ((v9 = v8, v7) && !CFBooleanGetValue(v7) || v9 && !CFBooleanGetValue(v9))
      nw_parameters_set_prohibit_constrained(v2, 1);
  }
  v10 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA090);
  if (v2 && v10 && CFBooleanGetValue(v10))
    nw_parameters_set_allow_ultra_constrained();
  v11 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA0C8);
  if (v2 && v11)
  {
    if (CFBooleanGetValue(v11))
      removeProhibitedNetworkType((uint64_t)v2, 0);
    else
      addProhibitedNetworkType((uint64_t)v2, 0);
  }
  v24 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA3D8);
  v25 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA3A0);
  if ((unint64_t)v24 | (unint64_t)v25)
  {
    if (v24)
      CFBooleanGetValue(v24);
    if (v25)
      CFBooleanGetValue(v25);
    tcp_connection_override_obscure();
  }
  v26 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA6B0);
  if (v26)
  {
    v27 = CFBooleanGetValue(v26);
    if (v2)
    {
      if (v27)
        addProhibitedNetworkSubtype((uint64_t)v2, 0x1389u);
    }
  }
  v28 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA608);
  if (v2)
  {
    if (v28)
    {
      *(_DWORD *)allocator = 0;
      if (CFNumberGetValue(v28, kCFNumberIntType, allocator))
      {
        v29 = nw_parameters_copy_default_protocol_stack(v2);
        v30 = v29;
        if (v29)
        {
          v31 = nw_protocol_stack_copy_internet_protocol(v29);
          v32 = v31;
          if (v31)
          {
            nw_ip_options_set_local_address_preference(v31, *(nw_ip_local_address_preference_t *)allocator);
            nw_release(v32);
          }
          nw_release(v30);
        }
      }
    }
  }
  v33 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA7C8);
  if (v33)
  {
    v34 = CFBooleanGetValue(v33);
    if (v2)
    {
      if (v34)
        addProhibitedNetworkSubtype((uint64_t)v2, 0x3E9u);
    }
  }
  tcp_connection_set_no_cellular();
  v35 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB8D8);
  if (v35)
  {
    CFBooleanGetValue(v35);
    tcp_connection_set_no_fallback();
  }
  v36 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB910);
  if (v36)
  {
    CFBooleanGetValue(v36);
    tcp_connection_set_fallback_fast();
  }
  v37 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBD70);
  if (v37)
  {
    CFBooleanGetValue(v37);
    tcp_connection_set_extended_background_idle();
  }
  tcp_connection_set_persistent();
  if (((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x8000000000) != 0)
    tcp_connection_set_usage_model();
  v38 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB0F8);
  if (v38)
  {
    CFBooleanGetValue(v38);
    tcp_connection_set_ecn_enabled();
  }
  if (*((_BYTE *)this + 406))
    tcp_connection_set_receive_any_interface();
  if (*((_QWORD *)this + 67))
  {
    v39 = CFGetAllocator((char *)this - 16);
    v40 = (const __CFString *)*((_QWORD *)this + 67);
    *(_QWORD *)allocator = v39;
    *(_QWORD *)&allocator[8] = 1023;
    if (v40)
    {
      *(_QWORD *)&allocator[16] = _CFStringGetOrCreateCString(v39, v40, (UInt8 *)v86, (uint64_t *)&allocator[8], 0x8000100u);
      if (!*(_QWORD *)&allocator[16])
        goto LABEL_76;
    }
    else
    {
      LOBYTE(v86[0]) = 0;
      *(_QWORD *)&allocator[8] = 0;
      *(_QWORD *)&allocator[16] = v86;
    }
    tcp_connection_set_interface_by_name();
    if (*(_QWORD *)&allocator[16] && v86 != *(_QWORD **)&allocator[16])
      CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
  }
LABEL_76:
  v41 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBC90);
  if (v41 && CFBooleanGetValue(v41))
  {
    v42 = 1;
    tcp_connection_set_opportunistic();
  }
  else
  {
    v42 = 0;
  }
  v43 = (const __CFData *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBF68);
  if (v43)
  {
    BytePtr = CFDataGetBytePtr(v43);
    if (BytePtr)
    {
      v45 = *((_OWORD *)BytePtr + 1);
      v70 = *(_OWORD *)BytePtr;
      v71 = v45;
      tcp_connection_set_source_application();
    }
  }
  v46 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFB718);
  if (v46)
  {
    *(_QWORD *)allocator = CFGetAllocator((char *)this - 16);
    *(_QWORD *)&allocator[8] = 1023;
    *(_QWORD *)&allocator[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)allocator, v46, (UInt8 *)v86, (uint64_t *)&allocator[8], 0x8000100u);
    if (*(_QWORD *)&allocator[16])
    {
      tcp_connection_set_account_identifier();
      if (*(_QWORD *)&allocator[16])
      {
        if (v86 != *(_QWORD **)&allocator[16])
          CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
      }
    }
  }
  v47 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBFA0);
  if (v47)
  {
    *(_QWORD *)allocator = CFGetAllocator((char *)this - 16);
    *(_QWORD *)&allocator[8] = 1023;
    *(_QWORD *)&allocator[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)allocator, v47, (UInt8 *)v86, (uint64_t *)&allocator[8], 0x8000100u);
    if (*(_QWORD *)&allocator[16])
    {
      tcp_connection_set_source_application_by_bundle();
      if (*(_QWORD *)&allocator[16])
      {
        if (v86 != *(_QWORD **)&allocator[16])
          CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
      }
    }
  }
  v48 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFBB08);
  if (v48)
  {
    CFBooleanGetValue(v48);
    tcp_connection_set_indefinite();
  }
  v49 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCF94C0);
  v50 = v49;
  if (v49)
  {
    *(_QWORD *)allocator = 0;
    v51 = CFGetTypeID(v49);
    if (v51 == CFNumberGetTypeID()
      && CFNumberGetValue(v50, kCFNumberDoubleType, allocator)
      && *(double *)allocator > 0.0)
    {
      tcp_connection_set_connection_attempt_timeout();
    }
  }
  if (*((_QWORD *)this + 70))
    tcp_connection_set_traffic_class();
  v52 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFA480);
  if (v52)
    SocketStream::updateExcessiveKeepalivesParameters((uint64_t)this, v52);
  v53 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFADE8);
  if (v53)
    SocketStream::updateTCPKeepalivesParameters((uint64_t)this, v53);
  v54 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFADB0);
  if (v54)
  {
    v55 = CFGetTypeID(v54);
    if (v55 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)allocator = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", allocator, 2u);
    }
    tcp_connection_set_keepalive_offload();
  }
  v56 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFACD0);
  v57 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EDCFAD08);
  if ((unint64_t)v56 | (unint64_t)v57)
    SocketStream::updateTCPAdaptiveParamters(this, v56, v57);
  *((_BYTE *)this + 544) = 1;
  CFRetain((char *)this - 16);
  v58 = (*(uint64_t (**)(SocketStream *))(*(_QWORD *)this + 184))(this);
  if (v58)
  {
    CFRetain((char *)this - 16);
    (*(void (**)(uint64_t))(*(_QWORD *)v58 + 16))(v58);
    v59 = *((_QWORD *)this + 71);
    dispatch_retain(v59);
    v60 = *((_QWORD *)this + 70);
    v67[0] = v3;
    v67[1] = 3221225472;
    v67[2] = ___ZN12SocketStream18startTCPConnectionEh_block_invoke_87;
    v67[3] = &unk_1E14F9430;
    v67[5] = this;
    v67[6] = v58;
    v67[4] = v59;
    v68 = 0;
    v69 = v42;
    (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v58 + 32))(v58, v60, v67);
    (*(void (**)(uint64_t))(*(_QWORD *)v58 + 24))(v58);
  }
  else
  {
    v61 = *((_QWORD *)this + 70);
    if (ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::emptyProxyDictOnce != -1)
      dispatch_once(&ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::emptyProxyDictOnce, &__block_literal_global_12940);
    if (v61)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v62 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v63 = tcp_connection_id();
        *(_DWORD *)allocator = 134218498;
        *(_QWORD *)&allocator[4] = v63;
        *(_WORD *)&allocator[12] = 2048;
        *(_QWORD *)&allocator[14] = v61;
        *(_WORD *)&allocator[22] = 2080;
        v86[0] = "empty";
        _os_log_impl(&dword_183ECA000, v62, OS_LOG_TYPE_DEFAULT, "TCP Conn [%llu:%p] using %s proxy configuration", allocator, 0x20u);
      }
      tcp_connection_set_proxies();
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v64 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v65 = tcp_connection_id();
      v66 = *((_QWORD *)this + 70);
      *(_DWORD *)allocator = 134218240;
      *(_QWORD *)&allocator[4] = v65;
      *(_WORD *)&allocator[12] = 2048;
      *(_QWORD *)&allocator[14] = v66;
      _os_log_impl(&dword_183ECA000, v64, OS_LOG_TYPE_DEFAULT, "Stream client bypassing proxies on TCP Conn [%llu:%p]", allocator, 0x16u);
    }
    SocketStream::_onqueue_startTCPConnectionConditional(this, 0, v42);
  }
  if (v2)
    nw_release(v2);
}

void sub_183FCB450(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,CFTypeRef cf,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,CFAllocatorRef allocator,uint64_t a36,void *ptr)
{
  void *v37;

  if (v37)
    nw_release(v37);
  _Unwind_Resume(exception_object);
}

void SocketStream::cancelSIMScheduler(SocketStream *this)
{
  ConditionalConnectionSIMScheduler *v2;
  char *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  v2 = (ConditionalConnectionSIMScheduler *)*((_QWORD *)this + 83);
  if (v2)
  {
    v3 = (char *)this + 664;
    ConditionalConnectionSIMScheduler::cancel(v2);
    v7 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v7);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
    if (*((_QWORD *)&v7 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void SocketStream::checkInVoIPSocket(SocketStream *this)
{
  __CFSocket *v2;
  double v3;
  _QWORD *v4;
  double v5;
  uint64_t v6;
  double v7;
  double v8;

  v2 = (__CFSocket *)*((_QWORD *)this + 36);
  if (v2
    && CFSocketIsValid(v2)
    && *((_DWORD *)this + 102) == 1
    && !*((_QWORD *)this + 69)
    && CFSocketGetNative(*((CFSocketRef *)this + 36)) != -1)
  {
    v4 = (_QWORD *)((char *)this + 552);
    v5 = gotLoadHelper_x8__spd_client_create(v3);
    if (*(_QWORD *)(v6 + 1208) && !spd_client_create_delayInitStub(v5))
    {
      if (!spd_client_checkin_socket_delayInitStub(v7))
        return;
      spd_client_destroy_delayInitStub(v8);
    }
    *v4 = 0;
  }
}

uint64_t SocketStream::captureStreams(SocketStream *this, __CFReadStream **a2, __CFWriteStream **a3)
{
  uint64_t result;
  __CFReadStream *v7;
  __CFWriteStream *v8;
  int *v9;
  int v10;

  if (*((_BYTE *)this + 193))
    return 0;
  if (a2)
  {
    CFGetAllocator((char *)this - 16);
    v7 = (__CFReadStream *)CFReadStreamCreate();
    *a2 = v7;
    objc_storeWeak((id *)this + 34, v7);
    if (*a2)
      CFRetain((char *)this - 16);
  }
  if (a3)
  {
    CFGetAllocator((char *)this - 16);
    v8 = (__CFWriteStream *)CFWriteStreamCreate();
    *a3 = v8;
    objc_storeWeak((id *)this + 35, v8);
    if (*a3)
      CFRetain((char *)this - 16);
  }
  if (!a2)
    return 1;
  result = 1;
  if (a3 && *a2 && *a3)
  {
    v10 = *((_DWORD *)this + 62);
    v9 = (int *)((char *)this + 248);
    *v9 = v10 | 0x80;
    CFRetain(v9 - 66);
    return 1;
  }
  return result;
}

void SocketStream::initialize(CFMutableDictionaryRef *this, __CFHost *a2, const __CFAllocator *a3)
{
  const __CFAllocator *v6;
  CFHostRef Copy;
  __CFDictionary *v8;
  void (**v9)(AutoScalar *__hidden);
  void *value;

  SocketStream::commonInitialization((SocketStream *)this);
  v6 = CFGetAllocator(this - 2);
  Copy = CFHostCreateCopy(v6, a2);
  CFDictionaryAddValue(this[42], &unk_1EDCFBDE0, Copy);
  v8 = this[42];
  AutoScalar::AutoScalar((AutoScalar *)&v9, a3);
  CFDictionaryAddValue(v8, &unk_1EDCFBE88, value);
  v9 = &off_1E14E47E8;
  if (value)
    CFRelease(value);
  CFRelease(Copy);
}

void sub_183FCB848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

BOOL Serializable::initializeFromPropertyList(uint64_t a1, CFDictionaryRef *a2)
{
  const __CFNumber *Value;
  const void *v5;
  const __CFString *v6;
  const __CFString *v7;
  _BOOL8 v8;
  uint64_t valuePtr;

  if (!a2)
    return 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(*a2, CFSTR("_version"));
  if (!Value)
    return 0;
  valuePtr = 0;
  CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
  if (valuePtr != 3)
    return 0;
  v5 = CFDictionaryGetValue(*a2, CFSTR("_kind"));
  if (!v5)
    return 0;
  v6 = (const __CFString *)CFRetain(v5);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = CFStringCompare(v6, *(CFStringRef *)(a1 + 8), 0) == kCFCompareEqualTo;
  CFRelease(v7);
  return v8;
}

void Schedulables::_add(Schedulables *this, const void *value)
{
  CFRange v4;

  v4.length = *((_QWORD *)this + 3);
  v4.location = 0;
  if (!CFArrayContainsValue(*((CFArrayRef *)this + 2), v4, value))
  {
    CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), value);
    ++*((_QWORD *)this + 3);
  }
}

void HTTPProtocol::sendError(HTTPProtocol *this, const __CFString *a2)
{
  const __CFAllocator *v4;
  const __CFDictionary *v5;
  const __CFAllocator *v6;
  __CFError *v7;
  const void *v8;
  void *keys;

  if (*((_QWORD *)this + 59))
  {
    v8 = (const void *)*((_QWORD *)this + 59);
    keys = CFSTR("NSErrorPeerAddressKey");
    v4 = CFGetAllocator((char *)this - 16);
    v5 = CFDictionaryCreate(v4, (const void **)&keys, &v8, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    v5 = 0;
  }
  v6 = CFGetAllocator((char *)this - 16);
  v7 = CFErrorCreate(v6, CFSTR("kCFErrorDomainCFNetwork"), (CFIndex)a2, v5);
  if (v5)
    CFRelease(v5);
  URLProtocol::sendDidFail((URLProtocol *)this, v7);
  if (v7)
    CFRelease(v7);
}

id HTTPProtocol::getTransactionMetrics(HTTPProtocol *this, const char *a2)
{
  id result;

  result = (id)*((_QWORD *)this + 104);
  if (result)
    return objc_getProperty(result, a2, 96, 1);
  return result;
}

uint64_t CookieUtils::looksLikeIPAddress(const __CFString *this, const __CFString *a2)
{
  CFIndex Length;
  uint64_t result;
  char buffer[24];
  _BYTE v6[255];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(this);
  result = 0;
  if (Length && Length <= 23)
  {
    if (CFStringGetCharacterAtIndex(this, 0) == 46
      && Length == 1
      && (*(_DWORD *)(MEMORY[0x1E0C80978] + 244) & 0x10000) == 0)
    {
      return 0;
    }
    else
    {
      result = CFStringGetCString(this, buffer, 24, 0x600u);
      if ((_DWORD)result)
      {
        result = inet_pton(2, buffer, v6);
        if ((_DWORD)result != 1)
          return inet_pton(30, buffer, v6) == 1;
      }
    }
  }
  return result;
}

uint64_t SyncClient::SyncClient(uint64_t a1, const __CFAllocator *a2, void *a3, dispatch_object_t object, const void *a5)
{
  uint64_t v9;
  void *v10;
  _OWORD *v11;
  NSObject *v12;
  _QWORD v14[13];

  *(_QWORD *)a1 = off_1E14EF578;
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = 1;
  if (((a1 + 16) & 3) != 0)
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  *(_QWORD *)a1 = off_1E14E4C08;
  *(_QWORD *)(a1 + 56) = object;
  dispatch_retain(object);
  *(_QWORD *)(a1 + 64) = _Block_copy(a5);
  *(_QWORD *)(a1 + 48) = CFDataCreateMutable(a2, 0);
  v14[0] = 1;
  v14[1] = a1;
  v14[2] = CFAllocatedReferenceCountedObject::_retainable_instance_retain;
  v14[3] = CFAllocatedReferenceCountedObject::_retainable_instance_release;
  v14[4] = CFAllocatedReferenceCountedObject::_retainable_copyDescription;
  v14[5] = 0;
  v14[6] = SyncClient::synchClientDidReceiveResponse;
  v14[7] = SyncClient::synchClientDidReceiveData;
  v14[8] = 0;
  v14[9] = SyncClient::synchClientDidFinishLoading;
  v14[11] = 0;
  v14[12] = 0;
  v14[10] = SyncClient::synchClientDidFail;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = (void *)MEMORY[0x186DB8C8C]();
  v11 = CFURLConnectionCreateWithProperties(v9, a3, v14, 0);
  objc_autoreleasePoolPop(v10);
  *(_QWORD *)(a1 + 24) = v11;
  v12 = dispatch_queue_create("com.apple.CFURLConnectionSynchronous", 0);
  CFURLConnectionSetDelegateDispatchQueue(*(_QWORD *)(a1 + 24), (uint64_t)v12);
  dispatch_release(v12);
  return a1;
}

void HTTPEngine::_connectionLost(HTTPEngine *this)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  *((_DWORD *)this + 8) |= 2u;
  if (!*((_QWORD *)this + 25) && !*((_QWORD *)this + 26) && !*((_QWORD *)this + 39))
  {
    v2 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
    if (v2)
    {
      v3 = std::__shared_weak_count::lock(v2);
      if (v3)
      {
        v4 = v3;
        v5 = *((_QWORD *)this + 10);
        if (v5)
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 24))(v5, 4, 4294967292);
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v7 = __ldaxr(p_shared_owners);
        while (__stlxr(v7 - 1, p_shared_owners));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
  }
}

void sub_183FCBD4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

__CFDictionary *createUpdatedSocketPropertiesForRequest(_CFURLRequest *a1, const __CFDictionary *a2, const __CFDictionary *a3)
{
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const __CFBoolean *v13;
  int v14;
  const __CFBoolean *v15;
  const __CFString *v16;
  CFAllocatorRef *v17;
  const void *NetworkServiceTypeString;
  __int16 v19;
  const __CFDictionary *v20;
  const __CFDictionary *v21;
  CFStringRef v22;
  double v23;
  double v24;
  __CFDictionary *Mutable;
  const __CFURL *v26;
  __CFDictionary *v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFNumberRef v30;
  const __CFDictionary *v31;
  const __CFAllocator *v32;
  const __CFDictionary *v33;
  const __CFDictionary *v34;
  CFStringRef v35;
  double v36;
  double v37;
  CFNumberRef v38;
  CFNumberRef v39;
  CFNumberRef v40;
  CFStringRef v41;
  CFTypeRef v42;
  const __CFURL *v44;
  CFStringRef value;
  double v46;
  double valuePtr;
  double v48;
  double v49;

  v6 = CFGetAllocator(a1);
  v7 = v6;
  if (a2)
    MutableCopy = CFDictionaryCreateMutableCopy(v6, 0, a2);
  else
    MutableCopy = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  v9 = MutableCopy;
  v10 = *(_QWORD *)(-[_CFURLRequest _inner](a1, "_inner") + 96);
  v11 = allowNewHTTP(void)::onceToken;
  if (v10 == 16)
    goto LABEL_14;
  if (allowNewHTTP(void)::onceToken != -1)
    dispatch_once(&allowNewHTTP(void)::onceToken, &__block_literal_global_3338);
  v12 = allowNewHTTP(void)::result;
  if (a3)
  {
    v13 = (const __CFBoolean *)CFDictionaryGetValue(a3, &unk_1EDCFE578);
    if (v13)
      v12 = CFBooleanGetValue(v13);
  }
  if (!v12)
    CFDictionaryAddValue(v9, &unk_1EDCF9B50, (const void *)*MEMORY[0x1E0C9AE50]);
  if (v10 != 64)
  {
    v11 = allowNewHTTP(void)::onceToken;
LABEL_14:
    if (v11 != -1)
      dispatch_once(&allowNewHTTP(void)::onceToken, &__block_literal_global_3338);
    v14 = allowNewHTTP(void)::result;
    if (a3)
    {
      v15 = (const __CFBoolean *)CFDictionaryGetValue(a3, &unk_1EDCFE5B0);
      if (v15)
        v14 = CFBooleanGetValue(v15);
    }
    if (!v14)
      CFDictionaryAddValue(v9, &unk_1EDCF9B88, (const void *)*MEMORY[0x1E0C9AE50]);
  }
  v16 = *(const __CFString **)(-[_CFURLRequest _inner](a1, "_inner") + 112);
  v17 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (v16)
    value = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v16);
  else
    value = 0;
  NetworkServiceTypeString = (const void *)ClassicURLConnection::getNetworkServiceTypeString(*(_DWORD *)(-[_CFURLRequest _inner](a1, "_inner") + 104));
  v19 = *(_WORD *)(-[_CFURLRequest _inner](a1, "_inner") + 64);
  if (a2)
  {
    v20 = (const __CFDictionary *)CFDictionaryGetValue(a2, &unk_1EDCFB868);
    v21 = v20;
    if (v20
      && !CFDictionaryGetValue(v20, CFSTR("kConditionalConnectionIdentifier"))
      && CFDictionaryGetValue(v21, CFSTR("kConditionalConnectionLaunchOnDemand"))
      && (v26 = *(const __CFURL **)(-[_CFURLRequest _inner](a1, "_inner") + 8)) != 0)
    {
      v22 = CFURLGetString(v26);
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = 0;
    v21 = 0;
  }
  v23 = *(double *)(-[_CFURLRequest _inner](a1, "_inner") + 128);
  valuePtr = v23;
  v24 = *(double *)(-[_CFURLRequest _inner](a1, "_inner") + 136);
  v46 = v24;
  if (NetworkServiceTypeString || value || (v19 & 8) == 0 || v22)
  {
    if (!v9)
      goto LABEL_66;
    if (NetworkServiceTypeString)
      CFDictionarySetValue(v9, &unk_1EDCFB478, NetworkServiceTypeString);
    if (value)
      CFDictionarySetValue(v9, &unk_1EDCFB830, value);
    if ((v19 & 8) == 0)
      CFDictionarySetValue(v9, &unk_1EDCFBC58, (const void *)*MEMORY[0x1E0C9AE50]);
    if (v22)
      goto LABEL_47;
  }
  else if (v23 == 0.0 || v24 == 0.0 || !v9)
  {
    goto LABEL_66;
  }
  if (v23 == 0.0 || v24 == 0.0)
    goto LABEL_66;
LABEL_47:
  if (v21)
    Mutable = CFDictionaryCreateMutableCopy(v7, 0, v21);
  else
    Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  v27 = Mutable;
  if (Mutable)
  {
    if (v22)
      CFDictionarySetValue(Mutable, CFSTR("kConditionalConnectionIdentifier"), v22);
    if (v23 == 0.0 || v24 == 0.0)
      goto LABEL_65;
    v28 = CFNumberCreate(v7, kCFNumberDoubleType, &valuePtr);
    v29 = CFNumberCreate(v7, kCFNumberDoubleType, &v46);
    v30 = v29;
    if (v28 && v29)
    {
      CFDictionarySetValue(v27, CFSTR("kConditionalConnectionRequirementTimeWindowDelay"), v28);
      CFDictionarySetValue(v27, CFSTR("kConditionalConnectionRequirementTimeWindowDuration"), v30);
    }
    else if (!v28)
    {
      goto LABEL_63;
    }
    CFRelease(v28);
LABEL_63:
    if (v30)
      CFRelease(v30);
LABEL_65:
    CFDictionarySetValue(v9, &unk_1EDCFB868, v27);
    CFRelease(v27);
  }
LABEL_66:
  if (!a2)
    goto LABEL_87;
  v31 = (const __CFDictionary *)CFDictionaryGetValue(a2, &unk_1EDCFB868);
  v32 = *v17;
  if (v31)
    v33 = CFDictionaryCreateMutableCopy(*v17, 0, v31);
  else
    v33 = CFDictionaryCreateMutable(*v17, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v34 = v33;
  if (v33
    && !CFDictionaryGetValue(v33, CFSTR("kConditionalConnectionIdentifier"))
    && CFDictionaryGetValue(v34, CFSTR("kConditionalConnectionLaunchOnDemand"))
    && (v44 = *(const __CFURL **)(-[_CFURLRequest _inner](a1, "_inner") + 8)) != 0)
  {
    v35 = CFURLGetString(v44);
  }
  else
  {
    v35 = 0;
  }
  v36 = *(double *)(-[_CFURLRequest _inner](a1, "_inner") + 128);
  v49 = v36;
  v37 = *(double *)(-[_CFURLRequest _inner](a1, "_inner") + 136);
  v48 = v37;
  if (v36 != 0.0 && v37 != 0.0)
  {
    v38 = CFNumberCreate(v32, kCFNumberDoubleType, &v49);
    v39 = CFNumberCreate(v32, kCFNumberDoubleType, &v48);
    v40 = v39;
    if (v38 && v39)
    {
      CFDictionarySetValue(v34, CFSTR("kConditionalConnectionRequirementTimeWindowDelay"), v38);
      CFDictionarySetValue(v34, CFSTR("kConditionalConnectionRequirementTimeWindowDuration"), v40);
    }
    else if (!v38)
    {
      goto LABEL_80;
    }
    CFRelease(v38);
LABEL_80:
    if (v40)
      CFRelease(v40);
  }
  if (v35)
    CFDictionarySetValue(v34, CFSTR("kConditionalConnectionIdentifier"), v35);
  if (v34)
  {
    if (CFDictionaryGetCount(v34))
      CFDictionarySetValue(v9, &unk_1EDCFB868, v34);
    else
      CFDictionaryRemoveValue(v9, &unk_1EDCFB868);
    v41 = value;
    CFRelease(v34);
    if (!value)
      goto LABEL_89;
    goto LABEL_88;
  }
LABEL_87:
  CFDictionaryRemoveValue(v9, &unk_1EDCFB868);
  v41 = value;
  if (value)
LABEL_88:
    CFRelease(v41);
LABEL_89:
  CFDictionaryAddValue(v9, &unk_1EDCF9338, (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", *(_QWORD *)(-[_CFURLRequest _inner](a1, "_inner") + 176)));
  v42 = *(CFTypeRef *)(-[_CFURLRequest _inner](a1, "_inner") + 120);
  if (v42
    || (v42 = (id)URLRequest::copyMainDocumentRegistrableDomain((URLRequest *)-[_CFURLRequest _inner](a1, "_inner"))) != 0)
  {
    CFDictionaryAddValue(v9, &unk_1EDCF9FB0, v42);
  }
  return v9;
}

void _NSURLConnectionDidReceiveResponse(_CFURLConnection *a1, _CFURLResponse *a2, uint64_t a3)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZL34_NSURLConnectionDidReceiveResponseP16_CFURLConnectionP14_CFURLResponsePKv_block_invoke;
  v3[3] = &__block_descriptor_40_e28_v24__0__NSURLConnection_8_16l;
  v3[4] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v3);
}

void _NSURLConnectionDidFinishLoading(_CFURLConnection *a1, uint64_t a2)
{
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a2, (uint64_t)&__block_literal_global_140);
}

uint64_t _CachedURLResponseRegisterClass(void)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  kCFCachedURLResponseTypeID = result;
  return result;
}

void _NSURLConnectionReleaseClient(uint64_t a1)
{
  void *v2;
  _QWORD v3[5];

  if (a1)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __66__NSURLConnectionInternal__withConnectionDisconnectFromConnection__block_invoke;
    v3[3] = &unk_1E14FE318;
    v3[4] = a1;
    v2 = (void *)MEMORY[0x186DB8C8C]();
    -[NSURLConnectionInternal _withConnectionAndDelegate:onlyActive:](a1, (uint64_t)v3, 0);
    objc_autoreleasePoolPop(v2);
  }
}

uint64_t copyGlobalTCPConnWorkQueue(void)
{
  if (copyGlobalTCPConnWorkQueue(void)::onceToken != -1)
    dispatch_once(&copyGlobalTCPConnWorkQueue(void)::onceToken, &__block_literal_global_184_5796);
  dispatch_retain((dispatch_object_t)copyGlobalTCPConnWorkQueue(void)::sTCPConnWorkQueue);
  return copyGlobalTCPConnWorkQueue(void)::sTCPConnWorkQueue;
}

uint64_t coreSchedulingSetRelease(const __CFAllocator *a1, const void *a2)
{
  return (*(uint64_t (**)(const void *))(*(_QWORD *)a2 + 48))(a2);
}

void appendEscaped(__CFString *a1, const __CFString *a2)
{
  const __CFString *v3;

  v3 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0, CFSTR("()<>@,;:\\\"/[]?={} \t"),
         0x8000100u);
  CFStringAppend(a1, v3);
  CFRelease(v3);
}

void __CFStreamCreatePairWithSocketToCFHost(const __CFAllocator *a1, __CFHost *a2, const __CFAllocator *a3, __CFReadStream **a4, __CFWriteStream **a5, int a6)
{
  uint64_t Instance;
  const char *v12;
  uint64_t v13;
  SocketStream *v14;
  const char *v15;
  CFMutableDictionaryRef *v16;
  unint64_t v17;
  __int16 v18;

  if (TCFObject<SocketStream>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_303);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v13 = Instance;
    v14 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B8uLL);
    SocketStream::SocketStream(v14, v15);
    SocketStream::initialize(v16, a2, a3);
    if ((*(unsigned int (**)(SocketStream *, __CFReadStream **, __CFWriteStream **))(*(_QWORD *)(v13 + 16)
                                                                                               + 64))(v14, a4, a5))
    {
      v17 = (*(unsigned int *)(v13 + 264) | ((unint64_t)*(unsigned __int16 *)(v13 + 268) << 32)) & 0xFFFFFF7FFFFFFFFFLL;
      v18 = 128;
      if (!a6)
        v18 = 0;
      *(_DWORD *)(v13 + 264) = *(_DWORD *)(v13 + 264);
      *(_WORD *)(v13 + 268) = WORD2(v17) | v18;
    }
    CFRelease((CFTypeRef)v13);
  }
  else
  {
    SocketStream::SocketStream(0, v12);
  }
}

uint64_t _CFURLProtectionSpaceCreateFromArchive(const __CFAllocator *a1, CFTypeRef cf)
{
  CFTypeRef v3;
  uint64_t Instance;
  CFTypeRef cfa[3];

  cfa[1] = a1;
  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  cfa[0] = v3;
  cfa[2] = a1;
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1)
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_8641);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3759];
  *(_QWORD *)(Instance + 16) = &off_1E14E9A20;
  *(_QWORD *)(Instance + 24) = &unk_1E14E9A78;
  *(_BYTE *)(Instance + 96) = 0;
  *(_BYTE *)(Instance + 104) = 0;
  *(_QWORD *)(Instance + 112) = 1;
  if (!URLProtectionSpace::initializeFromPropertyList((URLProtectionSpace *)(Instance + 16), (CFDictionaryRef *)cfa))
  {
    CFRelease((CFTypeRef)Instance);
    Instance = 0;
  }
  if (cfa[0])
    CFRelease(cfa[0]);
  return Instance;
}

void sub_183FCC770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t _CFHostCreateWithNameAndPortForConnect(const __CFAllocator *a1, const __CFString *a2, const __CFAllocator *a3)
{
  _OWORD *Instance;
  DispatchHost *v7;
  __CFArray *Array;
  void (**v10)(AutoScalar *__hidden);
  CFTypeRef cf;

  if (HostBase::Class(void)::sOnce_HostBase != -1)
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_14891);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v7 = (DispatchHost *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v7 = (DispatchHost *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  Array = cfTypeCreateArray(a1, a2, 0, 0, 0);
  AutoScalar::AutoScalar((AutoScalar *)&v10, a3);
  DispatchHost::DispatchHost(v7, CFSTR("kCFHostNames"), Array, 0x1EDCFF5A8, cf, 0);
  v10 = &off_1E14E47E8;
  if (cf)
    CFRelease(cf);
  if (Array)
    CFRelease(Array);
  if (v7)
    return (uint64_t)v7 - 16;
  else
    return 0;
}

void sub_183FCC8A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf)
{
  const void *v14;

  if (cf)
    CFRelease(cf);
  if (v14)
    CFRelease(v14);
  _Unwind_Resume(exception_object);
}

_QWORD *_CFHTTPCookieStorageCreateFromArchive(const __CFAllocator *a1, CFArrayRef theArray, audit_token_t *a3)
{
  const void *ValueAtIndex;
  CFTypeID v6;
  const __CFArray *v7;
  audit_token_t *v8;
  CFIndex Count;
  CFIndex v11;
  CFIndex v12;
  const void *v13;
  const __CFString *v14;
  CFTypeID v15;
  char *v16;
  os_unfair_lock_s *v17;
  _QWORD *v18;
  CFTypeID v19;
  OpaqueCFHTTPCookieStorage *v20;
  _QWORD *v21;
  unint64_t v22;
  CFRange v23;
  const void **v24;
  const __CFURL *v25;
  const __CFURL *v26;
  CFIndex v27;
  OpaqueCFHTTPCookie *v28;
  CFTypeRef v29;
  CFIndex range;
  const void **v31;
  _BYTE v32[248];
  CFIndex v33;

  if (CFArrayGetCount(theArray) >= 3)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
    v6 = CFGetTypeID(ValueAtIndex);
    if (v6 == CFNumberGetTypeID())
      return (_QWORD *)HTTPCookieStorage::createFromArchive(a1, theArray, v7, v8);
  }
  Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    v11 = Count;
    v12 = 0;
    v13 = 0;
    while (1)
    {
      v14 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v12);
      v15 = CFGetTypeID(v14);
      if (v15 == CFStringGetTypeID())
      {
        if (v14 && (v16 = (char *)CFEqual(v14, CFSTR("%ext%")), (_DWORD)v16))
        {
          v17 = (os_unfair_lock_s *)_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault;
          if (!_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault)
          {
            v16 = StorageSession::copyProcessDefault((StorageSession *)v16);
            v17 = (os_unfair_lock_s *)(v16 - 16);
            _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault = (uint64_t)(v16 - 16);
          }
          v18 = _CFURLStorageSessionCopyCookieStorage((uint64_t)v16, v17);
          if (v18)
            goto LABEL_21;
        }
        else
        {
          v25 = CFURLCreateWithFileSystemPath(a1, v14, kCFURLPOSIXPathStyle, 0);
          if (v25)
          {
            v26 = v25;
            v18 = CFHTTPCookieStorageCreateFromFile((char *)a1, v25, (uint64_t)v13);
            CFRelease(v26);
            if (v18)
              goto LABEL_21;
          }
        }
      }
      else
      {
        v19 = CFGetTypeID(v14);
        if (v19 == CFArrayGetTypeID())
        {
          v21 = _CookieStorageCreateInMemory(a1, v20);
          if (v21)
          {
            v18 = v21;
            if (v14)
            {
              v29 = CFRetain(v14);
              v22 = CFArrayGetCount((CFArrayRef)v14);
              v23.length = v22;
              range = v22;
              if (v22 - 1 > 0x1FFFFFFFFFFFFFFDLL)
              {
                v31 = 0;
              }
              else
              {
                if (v22 <= 0x1E)
                {
                  v24 = (const void **)v32;
                  v31 = (const void **)v32;
                  goto LABEL_26;
                }
                v24 = (const void **)malloc_type_malloc(8 * v22, 0x89ED541CuLL);
                v31 = v24;
                v23.length = range;
                if (v24)
                {
LABEL_26:
                  v23.location = 0;
                  CFArrayGetValues((CFArrayRef)v14, v23, v24);
                  v23.length = range;
                }
              }
              v33 = 0;
              if (v23.length >= 1)
              {
                v27 = 0;
                do
                {
                  v33 = v27 + 1;
                  v28 = -[NSHTTPCookie _initWithProperties:fromString:]([NSHTTPCookie alloc], "_initWithProperties:fromString:", v31[v27], 0);
                  if (v28)
                  {
                    CFHTTPCookieStorageSetCookie(v18, v28);
                    CFRelease(v28);
                  }
                  v27 = v33;
                }
                while (v33 < range);
              }
            }
            else
            {
              v29 = 0;
              range = 0;
              v31 = (const void **)v32;
              v33 = 0;
            }
            CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v29);
LABEL_21:
            if (v13)
              CFRelease(v13);
            goto LABEL_34;
          }
        }
      }
      v18 = v13;
LABEL_34:
      ++v12;
      v13 = v18;
      if (v12 == v11)
        return v18;
    }
  }
  return 0;
}

void sub_183FCCBA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void removeProhibitedNetworkType(uint64_t a1, int a2)
{
  uint64_t v3;
  void *v4;
  xpc_object_t v5;
  xpc_object_t v6;
  _QWORD v7[5];
  int v8;

  v3 = nw_parameters_copy_prohibited_interface_types();
  if (v3)
  {
    v4 = (void *)v3;
    v5 = xpc_array_create(0, 0);
    if (v5)
    {
      v6 = v5;
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = ___Z27removeProhibitedNetworkTypePU27objcproto16OS_nw_parameters8NSObject19nw_interface_type_t_block_invoke;
      v7[3] = &unk_1E14F7440;
      v8 = a2;
      v7[4] = v5;
      xpc_array_apply(v4, v7);
      xpc_release(v4);
      nw_parameters_set_prohibited_interface_types();
      v4 = v6;
    }
    xpc_release(v4);
  }
}

uint64_t stringToServiceType(uint64_t result)
{
  int ExactString;

  if (result)
  {
    ExactString = _findExactString((CFStringRef)result, 2u);
    if (ExactString <= 180604075)
    {
      if (ExactString <= 177638502)
      {
        if (ExactString == 175426624)
          return 8;
        if (ExactString == 176467028)
          return 3;
      }
      else
      {
        switch(ExactString)
        {
          case 177638503:
            return 5;
          case 178588802:
            return 11;
          case 179645591:
            return 10;
        }
      }
    }
    else if (ExactString > 183766244)
    {
      switch(ExactString)
      {
        case 185855239:
          return 1;
        case 184814838:
          return 4;
        case 183766245:
          return 2;
      }
    }
    else
    {
      switch(ExactString)
      {
        case 180604076:
          return 7;
        case 181726396:
          return 9;
        case 182791376:
          return 6;
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

_CFURLRequest *createCFRequest(const InternalInit *a1)
{
  _CFURLRequest *v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  __int16 v9;
  __int16 v10;

  v2 = (_CFURLRequest *)objc_msgSend(a1->var1, "mutableCopy");
  if (v2)
  {
    v3 = objc_msgSend((id)objc_msgSend(a1->var1, "URL"), "host");
    if (v3)
    {
      v4 = v3;
      v5 = +[NSURLRequest allowsSpecificHTTPSCertificateForHost:](NSURLRequest, "allowsSpecificHTTPSCertificateForHost:", v3);
      if (v5)
        setSSLProp(v2, CFSTR("_kCFStreamSSLTrustedLeafCertificates"), v5);
      if (+[NSURLRequest allowsAnyHTTPSCertificateForHost:](NSURLRequest, "allowsAnyHTTPSCertificateForHost:", v4))
      {
        setSSLProp(v2, (const __CFString *)&unk_1EDCFC588, (const void *)*MEMORY[0x1E0C9AE40]);
      }
    }
    v6 = objc_msgSend(a1->var1, "HTTPShouldHandleCookies");
    v7 = -[_CFURLRequest _inner](v2, "_inner");
    v8 = *(_WORD *)(v7 + 64);
    v9 = v8 | 0x21;
    v10 = v8 & 0xFFDE | 0x20;
    if (v6)
      v10 = v9;
    *(_WORD *)(v7 + 64) = v10;
  }
  return v2;
}

CFStringRef _CFURLCacheCopyCacheDirectory(os_unfair_lock_s **a1)
{
  uint64_t TypeID;
  const __CFAllocator *v3;
  const __CFString *DirectoryOfPersistentStore;

  if (!a1)
    return 0;
  TypeID = CFURLCacheGetTypeID();
  if (TypeID != CFGetTypeID(a1) || !__CFURLCache::GetDirectoryOfPersistentStore(a1[2]))
    return 0;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  DirectoryOfPersistentStore = (const __CFString *)__CFURLCache::GetDirectoryOfPersistentStore(a1[2]);
  return CFStringCreateCopy(v3, DirectoryOfPersistentStore);
}

const void *_CFHTTPCookieCreateWithStringAndPartition(const __CFAllocator *a1, uint64_t a2, const __CFURL *a3, const void *a4)
{
  __CFArray *Array;
  __CFArray *CookiesWithCookieStrings;
  const void *ValueAtIndex;
  const void *v10;

  Array = cfTypeCreateArray(a1, a2, 0, 0, 0);
  CookiesWithCookieStrings = _createCookiesWithCookieStrings(a1, Array, a3, a4, 1);
  if (Array)
    CFRelease(Array);
  if (!CookiesWithCookieStrings)
    return 0;
  if (CFArrayGetCount(CookiesWithCookieStrings) < 1)
  {
    v10 = 0;
  }
  else
  {
    ValueAtIndex = CFArrayGetValueAtIndex(CookiesWithCookieStrings, 0);
    v10 = ValueAtIndex;
    if (ValueAtIndex)
      CFRetain(ValueAtIndex);
  }
  CFRelease(CookiesWithCookieStrings);
  return v10;
}

void sub_183FCCFD8(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t CFURLCredentialCreate(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4, int a5)
{
  uint64_t Instance;

  if (URLCredential::Class(void)::sOnce_URLCredential != -1)
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_8521);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_QWORD *)(Instance + 112) = 0;
  *(_DWORD *)(Instance + 48) = 0;
  *(_BYTE *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 16) = &off_1E14EECF8;
  *(_QWORD *)(Instance + 24) = &unk_1E14EEDA0;
  *(_QWORD *)(Instance + 32) = &gConstantCFStringValueTable[3752];
  *(_QWORD *)(Instance + 40) = &unk_1E14EEDD0;
  *(_BYTE *)(Instance + 104) = 0;
  if (!URLCredentialInternetPassword::initialize(Instance + 16, a2, a3, a5, 0))
  {
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

void CFURLConnectionSetDelegateDispatchQueue(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;

  v4 = (void *)MEMORY[0x186DB8C8C]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_8_3802);
  if (a1)
    v5 = a1 + 16;
  else
    v5 = 0;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 120))(v5, a2);
  objc_autoreleasePoolPop(v4);
}

uint64_t CFURLConnectionSendSynchronousRequest(void *a1, _QWORD *a2, _QWORD *a3, double a4)
{
  const __CFAllocator *v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const void *v20;
  uint64_t v21;
  CFErrorRef CFError;
  _QWORD v24[8];
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;

  v8 = CFGetAllocator(a1);
  v9 = (void *)objc_msgSend(a1, "mutableCopy");
  if (*(double *)(objc_msgSend(v9, "_inner") + 24) >= a4)
  {
    v10 = objc_msgSend(v9, "_inner");
    *(_WORD *)(v10 + 64) |= 0x800u;
    *(double *)(v10 + 24) = a4;
  }
  v11 = dispatch_semaphore_create(0);
  v12 = dispatch_queue_create("com.apple.CFURLConnectionSynchronous", 0);
  v33 = 0;
  v34 = &v33;
  v35 = 0x2020000000;
  v36 = 0;
  v29 = 0;
  v30 = &v29;
  v31 = 0x2020000000;
  v32 = 0;
  v25 = 0;
  v26 = &v25;
  v27 = 0x2020000000;
  v28 = 0;
  v13 = CFAllocatorAllocate(v8, 72, 0);
  *((_OWORD *)v13 + 2) = 0u;
  *((_OWORD *)v13 + 3) = 0u;
  *(_OWORD *)v13 = 0u;
  *((_OWORD *)v13 + 1) = 0u;
  *((_QWORD *)v13 + 8) = 0;
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 3221225472;
  v24[2] = __CFURLConnectionSendSynchronousRequest_block_invoke;
  v24[3] = &unk_1E14F73F0;
  v24[6] = &v29;
  v24[7] = &v25;
  v24[4] = v11;
  v24[5] = &v33;
  SyncClient::SyncClient((uint64_t)v13, v8, v9, v12, v24);
  CFURLConnectionStart(*((_QWORD *)v13 + 3));
  dispatch_semaphore_wait(v11, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v11);
  dispatch_release(v12);
  (*(void (**)(void *))(*(_QWORD *)v13 + 48))(v13);
  if (v34[3] || v26[3])
  {
    if (!v9)
      goto LABEL_7;
    goto LABEL_6;
  }
  CFError = __cfnCreateCFError(v8, CFSTR("kCFErrorDomainCFNetwork"), -1001, v14, v15, v16, v17, v18, 0);
  v26[3] = (uint64_t)CFError;
  if (v9)
LABEL_6:
    CFRelease(v9);
LABEL_7:
  v19 = (void *)v30[3];
  if (a2)
    *a2 = v19;
  else

  v20 = (const void *)v26[3];
  if (a3)
  {
    *a3 = v20;
  }
  else if (v20)
  {
    CFRelease(v20);
  }
  v21 = v34[3];
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
  return v21;
}

void sub_183FCD39C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a18, 8);
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void sub_183FCD5E8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_183FCD6A0(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_183FCD898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183FCDA5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183FCDB58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183FCDC2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_183FCDCF0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_183FCDF20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183FCE110(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183FCE738(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FCEE9C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FD0A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *))
{
  a14(&a12);
  _Unwind_Resume(a1);
}

void sub_183FD120C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void sub_183FD13CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void sub_183FD204C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183FD216C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void xx_CFHTTPCookieStorageRemoveObserver(OpaqueCFHTTPCookieStorage *a1, __CFRunLoop *a2, const __CFString *a3, __CFAllocator *a4, const __CFAllocator *a5)
{
  CFTypeRef v9;
  __CFArray *Array;
  void *Value;
  void *v12;
  char *v13;
  __CFSet *v14;
  void (**v15)(AutoScalar *__hidden);
  CFTypeRef cf;
  void (**v17)(AutoScalar *__hidden);
  CFTypeRef v18;

  if (gObserverLock)
  {
    AutoScalar::AutoScalar((AutoScalar *)&v17, a4);
    v9 = v18;
    AutoScalar::AutoScalar((AutoScalar *)&v15, a5);
    Array = cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1, a2, a3, v9, cf, 0);
    v15 = &off_1E14E47E8;
    if (cf)
      CFRelease(cf);
    v17 = &off_1E14E47E8;
    if (v18)
      CFRelease(v18);
    os_unfair_lock_lock((os_unfair_lock_t)gObserverLock);
    Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(gObserverDict + 8), Array);
    if (Value)
    {
      v12 = Value;
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
      v13 = (char *)a1 + 16;
      if (!a1)
        v13 = 0;
      v14 = (__CFSet *)*((_QWORD *)v13 + 3);
      if (v14)
        CFSetRemoveValue(v14, v12);
      CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v12);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(gObserverDict + 8), Array);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)gObserverLock);
    if (Array)
      CFRelease(Array);
  }
}

void sub_183FD2734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf, uint64_t a17, CFTypeRef a18)
{
  if (cf)
    CFRelease(cf);
  if (a18)
    CFRelease(a18);
  _Unwind_Resume(exception_object);
}

void xx_CFHTTPCookieStorageAddObserver(OpaqueCFHTTPCookieStorage *a1, __CFRunLoop *a2, const __CFString *a3, const __CFAllocator *a4, const __CFAllocator *a5)
{
  _QWORD *v10;
  const __CFAllocator *v11;
  CFRunLoopSourceRef v12;
  char *v13;
  __CFSet *Mutable;
  const __CFAllocator *v15;
  CFTypeRef v16;
  __CFArray *Array;
  CFRunLoopSourceContext context;
  void (**v19)(AutoScalar *__hidden);
  CFTypeRef v20;
  void (**v21)(AutoScalar *__hidden);
  CFTypeRef v22;

  context.version = MEMORY[0x1E0C809B0];
  context.info = (void *)3221225472;
  context.retain = (const void *(__cdecl *)(const void *))___ZL19_dispatch_once_funcPlPFvvE_block_invoke_9756;
  context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e5_v8__0l;
  context.copyDescription = (CFStringRef (__cdecl *)(const void *))_initObserverLock;
  if (gObserverLockOnce != -1)
    dispatch_once(&gObserverLockOnce, &context);
  v10 = (_QWORD *)operator new();
  *v10 = a1;
  CFRetain(a1);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = 0;
  context.version = 0;
  context.info = v10;
  context.retain = (const void *(__cdecl *)(const void *))SourceContext::retain;
  context.release = (void (__cdecl *)(const void *))SourceContext::release;
  context.copyDescription = (CFStringRef (__cdecl *)(const void *))SourceContext::copyDescription;
  memset(&context.equal, 0, 32);
  context.perform = (void (__cdecl *)(void *))SourceContext::perform;
  v11 = CFGetAllocator(a1);
  v12 = CFRunLoopSourceCreate(v11, 0, &context);
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1)
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_9783);
  if (a1)
    v13 = (char *)a1 + 16;
  else
    v13 = 0;
  Mutable = (__CFSet *)*((_QWORD *)v13 + 3);
  v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!Mutable)
  {
    Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
    *((_QWORD *)v13 + 3) = Mutable;
  }
  CFSetAddValue(Mutable, v12);
  CFRunLoopAddSource(a2, v12, a3);
  AutoScalar::AutoScalar((AutoScalar *)&v21, a4);
  v16 = v22;
  AutoScalar::AutoScalar((AutoScalar *)&v19, a5);
  Array = cfTypeCreateArray(v15, a1, a2, a3, v16, v20, 0);
  v19 = &off_1E14E47E8;
  if (v20)
    CFRelease(v20);
  v21 = &off_1E14E47E8;
  if (v22)
    CFRelease(v22);
  os_unfair_lock_lock((os_unfair_lock_t)gObserverLock);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(gObserverDict + 8), Array, v12);
  os_unfair_lock_unlock((os_unfair_lock_t)gObserverLock);
  if (Array)
    CFRelease(Array);
  if (v12)
    CFRelease(v12);
}

void sub_183FD29C0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;
  const void *v4;

  *(_QWORD *)(v1 - 96) = &off_1E14E47E8;
  v3 = *(const void **)(v1 - 88);
  if (v3)
    CFRelease(v3);
  *(_QWORD *)(v1 - 80) = &off_1E14E47E8;
  v4 = *(const void **)(v1 - 72);
  if (v4)
    CFRelease(v4);
  _Unwind_Resume(exception_object);
}

void APSRelayEngine::~APSRelayEngine(id *this)
{
  APSRelayEngine::~APSRelayEngine(this);
  JUMPOUT(0x186DB748CLL);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;

  *this = &off_1E14E69B0;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 16));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 14));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 12));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 8));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 6));
  v2 = (std::__shared_weak_count *)this[5];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  *this = &off_1E14E5838;
  v3 = (std::__shared_weak_count *)this[2];
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

void sub_183FD2AE4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 16));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 14));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 12));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 8));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v1 + 6));
  v3 = (std::__shared_weak_count *)v1[5];
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  *v1 = &off_1E14E5838;
  v4 = (std::__shared_weak_count *)v1[2];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

_QWORD *std::shared_ptr<__CFString const>::operator=[abi:nn180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  if (a3)
  {
    v4 = (unint64_t *)(a3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (std::__shared_weak_count *)a1[1];
  *a1 = a2;
  a1[1] = a3;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return a1;
}

uint64_t std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

uint64_t std::__throw_bad_weak_ptr[abi:nn180100]()
{
  APSRelayEngine *v0;

  std::__libcpp_verbose_abort("bad_weak_ptr was thrown in -fno-exceptions mode");
  return APSRelayEngine::cancel(v0);
}

uint64_t APSRelayEngine::cancel(uint64_t this)
{
  if ((*(_BYTE *)(this + 24) & 1) == 0)
  {
    *(_BYTE *)(this + 24) |= 1u;
    if (*(_QWORD *)(this + 168))
    {
      if (!*(_QWORD *)(this + 160) && !*(_DWORD *)(this + 88))
        return objc_msgSend(*(id *)(this + 168), "cancelMessage:", *(_QWORD *)(this + 152));
    }
  }
  return this;
}

void ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke(_QWORD *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  _QWORD v33[11];
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;

  v6 = a1[5];
  v37 = 0;
  v38 = 0;
  v7 = (std::__shared_weak_count *)a1[7];
  if (v7)
  {
    v12 = std::__shared_weak_count::lock(v7);
    v38 = v12;
    if (v12)
    {
      v13 = a1[6];
      v37 = v13;
      if (v13)
      {
        v14 = v12;
        v15 = a2;
        v16 = a3;
        v17 = a5;
        v18 = *(_QWORD *)(v13 + 64);
        v33[0] = MEMORY[0x1E0C809B0];
        v33[1] = 3321888768;
        v33[2] = ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke_2;
        v33[3] = &unk_1E14F22B8;
        v33[4] = a2;
        v33[5] = a3;
        v33[8] = v6;
        v33[9] = a4;
        v33[6] = a5;
        v19 = (std::__shared_weak_count *)a1[9];
        v33[10] = a1[8];
        v34 = v19;
        if (v19)
        {
          p_shared_owners = (unint64_t *)&v19->__shared_owners_;
          do
            v21 = __ldxr(p_shared_owners);
          while (__stxr(v21 + 1, p_shared_owners));
        }
        v35 = v13;
        v36 = v14;
        v22 = (unint64_t *)&v14->__shared_owners_;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
        v33[7] = a1[4];
        (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v18 + 96))(v18, v33);
        v24 = v36;
        if (v36)
        {
          v25 = (unint64_t *)&v36->__shared_owners_;
          do
            v26 = __ldaxr(v25);
          while (__stlxr(v26 - 1, v25));
          if (!v26)
          {
            ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
            std::__shared_weak_count::__release_weak(v24);
          }
        }
        v27 = v34;
        if (v34)
        {
          v28 = (unint64_t *)&v34->__shared_owners_;
          do
            v29 = __ldaxr(v28);
          while (__stlxr(v29 - 1, v28));
          if (!v29)
          {
            ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
            std::__shared_weak_count::__release_weak(v27);
          }
        }
      }
    }
  }
  v30 = v38;
  if (v38)
  {
    v31 = (unint64_t *)&v38->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
}

void sub_183FD2E7C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 80);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_48c39_ZTSNSt3__18weak_ptrI14APSRelayEngineEE64c39_ZTSNSt3__110shared_ptrIK10__CFStringEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[9];
  result[8] = a2[8];
  result[9] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void __destroy_helper_block_e8_48c39_ZTSNSt3__18weak_ptrI14APSRelayEngineEE64c39_ZTSNSt3__110shared_ptrIK10__CFStringEE(uint64_t a1)
{
  std::__shared_weak_count *v2;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
  v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

uint64_t ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  __int128 v2;
  uint64_t v3;
  id v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v26;
  double Current;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  id v38;
  void *v39;
  void *v40;
  _BYTE *v41;
  const char *v42;
  _BYTE *v43;
  id Property;
  id v45;
  SEL v46;
  BOOL v47;
  uint64_t v48;
  void *v49;
  int v50;
  _OWORD *Instance;
  HTTPMessage *v52;
  _QWORD *v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t i;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t j;
  HTTPMessage **v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  id obj;
  uint64_t v71;
  std::__shared_weak_count *v72;
  _QWORD v73[2];
  void (*v74)(id *);
  void *v75;
  __int128 v76;
  uint64_t v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  void (**v86)(StringSerializable *__hidden);
  CFTypeRef cf;
  uint8_t buf[136];
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 64);
  v73[0] = MEMORY[0x1E0C809B0];
  v73[1] = 3221225472;
  v74 = ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke_3;
  v75 = &unk_1E14FE1E0;
  v2 = *(_OWORD *)(a1 + 32);
  v76 = v2;
  v77 = *(_QWORD *)(a1 + 48);
  if ((*(_BYTE *)(v1 + 24) & 1) == 0)
  {
    v3 = a1;
    *(_QWORD *)(v1 + 160) = v2;
    v4 = (id)v2;
    if (objc_msgSend(*(id *)(v1 + 160), "hasAttemptedAPSDelivery"))
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v5 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v6 = *(_QWORD *)(v3 + 80);
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v6;
        _os_log_impl(&dword_183ECA000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@ attempted APSP", buf, 0xCu);
      }
      v7 = *(_QWORD *)(v1 + 176);
      if (v7)
        *(_BYTE *)(v7 + 11) = 1;
    }
    else
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v8 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_QWORD *)(v3 + 80);
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v9;
        _os_log_impl(&dword_183ECA000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@ did not attempt APSP", buf, 0xCu);
      }
    }
    if (objc_msgSend(*(id *)(v1 + 160), "deliveryMechanism") == 1)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v10 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v11 = *(_QWORD *)(v3 + 80);
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v11;
        _os_log_impl(&dword_183ECA000, v10, OS_LOG_TYPE_DEFAULT, "%{public}@ arriving via APSP", buf, 0xCu);
      }
      v12 = *(_QWORD *)(v1 + 176);
      if (v12)
        *(_BYTE *)(v12 + 12) = 1;
    }
    else if (objc_msgSend(*(id *)(v1 + 160), "deliveryMechanism") == 2)
    {
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v13 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        v14 = *(_QWORD *)(v3 + 80);
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v14;
        _os_log_impl(&dword_183ECA000, v13, OS_LOG_TYPE_DEFAULT, "%{public}@ arriving via APSF", buf, 0xCu);
      }
    }
    v15 = *(void **)(v3 + 40);
    if (v15 || !*(_QWORD *)(v1 + 160))
    {
      v16 = (void *)objc_msgSend(v15, "domain");
      if (objc_msgSend(v16, "isEqualToString:", *MEMORY[0x1E0CB32E8]))
      {
        *(_QWORD *)(v1 + 80) = _CFStreamErrorFromCFError(*(__CFError **)(v3 + 40));
        *(_QWORD *)(v1 + 88) = v17;
      }
      else
      {
        *(_QWORD *)(v1 + 80) = 15;
        *(_DWORD *)(v1 + 88) = -1004;
      }
    }
    else
    {
      v26 = *(_QWORD *)(v3 + 96);
      Current = CFAbsoluteTimeGetCurrent();
      v28 = *(_QWORD *)(v26 + 176);
      if (v28)
        *(double *)(v28 + 200) = Current;
      v29 = objc_msgSend(*(id *)(v26 + 160), "deliveryMechanism", Current);
      v30 = *(void **)(v26 + 160);
      if (v29 == 1)
      {
        objc_msgSend((id)objc_msgSend(v30, "requestStart"), "timeIntervalSinceReferenceDate");
        v32 = *(_QWORD *)(v26 + 176);
        if (v32)
          *(_QWORD *)(v32 + 176) = v31;
        objc_msgSend((id)objc_msgSend(*(id *)(v26 + 160), "requestEnd"), "timeIntervalSinceReferenceDate");
        v34 = *(_QWORD *)(v26 + 176);
        if (v34)
          *(_QWORD *)(v34 + 184) = v33;
        objc_msgSend((id)objc_msgSend(*(id *)(v26 + 160), "responseReceived"), "timeIntervalSinceReferenceDate");
        v36 = *(_QWORD *)(v26 + 176);
        if (v36)
          *(_QWORD *)(v36 + 192) = v35;
      }
      else if (objc_msgSend(v30, "deliveryMechanism") == 2 && objc_msgSend(*(id *)(v26 + 160), "timingData"))
      {
        v37 = *(_QWORD *)(v26 + 176);
        v38 = (id)objc_msgSend(*(id *)(v26 + 160), "timingData");
        v39 = v38;
        if (v37)
        {
          objc_msgSend(v38, "objectForKeyedSubscript:", CFSTR("_kCFNTimingDataInternalTransactionMetrics"));
          v40 = (void *)objc_claimAutoreleasedReturnValue();
          if (v40)
          {
            objc_msgSend(MEMORY[0x1E0CB3710], "unarchivedObjectOfClass:fromData:error:", objc_opt_class(), v40, 0);
            v41 = (_BYTE *)objc_claimAutoreleasedReturnValue();
            v43 = v41;
            if (v41)
              Property = objc_getProperty(v41, v42, 88, 1);
            else
              Property = 0;
            v45 = Property;
            objc_setProperty_atomic((id)v37, v46, v45, 88);

            if (v43)
            {
              *(_BYTE *)(v37 + 8) = v43[8];
              *(_BYTE *)(v37 + 9) = v43[9];
              *(_QWORD *)(v37 + 96) = *((_QWORD *)v43 + 12);
              *(_QWORD *)(v37 + 104) = *((_QWORD *)v43 + 13);
              *(_QWORD *)(v37 + 112) = *((_QWORD *)v43 + 14);
              *(_QWORD *)(v37 + 120) = *((_QWORD *)v43 + 15);
              *(_QWORD *)(v37 + 128) = *((_QWORD *)v43 + 16);
              *(_QWORD *)(v37 + 136) = *((_QWORD *)v43 + 17);
              *(_QWORD *)(v37 + 176) = *((_QWORD *)v43 + 22);
              *(_QWORD *)(v37 + 184) = *((_QWORD *)v43 + 23);
              *(_QWORD *)(v37 + 192) = *((_QWORD *)v43 + 24);
              *(_QWORD *)(v37 + 200) = *((_QWORD *)v43 + 25);
              v47 = v43[10] != 0;
            }
            else
            {
              v47 = 0;
              *(_WORD *)(v37 + 8) = 0;
              *(_OWORD *)(v37 + 96) = 0u;
              *(_OWORD *)(v37 + 112) = 0u;
              *(_OWORD *)(v37 + 128) = 0u;
              *(_OWORD *)(v37 + 176) = 0u;
              *(_OWORD *)(v37 + 192) = 0u;
            }
            *(_BYTE *)(v37 + 10) = v47;

          }
        }

      }
      v48 = *(_QWORD *)(v3 + 96);
      v49 = *(void **)(v48 + 160);
      if (v49)
      {
        v50 = objc_msgSend((id)objc_msgSend(v49, "responseStatusCode"), "intValue");
        obj = (id)objc_msgSend(*(id *)(v48 + 160), "responseHeaders");
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
        Instance = (_OWORD *)_CFRuntimeCreateInstance();
        v52 = (HTTPMessage *)Instance;
        if (Instance)
        {
          Instance[1] = 0u;
          v52 = (HTTPMessage *)(Instance + 1);
          Instance[18] = 0u;
          Instance[19] = 0u;
          Instance[16] = 0u;
          Instance[17] = 0u;
          Instance[14] = 0u;
          Instance[15] = 0u;
          Instance[12] = 0u;
          Instance[13] = 0u;
          Instance[10] = 0u;
          Instance[11] = 0u;
          Instance[8] = 0u;
          Instance[9] = 0u;
          Instance[6] = 0u;
          Instance[7] = 0u;
          Instance[4] = 0u;
          Instance[5] = 0u;
          Instance[2] = 0u;
          Instance[3] = 0u;
        }
        HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v86, CFSTR("HTTP/1.1"));
        HTTPMessage::HTTPMessage(v52, "httpresponse", cf);
        *(_QWORD *)v52 = &off_1E14E9F38;
        *((_QWORD *)v52 + 1) = &unk_1E14E9FA8;
        *((_QWORD *)v52 + 2) = &unk_1E14E9FC8;
        *((_DWORD *)v52 + 32) = v50;
        *((_QWORD *)v52 + 17) = 0;
        *((_OWORD *)v52 + 10) = 0u;
        *((_OWORD *)v52 + 11) = 0u;
        *((_OWORD *)v52 + 12) = 0u;
        *((_OWORD *)v52 + 13) = 0u;
        *((_OWORD *)v52 + 14) = 0u;
        *((_OWORD *)v52 + 15) = 0u;
        *((_OWORD *)v52 + 16) = 0u;
        *((_OWORD *)v52 + 17) = 0u;
        *((_BYTE *)v52 + 296) = 0;
        *(_QWORD *)buf = v52;
        v53 = (_QWORD *)operator new();
        *v53 = &off_1E14F1710;
        v53[1] = 0;
        v53[2] = 0;
        v53[3] = v52;
        *(_QWORD *)&buf[8] = v53;
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v48 + 128, (__int128 *)buf);
        v54 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v55 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v56 = __ldaxr(v55);
          while (__stlxr(v56 - 1, v55));
          if (!v56)
          {
            ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
            std::__shared_weak_count::__release_weak(v54);
          }
        }
        v86 = &off_1E14E9A00;
        if (cf)
          CFRelease(cf);
        v57 = (void *)objc_msgSend(MEMORY[0x1E0CB37A0], "stringWithCapacity:", 0);
        v84 = 0u;
        v85 = 0u;
        v82 = 0u;
        v83 = 0u;
        v58 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v82, buf, 16);
        v66 = (HTTPMessage **)(v48 + 128);
        v67 = v48;
        v68 = v3;
        v69 = v1;
        if (v58)
        {
          v59 = *(_QWORD *)v83;
          while (2)
          {
            for (i = 0; i != v58; ++i)
            {
              if (*(_QWORD *)v83 != v59)
                objc_enumerationMutation(obj);
              v61 = *(_QWORD *)(*((_QWORD *)&v82 + 1) + 8 * i);
              v62 = (void *)objc_msgSend(obj, "objectForKeyedSubscript:", v61);
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                objc_msgSend(v57, "appendFormat:", CFSTR("%@: %@\r\n"), v61, v62);
              }
              else
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) == 0)
                {
                  v3 = v68;
                  *(_QWORD *)(v67 + 80) = 4;
                  *(_DWORD *)(v67 + 88) = -1;
                  v1 = v69;
                  goto LABEL_29;
                }
                v80 = 0u;
                v81 = 0u;
                v78 = 0u;
                v79 = 0u;
                v63 = objc_msgSend(v62, "countByEnumeratingWithState:objects:count:", &v78, &v86, 16);
                if (v63)
                {
                  v64 = *(_QWORD *)v79;
                  do
                  {
                    for (j = 0; j != v63; ++j)
                    {
                      if (*(_QWORD *)v79 != v64)
                        objc_enumerationMutation(v62);
                      objc_msgSend(v57, "appendFormat:", CFSTR("%@: %@\r\n"), v61, *(_QWORD *)(*((_QWORD *)&v78 + 1) + 8 * j));
                    }
                    v63 = objc_msgSend(v62, "countByEnumeratingWithState:objects:count:", &v78, &v86, 16);
                  }
                  while (v63);
                }
              }
            }
            v58 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v82, buf, 16);
            if (v58)
              continue;
            break;
          }
        }
        objc_msgSend(v57, "appendString:", CFSTR("\r\n"));
        v3 = v68;
        v1 = v69;
        if (HTTPMessage::appendBytes(*v66, (const char *)objc_msgSend(v57, "UTF8String"), objc_msgSend(v57, "lengthOfBytesUsingEncoding:", 4)))
        {
          HTTPMessage::ensureParserFinished(*v66);
          if (objc_msgSend(*(id *)(v67 + 160), "responseBody"))
            *(_QWORD *)(v67 + 144) = objc_msgSend((id)objc_msgSend(*(id *)(v67 + 160), "responseBody"), "_createDispatchData");
        }
        else
        {
          *(_QWORD *)(v67 + 80) = 4;
          *(_DWORD *)(v67 + 88) = -1;
        }
      }
    }
LABEL_29:
    v18 = *(_QWORD *)(v3 + 56);
    v19 = *(std::__shared_weak_count **)(v1 + 136);
    v71 = *(_QWORD *)(v1 + 128);
    v72 = v19;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v21 = __ldxr(p_shared_owners);
      while (__stxr(v21 + 1, p_shared_owners));
    }
    (*(void (**)(uint64_t, uint64_t *, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t))(v18 + 16))(v18, &v71, *(_QWORD *)(v1 + 144), *(_QWORD *)(v1 + 80), *(_QWORD *)(v1 + 88), objc_msgSend(*(id *)(v1 + 160), "sentByteCount"), objc_msgSend(*(id *)(v1 + 160), "receivedByteCount"));
    v22 = v72;
    if (v72)
    {
      v23 = (unint64_t *)&v72->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
  }
  return ((uint64_t (*)(_QWORD *))v74)(v73);
}

void sub_183FD387C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, void (*a20)(char *),uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,CFTypeRef cf)
{
  void *v42;
  void *v43;
  void *v44;
  void *v45;

  a20(&a18);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_80c39_ZTSNSt3__110shared_ptrIK10__CFStringEE96c42_ZTSNSt3__110shared_ptrI14APSRelayEngineEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[11];
  result[10] = a2[10];
  result[11] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[13];
  result[12] = a2[12];
  result[13] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_80c39_ZTSNSt3__110shared_ptrIK10__CFStringEE96c42_ZTSNSt3__110shared_ptrI14APSRelayEngineEE(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 80;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 96);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke_3(id *a1)
{

}

void StringSerializable::~StringSerializable(StringSerializable *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9A00;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9A00;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<HTTPResponseMessage *,Deleter_release<HTTPResponseMessage>,std::allocator<HTTPResponseMessage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void HTTPVersionMixedValue::~HTTPVersionMixedValue(HTTPVersionMixedValue *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9A00;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9A00;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

void sub_183FD3DC0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_183FD3F14(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t _copyPrivateProtocolSchedulingSet(void)
{
  if (_copyPrivateProtocolSchedulingSet(void)::sOnce != -1)
    dispatch_once(&_copyPrivateProtocolSchedulingSet(void)::sOnce, &__block_literal_global_330);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)_copyPrivateProtocolSchedulingSet(void)::sppss + 88))(_copyPrivateProtocolSchedulingSet(void)::sppss);
}

void ___ZL33_copyPrivateProtocolSchedulingSetv_block_invoke()
{
  __CFRunLoop *NewPrivateRunLoopThread;
  _OWORD *v1;
  uint64_t v2;

  NewPrivateRunLoopThread = (__CFRunLoop *)CoreSchedulingSet::createNewPrivateRunLoopThread((uint64_t)"com.apple.CFNetwork.CustomProtocols", 0, 0);
  v1 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 120, 0);
  *v1 = 0u;
  v1[1] = 0u;
  v1[2] = 0u;
  v1[3] = 0u;
  v1[4] = 0u;
  v1[5] = 0u;
  v1[6] = 0u;
  *((_QWORD *)v1 + 14) = 0;
  RunLoopSchedulingSet::RunLoopSchedulingSet((RunLoopSchedulingSet *)v1, NewPrivateRunLoopThread, (const __CFString *)*MEMORY[0x1E0C9B280], "privateloader");
  _copyPrivateProtocolSchedulingSet(void)::sppss = v2;
}

uint64_t ___ZN12XTubeManager27_markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v6[5];

  (*(void (**)(uint64_t))(*(_QWORD *)a3 + 40))(a3);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN12XTubeManager27_markReusedAfterAPSleepWakeEv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e5_v8__0l;
  v6[4] = a3;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a2 + 96))(a2, v6);
}

uint64_t ___ZN12XTubeManager27_markReusedAfterAPSleepWakeEv_block_invoke_2(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD **)(a1 + 32);
  v3 = v2[4];
  if (v3)
  {
    v4 = 0;
    v5 = v3 + 80;
    do
    {
      v6 = *(_QWORD *)(v5 + v4);
      if (v6)
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 144))(v6);
      v4 += 8;
    }
    while (v4 != 24);
    v2 = *(_QWORD **)(a1 + 32);
  }
  return (*(uint64_t (**)(_QWORD *))(*v2 + 48))(v2);
}

uint64_t ___ZN12XTubeManager23logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v6[5];

  (*(void (**)(uint64_t))(*(_QWORD *)a3 + 40))(a3);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN12XTubeManager23logConnectionsAtAPSleepEv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e5_v8__0l;
  v6[4] = a3;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a2 + 96))(a2, v6);
}

uint64_t ___ZN12XTubeManager23logConnectionsAtAPSleepEv_block_invoke_2(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD **)(a1 + 32);
  v3 = v2[4];
  if (v3)
  {
    v4 = 0;
    v5 = v3 + 80;
    do
    {
      v6 = *(_QWORD *)(v5 + v4);
      if (v6)
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 112))(v6);
      v4 += 8;
    }
    while (v4 != 24);
    v2 = *(_QWORD **)(a1 + 32);
  }
  return (*(uint64_t (**)(_QWORD *))(*v2 + 48))(v2);
}

uint64_t RetainableTypedDict<CoreSchedulingSet const*,GlueTubeManager *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA468;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<CoreSchedulingSet const*,GlueTubeManager *>::~RetainableTypedDict(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E14EA468;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  JUMPOUT(0x186DB748CLL);
}

void sub_183FD530C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void ___ZN12XTubeManager25setCurrentSSLMethodForKeyEPK22HTTPConnectionCacheKeyPK10__CFStringPK17CoreSchedulingSet_block_invoke(uint64_t a1, GlueTubeManager *this)
{
  const void *v3;
  const void *v4;
  uint64_t TManager;
  _QWORD *SManager;
  uint64_t v7;
  _QWORD *v8;

  v3 = *(const void **)(a1 + 32);
  v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    TManager = GlueTubeManager::_findOrCreateTManager((uint64_t)this, 0);
    if (v3)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(TManager + 128), v3, v4);
      SManager = GlueTubeManager::_findOrCreateSManager(this);
      CFDictionarySetValue((CFMutableDictionaryRef)SManager[16], v3, v4);
    }
    else
    {
      GlueTubeManager::_findOrCreateSManager(this);
    }
  }
  else
  {
    if (*((_QWORD *)this + 4))
    {
      v7 = GlueTubeManager::_findOrCreateTManager((uint64_t)this, 0);
      if (v3)
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v7 + 128), v3);
    }
    if (*((_QWORD *)this + 5))
    {
      v8 = GlueTubeManager::_findOrCreateSManager(this);
      if (v3)
        CFDictionaryRemoveValue((CFMutableDictionaryRef)v8[16], v3);
    }
  }
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

CFStringRef CFURLProtocol_NS::copyDebugDesc(CFURLProtocol_NS *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%s"), "copyDebugDesc");
}

uint64_t CFURLProtocol_NS::initialize(URLProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3)
{
  __NSCFURLProtocolClient_NS *v5;
  CFURLProtocol_NS *v6;
  CFURLProtocol_NS *v7;
  objc_super v9;

  URLProtocol::initialize(this, a2, a3);
  v5 = [__NSCFURLProtocolClient_NS alloc];
  if (v5)
  {
    v9.receiver = v5;
    v9.super_class = (Class)__NSCFURLProtocolClient_NS;
    v6 = -[URLProtocol init](&v9, sel_init);
    v7 = v6;
    if (v6)
    {
      *((_QWORD *)v6 + 1) = a3;
      (*((void (**)(URLProtocolClient *))a3->var0 + 2))(a3);
      *((_QWORD *)v7 + 2) = this;
      CFRetain((char *)this - 16);
    }
  }
  else
  {
    v7 = 0;
  }
  *((_QWORD *)this + 16) = v7;
  return 1;
}

void CFURLProtocol_NS::forgetProtocolClient(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  int os_unfair_lock_opaque_low;
  uint64_t v4;
  _QWORD v5[5];

  v2 = this + 35;
  os_unfair_lock_lock(this + 35);
  os_unfair_lock_opaque_low = LOBYTE(this[34]._os_unfair_lock_opaque);
  LOBYTE(this[34]._os_unfair_lock_opaque) = 1;
  os_unfair_lock_unlock(v2);
  if (!os_unfair_lock_opaque_low)
  {
    CFRetain(&this[-4]);
    v4 = *(_QWORD *)&this[36]._os_unfair_lock_opaque;
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN16CFURLProtocol_NS20forgetProtocolClientEv_block_invoke;
    v5[3] = &__block_descriptor_40_e5_v8__0l;
    v5[4] = this;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v5);
  }
}

uint64_t CFURLProtocol_NS::_protocolInterface_startLoad(CFURLProtocol_NS *this, CFTypeRef cf)
{
  uint64_t v4;
  _QWORD v6[6];

  if (cf)
    CFRetain(cf);
  CFRetain((char *)this - 16);
  v4 = *((_QWORD *)this + 18);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN16CFURLProtocol_NS28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = this;
  v6[5] = cf;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 96))(v4, v6);
}

uint64_t CFURLProtocol_NS::_protocolInterface_cancelLoad(CFURLProtocol_NS *this)
{
  uint64_t v2;
  _QWORD v4[5];

  CFRetain((char *)this - 16);
  v2 = *((_QWORD *)this + 18);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN16CFURLProtocol_NS29_protocolInterface_cancelLoadEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 96))(v2, v4);
}

uint64_t CFURLProtocol_NS::_protocolInterface_useCredential(CFURLProtocol_NS *this, CFTypeRef cf, CFTypeRef a3)
{
  uint64_t v6;
  _QWORD v8[7];

  if (cf)
    CFRetain(cf);
  if (a3)
    CFRetain(a3);
  CFRetain((char *)this - 16);
  v6 = *((_QWORD *)this + 18);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN16CFURLProtocol_NS32_protocolInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke;
  v8[3] = &__block_descriptor_56_e5_v8__0l;
  v8[4] = this;
  v8[5] = a3;
  v8[6] = cf;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 96))(v6, v8);
}

uint64_t URLProtocol::_protocolInterface_isCachedResponseValidNonBlocking(URLProtocol *this, const _CFCachedURLResponse *a2)
{
  return 0;
}

uint64_t URLProtocol::attemptRedirection(URLProtocol *this, __CFHTTPMessage *a2)
{
  return 0;
}

void `non-virtual thunk to'CFURLProtocol_NS::~CFURLProtocol_NS(CFURLProtocol_NS *this)
{
  CFURLProtocol_NS::~CFURLProtocol_NS((CFURLProtocol_NS *)((char *)this - 8));
}

{
  CFURLProtocol_NS::~CFURLProtocol_NS((CFURLProtocol_NS *)((char *)this - 8));
}

{
  CFURLProtocol_NS::~CFURLProtocol_NS((CFURLProtocol_NS *)((char *)this - 16));
}

{
  CFURLProtocol_NS::~CFURLProtocol_NS((CFURLProtocol_NS *)((char *)this - 16));
}

void CFURLProtocol_NS::~CFURLProtocol_NS(CFURLProtocol_NS *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E14E7EA8;
  *((_QWORD *)this + 1) = &unk_1E14E7FB0;
  *((_QWORD *)this + 2) = &unk_1E14E7FD0;

  v2 = *((_QWORD *)this + 18);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  URLProtocol::~URLProtocol((URLProtocol *)this);
}

void sub_183FD59DC(_Unwind_Exception *a1)
{
  URLProtocol *v1;

  URLProtocol::~URLProtocol(v1);
  _Unwind_Resume(a1);
}

void ___ZN16CFURLProtocol_NS32_protocolInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  const void *v4;
  CFTypeRef v5;
  CFTypeRef v6;
  const void *v7;
  CFTypeRef *v8;
  uint64_t v9;
  void *v10;
  const void *v11;

  v2 = a1[4];
  v3 = *(_QWORD **)(v2 + 128);
  if (!v3)
    goto LABEL_10;
  objc_sync_enter(*(id *)(v2 + 128));
  v4 = (const void *)v3[4];
  if (!v4)
  {
    objc_sync_exit(v3);
    goto LABEL_10;
  }
  v5 = CFRetain(v4);
  objc_sync_exit(v3);
  if (!v5)
  {
LABEL_10:
    v8 = (CFTypeRef *)(a1 + 5);
    goto LABEL_11;
  }
  v6 = CFAutorelease(v5);
  v8 = (CFTypeRef *)(a1 + 5);
  v7 = (const void *)a1[5];
  if (v7 && v6 && CFEqual(v7, v6))
  {
    v9 = a1[6];
    v10 = (void *)objc_msgSend(-[__NSCFURLProtocolClient_NS challenge](*(id **)(v2 + 128)), "sender");
    if (v9)
      objc_msgSend(v10, "useCredential:forAuthenticationChallenge:", -[NSURLCredential _initWithCFURLCredential:]([NSURLCredential alloc], "_initWithCFURLCredential:", a1[6]), -[__NSCFURLProtocolClient_NS challenge](*(id **)(v2 + 128)));
    else
      objc_msgSend(v10, "performDefaultHandlingForAuthenticationChallenge:", -[__NSCFURLProtocolClient_NS challenge](*(id **)(v2 + 128)));
  }
LABEL_11:
  v11 = (const void *)a1[6];
  if (v11)
    CFRelease(v11);
  if (*v8)
    CFRelease(*v8);
  CFRelease((CFTypeRef)(v2 - 16));
}

void sub_183FD5B00(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void ___ZN16CFURLProtocol_NS29_protocolInterface_cancelLoadEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(v1 + 120);
  if (v2)
  {
    objc_msgSend(v2, "stopLoading");

    *(_QWORD *)(v1 + 120) = 0;
  }
  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN16CFURLProtocol_NS28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke(uint64_t a1)
{
  uint64_t v1;
  id v3;
  void *v4;
  char isKindOfClass;
  void *v6;
  uint64_t v7;
  const void *v8;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v1 + 120))
    __assert_rtn("_protocolInterface_startLoad_block_invoke", "LocalSession.mm", 1917, "_protocolInstance == nil");
  if (*(_QWORD *)(a1 + 40))
    v3 = -[NSCachedURLResponse _initWithCFCachedURLResponse:]([NSCachedURLResponse alloc], "_initWithCFCachedURLResponse:", *(_QWORD *)(a1 + 40));
  else
    v3 = 0;
  v4 = *(void **)(v1 + 80);
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();
  v6 = (void *)objc_msgSend(*(id *)(v1 + 112), "alloc");
  if ((isKindOfClass & 1) != 0)
    v7 = objc_msgSend(v6, "initWithRequest:cachedResponse:client:", objc_msgSend(v4, "currentRequest"), v3, *(_QWORD *)(v1 + 128));
  else
    v7 = objc_msgSend(v6, "initWithTask:cachedResponse:client:", v4, v3, *(_QWORD *)(v1 + 128));
  *(_QWORD *)(v1 + 120) = v7;

  objc_msgSend(*(id *)(v1 + 120), "startLoading");
  v8 = *(const void **)(a1 + 40);
  if (v8)
    CFRelease(v8);
  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN16CFURLProtocol_NS20forgetProtocolClientEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  void *v4;
  _QWORD v5[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(v1 + 128);
  if (v2)
  {
    v3 = MEMORY[0x1E0C809B0];
    *(_QWORD *)(v1 + 128) = 0;
    v5[0] = v3;
    v5[1] = 3221225472;
    v5[2] = __38____NSCFURLProtocolClient_NS_teardown__block_invoke;
    v5[3] = &unk_1E14FE118;
    v5[4] = v2;
    -[__NSCFURLProtocolClient_NS withCustomProtocolScheduling:](v2, (uint64_t)v5);

  }
  v4 = *(void **)(v1 + 120);
  *(_QWORD *)(v1 + 120) = 0;
  if (v4)
  {
    objc_msgSend(v4, "stopLoading");

  }
  URLProtocol::forgetProtocolClient((URLProtocol *)v1);
  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke()
{
  CFClass *v0;

  v0 = (CFClass *)operator new();
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(_QWORD *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_183FD5D48(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void sub_183FD6270(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FD64C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183FD65FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_183FD66F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FD689C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FD6AC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183FD6BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_183FD6CC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FD6DD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FD6EE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_183FD6FA8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FD71D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FD72EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_183FD74B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FD75DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_183FD769C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FD775C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FD7838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_183FD78FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FD7A10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FD7BCC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FD7CE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_183FD7DAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183FD7F70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FD80F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FD82BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183FD8574(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_183FD8774(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_183FD897C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FD8B60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FD8D1C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FD8F0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FD9118(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FD9288(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FD9474(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_183FD9650(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183FD9808(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183FD99D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void HTTP2Diagnostic::LOG_FRAME(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  void (*v8)(uint64_t, const char *, const __CFString *);
  const char *v9;
  const __CFString *v10;
  uint64_t v11;
  unint64_t v12;
  std::string::size_type v13;
  uint64_t v14;
  std::string::size_type size;
  std::string *v16;
  std::string::size_type v17;
  unsigned int v18;
  const std::string::value_type *v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  std::string *p_p;
  std::string::size_type v25;
  std::string *v26;
  std::string::size_type v27;
  uint64_t i;
  std::string::size_type v29;
  const std::ios_base *v30;
  const std::locale::facet *v31;
  std::string::size_type v32;
  unsigned int v33;
  int v34;
  int v35;
  unsigned int v36;
  char *v37;
  std::string::size_type v38;
  char v39;
  std::string::size_type v40;
  std::string::size_type v41;
  std::string::size_type v42;
  std::string *v43;
  std::string::size_type v44;
  BOOL v45;
  void *v46;
  void *v47;
  std::string::size_type v48;
  std::string::size_type v49;
  uint64_t v50;
  std::string v51;
  std::string v52;
  std::string v53;
  std::string __p;
  std::string v55;
  _QWORD v56[8];
  void *v57;
  char v58;
  _BYTE v59[160];

  if (a5)
    (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72))(a1, "h2     ", CFSTR("[%llu] %s %s frame<length=%ld, flags=0x%x, stream_id=%d> error_code=%d"));
  else
    (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72))(a1, "h2     ", CFSTR("[%llu] %s %s frame<length=%ld, flags=0x%x, stream_id=%d>"));
  switch(*(_BYTE *)(a2 + 12))
  {
    case 1:
      v8 = *(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72);
      goto LABEL_7;
    case 2:
      v8 = *(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72);
LABEL_7:
      v9 = "h2 prio";
      v10 = CFSTR("[%llu] (dep_stream_id=%d, weight=%d, exclusive=%d)");
      goto LABEL_63;
    case 3:
      nghttp2_strerror();
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72))(a1, "h2 rsts", CFSTR("[%llu] (error_code=%s(%d))"));
      goto LABEL_66;
    case 4:
      if ((*(_BYTE *)(a2 + 13) & 1) != 0)
        goto LABEL_66;
      memset(&v51, 0, sizeof(v51));
      if (!*(_QWORD *)(a2 + 16))
        goto LABEL_66;
      v11 = 0;
      v12 = 0;
      v13 = *MEMORY[0x1E0DE4F50];
      v48 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
      v49 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
      v14 = MEMORY[0x1E0DE4FB8] + 16;
      do
      {
        size = HIBYTE(v51.__r_.__value_.__r.__words[2]);
        if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          size = v51.__r_.__value_.__l.__size_;
        if (size)
          std::string::append(&v51, "\n");
        std::string::append(&v51, "[");
        std::to_string(&v55, a4);
        if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v16 = &v55;
        else
          v16 = (std::string *)v55.__r_.__value_.__r.__words[0];
        if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v17 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
        else
          v17 = v55.__r_.__value_.__l.__size_;
        std::string::append(&v51, (const std::string::value_type *)v16, v17);
        if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v55.__r_.__value_.__l.__data_);
        std::string::append(&v51, "] [");
        v18 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + v11) - 1;
        v19 = "UNKNOWN";
        if (v18 <= 5)
          v19 = off_1E14F6608[v18];
        std::string::append(&v51, v19);
        std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)&v55);
        *(_DWORD *)((char *)v56 + *(_QWORD *)(v55.__r_.__value_.__r.__words[2] - 24)) = *(_DWORD *)((_BYTE *)v56
                                                                                                  + *(_QWORD *)(v55.__r_.__value_.__r.__words[2] - 24)) & 0xFFFFFFB5 | 8;
        std::ostream::operator<<();
        std::stringbuf::str();
        v20 = std::string::insert(&v52, 0, "(0x");
        v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
        v53.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v21;
        v20->__r_.__value_.__l.__size_ = 0;
        v20->__r_.__value_.__r.__words[2] = 0;
        v20->__r_.__value_.__r.__words[0] = 0;
        v22 = std::string::append(&v53, "):");
        v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v23;
        v22->__r_.__value_.__l.__size_ = 0;
        v22->__r_.__value_.__r.__words[2] = 0;
        v22->__r_.__value_.__r.__words[0] = 0;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v25 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v25 = __p.__r_.__value_.__l.__size_;
        std::string::append(&v51, (const std::string::value_type *)p_p, v25);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v53.__r_.__value_.__l.__data_);
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v52.__r_.__value_.__l.__data_);
        std::to_string(&__p, *(_DWORD *)(*(_QWORD *)(a2 + 24) + v11 + 4));
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = &__p;
        else
          v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v27 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v27 = __p.__r_.__value_.__l.__size_;
        std::string::append(&v51, (const std::string::value_type *)v26, v27);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        std::string::append(&v51, "]");
        v55.__r_.__value_.__r.__words[0] = v13;
        *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words + *(_QWORD *)(v13 - 24)) = v49;
        v55.__r_.__value_.__r.__words[2] = v48;
        v56[0] = v14;
        if (v58 < 0)
          operator delete(v57);
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x186DB7438](v59);
        ++v12;
        v11 += 8;
      }
      while (*(_QWORD *)(a2 + 16) > v12);
      if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
      {
        v47 = (void *)v51.__r_.__value_.__r.__words[0];
        if (!v51.__r_.__value_.__l.__size_)
          goto LABEL_115;
      }
      else if (!*((_BYTE *)&v51.__r_.__value_.__s + 23))
      {
        goto LABEL_66;
      }
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72))(a1, "h2 stgs", CFSTR("%s"));
      if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_66;
      v47 = (void *)v51.__r_.__value_.__r.__words[0];
LABEL_115:
      operator delete(v47);
LABEL_66:
      v33 = *(unsigned __int8 *)(a2 + 13);
      if (!*(_BYTE *)(a2 + 13))
        return;
      v50 = a1;
      v34 = *(unsigned __int8 *)(a2 + 12);
      v35 = 1;
      memset(&__p, 0, sizeof(__p));
      v36 = v33;
      do
      {
        if ((v35 & v33) != 0)
        {
          if ((v34 & 0xFFFFFFFD) == 4)
          {
            if ((v35 & v33 & 1) != 0)
              v37 = "ACK";
            else
              v37 = 0;
          }
          else
          {
            v37 = 0;
            switch(v34)
            {
              case 0:
                v37 = "END_STREAM";
                if ((v35 & v33 & 1) == 0)
                  goto LABEL_77;
                break;
              case 1:
                v37 = "END_STREAM";
                if ((v35 & v33 & 1) == 0)
                {
                  v37 = "END_HEADERS";
                  if ((v35 & v33 & 4) == 0)
                  {
                    v37 = "PADDED";
                    if ((v35 & v33 & 8) == 0)
                    {
                      v37 = "PRIORITY";
                      if ((v35 & v33 & 0x20) == 0)
                        goto LABEL_103;
                    }
                  }
                }
                break;
              case 5:
                v37 = "END_HEADERS";
                if ((v35 & v33 & 4) == 0)
                {
LABEL_77:
                  v37 = "PADDED";
                  if ((v35 & v33 & 8) == 0)
                    goto LABEL_103;
                }
                break;
              case 9:
                v37 = "END_HEADERS";
                if ((v35 & v33 & 4) == 0)
LABEL_103:
                  v37 = 0;
                break;
              default:
                break;
            }
          }
          std::string::basic_string[abi:nn180100]<0>(&v55, v37);
          v38 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
          v39 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
          v40 = v55.__r_.__value_.__l.__size_;
          if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v41 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
          else
            v41 = v55.__r_.__value_.__l.__size_;
          if (v41)
          {
            v42 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v42 = __p.__r_.__value_.__l.__size_;
            if (v42)
            {
              std::string::append(&__p, " | ");
              v38 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
              v40 = v55.__r_.__value_.__l.__size_;
              v39 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
            }
            if (v39 >= 0)
              v43 = &v55;
            else
              v43 = (std::string *)v55.__r_.__value_.__r.__words[0];
            if (v39 >= 0)
              v44 = v38;
            else
              v44 = v40;
            std::string::append(&__p, (const std::string::value_type *)v43, v44);
            v39 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
          }
          if (v39 < 0)
            operator delete(v55.__r_.__value_.__l.__data_);
        }
        v35 = 2 * v35;
        v45 = v36 > 1;
        v36 >>= 1;
      }
      while (v45);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        v46 = (void *)__p.__r_.__value_.__r.__words[0];
        if (!__p.__r_.__value_.__l.__size_)
          goto LABEL_110;
      }
      else if (!*((_BYTE *)&__p.__r_.__value_.__s + 23))
      {
        return;
      }
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)v50 + 72))(v50, "h2 flgs", CFSTR("[%llu] %s"));
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        return;
      v46 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_110:
      operator delete(v46);
      return;
    case 5:
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72))(a1, "h2 pshp", CFSTR("[%llu] (padlen=%zu, promised_stream_id=%d)"));
      goto LABEL_66;
    case 6:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)&v55);
      for (i = 0; i != 8; ++i)
      {
        v29 = v55.__r_.__value_.__r.__words[2];
        *(_QWORD *)((char *)&v56[2] + *(_QWORD *)(v55.__r_.__value_.__r.__words[2] - 24)) = 2;
        v30 = (const std::ios_base *)((char *)&v55.__r_.__value_.__r.__words[2] + *(_QWORD *)(v29 - 24));
        if (v30[1].__fmtflags_ == -1)
        {
          std::ios_base::getloc(v30);
          v31 = std::locale::use_facet((const std::locale *)&__p, MEMORY[0x1E0DE4A90]);
          ((void (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 32);
          std::locale::~locale((std::locale *)&__p);
          v29 = v55.__r_.__value_.__r.__words[2];
        }
        v30[1].__fmtflags_ = 48;
        *(_DWORD *)((char *)v56 + *(_QWORD *)(v29 - 24)) = *(_DWORD *)((_BYTE *)v56 + *(_QWORD *)(v29 - 24)) & 0xFFFFFFB5 | 8;
        std::ostream::operator<<();
      }
      std::stringbuf::str();
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72))(a1, "h2 ping", CFSTR("[%llu] (opaque_data=%s)"));
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v55.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0DE4F50];
      v32 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
      *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words
                                + *(_QWORD *)(v55.__r_.__value_.__r.__words[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50]
                                                                                                  + 64);
      v55.__r_.__value_.__r.__words[2] = v32;
      v56[0] = MEMORY[0x1E0DE4FB8] + 16;
      if (v58 < 0)
        operator delete(v57);
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x186DB7438](v59);
      goto LABEL_66;
    case 7:
      nghttp2_strerror();
      v8 = *(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72);
      v9 = "h2 gowy";
      v10 = CFSTR("[%llu] (last_stream_id=%d, error_code=%s(%d), opaque_data_len=%zu)");
LABEL_63:
      v8(a1, v9, v10);
      goto LABEL_66;
    case 8:
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(_QWORD *)a1 + 72))(a1, "h2 updt", CFSTR("[%llu] (window_size_increment=%d)"));
      goto LABEL_66;
    default:
      goto LABEL_66;
  }
}

void sub_183FDA350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,std::locale a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (a26 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = MEMORY[0x1E0DE4FD0];
  v3 = MEMORY[0x1E0DE4FD0] + 104;
  *(_QWORD *)(a1 + 128) = MEMORY[0x1E0DE4FD0] + 104;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  v4 = a1 + 16;
  v5 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + *(_QWORD *)(v6 - 24)) = v7;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v9 = v5[4];
  v10 = v5[5];
  *(_QWORD *)(a1 + 16) = v9;
  *(_QWORD *)(v4 + *(_QWORD *)(v9 - 24)) = v10;
  v11 = v5[1];
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + *(_QWORD *)(v11 - 24)) = v5[6];
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 128) = v3;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 24) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_183FDA574(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::iostream::~basic_iostream();
  MEMORY[0x186DB7438](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = MEMORY[0x1E0DE4F50];
  v3 = *MEMORY[0x1E0DE4F50];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F50];
  v4 = *(_QWORD *)(v2 + 72);
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 64);
  *(_QWORD *)(a1 + 24) = MEMORY[0x1E0DE4FB8] + 16;
  *(_QWORD *)(a1 + 16) = v4;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x186DB7438](a1 + 128);
  return a1;
}

_QWORD *std::string::basic_string[abi:nn180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

uint64_t ___Z33cf_nghttp2_on_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 53;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t cf_nghttp2_on_invalid_frame_recv_callback(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_5, 2);
  if (v7)
  {
    v8 = v7;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v7 + 16))(v7, "h2 frame", 0))
    {
      HTTP2Diagnostic::LOG_FRAME(v8, a2, 2, *(_QWORD *)(a4 + 72), a3);
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    }
  }
  return 0;
}

uint64_t ___Z41cf_nghttp2_on_invalid_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_frameiPv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 88;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

void HTTP2ServerPushStream::safe_data_deleter(dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
}

void ___ZN15HTTP2Connection31submitWindowUpdateForPushStreamEii_block_invoke(uint64_t a1)
{
  HTTP2Connection *v1;
  int v2;
  int v3;
  NSObject *v4;
  const __CFString *v5;
  int v6;
  char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v1 = *(HTTP2Connection **)(a1 + 32);
  if (*((_QWORD *)v1 + 20))
  {
    v2 = nghttp2_submit_window_update();
    if (v2 < 0)
    {
      v3 = v2;
      if (CFNLog::onceToken != -1)
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
      v4 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v5 = (const __CFString *)(*(uint64_t (**)(HTTP2Connection *))(*(_QWORD *)v1 + 24))(v1);
        v6 = 136315394;
        v7 = _cfnAutoreleaseInDebug(v5);
        v8 = 1024;
        v9 = v3;
        _os_log_error_impl(&dword_183ECA000, v4, OS_LOG_TYPE_ERROR, "Could not submit window update on [%s], error code: %d", (uint8_t *)&v6, 0x12u);
      }
    }
    HTTP2Connection::_onqueue_scheduleIO(v1);
  }
  CFRelease((char *)v1 - 16);
}

_QWORD *std::string::basic_string[abi:nn180100](_QWORD *__dst, void *__src, size_t __len)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v6 = __dst;
    if (!__len)
      goto LABEL_9;
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

uint64_t ___Z33cf_nghttp2_on_frame_send_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 215;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t ___Z33cf_nghttp2_on_frame_send_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 194;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t cf_nghttp2_on_frame_not_send_callback(int a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t stream_user_data;
  std::__shared_weak_count *v12;
  HTTP2Stream *v13;
  HTTP2Stream *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  HTTP2Stream *v21;
  HTTP2Stream *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;

  v8 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_9, 2);
  if (v8)
  {
    v9 = v8;
    if ((*(unsigned int (**)(uint64_t, const char *, _QWORD))(*(_QWORD *)v8 + 16))(v8, "h2 frame", 0))
    {
      HTTP2Diagnostic::LOG_FRAME(v9, a2, 3, *(_QWORD *)(a4 + 72), a3);
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    }
  }
  v10 = *(unsigned __int8 *)(a2 + 12);
  if (a3 == -522 && v10 == 1)
  {
    stream_user_data = nghttp2_session_get_stream_user_data();
    if (stream_user_data)
    {
      v13 = *(HTTP2Stream **)stream_user_data;
      v12 = *(std::__shared_weak_count **)(stream_user_data + 8);
      v14 = *(HTTP2Stream **)stream_user_data;
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v16 = __ldxr(p_shared_owners);
        while (__stxr(v16 + 1, p_shared_owners));
        v14 = *(HTTP2Stream **)stream_user_data;
      }
      HTTP2Connection::flushBatchedDataForStream((uint64_t **)a4, v14);
      HTTP2Stream::cleanUpInUserDataResetCallback(v13, a1, *(_DWORD *)(a2 + 8), (HTTP2Connection *)6, a4);
      if (v12)
      {
        v17 = (unint64_t *)&v12->__shared_owners_;
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
    }
    v10 = *(unsigned __int8 *)(a2 + 12);
  }
  if (v10 == 3)
  {
    v19 = nghttp2_session_get_stream_user_data();
    if (v19)
    {
      v21 = *(HTTP2Stream **)v19;
      v20 = *(std::__shared_weak_count **)(v19 + 8);
      v22 = *(HTTP2Stream **)v19;
      if (v20)
      {
        v23 = (unint64_t *)&v20->__shared_owners_;
        do
          v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
        v22 = *(HTTP2Stream **)v19;
      }
      HTTP2Connection::flushBatchedDataForStream((uint64_t **)a4, v22);
      HTTP2Stream::cleanUpInUserDataResetCallback(v21, a1, *(_DWORD *)(a2 + 8), (HTTP2Connection *)*(unsigned int *)(a2 + 16), a4);
      if (v20)
      {
        v25 = (unint64_t *)&v20->__shared_owners_;
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
    }
  }
  return 0;
}

void sub_183FDAC84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t ___Z37cf_nghttp2_on_frame_not_send_callbackP15nghttp2_sessionPK13nghttp2_frameiPv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(_QWORD *)(a1 + 16) = "CFNetwork.f";
  *(_QWORD *)(a1 + 24) = "CFNetwork";
  *(_QWORD *)(a1 + 32) = 248;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = "none";
  return result;
}

uint64_t cf_nghttp2_on_invalid_header_callback(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (a4 == 4 && *a3 == 1953722216 && nghttp2_check_header_value())
    return 0;
  else
    return 4294966775;
}

uint64_t cf_nghttp2_error_callback2(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v8;
  uint64_t v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (CFNLog::onceToken != -1)
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
  v8 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    v10 = *(_QWORD *)(a5 + 72);
    v11 = 134218498;
    v12 = v10;
    v13 = 1024;
    v14 = a2;
    v15 = 2080;
    v16 = a3;
    _os_log_error_impl(&dword_183ECA000, v8, OS_LOG_TYPE_ERROR, "HTTP/2 error encountered on Connection %llu (Code %d): %s", (uint8_t *)&v11, 0x1Cu);
  }
  return 0;
}

double CFNA::_CFNetworkAgentGetTTL(CFNA *this)
{
  char *v1;

  v1 = getenv("CFNETWORKAGENT_TTL");
  if (v1)
    return (double)strtol(v1, 0, 10);
  else
    return 86400.0;
}

const __CFString *CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore(CFNA *this, const __CFString *a2, const char *a3)
{
  const __CFAllocator *v5;
  char *v6;
  const char *v7;
  CFStringRef v8;
  CFStringRef v9;
  CFStringRef v10;
  CFStringRef v11;
  const __CFArray *v12;
  CFStringRef v13;
  const __CFString *v14;
  const __CFArray *Value;
  const __CFArray *v16;
  const __CFString *ValueAtIndex;
  const __CFString *v18;
  double Current;
  double v20;
  CFNA *v21;
  const __CFString *v22;
  const __CFString *v23;
  const __SCDynamicStore *v24;
  const __SCDynamicStore *v25;
  const __CFArray *v26;
  const __CFArray *v27;
  const __CFString *v28;
  const __CFArray *v29;
  const __CFArray *v30;
  double v31;
  double v32;
  CFNA *v33;
  const __CFString *v35;
  SCDynamicStoreContext context;
  void *values[3];

  values[2] = *(void **)MEMORY[0x1E0C80C00];
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!CFNA::sQueryResultsCache)
    CFNA::sQueryResultsCache = (uint64_t)CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v6 = getenv("CFNETWORKAGENT_KEY_SPACE_ROOT");
  if (v6)
    v7 = v6;
  else
    v7 = "com.apple.CFNetwork.netcompat";
  v8 = CFStringCreateWithCString(v5, v7, 0x600u);
  if (v8)
  {
    v9 = v8;
    v10 = CFStringCreateWithFormat(v5, 0, CFSTR("%@.%s"), v8, a2);
    if (v10)
    {
      v11 = v10;
      values[0] = (void *)v10;
      values[1] = this;
      v12 = CFArrayCreate(v5, (const void **)values, 2, MEMORY[0x1E0C9B378]);
      CFRelease(v11);
      CFRelease(v9);
      if (v12)
      {
        v13 = CFStringCreateByCombiningStrings(v5, v12, CFSTR(":"));
        if (!v13)
        {
          v23 = 0;
LABEL_34:
          CFRelease(v12);
          return v23;
        }
        v14 = v13;
        Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)CFNA::sQueryResultsCache, v13);
        if (Value)
        {
          v16 = Value;
          if (CFArrayGetCount(Value) == 2)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v16, 1);
            if (ValueAtIndex)
            {
              v18 = ValueAtIndex;
              Current = CFAbsoluteTimeGetCurrent();
              v20 = Current - CFStringGetDoubleValue(v18);
              if (v20 <= CFNA::_CFNetworkAgentGetTTL(v21))
              {
                v22 = (const __CFString *)CFArrayGetValueAtIndex(v16, 0);
                v23 = v22;
                if (v22)
                  CFRetain(v22);
                goto LABEL_33;
              }
            }
          }
          goto LABEL_28;
        }
        memset(&context, 0, sizeof(context));
        v24 = SCDynamicStoreCreate(v5, CFSTR("CFNETWORK_AGENT__STORE__"), 0, &context);
        if (!v24)
        {
LABEL_28:
          v23 = 0;
LABEL_33:
          CFRelease(v14);
          goto LABEL_34;
        }
        v25 = v24;
        v26 = SCDynamicStoreCopyKeyList(v24, v14);
        if (!v26)
        {
          v23 = 0;
          goto LABEL_32;
        }
        v27 = v26;
        if (CFArrayGetCount(v26) < 1
          || (v28 = (const __CFString *)CFArrayGetValueAtIndex(v27, 0),
              (v29 = (const __CFArray *)SCDynamicStoreCopyValue(v25, v28)) == 0))
        {
          v23 = 0;
          goto LABEL_30;
        }
        v30 = v29;
        if (CFArrayGetCount(v29) == 2)
        {
          v23 = (const __CFString *)CFArrayGetValueAtIndex(v30, 1);
          if (!v23)
          {
LABEL_27:
            CFRelease(v30);
LABEL_30:
            CFRelease(v27);
LABEL_32:
            CFRelease(v25);
            goto LABEL_33;
          }
          v31 = CFAbsoluteTimeGetCurrent();
          v32 = v31 - CFStringGetDoubleValue(v23);
          if (v32 <= CFNA::_CFNetworkAgentGetTTL(v33))
          {
            v35 = (const __CFString *)CFArrayGetValueAtIndex(v30, 0);
            v23 = v35;
            if (v35)
              CFRetain(v35);
            CFDictionarySetValue((CFMutableDictionaryRef)CFNA::sQueryResultsCache, v14, v30);
            goto LABEL_27;
          }
        }
        v23 = 0;
        goto LABEL_27;
      }
    }
    else
    {
      CFRelease(v9);
    }
  }
  return 0;
}

__n128 __Block_byref_object_copy__131(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__132(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

CFTypeRef std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>(_QWORD *a1, const void *a2)
{
  _QWORD *v4;
  CFTypeRef result;

  v4 = operator new(0x48uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_1E14F0948;
  v4[3] = &off_1E14E6B30;
  *((_WORD *)v4 + 28) = 0;
  if (a2)
    result = CFRetain(a2);
  else
    result = 0;
  v4[5] = 0;
  v4[6] = 0;
  v4[4] = result;
  *a1 = v4 + 3;
  a1[1] = v4;
  return result;
}

void sub_183FDB200(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  v1[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E14E5838;
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<CFNetworkTrust>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0948;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<CFNetworkTrust>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0948;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void __performStrictTrustEvaluationAsync_block_invoke(uint64_t a1, int a2)
{
  NSObject *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  if (a2)
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v3 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v7) = 0;
      _os_log_error_impl(&dword_183ECA000, v3, OS_LOG_TYPE_ERROR, "StrictTrustEvaluate failed", (uint8_t *)&v7, 2u);
    }
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v7 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48, &v7);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
  if (*((_QWORD *)&v7 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL HTTPRequestParserClient::completeFirstLine(HTTPRequestParserClient *this, const UInt8 *a2, uint64_t a3)
{
  const char *v6;
  uint64_t v7;
  const UInt8 *v8;
  unsigned int v9;
  _BOOL8 result;
  const char *v11;
  const char *v12;
  unsigned int v13;
  int v14;
  const char *v15;
  unsigned int v16;
  unsigned int v17;
  const UInt8 *v18;
  const UInt8 *v19;
  unsigned int v20;
  unsigned int v21;
  const char *v22;
  CFIndex v23;
  const __CFAllocator *v24;
  uint64_t v25;
  char *v26;
  _QWORD v27[3];
  const UInt8 *v28;
  const UInt8 *v29;
  const char *v30;

  if ((*((_QWORD *)this + 3)
     || *(_QWORD *)((*(uint64_t (**)(HTTPRequestParserClient *))(*(_QWORD *)this + 32))(this) + 8))
    && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v27[0]) = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "shouldn't be", (uint8_t *)v27, 2u);
  }
  v6 = (const char *)&a2[a3];
  v28 = 0;
  v27[0] = a2;
  v30 = (const char *)&a2[a3];
  if (a3 < 1)
    return 0;
  v7 = MEMORY[0x1E0C80978];
  v8 = a2;
  while (1)
  {
    v9 = *(char *)v8;
    if ((v9 & 0x80000000) != 0)
      break;
    if ((*(_DWORD *)(v7 + 4 * v9 + 60) & 0x4000) != 0)
      goto LABEL_14;
LABEL_11:
    if (++v8 >= (const UInt8 *)v6)
      return 0;
  }
  if (!__maskrune(v9, 0x4000uLL))
    goto LABEL_11;
LABEL_14:
  v27[1] = v8;
  v11 = (const char *)(v8 + 1);
  while (v11 < v6)
  {
    v12 = v11;
    v13 = *v11;
    if ((v13 & 0x80000000) != 0)
      v14 = __maskrune(v13, 0x4000uLL);
    else
      v14 = *(_DWORD *)(v7 + 4 * v13 + 60) & 0x4000;
    v11 = v12 + 1;
    if (!v14)
    {
      v27[2] = v12;
      v15 = v6;
      while (v15 > v12)
      {
        v17 = *--v15;
        v16 = v17;
        if ((v17 & 0x80000000) != 0)
        {
          if (__maskrune(v16, 0x4000uLL))
          {
LABEL_26:
            v18 = (const UInt8 *)(v15 + 1);
            v29 = v18;
            v19 = v18;
            while (v19 > (const UInt8 *)v12)
            {
              v21 = *(char *)--v19;
              v20 = v21;
              if ((v21 & 0x80000000) != 0)
              {
                if (!__maskrune(v20, 0x4000uLL))
                {
LABEL_32:
                  v22 = (const char *)(v19 + 1);
                  v28 = v19 + 1;
                  result = FirstLineFieldsBase::checkFields((uint64_t)v27, 3, (unint64_t)a2, (unint64_t)v6);
                  if ((_DWORD)result)
                  {
                    v23 = v8 - a2;
                    v24 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                    *((_QWORD *)this + 3) = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, v23, 0x201u, 0);
                    v25 = (*(uint64_t (**)(HTTPRequestParserClient *))(*(_QWORD *)this + 32))(this);
                    *(_QWORD *)(v25 + 8) = CFStringCreateWithBytes(v24, v18, v6 - (const char *)v18, 0x201u, 0);
                    if (v22 == v12)
                      v26 = 0;
                    else
                      v26 = strndup(v12, v22 - v12);
                    *((_QWORD *)this + 4) = v26;
                    return v26 != 0;
                  }
                  return result;
                }
              }
              else if ((*(_DWORD *)(v7 + 4 * v20 + 60) & 0x4000) == 0)
              {
                goto LABEL_32;
              }
            }
            return 0;
          }
        }
        else if ((*(_DWORD *)(v7 + 4 * v16 + 60) & 0x4000) != 0)
        {
          goto LABEL_26;
        }
      }
      return 0;
    }
  }
  return 0;
}

void HTTPRequestParserClient::addHeader(HTTPRequestParserClient *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  uint64_t v5;

  v5 = (*(uint64_t (**)(HTTPRequestParserClient *))(*(_QWORD *)this + 40))(this);
  HTTPHeaderDict::addValue(v5, (uint64_t)a2, (uint64_t)a3);
}

void HTTPRequestParserClient::HTTPRequestParserClient(HTTPRequestParserClient *this, CFTypeRef cf)
{
  CFTypeRef v3;

  *(_QWORD *)this = off_1E14ECB28;
  *((_QWORD *)this + 2) = &off_1E14EB4B8;
  *((_QWORD *)this + 3) = 0;
  if (cf)
    v3 = CFRetain(cf);
  else
    v3 = 0;
  *((_QWORD *)this + 1) = v3;
  *((_QWORD *)this + 4) = 0;
}

void sub_183FDB648(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;

  *(_QWORD *)(v1 + 16) = &off_1E14E9A00;
  v3 = *(const void **)(v1 + 24);
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

void HTTPMethodMixedValue::~HTTPMethodMixedValue(HTTPMethodMixedValue *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9A00;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9A00;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

void HTTPHeaderKeyMixedValue::~HTTPHeaderKeyMixedValue(HTTPHeaderKeyMixedValue *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9A00;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E14E9A00;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x186DB748CLL);
}

void sub_183FDC13C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void (*a18)(char *))
{
  a18(&a16);
  _Unwind_Resume(a1);
}

void sub_183FDC3E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,void (*a23)(char *))
{
  a23(&a21);
  _Unwind_Resume(a1);
}

void CoreStreamImplementation::_streamImpl_Read(CoreStreamImplementation *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  abort();
}

void CoreStreamImplementation::_streamImpl_CanRead(CoreStreamImplementation *this)
{
  abort();
}

void CoreStreamImplementation::_streamImpl_Write(CoreStreamImplementation *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  abort();
}

void CoreStreamImplementation::_streamImpl_CanWrite(CoreStreamImplementation *this)
{
  abort();
}

uint64_t CoreStreamImplementation::_streamImpl_workQueue(CoreStreamImplementation *this)
{
  return 0;
}

void CoreStreamImplementation::_streamImpl_openAsync()
{
  abort();
}

void CoreStreamImplementation::_streamImpl_UpdateScheduling(CoreStreamImplementation *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  void (*v5)(_QWORD, _QWORD, _QWORD);
  void (*v6[5])(_QWORD, _QWORD, _QWORD);
  void (*v7[5])(_QWORD, _QWORD, _QWORD);

  v5 = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  v7[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
  v7[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
  v7[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke;
  v7[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v7[4] = (void (*)(_QWORD, _QWORD, _QWORD))this;
  CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)a2, v7);
  v6[0] = v5;
  v6[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
  v6[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke_2;
  v6[3] = (void (*)(_QWORD, _QWORD, _QWORD))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v6[4] = (void (*)(_QWORD, _QWORD, _QWORD))this;
  CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)a3, v6);
}

void CoreStreamImplementation::_streamImpl_deprecated_Schedule(CoreStreamImplementation *this, __CFRunLoop *a2, const __CFString *a3)
{
  abort();
}

void CoreStreamImplementation::_streamImpl_deprecated_Unschedule(CoreStreamImplementation *this, __CFRunLoop *a2, const __CFString *a3)
{
  abort();
}

uint64_t ___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 160))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 152))(*(_QWORD *)(a1 + 32));
}

uint64_t CoreReadStreamScheduleWithRunLoop(CoreStreamBase *a1, CoreSchedulingSet *this, const __CFString *cf1)
{
  CoreStreamBase *v5;
  const CoreSchedulingSet *v6;

  v5 = a1;
  if (a1)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v5 = (CoreStreamBase *)((char *)v5 + 16);
  }
  v6 = (const CoreSchedulingSet *)CoreSchedulingSet::create(this, cf1, cf1);
  CoreStreamBase::_streamInterface_UpdateScheduling(v5, v6);
  return (*(uint64_t (**)(const CoreSchedulingSet *))(*(_QWORD *)v6 + 48))(v6);
}

void CoreReadStreamUnscheduleFromRunLoop(CoreStreamBase *this)
{
  CoreStreamBase *v1;

  v1 = this;
  if (this)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v1 = (CoreStreamBase *)((char *)v1 + 16);
  }
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
  CoreStreamBase::_streamInterface_UpdateScheduling(v1, (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet);
}

uint64_t CoreWriteStreamScheduleWithRunLoop(CoreStreamBase *a1, CoreSchedulingSet *this, const __CFString *cf1)
{
  CoreStreamBase *v5;
  const CoreSchedulingSet *v6;

  v5 = a1;
  if (a1)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    v5 = (CoreStreamBase *)((char *)v5 + 16);
  }
  v6 = (const CoreSchedulingSet *)CoreSchedulingSet::create(this, cf1, cf1);
  CoreStreamBase::_streamInterface_UpdateScheduling(v5, v6);
  return (*(uint64_t (**)(const CoreSchedulingSet *))(*(_QWORD *)v6 + 48))(v6);
}

void CoreWriteStreamUnscheduleFromRunLoop(CoreStreamBase *this)
{
  CoreStreamBase *v1;

  v1 = this;
  if (this)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    v1 = (CoreStreamBase *)((char *)v1 + 16);
  }
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16941);
  CoreStreamBase::_streamInterface_UpdateScheduling(v1, (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet);
}

void CFStreamCreatePairWithSocketToCFHost(CFAllocatorRef alloc, CFHostRef host, SInt32 port, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
  __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1);
}

uint64_t *std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::destroy(*(void ****)(v2 + 8));
    JUMPOUT(0x186DB748CLL);
  }
  return result;
}

void ***std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>::reset[abi:nn180100](void ***result)
{
  void **v1;
  char *v2;
  char *v3;
  void *v4;
  std::__shared_weak_count *v5;

  v1 = *result;
  *result = 0;
  if (v1)
  {
    v2 = (char *)*v1;
    if (*v1)
    {
      v3 = (char *)v1[1];
      v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          v5 = (std::__shared_weak_count *)*((_QWORD *)v3 - 1);
          if (v5)
            std::__shared_weak_count::__release_weak(v5);
          v3 -= 16;
        }
        while (v3 != v2);
        v4 = *v1;
      }
      v1[1] = v2;
      operator delete(v4);
    }
    JUMPOUT(0x186DB748CLL);
  }
  return result;
}

void CFStreamCreatePairWithSocketToNetService(CFAllocatorRef alloc, CFNetServiceRef service, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
  uint64_t Instance;
  const char *v8;
  uint64_t v9;
  SocketStream *v10;
  const char *v11;
  CFMutableDictionaryRef *v12;

  if (TCFObject<SocketStream>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_303);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v9 = Instance;
    v10 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B8uLL);
    SocketStream::SocketStream(v10, v11);
    SocketStream::initialize(v12, service);
    if ((*(unsigned int (**)(SocketStream *, CFReadStreamRef *, CFWriteStreamRef *))(*(_QWORD *)(v9 + 16)
                                                                                               + 64))(v10, readStream, writeStream))
    {
      *(_WORD *)(v9 + 268) = (*(unsigned int *)(v9 + 264) | ((unint64_t)*(unsigned __int16 *)(v9 + 268) << 32) | 0x8000000000) >> 32;
    }
    CFRelease((CFTypeRef)v9);
  }
  else
  {
    SocketStream::SocketStream(0, v8);
  }
}

void _CFStreamCreatePairWithNativeSocket(const __CFAllocator *a1, int a2, __CFReadStream **a3, __CFWriteStream **a4)
{
  uint64_t Instance;
  const char *v8;
  uint64_t v9;
  SocketStream *v10;
  const char *v11;
  SocketStream *v12;
  const __CFAllocator *v13;
  CFDataRef v14;
  UInt8 bytes[4];

  if (TCFObject<SocketStream>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_303);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v9 = Instance;
    v10 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B8uLL);
    SocketStream::SocketStream(v10, v11);
    *(_DWORD *)bytes = a2;
    SocketStream::commonInitialization(v12);
    *(_DWORD *)(v9 + 264) |= 0x100u;
    v13 = CFGetAllocator((CFTypeRef)v9);
    v14 = CFDataCreate(v13, bytes, 4);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v9 + 352), &unk_1EDCFBDA8, v14);
    if (v14)
      CFRelease(v14);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v9 + 352), &unk_1EDCFBD38, (const void *)*MEMORY[0x1E0C9AE40]);
    if (*(_QWORD *)(v9 + 232))
      SocketStream::setLoggerPrefixWithNativeHandle(v10, *(unsigned int *)bytes);
    if ((*(unsigned int (**)(SocketStream *, __CFReadStream **, __CFWriteStream **))(*(_QWORD *)v10 + 64))(v10, a3, a4))
    {
      *(_WORD *)(v9 + 268) = (*(unsigned int *)(v9 + 264) | ((unint64_t)*(unsigned __int16 *)(v9 + 268) << 32) | 0x8000000000) >> 32;
    }
    CFRelease((CFTypeRef)v9);
  }
  else
  {
    SocketStream::SocketStream(0, v8);
  }
}

void _CFStreamCreatePairWithCFSocketSignaturePieces(const __CFAllocator *a1, const __CFData *a2, uint64_t a3, uint64_t a4, const __CFData *a5, __CFReadStream **a6, __CFWriteStream **a7)
{
  uint64_t Instance;
  const char *v11;
  uint64_t v12;
  SocketStream *v13;
  const char *v14;
  SocketStream *v15;
  const __CFAllocator *v16;
  CFHostRef v17;

  if (TCFObject<SocketStream>::Class(void)::sOnce != -1)
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_303);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v12 = Instance;
    v13 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B8uLL);
    SocketStream::SocketStream(v13, v14);
    SocketStream::commonInitialization(v15);
    v16 = CFGetAllocator((CFTypeRef)v12);
    v17 = CFHostCreateWithAddress(v16, a2);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v12 + 352), &unk_1EDCFBDE0, v17);
    CFRelease(v17);
    if ((*(unsigned int (**)(SocketStream *, uint64_t, uint64_t))(*(_QWORD *)(v12 + 16) + 64))(v13, a3, a4))
      *(_WORD *)(v12 + 268) = (*(unsigned int *)(v12 + 264) | ((unint64_t)*(unsigned __int16 *)(v12 + 268) << 32) | 0x8000000000) >> 32;
    CFRelease((CFTypeRef)v12);
  }
  else
  {
    SocketStream::SocketStream(0, v11);
  }
}

BOOL _CFHTTPReadStreamIsAtMark(uint64_t a1)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  _BOOL8 v4;

  if (a1)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
    v2 = a1 + 16;
  }
  else
  {
    v2 = 0;
  }
  v3 = (pthread_mutex_t *)(v2 + 136);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 136));
  v4 = (~(*(unsigned __int16 *)(v2 + 232) | (*(unsigned __int8 *)(v2 + 234) << 16)) & 0x201) == 0;
  pthread_mutex_unlock(v3);
  return v4;
}

uint64_t CFReadStreamCreateHTTPStream(const __CFAllocator *a1, __CFReadStream *a2, int a3)
{
  _OWORD *HTTPStreamWithConnInfo;
  uint64_t v5;

  HTTPStreamWithConnInfo = __CoreReadStreamCreateHTTPStreamWithConnInfo(a1, a2, a3, 0);
  v5 = _CFReadStreamCreateWithCoreStream((uint64_t)a1, (uint64_t)HTTPStreamWithConnInfo);
  if (HTTPStreamWithConnInfo)
    CFRelease(HTTPStreamWithConnInfo);
  return v5;
}

_OWORD *__CoreReadStreamCreateHTTPStreamWithConnInfo(const __CFAllocator *a1, __CFReadStream *a2, int a3, HTTPNetConnection *a4)
{
  _OWORD *Instance;
  _OWORD *v8;
  CFTypeRef v9;
  const __CFAllocator *v10;

  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16727);
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v8 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    v8 = Instance + 1;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  *((_QWORD *)v8 + 15) = &unk_1E14E6BF8;
  *((_DWORD *)v8 + 26) = 0;
  *((_QWORD *)v8 + 3) = (char *)v8 + 120;
  *(_QWORD *)v8 = &off_1E14E6B70;
  *((_QWORD *)v8 + 1) = &unk_1E14E6BD8;
  _CoreLockable::_CoreLockable((_CoreLockable *)(v8 + 8), 1);
  *((_QWORD *)v8 + 25) = a4;
  *(_QWORD *)v8 = &off_1E14E6DC0;
  *((_QWORD *)v8 + 1) = &unk_1E14E6E60;
  *((_QWORD *)v8 + 15) = &unk_1E14E6E80;
  *((_QWORD *)v8 + 16) = &unk_1E14E6F38;
  *((_WORD *)v8 + 116) = 0;
  *((_BYTE *)v8 + 234) = 0;
  if (a2)
    v9 = CFRetain(a2);
  else
    v9 = 0;
  *((_QWORD *)v8 + 26) = v9;
  v10 = CFGetAllocator(v8 - 1);
  *((_QWORD *)v8 + 28) = CFHTTPMessageCreateEmpty(v10, a3 == 0);
  *((_QWORD *)v8 + 30) = -2;
  *((_QWORD *)v8 + 31) = 0;
  *((_QWORD *)v8 + 32) = 0;
  *((_QWORD *)v8 + 33) = 0;
  return v8 - 1;
}

void sub_183FDCE90(_Unwind_Exception *a1)
{
  CoreStreamBase *v1;

  *(_QWORD *)v1 = &off_1E14E9310;
  *((_QWORD *)v1 + 1) = &unk_1E14E9378;
  *((_QWORD *)v1 + 15) = &unk_1E14E9398;
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

const void *CFWriteStreamCreateHTTPStream(const __CFAllocator *a1, __CFHTTPMessage *a2, int a3, __CFWriteStream *a4)
{
  const void *result;
  const void *v5;
  uint64_t v6;

  result = (const void *)__CoreWriteStreamCreateHTTPStreamWithConnInfo(a1, a2, a3, a4, 0);
  if (result)
  {
    v5 = result;
    v6 = _CFWriteStreamCreateWithCoreStream();
    CFRelease(v5);
    return (const void *)v6;
  }
  return result;
}

uint64_t __CoreWriteStreamCreateHTTPStreamWithConnInfo(const __CFAllocator *a1, __CFHTTPMessage *a2, int a3, __CFWriteStream *a4, HTTPNetConnection *a5)
{
  uint64_t Instance;
  uint64_t v10;
  CFTypeRef v11;
  __int16 v12;

  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
  Instance = _CFRuntimeCreateInstance();
  v10 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v10 = Instance + 16;
    *(_QWORD *)(Instance + 304) = 0;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 288) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  *(_QWORD *)(v10 + 120) = &unk_1E14E7510;
  *(_DWORD *)(v10 + 104) = 0;
  *(_QWORD *)(v10 + 24) = v10 + 120;
  *(_QWORD *)v10 = &off_1E14E7488;
  *(_QWORD *)(v10 + 8) = &unk_1E14E74F0;
  _CoreLockable::_CoreLockable((_CoreLockable *)(v10 + 128), 1);
  *(_QWORD *)(v10 + 200) = a5;
  *(_QWORD *)v10 = &off_1E14E7A50;
  *(_QWORD *)(v10 + 8) = &unk_1E14E7AF0;
  *(_QWORD *)(v10 + 120) = &unk_1E14E7B10;
  *(_QWORD *)(v10 + 128) = &unk_1E14E7BC8;
  *(_WORD *)(v10 + 224) = 0;
  if (a4)
  {
    v11 = CFRetain(a4);
    v12 = *(_WORD *)(v10 + 224);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  *(_QWORD *)(v10 + 208) = v11;
  *(_QWORD *)(v10 + 216) = 0;
  *(_OWORD *)(v10 + 232) = 0u;
  *(_OWORD *)(v10 + 248) = 0u;
  *(_QWORD *)(v10 + 264) = 0;
  *(_QWORD *)(v10 + 280) = 0;
  *(_QWORD *)(v10 + 288) = 0;
  if (a3)
  {
    v12 |= 0x200u;
    *(_WORD *)(v10 + 224) = v12;
  }
  *(_WORD *)(v10 + 224) = v12 | 4;
  if (a2)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
    ++*(_QWORD *)(v10 + 80);
    (*(void (**)(_QWORD, uint64_t, __CFHTTPMessage *))(**(_QWORD **)(v10 + 24) + 32))(*(_QWORD *)(v10 + 24), 0x1EDCFE380, a2);
    --*(_QWORD *)(v10 + 80);
  }
  return v10 - 16;
}

void sub_183FDD0DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 128) = &off_1E14E6990;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 136));
  CoreStreamBase::~CoreStreamBase((CoreStreamBase *)v1);
  _Unwind_Resume(a1);
}

CFStringRef HSTSPolicy::copyDebugDesc(HSTSPolicy *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<HSTSPolicy@%p <%p>> { HSTSCache=%p }"), (char *)this - 16, this, *((_QWORD *)this + 2));
}

void `non-virtual thunk to'HSTSPolicy::~HSTSPolicy(HSTSPolicy *this)
{
  HSTSPolicy::~HSTSPolicy((HSTSPolicy *)((char *)this - 8));
}

{
  HSTSPolicy::~HSTSPolicy((HSTSPolicy *)((char *)this - 8));
}

void HSTSPolicy::~HSTSPolicy(HSTSPolicy *this)
{
  uint64_t v2;
  uint8_t v3[16];

  *(_QWORD *)this = &off_1E14E4908;
  *((_QWORD *)this + 1) = &unk_1E14E4950;
  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    if (!*(_BYTE *)(v2 + 73)
      || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT)
      || (*(_WORD *)v3 = 0,
          _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Non-private, global HSTS policy is being destroyed.", v3, 2u), (v2 = *((_QWORD *)this + 2)) != 0))
    {
      CFRelease((CFTypeRef)(v2 - 16));
    }
  }
  *((_QWORD *)this + 1) = &off_1E14E5838;
}

void sub_183FDD214(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = &off_1E14E5838;
  _Unwind_Resume(a1);
}

_QWORD *_CFHSTSPolicyCreateWithProperties(uint64_t a1, CFDictionaryRef theDict)
{
  _QWORD *v3;
  _QWORD *Instance;
  uint8_t v6[8];
  CFTypeRef cf;

  if (!theDict || CFDictionaryGetValue(theDict, CFSTR("hsts_persistent")) == (const void *)*MEMORY[0x1E0C9AE40])
  {
    if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
      dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
    Instance = (_QWORD *)_CFRuntimeCreateInstance();
    v3 = Instance;
    if (Instance)
    {
      Instance[2] = 0;
      Instance[3] = 0;
      v3 = Instance + 2;
      Instance[4] = 0;
    }
    cf = 0;
    HSTSPolicy::HSTSPolicy(v3, a1, 0, (uint64_t *)&cf);
    if (cf)
      CFRelease(cf);
  }
  else
  {
    if (HSTSPolicy::getDefaultPolicy(void)::sOnce != -1)
      dispatch_once(&HSTSPolicy::getDefaultPolicy(void)::sOnce, &__block_literal_global_2);
    v3 = (_QWORD *)HSTSPolicy::getDefaultPolicy(void)::sHSTSPolicy;
    CFRetain((CFTypeRef)(HSTSPolicy::getDefaultPolicy(void)::sHSTSPolicy - 16));
  }
  if (!v3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Must have a valid HSTS Policy now", v6, 2u);
  }
  return v3 - 2;
}

void sub_183FDD374(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

CFDictionaryRef HSTSPolicy::copyExternalRepresentationOfHSTSPolicies(HSTSPolicy *this)
{
  char *v2;
  const __CFAllocator *v3;
  CFMutableDictionaryRef Mutable;
  uint64_t v5;
  NSObject *v6;
  const __CFDictionary *v7;
  const __CFAllocator *v8;
  CFDictionaryRef Copy;
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  v2 = (char *)this - 16;
  v3 = CFGetAllocator((char *)this - 16);
  Mutable = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = *((_QWORD *)this + 2);
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  v6 = *(NSObject **)(v5 + 16);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = ___ZNK9HSTSCache40copyInternalRepresentationOfHSTSPoliciesEv_block_invoke;
  v11[3] = &unk_1E14FDA68;
  v11[4] = &v12;
  v11[5] = v5;
  dispatch_sync(v6, v11);
  v7 = (const __CFDictionary *)v13[3];
  _Block_object_dispose(&v12, 8);
  if (v7)
  {
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)mapToExternalRepresentation, Mutable);
    CFRelease(v7);
  }
  v8 = CFGetAllocator(v2);
  Copy = CFDictionaryCreateCopy(v8, Mutable);
  CFRelease(Mutable);
  return Copy;
}

void mapToExternalRepresentation(const __CFString *a1, CFDictionaryRef theDict, __CFDictionary *a3)
{
  const void *Value;
  const void *v7;
  CFTypeID v8;
  const __CFAllocator *v9;
  __CFDictionary *Mutable;
  const __CFString *v11;
  CFNumberRef v12;
  CFNumberRef v13;
  const void *v14;
  const void *v15;
  CFTypeID v16;
  CFDictionaryRef Copy;
  CFStringRef v18;
  CFStringRef v19;
  double valuePtr;
  uint8_t buf[16];

  if (a1)
  {
    if (theDict)
    {
      Value = CFDictionaryGetValue(theDict, CFSTR("HSTS Host"));
      if (Value)
      {
        v7 = Value;
        v8 = CFGetTypeID(Value);
        if (v8 == CFBooleanGetTypeID() && v7 == (const void *)*MEMORY[0x1E0C9AE50])
        {
          v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          valuePtr = HSTSParser::getTimeForKey(theDict, (const __CFDictionary *)CFSTR("Expiry"), v11);
          if (valuePtr > 0.0)
          {
            v12 = CFNumberCreate(v9, kCFNumberDoubleType, &valuePtr);
            if (v12)
            {
              v13 = v12;
              CFDictionarySetValue(Mutable, CFSTR("_kCFNetworkHSTSExpiry"), v12);
              CFRelease(v13);
            }
          }
          v14 = CFDictionaryGetValue(theDict, CFSTR("Include Subdomains"));
          if (v14)
          {
            v15 = v14;
            v16 = CFGetTypeID(v14);
            if (v16 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
            }
            if (v7 == v15)
              CFDictionarySetValue(Mutable, CFSTR("_kCFNetworkHSTSIncludeSubDomains"), v7);
          }
          if (forceHTTPSByHSTSPreload(a1))
            CFDictionarySetValue(Mutable, CFSTR("_kCFNetworkHSTSPreloaded"), v7);
          if (Mutable)
          {
            Copy = CFDictionaryCreateCopy(v9, Mutable);
            CFRelease(Mutable);
            if (Copy)
            {
              v18 = CFStringCreateCopy(v9, a1);
              if (v18)
              {
                v19 = v18;
                CFDictionarySetValue(a3, v18, Copy);
                CFRelease(v19);
              }
              CFRelease(Copy);
            }
          }
        }
      }
    }
  }
}

uint64_t HSTSPolicy::updateHSTSInfoForHost(HSTSPolicy *this, const __CFString *a2, const __CFDictionary *a3)
{
  const __CFString *v6;
  uint64_t result;
  HSTSCache *v8;
  const __CFString *v9;
  const __CFDictionary *v10;
  CFIndex Length;
  const void *v12;
  CFRange v13;

  if (_HSTSIsDisabled(void)::sDisableHSTSOnce != -1)
    dispatch_once(&_HSTSIsDisabled(void)::sDisableHSTSOnce, &__block_literal_global_11);
  if (_HSTSIsDisabled(void)::sHSTSIsDisabled || _isIPAddress(a2, 1))
    return 0;
  if (!a3 || HSTSParser::getTimeForKey(a3, (const __CFDictionary *)CFSTR("Expiry"), v6) == 0.0)
  {
    v8 = (HSTSCache *)*((_QWORD *)this + 2);
    v9 = a2;
    v10 = 0;
LABEL_10:
    HSTSCache::modifyHSTSStore(v8, v9, v10, 0);
    return 1;
  }
  if (CFStringGetLength(a2) < 2)
    return 0;
  Length = CFStringGetLength(a2);
  if (CFStringGetCharacterAtIndex(a2, Length - 1) != 46)
  {
    v8 = (HSTSCache *)*((_QWORD *)this + 2);
    v9 = a2;
    v10 = a3;
    goto LABEL_10;
  }
  v13.length = CFStringGetLength(a2) - 1;
  v13.location = 0;
  result = (uint64_t)CFStringCreateWithSubstring(0, a2, v13);
  if (result)
  {
    v12 = (const void *)result;
    HSTSCache::modifyHSTSStore(*((HSTSCache **)this + 2), (CFTypeRef)result, a3, 0);
    CFRelease(v12);
    return 1;
  }
  return result;
}

uint64_t HSTSPolicy::handleSTSHeader(HSTSPolicy *this, const __CFString *a2, const __CFURL *a3)
{
  CFAllocatorRef v6;
  CFIndex Length;
  const __CFCharacterSet *Predefined;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  CFIndex v11;
  double DoubleValue;
  _BOOL4 v13;
  int v14;
  CFIndex v15;
  CFIndex v16;
  uint64_t v17;
  int64_t v18;
  uint64_t v19;
  CFIndex v20;
  UniChar v21;
  _BOOL4 v22;
  int v23;
  int IsCharacterMember;
  int64_t v25;
  CFIndex v26;
  _BOOL4 v27;
  int64_t v28;
  uint64_t v29;
  CFIndex v30;
  int64_t v31;
  CFIndex v32;
  int v33;
  BOOL v34;
  int64_t v35;
  const __CFNumber *v36;
  const void *v37;
  CFIndex v38;
  int64_t v39;
  UniChar *v40;
  CFIndex v41;
  UniChar v42;
  UniChar CharacterAtIndex;
  int64_t v44;
  UniChar v45;
  int64_t v46;
  CFIndex v47;
  int64_t v48;
  CFIndex v49;
  UniChar v50;
  unint64_t v51;
  UniChar v52;
  UniChar *v53;
  unint64_t v54;
  int64_t v55;
  CFStringRef v56;
  const __CFString *v57;
  const __CFCharacterSet *v58;
  const __CFCharacterSet *InvertedSet;
  int64_t v60;
  int64_t v61;
  int64_t v62;
  int64_t v63;
  uint64_t updated;
  CFTypeID v66;
  _BOOL8 v67;
  CFDictionaryRef HSTSInfo;
  const __CFDictionary *v69;
  const __CFString *v70;
  const __CFString *v71;
  HSTSParser *v72;
  const __CFURL *v73;
  HSTSPolicy *v74;
  const __CFAllocator *alloc;
  CFTypeRef cf2;
  const __CFString *v77;
  CFTypeRef cf1;
  int v79;
  int64_t v80;
  _QWORD v81[2];
  void (*v82)(uint64_t);
  void *v83;
  const __CFCharacterSet *v84;
  _QWORD v85[2];
  void (*v86)(uint64_t);
  void *v87;
  CFStringRef v88;
  CFRange result;
  UniChar buffer[64];
  CFStringRef theString;
  UniChar *v92;
  const char *v93;
  uint64_t v94;
  CFIndex v95;
  int64_t v96;
  int64_t v97;
  CFRange v98;
  CFRange v99;
  CFRange v100;
  CFRange v101;
  CFRange v102;
  CFRange v103;
  CFRange v104;
  CFRange v105;
  CFRange v106;

  v6 = CFGetAllocator((char *)this - 16);
  if (!a2)
    return 1;
  v72 = v6;
  v73 = a3;
  v74 = this;
  Length = CFStringGetLength(a2);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  theString = a2;
  v94 = 0;
  v95 = Length;
  v80 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a2);
  CStringPtr = 0;
  v92 = (UniChar *)CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a2, 0x600u);
  cf1 = 0;
  v11 = 0;
  v79 = 0;
  v96 = 0;
  v97 = 0;
  v93 = CStringPtr;
  cf2 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  DoubleValue = -1.0;
  v77 = a2;
  do
  {
    if (v11 >= v80)
    {
      v33 = 0;
      v18 = v11;
LABEL_47:
      v35 = v18;
      goto LABEL_48;
    }
    v13 = 0;
    v14 = 0;
    v15 = -v11;
    v16 = v11 + 64;
    v17 = -1;
    v18 = v11;
    while (1)
    {
      if ((unint64_t)v18 >= 4)
        v19 = 4;
      else
        v19 = v18;
      if (v18 < 0 || (v20 = v95, v95 <= v18))
      {
        v21 = 0;
        v22 = !v13;
        goto LABEL_15;
      }
      if (v92)
      {
        v21 = v92[v18 + v94];
      }
      else if (v93)
      {
        v21 = v93[v94 + v18];
      }
      else
      {
        if (v97 <= v18 || (v28 = v96, v96 > v18))
        {
          v29 = v19 + v15;
          v30 = v16 - v19;
          v31 = v18 - v19;
          v32 = v31 + 64;
          if (v31 + 64 >= v95)
            v32 = v95;
          v96 = v31;
          v97 = v32;
          if (v95 >= v30)
            v20 = v30;
          v98.length = v20 + v29;
          v98.location = v31 + v94;
          CFStringGetCharacters(theString, v98, buffer);
          v28 = v96;
        }
        v21 = buffer[v18 - v28];
      }
      v22 = !v13;
      if (!v13 && v21 == 59)
        break;
      if (!v13 && v21 == 44)
      {
        v33 = 1;
        goto LABEL_45;
      }
LABEL_15:
      v23 = v21;
      IsCharacterMember = CFCharacterSetIsCharacterMember(Predefined, v21);
      if (v14)
        v25 = v18;
      else
        v25 = v17;
      if (v14)
        v26 = v11;
      else
        v26 = v18;
      if (v23 == 34)
        v27 = v22;
      else
        v27 = v13;
      if (!IsCharacterMember)
      {
        v14 = 1;
        v17 = v25;
        v13 = v27;
        v11 = v26;
      }
      ++v18;
      --v15;
      ++v16;
      if (v80 == v18)
      {
        v33 = 0;
        v18 = v80;
        goto LABEL_45;
      }
    }
    v33 = 0;
LABEL_45:
    v34 = __CFADD__(v17, 1);
    v35 = v17 + 1;
    a2 = v77;
    if (v34)
      goto LABEL_47;
LABEL_48:
    if (v35 - v11 != CFStringGetLength(CFSTR("includeSubDomains"))
      || (v103.location = v11,
          v103.length = v35 - v11,
          !CFStringFindWithOptions(a2, CFSTR("includeSubDomains"), v103, 9uLL, 0)))
    {
      v104.location = v11;
      v104.length = v35 - v11;
      if (!CFStringFindWithOptions(a2, CFSTR("max-age"), v104, 9uLL, &result))
        goto LABEL_134;
      if (v79)
        return 1;
      v38 = result.length + result.location;
      while (2)
      {
        if (v38 >= v35)
        {
LABEL_132:
          v79 = 1;
          goto LABEL_134;
        }
        if (v38 < 0 || (v39 = v95, v95 <= v38))
        {
          v42 = 0;
        }
        else
        {
          v40 = v92;
          if (v92)
          {
            v41 = v94 + v38;
            goto LABEL_61;
          }
          if (v93)
          {
            v42 = v93[v94 + v38];
          }
          else
          {
            if (v97 <= v38 || (v46 = v96, v96 > v38))
            {
              v47 = v38 - 4;
              if ((unint64_t)v38 < 4)
                v47 = 0;
              if (v47 + 64 < v95)
                v39 = v47 + 64;
              v96 = v47;
              v97 = v39;
              v99.location = v94 + v47;
              v99.length = v39 - v47;
              CFStringGetCharacters(theString, v99, buffer);
              v46 = v96;
            }
            v41 = v38 - v46;
            v40 = buffer;
LABEL_61:
            v42 = v40[v41];
          }
          if (v42 == 61)
          {
            do
            {
              if (++v38 >= v35)
                goto LABEL_64;
              CharacterAtIndex = CFStringGetCharacterAtIndex(a2, v38);
            }
            while (CFCharacterSetIsCharacterMember(Predefined, CharacterAtIndex));
            v44 = v95;
            if (v38 - 1 >= -1 && v95 > v38)
            {
              if (v92)
              {
                v45 = v92[v94 + v38];
              }
              else if (v93)
              {
                v45 = v93[v94 + v38];
              }
              else
              {
                if (v97 <= v38 || (v48 = v96, v96 > v38))
                {
                  v49 = v38 - 4;
                  if ((unint64_t)v38 < 4)
                    v49 = 0;
                  if (v49 + 64 < v95)
                    v44 = v49 + 64;
                  v96 = v49;
                  v97 = v44;
                  v100.location = v94 + v49;
                  v100.length = v44 - v49;
                  CFStringGetCharacters(theString, v100, buffer);
                  v44 = v95;
                  v48 = v96;
                }
                v45 = buffer[v38 - v48];
              }
              if (v45 == 34)
                ++v38;
            }
            if (v44 <= v35)
            {
              v50 = 0;
            }
            else if (v92)
            {
              v50 = v92[v94 + v35];
            }
            else if (v93)
            {
              v50 = v93[v94 + v35];
            }
            else
            {
              if (v97 <= v35 || (v60 = v96, v96 > v35))
              {
                v61 = v35 - 4;
                if ((unint64_t)v35 < 4)
                  v61 = 0;
                if (v61 + 64 < v44)
                  v44 = v61 + 64;
                v96 = v61;
                v97 = v44;
                v101.location = v94 + v61;
                v101.length = v44 - v61;
                CFStringGetCharacters(theString, v101, buffer);
                v44 = v95;
                v60 = v96;
              }
              v50 = buffer[v35 - v60];
            }
            v51 = v35 - 1;
            if (v44 < v35)
            {
              v52 = 0;
              goto LABEL_107;
            }
            v53 = v92;
            if (v92)
            {
              v54 = v94 + v51;
              goto LABEL_102;
            }
            if (v93)
            {
              v52 = v93[v94 + v51];
            }
            else
            {
              if (v97 < v35 || (v62 = v96, v96 >= v35))
              {
                v63 = v35 - 5;
                if (v51 < 4)
                  v63 = 0;
                if (v63 + 64 < v44)
                  v44 = v63 + 64;
                v96 = v63;
                v97 = v44;
                v102.location = v94 + v63;
                v102.length = v44 - v63;
                CFStringGetCharacters(theString, v102, buffer);
                v62 = v96;
              }
              v54 = v51 - v62;
              v53 = buffer;
LABEL_102:
              v52 = v53[v54];
            }
LABEL_107:
            if (v50 == 34)
              v55 = v35 - 1;
            else
              v55 = v35;
            v35 = v55 - (v52 == 34);
            v105.length = v35 - v38;
            v105.location = v38;
            v56 = CFStringCreateWithSubstring(alloc, a2, v105);
            v85[0] = MEMORY[0x1E0C809B0];
            v85[1] = 3221225472;
            v86 = ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke;
            v87 = &__block_descriptor_40_e5_v8__0l;
            v88 = v56;
            if (v56)
            {
              v57 = v56;
              v58 = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
              InvertedSet = CFCharacterSetCreateInvertedSet(0, v58);
              v81[0] = MEMORY[0x1E0C809B0];
              v81[1] = 3221225472;
              v82 = ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke_2;
              v83 = &__block_descriptor_40_e5_v8__0l;
              v84 = InvertedSet;
              v106.length = CFStringGetLength(v57);
              v106.location = 0;
              if (!CFStringFindCharacterFromSet(v57, InvertedSet, v106, 0, 0))
              {
                DoubleValue = CFStringGetDoubleValue(v57);
                if (DoubleValue > 1.79769313e308)
                  DoubleValue = 1.79769313e308;
              }
              v82((uint64_t)v81);
              v86((uint64_t)v85);
            }
            else
            {
              ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke((uint64_t)v85);
            }
            goto LABEL_64;
          }
        }
        if (!CFCharacterSetIsCharacterMember(Predefined, v42))
          goto LABEL_132;
LABEL_64:
        ++v38;
        continue;
      }
    }
    v37 = cf1;
    if (!cf1)
    {
      cf1 = cf2;
      goto LABEL_134;
    }
    cf1 = cf2;
    if (CFEqual(v37, cf2))
      return 1;
LABEL_134:
    if (v18 == v80)
      break;
    v11 = v18 + 1;
  }
  while (!v33);
  if (DoubleValue < 0.0)
    return 1;
  if (cf1)
  {
    v66 = CFGetTypeID(cf1);
    if (v66 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      buffer[0] = 0;
      _os_log_fault_impl(&dword_183ECA000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)buffer, 2u);
    }
    v67 = cf2 == cf1;
  }
  else
  {
    v67 = 0;
  }
  updated = 1;
  HSTSInfo = HSTSParser::createHSTSInfo(v72, (const __CFAllocator *)v67, DoubleValue, 1, 0, v36);
  if (HSTSInfo)
  {
    v69 = HSTSInfo;
    v70 = CFURLCopyHostName(v73);
    if (v70)
    {
      v71 = v70;
      updated = HSTSPolicy::updateHSTSInfoForHost(v74, v70, v69);
      CFRelease(v71);
    }
    else
    {
      updated = 0;
    }
    CFRelease(v69);
  }
  return updated;
}

void sub_183FDE000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void (*a28)(char *))
{
  a28(&a26);
  _Unwind_Resume(a1);
}

void NotificationStation::notifyPropertyChanged(NotificationStation *this, const __CFString *value, const void *a3)
{
  std::mutex *v6;
  uint64_t v7;
  uint64_t v8;
  __int128 **v9;
  __int128 *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  const __CFString *v13;
  uint64_t v14;
  __int128 *v15;
  __int128 *v16;
  __int128 *v17;
  __int128 v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  const __CFSet *v23;
  CFStringRef v24;
  void (*v25)(CFTypeRef);

  if (*((_BYTE *)this + 88) || (v23 = (const __CFSet *)*((_QWORD *)this + 9)) != 0 && CFSetContainsValue(v23, value))
  {
    v6 = (std::mutex *)((char *)this + 8);
    std::mutex::lock((std::mutex *)((char *)this + 8));
    v7 = *(_QWORD *)this;
    if (!*(_QWORD *)this)
      goto LABEL_31;
    if (value)
      CFRetain(value);
    v24 = value;
    v25 = CFTypeRefRelease<__CFString const*>;
    v8 = std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::find<std::unique_ptr<__CFString const,void (*)(__CFString const*)>>(v7, &v24);
    if (value)
      CFTypeRefRelease<__CFString const*>(value);
    if (*(_QWORD *)this + 8 == v8)
    {
LABEL_31:
      std::mutex::unlock(v6);
      return;
    }
    v9 = *(__int128 ***)(v8 + 48);
    v10 = *v9;
    while (1)
    {
      if (v10 == v9[1])
        goto LABEL_31;
      v24 = 0;
      v25 = 0;
      v11 = (std::__shared_weak_count *)*((_QWORD *)v10 + 1);
      if (v11)
      {
        v12 = std::__shared_weak_count::lock(v11);
        v25 = (void (*)(CFTypeRef))v12;
        if (v12)
        {
          v13 = *(const __CFString **)v10;
          v24 = v13;
          if (v13)
          {
            (*((void (**)(const __CFString *, const __CFString *, const void *))v13->isa + 2))(v13, value, a3);
            ++v10;
LABEL_26:
            p_shared_owners = (unint64_t *)&v12->__shared_owners_;
            do
              v22 = __ldaxr(p_shared_owners);
            while (__stlxr(v22 - 1, p_shared_owners));
            if (!v22)
            {
              ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
              std::__shared_weak_count::__release_weak(v12);
            }
            goto LABEL_30;
          }
        }
      }
      else
      {
        v12 = 0;
      }
      v14 = *(_QWORD *)(v8 + 48);
      v15 = v10 + 1;
      v16 = *(__int128 **)(v14 + 8);
      if (v10 + 1 == v16)
      {
        v17 = v10;
      }
      else
      {
        do
        {
          v17 = v15;
          v18 = *v15;
          *(_QWORD *)v15 = 0;
          *((_QWORD *)v15 + 1) = 0;
          v19 = (std::__shared_weak_count *)*((_QWORD *)v15 - 1);
          *(v15 - 1) = v18;
          if (v19)
            std::__shared_weak_count::__release_weak(v19);
          ++v15;
        }
        while (v17 + 1 != v16);
        v15 = *(__int128 **)(v14 + 8);
      }
      while (v15 != v17)
      {
        v20 = (std::__shared_weak_count *)*((_QWORD *)v15 - 1);
        if (v20)
          std::__shared_weak_count::__release_weak(v20);
        --v15;
      }
      *(_QWORD *)(v14 + 8) = v17;
      if (v12)
        goto LABEL_26;
LABEL_30:
      v9 = *(__int128 ***)(v8 + 48);
    }
  }
}

void sub_183FDE210(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

CFTypeID CFHTTPMessageGetTypeID(void)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  return *(_QWORD *)(HTTPMessage::Class(void)::sClass_OBJTYPE + 96);
}

CFHTTPMessageRef CFHTTPMessageCreateRequest(CFAllocatorRef alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion)
{
  uint64_t Instance;
  HTTPRequestMessage *v8;
  void (**v10)(StringSerializable *__hidden);
  CFTypeRef cf;
  void (**v12)(StringSerializable *__hidden);
  CFTypeRef v13;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  Instance = _CFRuntimeCreateInstance();
  v8 = (HTTPRequestMessage *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v8 = (HTTPRequestMessage *)(Instance + 16);
    *(_QWORD *)(Instance + 192) = 0;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  HTTPMethodMixedValue::HTTPMethodMixedValue((HTTPMethodMixedValue *)&v12, requestMethod);
  HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v10, httpVersion);
  HTTPRequestMessage::HTTPRequestMessage(v8, (CFTypeRef *)&v12, url, cf);
  v10 = &off_1E14E9A00;
  if (cf)
    CFRelease(cf);
  v12 = &off_1E14E9A00;
  if (v13)
    CFRelease(v13);
  return (HTTPRequestMessage *)((char *)v8 - 16);
}

void sub_183FDE388(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf, uint64_t a11, CFTypeRef a12)
{
  if (cf)
    CFRelease(cf);
  if (a12)
    CFRelease(a12);
  _Unwind_Resume(exception_object);
}

Boolean CFHTTPMessageIsRequest(CFHTTPMessageRef message)
{
  char *v2;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v2 = (char *)message + 16;
  if (!message)
    v2 = 0;
  return v2[24] == 0;
}

void CFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData)
{
  CFTypeID v4;
  char *v5;

  if (!bodyData || (v4 = CFGetTypeID(bodyData), v4 == CFDataGetTypeID()))
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (message)
      v5 = (char *)message + 16;
    else
      v5 = 0;
    (*(void (**)(char *, CFDataRef))(*(_QWORD *)v5 + 64))(v5, bodyData);
  }
}

void _CFHTTPMessageAddHeaderFieldValue(uint64_t a1, __CFString *a2, __CFString *a3)
{
  HTTPMessage *v6;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (a1)
    v6 = (HTTPMessage *)(a1 + 16);
  else
    v6 = 0;
  HTTPMessage::addHeaderFieldStringValue(v6, a2, a3);
}

Boolean CFHTTPMessageIsHeaderComplete(CFHTTPMessageRef message)
{
  char *v2;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v2 = (char *)message + 16;
  if (!message)
    v2 = 0;
  return *((_QWORD *)v2 + 11) == 0;
}

CFDataRef CFHTTPMessageCopySerializedMessage(CFHTTPMessageRef message)
{
  HTTPMessage *v2;
  __CFData *v3;
  const char *v4;
  const __CFData *v5;
  const __CFData **v6;
  const __CFData *Length;
  const __CFAllocator *v8;
  CFIndex v9;
  __CFData *MutableCopy;
  HTTPBodyData *v11;
  const char *v12;
  const __CFData *v13;
  const UInt8 *BytePtr;
  int v16;
  const __CFAllocator *v17;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (message)
    v2 = (CFHTTPMessageRef)((char *)message + 16);
  else
    v2 = 0;
  v3 = HTTPMessage::copySerializedHeaders(v2, 0);
  if (v3)
  {
    v5 = v3;
    v6 = (const __CFData **)*((_QWORD *)v2 + 6);
    if (!v6)
      return v5;
    Length = HTTPBodyData::getLength(v6, v4);
    v8 = CFGetAllocator((char *)v2 - 16);
    v9 = CFDataGetLength(v5);
    MutableCopy = CFDataCreateMutableCopy(v8, (CFIndex)Length + v9, v5);
    CFRelease(v5);
    v11 = (HTTPBodyData *)*((_QWORD *)v2 + 6);
    HTTPBodyData::logit(v11, v12);
    v13 = (const __CFData *)*((_QWORD *)v11 + 2);
    if (v13 || (v13 = (const __CFData *)*((_QWORD *)v11 + 3)) != 0)
      BytePtr = CFDataGetBytePtr(v13);
    else
      BytePtr = 0;
    CFDataAppendBytes(MutableCopy, BytePtr, (CFIndex)Length);
    if (!message)
      return MutableCopy;
  }
  else
  {
    MutableCopy = 0;
    if (!message)
      return MutableCopy;
  }
  if (MutableCopy)
    return MutableCopy;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (!*((_BYTE *)message + 40))
    return 0;
  if (*((_QWORD *)message + 38))
    return 0;
  if (*((_BYTE *)message + 176))
    return 0;
  v16 = *((_DWORD *)message + 36);
  if (v16 != 200 && v16 != -1)
    return 0;
  v17 = CFGetAllocator(message);
  return CFDataCreate(v17, (const UInt8 *)"\r\n\r\n", 4);
}

void _CFHTTPMessageSetResponseProxyURL(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (*(_BYTE *)(a1 + 40))
      HTTPResponseMessage::setResponseURL((HTTPResponseMessage *)(a1 + 16), cf, 1);
  }
}

uint64_t _CFHTTPMessageGetAuthentication(__CFHTTPMessage *a1, int a2)
{
  char *v4;
  uint64_t v5;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  v4 = (char *)a1 + 16;
  if (!a1)
    v4 = 0;
  v5 = 80;
  if (!a2)
    v5 = 72;
  return *(_QWORD *)&v4[v5];
}

CFTypeRef _CFHTTPMessageSetAuthentication(__CFHTTPMessage *a1, CFTypeRef cf, int a3)
{
  char *v6;
  uint64_t v7;
  CFTypeRef result;

  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
  if (a1)
    v6 = (char *)a1 + 16;
  else
    v6 = 0;
  if (a3)
    v7 = 80;
  else
    v7 = 72;
  result = *(CFTypeRef *)&v6[v7];
  if (result != cf)
  {
    if (result)
      CFRelease(result);
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)&v6[v7] = result;
  }
  return result;
}

void sub_183FDF140(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_48c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_48c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void __Block_byref_object_copy__461(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 135);
}

void __Block_byref_object_dispose__462(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 135);
}

void _CFHSTSPolicyResetHSTSHostsSinceDate(uint64_t a1, CFTypeRef a2)
{
  uint64_t v4;

  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1)
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
  v4 = a1 + 16;
  if (!a1)
    v4 = 0;
  HSTSCache::modifyHSTSStore(*(HSTSCache **)(v4 + 16), 0, 0, a2);
}

void std::__shared_ptr_pointer<__CFString *,Deleter_CFRelease,std::allocator<__CFString>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void sub_183FE007C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183FE0C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__582(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__583(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t ___ZL13countSegmentsPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1)
{
  ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return 1;
}

uint64_t ___ZL17resumeDataClassesv_block_invoke()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64_t result;
  double v10;
  void *v11;

  v0 = (void *)MEMORY[0x1E0C99E20];
  v1 = objc_opt_class();
  v2 = objc_opt_class();
  v3 = objc_opt_class();
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  resumeDataClasses(void)::resumeDataClasses = (uint64_t)(id)objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, objc_opt_class(), 0);
  gotLoadHelper_x20__OBJC_CLASS___SZExtractor(v7);
  if (objc_opt_class())
  {
    v8 = objc_msgSend(*(id *)(v1 + 3688), "knownSZExtractorImplementations");
    objc_msgSend((id)resumeDataClasses(void)::resumeDataClasses, "unionSet:", v8);
  }
  result = objc_opt_class();
  if (result)
  {
    v11 = (void *)resumeDataClasses(void)::resumeDataClasses;
    gotLoadHelper_x8__OBJC_CLASS___STRemoteExtractor(v10);
    return objc_msgSend(v11, "addObject:", objc_opt_class());
  }
  return result;
}

uint64_t BlockHolderVar<>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

uint64_t *std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::__tree<std::shared_ptr<void>>::destroy(*(_QWORD **)(v2 + 8));
    JUMPOUT(0x186DB748CLL);
  }
  return result;
}

void ___ZN14HTTPStallTimer5setupEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void (*v8)(_QWORD *);
  uint64_t v9;
  _QWORD *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        v6 = *(_QWORD *)(v5 + 40);
        if (v6)
        {
          if (*(_QWORD *)(v6 + 16))
          {
            std::__tree<std::shared_ptr<void>>::destroy(*(_QWORD **)(v6 + 8));
            *(_QWORD *)v6 = v6 + 8;
            *(_QWORD *)(v6 + 16) = 0;
            *(_QWORD *)(v6 + 8) = 0;
            v7 = *(_QWORD *)(v5 + 48);
            if (v7)
            {
              v8 = *(void (**)(_QWORD *))(v7 + 8);
              v9 = *(_QWORD *)(v7 + 16);
              v10 = (_QWORD *)(v7 + (v9 >> 1));
              if ((v9 & 1) != 0)
                v8 = *(void (**)(_QWORD *))(*v10 + v8);
              v8(v10);
            }
          }
        }
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_183FE2468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 != v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v18 = v7[1];
      *(_QWORD *)v12 = v18;
      if (v18)
        *(_QWORD *)(v18 + 16) = v12;
      v7[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(_QWORD *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12)
        result = v7;
      v7 = *(uint64_t **)v12;
    }
    v19 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v19 + 24))
      goto LABEL_68;
    v20 = (uint64_t *)v7[1];
    if (v20 && !*((_BYTE *)v20 + 24))
    {
      if (v19 && !*((_BYTE *)v19 + 24))
      {
LABEL_68:
        v20 = v7;
      }
      else
      {
        *((_BYTE *)v20 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v26 = *v20;
        v7[1] = *v20;
        if (v26)
          *(_QWORD *)(v26 + 16) = v7;
        v20[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
        *v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        v19 = v7;
      }
      v23 = v20[2];
      *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v19 + 24) = 1;
      v24 = *(uint64_t **)v23;
      v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
      *(_QWORD *)v23 = v27;
      if (v27)
        *(_QWORD *)(v27 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v13 = *(uint64_t **)(v12 + 8);
    v14 = *v13;
    *(_QWORD *)(v12 + 8) = *v13;
    if (v14)
      *(_QWORD *)(v14 + 16) = v12;
    v13[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
    *v13 = v12;
    *(_QWORD *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7)
      result = v7;
    v7 = *(uint64_t **)(*v7 + 8);
  }
  v15 = (_QWORD *)*v7;
  if (!*v7 || *((_BYTE *)v15 + 24))
  {
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_59;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
    goto LABEL_49;
  }
  v16 = (uint64_t *)v7[1];
  if (v16 && !*((_BYTE *)v16 + 24))
  {
LABEL_59:
    v15 = v7;
  }
  else
  {
    *((_BYTE *)v15 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v22 = v15[1];
    *v7 = v22;
    if (v22)
      *(_QWORD *)(v22 + 16) = v7;
    v15[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    v16 = v7;
  }
  v23 = v15[2];
  *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v16 + 24) = 1;
  v24 = *(uint64_t **)(v23 + 8);
  v25 = *v24;
  *(_QWORD *)(v23 + 8) = *v24;
  if (v25)
    *(_QWORD *)(v25 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  *v24 = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

void sub_183FE2B50(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void TunnelProxy<HTTPEngine>::~TunnelProxy(NetworkProxy *a1)
{
  TunnelProxy<HTTPEngine>::~TunnelProxy(a1);
  JUMPOUT(0x186DB748CLL);
}

{
  NSObject *v2;
  const void *v3;

  *(_QWORD *)a1 = &off_1E14E5400;
  *((_QWORD *)a1 + 13) = &unk_1E14E54A8;
  v2 = *((_QWORD *)a1 + 24);
  if (v2)
    dispatch_release(v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 256);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 240);
  v3 = (const void *)*((_QWORD *)a1 + 29);
  *((_QWORD *)a1 + 29) = 0;
  if (v3)
    CFRelease(v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 216);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 176);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 160);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 144);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 128);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 112);
  NetworkProxy::~NetworkProxy(a1);
}

const __CFString *TunnelProxy<HTTPEngine>::prettyType()
{
  return CFSTR("https");
}

CFTypeRef TunnelProxy<HTTPEngine>::copyCONNECTEndpointProperties(uint64_t a1)
{
  const __CFNumber *v2;
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  const void *Value;
  CFTypeRef v6;

  v2 = CFNumberCreate(0, kCFNumberCFIndexType, (const void *)(a1 + 40));
  v3 = _newConnPropsForHTTPSProxy(0, *(__CFHTTPMessage **)(a1 + 232), *(__CFString **)(a1 + 24), v2);
  v4 = v3;
  if (!v3)
  {
    v6 = 0;
    if (!v2)
      return v6;
    goto LABEL_8;
  }
  Value = CFDictionaryGetValue(v3, &unk_1EDD003E0);
  if (Value)
    v6 = CFRetain(Value);
  else
    v6 = 0;
  CFRelease(v4);
  if (v2)
LABEL_8:
    CFRelease(v2);
  return v6;
}

void sub_183FE2C88(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t TunnelProxy<HTTPEngine>::getType()
{
  return 3;
}

uint64_t NetworkProxy::getPort(NetworkProxy *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t NetworkProxy::host@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 32);
  *a2 = *(_QWORD *)(this + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t NetworkProxy::getEndpointHost@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 56);
  *a2 = *(_QWORD *)(this + 48);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t NetworkProxy::getEndpointPort(NetworkProxy *this)
{
  return *((unsigned int *)this + 16);
}

void TunnelProxy<HTTPEngine>::establishProxyConnection(uint64_t a1, uint64_t *a2)
{
  const __CFString *v4;
  const __CFURL *v5;
  uint64_t Instance;
  HTTPRequestMessage *v7;
  const __CFString *v8;
  uint64_t v9;
  HTTPMessage *v10;
  const __CFString *v11;
  NSObject *v12;
  const void *v13;
  uint64_t v14;
  HTTPMessage *v15;
  const __CFString *v16;
  uint64_t v17;
  uint64_t *v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  __int128 v40;
  HTTPRequestMessage *v41;
  void (**v42)(StringSerializable *__hidden);
  CFTypeRef cf;
  CFTypeRef v44[3];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v4 = CFStringCreateWithFormat(0, 0, CFSTR("%@:%d"), *(_QWORD *)(a1 + 48), *(unsigned __int16 *)(a1 + 64));
  v5 = CFURLCreateWithString(0, v4, 0);
  if (v5)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    Instance = _CFRuntimeCreateInstance();
    v7 = (HTTPRequestMessage *)Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 16) = 0u;
      v7 = (HTTPRequestMessage *)(Instance + 16);
      *(_QWORD *)(Instance + 192) = 0;
      *(_OWORD *)(Instance + 160) = 0u;
      *(_OWORD *)(Instance + 176) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 144) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
    }
    HTTPMethodMixedValue::HTTPMethodMixedValue((HTTPMethodMixedValue *)v44, (CFStringRef)&unk_1EDCFE0A8);
    HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v42, CFSTR("HTTP/1.1"));
    HTTPRequestMessage::HTTPRequestMessage(v7, v44, v5, cf);
    v41 = v7;
    v42 = &off_1E14E9A00;
    if (cf)
      CFRelease(cf);
    v44[0] = &off_1E14E9A00;
    if (v44[1])
      CFRelease(v44[1]);
    v8 = v4;
    if (*(_DWORD *)(a1 + 64) == 443)
      v8 = *(const __CFString **)(a1 + 48);
    HTTPMessage::setHeaderFieldStringValue(v7, (const __CFString *)&unk_1EDCFD0B0, v8);
    if ((dyld_program_sdk_at_least() & 1) != 0)
      goto LABEL_19;
    v9 = *(_QWORD *)(a1 + 232);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v10 = v9 ? (HTTPMessage *)(v9 + 16) : 0;
    v11 = HTTPMessage::copyHeaderFieldValue(v10, 0x14C15415u);
    if (!v11)
    {
LABEL_19:
      pthread_once(&initControl, initializeUserAgentString);
      if (sUserAgentString)
      {
        pthread_once(&initControl, initializeUserAgentString);
        v11 = (const __CFString *)CFRetain((CFTypeRef)sUserAgentString);
      }
      else
      {
        v11 = 0;
      }
    }
    HTTPMessage::setHeaderFieldStringValue(v7, CFSTR("User-Agent"), v11);
    v14 = *(_QWORD *)(a1 + 232);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    if (v14)
      v15 = (HTTPMessage *)(v14 + 16);
    else
      v15 = 0;
    v16 = HTTPMessage::copyHeaderFieldValue(v15, 0x1362735Fu);
    if (v16)
      HTTPMessage::setHeaderFieldStringValue(v7, (const __CFString *)&unk_1EDCFD3F8, v16);
    HTTPMessage::setHeaderFieldStringValue(v7, (const __CFString *)&unk_1EDCFD430, CFSTR("keep-alive"));
    HTTPMessage::setHeaderFieldStringValue(v7, CFSTR("Connection"), CFSTR("keep-alive"));
    if (v16)
      CFRelease(v16);
    if (v11)
      CFRelease(v11);
    CFRelease(v5);
    if (v4)
LABEL_40:
      CFRelease(v4);
  }
  else
  {
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v12 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(const void **)(a1 + 48);
      LODWORD(v44[0]) = 138412290;
      *(CFTypeRef *)((char *)v44 + 4) = v13;
      _os_log_impl(&dword_183ECA000, v12, OS_LOG_TYPE_DEFAULT, "Invalid URL for CONNECT request %@", (uint8_t *)v44, 0xCu);
    }
    *(_QWORD *)(a1 + 200) = 4;
    *(_DWORD *)(a1 + 208) = -2096;
    v41 = 0;
    if (v4)
      goto LABEL_40;
  }
  v17 = *std::shared_ptr<HTTPRequestMessage>::operator=[abi:nn180100]<HTTPRequestMessage,Deleter_release<HTTPRequestMessage>,void>((_QWORD *)(a1 + 160), (uint64_t *)&v41);
  if (v41)
    CFRelease((char *)v41 - 16);
  if (v17)
  {
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<HTTPEngine::HTTPEngineDelegate,TunnelProxy<HTTPEngine>>(&v42, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16), a1);
    std::allocate_shared[abi:nn180100]<HTTPEngine,std::allocator<HTTPEngine>,std::shared_ptr<TransportConnection> &,std::shared_ptr<HTTPEngine::HTTPEngineDelegate>,void>((uint64_t *)v44, *(_QWORD *)(a1 + 128), *(std::__shared_weak_count **)(a1 + 136), (uint64_t *)&v42);
    v18 = (uint64_t *)(a1 + 112);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 112, (__int128 *)v44);
    v19 = (std::__shared_weak_count *)v44[1];
    if (v44[1])
    {
      v20 = (unint64_t *)((char *)v44[1] + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v22 = (std::__shared_weak_count *)cf;
    if (cf)
    {
      v23 = (unint64_t *)((char *)cf + 8);
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    v44[0] = 0;
    v44[1] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 128, (__int128 *)v44);
    v25 = (std::__shared_weak_count *)v44[1];
    if (v44[1])
    {
      v26 = (unint64_t *)((char *)v44[1] + 8);
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    HTTPEngine::initialize(*v18, 3);
    *(_DWORD *)(*v18 + 32) |= 8u;
    v28 = *a2;
    v29 = (std::__shared_weak_count *)a2[1];
    if (v29)
    {
      p_shared_owners = (unint64_t *)&v29->__shared_owners_;
      do
        v31 = __ldxr(p_shared_owners);
      while (__stxr(v31 + 1, p_shared_owners));
    }
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 240), v28, (uint64_t)v29);
    v32 = *(_QWORD *)(a1 + 240);
    if (v32)
    {
      *(_QWORD *)(v32 + 8) = BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_normal;
      *(_QWORD *)(v32 + 16) = 0;
    }
    if (v29)
    {
      v33 = (unint64_t *)&v29->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    TunnelProxy<HTTPEngine>::establishTunnel(a1);
  }
  else
  {
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(v44, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16), a1);
    v40 = *(_OWORD *)v44;
    v44[0] = 0;
    v44[1] = 0;
    SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()(*a2, v40, *((std::__shared_weak_count **)&v40 + 1), 0, *(_QWORD *)(a1 + 200), *(_QWORD *)(a1 + 208));
    if (*((_QWORD *)&v40 + 1))
    {
      v35 = (unint64_t *)(*((_QWORD *)&v40 + 1) + 8);
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        (*(void (**)(_QWORD))(**((_QWORD **)&v40 + 1) + 16))(*((_QWORD *)&v40 + 1));
        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v40 + 1));
      }
    }
    v37 = (std::__shared_weak_count *)v44[1];
    if (v44[1])
    {
      v38 = (unint64_t *)((char *)v44[1] + 8);
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
  }
}

void sub_183FE3318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf, uint64_t a17, uint64_t a18)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void TunnelProxy<HTTPEngine>::continueProxyEstablishment(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  __int128 v27;
  __int128 v28;

  if (*(_DWORD *)(a1 + 208))
  {
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(&v27, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16), a1);
    v28 = v27;
    v27 = 0uLL;
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v28 + 1);
    SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()(*a3, v28, *((std::__shared_weak_count **)&v28 + 1), 0, *(_QWORD *)(a1 + 200), *(_QWORD *)(a1 + 208));
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    v8 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
    if (*((_QWORD *)&v27 + 1))
    {
      v9 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    *(_QWORD *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 208) = 0;
  }
  else
  {
    *(_BYTE *)(a1 + 97) = 0;
    v12 = *a3;
    v13 = (std::__shared_weak_count *)a3[1];
    if (v13)
    {
      v14 = (unint64_t *)&v13->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(a1 + 240), v12, (uint64_t)v13);
    v16 = *(_QWORD *)(a1 + 240);
    if (v16)
    {
      *(_QWORD *)(v16 + 8) = BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_normal;
      *(_QWORD *)(v16 + 16) = 0;
    }
    if (v13)
    {
      v17 = (unint64_t *)&v13->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<HTTPEngine::HTTPEngineDelegate,TunnelProxy<HTTPEngine>>(&v25, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16), a1);
    std::allocate_shared[abi:nn180100]<HTTPEngine,std::allocator<HTTPEngine>,std::shared_ptr<TransportConnection> &,std::shared_ptr<HTTPEngine::HTTPEngineDelegate>,void>((uint64_t *)&v27, *(_QWORD *)a2, *(std::__shared_weak_count **)(a2 + 8), &v25);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 112, &v27);
    v19 = (std::__shared_weak_count *)*((_QWORD *)&v27 + 1);
    if (*((_QWORD *)&v27 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v27 + 1) + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v22 = v26;
    if (v26)
    {
      v23 = (unint64_t *)&v26->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    HTTPEngine::initialize(*(_QWORD *)(a1 + 112), 3);
    *(_DWORD *)(*(_QWORD *)(a1 + 112) + 32) |= 8u;
    TunnelProxy<HTTPEngine>::completeTask(a1, 0);
  }
}

void sub_183FE3650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TunnelProxy<HTTPEngine>::proxyResponse(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 176);
  if (v1)
    return v1 - 16;
  else
    return 0;
}

uint64_t TunnelProxy<HTTPEngine>::proxyResponseData(uint64_t a1)
{
  return *(_QWORD *)(a1 + 192);
}

void TunnelProxy<HTTPEngine>::errorOccurred(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(_DWORD *)(a1 + 208))
  {
    *(_QWORD *)(a1 + 200) = a2;
    *(_DWORD *)(a1 + 208) = a3;
    TunnelProxy<HTTPEngine>::newConnectionRequired(a1);
  }
}

void `non-virtual thunk to'TunnelProxy<HTTPEngine>::~TunnelProxy(uint64_t a1)
{
  TunnelProxy<HTTPEngine>::~TunnelProxy((NetworkProxy *)(a1 - 104));
}

{
  TunnelProxy<HTTPEngine>::~TunnelProxy((NetworkProxy *)(a1 - 104));
  JUMPOUT(0x186DB748CLL);
}

void `non-virtual thunk to'TunnelProxy<HTTPEngine>::errorOccurred(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(_DWORD *)(a1 + 104))
  {
    *(_QWORD *)(a1 + 96) = a2;
    *(_DWORD *)(a1 + 104) = a3;
    TunnelProxy<HTTPEngine>::newConnectionRequired(a1 - 104);
  }
}

void TunnelProxy<HTTPEngine>::newConnectionRequired(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;

  v11 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 112, &v11);
  v2 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
  if (*((_QWORD *)&v11 + 1))
  {
    v3 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  ++*(_DWORD *)(a1 + 272);
  *(_BYTE *)(a1 + 97) = 1;
  TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(&v11, *(_QWORD *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16), a1);
  v10 = v11;
  v11 = 0uLL;
  TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion(a1, v10, *((std::__shared_weak_count **)&v10 + 1), 1, *(_QWORD *)(a1 + 200), *(_QWORD *)(a1 + 208));
  if (*((_QWORD *)&v10 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v10 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v10 + 1) + 16))(*((_QWORD *)&v10 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v10 + 1));
    }
  }
  v7 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
  if (*((_QWORD *)&v11 + 1))
  {
    v8 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  *(_QWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 208) = 0;
}

void sub_183FE382C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(_QWORD *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v12, a2, a3);
  v6 = v13;
  *a1 = a4;
  a1[1] = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v9 = v13;
    if (v13)
    {
      v10 = (unint64_t *)&v13->__shared_owners_;
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
}

void TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 v15;
  uint64_t v16;
  std::__shared_weak_count *v17;

  v7 = (uint64_t *)(a1 + 240);
  v16 = a2;
  v17 = a3;
  if (a3)
  {
    p_shared_owners = (unint64_t *)&a3->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()(*v7, a2, a3, a4, a5, a6);
  if (a3)
  {
    v10 = (unint64_t *)&a3->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
  SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::SmartBlockWithArgs((uint64_t *)&v15, 0);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v7, &v15);
  v12 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
  if (*((_QWORD *)&v15 + 1))
  {
    v13 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_183FE39A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t *p_shared_owners;
  unint64_t v7;
  void (*v8)(_QWORD *, uint64_t *, uint64_t, uint64_t, uint64_t);
  uint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v19;
  std::__shared_weak_count *v20;

  if (a1)
  {
    if (a3)
    {
      p_shared_owners = (unint64_t *)&a3->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    v8 = *(void (**)(_QWORD *, uint64_t *, uint64_t, uint64_t, uint64_t))(a1 + 8);
    v9 = *(_QWORD *)(a1 + 16);
    v10 = (_QWORD *)(a1 + (v9 >> 1));
    if ((v9 & 1) != 0)
      v8 = *(void (**)(_QWORD *, uint64_t *, uint64_t, uint64_t, uint64_t))(*v10 + v8);
    v19 = a2;
    v20 = a3;
    if (a3)
    {
      v11 = (unint64_t *)&a3->__shared_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    v8(v10, &v19, a4, a5, a6);
    v13 = v20;
    if (v20)
    {
      v14 = (unint64_t *)&v20->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    if (a3)
    {
      v16 = (unint64_t *)&a3->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
        std::__shared_weak_count::__release_weak(a3);
      }
    }
  }
}

void sub_183FE3AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_initial(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_normal;
  a1[2] = 0;
  v2 = *a1;
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_183FE3B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

_QWORD *std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(_QWORD *a1, uint64_t a2, std::__shared_weak_count *this)
{
  std::__shared_weak_count *v4;
  uint64_t v6;

  *a1 = a2;
  if (this)
  {
    v4 = std::__shared_weak_count::lock(this);
    a1[1] = v4;
    if (v4)
      return a1;
  }
  else
  {
    a1[1] = 0;
  }
  v6 = std::__throw_bad_weak_ptr[abi:nn180100]();
  return (_QWORD *)TunnelProxy<HTTPEngine>::~TunnelProxy(v6);
}

void NetworkProxy::~NetworkProxy(NetworkProxy *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  std::__shared_weak_count *v5;

  *(_QWORD *)this = &off_1E14E6108;
  v2 = (const void *)*((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v4)
    CFRelease(v4);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 48);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
  *(_QWORD *)this = &off_1E14E5838;
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

{
  NetworkProxy::~NetworkProxy(this);
  JUMPOUT(0x186DB748CLL);
}

void TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<HTTPEngine::HTTPEngineDelegate,TunnelProxy<HTTPEngine>>(_QWORD *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v13, a2, a3);
  v6 = a4 + 104;
  v7 = v14;
  if (!a4)
    v6 = 0;
  *a1 = v6;
  a1[1] = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    v10 = v14;
    if (v14)
    {
      v11 = (unint64_t *)&v14->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
}

void std::allocate_shared[abi:nn180100]<HTTPEngine,std::allocator<HTTPEngine>,std::shared_ptr<TransportConnection> &,std::shared_ptr<HTTPEngine::HTTPEngineDelegate>,void>(uint64_t *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4)
{
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19[2];
  uint64_t v20[2];

  v8 = operator new(0x178uLL);
  v9 = v8;
  v8[1] = 0;
  v8[2] = 0;
  *v8 = &off_1E14F0750;
  v10 = (uint64_t)(v8 + 3);
  v20[0] = a2;
  v20[1] = (uint64_t)a3;
  if (a3)
  {
    p_shared_owners = (unint64_t *)&a3->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v13 = *a4;
  v14 = (std::__shared_weak_count *)a4[1];
  v19[0] = v13;
  v19[1] = (uint64_t)v14;
  if (v14)
  {
    p_shared_weak_owners = (unint64_t *)&v14->__shared_weak_owners_;
    do
      v16 = __ldxr(p_shared_weak_owners);
    while (__stxr(v16 + 1, p_shared_weak_owners));
  }
  HTTPEngine::HTTPEngine((uint64_t)(v8 + 3), v20, v19);
  if (v14)
    std::__shared_weak_count::__release_weak(v14);
  if (a3)
  {
    v17 = (unint64_t *)&a3->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
  *a1 = v10;
  a1[1] = (uint64_t)v9;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)a1, v9 + 4, v10);
}

void sub_183FE3E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  void *v14;

  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::__shared_weak_count::~__shared_weak_count(v11);
  operator delete(v14);
  _Unwind_Resume(a1);
}

void TunnelProxy<HTTPEngine>::completeTask(uint64_t a1, char a2)
{
  int v2;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(_QWORD *, uint64_t);
  uint64_t v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  __int128 v13;

  v2 = *(_DWORD *)(a1 + 272) - 1;
  *(_DWORD *)(a1 + 272) = v2;
  if (!v2)
  {
    v5 = a1 + 256;
    v6 = *(_QWORD *)(a1 + 256);
    if (v6)
    {
      v7 = *(void (**)(_QWORD *, uint64_t))(v6 + 8);
      v8 = *(_QWORD *)(v6 + 16);
      v9 = (_QWORD *)(v6 + (v8 >> 1));
      if ((v8 & 1) != 0)
        v7 = *(void (**)(_QWORD *, uint64_t))(*v9 + v7);
      v7(v9, 1);
    }
    SmartBlockWithArgs<BOOL>::SmartBlockWithArgs((uint64_t *)&v13, 0);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v5, &v13);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
    if (!*((_QWORD *)&v13 + 1))
      goto LABEL_10;
    v11 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if ((a2 & 1) != 0)
        return;
    }
    else
    {
LABEL_10:
      if ((a2 & 1) != 0)
        return;
    }
    TunnelProxy<HTTPEngine>::establishTunnel(a1);
  }
}

uint64_t *SmartBlockWithArgs<BOOL>::SmartBlockWithArgs(uint64_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  v4[1] = BlockHolderVar<BOOL>::invoke_initial;
  v4[2] = 0;
  *v4 = _Block_copy(a2);
  *a1 = (uint64_t)v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F1470;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a1[1] = (uint64_t)v5;
  if (!a2)
  {
    v6 = *a1;
    *(_QWORD *)(v6 + 8) = BlockHolderVar<BOOL>::invoke_reseted;
    *(_QWORD *)(v6 + 16) = 0;
  }
  return a1;
}

void sub_183FE401C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void TunnelProxy<HTTPEngine>::establishTunnel(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  _QWORD aBlock[5];
  _QWORD v9[2];
  uint64_t v10[2];

  HTTPEngine::resetResponse(*(HTTPEngine **)(a1 + 112));
  v2 = *(_QWORD *)(a1 + 112);
  v3 = *(std::__shared_weak_count **)(a1 + 168);
  v10[0] = *(_QWORD *)(a1 + 160);
  v10[1] = (uint64_t)v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v9[0] = 0;
  v9[1] = 0;
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke;
  aBlock[3] = &__block_descriptor_40_e13_v24__0___qi_8l;
  aBlock[4] = a1;
  HTTPEngine::writeRequest(v2, v10, v9, aBlock);
  if (v3)
  {
    v6 = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_183FE4108(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 - 32);
  _Unwind_Resume(a1);
}

void ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD v11[5];
  _QWORD v12[7];

  v3 = *(_QWORD *)(a1 + 32);
  if (a3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 144))(v3);
  }
  else
  {
    ++*(_DWORD *)(v3 + 272);
    v4 = *(_QWORD *)(v3 + 112);
    v5 = *(_QWORD *)(v3 + 160);
    v6 = *(std::__shared_weak_count **)(v3 + 168);
    v12[5] = v5;
    v12[6] = v6;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    v11[4] = v3;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_2;
    v12[3] = &__block_descriptor_40_e93_v40__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8___qi_24l;
    v12[4] = v3;
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_3;
    v11[3] = &__block_descriptor_40_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
    HTTPEngine::readResponse(v4, v5, (uint64_t)v6, 0, v12, v11, &__block_literal_global_699);
    if (v6)
    {
      v9 = (unint64_t *)&v6->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_183FE422C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 - 32);
  _Unwind_Resume(a1);
}

void ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_2(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  HTTPMessage **v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  NSObject *v40;
  int v41;
  __int128 v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  unint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  std::__shared_weak_count *v58;
  HTTPResponseMessage *v59;
  std::__shared_weak_count *v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  _BYTE buf[24];
  void *v66;
  uint64_t v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  if ((_DWORD)a4)
  {
    (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v4 + 144))(*(_QWORD *)(a1 + 32), a3, a4);
    return;
  }
  v5 = (HTTPMessage **)(v4 + 176);
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v4 + 176), *a2, a2[1]);
  v6 = *(_DWORD *)(*(_QWORD *)(v4 + 176) + 128);
  if (v6 == 407)
  {
    v7 = *(_QWORD *)(v4 + 144);
    if (!v7)
    {
      v8 = operator new(0x50uLL);
      v8[1] = 0;
      v8[2] = 0;
      *v8 = &off_1E14F0788;
      *((_OWORD *)v8 + 2) = 0u;
      *((_OWORD *)v8 + 3) = 0u;
      *((_OWORD *)v8 + 4) = 0u;
      *(_QWORD *)&buf[8] = v8;
      v8[3] = &off_1E14E4C88;
      *(_QWORD *)buf = v8 + 3;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v4 + 144, (__int128 *)buf);
      v9 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v10 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      v7 = *(_QWORD *)(v4 + 144);
    }
    ++*(_DWORD *)(v4 + 272);
    v13 = *(_QWORD *)(v4 + 216);
    v12 = *(std::__shared_weak_count **)(v4 + 224);
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v63, *(_QWORD *)(v4 + 8), *(std::__shared_weak_count **)(v4 + 16));
    v16 = *(std::__shared_weak_count **)(v4 + 168);
    v61 = *(_QWORD *)(v4 + 160);
    v62 = v16;
    if (v16)
    {
      v17 = (unint64_t *)&v16->__shared_owners_;
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }
    v19 = *(std::__shared_weak_count **)(v4 + 184);
    v59 = *(HTTPResponseMessage **)(v4 + 176);
    v60 = v19;
    if (v19)
    {
      v20 = (unint64_t *)&v19->__shared_owners_;
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke;
    v66 = &__block_descriptor_40_e91_v40__0_shared_ptr_HTTPRequestMessage____HTTPRequestMessage_____shared_weak_count__8___qi_24l;
    v67 = v4;
    SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::SmartBlockWithArgs(&v57, buf);
    AuthLiaison::negotiateAuthentication(v7, v13, (uint64_t)v12, &v63, &v61, &v59, &v57);
    v22 = v58;
    if (v58)
    {
      v23 = (unint64_t *)&v58->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    v25 = v60;
    if (v60)
    {
      v26 = (unint64_t *)&v60->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    v28 = v62;
    if (v62)
    {
      v29 = (unint64_t *)&v62->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = v64;
    if (v64)
    {
      v32 = (unint64_t *)&v64->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    if (!v12)
      goto LABEL_80;
    v34 = (unint64_t *)&v12->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
LABEL_78:
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    goto LABEL_80;
  }
  if (v6 != 200)
  {
    v36 = *(_QWORD *)(v4 + 112);
    v37 = *(_QWORD *)(v36 + 56);
    v12 = *(std::__shared_weak_count **)(v36 + 64);
    if (v12)
    {
      v38 = (unint64_t *)&v12->__shared_owners_;
      do
        v39 = __ldxr(v38);
      while (__stxr(v39 + 1, v38));
    }
    if (CFNLog::onceToken != -1)
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4755);
    v40 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      if (v37)
        v56 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v37 + 256))(v37);
      else
        v56 = 0;
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v56;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v6;
      _os_log_error_impl(&dword_183ECA000, v40, OS_LOG_TYPE_ERROR, "HTTPS Proxy Connection [%llu] received status code %d", buf, 0x12u);
    }
    if ((v6 - 300) >= 0x64)
      v41 = -2096;
    else
      v41 = -2098;
    *(_QWORD *)(v4 + 200) = 4;
    *(_DWORD *)(v4 + 208) = v41;
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(buf, *(_QWORD *)(v4 + 8), *(std::__shared_weak_count **)(v4 + 16), v4);
    v42 = *(_OWORD *)buf;
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    v43 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
    TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion(v4, v42, *((std::__shared_weak_count **)&v42 + 1), 0, *(_QWORD *)(v4 + 200), *(_QWORD *)(v4 + 208));
    if (v43)
    {
      v44 = (unint64_t *)&v43->__shared_owners_;
      do
        v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }
    v46 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v47 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }
    HTTPEngine::_cleanupConnection(*(HTTPEngine **)(v4 + 112), 0);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v4 + 112, (__int128 *)buf);
    v49 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v50 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v4 + 216, (__int128 *)buf);
    v52 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v53 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
    }
    *(_QWORD *)(v4 + 200) = 0;
    *(_DWORD *)(v4 + 208) = 0;
    if (!v12)
      goto LABEL_80;
    v55 = (unint64_t *)&v12->__shared_owners_;
    do
      v35 = __ldaxr(v55);
    while (__stlxr(v35 - 1, v55));
    goto LABEL_78;
  }
  HTTPEngine::setProperty(*(HTTPEngine **)(v4 + 112), (CFStringRef)&unk_1EDCFE508, (const void *)*MEMORY[0x1E0C9AE50]);
LABEL_80:
  HTTPMessage::ensureParserFinished(*v5);
  HTTPMessage::removeHeaderFieldValue(*v5, 0x141153BEu);
  HTTPMessage::removeHeaderFieldValue(*v5, 0x142173C4u);
}

void sub_183FE4820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v21;

  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v21 = __ldaxr(p_shared_owners);
    while (__stlxr(v21 - 1, p_shared_owners));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  _Unwind_Resume(exception_object);
}

void ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_3(uint64_t a1, dispatch_object_t object, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8;
  NSObject *v10;
  HTTPMessage *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  const __CFString *v25;
  const __CFString *v26;
  HTTPMessage *v27;
  const __CFString *v28;
  const __CFString *v29;
  CFComparisonResult v30;
  __int128 v31;

  v8 = *(_QWORD *)(a1 + 32);
  if (object)
  {
    v10 = *(NSObject **)(v8 + 192);
    if (!v10)
    {
      dispatch_retain(object);
      *(_QWORD *)(v8 + 192) = object;
      if ((_DWORD)a4)
        goto LABEL_5;
      goto LABEL_7;
    }
    *(_QWORD *)(v8 + 192) = dispatch_data_create_concat(*(dispatch_data_t *)(v8 + 192), object);
    dispatch_release(v10);
  }
  if ((_DWORD)a4)
  {
LABEL_5:
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 144))(v8, a3, a4);
    return;
  }
LABEL_7:
  if (!a5)
    return;
  v11 = *(HTTPMessage **)(v8 + 176);
  if (*((_DWORD *)v11 + 32) != 200)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
    v25 = HTTPMessage::copyHeaderFieldValue(v11, 0x13721369u);
    v26 = v25;
    if (v25 && CFStringCompare(v25, CFSTR("close"), 1uLL) == kCFCompareEqualTo)
    {
      CFRelease(v26);
    }
    else
    {
      v27 = *(HTTPMessage **)(v8 + 176);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5133);
      v28 = HTTPMessage::copyHeaderFieldValue(v27, 0x119152ADu);
      v29 = v28;
      if (!v28)
      {
        if (v26)
          CFRelease(v26);
        goto LABEL_46;
      }
      v30 = CFStringCompare(v28, CFSTR("close"), 1uLL);
      CFRelease(v29);
      if (v26)
        CFRelease(v26);
      if (v30)
      {
LABEL_46:
        TunnelProxy<HTTPEngine>::completeTask(v8, *(_DWORD *)(v8 + 208) != 0);
        return;
      }
    }
    HTTPEngine::_cleanupConnection(*(HTTPEngine **)(v8 + 112), 0);
    TunnelProxy<HTTPEngine>::newConnectionRequired(v8);
    goto LABEL_46;
  }
  TunnelProxy<HTTPEngine>::completeTask(v8, 1);
  v31 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8 + 144, &v31);
  v12 = (std::__shared_weak_count *)*((_QWORD *)&v31 + 1);
  if (*((_QWORD *)&v31 + 1))
  {
    v13 = (unint64_t *)(*((_QWORD *)&v31 + 1) + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v31 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8 + 216, &v31);
  v15 = (std::__shared_weak_count *)*((_QWORD *)&v31 + 1);
  if (*((_QWORD *)&v31 + 1))
  {
    v16 = (unint64_t *)(*((_QWORD *)&v31 + 1) + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(&v31, *(_QWORD *)(v8 + 8), *(std::__shared_weak_count **)(v8 + 16), v8);
  v18 = v31;
  v31 = 0uLL;
  v19 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
  TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion(v8, v18, *((std::__shared_weak_count **)&v18 + 1), 0, 0, 0);
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v21 = __ldaxr(p_shared_owners);
    while (__stlxr(v21 - 1, p_shared_owners));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = (std::__shared_weak_count *)*((_QWORD *)&v31 + 1);
  if (*((_QWORD *)&v31 + 1))
  {
    v23 = (unint64_t *)(*((_QWORD *)&v31 + 1) + 8);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  *(_QWORD *)(v8 + 200) = 0;
  *(_DWORD *)(v8 + 208) = 0;
}

void sub_183FE4D18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  const void *v10;
  const void *v11;

  CFRelease(v11);
  if (v10)
    CFRelease(v10);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<__CFDictionary const*,Deleter_CFRelease,std::allocator<__CFDictionary const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  __int128 v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[5];
  __int128 v16;

  v4 = *(_QWORD *)(a1 + 32);
  if (a4 && a4 != -1002)
  {
    *(_DWORD *)(v4 + 208) = a4;
    *(_QWORD *)(v4 + 200) = a3;
    TunnelProxy<HTTPEngine>::completeTask(v4, 1);
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(&v16, *(_QWORD *)(v4 + 8), *(std::__shared_weak_count **)(v4 + 16), v4);
    v8 = v16;
    v16 = 0uLL;
    v9 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
    TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion(v4, v8, *((std::__shared_weak_count **)&v8 + 1), 0, *(_QWORD *)(v4 + 200), *(_QWORD *)(v4 + 208));
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
    if (*((_QWORD *)&v16 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
  else
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((_QWORD *)(v4 + 160), *a2, a2[1]);
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke_2;
    v15[3] = &__block_descriptor_40_e8_v12__0B8l;
    v15[4] = v4;
    SmartBlockWithArgs<BOOL>::SmartBlockWithArgs((uint64_t *)&v16, v15);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v4 + 256, &v16);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
    if (*((_QWORD *)&v16 + 1))
    {
      v6 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    TunnelProxy<HTTPEngine>::completeTask(v4, 0);
  }
}

void sub_183FE4F70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32);
  _Unwind_Resume(a1);
}

uint64_t *SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::SmartBlockWithArgs(uint64_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  v4[1] = BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial;
  v4[2] = 0;
  *v4 = _Block_copy(a2);
  *a1 = (uint64_t)v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E14F1208;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  a1[1] = (uint64_t)v5;
  if (!a2)
  {
    v6 = *a1;
    *(_QWORD *)(v6 + 8) = BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_reseted;
    *(_QWORD *)(v6 + 16) = 0;
  }
  return a1;
}

void sub_183FE5030(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DB748C](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_normal;
  a1[2] = 0;
  v2 = *a1;
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_183FE50E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void (*v3)(uint64_t *, uint64_t *);
  BOOL v4;
  int v5;
  _QWORD *v7;
  void (*v8)(uint64_t *, uint64_t *);
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(void (**)(uint64_t *, uint64_t *))(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | (unint64_t)v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if (v3 == BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      v8 = *(void (**)(uint64_t *, uint64_t *))(*v7
                                                       + BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial);
    else
      v8 = BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial;
    v13 = 0;
    v14 = 0;
    ((void (*)(_QWORD *, uint64_t *, _QWORD, _QWORD))v8)(v7, &v13, 0, 0);
    v9 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  _Block_release(*(const void **)v1);
  return MEMORY[0x186DB748C](v1, 0x80C40D6874129);
}

void sub_183FE5208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  unint64_t *p_shared_owners;
  unint64_t v12;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

void BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_normal(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *a1;
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_183FE52D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

double ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke_2(uint64_t a1, int a2)
{
  double result;

  if (a2)
  {
    result = NAN;
    *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112) + 176) = xmmword_1841E3800;
  }
  return result;
}

void std::__shared_ptr_emplace<AuthLiaison>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0788;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AuthLiaison>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0788;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t std::__shared_ptr_emplace<AuthLiaison>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t BlockHolderVar<BOOL>::invoke_initial(_QWORD *a1)
{
  a1[1] = BlockHolderVar<BOOL>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL> *,SmartBlockWithArgs<BOOL>::Deleter,std::allocator<BlockHolderVar<BOOL>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL> *,SmartBlockWithArgs<BOOL>::Deleter,std::allocator<BlockHolderVar<BOOL>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  int v5;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    v4 = (*(_QWORD *)(v1 + 16) & 1 | v3) == 0;
  else
    v4 = 1;
  v5 = v4;
  if ((uint64_t (*)(_QWORD *))v3 == BlockHolderVar<BOOL>::invoke_initial && v5 != 0)
  {
    v7 = (_QWORD *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0)
      (*(void (**)(_QWORD *, _QWORD))(*v7 + BlockHolderVar<BOOL>::invoke_initial))(v7, 0);
    else
      ((void (*)(_QWORD *, _QWORD))BlockHolderVar<BOOL>::invoke_initial)(v7, 0);
  }
  _Block_release(*(const void **)v1);
  JUMPOUT(0x186DB748CLL);
}

uint64_t BlockHolderVar<BOOL>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

void std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  if (a2)
  {
    v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
        do
          v9 = __ldxr(p_shared_weak_owners);
        while (__stxr(v9 + 1, p_shared_weak_owners));
        v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4)
        std::__shared_weak_count::__release_weak(v4);
      if (v5)
      {
        v10 = (unint64_t *)&v5->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }
}

void std::__shared_ptr_emplace<HTTPEngine>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0750;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTPEngine>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E14F0750;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

_QWORD *std::shared_ptr<HTTPRequestMessage>::operator=[abi:nn180100]<HTTPRequestMessage,Deleter_release<HTTPRequestMessage>,void>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  if (*a2)
  {
    v5 = (_QWORD *)operator new();
    v6 = *a2;
    *v5 = &off_1E14F16D8;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
  }
  *a2 = 0;
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void std::__shared_ptr_pointer<HTTPRequestMessage *,Deleter_release<HTTPRequestMessage>,std::allocator<HTTPRequestMessage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DB748CLL);
}

CFWriteStreamRef CFWriteStreamCreateWithFTPURL(CFAllocatorRef alloc, CFURLRef ftpURL)
{
  const __CFURL *CFFTPHappyURL;
  const __CFURL *v4;
  const __CFString *v5;
  const __CFString *v6;
  __CFWriteStream *v7;
  CFStringRef v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  _QWORD *v13;
  _QWORD *v14;
  CFMutableDictionaryRef Mutable;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  const __CFString *v19;
  const void *v20;
  const void *v21;
  __int128 v23;
  void (*v24)(const void *, _QWORD *);
  CFStringRef (*v25)(const void *, uint64_t);
  uint64_t (*v26)(const void *, uint64_t, _BYTE *, uint64_t);
  uint64_t (*v27)(char *, uint64_t, char *);
  uint64_t (*v28)(int, unsigned __int8 *, uint64_t, _QWORD *, uint64_t *);
  uint64_t (*v29)(int, char *);
  void **(*v30)(uint64_t, uint64_t);
  CFArrayRef (*v31)(int, CFTypeRef, uint64_t);
  uint64_t (*v32)(int, const __CFString *, const __CFString *, uint64_t);
  uint64_t v33;
  uint64_t (*v34)(uint64_t, CoreSchedulingSet *, const __CFString *, uint64_t);
  void (*v35)(uint64_t, __CFRunLoop *, const __CFString *, uint64_t);

  if (!ftpURL)
    return 0;
  CFFTPHappyURL = _CreateCFFTPHappyURL(ftpURL);
  if (!CFFTPHappyURL)
    return 0;
  v4 = CFFTPHappyURL;
  if (!_ValidFTPPathname(CFFTPHappyURL))
    goto LABEL_31;
  v5 = CFURLCopyScheme(v4);
  if (!v5)
    goto LABEL_31;
  v6 = v5;
  if (CFStringCompare(v5, CFSTR("ftp"), 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v6, CFSTR("ftps"), 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(v6);
    v8 = CFURLCopyHostName(v4);
    if (v8)
    {
      CFRelease(v8);
      v9 = CFURLCopyUserName(v4);
      v10 = v9;
      if (v9 && !_ValidFTPString(v9))
      {
        v19 = v10;
      }
      else
      {
        v11 = CFURLCopyPassword(v4);
        v12 = v11;
        if (!v11 || _ValidFTPString(v11))
        {
          v13 = CFAllocatorAllocate(alloc, 144, 0);
          if (v13)
          {
            v14 = v13;
            *((_OWORD *)v13 + 7) = 0u;
            *((_OWORD *)v13 + 8) = 0u;
            *((_OWORD *)v13 + 5) = 0u;
            *((_OWORD *)v13 + 6) = 0u;
            *((_OWORD *)v13 + 3) = 0u;
            *((_OWORD *)v13 + 4) = 0u;
            *((_OWORD *)v13 + 1) = 0u;
            *((_OWORD *)v13 + 2) = 0u;
            *(_OWORD *)v13 = 0u;
            *(_WORD *)v13 = 129;
            v13[1] = CFURLCopyAbsoluteURL(v4);
            v14[10] = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E0C9B378]);
            Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v14[11] = Mutable;
            v16 = (const void *)v14[1];
            if (v16)
            {
              if (!v14[10] || !Mutable)
                goto LABEL_34;
              v23 = 1uLL;
              v24 = _FTPStreamFinalize;
              v25 = _FTPStreamCopyDescription;
              v26 = _FTPStreamOpen;
              v27 = _FTPStreamOpenCompleted;
              v28 = _FTPStreamWrite;
              v29 = _FTPStreamCanWrite;
              v30 = _FTPStreamClose;
              v31 = _FTPStreamCopyProperty;
              v32 = _FTPStreamSetProperty;
              v33 = 0;
              v34 = _FTPStreamSchedule;
              v35 = _FTPStreamUnschedule;
              v17 = CoreWriteStreamCreate((uint64_t)alloc, &v23, (uint64_t)v14);
              if (v17)
              {
                v18 = v17;
                v14[4] = v17;
                if (v10)
                {
                  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
                    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
                  ++*(_QWORD *)(v18 + 96);
                  (*(void (**)(_QWORD, const __CFString *, const __CFString *))(**(_QWORD **)(v18 + 40) + 32))(*(_QWORD *)(v18 + 40), CFSTR("kCFStreamPropertyFTPUserName_prevalidated"), v10);
                  --*(_QWORD *)(v18 + 96);
                }
                if (v12)
                {
                  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
                    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3166);
                  ++*(_QWORD *)(v18 + 96);
                  (*(void (**)(_QWORD, const __CFString *, const __CFString *))(**(_QWORD **)(v18 + 40) + 32))(*(_QWORD *)(v18 + 40), CFSTR("kCFStreamPropertyFTPPassword_prevalidated"), v12);
                  --*(_QWORD *)(v18 + 96);
                }
LABEL_41:
                CFRelease(v4);
                if (v10)
                  CFRelease(v10);
                if (v12)
                  CFRelease(v12);
                if (v18)
                {
                  v7 = (__CFWriteStream *)_CFWriteStreamCreateWithCoreStream();
                  v4 = (const __CFURL *)v18;
                  goto LABEL_32;
                }
                return 0;
              }
              v16 = (const void *)v14[1];
              if (v16)
LABEL_34:
                CFRelease(v16);
            }
            v20 = (const void *)v14[10];
            if (v20)
              CFRelease(v20);
            v21 = (const void *)v14[11];
            if (v21)
              CFRelease(v21);
            CFAllocatorDeallocate(alloc, v14);
          }
          v18 = 0;
          goto LABEL_41;
        }
        if (v10)
          CFRelease(v10);
        v19 = v12;
      }
      CFRelease(v19);
    }
LABEL_31:
    v7 = 0;
    goto LABEL_32;
  }
  CFRelease(v4);
  v7 = 0;
  v4 = (const __CFURL *)v6;
LABEL_32:
  CFRelease(v4);
  return v7;
}

CFURLRef _CreateCFFTPHappyURL(const __CFURL *a1)
{
  const __CFURL *v1;
  const __CFURL *v2;
  CFIndex v3;
  CFIndex v4;
  UInt8 *v5;
  CFURLRef v6;
  CFIndex v7;
  UInt8 *v8;
  const __CFAllocator *v9;
  UInt8 buffer[2048];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v1 = CFURLCopyAbsoluteURL(a1);
  if (v1)
  {
    v2 = v1;
    v3 = CFURLGetBytes(v1, buffer, 2048);
    if (v3 == -1)
    {
      v7 = CFURLGetBytes(v2, 0, 0);
      v8 = (UInt8 *)malloc_type_malloc(v7, 0x75D81533uLL);
      if (!v8)
      {
        v6 = 0;
LABEL_10:
        CFRelease(v2);
        return v6;
      }
      v5 = v8;
      v4 = CFURLGetBytes(v2, v8, v7);
    }
    else
    {
      v4 = v3;
      v5 = buffer;
    }
    v9 = CFGetAllocator(v2);
    v6 = CFURLCreateAbsoluteURLWithBytes(v9, v5, v4, 0, 0, 0);
    if (v5 != buffer)
      free(v5);
    goto LABEL_10;
  }
  return 0;
}

uint64_t _ValidFTPPathname(const __CFURL *a1)
{
  const __CFString *v1;
  const __CFString *v2;
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFIndex v12;
  UniChar v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFIndex v18;
  int v20;
  uint64_t v21;
  UniChar buffer[64];
  CFStringRef theString;
  const UniChar *v25;
  const char *v26;
  uint64_t v27;
  CFIndex v28;
  uint64_t v29;
  uint64_t v30;
  CFRange v31;

  v1 = _CFURLCopyPathReplacingPercentEscapes(a1);
  if (!v1)
    return 0;
  v2 = v1;
  Length = CFStringGetLength(v1);
  theString = v2;
  v27 = 0;
  v28 = Length;
  CharactersPtr = CFStringGetCharactersPtr(v2);
  CStringPtr = 0;
  v25 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(v2, 0x600u);
  v29 = 0;
  v30 = 0;
  v26 = CStringPtr;
  if (Length < 1)
  {
LABEL_32:
    v21 = 1;
    goto LABEL_35;
  }
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 64;
  while (1)
  {
    v11 = (unint64_t)v9 >= 4 ? 4 : v9;
    v12 = v28;
    if (v28 <= v9)
      break;
    if (v25)
    {
      v13 = v25[v9 + v27];
    }
    else if (v26)
    {
      v13 = v26[v27 + v9];
    }
    else
    {
      if (v30 <= v9 || v7 > v9)
      {
        v15 = v11 + v6;
        v16 = v10 - v11;
        v17 = v9 - v11;
        v18 = v17 + 64;
        if (v17 + 64 >= v28)
          v18 = v28;
        v29 = v17;
        v30 = v18;
        if (v28 >= v16)
          v12 = v16;
        v31.length = v12 + v15;
        v31.location = v17 + v27;
        CFStringGetCharacters(theString, v31, buffer);
        v7 = v29;
      }
      v13 = buffer[v9 - v7];
    }
    if (v13 != 10 && v13 != 13)
      break;
    v20 = 1;
LABEL_31:
    ++v9;
    --v6;
    ++v10;
    v8 = v20;
    if (Length == v9)
      goto LABEL_32;
  }
  v20 = 0;
  if (!v8)
    goto LABEL_31;
  v21 = 0;
LABEL_35:
  CFRelease(v2);
  return v21;
}

uint64_t _ValidFTPString(const __CFString *a1)
{
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  CFIndex v10;
  UniChar v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  UniChar buffer[64];
  CFStringRef theString;
  const UniChar *v21;
  const char *v22;
  uint64_t v23;
  CFIndex v24;
  uint64_t v25;
  uint64_t v26;
  CFRange v27;

  Length = CFStringGetLength(a1);
  theString = a1;
  v23 = 0;
  v24 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v21 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v25 = 0;
  v26 = 0;
  v22 = CStringPtr;
  if (Length < 1)
    return 1;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  for (i = 64; ; ++i)
  {
    v9 = (unint64_t)v7 >= 4 ? 4 : v7;
    v10 = v24;
    if (v24 > v7)
    {
      if (v21)
      {
        v11 = v21[v7 + v23];
      }
      else if (v22)
      {
        v11 = v22[v23 + v7];
      }
      else
      {
        if (v26 <= v7 || v6 > v7)
        {
          v13 = v9 + v5;
          v14 = i - v9;
          v15 = v7 - v9;
          v16 = v15 + 64;
          if (v15 + 64 >= v24)
            v16 = v24;
          v25 = v15;
          v26 = v16;
          if (v24 >= v14)
            v10 = v14;
          v27.length = v10 + v13;
          v27.location = v15 + v23;
          CFStringGetCharacters(theString, v27, buffer);
          v6 = v25;
        }
        v11 = buffer[v7 - v6];
      }
      if (v11 == 10 || v11 == 13)
        break;
    }
    ++v7;
    --v5;
    if (Length == v7)
      return 1;
  }
  return 0;
}

void _FTPStreamFinalize(const void *a1, _QWORD *a2)
{
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  uint64_t v10;
  const __CFAllocator *v11;

  _FTPStreamClose((uint64_t)a1, (uint64_t)a2);
  v4 = (const void *)a2[1];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a2[2];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)a2[10];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a2[11];
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a2[14];
  if (v8)
    CFRelease(v8);
  v9 = (const void *)a2[8];
  if (v9)
    CFRelease(v9);
  v10 = a2[17];
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  v11 = CFGetAllocator(a1);
  CFAllocatorDeallocate(v11, a2);
}

CFStringRef _FTPStreamCopyDescription(const void *a1, uint64_t a2)
{
  const __CFAllocator *v4;
  const __CFString *v5;

  v4 = CFGetAllocator(a1);
  v5 = CFSTR("upload");
  if ((*(_WORD *)a2 & 0x80) == 0)
    v5 = CFSTR("download");
  return CFStringCreateWithFormat(v4, 0, CFSTR("<FTPStream %p>{%@, url = %@, flags = %p }"), a1, v5, *(_QWORD *)(a2 + 8), a2);
}

uint64_t _FTPStreamOpen(const void *a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  const __CFAllocator *v8;
  const void *Value;
  _BOOL4 v10;
  const __CFArray *v11;
  const void *v12;
  __CFDictionary *v13;
  const void *v14;
  const __CFArray *v15;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v17;
  const void *v18;
  PAC *v19;
  const __CFArray *v20;
  CFStreamClientContext *v21;
  CFIndex Count;
  CFIndex v23;
  _BOOL4 v24;
  CFIndex i;
  __CFRunLoop *v26;
  const __CFString *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t result;
  const void *v32;
  const __CFString *v33;
  CFStringRef v34;
  const void *v35;
  const void *v36;
  __CFDictionary *v37;
  CFAbsoluteTime Current;
  __CFRunLoopTimer *v39;
  __CFRunLoop *v40;
  __CFRunLoop *v41;
  __CFError *v42;
  uint64_t v43;
  int v44;
  const void *v45;
  const void *v46;
  CFStringRef v47;
  int v48;
  CFMutableArrayRef Mutable;
  SInt32 v50;
  const __CFDictionary *v51;
  char *v52;
  _QWORD *v53;
  AutoDict *Copy;
  const void *EmptyDict;
  uint64_t *v56;
  NetConnection *NewConnection;
  NetConnection *v58;
  uint64_t v59;
  os_unfair_lock_s *v60;
  NetConnection *v61;
  os_unfair_lock_s *v62;
  const __CFString *v63;
  const __CFURL *v64;
  NetConnection *v65;
  uint64_t v66;
  CFIndex v67;
  unint64_t v68;
  const void *v69;
  uint64_t v70;
  uint64_t v71;
  NetConnection *v72;
  int *v73;
  uint64_t v74;
  uint64_t v75;
  const __CFAllocator *cf;
  CFTypeRef cfa;
  _BOOL4 v78;
  _QWORD v79[2];
  __int128 v80;
  __int128 v81;
  __int128 v82;
  SInt32 valuePtr;
  CFRunLoopTimerContext context;
  _QWORD v85[6];

  if (_FTPStreamOpen(void const*,CFStreamError *,unsigned char *,_CFFTPStreamContext *)::onceToken != -1)
    dispatch_once(&_FTPStreamOpen(void const*,CFStreamError *,unsigned char *,_CFFTPStreamContext *)::onceToken, &__block_literal_global_750);
  valuePtr = -1;
  v8 = CFGetAllocator(a1);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), CFSTR("kCFStreamPropertyFTPAttemptPersistentConnection"));
  if (Value)
    v10 = CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0C9AE40]) != 0;
  else
    v10 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_QWORD *)a2 = 0;
  v11 = *(const __CFArray **)(a4 + 112);
  if (v11 || (*(_WORD *)a4 & 0x1000) != 0)
  {
    if ((*(_WORD *)a4 & 0x1000) == 0)
      goto LABEL_24;
LABEL_49:
    *a3 = 0;
    return 1;
  }
  v12 = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), CFSTR("kCFStreamPropertyFTPProxy"));
  if (!v12 || (v13 = (__CFDictionary *)CFRetain(v12)) == 0)
  {
    v14 = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), &unk_1EDCFBF30);
    if (!v14 || (v13 = (__CFDictionary *)CFRetain(v14)) == 0)
      v13 = CFNetworkCopySystemProxySettings();
  }
  *(_WORD *)a4 &= ~0x1000u;
  v15 = (const __CFArray *)__CFNetworkCopyProxiesForURLWithInterface(*(const __CFURL **)(a4 + 8), v13, 0);
  if (v13)
    CFRelease(v13);
  *(_QWORD *)(a4 + 120) = 0;
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, 0);
  if (!v15)
  {
    v29 = 6;
    v28 = 0xFFFFFFFFLL;
    goto LABEL_44;
  }
  v17 = ValueAtIndex;
  v18 = CFDictionaryGetValue(ValueAtIndex, CFSTR("kCFProxyTypeKey"));
  if (!CFEqual(CFSTR("kCFProxyTypeAutoConfigurationURL"), v18))
  {
    v28 = 0;
    v29 = 0;
    *(_QWORD *)(a4 + 112) = v15;
    goto LABEL_44;
  }
  v85[0] = 0;
  v85[1] = a4;
  memset(&v85[2], 0, 24);
  v19 = (PAC *)CFDictionaryGetValue(v17, CFSTR("kCFProxyAutoConfigurationURLKey"));
  v20 = *(const __CFArray **)(a4 + 80);
  *(_QWORD *)(a4 + 96) = PAC::CreatePACTicket(v19, *(const void **)(a4 + 8), 0, 0, (std::__shared_weak_count_vtbl *)PACExecutionComplete_FTPStream, (void (*)(void *, const __CFArray *, __CFError *))v85, v21);
  *(_WORD *)a4 |= 0x1000u;
  if (v20 && CFArrayGetCount(v20) >= 1)
  {
    Count = CFArrayGetCount(v20);
    if (Count >= 1)
    {
      v23 = Count;
      cf = v8;
      v24 = v10;
      for (i = 0; i < v23; i += 2)
      {
        v26 = (__CFRunLoop *)CFArrayGetValueAtIndex(v20, i);
        v27 = (const __CFString *)CFArrayGetValueAtIndex(v20, i + 1);
        CFRunLoopAddSource(v26, *(CFRunLoopSourceRef *)(a4 + 96), v27);
      }
      v28 = 0;
      v29 = 0;
      v10 = v24;
      v8 = cf;
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  context.version = 0;
  context.info = (void *)a4;
  memset(&context.retain, 0, 24);
  Current = CFAbsoluteTimeGetCurrent();
  v39 = CFRunLoopTimerCreate(v8, Current + 60.0, -1.0, 0, 0, (CFRunLoopTimerCallBack)PACTimerCallback_FTPStream, &context);
  v40 = CFRunLoopGetCurrent();
  CFRunLoopAddSource(v40, *(CFRunLoopSourceRef *)(a4 + 96), CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"));
  v41 = CFRunLoopGetCurrent();
  CFRunLoopAddTimer(v41, v39, CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"));
  while ((*(_WORD *)a4 & 0x1000) != 0)
    CFRunLoopRunInMode(CFSTR("_kProxySupportSyncPACExecutionRunLoopMode"), 1.0e10, 1u);
  CFRunLoopTimerInvalidate(v39);
  if (v39)
    CFRelease(v39);
  v42 = *(__CFError **)(a4 + 104);
  if (!v42)
  {
LABEL_42:
    v28 = 0;
    v29 = 0;
    goto LABEL_43;
  }
  v29 = _CFStreamErrorFromCFError(v42);
  v28 = v43;
LABEL_43:
  CFRelease(v15);
LABEL_44:
  *(_QWORD *)a2 = v29;
  *(_QWORD *)(a2 + 8) = v28;
  if (*(_QWORD *)(a4 + 128))
  {
    result = 1;
    *a3 = 1;
    return result;
  }
  if ((*(_WORD *)a4 & 0x1000) != 0)
    goto LABEL_49;
  if ((_DWORD)v28)
  {
    result = 0;
    *a3 = 1;
    return result;
  }
  v11 = *(const __CFArray **)(a4 + 112);
LABEL_24:
  v30 = *(_QWORD *)(a4 + 120);
  if (v30 == CFArrayGetCount(v11))
  {
    *a3 = 1;
    if (*(_DWORD *)(a4 + 48))
    {
      result = 0;
      *(_OWORD *)a2 = *(_OWORD *)(a4 + 40);
      return result;
    }
    result = 0;
    *(_QWORD *)a2 = 1;
    v44 = 57;
    goto LABEL_131;
  }
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 48) = 0;
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a4 + 88), CFSTR("kCFStreamPropertyFTPProxy"));
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a4 + 88), &unk_1EDCFBF30);
  *(_WORD *)a4 &= 0xFFCFu;
  v32 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 112), *(_QWORD *)(a4 + 120));
  v33 = 0;
  v34 = 0;
  if (CFEqual(v32, &unk_1E152A808))
  {
LABEL_56:
    v47 = CFURLCopyScheme(*(CFURLRef *)(a4 + 8));
    if (valuePtr < 0)
      valuePtr = CFURLGetPortNumber(*(CFURLRef *)(a4 + 8));
    if (!v34)
      v34 = CFURLCopyHostName(*(CFURLRef *)(a4 + 8));
    if (CFStringCompare(v47, CFSTR("ftp"), 1uLL))
    {
      if (!CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), &unk_1EDCFBEC0))
        _FTPStreamSetProperty(0, (const __CFString *)&unk_1EDCFBEC0, (const __CFString *)&unk_1EDCFC1D0, a4);
      if (valuePtr == -1)
        valuePtr = 990;
      if (v33)
        v48 = 4;
      else
        v48 = 2;
      if (v47)
LABEL_69:
        CFRelease(v47);
    }
    else
    {
      if (valuePtr == -1)
        valuePtr = 21;
      if (v33)
        v48 = 3;
      else
        v48 = 1;
      if (v47)
        goto LABEL_69;
    }
    *a3 = 0;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    if (*(_QWORD *)(a4 + 128))
    {
LABEL_122:
      if (v34)
        CFRelease(v34);
      v72 = *(NetConnection **)(a4 + 128);
      if (!v72 || !NetConnection::enqueue(v72, (uint64_t *)a4, 0))
      {
        *a3 = 1;
        if (*__error())
        {
          v73 = __error();
          result = 0;
          v44 = *v73;
          *(_QWORD *)a2 = 1;
        }
        else
        {
          result = 0;
          *(_QWORD *)a2 = 1;
          v44 = 12;
        }
LABEL_131:
        *(_DWORD *)(a2 + 8) = v44;
        return result;
      }
      if (v10)
        NetConnection::doNotAllowMoreRequests(*(NetConnection **)(a4 + 128));
      return 1;
    }
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
    v78 = v10;
    if (v34)
    {
      v50 = valuePtr;
      v51 = *(const __CFDictionary **)(a4 + 88);
      v52 = (char *)CFAllocatorAllocate(v8, 48, 0);
      *(_QWORD *)(v52 + 20) = 0;
      *(_QWORD *)(v52 + 36) = 0;
      *(_QWORD *)(v52 + 28) = 0;
      *((_DWORD *)v52 + 11) = 0;
      *(_QWORD *)v52 = off_1E14EF578;
      *((_QWORD *)v52 + 1) = v8;
      *((_DWORD *)v52 + 4) = 1;
      if (((unint64_t)(v52 + 16) & 3) != 0)
        __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
      v53 = v52;
      *(_QWORD *)v52 = off_1E14F0098;
      Copy = (AutoDict *)CFStringCreateCopy(v8, v34);
      v53[3] = Copy;
      *((_DWORD *)v53 + 8) = v50;
      *((_DWORD *)v53 + 9) = v48;
      if (v51)
      {
        EmptyDict = CFDictionaryCreateCopy(v8, v51);
        v10 = v78;
      }
      else
      {
        EmptyDict = (const void *)AutoDict::getEmptyDict(Copy);
        v10 = v78;
        if (EmptyDict)
          EmptyDict = CFRetain(EmptyDict);
      }
      v53[5] = EmptyDict;
    }
    else
    {
      v53 = 0;
    }
    v81 = 0u;
    v82 = 0u;
    v79[0] = 0;
    v80 = 0u;
    v79[1] = v53;
    os_unfair_lock_lock((os_unfair_lock_t)&gFTPSpinLock);
    v56 = &-[__NSCFURLProtocolClient_NS withCustomProtocolScheduling:]::sOnce;
    if (!gFTPConnectionCache)
      _FTPConnectionCacheCreate();
    os_unfair_lock_unlock((os_unfair_lock_t)&gFTPSpinLock);
    os_unfair_lock_lock((os_unfair_lock_t)(gFTPConnectionCache + 8));
    CFDictionaryApplyFunction((CFDictionaryRef)gFTPConnectionTimeouts, (CFDictionaryApplierFunction)_FTPConnectionCacheExpiration, Mutable);
    os_unfair_lock_unlock((os_unfair_lock_t)(gFTPConnectionCache + 8));
    cfa = *(CFTypeRef *)(a4 + 88);
    if (v10)
    {
      NewConnection = createNewConnection(v8, _kFTPConnectionCallBacks, (uint64_t)v79, 0);
      if (NewConnection)
      {
        v58 = NewConnection;
        setConnectionProperties(NewConnection, cfa);
        goto LABEL_106;
      }
LABEL_109:
      os_unfair_lock_lock((os_unfair_lock_t)(v56[29] + 8));
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gFTPConnectionTimeouts, *(const void **)(a4 + 128));
      v10 = v78;
      if (CFArrayGetCount(Mutable))
      {
        v67 = CFArrayGetCount(Mutable);
        if (v67 >= 1)
        {
          v68 = v67 + 1;
          do
          {
            v69 = CFArrayGetValueAtIndex(Mutable, v68 - 2);
            CFDictionaryRemoveValue((CFMutableDictionaryRef)gFTPConnectionTimeouts, v69);
            if (v69 != *(const void **)(a4 + 128))
            {
              v70 = *((_QWORD *)v69 + 12);
              if (v70)
                pthread_mutex_lock((pthread_mutex_t *)(v70 + 8));
              *((_WORD *)v69 + 44) &= ~1u;
              NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)v69);
              v71 = *((_QWORD *)v69 + 12);
              if (v71)
                pthread_mutex_unlock((pthread_mutex_t *)(v71 + 8));
            }
            --v68;
          }
          while (v68 > 1);
        }
      }
      if (Mutable)
        CFRelease(Mutable);
      os_unfair_lock_unlock((os_unfair_lock_t)(gFTPConnectionCache + 8));
      if (v53)
        (*(void (**)(_QWORD *))(*v53 + 48))(v53);
      goto LABEL_122;
    }
    v74 = _kFTPConnectionCallBacks;
    v59 = gFTPConnectionCache;
    v60 = (os_unfair_lock_s *)(gFTPConnectionCache + 8);
    os_unfair_lock_lock((os_unfair_lock_t)(gFTPConnectionCache + 8));
    v75 = v59;
    v61 = (NetConnection *)CFDictionaryGetValue(*(CFDictionaryRef *)(v59 + 16), v53);
    if (v61)
    {
      v58 = v61;
      if (NetConnection::willEnqueueRequests(v61))
      {
        v62 = v60;
        (*(void (**)(NetConnection *))(*(_QWORD *)v58 + 40))(v58);
        goto LABEL_105;
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v75 + 16), v53);
    }
    v65 = createNewConnection(v8, v74, (uint64_t)v79, 1);
    if (!v65)
    {
      os_unfair_lock_unlock(v60);
      v56 = &-[__NSCFURLProtocolClient_NS withCustomProtocolScheduling:]::sOnce;
      goto LABEL_109;
    }
    v58 = v65;
    v62 = v60;
    setConnectionProperties(v65, cfa);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v75 + 16), v53, v58);
LABEL_105:
    v56 = &-[__NSCFURLProtocolClient_NS withCustomProtocolScheduling:]::sOnce;
    os_unfair_lock_unlock(v62);
LABEL_106:
    *(_QWORD *)(a4 + 128) = v58;
    if (!*(_QWORD *)(a4 + 136))
    {
      v66 = operator new();
      *(_QWORD *)v66 = &off_1E14E6990;
      pthread_mutex_init((pthread_mutex_t *)(v66 + 8), 0);
      *(_QWORD *)v66 = &off_1E14E5818;
      *(_QWORD *)(a4 + 136) = v66;
    }
    goto LABEL_109;
  }
  v35 = CFDictionaryGetValue((CFDictionaryRef)v32, CFSTR("kCFProxyTypeKey"));
  v36 = CFDictionaryGetValue((CFDictionaryRef)v32, CFSTR("kCFProxyPortNumberKey"));
  v33 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v32, CFSTR("kCFProxyHostNameKey"));
  if (CFEqual(v35, CFSTR("kCFProxyTypeFTP")))
  {
    v37 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionaryAddValue(v37, CFSTR("FTPProxy"), v33);
    CFDictionaryAddValue(v37, CFSTR("FTPPort"), v36);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a4 + 88), CFSTR("kCFStreamPropertyFTPProxy"), v37);
    if (v37)
      CFRelease(v37);
    if (v33)
      CFRetain(v33);
    CFNumberGetValue((CFNumberRef)v36, kCFNumberSInt32Type, &valuePtr);
    v34 = v33;
    goto LABEL_56;
  }
  if (CFEqual(v35, CFSTR("kCFProxyTypeSOCKS")))
  {
    v45 = CFDictionaryGetValue((CFDictionaryRef)v32, CFSTR("kCFProxyUsernameKey"));
    v46 = CFDictionaryGetValue((CFDictionaryRef)v32, CFSTR("kCFProxyPasswordKey"));
    _SetSOCKS5ProxyInformation(v8, a4, v33, v36, v45, v46);
    v33 = 0;
LABEL_55:
    v34 = 0;
    goto LABEL_56;
  }
  if (!CFEqual(v35, CFSTR("kCFProxyTypeHTTP")) && !CFEqual(v35, CFSTR("kCFProxyTypeHTTPS")))
    goto LABEL_55;
  LODWORD(v85[0]) = 0;
  if ((*(_WORD *)a4 & 0x80) != 0)
  {
    ++*(_QWORD *)(a4 + 120);
    return _FTPStreamOpen(a1, a2, a3, a4);
  }
  else
  {
    CFNumberGetValue((CFNumberRef)v36, kCFNumberSInt32Type, v85);
    v63 = CFStringCreateWithFormat(v8, 0, CFSTR("http://%@:%d"), v33, LODWORD(v85[0]));
    v64 = CFURLCreateWithString(v8, v63, 0);
    if (v63)
      CFRelease(v63);
    _StartHTTPRequest(v8, (_WORD *)a4, (_QWORD *)a2, v64);
    if (v64)
      CFRelease(v64);
    *a3 = 1;
    return *(_DWORD *)(a2 + 8) == 0;
  }
}

