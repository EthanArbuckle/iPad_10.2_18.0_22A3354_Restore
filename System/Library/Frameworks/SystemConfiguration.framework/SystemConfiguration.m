CFArrayRef SCNetworkProxiesCopyMatching(const void *a1, __CFString *a2, const __CFString *a3)
{
  return _SCNetworkProxiesCopyMatchingInternal(a1, a2, a3, 0);
}

dispatch_queue_t ___callback_queue_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("SCNetworkReachability.callback", 0);
  _callback_queue_q = (uint64_t)result;
  return result;
}

dispatch_queue_t __storeQueue_block_invoke()
{
  dispatch_queue_t result;

  _sc_store_sessions = (uint64_t)CFSetCreateMutable(0, 0, 0);
  result = dispatch_queue_create("SCDynamicStore/client sessions", 0);
  storeQueue_q = (uint64_t)result;
  return result;
}

CFStringRef SCNetworkInterfaceGetInterfaceType(SCNetworkInterfaceRef interface)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_6;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) == v2)
    return (CFStringRef)*((_QWORD *)interface + 2);
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

Boolean SCPreferencesLock(SCPreferencesRef prefs, Boolean wait)
{
  int v3;
  Boolean v4;
  int v6;
  mach_port_t *v7;
  mach_port_t v8;
  int v9;
  const __CFDictionary *v10;
  const void *v11;
  CFTypeID TypeID;
  pthread_mutex_t *v13;
  const char *v14;
  size_t v15;
  char *v16;
  __int128 v17;
  __darwin_time_t v18;
  int v19;
  __CFData *v20;
  int v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  pthread_mutex_t *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  int v37;
  int v38;
  CFStringRef v39;
  int v40;
  const __CFString *v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  pthread_mutex_t *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  int v57;
  NSObject *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  pthread_mutex_t *v68;
  char *v69;
  uint64_t v70;
  int *v71;
  char *v72;
  char *v73;
  NSObject *v74;
  uint64_t v75;
  uint64_t v76;
  pthread_mutex_t *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  int *v87;
  char *v88;
  int v89;
  pid_t v90;
  size_t v91;
  __int128 v92;
  __darwin_time_t v93;
  uint64_t v94;
  timeval v95;
  stat v96;
  stat v97;
  void *value[6];

  value[4] = *(void **)MEMORY[0x1E0C80C00];
  v93 = 0;
  v94 = 0;
  if (!prefs)
  {
    v3 = 3001;
    goto LABEL_5;
  }
  if (*((_BYTE *)prefs + 112))
  {
    v3 = 1006;
    goto LABEL_5;
  }
  v6 = wait;
  memset(&v97, 0, sizeof(v97));
  memset(&v96, 0, sizeof(v96));
  if (!*((_QWORD *)prefs + 39))
  {
    if (!*((_BYTE *)prefs + 306))
    {
      v3 = 1003;
      goto LABEL_5;
    }
    value[0] = 0;
    v10 = (const __CFDictionary *)*((_QWORD *)prefs + 12);
    if (!v10
      || !CFDictionaryGetValueIfPresent(v10, CFSTR("avoid-deadlock"), (const void **)value)
      || (v11 = value[0], TypeID = CFBooleanGetTypeID(), !v11)
      || CFGetTypeID(v11) != TypeID
      || CFBooleanGetValue((CFBooleanRef)value[0]))
    {
      if (__SCPreferencesUsingDefaultPrefs((uint64_t)prefs)
        && avoid_SCNetworkConfiguration_deadlock_once != -1)
      {
        dispatch_once(&avoid_SCNetworkConfiguration_deadlock_once, &__block_literal_global_5);
      }
    }
    v13 = (pthread_mutex_t *)((char *)prefs + 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)prefs + 16));
    __SCPreferencesAddSessionKeys((CFStringRef)prefs);
    if (!*((_QWORD *)prefs + 15))
    {
      v14 = (const char *)*((_QWORD *)prefs + 13);
      v15 = strlen(v14) + 6;
      v16 = (char *)CFAllocatorAllocate(0, v15, 0);
      *((_QWORD *)prefs + 15) = v16;
      snprintf(v16, v15, "%s-lock", v14);
    }
    v95.tv_sec = 0;
    *(_QWORD *)&v95.tv_usec = 0;
    gettimeofday(&v95, 0);
    if (*((_QWORD *)prefs + 22))
    {
LABEL_30:
      if (!lockWithSCDynamicStore((uint64_t)prefs, v6))
      {
        v57 = 1001;
        goto LABEL_83;
      }
LABEL_31:
      gettimeofday((timeval *)prefs + 8, 0);
      v18 = *((_QWORD *)prefs + 16) - v95.tv_sec;
      v93 = v18;
      v19 = *((_DWORD *)prefs + 34) - v95.tv_usec;
      LODWORD(v94) = v19;
      if (v19 < 0)
      {
        v93 = --v18;
        LODWORD(v94) = v19 + 1000000;
      }
      if (!*((_BYTE *)prefs + 304))
        goto LABEL_38;
      if (stat(*((const char **)prefs + 13), &v97) == -1)
      {
        if (*__error() != 2)
        {
          v58 = __log_SCPreferences();
          v59 = _SC_syslog_os_log_mapping(6);
          if (__SC_log_enabled(6, v58, (os_log_type_t)v59))
          {
            v60 = _os_log_pack_size();
            v68 = v13;
            v69 = (char *)&v92
                - ((MEMORY[0x1E0C80A78](v60, v61, v62, v63, v64, v65, v66, v67) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v70 = _os_log_pack_fill();
            v71 = __error();
            v72 = strerror(*v71);
            *(_DWORD *)v70 = 136315138;
            *(_QWORD *)(v70 + 4) = v72;
            v73 = v69;
            v13 = v68;
            __SC_log_send(6, (uint64_t)v58, v59, v73);
          }
          goto LABEL_73;
        }
        memset(&v97, 0, sizeof(v97));
      }
      v20 = __SCPSignatureFromStatbuf(&v97.st_dev);
      v21 = CFEqual(*((CFTypeRef *)prefs + 18), v20);
      CFRelease(v20);
      if (v21)
      {
LABEL_38:
        if (v18 >= 1)
          reportDelay((uint64_t)prefs, &v93, 0);
        v22 = __log_SCPreferences();
        v23 = _SC_syslog_os_log_mapping(7);
        if (__SC_log_enabled(7, v22, (os_log_type_t)v23))
        {
          v24 = _os_log_pack_size();
          v32 = v13;
          v33 = (char *)&v92
              - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v34 = _os_log_pack_fill();
          v35 = *((_QWORD *)prefs + 13);
          *(_DWORD *)v34 = 136315138;
          *(_QWORD *)(v34 + 4) = v35;
          v36 = v33;
          v13 = v32;
          __SC_log_send(7, (uint64_t)v22, v23, v36);
        }
        v4 = 1;
        __SCPreferencesUpdateLockedState((uint64_t)prefs, 1);
        pthread_mutex_unlock(v13);
        return v4;
      }
LABEL_73:
      unlink(*((const char **)prefs + 15));
      if (v18 >= 1)
        reportDelay((uint64_t)prefs, &v93, 1);
      v57 = 3005;
      goto LABEL_83;
    }
    if (v6)
      v37 = 545;
    else
      v37 = 549;
    *(_QWORD *)&v17 = 136315138;
    v92 = v17;
    while (1)
    {
      v38 = open(*((const char **)prefs + 15), v37, 420);
      *((_DWORD *)prefs + 29) = v38;
      if (v38 != -1)
        break;
      v40 = *__error();
      if (v40 <= 34)
      {
        if (v40 != 2)
          goto LABEL_80;
        v41 = (const __CFString *)*((_QWORD *)prefs + 11);
        if (v41 && CFStringHasPrefix(v41, CFSTR("/")))
          goto LABEL_81;
        if (createParentDirectory())
        {
          v40 = *__error();
LABEL_80:
          if (v40 == 30)
            goto LABEL_31;
LABEL_81:
          v57 = *__error();
          v74 = __log_SCPreferences();
          v75 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v74, (os_log_type_t)v75))
          {
            v76 = _os_log_pack_size();
            v77 = v13;
            v85 = (char *)&v92
                - ((MEMORY[0x1E0C80A78](v76, v78, v79, v80, v81, v82, v83, v84) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v86 = _os_log_pack_fill();
            v87 = __error();
            v88 = strerror(*v87);
            *(_DWORD *)v86 = v92;
            *(_QWORD *)(v86 + 4) = v88;
            v13 = v77;
            __SC_log_send(5, (uint64_t)v74, v75, v85);
          }
LABEL_83:
          v89 = *((_DWORD *)prefs + 29);
          if (v89 != -1)
          {
            close(v89);
            *((_DWORD *)prefs + 29) = -1;
          }
          pthread_mutex_unlock(v13);
          v3 = v57;
LABEL_5:
          _SCErrorSet(v3);
          return 0;
        }
        v42 = __log_SCPreferences();
        v43 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v42, (os_log_type_t)v43))
        {
          v44 = _os_log_pack_size();
          v52 = v13;
          v53 = (char *)&v92
              - ((MEMORY[0x1E0C80A78](v44, v45, v46, v47, v48, v49, v50, v51) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v54 = _os_log_pack_fill();
          v55 = *((_QWORD *)prefs + 13);
          *(_DWORD *)v54 = v92;
          *(_QWORD *)(v54 + 4) = v55;
          v56 = v53;
          v13 = v52;
          __SC_log_send(6, (uint64_t)v42, v43, v56);
        }
        goto LABEL_57;
      }
      if (v40 != 45)
      {
        if (v40 == 35)
        {
          v57 = 3002;
          goto LABEL_83;
        }
        goto LABEL_81;
      }
      if (has_O_EXLOCK((uint64_t)prefs))
      {
        *__error() = 45;
        goto LABEL_81;
      }
      v39 = _SCPNotificationKey(0, *((const __CFString **)prefs + 11), 1);
      *((_QWORD *)prefs + 22) = v39;
LABEL_58:
      if (v39)
        goto LABEL_30;
    }
    if (stat(*((const char **)prefs + 15), &v97) != -1
      && fstat(*((_DWORD *)prefs + 29), &v96) != -1
      && v97.st_dev == v96.st_dev
      && v97.st_ino == v96.st_ino)
    {
      v90 = getpid();
      snprintf((char *)value, 0x20uLL, "%d\n", v90);
      v91 = strlen((const char *)value);
      write(*((_DWORD *)prefs + 29), value, v91);
      goto LABEL_31;
    }
    close(*((_DWORD *)prefs + 29));
    *((_DWORD *)prefs + 29) = -1;
LABEL_57:
    v39 = (CFStringRef)*((_QWORD *)prefs + 22);
    goto LABEL_58;
  }
  v7 = (mach_port_t *)((char *)prefs + 320);
  v8 = *((_DWORD *)prefs + 80);
  if (!v8)
  {
    if (!__SCPreferencesCreate_helper((uint64_t)prefs))
      return 0;
    v8 = *v7;
  }
  LODWORD(value[0]) = 0;
  if (v6)
    v9 = 103;
  else
    v9 = 102;
  if (!_SCHelperExec(v8, v9, *((const __CFData **)prefs + 18), value, 0))
  {
    if (*v7)
      _SCHelperClose((mach_port_t *)prefs + 80);
    v3 = 1003;
    LODWORD(value[0]) = 1003;
    goto LABEL_5;
  }
  v3 = (int)value[0];
  if (LODWORD(value[0]))
    goto LABEL_5;
  v4 = 1;
  __SCPreferencesUpdateLockedState((uint64_t)prefs, 1);
  return v4;
}

Boolean SCNetworkReachabilityUnscheduleFromRunLoop(SCNetworkReachabilityRef target, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v6;
  CFTypeID v7;
  pthread_mutex_t *v8;
  const __CFArray *v9;
  Boolean v10;

  if (__SCNetworkReachabilityInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkReachabilityInitialize_initialized, &__block_literal_global_10);
    if (target)
      goto LABEL_3;
LABEL_16:
    _SCErrorSet(1002);
    return 0;
  }
  if (!target)
    goto LABEL_16;
LABEL_3:
  v6 = __kSCNetworkReachabilityTypeID;
  v7 = CFGetTypeID(target);
  if (!runLoopMode || !runLoop || v7 != v6)
    goto LABEL_16;
  v8 = (pthread_mutex_t *)((char *)target + 16);
  if (pthread_mutex_lock((pthread_mutex_t *)((char *)target + 16)))
    SCNetworkReachabilityUnscheduleFromRunLoop_cold_3();
  v9 = (const __CFArray *)*((_QWORD *)target + 22);
  if (!v9 || !*((_QWORD *)target + 15) || !*((_BYTE *)target + 112))
  {
    if (pthread_mutex_unlock((pthread_mutex_t *)((char *)target + 16)))
      SCNetworkReachabilityUnscheduleFromRunLoop_cold_1();
    goto LABEL_16;
  }
  if (!_SC_unschedule(target, runLoop, runLoopMode, v9, 0))
  {
LABEL_14:
    v10 = 1;
    goto LABEL_19;
  }
  if (CFArrayGetCount(*((CFArrayRef *)target + 22)))
  {
    if (!_SC_isScheduled(0, runLoop, runLoopMode, *((CFArrayRef *)target + 22)))
      CFRunLoopRemoveSource(runLoop, *((CFRunLoopSourceRef *)target + 15), runLoopMode);
    goto LABEL_14;
  }
  CFRunLoopRemoveSource(runLoop, *((CFRunLoopSourceRef *)target + 15), runLoopMode);
  CFRelease(*((CFTypeRef *)target + 22));
  *((_QWORD *)target + 22) = 0;
  CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)target + 15));
  CFRelease(*((CFTypeRef *)target + 15));
  *((_QWORD *)target + 15) = 0;
  v10 = __SCNetworkReachabilitySetDispatchQueue((uint64_t)target, 0);
LABEL_19:
  if (pthread_mutex_unlock(v8))
    SCNetworkReachabilityUnscheduleFromRunLoop_cold_2();
  return v10;
}

uint64_t _SC_unschedule(const void *a1, const void *a2, const void *a3, CFArrayRef theArray, int a5)
{
  CFIndex Count;
  CFIndex v11;
  unsigned __int8 v12;
  CFIndex v13;
  const void *v14;
  const void *v15;
  const void *ValueAtIndex;

  Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    return 0;
  }
  else
  {
    v11 = Count;
    v12 = 0;
    v13 = 0;
    do
    {
      while (1)
      {
        if (!a1 || (v14 = CFArrayGetValueAtIndex(theArray, v13), CFEqual(a1, v14)))
        {
          if (!a2 || (v15 = CFArrayGetValueAtIndex(theArray, v13 + 1), CFEqual(a2, v15)))
          {
            if (!a3)
              break;
            ValueAtIndex = CFArrayGetValueAtIndex(theArray, v13 + 2);
            if (CFEqual(a3, ValueAtIndex))
              break;
          }
        }
        v13 += 3;
        if (v13 >= v11)
          return v12;
      }
      CFArrayRemoveValueAtIndex(theArray, v13 + 2);
      CFArrayRemoveValueAtIndex(theArray, v13 + 1);
      CFArrayRemoveValueAtIndex(theArray, v13);
      v12 = 1;
      if (!a5)
        break;
      v11 -= 3;
    }
    while (v13 < v11);
  }
  return v12;
}

BOOL _SCUnserializeString(CFStringRef *a1, const __CFData *a2, UInt8 *bytes, CFIndex length)
{
  CFStringRef v5;
  _BOOL8 result;
  const __CFData *v9;
  mach_error_t v10;
  mach_error_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  _QWORD v36[2];

  v36[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v5 = CFStringCreateFromExternalRepresentation(0, a2, 0x8000100u);
    *a1 = v5;
    if (v5)
      return 1;
  }
  else
  {
    v9 = CFDataCreateWithBytesNoCopy(0, bytes, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    *a1 = CFStringCreateFromExternalRepresentation(0, v9, 0x8000100u);
    CFRelease(v9);
    v10 = MEMORY[0x18D78D14C](*MEMORY[0x1E0C83DA0], bytes, length);
    if (v10)
    {
      v11 = v10;
      v12 = _SC_LOG_DEFAULT();
      v13 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v12, (os_log_type_t)v13))
      {
        v14 = _os_log_pack_size();
        v22 = (char *)v36 - ((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v23 = _os_log_pack_fill();
        v24 = mach_error_string(v11);
        *(_DWORD *)v23 = 136315138;
        *(_QWORD *)(v23 + 4) = v24;
        __SC_log_send(5, (uint64_t)v12, v13, v22);
      }
    }
    if (*a1)
      return 1;
  }
  v25 = _SC_LOG_DEFAULT();
  v26 = _SC_syslog_os_log_mapping(5);
  result = __SC_log_enabled(5, v25, (os_log_type_t)v26);
  if (result)
  {
    v27 = _os_log_pack_size();
    v35 = (char *)v36 - ((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(5, (uint64_t)v25, v26, v35);
    return 0;
  }
  return result;
}

Boolean SCNetworkReachabilitySetDispatchQueue(SCNetworkReachabilityRef target, dispatch_queue_t queue)
{
  uint64_t v4;
  Boolean v5;

  if (__SCNetworkReachabilityInitialize_initialized == -1)
  {
    if (!target)
    {
LABEL_8:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkReachabilityInitialize_initialized, &__block_literal_global_10);
    if (!target)
      goto LABEL_8;
  }
  v4 = __kSCNetworkReachabilityTypeID;
  if (CFGetTypeID(target) != v4)
    goto LABEL_8;
  if (pthread_mutex_lock((pthread_mutex_t *)((char *)target + 16)))
    SCNetworkReachabilitySetDispatchQueue_cold_2();
  v5 = __SCNetworkReachabilitySetDispatchQueue((uint64_t)target, queue);
  if (pthread_mutex_unlock((pthread_mutex_t *)((char *)target + 16)))
    SCNetworkReachabilitySetDispatchQueue_cold_1();
  return v5;
}

uint64_t __SCNetworkReachabilityDeallocate(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void (*v21)(_QWORD);
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  v2 = __log_SCNetworkReachability_log;
  if (!__log_SCNetworkReachability_log)
  {
    v2 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
    __log_SCNetworkReachability_log = (uint64_t)v2;
  }
  v3 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v2, (os_log_type_t)v3))
  {
    v4 = _os_log_pack_size();
    v12 = (char *)v23 - ((MEMORY[0x1E0C80A78](v4, v5, v6, v7, v8, v9, v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v13 = _os_log_pack_fill();
    *(_DWORD *)v13 = 136315138;
    *(_QWORD *)(v13 + 4) = a1 + 193;
    __SC_log_send(7, (uint64_t)v2, v3, v12);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 16)))
    __SCNetworkReachabilityDeallocate_cold_2();
  *(_BYTE *)(a1 + 112) = 0;
  v14 = *(void **)(a1 + 88);
  if (v14)
  {
    nw_release(v14);
    *(_QWORD *)(a1 + 88) = 0;
  }
  v15 = *(void **)(a1 + 96);
  if (v15)
  {
    nw_release(v15);
    *(_QWORD *)(a1 + 96) = 0;
  }
  v16 = *(void **)(a1 + 104);
  if (v16)
  {
    nw_release(v16);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v17 = *(void **)(a1 + 232);
  if (v17)
  {
    nw_release(v17);
    *(_QWORD *)(a1 + 232) = 0;
  }
  v18 = *(void **)(a1 + 248);
  if (v18)
  {
    nw_release(v18);
    *(_QWORD *)(a1 + 248) = 0;
  }
  v19 = *(void **)(a1 + 256);
  if (v19)
  {
    nw_release(v19);
    *(_QWORD *)(a1 + 256) = 0;
  }
  v20 = *(void **)(a1 + 280);
  if (v20)
  {
    nw_release(v20);
    *(_QWORD *)(a1 + 280) = 0;
  }
  v21 = *(void (**)(_QWORD))(a1 + 160);
  if (v21)
    v21(*(_QWORD *)(a1 + 144));
  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16)))
    __SCNetworkReachabilityDeallocate_cold_1();
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
}

Boolean SCPreferencesSetCallback(SCPreferencesRef prefs, SCPreferencesCallBack callout, SCPreferencesContext *context)
{
  uint64_t v6;
  void (*v7)(_QWORD);
  __int128 v8;
  __int128 v9;
  const void *(__cdecl *retain)(const void *);

  if (__SCPreferencesInitialize_initialized == -1)
  {
    if (!prefs)
    {
LABEL_11:
      _SCErrorSet(3001);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCPreferencesInitialize_initialized, &__block_literal_global_48);
    if (!prefs)
      goto LABEL_11;
  }
  v6 = __kSCPreferencesTypeID;
  if (CFGetTypeID(prefs) != v6)
    goto LABEL_11;
  pthread_mutex_lock((pthread_mutex_t *)((char *)prefs + 16));
  v7 = (void (*)(_QWORD))*((_QWORD *)prefs + 31);
  if (v7)
    v7(*((_QWORD *)prefs + 29));
  *(_OWORD *)((char *)prefs + 232) = 0u;
  *((_QWORD *)prefs + 27) = callout;
  *(_OWORD *)((char *)prefs + 248) = 0u;
  if (context)
  {
    v8 = *(_OWORD *)&context->version;
    v9 = *(_OWORD *)&context->retain;
    *((_QWORD *)prefs + 32) = context->copyDescription;
    *((_OWORD *)prefs + 14) = v8;
    *((_OWORD *)prefs + 15) = v9;
    retain = context->retain;
    if (retain)
      *((_QWORD *)prefs + 29) = ((uint64_t (*)(void *))retain)(context->info);
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)prefs + 16));
  return 1;
}

void __SCNetworkServiceDeallocate(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  CFRelease(*(CFTypeRef *)(a1 + 16));
  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 48);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 56);
  if (v6)
    CFRelease(v6);
}

CFDictionaryRef SCDynamicStoreCopyProxiesWithOptions(const __SCDynamicStore *a1, const __CFDictionary *a2)
{
  CFTypeID TypeID;
  const __CFBoolean *Value;
  CFTypeID v6;
  _BOOL4 v7;
  const __SCPreferences *v8;
  const __SCPreferences *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  const void *v12;
  CFTypeID v13;
  CFDictionaryRef v14;
  __CFDictionary *MutableCopy;
  CFNumberRef v16;
  const __CFString *NetworkGlobalEntity;
  CFTypeID v18;
  __CFDictionary *v19;
  CFNumberRef v20;
  int valuePtr;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a2)
    goto LABEL_6;
  TypeID = CFDictionaryGetTypeID();
  if (CFGetTypeID(a2) == TypeID)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("NO_GLOBAL"));
    v6 = CFBooleanGetTypeID();
    if (Value && CFGetTypeID(Value) == v6)
    {
      v7 = CFBooleanGetValue(Value) != 0;
      goto LABEL_7;
    }
LABEL_6:
    v7 = 0;
LABEL_7:
    v8 = SCPreferencesCreate(0, CFSTR("SCDynamicStoreCopyProxiesWithOptions"), CFSTR("/Library/Managed Preferences/mobile/com.apple.SystemConfiguration.plist"));
    if (v8)
    {
      v9 = v8;
      v10 = (const __CFDictionary *)SCPreferencesGetValue(v8, CFSTR("Proxies"));
      v11 = v10;
      if (v10)
        CFRetain(v10);
      CFRelease(v9);
      if (v7 && v11)
      {
        valuePtr = 0;
        v12 = CFDictionaryGetValue(v11, CFSTR("BypassAllowed"));
        v13 = CFNumberGetTypeID();
        if (v12
          && CFGetTypeID(v12) == v13
          && CFNumberGetValue((CFNumberRef)v12, kCFNumberIntType, &valuePtr)
          && valuePtr)
        {
          CFRelease(v11);
          goto LABEL_24;
        }
      }
      else
      {
        if (!v11)
          goto LABEL_24;
        if (!v7)
        {
          valuePtr = 0;
          MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v11);
          CFRelease(v11);
          v16 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          CFDictionarySetValue(MutableCopy, CFSTR("BypassAllowed"), v16);
          CFRelease(v16);
          v11 = MutableCopy;
        }
      }
      if (CFDictionaryContainsKey(v11, CFSTR("FallBackAllowed")))
      {
        if (v11)
        {
LABEL_30:
          v14 = __SCNetworkProxiesCopyNormalized(v11);
          CFRelease(v11);
          return v14;
        }
        return CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      }
      valuePtr = 0;
      v19 = CFDictionaryCreateMutableCopy(0, 0, v11);
      CFRelease(v11);
      v20 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v19, CFSTR("FallBackAllowed"), v20);
      CFRelease(v20);
LABEL_29:
      v11 = v19;
      if (v19)
        goto LABEL_30;
      return CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
LABEL_24:
    NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(0, CFSTR("State:"), CFSTR("Proxies"));
    v11 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, NetworkGlobalEntity);
    CFRelease(NetworkGlobalEntity);
    v18 = CFDictionaryGetTypeID();
    if (!v11)
      return CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (CFGetTypeID(v11) != v18 || !CFDictionaryContainsKey(v11, CFSTR("BypassAllowed")))
      goto LABEL_30;
    v19 = CFDictionaryCreateMutableCopy(0, 0, v11);
    CFRelease(v11);
    CFDictionaryRemoveValue(v19, CFSTR("BypassAllowed"));
    goto LABEL_29;
  }
  _SCErrorSet(1002);
  return 0;
}

SCPreferencesRef SCPreferencesCreate(CFAllocatorRef allocator, CFStringRef name, CFStringRef prefsID)
{
  const __SCPreferences *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v3 = (const __SCPreferences *)__SCPreferencesCreate(allocator, name, prefsID, 0, 0);
  if (v3)
  {
    v4 = __log_SCPreferences_log;
    if (!__log_SCPreferences_log)
    {
      v4 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
      __log_SCPreferences_log = (uint64_t)v4;
    }
    v5 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v4, (os_log_type_t)v5))
    {
      v6 = _os_log_pack_size();
      v14 = (char *)v17 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v15 = _os_log_pack_fill();
      *(_DWORD *)v15 = 138412290;
      *(_QWORD *)(v15 + 4) = v3;
      __SC_log_send(7, (uint64_t)v4, v5, v14);
    }
  }
  return v3;
}

CFStringRef SCDynamicStoreKeyCreateNetworkGlobalEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef entity)
{
  return CFStringCreateWithFormat(allocator, 0, CFSTR("%@/%@/%@/%@"), domain, CFSTR("Network"), CFSTR("Global"), entity);
}

CFPropertyListRef SCDynamicStoreCopyValue(SCDynamicStoreRef store, CFStringRef key)
{
  return __SCDynamicStoreCopyValueCommon((uint64_t)store, key, 1);
}

void normalize_scoped_proxy(const void *a1, uint64_t a2, __CFDictionary *a3)
{
  const void *v5;

  v5 = (const void *)__SCNetworkProxiesCopyNormalized(a2);
  CFDictionarySetValue(a3, a1, v5);
  CFRelease(v5);
}

CFDictionaryRef __SCNetworkProxiesCopyNormalized(const void *a1)
{
  CFTypeID TypeID;
  __CFDictionary *MutableCopy;
  uint64_t v4;
  const void *Value;
  const void *v7;
  CFTypeID v8;
  CFNumberRef v9;
  const __CFArray *v10;
  const __CFArray *v11;
  CFTypeID v12;
  CFIndex Count;
  CFIndex v14;
  CFIndex v15;
  const __CFString *ValueAtIndex;
  CFTypeID v17;
  const void *v18;
  const void *v19;
  CFTypeID v20;
  CFNumberRef v21;
  const __CFDictionary *v22;
  CFTypeID v23;
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v25;
  CFTypeID v26;
  CFMutableDictionaryRef v27;
  const __CFArray *v28;
  CFTypeID v29;
  CFMutableArrayRef v30;
  CFDictionaryRef Copy;
  _QWORD v32[10];
  CFRange v33;

  v32[9] = *MEMORY[0x1E0C80C00];
  TypeID = CFDictionaryGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
    return CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)a1);
  v4 = 0;
  v32[0] = CFSTR("FTPEnable");
  v32[1] = CFSTR("FTPProxy");
  v32[2] = CFSTR("FTPPort");
  v32[3] = CFSTR("GopherEnable");
  v32[4] = CFSTR("GopherProxy");
  v32[5] = CFSTR("GopherPort");
  v32[6] = CFSTR("RTSPEnable");
  v32[7] = CFSTR("RTSPProxy");
  v32[8] = CFSTR("RTSPPort");
  do
    CFDictionaryRemoveValue(MutableCopy, (const void *)v32[v4++]);
  while (v4 != 9);
  validate_proxy_content(MutableCopy, CFSTR("HTTPEnable"), CFSTR("HTTPProxy"), CFSTR("HTTPPort"), "http", 0x50u, 0);
  validate_proxy_content(MutableCopy, CFSTR("HTTPSEnable"), CFSTR("HTTPSProxy"), CFSTR("HTTPSPort"), "https", 0x1BBu, 0);
  validate_proxy_content(MutableCopy, CFSTR("SOCKSEnable"), CFSTR("SOCKSProxy"), CFSTR("SOCKSPort"), "socks", 0x438u, 0);
  validate_proxy_content(MutableCopy, CFSTR("TransportConverterEnable"), CFSTR("TransportConverterProxy"), CFSTR("TransportConverterPort"), 0, 0, 1);
  if (CFDictionaryContainsKey(MutableCopy, CFSTR("ProxyAutoConfigURLString")))
  {
    validate_proxy_content(MutableCopy, CFSTR("ProxyAutoConfigEnable"), CFSTR("ProxyAutoConfigURLString"), 0, 0, 0, 0);
    CFDictionaryRemoveValue(MutableCopy, CFSTR("ProxyAutoConfigJavaScript"));
  }
  else
  {
    validate_proxy_content(MutableCopy, CFSTR("ProxyAutoConfigEnable"), CFSTR("ProxyAutoConfigJavaScript"), 0, 0, 0, 0);
  }
  validate_proxy_content(MutableCopy, CFSTR("ProxyAutoDiscoveryEnable"), 0, 0, 0, 0, 0);
  validate_proxy_content(MutableCopy, CFSTR("FallBackAllowed"), 0, 0, 0, 0, 0);
  Value = CFDictionaryGetValue(MutableCopy, CFSTR("FTPPassive"));
  if (Value)
  {
    v7 = Value;
    LODWORD(v32[0]) = 0;
    v8 = CFNumberGetTypeID();
    if (CFGetTypeID(v7) != v8 || !CFNumberGetValue((CFNumberRef)v7, kCFNumberIntType, v32))
    {
      LODWORD(v32[0]) = 1;
      v9 = CFNumberCreate(0, kCFNumberIntType, v32);
      CFDictionarySetValue(MutableCopy, CFSTR("FTPPassive"), v9);
      CFRelease(v9);
    }
  }
  v10 = (const __CFArray *)CFDictionaryGetValue(MutableCopy, CFSTR("ExceptionsList"));
  if (v10)
  {
    v11 = v10;
    v12 = CFArrayGetTypeID();
    if (CFGetTypeID(v11) == v12)
    {
      Count = CFArrayGetCount(v11);
      v14 = Count;
      if (Count < 1)
      {
        if (Count)
          goto LABEL_24;
      }
      else
      {
        v15 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v11, v15);
          v17 = CFStringGetTypeID();
          if (!ValueAtIndex || CFGetTypeID(ValueAtIndex) != v17 || !CFStringGetLength(ValueAtIndex))
            break;
          if (v14 == ++v15)
            goto LABEL_24;
        }
      }
    }
    CFDictionaryRemoveValue(MutableCopy, CFSTR("ExceptionsList"));
  }
LABEL_24:
  v18 = CFDictionaryGetValue(MutableCopy, CFSTR("ExcludeSimpleHostnames"));
  if (v18)
  {
    v19 = v18;
    LODWORD(v32[0]) = 0;
    v20 = CFNumberGetTypeID();
    if (CFGetTypeID(v19) != v20 || !CFNumberGetValue((CFNumberRef)v19, kCFNumberIntType, v32))
    {
      LODWORD(v32[0]) = 0;
      v21 = CFNumberCreate(0, kCFNumberIntType, v32);
      CFDictionarySetValue(MutableCopy, CFSTR("ExcludeSimpleHostnames"), v21);
      CFRelease(v21);
    }
  }
  v22 = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, CFSTR("__SCOPED__"));
  v23 = CFDictionaryGetTypeID();
  if (v22 && CFGetTypeID(v22) == v23)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionaryApplyFunction(v22, (CFDictionaryApplierFunction)normalize_scoped_proxy, Mutable);
    CFDictionarySetValue(MutableCopy, CFSTR("__SCOPED__"), Mutable);
    CFRelease(Mutable);
  }
  v25 = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, CFSTR("__SERVICES__"));
  v26 = CFDictionaryGetTypeID();
  if (v25 && CFGetTypeID(v25) == v26)
  {
    v27 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionaryApplyFunction(v25, (CFDictionaryApplierFunction)normalize_services_proxy, v27);
    CFDictionarySetValue(MutableCopy, CFSTR("__SERVICES__"), v27);
    CFRelease(v27);
  }
  v28 = (const __CFArray *)CFDictionaryGetValue(MutableCopy, CFSTR("__SUPPLEMENTAL__"));
  v29 = CFArrayGetTypeID();
  if (v28)
  {
    if (CFGetTypeID(v28) == v29)
    {
      v30 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      v33.length = CFArrayGetCount(v28);
      v33.location = 0;
      CFArrayApplyFunction(v28, v33, (CFArrayApplierFunction)normalize_supplemental_proxy, v30);
      CFDictionarySetValue(MutableCopy, CFSTR("__SUPPLEMENTAL__"), v30);
      CFRelease(v30);
    }
  }
  Copy = CFDictionaryCreateCopy(0, MutableCopy);
  CFRelease(MutableCopy);
  return Copy;
}

void validate_proxy_content(const __CFDictionary *a1, const void *a2, const void *a3, const void *a4, const char *a5, unsigned int a6, int a7)
{
  const void *Value;
  const void *v15;
  CFTypeID TypeID;
  const __CFString *v17;
  const __CFString *v18;
  CFTypeID v19;
  CFTypeID v20;
  CFTypeID v21;
  CFIndex v22;
  const __CFString *ValueAtIndex;
  CFTypeID v24;
  const void *v25;
  const void *v26;
  int v27;
  CFNumberRef v28;
  CFTypeID v29;
  servent *v30;
  CFNumberRef v31;
  CFIndex Count;
  int v33;
  int valuePtr;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  Value = CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    v15 = Value;
    TypeID = CFNumberGetTypeID();
    if (CFGetTypeID(v15) != TypeID || !CFNumberGetValue((CFNumberRef)v15, kCFNumberIntType, &valuePtr))
      goto LABEL_26;
  }
  if (a3)
  {
    v17 = (const __CFString *)CFDictionaryGetValue(a1, a3);
    v18 = v17;
    if (!valuePtr && v17)
      goto LABEL_26;
    if (valuePtr)
    {
      v19 = CFStringGetTypeID();
      if (!v18)
      {
        CFArrayGetTypeID();
        goto LABEL_26;
      }
      if (CFGetTypeID(v18) == v19)
      {
        if (a7 || !CFStringGetLength(v18))
          goto LABEL_26;
      }
      else
      {
        v20 = CFArrayGetTypeID();
        v21 = CFGetTypeID(v18);
        if (!a7)
          goto LABEL_26;
        if (v21 != v20)
          goto LABEL_26;
        Count = CFArrayGetCount((CFArrayRef)v18);
        if (!Count)
          goto LABEL_26;
        if (Count >= 1)
        {
          v22 = 0;
          do
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v18, v22);
            v24 = CFStringGetTypeID();
            if (!ValueAtIndex || CFGetTypeID(ValueAtIndex) != v24 || !CFStringGetLength(ValueAtIndex))
              goto LABEL_26;
          }
          while (Count != ++v22);
        }
      }
    }
  }
  if (!a4)
    return;
  v33 = 0;
  v25 = CFDictionaryGetValue(a1, a4);
  v26 = v25;
  v27 = valuePtr;
  if (!valuePtr && v25)
    goto LABEL_26;
  if (valuePtr && v25)
  {
    v29 = CFNumberGetTypeID();
    if (CFGetTypeID(v26) == v29 && CFNumberGetValue((CFNumberRef)v26, kCFNumberIntType, &v33) && v33 < 0x10000)
    {
      if (!v33)
        v26 = 0;
      v27 = valuePtr;
      goto LABEL_39;
    }
LABEL_26:
    valuePtr = 0;
    v28 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(a1, a2, v28);
    CFRelease(v28);
    if (a3)
      CFDictionaryRemoveValue(a1, a3);
    if (a4)
      CFDictionaryRemoveValue(a1, a4);
    return;
  }
LABEL_39:
  if (!v27 || v26)
    return;
  if (!a5)
    goto LABEL_26;
  v30 = getservbyname(a5, "tcp");
  if (v30)
    a6 = bswap32(LOWORD(v30->s_port)) >> 16;
  v33 = a6;
  v31 = CFNumberCreate(0, kCFNumberIntType, &v33);
  CFDictionarySetValue(a1, a4, v31);
  CFRelease(v31);
}

void __SCNetworkInterfaceDeallocate(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;

  v2 = (const void *)a1[4];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[5];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[7];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[8];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)a1[9];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[10];
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a1[11];
  if (v8)
    CFRelease(v8);
  v9 = (const void *)a1[12];
  if (v9)
    CFRelease(v9);
  v10 = (const void *)a1[13];
  if (v10)
    CFRelease(v10);
  v11 = (const void *)a1[14];
  if (v11)
    CFRelease(v11);
  v12 = (const void *)a1[15];
  if (v12)
    CFRelease(v12);
  v13 = (const void *)a1[18];
  if (v13)
    CFRelease(v13);
  v14 = (const void *)a1[19];
  if (v14)
    CFRelease(v14);
  v15 = (const void *)a1[20];
  if (v15)
    CFRelease(v15);
  v16 = (const void *)a1[21];
  if (v16)
    CFRelease(v16);
  v17 = (const void *)a1[23];
  if (v17)
    CFRelease(v17);
  v18 = (const void *)a1[25];
  if (v18)
    CFRelease(v18);
  v19 = (const void *)a1[26];
  if (v19)
    CFRelease(v19);
  v20 = (const void *)a1[28];
  if (v20)
    CFRelease(v20);
  v21 = (const void *)a1[29];
  if (v21)
    CFRelease(v21);
  v22 = (const void *)a1[31];
  if (v22)
    CFRelease(v22);
  v23 = (const void *)a1[32];
  if (v23)
    CFRelease(v23);
  v24 = (const void *)a1[33];
  if (v24)
    CFRelease(v24);
  v25 = (const void *)a1[34];
  if (v25)
    CFRelease(v25);
  v26 = (const void *)a1[35];
  if (v26)
    CFRelease(v26);
  v27 = (const void *)a1[37];
  if (v27)
    CFRelease(v27);
  v28 = (const void *)a1[36];
  if (v28)
    CFRelease(v28);
  v29 = (const void *)a1[40];
  if (v29)
    CFRelease(v29);
  v30 = (const void *)a1[41];
  if (v30)
    CFRelease(v30);
  v31 = (const void *)a1[42];
  if (v31)
    CFRelease(v31);
  v32 = (const void *)a1[44];
  if (v32)
    CFRelease(v32);
  v33 = (const void *)a1[45];
  if (v33)
    CFRelease(v33);
  v34 = (const void *)a1[47];
  if (v34)
    CFRelease(v34);
  v35 = (const void *)a1[48];
  if (v35)
    CFRelease(v35);
  v36 = (const void *)a1[49];
  if (v36)
    CFRelease(v36);
  v37 = (const void *)a1[50];
  if (v37)
    CFRelease(v37);
}

char *_SC_sockaddr_to_string(uint64_t a1, void *a2, unint64_t a3)
{
  int v6;
  char *result;

  bzero(a2, a3);
  v6 = *(unsigned __int8 *)(a1 + 1);
  if (v6 == 30)
  {
    result = (char *)inet_ntop(30, (const void *)(a1 + 8), (char *)a2, a3);
    if (*(_DWORD *)(a1 + 24))
    {
      result = (char *)strlen((const char *)a2);
      if ((unint64_t)(result + 17) <= a3)
      {
        result[(_QWORD)a2] = 37;
        return if_indextoname(*(_DWORD *)(a1 + 24), &result[(_QWORD)a2 + 1]);
      }
    }
  }
  else if (v6 == 2)
  {
    return (char *)inet_ntop(2, (const void *)(a1 + 4), (char *)a2, a3);
  }
  else
  {
    return (char *)snprintf((char *)a2, a3, "unexpected address family %d", *(unsigned __int8 *)(a1 + 1));
  }
  return result;
}

Boolean SCNetworkReachabilitySetCallback(SCNetworkReachabilityRef target, SCNetworkReachabilityCallBack callout, SCNetworkReachabilityContext *context)
{
  pthread_mutex_t *v6;
  void (*v7)(_QWORD);
  __int128 v8;
  __int128 v9;
  const void *(__cdecl *retain)(const void *);

  v6 = (pthread_mutex_t *)((char *)target + 16);
  if (pthread_mutex_lock((pthread_mutex_t *)((char *)target + 16)))
    SCNetworkReachabilitySetCallback_cold_2();
  v7 = (void (*)(_QWORD))*((_QWORD *)target + 20);
  if (v7)
    v7(*((_QWORD *)target + 18));
  *((_OWORD *)target + 9) = 0u;
  *((_QWORD *)target + 16) = callout;
  *((_OWORD *)target + 10) = 0u;
  if (context)
  {
    v8 = *(_OWORD *)&context->version;
    v9 = *(_OWORD *)&context->retain;
    *((_QWORD *)target + 21) = context->copyDescription;
    *(_OWORD *)((char *)target + 136) = v8;
    *(_OWORD *)((char *)target + 152) = v9;
    retain = context->retain;
    if (retain)
      *((_QWORD *)target + 18) = ((uint64_t (*)(void *))retain)(context->info);
  }
  if (pthread_mutex_unlock(v6))
    SCNetworkReachabilitySetCallback_cold_1();
  return 1;
}

CFArrayRef _SCNetworkProxiesCopyMatchingInternal(const void *a1, __CFString *a2, const __CFString *Value, const __CFDictionary *a4)
{
  CFTypeID TypeID;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;
  const __CFUUID *v12;
  CFTypeID v13;
  CFTypeID v14;
  const void *v15;
  const void *v16;
  CFTypeID v17;
  void *Copy;
  CFTypeID v19;
  int v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  CFTypeID v23;
  CFNumberRef v24;
  void *v25;
  CFTypeID v26;
  const __CFString *v27;
  const __CFString *v28;
  CFIndex Length;
  const void *v30;
  const void *v31;
  CFTypeID v32;
  CFIndex Count;
  CFIndex v34;
  const __CFArray *Mutable;
  CFIndex i;
  void *ValueAtIndex;
  CFTypeID v38;
  const __CFString *v39;
  CFTypeID v40;
  CFIndex v41;
  CFIndex v42;
  CFIndex v43;
  void *MutableCopy;
  CFTypeRef v45;
  CFMutableDictionaryRef v46;
  void *v47;
  CFUUIDBytes v49;
  int valuePtr;
  void *values;
  CFTypeRef cf;
  uuid_t uu;
  uint64_t v54;
  CFRange v55;
  CFRange v56;
  CFRange v57;

  v54 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  TypeID = CFDictionaryGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
    goto LABEL_60;
  cf = 0;
  memset(uu, 0, sizeof(uu));
  values = 0;
  uuid_clear(uu);
  v9 = CFDictionaryGetTypeID();
  if (a4 && CFGetTypeID(a4) == v9)
  {
    Value = (const __CFString *)CFDictionaryGetValue(a4, CFSTR("Interface"));
    v10 = CFStringGetTypeID();
    if (Value && CFGetTypeID(Value) != v10)
      Value = 0;
    a2 = (__CFString *)CFDictionaryGetValue(a4, CFSTR("Server"));
    v11 = CFStringGetTypeID();
    if (a2 && CFGetTypeID(a2) != v11)
      a2 = 0;
    v12 = (const __CFUUID *)CFDictionaryGetValue(a4, CFSTR("UUID"));
    v13 = CFUUIDGetTypeID();
    if (v12 && CFGetTypeID(v12) == v13)
    {
      v49 = CFUUIDGetUUIDBytes(v12);
      uuid_copy(uu, &v49.byte0);
    }
  }
  if (Value)
  {
    v14 = CFStringGetTypeID();
    if (CFGetTypeID(Value) == v14 && CFStringGetLength(Value))
    {
      v15 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("__SCOPED__"));
      if (v15)
      {
        v16 = v15;
        v17 = CFDictionaryGetTypeID();
        if (CFGetTypeID(v16) != v17)
          goto LABEL_21;
        Copy = (void *)CFDictionaryGetValue((CFDictionaryRef)v16, Value);
        values = Copy;
        if (!Copy)
        {
          _SCErrorSet(0);
          return (CFArrayRef)Copy;
        }
        v19 = CFDictionaryGetTypeID();
        if (CFGetTypeID(Copy) != v19)
        {
LABEL_21:
          v20 = 1001;
LABEL_61:
          _SCErrorSet(v20);
          return 0;
        }
        return CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
      }
      if (CFDictionaryContainsKey((CFDictionaryRef)a1, CFSTR("BypassAllowed"))
        && (ne_session_always_on_vpn_configs_present() & 1) != 0)
      {
LABEL_56:
        v28 = 0;
        goto LABEL_57;
      }
LABEL_60:
      v20 = 0;
      goto LABEL_61;
    }
LABEL_52:
    v20 = 1002;
    goto LABEL_61;
  }
  valuePtr = VPNAppLayerGetMatchingServiceIdentifier(0, uu);
  if (valuePtr >= 1)
  {
    v21 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("__SERVICES__"));
    if (!v21)
      goto LABEL_64;
    v22 = v21;
    v23 = CFDictionaryGetTypeID();
    if (CFGetTypeID(v22) == v23)
    {
      v24 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
      values = (void *)CFDictionaryGetValue(v22, v24);
      CFRelease(v24);
      v25 = values;
      if (!values)
      {
        LODWORD(v21) = 0;
LABEL_64:
        _SCErrorSet((int)v21);
        values = CFDictionaryCreate(0, 0, 0, 0, 0, 0);
        Copy = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
        v47 = values;
LABEL_65:
        CFRelease(v47);
        return (CFArrayRef)Copy;
      }
      v26 = CFDictionaryGetTypeID();
      if (CFGetTypeID(v25) == v26)
        return CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    }
    LODWORD(v21) = 1001;
    goto LABEL_64;
  }
  if (!a2)
    goto LABEL_56;
  v27 = _SC_trimDomain(a2);
  if (!v27)
    goto LABEL_52;
  v28 = v27;
  Length = CFStringGetLength(v27);
  v30 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("__SUPPLEMENTAL__"));
  if (!v30)
    goto LABEL_57;
  v31 = v30;
  v32 = CFArrayGetTypeID();
  if (CFGetTypeID(v31) != v32)
  {
    _SCErrorSet(1001);
    Copy = 0;
    goto LABEL_59;
  }
  Count = CFArrayGetCount((CFArrayRef)v31);
  if (Count < 1)
    goto LABEL_57;
  v34 = Count;
  Mutable = 0;
  for (i = 0; i != v34; ++i)
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex((CFArrayRef)v31, i);
    values = ValueAtIndex;
    v38 = CFDictionaryGetTypeID();
    if (ValueAtIndex)
    {
      if (CFGetTypeID(ValueAtIndex) == v38)
      {
        v39 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)values, CFSTR("__MATCH_DOMAIN__"));
        v40 = CFStringGetTypeID();
        if (v39)
        {
          if (CFGetTypeID(v39) == v40)
          {
            v41 = CFStringGetLength(v39);
            if (v41 < 1
              || (v42 = v41, v56.location = 0,
                             v56.length = Length,
                             CFStringFindWithOptions(v28, v39, v56, 0xDuLL, 0))
              && (Length <= v42
               || (v57.location = 0,
                   v57.length = Length - v42,
                   CFStringFindWithOptions(v28, CFSTR("."), v57, 0xDuLL, 0))))
            {
              if (!Mutable)
                Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
              v43 = CFArrayGetCount(Mutable);
              MutableCopy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)values);
              cf = MutableCopy;
              CFDictionaryRemoveValue((CFMutableDictionaryRef)MutableCopy, CFSTR("__MATCH_DOMAIN__"));
              if (v43)
              {
                v55.location = 0;
                v55.length = v43;
                if (CFArrayContainsValue(Mutable, v55, MutableCopy))
                {
LABEL_48:
                  CFRelease(cf);
                  continue;
                }
                MutableCopy = (void *)cf;
              }
              CFArrayAppendValue(Mutable, MutableCopy);
              goto LABEL_48;
            }
          }
        }
      }
    }
  }
  if (Mutable)
  {
    Copy = CFArrayCreateCopy(0, Mutable);
    v45 = Mutable;
    goto LABEL_58;
  }
LABEL_57:
  v46 = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)a1);
  cf = v46;
  CFDictionaryRemoveValue(v46, CFSTR("__SCOPED__"));
  CFDictionaryRemoveValue(v46, CFSTR("__SERVICES__"));
  CFDictionaryRemoveValue(v46, CFSTR("__SUPPLEMENTAL__"));
  Copy = CFArrayCreate(0, &cf, 1, MEMORY[0x1E0C9B378]);
  v45 = cf;
LABEL_58:
  CFRelease(v45);
  if (v28)
  {
LABEL_59:
    v47 = (void *)v28;
    goto LABEL_65;
  }
  return (CFArrayRef)Copy;
}

CFMutableStringRef _SC_trimDomain(CFMutableStringRef MutableCopy)
{
  CFTypeID TypeID;
  uint64_t Length;
  CFRange v5;
  CFRange v6;

  TypeID = CFStringGetTypeID();
  if (MutableCopy)
  {
    if (CFGetTypeID(MutableCopy) != TypeID)
      return 0;
    Length = CFStringGetLength(MutableCopy);
    if (Length >= 1
      && ((v5.location = 0, v5.length = 1, CFStringFindWithOptions(MutableCopy, CFSTR("."), v5, 8uLL, 0))
       || (v6.location = 0, v6.length = Length, CFStringFindWithOptions(MutableCopy, CFSTR("."), v6, 0xCuLL, 0))))
    {
      MutableCopy = CFStringCreateMutableCopy(0, 0, MutableCopy);
      CFStringTrim(MutableCopy, CFSTR("."));
      if (!CFStringGetLength(MutableCopy))
        goto LABEL_9;
    }
    else
    {
      CFRetain(MutableCopy);
      if (!Length)
      {
LABEL_9:
        CFRelease(MutableCopy);
        return 0;
      }
    }
  }
  return MutableCopy;
}

uint64_t VPNAppLayerGetMatchingServiceIdentifier(int a1, const unsigned __int8 *a2)
{
  void *v4;
  uint64_t flow_divert_unit;

  if (!ne_session_app_vpn_configs_present())
    return 0xFFFFFFFFLL;
  v4 = (void *)copy_path_for_app(g_null_audit, a1, a2, 0, 0, 0);
  if (v4 && nw_path_is_flow_divert())
    flow_divert_unit = nw_path_get_flow_divert_unit();
  else
    flow_divert_unit = 0xFFFFFFFFLL;
  nw_release(v4);
  return flow_divert_unit;
}

CFStringRef _SCCopyDescription(const void *a1, const __CFDictionary *a2)
{
  CFTypeID v4;
  void *v6;
  int v7;
  const char *v8;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFIndex v13;
  unsigned int v14;
  __CFCalendar *v15;
  const __CFTimeZone *v16;
  CFAbsoluteTime v17;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v19;
  CFIndex Count;
  CFIndex v21;
  const void **v22;
  CFIndex v23;
  CFIndex v24;
  const void **v25;
  uint64_t i;
  CFStringRef v27;
  __CFString *v28;
  __CFString *v29;
  const void *v30;
  const void **v31;
  __CFArray *v32;
  uint64_t j;
  CFComparisonResult (__cdecl *v34)(const void *, const void *, void *);
  CFIndex v35;
  const void *ValueAtIndex;
  uint64_t v37;
  CFIndex v38;
  __CFString *v39;
  __CFString *v40;
  __CFString *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  const void **ptr;
  __CFArray *v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  void *value;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  CFRange v69;
  CFRange v70;

  v68 = *MEMORY[0x1E0C80C00];
  v50 = 0;
  value = 0;
  v4 = CFGetTypeID(a1);
  if (!a2 || !CFDictionaryGetValueIfPresent(a2, CFSTR("PREFIX1"), (const void **)&value))
    value = &stru_1E25D5260;
  if (v4 == CFStringGetTypeID())
    return CFStringCreateWithFormat(0, a2, CFSTR("%@%@"), value, a1);
  if (v4 == CFBooleanGetTypeID())
  {
    v6 = value;
    v7 = CFBooleanGetValue((CFBooleanRef)a1);
    v8 = "TRUE";
    if (!v7)
      v8 = "FALSE";
    return CFStringCreateWithFormat(0, a2, CFSTR("%@%s"), v6, v8);
  }
  if (v4 != CFDataGetTypeID())
  {
    if (v4 != CFNumberGetTypeID())
    {
      if (v4 == CFDateGetTypeID())
      {
        LODWORD(v52) = 0;
        v48 = 0;
        v49 = 0;
        v47 = 0;
        v15 = CFCalendarCreateWithIdentifier(0, (CFCalendarIdentifier)*MEMORY[0x1E0C9B008]);
        v16 = CFTimeZoneCopySystem();
        CFCalendarSetTimeZone(v15, v16);
        CFRelease(v16);
        MEMORY[0x18D78BD60](a1);
        CFCalendarDecomposeAbsoluteTime(v15, v17, "MdyHms", &v52, (char *)&v49 + 4, &v49, (char *)&v48 + 4, &v48, &v47);
        CFRelease(v15);
        return CFStringCreateWithFormat(0, a2, CFSTR("%@%02d/%02d/%04d %02d:%02d:%02d"), value, v52, HIDWORD(v49), v49, HIDWORD(v48), v48, v47);
      }
      if (a2)
      {
        if (!CFDictionaryGetValueIfPresent(a2, CFSTR("PREFIX2"), (const void **)&v50))
          v50 = value;
        MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a2);
      }
      else
      {
        v50 = value;
        MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      }
      v19 = MutableCopy;
      if (!MutableCopy)
        _SCCopyDescription_cold_1();
      if (v4 == CFArrayGetTypeID())
      {
        v66 = 0u;
        v67 = 0u;
        v64 = 0u;
        v65 = 0u;
        v62 = 0u;
        v63 = 0u;
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v52 = 0u;
        v53 = 0u;
        Mutable = CFStringCreateMutable(0, 0);
        CFStringAppendFormat(Mutable, a2, CFSTR("%@<array> {"), value);
        Count = CFArrayGetCount((CFArrayRef)a1);
        if (Count < 1)
          goto LABEL_54;
        v21 = Count;
        v22 = (unint64_t)Count < 0x21
            ? (const void **)&v52
            : (const void **)CFAllocatorAllocate(0, 8 * Count, 0);
        v69.location = 0;
        v69.length = v21;
        CFArrayGetValues((CFArrayRef)a1, v69, v22);
        for (i = 0; i != v21; ++i)
        {
          v27 = CFStringCreateWithFormat(0, 0, CFSTR("%ld"), i);
          v28 = CFStringCreateMutable(0, 0);
          CFStringAppendFormat(v28, a2, CFSTR("%@  %@ : "), v50, v27);
          v29 = CFStringCreateMutable(0, 0);
          CFStringAppendFormat(v29, a2, CFSTR("%@  "), v50);
          CFDictionarySetValue(v19, CFSTR("PREFIX1"), v28);
          CFDictionarySetValue(v19, CFSTR("PREFIX2"), v29);
          CFRelease(v28);
          CFRelease(v29);
          CFRelease(v27);
          v30 = (const void *)_SCCopyDescription(v22[i], v19);
          CFStringAppendFormat(Mutable, a2, CFSTR("\n%@"), v30);
          CFRelease(v30);
        }
        if (v22 == (const void **)&v52)
          goto LABEL_54;
        v31 = v22;
LABEL_53:
        CFAllocatorDeallocate(0, v31);
        goto LABEL_54;
      }
      if (v4 == CFDictionaryGetTypeID())
      {
        v66 = 0u;
        v67 = 0u;
        v64 = 0u;
        v65 = 0u;
        v62 = 0u;
        v63 = 0u;
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v52 = 0u;
        v53 = 0u;
        Mutable = CFStringCreateMutable(0, 0);
        CFStringAppendFormat(Mutable, a2, CFSTR("%@<dictionary> {"), value);
        v23 = CFDictionaryGetCount((CFDictionaryRef)a1);
        if (v23 < 1)
        {
LABEL_54:
          CFStringAppendFormat(Mutable, a2, CFSTR("\n%@}"), v50);
          CFRelease(v19);
          return Mutable;
        }
        v24 = v23;
        if ((unint64_t)v23 < 0x21)
          v25 = (const void **)&v52;
        else
          v25 = (const void **)CFAllocatorAllocate(0, 8 * v23, 0);
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v25, 0);
        v32 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
        for (j = 0; j != v24; ++j)
          CFArrayAppendValue(v32, v25[j]);
        if (isA_CFString(*v25))
        {
          v34 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))compare_CFString;
        }
        else if (isA_CFNumber(*v25))
        {
          v34 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))compare_CFNumber;
        }
        else
        {
          if (!isA_CFDate(*v25))
          {
LABEL_50:
            ptr = v25;
            v46 = v32;
            v35 = 0;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v32, v35);
              v37 = _SCCopyDescription(ValueAtIndex, 0);
              v38 = v24;
              v39 = CFStringCreateMutable(0, 0);
              CFStringAppendFormat(v39, a2, CFSTR("%@  %@ : "), v50, v37);
              v40 = CFStringCreateMutable(0, 0);
              CFStringAppendFormat(v40, a2, CFSTR("%@  "), v50);
              CFDictionarySetValue(v19, CFSTR("PREFIX1"), v39);
              CFDictionarySetValue(v19, CFSTR("PREFIX2"), v40);
              v41 = v39;
              v24 = v38;
              CFRelease(v41);
              CFRelease(v40);
              v42 = (const void *)v37;
              v32 = v46;
              CFRelease(v42);
              v43 = CFDictionaryGetValue((CFDictionaryRef)a1, ValueAtIndex);
              v44 = (const void *)_SCCopyDescription(v43, v19);
              CFStringAppendFormat(Mutable, a2, CFSTR("\n%@"), v44);
              CFRelease(v44);
              ++v35;
            }
            while (v38 != v35);
            CFRelease(v46);
            v31 = ptr;
            if (ptr == (const void **)&v52)
              goto LABEL_54;
            goto LABEL_53;
          }
          v34 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))compare_CFDate;
        }
        v70.location = 0;
        v70.length = v24;
        CFArraySortValues(v32, v70, v34, 0);
        goto LABEL_50;
      }
      CFRelease(v19);
    }
    return CFStringCreateWithFormat(0, a2, CFSTR("%@%@"), value, a1);
  }
  Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, a2, CFSTR("%@<data> 0x"), value);
  BytePtr = CFDataGetBytePtr((CFDataRef)a1);
  Length = CFDataGetLength((CFDataRef)a1);
  if (Length >= 1)
  {
    v13 = Length;
    do
    {
      v14 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0, CFSTR("%02x"), v14);
      --v13;
    }
    while (v13);
  }
  return Mutable;
}

void SCPrint(int a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
    __SCPrint(a2, a3, (uint64_t)&a9, 0, 0);
}

void __SCPrint(FILE *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  const __CFString *v8;
  UInt8 *v9;
  timeval v10;
  tm v11;
  size_t v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v12[0] = 0;
  v8 = (const __CFString *)_CFStringCreateWithFormatAndArgumentsAux();
  v9 = _SC_cfstring_to_cstring_ext(v8, 0, 0, 0x8000100u, 0x3Fu, v12);
  CFRelease(v8);
  if (v9)
  {
    pthread_mutex_lock(&lock);
    if (a4)
    {
      memset(&v11, 0, sizeof(v11));
      v10.tv_sec = 0;
      *(_QWORD *)&v10.tv_usec = 0;
      gettimeofday(&v10, 0);
      localtime_r(&v10.tv_sec, &v11);
      fprintf(a1, "%2d:%02d:%02d.%03d ", v11.tm_hour, v11.tm_min, v11.tm_sec, v10.tv_usec / 1000);
    }
    fwrite(v9, v12[0], 1uLL, a1);
    if (a5)
      fputc(10, a1);
    fflush(a1);
    pthread_mutex_unlock(&lock);
    CFAllocatorDeallocate(0, v9);
  }
}

UInt8 *_SC_cfstring_to_cstring_ext(const __CFString *a1, UInt8 *a2, CFIndex a3, CFStringEncoding a4, UInt8 a5, _QWORD *a6)
{
  const __CFString *v11;
  CFIndex Length;
  CFIndex usedBufLen[2];
  CFRange v15;
  CFRange v16;

  usedBufLen[1] = *MEMORY[0x1E0C80C00];
  usedBufLen[0] = 0;
  if (a1)
    v11 = a1;
  else
    v11 = &stru_1E25D5260;
  Length = CFStringGetLength(v11);
  v15.location = 0;
  v15.length = Length;
  if (CFStringGetBytes(v11, v15, a4, a5, 0, 0, 0, usedBufLen) < Length)
  {
    if (!a2)
      return a2;
    goto LABEL_9;
  }
  if (a2)
  {
    if (usedBufLen[0] >= a3)
    {
LABEL_9:
      *a2 = 0;
      return 0;
    }
  }
  else
  {
    a3 = usedBufLen[0] + 1;
    a2 = (UInt8 *)CFAllocatorAllocate(0, usedBufLen[0] + 1, 0);
    if (!a2)
      return a2;
  }
  v16.location = 0;
  v16.length = Length;
  CFStringGetBytes(v11, v16, a4, a5, 0, a2, a3, usedBufLen);
  a2[usedBufLen[0]] = 0;
  if (a6)
    *a6 = usedBufLen[0];
  return a2;
}

CFArrayRef SCNetworkSetCopyServices(SCNetworkSetRef set)
{
  uint64_t v2;
  const __CFString *SetNetworkService;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  const __CFArray *Mutable;
  CFIndex Count;
  CFIndex v8;
  const void **v9;
  uint64_t v11;
  __int128 v12;
  const __CFString *SetNetworkServiceEntity;
  const __CFString *Link;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFString *ValueAtIndex;
  CFStringRef NetworkServiceEntity;
  const __CFString *v18;
  const __CFDictionary *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  const void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  const void *v60;
  uint64_t v61;
  _QWORD *Private;
  _QWORD v63[2];
  CFMutableArrayRef v64;
  const __CFString *v65;
  __int128 v66;
  __int128 v67;
  _OWORD v68[8];
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!set)
    {
LABEL_32:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!set)
      goto LABEL_32;
  }
  v2 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(set) != v2)
    goto LABEL_32;
  SetNetworkService = SCPreferencesPathKeyCreateSetNetworkService(0, *((_QWORD *)set + 2), 0);
  Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)set + 3), SetNetworkService);
  CFRelease(SetNetworkService);
  if (!Value)
    return CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  TypeID = CFDictionaryGetTypeID();
  if (CFGetTypeID(Value) != TypeID)
    return 0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  Count = CFDictionaryGetCount(Value);
  if (Count < 1)
    return Mutable;
  v8 = Count;
  memset(v68, 0, sizeof(v68));
  v64 = Mutable;
  if ((unint64_t)Count < 0x11)
    v9 = (const void **)v68;
  else
    v9 = (const void **)CFAllocatorAllocate(0, 8 * Count, 0);
  CFDictionaryGetKeysAndValues(Value, v9, 0);
  v11 = 0;
  v65 = CFSTR("Interface");
  *(_QWORD *)&v12 = 138412546;
  v67 = v12;
  *(_QWORD *)&v12 = 138412802;
  v66 = v12;
  do
  {
    SetNetworkServiceEntity = SCPreferencesPathKeyCreateSetNetworkServiceEntity(0, *((_QWORD *)set + 2), (uint64_t)v9[v11], 0);
    Link = SCPreferencesPathGetLink(*((SCPreferencesRef *)set + 3), SetNetworkServiceEntity);
    CFRelease(SetNetworkServiceEntity);
    if (!Link)
    {
      v31 = __log_SCNetworkConfiguration();
      v32 = _SC_syslog_os_log_mapping(6);
      if (!__SC_log_enabled(6, v31, (os_log_type_t)v32))
        goto LABEL_27;
      v33 = _os_log_pack_size();
      v41 = (char *)v63 - ((MEMORY[0x1E0C80A78](v33, v34, v35, v36, v37, v38, v39, v40) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v42 = _os_log_pack_fill();
      v43 = v9[v11];
      v44 = *((_QWORD *)set + 2);
      *(_DWORD *)v42 = v67;
      *(_QWORD *)(v42 + 4) = v43;
      *(_WORD *)(v42 + 12) = 2112;
      *(_QWORD *)(v42 + 14) = v44;
      v45 = (uint64_t)v31;
      v46 = v32;
      v47 = v41;
LABEL_23:
      __SC_log_send(6, v45, v46, v47);
      goto LABEL_27;
    }
    if (!SCPreferencesPathGetValue(*((SCPreferencesRef *)set + 3), Link))
    {
      v48 = __log_SCNetworkConfiguration();
      v49 = _SC_syslog_os_log_mapping(6);
      if (!__SC_log_enabled(6, v48, (os_log_type_t)v49))
        goto LABEL_27;
      v50 = _os_log_pack_size();
      v58 = (char *)v63 - ((MEMORY[0x1E0C80A78](v50, v51, v52, v53, v54, v55, v56, v57) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v59 = _os_log_pack_fill();
      v60 = v9[v11];
      v61 = *((_QWORD *)set + 2);
      *(_DWORD *)v59 = v66;
      *(_QWORD *)(v59 + 4) = v60;
      *(_WORD *)(v59 + 12) = 2112;
      *(_QWORD *)(v59 + 14) = v61;
      *(_WORD *)(v59 + 22) = 2112;
      *(_QWORD *)(v59 + 24) = Link;
      v45 = (uint64_t)v48;
      v46 = v49;
      v47 = v58;
      goto LABEL_23;
    }
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, Link, CFSTR("/"));
    if (CFArrayGetCount(ArrayBySeparatingStrings) == 3)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 2);
      NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, (uint64_t)ValueAtIndex, 0);
      if (CFEqual(NetworkServiceEntity, Link))
      {
        v18 = SCPreferencesPathKeyCreateNetworkServiceEntity(0, (uint64_t)ValueAtIndex, (uint64_t)v65);
        v19 = SCPreferencesPathGetValue(*((SCPreferencesRef *)set + 3), v18);
        CFRelease(v18);
        if (__SCNetworkInterfaceEntityIsPPTP(v19))
        {
          v20 = __log_SCNetworkConfiguration();
          v21 = _SC_syslog_os_log_mapping(6);
          if (__SC_log_enabled(6, v20, (os_log_type_t)v21))
          {
            v22 = _os_log_pack_size();
            v63[1] = v63;
            v30 = (char *)v63
                - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            *(_WORD *)_os_log_pack_fill() = 0;
            __SC_log_send(6, (uint64_t)v20, v21, v30);
          }
        }
        else
        {
          Private = __SCNetworkServiceCreatePrivate(0, *((const void **)set + 3), ValueAtIndex, 0);
          CFArrayAppendValue(v64, Private);
          CFRelease(Private);
        }
      }
      CFRelease(NetworkServiceEntity);
    }
    CFRelease(ArrayBySeparatingStrings);
LABEL_27:
    ++v11;
  }
  while (v8 != v11);
  if (v9 != (const void **)v68)
    CFAllocatorDeallocate(0, v9);
  return v64;
}

CFStringRef SCPreferencesPathKeyCreateNetworkServiceEntity(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a3)
    return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@"), CFSTR("NetworkServices"), a2, a3, v5);
  else
    return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@"), CFSTR("NetworkServices"), a2, v4, v5);
}

CFDictionaryRef SCPreferencesPathGetValue(SCPreferencesRef prefs, CFStringRef path)
{
  const __CFDictionary *v3;
  CFTypeID TypeID;
  void *value;
  const __CFDictionary *v7[2];

  v7[1] = *(const __CFDictionary **)MEMORY[0x1E0C80C00];
  if (!prefs)
  {
    _SCErrorSet(3001);
    return 0;
  }
  value = 0;
  v7[0] = 0;
  if (!getPath(prefs, path, v7))
    return 0;
  v3 = v7[0];
  TypeID = CFDictionaryGetTypeID();
  if (v3 && CFGetTypeID(v3) == TypeID && CFDictionaryGetValueIfPresent(v3, CFSTR("__LINK__"), (const void **)&value))
  {
    if (getPath(prefs, (const __CFString *)value, v7))
      return v7[0];
    else
      return 0;
  }
  return v3;
}

uint64_t getPath(const __SCPreferences *a1, const __CFString *a2, const __CFDictionary **a3)
{
  const __CFArray *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  const __CFDictionary *v9;
  uint64_t v10;
  CFIndex v11;
  const void *ValueAtIndex;
  const __CFDictionary *Value;
  const __CFString *v14;
  CFTypeID TypeID;
  __CFArray *v16;
  const __CFArray *v17;
  int v18;
  uint64_t v19;
  const void *v21[2];
  CFRange v22;

  v21[1] = *(const void **)MEMORY[0x1E0C80C00];
  v5 = normalizePath(a2);
  if (!v5)
  {
    _SCErrorSet(1004);
    return 0;
  }
  v6 = v5;
  v21[0] = 0;
  Count = CFArrayGetCount(v5);
  if (Count < 1)
  {
    v17 = v6;
    goto LABEL_22;
  }
  v8 = Count;
  v9 = 0;
  v10 = 0;
  while (2)
  {
    v11 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v6, v11);
      if (v11)
      {
        Value = (const __CFDictionary *)CFDictionaryGetValue(v9, ValueAtIndex);
      }
      else
      {
        v14 = (const __CFString *)CFArrayGetValueAtIndex(v6, 0);
        Value = (const __CFDictionary *)SCPreferencesGetValue(a1, v14);
      }
      v9 = Value;
      if (!Value)
        goto LABEL_19;
      TypeID = CFDictionaryGetTypeID();
      if (CFGetTypeID(v9) != TypeID)
        goto LABEL_19;
      if (v11 < v8 - 1 && CFDictionaryGetValueIfPresent(v9, CFSTR("__LINK__"), v21))
        break;
      if (v8 == ++v11)
      {
        *a3 = v9;
        v19 = 1;
        goto LABEL_23;
      }
    }
    if (v10 == 8)
    {
      v18 = 3006;
      goto LABEL_20;
    }
    v16 = normalizePath((const __CFString *)v21[0]);
    if (!v16)
    {
LABEL_19:
      v18 = 1004;
LABEL_20:
      _SCErrorSet(v18);
      v19 = 0;
      goto LABEL_23;
    }
    v17 = v16;
    ++v10;
    v22.location = v11 + 1;
    v22.length = ~v11 + v8;
    CFArrayAppendArray(v16, v6, v22);
    CFRelease(v6);
    v8 = CFArrayGetCount(v17);
    v6 = v17;
    if (v8 >= 1)
      continue;
    break;
  }
LABEL_22:
  __SCPreferencesAccess((uint64_t)a1);
  *a3 = (const __CFDictionary *)*((_QWORD *)a1 + 35);
  v19 = 1;
  v6 = v17;
LABEL_23:
  CFRelease(v6);
  return v19;
}

CFPropertyListRef SCPreferencesGetValue(SCPreferencesRef prefs, CFStringRef key)
{
  CFPropertyListRef result;
  int v5;

  if (prefs)
  {
    __SCPreferencesAccess((uint64_t)prefs);
    result = CFDictionaryGetValue(*((CFDictionaryRef *)prefs + 35), key);
    if (result)
      return result;
    v5 = 1004;
  }
  else
  {
    v5 = 3001;
  }
  _SCErrorSet(v5);
  return 0;
}

void __SCPreferencesAccess(uint64_t a1)
{
  CFAllocatorRef v2;
  const __CFAllocator *v3;
  void *v4;
  int v5;
  mach_port_t *v6;
  mach_port_t v7;
  int v8;
  int v9;
  CFErrorRef v10;
  CFTypeID v11;
  const void *Value;
  CFTypeID v13;
  const void *v14;
  CFTypeID v15;
  int v16;
  int v17;
  char v18;
  uint64_t v19;
  int *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  int *v33;
  char *v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  int v47;
  const char *v48;
  const void *v49;
  __CFData *Mutable;
  UInt8 *BytePtr;
  ssize_t v52;
  const __CFDictionary *v53;
  CFTypeID TypeID;
  NSObject *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  CFErrorRef v66;
  NSObject *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  CFErrorRef v79;
  NSObject *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char *v90;
  NSObject *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  uint64_t v103;
  const __CFData *v104;
  uint64_t v105;
  const __CFData *v106;
  int v107;
  CFErrorRef error;
  stat v109;
  uint64_t v110;

  v110 = *MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator((CFTypeRef)a1);
  if (*(_BYTE *)(a1 + 304))
    return;
  v3 = v2;
  memset(&v109, 0, sizeof(v109));
  v4 = &unk_1ECDA1000;
  if (!access(*(const char **)(a1 + 104), 4))
  {
    v16 = open(*(const char **)(a1 + 104), 0, 420);
    if (v16 != -1)
    {
      v17 = v16;
      if (fstat(v16, &v109) != -1)
      {
        v18 = 0;
        goto LABEL_46;
      }
      v21 = __log_SCPreferences_log;
      if (!__log_SCPreferences_log)
      {
        v21 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
        __log_SCPreferences_log = (uint64_t)v21;
      }
      v22 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v21, (os_log_type_t)v22))
      {
        v23 = _os_log_pack_size();
        v31 = (char *)&v105
            - ((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v32 = _os_log_pack_fill();
        v33 = __error();
        v34 = strerror(*v33);
        *(_DWORD *)v32 = 136315138;
        *(_QWORD *)(v32 + 4) = v34;
        __SC_log_send(5, (uint64_t)v21, v22, v31);
      }
      v18 = 0;
LABEL_45:
      memset(&v109, 0, sizeof(v109));
LABEL_46:
      v49 = *(const void **)(a1 + 144);
      if (v49)
        CFRelease(v49);
      *(_QWORD *)(a1 + 144) = __SCPSignatureFromStatbuf(&v109.st_dev);
      if (v109.st_size < 1)
        goto LABEL_70;
      error = 0;
      Mutable = CFDataCreateMutable(v3, v109.st_size);
      CFDataSetLength(Mutable, v109.st_size);
      BytePtr = (UInt8 *)CFDataGetBytePtr(Mutable);
      v52 = read(v17, BytePtr, v109.st_size);
      if (v52 == v109.st_size)
      {
        v53 = (const __CFDictionary *)CFPropertyListCreateWithData(v3, Mutable, 0, 0, &error);
        CFRelease(Mutable);
        if (v53)
        {
          TypeID = CFDictionaryGetTypeID();
          if (CFGetTypeID(v53) == TypeID)
          {
            *(_QWORD *)(a1 + 280) = CFDictionaryCreateMutableCopy(v3, 0, v53);
            CFRelease(v53);
            processHardwareDependency(a1);
            goto LABEL_70;
          }
          v80 = __log_SCPreferences_log;
          if (!__log_SCPreferences_log)
          {
            v80 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
            __log_SCPreferences_log = (uint64_t)v80;
          }
          v81 = _SC_syslog_os_log_mapping(6);
          if (__SC_log_enabled(6, v80, (os_log_type_t)v81))
          {
            v82 = _os_log_pack_size();
            v90 = (char *)&v105
                - ((MEMORY[0x1E0C80A78](v82, v83, v84, v85, v86, v87, v88, v89) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            *(_WORD *)_os_log_pack_fill() = 0;
            __SC_log_send(6, (uint64_t)v80, v81, v90);
            v4 = &unk_1ECDA1000;
          }
          v66 = v53;
        }
        else
        {
          if (!error)
            goto LABEL_70;
          v67 = __log_SCPreferences_log;
          if (!__log_SCPreferences_log)
          {
            v67 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
            __log_SCPreferences_log = (uint64_t)v67;
          }
          v68 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v67, (os_log_type_t)v68))
          {
            v69 = _os_log_pack_size();
            v77 = (char *)&v105
                - ((MEMORY[0x1E0C80A78](v69, v70, v71, v72, v73, v74, v75, v76) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v78 = _os_log_pack_fill();
            v79 = error;
            *(_DWORD *)v78 = 138412290;
            *(_QWORD *)(v78 + 4) = v79;
            __SC_log_send(5, (uint64_t)v67, v68, v77);
          }
          v66 = error;
        }
      }
      else
      {
        v55 = __log_SCPreferences_log;
        if (!__log_SCPreferences_log)
        {
          v55 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
          __log_SCPreferences_log = (uint64_t)v55;
        }
        v56 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v55, (os_log_type_t)v56))
        {
          v57 = _os_log_pack_size();
          v65 = (char *)&v105
              - ((MEMORY[0x1E0C80A78](v57, v58, v59, v60, v61, v62, v63, v64) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(6, (uint64_t)v55, v56, v65);
          v4 = &unk_1ECDA1000;
        }
        v66 = Mutable;
      }
      CFRelease(v66);
LABEL_70:
      if ((v18 & 1) == 0)
        close(v17);
      goto LABEL_72;
    }
  }
  v5 = *__error();
  if (v5 != 13)
  {
    if (v5 == 2)
      goto LABEL_44;
    if (v5 != 1)
      goto LABEL_28;
  }
  if (!*(_QWORD *)(a1 + 312))
  {
LABEL_28:
    v19 = *(_QWORD *)(a1 + 104);
    v20 = __error();
    log_open_error(v19, *v20);
    goto LABEL_44;
  }
  error = 0;
  v107 = 0;
  v106 = 0;
  v6 = (mach_port_t *)(a1 + 320);
  v7 = *(_DWORD *)(a1 + 320);
  if (!v7)
  {
    if (!__SCPreferencesCreate_helper(a1))
      goto LABEL_40;
    v7 = *v6;
  }
  if (!_SCHelperExec(v7, 101, 0, &v107, &v106))
    goto LABEL_36;
  v8 = v107;
  if (v107)
  {
LABEL_39:
    _SCErrorSet(v8);
LABEL_40:
    v35 = __log_SCPreferences_log;
    if (!__log_SCPreferences_log)
    {
      v35 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
      __log_SCPreferences_log = (uint64_t)v35;
    }
    v36 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v35, (os_log_type_t)v36))
    {
      v37 = _os_log_pack_size();
      v45 = (char *)&v105 - ((MEMORY[0x1E0C80A78](v37, v38, v39, v40, v41, v42, v43, v44) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v46 = _os_log_pack_fill();
      v47 = SCError();
      v48 = SCErrorString(v47);
      *(_DWORD *)v46 = 136315138;
      *(_QWORD *)(v46 + 4) = v48;
      __SC_log_send(5, (uint64_t)v35, v36, v45);
      v17 = -1;
      v18 = 1;
      goto LABEL_45;
    }
LABEL_44:
    v17 = -1;
    v18 = 1;
    goto LABEL_45;
  }
  if (!v106 || (v9 = _SCUnserialize((CFPropertyListRef *)&error, v106, 0, 0), CFRelease(v106), !v9))
  {
LABEL_36:
    if (*v6)
      _SCHelperClose((mach_port_t *)(a1 + 320));
    v8 = 1003;
    v107 = 1003;
    goto LABEL_39;
  }
  v10 = error;
  v11 = CFDictionaryGetTypeID();
  if (!v10 || CFGetTypeID(v10) != v11)
    goto LABEL_34;
  Value = CFDictionaryGetValue(error, CFSTR("preferences"));
  v13 = CFDictionaryGetTypeID();
  if (Value && CFGetTypeID(Value) != v13)
    Value = 0;
  v14 = CFDictionaryGetValue(error, CFSTR("signature"));
  v15 = CFDataGetTypeID();
  if (!v14)
    goto LABEL_34;
  if (CFGetTypeID(v14) != v15)
    v14 = 0;
  if (!Value || !v14)
  {
LABEL_34:
    if (error)
      CFRelease(error);
    goto LABEL_36;
  }
  *(_QWORD *)(a1 + 280) = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)Value);
  *(_QWORD *)(a1 + 144) = CFRetain(v14);
  *(_BYTE *)(a1 + 304) = 1;
  CFRelease(error);
LABEL_72:
  if (!*(_QWORD *)(a1 + 280))
  {
    *(_QWORD *)(a1 + 280) = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *(_BYTE *)(a1 + 305) = 0;
  }
  v91 = *((_QWORD *)v4 + 50);
  if (!v91)
  {
    v91 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
    *((_QWORD *)v4 + 50) = v91;
  }
  v92 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v91, (os_log_type_t)v92))
  {
    v93 = _os_log_pack_size();
    v101 = (char *)&v105 - ((MEMORY[0x1E0C80A78](v93, v94, v95, v96, v97, v98, v99, v100) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v102 = _os_log_pack_fill();
    v103 = *(_QWORD *)(a1 + 104);
    v104 = __SCPreferencesPrefsSize(a1);
    *(_DWORD *)v102 = 136315394;
    *(_QWORD *)(v102 + 4) = v103;
    *(_WORD *)(v102 + 12) = 2048;
    *(_QWORD *)(v102 + 14) = v104;
    __SC_log_send(7, (uint64_t)v91, v92, v101);
  }
  *(_BYTE *)(a1 + 304) = 1;
}

const __CFArray *normalizePath(const __CFString *a1)
{
  CFTypeID TypeID;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *MutableCopy;
  CFIndex Count;
  unint64_t v6;
  const __CFString *ValueAtIndex;

  TypeID = CFStringGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
  {
    _SCErrorSet(1002);
    return 0;
  }
  if (!CFStringHasPrefix(a1, CFSTR("/")))
    return 0;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, a1, CFSTR("/"));
  MutableCopy = CFArrayCreateMutableCopy(0, 0, ArrayBySeparatingStrings);
  CFRelease(ArrayBySeparatingStrings);
  Count = CFArrayGetCount(MutableCopy);
  if (Count >= 1)
  {
    v6 = Count + 1;
    do
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v6 - 2);
      if (!CFStringGetLength(ValueAtIndex))
        CFArrayRemoveValueAtIndex(MutableCopy, v6 - 2);
      --v6;
    }
    while (v6 > 1);
  }
  return MutableCopy;
}

_QWORD *_SCErrorSet(int a1)
{
  _QWORD *result;

  result = __SCGetThreadSpecificData();
  *(_DWORD *)result = a1;
  return result;
}

_QWORD *__SCGetThreadSpecificData()
{
  _QWORD *v0;

  if (__SCThreadSpecificKeyInitialize_tsKeyInitialized != -1)
    dispatch_once(&__SCThreadSpecificKeyInitialize_tsKeyInitialized, &__block_literal_global_44);
  v0 = pthread_getspecific(tsDataKey);
  if (!v0)
  {
    v0 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE30], 24, 0);
    *(_DWORD *)v0 = 0;
    v0[1] = 0;
    v0[2] = 0;
    pthread_setspecific(tsDataKey, v0);
  }
  return v0;
}

_QWORD *__SCNetworkServiceCreatePrivate(uint64_t a1, const void *a2, const __CFString *a3, const void *a4)
{
  _QWORD *Instance;
  CFTypeRef v8;
  CFTypeRef v9;

  if (__SCNetworkServiceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    if (a2)
      v8 = CFRetain(a2);
    else
      v8 = 0;
    Instance[4] = v8;
    Instance[2] = CFStringCreateCopy(0, a3);
    if (a4)
      v9 = CFRetain(a4);
    else
      v9 = 0;
    Instance[3] = v9;
  }
  return Instance;
}

const __CFDictionary *__SCNetworkInterfaceEntityIsPPTP(const __CFDictionary *result)
{
  const void *Value;

  if (result)
  {
    Value = CFDictionaryGetValue(result, CFSTR("SubType"));
    return (const __CFDictionary *)(Value && CFEqual(Value, CFSTR("PPTP")));
  }
  return result;
}

CFStringRef SCPreferencesPathKeyCreateSetNetworkServiceEntity(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
    return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@/%@/%@/%@"), CFSTR("Sets"), a2, CFSTR("Network"), CFSTR("Service"), a3, a4);
  else
    return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@/%@/%@"), CFSTR("Sets"), a2, CFSTR("Network"), CFSTR("Service"), a3);
}

CFStringRef SCPreferencesPathGetLink(SCPreferencesRef prefs, CFStringRef path)
{
  const __CFDictionary *v2;
  CFTypeID TypeID;
  void *value;
  const __CFDictionary *v6[2];

  v6[1] = *(const __CFDictionary **)MEMORY[0x1E0C80C00];
  if (!prefs)
  {
    _SCErrorSet(3001);
    return 0;
  }
  value = 0;
  v6[0] = 0;
  if (!getPath(prefs, path, v6))
    return 0;
  v2 = v6[0];
  TypeID = CFDictionaryGetTypeID();
  if (!v2 || CFGetTypeID(v2) != TypeID)
    return 0;
  if (CFDictionaryGetValueIfPresent(v2, CFSTR("__LINK__"), (const void **)&value))
    return (CFStringRef)value;
  else
    return 0;
}

__CFData *__SCPSignatureFromStatbuf(int *a1)
{
  __CFData *Mutable;
  UInt8 *BytePtr;
  uint64_t v4;

  Mutable = CFDataCreateMutable(0, 40);
  CFDataSetLength(Mutable, 40);
  BytePtr = (UInt8 *)CFDataGetBytePtr(Mutable);
  v4 = *((_QWORD *)a1 + 1);
  *(_QWORD *)BytePtr = *a1;
  *((_QWORD *)BytePtr + 1) = v4;
  *((_OWORD *)BytePtr + 1) = *((_OWORD *)a1 + 3);
  *((_QWORD *)BytePtr + 4) = *((_QWORD *)a1 + 12);
  return Mutable;
}

uint64_t reachPerformAndUnlock(uint64_t a1)
{
  uint64_t (*v2)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v3)(_QWORD);
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t result;
  uint64_t FlagsFromPath;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  _QWORD v32[2];

  v32[1] = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 112))
  {
    v2 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 128);
    v4 = *(_QWORD *)(a1 + 144);
    v3 = *(uint64_t (**)(_QWORD))(a1 + 152);
    if (v3)
    {
      v4 = v3(*(_QWORD *)(a1 + 144));
      v5 = *(uint64_t (**)(uint64_t))(a1 + 160);
    }
    else
    {
      v5 = 0;
    }
    FlagsFromPath = __SCNetworkReachabilityGetFlagsFromPath(a1 + 193, (uint64_t)"Perform", *(nw_path_t *)(a1 + 248), *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 272), *(_QWORD *)(a1 + 280), *(unsigned __int8 *)(a1 + 288), *(_DWORD *)(a1 + 292));
    result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    if ((_DWORD)result)
      reachPerformAndUnlock_cold_2();
    if (v2)
    {
      v20 = __log_SCNetworkReachability_log;
      if (!__log_SCNetworkReachability_log)
      {
        v20 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
        __log_SCNetworkReachability_log = (uint64_t)v20;
      }
      v21 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v20, (os_log_type_t)v21))
      {
        v22 = _os_log_pack_size();
        v32[0] = v32;
        v30 = (char *)v32 - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v31 = _os_log_pack_fill();
        *(_DWORD *)v31 = 136315394;
        *(_QWORD *)(v31 + 4) = a1 + 193;
        *(_WORD *)(v31 + 12) = 1024;
        *(_DWORD *)(v31 + 14) = FlagsFromPath;
        __SC_log_send(7, (uint64_t)v20, v21, v30);
      }
      result = v2(a1, FlagsFromPath, v4);
    }
    if (v5)
      return v5(v4);
  }
  else
  {
    v6 = __log_SCNetworkReachability_log;
    if (!__log_SCNetworkReachability_log)
    {
      v6 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
      __log_SCNetworkReachability_log = (uint64_t)v6;
    }
    v7 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = (char *)v32 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v17 = _os_log_pack_fill();
      *(_DWORD *)v17 = 136315138;
      *(_QWORD *)(v17 + 4) = a1 + 193;
      __SC_log_send(6, (uint64_t)v6, v7, v16);
    }
    result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    if ((_DWORD)result)
      reachPerformAndUnlock_cold_1();
  }
  return result;
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithName(CFAllocatorRef allocator, const char *nodename)
{
  const __SCNetworkReachability *v4;
  char *Private;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  sockaddr address;
  uint64_t v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (nodename && *nodename)
  {
    *(_QWORD *)&address.sa_len = 0;
    *(_QWORD *)&address.sa_data[6] = 0;
    v22 = 0;
    v21 = 0;
    if (_SC_string_to_sockaddr((char *)nodename, 0, (in_addr *)&address, 0x1CuLL))
    {
      return SCNetworkReachabilityCreateWithAddress(allocator, &address);
    }
    else
    {
      Private = __SCNetworkReachabilityCreatePrivate();
      v4 = (const __SCNetworkReachability *)Private;
      if (Private)
      {
        *((_DWORD *)Private + 20) = 2;
        *((_QWORD *)Private + 11) = nw_endpoint_create_host(nodename, "0");
        v7 = __log_SCNetworkReachability_log;
        if (!__log_SCNetworkReachability_log)
        {
          v7 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
          __log_SCNetworkReachability_log = (uint64_t)v7;
        }
        v8 = _SC_syslog_os_log_mapping(7);
        if (__SC_log_enabled(7, v7, (os_log_type_t)v8))
        {
          v9 = _os_log_pack_size();
          v17 = (char *)&v19
              - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v18 = _os_log_pack_fill();
          *(_DWORD *)v18 = 136315650;
          *(_QWORD *)(v18 + 4) = (char *)v4 + 193;
          *(_WORD *)(v18 + 12) = 2080;
          *(_QWORD *)(v18 + 14) = "create w/name";
          *(_WORD *)(v18 + 22) = 2112;
          *(_QWORD *)(v18 + 24) = v4;
          __SC_log_send(7, (uint64_t)v7, v8, v17);
        }
      }
    }
  }
  else
  {
    _SCErrorSet(1002);
    return 0;
  }
  return v4;
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithAddress(CFAllocatorRef allocator, const sockaddr *address)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  char *Private;
  const __SCNetworkReachability *v5;
  int v6;
  _DWORD *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  v2 = is_valid_address(&address->sa_len);
  if (!v2)
  {
    _SCErrorSet(1002);
    return 0;
  }
  v3 = v2;
  Private = __SCNetworkReachabilityCreatePrivate();
  v5 = (const __SCNetworkReachability *)Private;
  if (Private)
  {
    *((_DWORD *)Private + 20) = 0;
    v6 = v3[1];
    if (v6 == 30)
    {
      if (!*((_DWORD *)v3 + 2) && !*((_DWORD *)v3 + 3) && !*((_DWORD *)v3 + 4))
      {
        v7 = v3 + 20;
LABEL_6:
        if (!*v7)
          goto LABEL_13;
      }
    }
    else if (v6 == 2)
    {
      v7 = v3 + 4;
      goto LABEL_6;
    }
    *((_QWORD *)Private + 13) = nw_endpoint_create_address((const sockaddr *)v3);
LABEL_13:
    v8 = __log_SCNetworkReachability_log;
    if (!__log_SCNetworkReachability_log)
    {
      v8 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
      __log_SCNetworkReachability_log = (uint64_t)v8;
    }
    v9 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v8, (os_log_type_t)v9))
    {
      v10 = _os_log_pack_size();
      v18 = (char *)v21 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v19 = _os_log_pack_fill();
      *(_DWORD *)v19 = 136315650;
      *(_QWORD *)(v19 + 4) = (char *)v5 + 193;
      *(_WORD *)(v19 + 12) = 2080;
      *(_QWORD *)(v19 + 14) = "create w/address";
      *(_WORD *)(v19 + 22) = 2112;
      *(_QWORD *)(v19 + 24) = v5;
      __SC_log_send(7, (uint64_t)v8, v9, v18);
    }
  }
  return v5;
}

char *__SCNetworkReachabilityCreatePrivate()
{
  uint64_t Instance;
  char *v1;

  if (__SCNetworkReachabilityInitialize_initialized != -1)
    dispatch_once(&__SCNetworkReachabilityInitialize_initialized, &__block_literal_global_10);
  Instance = _CFRuntimeCreateInstance();
  v1 = (char *)Instance;
  if (Instance)
  {
    if (pthread_mutex_init((pthread_mutex_t *)(Instance + 16), &lock_attr))
      __SCNetworkReachabilityCreatePrivate_cold_1();
    if (_sc_log >= 1)
      snprintf(v1 + 193, 0x20uLL, "[%p] ", v1);
  }
  return v1;
}

uint64_t __SCNetworkReachabilitySetDispatchQueue(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  unsigned int v17;
  NSObject **v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  NSObject *v35;
  void *evaluator_for_endpoint;
  NSObject *v37;
  NSObject *CrazyIvan46Path;
  NSObject *v39;
  uint64_t v40;
  _QWORD block[18];

  block[17] = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 184);
  if (!a2)
  {
    if (v3 && *(_BYTE *)(a1 + 112))
    {
      *(_WORD *)(a1 + 112) = 0;
      nw_path_evaluator_cancel();
      *(_QWORD *)(a1 + 240) = 0;
      nw_release(*(void **)(a1 + 248));
      *(_QWORD *)(a1 + 248) = 0;
      nw_release(*(void **)(a1 + 256));
      *(_QWORD *)(a1 + 256) = 0;
      nw_release(*(void **)(a1 + 280));
      *(_QWORD *)(a1 + 280) = 0;
      v19 = *(_QWORD *)(a1 + 264);
      if (v19)
      {
        nw_retain(*(void **)(a1 + 264));
        v20 = *(NSObject **)(a1 + 184);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ____SCNetworkReachabilitySetDispatchQueue_block_invoke_3;
        block[3] = &__block_descriptor_tmp_108_0;
        block[4] = v19;
        dispatch_async(v20, block);
      }
      v21 = *(NSObject **)(a1 + 184);
      if (v21)
      {
        dispatch_release(v21);
        *(_QWORD *)(a1 + 184) = 0;
      }
      v22 = __log_SCNetworkReachability_log;
      if (!__log_SCNetworkReachability_log)
      {
        v22 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
        __log_SCNetworkReachability_log = (uint64_t)v22;
      }
      v23 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v22, (os_log_type_t)v23))
      {
        v24 = _os_log_pack_size();
        v32 = (char *)block
            - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v33 = _os_log_pack_fill();
        *(_DWORD *)v33 = 136315138;
        *(_QWORD *)(v33 + 4) = a1 + 193;
        __SC_log_send(7, (uint64_t)v22, v23, v32);
        return 1;
      }
      return 1;
    }
LABEL_22:
    _SCErrorSet(1002);
    return 0;
  }
  if (v3 || *(_BYTE *)(a1 + 112))
    goto LABEL_22;
  v5 = __log_SCNetworkReachability_log;
  if (!__log_SCNetworkReachability_log)
  {
    v5 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
    __log_SCNetworkReachability_log = (uint64_t)v5;
  }
  v6 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v5, (os_log_type_t)v6))
  {
    v7 = _os_log_pack_size();
    v15 = (char *)block - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v16 = _os_log_pack_fill();
    *(_DWORD *)v16 = 136315138;
    *(_QWORD *)(v16 + 4) = a1 + 193;
    __SC_log_send(7, (uint64_t)v5, v6, v15);
  }
  dispatch_retain(a2);
  nw_path_evaluator_cancel();
  v17 = *(_DWORD *)(a1 + 80);
  if (v17 < 2 || v17 == 3)
  {
    v18 = (NSObject **)(a1 + 104);
    goto LABEL_24;
  }
  if (v17 == 2)
  {
    v18 = (NSObject **)(a1 + 88);
LABEL_24:
    v35 = *v18;
    goto LABEL_25;
  }
  v35 = 0;
LABEL_25:
  evaluator_for_endpoint = (void *)nw_path_create_evaluator_for_endpoint();
  *(_QWORD *)(a1 + 240) = evaluator_for_endpoint;
  *(_QWORD *)(a1 + 184) = a2;
  *(_BYTE *)(a1 + 112) = 1;
  *(_BYTE *)(a1 + 113) = *(_DWORD *)(a1 + 80) < 2u;
  nw_release(*(void **)(a1 + 248));
  v37 = nw_path_evaluator_copy_path();
  *(_QWORD *)(a1 + 248) = v37;
  if (*(_DWORD *)(a1 + 80) <= 1u)
  {
    CrazyIvan46Path = __SCNetworkReachabilityCreateCrazyIvan46Path(v37, v35, *(NSObject **)(a1 + 232), 0);
    if (CrazyIvan46Path)
    {
      v39 = CrazyIvan46Path;
      nw_release(*(void **)(a1 + 248));
      *(_QWORD *)(a1 + 248) = v39;
    }
  }
  nw_release(*(void **)(a1 + 256));
  *(_QWORD *)(a1 + 256) = nw_path_copy_derived_parameters();
  *(_DWORD *)(a1 + 272) = 0;
  nw_release(*(void **)(a1 + 280));
  *(_QWORD *)(a1 + 280) = 0;
  __SCNetworkReachabilityRestartResolver((void **)a1, (uint64_t)"Scheduled, start DNS");
  CFRetain((CFTypeRef)a1);
  v40 = MEMORY[0x1E0C809B0];
  block[11] = MEMORY[0x1E0C809B0];
  block[12] = 0x40000000;
  block[13] = ____SCNetworkReachabilitySetDispatchQueue_block_invoke;
  block[14] = &__block_descriptor_tmp_103;
  block[15] = a1;
  block[16] = evaluator_for_endpoint;
  nw_path_evaluator_set_cancel_handler();
  block[5] = v40;
  block[6] = 0x40000000;
  block[7] = ____SCNetworkReachabilitySetDispatchQueue_block_invoke_2;
  block[8] = &__block_descriptor_tmp_107;
  block[9] = a1;
  block[10] = v35;
  if ((nw_path_evaluator_set_update_handler() & 1) == 0)
  {
    *(_QWORD *)(a1 + 240) = 0;
    nw_release(evaluator_for_endpoint);
    CFRelease((CFTypeRef)a1);
  }
  return 1;
}

Boolean SCNetworkReachabilityGetFlags(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags *flags)
{
  uint64_t v4;
  unsigned int v5;
  NSObject **v6;
  NSObject *v7;
  void *evaluator_for_endpoint;
  NSObject *v9;
  NSObject *v10;
  NSObject *CrazyIvan46Path;
  NSObject *v12;

  if (__SCNetworkReachabilityInitialize_initialized == -1)
  {
    if (!target)
    {
LABEL_21:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkReachabilityInitialize_initialized, &__block_literal_global_10);
    if (!target)
      goto LABEL_21;
  }
  v4 = __kSCNetworkReachabilityTypeID;
  if (CFGetTypeID(target) != v4)
    goto LABEL_21;
  if (pthread_mutex_lock((pthread_mutex_t *)((char *)target + 16)))
    SCNetworkReachabilityGetFlags_cold_2();
  if (!*((_BYTE *)target + 112))
  {
    v5 = *((_DWORD *)target + 20);
    if (v5 < 2 || v5 == 3)
    {
      v6 = (NSObject **)((char *)target + 104);
    }
    else
    {
      if (v5 != 2)
      {
        v7 = 0;
LABEL_14:
        evaluator_for_endpoint = (void *)nw_path_create_evaluator_for_endpoint();
        v9 = nw_path_evaluator_copy_path();
        v10 = v9;
        if (*((_DWORD *)target + 20) <= 1u)
        {
          CrazyIvan46Path = __SCNetworkReachabilityCreateCrazyIvan46Path(v9, v7, *((NSObject **)target + 29), 0);
          if (CrazyIvan46Path)
          {
            v12 = CrazyIvan46Path;
            nw_release(v10);
            v10 = v12;
          }
        }
        *flags = __SCNetworkReachabilityGetFlagsFromPath((uint64_t)target + 193, (uint64_t)"GetFlags", v10, 0, 0, 0, 0, 0);
        nw_release(v10);
        nw_release(evaluator_for_endpoint);
        goto LABEL_18;
      }
      v6 = (NSObject **)((char *)target + 88);
    }
    v7 = *v6;
    goto LABEL_14;
  }
  *flags = __SCNetworkReachabilityGetFlagsFromPath((uint64_t)target + 193, (uint64_t)"GetFlags", *((nw_path_t *)target + 31), *((_DWORD *)target + 20), *((_DWORD *)target + 68), *((_QWORD *)target + 35), *((unsigned __int8 *)target + 288), *((_DWORD *)target + 73));
  *((_BYTE *)target + 113) = 1;
LABEL_18:
  if (pthread_mutex_unlock((pthread_mutex_t *)((char *)target + 16)))
    SCNetworkReachabilityGetFlags_cold_1();
  return 1;
}

uint64_t __SCNetworkReachabilityGetFlagsFromPath(uint64_t a1, uint64_t a2, nw_path_t path, unsigned int a4, int a5, uint64_t a6, int a7, int a8)
{
  nw_path_status_t status;
  void *v17;
  void *v18;
  const char *v19;
  const char *v20;
  int v21;
  NSObject *v22;
  NSObject *v23;
  const sockaddr *address;
  NSObject *v25;
  NSObject *v26;
  nw_interface_type_t type;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  _QWORD applier[8];
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  char v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v51 = 0;
  v52 = &v51;
  v53 = 0x2000000000;
  v54 = 2;
  v47 = 0;
  v48 = &v47;
  v49 = 0x2000000000;
  v50 = "???";
  if (path)
  {
    status = nw_path_get_status(path);
    switch(status)
    {
      case nw_path_status_satisfiable:
        v55 = 0;
        v56 = 0;
        *((_DWORD *)v52 + 6) = 7;
        v48[3] = (uint64_t)"nw_path_status_satisfiable";
        if ((nw_path_get_vpn_config_id() & 1) != 0)
        {
          v20 = "nw_path_status_satisfiable, OnDemand";
          v21 = 32;
        }
        else
        {
          if (!nw_path_uses_interface_type(path, nw_interface_type_cellular))
            break;
          v20 = "nw_path_status_satisfiable, WWAN";
          v21 = 0x40000;
        }
        *((_DWORD *)v52 + 6) |= v21;
        v48[3] = (uint64_t)v20;
        break;
      case nw_path_status_unsatisfied:
        *((_DWORD *)v52 + 6) = 0;
        v48[3] = (uint64_t)"nw_path_status_unsatisfied";
        if (nw_path_uses_interface_type(path, nw_interface_type_cellular))
        {
          *((_DWORD *)v52 + 6) |= 0x40000u;
          v48[3] = (uint64_t)"nw_path_status_unsatisfied, WWAN";
        }
        break;
      case nw_path_status_satisfied:
        v55 = 0;
        v56 = &v55;
        v57 = 0x2000000000;
        v58 = 1;
        *((_DWORD *)v52 + 6) = 2;
        v48[3] = (uint64_t)"nw_path_status_satisfied";
        if (nw_path_uses_interface_type(path, nw_interface_type_cellular))
        {
          *((_DWORD *)v52 + 6) |= 0x40001u;
          v48[3] = (uint64_t)"nw_path_status_satisfied, cellular";
        }
        v17 = (void *)nw_path_copy_netagent_dictionary();
        if (v17)
        {
          v18 = v17;
          if (xpc_dictionary_get_count(v17))
          {
            applier[0] = MEMORY[0x1E0C809B0];
            applier[1] = 0x40000000;
            applier[2] = ____SCNetworkReachabilityGetFlagsFromPath_block_invoke;
            applier[3] = &unk_1E25D0D78;
            applier[4] = &v51;
            applier[5] = &v47;
            v45 = a4;
            v46 = a5;
            applier[6] = &v55;
            applier[7] = a6;
            xpc_dictionary_apply(v18, applier);
          }
          xpc_release(v18);
        }
        if (a4 >= 2)
        {
          if (*((_BYTE *)v56 + 24))
          {
            if (a5 == 2 && !nw_array_get_count())
            {
              *((_DWORD *)v52 + 6) = 0;
              v19 = "nw_path_status_satisfied, DNS not reachable";
              goto LABEL_39;
            }
            if (a7)
            {
              *((_DWORD *)v52 + 6) = a8;
              v19 = "nw_path_status_satisfied, resolved endpoint flags";
LABEL_39:
              v48[3] = (uint64_t)v19;
              goto LABEL_40;
            }
          }
          goto LABEL_40;
        }
        if ((nw_path_is_direct() & 1) != 0)
          goto LABEL_25;
        v22 = nw_path_copy_endpoint();
        if (v22)
        {
          v23 = v22;
          if (nw_endpoint_get_type(v22) == nw_endpoint_type_address)
          {
            address = nw_endpoint_get_address(v23);
            if (address)
            {
              if (address->sa_family == 2 && *(__int16 *)&address->sa_data[2] == -343)
              {
                v25 = nw_path_copy_interface();
                if (v25)
                {
                  v26 = v25;
                  type = nw_interface_get_type(v25);
                  if (type == nw_interface_type_wired
                    || type == nw_interface_type_wifi && nw_interface_get_subtype() != 1002)
                  {
                    nw_release(v26);
                    nw_release(v23);
LABEL_25:
                    *((_DWORD *)v52 + 6) |= 0x20000u;
                    v48[3] = (uint64_t)"nw_path_status_satisfied, by address, direct";
                    goto LABEL_37;
                  }
                  nw_release(v26);
                }
              }
            }
          }
          nw_release(v23);
        }
LABEL_37:
        if (nw_path_is_local())
        {
          *((_DWORD *)v52 + 6) |= 0x10000u;
          v19 = "nw_path_status_satisfied, by address, local";
          goto LABEL_39;
        }
LABEL_40:
        _Block_object_dispose(&v55, 8);
        break;
      default:
        break;
    }
  }
  v28 = __log_SCNetworkReachability_log;
  if (!__log_SCNetworkReachability_log)
  {
    v28 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
    __log_SCNetworkReachability_log = (uint64_t)v28;
  }
  v29 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v28, (os_log_type_t)v29))
  {
    v30 = _os_log_pack_size();
    v38 = (char *)applier - ((MEMORY[0x1E0C80A78](v30, v31, v32, v33, v34, v35, v36, v37) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v39 = _os_log_pack_fill();
    v40 = *((_DWORD *)v52 + 6);
    v41 = v48[3];
    *(_DWORD *)v39 = 136315906;
    *(_QWORD *)(v39 + 4) = a1;
    *(_WORD *)(v39 + 12) = 2080;
    *(_QWORD *)(v39 + 14) = a2;
    *(_WORD *)(v39 + 22) = 1024;
    *(_DWORD *)(v39 + 24) = v40;
    *(_WORD *)(v39 + 28) = 2080;
    *(_QWORD *)(v39 + 30) = v41;
    __SC_log_send(7, (uint64_t)v28, v29, v38);
  }
  v42 = *((_DWORD *)v52 + 6);
  _Block_object_dispose(&v47, 8);
  _Block_object_dispose(&v51, 8);
  return v42 & 0xFFFFFF;
}

uint64_t _SC_syslog_os_log_mapping(int a1)
{
  if ((a1 ^ (a1 >> 31)) >= 8)
    return 0;
  else
    return (0x201000000101010uLL >> (8 * (a1 ^ (a1 >> 31))));
}

BOOL __SC_log_enabled(int a1, os_log_t oslog, os_log_type_t type)
{
  BOOL v4;
  _BOOL8 result;

  if (os_log_type_enabled(oslog, type))
    return 1;
  if (_sc_log != 1)
  {
    if (a1 < 6)
      return 1;
    v4 = _sc_verbose && a1 == 6;
    if (v4 || _sc_debug != 0)
      return 1;
  }
  if (_SC_isInstallEnvironment_once != -1)
    dispatch_once(&_SC_isInstallEnvironment_once, &__block_literal_global_0);
  if (!_SC_isInstallEnvironment_is_install)
    return 0;
  if (a1 < 6)
    return 1;
  if (a1 != 6)
    return _sc_debug != 0;
  if (_SC_isAppleInternal_once != -1)
    dispatch_once(&_SC_isAppleInternal_once, &__block_literal_global_46);
  result = 1;
  if (!_SC_isAppleInternal_isInternal && !_sc_debug)
    return 0;
  return result;
}

NSObject *__SCNetworkReachabilityCreateCrazyIvan46Path(NSObject *a1, NSObject *a2, NSObject *a3, int a4)
{
  nw_path_status_t status;
  NSObject *v8;
  nw_endpoint_t v9;
  void *evaluator_for_endpoint;
  nw_parameters_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  nw_parameters_t v24;
  void *v25;
  NSObject *v26;
  uint64_t v27;
  char *v28;
  void *v29;
  int required_interface_index;
  _BYTE address[20];
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  status = nw_path_get_status(a1);
  v8 = 0;
  if (!a2 || status != nw_path_status_unsatisfied)
    return v8;
  if (nw_endpoint_get_type(a2) != nw_endpoint_type_address || nw_endpoint_get_address(a2)->sa_family != 2)
    return 0;
  if (a4)
  {
    required_interface_index = 0;
    v29 = 0;
    v33 = 0;
    v34 = 0;
    __memcpy_chk();
    if (a3)
      required_interface_index = nw_parameters_get_required_interface_index();
    if ((int)nw_nat64_copy_prefixes() >= 1)
    {
      *(_QWORD *)&address[4] = 0;
      *(_QWORD *)&address[12] = 0;
      v32 = 0;
      *(_WORD *)address = 7708;
      *(_WORD *)&address[2] = __rev16(nw_endpoint_get_port(a2));
      nw_nat64_synthesize_v6();
      v9 = nw_endpoint_create_address((const sockaddr *)address);
      evaluator_for_endpoint = (void *)nw_path_create_evaluator_for_endpoint();
      v8 = nw_path_evaluator_copy_path();
      if (nw_path_get_status(v8) == nw_path_status_unsatisfied)
      {
        nw_release(v8);
        v8 = 0;
      }
      else
      {
        v13 = __log_SCNetworkReachability_log;
        if (!__log_SCNetworkReachability_log)
        {
          v13 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
          __log_SCNetworkReachability_log = (uint64_t)v13;
        }
        v14 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v13, (os_log_type_t)v14))
        {
          v15 = _os_log_pack_size();
          v23 = (char *)&v29
              - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(6, (uint64_t)v13, v14, v23);
        }
      }
      nw_release(evaluator_for_endpoint);
      nw_release(v9);
      free(v29);
      return v8;
    }
    return 0;
  }
  if (a3)
    v12 = nw_parameters_copy(a3);
  else
    v12 = nw_parameters_create();
  v24 = v12;
  nw_parameters_set_required_address_family();
  v25 = (void *)nw_path_create_evaluator_for_endpoint();
  v8 = nw_path_evaluator_copy_path();
  if (nw_path_get_status(v8) == nw_path_status_unsatisfied)
  {
    nw_release(v8);
    v8 = 0;
  }
  else
  {
    v26 = __log_SCNetworkReachability_log;
    if (!__log_SCNetworkReachability_log)
    {
      v26 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
      __log_SCNetworkReachability_log = (uint64_t)v26;
    }
    v27 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v26, (os_log_type_t)v27))
    {
      _os_log_pack_size();
      v28 = (char *)&v29 - ((((uint64_t (*)(void))MEMORY[0x1E0C80A78])() + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v26, v27, v28);
    }
  }
  nw_release(v25);
  nw_release(v24);
  return v8;
}

void __SCNetworkReachabilityRestartResolver(void **cf, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  void *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  _QWORD v21[12];
  _QWORD block[6];

  block[5] = *MEMORY[0x1E0C80C00];
  if (cf && !*((_BYTE *)cf + 192) && *((_DWORD *)cf + 20) >= 2u)
  {
    CFRetain(cf);
    v4 = cf[33];
    v5 = MEMORY[0x1E0C809B0];
    if (v4)
    {
      nw_retain(cf[33]);
      v6 = cf[23];
      block[0] = v5;
      block[1] = 0x40000000;
      block[2] = ____SCNetworkReachabilityRestartResolver_block_invoke;
      block[3] = &__block_descriptor_tmp_109_0;
      block[4] = v4;
      dispatch_async(v6, block);
    }
    if (cf[31])
      v7 = nw_resolver_create_with_path();
    else
      v7 = nw_resolver_create_with_endpoint();
    v8 = (void *)v7;
    if (v7)
    {
      cf[33] = (void *)v7;
      v21[6] = v5;
      v21[7] = 0x40000000;
      v21[8] = ____SCNetworkReachabilityRestartResolver_block_invoke_110;
      v21[9] = &__block_descriptor_tmp_111_0;
      v21[10] = cf;
      v21[11] = v7;
      nw_resolver_set_cancel_handler();
      v21[0] = v5;
      v21[1] = 0x40000000;
      v21[2] = ____SCNetworkReachabilityRestartResolver_block_invoke_2;
      v21[3] = &__block_descriptor_tmp_116;
      v21[4] = cf;
      v21[5] = a2;
      if ((nw_resolver_set_update_handler() & 1) != 0)
        return;
      nw_release(v8);
    }
    else
    {
      v9 = __log_SCNetworkReachability_log;
      if (!__log_SCNetworkReachability_log)
      {
        v9 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
        __log_SCNetworkReachability_log = (uint64_t)v9;
      }
      v10 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v9, (os_log_type_t)v10))
      {
        v11 = _os_log_pack_size();
        v19 = (char *)v21 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v20 = _os_log_pack_fill();
        *(_DWORD *)v20 = 136315138;
        *(_QWORD *)(v20 + 4) = (char *)cf + 193;
        __SC_log_send(3, (uint64_t)v9, v10, v19);
      }
    }
    cf[33] = 0;
    CFRelease(cf);
  }
}

unsigned __int8 *is_valid_address(unsigned __int8 *a1)
{
  unsigned __int8 *v1;
  unsigned int v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  int v36;
  _QWORD v38[2];

  v1 = a1;
  v38[1] = *MEMORY[0x1E0C80C00];
  if (!a1)
    return v1;
  v2 = *a1;
  if (v2 > 0x80)
    return 0;
  v3 = a1[1];
  if (v3 == 30)
  {
    if (v2 <= 0x1B)
    {
      if ((is_valid_address_warned & 1) == 0)
      {
        v4 = __log_SCNetworkReachability_log;
        if (!__log_SCNetworkReachability_log)
        {
          v4 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
          __log_SCNetworkReachability_log = (uint64_t)v4;
        }
        v5 = _SC_syslog_os_log_mapping(4);
        if (!__SC_log_enabled(4, v4, (os_log_type_t)v5))
          goto LABEL_25;
        v18 = _os_log_pack_size();
        v14 = (char *)v38 - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v15 = _os_log_pack_fill();
        v26 = *v1;
        *(_DWORD *)v15 = 67109376;
        *(_DWORD *)(v15 + 4) = v26;
        *(_WORD *)(v15 + 8) = 2048;
        v17 = 28;
LABEL_17:
        *(_QWORD *)(v15 + 10) = v17;
LABEL_24:
        __SC_log_send(4, (uint64_t)v4, v5, v14);
LABEL_25:
        v1 = 0;
        is_valid_address_warned = 1;
        return v1;
      }
      return 0;
    }
    return v1;
  }
  if (v3 != 2)
  {
    if ((is_valid_address_warned & 1) == 0)
    {
      v4 = __log_SCNetworkReachability_log;
      if (!__log_SCNetworkReachability_log)
      {
        v4 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
        __log_SCNetworkReachability_log = (uint64_t)v4;
      }
      v5 = _SC_syslog_os_log_mapping(4);
      if (!__SC_log_enabled(4, v4, (os_log_type_t)v5))
        goto LABEL_25;
      v27 = _os_log_pack_size();
      v14 = (char *)v38 - ((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v35 = (_DWORD *)_os_log_pack_fill();
      v36 = v1[1];
      *v35 = 67109120;
      v35[1] = v36;
      goto LABEL_24;
    }
    return 0;
  }
  if (v2 <= 0xF)
  {
    if ((is_valid_address_warned & 1) == 0)
    {
      v4 = __log_SCNetworkReachability_log;
      if (!__log_SCNetworkReachability_log)
      {
        v4 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
        __log_SCNetworkReachability_log = (uint64_t)v4;
      }
      v5 = _SC_syslog_os_log_mapping(4);
      if (!__SC_log_enabled(4, v4, (os_log_type_t)v5))
        goto LABEL_25;
      v6 = _os_log_pack_size();
      v14 = (char *)v38 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v15 = _os_log_pack_fill();
      v16 = *v1;
      *(_DWORD *)v15 = 67109376;
      *(_DWORD *)(v15 + 4) = v16;
      *(_WORD *)(v15 + 8) = 2048;
      v17 = 16;
      goto LABEL_17;
    }
    return 0;
  }
  return v1;
}

in_addr *_SC_string_to_sockaddr(char *a1, int a2, in_addr *a3, size_t a4)
{
  in_addr *v8;
  BOOL v9;
  BOOL v10;
  char *v11;
  int s_addr_low;
  char v14;
  unsigned int s_addr_high;

  v8 = a3;
  if (!a3)
  {
    a4 = 128;
    v8 = (in_addr *)CFAllocatorAllocate(0, 128, 0);
  }
  bzero(v8, a4);
  v9 = a2 == 2 || a2 == 0;
  if (v9 && a4 >= 0x10 && inet_aton(a1, v8 + 1) == 1)
  {
    LOWORD(v8->s_addr) = 528;
    return v8;
  }
  v10 = a2 == 30 || a2 == 0;
  if (v10 && a4 >= 0x1C && inet_pton(30, a1, &v8[2]) == 1)
  {
    LOWORD(v8->s_addr) = 7708;
    v11 = strchr(a1, 37);
    if (v11)
      v8[6].s_addr = if_nametoindex(v11 + 1);
    s_addr_low = LOBYTE(v8[2].s_addr);
    if (s_addr_low == 255)
    {
      v14 = BYTE1(v8[2].s_addr);
      if ((v14 & 0xF0) == 0x30 || (v14 & 0xF) != 2)
        return v8;
    }
    else if (s_addr_low != 254 || (BYTE1(v8[2].s_addr) & 0xC0) != 0x80)
    {
      return v8;
    }
    s_addr_high = HIWORD(v8[2].s_addr);
    HIWORD(v8[2].s_addr) = 0;
    if (!v8[6].s_addr)
      v8[6].s_addr = __rev16(s_addr_high);
  }
  else
  {
    if (v8 != a3)
      CFAllocatorDeallocate(0, v8);
    return 0;
  }
  return v8;
}

uint64_t reachUpdateAndUnlock(uint64_t a1)
{
  __CFRunLoopSource *v2;
  uint64_t result;

  *(_BYTE *)(a1 + 113) = 1;
  v2 = *(__CFRunLoopSource **)(a1 + 120);
  if (!v2)
    return reachPerformAndUnlock(a1);
  if (*(_QWORD *)(a1 + 176))
  {
    CFRunLoopSourceSignal(v2);
    _SC_signalRunLoop((const void *)a1, *(__CFRunLoopSource **)(a1 + 120), *(CFArrayRef *)(a1 + 176));
  }
  result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  if ((_DWORD)result)
    reachUpdateAndUnlock_cold_1();
  return result;
}

void _SC_signalRunLoop(const void *a1, __CFRunLoopSource *a2, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const void *ValueAtIndex;
  CFIndex v10;
  __CFRunLoop *v11;
  __CFRunLoop *v12;
  const void *v13;
  const void *v14;
  CFIndex v15;
  CFIndex j;
  const void *v17;
  __CFRunLoop *v18;
  CFRunLoopMode v19;
  const __CFString *v20;
  int v21;

  Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    v7 = Count;
    for (i = 4; ; i += 3)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, i - 4);
      if (CFEqual(a1, ValueAtIndex))
        break;
      v10 = i - 1;
      if (v10 >= v7)
        return;
    }
    v11 = (__CFRunLoop *)CFArrayGetValueAtIndex(theArray, i - 3);
    if (v11)
    {
      v12 = v11;
      if (i - 1 < v7)
      {
        while (1)
        {
          v13 = CFArrayGetValueAtIndex(theArray, i - 1);
          if (CFEqual(a1, v13))
          {
            v14 = CFArrayGetValueAtIndex(theArray, i);
            if (!CFEqual(v12, v14))
              break;
          }
          v15 = i + 2;
          i += 3;
          if (v15 >= v7)
          {
            v11 = v12;
            goto LABEL_23;
          }
        }
        for (j = 0; j < v7; j += 3)
        {
          v17 = CFArrayGetValueAtIndex(theArray, j);
          if (CFEqual(a1, v17))
          {
            v18 = (__CFRunLoop *)CFArrayGetValueAtIndex(theArray, j + 1);
            v19 = CFRunLoopCopyCurrentMode(v18);
            if (v19)
            {
              v20 = v19;
              if (CFRunLoopIsWaiting(v18))
              {
                v21 = CFRunLoopContainsSource(v18, a2, v20);
                CFRelease(v20);
                if (v21)
                {
                  CFRunLoopWakeUp(v18);
                  return;
                }
              }
              else
              {
                CFRelease(v20);
              }
            }
          }
        }
        v11 = v12;
      }
LABEL_23:
      CFRunLoopWakeUp(v11);
    }
  }
}

void __SC_log_send2(int a1, uint64_t a2, uint64_t a3, int a4, char *a5)
{
  int v6;
  char *v7;
  char *v8;
  char v9;
  uint64_t v10;
  BOOL v11;
  BOOL v12;
  FILE **v13;
  timeval v14;
  tm v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v6 = _sc_log;
  if (a4)
    v7 = a5;
  else
    v7 = 0;
  if (a4)
    v8 = 0;
  else
    v8 = a5;
  if (_sc_log < 1)
  {
    if (v7)
    {
      mach_get_times();
      v10 = os_log_pack_compose();
      goto LABEL_16;
    }
LABEL_15:
    v9 = 1;
LABEL_17:
    if (a1 < 6 || (_sc_verbose ? (v11 = a1 == 6) : (v11 = 0), !v11 ? (v12 = _sc_debug == 0) : (v12 = 0), !v12))
    {
      pthread_mutex_lock(&lock);
      v13 = (FILE **)MEMORY[0x1E0C80C20];
      if (v6 == 2)
      {
        memset(&v15, 0, sizeof(v15));
        v14.tv_sec = 0;
        *(_QWORD *)&v14.tv_usec = 0;
        if ((v9 & 1) != 0)
        {
          gettimeofday(&v14, 0);
        }
        else
        {
          v14.tv_sec = (__darwin_time_t)(v7 + 8);
          v14.tv_usec = (unint64_t)(v7 + 16) / 0x3E8;
        }
        localtime_r(&v14.tv_sec, &v15);
        fprintf(*v13, "%2d:%02d:%02d.%03d ", v15.tm_hour, v15.tm_min, v15.tm_sec, v14.tv_usec / 1000);
      }
      fprintf(*v13, "%s\n", v8);
      fflush(*v13);
      pthread_mutex_unlock(&lock);
    }
    goto LABEL_31;
  }
  if (!v7)
  {
    if (_sc_log == 1)
      return;
    goto LABEL_15;
  }
  if (_sc_log != 1)
  {
    v10 = os_log_pack_send_and_compose();
LABEL_16:
    v8 = (char *)v10;
    v9 = 0;
    goto LABEL_17;
  }
  os_log_pack_send();
  v9 = 0;
LABEL_31:
  if ((v9 & 1) == 0 && v8 != &v16)
    free(v8);
}

void __SC_log_send(int a1, uint64_t a2, uint64_t a3, char *a4)
{
  __SC_log_send2(a1, a2, a3, 1, a4);
}

void processHardwareDependency(uint64_t a1)
{
  const __CFDictionary *v2;
  const void *v3;
  CFTypeID TypeID;
  const void *v5;
  const void *v6;
  const void *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  void *value[2];

  value[1] = *(void **)MEMORY[0x1E0C80C00];
  value[0] = 0;
  if (__SCPreferencesUsingDefaultPrefs(a1))
  {
    v2 = *(const __CFDictionary **)(a1 + 96);
    if (!v2
      || !CFDictionaryGetValueIfPresent(v2, CFSTR("allow-model-conflict"), (const void **)value)
      || (v3 = value[0], TypeID = CFBooleanGetTypeID(), !v3)
      || CFGetTypeID(v3) != TypeID
      || !CFBooleanGetValue((CFBooleanRef)value[0]))
    {
      v5 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 280), CFSTR("Model"));
      v6 = (const void *)_SC_hw_model(0);
      if (v5)
      {
        v7 = v6;
        if (v5 != v6 && (!v6 || !CFEqual(v5, v6)))
        {
          v8 = __log_SCPreferences_log;
          if (!__log_SCPreferences_log)
          {
            v8 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
            __log_SCPreferences_log = (uint64_t)v8;
          }
          v9 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v8, (os_log_type_t)v9))
          {
            v10 = _os_log_pack_size();
            v18 = (char *)value
                - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v19 = _os_log_pack_fill();
            *(_DWORD *)v19 = 138412546;
            *(_QWORD *)(v19 + 4) = v5;
            *(_WORD *)(v19 + 12) = 2112;
            *(_QWORD *)(v19 + 14) = v7;
            __SC_log_send(5, (uint64_t)v8, v9, v18);
          }
          CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 280));
          *(_BYTE *)(a1 + 305) = 1;
        }
      }
    }
  }
}

uint64_t _SC_hw_model(int a1)
{
  uint64_t *v2;

  if (_SC_hw_model_once != -1)
    dispatch_once(&_SC_hw_model_once, &__block_literal_global_7);
  v2 = &_SC_hw_model_model_trimmed;
  if (!a1)
    v2 = &_SC_hw_model_model;
  return *v2;
}

SCPreferencesRef SCPreferencesCreateWithAuthorization(CFAllocatorRef allocator, CFStringRef name, CFStringRef prefsID, AuthorizationRef authorization)
{
  return (SCPreferencesRef)SCPreferencesCreateWithOptions(allocator, name, prefsID, CFSTR("UseEntitlement"), 0);
}

uint64_t reachPerform(uint64_t a1)
{
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 16)))
    reachPerform_cold_1();
  return reachPerformAndUnlock(a1);
}

CFStringRef SCNetworkServiceGetServiceID(SCNetworkServiceRef service)
{
  uint64_t v2;

  if (__SCNetworkServiceInitialize_initialized == -1)
  {
    if (!service)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (!service)
      goto LABEL_6;
  }
  v2 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) == v2)
    return (CFStringRef)*((_QWORD *)service + 2);
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

Boolean SCNetworkServiceGetEnabled(SCNetworkServiceRef service)
{
  uint64_t v2;
  const __CFString *NetworkServiceEntity;
  Boolean PrefsEnabled;

  if (__SCNetworkServiceInitialize_initialized == -1)
  {
    if (!service)
      goto LABEL_7;
  }
  else
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (!service)
      goto LABEL_7;
  }
  v2 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) == v2 && *((_QWORD *)service + 4))
  {
    NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)service + 2), 0);
    PrefsEnabled = __getPrefsEnabled(*((const __SCPreferences **)service + 4), NetworkServiceEntity);
    CFRelease(NetworkServiceEntity);
    return PrefsEnabled;
  }
LABEL_7:
  _SCErrorSet(1002);
  return 0;
}

BOOL __getPrefsEnabled(const __SCPreferences *a1, const __CFString *a2)
{
  CFDictionaryRef Value;
  CFTypeID TypeID;

  Value = SCPreferencesPathGetValue(a1, a2);
  TypeID = CFDictionaryGetTypeID();
  return !Value || CFGetTypeID(Value) != TypeID || !CFDictionaryContainsKey(Value, CFSTR("__INACTIVE__"));
}

CFRunLoopSourceRef SCDynamicStoreCreateRunLoopSource(CFAllocatorRef allocator, SCDynamicStoreRef store, CFIndex order)
{
  CFRunLoopSourceRef result;
  CFRunLoopSourceContext v7;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v8[0] = store;
  if (!__SCDynamicStoreNormalize((uint64_t)v8, 0))
    return 0;
  if ((*((_DWORD *)store + 12) | 4) != 4)
  {
    _SCErrorSet(2003);
    return 0;
  }
  result = (CFRunLoopSourceRef)*((_QWORD *)store + 8);
  if (result)
    goto LABEL_6;
  v7.version = 0;
  v7.info = (void *)v8[0];
  v7.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  v7.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  v7.copyDescription = (CFStringRef (__cdecl *)(const void *))rlsCopyDescription;
  v7.equal = (Boolean (__cdecl *)(const void *, const void *))MEMORY[0x1E0C98620];
  v7.hash = (CFHashCode (__cdecl *)(const void *))MEMORY[0x1E0C98758];
  v7.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))rlsSchedule;
  v7.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))rlsCancel;
  v7.perform = (void (__cdecl *)(void *))rlsPerform;
  result = CFRunLoopSourceCreate(allocator, order, &v7);
  *((_QWORD *)store + 8) = result;
  if (result || (_SCErrorSet(1001), (result = (CFRunLoopSourceRef)*((_QWORD *)store + 8)) != 0))
  {
LABEL_6:
    CFRetain(result);
    return (CFRunLoopSourceRef)*((_QWORD *)store + 8);
  }
  return result;
}

CFTypeRef __SCDynamicStoreCopyValueCommon(uint64_t a1, const __CFString *a2, int a3)
{
  uint64_t v5;
  const __CFDictionary *v6;
  const __CFArray *v7;
  int v8;
  const __CFDictionary *v9;
  uint64_t v11;
  int v12;
  void *v13;
  __CFDictionary *Mutable;
  int v15;
  uint64_t v16;
  void *value;
  _DWORD length[3];
  vm_size_t v19;
  uint64_t v20;
  CFTypeRef cf;
  uint64_t v22[2];
  CFRange v23;

  v22[1] = *MEMORY[0x1E0C80C00];
  v22[0] = a1;
  v20 = 0;
  cf = 0;
  v19 = 0;
  memset(length, 0, sizeof(length));
  v16 = 0;
  value = 0;
  _SCErrorSet(0);
  if (!__SCDynamicStoreNormalize((uint64_t)v22, 1))
    return 0;
  v5 = v22[0];
  if (*(_BYTE *)(v22[0] + 200))
  {
    v6 = *(const __CFDictionary **)(v22[0] + 216);
    if (v6)
    {
      if (CFDictionaryGetValueIfPresent(v6, a2, (const void **)&value))
        return CFRetain(value);
    }
    v7 = *(const __CFArray **)(v5 + 224);
    if (v7)
    {
      v23.length = CFArrayGetCount(*(CFArrayRef *)(v5 + 224));
      v23.location = 0;
      if (CFArrayContainsValue(v7, v23, a2))
      {
        v8 = 1004;
LABEL_30:
        _SCErrorSet(v8);
        return 0;
      }
    }
    v9 = *(const __CFDictionary **)(v5 + 208);
    if (v9)
    {
      if (CFDictionaryGetValueIfPresent(v9, a2, (const void **)&value))
        return CFRetain(value);
    }
  }
  if (!_SCSerializeString(a2, (CFDataRef *)&cf, (vm_address_t *)&v20, &v19))
    goto LABEL_29;
  do
    v11 = configget(*(_DWORD *)(v5 + 40), v20, v19, &length[1], length, (_DWORD *)&v16 + 1, &v16);
  while (__SCDynamicStoreCheckRetryAndHandleError(v22[0], v11, &v16, (uint64_t)"SCDynamicStoreCopyValue configget()"));
  CFRelease(cf);
  v12 = v16;
  v8 = __SCDynamicStoreMapInternalStatus(v16, a3);
  LODWORD(v16) = v8;
  if (v8)
  {
    if (*(_QWORD *)&length[1])
    {
      MEMORY[0x18D78D14C](*MEMORY[0x1E0C83DA0], *(_QWORD *)&length[1], length[0]);
      v8 = v16;
    }
    if (!a3)
      v8 = v12;
    goto LABEL_30;
  }
  if (!_SCUnserialize((CFPropertyListRef *)&value, 0, *(UInt8 **)&length[1], length[0]))
  {
LABEL_29:
    v8 = 1001;
    goto LABEL_30;
  }
  if (*(_BYTE *)(v5 + 200))
  {
    v13 = value;
    if (value)
    {
      Mutable = *(__CFDictionary **)(v5 + 208);
      if (!Mutable)
      {
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        *(_QWORD *)(v5 + 208) = Mutable;
        v13 = value;
      }
      CFDictionarySetValue(Mutable, a2, v13);
    }
  }
  if (a3)
    v15 = v16;
  else
    v15 = v12;
  _SCErrorSet(v15);
  return value;
}

uint64_t _SCUnserialize(CFPropertyListRef *a1, const __CFData *a2, UInt8 *bytes, CFIndex length)
{
  CFPropertyListRef v5;
  const __CFData *v9;
  mach_error_t v10;
  mach_error_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  CFErrorRef v37;
  CFErrorRef error[2];

  error[1] = *(CFErrorRef *)MEMORY[0x1E0C80C00];
  error[0] = 0;
  if (a2)
  {
    v5 = CFPropertyListCreateWithData(0, a2, 0, 0, error);
    *a1 = v5;
    if (v5)
      return 1;
  }
  else
  {
    v9 = CFDataCreateWithBytesNoCopy(0, bytes, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    *a1 = CFPropertyListCreateWithData(0, v9, 0, 0, error);
    CFRelease(v9);
    v10 = MEMORY[0x18D78D14C](*MEMORY[0x1E0C83DA0], bytes, length);
    if (v10)
    {
      v11 = v10;
      v12 = _SC_LOG_DEFAULT();
      v13 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v12, (os_log_type_t)v13))
      {
        v14 = _os_log_pack_size();
        v22 = (char *)error
            - ((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v23 = _os_log_pack_fill();
        v24 = mach_error_string(v11);
        *(_DWORD *)v23 = 136315138;
        *(_QWORD *)(v23 + 4) = v24;
        __SC_log_send(5, (uint64_t)v12, v13, v22);
      }
    }
    if (*a1)
      return 1;
  }
  if (error[0])
  {
    v25 = _SC_LOG_DEFAULT();
    v26 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v25, (os_log_type_t)v26))
    {
      v27 = _os_log_pack_size();
      v35 = (char *)error - ((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v36 = _os_log_pack_fill();
      v37 = error[0];
      *(_DWORD *)v36 = 138412290;
      *(_QWORD *)(v36 + 4) = v37;
      __SC_log_send(5, (uint64_t)v25, v26, v35);
    }
    CFRelease(error[0]);
  }
  _SCErrorSet(1001);
  return 0;
}

Boolean SCDynamicStoreSetNotificationKeys(SCDynamicStoreRef store, CFArrayRef keys, CFArrayRef patterns)
{
  int v6;
  uint64_t v7;
  int v8;
  const void *v9;
  const void *v10;
  int v12;
  vm_size_t v13;
  uint64_t v14;
  CFTypeRef v15;
  vm_size_t v16;
  uint64_t v17;
  CFTypeRef cf;
  uint64_t v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v19[0] = (uint64_t)store;
  v17 = 0;
  cf = 0;
  v15 = 0;
  v16 = 0;
  v13 = 0;
  v14 = 0;
  v12 = 0;
  v6 = __SCDynamicStoreNormalize((uint64_t)v19, 0);
  if (!v6)
    return v6;
  if (keys && !_SCSerialize(keys, (CFDataRef *)&cf, (vm_address_t *)&v17, &v16))
    goto LABEL_23;
  if (patterns && !_SCSerialize(patterns, (CFDataRef *)&v15, (vm_address_t *)&v14, &v13))
  {
    if (cf)
      CFRelease(cf);
LABEL_23:
    v8 = 1001;
LABEL_24:
    _SCErrorSet(v8);
    LOBYTE(v6) = 0;
    return v6;
  }
  do
    v7 = notifyset(*((_DWORD *)store + 10), v17, v16, v14, v13, &v12);
  while (__SCDynamicStoreCheckRetryAndHandleError(v19[0], v7, &v12, (uint64_t)"SCDynamicStoreSetNotificationKeys notifyset()"));
  if (cf)
    CFRelease(cf);
  if (v15)
    CFRelease(v15);
  v8 = v12;
  if (v12)
    goto LABEL_24;
  if (keys)
    keys = CFArrayCreateMutableCopy(0, 0, keys);
  v9 = (const void *)*((_QWORD *)store + 21);
  if (v9)
    CFRelease(v9);
  *((_QWORD *)store + 21) = keys;
  if (patterns)
    patterns = CFArrayCreateMutableCopy(0, 0, patterns);
  v10 = (const void *)*((_QWORD *)store + 22);
  if (v10)
    CFRelease(v10);
  *((_QWORD *)store + 22) = patterns;
  LOBYTE(v6) = 1;
  return v6;
}

uint64_t __SCDynamicStoreNormalize(uint64_t a1, int a2)
{
  const void *v3;
  uint64_t v4;
  int v6;

  if (!a1)
    __SCDynamicStoreNormalize_cold_1();
  v3 = *(const void **)a1;
  if (a2 && !v3)
  {
    if (__SCDynamicStoreNullSession_initialized != -1)
      dispatch_once(&__SCDynamicStoreNullSession_initialized, &__block_literal_global_33);
    v3 = (const void *)S_null_session;
    *(_QWORD *)a1 = S_null_session;
    if (!v3)
      return 0;
  }
  if (__SCDynamicStoreInitialize_initialized == -1)
  {
    if (!v3)
      goto LABEL_15;
  }
  else
  {
    dispatch_once(&__SCDynamicStoreInitialize_initialized, &__block_literal_global_51);
    if (!v3)
      goto LABEL_15;
  }
  v4 = __kSCDynamicStoreTypeID;
  if (CFGetTypeID(v3) == v4)
  {
    if (*(_DWORD *)(*(_QWORD *)a1 + 40))
      return 1;
    v6 = 2002;
    goto LABEL_16;
  }
LABEL_15:
  v6 = 2001;
LABEL_16:
  _SCErrorSet(v6);
  return 0;
}

BOOL _SCSerialize(CFPropertyListRef propertyList, CFDataRef *a2, vm_address_t *a3, vm_size_t *a4)
{
  CFDataRef v8;
  const __CFData *v9;
  _BOOL8 result;
  const __CFData *Data;
  const __CFData *v12;
  mach_error_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  _QWORD v38[2];

  v38[1] = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    result = 0;
    if (!a3 || !a4)
      return result;
    Data = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (Data)
    {
      v12 = Data;
      v13 = __CFDataCopyVMData(Data, a3, a4);
      CFRelease(v12);
      if (!v13)
        return 1;
      v14 = _SC_LOG_DEFAULT();
      v15 = _SC_syslog_os_log_mapping(5);
      result = __SC_log_enabled(5, v14, (os_log_type_t)v15);
      if (result)
      {
        v16 = _os_log_pack_size();
        v24 = (char *)v38 - ((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v25 = _os_log_pack_fill();
        v26 = mach_error_string(v13);
        *(_DWORD *)v25 = 136315138;
        *(_QWORD *)(v25 + 4) = v26;
        __SC_log_send(5, (uint64_t)v14, v15, v24);
        return 0;
      }
      return result;
    }
LABEL_13:
    v27 = _SC_LOG_DEFAULT();
    v28 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v27, (os_log_type_t)v28))
    {
      v29 = _os_log_pack_size();
      v37 = (char *)v38 - ((MEMORY[0x1E0C80A78](v29, v30, v31, v32, v33, v34, v35, v36) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v27, v28, v37);
    }
    if (a2)
      *a2 = 0;
    result = 0;
    if (a3 && a4)
    {
      result = 0;
      *a4 = 0;
      *a3 = 0;
    }
    return result;
  }
  v8 = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (!v8)
    goto LABEL_13;
  v9 = v8;
  *a2 = v8;
  result = 1;
  if (a3 && a4)
  {
    *a3 = (vm_address_t)CFDataGetBytePtr(v9);
    *a4 = CFDataGetLength(v9);
    return 1;
  }
  return result;
}

uint64_t notifyset(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int *a6)
{
  mach_port_t special_reply_port;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  mach_msg_header_t msg;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v14 = 2;
  v15 = a2;
  v16 = 16777472;
  v17 = a3;
  v18 = a4;
  v19 = 16777472;
  v20 = a5;
  v21 = *MEMORY[0x1E0C804E8];
  v22 = a3;
  v23 = a5;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4E3900000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v9 = mach_msg(&msg, 3162115, 0x4Cu, 0x30u, special_reply_port, 0, 0);
  v10 = v9;
  if ((v9 - 268435458) > 0xE || ((1 << (v9 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v9)
    {
      if (msg.msgh_id == 71)
      {
        v10 = 4294966988;
      }
      else if (msg.msgh_id == 20125)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 40)
          {
            if (!msg.msgh_remote_port)
            {
              v10 = HIDWORD(v15);
              if (!HIDWORD(v15))
              {
                *a6 = v16;
                return v10;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v11 = 1;
            else
              v11 = HIDWORD(v15) == 0;
            if (v11)
              v10 = 4294966996;
            else
              v10 = HIDWORD(v15);
            goto LABEL_22;
          }
        }
        v10 = 4294966996;
      }
      else
      {
        v10 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v10;
    }
    mig_dealloc_special_reply_port();
  }
  return v10;
}

uint64_t __SCDynamicStoreAddNotificationPort(mach_port_context_t context, __n128 a2)
{
  ipc_space_t *v3;
  kern_return_t v4;
  mach_error_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  kern_return_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  kern_return_t v34;
  char *v35;
  const __CFString *v36;
  UInt8 *v37;
  const char *v38;
  CFStringRef v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  char *v52;
  mach_port_type_t v53;
  BOOL v54;
  const char *v55;
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  __n128 v71;
  __n128 *v72;
  __n128 v73;
  mach_port_type_t ptype;
  mach_error_t v75;
  mach_port_name_t name[2];
  _QWORD block[7];
  mach_port_options_t options;
  uint64_t v79;

  v3 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  v79 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)name = 0;
  v75 = 0;
  a2.n128_u64[0] = 136315650;
  v71 = a2;
  a2.n128_u64[0] = 136315138;
  v73 = a2;
  do
  {
    while (1)
    {
      *(_QWORD *)&options.flags = 17;
      options.8 = 0uLL;
      v4 = mach_port_construct(*v3, &options, context, name);
      if (!v4)
        break;
      v5 = v4;
      v6 = __log_SCDynamicStore();
      v7 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v6, (os_log_type_t)v7))
      {
        v8 = _os_log_pack_size();
        v16 = (char *)&v71 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v17 = _os_log_pack_fill();
        v18 = mach_error_string(v5);
        *(_DWORD *)v17 = v73.n128_u32[0];
        *(_QWORD *)(v17 + 4) = v18;
        __SC_log_send(5, (uint64_t)v6, v7, v16);
      }
      if (v5 != 6 && v5 != 3)
        goto LABEL_37;
      usleep(0xC350u);
    }
    v20 = mach_port_request_notification(*v3, name[0], 70, 1u, name[0], 0x15u, &name[1]);
    if (v20)
    {
      v5 = v20;
      v56 = __log_SCDynamicStore();
      v57 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v56, (os_log_type_t)v57))
      {
        v58 = _os_log_pack_size();
        v66 = (char *)&v71 - ((MEMORY[0x1E0C80A78](v58, v59, v60, v61, v62, v63, v64, v65) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v67 = _os_log_pack_fill();
        v68 = mach_error_string(v5);
        *(_DWORD *)v67 = v73.n128_u32[0];
        *(_QWORD *)(v67 + 4) = v68;
        __SC_log_send(5, (uint64_t)v56, v57, v66);
      }
      goto LABEL_37;
    }
    if (name[1])
    {
      v21 = __log_SCDynamicStore();
      v22 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v21, (os_log_type_t)v22))
      {
        v23 = _os_log_pack_size();
        v31 = (char *)&v71 - ((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v21, v22, v31);
      }
    }
    v32 = notifyviaport(*(_DWORD *)(context + 40), name[0], 0, &v75);
    v33 = v32;
    switch((_DWORD)v32)
    {
      case 0xFFFFFECC:
        goto LABEL_29;
      case 0:
        continue;
      case 0x10000003:
        mach_port_deallocate(*v3, name[0]);
LABEL_29:
        mach_port_destruct(*v3, name[0], 0, context);
        name[0] = 0;
        continue;
    }
    ptype = 0;
    v34 = mach_port_type(*v3, name[0], &ptype);
    v35 = mach_error_string(v33);
    v36 = CFStringCreateWithFormat(0, 0, CFSTR("SCDynamicStore notifyviaport() failed: %s"), v35);
    v37 = _SC_cfstring_to_cstring(v36, 0, 0, 0x600u);
    CFRelease(v36);
    v38 = getprogname();
    v39 = CFStringCreateWithFormat(0, 0, CFSTR("A SCDynamicStore error has been detected by \"%s\""), v38);
    v40 = __log_SCDynamicStore();
    v41 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v40, (os_log_type_t)v41))
    {
      v42 = _os_log_pack_size();
      v72 = &v71;
      v50 = (char *)&v71 - ((MEMORY[0x1E0C80A78](v42, v43, v44, v45, v46, v47, v48, v49) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v51 = _os_log_pack_fill();
      v52 = mach_error_string(v33);
      v53 = ptype;
      v54 = (ptype & 0x150000) != 0 && v34 == 0;
      *(_DWORD *)v51 = v71.n128_u32[0];
      v55 = "";
      if (v54)
        v55 = "w/send";
      *(_QWORD *)(v51 + 4) = v52;
      *(_WORD *)(v51 + 12) = 2080;
      *(_QWORD *)(v51 + 14) = v55;
      *(_WORD *)(v51 + 22) = 1024;
      *(_DWORD *)(v51 + 24) = v53;
      __SC_log_send(3, (uint64_t)v40, v41, v50);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_0;
    block[3] = &__block_descriptor_tmp_14;
    block[4] = v37;
    block[5] = CFSTR("SCDynamicStore notify mach port error");
    block[6] = v39;
    if (_SC_crash_once_once_0 != -1)
      dispatch_once(&_SC_crash_once_once_0, block);
    CFAllocatorDeallocate(0, v37);
    CFRelease(v39);
    if ((_DWORD)v33)
      goto LABEL_29;
  }
  while (__SCDynamicStoreCheckRetryAndHandleError(context, v33, &v75, (uint64_t)"SCDynamicStore callback notifyviaport()"));
  v69 = name[0];
  if (v75 && name[0])
  {
    mach_port_destruct(*v3, name[0], 0, context);
    v5 = v75;
LABEL_37:
    _SCErrorSet(v5);
    return 0;
  }
  return v69;
}

uint64_t __SCDynamicStoreCheckRetryAndHandleError(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t result;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  const __CFString *v26;
  UInt8 *v27;
  const char *v28;
  CFStringRef v29;
  _QWORD block[5];
  _QWORD v31[6];
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  char v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a2 == 268435459)
    goto LABEL_4;
  v7 = a2;
  if (!(_DWORD)a2)
    return 0;
  if ((_DWORD)a2 == -308)
  {
LABEL_4:
    v8 = MEMORY[0x1E0C809B0];
    v9 = *(NSObject **)(a1 + 16);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ____SCDynamicStoreCheckRetryAndHandleError_block_invoke;
    block[3] = &__block_descriptor_tmp_3;
    block[4] = a1;
    dispatch_sync(v9, block);
    v32 = 0;
    v33 = &v32;
    v34 = 0x2000000000;
    v35 = 0;
    v10 = *(NSObject **)(a1 + 16);
    v31[0] = v8;
    v31[1] = 0x40000000;
    v31[2] = ____SCDynamicStoreReconnect_block_invoke;
    v31[3] = &unk_1E25D0648;
    v31[4] = &v32;
    v31[5] = a1;
    dispatch_sync(v10, v31);
    LODWORD(v8) = *((unsigned __int8 *)v33 + 24);
    _Block_object_dispose(&v32, 8);
    if ((_DWORD)v8)
      return 1;
    v7 = SCError();
  }
  if ((_DWORD)v7 != 2002)
  {
    v12 = __log_SCDynamicStore_log;
    if (!__log_SCDynamicStore_log)
    {
      v12 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
      __log_SCDynamicStore_log = (uint64_t)v12;
    }
    v13 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v12, (os_log_type_t)v13))
    {
      v14 = _os_log_pack_size();
      v22 = (char *)block - ((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v23 = _os_log_pack_fill();
      v24 = SCErrorString(v7);
      *(_DWORD *)v23 = 136315650;
      *(_QWORD *)(v23 + 4) = a4;
      *(_WORD *)(v23 + 12) = 2080;
      *(_QWORD *)(v23 + 14) = v24;
      *(_WORD *)(v23 + 22) = 1024;
      *(_DWORD *)(v23 + 24) = v7;
      __SC_log_send(5, (uint64_t)v12, v13, v22);
    }
    *(_DWORD *)(a1 + 40) = 0;
    v25 = SCErrorString(v7);
    v26 = CFStringCreateWithFormat(0, 0, CFSTR("CheckRetryAndHandleError \"%s\" failed: %s (%d)"), a4, v25, v7);
    v27 = _SC_cfstring_to_cstring(v26, 0, 0, 0x600u);
    CFRelease(v26);
    v28 = getprogname();
    v29 = CFStringCreateWithFormat(0, 0, CFSTR("A SCDynamicStore error has been detected by \"%s\"."), v28);
    _SC_crash((const char *)v27, CFSTR("CheckRetryAndHandleError"), (uint64_t)v29);
    CFAllocatorDeallocate(0, v27);
    CFRelease(v29);
  }
  result = 0;
  *a3 = v7;
  return result;
}

uint64_t notifyviaport(int a1, int a2, int a3, int *a4)
{
  mach_port_name_t special_reply_port;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  _BYTE msg[36];
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&msg[20] = 0u;
  *(_OWORD *)&msg[4] = 0u;
  *(_DWORD *)&msg[24] = 1;
  *(_DWORD *)&msg[28] = a2;
  v12 = 1114112;
  v13 = *MEMORY[0x1E0C804E8];
  v14 = a3;
  special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)msg = -2147478253;
  *(_QWORD *)&msg[16] = 0x4E3500000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    special_reply_port = *(_DWORD *)&msg[12];
  }
  v7 = mach_msg((mach_msg_header_t *)msg, 3162115, 0x34u, 0x30u, special_reply_port, 0, 0);
  v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v7)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v8 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 20121)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 40)
          {
            if (!*(_DWORD *)&msg[8])
            {
              v8 = *(unsigned int *)&msg[32];
              if (!*(_DWORD *)&msg[32])
              {
                *a4 = v12;
                return v8;
              }
              goto LABEL_22;
            }
          }
          else if (*(_DWORD *)&msg[4] == 36)
          {
            if (*(_DWORD *)&msg[8])
              v9 = 1;
            else
              v9 = *(_DWORD *)&msg[32] == 0;
            if (v9)
              v8 = 4294966996;
            else
              v8 = *(unsigned int *)&msg[32];
            goto LABEL_22;
          }
        }
        v8 = 4294966996;
      }
      else
      {
        v8 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v8;
    }
    mig_dealloc_special_reply_port();
  }
  return v8;
}

uint64_t SCPreferencesCreateWithOptions(const __CFAllocator *a1, const __CFString *a2, const __CFString *a3, __CFString *a4, const __CFDictionary *a5)
{
  CFTypeID TypeID;
  CFMutableDictionaryRef Mutable;
  const void *ApplicationBundleID;
  CFDataRef v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  _BOOL4 v17;
  _BOOL4 v18;
  const char *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  BOOL v32;
  int v33;
  const char *v34;
  _QWORD v36[2];
  CFDataRef v37[2];

  v37[1] = *(CFDataRef *)MEMORY[0x1E0C80C00];
  v37[0] = 0;
  if (a5 && (TypeID = CFDictionaryGetTypeID(), CFGetTypeID(a5) != TypeID))
  {
    _SCErrorSet(1002);
    return 0;
  }
  else
  {
    if (a4
      && (Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]),
          ApplicationBundleID = (const void *)_SC_getApplicationBundleID(),
          CFDictionaryAddValue(Mutable, CFSTR("CallerInfo"), ApplicationBundleID),
          Mutable))
    {
      _SCSerialize(Mutable, v37, 0, 0);
      CFRelease(Mutable);
      v13 = v37[0];
    }
    else
    {
      v13 = 0;
    }
    v14 = __SCPreferencesCreate(a1, a2, a3, v13, a5);
    if (v14)
    {
      if (a5)
        v15 = "options";
      else
        v15 = "";
      v16 = "authorization";
      if (a4 == CFSTR("UseEntitlement"))
        v17 = "entitlement" != "";
      else
        v17 = "authorization" != "";
      if (a4 == CFSTR("UseEntitlement"))
        v16 = "entitlement";
      if (a4)
        v18 = v17;
      else
        v18 = 0;
      if (a4)
        v19 = v16;
      else
        v19 = "";
      v20 = __log_SCPreferences_log;
      if (!__log_SCPreferences_log)
      {
        v20 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
        __log_SCPreferences_log = (uint64_t)v20;
      }
      v21 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v20, (os_log_type_t)v21))
      {
        v22 = _os_log_pack_size();
        v36[1] = v36;
        v30 = (char *)v36 - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v31 = _os_log_pack_fill();
        if (a5)
          v32 = "options" == "";
        else
          v32 = 1;
        v33 = !v32;
        *(_DWORD *)v31 = 136315906;
        *(_QWORD *)(v31 + 4) = v15;
        *(_WORD *)(v31 + 12) = 2080;
        if ((v33 & v18) != 0)
          v34 = " + ";
        else
          v34 = "";
        *(_QWORD *)(v31 + 14) = v34;
        *(_WORD *)(v31 + 22) = 2080;
        *(_QWORD *)(v31 + 24) = v19;
        *(_WORD *)(v31 + 32) = 2112;
        *(_QWORD *)(v31 + 34) = v14;
        __SC_log_send(7, (uint64_t)v20, v21, v30);
      }
    }
    if (v37[0])
      CFRelease(v37[0]);
  }
  return v14;
}

uint64_t __SCPreferencesCreate(const __CFAllocator *a1, const __CFString *a2, const __CFString *a3, const void *a4, const __CFDictionary *a5)
{
  uint64_t Instance;
  uint64_t v11;
  const char *v12;
  int v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  int *v27;
  char *v28;
  int v29;
  uint64_t v31;
  int *v32;
  _QWORD v33[2];

  v33[1] = *MEMORY[0x1E0C80C00];
  if (__SCPreferencesInitialize_initialized != -1)
    dispatch_once(&__SCPreferencesInitialize_initialized, &__block_literal_global_48);
  Instance = _CFRuntimeCreateInstance();
  v11 = Instance;
  if (Instance)
  {
    pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0);
    *(_DWORD *)(v11 + 116) = -1;
    *(_BYTE *)(v11 + 306) = geteuid() == 0;
    *(_QWORD *)(v11 + 80) = CFStringCreateCopy(a1, a2);
    if (a3)
      *(_QWORD *)(v11 + 88) = CFStringCreateCopy(a1, a3);
    if (a4)
      *(_QWORD *)(v11 + 312) = CFRetain(a4);
    if (a5)
      *(_QWORD *)(v11 + 96) = CFDictionaryCreateCopy(a1, a5);
    v12 = (const char *)__SCPreferencesPath(a1, a3);
    *(_QWORD *)(v11 + 104) = v12;
    if (v12)
    {
      v13 = access(v12, 4);
      if (!v13)
      {
LABEL_18:
        _SCErrorSet(v13);
        return v11;
      }
      v14 = *__error();
      switch(v14)
      {
        case 13:
          goto LABEL_29;
        case 2:
          v13 = 3003;
          goto LABEL_18;
        case 1:
LABEL_29:
          if (*(_QWORD *)(v11 + 312))
          {
            v13 = 0;
            goto LABEL_18;
          }
          v31 = *(_QWORD *)(v11 + 104);
          v32 = __error();
          log_open_error(v31, *v32);
          v29 = 1003;
LABEL_24:
          CFRelease((CFTypeRef)v11);
          _SCErrorSet(v29);
          return 0;
      }
      v15 = __log_SCPreferences_log;
      if (!__log_SCPreferences_log)
      {
        v15 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
        __log_SCPreferences_log = (uint64_t)v15;
      }
      v16 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v15, (os_log_type_t)v16))
      {
        v17 = _os_log_pack_size();
        v25 = (char *)v33 - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v26 = _os_log_pack_fill();
        v27 = __error();
        v28 = strerror(*v27);
        *(_DWORD *)v26 = 136315138;
        *(_QWORD *)(v26 + 4) = v28;
        __SC_log_send(5, (uint64_t)v15, v16, v25);
        v29 = 1001;
        goto LABEL_24;
      }
    }
    v29 = 1001;
    goto LABEL_24;
  }
  return v11;
}

uint64_t __SCPreferencesScheduleWithRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3, NSObject *a4)
{
  pthread_mutex_t *v8;
  uint64_t v9;
  __CFArray *Mutable;
  int v12;
  CFRunLoopSourceRef RunLoopSource;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  int v37;
  const char *v38;
  _QWORD v39[2];

  v39[1] = *MEMORY[0x1E0C80C00];
  v8 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (*(_QWORD *)(a1 + 272))
    goto LABEL_2;
  if (!a4)
  {
    if (*(_BYTE *)(a1 + 200))
      goto LABEL_9;
LABEL_13:
    if (!*(_QWORD *)(a1 + 152))
    {
      if (!__SCPreferencesAddSession(a1))
        goto LABEL_3;
      if (!*(_QWORD *)(a1 + 152))
        __SCPreferencesScheduleWithRunLoop_cold_1();
    }
    __SCPreferencesAddSessionKeys((CFStringRef)a1);
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    CFArrayAppendValue(Mutable, *(const void **)(a1 + 184));
    CFArrayAppendValue(Mutable, *(const void **)(a1 + 192));
    v12 = SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(a1 + 152), Mutable, 0);
    CFRelease(Mutable);
    if (v12)
    {
      if (!a2)
        goto LABEL_20;
      RunLoopSource = SCDynamicStoreCreateRunLoopSource(0, *(SCDynamicStoreRef *)(a1 + 152), 0);
      *(_QWORD *)(a1 + 208) = RunLoopSource;
      if (RunLoopSource)
      {
        *(_QWORD *)(a1 + 264) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
LABEL_20:
        v14 = __log_SCPreferences_log;
        if (!__log_SCPreferences_log)
        {
          v14 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
          __log_SCPreferences_log = (uint64_t)v14;
        }
        v15 = _SC_syslog_os_log_mapping(7);
        if (__SC_log_enabled(7, v14, (os_log_type_t)v15))
        {
          v16 = _os_log_pack_size();
          v24 = (char *)v39
              - ((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(7, (uint64_t)v14, v15, v24);
        }
        *(_BYTE *)(a1 + 200) = 1;
        if (a4)
        {
          if (!SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 152), a4))
          {
            *(_BYTE *)(a1 + 200) = 0;
            SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(a1 + 152), 0, 0);
            __SCPreferencesRemoveSession(a1);
            goto LABEL_3;
          }
          *(_QWORD *)(a1 + 272) = a4;
          dispatch_retain(a4);
LABEL_12:
          v9 = 1;
          goto LABEL_4;
        }
LABEL_9:
        if (!_SC_isScheduled(0, a2, a3, *(CFArrayRef *)(a1 + 264)))
          CFRunLoopAddSource(a2, *(CFRunLoopSourceRef *)(a1 + 208), a3);
        _SC_schedule((void *)a1, a2, a3, *(CFMutableArrayRef *)(a1 + 264));
        goto LABEL_12;
      }
      v25 = __log_SCPreferences_log;
      if (!__log_SCPreferences_log)
      {
        v25 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
        __log_SCPreferences_log = (uint64_t)v25;
      }
      v26 = _SC_syslog_os_log_mapping(3);
      if (!__SC_log_enabled(3, v25, (os_log_type_t)v26))
        goto LABEL_3;
    }
    else
    {
      v25 = __log_SCPreferences_log;
      if (!__log_SCPreferences_log)
      {
        v25 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
        __log_SCPreferences_log = (uint64_t)v25;
      }
      v26 = _SC_syslog_os_log_mapping(3);
      if (!__SC_log_enabled(3, v25, (os_log_type_t)v26))
        goto LABEL_3;
    }
    v27 = _os_log_pack_size();
    v35 = (char *)v39 - ((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v36 = _os_log_pack_fill();
    v37 = SCError();
    v38 = SCErrorString(v37);
    *(_DWORD *)v36 = 136315138;
    *(_QWORD *)(v36 + 4) = v38;
    __SC_log_send(3, (uint64_t)v25, v26, v35);
    goto LABEL_3;
  }
  if (!*(_BYTE *)(a1 + 200))
    goto LABEL_13;
LABEL_2:
  _SCErrorSet(1002);
LABEL_3:
  v9 = 0;
LABEL_4:
  pthread_mutex_unlock(v8);
  return v9;
}

BOOL __SCPreferencesAddSession(uint64_t a1)
{
  const __CFAllocator *v2;
  _BOOL8 result;
  SCDynamicStoreRef v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  int v27;
  const char *v28;
  SCDynamicStoreContext context;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator((CFTypeRef)a1);
  context.version = 0;
  context.info = (void *)a1;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  context.copyDescription = (CFStringRef (__cdecl *)(const void *))MEMORY[0x1E0C98350];
  if (*(_DWORD *)(a1 + 168))
  {
LABEL_2:
    ++*(_DWORD *)(a1 + 168);
    return 1;
  }
  v4 = SCDynamicStoreCreate(v2, *(CFStringRef *)(a1 + 80), (SCDynamicStoreCallBack)prefsNotify, &context);
  *(_QWORD *)(a1 + 152) = v4;
  v5 = __log_SCPreferences_log;
  if (v4)
  {
    if (!__log_SCPreferences_log)
    {
      v5 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
      __log_SCPreferences_log = (uint64_t)v5;
    }
    v6 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v5, (os_log_type_t)v6))
    {
      v7 = _os_log_pack_size();
      v15 = (char *)&context - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(7, (uint64_t)v5, v6, v15);
    }
    goto LABEL_2;
  }
  if (!__log_SCPreferences_log)
  {
    v5 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
    __log_SCPreferences_log = (uint64_t)v5;
  }
  v16 = _SC_syslog_os_log_mapping(3);
  result = __SC_log_enabled(3, v5, (os_log_type_t)v16);
  if (result)
  {
    v17 = _os_log_pack_size();
    v25 = (char *)&context - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v26 = _os_log_pack_fill();
    v27 = SCError();
    v28 = SCErrorString(v27);
    *(_DWORD *)v26 = 136315138;
    *(_QWORD *)(v26 + 4) = v28;
    __SC_log_send(3, (uint64_t)v5, v16, v25);
    return 0;
  }
  return result;
}

SCDynamicStoreRef SCDynamicStoreCreateWithOptions(CFAllocatorRef allocator, CFStringRef name, CFDictionaryRef storeOptions, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  _QWORD *Internal;
  uint64_t ApplicationBundleID;

  Internal = (_QWORD *)__SCDynamicStoreCreateInternal((uint64_t)allocator, 0, (uint64_t)callout, (__int128 *)&context->version, 1);
  if (Internal)
  {
    ApplicationBundleID = _SC_getApplicationBundleID();
    Internal[3] = CFStringCreateWithFormat(0, 0, CFSTR("%@:%@"), ApplicationBundleID, name);
    if (storeOptions)
      Internal[4] = CFRetain(storeOptions);
    if (!__SCDynamicStoreAddSession((uint64_t)Internal))
    {
      CFRelease(Internal);
      return 0;
    }
  }
  return (SCDynamicStoreRef)Internal;
}

uint64_t __SCDynamicStoreCreatePrivate(uint64_t a1, const void *a2, uint64_t a3, __int128 *a4)
{
  return __SCDynamicStoreCreateInternal(a1, a2, a3, a4, 0);
}

uint64_t _SC_getApplicationBundleID()
{
  if (_SC_getApplicationBundleID_once != -1)
    dispatch_once(&_SC_getApplicationBundleID_once, &__block_literal_global_9);
  return _SC_getApplicationBundleID_bundleID;
}

uint64_t __SCDynamicStoreAddSession(uint64_t a1)
{
  const void *v2;
  mach_port_t v3;
  int v4;
  int v5;
  NSObject *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  NSObject *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  int v33;
  const char *v34;
  mach_port_t v35;
  int v36;
  vm_size_t v37;
  uint64_t v38;
  CFDataRef v39;
  vm_size_t v40;
  uint64_t v41;
  CFDataRef v42[2];

  v42[1] = *(CFDataRef *)MEMORY[0x1E0C80C00];
  v41 = 0;
  v42[0] = 0;
  v39 = 0;
  v40 = 0;
  v37 = 0;
  v38 = 0;
  v35 = 0;
  v36 = 1001;
  if (!_SCSerializeString(*(const __CFString **)(a1 + 24), v42, (vm_address_t *)&v41, &v40))
    goto LABEL_18;
  v2 = *(const void **)(a1 + 32);
  if (v2 && !_SCSerialize(v2, &v39, (vm_address_t *)&v38, &v37))
  {
    CFRelease(v42[0]);
LABEL_18:
    v5 = 0;
    goto LABEL_19;
  }
  v35 = 0;
  updateServerPort(a1, (uint64_t)&v35, (uint64_t)&v36);
  v3 = v35;
  if (v35)
  {
    while (1)
    {
      v4 = configopen(v3, v41, v40, v38, v37, (_DWORD *)(a1 + 40), &v36);
      v5 = v4;
      if (v4 != -308 && v4 != 268435459)
        break;
      updateServerPort(a1, (uint64_t)&v35, (uint64_t)&v36);
      v3 = v35;
      if (!v35)
        goto LABEL_15;
    }
    if (v4)
      v36 = v4;
  }
  else
  {
    v5 = 0;
  }
LABEL_15:
  CFRelease(v42[0]);
  if (v39)
    CFRelease(v39);
LABEL_19:
  if (!v36)
    return 1;
  if (v36 == 1102)
  {
    v7 = __log_SCDynamicStore_log;
    if (!__log_SCDynamicStore_log)
    {
      v7 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
      __log_SCDynamicStore_log = (uint64_t)v7;
    }
    if (v5)
      v8 = 3;
    else
      v8 = 6;
    v9 = _SC_syslog_os_log_mapping(v8);
    if (__SC_log_enabled(v8, v7, (os_log_type_t)v9))
    {
      v10 = _os_log_pack_size();
      v18 = (char *)&v35 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(v8, (uint64_t)v7, v9, v18);
    }
    v36 = 2002;
  }
  else
  {
    v20 = __log_SCDynamicStore_log;
    if (!__log_SCDynamicStore_log)
    {
      v20 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
      __log_SCDynamicStore_log = (uint64_t)v20;
    }
    if (v5)
      v21 = 3;
    else
      v21 = 6;
    v22 = _SC_syslog_os_log_mapping(v21);
    if (__SC_log_enabled(v21, v20, (os_log_type_t)v22))
    {
      v23 = _os_log_pack_size();
      v31 = (char *)&v35 - ((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v32 = _os_log_pack_fill();
      v33 = v36;
      v34 = SCErrorString(v36);
      *(_DWORD *)v32 = 67109378;
      *(_DWORD *)(v32 + 4) = v33;
      *(_WORD *)(v32 + 8) = 2080;
      *(_QWORD *)(v32 + 10) = v34;
      __SC_log_send(v21, (uint64_t)v20, v22, v31);
    }
  }
  _SCErrorSet(v36);
  return 0;
}

BOOL _SCSerializeString(const __CFString *a1, CFDataRef *a2, vm_address_t *a3, vm_size_t *a4)
{
  CFTypeID TypeID;
  CFDataRef ExternalRepresentation;
  const __CFData *v10;
  _BOOL8 result;
  const __CFData *v12;
  const __CFData *v13;
  mach_error_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  _QWORD v39[2];

  v39[1] = *MEMORY[0x1E0C80C00];
  TypeID = CFStringGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
    return 0;
  if (a2)
  {
    ExternalRepresentation = CFStringCreateExternalRepresentation(0, a1, 0x8000100u, 0);
    if (ExternalRepresentation)
    {
      v10 = ExternalRepresentation;
      *a2 = ExternalRepresentation;
      result = 1;
      if (a3 && a4)
      {
        *a3 = (vm_address_t)CFDataGetBytePtr(v10);
        *a4 = CFDataGetLength(v10);
        return 1;
      }
      return result;
    }
LABEL_17:
    v28 = _SC_LOG_DEFAULT();
    v29 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v28, (os_log_type_t)v29))
    {
      v30 = _os_log_pack_size();
      v38 = (char *)v39 - ((MEMORY[0x1E0C80A78](v30, v31, v32, v33, v34, v35, v36, v37) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v28, v29, v38);
    }
    if (a2)
      *a2 = 0;
    result = 0;
    if (a3 && a4)
    {
      result = 0;
      *a3 = 0;
      *a4 = 0;
    }
    return result;
  }
  result = 0;
  if (!a3 || !a4)
    return result;
  v12 = CFStringCreateExternalRepresentation(0, a1, 0x8000100u, 0);
  if (!v12)
    goto LABEL_17;
  v13 = v12;
  v14 = __CFDataCopyVMData(v12, a3, a4);
  CFRelease(v13);
  if (!v14)
    return 1;
  v15 = _SC_LOG_DEFAULT();
  v16 = _SC_syslog_os_log_mapping(5);
  result = __SC_log_enabled(5, v15, (os_log_type_t)v16);
  if (result)
  {
    v17 = _os_log_pack_size();
    v25 = (char *)v39 - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v26 = _os_log_pack_fill();
    v27 = mach_error_string(v14);
    *(_DWORD *)v26 = 136315138;
    *(_QWORD *)(v26 + 4) = v27;
    __SC_log_send(5, (uint64_t)v15, v16, v25);
    return 0;
  }
  return result;
}

void updateServerPort(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD block[8];
  _QWORD v7[3];
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  v8 = 0;
  if (storeQueue_once != -1)
    dispatch_once(&storeQueue_once, &__block_literal_global_3);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __updateServerPort_block_invoke;
  block[3] = &unk_1E25D0670;
  block[4] = v7;
  block[5] = a2;
  block[6] = a1;
  block[7] = a3;
  dispatch_sync((dispatch_queue_t)storeQueue_q, block);
  _Block_object_dispose(v7, 8);
}

uint64_t configopen(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, _DWORD *a6, _DWORD *a7)
{
  mach_port_t special_reply_port;
  uint64_t v11;
  uint64_t v12;
  int v13;
  mach_msg_header_t msg;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v16 = 2;
  v17 = a2;
  v18 = 16777472;
  v19 = a3;
  v20 = a4;
  v21 = 16777472;
  v22 = a5;
  v23 = *MEMORY[0x1E0C804E8];
  v24 = a3;
  v25 = a5;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4E2000000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v11 = mach_msg(&msg, 3162115, 0x4Cu, 0x3Cu, special_reply_port, 0, 0);
  v12 = v11;
  if ((v11 - 268435458) > 0xE || ((1 << (v11 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v11)
    {
      if (msg.msgh_id == 71)
      {
        v12 = 4294966988;
      }
      else if (msg.msgh_id == 20100)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            v12 = 4294966996;
            if (HIDWORD(v17))
            {
              if (msg.msgh_remote_port)
                v12 = 4294966996;
              else
                v12 = HIDWORD(v17);
            }
          }
          else
          {
            v12 = 4294966996;
          }
          goto LABEL_23;
        }
        v12 = 4294966996;
        if (v16 == 1 && msg.msgh_size == 52 && !msg.msgh_remote_port && HIWORD(v18) << 16 == 1114112)
        {
          v12 = 0;
          v13 = HIDWORD(v20);
          *a6 = v17;
          *a7 = v13;
          return v12;
        }
      }
      else
      {
        v12 = 4294966995;
      }
LABEL_23:
      mach_msg_destroy(&msg);
      return v12;
    }
    mig_dealloc_special_reply_port();
  }
  return v12;
}

SCDynamicStoreRef SCDynamicStoreCreate(CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return SCDynamicStoreCreateWithOptions(allocator, name, 0, callout, context);
}

void rlsSchedule(mach_port_context_t context, __CFRunLoop *a2, const __CFString *a3, __n128 a4)
{
  mach_port_t v7;
  __CFMachPort *v8;
  CFMachPortContext v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(context + 120))
  {
    v9.version = 0;
    v9.info = (void *)context;
    v9.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
    v9.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
    v9.copyDescription = (CFStringRef (__cdecl *)(const void *))notifyMPCopyDescription;
    v7 = __SCDynamicStoreAddNotificationPort(context, a4);
    if (!v7)
      return;
    v8 = _SC_CFMachPortCreateWithPort((uint64_t)"SCDynamicStore", v7, (void (__cdecl *)(CFMachPortRef, void *, CFIndex, void *))rlsCallback, &v9);
    *(_QWORD *)(context + 120) = v8;
    if (a2)
    {
      *(_QWORD *)(context + 128) = CFMachPortCreateRunLoopSource(0, v8, 0);
      *(_QWORD *)(context + 56) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    }
  }
  if (*(_QWORD *)(context + 128))
  {
    *(_DWORD *)(context + 48) = 4;
    if (!_SC_isScheduled((const void *)context, a2, a3, *(CFArrayRef *)(context + 56)))
      CFRunLoopAddSource(a2, *(CFRunLoopSourceRef *)(context + 128), a3);
    _SC_schedule((void *)context, a2, a3, *(CFMutableArrayRef *)(context + 56));
  }
}

Boolean SCNetworkReachabilityScheduleWithRunLoop(SCNetworkReachabilityRef target, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v6;
  CFTypeID v7;
  const __CFArray *v8;
  int v9;
  const __CFArray *Mutable;
  CFRunLoopSourceContext context;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  context.version = 0;
  context.info = target;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  context.copyDescription = (CFStringRef (__cdecl *)(const void *))reachRLSCopyDescription;
  context.equal = (Boolean (__cdecl *)(const void *, const void *))MEMORY[0x1E0C98620];
  context.hash = (CFHashCode (__cdecl *)(const void *))MEMORY[0x1E0C98758];
  context.schedule = 0;
  context.cancel = 0;
  context.perform = (void (__cdecl *)(void *))reachPerform;
  if (__SCNetworkReachabilityInitialize_initialized == -1)
  {
    if (!target)
      goto LABEL_15;
  }
  else
  {
    dispatch_once(&__SCNetworkReachabilityInitialize_initialized, &__block_literal_global_10);
    if (!target)
      goto LABEL_15;
  }
  v6 = __kSCNetworkReachabilityTypeID;
  v7 = CFGetTypeID(target);
  if (!runLoopMode || !runLoop || v7 != v6)
    goto LABEL_15;
  if (pthread_mutex_lock((pthread_mutex_t *)((char *)target + 16)))
    SCNetworkReachabilityScheduleWithRunLoop_cold_4();
  if (*((_BYTE *)target + 112))
  {
    if (*((_QWORD *)target + 15))
    {
      v8 = (const __CFArray *)*((_QWORD *)target + 22);
      if (v8)
      {
        if (!_SC_isScheduled(0, runLoop, runLoopMode, v8))
          CFRunLoopAddSource(runLoop, *((CFRunLoopSourceRef *)target + 15), runLoopMode);
        _SC_schedule(target, runLoop, runLoopMode, *((CFMutableArrayRef *)target + 22));
        if (pthread_mutex_unlock((pthread_mutex_t *)((char *)target + 16)))
          SCNetworkReachabilityScheduleWithRunLoop_cold_3();
        LOBYTE(v9) = 1;
        return v9;
      }
    }
    if (pthread_mutex_unlock((pthread_mutex_t *)((char *)target + 16)))
      SCNetworkReachabilityScheduleWithRunLoop_cold_2();
LABEL_15:
    _SCErrorSet(1002);
    LOBYTE(v9) = 0;
    return v9;
  }
  *((_QWORD *)target + 15) = CFRunLoopSourceCreate(0, 0, &context);
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *((_QWORD *)target + 22) = Mutable;
  if (!_SC_isScheduled(0, runLoop, runLoopMode, Mutable))
    CFRunLoopAddSource(runLoop, *((CFRunLoopSourceRef *)target + 15), runLoopMode);
  _SC_schedule(target, runLoop, runLoopMode, *((CFMutableArrayRef *)target + 22));
  if (_callback_queue_once != -1)
    dispatch_once(&_callback_queue_once, &__block_literal_global_100);
  v9 = __SCNetworkReachabilitySetDispatchQueue((uint64_t)target, _callback_queue_q);
  if (!v9 && _SC_unschedule(target, runLoop, runLoopMode, *((CFArrayRef *)target + 22), 0))
  {
    if (CFArrayGetCount(*((CFArrayRef *)target + 22)))
    {
      if (!_SC_isScheduled(0, runLoop, runLoopMode, *((CFArrayRef *)target + 22)))
        CFRunLoopRemoveSource(runLoop, *((CFRunLoopSourceRef *)target + 15), runLoopMode);
    }
    else
    {
      CFRunLoopRemoveSource(runLoop, *((CFRunLoopSourceRef *)target + 15), runLoopMode);
      CFRelease(*((CFTypeRef *)target + 22));
      *((_QWORD *)target + 22) = 0;
      CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)target + 15));
      CFRelease(*((CFTypeRef *)target + 15));
      *((_QWORD *)target + 15) = 0;
    }
  }
  if (pthread_mutex_unlock((pthread_mutex_t *)((char *)target + 16)))
    SCNetworkReachabilityScheduleWithRunLoop_cold_1();
  return v9;
}

void _SC_schedule(void *value, const void *a2, const void *a3, CFMutableArrayRef theArray)
{
  CFArrayAppendValue(theArray, value);
  CFArrayAppendValue(theArray, a2);
  CFArrayAppendValue(theArray, a3);
}

uint64_t _SC_isScheduled(const void *a1, const void *a2, const void *a3, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const void *v11;
  const void *v12;
  const void *ValueAtIndex;

  Count = CFArrayGetCount(theArray);
  if (Count < 1)
    return 0;
  v9 = Count;
  v10 = 0;
  while (1)
  {
    if (!a1 || (v11 = CFArrayGetValueAtIndex(theArray, v10), CFEqual(a1, v11)))
    {
      if (!a2 || (v12 = CFArrayGetValueAtIndex(theArray, v10 + 1), CFEqual(a2, v12)))
      {
        if (!a3)
          break;
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v10 + 2);
        if (CFEqual(a3, ValueAtIndex))
          break;
      }
    }
    v10 += 3;
    if (v10 >= v9)
      return 0;
  }
  return 1;
}

Boolean SCDynamicStoreSetDispatchQueue(SCDynamicStoreRef store, dispatch_queue_t queue)
{
  CFTypeID TypeID;
  __n128 v5;
  int v6;
  mach_port_name_t v7;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  dispatch_source_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  _QWORD v26[8];
  mach_port_name_t v27;
  _QWORD handler[7];
  mach_port_name_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  TypeID = SCDynamicStoreGetTypeID();
  if (!store || CFGetTypeID(store) != TypeID)
  {
    v6 = 2001;
    goto LABEL_10;
  }
  if (queue)
  {
    if (!*((_DWORD *)store + 10))
    {
      v6 = 2002;
      goto LABEL_10;
    }
    if (*((_QWORD *)store + 17) || *((_QWORD *)store + 8) || *((_DWORD *)store + 12))
    {
      v6 = 2003;
LABEL_10:
      _SCErrorSet(v6);
      LOBYTE(v7) = 0;
      return v7;
    }
    *((_DWORD *)store + 12) = 5;
    v7 = __SCDynamicStoreAddNotificationPort((mach_port_context_t)store, v5);
    if (v7)
    {
      *((_QWORD *)store + 17) = queue;
      dispatch_retain(queue);
      v11 = dispatch_queue_create("SCDynamicStore notifications", 0);
      v12 = dispatch_source_create(MEMORY[0x1E0C80D98], v7, 0, v11);
      if (v12)
      {
        v13 = v12;
        CFRetain(store);
        dispatch_set_context(v13, store);
        dispatch_set_finalizer_f(v13, (dispatch_function_t)dispatch_CFRelease);
        dispatch_retain(queue);
        v14 = MEMORY[0x1E0C809B0];
        handler[0] = MEMORY[0x1E0C809B0];
        handler[1] = 0x40000000;
        handler[2] = __SCDynamicStoreSetDispatchQueue_block_invoke;
        handler[3] = &__block_descriptor_tmp_12;
        v29 = v7;
        handler[4] = store;
        handler[5] = queue;
        handler[6] = store;
        dispatch_source_set_event_handler(v13, handler);
        v26[0] = v14;
        v26[1] = 0x40000000;
        v26[2] = __SCDynamicStoreSetDispatchQueue_block_invoke_3;
        v26[3] = &__block_descriptor_tmp_13;
        v27 = v7;
        v26[4] = store;
        v26[5] = v11;
        v26[6] = v13;
        v26[7] = queue;
        dispatch_source_set_cancel_handler(v13, v26);
        *((_QWORD *)store + 18) = v13;
        dispatch_resume(v13);
        LOBYTE(v7) = 1;
        return v7;
      }
      v15 = __log_SCDynamicStore();
      v16 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v15, (os_log_type_t)v16))
      {
        v17 = _os_log_pack_size();
        v25 = (char *)v26 - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v15, v16, v25);
      }
      mach_port_destruct(*MEMORY[0x1E0C83DA0], v7, 0, (mach_port_context_t)store);
      dispatch_release(v11);
      _SCErrorSet(1001);
      LOBYTE(v7) = 0;
    }
  }
  else
  {
    if (!*((_QWORD *)store + 17))
    {
      v6 = 1002;
      goto LABEL_10;
    }
    LOBYTE(v7) = 1;
  }
  CFRetain(store);
  v9 = *((_QWORD *)store + 18);
  if (v9)
  {
    dispatch_source_cancel(v9);
    *((_QWORD *)store + 18) = 0;
  }
  v10 = *((_QWORD *)store + 17);
  if (v10)
  {
    dispatch_release(v10);
    *((_QWORD *)store + 17) = 0;
  }
  *((_DWORD *)store + 12) = 0;
  CFRelease(store);
  return v7;
}

CFTypeID SCDynamicStoreGetTypeID(void)
{
  if (__SCDynamicStoreInitialize_initialized != -1)
    dispatch_once(&__SCDynamicStoreInitialize_initialized, &__block_literal_global_51);
  return __kSCDynamicStoreTypeID;
}

uint64_t __SCDynamicStoreMapInternalStatus(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  void (*v4)(uint64_t);
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  switch((_DWORD)result)
  {
    case 0x2712:
      if (!a2)
        return 1003;
      v2 = MEMORY[0x1E0C809B0];
      v3 = 0x40000000;
      v4 = ___SC_crash_once_block_invoke;
      v5 = &__block_descriptor_tmp_92;
      v7 = 0;
      v8 = 0;
      v6 = "SCDynamicStore write denied : missing entitlement";
      if (_SC_crash_once_once == -1)
        return 1003;
LABEL_15:
      dispatch_once(&_SC_crash_once_once, &v2);
      return 1003;
    case 0x2774:
      if (a2)
      {
        v2 = MEMORY[0x1E0C809B0];
        v3 = 0x40000000;
        v4 = ___SC_crash_once_block_invoke;
        v5 = &__block_descriptor_tmp_92;
        v7 = 0;
        v8 = 0;
        v6 = "SCDynamicStore read allowed: missing entitlement";
        if (_SC_crash_once_once != -1)
          dispatch_once(&_SC_crash_once_once, &v2);
      }
      return 0;
    case 0x2713:
      if (!a2)
        return 1003;
      v2 = MEMORY[0x1E0C809B0];
      v3 = 0x40000000;
      v4 = ___SC_crash_once_block_invoke;
      v5 = &__block_descriptor_tmp_92;
      v7 = 0;
      v8 = 0;
      v6 = "SCDynamicStore read denied: missing entitlement";
      if (_SC_crash_once_once == -1)
        return 1003;
      goto LABEL_15;
  }
  return result;
}

uint64_t configget(int a1, uint64_t a2, int a3, _QWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  mach_port_name_t special_reply_port;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v18;
  _BYTE rcv_name[24];
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  __int128 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&rcv_name[16] = 0x100000000;
  v23 = 0;
  v24 = 0u;
  *(_OWORD *)rcv_name = 0u;
  v20 = a2;
  v21 = 16777472;
  v22 = a3;
  v23 = *MEMORY[0x1E0C804E8];
  v25 = 0;
  LODWORD(v24) = a3;
  special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&rcv_name[4] = a1;
  *(_DWORD *)&rcv_name[8] = special_reply_port;
  v18 = -2147478253;
  *(_QWORD *)&rcv_name[12] = 0x4E2A00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&v18);
    special_reply_port = *(_DWORD *)&rcv_name[8];
  }
  v13 = mach_msg((mach_msg_header_t *)&v18, 3162115, 0x38u, 0x48u, special_reply_port, 0, 0);
  v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v13)
    {
      if (*(_DWORD *)&rcv_name[16] == 71)
      {
        v14 = 4294966988;
      }
      else if (*(_DWORD *)&rcv_name[16] == 20110)
      {
        if ((v18 & 0x80000000) == 0)
        {
          if (*(_DWORD *)rcv_name == 36)
          {
            v14 = 4294966996;
            if (HIDWORD(v20))
            {
              if (*(_DWORD *)&rcv_name[4])
                v14 = 4294966996;
              else
                v14 = HIDWORD(v20);
            }
          }
          else
          {
            v14 = 4294966996;
          }
          goto LABEL_24;
        }
        v14 = 4294966996;
        if (*(_DWORD *)&rcv_name[20] == 1 && *(_DWORD *)rcv_name == 64 && !*(_DWORD *)&rcv_name[4] && HIBYTE(v21) == 1)
        {
          v15 = v22;
          if (v22 == (_DWORD)v24)
          {
            v14 = 0;
            *a4 = v20;
            *a5 = v15;
            v16 = DWORD2(v24);
            *a6 = DWORD1(v24);
            *a7 = v16;
            return v14;
          }
        }
      }
      else
      {
        v14 = 4294966995;
      }
LABEL_24:
      mach_msg_destroy((mach_msg_header_t *)&v18);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  return v14;
}

CFMachPortRef _SC_CFMachPortCreateWithPort(uint64_t a1, mach_port_t a2, void (__cdecl *a3)(CFMachPortRef, void *, CFIndex, void *), CFMachPortContext *a4)
{
  CFMachPortRef v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  const __CFString *v19;
  const __CFString *v20;
  UInt8 *v21;
  const char *v22;
  CFStringRef v23;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  HIBYTE(v25) = 0;
  v6 = CFMachPortCreateWithPort(0, a2, a3, a4, (Boolean *)&v25 + 7);
  if (!v6 || HIBYTE(v25))
  {
    v7 = _SC_LOG_DEFAULT();
    v8 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v7, (os_log_type_t)v8))
    {
      v9 = _os_log_pack_size();
      v17 = (char *)&v25 - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v18 = _os_log_pack_fill();
      *(_DWORD *)v18 = 136315394;
      *(_QWORD *)(v18 + 4) = a1;
      *(_WORD *)(v18 + 12) = 2048;
      *(_QWORD *)(v18 + 14) = a2;
      __SC_log_send(5, (uint64_t)v7, v8, v17);
    }
    if (v6)
      v19 = CFStringCreateWithFormat(0, 0, CFSTR("%s: CFMachPortCreateWithPort recycled, [old] port = %@"), a1, v6);
    else
      v19 = CFStringCreateWithFormat(0, 0, CFSTR("%s: CFMachPortCreateWithPort returned NULL"), a1);
    v20 = v19;
    v21 = _SC_cfstring_to_cstring_ext(v19, 0, 0, 0x600u, 0, 0);
    CFRelease(v20);
    v22 = getprogname();
    v23 = CFStringCreateWithFormat(0, 0, CFSTR("A recycled mach_port has been detected by \"%s\"."), v22);
    _SC_crash((const char *)v21, CFSTR("CFMachPort error"), (uint64_t)v23);
    CFAllocatorDeallocate(0, v21);
    CFRelease(v23);
  }
  return v6;
}

Boolean SCPreferencesSetDispatchQueue(SCPreferencesRef prefs, dispatch_queue_t queue)
{
  uint64_t v4;

  if (__SCPreferencesInitialize_initialized == -1)
  {
    if (!prefs)
    {
LABEL_8:
      _SCErrorSet(3001);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCPreferencesInitialize_initialized, &__block_literal_global_48);
    if (!prefs)
      goto LABEL_8;
  }
  v4 = __kSCPreferencesTypeID;
  if (CFGetTypeID(prefs) != v4)
    goto LABEL_8;
  if (queue)
    return __SCPreferencesScheduleWithRunLoop((uint64_t)prefs, 0, 0, queue);
  else
    return __SCPreferencesUnscheduleFromRunLoop((uint64_t)prefs, 0, 0);
}

CFComparisonResult _SCNetworkInterfaceCompare(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  const void *v6;
  CFTypeID TypeID;
  const void *v8;
  CFTypeID v9;
  CFComparisonResult v10;
  const __CFString *v11;
  CFIndex Count;
  const __CFArray *v13;
  CFIndex v14;
  uint64_t v15;
  CFIndex v16;
  const __CFString *ValueAtIndex;
  const __CFString *v18;
  UInt8 *v19;
  uint64_t v20;
  CFComparisonResult v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  const __CFString *v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *v29;
  uint64_t v31;
  CFIndex v32;
  CFIndex v33;
  const __CFArray *theArray;
  char *__endptr[2];

  __endptr[1] = *(char **)MEMORY[0x1E0C80C00];
  v2 = *(_DWORD *)(a1 + 312);
  v3 = *(_DWORD *)(a2 + 312);
  if (v2 != v3)
  {
    if (v2 < v3)
      return -1;
    else
      return 1;
  }
  if (*(unsigned __int8 *)(a1 + 176) != *(unsigned __int8 *)(a2 + 176))
  {
    if (*(_BYTE *)(a1 + 176))
      return -1;
    else
      return 1;
  }
  if (!*(_BYTE *)(a1 + 176))
    goto LABEL_10;
  v6 = *(const void **)(a1 + 200);
  if (v6 == *(const void **)(a2 + 200))
    goto LABEL_10;
  TypeID = CFStringGetTypeID();
  if (!v6 || CFGetTypeID(v6) != TypeID)
    return 1;
  v8 = *(const void **)(a2 + 200);
  v9 = CFStringGetTypeID();
  if (!v8 || CFGetTypeID(v8) != v9)
    return -1;
  v10 = CFStringCompare(*(CFStringRef *)(a1 + 200), *(CFStringRef *)(a2 + 200), 0);
  if (v10 == kCFCompareEqualTo)
  {
LABEL_10:
    v11 = *(const __CFString **)(a1 + 208);
    if (!v11 || !*(_QWORD *)(a2 + 208))
      goto LABEL_44;
    theArray = split_path(v11);
    Count = CFArrayGetCount(theArray);
    v13 = split_path(*(CFStringRef *)(a2 + 208));
    v14 = CFArrayGetCount(v13);
    v32 = v14;
    v33 = Count;
    if (Count >= v14)
      v15 = v14;
    else
      v15 = Count;
    if (v15 < 1)
    {
LABEL_38:
      if (v33 >= v32)
        v10 = kCFCompareEqualTo;
      else
        v10 = kCFCompareLessThan;
      goto LABEL_43;
    }
    v16 = 0;
    while (1)
    {
      __endptr[0] = 0;
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v16);
      v18 = (const __CFString *)CFArrayGetValueAtIndex(v13, v16);
      v19 = _SC_cfstring_to_cstring(ValueAtIndex, 0, 0, 0x8000100u);
      *__error() = 0;
      v20 = strtoq((const char *)v19, __endptr, 16);
      if (!*v19 || *__endptr[0])
        break;
      v22 = v20;
      v23 = *__error();
      CFAllocatorDeallocate(0, v19);
      if (v23)
        goto LABEL_20;
      v19 = _SC_cfstring_to_cstring(v18, 0, 0, 0x8000100u);
      *__error() = 0;
      v24 = strtoq((const char *)v19, __endptr, 16);
      if (!*v19 || *__endptr[0])
        break;
      v31 = v24;
      v25 = *__error();
      CFAllocatorDeallocate(0, v19);
      if (v25)
        goto LABEL_20;
      if (v22 != v31)
      {
        if (v22 < v31)
          v10 = kCFCompareLessThan;
        else
          v10 = kCFCompareGreaterThan;
LABEL_43:
        CFRelease(theArray);
        CFRelease(v13);
        if (v10 == kCFCompareEqualTo)
        {
LABEL_44:
          v26 = *(const __CFString **)(a1 + 112);
          if (!v26
            || (v27 = *(const __CFString **)(a2 + 112)) == 0
            || (v10 = CFStringCompare(v26, v27, 0)) == kCFCompareEqualTo)
          {
            v28 = *(const __CFString **)(a1 + 120);
            if (v28 && (v29 = *(const __CFString **)(a2 + 120)) != 0)
              return CFStringCompare(v28, v29, 0);
            else
              return 0;
          }
        }
        return v10;
      }
LABEL_21:
      if (v15 == ++v16)
        goto LABEL_38;
    }
    CFAllocatorDeallocate(0, v19);
LABEL_20:
    v21 = CFStringCompare(ValueAtIndex, v18, 0);
    if (v21)
    {
      v10 = v21;
      goto LABEL_43;
    }
    goto LABEL_21;
  }
  return v10;
}

__CFArray *findMatchingInterfaces(const void *a1, unsigned int (*a2)(uint64_t, uint64_t, __CFDictionary *, _QWORD, __CFDictionary *, _QWORD, __CFDictionary *), const __CFString *a3, int a4, int a5)
{
  kern_return_t MatchingServices;
  kern_return_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  _DWORD *v23;
  __CFArray *Mutable;
  uint64_t v25;
  uint64_t v26;
  _DWORD *Interface;
  const void *v28;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  HIDWORD(v30) = 0;
  CFRetain(a1);
  MatchingServices = IOServiceGetMatchingServices(masterPort, (CFDictionaryRef)a1, (io_iterator_t *)&v30 + 1);
  if (MatchingServices)
  {
    v11 = MatchingServices;
    v12 = __log_SCNetworkConfiguration();
    v13 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v12, (os_log_type_t)v13))
    {
      v14 = _os_log_pack_size();
      v22 = (char *)&v30 - ((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v23 = (_DWORD *)_os_log_pack_fill();
      *v23 = 67109120;
      v23[1] = v11;
      __SC_log_send(6, (uint64_t)v12, v13, v22);
    }
    return 0;
  }
  else
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    v25 = IOIteratorNext(HIDWORD(v30));
    if ((_DWORD)v25)
    {
      v26 = v25;
      do
      {
        Interface = (_DWORD *)createInterface(v26, a2, a3, a4);
        if (Interface)
        {
          v28 = Interface;
          if (a5 || !_SCNetworkInterfaceIsApplePreconfigured(Interface))
            CFArrayAppendValue(Mutable, v28);
          CFRelease(v28);
        }
        IOObjectRelease(v26);
        v26 = IOIteratorNext(HIDWORD(v30));
      }
      while ((_DWORD)v26);
    }
    IOObjectRelease(HIDWORD(v30));
  }
  return Mutable;
}

uint64_t createInterface(uint64_t entry, unsigned int (*a2)(uint64_t, uint64_t, __CFDictionary *, _QWORD, __CFDictionary *, _QWORD, __CFDictionary *), const __CFString *a3, int a4)
{
  const __CFBoolean *v7;
  const __CFBoolean *v8;
  unsigned int BooleanValue;
  __CFDictionary *v10;
  __CFDictionary *v11;
  uint64_t v12;
  __CFDictionary *v13;
  kern_return_t ParentEntry;
  kern_return_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  _DWORD *v27;
  __CFDictionary *v28;
  const __CFBoolean *Value;
  unsigned __int8 v30;
  kern_return_t v31;
  kern_return_t v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  _DWORD *v44;
  kern_return_t RegistryEntryID;
  kern_return_t v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  _DWORD *v59;
  uint64_t Private;
  CFStringRef v61;
  uint64_t v62;
  const __CFDictionary *v63;
  const __CFDictionary *v64;
  CFTypeID TypeID;
  CFTypeRef v66;
  const void *v67;
  CFTypeID v68;
  const __CFBoolean *v69;
  const __CFBoolean *v70;
  const __CFBoolean *v71;
  const __CFBoolean *v72;
  CFTypeID v73;
  uint64_t entryID;
  io_registry_entry_t parent[2];
  CFStringRef v76[2];

  v76[1] = *(CFStringRef *)MEMORY[0x1E0C80C00];
  entryID = 0;
  *(_QWORD *)parent = 0;
  v76[0] = CFSTR("name");
  if (a3 && (v7 = (const __CFBoolean *)IORegistryEntrySearchCFProperty(entry, "IOService", a3, 0, 3u)) != 0)
  {
    v8 = v7;
    BooleanValue = getBooleanValue(v7);
    CFRelease(v8);
    if (!a4 && BooleanValue)
    {
      v10 = 0;
      v11 = 0;
      v12 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    LOBYTE(BooleanValue) = 0;
  }
  v13 = copyIORegistryProperties(entry, (CFStringRef *)off_1E25D1D50, 12);
  ParentEntry = IORegistryEntryGetParentEntry(entry, "IOService", parent);
  if (ParentEntry)
  {
    v15 = ParentEntry;
    v16 = __log_SCNetworkConfiguration();
    v17 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v16, (os_log_type_t)v17))
    {
      v18 = _os_log_pack_size();
      v26 = (char *)&parent[-2]
          - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v27 = (_DWORD *)_os_log_pack_fill();
      *v27 = 67109120;
      v27[1] = v15;
      __SC_log_send(6, (uint64_t)v16, v17, v26);
    }
    v12 = 0;
    v11 = 0;
LABEL_18:
    v10 = 0;
    goto LABEL_19;
  }
  v28 = copyIORegistryProperties(parent[0], (CFStringRef *)off_1E25D1DB0, 3);
  v11 = v28;
  if (v28)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v28, CFSTR("SelfNamed"));
    v30 = getBooleanValue(Value);
  }
  else
  {
    v30 = 0;
  }
  v31 = IORegistryEntryGetParentEntry(parent[0], "IOService", &parent[1]);
  if (v31)
  {
    v32 = v31;
    v33 = __log_SCNetworkConfiguration();
    v34 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v33, (os_log_type_t)v34))
    {
      v35 = _os_log_pack_size();
      v43 = (char *)&parent[-2]
          - ((MEMORY[0x1E0C80A78](v35, v36, v37, v38, v39, v40, v41, v42) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v44 = (_DWORD *)_os_log_pack_fill();
      *v44 = 67109120;
      v44[1] = v32;
      __SC_log_send(6, (uint64_t)v33, v34, v43);
    }
    v12 = 0;
    goto LABEL_18;
  }
  v10 = copyIORegistryProperties(parent[1], v76, 1);
  RegistryEntryID = IORegistryEntryGetRegistryEntryID(entry, &entryID);
  if (RegistryEntryID)
  {
    v47 = RegistryEntryID;
    v48 = __log_SCNetworkConfiguration();
    v49 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v48, (os_log_type_t)v49))
    {
      v50 = _os_log_pack_size();
      v58 = (char *)&parent[-2]
          - ((MEMORY[0x1E0C80A78](v50, v51, v52, v53, v54, v55, v56, v57) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v59 = (_DWORD *)_os_log_pack_fill();
      *v59 = 67109120;
      v59[1] = v47;
      __SC_log_send(6, (uint64_t)v48, v49, v58);
    }
  }
  else
  {
    Private = __SCNetworkInterfaceCreatePrivate(0, 0, 0, 0);
    if (!Private)
      createInterface_cold_1();
    v12 = Private;
    *(_BYTE *)(Private + 193) = BooleanValue;
    v61 = __SC_IORegistryEntryCopyPath(entry);
    v62 = entryID;
    *(_QWORD *)(v12 + 208) = v61;
    *(_QWORD *)(v12 + 216) = v62;
    *(_BYTE *)(v12 + 242) = v30;
    v63 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("NetworkConfigurationOverrides"), 0, 3u);
    if (v63)
    {
      v64 = v63;
      TypeID = CFDictionaryGetTypeID();
      if (CFGetTypeID(v64) == TypeID)
        *(_QWORD *)(v12 + 224) = CFDictionaryCreateMutableCopy(0, 0, v64);
      CFRelease(v64);
    }
    if (a2(v12, entry, v13, parent[0], v11, parent[1], v10))
    {
      v66 = IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("New Interface Detected Action"), 0, 3u);
      if (v66)
      {
        v67 = v66;
        v68 = CFStringGetTypeID();
        if (CFGetTypeID(v67) == v68)
          *(_QWORD *)(v12 + 184) = CFRetain(v67);
        CFRelease(v67);
      }
      v69 = (const __CFBoolean *)IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("HiddenConfiguration"), 0, 3u);
      if (v69)
      {
        v70 = v69;
        *(_BYTE *)(v12 + 192) = getBooleanValue(v69);
        CFRelease(v70);
      }
      v71 = (const __CFBoolean *)IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("TrustRequired"), 0, 3u);
      if (v71)
      {
        v72 = v71;
        v73 = CFBooleanGetTypeID();
        if (CFGetTypeID(v72) == v73)
          *(_BYTE *)(v12 + 240) = CFBooleanGetValue(v72);
        CFRelease(v72);
      }
      goto LABEL_19;
    }
    CFRelease((CFTypeRef)v12);
  }
  v12 = 0;
LABEL_19:
  if (v13)
    CFRelease(v13);
LABEL_21:
  if (parent[0])
    IOObjectRelease(parent[0]);
  if (v11)
    CFRelease(v11);
  if (parent[1])
    IOObjectRelease(parent[1]);
  if (v10)
    CFRelease(v10);
  return v12;
}

__CFDictionary *copyIORegistryProperties(io_registry_entry_t a1, CFStringRef *a2, uint64_t a3)
{
  __CFDictionary *Mutable;
  CFTypeRef CFProperty;
  const void *v8;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (a3 >= 1)
  {
    do
    {
      CFProperty = IORegistryEntryCreateCFProperty(a1, *a2, 0, 0);
      if (CFProperty)
      {
        v8 = CFProperty;
        CFDictionaryAddValue(Mutable, *a2, CFProperty);
        CFRelease(v8);
      }
      ++a2;
      --a3;
    }
    while (a3);
  }
  return Mutable;
}

BOOL processNetworkInterface(uint64_t a1, io_registry_entry_t a2, CFDictionaryRef theDict, io_object_t a4, const __CFDictionary *a5, io_registry_entry_t a6, const __CFDictionary *a7)
{
  const void *Value;
  CFTypeID TypeID;
  const __CFString *v16;
  void *v17;
  NSObject *v18;
  uint64_t v19;
  _BOOL8 result;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  int v31;
  const __CFString *v32;
  CFTypeRef v33;
  const void *v34;
  CFTypeID v35;
  int v36;
  int v37;
  const __CFString *v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  _DWORD *v50;
  int v51;
  int v52;
  uint64_t v53;
  CFMutableStringRef v54;
  const __CFString *v55;
  CFMutableStringRef v56;
  const __CFString *v57;
  const __CFString *v58;
  CFStringRef v59;
  CFStringRef v60;
  const __CFBoolean *v61;
  CFTypeID v62;
  CFTypeID v63;
  int v64;
  const __CFBoolean *v65;
  const __CFBoolean *v66;
  const __CFString *v67;
  const __CFString *v68;
  const void *v69;
  CFTypeID v70;
  const void *v71;
  CFTypeID v72;
  const void *v73;
  CFTypeID v74;
  const void *v75;
  CFTypeID v76;
  const __CFString *v77;
  const __CFString *v78;
  const __CFString *v79;
  const __CFString *v80;
  CFTypeRef v81;
  CFTypeRef v82;
  io_registry_entry_t v83;
  int v84;
  uint64_t v85;
  CFMutableStringRef v86;
  const __CFString *v87;
  io_object_t v88;
  io_registry_entry_t v89;
  CFMutableStringRef v90;
  const __CFString *v91;
  CFMutableStringRef v92;
  io_registry_entry_t parent[2];
  int v94;
  int valuePtr;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  v94 = 0;
  valuePtr = -1;
  Value = CFDictionaryGetValue(theDict, CFSTR("IOInterfaceType"));
  TypeID = CFNumberGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID || !CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &valuePtr))
  {
    v18 = __log_SCNetworkConfiguration();
    v19 = _SC_syslog_os_log_mapping(6);
    result = __SC_log_enabled(6, v18, (os_log_type_t)v19);
    if (!result)
      return result;
    v21 = _os_log_pack_size();
    v29 = (char *)&parent[-2]
        - ((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v30 = _os_log_pack_fill();
    *(_DWORD *)v30 = 138412290;
    *(_QWORD *)(v30 + 4) = theDict;
    __SC_log_send(6, (uint64_t)v18, v19, v29);
    return 0;
  }
  *(_QWORD *)(a1 + 248) = CFRetain(Value);
  if (valuePtr == 6)
  {
    if (IOObjectConformsTo(a4, "IO80211Controller")
      || IOObjectConformsTo(a4, "AirPortPCI")
      || IOObjectConformsTo(a4, "AirPortDriver"))
    {
      *(_QWORD *)(a1 + 16) = CFSTR("IEEE80211");
      *(_QWORD *)(a1 + 128) = CFSTR("Ethernet");
      v31 = 12;
    }
    else if (IOObjectConformsTo(a4, "AppleThunderboltIPPort"))
    {
      *(_QWORD *)(a1 + 16) = CFSTR("Ethernet");
      *(_QWORD *)(a1 + 128) = CFSTR("Ethernet");
      v31 = 13;
    }
    else if (IOObjectConformsTo(a4, "IOBluetoothBNEPDriver"))
    {
      *(_QWORD *)(a1 + 16) = CFSTR("Ethernet");
      *(_QWORD *)(a1 + 128) = CFSTR("Ethernet");
      v31 = 18;
    }
    else if (IOObjectConformsTo(a4, "AppleUSBEthernetHost"))
    {
      *(_QWORD *)(a1 + 16) = CFSTR("Ethernet");
      *(_QWORD *)(a1 + 128) = CFSTR("Ethernet");
      v31 = 15;
    }
    else
    {
      if (!IOObjectConformsTo(a4, "AppleUSBCDCECMData"))
      {
        if (IOObjectConformsTo(a4, "IOUserEthernetController"))
          *(_BYTE *)(a1 + 243) = 1;
LABEL_18:
        v32 = *(const __CFString **)(a1 + 16);
        if (v32)
          goto LABEL_63;
        v33 = IORegistryEntrySearchCFProperty(a2, "IOService", CFSTR("InterfaceRole"), 0, 3u);
        if (!v33)
        {
LABEL_56:
          v32 = *(const __CFString **)(a1 + 16);
          if (!v32)
          {
            v58 = (const __CFString *)CFDictionaryGetValue(a7, CFSTR("name"));
            v59 = IOCopyCFStringValue(v58);
            if (v59)
            {
              v60 = v59;
              if (CFEqual(v59, CFSTR("radio")))
              {
                *(_QWORD *)(a1 + 16) = CFSTR("Ethernet");
                *(_QWORD *)(a1 + 128) = CFSTR("Ethernet");
                *(_DWORD *)(a1 + 312) = 14;
              }
              CFRelease(v60);
            }
            v32 = *(const __CFString **)(a1 + 16);
            if (!v32)
            {
              v32 = CFSTR("Ethernet");
              *(_QWORD *)(a1 + 16) = CFSTR("Ethernet");
              *(_QWORD *)(a1 + 128) = CFSTR("Ethernet");
              *(_DWORD *)(a1 + 312) = 7;
              *(_BYTE *)(a1 + 316) = 1;
            }
          }
LABEL_63:
          if (!CFEqual(v32, CFSTR("IEEE80211")))
            *(_BYTE *)(a1 + 344) = 1;
          v61 = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("IOBuiltin"));
          v62 = CFBooleanGetTypeID();
          if (v61 && CFGetTypeID(v61) == v62
            || (v61 = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("IOPrimaryInterface")),
                v63 = CFBooleanGetTypeID(),
                v61)
            && CFGetTypeID(v61) == v63)
          {
            v64 = CFBooleanGetValue(v61);
          }
          else
          {
            v64 = isBuiltin(a2);
          }
          *(_BYTE *)(a1 + 176) = v64;
          if (!v64 && CFEqual(*(CFTypeRef *)(a1 + 16), CFSTR("IEEE80211")))
            *(_BYTE *)(a1 + 176) = 1;
          v65 = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("IsEphemeral"));
          *(_BYTE *)(a1 + 241) = getBooleanValue(v65);
          v66 = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("SupportsVMNETBridgedMode"));
          *(_BYTE *)(a1 + 244) = getBooleanValue(v66);
          v67 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("IOLocation"));
          v68 = IOCopyCFStringValue(v67);
          *(_QWORD *)(a1 + 200) = v68;
          if (v68 && !CFStringGetLength(v68))
          {
            CFRelease(*(CFTypeRef *)(a1 + 200));
            *(_QWORD *)(a1 + 200) = 0;
          }
          v69 = CFDictionaryGetValue(a5, CFSTR("IOFeatures"));
          v70 = CFNumberGetTypeID();
          if (v69
            && CFGetTypeID(v69) == v70
            && CFNumberGetValue((CFNumberRef)v69, kCFNumberIntType, &v94)
            && (v94 & 6) != 0)
          {
            *(_BYTE *)(a1 + 368) = 1;
          }
          if (CFEqual(*(CFTypeRef *)(a1 + 16), CFSTR("IEEE80211")))
          {
            v38 = CFSTR("airport");
            goto LABEL_84;
          }
          switch(*(_DWORD *)(a1 + 312))
          {
            case 0xD:
              v77 = *(const __CFString **)(a1 + 200);
              if (v77 && CFStringGetLength(v77))
              {
                v78 = CFSTR("multithunderbolt");
                goto LABEL_106;
              }
              v38 = CFSTR("thunderbolt");
              goto LABEL_84;
            case 0xE:
              *(_QWORD *)(a1 + 48) = CFSTR("wireless");
              v79 = &stru_1E25D5260;
              goto LABEL_107;
            case 0x12:
              v38 = CFSTR("bluetooth-pan-gn");
              goto LABEL_84;
            case 0x13:
              v38 = CFSTR("bluetooth-pan-nap");
              goto LABEL_84;
            case 0x14:
              v38 = CFSTR("bluetooth-pan-u");
              goto LABEL_84;
            default:
              if (*(_BYTE *)(a1 + 176))
              {
                v80 = *(const __CFString **)(a1 + 200);
                if (!v80 || !CFStringGetLength(v80))
                {
                  v38 = CFSTR("ether");
                  goto LABEL_84;
                }
                v78 = CFSTR("multiether");
LABEL_106:
                *(_QWORD *)(a1 + 48) = v78;
                v79 = *(const __CFString **)(a1 + 200);
LABEL_107:
                v17 = (void *)CFRetain(v79);
                goto LABEL_9;
              }
              parent[0] = 0;
              v81 = IORegistryEntrySearchCFProperty(a2, "IOService", CFSTR("IOProviderClass"), 0, 3u);
              if (!v81)
                goto LABEL_152;
              v82 = v81;
              v83 = a2;
              break;
          }
          while (CFEqual(v82, CFSTR("IOSkywalkEthernetInterface")))
          {
            CFRelease(v82);
            if (!IORegistryEntryGetParentEntry(v83, "IOService", parent))
            {
              v83 = parent[0];
              parent[0] = 0;
              v82 = IORegistryEntrySearchCFProperty(v83, "IOService", CFSTR("IOProviderClass"), 0, 3u);
              if (v82)
                continue;
            }
            goto LABEL_152;
          }
          if (!CFEqual(v82, CFSTR("IOPCIDevice")))
          {
            v88 = a2;
            while (!CFEqual(v82, CFSTR("IOUSBDevice"))
                 && !CFEqual(v82, CFSTR("IOUSBInterface"))
                 && !CFEqual(v82, CFSTR("IOUSBHostInterface")))
            {
              if (_SC_isAppleInternal_once_3 != -1)
                dispatch_once(&_SC_isAppleInternal_once_3, &__block_literal_global_431);
              if (_SC_isAppleInternal_isInternal_3 && IOObjectConformsTo(v88, "IOUserEthernetController"))
                break;
              v89 = a4;
              if (v88 == a2 || (v89 = a6, v88 == a4))
              {
                CFRelease(v82);
                v82 = IORegistryEntrySearchCFProperty(v89, "IOService", CFSTR("IOProviderClass"), 0, 3u);
                v88 = v89;
                if (v82)
                  continue;
              }
              goto LABEL_139;
            }
            processUSBInterface((_QWORD *)a1, a2);
            if (!update_interface_name((_QWORD *)a1, a2, 1))
            {
              *(_QWORD *)(a1 + 48) = CFSTR("usb-ether");
              *(_QWORD *)(a1 + 56) = IODictionaryCopyBSDName(theDict);
            }
LABEL_139:
            if (!*(_QWORD *)(a1 + 48))
              update_interface_name((_QWORD *)a1, a2, 0);
            if (!v82)
              goto LABEL_152;
            goto LABEL_151;
          }
          v92 = 0;
          *(_QWORD *)parent = 0;
          if (update_interface_name((_QWORD *)a1, a2, 0)
            || !pci_slot_info(a2, valuePtr, &v92, (CFStringRef *)parent))
          {
LABEL_151:
            CFRelease(v82);
LABEL_152:
            if (*(_QWORD *)(a1 + 48))
              goto LABEL_85;
            v16 = CFSTR("generic-ether");
LABEL_8:
            *(_QWORD *)(a1 + 48) = v16;
            v17 = (void *)IODictionaryCopyBSDName(theDict);
LABEL_9:
            *(_QWORD *)(a1 + 56) = v17;
            goto LABEL_85;
          }
          v84 = isThunderbolt(a2);
          v85 = *(_QWORD *)parent;
          if (v84)
          {
            if (*(_QWORD *)parent)
            {
              v86 = v92;
              v87 = CFSTR("thunderbolt-multiether");
LABEL_147:
              *(_QWORD *)(a1 + 48) = v87;
              *(_QWORD *)(a1 + 56) = v86;
              *(_QWORD *)(a1 + 64) = v85;
              goto LABEL_151;
            }
            v90 = v92;
            v91 = CFSTR("thunderbolt-ether");
          }
          else
          {
            if (*(_QWORD *)parent)
            {
              v86 = v92;
              v87 = CFSTR("pci-multiether");
              goto LABEL_147;
            }
            v90 = v92;
            v91 = CFSTR("pci-ether");
          }
          *(_QWORD *)(a1 + 48) = v91;
          *(_QWORD *)(a1 + 56) = v90;
          goto LABEL_151;
        }
        v34 = v33;
        v35 = CFStringGetTypeID();
        if (CFGetTypeID(v34) == v35)
        {
          if (CFEqual(v34, CFSTR("Bluetooth PAN")))
          {
            v36 = 18;
LABEL_54:
            *(_QWORD *)(a1 + 16) = CFSTR("Ethernet");
            *(_QWORD *)(a1 + 128) = CFSTR("Ethernet");
            *(_DWORD *)(a1 + 312) = v36;
            goto LABEL_55;
          }
          if (CFEqual(v34, CFSTR("Bluetooth PAN-NAP")))
          {
            v36 = 19;
            goto LABEL_54;
          }
          if (CFEqual(v34, CFSTR("Bluetooth P2P")))
          {
            v36 = 20;
            goto LABEL_54;
          }
          if (CFEqual(v34, CFSTR("CarPlay")))
          {
            v36 = 21;
            goto LABEL_54;
          }
          if (CFEqual(v34, CFSTR("VMNET")))
          {
            v36 = 23;
            goto LABEL_54;
          }
        }
LABEL_55:
        CFRelease(v34);
        goto LABEL_56;
      }
      *(_QWORD *)(a1 + 16) = CFSTR("Ethernet");
      *(_QWORD *)(a1 + 128) = CFSTR("Ethernet");
      v31 = 17;
    }
    *(_DWORD *)(a1 + 312) = v31;
    goto LABEL_18;
  }
  if (valuePtr != 144)
  {
    if (valuePtr == 255)
    {
      *(_QWORD *)(a1 + 16) = CFSTR("Cellular");
      *(_QWORD *)(a1 + 128) = CFSTR("Cellular");
      *(_BYTE *)(a1 + 176) = 1;
      *(_DWORD *)(a1 + 312) = 22;
      v16 = CFSTR("cellular");
      goto LABEL_8;
    }
    v39 = __log_SCNetworkConfiguration();
    v40 = _SC_syslog_os_log_mapping(6);
    result = __SC_log_enabled(6, v39, (os_log_type_t)v40);
    if (!result)
      return result;
    v41 = _os_log_pack_size();
    v49 = (char *)&parent[-2]
        - ((MEMORY[0x1E0C80A78](v41, v42, v43, v44, v45, v46, v47, v48) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v50 = (_DWORD *)_os_log_pack_fill();
    v51 = valuePtr;
    *v50 = 67109120;
    v50[1] = v51;
    __SC_log_send(6, (uint64_t)v39, v40, v49);
    return 0;
  }
  *(_QWORD *)(a1 + 16) = CFSTR("FireWire");
  *(_QWORD *)(a1 + 128) = CFSTR("FireWire");
  v37 = isBuiltin(a2);
  *(_BYTE *)(a1 + 176) = v37;
  *(_DWORD *)(a1 + 312) = 11;
  if (!v37)
  {
    v92 = 0;
    *(_QWORD *)parent = 0;
    if (update_interface_name((_QWORD *)a1, a2, 0)
      || !pci_slot_info(a2, valuePtr, &v92, (CFStringRef *)parent))
    {
      goto LABEL_85;
    }
    v52 = isThunderbolt(a2);
    v53 = *(_QWORD *)parent;
    if (v52)
    {
      if (*(_QWORD *)parent)
      {
        v54 = v92;
        v55 = CFSTR("thunderbolt-multifirewire");
LABEL_38:
        *(_QWORD *)(a1 + 48) = v55;
        *(_QWORD *)(a1 + 56) = v54;
        *(_QWORD *)(a1 + 64) = v53;
        goto LABEL_85;
      }
      v56 = v92;
      v57 = CFSTR("thunderbolt-firewire");
    }
    else
    {
      if (*(_QWORD *)parent)
      {
        v54 = v92;
        v55 = CFSTR("pci-multifirewire");
        goto LABEL_38;
      }
      v56 = v92;
      v57 = CFSTR("pci-firewire");
    }
    *(_QWORD *)(a1 + 48) = v57;
    *(_QWORD *)(a1 + 56) = v56;
    goto LABEL_85;
  }
  v38 = CFSTR("firewire");
LABEL_84:
  *(_QWORD *)(a1 + 48) = v38;
LABEL_85:
  *(_QWORD *)(a1 + 112) = IODictionaryCopyBSDName(theDict);
  v71 = CFDictionaryGetValue(a5, CFSTR("IOMACAddress"));
  v72 = CFDataGetTypeID();
  if (v71 && CFGetTypeID(v71) == v72)
    *(_QWORD *)(a1 + 160) = CFRetain(v71);
  v73 = CFDictionaryGetValue(theDict, CFSTR("IOInterfaceNamePrefix"));
  v74 = CFStringGetTypeID();
  if (v73 && CFGetTypeID(v73) == v74)
    *(_QWORD *)(a1 + 232) = CFRetain(v73);
  v75 = CFDictionaryGetValue(theDict, CFSTR("IOInterfaceUnit"));
  v76 = CFNumberGetTypeID();
  if (v75 && CFGetTypeID(v75) == v76)
  {
    if (CFNumberGetValue((CFNumberRef)v75, kCFNumberIntType, &v94))
      *(_QWORD *)(a1 + 256) = CFRetain(v75);
  }
  merge_override(a1, a2, CFSTR("PPP"));
  return 1;
}

SCNetworkInterfaceRef SCNetworkServiceGetInterface(SCNetworkServiceRef service)
{
  uint64_t v2;
  const __CFString *NetworkServiceEntity;
  const __CFDictionary *Value;
  CFTypeID TypeID;

  if (__SCNetworkServiceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (service)
      goto LABEL_3;
LABEL_11:
    _SCErrorSet(1002);
    return 0;
  }
  if (!service)
    goto LABEL_11;
LABEL_3:
  v2 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) != v2 || !*((_QWORD *)service + 4))
    goto LABEL_11;
  if (!*((_QWORD *)service + 3))
  {
    NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)service + 2), (uint64_t)CFSTR("Interface"));
    Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)service + 4), NetworkServiceEntity);
    CFRelease(NetworkServiceEntity);
    TypeID = CFDictionaryGetTypeID();
    if (Value)
    {
      if (CFGetTypeID(Value) == TypeID)
        *((_QWORD *)service + 3) = _SCNetworkInterfaceCreateWithEntity(0, Value, (uint64_t)service);
    }
  }
  return (SCNetworkInterfaceRef)*((_QWORD *)service + 3);
}

SCNetworkInterfaceRef _SCNetworkInterfaceCreateWithEntity(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  const __SCPreferences *v5;
  int v6;
  _BOOL4 v7;
  const __CFString *v8;
  const __CFString *v9;
  CFTypeID TypeID;
  const __CFString *v11;
  const __CFString *v12;
  CFTypeID v13;
  CFTypeID v14;
  uint64_t v15;
  uint64_t Copy;
  __CFArray *MatchingInterfaces;
  CFDictionaryRef v18;
  CFDictionaryRef v19;
  CFDictionaryRef v20;
  CFIndex v21;
  uint64_t v22;
  const __CFString *v23;
  uint64_t v24;
  CFIndex i;
  const __CFString *v26;
  const __CFString *v27;
  const __SCPreferences *v28;
  BOOL v29;
  uint64_t v30;
  CFIndex v31;
  CFStringRef *v32;
  CFStringRef NonLocalizedDisplayName;
  _BOOL4 v34;
  NSObject *v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  const __CFString *v47;
  CFStringRef v48;
  CFStringRef v49;
  const __CFString *v50;
  CFTypeID v51;
  CFTypeID v52;
  CFTypeID v53;
  BOOL v54;
  const __CFString *v55;
  const void *v57;
  const void *v58;
  const void *v59;
  CFTypeID v60;
  int v61;
  const __SCNetworkInterface *BridgeInterface;
  const __CFBoolean *v63;
  const __CFArray *MemberInterfaces;
  const __CFArray *v65;
  CFIndex v66;
  CFIndex v67;
  CFIndex j;
  const void *v69;
  SCNetworkInterfaceRef PhysicalInterface;
  const __CFString *v71;
  SCNetworkInterfaceRef v72;
  const void *v73;
  int v74;
  const __CFString *v75;
  const __CFString *v76;
  const __CFString *v77;
  const __CFString *v78;
  const __CFString *v79;
  int v80;
  CFArrayRef v81;
  CFIndex v82;
  CFIndex v83;
  _QWORD *ValueAtIndex;
  uint64_t v85;
  void *v86;
  const __CFString *v87;
  CFDictionaryRef v88;
  uint64_t v89;
  __CFSet *Mutable;
  _BYTE v92[12];
  unsigned int v93;
  _BYTE *v94;
  CFArrayRef v95;
  CFIndex Count;
  const __CFString *v97;
  const __CFString *v98;
  __CFArray *v99;
  void *value;
  void *values[2];
  void *keys;
  const __CFString *v103;
  uint64_t v104;

  v104 = *MEMORY[0x1E0C80C00];
  v99 = 0;
  value = 0;
  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  if ((_UNKNOWN *)a3 == &__SCNetworkInterfaceSearchExternal)
  {
    v5 = 0;
    v7 = 0;
    v6 = 0;
    a3 = 0;
  }
  else if ((_UNKNOWN *)a3 == &__SCNetworkInterfaceSearchSystem)
  {
    v5 = 0;
    a3 = 0;
    v7 = 1;
    v6 = 1;
  }
  else if (a3)
  {
    v5 = *(const __SCPreferences **)(a3 + 32);
    v6 = 0;
    v7 = !_SCNetworkConfigurationBypassSystemInterfaces((uint64_t)v5);
  }
  else
  {
    v5 = 0;
    v6 = 0;
    v7 = 1;
  }
  v8 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("Type"));
  if (v8)
    v9 = v8;
  else
    v9 = CFSTR("Ethernet");
  TypeID = CFStringGetTypeID();
  if (!v9 || CFGetTypeID(v9) != TypeID)
    return 0;
  v11 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("SubType"));
  v12 = CFSTR("PPP");
  if (CFEqual(v9, CFSTR("PPP")) || CFEqual(v9, CFSTR("VPN")))
  {
    v13 = CFStringGetTypeID();
    if (!v11 || CFGetTypeID(v11) != v13)
      return 0;
  }
  v98 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("DeviceName"));
  v97 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("DeviceUniqueIdentifier"));
  if (CFEqual(v9, CFSTR("Ethernet"))
    || CFEqual(v9, CFSTR("FireWire"))
    || CFEqual(v9, CFSTR("Cellular"))
    || CFEqual(v9, CFSTR("PPP")) && CFEqual(v11, CFSTR("PPPoE")))
  {
    v14 = CFStringGetTypeID();
    if (!v98)
      return 0;
    Count = (CFIndex)v11;
    if (CFGetTypeID(v98) != v14)
      return 0;
    v15 = CFEqual(v98, CFSTR("lo0"));
    if ((_DWORD)v15)
    {
      Copy = (uint64_t)__SCNetworkInterfaceCreateCopy(v15, (uint64_t)&__kSCNetworkInterfaceLoopback, 0, 0);
      v12 = CFSTR("PPP");
      v11 = (const __CFString *)Count;
      goto LABEL_112;
    }
    if (__SCNetworkInterfaceCacheCopy(v98, (uint64_t *)&v99))
    {
      MatchingInterfaces = v99;
      v12 = CFSTR("PPP");
      v11 = (const __CFString *)Count;
      if (v99)
        goto LABEL_44;
      goto LABEL_92;
    }
    if (v7)
    {
      v12 = CFSTR("PPP");
      if (_SC_cfstring_to_cstring(v98, (UInt8 *)&keys, 16, 0x8000100u))
      {
        v19 = _SC_IONetworkInterfaceBSDNameMatching((char *)&keys);
        if (v19)
        {
          v20 = v19;
          MatchingInterfaces = findMatchingInterfaces(v19, (unsigned int (*)(uint64_t, uint64_t, __CFDictionary *, _QWORD, __CFDictionary *, _QWORD, __CFDictionary *))processNetworkInterface, CFSTR("HiddenInterface"), v6, 1);
          v99 = MatchingInterfaces;
          __SCNetworkInterfaceCacheAdd(v98, MatchingInterfaces);
          CFRelease(v20);
LABEL_42:
          v11 = (const __CFString *)Count;
          goto LABEL_43;
        }
        __SCNetworkInterfaceCacheAdd(v98, 0);
      }
      v11 = (const __CFString *)Count;
LABEL_92:
      Count = (CFIndex)CFSTR("PPP");
LABEL_93:
      LODWORD(v95) = v7;
      v34 = !v7;
      goto LABEL_118;
    }
    MatchingInterfaces = v99;
    v12 = CFSTR("PPP");
    goto LABEL_42;
  }
  if (CFEqual(v9, CFSTR("PPP")))
  {
    if (CFEqual(v11, CFSTR("PPPSerial")))
    {
      if (!isA_CFString(v98))
        return 0;
      if (!v7)
      {
        MatchingInterfaces = 0;
        goto LABEL_43;
      }
      keys = CFSTR("IOProviderClass");
      v103 = CFSTR("IOTTYBaseName");
      values[0] = CFSTR("IOSerialBSDClient");
      values[1] = (void *)v98;
      v18 = CFDictionaryCreate(0, (const void **)&keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v95 = findMatchingInterfaces(v18, (unsigned int (*)(uint64_t, uint64_t, __CFDictionary *, _QWORD, __CFDictionary *, _QWORD, __CFDictionary *))processSerialInterface, CFSTR("HiddenPort"), v6, 1);
      v99 = v95;
      CFRelease(v18);
      if (v97)
      {
LABEL_36:
        MatchingInterfaces = v95;
        goto LABEL_43;
      }
      v81 = v95;
      if (v95)
      {
        Count = CFArrayGetCount(v95);
        if (Count >= 1)
        {
          if (*((_QWORD *)CFArrayGetValueAtIndex(v95, 0) + 15))
            goto LABEL_36;
          v82 = 1;
          do
          {
            v83 = v82;
            if (Count == v82)
              break;
            ValueAtIndex = CFArrayGetValueAtIndex(v95, v82);
            v82 = v83 + 1;
          }
          while (!ValueAtIndex[15]);
          v29 = v83 < Count;
          v81 = v95;
          if (v29)
          {
            MatchingInterfaces = v95;
            goto LABEL_43;
          }
        }
        CFRelease(v81);
      }
      v103 = CFSTR("IOTTYDevice");
      v88 = CFDictionaryCreate(0, (const void **)&keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      MatchingInterfaces = findMatchingInterfaces(v88, (unsigned int (*)(uint64_t, uint64_t, __CFDictionary *, _QWORD, __CFDictionary *, _QWORD, __CFDictionary *))processSerialInterface, CFSTR("HiddenPort"), v6, 1);
      v99 = MatchingInterfaces;
      CFRelease(v88);
LABEL_43:
      if (MatchingInterfaces)
      {
LABEL_44:
        v21 = CFArrayGetCount(MatchingInterfaces);
        if (!v21)
          goto LABEL_51;
        v22 = v21;
        if (v21 == 1)
        {
          Copy = (uint64_t)CFArrayGetValueAtIndex(MatchingInterfaces, 0);
          v23 = *(const __CFString **)(Copy + 120);
          if (v97 == v23 || v97 && v23 && CFEqual(v97, v23))
          {
            CFRetain((CFTypeRef)Copy);
            goto LABEL_111;
          }
LABEL_51:
          if (CFEqual(v9, CFSTR("Ethernet"))
            && (!CFDictionaryGetValueIfPresent(a2, CFSTR("UserDefinedName"), (const void **)&value)
             || !CFEqual(value, CFSTR("Bluetooth PAN"))))
          {
            v28 = v5;
            if (v5 || (v28 = SCPreferencesCreate(0, CFSTR("SCNetworkInterface"), 0)) != 0)
            {
              if (CFDictionaryContainsKey(a2, CFSTR("_NO_BRIDGE_INTERFACES_"))
                || (Copy = (uint64_t)findBridgeInterface(v28, v98)) == 0)
              {
                if (CFDictionaryContainsKey(a2, CFSTR("_NO_VLAN_INTERFACES_")))
                  Copy = 0;
                else
                  Copy = (uint64_t)findVLANInterface(v28, v98);
              }
              if (v5)
                v5 = v28;
              else
                CFRelease(v28);
              goto LABEL_111;
            }
            v5 = 0;
          }
          Copy = 0;
LABEL_111:
          CFRelease(v99);
          goto LABEL_112;
        }
        v95 = MatchingInterfaces;
        Count = (CFIndex)CFSTR("PPP");
        v94 = (_BYTE *)v21;
        if (v97)
        {
          if (v21 >= 1)
          {
            v24 = 0;
            for (i = 0; (_BYTE *)i != v94; ++i)
            {
              Copy = (uint64_t)CFArrayGetValueAtIndex(v95, i);
              v26 = *(const __CFString **)(Copy + 120);
              if (v97 == v26 || v26 && CFEqual(v97, v26))
              {
                if (v24)
                  goto LABEL_107;
              }
              else
              {
                Copy = v24;
              }
              v24 = Copy;
            }
LABEL_106:
            if (Copy)
              goto LABEL_110;
          }
        }
        else
        {
          if (CFDictionaryGetValueIfPresent(a2, CFSTR("UserDefinedName"), (const void **)&value))
            v29 = v22 < 1;
          else
            v29 = 1;
          if (!v29)
          {
            v30 = 0;
            v31 = 0;
            while (1)
            {
              v32 = (CFStringRef *)CFArrayGetValueAtIndex(v95, v31);
              Copy = (uint64_t)v32;
              if (!v32[15]
                || (NonLocalizedDisplayName = __SCNetworkInterfaceGetNonLocalizedDisplayName(v32)) == 0
                || value == NonLocalizedDisplayName
                || value && CFEqual(value, NonLocalizedDisplayName))
              {
                if (v30)
                {
                  Copy = 0;
                  goto LABEL_106;
                }
              }
              else
              {
                Copy = v30;
              }
              ++v31;
              v30 = Copy;
              if (v94 == (_BYTE *)v31)
                goto LABEL_106;
            }
          }
        }
LABEL_107:
        v35 = __log_SCNetworkConfiguration();
        v36 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v35, (os_log_type_t)v36))
        {
          v37 = _os_log_pack_size();
          v93 = v36;
          v94 = v92;
          v45 = &v92[-((MEMORY[0x1E0C80A78](v37, v38, v39, v40, v41, v42, v43, v44) + 15) & 0xFFFFFFFFFFFFFFF0)];
          __error();
          v46 = _os_log_pack_fill();
          *(_DWORD *)v46 = 138412290;
          *(_QWORD *)(v46 + 4) = v98;
          __SC_log_send(5, (uint64_t)v35, v93, v45);
        }
        Copy = (uint64_t)CFArrayGetValueAtIndex(v95, 0);
LABEL_110:
        CFRetain((CFTypeRef)Copy);
        v12 = (const __CFString *)Count;
        goto LABEL_111;
      }
      goto LABEL_92;
    }
    if (CFEqual(v11, CFSTR("L2TP")))
    {
      v27 = CFSTR("L2TP");
    }
    else if (CFEqual(v11, CFSTR("PPTP")))
    {
      v27 = CFSTR("PPTP");
    }
    else
    {
      v27 = v11;
    }
    goto LABEL_214;
  }
  if (CFEqual(v9, CFSTR("6to4")))
  {
    if (!isA_CFString(v98))
      return 0;
    v27 = CFSTR("6to4");
    goto LABEL_214;
  }
  if (CFEqual(v9, CFSTR("IPSec")))
  {
    v27 = CFSTR("IPSec");
LABEL_214:
    v86 = SCNetworkInterfaceCreateWithInterface((SCNetworkInterfaceRef)&__kSCNetworkInterfaceIPv4, v27);
    goto LABEL_215;
  }
  v85 = CFEqual(v9, CFSTR("Loopback"));
  if ((_DWORD)v85)
  {
    v86 = (void *)__SCNetworkInterfaceCreateCopy(v85, (uint64_t)&__kSCNetworkInterfaceLoopback, 0, 0);
LABEL_215:
    Copy = (uint64_t)v86;
    goto LABEL_112;
  }
  Count = (CFIndex)CFSTR("PPP");
  if (CFEqual(v9, CFSTR("VPN")))
  {
    if (CFStringFind(v11, CFSTR("."), 0).location == -1)
      goto LABEL_93;
    v87 = v11;
  }
  else
  {
    if (CFStringFind(v9, CFSTR("."), 0).location == -1 || v98)
      goto LABEL_93;
    v87 = v9;
  }
  Copy = (uint64_t)SCNetworkInterfaceCreateWithInterface((SCNetworkInterfaceRef)&__kSCNetworkInterfaceIPv4, v87);
  v12 = (const __CFString *)Count;
LABEL_112:
  if (Copy && v7)
    goto LABEL_158;
  Count = (CFIndex)v12;
  v34 = !v7;
  if (v7 || !Copy)
  {
    LODWORD(v95) = v7;
  }
  else
  {
    CFRelease((CFTypeRef)Copy);
    LODWORD(v95) = 0;
    v34 = 1;
  }
LABEL_118:
  v47 = v97;
  Copy = __SCNetworkInterfaceCreatePrivate(0, 0, 0, 0);
  *(_QWORD *)(Copy + 128) = v9;
  *(_QWORD *)(Copy + 136) = v11;
  if (v98)
    v48 = CFStringCreateCopy(0, v98);
  else
    v48 = 0;
  *(_QWORD *)(Copy + 112) = v48;
  v49 = 0;
  if (v47)
    v49 = CFStringCreateCopy(0, v47);
  *(_QWORD *)(Copy + 120) = v49;
  v50 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("UserDefinedName"));
  v51 = CFStringGetTypeID();
  if (!v50)
    goto LABEL_137;
  v52 = v51;
  v53 = CFGetTypeID(v50);
  v54 = v53 == v52;
  if (v53 == v52)
    v55 = v50;
  else
    v55 = 0;
  if (!v54 || !v34)
  {
    v50 = v55;
LABEL_137:
    v12 = (const __CFString *)Count;
    goto LABEL_138;
  }
  CFRetain(v55);
  v57 = *(const void **)(Copy + 32);
  v12 = (const __CFString *)Count;
  if (v57)
    CFRelease(v57);
  *(_QWORD *)(Copy + 32) = v55;
  CFRetain(v55);
  v58 = *(const void **)(Copy + 40);
  if (v58)
    CFRelease(v58);
  *(_QWORD *)(Copy + 40) = v55;
LABEL_138:
  if (CFEqual(v9, CFSTR("Ethernet")))
  {
    if ((v95 & 1) == 0)
    {
      BridgeInterface = findBridgeInterface(v5, v98);
      if (BridgeInterface || (BridgeInterface = findVLANInterface(v5, v98)) != 0)
      {
        CFRelease((CFTypeRef)Copy);
        Copy = (uint64_t)BridgeInterface;
LABEL_155:
        __SCNetworkInterfaceCacheAdd1(v98, (const void *)Copy);
        goto LABEL_156;
      }
    }
    v59 = CFDictionaryGetValue(a2, CFSTR("Hardware"));
    v60 = CFStringGetTypeID();
    if (v59 && CFGetTypeID(v59) == v60 && CFEqual(v59, CFSTR("AirPort")))
    {
      *(_QWORD *)(Copy + 16) = CFSTR("IEEE80211");
      *(_QWORD *)(Copy + 48) = CFSTR("airport");
      v61 = 12;
LABEL_153:
      *(_DWORD *)(Copy + 312) = v61;
LABEL_154:
      *(_BYTE *)(Copy + 176) = 1;
      goto LABEL_155;
    }
    *(_QWORD *)(Copy + 16) = CFSTR("Ethernet");
    if (__SCNetworkInterfaceMatchesName(v50, CFSTR("ether"))
      || __SCNetworkInterfaceMatchesName(v50, CFSTR("multiether")))
    {
      v61 = 7;
      goto LABEL_153;
    }
    v77 = CFSTR("iPhone");
    if (__SCNetworkInterfaceMatchesName(v50, CFSTR("iPhone"))
      || __SCNetworkInterfaceMatchesName(v50, CFSTR("X-iPhone"))
      || (v77 = CFSTR("iPad"), __SCNetworkInterfaceMatchesName(v50, CFSTR("iPad")))
      || __SCNetworkInterfaceMatchesName(v50, CFSTR("X-iPad")))
    {
      *(_QWORD *)(Copy + 48) = v77;
      v74 = 16;
    }
    else
    {
      if (__SCNetworkInterfaceMatchesName(v50, CFSTR("thunderbolt"))
        || __SCNetworkInterfaceMatchesName(v50, CFSTR("multithunderbolt")))
      {
        *(_QWORD *)(Copy + 48) = CFSTR("thunderbolt");
        v61 = 13;
        goto LABEL_153;
      }
      if (__SCNetworkInterfaceMatchesName(v50, CFSTR("bluetooth-pan-gn")))
      {
        *(_QWORD *)(Copy + 48) = CFSTR("bluetooth-pan-gn");
        v74 = 18;
      }
      else if (__SCNetworkInterfaceMatchesName(v50, CFSTR("bluetooth-pan-nap")))
      {
        *(_QWORD *)(Copy + 48) = CFSTR("bluetooth-pan-nap");
        v74 = 19;
      }
      else if (__SCNetworkInterfaceMatchesName(v50, CFSTR("bluetooth-pan-u")))
      {
        *(_QWORD *)(Copy + 48) = CFSTR("bluetooth-pan-u");
        v74 = 20;
      }
      else
      {
        v74 = 7;
      }
    }
LABEL_190:
    *(_DWORD *)(Copy + 312) = v74;
    goto LABEL_155;
  }
  if (CFEqual(v9, CFSTR("FireWire")))
  {
    *(_QWORD *)(Copy + 16) = CFSTR("FireWire");
    *(_DWORD *)(Copy + 312) = 11;
    if (!__SCNetworkInterfaceMatchesName(v50, CFSTR("firewire")))
      goto LABEL_155;
    goto LABEL_154;
  }
  if (!CFEqual(v9, v12) || !v11)
  {
    if (CFEqual(v9, CFSTR("VPN")) && v11)
      goto LABEL_194;
    if (CFEqual(v9, CFSTR("IPSec")))
    {
      CFRelease((CFTypeRef)Copy);
      v76 = CFSTR("IPSec");
LABEL_182:
      Copy = (uint64_t)SCNetworkInterfaceCreateWithInterface((SCNetworkInterfaceRef)&__kSCNetworkInterfaceIPv4, v76);
      goto LABEL_156;
    }
    if (CFEqual(v9, CFSTR("6to4")))
    {
      CFRelease((CFTypeRef)Copy);
      if (isA_CFString(v98))
      {
        v76 = CFSTR("6to4");
        goto LABEL_182;
      }
    }
    else
    {
      if (CFEqual(v9, CFSTR("PointToPoint")))
      {
        *(_QWORD *)(Copy + 16) = CFSTR("PointToPoint");
        goto LABEL_156;
      }
      if (CFEqual(v9, CFSTR("Loopback")))
      {
        CFRelease((CFTypeRef)Copy);
        Copy = (uint64_t)__SCNetworkInterfaceCreateCopy(v89, (uint64_t)&__kSCNetworkInterfaceLoopback, 0, 0);
        goto LABEL_156;
      }
      if (CFStringFind(v9, CFSTR("."), 0).location != -1)
      {
        pthread_mutex_lock(&lock_1);
        Mutable = (__CFSet *)vendor_interface_types;
        if (!vendor_interface_types)
        {
          Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
          vendor_interface_types = (uint64_t)Mutable;
        }
        CFSetAddValue(Mutable, v9);
        *(_QWORD *)(Copy + 16) = CFSetGetValue((CFSetRef)vendor_interface_types, v9);
        pthread_mutex_unlock(&lock_1);
        goto LABEL_156;
      }
      CFRelease((CFTypeRef)Copy);
    }
    return 0;
  }
  if (CFEqual(v11, CFSTR("PPPoE")))
  {
    v73 = CFDictionaryGetValue(a2, CFSTR("Hardware"));
    if (isA_CFString(v73) && CFEqual(v73, CFSTR("AirPort")))
    {
      v74 = 12;
      v75 = CFSTR("IEEE80211");
    }
    else
    {
      v74 = 7;
      v75 = CFSTR("Ethernet");
    }
    *(_QWORD *)(Copy + 16) = v75;
    goto LABEL_190;
  }
  if (!CFEqual(v11, CFSTR("PPPSerial")))
  {
LABEL_194:
    CFRelease((CFTypeRef)Copy);
    Copy = (uint64_t)SCNetworkInterfaceCreateWithInterface((SCNetworkInterfaceRef)&__kSCNetworkInterfaceIPv4, v11);
    if (!Copy)
      return (SCNetworkInterfaceRef)Copy;
    goto LABEL_156;
  }
  v78 = v12;
  v79 = v98;
  if (CFStringHasPrefix(v98, CFSTR("Bluetooth")))
  {
    *(_QWORD *)(Copy + 16) = CFSTR("Bluetooth");
    v80 = 3;
  }
  else if (CFStringHasPrefix(v79, CFSTR("wwan")))
  {
    *(_QWORD *)(Copy + 16) = CFSTR("WWAN");
    v80 = 4;
  }
  else
  {
    *(_QWORD *)(Copy + 16) = CFSTR("Modem");
    v80 = 2;
  }
  *(_DWORD *)(Copy + 312) = v80;
  v12 = v78;
LABEL_156:
  v63 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("HiddenConfiguration"));
  *(_BYTE *)(Copy + 192) = getBooleanValue(v63);
  if (CFDictionaryContainsKey(a2, CFSTR("TrustRequired")))
    *(_BYTE *)(Copy + 240) = 1;
LABEL_158:
  if (a3)
  {
    __SCNetworkInterfaceSetService(Copy, a3);
    if (CFEqual(*(CFTypeRef *)(Copy + 16), CFSTR("Bridge")))
    {
      MemberInterfaces = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces((const __SCNetworkInterface *)Copy);
      if (MemberInterfaces)
      {
        v65 = MemberInterfaces;
        v66 = CFArrayGetCount(MemberInterfaces);
        if (v66 >= 1)
        {
          v67 = v66;
          for (j = 0; j != v67; ++j)
          {
            v69 = CFArrayGetValueAtIndex(v65, j);
            __SCNetworkInterfaceSetService((uint64_t)v69, a3);
          }
        }
      }
    }
    if (CFEqual(*(CFTypeRef *)(Copy + 16), CFSTR("VLAN")))
    {
      PhysicalInterface = SCVLANInterfaceGetPhysicalInterface((SCVLANInterfaceRef)Copy);
      if (PhysicalInterface)
        __SCNetworkInterfaceSetService((uint64_t)PhysicalInterface, a3);
    }
  }
  if (CFEqual(v9, v12))
  {
    v71 = CFSTR("PPP");
LABEL_171:
    v72 = SCNetworkInterfaceCreateWithInterface((SCNetworkInterfaceRef)Copy, v71);
    CFRelease((CFTypeRef)Copy);
    return v72;
  }
  if (CFEqual(v9, CFSTR("VPN")))
  {
    v71 = CFSTR("VPN");
    goto LABEL_171;
  }
  return (SCNetworkInterfaceRef)Copy;
}

const __CFBoolean *getBooleanValue(const __CFBoolean *result)
{
  const __CFBoolean *v1;
  CFTypeID TypeID;
  CFTypeID v3;
  BOOL v4;
  int valuePtr;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    TypeID = CFBooleanGetTypeID();
    if (CFGetTypeID(v1) == TypeID)
    {
      return (const __CFBoolean *)CFBooleanGetValue(v1);
    }
    else
    {
      v3 = CFNumberGetTypeID();
      if (CFGetTypeID(v1) == v3)
      {
        valuePtr = 0;
        if (CFNumberGetValue(v1, kCFNumberIntType, &valuePtr))
          v4 = valuePtr == 0;
        else
          v4 = 1;
        return (const __CFBoolean *)!v4;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

CFTypeRef __SCNetworkInterfaceSetService(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  const void *v6;
  CFTypeRef result;

  v4 = *(const void **)(a1 + 80);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v5 = *(const void **)(a1 + 96);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 96) = 0;
  }
  v6 = *(const void **)(a2 + 32);
  if (v6)
    *(_QWORD *)(a1 + 80) = CFRetain(v6);
  result = *(CFTypeRef *)(a2 + 16);
  if (result)
  {
    result = CFRetain(result);
    *(_QWORD *)(a1 + 96) = result;
  }
  return result;
}

BOOL _SCNetworkConfigurationBypassSystemInterfaces(uint64_t a1)
{
  char NetworkConfigurationFlags;

  NetworkConfigurationFlags = __SCPreferencesGetNetworkConfigurationFlags(a1);
  if ((NetworkConfigurationFlags & 3) != 0)
    return NetworkConfigurationFlags & 1;
  else
    return __SCPreferencesUsingDefaultPrefs(a1) == 0;
}

uint64_t __SCPreferencesUsingDefaultPrefs(uint64_t a1)
{
  const char *v1;
  const char *v2;
  char *v3;

  if (!a1)
    return 1;
  v1 = *(const char **)(a1 + 104);
  if (v1)
  {
    v2 = (const char *)__SCPreferencesPath(0, 0);
    if (v2)
    {
      v3 = (char *)v2;
      v1 = (const char *)(strcmp(v1, v2) == 0);
      CFAllocatorDeallocate(0, v3);
    }
    else
    {
      return 0;
    }
  }
  return (uint64_t)v1;
}

uint64_t __SCPreferencesGetNetworkConfigurationFlags(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 308);
  return result;
}

uint64_t __SCNetworkInterfaceCreatePrivate(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  uint64_t Instance;
  CFTypeRef v8;
  CFTypeRef v9;
  CFTypeRef v10;

  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    if (a2)
      v8 = CFRetain(a2);
    else
      v8 = 0;
    *(_QWORD *)(Instance + 72) = v8;
    if (a3)
      v9 = CFRetain(a3);
    else
      v9 = 0;
    *(_QWORD *)(Instance + 80) = v9;
    if (a4)
      v10 = CFRetain(a4);
    else
      v10 = 0;
    *(_QWORD *)(Instance + 96) = v10;
    *(_DWORD *)(Instance + 312) = 24;
  }
  return Instance;
}

CFStringRef IOCopyCFStringValue(const __CFString *a1)
{
  CFTypeID TypeID;
  CFTypeID v4;
  const char *BytePtr;

  TypeID = CFStringGetTypeID();
  if (a1)
  {
    if (CFGetTypeID(a1) == TypeID)
      return CFStringCreateCopy(0, a1);
    v4 = CFDataGetTypeID();
    if (CFGetTypeID(a1) == v4)
    {
      BytePtr = (const char *)CFDataGetBytePtr((CFDataRef)a1);
      return CFStringCreateWithCString(0, BytePtr, 0x8000100u);
    }
  }
  else
  {
    CFDataGetTypeID();
  }
  return 0;
}

CFStringRef __SCPreferencesAddSessionKeys(CFStringRef result)
{
  CFStringRef v1;

  v1 = result;
  if (!result[5].length)
  {
    result = _SCPNotificationKey(0, (const __CFString *)result[2].length, 2);
    v1[5].length = (uint64_t)result;
  }
  if (!v1[6].isa)
  {
    result = _SCPNotificationKey(0, (const __CFString *)v1[2].length, 3);
    v1[6].isa = (void *)result;
  }
  return result;
}

CFStringRef _SCPNotificationKey(const __CFAllocator *a1, const __CFString *a2, int a3)
{
  __CFString *v4;
  const char *v5;
  char *v6;
  CFStringRef v7;
  CFStringRef v8;

  if ((a3 - 1) > 2)
    return 0;
  v4 = off_1E25D07D8[a3 - 1];
  v5 = (const char *)__SCPreferencesPath(a1, a2);
  if (!v5)
    return 0;
  v6 = (char *)v5;
  v7 = CFStringCreateWithCStringNoCopy(a1, v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v8 = CFStringCreateWithFormat(a1, 0, CFSTR("%@%@:%@"), CFSTR("Prefs:"), v4, v7);
  CFRelease(v7);
  CFAllocatorDeallocate(0, v6);
  return v8;
}

void *__SCPreferencesPath(CFAllocatorRef alloc, CFStringRef theString)
{
  CFStringRef Copy;
  const __CFString *v5;
  void *v6;
  CFIndex MaximumSizeOfFileSystemRepresentation;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  CFMutableStringRef MutableCopy;
  _QWORD v21[2];
  CFRange v22;

  v21[1] = *MEMORY[0x1E0C80C00];
  if (!theString)
  {
    Copy = CFStringCreateWithFormat(alloc, 0, CFSTR("%s%@/%@"), "", CFSTR("/Library/Preferences/SystemConfiguration"), CFSTR("preferences.plist"));
    goto LABEL_5;
  }
  if (CFStringHasPrefix(theString, CFSTR("/")))
  {
    Copy = CFStringCreateCopy(alloc, theString);
LABEL_5:
    v5 = Copy;
    goto LABEL_6;
  }
  if (!CFEqual(theString, CFSTR("preferences.plist")))
    CFEqual(theString, CFSTR("NetworkInterfaces.plist"));
  v5 = CFStringCreateWithFormat(alloc, 0, CFSTR("%s%@/%@"), "", CFSTR("/Library/Preferences/SystemConfiguration"), theString);
  if (CFStringHasSuffix(theString, CFSTR(".xml")))
  {
    MutableCopy = CFStringCreateMutableCopy(alloc, 0, v5);
    v22.location = CFStringGetLength(MutableCopy) - 4;
    v22.length = 4;
    CFStringReplace(MutableCopy, v22, CFSTR(".plist"));
    CFRelease(v5);
    v5 = MutableCopy;
  }
LABEL_6:
  v6 = _SC_cfstring_to_cstring(v5, 0, 0, 0x600u);
  if (!v6)
  {
    MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(v5);
    v6 = CFAllocatorAllocate(0, MaximumSizeOfFileSystemRepresentation, 0);
    if (!CFStringGetFileSystemRepresentation(v5, (char *)v6, MaximumSizeOfFileSystemRepresentation))
    {
      v8 = __log_SCPreferences();
      v9 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v8, (os_log_type_t)v9))
      {
        v10 = _os_log_pack_size();
        v18 = (char *)v21 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(6, (uint64_t)v8, v9, v18);
      }
      CFAllocatorDeallocate(0, v6);
      v6 = 0;
    }
  }
  CFRelease(v5);
  return v6;
}

UInt8 *_SC_cfstring_to_cstring(const __CFString *a1, UInt8 *a2, CFIndex a3, CFStringEncoding a4)
{
  return _SC_cfstring_to_cstring_ext(a1, a2, a3, a4, 0, 0);
}

CFStringRef IODictionaryCopyBSDName(const __CFDictionary *a1)
{
  const __CFString *Value;
  const void *v4;
  const void *v5;
  CFTypeID TypeID;
  CFTypeID v7;

  Value = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("BSD Name"));
  if (Value)
    return IOCopyCFStringValue(Value);
  v4 = CFDictionaryGetValue(a1, CFSTR("IOInterfaceNamePrefix"));
  v5 = CFDictionaryGetValue(a1, CFSTR("IOInterfaceUnit"));
  TypeID = CFStringGetTypeID();
  if (v4 && CFGetTypeID(v4) == TypeID && (v7 = CFNumberGetTypeID(), v5) && CFGetTypeID(v5) == v7)
    return CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), v4, v5);
  else
    return 0;
}

void merge_override(uint64_t a1, io_registry_entry_t a2, const void *a3)
{
  const __CFString *v6;
  CFTypeRef v7;
  CFTypeID TypeID;
  __CFDictionary *Mutable;

  v6 = CFStringCreateWithFormat(0, 0, CFSTR("Device%@Overrides"), a3);
  v7 = IORegistryEntrySearchCFProperty(a2, "IOService", v6, 0, 3u);
  CFRelease(v6);
  if (v7)
  {
    TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(v7) == TypeID)
    {
      Mutable = *(__CFDictionary **)(a1 + 224);
      if (!Mutable)
      {
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        *(_QWORD *)(a1 + 224) = Mutable;
      }
      CFDictionarySetValue(Mutable, a3, v7);
    }
    CFRelease(v7);
  }
}

CFStringRef __SC_IORegistryEntryCopyPath(uint64_t a1)
{
  io_registry_entry_t v1;
  int v2;
  CFStringRef v3;
  uint64_t v5;
  const void *v6;
  CFStringRef v7;
  io_registry_entry_t parent;
  io_name_t location;
  io_name_t name;
  _OWORD cStr[32];
  uint64_t v12;

  v1 = a1;
  v12 = *MEMORY[0x1E0C80C00];
  memset(cStr, 0, sizeof(cStr));
  v2 = MEMORY[0x18D78C3F0](a1, "IOService", cStr);
  if (v2 != -536870206)
  {
    if (!v2)
      return CFStringCreateWithCString(0, (const char *)cStr, 0x8000100u);
    return 0;
  }
  parent = 0;
  if (IORegistryEntryGetParentEntry(v1, "IOService", &parent))
    return 0;
  v5 = __SC_IORegistryEntryCopyPath(parent);
  if (v5)
  {
    v6 = (const void *)v5;
    memset(name, 0, sizeof(name));
    if (IORegistryEntryGetNameInPlane(v1, "IOService", name))
    {
      v3 = 0;
    }
    else
    {
      memset(location, 0, sizeof(location));
      if (IORegistryEntryGetLocationInPlane(v1, "IOService", location))
        v7 = CFStringCreateWithFormat(0, 0, CFSTR("%@/%s"), v6, name);
      else
        v7 = CFStringCreateWithFormat(0, 0, CFSTR("%@/%s@%s"), v6, name, location);
      v3 = v7;
    }
    CFRelease(v6);
  }
  else
  {
    v3 = 0;
  }
  IOObjectRelease(parent);
  return v3;
}

uint64_t __SCNetworkInterfaceCacheCopy(const void *a1, uint64_t *a2)
{
  _QWORD *v4;
  uint64_t result;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  v4 = __SCGetThreadSpecificData();
  result = 0;
  if (a1)
  {
    v6 = v4[1];
    if (v6)
    {
      result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)v4[1], a1);
      *a2 = result;
      if (result)
      {
        if (result == *MEMORY[0x1E0C9B0D0])
          *a2 = 0;
        else
          CFRetain((CFTypeRef)result);
        v7 = __log_SCNetworkConfiguration();
        v8 = _SC_syslog_os_log_mapping(7);
        if (__SC_log_enabled(7, v7, (os_log_type_t)v8))
        {
          v9 = _os_log_pack_size();
          v17 = (char *)v21 - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v18 = _os_log_pack_fill();
          v19 = *a2;
          *(_DWORD *)v18 = 134218498;
          *(_QWORD *)(v18 + 4) = v6;
          if (v19)
            v20 = "";
          else
            v20 = "no ";
          *(_WORD *)(v18 + 12) = 2080;
          *(_QWORD *)(v18 + 14) = v20;
          *(_WORD *)(v18 + 22) = 2112;
          *(_QWORD *)(v18 + 24) = a1;
          __SC_log_send(7, (uint64_t)v7, v8, v17);
          return 1;
        }
        else
        {
          return 1;
        }
      }
    }
  }
  return result;
}

void __SCNetworkInterfaceCacheAdd(const void *a1, const void *a2)
{
  _QWORD *v4;
  __CFDictionary *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v4 = __SCGetThreadSpecificData();
  if (a1)
  {
    v5 = (__CFDictionary *)v4[1];
    if (v5)
    {
      if (!a2)
        a2 = (const void *)*MEMORY[0x1E0C9B0D0];
      v6 = __log_SCNetworkConfiguration();
      v7 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v6, (os_log_type_t)v7))
      {
        v8 = _os_log_pack_size();
        v16 = (char *)v18 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v17 = _os_log_pack_fill();
        *(_DWORD *)v17 = 134218242;
        *(_QWORD *)(v17 + 4) = v5;
        *(_WORD *)(v17 + 12) = 2112;
        *(_QWORD *)(v17 + 14) = a1;
        __SC_log_send(7, (uint64_t)v6, v7, v16);
      }
      CFDictionaryAddValue(v5, a1, a2);
    }
  }
}

uint64_t update_interface_name(_QWORD *a1, io_registry_entry_t entry, int a3)
{
  CFTypeRef v5;
  uint64_t v6;
  const void *v7;
  CFStringRef v8;
  const void *v9;
  const void *v10;

  v5 = IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("Product Name"), 0, 3u);
  v6 = (uint64_t)v5;
  if (a3 && !v5)
  {
    v7 = (const void *)a1[35];
    if (!v7)
      return 0;
    v6 = (uint64_t)CFRetain(v7);
  }
  if (!v6)
    return v6;
  v8 = IOCopyCFStringValue((const __CFString *)v6);
  CFRelease((CFTypeRef)v6);
  if (!v8)
    return 0;
  if (CFStringGetLength(v8) < 1)
  {
    v6 = 0;
  }
  else
  {
    v9 = (const void *)a1[4];
    if (v9)
      CFRelease(v9);
    a1[4] = CFRetain(v8);
    v10 = (const void *)a1[5];
    if (v10)
    {
      CFRelease(v10);
      a1[5] = 0;
    }
    v6 = 1;
    if (bundle)
      a1[5] = copy_interface_string((__CFBundle *)bundle, v8, 1);
  }
  CFRelease(v8);
  return v6;
}

CFArrayRef split_path(CFStringRef theString)
{
  CFMutableStringRef MutableCopy;
  CFArrayRef ArrayBySeparatingStrings;
  CFRange v4;

  MutableCopy = CFStringCreateMutableCopy(0, 0, theString);
  v4.length = CFStringGetLength(MutableCopy);
  v4.location = 0;
  CFStringFindAndReplace(MutableCopy, CFSTR("@"), CFSTR("/"), v4, 0);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, MutableCopy, CFSTR("/"));
  CFRelease(MutableCopy);
  return ArrayBySeparatingStrings;
}

uint64_t _SCNetworkInterfaceIsApplePreconfigured(_DWORD *cf)
{
  uint64_t v2;
  uint64_t result;
  const void *v4;
  CFTypeID TypeID;
  const __CFDictionary *v6;
  int valuePtr;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
  {
    result = _SCNetworkInterfaceIsHiddenConfiguration((unsigned __int8 *)cf);
    if (!(_DWORD)result)
      return result;
    if (_SCNetworkInterfaceIsBuiltin((unsigned __int8 *)cf))
      return 1;
    v4 = (const void *)*((_QWORD *)cf + 36);
    TypeID = CFNumberGetTypeID();
    if (v4)
    {
      if (CFGetTypeID(v4) == TypeID)
      {
        valuePtr = 0;
        if (CFNumberGetValue(*((CFNumberRef *)cf + 36), kCFNumberIntType, &valuePtr))
        {
          if (valuePtr == 1452)
            return 1;
        }
      }
    }
    if (_SCNetworkInterfaceIsCarPlay(cf))
    {
      v6 = (const __CFDictionary *)*((_QWORD *)cf + 28);
      if (v6)
      {
        if (CFDictionaryContainsKey(v6, CFSTR("IPv4"))
          || CFDictionaryContainsKey(*((CFDictionaryRef *)cf + 28), CFSTR("IPv6")))
        {
          return 1;
        }
      }
    }
  }
  return 0;
}

uint64_t _SCNetworkInterfaceIsHiddenConfiguration(unsigned __int8 *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[192];
  return 0;
}

__CFArray *_SCNetworkInterfaceCopyAllWithPreferences(const __SCPreferences *a1)
{
  __CFArray *Mutable;
  __CFArray *v3;
  __CFArray *v4;
  CFDictionaryRef v5;
  __CFArray *MatchingInterfaces;
  const __SCPreferences *v7;
  const __CFArray *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  const __CFArray *v11;
  uint64_t Count;
  void *values[2];
  void *keys[3];
  CFRange v16;

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  if (__wait_for_IOKit_to_quiesce_iokit_quiet != -1)
    dispatch_once(&__wait_for_IOKit_to_quiesce_iokit_quiet, &__block_literal_global_455);
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v3 = __SCNetworkInterfaceCopyAll_IONetworkInterface(0);
  if (v3)
  {
    v4 = v3;
    add_interfaces(Mutable, v3);
    CFRelease(v4);
  }
  keys[0] = CFSTR("IOProviderClass");
  keys[1] = CFSTR("IOSerialBSDClientType");
  values[0] = CFSTR("IOSerialBSDClient");
  values[1] = CFSTR("IOSerialStream");
  v5 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  MatchingInterfaces = findMatchingInterfaces(v5, (unsigned int (*)(uint64_t, uint64_t, __CFDictionary *, _QWORD, __CFDictionary *, _QWORD, __CFDictionary *))processSerialInterface, CFSTR("HiddenPort"), 0, 0);
  CFRelease(v5);
  if (MatchingInterfaces)
  {
    add_interfaces(Mutable, MatchingInterfaces);
    CFRelease(MatchingInterfaces);
  }
  v7 = a1;
  if (a1 || (v7 = SCPreferencesCreate(0, CFSTR("SCNetworkInterfaceCopyAll"), 0)) != 0)
  {
    v8 = (const __CFArray *)SCBridgeInterfaceCopyAll(v7);
    if (v8)
    {
      v9 = v8;
      add_interfaces(Mutable, v8);
      CFRelease(v9);
    }
    v10 = SCVLANInterfaceCopyAll(v7);
    if (v10)
    {
      v11 = v10;
      add_interfaces(Mutable, v10);
      CFRelease(v11);
    }
    if (!a1)
      CFRelease(v7);
  }
  Count = CFArrayGetCount(Mutable);
  if (Count >= 2)
  {
    v16.length = Count;
    v16.location = 0;
    CFArraySortValues(Mutable, v16, (CFComparatorFunction)_SCNetworkInterfaceCompare, 0);
  }
  return Mutable;
}

void add_interfaces(__CFArray *a1, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const void *ValueAtIndex;

  Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    v5 = Count;
    for (i = 0; i != v5; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
      if (SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)ValueAtIndex))
        CFArrayAppendValue(a1, ValueAtIndex);
    }
  }
}

CFStringRef SCNetworkInterfaceGetBSDName(SCNetworkInterfaceRef interface)
{
  uint64_t v2;
  void *v3;
  int v4;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
    {
LABEL_9:
      v4 = 1002;
      goto LABEL_10;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_9;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) != v2)
    goto LABEL_9;
  v3 = (void *)*((_QWORD *)interface + 9);
  if (!v3 || v3 == &__kSCNetworkInterfaceIPv4)
    return (CFStringRef)*((_QWORD *)interface + 14);
  v4 = 0;
LABEL_10:
  _SCErrorSet(v4);
  return 0;
}

CFStringRef SCDynamicStoreKeyCreateNetworkServiceEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef serviceID, CFStringRef entity)
{
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (entity)
    return CFStringCreateWithFormat(allocator, 0, CFSTR("%@/%@/%@/%@/%@"), domain, CFSTR("Network"), CFSTR("Service"), serviceID, entity, v6);
  else
    return CFStringCreateWithFormat(allocator, 0, CFSTR("%@/%@/%@/%@"), domain, CFSTR("Network"), CFSTR("Service"), serviceID, v5, v6);
}

void SCLog(int a1, int a2, CFStringRef theString, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v11;
  FILE **v12;
  uint64_t *v13;

  v13 = 0;
  if (!a1)
    return;
  if (_sc_log < 1)
  {
    v13 = &a9;
LABEL_12:
    v12 = (FILE **)MEMORY[0x1E0C80C10];
    if ((~a2 & 6) != 0)
      v12 = (FILE **)MEMORY[0x1E0C80C20];
    __SCPrint(*v12, (uint64_t)theString, (uint64_t)v13, _sc_log == 2, 1);
    return;
  }
  v11 = _sc_log;
  if (_sc_log >= 2)
    v13 = &a9;
  if (CFStringGetCStringPtr(theString, 0x8000100u))
  {
    if (!_SC_LOG_DEFAULT_log)
      _SC_LOG_DEFAULT_log = (uint64_t)os_log_create("com.apple.SystemConfiguration", "");
    os_log_with_args();
  }
  if (v11 >= 2)
    goto LABEL_12;
}

uint64_t __updateServerPort_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = _sc_server;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = _sc_server;
  if ((_DWORD)result)
  {
    if (**(_DWORD **)(a1 + 40) == (_DWORD)result)
    {
      _sc_server = __SCDynamicStoreServerPort(*(kern_return_t **)(a1 + 56), 1);
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      result = _sc_server;
    }
  }
  else
  {
    result = __SCDynamicStoreServerPort(*(kern_return_t **)(a1 + 56), 0);
    _sc_server = result;
  }
  **(_DWORD **)(a1 + 40) = result;
  return result;
}

uint64_t __SCDynamicStoreServerPort(kern_return_t *a1, int a2)
{
  __int128 v4;
  uint64_t result;
  unsigned int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  _DWORD *v18;
  int v19;
  int v20;
  NSObject *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  const char *v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  const char *v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  __int128 v59;
  __int128 v60;
  unsigned int v61;
  unsigned int v62;
  int v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v62 = 0;
  if (getenv("SCD_SERVER"))
  {
    result = 0;
    *a1 = 1102;
  }
  else
  {
    v6 = 0;
    *(_QWORD *)&v4 = 67109120;
    v59 = v4;
    *(_QWORD *)&v4 = 67109378;
    v60 = v4;
    while (1)
    {
      if (xpc_user_sessions_enabled())
      {
        v63 = 0;
        if (xpc_user_sessions_get_foreground_uid() == -101)
        {
          v7 = __log_SCDynamicStore_log;
          if (!__log_SCDynamicStore_log)
          {
            v7 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
            __log_SCDynamicStore_log = (uint64_t)v7;
          }
          v8 = _SC_syslog_os_log_mapping(3);
          if (__SC_log_enabled(3, v7, (os_log_type_t)v8))
          {
            v9 = _os_log_pack_size();
            v17 = (char *)&v59
                - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v18 = (_DWORD *)_os_log_pack_fill();
            v19 = v63;
            *v18 = v59;
            v18[1] = v19;
            __SC_log_send(3, (uint64_t)v7, v8, v17);
          }
          v20 = 1102;
        }
        else
        {
          v20 = bootstrap_look_up_per_user();
        }
      }
      else
      {
        v20 = bootstrap_look_up2();
      }
      *a1 = v20;
      if (v20 != 1102)
        break;
      v63 = 0;
      if (get_sysctl_val("kern.willshutdown", &v63) && v63 || get_sysctl_val("kern.willuserspacereboot", &v63) && v63)
      {
        v48 = __log_SCDynamicStore_log;
        if (!__log_SCDynamicStore_log)
        {
          v48 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
          __log_SCDynamicStore_log = (uint64_t)v48;
        }
        v49 = _SC_syslog_os_log_mapping(6);
        result = __SC_log_enabled(6, v48, (os_log_type_t)v49);
        if ((_DWORD)result)
        {
          v50 = _os_log_pack_size();
          v58 = (char *)&v59
              - ((MEMORY[0x1E0C80A78](v50, v51, v52, v53, v54, v55, v56, v57) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(6, (uint64_t)v48, v49, v58);
          return 0;
        }
        return result;
      }
      if (!a2)
        return 0;
      v21 = __log_SCDynamicStore_log;
      if (!__log_SCDynamicStore_log)
      {
        v21 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
        __log_SCDynamicStore_log = (uint64_t)v21;
      }
      v22 = v6 >= 3 ? 3 : 6;
      v23 = _SC_syslog_os_log_mapping(v22);
      if (__SC_log_enabled(v22, v21, (os_log_type_t)v23))
      {
        v24 = _os_log_pack_size();
        v61 = v6;
        v32 = (char *)&v59 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v33 = _os_log_pack_fill();
        v34 = bootstrap_strerror(*a1);
        *(_DWORD *)v33 = v60;
        *(_DWORD *)(v33 + 4) = v6 + 1;
        *(_WORD *)(v33 + 8) = 2080;
        *(_QWORD *)(v33 + 10) = v34;
        __SC_log_send(v22, (uint64_t)v21, v23, v32);
        v6 = v61;
      }
      if (v6 == 3)
        return 0;
      usleep(0xC350u);
      ++v6;
    }
    if (v20)
      return 0;
    if (v6)
    {
      v35 = __log_SCDynamicStore_log;
      if (!__log_SCDynamicStore_log)
      {
        v35 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
        __log_SCDynamicStore_log = (uint64_t)v35;
      }
      v36 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v35, (os_log_type_t)v36))
      {
        v37 = _os_log_pack_size();
        v45 = (char *)&v59 - ((MEMORY[0x1E0C80A78](v37, v38, v39, v40, v41, v42, v43, v44) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v46 = _os_log_pack_fill();
        v47 = "ies";
        if (v6 == 1)
          v47 = "y";
        *(_DWORD *)v46 = v60;
        *(_DWORD *)(v46 + 4) = v6;
        *(_WORD *)(v46 + 8) = 2080;
        *(_QWORD *)(v46 + 10) = v47;
        __SC_log_send(6, (uint64_t)v35, v36, v45);
      }
    }
    return v62;
  }
  return result;
}

void SCPreferencesSynchronize(SCPreferencesRef prefs)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  mach_port_t v16;
  const void *v17;
  const void *v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (__SCPreferencesInitialize_initialized == -1)
  {
    if (!prefs)
    {
LABEL_19:
      _SCErrorSet(3001);
      return;
    }
  }
  else
  {
    dispatch_once(&__SCPreferencesInitialize_initialized, &__block_literal_global_48);
    if (!prefs)
      goto LABEL_19;
  }
  v2 = __kSCPreferencesTypeID;
  if (CFGetTypeID(prefs) != v2)
    goto LABEL_19;
  v3 = __log_SCPreferences_log;
  if (!__log_SCPreferences_log)
  {
    v3 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
    __log_SCPreferences_log = (uint64_t)v3;
  }
  v4 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v3, (os_log_type_t)v4))
  {
    v5 = _os_log_pack_size();
    v13 = (char *)&v19 - ((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v14 = _os_log_pack_fill();
    v15 = *((_QWORD *)prefs + 13);
    *(_DWORD *)v14 = 136315138;
    *(_QWORD *)(v14 + 4) = v15;
    __SC_log_send(7, (uint64_t)v3, v4, v13);
  }
  if (*((_QWORD *)prefs + 39))
  {
    HIDWORD(v19) = 0;
    v16 = *((_DWORD *)prefs + 80);
    if (v16)
    {
      if (!_SCHelperExec(v16, 108, 0, (_DWORD *)&v19 + 1, 0) && *((_DWORD *)prefs + 80))
        _SCHelperClose((mach_port_t *)prefs + 80);
    }
  }
  v17 = (const void *)*((_QWORD *)prefs + 35);
  if (v17)
  {
    CFRelease(v17);
    *((_QWORD *)prefs + 35) = 0;
  }
  v18 = (const void *)*((_QWORD *)prefs + 18);
  if (v18)
  {
    CFRelease(v18);
    *((_QWORD *)prefs + 18) = 0;
  }
  *((_WORD *)prefs + 152) = 0;
}

BOOL _SCSerializeData(const void *a1, vm_address_t *a2, vm_size_t *a3)
{
  CFTypeID TypeID;
  mach_error_t v7;
  mach_error_t v8;
  NSObject *v9;
  uint64_t v10;
  _BOOL8 result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  TypeID = CFDataGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
    return 0;
  v7 = __CFDataCopyVMData((const __CFData *)a1, a2, a3);
  if (!v7)
    return 1;
  v8 = v7;
  v9 = _SC_LOG_DEFAULT();
  v10 = _SC_syslog_os_log_mapping(5);
  result = __SC_log_enabled(5, v9, (os_log_type_t)v10);
  if (result)
  {
    v12 = _os_log_pack_size();
    v20 = (char *)v23 - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v21 = _os_log_pack_fill();
    v22 = mach_error_string(v8);
    *(_DWORD *)v21 = 136315138;
    *(_QWORD *)(v21 + 4) = v22;
    __SC_log_send(5, (uint64_t)v9, v10, v20);
    return 0;
  }
  return result;
}

uint64_t __CFDataCopyVMData(const __CFData *a1, vm_address_t *a2, vm_size_t *a3)
{
  vm_size_t Length;
  uint64_t v7;
  vm_address_t v8;
  void *v9;
  const UInt8 *BytePtr;
  vm_address_t v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v12[0] = (vm_address_t)CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v7 = vm_allocate(*MEMORY[0x1E0C83DA0], v12, Length, 1);
  if ((_DWORD)v7)
  {
    v8 = 0;
    Length = 0;
  }
  else
  {
    v9 = (void *)v12[0];
    BytePtr = CFDataGetBytePtr(a1);
    memcpy(v9, BytePtr, Length);
    v8 = v12[0];
  }
  *a2 = v8;
  *a3 = Length;
  return v7;
}

void __SCDynamicStoreDeallocate(uint64_t a1)
{
  mach_port_name_t v2;
  void (*v3)(_QWORD);
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  NSObject *v8;
  _QWORD block[5];
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  pthread_setcanceltype(2, &v10);
  if (*(_QWORD *)(a1 + 144))
    _SC_crash("SCDynamicStore OVER-RELEASED (notification still active)", 0, 0);
  if (*(_QWORD *)(a1 + 16))
  {
    if (storeQueue_once != -1)
      dispatch_once(&storeQueue_once, &__block_literal_global_3);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ____SCDynamicStoreDeallocate_block_invoke;
    block[3] = &__block_descriptor_tmp_53;
    block[4] = a1;
    dispatch_sync((dispatch_queue_t)storeQueue_q, block);
  }
  SCDynamicStoreNotifyCancel(a1);
  v2 = *(_DWORD *)(a1 + 40);
  if (v2)
  {
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v2);
    *(_DWORD *)(a1 + 40) = 0;
  }
  pthread_setcanceltype(0, &v10);
  pthread_testcancel();
  v3 = *(void (**)(_QWORD))(a1 + 104);
  if (v3)
    v3(*(_QWORD *)(a1 + 88));
  v4 = *(const void **)(a1 + 168);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 176);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 24);
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(a1 + 32);
  if (v7)
    CFRelease(v7);
  if (*(_BYTE *)(a1 + 200))
    _SCDynamicStoreCacheClose(a1);
  v8 = *(NSObject **)(a1 + 16);
  if (v8)
    dispatch_release(v8);
}

uint64_t SCDynamicStoreNotifyCancel(uint64_t a1)
{
  CFTypeID TypeID;
  int v3;
  __CFRunLoopSource *v4;
  int v5;
  uint64_t result;
  mach_port_t v7;
  uint64_t v8;
  int v9;
  mach_port_t v10;
  mach_port_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  TypeID = SCDynamicStoreGetTypeID();
  if (!a1 || CFGetTypeID((CFTypeRef)a1) != TypeID)
  {
    v5 = 2001;
LABEL_9:
    _SCErrorSet(v5);
    return 0;
  }
  v3 = *(_DWORD *)(a1 + 48);
  switch(v3)
  {
    case 0:
      return 1;
    case 5:
      SCDynamicStoreSetDispatchQueue((SCDynamicStoreRef)a1, 0);
      return 1;
    case 4:
      v4 = *(__CFRunLoopSource **)(a1 + 64);
      if (v4)
      {
        *(_QWORD *)(a1 + 64) = 0;
        CFRunLoopSourceInvalidate(v4);
        CFRelease(v4);
      }
      return 1;
  }
  v11 = 0;
  v7 = *(_DWORD *)(a1 + 40);
  if (!v7)
  {
    v10 = 2002;
    v11 = 2002;
LABEL_18:
    v5 = v10;
    goto LABEL_9;
  }
  v8 = notifycancel(v7, &v11);
  v9 = __SCDynamicStoreCheckRetryAndHandleError(a1, v8, &v11, (uint64_t)"SCDynamicStoreNotifyCancel notifycancel()");
  result = 1;
  if (!v9)
  {
    v10 = v11;
    if (v11)
      goto LABEL_18;
  }
  return result;
}

uint64_t _SCNetworkInterfaceGetIORegistryEntryID(uint64_t a1)
{
  return *(_QWORD *)(a1 + 216);
}

void __SCThreadSpecificDataFinalize(_QWORD *ptr)
{
  const void *v2;
  const void *v3;

  if (ptr)
  {
    v2 = (const void *)ptr[1];
    if (v2)
      CFRelease(v2);
    v3 = (const void *)ptr[2];
    if (v3)
      CFRelease(v3);
    CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E0C9AE30], ptr);
  }
}

Boolean SCPreferencesScheduleWithRunLoop(SCPreferencesRef prefs, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v6;
  CFTypeID v7;

  if (__SCPreferencesInitialize_initialized == -1)
  {
    if (!prefs)
      goto LABEL_8;
  }
  else
  {
    dispatch_once(&__SCPreferencesInitialize_initialized, &__block_literal_global_48);
    if (!prefs)
      goto LABEL_8;
  }
  v6 = __kSCPreferencesTypeID;
  v7 = CFGetTypeID(prefs);
  if (runLoopMode && runLoop && v7 == v6)
    return __SCPreferencesScheduleWithRunLoop((uint64_t)prefs, runLoop, runLoopMode, 0);
LABEL_8:
  _SCErrorSet(1002);
  return 0;
}

CFStringRef SCDynamicStoreCopyComputerName(SCDynamicStoreRef store, CFStringEncoding *nameEncoding)
{
  const __CFString *v4;
  const __CFDictionary *v5;
  CFTypeID TypeID;
  const __CFString *Value;
  CFTypeID v8;
  CFStringEncoding v9;
  int v10;
  int v11;
  uint64_t block;
  uint64_t v14;
  void (*v15)(uint64_t);
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (nameEncoding)
    *nameEncoding = 134217984;
  v4 = SCDynamicStoreKeyCreate(0, CFSTR("%@/%@"), CFSTR("Setup:"), CFSTR("System"));
  v5 = (const __CFDictionary *)__SCDynamicStoreCopyValueCommon((uint64_t)store, v4, 0);
  CFRelease(v4);
  if (v5)
  {
    TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(v5) == TypeID)
    {
      Value = (const __CFString *)CFDictionaryGetValue(v5, CFSTR("ComputerName"));
      v8 = CFStringGetTypeID();
      if (!Value)
      {
LABEL_12:
        v10 = 1004;
LABEL_13:
        _SCErrorSet(v10);
        CFRelease(v5);
        return Value;
      }
      if (CFGetTypeID(Value) == v8)
      {
        CFRetain(Value);
        if (SCError() == 10100)
          report_missing_entitlement("SCDynamicStoreCopyComputerName");
        if (nameEncoding)
        {
          v9 = getNameEncoding(v5);
          v10 = 0;
          *nameEncoding = v9;
        }
        else
        {
          v10 = 0;
        }
        goto LABEL_13;
      }
    }
    Value = 0;
    goto LABEL_12;
  }
  v11 = SCError();
  if (v11 == 10003)
  {
    block = MEMORY[0x1E0C809B0];
    v14 = 0x40000000;
    v15 = ___SC_crash_once_block_invoke_1;
    v16 = &__block_descriptor_tmp_9;
    v18 = 0;
    v19 = 0;
    v17 = "SCDynamicStoreCopyComputerName() access denied, missing entitlement";
    if (_SC_crash_once_once_1 == -1)
      return 0;
LABEL_23:
    dispatch_once(&_SC_crash_once_once_1, &block);
    return 0;
  }
  if (v11 == 1003)
  {
    block = MEMORY[0x1E0C809B0];
    v14 = 0x40000000;
    v15 = ___SC_crash_once_block_invoke_1;
    v16 = &__block_descriptor_tmp_9;
    v18 = 0;
    v19 = 0;
    v17 = "SCDynamicStoreCopyComputerName() access denied by policy";
    if (_SC_crash_once_once_1 == -1)
      return 0;
    goto LABEL_23;
  }
  return (CFStringRef)_SCPreferencesCopyComputerName(0, nameEncoding);
}

CFStringRef SCDynamicStoreKeyCreateComputerName(CFAllocatorRef allocator)
{
  return SCDynamicStoreKeyCreate(allocator, CFSTR("%@/%@"), CFSTR("Setup:"), CFSTR("System"));
}

CFStringRef SCDynamicStoreKeyCreate(CFAllocatorRef allocator, CFStringRef fmt, ...)
{
  va_list va;

  va_start(va, fmt);
  return CFStringCreateWithFormatAndArguments(allocator, 0, fmt, va);
}

int SCError(void)
{
  return *(_DWORD *)__SCGetThreadSpecificData();
}

SCNetworkInterfaceRef SCNetworkInterfaceGetInterface(SCNetworkInterfaceRef interface)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_6;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) == v2)
    return (SCNetworkInterfaceRef)*((_QWORD *)interface + 9);
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

CFDictionaryRef SCDynamicStoreCopyProxies(SCDynamicStoreRef store)
{
  return SCDynamicStoreCopyProxiesWithOptions(store, 0);
}

void dispatch_CFRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void dispatch_CFRelease_0(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void __SCPreferencesDeallocate(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  void *v19;
  int v20;
  void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  void (*v27)(_QWORD);
  const void *v28;
  const void *v29;
  mach_port_t v30;
  _QWORD v31[2];

  v31[1] = *MEMORY[0x1E0C80C00];
  v2 = __log_SCPreferences_log;
  if (!__log_SCPreferences_log)
  {
    v2 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
    __log_SCPreferences_log = (uint64_t)v2;
  }
  v3 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v2, (os_log_type_t)v3))
  {
    v4 = _os_log_pack_size();
    v12 = (char *)v31 - ((MEMORY[0x1E0C80A78](v4, v5, v6, v7, v8, v9, v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v13 = _os_log_pack_fill();
    *(_DWORD *)v13 = 138412290;
    *(_QWORD *)(v13 + 4) = a1;
    __SC_log_send(7, (uint64_t)v2, v3, v12);
  }
  if (*(_BYTE *)(a1 + 112))
    __SCPreferencesUpdateLockedState(a1, 0);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  v14 = *(_QWORD *)(a1 + 288);
  if (v14)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v14 + 16));
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v14 + 296), *(const void **)(a1 + 88));
    pthread_mutex_unlock((pthread_mutex_t *)(v14 + 16));
    CFRelease(*(CFTypeRef *)(a1 + 288));
  }
  v15 = *(const void **)(a1 + 296);
  if (v15)
    CFRelease(v15);
  v16 = *(const void **)(a1 + 80);
  if (v16)
    CFRelease(v16);
  v17 = *(const void **)(a1 + 88);
  if (v17)
    CFRelease(v17);
  v18 = *(const void **)(a1 + 96);
  if (v18)
    CFRelease(v18);
  v19 = *(void **)(a1 + 104);
  if (v19)
    CFAllocatorDeallocate(0, v19);
  v20 = *(_DWORD *)(a1 + 116);
  if (v20 != -1)
  {
    if (*(_QWORD *)(a1 + 120))
    {
      unlink(*(const char **)(a1 + 120));
      v20 = *(_DWORD *)(a1 + 116);
    }
    close(v20);
  }
  v21 = *(void **)(a1 + 120);
  if (v21)
    CFAllocatorDeallocate(0, v21);
  v22 = *(const void **)(a1 + 144);
  if (v22)
    CFRelease(v22);
  v23 = *(const void **)(a1 + 160);
  if (v23)
    CFRelease(v23);
  v24 = *(const void **)(a1 + 176);
  if (v24)
    CFRelease(v24);
  v25 = *(const void **)(a1 + 184);
  if (v25)
    CFRelease(v25);
  v26 = *(const void **)(a1 + 192);
  if (v26)
    CFRelease(v26);
  v27 = *(void (**)(_QWORD))(a1 + 248);
  if (v27)
    v27(*(_QWORD *)(a1 + 232));
  v28 = *(const void **)(a1 + 280);
  if (v28)
    CFRelease(v28);
  v29 = *(const void **)(a1 + 312);
  if (v29)
    CFRelease(v29);
  v30 = *(_DWORD *)(a1 + 320);
  if (v30)
  {
    _SCHelperExec(v30, 107, 0, 0, 0);
    _SCHelperClose((mach_port_t *)(a1 + 320));
  }
}

Boolean SCDynamicStoreSetValue(SCDynamicStoreRef store, CFStringRef key, CFPropertyListRef value)
{
  uint64_t v5;
  const __CFArray *v6;
  CFIndex FirstIndexOfValue;
  __CFDictionary *Mutable;
  Boolean v9;
  uint64_t v10;
  int v11;
  uint64_t v13;
  vm_size_t v14;
  uint64_t v15;
  CFTypeRef v16;
  vm_size_t v17;
  uint64_t v18;
  CFTypeRef cf;
  uint64_t v20[2];
  CFRange v21;

  v20[1] = *MEMORY[0x1E0C80C00];
  v20[0] = (uint64_t)store;
  v18 = 0;
  cf = 0;
  v16 = 0;
  v17 = 0;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  if (!__SCDynamicStoreNormalize((uint64_t)v20, 1))
    return 0;
  v5 = v20[0];
  if (!*(_BYTE *)(v20[0] + 200))
  {
    if (_SCSerializeString(key, (CFDataRef *)&cf, (vm_address_t *)&v18, &v17))
    {
      if (_SCSerialize(value, (CFDataRef *)&v16, (vm_address_t *)&v15, &v14))
      {
        do
          v10 = configset(*(_DWORD *)(v5 + 40), v18, v17, v15, v14, 0, (int *)&v13, (_DWORD *)&v13 + 1);
        while (__SCDynamicStoreCheckRetryAndHandleError(v20[0], v10, (_DWORD *)&v13 + 1, (uint64_t)"SCDynamicStoreSetValue configset()"));
        CFRelease(cf);
        CFRelease(v16);
        v9 = 1;
        v11 = __SCDynamicStoreMapInternalStatus(HIDWORD(v13), 1);
        HIDWORD(v13) = v11;
        if (!v11)
          return v9;
        goto LABEL_16;
      }
      CFRelease(cf);
    }
    v11 = 1002;
LABEL_16:
    _SCErrorSet(v11);
    return 0;
  }
  v6 = *(const __CFArray **)(v20[0] + 224);
  if (v6)
  {
    v21.length = CFArrayGetCount(*(CFArrayRef *)(v20[0] + 224));
    v21.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v6, v21, key);
    if (FirstIndexOfValue != -1)
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v5 + 224), FirstIndexOfValue);
  }
  Mutable = *(__CFDictionary **)(v5 + 216);
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)(v5 + 216) = Mutable;
  }
  CFDictionarySetValue(Mutable, key, value);
  return 1;
}

uint64_t configset(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int a6, int *a7, _DWORD *a8)
{
  mach_port_t special_reply_port;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  int v16;
  mach_msg_header_t msg;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v18 = 2;
  v19 = a2;
  v20 = 16777472;
  v21 = a3;
  v22 = a4;
  v23 = 16777472;
  v24 = a5;
  v25 = *MEMORY[0x1E0C804E8];
  v26 = a3;
  v27 = a5;
  v28 = a6;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4E2B00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v12 = mach_msg(&msg, 3162115, 0x50u, 0x34u, special_reply_port, 0, 0);
  v13 = v12;
  if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v12)
    {
      if (msg.msgh_id == 71)
      {
        v13 = 4294966988;
      }
      else if (msg.msgh_id == 20111)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 44)
          {
            if (!msg.msgh_remote_port)
            {
              v13 = HIDWORD(v19);
              if (!HIDWORD(v19))
              {
                v16 = v21;
                *a7 = v20;
                *a8 = v16;
                return v13;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v14 = 1;
            else
              v14 = HIDWORD(v19) == 0;
            if (v14)
              v13 = 4294966996;
            else
              v13 = HIDWORD(v19);
            goto LABEL_22;
          }
        }
        v13 = 4294966996;
      }
      else
      {
        v13 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v13;
    }
    mig_dealloc_special_reply_port();
  }
  return v13;
}

uint64_t SCDynamicStoreAddWatchedKey(uint64_t a1, __CFString *a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  __CFArray **v9;
  int v10;
  vm_size_t v11;
  uint64_t v12;
  CFTypeRef cf;
  uint64_t v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  cf = 0;
  v14[0] = a1;
  v11 = 0;
  v12 = 0;
  v10 = 0;
  result = __SCDynamicStoreNormalize((uint64_t)v14, 0);
  if (!(_DWORD)result)
    return result;
  if (!_SCSerializeString(a2, (CFDataRef *)&cf, (vm_address_t *)&v12, &v11))
  {
    v8 = 1001;
LABEL_8:
    _SCErrorSet(v8);
    return 0;
  }
  do
    v7 = notifyadd(*(_DWORD *)(a1 + 40), v12, v11, a3, &v10);
  while (__SCDynamicStoreCheckRetryAndHandleError(v14[0], v7, &v10, (uint64_t)"SCDynamicStoreAddWatchedKey notifyadd()"));
  CFRelease(cf);
  v8 = v10;
  if (v10)
    goto LABEL_8;
  if (a3)
    v9 = (__CFArray **)(a1 + 176);
  else
    v9 = (__CFArray **)(a1 + 168);
  addKey(v9, a2);
  return 1;
}

uint64_t notifyadd(mach_port_t a1, uint64_t a2, int a3, int a4, int *a5)
{
  mach_port_t special_reply_port;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  mach_msg_header_t msg;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v13 = 1;
  v14 = a2;
  v15 = 16777472;
  v16 = a3;
  v17 = *MEMORY[0x1E0C804E8];
  v18 = a3;
  v19 = a4;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4E3200000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v8 = mach_msg(&msg, 3162115, 0x3Cu, 0x30u, special_reply_port, 0, 0);
  v9 = v8;
  if ((v8 - 268435458) > 0xE || ((1 << (v8 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v8)
    {
      if (msg.msgh_id == 71)
      {
        v9 = 4294966988;
      }
      else if (msg.msgh_id == 20118)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 40)
          {
            if (!msg.msgh_remote_port)
            {
              v9 = HIDWORD(v14);
              if (!HIDWORD(v14))
              {
                *a5 = v15;
                return v9;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v10 = 1;
            else
              v10 = HIDWORD(v14) == 0;
            if (v10)
              v9 = 4294966996;
            else
              v9 = HIDWORD(v14);
            goto LABEL_22;
          }
        }
        v9 = 4294966996;
      }
      else
      {
        v9 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v9;
    }
    mig_dealloc_special_reply_port();
  }
  return v9;
}

void addKey(__CFArray **a1, void *value)
{
  __CFArray *Mutable;

  Mutable = *a1;
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    *a1 = Mutable;
  }
  CFArrayAppendValue(Mutable, value);
}

__CFString *__SCNetworkReachabilityCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  pthread_mutex_t *v3;
  __CFString *Mutable;
  const __CFAllocator *v5;
  CFMutableStringRef v6;
  unsigned int v7;
  NSObject *v8;
  const sockaddr *v9;
  NSObject *v10;
  const sockaddr *address;
  NSObject *v12;
  const sockaddr *v13;
  const char *v14;
  const char *v15;
  uint64_t required_interface_index;
  int v17;
  const char *v18;
  const __CFAllocator *v19;
  uint64_t FlagsFromPath;
  uint64_t interface_index;
  CFStringRef v22;
  uint64_t v24;
  const char *hostname;
  uint64_t v26;
  _BYTE v27[64];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator((CFTypeRef)a1);
  v3 = (pthread_mutex_t *)(a1 + 16);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 16)))
    __SCNetworkReachabilityCopyDescription_cold_2();
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCNetworkReachability %p [%p]> {"), a1, v2);
  v5 = CFGetAllocator((CFTypeRef)a1);
  v6 = CFStringCreateMutable(v5, 0);
  v7 = *(_DWORD *)(a1 + 80);
  if (v7 < 2)
  {
    v10 = *(NSObject **)(a1 + 96);
    if (v10)
    {
      address = nw_endpoint_get_address(v10);
      _SC_sockaddr_to_string((uint64_t)address, v27, 0x40uLL);
      CFStringAppendFormat(v6, 0, CFSTR("local address = %s"), v27);
    }
    v12 = *(NSObject **)(a1 + 104);
    if (v12)
    {
      v13 = nw_endpoint_get_address(v12);
      _SC_sockaddr_to_string((uint64_t)v13, v27, 0x40uLL);
      if (*(_QWORD *)(a1 + 96))
        v14 = ", ";
      else
        v14 = "";
      if (*(_DWORD *)(a1 + 80) == 1)
        v15 = "remote ";
      else
        v15 = "";
      CFStringAppendFormat(v6, 0, CFSTR("%s%saddress = %s"), v14, v15, v27);
    }
    else
    {
      CFStringAppendFormat(v6, 0, CFSTR("default path"), v24, v26);
    }
  }
  else if (v7 == 2)
  {
    hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 88));
    CFStringAppendFormat(v6, 0, CFSTR("name = %s"), hostname, v26);
  }
  else if (v7 == 3)
  {
    v8 = *(NSObject **)(a1 + 104);
    if (v8)
    {
      v9 = nw_endpoint_get_address(v8);
      _SC_sockaddr_to_string((uint64_t)v9, v27, 0x40uLL);
      CFStringAppendFormat(v6, 0, CFSTR("ptr = %s"), v27, v26);
    }
  }
  if (*(_QWORD *)(a1 + 232))
  {
    required_interface_index = nw_parameters_get_required_interface_index();
    if ((_DWORD)required_interface_index)
      CFStringAppendFormat(v6, 0, CFSTR(", if_index = %u"), required_interface_index);
  }
  CFStringAppend(Mutable, v6);
  CFRelease(v6);
  if (*(_DWORD *)(a1 + 80) >= 2u)
  {
    v17 = *(_DWORD *)(a1 + 272);
    if (*(_QWORD *)(a1 + 264))
    {
      if (!v17)
      {
        CFStringAppendFormat(Mutable, 0, CFSTR(" (DNS query active)"));
        goto LABEL_34;
      }
    }
    else if (!v17)
    {
      goto LABEL_34;
    }
    if (v17 == 2)
      v18 = "complete";
    else
      v18 = "in progress";
    CFStringAppendFormat(Mutable, 0, CFSTR(" (%s"), v18);
    if (nw_array_get_count())
      nw_array_apply();
    else
      CFStringAppendFormat(Mutable, 0, CFSTR(", no addresses"));
    CFStringAppendFormat(Mutable, 0, CFSTR(")"));
  }
LABEL_34:
  if (*(_BYTE *)(a1 + 192))
    CFStringAppendFormat(Mutable, 0, CFSTR(", !resolve"));
  if (*(_BYTE *)(a1 + 112))
  {
    v19 = CFGetAllocator((CFTypeRef)a1);
    FlagsFromPath = __SCNetworkReachabilityGetFlagsFromPath(a1 + 193, (uint64_t)"CopyTargetFlags", *(nw_path_t *)(a1 + 248), *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 272), *(_QWORD *)(a1 + 280), *(unsigned __int8 *)(a1 + 288), *(_DWORD *)(a1 + 292));
    if (*(_BYTE *)(a1 + 288))
      interface_index = *(unsigned int *)(a1 + 296);
    else
      interface_index = nw_path_get_interface_index();
    v22 = CFStringCreateWithFormat(v19, 0, CFSTR("flags = 0x%08x, if_index = %u"), FlagsFromPath, interface_index);
    CFStringAppendFormat(Mutable, 0, CFSTR(", %@"), v22);
    CFRelease(v22);
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  if (pthread_mutex_unlock(v3))
    __SCNetworkReachabilityCopyDescription_cold_1();
  return Mutable;
}

uint64_t __SCPreferencesUnscheduleFromRunLoop(uint64_t a1, void *a2, const __CFString *a3)
{
  pthread_mutex_t *v6;
  _QWORD *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  CFArrayRef v19;
  uint64_t v20;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  v6 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (!a2)
  {
    if (*(_QWORD *)(a1 + 272))
    {
      v7 = (_QWORD *)(a1 + 272);
      SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 152), 0);
      dispatch_release(*(dispatch_object_t *)(a1 + 272));
LABEL_10:
      *v7 = 0;
      v8 = __log_SCPreferences_log;
      if (!__log_SCPreferences_log)
      {
        v8 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
        __log_SCPreferences_log = (uint64_t)v8;
      }
      v9 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v8, (os_log_type_t)v9))
      {
        v10 = _os_log_pack_size();
        v18 = (char *)v22 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(7, (uint64_t)v8, v9, v18);
      }
      *(_BYTE *)(a1 + 200) = 0;
      SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(a1 + 152), 0, 0);
      v19 = SCDynamicStoreCopyNotifiedKeys(*(SCDynamicStoreRef *)(a1 + 152));
      if (v19)
        CFRelease(v19);
      __SCPreferencesRemoveSession(a1);
      goto LABEL_17;
    }
LABEL_18:
    _SCErrorSet(1002);
    v20 = 0;
    goto LABEL_19;
  }
  if (!*(_BYTE *)(a1 + 200)
    || *(_QWORD *)(a1 + 272)
    || !_SC_unschedule((const void *)a1, a2, a3, *(CFArrayRef *)(a1 + 264), 0))
  {
    goto LABEL_18;
  }
  if (!CFArrayGetCount(*(CFArrayRef *)(a1 + 264)))
  {
    v7 = (_QWORD *)(a1 + 208);
    CFRunLoopRemoveSource((CFRunLoopRef)a2, *(CFRunLoopSourceRef *)(a1 + 208), a3);
    CFRelease(*(CFTypeRef *)(a1 + 264));
    *(_QWORD *)(a1 + 264) = 0;
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(a1 + 208));
    CFRelease(*(CFTypeRef *)(a1 + 208));
    goto LABEL_10;
  }
  if (!_SC_isScheduled(0, a2, a3, *(CFArrayRef *)(a1 + 264)))
    CFRunLoopRemoveSource((CFRunLoopRef)a2, *(CFRunLoopSourceRef *)(a1 + 208), a3);
LABEL_17:
  v20 = 1;
LABEL_19:
  pthread_mutex_unlock(v6);
  return v20;
}

void __SCPreferencesRemoveSession(uint64_t a1)
{
  int v1;
  BOOL v2;
  int v3;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v1 = *(_DWORD *)(a1 + 168);
  v2 = __OFSUB__(v1, 1);
  v3 = v1 - 1;
  if (v3 < 0 == v2)
  {
    *(_DWORD *)(a1 + 168) = v3;
    if (!v3)
    {
      CFRelease(*(CFTypeRef *)(a1 + 152));
      *(_QWORD *)(a1 + 152) = 0;
      v5 = __log_SCPreferences_log;
      if (!__log_SCPreferences_log)
      {
        v5 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
        __log_SCPreferences_log = (uint64_t)v5;
      }
      v6 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v5, (os_log_type_t)v6))
      {
        v7 = _os_log_pack_size();
        v15 = (char *)v16 - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(7, (uint64_t)v5, v6, v15);
      }
    }
  }
}

CFArrayRef SCDynamicStoreCopyNotifiedKeys(SCDynamicStoreRef store)
{
  uint64_t v2;
  int v3;
  const __CFArray *v5;
  CFIndex length;
  UInt8 *bytes;
  uint64_t v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  bytes = 0;
  v8[0] = (uint64_t)store;
  v5 = 0;
  length = 0;
  if (__SCDynamicStoreNormalize((uint64_t)v8, 0))
  {
    do
      v2 = notifychanges(*((_DWORD *)store + 10), &bytes, (_DWORD *)&length + 1, &length);
    while (__SCDynamicStoreCheckRetryAndHandleError(v8[0], v2, &length, (uint64_t)"SCDynamicStoreCopyNotifiedKeys notifychanges()"));
    v3 = length;
    if ((_DWORD)length)
    {
      if (bytes)
      {
        MEMORY[0x18D78D14C](*MEMORY[0x1E0C83DA0], bytes, HIDWORD(length));
        v3 = length;
      }
    }
    else
    {
      if (_SCUnserialize((CFPropertyListRef *)&v5, 0, bytes, HIDWORD(length)))
        return v5;
      v3 = 1001;
    }
    _SCErrorSet(v3);
  }
  return 0;
}

uint64_t notifychanges(int a1, _QWORD *a2, _DWORD *a3, _DWORD *a4)
{
  mach_port_name_t special_reply_port;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _BYTE msg[36];
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v15 = 0u;
  v14 = 0u;
  *(_OWORD *)&msg[20] = 0u;
  *(_DWORD *)&msg[4] = 0;
  special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)msg = 5395;
  *(_QWORD *)&msg[16] = 0x4E3400000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    special_reply_port = *(_DWORD *)&msg[12];
  }
  v9 = mach_msg((mach_msg_header_t *)msg, 3162115, 0x18u, 0x44u, special_reply_port, 0, 0);
  v10 = v9;
  if ((v9 - 268435458) > 0xE || ((1 << (v9 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v9)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v10 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 20120)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 36)
          {
            v10 = 4294966996;
            if (*(_DWORD *)&msg[32])
            {
              if (*(_DWORD *)&msg[8])
                v10 = 4294966996;
              else
                v10 = *(unsigned int *)&msg[32];
            }
          }
          else
          {
            v10 = 4294966996;
          }
          goto LABEL_24;
        }
        v10 = 4294966996;
        if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 60 && !*(_DWORD *)&msg[8] && BYTE3(v14) == 1)
        {
          v11 = DWORD1(v14);
          if (DWORD1(v14) == (_DWORD)v15)
          {
            v10 = 0;
            *a2 = *(_QWORD *)&msg[28];
            *a3 = v11;
            *a4 = DWORD1(v15);
            return v10;
          }
        }
      }
      else
      {
        v10 = 4294966995;
      }
LABEL_24:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v10;
    }
    mig_dealloc_special_reply_port();
  }
  return v10;
}

_DWORD *__add_state_handler_block_invoke()
{
  uint64_t v0;
  uint64_t v1;
  CFIndex Count;
  _DWORD *v3;
  CFMutableDictionaryRef Mutable;
  _BOOL4 v6;
  int64_t v7;
  size_t v8;
  CFIndex Length;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  CFDataRef v22;
  _DWORD *v23;
  const UInt8 *BytePtr;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  CFDataRef v37[2];

  v37[1] = *(CFDataRef *)MEMORY[0x1E0C80C00];
  v37[0] = 0;
  v0 = _sc_store_max;
  if (_sc_store_advise)
    v1 = _sc_store_advise;
  else
    v1 = 25;
  Count = CFSetGetCount((CFSetRef)_sc_store_sessions);
  v3 = 0;
  if ((v0 & 0x8000000000000000) == 0 && Count && Count >= v1)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFSetApplyFunction((CFSetRef)_sc_store_sessions, (CFSetApplierFunction)addSessionReference, Mutable);
    if (!CFDictionaryGetCount(Mutable))
    {
      v22 = Mutable;
      goto LABEL_29;
    }
    v6 = _SCSerialize(Mutable, v37, 0, 0);
    CFRelease(Mutable);
    v7 = 0;
    v8 = 200;
    if (v6 && v37[0])
    {
      Length = CFDataGetLength(v37[0]);
      v8 = Length + 200;
      if ((unint64_t)(Length + 200) > 0x8000)
      {
        v10 = __log_SCDynamicStore_log;
        if (!__log_SCDynamicStore_log)
        {
          v10 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
          __log_SCDynamicStore_log = (uint64_t)v10;
        }
        v11 = _SC_syslog_os_log_mapping(3);
        if (__SC_log_enabled(3, v10, (os_log_type_t)v11))
        {
          v12 = _os_log_pack_size();
          v20 = (char *)v37
              - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v21 = _os_log_pack_fill();
          *(_DWORD *)v21 = 134218240;
          *(_QWORD *)(v21 + 4) = v8;
          *(_WORD *)(v21 + 12) = 2048;
          *(_QWORD *)(v21 + 14) = 0x8000;
          __SC_log_send(3, (uint64_t)v10, v11, v20);
        }
        goto LABEL_28;
      }
      v7 = Length;
    }
    v23 = malloc_type_calloc(1uLL, v8, 0x9DA70040uLL);
    if (!v23)
    {
      v25 = __log_SCDynamicStore_log;
      if (!__log_SCDynamicStore_log)
      {
        v25 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
        __log_SCDynamicStore_log = (uint64_t)v25;
      }
      v26 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v25, (os_log_type_t)v26))
      {
        v27 = _os_log_pack_size();
        v35 = (char *)v37 - ((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(3, (uint64_t)v25, v26, v35);
      }
LABEL_28:
      v22 = v37[0];
      if (!v37[0])
        return 0;
LABEL_29:
      CFRelease(v22);
      return 0;
    }
    v3 = v23;
    *v23 = 1;
    v23[1] = v7;
    __strlcpy_chk();
    if (v7 >= 1)
    {
      BytePtr = CFDataGetBytePtr(v37[0]);
      memcpy(v3 + 50, BytePtr, v7);
    }
    if (v37[0])
      CFRelease(v37[0]);
  }
  return v3;
}

CFNumberRef update_ift_family(CFNumberRef interface)
{
  CFNumberRef v1;
  const __CFString *BSDName;
  int v3;
  int v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)interface + 33))
  {
    v1 = interface;
    if (!*((_QWORD *)interface + 34))
    {
      BSDName = SCNetworkInterfaceGetBSDName(interface);
      v5 = 0u;
      v6 = 0u;
      if (BSDName)
      {
        if (_SC_cfstring_to_cstring(BSDName, (UInt8 *)&v5, 16, 0x600u))
        {
          v3 = socket(2, 2, 0);
          if (v3 != -1)
          {
            v4 = v3;
            if (ioctl(v3, 0xC020699FuLL, &v5) == -1)
              *(_QWORD *)((char *)&v6 + 4) = 0;
            close(v4);
          }
        }
      }
      *((_QWORD *)v1 + 33) = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&v6 + 4);
      interface = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&v6 + 8);
      *((_QWORD *)v1 + 34) = interface;
    }
  }
  return interface;
}

uint64_t configset_m(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, int *a8)
{
  mach_port_t special_reply_port;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  mach_msg_header_t msg;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v16 = 3;
  v17 = a2;
  v18 = 16777472;
  v19 = a3;
  v20 = a4;
  v21 = 16777472;
  v22 = a5;
  v23 = a6;
  v24 = 16777472;
  v25 = a7;
  v26 = *MEMORY[0x1E0C804E8];
  v27 = a3;
  v28 = a5;
  v29 = a7;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4E3100000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v11 = mach_msg(&msg, 3162115, 0x60u, 0x30u, special_reply_port, 0, 0);
  v12 = v11;
  if ((v11 - 268435458) > 0xE || ((1 << (v11 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v11)
    {
      if (msg.msgh_id == 71)
      {
        v12 = 4294966988;
      }
      else if (msg.msgh_id == 20117)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 40)
          {
            if (!msg.msgh_remote_port)
            {
              v12 = HIDWORD(v17);
              if (!HIDWORD(v17))
              {
                *a8 = v18;
                return v12;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v13 = 1;
            else
              v13 = HIDWORD(v17) == 0;
            if (v13)
              v12 = 4294966996;
            else
              v12 = HIDWORD(v17);
            goto LABEL_22;
          }
        }
        v12 = 4294966996;
      }
      else
      {
        v12 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v12;
    }
    mig_dealloc_special_reply_port();
  }
  return v12;
}

uint64_t configget_m(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, _QWORD *a6, _DWORD *a7, _DWORD *a8)
{
  mach_port_t special_reply_port;
  uint64_t v13;
  uint64_t v14;
  int v15;
  mach_msg_header_t msg;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v18 = 2;
  v19 = a2;
  v20 = 16777472;
  v21 = a3;
  v22 = a4;
  v23 = 16777472;
  v24 = a5;
  v25 = *MEMORY[0x1E0C804E8];
  v26 = a3;
  v27 = a5;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4E3000000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v13 = mach_msg(&msg, 3162115, 0x4Cu, 0x44u, special_reply_port, 0, 0);
  v14 = v13;
  if ((v13 - 268435458) > 0xE || ((1 << (v13 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v13)
    {
      if (msg.msgh_id == 71)
      {
        v14 = 4294966988;
      }
      else if (msg.msgh_id == 20116)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            v14 = 4294966996;
            if (HIDWORD(v19))
            {
              if (msg.msgh_remote_port)
                v14 = 4294966996;
              else
                v14 = HIDWORD(v19);
            }
          }
          else
          {
            v14 = 4294966996;
          }
          goto LABEL_24;
        }
        v14 = 4294966996;
        if (v18 == 1 && msg.msgh_size == 60 && !msg.msgh_remote_port && HIBYTE(v20) == 1)
        {
          v15 = v21;
          if (v21 == v23)
          {
            v14 = 0;
            *a6 = v19;
            *a7 = v15;
            *a8 = v24;
            return v14;
          }
        }
      }
      else
      {
        v14 = 4294966995;
      }
LABEL_24:
      mach_msg_destroy(&msg);
      return v14;
    }
    mig_dealloc_special_reply_port();
  }
  return v14;
}

os_log_t __log_SCPreferences()
{
  os_log_t result;

  result = (os_log_t)__log_SCPreferences_log;
  if (!__log_SCPreferences_log)
  {
    result = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
    __log_SCPreferences_log = (uint64_t)result;
  }
  return result;
}

void __SCPreferencesUpdateLockedState(uint64_t a1, char a2)
{
  _QWORD block[5];
  char v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (__SCPreferencesUpdateLockedState_once != -1)
    dispatch_once(&__SCPreferencesUpdateLockedState_once, &__block_literal_global_4);
  *(_BYTE *)(a1 + 112) = a2;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ____SCPreferencesUpdateLockedState_block_invoke_32;
  block[3] = &__block_descriptor_tmp_33;
  v5 = a2;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)__SCPreferencesUpdateLockedState_lockedQueue, block);
}

__CFString *__SCPreferencesCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  const __CFString *v4;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCPreferences %p [%p]> {"), a1, v2);
  CFStringAppendFormat(Mutable, 0, CFSTR("name = %@"), *(_QWORD *)(a1 + 80));
  v4 = *(const __CFString **)(a1 + 88);
  if (!v4)
    v4 = CFSTR("[default]");
  CFStringAppendFormat(Mutable, 0, CFSTR(", id = %@"), v4);
  CFStringAppendFormat(Mutable, 0, CFSTR(", path = %s"), *(_QWORD *)(a1 + 104));
  if (*(_BYTE *)(a1 + 304))
    CFStringAppendFormat(Mutable, 0, CFSTR(", accessed"));
  if (*(_BYTE *)(a1 + 305))
    CFStringAppendFormat(Mutable, 0, CFSTR(", changed"));
  if (*(_BYTE *)(a1 + 112))
    CFStringAppendFormat(Mutable, 0, CFSTR(", locked"));
  if (*(_DWORD *)(a1 + 320))
    CFStringAppendFormat(Mutable, 0, CFSTR(", helper port = 0x%x"), *(unsigned int *)(a1 + 320));
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  return Mutable;
}

void __SCNetworkSetDeallocate(uint64_t a1)
{
  const void *v2;

  CFRelease(*(CFTypeRef *)(a1 + 16));
  CFRelease(*(CFTypeRef *)(a1 + 24));
  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
}

uint64_t __SCNetworkSetCreatePrivate(const void *a1, const __CFString *a2)
{
  uint64_t Instance;

  if (__SCNetworkSetInitialize_initialized != -1)
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = CFStringCreateCopy(0, a2);
    *(_QWORD *)(Instance + 24) = CFRetain(a1);
  }
  return Instance;
}

__CFArray *__SCNetworkInterfaceCopyAll_IONetworkInterface(int a1)
{
  CFMutableDictionaryRef v2;
  __CFArray *MatchingInterfaces;

  v2 = IOServiceMatching("IONetworkInterface");
  MatchingInterfaces = findMatchingInterfaces(v2, (unsigned int (*)(uint64_t, uint64_t, __CFDictionary *, _QWORD, __CFDictionary *, _QWORD, __CFDictionary *))processNetworkInterface, CFSTR("HiddenInterface"), 0, a1);
  CFRelease(v2);
  return MatchingInterfaces;
}

uint64_t _SC_CFBundleGet()
{
  CFBundleRef BundleWithIdentifier;
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  size_t v15;
  size_t v16;
  int v17;
  const __CFURL *v18;
  const __CFURL *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  _BYTE v33[8];
  UInt8 v34[1024];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!_SC_CFBundleGet_bundle)
  {
    BundleWithIdentifier = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.SystemConfiguration"));
    _SC_CFBundleGet_bundle = (uint64_t)BundleWithIdentifier;
    if (BundleWithIdentifier)
    {
      CFRetain(BundleWithIdentifier);
    }
    else
    {
      v1 = _SC_LOG_DEFAULT();
      v2 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v1, (os_log_type_t)v2))
      {
        v3 = _os_log_pack_size();
        v11 = &v33[-((MEMORY[0x1E0C80A78](v3, v4, v5, v6, v7, v8, v9, v10) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v12 = _os_log_pack_fill();
        *(_DWORD *)v12 = 138412290;
        *(_QWORD *)(v12 + 4) = CFSTR("com.apple.SystemConfiguration");
        __SC_log_send(5, (uint64_t)v1, v2, v11);
      }
      v13 = getenv("DYLD_FRAMEWORK_PATH");
      if (v13)
      {
        v14 = v13;
        v15 = strlen(v13);
        if (v15)
        {
          while (v15 >= 2)
          {
            v16 = v15 - 1;
            v17 = v14[--v15];
            if (v17 != 47)
            {
              if (v16 + 1 >= 5 && !strncmp(&v14[v16 - 3], "~sym", 4uLL) && v16 + 57 <= 0x3FF)
              {
                __strlcpy_chk();
                strlcpy(&v33[v16 + 5], "~dst", 1027 - v16);
                strlcat((char *)&v34[v16 + 1], "/System/Library/Frameworks/SystemConfiguration.framework", 1023 - v16);
                v18 = CFURLCreateFromFileSystemRepresentation(0, v34, v16 + 57, 1u);
                _SC_CFBundleGet_bundle = (uint64_t)CFBundleCreate(0, v18);
                CFRelease(v18);
              }
              break;
            }
          }
        }
      }
      if (!_SC_CFBundleGet_bundle)
      {
        v19 = CFURLCreateWithFileSystemPath(0, CFSTR("/System/Library/Frameworks/SystemConfiguration.framework"), kCFURLPOSIXPathStyle, 1u);
        _SC_CFBundleGet_bundle = (uint64_t)CFBundleCreate(0, v19);
        CFRelease(v19);
        if (!_SC_CFBundleGet_bundle)
        {
          v20 = _SC_LOG_DEFAULT();
          v21 = _SC_syslog_os_log_mapping(3);
          if (__SC_log_enabled(3, v20, (os_log_type_t)v21))
          {
            v22 = _os_log_pack_size();
            v30 = &v33[-((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0)];
            __error();
            v31 = _os_log_pack_fill();
            *(_DWORD *)v31 = 138412290;
            *(_QWORD *)(v31 + 4) = CFSTR("com.apple.SystemConfiguration");
            __SC_log_send(3, (uint64_t)v20, v21, v30);
          }
        }
      }
    }
  }
  return _SC_CFBundleGet_bundle;
}

CFDictionaryRef _SCUnserializeMultiple(const __CFDictionary *a1)
{
  CFIndex Count;
  CFIndex v3;
  const void **v4;
  const void **v5;
  const void **v6;
  uint64_t v7;
  CFIndex v8;
  CFDictionaryRef v9;
  uint64_t i;
  const void *v11;
  _OWORD v13[16];
  void *values[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  void *keys[2];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  *(_OWORD *)keys = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  *(_OWORD *)values = 0u;
  v15 = 0u;
  memset(v13, 0, sizeof(v13));
  Count = CFDictionaryGetCount(a1);
  v3 = Count;
  if (Count < 1)
  {
    v5 = (const void **)v13;
    v6 = (const void **)values;
    v4 = (const void **)keys;
LABEL_9:
    v9 = CFDictionaryCreate(0, v4, v6, v3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    if ((unint64_t)Count < 0x21)
    {
      v5 = (const void **)v13;
      v6 = (const void **)values;
      v4 = (const void **)keys;
    }
    else
    {
      v4 = (const void **)CFAllocatorAllocate(0, 8 * Count, 0);
      v5 = (const void **)CFAllocatorAllocate(0, 8 * v3, 0);
      v6 = (const void **)CFAllocatorAllocate(0, 8 * v3, 0);
    }
    bzero(v6, 8 * v3);
    CFDictionaryGetKeysAndValues(a1, v4, v5);
    v7 = 0;
    v8 = v3;
    while (_SCUnserialize(&v6[v7], (const __CFData *)v5[v7], 0, 0))
    {
      ++v7;
      if (!--v8)
        goto LABEL_9;
    }
    v9 = 0;
  }
  if (v3 >= 1)
  {
    for (i = 0; i != v3; ++i)
    {
      v11 = v6[i];
      if (v11)
        CFRelease(v11);
    }
    if (v4 != (const void **)keys)
    {
      CFAllocatorDeallocate(0, v4);
      CFAllocatorDeallocate(0, v5);
      CFAllocatorDeallocate(0, v6);
    }
  }
  return v9;
}

CFDictionaryRef _SCSerializeMultiple(const __CFDictionary *a1)
{
  CFIndex Count;
  CFIndex v3;
  const void **v4;
  const void **v5;
  const void **v6;
  uint64_t v7;
  CFIndex v8;
  CFDictionaryRef v9;
  uint64_t i;
  const void *v11;
  _OWORD v13[16];
  void *values[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  void *keys[2];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  *(_OWORD *)keys = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  *(_OWORD *)values = 0u;
  v15 = 0u;
  memset(v13, 0, sizeof(v13));
  Count = CFDictionaryGetCount(a1);
  v3 = Count;
  if (Count < 1)
  {
    v5 = (const void **)v13;
    v6 = (const void **)values;
    v4 = (const void **)keys;
LABEL_9:
    v9 = CFDictionaryCreate(0, v4, v6, v3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    if ((unint64_t)Count < 0x21)
    {
      v5 = (const void **)v13;
      v6 = (const void **)values;
      v4 = (const void **)keys;
    }
    else
    {
      v4 = (const void **)CFAllocatorAllocate(0, 8 * Count, 0);
      v5 = (const void **)CFAllocatorAllocate(0, 8 * v3, 0);
      v6 = (const void **)CFAllocatorAllocate(0, 8 * v3, 0);
    }
    bzero(v6, 8 * v3);
    CFDictionaryGetKeysAndValues(a1, v4, v5);
    v7 = 0;
    v8 = v3;
    while (1)
    {
      v6[v7] = 0;
      if (!_SCSerialize(v5[v7], (CFDataRef *)&v6[v7], 0, 0))
        break;
      ++v7;
      if (!--v8)
        goto LABEL_9;
    }
    v9 = 0;
  }
  if (v3 >= 1)
  {
    for (i = 0; i != v3; ++i)
    {
      v11 = v6[i];
      if (v11)
        CFRelease(v11);
    }
    if (v4 != (const void **)keys)
    {
      CFAllocatorDeallocate(0, v4);
      CFAllocatorDeallocate(0, v5);
      CFAllocatorDeallocate(0, v6);
    }
  }
  return v9;
}

CFTypeRef _SCNetworkSetCopyUserDefinedName(CFTypeRef cf)
{
  uint64_t v2;
  const __CFString *Set;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  const void *v6;
  CFTypeID v7;

  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(cf) == v2)
  {
    Set = SCPreferencesPathKeyCreateSet(0, *((_QWORD *)cf + 2));
    Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)cf + 3), Set);
    CFRelease(Set);
    if (Value)
    {
      TypeID = CFDictionaryGetTypeID();
      if (CFGetTypeID(Value) == TypeID)
      {
        v6 = CFDictionaryGetValue(Value, CFSTR("UserDefinedName"));
        v7 = CFStringGetTypeID();
        if (v6)
        {
          if (CFGetTypeID(v6) == v7)
            return CFRetain(v6);
        }
      }
    }
  }
  return 0;
}

uint64_t _SCNetworkInterfaceGetIOInterfaceType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 248);
}

uint64_t _SCNetworkInterfaceGetFamilyType(const __CFNumber *interface)
{
  uint64_t result;

  result = *((_QWORD *)interface + 33);
  if (!result)
  {
    update_ift_family(interface);
    return *((_QWORD *)interface + 33);
  }
  return result;
}

uint64_t _SCNetworkInterfaceGetFamilySubType(const __CFNumber *interface)
{
  uint64_t result;

  result = *((_QWORD *)interface + 34);
  if (!result)
  {
    update_ift_family(interface);
    return *((_QWORD *)interface + 34);
  }
  return result;
}

CFArrayRef SCVLANInterfaceCopyAll(SCPreferencesRef prefs)
{
  void *Companion;
  const __CFString *v3;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  const __CFAllocator *v6;
  const __CFDictionary *Copy;
  _QWORD context[4];

  context[3] = *MEMORY[0x1E0C80C00];
  if (__SCPreferencesUsingDefaultPrefs((uint64_t)prefs))
    Companion = 0;
  else
    Companion = SCPreferencesCreateCompanion((uint64_t)prefs, CFSTR("NetworkInterfaces.plist"));
  context[0] = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  context[1] = Companion;
  context[2] = prefs;
  v3 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("VLAN"));
  Value = SCPreferencesPathGetValue(prefs, v3);
  CFRelease(v3);
  TypeID = CFDictionaryGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID)
  {
    v6 = CFGetAllocator(Value);
    Copy = CFDictionaryCreateCopy(v6, Value);
    CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)add_configured_interface_0, context);
    CFRelease(Copy);
  }
  if (Companion)
    CFRelease(Companion);
  return (CFArrayRef)context[0];
}

Boolean SCPreferencesUnlock(SCPreferencesRef prefs)
{
  mach_port_t v2;
  int v3;
  const void *v4;
  int v5;
  __darwin_time_t v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  timeval v23;
  __darwin_time_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!prefs)
  {
    v3 = 3001;
    goto LABEL_27;
  }
  if (!*((_BYTE *)prefs + 112))
  {
    v3 = 1007;
    goto LABEL_27;
  }
  if (!*((_QWORD *)prefs + 39))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)prefs + 16));
    v4 = (const void *)*((_QWORD *)prefs + 20);
    if (v4)
    {
      CFRelease(v4);
      *((_QWORD *)prefs + 20) = 0;
    }
    v5 = *((_DWORD *)prefs + 29);
    if (v5 != -1)
    {
      if (*((_QWORD *)prefs + 15))
      {
        unlink(*((const char **)prefs + 15));
        v5 = *((_DWORD *)prefs + 29);
      }
      close(v5);
      *((_DWORD *)prefs + 29) = -1;
    }
    v25 = 0;
    v23.tv_sec = 0;
    *(_QWORD *)&v23.tv_usec = 0;
    gettimeofday(&v23, 0);
    v6 = v23.tv_sec - *((_QWORD *)prefs + 16);
    v24 = v6;
    v7 = v23.tv_usec - *((_DWORD *)prefs + 34);
    LODWORD(v25) = v7;
    if (v7 < 0)
    {
      v24 = --v6;
      LODWORD(v25) = v7 + 1000000;
    }
    if (v6 >= 1)
      reportDelay_0((uint64_t)prefs, &v24);
    v8 = __log_SCPreferences();
    v9 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v8, (os_log_type_t)v9))
    {
      v10 = _os_log_pack_size();
      v18 = (char *)&v22 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v19 = _os_log_pack_fill();
      v20 = *((_QWORD *)prefs + 13);
      *(_DWORD *)v19 = 136315138;
      *(_QWORD *)(v19 + 4) = v20;
      __SC_log_send(7, (uint64_t)v8, v9, v18);
    }
    __SCPreferencesUpdateLockedState((uint64_t)prefs, 0);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)prefs + 16));
    return 1;
  }
  LODWORD(v24) = 0;
  v2 = *((_DWORD *)prefs + 80);
  if (!v2)
  {
LABEL_26:
    v3 = 1003;
    LODWORD(v24) = 1003;
    goto LABEL_27;
  }
  if (!_SCHelperExec(v2, 106, 0, &v24, 0))
  {
    if (*((_DWORD *)prefs + 80))
      _SCHelperClose((mach_port_t *)prefs + 80);
    goto LABEL_26;
  }
  v3 = v24;
  if (!(_DWORD)v24)
  {
    __SCPreferencesUpdateLockedState((uint64_t)prefs, 0);
    return 1;
  }
LABEL_27:
  _SCErrorSet(v3);
  return 0;
}

CFStringRef SCPreferencesPathKeyCreateSets(const __CFAllocator *a1)
{
  return CFStringCreateWithFormat(a1, 0, CFSTR("/%@"), CFSTR("Sets"));
}

CFStringRef SCPreferencesPathKeyCreateSetNetworkService(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a3)
    return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@/%@/%@"), CFSTR("Sets"), a2, CFSTR("Network"), CFSTR("Service"), a3, v5);
  else
    return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@/%@"), CFSTR("Sets"), a2, CFSTR("Network"), CFSTR("Service"), v4, v5);
}

CFStringRef SCPreferencesPathKeyCreateSetNetworkGlobalEntity(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@/%@/%@"), CFSTR("Sets"), a2, CFSTR("Network"), CFSTR("Global"), a3, *MEMORY[0x1E0C80C00]);
}

CFStringRef SCPreferencesPathKeyCreateSet(const __CFAllocator *a1, uint64_t a2)
{
  return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@"), CFSTR("Sets"), a2);
}

CFStringRef SCNetworkSetGetSetID(SCNetworkSetRef set)
{
  uint64_t v2;

  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!set)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!set)
      goto LABEL_6;
  }
  v2 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(set) == v2)
    return (CFStringRef)*((_QWORD *)set + 2);
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

CFArrayRef SCNetworkSetGetServiceOrder(SCNetworkSetRef set)
{
  uint64_t v2;
  CFArrayRef result;
  CFArrayRef v4;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  const __CFArray *v7;
  CFTypeID v8;

  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!set)
    {
LABEL_12:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!set)
      goto LABEL_12;
  }
  v2 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(set) != v2)
    goto LABEL_12;
  result = (CFArrayRef)SCPreferencesPathKeyCreateSetNetworkGlobalEntity(0, *((_QWORD *)set + 2), (uint64_t)CFSTR("IPv4"));
  if (!result)
    return result;
  v4 = result;
  Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)set + 3), (CFStringRef)result);
  CFRelease(v4);
  TypeID = CFDictionaryGetTypeID();
  if (!Value)
    return 0;
  if (CFGetTypeID(Value) != TypeID)
    return 0;
  v7 = (const __CFArray *)CFDictionaryGetValue(Value, CFSTR("ServiceOrder"));
  v8 = CFArrayGetTypeID();
  if (!v7)
    return 0;
  if (CFGetTypeID(v7) == v8)
    return v7;
  else
    return 0;
}

CFStringRef SCNetworkSetGetName(SCNetworkSetRef set)
{
  uint64_t v2;
  CFStringRef result;

  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!set)
    {
LABEL_7:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!set)
      goto LABEL_7;
  }
  v2 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(set) != v2)
    goto LABEL_7;
  result = (CFStringRef)*((_QWORD *)set + 4);
  if (!result)
  {
    result = (CFStringRef)_SCNetworkSetCopyUserDefinedName(set);
    *((_QWORD *)set + 4) = result;
  }
  return result;
}

SCNetworkSetRef SCNetworkSetCopyCurrent(SCPreferencesRef prefs)
{
  const __CFString *Value;
  CFTypeID TypeID;
  const __CFArray *ArrayBySeparatingStrings;
  const __SCNetworkSet *v5;
  const __CFString *ValueAtIndex;
  CFStringRef Set;
  uint64_t Private;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  Value = (const __CFString *)SCPreferencesGetValue(prefs, CFSTR("CurrentSet"));
  TypeID = CFStringGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID)
    return 0;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, Value, CFSTR("/"));
  v5 = 0;
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 3)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 2);
    Set = SCPreferencesPathKeyCreateSet(0, (uint64_t)ValueAtIndex);
    if (CFEqual(Set, Value))
    {
      Private = __SCNetworkSetCreatePrivate(prefs, ValueAtIndex);
      if (!Private)
        SCNetworkSetCopyCurrent_cold_1();
      v5 = (const __SCNetworkSet *)Private;
      *(_BYTE *)(Private + 40) = 1;
    }
    else
    {
      v9 = __log_SCNetworkConfiguration();
      v10 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v9, (os_log_type_t)v10))
      {
        v11 = _os_log_pack_size();
        v19 = (char *)v21 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v9, v10, v19);
      }
      v5 = 0;
    }
    CFRelease(Set);
  }
  CFRelease(ArrayBySeparatingStrings);
  return v5;
}

CFArrayRef SCNetworkSetCopyAll(SCPreferencesRef prefs)
{
  const __CFString *Sets;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v6;
  const void **v7;
  const void **v8;
  uint64_t v10;
  __int128 v11;
  const void *v12;
  CFTypeID v13;
  _BYTE *Private;
  const void *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  const void *v28;
  __int128 v29;
  SCPreferencesRef v30;
  CFMutableArrayRef Mutable;
  _OWORD v32[8];
  _OWORD v33[8];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  Sets = SCPreferencesPathKeyCreateSets(0);
  v30 = prefs;
  Value = SCPreferencesPathGetValue(prefs, Sets);
  CFRelease(Sets);
  if (!Value)
    return CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  TypeID = CFDictionaryGetTypeID();
  if (CFGetTypeID(Value) != TypeID)
    return 0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  Count = CFDictionaryGetCount(Value);
  if (Count >= 1)
  {
    v6 = Count;
    memset(v33, 0, sizeof(v33));
    memset(v32, 0, sizeof(v32));
    if ((unint64_t)Count < 0x11)
    {
      v8 = (const void **)v32;
      v7 = (const void **)v33;
    }
    else
    {
      v7 = (const void **)CFAllocatorAllocate(0, 8 * Count, 0);
      v8 = (const void **)CFAllocatorAllocate(0, 8 * v6, 0);
    }
    CFDictionaryGetKeysAndValues(Value, v7, v8);
    v10 = 0;
    *(_QWORD *)&v11 = 138412290;
    v29 = v11;
    do
    {
      v12 = v8[v10];
      v13 = CFDictionaryGetTypeID();
      if (v12 && CFGetTypeID(v12) == v13)
      {
        Private = (_BYTE *)__SCNetworkSetCreatePrivate(v30, (const __CFString *)v7[v10]);
        if (!Private)
          SCNetworkSetCopyAll_cold_1();
        v15 = Private;
        Private[40] = 1;
        CFArrayAppendValue(Mutable, Private);
        CFRelease(v15);
      }
      else
      {
        v16 = __log_SCNetworkConfiguration();
        v17 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v16, (os_log_type_t)v17))
        {
          v18 = _os_log_pack_size();
          v26 = (char *)&v29
              - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v27 = _os_log_pack_fill();
          v28 = v7[v10];
          *(_DWORD *)v27 = v29;
          *(_QWORD *)(v27 + 4) = v28;
          __SC_log_send(6, (uint64_t)v16, v17, v26);
        }
      }
      ++v10;
    }
    while (v6 != v10);
    if (v7 != (const void **)v33)
    {
      CFAllocatorDeallocate(0, v7);
      CFAllocatorDeallocate(0, v8);
    }
  }
  return Mutable;
}

CFArrayRef SCNetworkInterfaceCopyAll(void)
{
  return _SCNetworkInterfaceCopyAllWithPreferences(0);
}

Boolean SCDynamicStoreSetMultiple(SCDynamicStoreRef store, CFDictionaryRef keysToSet, CFArrayRef keysToRemove, CFArrayRef keysToNotify)
{
  CFDictionaryRef v7;
  CFDictionaryRef v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  Boolean v12;
  int v13;
  CFDataRef v14;
  unsigned int v16;
  vm_size_t v17;
  uint64_t v18;
  CFTypeRef v19;
  vm_size_t v20;
  uint64_t v21;
  CFTypeRef cf;
  vm_size_t v23;
  uint64_t v24;
  CFDataRef v25;
  uint64_t v26[2];

  v26[1] = *MEMORY[0x1E0C80C00];
  v25 = 0;
  v26[0] = (uint64_t)store;
  v23 = 0;
  v24 = 0;
  v21 = 0;
  cf = 0;
  v19 = 0;
  v20 = 0;
  v17 = 0;
  v18 = 0;
  v16 = 0;
  if (!__SCDynamicStoreNormalize((uint64_t)v26, 1))
    return 0;
  if (keysToSet)
  {
    v7 = _SCSerializeMultiple(keysToSet);
    if (!v7)
      goto LABEL_21;
    v8 = v7;
    v9 = _SCSerialize(v7, &v25, (vm_address_t *)&v24, &v23);
    CFRelease(v8);
    if (!v9)
      goto LABEL_21;
  }
  if (keysToRemove && !_SCSerialize(keysToRemove, (CFDataRef *)&cf, (vm_address_t *)&v21, &v20))
  {
    v14 = v25;
    if (!v25)
    {
LABEL_21:
      v13 = 1002;
LABEL_22:
      _SCErrorSet(v13);
      return 0;
    }
LABEL_20:
    CFRelease(v14);
    goto LABEL_21;
  }
  if (keysToNotify && !_SCSerialize(keysToNotify, (CFDataRef *)&v19, (vm_address_t *)&v18, &v17))
  {
    if (v25)
      CFRelease(v25);
    v14 = (CFDataRef)cf;
    if (!cf)
      goto LABEL_21;
    goto LABEL_20;
  }
  v10 = v26[0];
  do
    v11 = configset_m(*(_DWORD *)(v10 + 40), v24, v23, v21, v20, v18, v17, (int *)&v16);
  while (__SCDynamicStoreCheckRetryAndHandleError(v26[0], v11, &v16, (uint64_t)"SCDynamicStoreSetMultiple configset_m()"));
  if (v25)
    CFRelease(v25);
  if (cf)
    CFRelease(cf);
  if (v19)
    CFRelease(v19);
  v12 = 1;
  v13 = __SCDynamicStoreMapInternalStatus(v16, 1);
  v16 = v13;
  if (v13)
    goto LABEL_22;
  return v12;
}

CFStringRef SCDynamicStoreKeyCreateNetworkInterfaceEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef ifname, CFStringRef entity)
{
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (entity)
    return CFStringCreateWithFormat(allocator, 0, CFSTR("%@/%@/%@/%@/%@"), domain, CFSTR("Network"), CFSTR("Interface"), ifname, entity, v6);
  else
    return CFStringCreateWithFormat(allocator, 0, CFSTR("%@/%@/%@/%@"), domain, CFSTR("Network"), CFSTR("Interface"), ifname, v5, v6);
}

CFStringRef SCDynamicStoreKeyCreateNetworkInterface(CFAllocatorRef allocator, CFStringRef domain)
{
  return CFStringCreateWithFormat(allocator, 0, CFSTR("%@/%@/%@"), domain, CFSTR("Network"), CFSTR("Interface"), *MEMORY[0x1E0C80C00]);
}

CFDictionaryRef SCDynamicStoreCopyMultiple(SCDynamicStoreRef store, CFArrayRef keys, CFArrayRef patterns)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  const __CFDictionary *v8;
  int v10;
  CFTypeRef cf;
  _DWORD length[3];
  vm_size_t v13;
  uint64_t v14;
  CFTypeRef v15;
  vm_size_t v16;
  uint64_t v17;
  CFDataRef v18;
  uint64_t v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v18 = 0;
  v19[0] = (uint64_t)store;
  v17 = 0;
  v15 = 0;
  v16 = 0;
  v13 = 0;
  v14 = 0;
  memset(length, 0, sizeof(length));
  cf = 0;
  v10 = 0;
  if (!__SCDynamicStoreNormalize((uint64_t)v19, 1))
    return 0;
  if (keys && !_SCSerialize(keys, &v18, (vm_address_t *)&v17, &v16))
  {
LABEL_15:
    _SCErrorSet(1001);
    return 0;
  }
  if (patterns && !_SCSerialize(patterns, (CFDataRef *)&v15, (vm_address_t *)&v14, &v13))
  {
    if (v18)
      CFRelease(v18);
    goto LABEL_15;
  }
  v5 = v19[0];
  do
    v6 = configget_m(*(_DWORD *)(v5 + 40), v17, v16, v14, v13, &length[1], length, &v10);
  while (__SCDynamicStoreCheckRetryAndHandleError(v19[0], v6, &v10, (uint64_t)"SCDynamicStoreCopyMultiple configget_m()"));
  v7 = v10;
  if (v10)
  {
    if (*(_QWORD *)&length[1])
    {
      MEMORY[0x18D78D14C](*MEMORY[0x1E0C83DA0], *(_QWORD *)&length[1], length[0]);
      v7 = v10;
    }
    goto LABEL_18;
  }
  if (!_SCUnserialize(&cf, 0, *(UInt8 **)&length[1], length[0]))
  {
    v7 = 1001;
LABEL_18:
    _SCErrorSet(v7);
    v8 = 0;
    goto LABEL_19;
  }
  v8 = _SCUnserializeMultiple((const __CFDictionary *)cf);
  CFRelease(cf);
LABEL_19:
  if (v18)
    CFRelease(v18);
  if (v15)
    CFRelease(v15);
  return v8;
}

uint64_t SCBridgeInterfaceCopyAll(const __SCPreferences *a1)
{
  void *Companion;
  const __CFString *v3;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  const __CFAllocator *v6;
  const __CFDictionary *Copy;
  _QWORD context[4];

  context[3] = *MEMORY[0x1E0C80C00];
  if (__SCPreferencesUsingDefaultPrefs((uint64_t)a1))
    Companion = 0;
  else
    Companion = SCPreferencesCreateCompanion((uint64_t)a1, CFSTR("NetworkInterfaces.plist"));
  context[1] = Companion;
  context[2] = a1;
  context[0] = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v3 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("Bridge"));
  Value = SCPreferencesPathGetValue(a1, v3);
  CFRelease(v3);
  TypeID = CFDictionaryGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID)
  {
    v6 = CFGetAllocator(Value);
    Copy = CFDictionaryCreateCopy(v6, Value);
    CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)add_configured_interface, context);
    CFRelease(Copy);
  }
  if (Companion)
    CFRelease(Companion);
  return context[0];
}

uint64_t SCNetworkCategoryGetTypeID()
{
  if (__SCNetworkCategoryInitialize_initialized != -1)
    dispatch_once(&__SCNetworkCategoryInitialize_initialized, &__block_literal_global);
  return __kSCNetworkCategoryTypeID;
}

uint64_t SCNetworkCategoryCopyAll(const __SCPreferences *a1)
{
  const __CFString *Categories;
  const __CFDictionary *Value;
  const __SCPreferences *context;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  Categories = SCPreferencesPathKeyCreateCategories(0);
  Value = SCPreferencesPathGetValue(a1, Categories);
  CFRelease(Categories);
  if (Value)
  {
    context = a1;
    v6 = 0;
    CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)copyAllApplier, &context);
    return v6;
  }
  else
  {
    _SCErrorSet(1004);
    return 0;
  }
}

void copyAllApplier(const __CFString *a1, const void *a2, uint64_t a3)
{
  CFTypeID TypeID;
  const void *v7;
  __CFArray *Mutable;

  TypeID = CFDictionaryGetTypeID();
  if (a2 && CFGetTypeID(a2) == TypeID)
  {
    v7 = (const void *)__SCNetworkCategoryCreate(*(const void **)a3, a1);
    Mutable = *(__CFArray **)(a3 + 8);
    if (!Mutable)
    {
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      *(_QWORD *)(a3 + 8) = Mutable;
    }
    CFArrayAppendValue(Mutable, v7);
    CFRelease(v7);
  }
}

uint64_t SCNetworkCategoryCreate(const void *a1, const __CFString *a2)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v2 = __SCNetworkCategoryCreate(a1, a2);
  if (v2)
  {
    v3 = _SC_LOG_DEFAULT();
    v4 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v3, (os_log_type_t)v4))
    {
      v5 = _os_log_pack_size();
      v13 = (char *)v16 - ((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v14 = _os_log_pack_fill();
      *(_DWORD *)v14 = 136315394;
      *(_QWORD *)(v14 + 4) = "SCNetworkCategoryCreate";
      *(_WORD *)(v14 + 12) = 2112;
      *(_QWORD *)(v14 + 14) = v2;
      __SC_log_send(7, (uint64_t)v3, v4, v13);
    }
  }
  return v2;
}

uint64_t __SCNetworkCategoryCreate(const void *a1, const __CFString *a2)
{
  uint64_t Instance;

  if (__SCNetworkCategoryInitialize_initialized != -1)
    dispatch_once(&__SCNetworkCategoryInitialize_initialized, &__block_literal_global);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = CFStringCreateCopy(0, a2);
    *(_QWORD *)(Instance + 24) = CFRetain(a1);
  }
  return Instance;
}

uint64_t SCNetworkCategoryAddService(uint64_t a1, uint64_t a2, SCNetworkServiceRef service)
{
  CFStringRef ServiceID;
  const __CFString *CategoryService;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  uint64_t v9;
  const __CFDictionary *v10;

  ServiceID = SCNetworkServiceGetServiceID(service);
  CategoryService = SCPreferencesPathKeyCreateCategoryService(0, *(_QWORD *)(a1 + 16), a2, (uint64_t)ServiceID);
  Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 24), CategoryService);
  TypeID = CFDictionaryGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID)
  {
    _SCErrorSet(1005);
    v9 = 0;
  }
  else
  {
    v10 = CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v9 = SCPreferencesPathSetValue(*(SCPreferencesRef *)(a1 + 24), CategoryService, v10);
    CFRelease(v10);
  }
  CFRelease(CategoryService);
  return v9;
}

uint64_t SCNetworkCategoryRemoveService(uint64_t a1, uint64_t a2, SCNetworkServiceRef service)
{
  CFStringRef ServiceID;
  const __CFString *CategoryService;
  uint64_t v8;

  ServiceID = SCNetworkServiceGetServiceID(service);
  CategoryService = SCPreferencesPathKeyCreateCategoryService(0, *(_QWORD *)(a1 + 16), a2, (uint64_t)ServiceID);
  v8 = SCPreferencesPathRemoveValue(*(SCPreferencesRef *)(a1 + 24), CategoryService);
  SCNetworkServiceRemove(service);
  CFRelease(CategoryService);
  return v8;
}

uint64_t SCNetworkCategoryCopyServices(uint64_t a1, uint64_t a2)
{
  const __CFString *CategoryService;
  const __CFDictionary *Value;
  uint64_t context;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  CategoryService = SCPreferencesPathKeyCreateCategoryService(0, *(_QWORD *)(a1 + 16), a2, 0);
  Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 24), CategoryService);
  CFRelease(CategoryService);
  if (Value)
  {
    context = *(_QWORD *)(a1 + 24);
    v7 = 0;
    CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)copyServicesApplier, &context);
    return v7;
  }
  else
  {
    _SCErrorSet(1004);
    return 0;
  }
}

void copyServicesApplier(const __CFString *a1, const void *a2, SCPreferencesRef *a3)
{
  CFTypeID TypeID;
  SCNetworkServiceRef v7;
  SCNetworkServiceRef v8;
  __CFArray *Mutable;

  TypeID = CFDictionaryGetTypeID();
  if (a2)
  {
    if (CFGetTypeID(a2) == TypeID)
    {
      v7 = SCNetworkServiceCopy(*a3, a1);
      if (v7)
      {
        v8 = v7;
        Mutable = a3[1];
        if (!Mutable)
        {
          Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
          a3[1] = Mutable;
        }
        CFArrayAppendValue(Mutable, v8);
        CFRelease(v8);
      }
    }
  }
}

uint64_t SCNetworkCategoryCopyValues(uint64_t a1)
{
  const __CFString *Category;
  const __CFDictionary *Value;
  _QWORD v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  Category = SCPreferencesPathKeyCreateCategory(0, *(_QWORD *)(a1 + 16));
  Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 24), Category);
  CFRelease(Category);
  if (Value)
  {
    v5[0] = 0;
    CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)copyValuesApplier, v5);
    return v5[0];
  }
  else
  {
    _SCErrorSet(1004);
    return 0;
  }
}

void copyValuesApplier(const void *a1, const void *a2, __CFArray **a3)
{
  CFTypeID TypeID;
  __CFArray *Mutable;

  TypeID = CFDictionaryGetTypeID();
  if (a2 && CFGetTypeID(a2) == TypeID)
  {
    Mutable = *a3;
    if (!*a3)
    {
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      *a3 = Mutable;
    }
    CFArrayAppendValue(Mutable, a1);
  }
}

uint64_t SCNetworkCategorySetServiceQoSMarkingPolicy(uint64_t a1, uint64_t a2, SCNetworkServiceRef service, const __CFDictionary *a4)
{
  CFStringRef ServiceID;
  const __CFString *CategoryServiceEntity;
  const __SCPreferences *v9;
  uint64_t v10;
  uint64_t v11;

  ServiceID = SCNetworkServiceGetServiceID(service);
  CategoryServiceEntity = SCPreferencesPathKeyCreateCategoryServiceEntity(0, *(_QWORD *)(a1 + 16), a2, (uint64_t)ServiceID, (uint64_t)CFSTR("QoSMarkingPolicy"));
  v9 = *(const __SCPreferences **)(a1 + 24);
  if (a4)
    v10 = SCPreferencesPathSetValue(v9, CategoryServiceEntity, a4);
  else
    v10 = SCPreferencesPathRemoveValue(v9, CategoryServiceEntity);
  v11 = v10;
  CFRelease(CategoryServiceEntity);
  return v11;
}

CFDictionaryRef SCNetworkCategoryGetServiceQoSMarkingPolicy(uint64_t a1, uint64_t a2, SCNetworkServiceRef service)
{
  CFStringRef ServiceID;
  const __CFString *CategoryServiceEntity;
  CFDictionaryRef Value;

  ServiceID = SCNetworkServiceGetServiceID(service);
  CategoryServiceEntity = SCPreferencesPathKeyCreateCategoryServiceEntity(0, *(_QWORD *)(a1 + 16), a2, (uint64_t)ServiceID, (uint64_t)CFSTR("QoSMarkingPolicy"));
  Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 24), CategoryServiceEntity);
  CFRelease(CategoryServiceEntity);
  if (!Value)
    _SCErrorSet(1004);
  return Value;
}

void __SCNetworkCategoryDeallocate(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t __SCNetworkCategoryEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
    return 1;
  else
    return CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
}

CFHashCode __SCNetworkCategoryHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 16));
}

__CFString *__SCNetworkCategoryCopyDescription(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<%s %p [%p]> { ID = %@ }"), "SCNetworkCategory", a1, v2, a1[2]);
  return Mutable;
}

const void *isA_CFString(const void *a1)
{
  CFTypeID TypeID;

  TypeID = CFStringGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) == TypeID)
    return a1;
  return 0;
}

CFComparisonResult compare_CFString(const __CFString *a1, const __CFString *a2)
{
  return CFStringCompare(a1, a2, 0);
}

const void *isA_CFNumber(const void *a1)
{
  CFTypeID TypeID;

  TypeID = CFNumberGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) == TypeID)
    return a1;
  return 0;
}

CFComparisonResult compare_CFNumber(const __CFNumber *a1, const __CFNumber *a2)
{
  return CFNumberCompare(a1, a2, 0);
}

const void *isA_CFDate(const void *a1)
{
  CFTypeID TypeID;

  TypeID = CFDateGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) == TypeID)
    return a1;
  return 0;
}

CFComparisonResult compare_CFDate(const __CFDate *a1, const __CFDate *a2)
{
  return CFDateCompare(a1, a2, 0);
}

uint64_t _SC_isInstallEnvironment()
{
  if (_SC_isInstallEnvironment_once != -1)
    dispatch_once(&_SC_isInstallEnvironment_once, &__block_literal_global_0);
  return _SC_isInstallEnvironment_is_install;
}

os_log_t _SC_LOG_DEFAULT()
{
  os_log_t result;

  result = (os_log_t)_SC_LOG_DEFAULT_log;
  if (!_SC_LOG_DEFAULT_log)
  {
    result = os_log_create("com.apple.SystemConfiguration", "");
    _SC_LOG_DEFAULT_log = (uint64_t)result;
  }
  return result;
}

void __SC_Log(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (_sc_log < 1)
    goto LABEL_4;
  if (_sc_log >= 2)
  {
    os_log_with_args();
LABEL_4:
    __SCPrint((FILE *)*MEMORY[0x1E0C80C20], a2, (uint64_t)&a9, _sc_log == 2, 1);
    return;
  }
  os_log_with_args();
}

CFErrorRef SCCopyLastError(void)
{
  uint64_t v0;
  CFIndex v1;
  CFErrorDomain *v2;
  __CFDictionary *Mutable;
  CFStringRef v5;
  __CFError *v6;

  v0 = 0;
  v1 = *(int *)__SCGetThreadSpecificData();
  while (sc_errmsgs[v0] != (_DWORD)v1)
  {
    v0 += 4;
    if (v0 == 80)
    {
      v2 = (CFErrorDomain *)MEMORY[0x1E0C9AFC0];
      if ((v1 - 1) < 0x6A)
        v2 = (CFErrorDomain *)MEMORY[0x1E0C9AFD0];
      return CFErrorCreate(0, *v2, v1, 0);
    }
  }
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  v5 = CFStringCreateWithCString(0, *(const char **)&sc_errmsgs[v0 + 2], 0x600u);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0C9AFB0], v5);
  CFRelease(v5);
  v6 = CFErrorCreate(0, CFSTR("com.apple.SystemConfiguration"), v1, Mutable);
  if (Mutable)
    CFRelease(Mutable);
  return v6;
}

const char *__cdecl SCErrorString(int status)
{
  uint64_t i;
  const char *result;

  for (i = 0; i != 80; i += 4)
  {
    if (sc_errmsgs[i] == status)
      return *(const char **)&sc_errmsgs[i + 2];
  }
  if ((status - 1) <= 0x69)
    return strerror(status);
  if (status <= 0x451)
    return bootstrap_strerror(status);
  result = mach_error_string(status);
  if (!result)
    return strerror(status);
  return result;
}

void *_SC_dlopen(char *__path)
{
  const char *v2;
  char v4[1024];
  stat v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (_SC_dlopen_once != -1)
    dispatch_once(&_SC_dlopen_once, &__block_literal_global_1);
  if (!_SC_dlopen_suffix || (memset(&v5, 0, sizeof(v5)), __strlcpy_chk(), __strlcat_chk(), stat(v4, &v5) < 0))
    v2 = __path;
  else
    v2 = v4;
  return dlopen(v2, 5);
}

void _SC_sendMachMessage(mach_port_t a1, mach_msg_id_t a2)
{
  mach_msg_header_t v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v2.msgh_bits = 0x1800000013;
  v2.msgh_remote_port = a1;
  v2.msgh_local_port = 0;
  v2.msgh_voucher_port = 0;
  v2.msgh_id = a2;
  if ((mach_msg(&v2, 17, 0x18u, 0, 0, 0, 0) - 268435459) <= 1)
    mach_msg_destroy(&v2);
}

uint64_t _SCUnserializeData(CFDataRef *a1, const UInt8 *a2, CFIndex a3)
{
  mach_error_t v5;
  mach_error_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  *a1 = CFDataCreate(0, a2, a3);
  v5 = MEMORY[0x18D78D14C](*MEMORY[0x1E0C83DA0], a2, a3);
  if (!v5)
    return 1;
  v6 = v5;
  v7 = _SC_LOG_DEFAULT();
  v8 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v7, (os_log_type_t)v8))
  {
    v9 = _os_log_pack_size();
    v17 = (char *)v21 - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v18 = _os_log_pack_fill();
    v19 = mach_error_string(v6);
    *(_DWORD *)v18 = 136315138;
    *(_QWORD *)(v18 + 4) = v19;
    __SC_log_send(5, (uint64_t)v7, v8, v17);
  }
  _SCErrorSet(1001);
  return 0;
}

CFPropertyListRef _SCCreatePropertyListFromResource(const __CFURL *a1)
{
  BOOL v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  int v15;
  int Value;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  CFPropertyListRef v27;
  __CFReadStream *v29;
  __CFReadStream *v30;
  UInt8 *v31;
  CFIndex v32;
  const __CFData *v33;
  const __CFData *v34;
  uint64_t v35;
  const __CFNumber *propertyValueTypeRefPtr;
  CFIndex valuePtr[2];

  valuePtr[1] = *MEMORY[0x1E0C80C00];
  propertyValueTypeRefPtr = 0;
  valuePtr[0] = 0;
  if (CFURLCopyResourcePropertyForKey(a1, (CFStringRef)*MEMORY[0x1E0C9B4A8], &propertyValueTypeRefPtr, 0))
    v2 = propertyValueTypeRefPtr == 0;
  else
    v2 = 1;
  if (v2)
  {
    v3 = _SC_LOG_DEFAULT();
    v4 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v3, (os_log_type_t)v4))
    {
      v5 = _os_log_pack_size();
      v13 = (char *)&v35 - ((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v14 = _os_log_pack_fill();
      *(_DWORD *)v14 = 138412290;
      *(_QWORD *)(v14 + 4) = a1;
      v15 = 5;
LABEL_15:
      __SC_log_send(v15, (uint64_t)v3, v4, v13);
    }
    return 0;
  }
  Value = CFNumberGetValue(propertyValueTypeRefPtr, kCFNumberSInt64Type, valuePtr);
  CFRelease(propertyValueTypeRefPtr);
  if (Value)
    v17 = valuePtr[0] == 0;
  else
    v17 = 1;
  if (v17)
  {
    v3 = _SC_LOG_DEFAULT();
    v4 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v3, (os_log_type_t)v4))
    {
      v18 = _os_log_pack_size();
      v13 = (char *)&v35 - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v26 = _os_log_pack_fill();
      *(_DWORD *)v26 = 138412290;
      *(_QWORD *)(v26 + 4) = a1;
      v15 = 6;
      goto LABEL_15;
    }
    return 0;
  }
  v29 = CFReadStreamCreateWithFile(0, a1);
  if (!v29)
    return 0;
  v30 = v29;
  if (CFReadStreamOpen(v29))
  {
    v31 = (UInt8 *)CFAllocatorAllocate(0, valuePtr[0], 0);
    v32 = CFReadStreamRead(v30, v31, valuePtr[0]);
    v27 = 0;
    if (v32 == valuePtr[0])
    {
      v33 = CFDataCreateWithBytesNoCopy(0, v31, v32, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
      if (v33)
      {
        v34 = v33;
        v27 = CFPropertyListCreateWithData(0, v33, 0, 0, 0);
        CFRelease(v34);
      }
      else
      {
        v27 = 0;
      }
    }
    CFAllocatorDeallocate(0, v31);
    CFReadStreamClose(v30);
  }
  else
  {
    v27 = 0;
  }
  CFRelease(v30);
  return v27;
}

void _SC_crash(const char *a1, const __CFString *a2, uint64_t a3)
{
  const char *v6;
  NSObject *v7;
  const __CFString *v8;
  uint8_t buf[4];
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (_SC_isAppleInternal_once_0 != -1)
    dispatch_once(&_SC_isAppleInternal_once_0, &__block_literal_global_47);
  if (_SC_isAppleInternal_isInternal_0)
  {
    if (a1)
      v6 = a1;
    else
      v6 = "_SC_crash() called w/o \"crash_info\"";
    qword_1EE061F00 = (uint64_t)v6;
    v7 = _SC_LOG_DEFAULT();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v10 = v6;
      _os_log_impl(&dword_18D387000, v7, OS_LOG_TYPE_FAULT, "%s", buf, 0xCu);
    }
    if (a2 && a3 && (_SC_ReportCrash_warned & 1) == 0)
    {
      v8 = CFStringCreateWithFormat(0, 0, CFSTR("%@\n\nPlease collect the crash report and file a Radar."), a3);
      CFUserNotificationDisplayNotice(0.0, 0, 0, 0, 0, a2, v8, 0);
      CFRelease(v8);
      _SC_ReportCrash_warned = 1;
    }
    qword_1EE061F00 = 0;
  }
}

void _SC_logMachPortStatus()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  __CFString *Mutable;
  unint64_t i;
  uint64_t v13;
  int v14;
  char *v15;
  __int16 *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  __int16 v33;
  char v34;
  _BYTE v35[21];

  *(_QWORD *)&v35[13] = *MEMORY[0x1E0C80C00];
  v31 = 0;
  v32 = 0;
  v30 = 0;
  v0 = _SC_LOG_DEFAULT();
  v1 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v0, (os_log_type_t)v1))
  {
    v2 = _os_log_pack_size();
    v10 = (char *)&v30 - ((MEMORY[0x1E0C80A78](v2, v3, v4, v5, v6, v7, v8, v9) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(7, (uint64_t)v0, v1, v10);
  }
  if (!MEMORY[0x18D78C9B4](*MEMORY[0x1E0C83DA0], &v32, (char *)&v30 + 4, &v31, &v30))
  {
    Mutable = CFStringCreateMutable(0, 0);
    if (HIDWORD(v30))
    {
      for (i = 0; i < HIDWORD(v30); ++i)
      {
        v13 = v31;
        if (!*(_DWORD *)(v31 + 4 * i))
        {
          v16 = &v33;
          goto LABEL_15;
        }
        v33 = 10272;
        v14 = *(_DWORD *)(v31 + 4 * i);
        v15 = &v34;
        if ((v14 & 0x10000) != 0)
        {
          v34 = 83;
          v14 = *(_DWORD *)(v31 + 4 * i);
          v15 = v35;
          if ((v14 & 0x20000) == 0)
          {
LABEL_9:
            if ((v14 & 0x40000) == 0)
              goto LABEL_10;
            goto LABEL_19;
          }
        }
        else if ((v14 & 0x20000) == 0)
        {
          goto LABEL_9;
        }
        *v15++ = 82;
        v14 = *(_DWORD *)(v13 + 4 * i);
        if ((v14 & 0x40000) == 0)
        {
LABEL_10:
          if ((v14 & 0x80000) != 0)
            goto LABEL_20;
          goto LABEL_11;
        }
LABEL_19:
        *v15++ = 79;
        v14 = *(_DWORD *)(v31 + 4 * i);
        if ((v14 & 0x80000) != 0)
        {
LABEL_20:
          *v15++ = 80;
          if ((*(_DWORD *)(v31 + 4 * i) & 0x100000) == 0)
            goto LABEL_13;
LABEL_12:
          *v15++ = 68;
          goto LABEL_13;
        }
LABEL_11:
        if ((v14 & 0x100000) != 0)
          goto LABEL_12;
LABEL_13:
        *v15 = 41;
        v16 = (__int16 *)(v15 + 1);
LABEL_15:
        *(_BYTE *)v16 = 0;
        CFStringAppendFormat(Mutable, 0, CFSTR(" %u%s"), *(unsigned int *)(v32 + 4 * i), &v33, v30);
      }
    }
    v17 = _SC_LOG_DEFAULT();
    v18 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v17, (os_log_type_t)v18))
    {
      v19 = _os_log_pack_size();
      v27 = (char *)&v30 - ((MEMORY[0x1E0C80A78](v19, v20, v21, v22, v23, v24, v25, v26) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v28 = _os_log_pack_fill();
      v29 = HIDWORD(v30);
      *(_DWORD *)v28 = 67109378;
      *(_DWORD *)(v28 + 4) = v29;
      *(_WORD *)(v28 + 8) = 2112;
      *(_QWORD *)(v28 + 10) = Mutable;
      __SC_log_send(7, (uint64_t)v17, v18, v27);
    }
    CFRelease(Mutable);
  }
}

BOOL _SC_checkMachPortReceive(uint64_t a1, uint64_t name)
{
  BOOL v2;
  int v4;
  _OWORD v5[2];
  uint64_t v6;
  mach_port_type_t ptype;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  ptype = 0;
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v4 = 0;
  if (_SC_getMachPortReferences(name, &ptype, 0, (uint64_t)&v4, (integer_t *)v5, 0, 0, 0, a1))
    v2 = 1;
  else
    v2 = v4 == 0;
  return !v2;
}

uint64_t _SC_getMachPortReferences(uint64_t name, mach_port_type_t *ptype, uint64_t a3, uint64_t a4, integer_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ipc_space_read_t *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t attributes;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  mach_msg_type_number_t port_info_outCnt;
  uint64_t v50;

  v48 = a9;
  v50 = *MEMORY[0x1E0C80C00];
  v17 = (ipc_space_read_t *)MEMORY[0x1E0C83DA0];
  v18 = mach_port_type(*MEMORY[0x1E0C83DA0], name, ptype);
  if (!(_DWORD)v18)
  {
    if (a3)
    {
      if ((*((_BYTE *)ptype + 2) & 1) != 0)
      {
        v34 = MEMORY[0x18D78C990](*v17, name, 0, a3);
        if ((_DWORD)v34)
        {
          v19 = v34;
          v20 = _SC_LOG_DEFAULT();
          v21 = _SC_syslog_os_log_mapping(7);
          if (!__SC_log_enabled(7, v20, (os_log_type_t)v21))
            return v19;
          goto LABEL_3;
        }
      }
    }
    if (!a4 || !a5 || (*((_BYTE *)ptype + 2) & 2) == 0)
      goto LABEL_38;
    v37 = MEMORY[0x18D78C990](*v17, name, 1, a4);
    if ((_DWORD)v37)
    {
      v19 = v37;
      v20 = _SC_LOG_DEFAULT();
      v21 = _SC_syslog_os_log_mapping(7);
      if (!__SC_log_enabled(7, v20, (os_log_type_t)v21))
        return v19;
      goto LABEL_3;
    }
    port_info_outCnt = 10;
    attributes = mach_port_get_attributes(*v17, name, 2, a5, &port_info_outCnt);
    if ((_DWORD)attributes)
    {
      v19 = attributes;
      v20 = _SC_LOG_DEFAULT();
      v21 = _SC_syslog_os_log_mapping(7);
      if (!__SC_log_enabled(7, v20, (os_log_type_t)v21))
        return v19;
    }
    else
    {
LABEL_38:
      if (a6 && (*((_BYTE *)ptype + 2) & 4) != 0 && (v35 = MEMORY[0x18D78C990](*v17, name, 2, a6), (_DWORD)v35))
      {
        v19 = v35;
        v20 = _SC_LOG_DEFAULT();
        v21 = _SC_syslog_os_log_mapping(7);
        if (!__SC_log_enabled(7, v20, (os_log_type_t)v21))
          return v19;
      }
      else if (a7 && (*((_BYTE *)ptype + 2) & 8) != 0 && (v36 = MEMORY[0x18D78C990](*v17, name, 3, a7), (_DWORD)v36))
      {
        v19 = v36;
        v20 = _SC_LOG_DEFAULT();
        v21 = _SC_syslog_os_log_mapping(7);
        if (!__SC_log_enabled(7, v20, (os_log_type_t)v21))
          return v19;
      }
      else
      {
        if (!a8 || (*((_BYTE *)ptype + 2) & 0x10) == 0)
          return 0;
        v19 = MEMORY[0x18D78C990](*v17, name, 4, a8);
        if (!(_DWORD)v19)
          return v19;
        v20 = _SC_LOG_DEFAULT();
        v21 = _SC_syslog_os_log_mapping(7);
        if (!__SC_log_enabled(7, v20, (os_log_type_t)v21))
          return v19;
      }
    }
    v39 = _os_log_pack_size();
    v30 = (char *)&v47 - ((MEMORY[0x1E0C80A78](v39, v40, v41, v42, v43, v44, v45, v46) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    goto LABEL_4;
  }
  v19 = v18;
  v20 = _SC_LOG_DEFAULT();
  v21 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v20, (os_log_type_t)v21))
  {
LABEL_3:
    v22 = _os_log_pack_size();
    v30 = (char *)&v47 - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
LABEL_4:
    v31 = _os_log_pack_fill();
    v32 = mach_error_string(v19);
    *(_DWORD *)v31 = 136315650;
    *(_QWORD *)(v31 + 4) = v48;
    *(_WORD *)(v31 + 12) = 1024;
    *(_DWORD *)(v31 + 14) = name;
    *(_WORD *)(v31 + 18) = 2080;
    *(_QWORD *)(v31 + 20) = v32;
    __SC_log_send(7, (uint64_t)v20, v21, v30);
  }
  return v19;
}

BOOL _SC_checkMachPortSend(uint64_t a1, uint64_t name)
{
  int MachPortReferences;
  _BOOL8 result;
  uint64_t v4;
  int v5;
  mach_port_type_t ptype;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  ptype = 0;
  v5 = 0;
  v4 = 0;
  MachPortReferences = _SC_getMachPortReferences(name, &ptype, (uint64_t)&v5, 0, 0, (uint64_t)&v4 + 4, 0, (uint64_t)&v4, a1);
  result = 0;
  if (!MachPortReferences)
    return (v5 | HIDWORD(v4) | v4) != 0;
  return result;
}

void _SC_logMachPortReferences(uint64_t a1, uint64_t name)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD v21[2];
  uint64_t v22;
  mach_port_type_t ptype;
  _BYTE v24[57];
  unsigned __int16 v25;
  unsigned __int8 v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  ptype = 0;
  v22 = 0;
  memset(v21, 0, sizeof(v21));
  v19 = 0;
  v20 = 0;
  v18 = 0;
  v24[0] = 0;
  if (a1)
  {
    __strlcpy_chk();
    __strlcat_chk();
    if (!(v25 ^ 0x2020 | v26))
      LOBYTE(v25) = 58;
  }
  if (!_SC_getMachPortReferences(name, &ptype, (uint64_t)&v20 + 4, (uint64_t)&v20, (integer_t *)v21, (uint64_t)&v19 + 4, (uint64_t)&v19, (uint64_t)&v18, (uint64_t)v24))
  {
    v3 = _SC_LOG_DEFAULT();
    v4 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v3, (os_log_type_t)v4))
    {
      v5 = _os_log_pack_size();
      v13 = (char *)&v17 - ((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v14 = _os_log_pack_fill();
      if ((_DWORD)v22)
        v15 = ", no more senders";
      else
        v15 = "";
      if ((ptype & 0x100000) != 0)
        v16 = ", dead name request";
      else
        v16 = "";
      __os_log_helper_1_2_10_8_32_4_0_4_0_4_0_4_0_4_0_4_0_4_0_8_32_8_32(v14, (uint64_t)v24, name, name, SHIDWORD(v20), v20, SHIDWORD(v19), v19, v18, (uint64_t)v15, (uint64_t)v16);
      __SC_log_send(7, (uint64_t)v3, v4, v13);
    }
  }
}

double __os_log_helper_1_2_10_8_32_4_0_4_0_4_0_4_0_4_0_4_0_4_0_8_32_8_32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, uint64_t a10, uint64_t a11)
{
  double result;

  *(_QWORD *)&result = 136317442;
  *(_DWORD *)a1 = 136317442;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 18) = 1024;
  *(_DWORD *)(a1 + 20) = a4;
  *(_WORD *)(a1 + 24) = 1024;
  *(_DWORD *)(a1 + 26) = a5;
  *(_WORD *)(a1 + 30) = 1024;
  *(_DWORD *)(a1 + 32) = a6;
  *(_WORD *)(a1 + 36) = 1024;
  *(_DWORD *)(a1 + 38) = a7;
  *(_WORD *)(a1 + 42) = 1024;
  *(_DWORD *)(a1 + 44) = a8;
  *(_WORD *)(a1 + 48) = 1024;
  *(_DWORD *)(a1 + 50) = a9;
  *(_WORD *)(a1 + 54) = 2080;
  *(_QWORD *)(a1 + 56) = a10;
  *(_WORD *)(a1 + 64) = 2080;
  *(_QWORD *)(a1 + 66) = a11;
  return result;
}

__CFString *_SC_copyBacktrace()
{
  int v0;
  int v1;
  __CFString *Mutable;
  char **v3;
  char **v4;
  uint64_t v5;
  char **v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  int *v20;
  char *v21;
  _OWORD v23[32];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  memset(v23, 0, sizeof(v23));
  v0 = backtrace((void **)v23, 64);
  if (v0 == -1)
  {
    v8 = _SC_LOG_DEFAULT();
    v9 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v8, (os_log_type_t)v9))
    {
      v10 = _os_log_pack_size();
      v18 = (char *)v23 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v19 = _os_log_pack_fill();
      v20 = __error();
      v21 = strerror(*v20);
      *(_DWORD *)v19 = 136315138;
      *(_QWORD *)(v19 + 4) = v21;
      __SC_log_send(5, (uint64_t)v8, v9, v18);
    }
    return 0;
  }
  else
  {
    v1 = v0;
    Mutable = CFStringCreateMutable(0, 0);
    v3 = backtrace_symbols((void *const *)v23, v1);
    if (v3)
    {
      v4 = v3;
      if (v1 >= 1)
      {
        v5 = v1;
        v6 = v3;
        do
        {
          v7 = (uint64_t)*v6++;
          CFStringAppendFormat(Mutable, 0, CFSTR("%s\n"), v7);
          --v5;
        }
        while (v5);
      }
      free(v4);
    }
  }
  return Mutable;
}

BOOL _SC_getconninfo(int a1, _OWORD *a2, _OWORD *a3, _DWORD *a4, _DWORD *a5)
{
  NSObject *v7;
  uint64_t v8;
  _BOOL8 result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  int *v20;
  char *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  if (a2)
  {
    a2[6] = 0uLL;
    a2[7] = 0uLL;
    a2[4] = 0uLL;
    a2[5] = 0uLL;
    a2[2] = 0uLL;
    a2[3] = 0uLL;
    *a2 = 0uLL;
    a2[1] = 0uLL;
    *(_QWORD *)&v23 = a2;
    DWORD2(v23) = 128;
  }
  if (a3)
  {
    a3[6] = 0uLL;
    a3[7] = 0uLL;
    a3[4] = 0uLL;
    a3[5] = 0uLL;
    a3[2] = 0uLL;
    a3[3] = 0uLL;
    *a3 = 0uLL;
    a3[1] = 0uLL;
    *(_QWORD *)&v24 = a3;
    DWORD2(v24) = 128;
  }
  if (ioctl(a1, 0xC0407398uLL))
  {
    v7 = _SC_LOG_DEFAULT();
    v8 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v7, (os_log_type_t)v8);
    if (result)
    {
      v10 = _os_log_pack_size();
      v18 = (char *)&v22 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v19 = _os_log_pack_fill();
      v20 = __error();
      v21 = strerror(*v20);
      *(_DWORD *)v19 = 136315138;
      *(_QWORD *)(v19 + 4) = v21;
      __SC_log_send(5, (uint64_t)v7, v8, v18);
      return 0;
    }
  }
  else
  {
    if (a4)
      *a4 = DWORD2(v22);
    if (a5)
      *a5 = DWORD1(v22);
    return 1;
  }
  return result;
}

CFStringRef _SC_copyInterfaceUUID(const __CFString *a1)
{
  const __CFUUID *v1;
  CFStringRef v2;
  _QWORD v4[2];
  CC_SHA256_CTX c;
  unsigned __int8 md[16];
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(&c, 0, sizeof(c));
  v4[0] = 0;
  v4[1] = 0;
  _SC_cfstring_to_cstring_ext(a1, (UInt8 *)v4, 16, 0x8000100u, 0, 0);
  *(_OWORD *)md = 0u;
  v7 = 0u;
  CC_SHA256_Init(&c);
  CC_SHA256_Update(&c, v4, 0x10u);
  CC_SHA256_Final(md, &c);
  v1 = CFUUIDCreateFromUUIDBytes(0, *(CFUUIDBytes *)md);
  v2 = CFUUIDCreateString(0, v1);
  CFRelease(v1);
  return v2;
}

CFDictionaryRef _SC_IONetworkInterfaceBSDNameMatching(char *cStr)
{
  CFStringRef v1;
  CFDictionaryRef v2;
  const void *v4[2];
  void *keys[2];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)keys = xmmword_1E25D04B8;
  v1 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  v4[0] = v1;
  v4[1] = CFSTR("IONetworkInterface");
  v2 = CFDictionaryCreate(0, (const void **)keys, v4, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(v1);
  return v2;
}

void _SCDPluginExecInit()
{
  uint64_t v0;
  uint64_t Port;
  __CFRunLoopSource *RunLoopSource;
  __CFRunLoop *Current;
  CFMachPortContext v4;
  sigaction v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&v4.version = xmmword_1E25D0508;
  *(_OWORD *)&v4.retain = unk_1E25D0518;
  v4.copyDescription = (CFStringRef (__cdecl *)(const void *))childReapedMPCopyDescription;
  childReaped = (uint64_t)CFMachPortCreate(0, (CFMachPortCallBack)childrenReaped, &v4, 0);
  LODWORD(v5.__sigaction_u.__sa_handler) = 1;
  v0 = *MEMORY[0x1E0C83DA0];
  Port = CFMachPortGetPort((CFMachPortRef)childReaped);
  if (MEMORY[0x18D78C9CC](v0, Port, 1, &v5, 1))
    perror("mach_port_set_attributes");
  RunLoopSource = CFMachPortCreateRunLoopSource(0, (CFMachPortRef)childReaped, 0);
  Current = CFRunLoopGetCurrent();
  CFRunLoopAddSource(Current, RunLoopSource, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
  CFRelease(RunLoopSource);
  v5.__sigaction_u.__sa_handler = (void (__cdecl *)(int))reaper;
  *(_QWORD *)&v5.sa_mask = 0xA00000000;
  if (sigaction(20, &v5, 0) == -1)
    perror("sigaction");
}

CFStringRef childReapedMPCopyDescription()
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<SIGCHLD MP>"));
}

void childrenReaped()
{
  unsigned int *v0;
  pid_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  timeval ru_stime;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t *v13;
  unsigned int *v14;
  int v15;
  rusage v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (initializeLock_initialized != -1)
    dispatch_once(&initializeLock_initialized, &__block_literal_global_2);
  v0 = 0;
  do
  {
    memset(&v16, 0, sizeof(v16));
    v15 = 0;
    v1 = wait4(-1, &v15, 1, &v16);
    if (!v1)
      break;
    v2 = v1;
    if (v1 == -1)
    {
      if (*__error() != 10)
        perror("wait4");
      break;
    }
    pthread_mutex_lock((pthread_mutex_t *)&lock_0);
    v3 = activeChildren;
    if (activeChildren)
    {
      if (*(_DWORD *)activeChildren == v2)
      {
        v4 = 0;
LABEL_12:
        *(_DWORD *)(v3 + 24) = v15;
        ru_stime = v16.ru_stime;
        *(timeval *)(v3 + 32) = v16.ru_utime;
        v8 = *(_OWORD *)&v16.ru_idrss;
        v7 = *(_OWORD *)&v16.ru_minflt;
        v9 = *(_OWORD *)&v16.ru_maxrss;
        *(timeval *)(v3 + 48) = ru_stime;
        *(_OWORD *)(v3 + 64) = v9;
        v10 = *(_OWORD *)&v16.ru_nvcsw;
        v12 = *(_OWORD *)&v16.ru_oublock;
        v11 = *(_OWORD *)&v16.ru_msgrcv;
        *(_OWORD *)(v3 + 112) = *(_OWORD *)&v16.ru_nswap;
        *(_OWORD *)(v3 + 128) = v12;
        *(_OWORD *)(v3 + 144) = v11;
        *(_OWORD *)(v3 + 160) = v10;
        *(_OWORD *)(v3 + 80) = v8;
        *(_OWORD *)(v3 + 96) = v7;
        if (v4)
          v13 = (uint64_t *)(v4 + 176);
        else
          v13 = &activeChildren;
        *v13 = *(_QWORD *)(v3 + 176);
        *(_QWORD *)(v3 + 176) = v0;
        v0 = (unsigned int *)v3;
      }
      else
      {
        v5 = activeChildren;
        while (1)
        {
          v3 = *(_QWORD *)(v5 + 176);
          if (!v3)
            break;
          v4 = v5;
          v5 = *(_QWORD *)(v5 + 176);
          if (*(_DWORD *)v3 == v2)
            goto LABEL_12;
        }
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)&lock_0);
  }
  while (v2 > 0);
  LODWORD(v16.ru_utime.tv_sec) = 0x80000;
  if (sigprocmask(2, (const sigset_t *)&v16, 0) == -1)
  {
    perror("sigprocmask(SIG_UNBLOCK)");
    if (!v0)
      return;
  }
  else if (!v0)
  {
    return;
  }
  do
  {
    v14 = (unsigned int *)*((_QWORD *)v0 + 22);
    (*((void (**)(_QWORD, _QWORD, unsigned int *, _QWORD))v0 + 1))(*v0, v0[6], v0 + 8, *((_QWORD *)v0 + 2));
    CFAllocatorDeallocate(0, v0);
    v0 = v14;
  }
  while (v14);
}

void reaper()
{
  mach_port_t Port;
  sigset_t v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1 = 0x80000;
  if (sigprocmask(1, &v1, 0) == -1)
    perror("sigprocmask(SIG_BLOCK)");
  Port = CFMachPortGetPort((CFMachPortRef)childReaped);
  _SC_sendMachMessage(Port, 0);
}

uint64_t _SCDPluginSpawnCommand(uint64_t a1, uint64_t a2, const char *a3, char *const *a4, void (*a5)(posix_spawn_file_actions_t *, posix_spawnattr_t *, uint64_t), uint64_t a6)
{
  char **v12;
  int v13;
  _OWORD *v14;
  int v15;
  pid_t v17;
  posix_spawnattr_t v18;
  posix_spawn_file_actions_t v19;
  uint8_t buf[4];
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  v19 = 0;
  v12 = *_NSGetEnviron();
  v17 = 0;
  if (initializeLock_initialized != -1)
    dispatch_once(&initializeLock_initialized, &__block_literal_global_2);
  pthread_mutex_lock((pthread_mutex_t *)&lock_0);
  if (!childReaped)
    _SCDPluginExecInit();
  posix_spawnattr_init(&v18);
  posix_spawn_file_actions_init(&v19);
  posix_spawnattr_setflags(&v18, 0x4000);
  if (a5)
  {
    a5(&v19, &v18, a6);
  }
  else
  {
    posix_spawn_file_actions_addopen(&v19, 0, "/dev/null", 2, 0);
    posix_spawn_file_actions_adddup2(&v19, 0, 1);
    posix_spawn_file_actions_adddup2(&v19, 0, 2);
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315138;
    v21 = a3;
    _os_log_impl(&dword_18D387000, MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO, "spawn: %s", buf, 0xCu);
  }
  v13 = posix_spawn(&v17, a3, &v19, &v18, a4, v12);
  posix_spawnattr_destroy(&v18);
  posix_spawn_file_actions_destroy(&v19);
  if (v13 || !v17)
  {
    v15 = *__error();
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      _SCDPluginSpawnCommand_cold_1(v15);
    *__error() = v15;
    v17 = -1;
  }
  else if (a1)
  {
    v14 = CFAllocatorAllocate(0, 184, 0);
    *v14 = 0u;
    v14[1] = 0u;
    *((_QWORD *)v14 + 22) = 0;
    v14[2] = 0u;
    v14[3] = 0u;
    v14[4] = 0u;
    v14[5] = 0u;
    v14[6] = 0u;
    v14[7] = 0u;
    v14[8] = 0u;
    v14[9] = 0u;
    v14[10] = 0u;
    *(_DWORD *)v14 = v17;
    *((_QWORD *)v14 + 1) = a1;
    *((_QWORD *)v14 + 2) = a2;
    *((_QWORD *)v14 + 22) = activeChildren;
    activeChildren = (uint64_t)v14;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&lock_0);
  return v17;
}

uint64_t _SCDPluginExecCommand2(uint64_t a1, uint64_t a2, uid_t a3, gid_t a4, const char *a5, char *const *a6, void (*a7)(uint64_t, uint64_t), uint64_t a8)
{
  gid_t v16;
  uid_t v17;
  char *pw_name;
  uint64_t v20;
  uint64_t v21;
  _OWORD *v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  gid_t v28;
  uid_t v29;
  int *v30;
  passwd *v31;
  passwd v32;
  uint8_t buf[4];
  const char *v34;
  char v35[1024];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v16 = getegid();
  v17 = geteuid();
  v31 = 0;
  if (!a7 && v17 == a3 && v16 == a4)
    return _SCDPluginSpawnCommand(a1, a2, a5, a6, 0, 0);
  if (initializeLock_initialized != -1)
    dispatch_once(&initializeLock_initialized, &__block_literal_global_2);
  memset(&v32, 0, sizeof(v32));
  pthread_mutex_lock((pthread_mutex_t *)&lock_0);
  pw_name = 0;
  if (!getpwuid_r(a3, &v32, v35, 0x400uLL, &v31) && v31)
    pw_name = v31->pw_name;
  if (!childReaped)
    _SCDPluginExecInit();
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315138;
    v34 = a5;
    _os_log_impl(&dword_18D387000, MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO, "fork/exec: %s", buf, 0xCu);
  }
  v20 = fork();
  v21 = v20;
  if ((_DWORD)v20 == -1)
  {
    v23 = *__error();
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      _SCDPluginExecCommand2_cold_1(v23);
    *__error() = v23;
  }
  else
  {
    if (!(_DWORD)v20)
    {
      if (a7)
      {
        a7(0, a8);
      }
      else
      {
        v24 = getdtablesize();
        if (v24 >= 1)
        {
          v25 = v24 + 1;
          do
          {
            close(v25 - 2);
            --v25;
          }
          while (v25 > 1);
        }
        v26 = open("/dev/null", 2, 0);
        if (v26 != -1)
        {
          v27 = v26;
          dup2(v26, 0);
          dup2(v27, 1);
          dup2(v27, 2);
          if (v27 >= 3)
            close(v27);
        }
      }
      v28 = getegid();
      v29 = geteuid();
      if (v28 != a4)
        setgid(a4);
      if (v29 == a3)
      {
        if (v28 != a4 && pw_name)
          initgroups(pw_name, a4);
      }
      else
      {
        if (pw_name)
          initgroups(pw_name, a4);
        setuid(a3);
      }
      if (setenv("PATH", "/bin:/sbin:/usr/bin:/usr/sbin", 0) == -1)
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          _SCDPluginExecCommand2_cold_2();
        exit(71);
      }
      execv(a5, a6);
      v30 = __error();
      _exit(*(unsigned __int8 *)v30);
    }
    if (a7)
      a7(v20, a8);
    if (a1)
    {
      v22 = CFAllocatorAllocate(0, 184, 0);
      *v22 = 0u;
      v22[1] = 0u;
      v22[2] = 0u;
      v22[3] = 0u;
      v22[4] = 0u;
      v22[5] = 0u;
      v22[6] = 0u;
      v22[7] = 0u;
      v22[8] = 0u;
      v22[9] = 0u;
      v22[10] = 0u;
      *(_DWORD *)v22 = v21;
      *((_QWORD *)v22 + 1) = a1;
      *((_QWORD *)v22 + 2) = a2;
      *((_QWORD *)v22 + 22) = activeChildren;
      activeChildren = (uint64_t)v22;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)&lock_0);
  return v21;
}

uint64_t _SCDPluginExecCommand(uint64_t a1, uint64_t a2, uid_t a3, gid_t a4, const char *a5, char *const *a6)
{
  return _SCDPluginExecCommand2(a1, a2, a3, a4, a5, a6, 0, 0);
}

uint64_t __initializeLock_block_invoke()
{
  return pthread_mutex_init((pthread_mutex_t *)&lock_0, 0);
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t _SCDynamicStoreSetSessionWatchLimit(uint64_t result)
{
  _sc_store_max = result;
  _sc_store_advise = result;
  return result;
}

os_log_t __log_SCDynamicStore()
{
  os_log_t result;

  result = (os_log_t)__log_SCDynamicStore_log;
  if (!__log_SCDynamicStore_log)
  {
    result = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
    __log_SCDynamicStore_log = (uint64_t)result;
  }
  return result;
}

uint64_t __SCDynamicStoreCreateInternal(uint64_t a1, const void *a2, uint64_t a3, __int128 *a4, int a5)
{
  uint64_t Instance;
  CFTypeRef v10;
  __int128 v11;
  __int128 v12;
  uint64_t (*v13)(_QWORD);
  uint64_t v14;
  _QWORD v16[6];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char v20;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCDynamicStoreInitialize_initialized != -1)
    dispatch_once(&__SCDynamicStoreInitialize_initialized, &__block_literal_global_51);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    if (a5)
      *(_QWORD *)(Instance + 16) = dispatch_queue_create("SCDynamicStore object", 0);
    if (a2)
      v10 = CFRetain(a2);
    else
      v10 = 0;
    *(_QWORD *)(Instance + 24) = v10;
    *(_DWORD *)(Instance + 48) = 0;
    *(_QWORD *)(Instance + 72) = a3;
    if (a4)
    {
      v11 = *a4;
      v12 = a4[1];
      *(_QWORD *)(Instance + 112) = *((_QWORD *)a4 + 4);
      *(_OWORD *)(Instance + 80) = v11;
      *(_OWORD *)(Instance + 96) = v12;
      v13 = (uint64_t (*)(_QWORD))*((_QWORD *)a4 + 2);
      if (v13)
        *(_QWORD *)(Instance + 88) = v13(*((_QWORD *)a4 + 1));
    }
    *(_DWORD *)(Instance + 192) = -1;
    if (a5)
    {
      v17 = 0;
      v18 = &v17;
      v19 = 0x2000000000;
      v20 = 0;
      if (storeQueue_once != -1)
        dispatch_once(&storeQueue_once, &__block_literal_global_3);
      v14 = MEMORY[0x1E0C809B0];
      v16[0] = MEMORY[0x1E0C809B0];
      v16[1] = 0x40000000;
      v16[2] = ____SCDynamicStoreCreateInternal_block_invoke;
      v16[3] = &unk_1E25D05C0;
      v16[4] = &v17;
      v16[5] = Instance;
      dispatch_sync((dispatch_queue_t)storeQueue_q, v16);
      if (*((_BYTE *)v18 + 24))
      {
        block[0] = v14;
        block[1] = 0x40000000;
        block[2] = ___SC_crash_once_block_invoke;
        block[3] = &__block_descriptor_tmp_92;
        block[5] = 0;
        block[6] = 0;
        block[4] = "Excessive number of SCDynamicStore sessions";
        if (_SC_crash_once_once != -1)
          dispatch_once(&_SC_crash_once_once, block);
      }
      _Block_object_dispose(&v17, 8);
    }
  }
  else
  {
    _SCErrorSet(1001);
  }
  return Instance;
}

uint64_t __SCDynamicStoreReconnectNotifications(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  const __CFArray *Copy;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  int v18;
  const char *v19;
  uint64_t v20;
  CFRunLoopSourceRef RunLoopSource;
  __CFRunLoopSource *v22;
  CFIndex Count;
  CFIndex v24;
  CFIndex i;
  __CFRunLoop *ValueAtIndex;
  const __CFString *v27;
  int v28;
  int v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  const char *v42;
  int v43;
  int v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  const char *v57;
  int v58;
  int v59;
  NSObject *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  const char *v72;
  int v73;
  NSObject *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  uint64_t v85;
  const char *v86;
  uint64_t v87;
  _QWORD v89[2];

  v89[1] = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(a1 + 48);
  if ((_DWORD)v2 == 5)
  {
    v5 = *(NSObject **)(a1 + 136);
    if (v5)
      dispatch_retain(*(dispatch_object_t *)(a1 + 136));
    Copy = 0;
  }
  else
  {
    if ((_DWORD)v2 == 4 && (v3 = *(const __CFArray **)(a1 + 56)) != 0)
      Copy = CFArrayCreateCopy(0, v3);
    else
      Copy = 0;
    v5 = 0;
  }
  if (!SCDynamicStoreNotifyCancel(a1))
  {
    v6 = __log_SCDynamicStore_log;
    if (!__log_SCDynamicStore_log)
    {
      v6 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
      __log_SCDynamicStore_log = (uint64_t)v6;
    }
    v7 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = (char *)v89 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v17 = _os_log_pack_fill();
      v18 = SCError();
      v19 = SCErrorString(v18);
      *(_DWORD *)v17 = 136315138;
      *(_QWORD *)(v17 + 4) = v19;
      __SC_log_send(5, (uint64_t)v6, v7, v16);
    }
  }
  if (*(_OWORD *)(a1 + 168) == 0)
  {
    v20 = 1;
  }
  else
  {
    v20 = SCDynamicStoreSetNotificationKeys((SCDynamicStoreRef)a1, *(CFArrayRef *)(a1 + 168), *(CFArrayRef *)(a1 + 176));
    if (!(_DWORD)v20)
    {
      v43 = SCError();
      if (v43 != 1102)
      {
        v44 = v43;
        v45 = __log_SCDynamicStore_log;
        if (!__log_SCDynamicStore_log)
        {
          v45 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
          __log_SCDynamicStore_log = (uint64_t)v45;
        }
        v46 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v45, (os_log_type_t)v46))
        {
          v47 = _os_log_pack_size();
          v55 = (char *)v89
              - ((MEMORY[0x1E0C80A78](v47, v48, v49, v50, v51, v52, v53, v54) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v56 = _os_log_pack_fill();
          v57 = SCErrorString(v44);
          *(_DWORD *)v56 = 136315138;
          *(_QWORD *)(v56 + 4) = v57;
          __SC_log_send(5, (uint64_t)v45, v46, v55);
        }
      }
      goto LABEL_39;
    }
  }
  if ((_DWORD)v2 == 5)
  {
    v20 = SCDynamicStoreSetDispatchQueue((SCDynamicStoreRef)a1, v5);
    if (!(_DWORD)v20)
    {
      v28 = SCError();
      if (v28 != 1102)
      {
        v29 = v28;
        v30 = __log_SCDynamicStore_log;
        if (!__log_SCDynamicStore_log)
        {
          v30 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
          __log_SCDynamicStore_log = (uint64_t)v30;
        }
        v31 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v30, (os_log_type_t)v31))
        {
          v32 = _os_log_pack_size();
          v40 = (char *)v89
              - ((MEMORY[0x1E0C80A78](v32, v33, v34, v35, v36, v37, v38, v39) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v41 = _os_log_pack_fill();
          v42 = SCErrorString(v29);
          *(_DWORD *)v41 = 136315138;
          *(_QWORD *)(v41 + 4) = v42;
          __SC_log_send(5, (uint64_t)v30, v31, v40);
        }
      }
      v20 = 0;
    }
LABEL_44:
    if (v5)
      dispatch_release(v5);
    goto LABEL_53;
  }
  if ((_DWORD)v2 != 4)
  {
    _SCErrorSet(1001);
LABEL_39:
    v20 = 0;
    goto LABEL_40;
  }
  RunLoopSource = SCDynamicStoreCreateRunLoopSource(0, (SCDynamicStoreRef)a1, 0);
  if (RunLoopSource)
  {
    v22 = RunLoopSource;
    if (Copy)
    {
      Count = CFArrayGetCount(Copy);
      if (Count >= 1)
      {
        v24 = Count;
        for (i = 0; i < v24; i += 3)
        {
          ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(Copy, i + 1);
          v27 = (const __CFString *)CFArrayGetValueAtIndex(Copy, i + 2);
          CFRunLoopAddSource(ValueAtIndex, v22, v27);
        }
      }
    }
    CFRelease(v22);
LABEL_40:
    if ((_DWORD)v2 != 5)
    {
      if ((_DWORD)v2 != 4 || !Copy)
        goto LABEL_53;
LABEL_52:
      CFRelease(Copy);
      goto LABEL_53;
    }
    goto LABEL_44;
  }
  v58 = SCError();
  if (v58 != 1102)
  {
    v59 = v58;
    v60 = __log_SCDynamicStore_log;
    if (!__log_SCDynamicStore_log)
    {
      v60 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
      __log_SCDynamicStore_log = (uint64_t)v60;
    }
    v61 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v60, (os_log_type_t)v61))
    {
      v62 = _os_log_pack_size();
      v70 = (char *)v89 - ((MEMORY[0x1E0C80A78](v62, v63, v64, v65, v66, v67, v68, v69) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v71 = _os_log_pack_fill();
      v72 = SCErrorString(v59);
      *(_DWORD *)v71 = 136315138;
      *(_QWORD *)(v71 + 4) = v72;
      __SC_log_send(5, (uint64_t)v60, v61, v70);
    }
  }
  v20 = 0;
  if (Copy)
    goto LABEL_52;
LABEL_53:
  if (!(_DWORD)v20)
  {
    v73 = SCError();
    v74 = __log_SCDynamicStore_log;
    if (!__log_SCDynamicStore_log)
    {
      v74 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
      __log_SCDynamicStore_log = (uint64_t)v74;
    }
    v75 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v74, (os_log_type_t)v75))
    {
      v76 = _os_log_pack_size();
      v84 = (char *)v89 - ((MEMORY[0x1E0C80A78](v76, v77, v78, v79, v80, v81, v82, v83) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v85 = _os_log_pack_fill();
      v86 = "failed";
      v87 = *((_QWORD *)&notifyType + v2);
      if (v73 == 1102)
        v86 = "shutdown";
      *(_DWORD *)v85 = 136315394;
      *(_QWORD *)(v85 + 4) = v86;
      *(_WORD *)(v85 + 12) = 2080;
      *(_QWORD *)(v85 + 14) = v87;
      __SC_log_send(5, (uint64_t)v74, v75, v84);
    }
  }
  pushDisconnect(a1);
  return v20;
}

uint64_t pushDisconnect(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(uint64_t, uint64_t);
  uint64_t (*v3)(_QWORD);
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  _QWORD v17[2];

  v1 = result;
  v17[1] = *MEMORY[0x1E0C80C00];
  v2 = *(uint64_t (**)(uint64_t, uint64_t))(result + 152);
  if (v2)
  {
    v4 = *(_QWORD *)(result + 88);
    v3 = *(uint64_t (**)(_QWORD))(result + 96);
    if (v3)
    {
      v4 = v3(*(_QWORD *)(result + 88));
      v5 = *(uint64_t (**)(uint64_t))(v1 + 104);
    }
    else
    {
      v5 = 0;
    }
    v6 = __log_SCDynamicStore_log;
    if (!__log_SCDynamicStore_log)
    {
      v6 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
      __log_SCDynamicStore_log = (uint64_t)v6;
    }
    v7 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = (char *)v17 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(7, (uint64_t)v6, v7, v16);
    }
    result = v2(v1, v4);
    if (v5)
      return v5(v4);
  }
  else
  {
    *(_BYTE *)(result + 160) = 1;
  }
  return result;
}

uint64_t SCDynamicStoreSetDisconnectCallBack(_QWORD *cf, uint64_t a2)
{
  uint64_t v4;

  if (__SCDynamicStoreInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCDynamicStoreInitialize_initialized, &__block_literal_global_51);
    if (!cf)
      goto LABEL_6;
  }
  v4 = __kSCDynamicStoreTypeID;
  if (CFGetTypeID(cf) == v4)
  {
    cf[19] = a2;
    return 1;
  }
LABEL_6:
  _SCErrorSet(2001);
  return 0;
}

void addSessionReference(uint64_t a1, const __CFDictionary *a2)
{
  const __CFString *v2;
  __CFString *MutableCopy;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  const void *ValueAtIndex;
  const __CFArray *v10;
  CFIndex v11;
  CFIndex v12;
  const void *v13;
  int v14;
  void *value;
  int valuePtr;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *(const __CFString **)(a1 + 24);
  if (v2)
  {
    valuePtr = 0;
    value = 0;
    MutableCopy = CFStringCreateMutableCopy(0, 0, v2);
    v6 = *(const __CFArray **)(a1 + 168);
    if (v6)
    {
      Count = CFArrayGetCount(v6);
      if (Count >= 1)
      {
        v8 = Count;
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 168), 0);
        CFStringAppendFormat(MutableCopy, 0, CFSTR(":k[0/%ld]=%@"), v8, ValueAtIndex);
      }
    }
    v10 = *(const __CFArray **)(a1 + 176);
    if (v10)
    {
      v11 = CFArrayGetCount(v10);
      if (v11 >= 1)
      {
        v12 = v11;
        v13 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), 0);
        CFStringAppendFormat(MutableCopy, 0, CFSTR(":p[0/%ld]=%@"), v12, v13);
      }
    }
    if (CFDictionaryGetValueIfPresent(a2, MutableCopy, (const void **)&value)
      && CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr))
    {
      v14 = valuePtr + 1;
    }
    else
    {
      v14 = 1;
    }
    valuePtr = v14;
    value = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(a2, MutableCopy, value);
    CFRelease(value);
    CFRelease(MutableCopy);
  }
}

void logSessionReference(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v4 = __log_SCDynamicStore_log;
  if (!__log_SCDynamicStore_log)
  {
    v4 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
    __log_SCDynamicStore_log = (uint64_t)v4;
  }
  v5 = _SC_syslog_os_log_mapping(3);
  if (__SC_log_enabled(3, v4, (os_log_type_t)v5))
  {
    v6 = _os_log_pack_size();
    v14 = (char *)v16 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v15 = _os_log_pack_fill();
    *(_DWORD *)v15 = 138412546;
    *(_QWORD *)(v15 + 4) = a2;
    *(_WORD *)(v15 + 12) = 2112;
    *(_QWORD *)(v15 + 14) = a1;
    __SC_log_send(3, (uint64_t)v4, v5, v14);
  }
}

BOOL get_sysctl_val(const char *a1, _DWORD *a2)
{
  NSObject *v4;
  uint64_t v5;
  _BOOL8 result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int *v17;
  char *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  size_t v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  v33 = 4;
  if (sysctlbyname(a1, &v34, &v33, 0, 0))
  {
    v4 = __log_SCDynamicStore_log;
    if (!__log_SCDynamicStore_log)
    {
      v4 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
      __log_SCDynamicStore_log = (uint64_t)v4;
    }
    v5 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v4, (os_log_type_t)v5);
    if (result)
    {
      v7 = _os_log_pack_size();
      v15 = (char *)&v32 - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v16 = _os_log_pack_fill();
      v17 = __error();
      v18 = strerror(*v17);
      *(_DWORD *)v16 = 136315394;
      *(_QWORD *)(v16 + 4) = a1;
      *(_WORD *)(v16 + 12) = 2080;
      *(_QWORD *)(v16 + 14) = v18;
      __SC_log_send(5, (uint64_t)v4, v5, v15);
      return 0;
    }
  }
  else
  {
    *a2 = v34;
    v19 = __log_SCDynamicStore_log;
    if (!__log_SCDynamicStore_log)
    {
      v19 = os_log_create("com.apple.SystemConfiguration", "SCDynamicStore");
      __log_SCDynamicStore_log = (uint64_t)v19;
    }
    v20 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v19, (os_log_type_t)v20))
    {
      v21 = _os_log_pack_size();
      v29 = (char *)&v32 - ((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v30 = _os_log_pack_fill();
      v31 = v34;
      *(_DWORD *)v30 = 136315394;
      *(_QWORD *)(v30 + 4) = a1;
      *(_WORD *)(v30 + 12) = 1024;
      *(_DWORD *)(v30 + 14) = v31;
      __SC_log_send(6, (uint64_t)v19, v20, v29);
    }
    return 1;
  }
  return result;
}

void childForkHandler()
{
  _sc_server = 0;
}

__CFString *__SCDynamicStoreCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  const char *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCDynamicStore %p [%p]> {"), a1, v2);
  if (*(_DWORD *)(a1 + 40))
    CFStringAppendFormat(Mutable, 0, CFSTR("server port = 0x%x"), *(unsigned int *)(a1 + 40));
  else
    CFStringAppendFormat(Mutable, 0, CFSTR("server not (no longer) available"), v6);
  if (*(_QWORD *)(a1 + 152))
    CFStringAppendFormat(Mutable, 0, CFSTR(", disconnect = %p"), *(_QWORD *)(a1 + 152));
  switch(*(_DWORD *)(a1 + 48))
  {
    case 1:
      CFStringAppendFormat(Mutable, 0, CFSTR(", waiting for a notification"), v7);
      break;
    case 2:
      CFStringAppendFormat(Mutable, 0, CFSTR(", mach port notifications"), v7);
      break;
    case 3:
      CFStringAppendFormat(Mutable, 0, CFSTR(", FD notifications"), v7);
      break;
    case 4:
      CFStringAppendFormat(Mutable, 0, CFSTR(", runloop notifications"));
      CFStringAppendFormat(Mutable, 0, CFSTR(" {callout = %p"), *(_QWORD *)(a1 + 72));
      CFStringAppendFormat(Mutable, 0, CFSTR(", info = %p"), *(_QWORD *)(a1 + 88));
      CFStringAppendFormat(Mutable, 0, CFSTR(", rls = %p"), *(_QWORD *)(a1 + 64));
      CFStringAppendFormat(Mutable, 0, CFSTR(", notify rls = %@"), *(_QWORD *)(a1 + 128));
      goto LABEL_16;
    case 5:
      CFStringAppendFormat(Mutable, 0, CFSTR(", dispatch notifications"));
      CFStringAppendFormat(Mutable, 0, CFSTR(" {callout = %p"), *(_QWORD *)(a1 + 72));
      CFStringAppendFormat(Mutable, 0, CFSTR(", info = %p"), *(_QWORD *)(a1 + 88));
      CFStringAppendFormat(Mutable, 0, CFSTR(", queue = %p"), *(_QWORD *)(a1 + 136));
      CFStringAppendFormat(Mutable, 0, CFSTR(", source = %p"), *(_QWORD *)(a1 + 144));
LABEL_16:
      CFStringAppendFormat(Mutable, 0, CFSTR("}"), v8);
      break;
    default:
      if (*(_QWORD *)(a1 + 72))
        v4 = " (yet)";
      else
        v4 = "";
      CFStringAppendFormat(Mutable, 0, CFSTR(", notification delivery not requested%s"), v4);
      break;
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  return Mutable;
}

CFArrayRef SCDynamicStoreCopyKeyList(SCDynamicStoreRef store, CFStringRef pattern)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  const __CFArray *v7;
  CFIndex length;
  UInt8 *bytes;
  vm_size_t v10;
  uint64_t v11;
  CFTypeRef cf;
  uint64_t v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v13[0] = (uint64_t)store;
  v11 = 0;
  cf = 0;
  bytes = 0;
  v10 = 0;
  v7 = 0;
  length = 0;
  if (!__SCDynamicStoreNormalize((uint64_t)v13, 1))
    return 0;
  if (_SCSerializeString(pattern, (CFDataRef *)&cf, (vm_address_t *)&v11, &v10))
  {
    v3 = v13[0];
    do
      v4 = configlist(*(_DWORD *)(v3 + 40), v11, v10, 1u, &bytes, (unsigned int *)&length + 1, &length);
    while (__SCDynamicStoreCheckRetryAndHandleError(v13[0], v4, &length, (uint64_t)"SCDynamicStoreCopyKeyList configlist()"));
    CFRelease(cf);
    v5 = length;
    if ((_DWORD)length)
    {
      if (bytes)
      {
        MEMORY[0x18D78D14C](*MEMORY[0x1E0C83DA0], bytes, HIDWORD(length));
        v5 = length;
      }
      goto LABEL_11;
    }
    if (_SCUnserialize((CFPropertyListRef *)&v7, 0, bytes, HIDWORD(length)))
      return v7;
  }
  v5 = 1001;
LABEL_11:
  _SCErrorSet(v5);
  return 0;
}

Boolean SCDynamicStoreAddTemporaryValue(SCDynamicStoreRef store, CFStringRef key, CFPropertyListRef value)
{
  uint64_t v6;
  Boolean v7;
  int v8;
  uint64_t v10;
  vm_size_t v11;
  uint64_t v12;
  CFTypeRef v13;
  vm_size_t v14;
  uint64_t v15;
  CFTypeRef cf;
  uint64_t v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v17[0] = (uint64_t)store;
  v15 = 0;
  cf = 0;
  v13 = 0;
  v14 = 0;
  v11 = 0;
  v12 = 0;
  v10 = 0;
  if (!__SCDynamicStoreNormalize((uint64_t)v17, 0))
    return 0;
  if (!_SCSerializeString(key, (CFDataRef *)&cf, (vm_address_t *)&v15, &v14))
    goto LABEL_8;
  if (!_SCSerialize(value, (CFDataRef *)&v13, (vm_address_t *)&v12, &v11))
  {
    CFRelease(cf);
LABEL_8:
    v8 = 1001;
LABEL_9:
    _SCErrorSet(v8);
    return 0;
  }
  do
    v6 = configadd_s(*((_DWORD *)store + 10), v15, v14, v12, v11, (int *)&v10 + 1, &v10);
  while (__SCDynamicStoreCheckRetryAndHandleError(v17[0], v6, &v10, (uint64_t)"SCDynamicStoreAddTemporaryValue configadd_s()"));
  CFRelease(cf);
  CFRelease(v13);
  v7 = 1;
  v8 = __SCDynamicStoreMapInternalStatus(v10, 1);
  LODWORD(v10) = v8;
  if (v8)
    goto LABEL_9;
  return v7;
}

Boolean SCDynamicStoreAddValue(SCDynamicStoreRef store, CFStringRef key, CFPropertyListRef value)
{
  uint64_t v5;
  uint64_t v6;
  Boolean v7;
  int v8;
  uint64_t v10;
  vm_size_t v11;
  uint64_t v12;
  CFTypeRef cf;
  vm_size_t v14;
  uint64_t v15;
  CFDataRef v16;
  uint64_t v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v17[0] = (uint64_t)store;
  v14 = 0;
  v15 = 0;
  v12 = 0;
  cf = 0;
  v10 = 0;
  v11 = 0;
  if (!__SCDynamicStoreNormalize((uint64_t)v17, 1))
    return 0;
  if (!_SCSerializeString(key, &v16, (vm_address_t *)&v15, &v14))
    goto LABEL_9;
  if (!_SCSerialize(value, (CFDataRef *)&cf, (vm_address_t *)&v12, &v11))
  {
    CFRelease(v16);
LABEL_9:
    v8 = 1001;
LABEL_10:
    _SCErrorSet(v8);
    return 0;
  }
  v5 = v17[0];
  do
    v6 = configadd(*(_DWORD *)(v5 + 40), v15, v14, v12, v11, (int *)&v10 + 1, &v10);
  while (__SCDynamicStoreCheckRetryAndHandleError(v17[0], v6, &v10, (uint64_t)"SCDynamicStoreAddValue configadd()"));
  CFRelease(v16);
  CFRelease(cf);
  v7 = 1;
  v8 = __SCDynamicStoreMapInternalStatus(v10, 1);
  LODWORD(v10) = v8;
  if (v8)
    goto LABEL_10;
  return v7;
}

Boolean SCDynamicStoreRemoveValue(SCDynamicStoreRef store, CFStringRef key)
{
  uint64_t v3;
  __CFDictionary *v4;
  const __CFArray *Mutable;
  Boolean v6;
  uint64_t v7;
  int v8;
  unsigned int v10;
  vm_size_t v11;
  uint64_t v12;
  CFTypeRef cf;
  uint64_t v14[2];
  CFRange v15;

  v14[1] = *MEMORY[0x1E0C80C00];
  cf = 0;
  v14[0] = (uint64_t)store;
  v11 = 0;
  v12 = 0;
  v10 = 0;
  if (!__SCDynamicStoreNormalize((uint64_t)v14, 1))
    return 0;
  v3 = v14[0];
  if (!*(_BYTE *)(v14[0] + 200))
  {
    if (_SCSerializeString(key, (CFDataRef *)&cf, (vm_address_t *)&v12, &v11))
    {
      do
        v7 = configremove(*(_DWORD *)(v3 + 40), v12, v11, (int *)&v10);
      while (__SCDynamicStoreCheckRetryAndHandleError(v14[0], v7, &v10, (uint64_t)"SCDynamicStoreRemoveValue configremove()"));
      CFRelease(cf);
      v6 = 1;
      v8 = __SCDynamicStoreMapInternalStatus(v10, 1);
      v10 = v8;
      if (!v8)
        return v6;
    }
    else
    {
      v8 = 1001;
    }
    _SCErrorSet(v8);
    return 0;
  }
  v4 = *(__CFDictionary **)(v14[0] + 216);
  if (v4)
    CFDictionaryRemoveValue(v4, key);
  Mutable = *(const __CFArray **)(v3 + 224);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    *(_QWORD *)(v3 + 224) = Mutable;
  }
  v15.length = CFArrayGetCount(Mutable);
  v15.location = 0;
  if (!CFArrayContainsValue(Mutable, v15, key))
    CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 224), key);
  return 1;
}

Boolean SCDynamicStoreNotifyValue(SCDynamicStoreRef store, CFStringRef key)
{
  uint64_t v3;
  const __CFArray *Mutable;
  Boolean v5;
  uint64_t v6;
  int v7;
  unsigned int v9;
  vm_size_t v10;
  uint64_t v11;
  CFTypeRef cf;
  uint64_t v13[2];
  CFRange v14;

  v13[1] = *MEMORY[0x1E0C80C00];
  cf = 0;
  v13[0] = (uint64_t)store;
  v10 = 0;
  v11 = 0;
  v9 = 0;
  if (!__SCDynamicStoreNormalize((uint64_t)v13, 1))
    return 0;
  v3 = v13[0];
  if (!*(_BYTE *)(v13[0] + 200))
  {
    if (_SCSerializeString(key, (CFDataRef *)&cf, (vm_address_t *)&v11, &v10))
    {
      do
        v6 = confignotify(*(_DWORD *)(v3 + 40), v11, v10, (int *)&v9);
      while (__SCDynamicStoreCheckRetryAndHandleError(v13[0], v6, &v9, (uint64_t)"SCDynamicStoreNotifyValue confignotify()"));
      CFRelease(cf);
      v5 = 1;
      v7 = __SCDynamicStoreMapInternalStatus(v9, 1);
      v9 = v7;
      if (!v7)
        return v5;
    }
    else
    {
      v7 = 1001;
    }
    _SCErrorSet(v7);
    return 0;
  }
  Mutable = *(const __CFArray **)(v13[0] + 232);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    *(_QWORD *)(v3 + 232) = Mutable;
  }
  v14.length = CFArrayGetCount(Mutable);
  v14.location = 0;
  if (!CFArrayContainsValue(Mutable, v14, key))
    CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 232), key);
  return 1;
}

uint64_t SCDynamicStoreRemoveWatchedKey(uint64_t a1, const __CFString *a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  const __CFArray *v9;
  int v10;
  vm_size_t v11;
  uint64_t v12;
  CFTypeRef cf;
  uint64_t v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  cf = 0;
  v14[0] = a1;
  v11 = 0;
  v12 = 0;
  v10 = 0;
  result = __SCDynamicStoreNormalize((uint64_t)v14, 0);
  if (!(_DWORD)result)
    return result;
  if (!_SCSerializeString(a2, (CFDataRef *)&cf, (vm_address_t *)&v12, &v11))
  {
    v8 = 1001;
LABEL_8:
    _SCErrorSet(v8);
    return 0;
  }
  do
    v7 = notifyremove(*(_DWORD *)(a1 + 40), v12, v11, a3, &v10);
  while (__SCDynamicStoreCheckRetryAndHandleError(v14[0], v7, &v10, (uint64_t)"SCDynamicStoreRemoveWatchedKey notifyremove()"));
  CFRelease(cf);
  v8 = v10;
  if (v10)
    goto LABEL_8;
  if (a3)
    v9 = *(const __CFArray **)(a1 + 176);
  else
    v9 = *(const __CFArray **)(a1 + 168);
  removeKey(v9, a2);
  return 1;
}

void removeKey(const __CFArray *a1, const void *a2)
{
  CFIndex FirstIndexOfValue;
  CFRange v5;

  if (a1)
  {
    v5.length = CFArrayGetCount(a1);
    v5.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(a1, v5, a2);
    CFArrayRemoveValueAtIndex(a1, FirstIndexOfValue);
  }
}

uint64_t SCDynamicStoreNotifyWait(mach_port_context_t a1)
{
  uint64_t result;
  __n128 v3;
  int v4;
  mach_port_name_t v5;
  int v6;
  uint64_t v7;
  int v8;
  mach_port_context_t guard[2];

  guard[1] = *MEMORY[0x1E0C80C00];
  guard[0] = a1;
  v8 = 0;
  result = __SCDynamicStoreNormalize((uint64_t)guard, 0);
  if ((_DWORD)result)
  {
    if (*(_DWORD *)(a1 + 48))
    {
      v4 = 2003;
      goto LABEL_4;
    }
    result = __SCDynamicStoreAddNotificationPort(guard[0], v3);
    if ((_DWORD)result)
    {
      v5 = result;
      *(_DWORD *)(a1 + 48) = 1;
      v6 = waitForMachMessage(result);
      *(_DWORD *)(a1 + 48) = 0;
      if (v6 != 70)
      {
        if (v6 != -1)
        {
          v7 = notifycancel(*(_DWORD *)(a1 + 40), (mach_port_t *)&v8);
          if (__SCDynamicStoreCheckRetryAndHandleError(guard[0], v7, &v8, (uint64_t)"SCDynamicStoreNotifyWait notifycancel()"))v8 = 0;
          __SCDynamicStoreRemoveNotificationPort(guard[0], v5);
          v4 = v8;
          if (!v8)
            return 1;
          goto LABEL_4;
        }
        mach_port_mod_refs(*MEMORY[0x1E0C83DA0], v5, 1u, -1);
      }
      v4 = 2002;
LABEL_4:
      _SCErrorSet(v4);
      return 0;
    }
  }
  return result;
}

uint64_t waitForMachMessage(mach_port_name_t rcv_name)
{
  mach_msg_return_t v1;
  mach_error_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  _BYTE msg[32];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  memset(msg, 0, sizeof(msg));
  v1 = mach_msg((mach_msg_header_t *)msg, 2, 0, 0x64u, rcv_name, 0, 0);
  if (!v1)
    return *(unsigned int *)&msg[20];
  v2 = v1;
  v3 = __log_SCDynamicStore();
  v4 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v3, (os_log_type_t)v4))
  {
    v5 = _os_log_pack_size();
    v13 = &msg[-((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0)];
    __error();
    v14 = _os_log_pack_fill();
    v15 = mach_error_string(v2);
    *(_DWORD *)v14 = 136315138;
    *(_QWORD *)(v14 + 4) = v15;
    __SC_log_send(5, (uint64_t)v3, v4, v13);
  }
  return 0xFFFFFFFFLL;
}

uint64_t __SCDynamicStoreRemoveNotificationPort(mach_port_context_t guard, mach_port_name_t a2)
{
  return mach_port_destruct(*MEMORY[0x1E0C83DA0], a2, 0, guard);
}

__CFString *rlsCopyDescription(uint64_t a1)
{
  __CFString *Mutable;
  uint64_t v3;
  uint64_t (*v4)(void);
  const void *v5;

  Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCDynamicStore RLS> {"));
  CFStringAppendFormat(Mutable, 0, CFSTR("store = %p"), a1);
  if (*(_DWORD *)(a1 + 48) == 4)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR(", callout = %p"), *(_QWORD *)(a1 + 72));
    v3 = *(_QWORD *)(a1 + 88);
    if (v3)
    {
      v4 = *(uint64_t (**)(void))(a1 + 112);
      if (v4)
      {
        v5 = (const void *)v4();
        if (v5)
        {
LABEL_8:
          CFStringAppendFormat(Mutable, 0, CFSTR(", context = %@"), v5);
          CFRelease(v5);
          goto LABEL_9;
        }
        v3 = *(_QWORD *)(a1 + 88);
      }
    }
    v5 = CFStringCreateWithFormat(0, 0, CFSTR("<SCDynamicStore context %p>"), v3);
    if (!v5)
      v5 = CFRetain(CFSTR("<no description>"));
    goto LABEL_8;
  }
LABEL_9:
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  return Mutable;
}

void rlsCancel(mach_port_context_t a1, __CFRunLoop *a2, const __CFString *a3)
{
  __CFMachPort *v6;
  mach_port_name_t Port;
  const void *v8;
  const void *v9;
  __CFRunLoopSource *v10;
  __CFMachPort *v11;
  mach_port_t v12;
  uint64_t v13;
  mach_port_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 128) && _SC_unschedule((const void *)a1, a2, a3, *(CFArrayRef *)(a1 + 56), 0))
  {
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 56)))
    {
      if (!_SC_isScheduled((const void *)a1, a2, a3, *(CFArrayRef *)(a1 + 56)))
        CFRunLoopRemoveSource(a2, *(CFRunLoopSourceRef *)(a1 + 128), a3);
      return;
    }
    CFRunLoopRemoveSource(a2, *(CFRunLoopSourceRef *)(a1 + 128), a3);
  }
  v14 = 0;
  v6 = *(__CFMachPort **)(a1 + 120);
  if (v6)
    Port = CFMachPortGetPort(v6);
  else
    Port = 0;
  v8 = *(const void **)(a1 + 64);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v9 = *(const void **)(a1 + 56);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v10 = *(__CFRunLoopSource **)(a1 + 128);
  if (v10)
  {
    CFRunLoopSourceInvalidate(v10);
    CFRelease(*(CFTypeRef *)(a1 + 128));
    *(_QWORD *)(a1 + 128) = 0;
  }
  v11 = *(__CFMachPort **)(a1 + 120);
  if (v11)
  {
    CFMachPortInvalidate(v11);
    CFRelease(*(CFTypeRef *)(a1 + 120));
    *(_QWORD *)(a1 + 120) = 0;
  }
  v12 = *(_DWORD *)(a1 + 40);
  if (v12)
  {
    v13 = notifycancel(v12, &v14);
    if (__SCDynamicStoreCheckRetryAndHandleError(a1, v13, &v14, (uint64_t)"rlsCancel notifycancel()"))
      v14 = 0;
  }
  if (Port)
    mach_port_destruct(*MEMORY[0x1E0C83DA0], Port, 0, a1);
  if (!v14)
    *(_DWORD *)(a1 + 48) = 0;
}

void rlsPerform(uint64_t a1)
{
  const __CFArray *v2;
  CFArrayRef v3;
  void (*v4)(uint64_t, CFArrayRef, uint64_t);
  uint64_t (*v5)(_QWORD);
  uint64_t v6;
  void (*v7)(uint64_t);
  int v8;
  NSObject *v9;
  uint64_t v10;
  _BOOL4 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD v42[2];

  v42[1] = *MEMORY[0x1E0C80C00];
  v2 = SCDynamicStoreCopyNotifiedKeys((SCDynamicStoreRef)a1);
  v3 = v2;
  if (*(_BYTE *)(a1 + 160))
  {
    *(_BYTE *)(a1 + 160) = 0;
    if (!v2)
      v3 = CFArrayCreate(0, 0, 0, MEMORY[0x1E0C9B378]);
  }
  else
  {
    if (!v2)
      return;
    if (!CFArrayGetCount(v2))
      goto LABEL_21;
  }
  v4 = *(void (**)(uint64_t, CFArrayRef, uint64_t))(a1 + 72);
  v6 = *(_QWORD *)(a1 + 88);
  v5 = *(uint64_t (**)(_QWORD))(a1 + 96);
  if (v5)
  {
    v6 = v5(*(_QWORD *)(a1 + 88));
    v7 = *(void (**)(uint64_t))(a1 + 104);
  }
  else
  {
    v7 = 0;
  }
  v8 = *(_DWORD *)(a1 + 48);
  v9 = __log_SCDynamicStore();
  v10 = _SC_syslog_os_log_mapping(7);
  v11 = __SC_log_enabled(7, v9, (os_log_type_t)v10);
  if (!v8 || !v4)
  {
    if (!v11)
      goto LABEL_18;
    v34 = _os_log_pack_size();
    v31 = (char *)v42 - ((MEMORY[0x1E0C80A78](v34, v35, v36, v37, v38, v39, v40, v41) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    v32 = (uint64_t)v9;
    v33 = v10;
    goto LABEL_17;
  }
  if (v11)
  {
    v12 = _os_log_pack_size();
    v20 = (char *)v42 - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(7, (uint64_t)v9, v10, v20);
  }
  v4(a1, v3, v6);
  v21 = __log_SCDynamicStore();
  v22 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v21, (os_log_type_t)v22))
  {
    v23 = _os_log_pack_size();
    v31 = (char *)v42 - ((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    v32 = (uint64_t)v21;
    v33 = v22;
LABEL_17:
    __SC_log_send(7, v32, v33, v31);
  }
LABEL_18:
  if (v7)
    v7(v6);
  if (v3)
LABEL_21:
    CFRelease(v3);
}

CFStringRef notifyMPCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<SCDynamicStore notification MP> {store = %p}"), a1);
}

void rlsCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFRunLoopSource *v5;

  if (*(_DWORD *)(a2 + 20) == 70)
    __SCDynamicStoreReconnectNotifications(a4);
  v5 = *(__CFRunLoopSource **)(a4 + 64);
  if (v5)
    CFRunLoopSourceSignal(v5);
}

uint64_t SCDynamicStoreNotifyFileDescriptor(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  int *v9;
  NSObject *v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  int *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  int v27[2];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v26 = a1;
  *(_QWORD *)v27 = -1;
  v25 = 0;
  result = __SCDynamicStoreNormalize((uint64_t)&v26, 0);
  if ((_DWORD)result)
  {
    if (*(_DWORD *)(a1 + 48))
    {
      _SCErrorSet(2003);
      return 0;
    }
    if (pipe(v27) == -1)
    {
      v9 = __error();
      _SCErrorSet(*v9);
      v10 = __log_SCDynamicStore();
      v11 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v10, (os_log_type_t)v11))
      {
LABEL_12:
        v13 = _os_log_pack_size();
        v21 = (char *)&v25 - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v22 = _os_log_pack_fill();
        v23 = __error();
        v24 = strerror(*v23);
        *(_DWORD *)v22 = 136315138;
        *(_QWORD *)(v22 + 4) = v24;
        __SC_log_send(3, (uint64_t)v10, v11, v21);
      }
    }
    else
    {
      HIDWORD(v25) = 0;
      if ((fileport_makeport() & 0x80000000) == 0)
      {
        do
          v7 = notifyviafd(*(_DWORD *)(a1 + 40), SHIDWORD(v25), a2, (int *)&v25);
        while (__SCDynamicStoreCheckRetryAndHandleError(v26, v7, &v25, (uint64_t)"SCDynamicStoreNotifyFileDescriptor notifyviafd()"));
        if ((_DWORD)v7)
        {
          v8 = v7;
        }
        else
        {
          v8 = v25;
          if (!(_DWORD)v25)
          {
            close(v27[1]);
            *a3 = v27[0];
            *(_DWORD *)(a1 + 48) = 3;
            return 1;
          }
        }
        _SCErrorSet(v8);
        goto LABEL_15;
      }
      v12 = __error();
      _SCErrorSet(*v12);
      v10 = __log_SCDynamicStore();
      v11 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v10, (os_log_type_t)v11))
        goto LABEL_12;
    }
LABEL_15:
    if (v27[0] != -1)
      close(v27[0]);
    if (v27[1] != -1)
      close(v27[1]);
    return 0;
  }
  return result;
}

_xpc_connection_s *CategoryManagerConnectionCreate(dispatch_queue_t targetq, uint64_t a2)
{
  _xpc_connection_s *mach_service;
  _QWORD handler[7];

  handler[6] = *MEMORY[0x1E0C80C00];
  mach_service = xpc_connection_create_mach_service("com.apple.SystemConfiguration.NetworkCategoryManager", targetq, 2uLL);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = __CategoryManagerConnectionCreate_block_invoke;
  handler[3] = &unk_1E25D07B8;
  handler[4] = a2;
  handler[5] = mach_service;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_activate(mach_service);
  return mach_service;
}

size_t CategoryManagerHandleResponse(void *a1, int a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  size_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  const char *string;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int int64;
  int v48;
  NSObject *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  const char *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char *v83;
  _QWORD v84[2];

  v84[1] = *MEMORY[0x1E0C80C00];
  v6 = MEMORY[0x18D78D248]();
  if (v6 == MEMORY[0x1E0C812F8])
  {
    if (a2)
    {
      result = xpc_dictionary_get_count(a1);
      if (!result)
      {
        v48 = 3;
        goto LABEL_31;
      }
      v22 = _SC_LOG_DEFAULT();
      v23 = _SC_syslog_os_log_mapping(5);
      result = __SC_log_enabled(5, v22, (os_log_type_t)v23);
      if ((_DWORD)result)
      {
        v24 = _os_log_pack_size();
        v32 = (char *)v84 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v33 = _os_log_pack_fill();
        *(_DWORD *)v33 = 136315138;
        *(_QWORD *)(v33 + 4) = "CategoryManagerHandleResponse";
        v21 = (uint64_t)v22;
        v34 = v23;
        v35 = v32;
LABEL_28:
        __SC_log_send(5, v21, v34, v35);
        v48 = 0;
        goto LABEL_29;
      }
    }
    else
    {
      if (a1 == (void *)MEMORY[0x1E0C81260])
      {
        int64 = 2;
      }
      else
      {
        int64 = xpc_dictionary_get_int64(a1, "Error");
        if (!int64)
        {
          v48 = 0;
          result = 1;
          goto LABEL_31;
        }
      }
      v37 = _SC_LOG_DEFAULT();
      v9 = _SC_syslog_os_log_mapping(5);
      result = __SC_log_enabled(5, v37, (os_log_type_t)v9);
      if ((_DWORD)result)
      {
        v74 = _os_log_pack_size();
        v19 = (char *)v84 - ((MEMORY[0x1E0C80A78](v74, v75, v76, v77, v78, v79, v80, v81) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v82 = _os_log_pack_fill();
        v83 = strerror(int64);
        *(_DWORD *)v82 = 136315650;
        *(_QWORD *)(v82 + 4) = "CategoryManagerHandleResponse";
        *(_WORD *)(v82 + 12) = 2080;
        *(_QWORD *)(v82 + 14) = v83;
        *(_WORD *)(v82 + 22) = 1024;
        *(_DWORD *)(v82 + 24) = int64;
        goto LABEL_26;
      }
    }
LABEL_30:
    v48 = 0;
    goto LABEL_31;
  }
  v7 = v6;
  if (v6 != MEMORY[0x1E0C81310])
  {
    v8 = _SC_LOG_DEFAULT();
    v9 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v8, (os_log_type_t)v9);
    if ((_DWORD)result)
    {
      v11 = _os_log_pack_size();
      v19 = (char *)v84 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v20 = _os_log_pack_fill();
      *(_DWORD *)v20 = 136315394;
      *(_QWORD *)(v20 + 4) = "CategoryManagerHandleResponse";
      *(_WORD *)(v20 + 12) = 2048;
      *(_QWORD *)(v20 + 14) = v7;
      v21 = (uint64_t)v8;
LABEL_27:
      v34 = v9;
      v35 = v19;
      goto LABEL_28;
    }
    goto LABEL_30;
  }
  if (a1 == (void *)MEMORY[0x1E0C81258])
  {
    v49 = _SC_LOG_DEFAULT();
    v50 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v49, (os_log_type_t)v50);
    if ((_DWORD)result)
    {
      v51 = _os_log_pack_size();
      v59 = (char *)v84 - ((MEMORY[0x1E0C80A78](v51, v52, v53, v54, v55, v56, v57, v58) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v60 = _os_log_pack_fill();
      *(_DWORD *)v60 = 136315138;
      *(_QWORD *)(v60 + 4) = "CategoryManagerHandleResponse";
      __SC_log_send(5, (uint64_t)v49, v50, v59);
      v48 = 2;
LABEL_29:
      result = 0;
      goto LABEL_31;
    }
    v48 = 2;
  }
  else
  {
    if (a1 != (void *)MEMORY[0x1E0C81260])
    {
      string = xpc_dictionary_get_string(a1, (const char *)*MEMORY[0x1E0C81270]);
      v37 = _SC_LOG_DEFAULT();
      v9 = _SC_syslog_os_log_mapping(5);
      result = __SC_log_enabled(5, v37, (os_log_type_t)v9);
      if ((_DWORD)result)
      {
        v38 = _os_log_pack_size();
        v19 = (char *)v84 - ((MEMORY[0x1E0C80A78](v38, v39, v40, v41, v42, v43, v44, v45) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v46 = _os_log_pack_fill();
        *(_DWORD *)v46 = 136315394;
        *(_QWORD *)(v46 + 4) = "CategoryManagerHandleResponse";
        *(_WORD *)(v46 + 12) = 2080;
        *(_QWORD *)(v46 + 14) = string;
LABEL_26:
        v21 = (uint64_t)v37;
        goto LABEL_27;
      }
      goto LABEL_30;
    }
    v61 = _SC_LOG_DEFAULT();
    v62 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v61, (os_log_type_t)v62);
    if ((_DWORD)result)
    {
      v63 = _os_log_pack_size();
      v71 = (char *)v84 - ((MEMORY[0x1E0C80A78](v63, v64, v65, v66, v67, v68, v69, v70) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v72 = _os_log_pack_fill();
      v73 = "[async]";
      if (!a2)
        v73 = "";
      *(_DWORD *)v72 = 136315394;
      *(_QWORD *)(v72 + 4) = "CategoryManagerHandleResponse";
      *(_WORD *)(v72 + 12) = 2080;
      *(_QWORD *)(v72 + 14) = v73;
      __SC_log_send(5, (uint64_t)v61, v62, v71);
      v48 = 1;
      goto LABEL_29;
    }
    v48 = 1;
  }
LABEL_31:
  if (a3)
    *a3 = v48;
  return result;
}

uint64_t CategoryManagerConnectionRegister(_xpc_connection_s *a1, const __CFString *a2, const __CFString *a3, unsigned int a4)
{
  xpc_object_t v5;
  xpc_object_t v6;
  int64_t int64;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  _QWORD v34[2];

  v34[1] = *MEMORY[0x1E0C80C00];
  v5 = register_request_create(a2, a3, a4);
  v6 = CategoryManagerSendRequest(a1, v5);
  xpc_release(v5);
  if (v6)
  {
    if (v6 == (xpc_object_t)MEMORY[0x1E0C81260])
    {
      int64 = 2;
    }
    else
    {
      int64 = xpc_dictionary_get_int64(v6, "Error");
      if (!(_DWORD)int64)
      {
LABEL_11:
        xpc_release(v6);
        return int64;
      }
    }
    v20 = _SC_LOG_DEFAULT();
    v21 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v20, (os_log_type_t)v21))
    {
      v22 = _os_log_pack_size();
      v30 = (char *)v34 - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v31 = _os_log_pack_fill();
      v32 = strerror(int64);
      *(_DWORD *)v31 = 136315650;
      *(_QWORD *)(v31 + 4) = "CategoryManagerConnectionRegister";
      *(_WORD *)(v31 + 12) = 2080;
      *(_QWORD *)(v31 + 14) = v32;
      *(_WORD *)(v31 + 22) = 1024;
      *(_DWORD *)(v31 + 24) = int64;
      __SC_log_send(5, (uint64_t)v20, v21, v30);
    }
    goto LABEL_11;
  }
  v8 = _SC_LOG_DEFAULT();
  v9 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v8, (os_log_type_t)v9))
  {
    v10 = _os_log_pack_size();
    v18 = (char *)v34 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v19 = _os_log_pack_fill();
    *(_DWORD *)v19 = 136315138;
    *(_QWORD *)(v19 + 4) = "CategoryManagerConnectionRegister";
    __SC_log_send(5, (uint64_t)v8, v9, v18);
  }
  return 22;
}

xpc_object_t register_request_create(const __CFString *a1, const __CFString *a2, unsigned int a3)
{
  xpc_object_t v6;
  const char *v7;
  UInt8 *v8;
  UInt8 *v9;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_int64(v6, "Type", 1);
  v7 = getprogname();
  if (v7)
    xpc_dictionary_set_string(v6, "ProcessName", v7);
  if (!a1)
  {
    xpc_dictionary_set_string(v6, "Category", 0);
    if (!a2)
      goto LABEL_11;
    goto LABEL_9;
  }
  v8 = _SC_cfstring_to_cstring(a1, 0, 0, 0x8000100u);
  xpc_dictionary_set_string(v6, "Category", (const char *)v8);
  if (v8)
    CFAllocatorDeallocate(0, v8);
  if (a2)
  {
LABEL_9:
    v9 = _SC_cfstring_to_cstring(a2, 0, 0, 0x8000100u);
    xpc_dictionary_set_string(v6, "InterfaceName", (const char *)v9);
    if (v9)
      CFAllocatorDeallocate(0, v9);
  }
LABEL_11:
  xpc_dictionary_set_int64(v6, "Flags", a3);
  return v6;
}

xpc_object_t CategoryManagerSendRequest(_xpc_connection_s *a1, void *a2)
{
  xpc_object_t v4;
  xpc_object_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  HIDWORD(v19) = 0;
  v4 = xpc_connection_send_message_with_reply_sync(a1, a2);
  if (v4)
  {
    v5 = v4;
    while (!CategoryManagerHandleResponse(v5, 0, (int *)&v19 + 1) && HIDWORD(v19) == 2)
    {
      xpc_release(v5);
      HIDWORD(v19) = 0;
      v5 = xpc_connection_send_message_with_reply_sync(a1, a2);
      if (!v5)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v6 = _SC_LOG_DEFAULT();
    v7 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = (char *)&v19 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v17 = _os_log_pack_fill();
      *(_DWORD *)v17 = 136315138;
      *(_QWORD *)(v17 + 4) = "CategoryManagerSendRequest";
      __SC_log_send(5, (uint64_t)v6, v7, v16);
    }
    return 0;
  }
  return v5;
}

void CategoryManagerConnectionSynchronize(_xpc_connection_s *a1, const __CFString *a2, const __CFString *a3, unsigned int a4, const __CFString *a5)
{
  xpc_object_t v7;
  xpc_object_t v8;

  v7 = register_request_create(a2, a3, a4);
  xpc_connection_send_message(a1, v7);
  xpc_release(v7);
  v8 = activate_request_create(a5);
  xpc_connection_send_message(a1, v8);
  xpc_release(v8);
}

xpc_object_t activate_request_create(const __CFString *a1)
{
  xpc_object_t v2;
  UInt8 *v3;

  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_int64(v2, "Type", 2);
  if (a1)
  {
    v3 = _SC_cfstring_to_cstring(a1, 0, 0, 0x8000100u);
    xpc_dictionary_set_string(v2, "Value", (const char *)v3);
    if (v3)
      CFAllocatorDeallocate(0, v3);
  }
  return v2;
}

uint64_t CategoryManagerConnectionActivateValue(_xpc_connection_s *a1, const __CFString *a2)
{
  xpc_object_t v3;
  xpc_object_t v4;
  int64_t int64;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  _QWORD v32[2];

  v32[1] = *MEMORY[0x1E0C80C00];
  v3 = activate_request_create(a2);
  v4 = CategoryManagerSendRequest(a1, v3);
  xpc_release(v3);
  if (v4)
  {
    if (v4 == (xpc_object_t)MEMORY[0x1E0C81260])
    {
      int64 = 2;
    }
    else
    {
      int64 = xpc_dictionary_get_int64(v4, "Error");
      if (!(_DWORD)int64)
      {
LABEL_11:
        xpc_release(v4);
        return int64;
      }
    }
    v18 = _SC_LOG_DEFAULT();
    v19 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v18, (os_log_type_t)v19))
    {
      v20 = _os_log_pack_size();
      v28 = (char *)v32 - ((MEMORY[0x1E0C80A78](v20, v21, v22, v23, v24, v25, v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v29 = _os_log_pack_fill();
      v30 = strerror(int64);
      *(_DWORD *)v29 = 136315650;
      *(_QWORD *)(v29 + 4) = "CategoryManagerConnectionActivateValue";
      *(_WORD *)(v29 + 12) = 2080;
      *(_QWORD *)(v29 + 14) = v30;
      *(_WORD *)(v29 + 22) = 1024;
      *(_DWORD *)(v29 + 24) = int64;
      __SC_log_send(5, (uint64_t)v18, v19, v28);
    }
    goto LABEL_11;
  }
  v6 = _SC_LOG_DEFAULT();
  v7 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v6, (os_log_type_t)v7))
  {
    v8 = _os_log_pack_size();
    v16 = (char *)v32 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v17 = _os_log_pack_fill();
    *(_DWORD *)v17 = 136315138;
    *(_QWORD *)(v17 + 4) = "CategoryManagerConnectionActivateValue";
    __SC_log_send(5, (uint64_t)v6, v7, v16);
  }
  return 22;
}

CFStringRef CategoryManagerConnectionCopyActiveValue(_xpc_connection_s *a1, int *a2)
{
  xpc_object_t v4;
  xpc_object_t v5;
  int int64;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  CFStringRef v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  const char *string;
  _QWORD v35[2];

  v35[1] = *MEMORY[0x1E0C80C00];
  v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_int64(v4, "Type", 3);
  v5 = CategoryManagerSendRequest(a1, v4);
  xpc_release(v4);
  if (!v5)
  {
    v7 = _SC_LOG_DEFAULT();
    v8 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v7, (os_log_type_t)v8))
    {
      v9 = _os_log_pack_size();
      v17 = (char *)v35 - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v18 = _os_log_pack_fill();
      *(_DWORD *)v18 = 136315138;
      *(_QWORD *)(v18 + 4) = "CategoryManagerConnectionCopyActiveValue";
      __SC_log_send(5, (uint64_t)v7, v8, v17);
      int64 = 22;
      v19 = 0;
    }
    else
    {
      v19 = 0;
      int64 = 22;
    }
    goto LABEL_14;
  }
  if (v5 == (xpc_object_t)MEMORY[0x1E0C81260])
  {
    int64 = 2;
LABEL_8:
    v20 = _SC_LOG_DEFAULT();
    v21 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v20, (os_log_type_t)v21))
    {
      v22 = _os_log_pack_size();
      v30 = (char *)v35 - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v31 = _os_log_pack_fill();
      v32 = strerror(int64);
      *(_DWORD *)v31 = 136315650;
      *(_QWORD *)(v31 + 4) = "CategoryManagerConnectionCopyActiveValue";
      *(_WORD *)(v31 + 12) = 2080;
      *(_QWORD *)(v31 + 14) = v32;
      *(_WORD *)(v31 + 22) = 1024;
      *(_DWORD *)(v31 + 24) = int64;
      __SC_log_send(5, (uint64_t)v20, v21, v30);
    }
    goto LABEL_10;
  }
  int64 = xpc_dictionary_get_int64(v5, "Error");
  if (int64)
    goto LABEL_8;
LABEL_10:
  string = xpc_dictionary_get_string(v5, "ActiveValue");
  if (string)
    v19 = CFStringCreateWithCString(0, string, 0x8000100u);
  else
    v19 = 0;
  xpc_release(v5);
LABEL_14:
  *a2 = int64;
  return v19;
}

CFStringRef CategoryManagerConnectionCopyActiveValueNoSession(_xpc_connection_s *a1, const __CFString *a2, const __CFString *a3, int *a4)
{
  xpc_object_t v8;
  UInt8 *v9;
  UInt8 *v10;
  xpc_object_t v11;
  int int64;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  CFStringRef v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  char *v38;
  const char *string;
  _QWORD v41[2];

  v41[1] = *MEMORY[0x1E0C80C00];
  v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_int64(v8, "Type", 3);
  if (a2)
  {
    v9 = _SC_cfstring_to_cstring(a2, 0, 0, 0x8000100u);
    xpc_dictionary_set_string(v8, "Category", (const char *)v9);
    if (v9)
      CFAllocatorDeallocate(0, v9);
  }
  if (a3)
  {
    v10 = _SC_cfstring_to_cstring(a3, 0, 0, 0x8000100u);
    xpc_dictionary_set_string(v8, "InterfaceName", (const char *)v10);
    if (v10)
      CFAllocatorDeallocate(0, v10);
  }
  v11 = CategoryManagerSendRequest(a1, v8);
  xpc_release(v8);
  if (!v11)
  {
    v13 = _SC_LOG_DEFAULT();
    v14 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v13, (os_log_type_t)v14))
    {
      v15 = _os_log_pack_size();
      v23 = (char *)v41 - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v24 = _os_log_pack_fill();
      *(_DWORD *)v24 = 136315138;
      *(_QWORD *)(v24 + 4) = "CategoryManagerConnectionCopyActiveValueNoSession";
      __SC_log_send(5, (uint64_t)v13, v14, v23);
      int64 = 22;
      v25 = 0;
    }
    else
    {
      v25 = 0;
      int64 = 22;
    }
    goto LABEL_20;
  }
  if (v11 == (xpc_object_t)MEMORY[0x1E0C81260])
  {
    int64 = 2;
LABEL_14:
    v26 = _SC_LOG_DEFAULT();
    v27 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v26, (os_log_type_t)v27))
    {
      v28 = _os_log_pack_size();
      v36 = (char *)v41 - ((MEMORY[0x1E0C80A78](v28, v29, v30, v31, v32, v33, v34, v35) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v37 = _os_log_pack_fill();
      v38 = strerror(int64);
      *(_DWORD *)v37 = 136315650;
      *(_QWORD *)(v37 + 4) = "CategoryManagerConnectionCopyActiveValueNoSession";
      *(_WORD *)(v37 + 12) = 2080;
      *(_QWORD *)(v37 + 14) = v38;
      *(_WORD *)(v37 + 22) = 1024;
      *(_DWORD *)(v37 + 24) = int64;
      __SC_log_send(5, (uint64_t)v26, v27, v36);
    }
    goto LABEL_16;
  }
  int64 = xpc_dictionary_get_int64(v11, "Error");
  if (int64)
    goto LABEL_14;
LABEL_16:
  string = xpc_dictionary_get_string(v11, "ActiveValue");
  if (string)
    v25 = CFStringCreateWithCString(0, string, 0x8000100u);
  else
    v25 = 0;
  xpc_release(v11);
LABEL_20:
  *a4 = int64;
  return v25;
}

uint64_t SCDynamicStoreSnapshot(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  v5[0] = a1;
  v4 = 0;
  result = __SCDynamicStoreNormalize((uint64_t)v5, 1);
  if ((_DWORD)result)
  {
    v2 = v5[0];
    do
      v3 = snapshot(*(_DWORD *)(v2 + 40), (mach_port_t *)&v4);
    while (__SCDynamicStoreCheckRetryAndHandleError(v5[0], v3, &v4, (uint64_t)"SCDynamicStoreSnapshot snapshot()"));
    if (v4)
    {
      _SCErrorSet(v4);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t __SCPreferencesSetNetworkConfigurationFlags(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 308) = a2;
  return result;
}

BOOL __SCPreferencesIsEmpty(uint64_t a1)
{
  const __CFDictionary *v2;

  if (!a1)
    __SCPreferencesIsEmpty_cold_1();
  __SCPreferencesAccess(a1);
  v2 = *(const __CFDictionary **)(a1 + 280);
  return !v2 || CFDictionaryGetCount(v2) == 0;
}

const __CFData *__SCPreferencesPrefsSize(uint64_t a1)
{
  const __CFData *result;

  result = *(const __CFData **)(a1 + 144);
  if (result)
    return (const __CFData *)*((_QWORD *)CFDataGetBytePtr(result) + 4);
  return result;
}

CFDataRef SCPreferencesGetSignature(SCPreferencesRef prefs)
{
  if (prefs)
  {
    __SCPreferencesAccess((uint64_t)prefs);
    return (CFDataRef)*((_QWORD *)prefs + 18);
  }
  else
  {
    _SCErrorSet(3001);
    return 0;
  }
}

CFStringRef SCDynamicStoreKeyCreatePreferences(const __CFAllocator *a1, const __CFString *a2, int a3)
{
  return _SCPNotificationKey(a1, a2, a3);
}

uint64_t __SCPreferencesCreate_helper(uint64_t a1)
{
  mach_port_t *v2;
  __CFDictionary *Mutable;
  __CFDictionary *v4;
  const void *v5;
  const void *v6;
  CFNumberRef v7;
  const char *v8;
  CFStringRef v9;
  _BOOL4 v10;
  int v11;
  int v12;
  pid_t valuePtr;
  int v15;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = 0;
  v15 = 0;
  valuePtr = getpid();
  v2 = (mach_port_t *)(a1 + 320);
  if (!_SCHelperOpen(*(const __CFData **)(a1 + 312), (mach_port_name_t *)(a1 + 320)))
    goto LABEL_19;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v4 = Mutable;
  v5 = *(const void **)(a1 + 88);
  if (v5)
    CFDictionarySetValue(Mutable, CFSTR("prefsID"), v5);
  v6 = *(const void **)(a1 + 96);
  if (v6)
    CFDictionarySetValue(v4, CFSTR("options"), v6);
  CFDictionarySetValue(v4, CFSTR("name"), *(const void **)(a1 + 80));
  v7 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(v4, CFSTR("PID"), v7);
  CFRelease(v7);
  v8 = getprogname();
  v9 = CFStringCreateWithCString(0, v8, 0x8000100u);
  CFDictionarySetValue(v4, CFSTR("PROC_NAME"), v9);
  CFRelease(v9);
  v10 = _SCSerialize(v4, (CFDataRef *)cf, 0, 0);
  CFRelease(v4);
  if (!cf[0] || !v10)
    goto LABEL_19;
  v11 = _SCHelperExec(*v2, 100, (const __CFData *)cf[0], &v15, 0);
  if (cf[0])
    CFRelease(cf[0]);
  if (v11)
  {
    v12 = v15;
    if (!v15)
      return 1;
  }
  else
  {
LABEL_19:
    if (*v2)
      _SCHelperClose(v2);
    v12 = 1003;
    v15 = 1003;
  }
  _SCErrorSet(v12);
  return 0;
}

void log_open_error(uint64_t a1, int a2)
{
  int v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  char *v41;
  _QWORD v42[2];

  v42[1] = *MEMORY[0x1E0C80C00];
  if (log_open_error_once != -1)
    dispatch_once(&log_open_error_once, &__block_literal_global_39);
  getpid();
  v3 = sandbox_check();
  if (v3 == 1)
  {
    v20 = __log_SCPreferences_log;
    if (!__log_SCPreferences_log)
    {
      v20 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
      __log_SCPreferences_log = (uint64_t)v20;
    }
    v21 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v20, (os_log_type_t)v21))
      return;
    v22 = _os_log_pack_size();
    v30 = (char *)v42 - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
LABEL_17:
    v17 = (uint64_t)v20;
    v18 = v21;
    v19 = v30;
    goto LABEL_18;
  }
  if (v3)
  {
    v20 = __log_SCPreferences_log;
    if (!__log_SCPreferences_log)
    {
      v20 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
      __log_SCPreferences_log = (uint64_t)v20;
    }
    v21 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v20, (os_log_type_t)v21))
      return;
    v31 = _os_log_pack_size();
    v30 = (char *)v42 - ((MEMORY[0x1E0C80A78](v31, v32, v33, v34, v35, v36, v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v39 = _os_log_pack_fill();
    v40 = __error();
    v41 = strerror(*v40);
    *(_DWORD *)v39 = 136315138;
    *(_QWORD *)(v39 + 4) = v41;
    goto LABEL_17;
  }
  v4 = __log_SCPreferences_log;
  if (!__log_SCPreferences_log)
  {
    v4 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
    __log_SCPreferences_log = (uint64_t)v4;
  }
  v5 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v4, (os_log_type_t)v5))
  {
    v6 = _os_log_pack_size();
    v14 = (char *)v42 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v15 = _os_log_pack_fill();
    v16 = strerror(a2);
    *(_DWORD *)v15 = 136315138;
    *(_QWORD *)(v15 + 4) = v16;
    v17 = (uint64_t)v4;
    v18 = v5;
    v19 = v14;
LABEL_18:
    __SC_log_send(5, v17, v18, v19);
  }
}

void *SCPreferencesCreateCompanion(uint64_t a1, const __CFString *a2)
{
  const __CFAllocator *v4;
  const __CFString *v5;
  CFIndex Length;
  CFRange v7;
  CFStringRef v8;
  int v9;
  CFMutableStringRef MutableCopy;
  const __CFAllocator *v11;
  pthread_mutex_t *v13;
  const __CFDictionary *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  void *v27;
  void *v28;
  _QWORD *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  void *v42;
  __CFDictionary *Mutable;
  CFRange result;
  void *value[2];
  CFRange v46;
  CFRange v47;

  value[1] = *(void **)MEMORY[0x1E0C80C00];
  v4 = CFGetAllocator((CFTypeRef)a1);
  value[0] = 0;
  if (a2)
  {
    v46.length = CFStringGetLength(a2);
    v46.location = 0;
    if (CFStringFindWithOptions(a2, CFSTR("/"), v46, 4uLL, 0))
      goto LABEL_13;
  }
  else
  {
    a2 = CFSTR("preferences.plist");
  }
  v5 = *(const __CFString **)(a1 + 88);
  if (!v5)
  {
    if (!CFEqual(a2, CFSTR("preferences.plist")))
    {
      v11 = v4;
      goto LABEL_15;
    }
LABEL_13:
    _SCErrorSet(1002);
    return 0;
  }
  Length = CFStringGetLength(v5);
  result.location = 0;
  result.length = 0;
  v47.location = 0;
  v47.length = Length;
  if (!CFStringFindWithOptions(*(CFStringRef *)(a1 + 88), CFSTR("/"), v47, 4uLL, &result))
  {
    if (CFEqual(*(CFTypeRef *)(a1 + 88), a2))
      goto LABEL_13;
    v11 = 0;
LABEL_15:
    MutableCopy = CFStringCreateMutableCopy(v11, 0, a2);
    goto LABEL_16;
  }
  v7.location = result.location + 1;
  result.location = v7.location;
  if (Length <= v7.location)
    goto LABEL_13;
  result.length = Length - v7.location;
  v7.length = Length - v7.location;
  v8 = CFStringCreateWithSubstring(v4, *(CFStringRef *)(a1 + 88), v7);
  v9 = CFEqual(v8, a2);
  CFRelease(v8);
  if (v9)
    goto LABEL_13;
  MutableCopy = CFStringCreateMutableCopy(0, 0, *(CFStringRef *)(a1 + 88));
  CFStringReplace(MutableCopy, result, a2);
LABEL_16:
  if (!MutableCopy)
    SCPreferencesCreateCompanion_cold_1();
  v13 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v14 = *(const __CFDictionary **)(a1 + 296);
  if (v14 && CFDictionaryGetValueIfPresent(v14, MutableCopy, (const void **)value) && value[0])
  {
    v15 = __log_SCPreferences_log;
    if (!__log_SCPreferences_log)
    {
      v15 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
      __log_SCPreferences_log = (uint64_t)v15;
    }
    v16 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v15, (os_log_type_t)v16))
    {
      v17 = _os_log_pack_size();
      v25 = (char *)&result
          - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v26 = _os_log_pack_fill();
      v27 = value[0];
      *(_DWORD *)v26 = 138412290;
      *(_QWORD *)(v26 + 4) = v27;
      __SC_log_send(7, (uint64_t)v15, v16, v25);
    }
    CFRetain(value[0]);
  }
  else
  {
    v28 = (void *)__SCPreferencesCreate(v4, *(const __CFString **)(a1 + 80), MutableCopy, *(const void **)(a1 + 312), *(const __CFDictionary **)(a1 + 96));
    value[0] = v28;
    if (v28)
    {
      v29 = v28;
      v30 = __log_SCPreferences_log;
      if (!__log_SCPreferences_log)
      {
        v30 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
        __log_SCPreferences_log = (uint64_t)v30;
      }
      v31 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v30, (os_log_type_t)v31))
      {
        v32 = _os_log_pack_size();
        v40 = (char *)&result
            - ((MEMORY[0x1E0C80A78](v32, v33, v34, v35, v36, v37, v38, v39) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v41 = _os_log_pack_fill();
        v42 = value[0];
        *(_DWORD *)v41 = 138412290;
        *(_QWORD *)(v41 + 4) = v42;
        __SC_log_send(7, (uint64_t)v30, v31, v40);
      }
      v29[36] = CFRetain((CFTypeRef)a1);
      Mutable = *(__CFDictionary **)(a1 + 296);
      if (!Mutable)
      {
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], 0);
        *(_QWORD *)(a1 + 296) = Mutable;
      }
      CFDictionarySetValue(Mutable, MutableCopy, value[0]);
    }
  }
  pthread_mutex_unlock(v13);
  CFRelease(MutableCopy);
  return value[0];
}

CFTypeID SCPreferencesGetTypeID(void)
{
  if (__SCPreferencesInitialize_initialized != -1)
    dispatch_once(&__SCPreferencesInitialize_initialized, &__block_literal_global_48);
  return __kSCPreferencesTypeID;
}

void prefsNotify(int a1, CFArrayRef theArray, uint64_t a3)
{
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  uint64_t v8;
  const void *ValueAtIndex;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v11)(_QWORD);
  uint64_t v12;
  void (*v13)(uint64_t);
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  const char *v28;
  _QWORD v29[2];

  v29[1] = *MEMORY[0x1E0C80C00];
  if (theArray)
  {
    Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      v6 = Count;
      v7 = 0;
      LODWORD(v8) = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v7);
        if (CFEqual(ValueAtIndex, *(CFTypeRef *)(a3 + 184)))
        {
          v8 = v8 | 1;
        }
        else if (CFEqual(ValueAtIndex, *(CFTypeRef *)(a3 + 192)))
        {
          v8 = v8 | 2;
        }
        else
        {
          v8 = v8;
        }
        ++v7;
      }
      while (v6 != v7);
      if ((_DWORD)v8)
      {
        pthread_mutex_lock((pthread_mutex_t *)(a3 + 16));
        v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 216);
        v12 = *(_QWORD *)(a3 + 232);
        v11 = *(uint64_t (**)(_QWORD))(a3 + 240);
        if (v11)
        {
          v12 = v11(*(_QWORD *)(a3 + 232));
          v13 = *(void (**)(uint64_t))(a3 + 248);
        }
        else
        {
          v13 = 0;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a3 + 16));
        if (v10)
        {
          v14 = __log_SCPreferences_log;
          if (!__log_SCPreferences_log)
          {
            v14 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
            __log_SCPreferences_log = (uint64_t)v14;
          }
          v15 = _SC_syslog_os_log_mapping(7);
          if (__SC_log_enabled(7, v14, (os_log_type_t)v15))
          {
            v16 = _os_log_pack_size();
            v24 = (char *)v29
                - ((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v25 = _os_log_pack_fill();
            v26 = "commit";
            v27 = "";
            if ((v8 & 1) == 0)
              v26 = "";
            v28 = ", ";
            if ((~(_DWORD)v8 & 3) != 0)
              v28 = "";
            *(_DWORD *)v25 = 136315650;
            *(_QWORD *)(v25 + 4) = v26;
            *(_WORD *)(v25 + 12) = 2080;
            *(_QWORD *)(v25 + 14) = v28;
            if ((v8 & 2) != 0)
              v27 = "apply";
            *(_WORD *)(v25 + 22) = 2080;
            *(_QWORD *)(v25 + 24) = v27;
            __SC_log_send(7, (uint64_t)v14, v15, v24);
          }
          v10(a3, v8, v12);
        }
        if (v13)
          v13(v12);
      }
    }
  }
}

void appendLockedPreferences(int a1, uint64_t a2, __CFString *theString)
{
  CFIndex Length;
  const char *v6;

  Length = CFStringGetLength(theString);
  v6 = "";
  if (Length > 0)
    v6 = "\n";
  CFStringAppendFormat(theString, 0, CFSTR("%s%@"), v6, a2);
}

Boolean SCPreferencesUnscheduleFromRunLoop(SCPreferencesRef prefs, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v6;
  CFTypeID v7;

  if (__SCPreferencesInitialize_initialized == -1)
  {
    if (!prefs)
      goto LABEL_8;
  }
  else
  {
    dispatch_once(&__SCPreferencesInitialize_initialized, &__block_literal_global_48);
    if (!prefs)
      goto LABEL_8;
  }
  v6 = __kSCPreferencesTypeID;
  v7 = CFGetTypeID(prefs);
  if (runLoopMode && runLoop && v7 == v6)
    return __SCPreferencesUnscheduleFromRunLoop((uint64_t)prefs, runLoop, runLoopMode);
LABEL_8:
  _SCErrorSet(1002);
  return 0;
}

void __SCPreferencesHandleInternalStatus(int *a1)
{
  int v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  if (*a1 == 10003)
  {
    v3 = __log_SCPreferences_log;
    if (!__log_SCPreferences_log)
    {
      v3 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
      __log_SCPreferences_log = (uint64_t)v3;
    }
    v4 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v3, (os_log_type_t)v4))
      goto LABEL_16;
    goto LABEL_15;
  }
  if (v2 == 10002)
  {
    v3 = __log_SCPreferences_log;
    if (!__log_SCPreferences_log)
    {
      v3 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
      __log_SCPreferences_log = (uint64_t)v3;
    }
    v4 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v3, (os_log_type_t)v4))
      goto LABEL_16;
    goto LABEL_15;
  }
  if (v2 != 10001)
    return;
  v3 = __log_SCPreferences_log;
  if (!__log_SCPreferences_log)
  {
    v3 = os_log_create("com.apple.SystemConfiguration", "SCPreferences");
    __log_SCPreferences_log = (uint64_t)v3;
  }
  v4 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v3, (os_log_type_t)v4))
  {
LABEL_15:
    v5 = _os_log_pack_size();
    v13 = (char *)v14 - ((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(5, (uint64_t)v3, v4, v13);
  }
LABEL_16:
  *a1 = 1003;
}

void __log_open_error_block_invoke()
{
  log_open_error_sb_type = 1;
  if (_SC_isAppleInternal_once_1 != -1)
    dispatch_once(&_SC_isAppleInternal_once_1, &__block_literal_global_42);
  if (!_SC_isAppleInternal_isInternal_1)
    log_open_error_sb_type |= *MEMORY[0x1E0C806B0];
}

BOOL lockWithSCDynamicStore(uint64_t a1, int a2)
{
  SCDynamicStoreRef v4;
  CFAbsoluteTime Current;
  CFDateRef v6;
  int v7;
  _BOOL8 v8;
  CFArrayRef v9;
  CFAbsoluteTime v10;
  CFDateRef v11;
  int v12;
  int v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  CFArrayRef v37;
  const void *v38;
  _QWORD v40[2];

  v40[1] = *MEMORY[0x1E0C80C00];
  if (!__SCPreferencesAddSession(a1))
    return 0;
  if (!SCDynamicStoreAddWatchedKey(*(_QWORD *)(a1 + 152), *(__CFString **)(a1 + 176), 0))
  {
    v13 = SCError();
    v15 = __log_SCPreferences();
    v16 = _SC_syslog_os_log_mapping(6);
    if (!__SC_log_enabled(6, v15, (os_log_type_t)v16))
      goto LABEL_24;
LABEL_19:
    v17 = _os_log_pack_size();
    v25 = (char *)v40 - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(6, (uint64_t)v15, v16, v25);
    v14 = 1;
LABEL_20:
    v8 = 0;
    goto LABEL_25;
  }
  v4 = SCDynamicStoreCreate(0, *(CFStringRef *)(a1 + 80), 0, 0);
  *(_QWORD *)(a1 + 160) = v4;
  if (!v4)
  {
    v13 = SCError();
    v15 = __log_SCPreferences();
    v16 = _SC_syslog_os_log_mapping(6);
    if (!__SC_log_enabled(6, v15, (os_log_type_t)v16))
      goto LABEL_24;
    goto LABEL_19;
  }
  Current = CFAbsoluteTimeGetCurrent();
  v6 = CFDateCreate(0, Current);
  v7 = SCDynamicStoreAddTemporaryValue(*(SCDynamicStoreRef *)(a1 + 160), *(CFStringRef *)(a1 + 176), v6);
  CFRelease(v6);
  v8 = v7 != 0;
  if (v7 || !a2)
  {
LABEL_9:
    if (v8)
      v13 = 0;
    else
      v13 = 3002;
    v14 = !v8;
    goto LABEL_25;
  }
  while (1)
  {
    if (!SCDynamicStoreNotifyWait(*(_QWORD *)(a1 + 152)))
    {
      v13 = SCError();
      v15 = __log_SCPreferences();
      v16 = _SC_syslog_os_log_mapping(6);
      if (!__SC_log_enabled(6, v15, (os_log_type_t)v16))
        goto LABEL_24;
      goto LABEL_19;
    }
    v9 = SCDynamicStoreCopyNotifiedKeys(*(SCDynamicStoreRef *)(a1 + 152));
    if (!v9)
      break;
    CFRelease(v9);
    v10 = CFAbsoluteTimeGetCurrent();
    v11 = CFDateCreate(0, v10);
    v12 = SCDynamicStoreAddTemporaryValue(*(SCDynamicStoreRef *)(a1 + 160), *(CFStringRef *)(a1 + 176), v11);
    CFRelease(v11);
    v8 = v12 != 0;
    if (v12)
      goto LABEL_9;
  }
  v26 = __log_SCPreferences();
  v27 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v26, (os_log_type_t)v27))
  {
    v28 = _os_log_pack_size();
    v36 = (char *)v40 - ((MEMORY[0x1E0C80A78](v28, v29, v30, v31, v32, v33, v34, v35) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(6, (uint64_t)v26, v27, v36);
    v14 = 1;
    v13 = 0;
    goto LABEL_20;
  }
  v13 = 0;
LABEL_24:
  v8 = 0;
  v14 = 1;
LABEL_25:
  SCDynamicStoreRemoveWatchedKey(*(_QWORD *)(a1 + 152), *(const __CFString **)(a1 + 176), 0);
  v37 = SCDynamicStoreCopyNotifiedKeys(*(SCDynamicStoreRef *)(a1 + 152));
  if (v37)
    CFRelease(v37);
  __SCPreferencesRemoveSession(a1);
  if (v14)
  {
    v38 = *(const void **)(a1 + 160);
    if (v38)
    {
      CFRelease(v38);
      *(_QWORD *)(a1 + 160) = 0;
    }
  }
  if (v13)
    _SCErrorSet(v13);
  return v8;
}

uint64_t createParentDirectory()
{
  char *v0;
  __int128 v1;
  char *v2;
  unint64_t v3;
  char *v4;
  char v5;
  gid_t gr_gid;
  int *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  int *v20;
  char *v21;
  char *v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  int *v35;
  char *v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  int *v49;
  char *v50;
  uint64_t result;
  NSObject *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  int *v64;
  char *v65;
  __int128 v66;
  group *v67;
  group v68;
  char v69[256];
  char v70[1024];
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)__strlcpy_chk() >= 0x400 || (v0 = strrchr(v70, 47)) == 0 || v0 == v70)
  {
    *__error() = 2;
    return 0xFFFFFFFFLL;
  }
  v2 = v0;
  *v0 = 0;
  v3 = 0x1EE061000uLL;
  *(_QWORD *)&v1 = 136315138;
  v66 = v1;
  v4 = v70;
LABEL_5:
  v5 = *v2;
  *v2 = 0;
  while (1)
  {
    if (!mkdir(v70, 0x1EDu))
    {
      gr_gid = *(_DWORD *)(v3 + 3560);
      if (gr_gid == -1)
      {
        memset(&v68, 0, sizeof(v68));
        v67 = 0;
        if (getgrnam_r("wheel", &v68, v69, 0x100uLL, &v67) || !v67)
        {
          v8 = __log_SCPreferences();
          v9 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v8, (os_log_type_t)v9))
          {
            v10 = _os_log_pack_size();
            v18 = (char *)&v66
                - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v19 = _os_log_pack_fill();
            v20 = __error();
            v21 = strerror(*v20);
            *(_DWORD *)v19 = v66;
            *(_QWORD *)(v19 + 4) = v21;
            v22 = v18;
            v3 = 0x1EE061000uLL;
            __SC_log_send(5, (uint64_t)v8, v9, v22);
          }
          gr_gid = 0;
        }
        else
        {
          gr_gid = v67->gr_gid;
        }
        *(_DWORD *)(v3 + 3560) = gr_gid;
      }
      if (chown(v70, 0xFFFFFFFF, gr_gid) == -1)
      {
        v23 = __log_SCPreferences();
        v24 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v23, (os_log_type_t)v24))
        {
          v25 = _os_log_pack_size();
          v33 = (char *)&v66
              - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v34 = _os_log_pack_fill();
          v35 = __error();
          v36 = strerror(*v35);
          *(_DWORD *)v34 = v66;
          *(_QWORD *)(v34 + 4) = v36;
          v3 = 0x1EE061000;
          __SC_log_send(5, (uint64_t)v23, v24, v33);
        }
      }
      if (chmod(v70, 0x1EDu) == -1)
      {
        v37 = __log_SCPreferences();
        v38 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v37, (os_log_type_t)v38))
        {
          v39 = _os_log_pack_size();
          v47 = (char *)&v66
              - ((MEMORY[0x1E0C80A78](v39, v40, v41, v42, v43, v44, v45, v46) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v48 = _os_log_pack_fill();
          v49 = __error();
          v50 = strerror(*v49);
          *(_DWORD *)v48 = v66;
          *(_QWORD *)(v48 + 4) = v50;
          v3 = 0x1EE061000;
          __SC_log_send(5, (uint64_t)v37, v38, v47);
        }
      }
      result = 0;
      if (!v2 || v4 == v70)
        return result;
      goto LABEL_31;
    }
    if (*__error() != 2 || v4 != v70)
      break;
    if (!v2)
      goto LABEL_36;
LABEL_31:
    *v2 = v5;
    v2 = strchr(v4 + 1, 47);
    v4 = v2;
    if (v2)
      goto LABEL_5;
    v5 = 0;
  }
  if (*__error() == 30)
    return 0xFFFFFFFFLL;
  v7 = __error();
  if (v2 && *v7 == 17)
    goto LABEL_31;
LABEL_36:
  v52 = __log_SCPreferences();
  v53 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v52, (os_log_type_t)v53))
  {
    v54 = _os_log_pack_size();
    v62 = (char *)&v66 - ((MEMORY[0x1E0C80A78](v54, v55, v56, v57, v58, v59, v60, v61) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v63 = _os_log_pack_fill();
    v64 = __error();
    v65 = strerror(*v64);
    *(_DWORD *)v63 = v66;
    *(_QWORD *)(v63 + 4) = v65;
    __SC_log_send(5, (uint64_t)v52, v53, v62);
    return 0xFFFFFFFFLL;
  }
  return 0xFFFFFFFFLL;
}

BOOL has_O_EXLOCK(uint64_t a1)
{
  int v2;
  int v3;
  int v4;
  _BOOL8 result;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  char *v35;
  _QWORD v37[3];
  statfs v38;
  __int128 v39;
  __int128 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  memset(&v38, 0, 512);
  v2 = open(*(const char **)(a1 + 120), 513);
  if (v2 == -1)
  {
    v6 = __log_SCPreferences();
    v7 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v6, (os_log_type_t)v7);
    if (!result)
      return result;
    v8 = _os_log_pack_size();
    v16 = (char *)&v37[-1] - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
  }
  else
  {
    v3 = v2;
    v4 = fstatfs(v2, &v38);
    unlink(*(const char **)(a1 + 120));
    close(v3);
    if (v4 == -1)
    {
      v6 = __log_SCPreferences();
      v7 = _SC_syslog_os_log_mapping(5);
      result = __SC_log_enabled(5, v6, (os_log_type_t)v7);
      if (!result)
        return result;
      v17 = _os_log_pack_size();
      v16 = (char *)&v37[-1]
          - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
    }
    else
    {
      v37[0] = 5;
      v37[1] = 2147614720;
      v37[2] = 0;
      v39 = 0u;
      v40 = 0u;
      v41 = 0;
      if (getattrlist(v38.f_mntonname, v37, &v39, 0x24uLL, 0) != -1)
        return (BYTE9(v39) & 2) != 0 && (BYTE9(v40) & 2) != 0;
      v6 = __log_SCPreferences();
      v7 = _SC_syslog_os_log_mapping(5);
      result = __SC_log_enabled(5, v6, (os_log_type_t)v7);
      if (!result)
        return result;
      v25 = _os_log_pack_size();
      v16 = (char *)&v37[-1]
          - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
    }
  }
  v33 = _os_log_pack_fill();
  v34 = __error();
  v35 = strerror(*v34);
  *(_DWORD *)v33 = 136315138;
  *(_QWORD *)(v33 + 4) = v35;
  __SC_log_send(5, (uint64_t)v6, v7, v16);
  return 0;
}

void reportDelay(uint64_t a1, uint64_t *a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  const char *v22;
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  v6 = __log_SCPreferences();
  v7 = _SC_syslog_os_log_mapping(3);
  if (__SC_log_enabled(3, v6, (os_log_type_t)v7))
  {
    v8 = _os_log_pack_size();
    v16 = (char *)v23 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v17 = _os_log_pack_fill();
    v18 = *(_QWORD *)(a1 + 80);
    v19 = *(_QWORD *)(a1 + 88);
    v20 = *a2;
    v21 = *((_DWORD *)a2 + 2) / 1000;
    v22 = " (stale)";
    *(_DWORD *)v17 = 138413314;
    if (!a3)
      v22 = "";
    *(_QWORD *)(v17 + 4) = v18;
    *(_WORD *)(v17 + 12) = 2112;
    *(_QWORD *)(v17 + 14) = v19;
    *(_WORD *)(v17 + 22) = 1024;
    *(_DWORD *)(v17 + 24) = v20;
    *(_WORD *)(v17 + 28) = 1024;
    *(_DWORD *)(v17 + 30) = v21;
    *(_WORD *)(v17 + 34) = 2080;
    *(_QWORD *)(v17 + 36) = v22;
    __SC_log_send(3, (uint64_t)v6, v7, v16);
  }
}

void __wait_for_PreferencesMonitor()
{
  SCDynamicStoreRef v0;
  const __SCDynamicStore *v1;
  const __CFArray *v2;
  int v3;
  CFPropertyListRef v4;
  CFArrayRef v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  int v18;
  const char *v19;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  qword_1EE061F00 = (uint64_t)"Waiting for configd/PreferencesMonitor";
  v0 = SCDynamicStoreCreate(0, CFSTR("__wait_for_PreferencesMonitor"), 0, 0);
  if (!v0)
  {
    qword_1EE061F00 = 0;
    return;
  }
  v1 = v0;
  v2 = CFArrayCreate(0, (const void **)&kSCDynamicStoreDomainSetup, 1, MEMORY[0x1E0C9B378]);
  v3 = SCDynamicStoreSetNotificationKeys(v1, v2, 0);
  CFRelease(v2);
  if (v3)
  {
    while (1)
    {
      v4 = SCDynamicStoreCopyValue(v1, CFSTR("Setup:"));
      if (v4)
      {
        CFRelease(v4);
        goto LABEL_13;
      }
      if (!SCDynamicStoreNotifyWait((mach_port_context_t)v1))
        break;
      v5 = SCDynamicStoreCopyNotifiedKeys(v1);
      if (v5)
        CFRelease(v5);
    }
    v6 = __log_SCPreferences();
    v7 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v6, (os_log_type_t)v7))
      goto LABEL_13;
    goto LABEL_12;
  }
  v6 = __log_SCPreferences();
  v7 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v6, (os_log_type_t)v7))
  {
LABEL_12:
    v8 = _os_log_pack_size();
    v16 = (char *)v20 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v17 = _os_log_pack_fill();
    v18 = SCError();
    v19 = SCErrorString(v18);
    *(_DWORD *)v17 = 136315138;
    *(_QWORD *)(v17 + 4) = v19;
    __SC_log_send(5, (uint64_t)v6, v7, v16);
  }
LABEL_13:
  qword_1EE061F00 = 0;
  CFRelease(v1);
}

void reportDelay_0(uint64_t a1, uint64_t *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  v4 = __log_SCPreferences();
  v5 = _SC_syslog_os_log_mapping(3);
  if (__SC_log_enabled(3, v4, (os_log_type_t)v5))
  {
    v6 = _os_log_pack_size();
    v14 = (char *)v20 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v15 = _os_log_pack_fill();
    v16 = *(_QWORD *)(a1 + 80);
    v17 = *(_QWORD *)(a1 + 88);
    v18 = *a2;
    v19 = *((_DWORD *)a2 + 2) / 1000;
    *(_DWORD *)v15 = 138413058;
    *(_QWORD *)(v15 + 4) = v16;
    *(_WORD *)(v15 + 12) = 2112;
    *(_QWORD *)(v15 + 14) = v17;
    *(_WORD *)(v15 + 22) = 1024;
    *(_DWORD *)(v15 + 24) = v18;
    *(_WORD *)(v15 + 28) = 1024;
    *(_DWORD *)(v15 + 30) = v19;
    __SC_log_send(3, (uint64_t)v4, v5, v14);
  }
}

CFArrayRef SCPreferencesCopyKeyList(SCPreferencesRef prefs)
{
  const __CFAllocator *v2;
  CFIndex Count;
  CFIndex v4;
  const void **v5;
  const __CFArray *v6;

  if (prefs)
  {
    __SCPreferencesAccess((uint64_t)prefs);
    v2 = CFGetAllocator(prefs);
    Count = CFDictionaryGetCount(*((CFDictionaryRef *)prefs + 35));
    if (Count < 1)
    {
      return CFArrayCreate(v2, 0, 0, MEMORY[0x1E0C9B378]);
    }
    else
    {
      v4 = Count;
      v5 = (const void **)CFAllocatorAllocate(v2, 8 * Count, 0);
      CFDictionaryGetKeysAndValues(*((CFDictionaryRef *)prefs + 35), v5, 0);
      v6 = CFArrayCreate(v2, v5, v4, MEMORY[0x1E0C9B378]);
      CFAllocatorDeallocate(v2, v5);
      return v6;
    }
  }
  else
  {
    _SCErrorSet(3001);
    return 0;
  }
}

uint64_t __SCNetworkConfigurationBackup(const __SCPreferences *a1, const __CFString *a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  const __CFString *v18;
  CFMutableStringRef MutableCopy;
  CFIndex Length;
  CFIndex v21;
  const __SCPreferences *Companion;
  const __CFDictionary *Value;
  uint64_t v24;
  uint64_t v26;
  CFRange result;
  uint64_t v28;
  CFRange v29;
  CFRange v30;

  v28 = *MEMORY[0x1E0C80C00];
  result.location = 0;
  result.length = 0;
  v6 = __log_SCNetworkConfiguration();
  v7 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v6, (os_log_type_t)v7))
  {
    v8 = _os_log_pack_size();
    v16 = (char *)&v26 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v17 = _os_log_pack_fill();
    *(_DWORD *)v17 = 138412290;
    *(_QWORD *)(v17 + 4) = a2;
    __SC_log_send(5, (uint64_t)v6, v7, v16);
  }
  if (*((_QWORD *)a1 + 11))
    v18 = (const __CFString *)*((_QWORD *)a1 + 11);
  else
    v18 = CFSTR("preferences.plist");
  MutableCopy = CFStringCreateMutableCopy(0, 0, v18);
  v30.length = CFStringGetLength(MutableCopy);
  v30.location = 0;
  if (CFStringFindWithOptions(MutableCopy, CFSTR("/"), v30, 4uLL, &result))
  {
    v29.length = result.location + 1;
    result.location = 0;
    result.length = v29.length;
    v29.location = 0;
    CFStringReplace(MutableCopy, v29, &stru_1E25D5260);
  }
  Length = CFStringGetLength(MutableCopy);
  CFStringInsert(MutableCopy, Length - 6, CFSTR("-"));
  v21 = CFStringGetLength(MutableCopy);
  CFStringInsert(MutableCopy, v21 - 6, a2);
  Companion = (const __SCPreferences *)SCPreferencesCreateCompanion(a3, MutableCopy);
  CFRelease(MutableCopy);
  if (!Companion)
    return 0;
  Value = SCPreferencesPathGetValue(a1, CFSTR("/"));
  SCPreferencesPathSetValue(Companion, CFSTR("/"), Value);
  v24 = SCPreferencesCommitChanges(Companion);
  CFRelease(Companion);
  return v24;
}

uint64_t __SCNetworkConfigurationSaveModel(const __SCPreferences *a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  const __CFString *v16;
  uint64_t v17;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v4 = __log_SCNetworkConfiguration();
  v5 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v4, (os_log_type_t)v5))
  {
    v6 = _os_log_pack_size();
    v14 = (char *)v19 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v15 = _os_log_pack_fill();
    *(_DWORD *)v15 = 138412290;
    *(_QWORD *)(v15 + 4) = a2;
    __SC_log_send(5, (uint64_t)v4, v5, v14);
  }
  v16 = CFStringCreateWithFormat(0, 0, CFSTR("preferences-%@.plist"), a2);
  v17 = savePreferences(a1, v16, (uint64_t)&stru_1E25D5260, CFSTR("Model"), a2);
  CFRelease(v16);
  return v17;
}

uint64_t savePreferences(const __SCPreferences *a1, const __CFString *a2, uint64_t a3, const __CFString *a4, const void *a5)
{
  const __SCPreferences *Companion;
  uint64_t i;
  const __CFString *v11;
  const __CFString *v12;
  CFPropertyListRef Value;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  int v27;
  const char *v28;
  uint64_t v30;
  const __CFString *v31;
  _QWORD v32[8];

  v32[7] = *MEMORY[0x1E0C80C00];
  v32[0] = CFSTR("CurrentSet");
  v32[1] = CFSTR("Model");
  v32[2] = CFSTR("NetworkServices");
  v32[3] = CFSTR("Sets");
  v32[4] = CFSTR("System");
  v32[5] = CFSTR("__VERSION__");
  v32[6] = CFSTR("VirtualNetworkInterfaces");
  v31 = a2;
  Companion = (const __SCPreferences *)SCPreferencesCreateCompanion((uint64_t)a1, a2);
  for (i = 0; i != 7; ++i)
  {
    v11 = (const __CFString *)v32[i];
    v12 = CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), a3, v11);
    Value = SCPreferencesGetValue(a1, v12);
    if (Value)
    {
      SCPreferencesSetValue(Companion, v11, Value);
      SCPreferencesRemoveValue(a1, v12);
    }
    CFRelease(v12);
  }
  if (a4)
    SCPreferencesSetValue(Companion, a4, a5);
  v14 = SCPreferencesCommitChanges(Companion);
  CFRelease(Companion);
  if (!(_DWORD)v14)
  {
    v15 = __log_SCNetworkConfiguration();
    v16 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v15, (os_log_type_t)v16))
    {
      v17 = _os_log_pack_size();
      v25 = (char *)&v30 - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v26 = _os_log_pack_fill();
      v27 = SCError();
      v28 = SCErrorString(v27);
      *(_DWORD *)v26 = 138412546;
      *(_QWORD *)(v26 + 4) = v31;
      *(_WORD *)(v26 + 12) = 2080;
      *(_QWORD *)(v26 + 14) = v28;
      __SC_log_send(3, (uint64_t)v15, v16, v25);
    }
  }
  return v14;
}

uint64_t __SCNetworkConfigurationUpgrade(const __SCPreferences **a1, uint64_t *a2, int a3)
{
  const __SCPreferences *Companion;
  _BOOL4 v7;
  const __SCPreferences *v8;
  NSObject *v9;
  uint64_t v10;
  BOOL v11;
  int v14;
  const __SCPreferences *v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  int v30;
  const char *v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  int v44;
  const char *v45;
  CFNumberRef v46;
  CFNumberRef v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  int v60;
  const char *v61;
  NSObject *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  int v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  uint64_t v85;
  int v86;
  const char *v87;
  _QWORD v89[2];
  int valuePtr;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  valuePtr = 20191120;
  if (a1)
    Companion = *a1;
  else
    Companion = 0;
  v7 = a2 != 0;
  if (!a2)
  {
    v8 = 0;
LABEL_11:
    if (a1)
      v11 = Companion == 0;
    else
      v11 = 1;
    v14 = !v11 && a2 != 0 && v8 == 0;
    goto LABEL_29;
  }
  v8 = (const __SCPreferences *)*a2;
  if (!a1 && v8)
  {
    Companion = (const __SCPreferences *)SCPreferencesCreateCompanion(*a2, 0);
    if (!Companion)
    {
      v9 = __log_SCNetworkConfiguration();
      v10 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v9, (os_log_type_t)v10))
        goto LABEL_66;
      return 0;
    }
    goto LABEL_11;
  }
  v14 = 0;
  if (a1 && Companion && !v8)
  {
    v15 = (const __SCPreferences *)SCPreferencesCreateCompanion((uint64_t)Companion, CFSTR("NetworkInterfaces.plist"));
    if (!v15)
    {
      v9 = __log_SCNetworkConfiguration();
      v10 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v9, (os_log_type_t)v10))
      {
LABEL_66:
        v76 = _os_log_pack_size();
        v84 = (char *)v89 - ((MEMORY[0x1E0C80A78](v76, v77, v78, v79, v80, v81, v82, v83) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v85 = _os_log_pack_fill();
        v86 = SCError();
        v87 = SCErrorString(v86);
        *(_DWORD *)v85 = 136315138;
        *(_QWORD *)(v85 + 4) = v87;
        __SC_log_send(3, (uint64_t)v9, v10, v84);
      }
      return 0;
    }
    v8 = v15;
    v7 = 0;
    v14 = 1;
  }
  else
  {
    v7 = 0;
  }
LABEL_29:
  if (needsUpdate(Companion) || needsUpdate(v8))
  {
    v16 = lockWithSync(Companion);
    if (!(_DWORD)v16)
    {
      v32 = __log_SCNetworkConfiguration();
      v33 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v32, (os_log_type_t)v33))
      {
        v34 = _os_log_pack_size();
        v42 = (char *)v89 - ((MEMORY[0x1E0C80A78](v34, v35, v36, v37, v38, v39, v40, v41) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v43 = _os_log_pack_fill();
        v44 = SCError();
        v45 = SCErrorString(v44);
        *(_DWORD *)v43 = 136315138;
        *(_QWORD *)(v43 + 4) = v45;
        __SC_log_send(3, (uint64_t)v32, v33, v42);
      }
      goto LABEL_39;
    }
    if (v8)
    {
      v17 = lockWithSync(v8);
      if (!(_DWORD)v17)
      {
        v18 = __log_SCNetworkConfiguration();
        v19 = _SC_syslog_os_log_mapping(3);
        if (__SC_log_enabled(3, v18, (os_log_type_t)v19))
        {
          v20 = _os_log_pack_size();
          v28 = (char *)v89
              - ((MEMORY[0x1E0C80A78](v20, v21, v22, v23, v24, v25, v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v29 = _os_log_pack_fill();
          v30 = SCError();
          v31 = SCErrorString(v30);
          *(_DWORD *)v29 = 136315138;
          *(_QWORD *)(v29 + 4) = v31;
          __SC_log_send(3, (uint64_t)v18, v19, v28);
        }
        SCPreferencesUnlock(Companion);
        goto LABEL_39;
      }
    }
    else
    {
      v17 = v16;
    }
    __SCNetworkConfigurationClean(Companion, v8);
    v46 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    SCPreferencesSetValue(Companion, CFSTR("__VERSION__"), v46);
    CFRelease(v46);
    if (v8)
    {
      v47 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      SCPreferencesSetValue(v8, CFSTR("__VERSION__"), v47);
      CFRelease(v47);
    }
    if (!a3)
    {
LABEL_51:
      SCPreferencesUnlock(Companion);
      if (v8)
      {
        if (a3)
        {
          if ((_DWORD)v17)
          {
            v17 = SCPreferencesCommitChanges(v8);
            if (!(_DWORD)v17)
            {
              v62 = __log_SCNetworkConfiguration();
              v63 = _SC_syslog_os_log_mapping(3);
              if (__SC_log_enabled(3, v62, (os_log_type_t)v63))
              {
                v64 = _os_log_pack_size();
                v72 = (char *)v89
                    - ((MEMORY[0x1E0C80A78](v64, v65, v66, v67, v68, v69, v70, v71) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v73 = _os_log_pack_fill();
                v74 = SCError();
                v75 = SCErrorString(v74);
                *(_DWORD *)v73 = 136315138;
                *(_QWORD *)(v73 + 4) = v75;
                __SC_log_send(3, (uint64_t)v62, v63, v72);
              }
              v17 = 0;
            }
          }
        }
        SCPreferencesUnlock(v8);
      }
      goto LABEL_59;
    }
    if (SCPreferencesCommitChanges(Companion))
    {
      v17 = SCPreferencesApplyChanges(Companion);
      if ((_DWORD)v17)
        goto LABEL_51;
      v48 = __log_SCNetworkConfiguration();
      v49 = _SC_syslog_os_log_mapping(3);
      if (!__SC_log_enabled(3, v48, (os_log_type_t)v49))
        goto LABEL_50;
    }
    else
    {
      v48 = __log_SCNetworkConfiguration();
      v49 = _SC_syslog_os_log_mapping(3);
      if (!__SC_log_enabled(3, v48, (os_log_type_t)v49))
      {
LABEL_50:
        v17 = 0;
        goto LABEL_51;
      }
    }
    v50 = _os_log_pack_size();
    v89[1] = v89;
    v58 = (char *)v89 - ((MEMORY[0x1E0C80A78](v50, v51, v52, v53, v54, v55, v56, v57) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v59 = _os_log_pack_fill();
    v60 = SCError();
    v61 = SCErrorString(v60);
    *(_DWORD *)v59 = 136315138;
    *(_QWORD *)(v59 + 4) = v61;
    __SC_log_send(3, (uint64_t)v48, v49, v58);
    goto LABEL_50;
  }
LABEL_39:
  v17 = 0;
LABEL_59:
  if (v7)
    CFRelease(Companion);
  if (v14)
  {
    if ((_DWORD)v17)
      *a2 = (uint64_t)CFRetain(v8);
    CFRelease(v8);
  }
  return v17;
}

const __SCPreferences *needsUpdate(const __SCPreferences *result)
{
  CFPropertyListRef Value;
  CFTypeID TypeID;
  int valuePtr;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  if (result)
  {
    Value = SCPreferencesGetValue(result, CFSTR("__VERSION__"));
    TypeID = CFNumberGetTypeID();
    if (Value && CFGetTypeID(Value) == TypeID && CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &valuePtr))
      return (const __SCPreferences *)(valuePtr != 20191120);
    else
      return (const __SCPreferences *)1;
  }
  return result;
}

uint64_t lockWithSync(const __SCPreferences *a1)
{
  uint64_t result;

  if (!a1)
    lockWithSync_cold_1();
  result = SCPreferencesLock(a1, 1u);
  if (!(_DWORD)result)
  {
    if (SCError() == 3005)
    {
      SCPreferencesSynchronize(a1);
      return SCPreferencesLock(a1, 1u);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t __SCNetworkConfigurationClean(const __SCPreferences *a1, const __SCPreferences *a2)
{
  uint64_t v4;
  const __CFString *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  __CFSet *Mutable;
  const CFSetCallBacks *v10;
  const __CFString *ValueAtIndex;
  __CFString *MutableCopy;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  CFArrayRef v24;
  const __CFArray *v25;
  const __CFString *v26;
  CFIndex v27;
  CFIndex v28;
  CFIndex v29;
  __CFSet *v30;
  const CFSetCallBacks *v31;
  const __CFString *v32;
  __CFString *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  _QWORD v68[2];

  v68[1] = *MEMORY[0x1E0C80C00];
  v4 = (uint64_t)SCPreferencesCopyKeyList(a1);
  if (v4)
  {
    v5 = CFStringCreateWithFormat(0, 0, CFSTR(" : %@"), CFSTR("Sets"));
    Count = CFArrayGetCount((CFArrayRef)v4);
    if (Count < 1)
    {
      Mutable = 0;
    }
    else
    {
      v7 = Count;
      v8 = 0;
      Mutable = 0;
      v10 = (const CFSetCallBacks *)MEMORY[0x1E0C9B3B0];
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v4, v8);
        if (CFStringHasSuffix(ValueAtIndex, v5))
        {
          if (!Mutable)
            Mutable = CFSetCreateMutable(0, 0, v10);
          MutableCopy = CFStringCreateMutableCopy(0, 0, ValueAtIndex);
          CFStringTrim(MutableCopy, v5);
          CFSetAddValue(Mutable, MutableCopy);
          CFRelease(MutableCopy);
        }
        ++v8;
      }
      while (v7 != v8);
    }
    CFRelease(v5);
    CFRelease((CFTypeRef)v4);
    if (Mutable)
    {
      CFSetApplyFunction(Mutable, (CFSetApplierFunction)thinInlineBackup, a1);
      CFRelease(Mutable);
      v13 = __log_SCNetworkConfiguration();
      v14 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v13, (os_log_type_t)v14))
      {
        v15 = _os_log_pack_size();
        v23 = (char *)v68 - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v13, v14, v23);
      }
      v4 = 1;
    }
    else
    {
      v4 = 0;
    }
  }
  v24 = SCPreferencesCopyKeyList(a1);
  if (v24)
  {
    v25 = v24;
    v26 = CFStringCreateWithFormat(0, 0, CFSTR(":%@"), CFSTR("Sets"));
    v27 = CFArrayGetCount(v25);
    if (v27 < 1)
    {
      v30 = 0;
    }
    else
    {
      v28 = v27;
      v29 = 0;
      v30 = 0;
      v31 = (const CFSetCallBacks *)MEMORY[0x1E0C9B3B0];
      do
      {
        v32 = (const __CFString *)CFArrayGetValueAtIndex(v25, v29);
        if (CFStringHasSuffix(v32, v26))
        {
          if (!v30)
            v30 = CFSetCreateMutable(0, 0, v31);
          v33 = CFStringCreateMutableCopy(0, 0, v32);
          CFStringTrim(v33, v26);
          CFSetAddValue(v30, v33);
          CFRelease(v33);
        }
        ++v29;
      }
      while (v28 != v29);
    }
    CFRelease(v26);
    CFRelease(v25);
    if (v30)
    {
      CFSetApplyFunction(v30, (CFSetApplierFunction)thinInlineModel, a1);
      CFRelease(v30);
      v34 = __log_SCNetworkConfiguration();
      v35 = _SC_syslog_os_log_mapping(5);
      if (!__SC_log_enabled(5, v34, (os_log_type_t)v35))
      {
        v4 = 1;
        if (!a2)
          goto LABEL_38;
        goto LABEL_31;
      }
      v36 = _os_log_pack_size();
      v44 = (char *)v68 - ((MEMORY[0x1E0C80A78](v36, v37, v38, v39, v40, v41, v42, v43) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v34, v35, v44);
      v4 = 1;
    }
  }
  if (!a2)
    goto LABEL_38;
LABEL_31:
  if (__SCNetworkConfigurationCleanHiddenInterfaces(a1, a2))
  {
    v45 = __log_SCNetworkConfiguration();
    v46 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v45, (os_log_type_t)v46))
    {
      v47 = _os_log_pack_size();
      v55 = (char *)v68 - ((MEMORY[0x1E0C80A78](v47, v48, v49, v50, v51, v52, v53, v54) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v45, v46, v55);
    }
    v4 = 1;
  }
LABEL_38:
  if (__SCNetworkConfigurationCleanServiceOrderIssues(a1))
  {
    v56 = __log_SCNetworkConfiguration();
    v57 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v56, (os_log_type_t)v57))
    {
      v58 = _os_log_pack_size();
      v66 = (char *)v68 - ((MEMORY[0x1E0C80A78](v58, v59, v60, v61, v62, v63, v64, v65) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v56, v57, v66);
    }
    return 1;
  }
  return v4;
}

uint64_t __SCNetworkConfigurationCleanHiddenInterfaces(const __SCPreferences *a1, const __SCPreferences *a2)
{
  const __CFArray *Mutable;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  __int128 v7;
  CFIndex v8;
  CFIndex v9;
  const __SCNetworkService *ValueAtIndex;
  const __SCNetworkInterface *Interface;
  CFStringRef BSDName;
  CFStringRef v13;
  int IsHiddenConfiguration;
  const char *v15;
  const __CFString *LocalizedDisplayName;
  int HasPrefix;
  const __SCNetworkInterface *v18;
  const __SCNetworkService *v19;
  const __SCNetworkService *v20;
  const __CFArray *v21;
  const __CFArray *v22;
  const __CFArray *v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex i;
  const __SCNetworkProtocol *v27;
  CFStringRef ProtocolType;
  const __CFArray *v29;
  const __CFArray *v30;
  CFIndex v31;
  CFIndex v32;
  CFIndex j;
  const __SCNetworkProtocol *v34;
  CFStringRef v35;
  CFIndex v36;
  CFIndex v37;
  CFIndex v38;
  CFStringRef Copy;
  const __CFString *v40;
  const __SCNetworkProtocol *v41;
  SCNetworkProtocolRef v42;
  const __SCNetworkProtocol *v43;
  int Enabled;
  int v45;
  const __CFString *v46;
  CFDictionaryRef Configuration;
  CFDictionaryRef v48;
  int v49;
  BOOL v50;
  NSObject *v51;
  uint64_t v52;
  BOOL v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  CFIndex v64;
  CFStringRef v65;
  CFStringRef v66;
  const __CFString *v67;
  uint64_t v68;
  BOOL v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  CFStringRef v79;
  uint64_t v80;
  CFIndex v81;
  CFStringRef v82;
  CFStringRef v83;
  _BOOL4 v85;
  NSObject *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  CFIndex v96;
  char *v97;
  uint64_t v98;
  CFStringRef ServiceID;
  CFStringRef Name;
  char *v101;
  NSObject *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  char *v112;
  uint64_t v113;
  const void *v114;
  const __CFArray *v115;
  const __CFArray *v116;
  __int128 v117;
  CFIndex v118;
  const __SCNetworkInterface *v119;
  const __CFArray *MemberInterfaces;
  const __CFArray *v121;
  CFIndex v122;
  CFIndex v123;
  CFIndex k;
  const __SCNetworkInterface *v125;
  CFStringRef v126;
  CFStringRef v127;
  NSObject *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  char *v139;
  uint64_t v140;
  const __CFArray *v141;
  const __CFArray *v142;
  CFIndex v143;
  __int128 v144;
  CFIndex v145;
  CFIndex v146;
  const __SCNetworkInterface *v147;
  const __SCNetworkInterface *PhysicalInterface;
  CFStringRef v149;
  CFStringRef v150;
  NSObject *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  char *v162;
  uint64_t v163;
  CFIndex v164;
  __int128 v165;
  CFIndex v166;
  int v167;
  CFIndex v168;
  int *v169;
  const __SCNetworkService *v170;
  const __SCNetworkInterface *v171;
  CFStringRef v172;
  CFStringRef v173;
  NSObject *v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  char *v187;
  uint64_t v188;
  int *v189;
  CFStringRef v190;
  CFStringRef v191;
  char *v192;
  BOOL v193;
  NSObject *v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  char *v204;
  uint64_t v205;
  const char *v206;
  uint64_t v207;
  const __CFArray *Value;
  CFTypeID TypeID;
  CFIndex v210;
  const __CFArray *v211;
  __CFArray *v212;
  CFIndex v213;
  __int128 v214;
  CFIndex v215;
  char *v216;
  CFIndex v217;
  const __CFDictionary *v218;
  const void *v219;
  int v220;
  _BOOL4 v222;
  NSObject *v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  char *v233;
  char *v234;
  uint64_t v235;
  char *v236;
  NSObject *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  int v247;
  uint64_t v248;
  char *v249;
  BOOL v251;
  NSObject *v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  char *v262;
  uint64_t v263;
  const char *v264;
  __int128 v265;
  __int128 v266;
  SCPreferencesRef v267;
  CFIndex v268;
  const __SCPreferences *v269;
  const __CFArray *v270;
  __int128 v271;
  __int128 v272;
  __int128 v273;
  __int128 v274;
  const __CFArray *v275;
  uint64_t v276;
  CFRange v277;
  CFRange v278;
  CFRange v279;
  CFRange v280;
  CFRange v281;

  v267 = a2;
  v276 = *MEMORY[0x1E0C80C00];
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v269 = a1;
  v4 = SCNetworkServiceCopyAll(a1);
  v5 = v4;
  v275 = Mutable;
  v270 = v4;
  if (v4)
  {
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v8 = Count;
      v9 = 0;
      *(_QWORD *)&v7 = 138412546;
      v271 = v7;
      *(_QWORD *)&v7 = 138412802;
      v265 = v7;
      *(_QWORD *)&v7 = 138413314;
      v266 = v7;
      v268 = Count;
      while (1)
      {
        ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(v5, v9);
        if (!SCNetworkServiceGetEnabled(ValueAtIndex))
          break;
        Interface = SCNetworkServiceGetInterface(ValueAtIndex);
        BSDName = SCNetworkInterfaceGetBSDName(Interface);
        if (!BSDName)
        {
          v53 = _sc_log != 1 && _sc_debug == 0;
          Mutable = v275;
          if (v53)
            goto LABEL_89;
          v51 = __log_SCNetworkConfiguration();
          v52 = _SC_syslog_os_log_mapping(6);
          if (!__SC_log_enabled(6, v51, (os_log_type_t)v52))
            goto LABEL_89;
          goto LABEL_56;
        }
        v13 = BSDName;
        IsHiddenConfiguration = _SCNetworkInterfaceIsHiddenConfiguration((unsigned __int8 *)Interface);
        v15 = "hidden";
        if (IsHiddenConfiguration)
          goto LABEL_8;
        LocalizedDisplayName = SCNetworkInterfaceGetLocalizedDisplayName(Interface);
        HasPrefix = CFStringHasPrefix(LocalizedDisplayName, CFSTR("Apple TV"));
        v15 = "effectively hidden";
        if (HasPrefix)
          goto LABEL_8;
        v68 = 0;
        do
        {
          if (v68 == 4)
            goto LABEL_65;
        }
        while (!CFStringHasPrefix(LocalizedDisplayName, off_1E25D0938[++v68]));
        v15 = "effectively hidden";
        if ((unint64_t)(v68 - 1) < 4)
        {
LABEL_8:
          *(_QWORD *)&v273 = v15;
          v18 = SCNetworkServiceGetInterface(ValueAtIndex);
          *(_QWORD *)&v274 = v13;
          if (v18)
          {
            v19 = SCNetworkServiceCreate(v269, v18);
            if (v19)
            {
              v20 = v19;
              *(_QWORD *)&v272 = v9;
              SCNetworkServiceEstablishDefaultConfiguration(v19);
              v21 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
              v22 = SCNetworkServiceCopyProtocols(ValueAtIndex);
              if (v22)
              {
                v23 = v22;
                v24 = CFArrayGetCount(v22);
                if (v24 >= 1)
                {
                  v25 = v24;
                  for (i = 0; i != v25; ++i)
                  {
                    v27 = (const __SCNetworkProtocol *)CFArrayGetValueAtIndex(v23, i);
                    ProtocolType = SCNetworkProtocolGetProtocolType(v27);
                    v277.length = CFArrayGetCount(v21);
                    v277.location = 0;
                    if (!CFArrayContainsValue(v21, v277, ProtocolType))
                      CFArrayAppendValue(v21, ProtocolType);
                  }
                }
                CFRelease(v23);
              }
              v29 = SCNetworkServiceCopyProtocols(v20);
              if (v29)
              {
                v30 = v29;
                v31 = CFArrayGetCount(v29);
                if (v31 >= 1)
                {
                  v32 = v31;
                  for (j = 0; j != v32; ++j)
                  {
                    v34 = (const __SCNetworkProtocol *)CFArrayGetValueAtIndex(v30, j);
                    v35 = SCNetworkProtocolGetProtocolType(v34);
                    v278.length = CFArrayGetCount(v21);
                    v278.location = 0;
                    if (!CFArrayContainsValue(v21, v278, v35))
                      CFArrayAppendValue(v21, v35);
                  }
                }
                CFRelease(v30);
              }
              v36 = CFArrayGetCount(v21);
              v37 = v36 - 1;
              if (v36 >= 1)
              {
                v38 = 0;
                Copy = 0;
                while (1)
                {
                  v40 = (const __CFString *)CFArrayGetValueAtIndex(v21, v38);
                  v41 = SCNetworkServiceCopyProtocol(ValueAtIndex, v40);
                  v42 = SCNetworkServiceCopyProtocol(v20, v40);
                  v43 = v42;
                  if (v41 && v42)
                  {
                    Enabled = SCNetworkProtocolGetEnabled(v41);
                    v45 = SCNetworkProtocolGetEnabled(v43);
                    v46 = CFSTR("conflicting %@ enable/disable");
                    if (Enabled != v45)
                      goto LABEL_34;
                    Configuration = SCNetworkProtocolGetConfiguration(v41);
                    v48 = SCNetworkProtocolGetConfiguration(v43);
                    if (Configuration != v48)
                    {
                      if (!Configuration)
                        goto LABEL_33;
                      v46 = CFSTR("conflicting %@ configuration");
                      if (v48)
                      {
                        v49 = CFEqual(Configuration, v48);
                        if (v49)
                          goto LABEL_43;
LABEL_33:
                        v46 = CFSTR("conflicting %@ configuration");
                      }
LABEL_34:
                      Copy = CFStringCreateWithFormat(0, 0, v46, v40);
                      v49 = 0;
                      goto LABEL_43;
                    }
                    v49 = 1;
                  }
                  else
                  {
                    Copy = CFStringCreateWithFormat(0, 0, CFSTR("conflicting %@ enable/disable"), v40);
                    v49 = 0;
                    if (!v41)
                    {
                      if (!v43)
                        goto LABEL_38;
LABEL_37:
                      CFRelease(v43);
                      goto LABEL_38;
                    }
                  }
LABEL_43:
                  CFRelease(v41);
                  if (v43)
                    goto LABEL_37;
LABEL_38:
                  if (v49)
                  {
                    v50 = v37 == v38++;
                    if (!v50)
                      continue;
                  }
                  goto LABEL_72;
                }
              }
              Copy = 0;
LABEL_72:
              SCNetworkServiceRemove(v20);
              CFRelease(v20);
              CFRelease(v21);
              v5 = v270;
              v8 = v268;
              v9 = v272;
LABEL_73:
              v85 = _sc_log == 1 || _sc_debug != 0;
              Mutable = v275;
              if (Copy)
              {
                if (v85)
                {
                  v86 = __log_SCNetworkConfiguration();
                  v87 = _SC_syslog_os_log_mapping(6);
                  if (__SC_log_enabled(6, v86, (os_log_type_t)v87))
                  {
                    v88 = _os_log_pack_size();
                    v96 = v9;
                    v97 = (char *)&v265
                        - ((MEMORY[0x1E0C80A78](v88, v89, v90, v91, v92, v93, v94, v95) + 15) & 0xFFFFFFFFFFFFFFF0);
                    __error();
                    v98 = _os_log_pack_fill();
                    ServiceID = SCNetworkServiceGetServiceID(ValueAtIndex);
                    Name = SCNetworkServiceGetName(ValueAtIndex);
                    *(_DWORD *)v98 = v266;
                    *(_QWORD *)(v98 + 4) = ServiceID;
                    v8 = v268;
                    *(_WORD *)(v98 + 12) = 2112;
                    *(_QWORD *)(v98 + 14) = Name;
                    *(_WORD *)(v98 + 22) = 2112;
                    *(_QWORD *)(v98 + 24) = v274;
                    *(_WORD *)(v98 + 32) = 2080;
                    *(_QWORD *)(v98 + 34) = v273;
                    *(_WORD *)(v98 + 42) = 2112;
                    *(_QWORD *)(v98 + 44) = Copy;
                    Mutable = v275;
                    v101 = v97;
                    v9 = v96;
                    __SC_log_send(6, (uint64_t)v86, v87, v101);
                    v5 = v270;
                  }
                }
                CFRelease(Copy);
              }
              else
              {
                if (v85)
                {
                  v102 = __log_SCNetworkConfiguration();
                  v103 = _SC_syslog_os_log_mapping(6);
                  if (__SC_log_enabled(6, v102, (os_log_type_t)v103))
                  {
                    v104 = _os_log_pack_size();
                    v112 = (char *)&v265
                         - ((MEMORY[0x1E0C80A78](v104, v105, v106, v107, v108, v109, v110, v111) + 15) & 0xFFFFFFFFFFFFFFF0);
                    __error();
                    Mutable = v275;
                    v113 = _os_log_pack_fill();
                    *(_DWORD *)v113 = v271;
                    *(_QWORD *)(v113 + 4) = v274;
                    *(_WORD *)(v113 + 12) = 2080;
                    *(_QWORD *)(v113 + 14) = v273;
                    __SC_log_send(6, (uint64_t)v102, v103, v112);
                  }
                }
                v279.length = CFArrayGetCount(Mutable);
                v279.location = 0;
                v114 = (const void *)v274;
                if (!CFArrayContainsValue(Mutable, v279, (const void *)v274))
                  CFArrayAppendValue(Mutable, v114);
              }
              goto LABEL_89;
            }
            v67 = CFSTR("could not create service for interface");
          }
          else
          {
            v67 = CFSTR("could not get interface for service");
          }
          Copy = CFStringCreateCopy(0, v67);
          goto LABEL_73;
        }
LABEL_65:
        v70 = _sc_log != 1 && _sc_debug == 0;
        Mutable = v275;
        if (v70)
          goto LABEL_89;
        v51 = __log_SCNetworkConfiguration();
        v52 = _SC_syslog_os_log_mapping(6);
        if (!__SC_log_enabled(6, v51, (os_log_type_t)v52))
          goto LABEL_89;
        v71 = _os_log_pack_size();
        v79 = v13;
        v62 = (char *)&v265
            - ((MEMORY[0x1E0C80A78](v71, v72, v73, v74, v75, v76, v77, v78) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v80 = _os_log_pack_fill();
        v81 = v9;
        v82 = SCNetworkServiceGetServiceID(ValueAtIndex);
        v83 = SCNetworkServiceGetName(ValueAtIndex);
        *(_DWORD *)v80 = v265;
        *(_QWORD *)(v80 + 4) = v82;
        v9 = v81;
        *(_WORD *)(v80 + 12) = 2112;
        *(_QWORD *)(v80 + 14) = v83;
        *(_WORD *)(v80 + 22) = 2112;
        *(_QWORD *)(v80 + 24) = v79;
LABEL_57:
        Mutable = v275;
        __SC_log_send(6, (uint64_t)v51, v52, v62);
        v5 = v270;
LABEL_89:
        if (++v9 == v8)
          goto LABEL_90;
      }
      v50 = _sc_log != 1 && _sc_debug == 0;
      if (v50)
        goto LABEL_89;
      v51 = __log_SCNetworkConfiguration();
      v52 = _SC_syslog_os_log_mapping(6);
      if (!__SC_log_enabled(6, v51, (os_log_type_t)v52))
        goto LABEL_89;
LABEL_56:
      v54 = _os_log_pack_size();
      v62 = (char *)&v265 - ((MEMORY[0x1E0C80A78](v54, v55, v56, v57, v58, v59, v60, v61) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v63 = _os_log_pack_fill();
      v64 = v9;
      v65 = SCNetworkServiceGetServiceID(ValueAtIndex);
      v66 = SCNetworkServiceGetName(ValueAtIndex);
      *(_DWORD *)v63 = v271;
      *(_QWORD *)(v63 + 4) = v65;
      v9 = v64;
      *(_WORD *)(v63 + 12) = 2112;
      *(_QWORD *)(v63 + 14) = v66;
      goto LABEL_57;
    }
  }
LABEL_90:
  v115 = (const __CFArray *)SCBridgeInterfaceCopyAll(v269);
  if (v115)
  {
    v116 = v115;
    *(_QWORD *)&v272 = CFArrayGetCount(v115);
    if ((uint64_t)v272 >= 1)
    {
      v118 = 0;
      *(_QWORD *)&v117 = 138412290;
      v273 = v117;
      *(_QWORD *)&v271 = v116;
      do
      {
        *(_QWORD *)&v274 = v118;
        v119 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v116, v118);
        MemberInterfaces = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces(v119);
        if (MemberInterfaces)
        {
          v121 = MemberInterfaces;
          v122 = CFArrayGetCount(MemberInterfaces);
          if (v122 >= 1)
          {
            v123 = v122;
            for (k = 0; k != v123; ++k)
            {
              v125 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v121, k);
              v126 = SCNetworkInterfaceGetBSDName(v125);
              if (v126)
              {
                v127 = v126;
                if (thinRemove(Mutable, v126))
                {
                  if (_sc_log == 1 || _sc_debug != 0)
                  {
                    v129 = __log_SCNetworkConfiguration();
                    v130 = _SC_syslog_os_log_mapping(6);
                    if (__SC_log_enabled(6, v129, (os_log_type_t)v130))
                    {
                      v131 = _os_log_pack_size();
                      v139 = (char *)&v265
                           - ((MEMORY[0x1E0C80A78](v131, v132, v133, v134, v135, v136, v137, v138) + 15) & 0xFFFFFFFFFFFFFFF0);
                      __error();
                      Mutable = v275;
                      v140 = _os_log_pack_fill();
                      *(_DWORD *)v140 = v273;
                      *(_QWORD *)(v140 + 4) = v127;
                      __SC_log_send(6, (uint64_t)v129, v130, v139);
                    }
                  }
                }
              }
            }
          }
        }
        v118 = v274 + 1;
        v116 = (const __CFArray *)v271;
      }
      while ((_QWORD)v274 + 1 != (_QWORD)v272);
    }
    CFRelease(v116);
    v5 = v270;
  }
  v141 = SCVLANInterfaceCopyAll(v269);
  if (v141)
  {
    v142 = v141;
    v143 = CFArrayGetCount(v141);
    if (v143 >= 1)
    {
      v145 = v143;
      v146 = 0;
      *(_QWORD *)&v144 = 138412290;
      v274 = v144;
      do
      {
        v147 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v142, v146);
        PhysicalInterface = SCVLANInterfaceGetPhysicalInterface(v147);
        v149 = SCNetworkInterfaceGetBSDName(PhysicalInterface);
        if (v149)
        {
          v150 = v149;
          if (thinRemove(Mutable, v149))
          {
            if (_sc_log == 1 || _sc_debug != 0)
            {
              v152 = __log_SCNetworkConfiguration();
              v153 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v152, (os_log_type_t)v153))
              {
                v154 = _os_log_pack_size();
                v162 = (char *)&v265
                     - ((MEMORY[0x1E0C80A78](v154, v155, v156, v157, v158, v159, v160, v161) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                Mutable = v275;
                v163 = _os_log_pack_fill();
                *(_DWORD *)v163 = v274;
                *(_QWORD *)(v163 + 4) = v150;
                __SC_log_send(6, (uint64_t)v152, v153, v162);
              }
            }
          }
        }
        ++v146;
      }
      while (v145 != v146);
    }
    CFRelease(v142);
    v5 = v270;
  }
  if (!v5)
    goto LABEL_145;
  v164 = CFArrayGetCount(v5);
  if (v164 < 1)
    goto LABEL_145;
  v166 = v164;
  v167 = 0;
  v168 = 0;
  v169 = &_sc_log;
  *(_QWORD *)&v165 = 138412802;
  v272 = v165;
  do
  {
    v170 = (const __SCNetworkService *)CFArrayGetValueAtIndex(v5, v168);
    v171 = SCNetworkServiceGetInterface(v170);
    v172 = SCNetworkInterfaceGetBSDName(v171);
    if (v172)
    {
      v173 = v172;
      v280.length = CFArrayGetCount(Mutable);
      v280.location = 0;
      if (CFArrayContainsValue(Mutable, v280, v173))
      {
        if (*v169 == 1 || _sc_debug != 0 || _sc_verbose != 0)
        {
          v176 = __log_SCNetworkConfiguration();
          v177 = _SC_syslog_os_log_mapping(6);
          if (__SC_log_enabled(6, v176, (os_log_type_t)v177))
          {
            v178 = _os_log_pack_size();
            *(_QWORD *)&v273 = &v265;
            v186 = MEMORY[0x1E0C80A78](v178, v179, v180, v181, v182, v183, v184, v185);
            LODWORD(v274) = v167;
            v187 = (char *)&v265 - ((v186 + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v188 = _os_log_pack_fill();
            v189 = v169;
            v190 = SCNetworkServiceGetServiceID(v170);
            v191 = SCNetworkServiceGetName(v170);
            *(_DWORD *)v188 = v272;
            *(_QWORD *)(v188 + 4) = v190;
            v169 = v189;
            *(_WORD *)(v188 + 12) = 2112;
            *(_QWORD *)(v188 + 14) = v191;
            *(_WORD *)(v188 + 22) = 2112;
            *(_QWORD *)(v188 + 24) = v173;
            Mutable = v275;
            v192 = v187;
            v167 = v274;
            __SC_log_send(6, (uint64_t)v176, v177, v192);
            v5 = v270;
          }
        }
        SCNetworkServiceRemove(v170);
        ++v167;
      }
    }
    ++v168;
  }
  while (v166 != v168);
  if (v167 > 0)
  {
    v193 = *v169 != 1 && _sc_debug == 0;
    if (v193
      || (v194 = __log_SCNetworkConfiguration(),
          v195 = _SC_syslog_os_log_mapping(5),
          !__SC_log_enabled(5, v194, (os_log_type_t)v195)))
    {
      v207 = 1;
    }
    else
    {
      v196 = _os_log_pack_size();
      v204 = (char *)&v265
           - ((MEMORY[0x1E0C80A78](v196, v197, v198, v199, v200, v201, v202, v203) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v205 = _os_log_pack_fill();
      v206 = "s";
      if (v167 == 1)
        v206 = "";
      *(_DWORD *)v205 = 67109378;
      *(_DWORD *)(v205 + 4) = v167;
      *(_WORD *)(v205 + 8) = 2080;
      *(_QWORD *)(v205 + 10) = v206;
      __SC_log_send(5, (uint64_t)v194, v195, v204);
      v207 = 1;
    }
  }
  else
  {
LABEL_145:
    v207 = 0;
  }
  Value = (const __CFArray *)SCPreferencesGetValue(v267, CFSTR("Interfaces"));
  TypeID = CFArrayGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID)
  {
    v210 = CFArrayGetCount(Value);
    v211 = v275;
    if (v210 >= 1)
    {
      LODWORD(v271) = v207;
      v212 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      v213 = CFArrayGetCount(Value);
      if (v213 >= 1)
      {
        v215 = v213;
        v216 = 0;
        v217 = 0;
        *(_QWORD *)&v214 = 138412290;
        v272 = v214;
        *(_QWORD *)&v273 = v212;
        while (1)
        {
          v218 = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v217);
          v219 = CFDictionaryGetValue(v218, CFSTR("BSD Name"));
          v281.length = CFArrayGetCount(v211);
          v281.location = 0;
          if (CFArrayContainsValue(v211, v281, v219))
          {
            v220 = CFDictionaryContainsKey(v218, CFSTR("Active"));
            v222 = _sc_log == 1 || _sc_debug != 0;
            if (!v220)
            {
              if (_sc_verbose)
                v222 = 1;
              if (v222)
              {
                v237 = __log_SCNetworkConfiguration();
                v238 = _SC_syslog_os_log_mapping(6);
                if (__SC_log_enabled(6, v237, (os_log_type_t)v238))
                {
                  v239 = _os_log_pack_size();
                  v247 = (int)v216;
                  v216 = (char *)&v265
                       - ((MEMORY[0x1E0C80A78](v239, v240, v241, v242, v243, v244, v245, v246) + 15) & 0xFFFFFFFFFFFFFFF0);
                  __error();
                  v211 = v275;
                  v248 = _os_log_pack_fill();
                  *(_DWORD *)v248 = v272;
                  *(_QWORD *)(v248 + 4) = v219;
                  v249 = v216;
                  LODWORD(v216) = v247;
                  __SC_log_send(6, (uint64_t)v237, v238, v249);
                  v212 = (__CFArray *)v273;
                }
              }
              v216 = (char *)((_DWORD)v216 + 1);
              goto LABEL_169;
            }
            if (v222)
            {
              v223 = __log_SCNetworkConfiguration();
              v224 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v223, (os_log_type_t)v224))
              {
                v225 = _os_log_pack_size();
                *(_QWORD *)&v274 = &v265;
                v233 = v216;
                v234 = (char *)&v265
                     - ((MEMORY[0x1E0C80A78](v225, v226, v227, v228, v229, v230, v231, v232) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v211 = v275;
                v235 = _os_log_pack_fill();
                *(_DWORD *)v235 = v272;
                *(_QWORD *)(v235 + 4) = v219;
                v236 = v234;
                v216 = v233;
                v212 = (__CFArray *)v273;
                __SC_log_send(6, (uint64_t)v223, v224, v236);
              }
            }
          }
          CFArrayAppendValue(v212, v218);
LABEL_169:
          if (v215 == ++v217)
            goto LABEL_177;
        }
      }
      LODWORD(v216) = 0;
LABEL_177:
      SCPreferencesSetValue(v267, CFSTR("Interfaces"), v212);
      CFRelease(v212);
      v5 = v270;
      v207 = v271;
      if ((int)v216 > 0)
      {
        v251 = _sc_log != 1 && _sc_debug == 0;
        if (v251
          || (v252 = __log_SCNetworkConfiguration(),
              v253 = _SC_syslog_os_log_mapping(6),
              !__SC_log_enabled(6, v252, (os_log_type_t)v253)))
        {
          v207 = 1;
        }
        else
        {
          v254 = _os_log_pack_size();
          v262 = (char *)&v265
               - ((MEMORY[0x1E0C80A78](v254, v255, v256, v257, v258, v259, v260, v261) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v211 = v275;
          v263 = _os_log_pack_fill();
          v264 = "s";
          if ((_DWORD)v216 == 1)
            v264 = "";
          *(_DWORD *)v263 = 67109378;
          *(_DWORD *)(v263 + 4) = (_DWORD)v216;
          *(_WORD *)(v263 + 8) = 2080;
          *(_QWORD *)(v263 + 10) = v264;
          __SC_log_send(6, (uint64_t)v252, v253, v262);
          v207 = 1;
        }
      }
    }
  }
  else
  {
    v211 = v275;
  }
  if (v5)
    CFRelease(v5);
  CFRelease(v211);
  return v207;
}

uint64_t __SCNetworkConfigurationCleanServiceOrderIssues(const __SCPreferences *a1)
{
  const __CFArray *v1;
  const __CFArray *v2;
  CFIndex Count;
  __int128 v4;
  CFIndex v5;
  int v6;
  CFIndex v7;
  const __SCNetworkSet *ValueAtIndex;
  const __CFArray *ServiceOrder;
  const __CFArray *v10;
  CFIndex v11;
  CFIndex v12;
  const __CFSet *Mutable;
  const __CFArray *MutableCopy;
  CFIndex v15;
  const __CFString *v16;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  SCNetworkServiceRef v33;
  SCNetworkServiceRef v34;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  NSObject *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v62;
  CFIndex v63;
  const __CFArray *v64;
  SCNetworkSetRef v65;
  uint64_t *v66;
  CFIndex v67;
  __int128 v68;
  CFStringRef SetID;
  SCPreferencesRef v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v70 = a1;
  v1 = SCNetworkSetCopyAll(a1);
  if (v1)
  {
    v2 = v1;
    Count = CFArrayGetCount(v1);
    if (Count < 1)
    {
      LOBYTE(v6) = 0;
      goto LABEL_47;
    }
    v5 = Count;
    v6 = 0;
    v7 = 0;
    *(_QWORD *)&v4 = 138412546;
    v68 = v4;
    v63 = Count;
    v64 = v2;
    while (1)
    {
      ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v2, v7);
      SetID = SCNetworkSetGetSetID(ValueAtIndex);
      ServiceOrder = SCNetworkSetGetServiceOrder(ValueAtIndex);
      if (!ServiceOrder)
        goto LABEL_43;
      v10 = ServiceOrder;
      v11 = CFArrayGetCount(ServiceOrder);
      if (v11 < 1)
        goto LABEL_43;
      v12 = v11;
      v65 = ValueAtIndex;
      v67 = v7;
      Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
      MutableCopy = CFArrayCreateMutableCopy(0, 0, v10);
      v15 = 0;
      do
      {
        v16 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v15);
        if (CFSetContainsValue(Mutable, v16))
        {
          if (_sc_log == 1 || _sc_debug != 0)
          {
            v18 = __log_SCNetworkConfiguration();
            v19 = _SC_syslog_os_log_mapping(5);
            if (__SC_log_enabled(5, v18, (os_log_type_t)v19))
            {
              v20 = _os_log_pack_size();
              v28 = (char *)&v62
                  - ((MEMORY[0x1E0C80A78](v20, v21, v22, v23, v24, v25, v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              v29 = _os_log_pack_fill();
              *(_DWORD *)v29 = v68;
              *(_QWORD *)(v29 + 4) = SetID;
              *(_WORD *)(v29 + 12) = 2112;
              *(_QWORD *)(v29 + 14) = v16;
              v30 = (uint64_t)v18;
              v31 = v19;
              v32 = v28;
              goto LABEL_14;
            }
          }
          goto LABEL_24;
        }
        CFSetAddValue(Mutable, v16);
        v33 = SCNetworkServiceCopy(v70, v16);
        if (!v33)
        {
          if (_sc_log == 1 || _sc_debug != 0)
          {
            v36 = __log_SCNetworkConfiguration();
            v37 = _SC_syslog_os_log_mapping(5);
            if (__SC_log_enabled(5, v36, (os_log_type_t)v37))
            {
              v38 = _os_log_pack_size();
              v46 = (char *)&v62
                  - ((MEMORY[0x1E0C80A78](v38, v39, v40, v41, v42, v43, v44, v45) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              v47 = _os_log_pack_fill();
              *(_DWORD *)v47 = v68;
              *(_QWORD *)(v47 + 4) = SetID;
              *(_WORD *)(v47 + 12) = 2112;
              *(_QWORD *)(v47 + 14) = v16;
              v30 = (uint64_t)v36;
              v31 = v37;
              v32 = v46;
LABEL_14:
              __SC_log_send(5, v30, v31, v32);
            }
          }
LABEL_24:
          CFArrayRemoveValueAtIndex(MutableCopy, v15);
          --v12;
          goto LABEL_25;
        }
        v34 = v33;
        if (__SCNetworkServiceExists((uint64_t)v33))
        {
          CFRelease(v34);
          ++v15;
          continue;
        }
        if (_sc_log == 1 || _sc_debug != 0)
        {
          v49 = __log_SCNetworkConfiguration();
          v50 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v49, (os_log_type_t)v50))
          {
            v51 = _os_log_pack_size();
            v66 = &v62;
            v59 = (char *)&v62
                - ((MEMORY[0x1E0C80A78](v51, v52, v53, v54, v55, v56, v57, v58) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v60 = _os_log_pack_fill();
            *(_DWORD *)v60 = v68;
            *(_QWORD *)(v60 + 4) = SetID;
            *(_WORD *)(v60 + 12) = 2112;
            *(_QWORD *)(v60 + 14) = v16;
            __SC_log_send(5, (uint64_t)v49, v50, v59);
          }
        }
        CFArrayRemoveValueAtIndex(MutableCopy, v15);
        --v12;
        CFRelease(v34);
LABEL_25:
        v6 = 1;
      }
      while (v15 < v12);
      if (Mutable)
        CFRelease(Mutable);
      if (MutableCopy)
      {
        v2 = v64;
        if (v6)
          SCNetworkSetSetServiceOrder(v65, MutableCopy);
        CFRelease(MutableCopy);
      }
      else
      {
        v2 = v64;
      }
      v5 = v63;
      v7 = v67;
LABEL_43:
      if (++v7 == v5)
      {
LABEL_47:
        CFRelease(v2);
        return v6;
      }
    }
  }
  LOBYTE(v6) = 0;
  return v6;
}

void thinInlineBackup(const __CFString *a1, const __SCPreferences *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  CFStringRef v16;
  UInt8 *v17;
  UInt8 *v18;
  const __CFString *v19;
  tm v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = __log_SCNetworkConfiguration();
  v5 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v4, (os_log_type_t)v5))
  {
    v6 = _os_log_pack_size();
    v14 = (char *)&v20 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v15 = _os_log_pack_fill();
    *(_DWORD *)v15 = 138412290;
    *(_QWORD *)(v15 + 4) = a1;
    __SC_log_send(5, (uint64_t)v4, v5, v14);
  }
  v16 = CFStringCreateWithFormat(0, 0, CFSTR("%@ : "), a1);
  v17 = _SC_cfstring_to_cstring(a1, 0, 0, 0x600u);
  if (!v17)
    goto LABEL_8;
  v18 = v17;
  memset(&v20, 0, sizeof(v20));
  if (!strptime((const char *)v17, "%Y-%m-%d %H:%M:%S", &v20))
  {
    CFAllocatorDeallocate(0, v18);
LABEL_8:
    v19 = CFStringCreateWithFormat(0, 0, CFSTR("preferences-%@.plist"), a1);
    goto LABEL_9;
  }
  v19 = CFStringCreateWithFormat(0, 0, CFSTR("preferences-%4d-%02d-%02d-%02d%02d%02d.plist"), (v20.tm_year + 1900), (v20.tm_mon + 1), v20.tm_mday, v20.tm_hour, v20.tm_min, v20.tm_sec);
  CFAllocatorDeallocate(0, v18);
  if (!v19)
    goto LABEL_8;
LABEL_9:
  savePreferences(a2, v19, (uint64_t)v16, 0, 0);
  CFRelease(v19);
  CFRelease(v16);
}

void thinInlineModel(const void *a1, const __SCPreferences *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  CFStringRef v16;
  const __CFString *v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v4 = __log_SCNetworkConfiguration();
  v5 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v4, (os_log_type_t)v5))
  {
    v6 = _os_log_pack_size();
    v14 = (char *)v18 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v15 = _os_log_pack_fill();
    *(_DWORD *)v15 = 138412290;
    *(_QWORD *)(v15 + 4) = a1;
    __SC_log_send(5, (uint64_t)v4, v5, v14);
  }
  v16 = CFStringCreateWithFormat(0, 0, CFSTR("%@:"), a1);
  v17 = CFStringCreateWithFormat(0, 0, CFSTR("preferences-%@.plist"), a1);
  savePreferences(a2, v17, (uint64_t)v16, CFSTR("Model"), a1);
  CFRelease(v17);
  CFRelease(v16);
}

uint64_t thinRemove(const __CFArray *a1, const void *a2)
{
  CFIndex FirstIndexOfValue;
  CFRange v6;

  v6.length = CFArrayGetCount(a1);
  v6.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(a1, v6, a2);
  if (FirstIndexOfValue == -1)
    return 0;
  CFArrayRemoveValueAtIndex(a1, FirstIndexOfValue);
  return 1;
}

Boolean SCPreferencesAddValue(SCPreferencesRef prefs, CFStringRef key, CFPropertyListRef value)
{
  int v6;
  Boolean result;

  if (!prefs)
  {
    v6 = 3001;
    goto LABEL_5;
  }
  __SCPreferencesAccess((uint64_t)prefs);
  if (CFDictionaryContainsKey(*((CFDictionaryRef *)prefs + 35), key))
  {
    v6 = 1005;
LABEL_5:
    _SCErrorSet(v6);
    return 0;
  }
  CFDictionaryAddValue(*((CFMutableDictionaryRef *)prefs + 35), key, value);
  result = 1;
  *((_BYTE *)prefs + 305) = 1;
  return result;
}

Boolean SCPreferencesSetValue(SCPreferencesRef prefs, CFStringRef key, CFPropertyListRef value)
{
  Boolean result;

  if (prefs)
  {
    __SCPreferencesAccess((uint64_t)prefs);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)prefs + 35), key, value);
    result = 1;
    *((_BYTE *)prefs + 305) = 1;
  }
  else
  {
    _SCErrorSet(3001);
    return 0;
  }
  return result;
}

uint64_t SCPreferencesRemoveAllValues(uint64_t a1)
{
  uint64_t result;

  if (a1)
  {
    __SCPreferencesAccess(a1);
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 280));
    result = 1;
    *(_BYTE *)(a1 + 305) = 1;
  }
  else
  {
    _SCErrorSet(3001);
    return 0;
  }
  return result;
}

Boolean SCPreferencesRemoveValue(SCPreferencesRef prefs, CFStringRef key)
{
  Boolean result;
  int v5;

  if (prefs)
  {
    __SCPreferencesAccess((uint64_t)prefs);
    if (CFDictionaryContainsKey(*((CFDictionaryRef *)prefs + 35), key))
    {
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)prefs + 35), key);
      result = 1;
      *((_BYTE *)prefs + 305) = 1;
      return result;
    }
    v5 = 1004;
  }
  else
  {
    v5 = 3001;
  }
  _SCErrorSet(v5);
  return 0;
}

Boolean SCPreferencesCommitChanges(SCPreferencesRef prefs)
{
  int v2;
  Boolean v3;
  const __CFDictionary *v4;
  void *v5;
  CFTypeID TypeID;
  const std::__fs::filesystem::path *v7;
  size_t v8;
  std::__fs::filesystem::path *v9;
  const __CFDictionary *v10;
  void *v11;
  CFTypeID v12;
  const char *CStringPtr;
  int v14;
  int v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  int v27;
  int v28;
  const __CFData *Data;
  const __CFData *v30;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFIndex v33;
  size_t v34;
  ssize_t v35;
  std::error_code *v36;
  int v37;
  const void *v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  const __CFData *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  NSObject *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  int *v75;
  NSObject *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  uint64_t v87;
  int *v88;
  char *v89;
  int *v90;
  NSObject *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  int *v103;
  char *v104;
  NSObject *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  char *v115;
  NSObject *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  char *v126;
  uint64_t v127;
  int *v128;
  NSObject *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  char *v139;
  uint64_t v140;
  int *v141;
  char *v142;
  NSObject *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  char *v153;
  uint64_t v154;
  int *v155;
  NSObject *v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  char *v166;
  uint64_t v167;
  int *v168;
  char *v169;
  NSObject *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  char *v180;
  uint64_t v181;
  int v182;
  int *v184;
  NSObject *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  char *v195;
  uint64_t v196;
  int *v197;
  char *v198;
  NSObject *v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  char *v209;
  uint64_t v210;
  int *v211;
  NSObject *v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  char *v222;
  uint64_t v223;
  int *v224;
  char *v225;
  NSObject *v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  char *v236;
  uint64_t v237;
  uint64_t v238;
  void *value;
  stat v240;
  uint64_t v241;

  v241 = *MEMORY[0x1E0C80C00];
  if (!prefs)
  {
    _SCErrorSet(3001);
    return 0;
  }
  memset(&v240, 0, sizeof(v240));
  v2 = *((unsigned __int8 *)prefs + 112);
  if (!*((_BYTE *)prefs + 112) && !SCPreferencesLock(prefs, 1u))
  {
    v16 = __log_SCPreferences();
    v17 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v16, (os_log_type_t)v17))
    {
      v18 = _os_log_pack_size();
      v26 = (char *)&v238 - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v16, v17, v26);
    }
    return 0;
  }
  if (*((_QWORD *)prefs + 39))
  {
    if (__SCPreferencesCommitChanges_helper((uint64_t)prefs))
    {
      *((_BYTE *)prefs + 305) = 0;
      v3 = 1;
      goto LABEL_79;
    }
    goto LABEL_78;
  }
  if (!*((_BYTE *)prefs + 305))
    goto LABEL_48;
  if (__SCPreferencesIsEmpty((uint64_t)prefs))
  {
    value = 0;
    v4 = (const __CFDictionary *)*((_QWORD *)prefs + 12);
    if (v4)
    {
      if (CFDictionaryGetValueIfPresent(v4, CFSTR("remove-when-empty"), (const void **)&value))
      {
        v5 = value;
        TypeID = CFBooleanGetTypeID();
        if (v5)
        {
          if (CFGetTypeID(v5) == TypeID && CFBooleanGetValue((CFBooleanRef)value))
          {
            unlink(*((const char **)prefs + 13));
            memset(&v240, 0, sizeof(v240));
            goto LABEL_43;
          }
        }
      }
    }
  }
  v7 = (const std::__fs::filesystem::path *)*((_QWORD *)prefs + 13);
  value = 0;
  if (stat((const char *)v7, &v240) == -1)
  {
    if (*__error() != 2)
    {
      v90 = __error();
      _SCErrorSet(*v90);
      v91 = __log_SCPreferences();
      v92 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v91, (os_log_type_t)v92))
      {
        v93 = _os_log_pack_size();
        v101 = (char *)&v238
             - ((MEMORY[0x1E0C80A78](v93, v94, v95, v96, v97, v98, v99, v100) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v102 = _os_log_pack_fill();
        v103 = __error();
        v104 = strerror(*v103);
        *(_DWORD *)v102 = 136315138;
        *(_QWORD *)(v102 + 4) = v104;
        __SC_log_send(6, (uint64_t)v91, v92, v101);
      }
      goto LABEL_78;
    }
    memset(&v240, 0, sizeof(v240));
    v240.st_mode = 420;
    v240.st_uid = geteuid();
    v240.st_gid = getegid();
  }
  v8 = strlen((const char *)v7) + 5;
  v9 = (std::__fs::filesystem::path *)CFAllocatorAllocate(0, v8, 0);
  snprintf((char *)v9, v8, "%s-new", (const char *)v7);
  v10 = (const __CFDictionary *)*((_QWORD *)prefs + 12);
  if (!v10 || !CFDictionaryGetValueIfPresent(v10, CFSTR("ProtectionClass"), (const void **)&value))
  {
    v27 = open((const char *)v9, 513, v240.st_mode);
    goto LABEL_31;
  }
  v11 = value;
  v12 = CFStringGetTypeID();
  if (v11)
  {
    if (CFGetTypeID(v11) == v12 && CFStringGetLength((CFStringRef)value) == 1)
    {
      CStringPtr = CFStringGetCStringPtr((CFStringRef)value, 0x600u);
      if (CStringPtr)
      {
        v14 = *(unsigned __int8 *)CStringPtr;
        if ((v14 - 71) >= 0xFFFFFFFA)
        {
          v27 = open_dprotected_np((const char *)v9, 513, v14 - 64, 0, v240.st_mode);
LABEL_31:
          v28 = v27;
          if (v27 == -1)
          {
            v75 = __error();
            _SCErrorSet(*v75);
            v76 = __log_SCPreferences();
            v77 = _SC_syslog_os_log_mapping(5);
            if (__SC_log_enabled(5, v76, (os_log_type_t)v77))
            {
              v78 = _os_log_pack_size();
              v86 = (char *)&v238
                  - ((MEMORY[0x1E0C80A78](v78, v79, v80, v81, v82, v83, v84, v85) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              v87 = _os_log_pack_fill();
              v88 = __error();
              v89 = strerror(*v88);
              *(_DWORD *)v87 = 136315138;
              *(_QWORD *)(v87 + 4) = v89;
              __SC_log_send(5, (uint64_t)v76, v77, v86);
            }
          }
          else
          {
            fchown(v27, v240.st_uid, v240.st_gid);
            fchmod(v28, v240.st_mode);
            Data = CFPropertyListCreateData(0, *((CFPropertyListRef *)prefs + 35), kCFPropertyListBinaryFormat_v1_0, 0, 0);
            if (!Data)
            {
              _SCErrorSet(1001);
              v105 = __log_SCPreferences();
              v106 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v105, (os_log_type_t)v106))
              {
                v107 = _os_log_pack_size();
                v115 = (char *)&v238
                     - ((MEMORY[0x1E0C80A78](v107, v108, v109, v110, v111, v112, v113, v114) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                *(_WORD *)_os_log_pack_fill() = 0;
                __SC_log_send(6, (uint64_t)v105, v106, v115);
              }
              v116 = __log_SCPreferences();
              v117 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v116, (os_log_type_t)v117))
              {
                v118 = _os_log_pack_size();
                v126 = (char *)&v238
                     - ((MEMORY[0x1E0C80A78](v118, v119, v120, v121, v122, v123, v124, v125) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v127 = _os_log_pack_fill();
                *(_DWORD *)v127 = 136315138;
                *(_QWORD *)(v127 + 4) = v7;
                __SC_log_send(6, (uint64_t)v116, v117, v126);
              }
              CFAllocatorDeallocate(0, v9);
              close(v28);
              goto LABEL_78;
            }
            v30 = Data;
            BytePtr = CFDataGetBytePtr(Data);
            Length = CFDataGetLength(v30);
            if (Length)
            {
              v33 = Length;
              v34 = Length;
              do
              {
                v35 = write(v28, BytePtr, v34);
                if (v35 == -1)
                {
                  if (*__error() != 4)
                    goto LABEL_67;
                  v35 = 0;
                }
                BytePtr += v35;
                v34 -= v35;
              }
              while (v34);
              if (v33 != -1)
                goto LABEL_40;
LABEL_67:
              v128 = __error();
              _SCErrorSet(*v128);
              v129 = __log_SCPreferences();
              v130 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v129, (os_log_type_t)v130))
              {
                v131 = _os_log_pack_size();
                v139 = (char *)&v238
                     - ((MEMORY[0x1E0C80A78](v131, v132, v133, v134, v135, v136, v137, v138) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v140 = _os_log_pack_fill();
                v141 = __error();
                v142 = strerror(*v141);
                *(_DWORD *)v140 = 136315138;
                *(_QWORD *)(v140 + 4) = v142;
                __SC_log_send(6, (uint64_t)v129, v130, v139);
              }
              v143 = __log_SCPreferences();
              v144 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v143, (os_log_type_t)v144))
              {
                v145 = _os_log_pack_size();
                v153 = (char *)&v238
                     - ((MEMORY[0x1E0C80A78](v145, v146, v147, v148, v149, v150, v151, v152) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v154 = _os_log_pack_fill();
                *(_DWORD *)v154 = 136315138;
                *(_QWORD *)(v154 + 4) = v9;
                __SC_log_send(6, (uint64_t)v143, v144, v153);
              }
              unlink((const char *)v9);
              CFAllocatorDeallocate(0, v9);
              close(v28);
              goto LABEL_77;
            }
LABEL_40:
            if (close(v28) == -1)
            {
              v155 = __error();
              _SCErrorSet(*v155);
              v156 = __log_SCPreferences();
              v157 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v156, (os_log_type_t)v157))
              {
                v158 = _os_log_pack_size();
                v166 = (char *)&v238
                     - ((MEMORY[0x1E0C80A78](v158, v159, v160, v161, v162, v163, v164, v165) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v167 = _os_log_pack_fill();
                v168 = __error();
                v169 = strerror(*v168);
                *(_DWORD *)v167 = 136315138;
                *(_QWORD *)(v167 + 4) = v169;
                __SC_log_send(6, (uint64_t)v156, v157, v166);
              }
              v170 = __log_SCPreferences();
              v171 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v170, (os_log_type_t)v171))
              {
                v172 = _os_log_pack_size();
                v180 = (char *)&v238
                     - ((MEMORY[0x1E0C80A78](v172, v173, v174, v175, v176, v177, v178, v179) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v181 = _os_log_pack_fill();
                *(_DWORD *)v181 = 136315138;
                *(_QWORD *)(v181 + 4) = v9;
                __SC_log_send(6, (uint64_t)v170, v171, v180);
              }
              unlink((const char *)v9);
              CFAllocatorDeallocate(0, v9);
LABEL_77:
              CFRelease(v30);
              goto LABEL_78;
            }
            CFRelease(v30);
            rename(v9, v7, v36);
            if (v37 != -1)
            {
              CFAllocatorDeallocate(0, v9);
              if (stat((const char *)v7, &v240) == -1)
              {
                v211 = __error();
                _SCErrorSet(*v211);
                v212 = __log_SCPreferences();
                v213 = _SC_syslog_os_log_mapping(6);
                if (__SC_log_enabled(6, v212, (os_log_type_t)v213))
                {
                  v214 = _os_log_pack_size();
                  v222 = (char *)&v238
                       - ((MEMORY[0x1E0C80A78](v214, v215, v216, v217, v218, v219, v220, v221) + 15) & 0xFFFFFFFFFFFFFFF0);
                  __error();
                  v223 = _os_log_pack_fill();
                  v224 = __error();
                  v225 = strerror(*v224);
                  *(_DWORD *)v223 = 136315138;
                  *(_QWORD *)(v223 + 4) = v225;
                  __SC_log_send(6, (uint64_t)v212, v213, v222);
                }
                v226 = __log_SCPreferences();
                v227 = _SC_syslog_os_log_mapping(6);
                if (__SC_log_enabled(6, v226, (os_log_type_t)v227))
                {
                  v228 = _os_log_pack_size();
                  v236 = (char *)&v238
                       - ((MEMORY[0x1E0C80A78](v228, v229, v230, v231, v232, v233, v234, v235) + 15) & 0xFFFFFFFFFFFFFFF0);
                  __error();
                  v237 = _os_log_pack_fill();
                  *(_DWORD *)v237 = 136315138;
                  *(_QWORD *)(v237 + 4) = v9;
                  __SC_log_send(6, (uint64_t)v226, v227, v236);
                }
                goto LABEL_78;
              }
LABEL_43:
              v38 = (const void *)*((_QWORD *)prefs + 18);
              if (v38)
                CFRelease(v38);
              *((_QWORD *)prefs + 18) = __SCPSignatureFromStatbuf(&v240.st_dev);
              if (*((_BYTE *)prefs + 305))
              {
                v39 = __log_SCPreferences();
                v40 = _SC_syslog_os_log_mapping(6);
                if (__SC_log_enabled(6, v39, (os_log_type_t)v40))
                {
                  v41 = _os_log_pack_size();
                  v49 = (char *)&v238
                      - ((MEMORY[0x1E0C80A78](v41, v42, v43, v44, v45, v46, v47, v48) + 15) & 0xFFFFFFFFFFFFFFF0);
                  __error();
                  v50 = _os_log_pack_fill();
                  v51 = *((_QWORD *)prefs + 13);
                  v52 = __SCPreferencesPrefsSize((uint64_t)prefs);
                  *(_DWORD *)v50 = 136315394;
                  *(_QWORD *)(v50 + 4) = v51;
                  *(_WORD *)(v50 + 12) = 2048;
                  *(_QWORD *)(v50 + 14) = v52;
LABEL_50:
                  __SC_log_send(6, (uint64_t)v39, v40, v49);
                  goto LABEL_51;
                }
                goto LABEL_51;
              }
LABEL_48:
              v39 = __log_SCPreferences();
              v40 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v39, (os_log_type_t)v40))
              {
                v53 = _os_log_pack_size();
                v49 = (char *)&v238
                    - ((MEMORY[0x1E0C80A78](v53, v54, v55, v56, v57, v58, v59, v60) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v61 = _os_log_pack_fill();
                v62 = *((_QWORD *)prefs + 13);
                *(_DWORD *)v61 = 136315138;
                *(_QWORD *)(v61 + 4) = v62;
                goto LABEL_50;
              }
LABEL_51:
              v63 = SCDynamicStoreNotifyValue(0, *((CFStringRef *)prefs + 23));
              if (v63)
              {
                v3 = v63;
                *((_BYTE *)prefs + 305) = 0;
                goto LABEL_79;
              }
              v64 = __log_SCPreferences();
              v65 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v64, (os_log_type_t)v65))
              {
                v66 = _os_log_pack_size();
                v74 = (char *)&v238
                    - ((MEMORY[0x1E0C80A78](v66, v67, v68, v69, v70, v71, v72, v73) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                *(_WORD *)_os_log_pack_fill() = 0;
                __SC_log_send(6, (uint64_t)v64, v65, v74);
              }
              v15 = 1001;
              goto LABEL_56;
            }
            v184 = __error();
            _SCErrorSet(*v184);
            v185 = __log_SCPreferences();
            v186 = _SC_syslog_os_log_mapping(6);
            if (__SC_log_enabled(6, v185, (os_log_type_t)v186))
            {
              v187 = _os_log_pack_size();
              v195 = (char *)&v238
                   - ((MEMORY[0x1E0C80A78](v187, v188, v189, v190, v191, v192, v193, v194) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              v196 = _os_log_pack_fill();
              v197 = __error();
              v198 = strerror(*v197);
              *(_DWORD *)v196 = 136315138;
              *(_QWORD *)(v196 + 4) = v198;
              __SC_log_send(6, (uint64_t)v185, v186, v195);
            }
            v199 = __log_SCPreferences();
            v200 = _SC_syslog_os_log_mapping(6);
            if (__SC_log_enabled(6, v199, (os_log_type_t)v200))
            {
              v201 = _os_log_pack_size();
              v209 = (char *)&v238
                   - ((MEMORY[0x1E0C80A78](v201, v202, v203, v204, v205, v206, v207, v208) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              v210 = _os_log_pack_fill();
              *(_DWORD *)v210 = 136315394;
              *(_QWORD *)(v210 + 4) = v9;
              *(_WORD *)(v210 + 12) = 2080;
              *(_QWORD *)(v210 + 14) = v7;
              __SC_log_send(6, (uint64_t)v199, v200, v209);
            }
          }
          CFAllocatorDeallocate(0, v9);
          goto LABEL_78;
        }
      }
    }
  }
  v15 = 1002;
LABEL_56:
  _SCErrorSet(v15);
LABEL_78:
  v3 = 0;
LABEL_79:
  if (!v2)
  {
    v182 = SCError();
    SCPreferencesUnlock(prefs);
    _SCErrorSet(v182);
  }
  return v3;
}

uint64_t __SCPreferencesCommitChanges_helper(uint64_t a1)
{
  mach_port_t v2;
  mach_port_t *v3;
  const __CFData *v4;
  int v5;
  const void *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  CFTypeRef v32;
  int v33;
  CFDataRef v34[2];

  v34[1] = *(CFDataRef *)MEMORY[0x1E0C80C00];
  v34[0] = 0;
  v33 = 0;
  v32 = 0;
  v2 = *(_DWORD *)(a1 + 320);
  if (v2)
  {
    v3 = (mach_port_t *)(a1 + 320);
    if (*(_BYTE *)(a1 + 305))
    {
      if (!_SCSerialize(*(CFPropertyListRef *)(a1 + 280), v34, 0, 0))
      {
        v33 = 1001;
        if (_sc_verbose)
        {
          v7 = __log_SCPreferences();
          v8 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v7, (os_log_type_t)v8))
          {
            v9 = _os_log_pack_size();
            v17 = (char *)&v32
                - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            *(_WORD *)_os_log_pack_fill() = 0;
            __SC_log_send(5, (uint64_t)v7, v8, v17);
          }
          v18 = __log_SCPreferences();
          v19 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v18, (os_log_type_t)v19))
          {
            v20 = _os_log_pack_size();
            v28 = (char *)&v32
                - ((MEMORY[0x1E0C80A78](v20, v21, v22, v23, v24, v25, v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v29 = _os_log_pack_fill();
            v30 = *(_QWORD *)(a1 + 104);
            *(_DWORD *)v29 = 136315138;
            *(_QWORD *)(v29 + 4) = v30;
            __SC_log_send(5, (uint64_t)v18, v19, v28);
          }
        }
        goto LABEL_22;
      }
      v2 = *v3;
      v4 = v34[0];
    }
    else
    {
      v4 = 0;
    }
    v5 = _SCHelperExec(v2, 104, v4, &v33, &v32);
    if (v34[0])
      CFRelease(v34[0]);
    if (v5)
    {
      if (!v33)
      {
        if (*(_BYTE *)(a1 + 305))
        {
          v6 = *(const void **)(a1 + 144);
          if (v6)
            CFRelease(v6);
          *(_QWORD *)(a1 + 144) = v32;
        }
        else if (v32)
        {
          CFRelease(v32);
        }
        *(_BYTE *)(a1 + 305) = 0;
        return 1;
      }
    }
    else if (*v3)
    {
      _SCHelperClose((mach_port_t *)(a1 + 320));
    }
  }
  else
  {
    v33 = 1003;
  }
LABEL_22:
  if (v32)
    CFRelease(v32);
  _SCErrorSet(v33);
  return 0;
}

uint64_t SCNetworkInterfaceProviderCreate(const void *a1, const void *a2, uint64_t a3)
{
  uint64_t v5;
  const void *v6;
  const __CFArray *v7;
  NSObject *v8;
  uint64_t Instance;
  const __SCDynamicStore *v10;
  int v11;
  uint64_t v13;
  void *values[2];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  v13 = 0;
  if (!a1 || !a2 || a3)
  {
    v11 = 1002;
LABEL_11:
    _SCErrorSet(v11);
    return 0;
  }
  v5 = IPMonitorControlCreate();
  if (!v5)
  {
    v11 = 1001;
    goto LABEL_11;
  }
  v6 = (const void *)v5;
  values[0] = (void *)IPMonitorControlCopyInterfaceAdvisoryNotificationKey(CFSTR("[^/]+"));
  v7 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x1E0C9B378]);
  CFRelease(values[0]);
  v8 = dispatch_queue_create("SCNetworkInterfaceProvider", 0);
  if (__SCNetworkInterfaceProviderRegisterClass_once != -1)
    dispatch_once(&__SCNetworkInterfaceProviderRegisterClass_once, &__block_literal_global_6);
  Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  v10 = StoreObjectWrapperAllocate(Instance, v7, v8, &v13);
  CFRelease(v7);
  if (!v10)
  {
    dispatch_release(v8);
    CFRelease((CFTypeRef)Instance);
    CFRelease(v6);
    return 0;
  }
  *(_QWORD *)(Instance + 16) = v6;
  *(_QWORD *)(Instance + 24) = v10;
  *(_QWORD *)(Instance + 32) = v13;
  *(_QWORD *)(Instance + 40) = v8;
  *(_QWORD *)(Instance + 56) = CFRetain(a2);
  *(_QWORD *)(Instance + 64) = CFRetain(a1);
  return Instance;
}

const __SCDynamicStore *StoreObjectWrapperAllocate(uint64_t a1, const __CFArray *a2, NSObject *a3, _QWORD *a4)
{
  _DWORD *v8;
  const __SCDynamicStore *v9;
  const __SCDynamicStore *v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  SCDynamicStoreContext context;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  context.version = 0;
  *(_OWORD *)&context.retain = *(_OWORD *)off_1E25D09F8;
  context.copyDescription = 0;
  v8 = malloc_type_malloc(0x10uLL, 0x10C0040AE459949uLL);
  *(_QWORD *)v8 = a1;
  v8[2] = 1;
  context.info = v8;
  v9 = SCDynamicStoreCreate(0, CFSTR("SCNetworkInterfaceProvider"), (SCDynamicStoreCallBack)StoreHandleChanges, &context);
  if (!v9)
  {
    v13 = __log_SCNetworkConfiguration();
    v14 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v13, (os_log_type_t)v14))
    {
      v15 = _os_log_pack_size();
      v23 = (char *)&context
          - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v24 = _os_log_pack_fill();
      *(_DWORD *)v24 = 138412290;
      *(_QWORD *)(v24 + 4) = CFSTR("SCNetworkInterfaceProvider");
      __SC_log_send(5, (uint64_t)v13, v14, v23);
    }
    goto LABEL_12;
  }
  v10 = v9;
  if (!SCDynamicStoreSetNotificationKeys(v9, 0, a2))
  {
    v11 = __log_SCNetworkConfiguration();
    v12 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v11, (os_log_type_t)v12))
    {
LABEL_10:
      v25 = _os_log_pack_size();
      v33 = (char *)&context
          - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v34 = _os_log_pack_fill();
      *(_DWORD *)v34 = 138412290;
      *(_QWORD *)(v34 + 4) = CFSTR("SCNetworkInterfaceProvider");
      __SC_log_send(5, (uint64_t)v11, v12, v33);
    }
LABEL_11:
    CFRelease(v10);
LABEL_12:
    ObjectWrapperRelease(v8);
    v10 = 0;
    v8 = 0;
    goto LABEL_13;
  }
  if (a3 && !SCDynamicStoreSetDispatchQueue(v10, a3))
  {
    v11 = __log_SCNetworkConfiguration();
    v12 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v11, (os_log_type_t)v12))
      goto LABEL_10;
    goto LABEL_11;
  }
LABEL_13:
  *a4 = v8;
  return v10;
}

uint64_t StoreHandleChanges(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;

  result = *a3;
  if (*a3)
    return SCNetworkInterfaceProviderCheck(result);
  return result;
}

void SCNetworkInterfaceProviderSetEventHandler(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD block[7];

  block[6] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v2 = *(NSObject **)(a1 + 40);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SCNetworkInterfaceProviderSetEventHandler_block_invoke;
    block[3] = &unk_1E25D0968;
    block[4] = a2;
    block[5] = a1;
    dispatch_sync(v2, block);
  }
}

void SCNetworkInterfaceProviderResume(uint64_t a1)
{
  NSObject *v1;
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  v1 = *(NSObject **)(a1 + 40);
  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 0x40000000;
  v2[2] = __SCNetworkInterfaceProviderResume_block_invoke;
  v2[3] = &__block_descriptor_tmp_3;
  v2[4] = a1;
  dispatch_async(v1, v2);
}

uint64_t SCNetworkInterfaceProviderCheck(uint64_t result)
{
  uint64_t v1;
  char v2;

  if (*(_BYTE *)(result + 72))
  {
    v1 = result;
    if (*(_QWORD *)(result + 48))
    {
      result = IPMonitorControlAnyInterfaceAdvisoryIsSet(*(_QWORD *)(result + 16));
      if (*(unsigned __int8 *)(v1 + 73) != (_DWORD)result)
      {
        v2 = result;
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v1 + 48) + 16))();
        *(_BYTE *)(v1 + 73) = v2;
      }
    }
  }
  return result;
}

void __SCNetworkInterfaceProviderDeallocate(uint64_t a1)
{
  NSObject *v1;
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  v1 = *(NSObject **)(a1 + 40);
  if (v1)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = ____SCNetworkInterfaceProviderDeallocate_block_invoke;
    v2[3] = &__block_descriptor_tmp_5;
    v2[4] = a1;
    dispatch_sync(v1, v2);
  }
  else
  {
    SCNetworkInterfaceProviderDeallocate(a1);
  }
}

__CFString *__SCNetworkInterfaceProviderCopyDebugDesc(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCNetworkInterfaceProvider %@ %@ <%p>"), a1[8], a1[7], a1);
  return Mutable;
}

void SCNetworkInterfaceProviderDeallocate(uint64_t a1)
{
  const void *v2;
  unsigned int *v3;
  const __SCDynamicStore *v4;
  const void *v5;
  NSObject *v6;
  const void *v7;
  const void *v8;
  const void *v9;

  *(_BYTE *)(a1 + 72) = 0;
  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v3 = *(unsigned int **)(a1 + 32);
  if (v3)
  {
    *(_QWORD *)v3 = 0;
    ObjectWrapperRelease(v3);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v4 = *(const __SCDynamicStore **)(a1 + 24);
  if (v4)
  {
    SCDynamicStoreSetDispatchQueue(v4, 0);
    v5 = *(const void **)(a1 + 24);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
  v6 = *(NSObject **)(a1 + 40);
  if (v6)
  {
    dispatch_release(v6);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v7 = *(const void **)(a1 + 48);
  if (v7)
  {
    _Block_release(v7);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v8 = *(const void **)(a1 + 56);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v9 = *(const void **)(a1 + 64);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 64) = 0;
  }
}

void ObjectWrapperRelease(unsigned int *a1)
{
  unsigned int *v1;
  int v2;

  v1 = a1 + 2;
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 - 1, v1));
  if (v2 == 1)
  {
    free(a1);
  }
  else if (v2 <= 1)
  {
    ObjectWrapperRelease_cold_1();
  }
}

uint64_t ObjectWrapperRetain(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

CFStringRef SCPreferencesPathCreateUniqueChild(SCPreferencesRef prefs, CFStringRef prefix)
{
  int v4;
  CFStringRef v5;
  const __CFUUID *v6;
  CFStringRef v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  CFDictionaryRef theDict[2];

  theDict[1] = *(CFDictionaryRef *)MEMORY[0x1E0C80C00];
  if (!prefs)
  {
    v4 = 3001;
    goto LABEL_6;
  }
  theDict[0] = 0;
  if (getPath(prefs, prefix, theDict))
  {
    if (CFDictionaryContainsKey(theDict[0], CFSTR("__LINK__")))
    {
      v4 = 1001;
LABEL_6:
      _SCErrorSet(v4);
      return 0;
    }
  }
  else if (SCError() != 1004)
  {
    return 0;
  }
  v6 = CFUUIDCreate(0);
  v7 = CFUUIDCreateString(0, v6);
  v5 = CFStringCreateWithFormat(0, 0, CFSTR("%@/%@"), prefix, v7);
  CFRelease(v7);
  CFRelease(v6);
  v8 = CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v8)
    SCPreferencesPathCreateUniqueChild_cold_1();
  v9 = v8;
  if (!setPath((uint64_t)prefs, v5, v8))
  {
    CFRelease(v5);
    v5 = 0;
  }
  CFRelease(v9);
  return v5;
}

uint64_t setPath(uint64_t a1, const __CFString *a2, const __CFDictionary *a3)
{
  const __CFDictionary *v3;
  CFTypeID v5;
  const __CFArray *v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  const __CFDictionary *v10;
  const CFArrayCallBacks *v11;
  CFIndex v12;
  __CFArray *Mutable;
  CFIndex v14;
  CFIndex v15;
  const __CFString *ValueAtIndex;
  const __CFDictionary *v17;
  CFTypeID TypeID;
  __CFArray *v19;
  const __CFArray *v20;
  int v21;
  uint64_t v22;
  const void *v23;
  CFMutableDictionaryRef MutableCopy;
  int v25;
  const void *v26;
  const __CFDictionary *v27;
  const void *v28;
  const __CFString *v29;
  const void *v30;
  CFTypeID v31;
  const __CFString *v32;
  const __CFDictionary *v33;
  __CFDictionary *v34;
  const __CFDictionary *v35;
  uint64_t v36;
  uint64_t v38;
  void *value[2];
  CFRange v41;

  v3 = a3;
  value[1] = *(void **)MEMORY[0x1E0C80C00];
  if (a3 && (v5 = CFDictionaryGetTypeID(), CFGetTypeID(v3) != v5))
  {
    v21 = 1002;
  }
  else
  {
    v6 = normalizePath(a2);
    if (v6)
    {
      v7 = v6;
      value[0] = 0;
      Count = CFArrayGetCount(v6);
      if (Count < 1)
      {
        v20 = v7;
LABEL_26:
        __SCPreferencesAccess(a1);
        v23 = *(const void **)(a1 + 280);
        if (v23)
          CFRelease(v23);
        if (v3)
          MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v3);
        else
          MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        *(_QWORD *)(a1 + 280) = MutableCopy;
        v22 = 1;
        *(_BYTE *)(a1 + 305) = 1;
        goto LABEL_52;
      }
      v9 = Count;
      v10 = 0;
      v38 = 0;
      v11 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      while (2)
      {
        v12 = v9 - 1;
        Mutable = CFArrayCreateMutable(0, v9 - 1, v11);
        v14 = v9 - 2;
        if ((unint64_t)v9 >= 2)
        {
          v15 = 0;
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v15);
            if (v15)
              v17 = (const __CFDictionary *)CFDictionaryGetValue(v10, ValueAtIndex);
            else
              v17 = (const __CFDictionary *)SCPreferencesGetValue((SCPreferencesRef)a1, ValueAtIndex);
            v10 = v17;
            if (v17)
            {
              CFArrayAppendValue(Mutable, v17);
              TypeID = CFDictionaryGetTypeID();
            }
            else
            {
              v10 = CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              CFArrayAppendValue(Mutable, v10);
              CFRelease(v10);
              TypeID = CFDictionaryGetTypeID();
              if (!v10)
                goto LABEL_30;
            }
            if (CFGetTypeID(v10) != TypeID)
              goto LABEL_30;
            if (CFDictionaryGetValueIfPresent(v10, CFSTR("__LINK__"), (const void **)value))
              break;
            if (v12 == ++v15)
            {
              v26 = CFArrayGetValueAtIndex(v7, v9 - 1);
              v27 = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v9 - 2);
              v28 = CFDictionaryGetValue(v27, v26);
              goto LABEL_36;
            }
          }
          if (v38 != 8)
          {
            v19 = normalizePath((const __CFString *)value[0]);
            if (!v19)
            {
LABEL_30:
              v25 = 1004;
              goto LABEL_31;
            }
            v20 = v19;
            ++v38;
            v41.location = v15 + 1;
            v41.length = v12 - v15;
            CFArrayAppendArray(v19, v7, v41);
            CFRelease(v7);
            CFRelease(Mutable);
            v9 = CFArrayGetCount(v20);
            v7 = v20;
            v11 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
            if (v9 >= 1)
              continue;
            goto LABEL_26;
          }
          v25 = 3006;
LABEL_31:
          _SCErrorSet(v25);
          v22 = 0;
          if (!Mutable)
            goto LABEL_51;
          goto LABEL_50;
        }
        break;
      }
      v29 = (const __CFString *)CFArrayGetValueAtIndex(v7, v9 - 1);
      v28 = SCPreferencesGetValue((SCPreferencesRef)a1, v29);
LABEL_36:
      v30 = v28;
      if (v28)
      {
        v31 = CFDictionaryGetTypeID();
        if (CFGetTypeID(v30) != v31)
        {
          v25 = 1002;
          goto LABEL_31;
        }
      }
      if (v3)
        v3 = (const __CFDictionary *)CFRetain(v3);
      v32 = (const __CFString *)CFArrayGetValueAtIndex(v7, v9 - 1);
      if (v9 == 1)
      {
        v35 = v3;
        if (v3)
          goto LABEL_47;
      }
      else
      {
        do
        {
          v33 = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v14);
          v34 = CFDictionaryCreateMutableCopy(0, 0, v33);
          v35 = v34;
          if (v3)
          {
            CFDictionarySetValue(v34, v32, v3);
            CFRelease(v3);
          }
          else
          {
            CFDictionaryRemoveValue(v34, v32);
            if (!CFDictionaryGetCount(v35))
            {
              CFRelease(v35);
              v35 = 0;
            }
          }
          v32 = (const __CFString *)CFArrayGetValueAtIndex(v7, v14--);
          v3 = v35;
        }
        while (v14 != -1);
        if (v35)
        {
LABEL_47:
          v36 = SCPreferencesSetValue((SCPreferencesRef)a1, v32, v35);
          CFRelease(v35);
          v22 = v36;
          if (!Mutable)
            goto LABEL_51;
LABEL_50:
          CFRelease(Mutable);
LABEL_51:
          v20 = v7;
LABEL_52:
          CFRelease(v20);
          return v22;
        }
      }
      v22 = SCPreferencesRemoveValue((SCPreferencesRef)a1, v32);
      if (!Mutable)
        goto LABEL_51;
      goto LABEL_50;
    }
    v21 = 1004;
  }
  _SCErrorSet(v21);
  return 0;
}

Boolean SCPreferencesPathSetValue(SCPreferencesRef prefs, CFStringRef path, CFDictionaryRef value)
{
  CFTypeID v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v13;
  CFTypeID TypeID;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (!prefs)
  {
    v13 = 3001;
LABEL_16:
    _SCErrorSet(v13);
    return 0;
  }
  if (!CFEqual(path, CFSTR("/CurrentSet")))
  {
    TypeID = CFDictionaryGetTypeID();
    if (value)
      goto LABEL_13;
LABEL_15:
    SCPrint(1, (FILE *)*MEMORY[0x1E0C80C10], (uint64_t)CFSTR("SCPreferencesPathSetValue(, %@,) called with non-dictionary value\n"), v15, v16, v17, v18, v19, (uint64_t)path);
    v13 = 1002;
    goto LABEL_16;
  }
  v6 = CFStringGetTypeID();
  if (!value)
  {
    CFDictionaryGetTypeID();
    goto LABEL_15;
  }
  if (CFGetTypeID(value) != v6)
  {
    TypeID = CFDictionaryGetTypeID();
LABEL_13:
    if (CFGetTypeID(value) == TypeID)
      return setPath((uint64_t)prefs, path, value);
    goto LABEL_15;
  }
  if ((SCPreferencesPathSetValue_warned & 1) == 0)
  {
    SCPrint(1, (FILE *)*MEMORY[0x1E0C80C10], (uint64_t)CFSTR("SCPreferencesPathSetValue(, %@,) called with non-dictionary value\n"), v7, v8, v9, v10, v11, (uint64_t)path);
    SCPreferencesPathSetValue_warned = 1;
  }
  return SCPreferencesSetValue(prefs, CFSTR("CurrentSet"), value);
}

Boolean SCPreferencesPathSetLink(SCPreferencesRef prefs, CFStringRef path, CFStringRef link)
{
  CFTypeID TypeID;
  __CFDictionary *Mutable;
  Boolean v8;
  int v10;
  const __CFDictionary *v11[2];

  v11[1] = *(const __CFDictionary **)MEMORY[0x1E0C80C00];
  if (!prefs)
  {
    v10 = 3001;
    goto LABEL_8;
  }
  TypeID = CFStringGetTypeID();
  if (!link || CFGetTypeID(link) != TypeID)
  {
    v10 = 1002;
LABEL_8:
    _SCErrorSet(v10);
    return 0;
  }
  if (getPath(prefs, link, v11))
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(Mutable, CFSTR("__LINK__"), link);
    v8 = setPath((uint64_t)prefs, path, Mutable);
    CFRelease(Mutable);
    return v8;
  }
  return 0;
}

Boolean SCPreferencesPathRemoveValue(SCPreferencesRef prefs, CFStringRef path)
{
  const __CFArray *v4;
  const __CFArray *v5;
  Boolean v6;
  int v8;
  const __CFDictionary *v9[2];

  v9[1] = *(const __CFDictionary **)MEMORY[0x1E0C80C00];
  if (!prefs)
  {
    v8 = 3001;
LABEL_7:
    _SCErrorSet(v8);
    return 0;
  }
  if (getPath(prefs, path, v9))
  {
    v4 = normalizePath(path);
    if (v4)
    {
      v5 = v4;
      v6 = setPath((uint64_t)prefs, path, 0);
      CFRelease(v5);
      return v6;
    }
    v8 = 1004;
    goto LABEL_7;
  }
  return 0;
}

Boolean SCPreferencesApplyChanges(SCPreferencesRef prefs)
{
  int v2;
  mach_port_t v3;
  int v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  int v41;
  _BYTE v43[4];
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (!prefs)
  {
    _SCErrorSet(3001);
LABEL_10:
    LOBYTE(v5) = 0;
    return v5;
  }
  v2 = *((unsigned __int8 *)prefs + 112);
  if (!*((_BYTE *)prefs + 112) && !SCPreferencesLock(prefs, 1u))
  {
    v30 = __log_SCPreferences();
    v31 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v30, (os_log_type_t)v31))
    {
      v32 = _os_log_pack_size();
      v40 = &v43[-((MEMORY[0x1E0C80A78](v32, v33, v34, v35, v36, v37, v38, v39) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v30, v31, v40);
    }
    goto LABEL_10;
  }
  if (!*((_QWORD *)prefs + 39))
  {
    v6 = __log_SCPreferences();
    v7 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = &v43[-((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v17 = _os_log_pack_fill();
      v18 = *((_QWORD *)prefs + 13);
      *(_DWORD *)v17 = 136315138;
      *(_QWORD *)(v17 + 4) = v18;
      __SC_log_send(6, (uint64_t)v6, v7, v16);
    }
    v5 = SCDynamicStoreNotifyValue(0, *((CFStringRef *)prefs + 24));
    if (v5)
      goto LABEL_23;
    v19 = __log_SCPreferences();
    v20 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v19, (os_log_type_t)v20))
    {
      v21 = _os_log_pack_size();
      v29 = &v43[-((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v19, v20, v29);
    }
    v4 = 1001;
    goto LABEL_22;
  }
  v44 = 0;
  v3 = *((_DWORD *)prefs + 80);
  if (!v3)
    goto LABEL_21;
  if (!_SCHelperExec(v3, 105, 0, &v44, 0))
  {
    if (*((_DWORD *)prefs + 80))
      _SCHelperClose((mach_port_t *)prefs + 80);
LABEL_21:
    v4 = 1003;
    v44 = 1003;
    goto LABEL_22;
  }
  v4 = v44;
  if (!v44)
  {
    LOBYTE(v5) = 1;
    goto LABEL_23;
  }
LABEL_22:
  _SCErrorSet(v4);
  LOBYTE(v5) = 0;
LABEL_23:
  if (!v2)
  {
    v41 = SCError();
    SCPreferencesUnlock(prefs);
    _SCErrorSet(v41);
  }
  return v5;
}

const void *_SCPreferencesCopyComputerName(const __SCPreferences *a1, _DWORD *a2)
{
  const __SCPreferences *v4;
  const __CFString *v5;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  const void *v8;
  CFTypeID v9;
  int v10;

  v4 = a1;
  if (!a1)
  {
    v4 = SCPreferencesCreate(0, CFSTR("_SCPreferencesCopyComputerName"), 0);
    if (!v4)
      return 0;
  }
  v5 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@"), CFSTR("System"), CFSTR("System"));
  Value = SCPreferencesPathGetValue(v4, v5);
  CFRelease(v5);
  if (Value)
  {
    TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(Value) != TypeID)
      goto LABEL_8;
    v8 = CFDictionaryGetValue(Value, CFSTR("ComputerName"));
    v9 = CFStringGetTypeID();
    if (!v8)
      goto LABEL_9;
    if (CFGetTypeID(v8) == v9)
      CFRetain(v8);
    else
LABEL_8:
      v8 = 0;
LABEL_9:
    if (a2)
      *a2 = getNameEncoding(Value);
    if (a1)
      goto LABEL_12;
    goto LABEL_18;
  }
  v8 = 0;
  if (!a1)
LABEL_18:
    CFRelease(v4);
LABEL_12:
  if (v8)
    v10 = 0;
  else
    v10 = 1004;
  _SCErrorSet(v10);
  return v8;
}

uint64_t getNameEncoding(const __CFDictionary *a1)
{
  void *v1;
  CFTypeID TypeID;
  void *value;
  unsigned int valuePtr;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  value = 0;
  if (CFDictionaryGetValueIfPresent(a1, CFSTR("ComputerNameEncoding"), (const void **)&value)
    && (v1 = value, TypeID = CFNumberGetTypeID(), v1)
    && CFGetTypeID(v1) == TypeID
    && CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr))
  {
    return valuePtr;
  }
  else
  {
    return CFStringGetSystemEncoding();
  }
}

void report_missing_entitlement(const char *a1)
{
  const char *v2;
  const __SCPreferences *v3;
  const __SCPreferences *v4;
  const __CFString *Value;
  CFTypeID TypeID;
  _QWORD block[7];
  char __str[256];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (_SC_isAppleInternal_once_2 != -1)
    dispatch_once(&_SC_isAppleInternal_once_2, &__block_literal_global_7);
  if (_SC_isAppleInternal_isInternal_2)
  {
    v2 = (const char *)get_contact_string_contact;
    if (!get_contact_string_contact)
    {
      v3 = SCPreferencesCreate(0, CFSTR("UserDefinedDeviceNameContact"), CFSTR("/AppleInternal/Library/SystemConfiguration/PrivateStrings.plist"));
      if (v3)
      {
        v4 = v3;
        Value = (const __CFString *)SCPreferencesGetValue(v3, CFSTR("UserDefinedDeviceNameContact"));
        TypeID = CFStringGetTypeID();
        if (Value && CFGetTypeID(Value) == TypeID)
        {
          CFRetain(Value);
          CFRelease(v4);
          get_contact_string_contact = (uint64_t)_SC_cfstring_to_cstring(Value, 0, 0, 0x8000100u);
          CFRelease(Value);
          v2 = (const char *)get_contact_string_contact;
          goto LABEL_11;
        }
        CFRelease(v4);
      }
      v2 = 0;
    }
LABEL_11:
    if (!v2)
      v2 = "privacy";
    snprintf(__str, 0x100uLL, "%s() requires an entitlement, please contact %s", a1, v2);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_1;
    block[3] = &__block_descriptor_tmp_9;
    block[5] = 0;
    block[6] = 0;
    block[4] = __str;
    if (_SC_crash_once_once_1 != -1)
      dispatch_once(&_SC_crash_once_once_1, block);
  }
}

Boolean SCPreferencesSetComputerName(SCPreferencesRef prefs, CFStringRef name, CFStringEncoding nameEncoding)
{
  CFTypeID TypeID;
  CFStringRef v6;
  const __CFString *v7;
  const __CFDictionary *Value;
  CFMutableDictionaryRef MutableCopy;
  int v10;
  __CFDictionary *v11;
  CFNumberRef v12;
  NSObject *v13;
  uint64_t v14;
  _BOOL4 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _BYTE v35[20];
  CFStringEncoding valuePtr;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  valuePtr = nameEncoding;
  if (!name)
  {
    v6 = 0;
LABEL_7:
    v7 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@"), CFSTR("System"), CFSTR("System"));
    Value = SCPreferencesPathGetValue(prefs, v7);
    if (Value)
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
    else
      MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v11 = MutableCopy;
    if (v6 && CFStringGetLength(v6) >= 1)
    {
      CFDictionarySetValue(v11, CFSTR("ComputerName"), v6);
      v12 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFDictionarySetValue(v11, CFSTR("ComputerNameEncoding"), v12);
      CFRelease(v12);
      CFDictionaryRemoveValue(v11, CFSTR("ComputerNameRegion"));
      if (!valuePtr)
      {
        *(_QWORD *)&v35[12] = 0;
        _CFStringGetUserDefaultEncoding();
      }
    }
    else
    {
      CFDictionaryRemoveValue(v11, CFSTR("ComputerName"));
      CFDictionaryRemoveValue(v11, CFSTR("ComputerNameEncoding"));
      CFDictionaryRemoveValue(v11, CFSTR("ComputerNameRegion"));
    }
    v10 = __SCNetworkConfigurationSetValue(prefs, v7, v11, 0);
    if (!v10 || !__SCPreferencesUsingDefaultPrefs((uint64_t)prefs))
      goto LABEL_24;
    v13 = __log_SCPreferences();
    v14 = _SC_syslog_os_log_mapping(5);
    v15 = __SC_log_enabled(5, v13, (os_log_type_t)v14);
    if (v6)
    {
      if (v15)
      {
        v16 = _os_log_pack_size();
        v24 = &v35[-((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v25 = _os_log_pack_fill();
        *(_DWORD *)v25 = 138412290;
        *(_QWORD *)(v25 + 4) = v6;
LABEL_23:
        __SC_log_send(5, (uint64_t)v13, v14, v24);
      }
    }
    else if (v15)
    {
      v26 = _os_log_pack_size();
      v24 = &v35[-((MEMORY[0x1E0C80A78](v26, v27, v28, v29, v30, v31, v32, v33) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      goto LABEL_23;
    }
LABEL_24:
    CFRelease(v7);
    CFRelease(v11);
    return v10;
  }
  TypeID = CFStringGetTypeID();
  if (CFGetTypeID(name) == TypeID)
  {
    if (CFStringGetLength(name))
      v6 = name;
    else
      v6 = 0;
    goto LABEL_7;
  }
  _SCErrorSet(1002);
  LOBYTE(v10) = 0;
  return v10;
}

const void *SCPreferencesGetHostName(const __SCPreferences *a1)
{
  const __CFString *v2;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  const void *v5;
  CFTypeID v6;

  v2 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@"), CFSTR("System"), CFSTR("System"));
  Value = SCPreferencesPathGetValue(a1, v2);
  CFRelease(v2);
  TypeID = CFDictionaryGetTypeID();
  if (!Value
    || CFGetTypeID(Value) != TypeID
    || (v5 = CFDictionaryGetValue(Value, CFSTR("HostName")), v6 = CFStringGetTypeID(), !v5)
    || CFGetTypeID(v5) != v6)
  {
    _SCErrorSet(1004);
    return 0;
  }
  return v5;
}

uint64_t SCPreferencesSetHostName(const __SCPreferences *a1, const __CFString *a2)
{
  CFTypeID TypeID;
  const __CFString *v5;
  const __CFString *v6;
  const __CFDictionary *Value;
  __CFDictionary *MutableCopy;
  uint64_t v9;
  __CFDictionary *v10;
  NSObject *v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD v33[2];

  v33[1] = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v5 = 0;
LABEL_7:
    v6 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@"), CFSTR("System"), CFSTR("System"));
    Value = SCPreferencesPathGetValue(a1, v6);
    if (Value)
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
    else
      MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v10 = MutableCopy;
    if (v5)
      CFDictionarySetValue(MutableCopy, CFSTR("HostName"), v5);
    else
      CFDictionaryRemoveValue(MutableCopy, CFSTR("HostName"));
    v9 = __SCNetworkConfigurationSetValue(a1, v6, v10, 0);
    if (!(_DWORD)v9 || !__SCPreferencesUsingDefaultPrefs((uint64_t)a1))
      goto LABEL_22;
    v11 = __log_SCPreferences();
    v12 = _SC_syslog_os_log_mapping(5);
    v13 = __SC_log_enabled(5, v11, (os_log_type_t)v12);
    if (v5)
    {
      if (v13)
      {
        v14 = _os_log_pack_size();
        v22 = (char *)v33 - ((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v23 = _os_log_pack_fill();
        *(_DWORD *)v23 = 138412290;
        *(_QWORD *)(v23 + 4) = v5;
LABEL_21:
        __SC_log_send(5, (uint64_t)v11, v12, v22);
      }
    }
    else if (v13)
    {
      v24 = _os_log_pack_size();
      v22 = (char *)v33 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      goto LABEL_21;
    }
LABEL_22:
    CFRelease(v6);
    CFRelease(v10);
    return v9;
  }
  TypeID = CFStringGetTypeID();
  if (CFGetTypeID(a2) == TypeID)
  {
    if (CFStringGetLength(a2))
      v5 = a2;
    else
      v5 = 0;
    goto LABEL_7;
  }
  _SCErrorSet(1002);
  return 0;
}

const void *_SCPreferencesCopyLocalHostName(const __SCPreferences *a1)
{
  const __SCPreferences *v2;
  const __CFString *v3;
  const void *Value;
  CFTypeID TypeID;
  CFTypeID v6;
  int v7;

  v2 = a1;
  if (!a1)
  {
    v2 = SCPreferencesCreate(0, CFSTR("_SCPreferencesCopyLocalHostName"), 0);
    if (!v2)
      return 0;
  }
  v3 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@/%@"), CFSTR("System"), CFSTR("Network"), CFSTR("HostNames"));
  Value = SCPreferencesPathGetValue(v2, v3);
  CFRelease(v3);
  if (Value)
  {
    TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(Value) != TypeID)
      goto LABEL_8;
    Value = CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("LocalHostName"));
    v6 = CFStringGetTypeID();
    if (Value)
    {
      if (CFGetTypeID(Value) == v6)
      {
        CFRetain(Value);
        goto LABEL_9;
      }
LABEL_8:
      Value = 0;
    }
  }
LABEL_9:
  if (!a1)
    CFRelease(v2);
  if (Value)
    v7 = 0;
  else
    v7 = 1004;
  _SCErrorSet(v7);
  return Value;
}

CFStringRef SCDynamicStoreKeyCreateHostNames(CFAllocatorRef allocator)
{
  return SCDynamicStoreKeyCreate(allocator, CFSTR("%@/%@/%@"), CFSTR("Setup:"), CFSTR("Network"), CFSTR("HostNames"), *MEMORY[0x1E0C80C00]);
}

CFStringRef SCDynamicStoreCopyLocalHostName(SCDynamicStoreRef store)
{
  const __CFString *v2;
  const __CFDictionary *v3;
  CFTypeID TypeID;
  const __CFString *Value;
  CFTypeID v6;
  int v7;
  int v8;
  uint64_t block;
  uint64_t v11;
  void (*v12)(uint64_t);
  void *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = SCDynamicStoreKeyCreate(0, CFSTR("%@/%@/%@"), CFSTR("Setup:"), CFSTR("Network"), CFSTR("HostNames"));
  v3 = (const __CFDictionary *)__SCDynamicStoreCopyValueCommon((uint64_t)store, v2, 0);
  CFRelease(v2);
  if (v3)
  {
    TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(v3) == TypeID)
    {
      Value = (const __CFString *)CFDictionaryGetValue(v3, CFSTR("LocalHostName"));
      v6 = CFStringGetTypeID();
      if (!Value)
      {
LABEL_9:
        v7 = 1004;
LABEL_10:
        _SCErrorSet(v7);
        CFRelease(v3);
        return Value;
      }
      if (CFGetTypeID(Value) == v6)
      {
        CFRetain(Value);
        if (SCError() == 10100)
          report_missing_entitlement("SCDynamicStoreCopyLocalHostName");
        v7 = 0;
        goto LABEL_10;
      }
    }
    Value = 0;
    goto LABEL_9;
  }
  v8 = SCError();
  if (v8 == 10003)
  {
    block = MEMORY[0x1E0C809B0];
    v11 = 0x40000000;
    v12 = ___SC_crash_once_block_invoke_1;
    v13 = &__block_descriptor_tmp_9;
    v15 = 0;
    v16 = 0;
    v14 = "SCDynamicStoreCopyLocalHostName() access denied, missing entitlement";
    if (_SC_crash_once_once_1 == -1)
      return 0;
LABEL_19:
    dispatch_once(&_SC_crash_once_once_1, &block);
    return 0;
  }
  if (v8 == 1003)
  {
    block = MEMORY[0x1E0C809B0];
    v11 = 0x40000000;
    v12 = ___SC_crash_once_block_invoke_1;
    v13 = &__block_descriptor_tmp_9;
    v15 = 0;
    v16 = 0;
    v14 = "SCDynamicStoreCopyLocalHostName() access denied by policy";
    if (_SC_crash_once_once_1 == -1)
      return 0;
    goto LABEL_19;
  }
  return (CFStringRef)_SCPreferencesCopyLocalHostName(0);
}

size_t _SC_stringIsValidDNSName(const char *a1)
{
  size_t result;
  size_t v3;
  char v4;
  unsigned __int8 *v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  BOOL v10;
  int v11;

  result = strlen(a1);
  if (result)
  {
    v3 = result;
    v4 = 0;
    v5 = (unsigned __int8 *)(a1 + 1);
    v6 = MEMORY[0x1E0C80978];
    while (1)
    {
      v7 = (char)*(v5 - 1);
      v8 = v4 == 46 || v4 == 0;
      if (v8 || ((v9 = *v5, v9 != 46) ? (v10 = v9 == 0) : (v10 = 1), v10))
      {
        if ((v7 & 0x80000000) != 0)
        {
          result = __maskrune((char)*(v5 - 1), 0x500uLL);
          if (!(_DWORD)result)
            return result;
        }
        else
        {
          result = *(_DWORD *)(v6 + 4 * v7 + 60) & 0x500;
          if (!(_DWORD)result)
            return result;
        }
      }
      else
      {
        if ((v7 & 0x80000000) != 0)
          v11 = __maskrune((char)*(v5 - 1), 0x500uLL);
        else
          v11 = *(_DWORD *)(v6 + 4 * v7 + 60) & 0x500;
        if (v7 - 45 >= 2 && v11 == 0)
          return 0;
      }
      v4 = v7;
      ++v5;
      if (!--v3)
        return 1;
    }
  }
  return result;
}

size_t _SC_CFStringIsValidDNSName(const __CFString *a1)
{
  CFTypeID TypeID;
  UInt8 *v3;
  UInt8 *v4;
  size_t IsValidDNSName;

  TypeID = CFStringGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) != TypeID)
    return 0;
  v3 = _SC_cfstring_to_cstring(a1, 0, 0, 0x600u);
  if (!v3)
    return 0;
  v4 = v3;
  IsValidDNSName = _SC_stringIsValidDNSName((const char *)v3);
  CFAllocatorDeallocate(0, v4);
  return IsValidDNSName;
}

Boolean SCPreferencesSetLocalHostName(SCPreferencesRef prefs, CFStringRef name)
{
  const __CFString *v2;
  CFTypeID TypeID;
  CFIndex Length;
  CFIndex v6;
  int v7;
  const __CFString *v8;
  const __CFDictionary *Value;
  __CFDictionary *MutableCopy;
  __CFDictionary *v11;
  NSObject *v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD v34[2];
  CFRange v35;

  v2 = name;
  v34[1] = *MEMORY[0x1E0C80C00];
  if (!name)
    goto LABEL_8;
  TypeID = CFStringGetTypeID();
  if (CFGetTypeID(v2) == TypeID)
  {
    Length = CFStringGetLength(v2);
    if (Length < 1)
    {
      v2 = 0;
    }
    else
    {
      v6 = Length;
      if (!_SC_CFStringIsValidDNSName(v2))
        goto LABEL_6;
      v35.location = 0;
      v35.length = v6;
      if (CFStringFindWithOptions(v2, CFSTR("."), v35, 0, 0))
        goto LABEL_6;
    }
LABEL_8:
    v8 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@/%@"), CFSTR("System"), CFSTR("Network"), CFSTR("HostNames"));
    Value = SCPreferencesPathGetValue(prefs, v8);
    if (Value)
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
    else
      MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v11 = MutableCopy;
    if (v2)
      CFDictionarySetValue(MutableCopy, CFSTR("LocalHostName"), v2);
    else
      CFDictionaryRemoveValue(MutableCopy, CFSTR("LocalHostName"));
    v7 = __SCNetworkConfigurationSetValue(prefs, v8, v11, 0);
    if (!v7 || !__SCPreferencesUsingDefaultPrefs((uint64_t)prefs))
      goto LABEL_22;
    v12 = __log_SCPreferences();
    v13 = _SC_syslog_os_log_mapping(5);
    v14 = __SC_log_enabled(5, v12, (os_log_type_t)v13);
    if (v2)
    {
      if (v14)
      {
        v15 = _os_log_pack_size();
        v23 = (char *)v34 - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v24 = _os_log_pack_fill();
        *(_DWORD *)v24 = 138412290;
        *(_QWORD *)(v24 + 4) = v2;
LABEL_21:
        __SC_log_send(5, (uint64_t)v12, v13, v23);
      }
    }
    else if (v14)
    {
      v25 = _os_log_pack_size();
      v23 = (char *)v34 - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      goto LABEL_21;
    }
LABEL_22:
    CFRelease(v8);
    CFRelease(v11);
    return v7;
  }
LABEL_6:
  _SCErrorSet(1002);
  LOBYTE(v7) = 0;
  return v7;
}

BOOL _SC_CFStringIsValidNetBIOSName(const __CFString *a1)
{
  CFTypeID TypeID;

  TypeID = CFStringGetTypeID();
  return a1 && CFGetTypeID(a1) == TypeID && CFStringGetLength(a1) < 16;
}

CFStringRef SCDynamicStoreKeyCreateLocation(CFAllocatorRef allocator)
{
  return (CFStringRef)CFRetain(CFSTR("Setup:"));
}

CFTypeID SCNetworkConnectionGetTypeID(void)
{
  if (__SCNetworkConnectionInitialize_initialized != -1)
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
  return __kSCNetworkConnectionTypeID;
}

CFMutableArrayRef SCNetworkConnectionCopyAvailableServices(const __SCNetworkSet *a1)
{
  __CFArray *Mutable;
  const __SCNetworkSet *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const __SCNetworkService *ValueAtIndex;
  const __SCNetworkInterface *Interface;
  CFStringRef InterfaceType;
  const __SCPreferences *v12;
  const __SCPreferences *v13;

  if (a1)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    v3 = a1;
    goto LABEL_3;
  }
  v12 = SCPreferencesCreate(0, CFSTR("SCNetworkConnectionCopyAvailableServices"), 0);
  if (v12)
  {
    v13 = v12;
    v3 = SCNetworkSetCopyCurrent(v12);
    CFRelease(v13);
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    if (!v3)
      return Mutable;
LABEL_3:
    v4 = SCNetworkSetCopyServices(v3);
    if (v4)
    {
      v5 = v4;
      Count = CFArrayGetCount(v4);
      if (Count >= 1)
      {
        v7 = Count;
        for (i = 0; i != v7; ++i)
        {
          ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(v5, i);
          Interface = SCNetworkServiceGetInterface(ValueAtIndex);
          if (Interface)
          {
            InterfaceType = SCNetworkInterfaceGetInterfaceType(Interface);
            if (CFEqual(InterfaceType, CFSTR("PPP"))
              || CFEqual(InterfaceType, CFSTR("VPN"))
              || CFEqual(InterfaceType, CFSTR("IPSec")))
            {
              CFArrayAppendValue(Mutable, ValueAtIndex);
            }
          }
        }
      }
      CFRelease(v5);
    }
    if (!a1)
      CFRelease(v3);
    return Mutable;
  }
  return CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
}

uint64_t SCNetworkConnectionCreateWithService(uint64_t a1, _QWORD *a2, uint64_t a3, __int128 *a4)
{
  CFTypeID TypeID;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int v20;
  uint64_t Private;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  _QWORD v35[2];

  v35[1] = *MEMORY[0x1E0C80C00];
  TypeID = SCNetworkServiceGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
  {
    v20 = 1002;
LABEL_10:
    _SCErrorSet(v20);
    return 0;
  }
  if (__SCNetworkServiceIsPPTP(a2))
  {
    v9 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v9 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v9;
    }
    v10 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v9, (os_log_type_t)v10))
    {
      v11 = _os_log_pack_size();
      v19 = (char *)v35 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v9, v10, v19);
    }
    v20 = 5002;
    goto LABEL_10;
  }
  Private = __SCNetworkConnectionCreatePrivate(a1, a2, a3, a4);
  if (Private)
  {
    v23 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v23 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v23;
    }
    v24 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v23, (os_log_type_t)v24))
    {
      v25 = _os_log_pack_size();
      v33 = (char *)v35 - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v34 = _os_log_pack_fill();
      *(_DWORD *)v34 = 136315394;
      *(_QWORD *)(v34 + 4) = Private + 88;
      *(_WORD *)(v34 + 12) = 2112;
      *(_QWORD *)(v34 + 14) = a2;
      __SC_log_send(7, (uint64_t)v23, v24, v33);
    }
  }
  return Private;
}

uint64_t __SCNetworkConnectionCreatePrivate(uint64_t a1, const void *a2, uint64_t a3, __int128 *a4)
{
  uint64_t Instance;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t (*v11)(_QWORD);
  const __CFString *v12;
  const __CFString *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  const __CFString *ServiceID;
  const __CFString *NetworkServiceEntity;
  const __CFDictionary *v29;
  CFTypeID TypeID;
  const void *Value;
  CFTypeID v32;
  CFTypeRef *v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  int v47;
  uuid_t uu;
  char buffer[16];
  _BYTE v50[21];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkConnectionInitialize_initialized != -1)
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    goto LABEL_23;
  v8 = Instance;
  pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0);
  if (a2)
    *(_QWORD *)(v8 + 80) = CFRetain(a2);
  *(_DWORD *)(v8 + 160) = geteuid();
  *(_DWORD *)(v8 + 164) = getegid();
  *(_DWORD *)(v8 + 168) = getpid();
  *(_QWORD *)(v8 + 232) = a3;
  if (a4)
  {
    v9 = *a4;
    v10 = a4[1];
    *(_QWORD *)(v8 + 272) = *((_QWORD *)a4 + 4);
    *(_OWORD *)(v8 + 240) = v9;
    *(_OWORD *)(v8 + 256) = v10;
    v11 = (uint64_t (*)(_QWORD))*((_QWORD *)a4 + 2);
    if (v11)
      *(_QWORD *)(v8 + 248) = v11(*((_QWORD *)a4 + 1));
  }
  *(_DWORD *)(v8 + 304) = 0;
  if (_sc_log >= 1)
    snprintf((char *)(v8 + 88), 0x20uLL, "[%p] ", (const void *)v8);
  if (ne_session_use_as_system_vpn() && *(_QWORD *)(v8 + 80))
  {
    _SCErrorSet(0);
    if (_SCNetworkServiceIsVPN(*(const __SCNetworkService **)(v8 + 80)))
      goto LABEL_14;
    if (SCError() != 1002)
      return v8;
    ServiceID = SCNetworkServiceGetServiceID(*(SCNetworkServiceRef *)(v8 + 80));
    NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("Setup:"), ServiceID, CFSTR("Interface"));
    v29 = (const __CFDictionary *)SCDynamicStoreCopyValue(0, NetworkServiceEntity);
    TypeID = CFDictionaryGetTypeID();
    if (v29)
    {
      if (CFGetTypeID(v29) == TypeID)
      {
        Value = CFDictionaryGetValue(v29, CFSTR("Type"));
        v32 = CFStringGetTypeID();
        if (Value)
        {
          if (CFGetTypeID(Value) == v32)
          {
            if (!CFEqual(Value, CFSTR("PPP")))
            {
              if (!CFEqual(Value, CFSTR("VPN")))
              {
                v33 = (CFTypeRef *)&kSCNetworkInterfaceTypeIPSec;
LABEL_44:
                v47 = CFEqual(Value, *v33);
                CFRelease(v29);
                CFRelease(NetworkServiceEntity);
                if (!v47)
                  return v8;
LABEL_14:
                v12 = SCNetworkServiceGetServiceID(*(SCNetworkServiceRef *)(v8 + 80));
                v13 = v12;
                if (v12)
                {
                  *(_OWORD *)buffer = 0u;
                  memset(v50, 0, sizeof(v50));
                  if (CFStringGetCString(v12, buffer, 37, 0x8000100u))
                  {
                    memset(uu, 0, sizeof(uu));
                    if (!uuid_parse(buffer, uu))
                    {
                      v34 = ne_session_create();
                      *(_QWORD *)(v8 + 344) = v34;
                      if (v34)
                      {
                        v35 = __log_SCNetworkConnection_log;
                        if (!__log_SCNetworkConnection_log)
                        {
                          v35 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
                          __log_SCNetworkConnection_log = (uint64_t)v35;
                        }
                        v36 = _SC_syslog_os_log_mapping(7);
                        if (__SC_log_enabled(7, v35, (os_log_type_t)v36))
                        {
                          v37 = _os_log_pack_size();
                          v45 = (char *)&uu[-((MEMORY[0x1E0C80A78](v37, v38, v39, v40, v41, v42, v43, v44) + 15) & 0xFFFFFFFFFFFFFFF0)];
                          __error();
                          v46 = _os_log_pack_fill();
                          *(_DWORD *)v46 = 136315138;
                          *(_QWORD *)(v46 + 4) = v8 + 88;
                          __SC_log_send(7, (uint64_t)v35, v36, v45);
                        }
                      }
                    }
                  }
                }
                if (!*(_QWORD *)(v8 + 344))
                {
                  v14 = __log_SCNetworkConnection_log;
                  if (!__log_SCNetworkConnection_log)
                  {
                    v14 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
                    __log_SCNetworkConnection_log = (uint64_t)v14;
                  }
                  v15 = _SC_syslog_os_log_mapping(5);
                  if (__SC_log_enabled(5, v14, (os_log_type_t)v15))
                  {
                    v16 = _os_log_pack_size();
                    v24 = (char *)&uu[-((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0)];
                    __error();
                    v25 = _os_log_pack_fill();
                    *(_DWORD *)v25 = 138412290;
                    *(_QWORD *)(v25 + 4) = v13;
                    __SC_log_send(5, (uint64_t)v14, v15, v24);
                  }
                  CFRelease((CFTypeRef)v8);
LABEL_23:
                  _SCErrorSet(1001);
                  return 0;
                }
                return v8;
              }
LABEL_42:
              CFRelease(v29);
              CFRelease(NetworkServiceEntity);
              goto LABEL_14;
            }
            Value = CFDictionaryGetValue(v29, CFSTR("SubType"));
            if (isA_CFString(Value))
            {
              if (!CFEqual(Value, CFSTR("PPTP")))
              {
                v33 = (CFTypeRef *)&kSCValNetInterfaceSubTypeL2TP;
                goto LABEL_44;
              }
              goto LABEL_42;
            }
          }
        }
      }
      CFRelease(v29);
    }
    CFRelease(NetworkServiceEntity);
  }
  return v8;
}

SCNetworkConnectionRef SCNetworkConnectionCreateWithServiceID(CFAllocatorRef allocator, CFStringRef serviceID, SCNetworkConnectionCallBack callout, SCNetworkConnectionContext *context)
{
  CFTypeID TypeID;
  _QWORD *v9;
  const void *v10;
  const __SCNetworkConnection *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  _QWORD v25[2];

  v25[1] = *MEMORY[0x1E0C80C00];
  TypeID = CFStringGetTypeID();
  if (!serviceID || CFGetTypeID(serviceID) != TypeID)
  {
    _SCErrorSet(1002);
    return 0;
  }
  v9 = _SCNetworkServiceCopyActive(0, serviceID);
  if (!v9)
    return 0;
  v10 = v9;
  v11 = (const __SCNetworkConnection *)SCNetworkConnectionCreateWithService((uint64_t)allocator, v9, (uint64_t)callout, (__int128 *)&context->version);
  CFRelease(v10);
  if (v11)
  {
    v12 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v12 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v12;
    }
    v13 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v12, (os_log_type_t)v13))
    {
      v14 = _os_log_pack_size();
      v22 = (char *)v25 - ((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v23 = _os_log_pack_fill();
      *(_DWORD *)v23 = 136315394;
      *(_QWORD *)(v23 + 4) = (char *)v11 + 88;
      *(_WORD *)(v23 + 12) = 2112;
      *(_QWORD *)(v23 + 14) = v10;
      __SC_log_send(7, (uint64_t)v12, v13, v22);
    }
  }
  return v11;
}

uint64_t SCNetworkConnectionCreate(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t Private;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  Private = __SCNetworkConnectionCreatePrivate(a1, 0, a2, a3);
  if (Private)
  {
    v4 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v4 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v4;
    }
    v5 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v4, (os_log_type_t)v5))
    {
      v6 = _os_log_pack_size();
      v14 = (char *)v17 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v15 = _os_log_pack_fill();
      *(_DWORD *)v15 = 136315138;
      *(_QWORD *)(v15 + 4) = Private + 88;
      __SC_log_send(7, (uint64_t)v4, v5, v14);
    }
  }
  return Private;
}

CFStringRef SCNetworkConnectionCopyServiceID(SCNetworkConnectionRef connection)
{
  uint64_t v2;
  const __SCNetworkService *v3;
  CFStringRef ServiceID;
  int v6;

  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!connection)
    {
LABEL_8:
      v6 = 1002;
      goto LABEL_9;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!connection)
      goto LABEL_8;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(connection) != v2)
    goto LABEL_8;
  v3 = (const __SCNetworkService *)*((_QWORD *)connection + 10);
  if (v3)
  {
    ServiceID = SCNetworkServiceGetServiceID(v3);
    return (CFStringRef)CFRetain(ServiceID);
  }
  v6 = 5001;
LABEL_9:
  _SCErrorSet(v6);
  return 0;
}

uint64_t SCNetworkConnectionSetClientInfo(mach_port_name_t *cf, mach_port_name_t a2, mach_port_name_t a3, mach_port_name_t a4, mach_port_name_t a5)
{
  uint64_t v10;
  mach_port_name_t v11;
  ipc_space_t *v12;
  uint64_t result;

  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_10:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!cf)
      goto LABEL_10;
  }
  v10 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(cf) != v10)
    goto LABEL_10;
  v11 = cf[30];
  v12 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  if (v11)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v11);
  cf[30] = a2;
  if (a2)
    mach_port_mod_refs(*v12, a2, 0, 1);
  cf[40] = a3;
  cf[41] = a4;
  result = 1;
  cf[42] = a5;
  return result;
}

uint64_t SCNetworkConnectionSetClientAuditInfo(uint64_t a1, _QWORD *a2, mach_port_name_t a3, mach_port_name_t a4, pid_t a5, const unsigned __int8 *a6, const char *a7)
{
  BOOL v13;
  __int128 v16;
  mach_port_name_t v17;
  __int128 v18;
  mach_port_name_t v19;
  __int128 v20;
  uint64_t result;
  mach_port_name_t v22;
  ipc_space_t *v23;
  __int128 v24;
  const void *v25;
  audit_token_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v27 = 0u;
  v28 = 0u;
  if (*a2)
    v13 = 0;
  else
    v13 = a2[1] == 0;
  if (v13 && a2[2] == 0 && a2[3] == 0)
  {
    v19 = 0;
    v17 = 0;
  }
  else
  {
    v16 = *((_OWORD *)a2 + 1);
    *(_OWORD *)v26.val = *(_OWORD *)a2;
    *(_OWORD *)&v26.val[4] = v16;
    v17 = audit_token_to_euid(&v26);
    v18 = *((_OWORD *)a2 + 1);
    *(_OWORD *)v26.val = *(_OWORD *)a2;
    *(_OWORD *)&v26.val[4] = v18;
    v19 = audit_token_to_egid(&v26);
    v20 = *((_OWORD *)a2 + 1);
    *(_OWORD *)v26.val = *(_OWORD *)a2;
    *(_OWORD *)&v26.val[4] = v20;
    a5 = audit_token_to_pid(&v26);
  }
  result = SCNetworkConnectionSetClientInfo((mach_port_name_t *)a1, a3, v17, v19, a5);
  if ((_DWORD)result)
  {
    v22 = *(_DWORD *)(a1 + 156);
    v23 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    if (v22)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v22);
    *(_DWORD *)(a1 + 156) = a4;
    if (a4)
      mach_port_mod_refs(*v23, a4, 0, 1);
    v24 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 140) = *((_OWORD *)a2 + 1);
    *(_OWORD *)(a1 + 124) = v24;
    if (a6 && !uuid_is_null(a6))
      uuid_copy((unsigned __int8 *)(a1 + 172), a6);
    v25 = *(const void **)(a1 + 192);
    if (v25)
    {
      CFRelease(v25);
      *(_QWORD *)(a1 + 192) = 0;
    }
    if (a7)
      *(_QWORD *)(a1 + 192) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a7, 0x8000100u);
    return 1;
  }
  return result;
}

CFDictionaryRef SCNetworkConnectionCopyStatistics(SCNetworkConnectionRef connection)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  NSObject *v4;
  const __CFDictionary *v5;
  int v6;
  mach_error_t v7;
  int v8;
  int v9;
  int v10;
  CFPropertyListRef v11;
  CFTypeID TypeID;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  CFPropertyListRef v18;
  mach_error_t v19;
  unsigned int v20;
  UInt8 *v21[2];

  v21[1] = *(UInt8 **)MEMORY[0x1E0C80C00];
  v21[0] = 0;
  v19 = 1001;
  v20 = 0;
  v18 = 0;
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!connection)
    {
LABEL_28:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!connection)
      goto LABEL_28;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(connection) != v2)
    goto LABEL_28;
  v3 = (pthread_mutex_t *)((char *)connection + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)connection + 16));
  if (*((_QWORD *)connection + 43))
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2000000000;
    v17 = 0;
    ne_session_retain();
    pthread_mutex_unlock((pthread_mutex_t *)((char *)connection + 16));
    v4 = dispatch_semaphore_create(0);
    if (__SCNetworkConnectionQueue_once != -1)
      dispatch_once(&__SCNetworkConnectionQueue_once, &__block_literal_global_91_0);
    ne_session_get_info();
    dispatch_semaphore_wait(v4, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v4);
    if (v15[3])
    {
      v5 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
      xpc_release((xpc_object_t)v15[3]);
    }
    else
    {
      _SCErrorSet(1001);
      v5 = 0;
    }
    _Block_object_dispose(&v14, 8);
  }
  else
  {
    while (1)
    {
      v6 = __SCNetworkConnectionSessionPort((uint64_t)connection);
      if (!v6)
        break;
      v7 = pppcontroller_copystatistics(v6, v21, &v20, &v19);
      if (!__SCNetworkConnectionNeedsRetry((uint64_t)connection, (uint64_t)"SCNetworkConnectionCopyStatistics()", v7, &v19))
      {
        if (!v21[0])
          goto LABEL_16;
        v8 = _SCUnserialize(&v18, 0, v21[0], v20);
        v9 = v19;
        if (!v8 && v19)
        {
          v9 = SCError();
          v19 = v9;
        }
        if (v9 || (v11 = v18, TypeID = CFDictionaryGetTypeID(), v11) && CFGetTypeID(v11) == TypeID)
        {
LABEL_16:
          v10 = v19;
          if (!v19)
            break;
        }
        else
        {
          v10 = 1001;
          v19 = 1001;
        }
        if (v18)
        {
          CFRelease(v18);
          v18 = 0;
          v10 = v19;
        }
        _SCErrorSet(v10);
        break;
      }
    }
    pthread_mutex_unlock(v3);
    return (CFDictionaryRef)v18;
  }
  return v5;
}

uint64_t __SCNetworkConnectionSessionPort(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  mach_port_name_t *v3;
  const __SCNetworkService *v4;
  uint64_t *v5;
  int v6;
  const __CFString *ServiceID;
  __CFMachPort *v8;
  ipc_space_t *v9;
  mach_port_name_t Port;
  mach_port_name_t v11;
  mach_error_t inserted;
  uint64_t *v13;
  __int128 v14;
  BOOL v15;
  kern_return_t v16;
  int v17;
  int v18;
  int v19;
  mach_error_t v20;
  unsigned int v21;
  unsigned int v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  mach_port_name_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  const char *v38;
  int v39;
  unsigned int v40;
  SCDynamicStoreRef v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  const char *v54;
  const char *v55;
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  uint64_t v67;
  char *v68;
  NSObject *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  char *v81;
  NSObject *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  NSObject *v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  char *v109;
  uint64_t v110;
  NSObject *v111;
  int v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  const char *v122;
  NSObject *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  char *v133;
  unsigned int v134;
  mach_port_name_t v135;
  uint64_t v136;
  __int128 v137;
  CFMachPortContext v138;
  kern_return_t v139;
  mach_port_name_t name[2];
  vm_size_t v141;
  uint64_t v142;
  CFDataRef v143[2];

  v1 = a1;
  v143[1] = *(CFDataRef *)MEMORY[0x1E0C80C00];
  v142 = 0;
  v143[0] = 0;
  *(_QWORD *)name = 0;
  v141 = 0;
  v139 = 1001;
  v3 = (mach_port_name_t *)(a1 + 200);
  result = *(unsigned int *)(a1 + 200);
  if ((_DWORD)result)
    return result;
  v4 = *(const __SCNetworkService **)(v1 + 80);
  if (!v4)
  {
    inserted = 0;
    v139 = 5001;
    goto LABEL_88;
  }
  v5 = &_SCHelperExecCopyBacktrace_once;
  v6 = scnc_server;
  ServiceID = SCNetworkServiceGetServiceID(v4);
  if (!_SCSerializeString(ServiceID, v143, (vm_address_t *)&v142, &v141))
  {
    inserted = 0;
    goto LABEL_88;
  }
  v8 = *(__CFMachPort **)(v1 + 208);
  v9 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  if (v8)
  {
    Port = CFMachPortGetPort(v8);
    CFMachPortInvalidate(*(CFMachPortRef *)(v1 + 208));
    CFRelease(*(CFTypeRef *)(v1 + 208));
    *(_QWORD *)(v1 + 208) = 0;
    mach_port_mod_refs(*v9, Port, 1u, -1);
  }
  v11 = audit_session_self();
  inserted = 0;
  v134 = 0;
  v13 = &_SCHelperExecCopyBacktrace_once;
  *(_QWORD *)&v14 = 136315138;
  v137 = v14;
  v136 = v1;
  v135 = v11;
  while (1)
  {
    if (*(_QWORD *)(v1 + 232))
      v15 = name[1] == 0;
    else
      v15 = 0;
    if (v15)
    {
      v16 = mach_port_allocate(*v9, 1u, &name[1]);
      if (v16)
      {
        inserted = v16;
        v56 = v13[13];
        if (!v56)
        {
          v56 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
          v13[13] = (uint64_t)v56;
        }
        v57 = _SC_syslog_os_log_mapping(3);
        if (__SC_log_enabled(3, v56, (os_log_type_t)v57))
        {
          v58 = _os_log_pack_size();
          v66 = (char *)&v134
              - ((MEMORY[0x1E0C80A78](v58, v59, v60, v61, v62, v63, v64, v65) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v67 = _os_log_pack_fill();
          v68 = mach_error_string(inserted);
          *(_DWORD *)v67 = v137;
          *(_QWORD *)(v67 + 4) = v68;
          __SC_log_send(3, (uint64_t)v56, v57, v66);
        }
      }
      else
      {
        inserted = mach_port_insert_right(*v9, name[1], name[1], 0x14u);
        if (!inserted)
          goto LABEL_14;
        v69 = v13[13];
        if (!v69)
        {
          v69 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
          v13[13] = (uint64_t)v69;
        }
        v70 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v69, (os_log_type_t)v70))
        {
LABEL_78:
          v71 = _os_log_pack_size();
          v79 = (char *)&v134
              - ((MEMORY[0x1E0C80A78](v71, v72, v73, v74, v75, v76, v77, v78) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v80 = _os_log_pack_fill();
          v81 = mach_error_string(inserted);
          *(_DWORD *)v80 = v137;
          *(_QWORD *)(v80 + 4) = v81;
          __SC_log_send(5, (uint64_t)v69, v70, v79);
        }
LABEL_79:
        mach_port_mod_refs(*v9, name[1], 1u, -1);
      }
      v139 = inserted;
      if (!v11)
        goto LABEL_88;
      goto LABEL_87;
    }
LABEL_14:
    if (!v6)
      goto LABEL_37;
    if (!*(_DWORD *)(v1 + 120)
      && !*(_DWORD *)(v1 + 156)
      && (v17 = *(_DWORD *)(v1 + 160), v17 == geteuid())
      && (v18 = *(_DWORD *)(v1 + 164), v18 == getegid())
      && (v19 = *(_DWORD *)(v1 + 168), v19 == getpid()))
    {
      v20 = pppcontroller_attach(v6, v142, v141, *MEMORY[0x1E0C81720], name[1], v11, v3, &v139);
    }
    else
    {
      v21 = *(_DWORD *)(v1 + 120) ? *(_DWORD *)(v1 + 120) : v11;
      v22 = *(_DWORD *)(v1 + 156) ? *(_DWORD *)(v1 + 156) : *MEMORY[0x1E0C81720];
      v20 = pppcontroller_attach_proxy(v6, v142, v141, v22, name[1], v21, *(_DWORD *)(v1 + 160), *(_DWORD *)(v1 + 164), *(_DWORD *)(v1 + 168), v3, &v139);
    }
    inserted = v20;
    if (!v20)
      break;
    v23 = v13[13];
    if (!v23)
    {
      v23 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      v13[13] = (uint64_t)v23;
    }
    v24 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v23, (os_log_type_t)v24))
    {
      v25 = _os_log_pack_size();
      v26 = v5;
      v27 = v13;
      v28 = v3;
      v36 = (char *)&v134 - ((MEMORY[0x1E0C80A78](v25, v29, v30, v31, v32, v33, v34, v35) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v37 = _os_log_pack_fill();
      v38 = SCErrorString(inserted);
      *(_DWORD *)v37 = v137;
      *(_QWORD *)(v37 + 4) = v38;
      v3 = v28;
      v13 = v27;
      v5 = v26;
      __SC_log_send(6, (uint64_t)v23, v24, v36);
      v11 = v135;
      v1 = v136;
    }
    if (inserted == 268435459)
    {
      v9 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    }
    else
    {
      v9 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
      if (inserted != -308)
      {
        v139 = inserted;
        goto LABEL_72;
      }
      mach_port_mod_refs(*MEMORY[0x1E0C83DA0], name[1], 1u, -1);
      name[1] = 0;
    }
LABEL_37:
    pthread_mutex_lock(&scnc_lock);
    v39 = *((_DWORD *)v5 + 36);
    if (!v39)
      goto LABEL_40;
    if (v39 == v6)
    {
      scnc_server_name = 0;
      mach_port_deallocate(*v9, v6);
LABEL_40:
      v39 = __SCNetworkConnectionServerPort(&v139);
      *((_DWORD *)v5 + 36) = v39;
    }
    pthread_mutex_unlock(&scnc_lock);
    v6 = v39;
    if (!v39)
    {
      if (v139 != 1102)
        goto LABEL_72;
      v40 = v134;
      if (v134)
      {
        if (v134 > 0x991)
          goto LABEL_72;
      }
      else
      {
        v41 = SCDynamicStoreCreate(0, CFSTR("SCNetworkConnection connect"), 0, 0);
        if (v41)
          CFRelease(v41);
      }
      v134 = v40 + 50;
      usleep(0xC350u);
      v6 = 0;
    }
  }
  if (v139)
  {
    v42 = v13[13];
    if (!v42)
    {
      v42 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      v13[13] = (uint64_t)v42;
    }
    v43 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v42, (os_log_type_t)v43))
    {
      v44 = _os_log_pack_size();
      v52 = (char *)&v134 - ((MEMORY[0x1E0C80A78](v44, v45, v46, v47, v48, v49, v50, v51) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v53 = _os_log_pack_fill();
      v54 = SCErrorString(v139);
      v55 = ", w/session_port!=MACH_PORT_NULL";
      if (!*v3)
        v55 = "";
      *(_DWORD *)v53 = 136315394;
      *(_QWORD *)(v53 + 4) = v54;
      *(_WORD *)(v53 + 12) = 2080;
      *(_QWORD *)(v53 + 14) = v55;
      __SC_log_send(7, (uint64_t)v42, v43, v52);
    }
    if (*v3)
    {
      mach_port_deallocate(*v9, *v3);
      *v3 = 0;
    }
    if (name[1])
    {
      mach_port_mod_refs(*v9, name[1], 1u, -1);
      inserted = 0;
      goto LABEL_85;
    }
    inserted = 0;
    if (!v11)
      goto LABEL_88;
LABEL_87:
    mach_port_deallocate(*v9, v11);
    goto LABEL_88;
  }
  inserted = 0;
LABEL_72:
  if (!name[1])
  {
LABEL_86:
    if (!v11)
      goto LABEL_88;
    goto LABEL_87;
  }
  if (!*v3)
  {
    mach_port_mod_refs(*v9, name[1], 1u, -1);
    mach_port_deallocate(*v9, name[1]);
LABEL_85:
    name[1] = 0;
    goto LABEL_86;
  }
  v138.version = 0;
  v138.info = (void *)v1;
  v138.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
  v138.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
  v138.copyDescription = (CFStringRef (__cdecl *)(const void *))pppMPCopyDescription;
  inserted = mach_port_request_notification(*v9, name[1], 70, 1u, name[1], 0x15u, name);
  if (inserted)
  {
    v69 = v13[13];
    if (!v69)
    {
      v69 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      v13[13] = (uint64_t)v69;
    }
    v70 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v69, (os_log_type_t)v70))
      goto LABEL_78;
    goto LABEL_79;
  }
  if (name[0])
  {
    v123 = v13[13];
    if (!v123)
    {
      v123 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      v13[13] = (uint64_t)v123;
    }
    v124 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v123, (os_log_type_t)v124))
    {
      v125 = _os_log_pack_size();
      v133 = (char *)&v134
           - ((MEMORY[0x1E0C80A78](v125, v126, v127, v128, v129, v130, v131, v132) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v123, v124, v133);
    }
  }
  *(_QWORD *)(v1 + 208) = _SC_CFMachPortCreateWithPort((uint64_t)"SCNetworkConnection", name[1], (void (__cdecl *)(CFMachPortRef, void *, CFIndex, void *))__SCNetworkConnectionMachCallBack, &v138);
  *(_BYTE *)(v1 + 216) = 0;
  if (v11)
    goto LABEL_87;
LABEL_88:
  if (v143[0])
    CFRelease(v143[0]);
  if (v139 == 1102)
  {
    v98 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v98 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v98;
    }
    if (inserted)
      v99 = 3;
    else
      v99 = 5;
    v100 = _SC_syslog_os_log_mapping(v99);
    if (!__SC_log_enabled(v99, v98, (os_log_type_t)v100))
      goto LABEL_112;
    v101 = _os_log_pack_size();
    v109 = (char *)&v134
         - ((MEMORY[0x1E0C80A78](v101, v102, v103, v104, v105, v106, v107, v108) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v110 = _os_log_pack_fill();
    *(_DWORD *)v110 = 136315138;
    *(_QWORD *)(v110 + 4) = v1 + 88;
    v94 = v99;
    v95 = (uint64_t)v98;
  }
  else
  {
    if (!v139)
    {
      v82 = __log_SCNetworkConnection_log;
      if (!__log_SCNetworkConnection_log)
      {
        v82 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
        __log_SCNetworkConnection_log = (uint64_t)v82;
      }
      v83 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v82, (os_log_type_t)v83))
      {
        v84 = _os_log_pack_size();
        v92 = (char *)&v134
            - ((MEMORY[0x1E0C80A78](v84, v85, v86, v87, v88, v89, v90, v91) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v93 = _os_log_pack_fill();
        *(_DWORD *)v93 = 136315138;
        *(_QWORD *)(v93 + 4) = v1 + 88;
        v94 = 7;
        v95 = (uint64_t)v82;
        v96 = v83;
        v97 = v92;
        goto LABEL_111;
      }
      goto LABEL_112;
    }
    v111 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v111 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v111;
    }
    if (inserted)
      v112 = 3;
    else
      v112 = 5;
    v100 = _SC_syslog_os_log_mapping(v112);
    if (!__SC_log_enabled(v112, v111, (os_log_type_t)v100))
      goto LABEL_112;
    v113 = _os_log_pack_size();
    v109 = (char *)&v134
         - ((MEMORY[0x1E0C80A78](v113, v114, v115, v116, v117, v118, v119, v120) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v121 = _os_log_pack_fill();
    v122 = SCErrorString(v139);
    *(_DWORD *)v121 = 136315394;
    *(_QWORD *)(v121 + 4) = v1 + 88;
    *(_WORD *)(v121 + 12) = 2080;
    *(_QWORD *)(v121 + 14) = v122;
    v94 = v112;
    v95 = (uint64_t)v111;
  }
  v96 = v100;
  v97 = v109;
LABEL_111:
  __SC_log_send(v94, v95, v96, v97);
LABEL_112:
  if (v139)
    _SCErrorSet(v139);
  return *v3;
}

uint64_t __SCNetworkConnectionNeedsRetry(uint64_t a1, uint64_t a2, mach_error_t a3, mach_error_t *a4)
{
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t result;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  char *v33;
  _QWORD v34[2];

  v34[1] = *MEMORY[0x1E0C80C00];
  switch(a3)
  {
    case 268435459:
      goto LABEL_4;
    case 0:
      return 0;
    case -308:
LABEL_4:
      v7 = __log_SCNetworkConnection_log;
      if (!__log_SCNetworkConnection_log)
      {
        v7 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
        __log_SCNetworkConnection_log = (uint64_t)v7;
      }
      v8 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v7, (os_log_type_t)v8))
      {
        v9 = _os_log_pack_size();
        v17 = (char *)v34 - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v18 = _os_log_pack_fill();
        *(_DWORD *)v18 = 136315138;
        *(_QWORD *)(v18 + 4) = a1 + 88;
        __SC_log_send(7, (uint64_t)v7, v8, v17);
      }
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], *(_DWORD *)(a1 + 200));
      break;
    default:
      v21 = __log_SCNetworkConnection_log;
      if (!__log_SCNetworkConnection_log)
      {
        v21 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
        __log_SCNetworkConnection_log = (uint64_t)v21;
      }
      v22 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v21, (os_log_type_t)v22))
      {
        v23 = _os_log_pack_size();
        v31 = (char *)v34 - ((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v32 = _os_log_pack_fill();
        v33 = mach_error_string(a3);
        *(_DWORD *)v32 = 136315650;
        *(_QWORD *)(v32 + 4) = a1 + 88;
        *(_WORD *)(v32 + 12) = 2080;
        *(_QWORD *)(v32 + 14) = a2;
        *(_WORD *)(v32 + 22) = 2080;
        *(_QWORD *)(v32 + 24) = v33;
        __SC_log_send(5, (uint64_t)v21, v22, v31);
      }
      break;
  }
  *(_DWORD *)(a1 + 200) = 0;
  if ((a3 == 268435459 || a3 == -308) && __SCNetworkConnectionSessionPort(a1))
    return 1;
  result = 0;
  *a4 = a3;
  return result;
}

const void *isA_CFDictionary(const void *a1)
{
  CFTypeID TypeID;

  TypeID = CFDictionaryGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) == TypeID)
    return a1;
  return 0;
}

uint64_t SCNetworkConnectionGetService(_QWORD *cf)
{
  uint64_t v2;

  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!cf)
      goto LABEL_6;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[10];
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

SCNetworkConnectionStatus SCNetworkConnectionGetStatus(SCNetworkConnectionRef connection)
{
  uint64_t v2;
  const __SCNetworkService *v3;
  const __CFString *ServiceID;
  NSObject *v5;
  unsigned int v6;
  SCNetworkConnectionStatus v7;
  int v8;
  unsigned int i;
  int v10;
  mach_error_t v11;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;
  mach_error_t v17;
  SCNetworkConnectionStatus v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v17 = 1001;
  v18 = kSCNetworkConnectionInvalid;
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!connection)
    {
LABEL_27:
      v8 = 1002;
      goto LABEL_28;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!connection)
      goto LABEL_27;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(connection) != v2)
    goto LABEL_27;
  v3 = (const __SCNetworkService *)*((_QWORD *)connection + 10);
  if (!v3 || (ServiceID = SCNetworkServiceGetServiceID(v3), !CFStringGetLength(ServiceID)))
  {
    v8 = 5001;
LABEL_28:
    _SCErrorSet(v8);
    return -1;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)connection + 16));
  if (*((_QWORD *)connection + 43))
  {
    v13 = 0;
    v14 = &v13;
    v15 = 0x2000000000;
    v16 = 0;
    ne_session_retain();
    pthread_mutex_unlock((pthread_mutex_t *)((char *)connection + 16));
    v5 = dispatch_semaphore_create(0);
    if (__SCNetworkConnectionQueue_once != -1)
      dispatch_once(&__SCNetworkConnectionQueue_once, &__block_literal_global_91_0);
    ne_session_get_status();
    dispatch_semaphore_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
    v6 = *((_DWORD *)v14 + 6) - 1;
    if (v6 > 4)
      v7 = kSCNetworkConnectionInvalid;
    else
      v7 = dword_18D3FF438[v6];
    _Block_object_dispose(&v13, 8);
  }
  else
  {
    for (i = 0; ; i += 10)
    {
      do
      {
        v10 = __SCNetworkConnectionSessionPort(connection);
        if (!v10)
          goto LABEL_23;
        v11 = pppcontroller_getstatus(v10, &v18, &v17);
      }
      while (__SCNetworkConnectionNeedsRetry((uint64_t)connection, (uint64_t)"SCNetworkConnectionGetStatus()", v11, &v17));
      if (*((_BYTE *)connection + 216) || v17 != 5001 || i > 0xEF)
        break;
      usleep(0x2710u);
    }
    if (v17)
    {
      _SCErrorSet(v17);
LABEL_23:
      v18 = kSCNetworkConnectionInvalid;
      goto LABEL_24;
    }
    *((_BYTE *)connection + 216) = 1;
LABEL_24:
    pthread_mutex_unlock((pthread_mutex_t *)((char *)connection + 16));
    return v18;
  }
  return v7;
}

uint64_t SCNetworkConnectionGetStatusFromNEStatus(int a1)
{
  if ((a1 - 1) > 4)
    return 0xFFFFFFFFLL;
  else
    return dword_18D3FF438[a1 - 1];
}

CFDictionaryRef SCNetworkConnectionCopyExtendedStatus(SCNetworkConnectionRef connection)
{
  uint64_t v2;
  const __SCNetworkService *v3;
  const __CFString *ServiceID;
  NSObject *v5;
  const __CFDictionary *v6;
  int v7;
  unsigned int v8;
  int v9;
  mach_error_t v10;
  int v11;
  int v12;
  CFTypeRef v13;
  CFTypeID TypeID;
  int v15;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  mach_error_t v21;
  CFTypeRef cf;
  unsigned int v23;
  UInt8 *v24[2];

  v24[1] = *(UInt8 **)MEMORY[0x1E0C80C00];
  v24[0] = 0;
  v23 = 0;
  cf = 0;
  v21 = 1001;
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!connection)
    {
LABEL_35:
      v7 = 1002;
      goto LABEL_36;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!connection)
      goto LABEL_35;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(connection) != v2)
    goto LABEL_35;
  v3 = (const __SCNetworkService *)*((_QWORD *)connection + 10);
  if (!v3 || (ServiceID = SCNetworkServiceGetServiceID(v3), !CFStringGetLength(ServiceID)))
  {
    v7 = 5001;
LABEL_36:
    _SCErrorSet(v7);
    return 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)connection + 16));
  if (*((_QWORD *)connection + 43))
  {
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = 0;
    ne_session_retain();
    pthread_mutex_unlock((pthread_mutex_t *)((char *)connection + 16));
    v5 = dispatch_semaphore_create(0);
    if (__SCNetworkConnectionQueue_once != -1)
      dispatch_once(&__SCNetworkConnectionQueue_once, &__block_literal_global_91_0);
    ne_session_get_info();
    dispatch_semaphore_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
    v6 = (const __CFDictionary *)v18[3];
    if (!v6)
      _SCErrorSet(1001);
    _Block_object_dispose(&v17, 8);
  }
  else
  {
    v8 = 0;
    while (1)
    {
      v9 = __SCNetworkConnectionSessionPort((uint64_t)connection);
      if (!v9)
        break;
      v10 = pppcontroller_copyextendedstatus(v9, v24, &v23, &v21);
      if (!__SCNetworkConnectionNeedsRetry((uint64_t)connection, (uint64_t)"SCNetworkConnectionCopyExtendedStatus()", v10, &v21))
      {
        if (v24[0])
        {
          v11 = _SCUnserialize(&cf, 0, v24[0], v23);
          v12 = v21;
          if (!v11 && v21)
          {
            v12 = SCError();
            v21 = v12;
          }
          if (!v12)
          {
            v13 = cf;
            TypeID = CFDictionaryGetTypeID();
            if (!v13 || CFGetTypeID(v13) != TypeID)
            {
              v15 = 1001;
              v21 = 1001;
LABEL_30:
              if (cf)
              {
                CFRelease(cf);
                cf = 0;
                v15 = v21;
              }
              _SCErrorSet(v15);
              break;
            }
          }
        }
        v15 = v21;
        if (*((_BYTE *)connection + 216) || v21 != 5001 || v8 > 0xEF)
        {
          if (!v21)
          {
            *((_BYTE *)connection + 216) = 1;
            break;
          }
          goto LABEL_30;
        }
        v8 += 10;
        usleep(0x2710u);
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)connection + 16));
    return (CFDictionaryRef)cf;
  }
  return v6;
}

Boolean SCNetworkConnectionStart(SCNetworkConnectionRef connection, CFDictionaryRef userOptions, Boolean linger)
{
  int v3;
  uint64_t v6;
  CFTypeID TypeID;
  CFMutableDictionaryRef MutableCopy;
  const __CFDictionary *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  const __CFDictionary *v22;
  const __CFDictionary *Value;
  CFTypeID v24;
  const void *v25;
  CFTypeID v26;
  __CFDictionary *v27;
  const __CFDictionary *v28;
  CFTypeID v29;
  const void *v30;
  CFTypeID v31;
  __CFDictionary *v32;
  const __CFDictionary *v33;
  CFTypeID v34;
  const void *v35;
  CFTypeID v36;
  __CFDictionary *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  pthread_mutex_t *v50;
  const void *v51;
  void *v52;
  mach_port_t v53;
  mach_error_t v54;
  NSObject *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  int v67;
  Boolean v68;
  _BYTE v70[12];
  int v71;
  vm_size_t v72;
  uint64_t v73;
  CFDataRef v74[2];

  v3 = linger;
  v74[1] = *(CFDataRef *)MEMORY[0x1E0C80C00];
  v73 = 0;
  v74[0] = 0;
  v72 = 0;
  v71 = 1001;
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!connection)
      goto LABEL_71;
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!connection)
      goto LABEL_71;
  }
  v6 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(connection) != v6)
    goto LABEL_71;
  if (!userOptions)
  {
    userOptions = (CFDictionaryRef)*((_QWORD *)connection + 40);
    goto LABEL_10;
  }
  TypeID = CFDictionaryGetTypeID();
  if (CFGetTypeID(userOptions) != TypeID)
  {
LABEL_71:
    _SCErrorSet(1002);
    return 0;
  }
  if (*((_QWORD *)connection + 40))
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, userOptions);
    if (MutableCopy)
    {
      v9 = MutableCopy;
      CFDictionaryApplyFunction(*((CFDictionaryRef *)connection + 40), (CFDictionaryApplierFunction)_SCNetworkConnectionMergeDictionaries, MutableCopy);
      CFRelease(*((CFTypeRef *)connection + 40));
      *((_QWORD *)connection + 40) = v9;
      userOptions = v9;
    }
  }
LABEL_10:
  if (debug >= 1)
  {
    v10 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v10 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v10;
    }
    v11 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v10, (os_log_type_t)v11))
    {
      v12 = _os_log_pack_size();
      v20 = &v70[-((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v21 = _os_log_pack_fill();
      *(_DWORD *)v21 = 136315138;
      *(_QWORD *)(v21 + 4) = (char *)connection + 88;
      __SC_log_send(6, (uint64_t)v10, v11, v20);
    }
    if (userOptions)
    {
      v22 = CFDictionaryCreateMutableCopy(0, 0, userOptions);
      Value = (const __CFDictionary *)CFDictionaryGetValue(v22, CFSTR("PPP"));
      v24 = CFDictionaryGetTypeID();
      if (Value)
      {
        if (CFGetTypeID(Value) == v24)
        {
          v25 = CFDictionaryGetValue(Value, CFSTR("AuthPasswordEncryption"));
          v26 = CFStringGetTypeID();
          if (!v25 || CFGetTypeID(v25) != v26 || !CFEqual(v25, CFSTR("Keychain")))
          {
            v27 = CFDictionaryCreateMutableCopy(0, 0, Value);
            CFDictionaryReplaceValue(v27, CFSTR("AuthPassword"), CFSTR("******"));
            CFDictionarySetValue(v22, CFSTR("PPP"), v27);
            CFRelease(v27);
          }
        }
      }
      v28 = (const __CFDictionary *)CFDictionaryGetValue(v22, CFSTR("L2TP"));
      v29 = CFDictionaryGetTypeID();
      if (v28)
      {
        if (CFGetTypeID(v28) == v29)
        {
          v30 = CFDictionaryGetValue(v28, CFSTR("IPSecSharedSecretEncryption"));
          v31 = CFStringGetTypeID();
          if (!v30 || CFGetTypeID(v30) != v31 || !CFEqual(v30, CFSTR("Keychain")))
          {
            v32 = CFDictionaryCreateMutableCopy(0, 0, v28);
            CFDictionaryReplaceValue(v32, CFSTR("IPSecSharedSecret"), CFSTR("******"));
            CFDictionarySetValue(v22, CFSTR("L2TP"), v32);
            CFRelease(v32);
          }
        }
      }
      v33 = (const __CFDictionary *)CFDictionaryGetValue(v22, CFSTR("IPSec"));
      v34 = CFDictionaryGetTypeID();
      if (v33)
      {
        if (CFGetTypeID(v33) == v34)
        {
          v35 = CFDictionaryGetValue(v33, CFSTR("SharedSecretEncryption"));
          v36 = CFStringGetTypeID();
          if (!v35 || CFGetTypeID(v35) != v36 || !CFEqual(v35, CFSTR("Keychain")))
          {
            v37 = CFDictionaryCreateMutableCopy(0, 0, v33);
            CFDictionaryReplaceValue(v37, CFSTR("SharedSecret"), CFSTR("******"));
            CFDictionarySetValue(v22, CFSTR("IPSec"), v37);
            CFRelease(v37);
          }
        }
      }
    }
    else
    {
      v22 = 0;
    }
    v38 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v38 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v38;
    }
    v39 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v38, (os_log_type_t)v39))
    {
      v40 = _os_log_pack_size();
      v48 = &v70[-((MEMORY[0x1E0C80A78](v40, v41, v42, v43, v44, v45, v46, v47) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v49 = _os_log_pack_fill();
      *(_DWORD *)v49 = 138412290;
      *(_QWORD *)(v49 + 4) = v22;
      __SC_log_send(6, (uint64_t)v38, v39, v48);
    }
    if (v22)
      CFRelease(v22);
  }
  v50 = (pthread_mutex_t *)((char *)connection + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)connection + 16));
  v51 = (const void *)*((_QWORD *)connection + 42);
  if (v51)
  {
    CFRelease(v51);
    *((_QWORD *)connection + 42) = 0;
  }
  if (*((_QWORD *)connection + 43))
  {
    if (userOptions)
      v52 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    else
      v52 = 0;
    if (*((_DWORD *)connection + 39))
      ne_session_start_on_behalf_of();
    else
      ne_session_start_with_options();
    ne_session_send_barrier();
    if (v52)
      xpc_release(v52);
  }
  else
  {
    if (userOptions && !_SCSerialize(userOptions, v74, (vm_address_t *)&v73, &v72))
    {
LABEL_68:
      v68 = 0;
      goto LABEL_69;
    }
    do
    {
      v53 = __SCNetworkConnectionSessionPort((uint64_t)connection);
      if (!v53)
      {
        if (v74[0])
          CFRelease(v74[0]);
        goto LABEL_68;
      }
      v54 = pppcontroller_start(v53, v73, v72, v3, &v71);
    }
    while (__SCNetworkConnectionNeedsRetry((uint64_t)connection, (uint64_t)"SCNetworkConnectionStart()", v54, &v71));
    if (v74[0])
      CFRelease(v74[0]);
    if (debug >= 1)
    {
      v55 = __log_SCNetworkConnection_log;
      if (!__log_SCNetworkConnection_log)
      {
        v55 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
        __log_SCNetworkConnection_log = (uint64_t)v55;
      }
      v56 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v55, (os_log_type_t)v56))
      {
        v57 = _os_log_pack_size();
        v65 = &v70[-((MEMORY[0x1E0C80A78](v57, v58, v59, v60, v61, v62, v63, v64) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v66 = _os_log_pack_fill();
        v67 = v71;
        *(_DWORD *)v66 = 136315394;
        *(_QWORD *)(v66 + 4) = (char *)connection + 88;
        *(_WORD *)(v66 + 12) = 1024;
        *(_DWORD *)(v66 + 14) = v67;
        __SC_log_send(6, (uint64_t)v55, v56, v65);
      }
    }
    if (v71)
    {
      _SCErrorSet(v71);
      goto LABEL_68;
    }
  }
  v68 = 1;
LABEL_69:
  pthread_mutex_unlock(v50);
  return v68;
}

void _SCNetworkConnectionMergeDictionaries(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionaryAddValue(theDict, key, value);
}

Boolean SCNetworkConnectionStop(SCNetworkConnectionRef connection, Boolean forceDisconnect)
{
  int v2;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  pthread_mutex_t *v17;
  Boolean v18;
  int v19;
  mach_error_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  mach_error_t v33;
  _BYTE v35[4];
  mach_error_t v36;
  uint64_t v37;

  v2 = forceDisconnect;
  v37 = *MEMORY[0x1E0C80C00];
  v36 = 1001;
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!connection)
    {
LABEL_24:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!connection)
      goto LABEL_24;
  }
  v4 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(connection) != v4)
    goto LABEL_24;
  if (debug >= 1)
  {
    v5 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v5 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v5;
    }
    v6 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v5, (os_log_type_t)v6))
    {
      v7 = _os_log_pack_size();
      v15 = &v35[-((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v16 = _os_log_pack_fill();
      *(_DWORD *)v16 = 136315138;
      *(_QWORD *)(v16 + 4) = (char *)connection + 88;
      __SC_log_send(6, (uint64_t)v5, v6, v15);
    }
  }
  v17 = (pthread_mutex_t *)((char *)connection + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)connection + 16));
  if (*((_QWORD *)connection + 43))
  {
    ne_session_stop();
    ne_session_send_barrier();
  }
  else
  {
    do
    {
      v19 = __SCNetworkConnectionSessionPort((uint64_t)connection);
      if (!v19)
        goto LABEL_21;
      v20 = pppcontroller_stop(v19, v2, &v36);
    }
    while (__SCNetworkConnectionNeedsRetry((uint64_t)connection, (uint64_t)"SCNetworkConnectionStop()", v20, &v36));
    if (debug >= 1)
    {
      v21 = __log_SCNetworkConnection_log;
      if (!__log_SCNetworkConnection_log)
      {
        v21 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
        __log_SCNetworkConnection_log = (uint64_t)v21;
      }
      v22 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v21, (os_log_type_t)v22))
      {
        v23 = _os_log_pack_size();
        v31 = &v35[-((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v32 = _os_log_pack_fill();
        v33 = v36;
        *(_DWORD *)v32 = 136315394;
        *(_QWORD *)(v32 + 4) = (char *)connection + 88;
        *(_WORD *)(v32 + 12) = 1024;
        *(_DWORD *)(v32 + 14) = v33;
        __SC_log_send(6, (uint64_t)v21, v22, v31);
      }
    }
    if (v36)
    {
      _SCErrorSet(v36);
LABEL_21:
      v18 = 0;
      goto LABEL_22;
    }
  }
  v18 = 1;
LABEL_22:
  pthread_mutex_unlock(v17);
  return v18;
}

uint64_t SCNetworkConnectionSuspend(char *cf)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  pthread_mutex_t *v15;
  mach_port_t v16;
  mach_error_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  mach_error_t v30;
  uint64_t v31;
  _BYTE v33[4];
  mach_error_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v34 = 1001;
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_23:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!cf)
      goto LABEL_23;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_23;
  if (debug >= 1)
  {
    v3 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v3 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v3;
    }
    v4 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v3, (os_log_type_t)v4))
    {
      v5 = _os_log_pack_size();
      v13 = &v33[-((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v14 = _os_log_pack_fill();
      *(_DWORD *)v14 = 136315138;
      *(_QWORD *)(v14 + 4) = cf + 88;
      __SC_log_send(6, (uint64_t)v3, v4, v13);
    }
  }
  v15 = (pthread_mutex_t *)(cf + 16);
  pthread_mutex_lock((pthread_mutex_t *)(cf + 16));
  do
  {
    v16 = __SCNetworkConnectionSessionPort((uint64_t)cf);
    if (!v16)
      goto LABEL_19;
    v17 = pppcontroller_suspend(v16, (mach_port_t *)&v34);
  }
  while (__SCNetworkConnectionNeedsRetry((uint64_t)cf, (uint64_t)"SCNetworkConnectionSuspend()", v17, &v34));
  if (debug >= 1)
  {
    v18 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v18 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v18;
    }
    v19 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v18, (os_log_type_t)v19))
    {
      v20 = _os_log_pack_size();
      v28 = &v33[-((MEMORY[0x1E0C80A78](v20, v21, v22, v23, v24, v25, v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v29 = _os_log_pack_fill();
      v30 = v34;
      *(_DWORD *)v29 = 136315394;
      *(_QWORD *)(v29 + 4) = cf + 88;
      *(_WORD *)(v29 + 12) = 1024;
      *(_DWORD *)(v29 + 14) = v30;
      __SC_log_send(6, (uint64_t)v18, v19, v28);
    }
  }
  if (v34)
  {
    _SCErrorSet(v34);
LABEL_19:
    v31 = 0;
    goto LABEL_20;
  }
  v31 = 1;
LABEL_20:
  pthread_mutex_unlock(v15);
  return v31;
}

uint64_t SCNetworkConnectionResume(char *cf)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  pthread_mutex_t *v15;
  uint64_t v16;
  mach_port_t v17;
  mach_error_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  mach_error_t v31;
  _BYTE v33[4];
  mach_error_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v34 = 1001;
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_23:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!cf)
      goto LABEL_23;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_23;
  if (debug >= 1)
  {
    v3 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v3 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v3;
    }
    v4 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v3, (os_log_type_t)v4))
    {
      v5 = _os_log_pack_size();
      v13 = &v33[-((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v14 = _os_log_pack_fill();
      *(_DWORD *)v14 = 136315138;
      *(_QWORD *)(v14 + 4) = cf + 88;
      __SC_log_send(6, (uint64_t)v3, v4, v13);
    }
  }
  v15 = (pthread_mutex_t *)(cf + 16);
  pthread_mutex_lock((pthread_mutex_t *)(cf + 16));
  if (!*((_QWORD *)cf + 43))
  {
    do
    {
      v17 = __SCNetworkConnectionSessionPort((uint64_t)cf);
      if (!v17)
        goto LABEL_20;
      v18 = pppcontroller_resume(v17, (mach_port_t *)&v34);
    }
    while (__SCNetworkConnectionNeedsRetry((uint64_t)cf, (uint64_t)"SCNetworkConnectionResume()", v18, &v34));
    if (debug >= 1)
    {
      v19 = __log_SCNetworkConnection_log;
      if (!__log_SCNetworkConnection_log)
      {
        v19 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
        __log_SCNetworkConnection_log = (uint64_t)v19;
      }
      v20 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v19, (os_log_type_t)v20))
      {
        v21 = _os_log_pack_size();
        v29 = &v33[-((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v30 = _os_log_pack_fill();
        v31 = v34;
        *(_DWORD *)v30 = 136315394;
        *(_QWORD *)(v30 + 4) = cf + 88;
        *(_WORD *)(v30 + 12) = 1024;
        *(_DWORD *)(v30 + 14) = v31;
        __SC_log_send(6, (uint64_t)v19, v20, v29);
      }
    }
    if (v34)
    {
      _SCErrorSet(v34);
LABEL_20:
      v16 = 0;
      goto LABEL_21;
    }
  }
  v16 = 1;
LABEL_21:
  pthread_mutex_unlock(v15);
  return v16;
}

uint64_t SCNetworkConnectionRefreshOnDemandState()
{
  return 0;
}

CFDictionaryRef SCNetworkConnectionCopyUserOptions(SCNetworkConnectionRef connection)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  NSObject *v4;
  const __CFDictionary *v5;
  int v6;
  mach_error_t v7;
  int v8;
  int v9;
  const __CFDictionary *v10;
  CFTypeID TypeID;
  CFTypeID v12;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  const __CFDictionary *v18;
  mach_error_t v19;
  unsigned int v20;
  UInt8 *v21[2];

  v21[1] = *(UInt8 **)MEMORY[0x1E0C80C00];
  v21[0] = 0;
  v19 = 1001;
  v20 = 0;
  v18 = 0;
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!connection)
    {
LABEL_35:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!connection)
      goto LABEL_35;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(connection) != v2)
    goto LABEL_35;
  v3 = (pthread_mutex_t *)((char *)connection + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)connection + 16));
  if (*((_QWORD *)connection + 43))
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2000000000;
    v17 = 0;
    ne_session_retain();
    pthread_mutex_unlock((pthread_mutex_t *)((char *)connection + 16));
    v4 = dispatch_semaphore_create(0);
    if (__SCNetworkConnectionQueue_once != -1)
      dispatch_once(&__SCNetworkConnectionQueue_once, &__block_literal_global_91_0);
    ne_session_get_info();
    dispatch_semaphore_wait(v4, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v4);
    if (v15[3] && MEMORY[0x18D78D248]() == MEMORY[0x1E0C812F8])
    {
      if (xpc_dictionary_get_value((xpc_object_t)v15[3], "SessionLegacyUserConfiguration"))
        v5 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
      else
        v5 = 0;
      xpc_release((xpc_object_t)v15[3]);
    }
    else
    {
      v5 = 0;
    }
    _Block_object_dispose(&v14, 8);
    return v5;
  }
  do
  {
    v6 = __SCNetworkConnectionSessionPort((uint64_t)connection);
    if (!v6)
      goto LABEL_30;
    v7 = pppcontroller_copyuseroptions(v6, v21, &v20, &v19);
  }
  while (__SCNetworkConnectionNeedsRetry((uint64_t)connection, (uint64_t)"SCNetworkConnectionCopyUserOptions()", v7, &v19));
  if (!v21[0])
  {
    v10 = 0;
LABEL_23:
    v9 = v19;
    goto LABEL_24;
  }
  v8 = _SCUnserialize((CFPropertyListRef *)&v18, 0, v21[0], v20);
  v9 = v19;
  if (!v8 && v19)
  {
    v9 = SCError();
    v19 = v9;
  }
  v10 = v18;
  if (!v9 && v18)
  {
    TypeID = CFDictionaryGetTypeID();
    v12 = CFGetTypeID(v10);
    v10 = v18;
    if (v12 != TypeID)
    {
      v9 = 1001;
      v19 = 1001;
LABEL_25:
      if (v10)
      {
        CFRelease(v10);
        v18 = 0;
        v9 = v19;
      }
      _SCErrorSet(v9);
      goto LABEL_30;
    }
    goto LABEL_23;
  }
LABEL_24:
  if (v9)
    goto LABEL_25;
  if (!v10)
    v18 = CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
LABEL_30:
  pthread_mutex_unlock(v3);
  return v18;
}

Boolean SCNetworkConnectionScheduleWithRunLoop(SCNetworkConnectionRef connection, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v6;
  CFTypeID v7;

  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!connection)
      goto LABEL_8;
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!connection)
      goto LABEL_8;
  }
  v6 = __kSCNetworkConnectionTypeID;
  v7 = CFGetTypeID(connection);
  if (runLoopMode && runLoop && v7 == v6)
    return __SCNetworkConnectionScheduleWithRunLoop((uint64_t)connection, runLoop, runLoopMode, 0);
LABEL_8:
  _SCErrorSet(1002);
  return 0;
}

uint64_t __SCNetworkConnectionScheduleWithRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3, NSObject *a4)
{
  pthread_mutex_t *v8;
  int v9;
  uint64_t v10;
  int v12;
  mach_error_t v13;
  CFRunLoopSourceRef RunLoopSource;
  __CFMachPort *v15;
  mach_port_t Port;
  mach_port_t v17;
  uintptr_t v18;
  dispatch_source_t v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  _QWORD v45[6];
  _QWORD v46[7];
  _QWORD v47[6];
  mach_port_t v48;
  CFRunLoopSourceContext v49;
  mach_error_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v50 = 1001;
  v8 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (!*(_QWORD *)(a1 + 232) || *(_QWORD *)(a1 + 288))
    goto LABEL_3;
  if (!a4)
  {
    if (!*(_BYTE *)(a1 + 217))
      goto LABEL_11;
LABEL_27:
    if (!_SC_isScheduled((const void *)a1, a2, a3, *(CFArrayRef *)(a1 + 280)))
      CFRunLoopAddSource(a2, *(CFRunLoopSourceRef *)(a1 + 224), a3);
    _SC_schedule((void *)a1, a2, a3, *(CFMutableArrayRef *)(a1 + 280));
    goto LABEL_30;
  }
  if (*(_BYTE *)(a1 + 217))
  {
LABEL_3:
    v9 = 1002;
    goto LABEL_4;
  }
  do
  {
LABEL_11:
    if (*(_QWORD *)(a1 + 344))
    {
      if (!a2)
        goto LABEL_20;
      v49.version = 0;
      v49.info = (void *)a1;
      v49.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
      v49.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
      memset(&v49.copyDescription, 0, 40);
      v49.perform = (void (__cdecl *)(void *))__SCNetworkConnectionCallBack;
      RunLoopSource = CFRunLoopSourceCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &v49);
      goto LABEL_19;
    }
    v12 = __SCNetworkConnectionSessionPort(a1);
    if (!v12)
      goto LABEL_5;
    v13 = pppcontroller_notification(v12, 1, &v50);
  }
  while (__SCNetworkConnectionNeedsRetry(a1, (uint64_t)"__SCNetworkConnectionScheduleWithRunLoop()", v13, &v50));
  v9 = v50;
  if (v50)
    goto LABEL_4;
  if (a2)
  {
    RunLoopSource = CFMachPortCreateRunLoopSource(0, *(CFMachPortRef *)(a1 + 208), 0);
LABEL_19:
    *(_QWORD *)(a1 + 224) = RunLoopSource;
    *(_QWORD *)(a1 + 280) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  }
LABEL_20:
  *(_BYTE *)(a1 + 217) = 1;
  if (!a4)
    goto LABEL_27;
  *(_QWORD *)(a1 + 288) = a4;
  dispatch_retain(a4);
  if (*(_QWORD *)(a1 + 344))
  {
LABEL_30:
    if (*(_QWORD *)(a1 + 344))
    {
      CFRetain((CFTypeRef)a1);
      if (__SCNetworkConnectionQueue_once != -1)
        dispatch_once(&__SCNetworkConnectionQueue_once, &__block_literal_global_91_0);
      v45[0] = MEMORY[0x1E0C809B0];
      v45[1] = 0x40000000;
      v45[2] = ____SCNetworkConnectionScheduleWithRunLoop_block_invoke_3;
      v45[3] = &__block_descriptor_tmp_112;
      v45[4] = a1;
      v45[5] = a1;
      ne_session_set_event_handler();
    }
    v22 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v22 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v22;
    }
    v23 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v22, (os_log_type_t)v23))
    {
      v24 = _os_log_pack_size();
      v32 = (char *)v45 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v33 = _os_log_pack_fill();
      *(_DWORD *)v33 = 136315138;
      *(_QWORD *)(v33 + 4) = a1 + 88;
      __SC_log_send(7, (uint64_t)v22, v23, v32);
    }
    v10 = 1;
    goto LABEL_6;
  }
  v15 = *(__CFMachPort **)(a1 + 208);
  Port = CFMachPortGetPort(v15);
  if (Port)
  {
    v17 = Port;
    v18 = Port;
    if (__SCNetworkConnectionQueue_once != -1)
      dispatch_once(&__SCNetworkConnectionQueue_once, &__block_literal_global_91_0);
    v19 = dispatch_source_create(MEMORY[0x1E0C80D98], v18, 0, (dispatch_queue_t)__SCNetworkConnectionQueue_q);
    if (v19)
    {
      v20 = v19;
      CFRetain((CFTypeRef)a1);
      dispatch_set_context(v20, (void *)a1);
      dispatch_set_finalizer_f(v20, (dispatch_function_t)dispatch_CFRelease_0);
      CFRetain(v15);
      dispatch_retain(a4);
      v21 = MEMORY[0x1E0C809B0];
      v47[0] = MEMORY[0x1E0C809B0];
      v47[1] = 0x40000000;
      v47[2] = ____SCNetworkConnectionScheduleWithRunLoop_block_invoke;
      v47[3] = &__block_descriptor_tmp_109;
      v48 = v17;
      v47[4] = a1;
      v47[5] = a4;
      dispatch_source_set_event_handler(v20, v47);
      v46[0] = v21;
      v46[1] = 0x40000000;
      v46[2] = ____SCNetworkConnectionScheduleWithRunLoop_block_invoke_2;
      v46[3] = &__block_descriptor_tmp_110;
      v46[4] = v15;
      v46[5] = v20;
      v46[6] = a4;
      dispatch_source_set_cancel_handler(v20, v46);
      *(_QWORD *)(a1 + 296) = v20;
      dispatch_resume(v20);
      goto LABEL_30;
    }
    v34 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v34 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v34;
    }
    v35 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v34, (os_log_type_t)v35))
    {
      v36 = _os_log_pack_size();
      v44 = (char *)v45 - ((MEMORY[0x1E0C80A78](v36, v37, v38, v39, v40, v41, v42, v43) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v34, v35, v44);
    }
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 288));
  *(_QWORD *)(a1 + 288) = 0;
  v9 = 1001;
LABEL_4:
  _SCErrorSet(v9);
LABEL_5:
  v10 = 0;
LABEL_6:
  pthread_mutex_unlock(v8);
  return v10;
}

Boolean SCNetworkConnectionUnscheduleFromRunLoop(SCNetworkConnectionRef connection, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v6;
  CFTypeID v7;

  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!connection)
      goto LABEL_8;
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!connection)
      goto LABEL_8;
  }
  v6 = __kSCNetworkConnectionTypeID;
  v7 = CFGetTypeID(connection);
  if (runLoopMode && runLoop && v7 == v6)
    return __SCNetworkConnectionUnscheduleFromRunLoop((uint64_t)connection, runLoop, runLoopMode);
LABEL_8:
  _SCErrorSet(1002);
  return 0;
}

uint64_t __SCNetworkConnectionUnscheduleFromRunLoop(uint64_t a1, void *a2, const __CFString *a3)
{
  NSObject *v6;
  _QWORD *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v23;
  mach_error_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  HIDWORD(v25) = 1001;
  CFRetain((CFTypeRef)a1);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (a2)
  {
    if (*(_BYTE *)(a1 + 217) && !*(_QWORD *)(a1 + 288))
    {
      if (!_SC_unschedule((const void *)a1, a2, a3, *(CFArrayRef *)(a1 + 280), 0))
      {
        v21 = 1001;
        goto LABEL_20;
      }
      if (CFArrayGetCount(*(CFArrayRef *)(a1 + 280)))
      {
        if (!_SC_isScheduled((const void *)a1, a2, a3, *(CFArrayRef *)(a1 + 280)))
          CFRunLoopRemoveSource((CFRunLoopRef)a2, *(CFRunLoopSourceRef *)(a1 + 224), a3);
        goto LABEL_14;
      }
      v7 = (_QWORD *)(a1 + 224);
      CFRunLoopRemoveSource((CFRunLoopRef)a2, *(CFRunLoopSourceRef *)(a1 + 224), a3);
      CFRelease(*(CFTypeRef *)(a1 + 280));
      *(_QWORD *)(a1 + 280) = 0;
      CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(a1 + 224));
      CFRelease(*(CFTypeRef *)(a1 + 224));
      goto LABEL_11;
    }
LABEL_19:
    v21 = 1002;
    goto LABEL_20;
  }
  v6 = *(NSObject **)(a1 + 288);
  if (!v6)
    goto LABEL_19;
  v7 = (_QWORD *)(a1 + 288);
  if (*(_QWORD *)(a1 + 344)
    || !*(_QWORD *)(a1 + 296)
    || (dispatch_source_cancel(*(dispatch_source_t *)(a1 + 296)),
        *(_QWORD *)(a1 + 296) = 0,
        (v6 = *(NSObject **)(a1 + 288)) != 0))
  {
    dispatch_release(v6);
LABEL_11:
    *v7 = 0;
  }
  *(_BYTE *)(a1 + 217) = 0;
  if (!*(_QWORD *)(a1 + 344))
  {
    v23 = __SCNetworkConnectionSessionPort(a1);
    if (!v23)
      goto LABEL_21;
    v24 = pppcontroller_notification(v23, 0, (_DWORD *)&v25 + 1);
    if (__SCNetworkConnectionNeedsRetry(a1, (uint64_t)"__SCNetworkConnectionUnscheduleFromRunLoop pppcontroller_notification()", v24, (mach_error_t *)&v25 + 1))
    {
      v21 = 0;
      HIDWORD(v25) = 0;
      goto LABEL_33;
    }
    v21 = HIDWORD(v25);
    if (!v24)
    {
LABEL_33:
      if (!v21)
        goto LABEL_14;
    }
LABEL_20:
    _SCErrorSet(v21);
LABEL_21:
    v20 = 0;
    goto LABEL_22;
  }
  ne_session_cancel();
LABEL_14:
  v8 = __log_SCNetworkConnection_log;
  if (!__log_SCNetworkConnection_log)
  {
    v8 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
    __log_SCNetworkConnection_log = (uint64_t)v8;
  }
  v9 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v8, (os_log_type_t)v9))
  {
    v10 = _os_log_pack_size();
    v18 = (char *)&v25 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v19 = _os_log_pack_fill();
    *(_DWORD *)v19 = 136315138;
    *(_QWORD *)(v19 + 4) = a1 + 88;
    __SC_log_send(7, (uint64_t)v8, v9, v18);
  }
  v20 = 1;
LABEL_22:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  CFRelease((CFTypeRef)a1);
  return v20;
}

Boolean SCNetworkConnectionSetDispatchQueue(SCNetworkConnectionRef connection, dispatch_queue_t queue)
{
  uint64_t v4;

  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!connection)
    {
LABEL_8:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!connection)
      goto LABEL_8;
  }
  v4 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(connection) != v4)
    goto LABEL_8;
  if (queue)
    return __SCNetworkConnectionScheduleWithRunLoop((uint64_t)connection, 0, 0, queue);
  else
    return __SCNetworkConnectionUnscheduleFromRunLoop((uint64_t)connection, 0, 0);
}

uint64_t SCNetworkConnectionIsOnDemandSuspended(const __CFDictionary **cf)
{
  uint64_t v2;
  const __CFDictionary *v3;
  const void *Value;
  CFTypeID TypeID;
  int v7;
  int valuePtr;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_12:
      v7 = 1002;
      goto LABEL_13;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!cf)
      goto LABEL_12;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_12;
  v3 = cf[39];
  if (v3)
  {
    valuePtr = 0;
    Value = CFDictionaryGetValue(v3, CFSTR("OnDemandSuspended"));
    TypeID = CFNumberGetTypeID();
    if (Value)
    {
      if (CFGetTypeID(Value) == TypeID
        && CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, &valuePtr)
        && valuePtr)
      {
        return 1;
      }
    }
  }
  v7 = 0;
LABEL_13:
  _SCErrorSet(v7);
  return 0;
}

uint64_t SCNetworkConnectionTriggerOnDemandIfNeeded(const __CFString *a1, int a2, int a3)
{
  pid_t v6;
  UInt8 *v7;
  void *v8;
  int service_action;
  xpc_object_t v10;
  void *v11;
  NSObject *v12;
  dispatch_time_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD buffer[3];
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v23 = 0;
  memset(buffer, 0, sizeof(buffer));
  v6 = getpid();
  geteuid();
  if (a1 && geteuid())
  {
    v7 = _SC_cfstring_to_cstring(a1, 0, 0, 0x8000100u);
    v8 = 0;
    if (proc_pidinfo(v6, 17, 1uLL, buffer, 56) == 56)
    {
      v8 = (void *)ne_session_copy_policy_match();
      service_action = ne_session_policy_match_get_service_action();
      if (service_action == 1 || a2 && service_action == 2)
      {
        v20 = 0;
        v21 = 0;
        if (ne_session_policy_match_get_service())
        {
          v10 = xpc_dictionary_create(0, 0, 0);
          if (v10)
          {
            v11 = v10;
            xpc_dictionary_set_BOOL(v10, "is-on-demand", 1);
            xpc_dictionary_set_string(v11, "match-hostname", (const char *)v7);
            ne_session_policy_match_get_service_type();
            if (ne_session_create())
            {
              v12 = dispatch_semaphore_create(0);
              dispatch_retain(v12);
              xpc_retain(v11);
              if (__SCNetworkConnectionQueue_once != -1)
                dispatch_once(&__SCNetworkConnectionQueue_once, &__block_literal_global_91_0);
              ne_session_get_status();
              if (a3)
                v13 = dispatch_time(0, 1000000000 * a3);
              else
                v13 = -1;
              dispatch_semaphore_wait(v12, v13);
              dispatch_release(v12);
              ne_session_release();
            }
            xpc_release(v11);
          }
        }
      }
    }
    if (v7)
      CFAllocatorDeallocate(0, v7);
    if (v8)
      free(v8);
  }
  v14 = *((unsigned __int8 *)v17 + 24);
  _Block_object_dispose(&v16, 8);
  return v14;
}

uint64_t SCNetworkConnectionCopyOnDemandInfo(CFDictionaryRef *cf, _QWORD *a2, _DWORD *a3)
{
  uint64_t v6;
  const __CFDictionary *v7;
  const void *Value;
  CFTypeID TypeID;
  const __CFNumber *v10;
  CFTypeID v11;
  int v13;
  int valuePtr;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_22:
      v13 = 1002;
      goto LABEL_23;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!cf)
      goto LABEL_22;
  }
  v6 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(cf) != v6)
    goto LABEL_22;
  if (!cf[10])
  {
    v13 = 5001;
LABEL_23:
    _SCErrorSet(v13);
    return 0;
  }
  if (a2)
    *a2 = 0;
  if (a3)
    *a3 = -1;
  v7 = cf[39];
  if (v7)
  {
    if (a2)
    {
      Value = CFDictionaryGetValue(v7, CFSTR("RemoteAddress"));
      TypeID = CFStringGetTypeID();
      if (Value)
      {
        if (CFGetTypeID(Value) == TypeID)
        {
          *a2 = Value;
          CFRetain(Value);
        }
      }
    }
    if (a3)
    {
      valuePtr = 0;
      v10 = (const __CFNumber *)CFDictionaryGetValue(cf[39], CFSTR("Status"));
      v11 = CFNumberGetTypeID();
      if (v10)
      {
        if (CFGetTypeID(v10) == v11)
        {
          if (CFNumberGetValue(v10, kCFNumberIntType, &valuePtr))
            *a3 = valuePtr;
        }
      }
    }
  }
  return *((unsigned __int8 *)cf + 308);
}

uint64_t SCNetworkConnectionGetReachabilityInfo(CFDictionaryRef *cf, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6;
  const __CFDictionary *v7;
  const void *Value;
  CFTypeID TypeID;
  const __CFNumber *v10;
  CFTypeID v11;
  int v13;
  int valuePtr;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_23:
      v13 = 1002;
      goto LABEL_24;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!cf)
      goto LABEL_23;
  }
  v6 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(cf) != v6)
    goto LABEL_23;
  if (!cf[10])
  {
    v13 = 5001;
LABEL_24:
    _SCErrorSet(v13);
    return 0;
  }
  if (a2)
    *a2 = 0;
  if (a3)
    *a3 = 0;
  v7 = cf[39];
  if (v7)
  {
    if (a2)
    {
      valuePtr = 0;
      Value = CFDictionaryGetValue(v7, CFSTR("ReachFlags"));
      TypeID = CFNumberGetTypeID();
      if (Value)
      {
        if (CFGetTypeID(Value) == TypeID && CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &valuePtr))
          *a2 = valuePtr;
      }
    }
    if (a3)
    {
      valuePtr = 0;
      v10 = (const __CFNumber *)CFDictionaryGetValue(cf[39], CFSTR("ReachInterfaceIndex"));
      v11 = CFNumberGetTypeID();
      if (v10)
      {
        if (CFGetTypeID(v10) == v11)
        {
          if (CFNumberGetValue(v10, kCFNumberIntType, &valuePtr))
            *a3 = valuePtr;
        }
      }
    }
  }
  return 1;
}

uint64_t SCNetworkConnectionGetType(unsigned int *cf)
{
  uint64_t v2;
  int v4;

  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_8:
      v4 = 1002;
      goto LABEL_9;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!cf)
      goto LABEL_8;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_8;
  if (*((_QWORD *)cf + 10))
  {
    _SCErrorSet(0);
    return cf[76];
  }
  v4 = 5001;
LABEL_9:
  _SCErrorSet(v4);
  return 0;
}

uint64_t SCNetworkConnectionCopyFlowDivertToken()
{
  _SCErrorSet(1001);
  return 0;
}

const __CFDictionary *SCNetworkConnectionGetServiceIdentifier(uint64_t a1)
{
  const __CFDictionary *result;
  const __CFNumber *Value;
  CFTypeID TypeID;
  unsigned int valuePtr;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 80))
    return (const __CFDictionary *)0xFFFFFFFFLL;
  valuePtr = 0;
  result = *(const __CFDictionary **)(a1 + 312);
  if (result)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(result, CFSTR("ServiceIdentifier"));
    TypeID = CFNumberGetTypeID();
    if (Value && CFGetTypeID(Value) == TypeID)
    {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      return (const __CFDictionary *)valuePtr;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t _SC_domainEndsWithDomain(const __CFString *a1, const __CFString *cf1)
{
  const __CFString *v2;
  uint64_t v4;
  int HasSuffix;
  int v6;
  int v7;
  CFStringRef v8;
  const __CFString *v9;
  CFRange v11;
  CFRange v12;
  CFRange v13;

  v2 = cf1;
  if (CFEqual(cf1, CFSTR("*")))
    return 1;
  HasSuffix = CFStringHasSuffix(a1, CFSTR("."));
  if (HasSuffix)
  {
    v11.length = CFStringGetLength(a1) - 1;
    v11.location = 0;
    a1 = CFStringCreateWithSubstring(0, a1, v11);
    if (!a1)
      return 0;
  }
  v6 = CFStringHasSuffix(v2, CFSTR("."));
  if (v6)
  {
    v12.length = CFStringGetLength(v2) - 1;
    v12.location = 0;
    v2 = CFStringCreateWithSubstring(0, v2, v12);
    if (!v2)
    {
      v4 = 0;
      v7 = 0;
      if (!HasSuffix)
        goto LABEL_20;
      goto LABEL_19;
    }
    v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  if (!CFStringHasPrefix(v2, CFSTR("*.")))
  {
    v9 = v2;
    goto LABEL_16;
  }
  v13.length = CFStringGetLength(v2) - 2;
  v13.location = 2;
  v8 = CFStringCreateWithSubstring(0, v2, v13);
  if (v8)
  {
    v9 = v8;
    if (v6)
      CFRelease(v2);
    v7 = 1;
LABEL_16:
    v4 = CFStringHasSuffix(a1, v9);
    v2 = v9;
    if (!HasSuffix)
      goto LABEL_20;
LABEL_19:
    CFRelease(a1);
    goto LABEL_20;
  }
  v4 = 0;
  if (HasSuffix)
    goto LABEL_19;
LABEL_20:
  if (v7)
    CFRelease(v2);
  return v4;
}

uint64_t _SC_hostMatchesDomain(const __CFString *a1, const __CFString *a2)
{
  CFTypeID TypeID;
  CFTypeID v5;
  CFMutableStringRef StringByTrimmingDotsAndStars;
  CFMutableStringRef v7;
  CFTypeID v8;
  CFTypeID v9;
  CFIndex CountOfStringInString;
  CFIndex v11;
  uint64_t HasSuffix;
  uint64_t v13;
  CFRange v15;

  TypeID = CFStringGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) != TypeID)
    return 0;
  v5 = CFStringGetTypeID();
  if (!a2 || CFGetTypeID(a2) != v5)
    return 0;
  StringByTrimmingDotsAndStars = _SC_createStringByTrimmingDotsAndStars(a1);
  v7 = _SC_createStringByTrimmingDotsAndStars(a2);
  v8 = CFStringGetTypeID();
  if (StringByTrimmingDotsAndStars)
  {
    if (CFGetTypeID(StringByTrimmingDotsAndStars) != v8 || (v9 = CFStringGetTypeID(), !v7) || CFGetTypeID(v7) != v9)
    {
      v13 = 0;
      goto LABEL_14;
    }
    CountOfStringInString = _SC_getCountOfStringInString(StringByTrimmingDotsAndStars);
    v11 = _SC_getCountOfStringInString(v7);
    if (CountOfStringInString == v11)
    {
      HasSuffix = CFEqual(StringByTrimmingDotsAndStars, v7);
    }
    else
    {
      v13 = 0;
      if (v11 < 1 || v11 >= CountOfStringInString)
      {
LABEL_14:
        CFRelease(StringByTrimmingDotsAndStars);
        if (!v7)
          return v13;
        goto LABEL_17;
      }
      v15.location = 0;
      v15.length = 0;
      CFStringReplace(v7, v15, CFSTR("."));
      HasSuffix = CFStringHasSuffix(StringByTrimmingDotsAndStars, v7);
    }
    v13 = HasSuffix;
    goto LABEL_14;
  }
  v13 = 0;
  if (v7)
LABEL_17:
    CFRelease(v7);
  return v13;
}

CFMutableStringRef _SC_createStringByTrimmingDotsAndStars(CFStringRef theString)
{
  const __CFAllocator *v2;
  const __CFCharacterSet *v3;
  const __CFCharacterSet *v4;
  const __CFCharacterSet *v5;
  CFIndex Length;
  CFMutableStringRef MutableCopy;
  int CharacterFromSet;
  CFIndex location;
  CFRange v10;
  CFRange v12;
  CFRange result;
  uint64_t v14;
  CFRange v15;
  CFRange v16;
  CFRange v17;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!_SC_getNotDotOrStarCharacterSet_notDotOrStar)
  {
    v3 = CFCharacterSetCreateWithCharactersInString(v2, CFSTR(".*"));
    if (v3)
    {
      v4 = v3;
      _SC_getNotDotOrStarCharacterSet_notDotOrStar = (uint64_t)CFCharacterSetCreateInvertedSet(v2, v3);
      CFRelease(v4);
    }
  }
  v5 = (const __CFCharacterSet *)_SC_getNotDotOrStarCharacterSet_notDotOrStar;
  Length = CFStringGetLength(theString);
  MutableCopy = CFStringCreateMutableCopy(v2, Length, theString);
  result.location = 0;
  result.length = 0;
  v12.location = Length;
  v12.length = 0;
  v16.location = 0;
  v16.length = Length;
  if (CFStringFindCharacterFromSet(theString, v5, v16, 0, &result))
  {
    v17.location = 0;
    v17.length = Length;
    CharacterFromSet = CFStringFindCharacterFromSet(theString, v5, v17, 4uLL, &v12);
    location = v12.location;
    if (CharacterFromSet && (result.location == -1 || v12.location == -1 || result.location > v12.location))
    {
      CFRelease(MutableCopy);
      return 0;
    }
  }
  else
  {
    location = Length;
  }
  if (Length > location + 1)
  {
    v15.location = location + 1;
    v15.length = Length - (location + 1);
    CFStringReplace(MutableCopy, v15, &stru_1E25D5260);
  }
  v10.length = result.location;
  if (result.location >= 1)
  {
    v10.location = 0;
    CFStringReplace(MutableCopy, v10, &stru_1E25D5260);
  }
  return MutableCopy;
}

CFIndex _SC_getCountOfStringInString(const __CFString *a1)
{
  const __CFAllocator *v2;
  const __CFArray *Results;
  const __CFArray *v4;
  CFIndex Count;
  CFRange v7;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7.length = CFStringGetLength(a1);
  v7.location = 0;
  Results = CFStringCreateArrayWithFindResults(v2, a1, CFSTR("."), v7, 0);
  if (!Results)
    return 0;
  v4 = Results;
  Count = CFArrayGetCount(Results);
  CFRelease(v4);
  return Count;
}

uint64_t __SCNetworkConnectionCopyOnDemandInfoWithName(uint64_t a1, const __CFString *a2, int a3, CFTypeRef *a4, _DWORD *a5, CFTypeRef *a6)
{
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  void *v15;
  CFTypeID TypeID;
  const __CFString *v17;
  CFTypeID v18;
  int v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  const char *v32;
  int v33;
  int v34;
  int v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  const char *v48;
  const __CFString *v49;
  CFTypeID v50;
  NSObject *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  const char *v63;
  _BYTE v65[4];
  int valuePtr;
  void *value;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  v68 = 0;
  v11 = (const __CFDictionary *)__SCNetworkConnectionCopyOnDemandConfiguration();
  if (!v11)
    goto LABEL_60;
  v12 = v11;
  v13 = (const __CFDictionary *)__SCNetworkConnectionCopyMatchingTriggerWithName(v11, a2, 0, a3, 0, &v68, 0);
  v14 = v13;
  if (v13 && v68)
  {
    value = 0;
    valuePtr = 0;
    if (!CFDictionaryGetValueIfPresent(v13, CFSTR("Status"), (const void **)&value)
      || (v15 = value, TypeID = CFNumberGetTypeID(), !v15)
      || CFGetTypeID(v15) != TypeID
      || !CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr))
    {
      valuePtr = 0;
    }
    if (a5)
      *a5 = valuePtr;
    if (a4)
    {
      v17 = (const __CFString *)CFDictionaryGetValue(v14, CFSTR("ServiceID"));
      *a4 = v17;
      v18 = CFStringGetTypeID();
      if (v17 && CFGetTypeID(v17) == v18)
      {
        *a4 = v17;
        if (CFStringGetLength(v17) >= 1)
        {
          CFRetain(*a4);
          goto LABEL_16;
        }
      }
      else
      {
        *a4 = 0;
      }
      v36 = __log_SCNetworkConnection_log;
      if (!__log_SCNetworkConnection_log)
      {
        v36 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
        __log_SCNetworkConnection_log = (uint64_t)v36;
      }
      v37 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v36, (os_log_type_t)v37))
      {
        v38 = _os_log_pack_size();
        v46 = &v65[-((MEMORY[0x1E0C80A78](v38, v39, v40, v41, v42, v43, v44, v45) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v47 = _os_log_pack_fill();
        v48 = " (on retry)";
        if (!a3)
          v48 = "";
        *(_DWORD *)v47 = 136315138;
        *(_QWORD *)(v47 + 4) = v48;
        __SC_log_send(6, (uint64_t)v36, v37, v46);
      }
      *a4 = 0;
      v19 = 1;
      if (!a6)
      {
LABEL_17:
        if (!v19)
        {
LABEL_18:
          v20 = __log_SCNetworkConnection_log;
          if (!__log_SCNetworkConnection_log)
          {
            v20 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
            __log_SCNetworkConnection_log = (uint64_t)v20;
          }
          v21 = _SC_syslog_os_log_mapping(6);
          if (__SC_log_enabled(6, v20, (os_log_type_t)v21))
          {
            v22 = _os_log_pack_size();
            v30 = &v65[-((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0)];
            __error();
            v31 = _os_log_pack_fill();
            v32 = " (on retry)";
            v33 = valuePtr;
            if (!a3)
              v32 = "";
            *(_DWORD *)v31 = 136315394;
            *(_QWORD *)(v31 + 4) = v32;
            *(_WORD *)(v31 + 12) = 1024;
            *(_DWORD *)(v31 + 14) = v33;
            __SC_log_send(6, (uint64_t)v20, v21, v30);
            v34 = 1;
            goto LABEL_26;
          }
          v35 = 0;
          v34 = 1;
LABEL_56:
          CFRelease(v14);
          CFRelease(v12);
          if (v34)
            return 1;
          goto LABEL_59;
        }
LABEL_48:
        if (a4 && *a4)
        {
          CFRelease(*a4);
          *a4 = 0;
        }
        if (a6 && *a6)
        {
          CFRelease(*a6);
          v34 = 0;
          *a6 = 0;
        }
        else
        {
          v34 = 0;
        }
        v35 = 1001;
        goto LABEL_56;
      }
LABEL_35:
      v49 = (const __CFString *)CFDictionaryGetValue(v14, CFSTR("RemoteAddress"));
      *a6 = v49;
      v50 = CFStringGetTypeID();
      if (v49 && CFGetTypeID(v49) == v50)
      {
        *a6 = v49;
        if (CFStringGetLength(v49) >= 1)
        {
          CFRetain(*a6);
          if (!v19)
            goto LABEL_18;
          goto LABEL_48;
        }
      }
      else
      {
        *a6 = 0;
      }
      v51 = __log_SCNetworkConnection_log;
      if (!__log_SCNetworkConnection_log)
      {
        v51 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
        __log_SCNetworkConnection_log = (uint64_t)v51;
      }
      v52 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v51, (os_log_type_t)v52))
      {
        v53 = _os_log_pack_size();
        v61 = &v65[-((MEMORY[0x1E0C80A78](v53, v54, v55, v56, v57, v58, v59, v60) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v62 = _os_log_pack_fill();
        v63 = " (on retry)";
        if (!a3)
          v63 = "";
        *(_DWORD *)v62 = 136315138;
        *(_QWORD *)(v62 + 4) = v63;
        __SC_log_send(6, (uint64_t)v51, v52, v61);
      }
      *a6 = 0;
      goto LABEL_48;
    }
LABEL_16:
    v19 = 0;
    if (!a6)
      goto LABEL_17;
    goto LABEL_35;
  }
  if (v13)
  {
    v34 = 0;
LABEL_26:
    v35 = 0;
    goto LABEL_56;
  }
  CFRelease(v12);
  v35 = 0;
LABEL_59:
  LODWORD(v11) = v35;
LABEL_60:
  _SCErrorSet((int)v11);
  return 0;
}

CFTypeRef __SCNetworkConnectionCopyOnDemandConfiguration()
{
  int v0;
  uint32_t v1;
  uint32_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  _DWORD *v14;
  uint32_t v15;
  uint32_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  _DWORD *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  const char *v41;
  const __CFString *NetworkGlobalEntity;
  const void *v43;
  CFTypeID TypeID;
  CFTypeRef v45;
  uint32_t state;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t state64;
  int check;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  check = 1;
  state64 = 0;
  pthread_mutex_lock(&onDemand_notify_lock);
  v0 = onDemand_notify_token;
  if (onDemand_notify_token == -1)
  {
    v15 = notify_register_check("com.apple.system.SCNetworkConnectionOnDemand", &onDemand_notify_token);
    if (v15)
    {
      v16 = v15;
      v17 = __log_SCNetworkConnection_log;
      if (!__log_SCNetworkConnection_log)
      {
        v17 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
        __log_SCNetworkConnection_log = (uint64_t)v17;
      }
      v18 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v17, (os_log_type_t)v18))
      {
        v19 = _os_log_pack_size();
        v27 = (char *)&v56 - ((MEMORY[0x1E0C80A78](v19, v20, v21, v22, v23, v24, v25, v26) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v28 = (_DWORD *)_os_log_pack_fill();
        *v28 = 67109120;
        v28[1] = v16;
        __SC_log_send(5, (uint64_t)v17, v18, v27);
      }
      goto LABEL_14;
    }
    v0 = onDemand_notify_token;
    if (onDemand_notify_token == -1)
      goto LABEL_15;
  }
  v1 = notify_check(v0, &check);
  if (v1)
  {
    v2 = v1;
    v3 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v3 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v3;
    }
    v4 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v3, (os_log_type_t)v4))
      goto LABEL_8;
    v5 = _os_log_pack_size();
    v13 = (char *)&v56 - ((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
LABEL_7:
    v14 = (_DWORD *)_os_log_pack_fill();
    *v14 = 67109120;
    v14[1] = v2;
    __SC_log_send(5, (uint64_t)v3, v4, v13);
LABEL_8:
    notify_cancel(onDemand_notify_token);
LABEL_14:
    onDemand_notify_token = -1;
    goto LABEL_15;
  }
  if (check)
  {
    if (onDemand_notify_token != -1)
    {
      state = notify_get_state(onDemand_notify_token, &state64);
      if (state)
      {
        v2 = state;
        v3 = __log_SCNetworkConnection_log;
        if (!__log_SCNetworkConnection_log)
        {
          v3 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
          __log_SCNetworkConnection_log = (uint64_t)v3;
        }
        v4 = _SC_syslog_os_log_mapping(5);
        if (!__SC_log_enabled(5, v3, (os_log_type_t)v4))
          goto LABEL_8;
        v48 = _os_log_pack_size();
        v13 = (char *)&v56 - ((MEMORY[0x1E0C80A78](v48, v49, v50, v51, v52, v53, v54, v55) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        goto LABEL_7;
      }
    }
  }
LABEL_15:
  if (check || onDemand_force_refresh)
  {
    v29 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v29 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v29;
    }
    v30 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v29, (os_log_type_t)v30))
    {
      v31 = _os_log_pack_size();
      v39 = (char *)&v56 - ((MEMORY[0x1E0C80A78](v31, v32, v33, v34, v35, v36, v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v40 = _os_log_pack_fill();
      if (onDemand_configuration)
        v41 = "updated";
      else
        v41 = "fetched";
      *(_DWORD *)v40 = 136315138;
      *(_QWORD *)(v40 + 4) = v41;
      __SC_log_send(6, (uint64_t)v29, v30, v39);
    }
    if (onDemand_configuration)
    {
      CFRelease((CFTypeRef)onDemand_configuration);
      onDemand_configuration = 0;
    }
    if (state64 || onDemand_force_refresh)
    {
      NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(0, CFSTR("State:"), CFSTR("OnDemand"));
      onDemand_configuration = (uint64_t)SCDynamicStoreCopyValue(0, NetworkGlobalEntity);
      CFRelease(NetworkGlobalEntity);
      v43 = (const void *)onDemand_configuration;
      if (onDemand_configuration)
      {
        TypeID = CFDictionaryGetTypeID();
        if (CFGetTypeID(v43) != TypeID)
        {
          CFRelease((CFTypeRef)onDemand_configuration);
          onDemand_configuration = 0;
        }
      }
    }
    onDemand_force_refresh = 0;
  }
  if (onDemand_configuration)
    v45 = CFRetain((CFTypeRef)onDemand_configuration);
  else
    v45 = 0;
  pthread_mutex_unlock(&onDemand_notify_lock);
  return v45;
}

const void *__SCNetworkConnectionCopyMatchingTriggerWithName(const __CFDictionary *a1, const __CFString *a2, int a3, int a4, CFTypeRef *a5, _BYTE *a6, CFTypeRef *a7)
{
  _BYTE *v8;
  CFTypeRef *v9;
  const void *Value;
  CFTypeID TypeID;
  CFIndex v14;
  int v15;
  unint64_t v16;
  const void *ValueAtIndex;
  CFTypeID v18;
  const void *v19;
  CFTypeID v20;
  const void *v21;
  const void *v22;
  CFTypeID v23;
  CFIndex v24;
  const __CFDictionary *v25;
  CFTypeID v26;
  const __CFArray *v27;
  CFTypeID v28;
  CFIndex v29;
  CFIndex v30;
  CFIndex v31;
  const __CFString *Match;
  CFTypeID v33;
  const __CFString *v34;
  int v35;
  const void *v36;
  CFTypeRef *v37;
  __CFDictionary *Mutable;
  CFNumberRef v39;
  const void *v40;
  BOOL v41;
  _BOOL4 v42;
  const void *v43;
  CFTypeID v44;
  CFTypeRef *v46;
  CFTypeRef *v47;
  const void *v48;
  const void *v49;
  const __CFAllocator *allocator;
  _BYTE *v51;
  int v52;
  int v53;
  int v54;
  CFIndex v55;
  CFTypeRef cf;
  const void *v57;
  CFIndex Count;
  int valuePtr;
  uint64_t v61;

  v8 = a6;
  v9 = a5;
  v61 = *MEMORY[0x1E0C80C00];
  if (a6)
    *a6 = 0;
  if (a5)
    *a5 = 0;
  Value = CFDictionaryGetValue(a1, CFSTR("Triggers"));
  TypeID = CFArrayGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID || (Count = CFArrayGetCount((CFArrayRef)Value), Count < 1))
  {
    ValueAtIndex = 0;
    v15 = 0;
    goto LABEL_79;
  }
  v53 = a3;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v48 = (const void *)*MEMORY[0x1E0C9AE40];
  v49 = (const void *)*MEMORY[0x1E0C9AE50];
  v52 = a4;
  v57 = Value;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)Value, v14);
    v18 = CFDictionaryGetTypeID();
    if (!ValueAtIndex || CFGetTypeID(ValueAtIndex) != v18)
      goto LABEL_19;
    v19 = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, CFSTR("Action"));
    v20 = CFStringGetTypeID();
    if (v19 && CFGetTypeID(v19) == v20 && CFEqual(v19, CFSTR("Connect")))
    {
      if (__SCNetworkConnectionShouldNeverMatch((const __CFDictionary *)ValueAtIndex, a2, v53))
      {
        ValueAtIndex = (const void *)v16;
LABEL_16:
        Value = v57;
        goto LABEL_20;
      }
      v54 = v15;
      Match = 0;
      v35 = 0;
      v36 = 0;
      Value = v57;
    }
    else
    {
      Value = v57;
      if (__SCNetworkConnectionShouldIgnoreTrigger((const __CFDictionary *)ValueAtIndex))
      {
        v15 = 5002;
LABEL_19:
        ValueAtIndex = (const void *)v16;
        goto LABEL_20;
      }
      v21 = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, CFSTR("Action"));
      v22 = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, CFSTR("ActionParameters"));
      if (v21 && v22)
      {
        cf = v22;
        if (!CFEqual(v21, CFSTR("EvaluateConnection")))
          goto LABEL_19;
        v51 = v8;
        v23 = CFArrayGetTypeID();
        if (CFGetTypeID(cf) != v23 || (v55 = CFArrayGetCount((CFArrayRef)cf), v55 < 1))
        {
          ValueAtIndex = (const void *)v16;
          goto LABEL_20;
        }
        v54 = v15;
        v46 = v9;
        v47 = a7;
        v24 = 0;
        while (1)
        {
          v25 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)cf, v24);
          v26 = CFDictionaryGetTypeID();
          if (v25)
          {
            if (CFGetTypeID(v25) == v26)
            {
              v27 = (const __CFArray *)CFDictionaryGetValue(v25, CFSTR("Domains"));
              v28 = CFArrayGetTypeID();
              if (v27)
              {
                if (CFGetTypeID(v27) == v28)
                {
                  v29 = CFArrayGetCount(v27);
                  if (v29 >= 1)
                    break;
                }
              }
            }
          }
LABEL_38:
          if (++v24 == v55)
            goto LABEL_39;
        }
        v30 = v29;
        v31 = 0;
        while (1)
        {
          Match = (const __CFString *)CFArrayGetValueAtIndex(v27, v31);
          v33 = CFStringGetTypeID();
          if (Match)
          {
            if (CFGetTypeID(Match) == v33 && _SC_domainEndsWithDomain(a2, Match))
              break;
          }
          if (v30 == ++v31)
            goto LABEL_38;
        }
        v43 = CFDictionaryGetValue(v25, CFSTR("DomainAction"));
        v44 = CFStringGetTypeID();
        if (v43 && CFGetTypeID(v43) == v44 && CFEqual(v43, CFSTR("NeverConnect")))
        {
LABEL_39:
          ValueAtIndex = (const void *)v16;
          v8 = v51;
          v9 = v46;
          a7 = v47;
          a4 = v52;
          goto LABEL_16;
        }
        v36 = CFDictionaryGetValue(v25, CFSTR("RequiredURLStringProbe"));
        v35 = 1;
        v8 = v51;
        v9 = v46;
        a7 = v47;
        Value = v57;
      }
      else
      {
        v54 = v15;
        if (!a4
          && (v34 = __SCNetworkConnectionDomainGetMatch((const __CFDictionary *)ValueAtIndex, a2, 0),
              (unint64_t)v34 | v16))
        {
          Match = v34;
          v35 = 0;
          if (!v34)
          {
LABEL_45:
            ValueAtIndex = (const void *)v16;
            a4 = v52;
            v15 = v54;
            goto LABEL_20;
          }
        }
        else
        {
          v35 = 1;
          Match = __SCNetworkConnectionDomainGetMatch((const __CFDictionary *)ValueAtIndex, a2, 1);
          if (!Match)
            goto LABEL_45;
        }
        v36 = 0;
      }
      if (__SCNetworkConnectionShouldNeverMatch((const __CFDictionary *)ValueAtIndex, a2, v53))
        goto LABEL_45;
    }
    if (v9)
    {
      valuePtr = 2;
      if (*v9)
      {
        CFRelease(*v9);
        *v9 = 0;
      }
      v37 = v9;
      Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v39 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
      CFDictionarySetValue(Mutable, CFSTR("OnDemandMatchInfoVPNType"), v39);
      CFRelease(v39);
      if (Match)
        CFDictionarySetValue(Mutable, CFSTR("OnDemandMatchInfoDomain"), Match);
      if (v35)
        v40 = v49;
      else
        v40 = v48;
      CFDictionarySetValue(Mutable, CFSTR("OnDemandMatchInfoOnRetry"), v40);
      v9 = v37;
      *v37 = Mutable;
      Value = v57;
    }
    a4 = v52;
    if (a7)
    {
      if (*a7)
      {
        CFRelease(*a7);
        *a7 = 0;
      }
      if (v36)
        *a7 = CFRetain(v36);
    }
    v41 = v52 || v35 == 0;
    v42 = !v41;
    if (v8 && !v42)
      break;
    v15 = v54;
    if (!v42)
      goto LABEL_81;
LABEL_20:
    ++v14;
    v16 = (unint64_t)ValueAtIndex;
    if (v14 == Count)
      goto LABEL_81;
  }
  *v8 = 1;
  v15 = v54;
LABEL_81:
  if (ValueAtIndex)
    CFRetain(ValueAtIndex);
LABEL_79:
  _SCErrorSet(v15);
  return ValueAtIndex;
}

Boolean SCNetworkConnectionCopyUserPreferences(CFDictionaryRef selectionOptions, CFStringRef *serviceID, CFDictionaryRef *userOptions)
{
  const __CFString *Value;
  CFTypeID TypeID;
  const __CFBoolean *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  int v25;
  Boolean result;
  const __CFDictionary *Mutable;
  uint64_t v28;
  int v29;
  CFTypeRef v30[2];

  v30[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  if (__SCNetworkConnectionInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (selectionOptions)
      goto LABEL_3;
    return __SCNetworkConnectionCopyUserPreferencesInternal(selectionOptions, serviceID, userOptions);
  }
  if (!selectionOptions)
    return __SCNetworkConnectionCopyUserPreferencesInternal(selectionOptions, serviceID, userOptions);
LABEL_3:
  Value = (const __CFString *)CFDictionaryGetValue(selectionOptions, CFSTR("OnDemandHostName"));
  TypeID = CFStringGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID)
    return __SCNetworkConnectionCopyUserPreferencesInternal(selectionOptions, serviceID, userOptions);
  v30[0] = 0;
  v29 = -1;
  v8 = (const __CFBoolean *)CFDictionaryGetValue(selectionOptions, CFSTR("OnDemandRetry"));
  v9 = CFBooleanGetTypeID();
  if (v8 && (v10 = v9, v9 = CFGetTypeID(v8), v9 == v10))
  {
    v9 = CFBooleanGetValue(v8);
    v11 = v9;
  }
  else
  {
    v11 = 1;
  }
  v12 = __SCNetworkConnectionCopyOnDemandInfoWithName(v9, Value, v11, v30, &v29, 0);
  if (debug >= 2)
  {
    v13 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v13 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v13;
    }
    v14 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v13, (os_log_type_t)v14))
    {
      v15 = _os_log_pack_size();
      v28 = (uint64_t)&v28;
      v23 = (char *)&v28 - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v24 = _os_log_pack_fill();
      v25 = v29;
      *(_DWORD *)v24 = 67109376;
      *(_DWORD *)(v24 + 4) = v12;
      *(_WORD *)(v24 + 8) = 1024;
      *(_DWORD *)(v24 + 10) = v25;
      __SC_log_send(6, (uint64_t)v13, v14, v23);
    }
  }
  if (!v12)
  {
    if (!v11)
      return 0;
    return __SCNetworkConnectionCopyUserPreferencesInternal(selectionOptions, serviceID, userOptions);
  }
  result = (Boolean)v30[0];
  if (v29 == 2)
  {
    if (v30[0])
    {
      CFRelease(v30[0]);
      return 0;
    }
  }
  else
  {
    *serviceID = (CFStringRef)v30[0];
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *userOptions = Mutable;
    CFDictionarySetValue(Mutable, CFSTR("OnDemandHostName"), Value);
    return 1;
  }
  return result;
}

const void *isA_CFBoolean(const void *a1)
{
  CFTypeID TypeID;

  TypeID = CFBooleanGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) == TypeID)
    return a1;
  return 0;
}

uint64_t __SCNetworkConnectionCopyUserPreferencesInternal(const __CFDictionary *a1, CFStringRef *a2, CFDictionaryRef *a3)
{
  int v6;
  uint32_t v7;
  uint32_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint32_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  const __CFString *Value;
  const __CFString *v31;
  CFTypeID TypeID;
  const __CFString *v33;
  const __CFString *v34;
  const __CFString *v35;
  const __CFString *NetworkServiceEntity;
  CFPropertyListRef v37;
  const __CFString *v38;
  CFTypeID v39;
  const __CFString *v40;
  const __CFString *v41;
  CFArrayRef v42;
  CFTypeID v43;
  const __CFDictionary *v44;
  CFTypeID v45;
  CFIndex v46;
  const __CFString *ValueAtIndex;
  CFTypeID v48;
  const __CFArray *v49;
  CFTypeID v50;
  CFIndex v51;
  CFIndex v52;
  CFIndex i;
  const __CFDictionary *v54;
  CFTypeID v55;
  const __CFDictionary *v56;
  CFTypeID v57;
  const __CFNumber *v58;
  CFTypeID v59;
  const __CFArray *v60;
  CFTypeID v61;
  CFIndex v62;
  const __CFString *v63;
  CFTypeID v64;
  const __CFString *v65;
  const __CFArray *v66;
  const __CFDictionary *v67;
  const __CFString **v68;
  __CFDictionary *v69;
  CFMutableDictionaryRef *v70;
  const __CFString *v71;
  uint64_t v72;
  const __CFString *NetworkGlobalEntity;
  const __CFString *v74;
  CFPropertyListRef v75;
  CFTypeID v76;
  const void *v77;
  CFTypeID v78;
  CFIndex v79;
  CFIndex v80;
  CFStringRef *v81;
  CFIndex v82;
  const __CFString *v83;
  int v84;
  const __CFArray *v85;
  const __CFArray *v86;
  CFTypeID v87;
  CFIndex v88;
  CFIndex v89;
  CFIndex v90;
  const __CFDictionary *v91;
  CFTypeID v92;
  const void *v93;
  CFTypeID v94;
  CFDictionaryRef v95;
  int v96;
  NSObject *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  char *v107;
  uint64_t v108;
  const char *v109;
  NSObject *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  char *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  NSObject *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  char *v134;
  NSObject *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  const __CFString *v146;
  const __CFString *v148;
  const __CFString **v149;
  __CFDictionary *MutableCopy;
  CFMutableDictionaryRef *v151;
  const __CFString *v152;
  const __CFString **v153;
  CFIndex v154;
  CFIndex v155;
  const __CFString *v156;
  CFDictionaryRef *v157;
  int v158;
  const __CFArray *v159;
  CFIndex v160;
  const __CFString *v161;
  const __CFArray *v162;
  CFDictionaryRef v163;
  const __CFString *v164;
  const __CFString *v165;
  const __CFDictionary *v166;
  CFIndex Count;
  int valuePtr;
  int check;
  uint64_t v170;

  v170 = *MEMORY[0x1E0C80C00];
  check = 1;
  v6 = notify_userprefs_token;
  if (notify_userprefs_token != -1)
    goto LABEL_2;
  v20 = notify_register_check("com.apple.networkConnect", &notify_userprefs_token);
  if (v20)
  {
    v8 = v20;
    v9 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v9 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v9;
    }
    v10 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v9, (os_log_type_t)v10))
      goto LABEL_13;
    v21 = _os_log_pack_size();
    v19 = (char *)&v152 - ((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    goto LABEL_12;
  }
  notify_check(notify_userprefs_token, &check);
  check = 1;
  v6 = notify_userprefs_token;
  if (notify_userprefs_token != -1)
  {
LABEL_2:
    v7 = notify_check(v6, &check);
    if (!v7)
      goto LABEL_14;
    v8 = v7;
    v9 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v9 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v9;
    }
    v10 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v9, (os_log_type_t)v10))
    {
LABEL_13:
      notify_cancel(notify_userprefs_token);
      notify_userprefs_token = -1;
LABEL_14:
      if (!check)
        goto LABEL_16;
      goto LABEL_15;
    }
    v11 = _os_log_pack_size();
    v19 = (char *)&v152 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
LABEL_12:
    v29 = (_DWORD *)_os_log_pack_fill();
    *v29 = 67109120;
    v29[1] = v8;
    __SC_log_send(5, (uint64_t)v9, v10, v19);
    goto LABEL_13;
  }
LABEL_15:
  CFPreferencesAppSynchronize(CFSTR("com.apple.networkConnect"));
LABEL_16:
  *a2 = 0;
  *a3 = 0;
  if (a1)
  {
    Value = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("OnDemandHostName"));
    if (Value)
    {
      v31 = Value;
      TypeID = CFStringGetTypeID();
    }
    else
    {
      v31 = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("OnDemandHostName"));
      TypeID = CFStringGetTypeID();
      if (!v31)
        goto LABEL_67;
    }
    if (CFGetTypeID(v31) == TypeID)
    {
      v38 = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("OnDemandPriority"));
      v39 = CFStringGetTypeID();
      if (!v38 || CFGetTypeID(v38) != v39)
        v38 = CFSTR("Default");
      v164 = v38;
      v40 = (const __CFString *)*MEMORY[0x1E0C9B260];
      v41 = (const __CFString *)*MEMORY[0x1E0C9B250];
      v42 = CFPreferencesCopyKeyList(CFSTR("com.apple.networkConnect"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
      v43 = CFArrayGetTypeID();
      if (v42)
      {
        if (CFGetTypeID(v42) != v43
          || (v44 = CFPreferencesCopyMultiple(v42, CFSTR("com.apple.networkConnect"), v40, v41),
              v45 = CFDictionaryGetTypeID(),
              !v44))
        {
          v72 = 0;
          v95 = v42;
          goto LABEL_100;
        }
        v163 = v44;
        if (CFGetTypeID(v44) == v45)
        {
          Count = CFArrayGetCount(v42);
          if (Count >= 1)
          {
            v152 = CFSTR("OnDemandPriority");
            v153 = a2;
            v157 = a3;
            v158 = 0;
            v154 = 0;
            v155 = 0;
            v46 = 0;
            v165 = CFSTR("PPP");
            v161 = CFSTR("OnDemandEnabled");
            v162 = v42;
            v156 = CFSTR("OnDemandDomains");
            v166 = a1;
            do
            {
              valuePtr = 0;
              ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v42, v46);
              v48 = CFStringGetTypeID();
              if (ValueAtIndex)
              {
                if (CFGetTypeID(ValueAtIndex) == v48)
                {
                  v49 = (const __CFArray *)CFDictionaryGetValue(v163, ValueAtIndex);
                  v50 = CFArrayGetTypeID();
                  if (v49)
                  {
                    if (CFGetTypeID(v49) == v50)
                    {
                      v51 = CFArrayGetCount(v49);
                      if (v51 >= 1)
                      {
                        v52 = v51;
                        for (i = 0; i != v52; ++i)
                        {
                          v54 = (const __CFDictionary *)CFArrayGetValueAtIndex(v49, i);
                          v55 = CFDictionaryGetTypeID();
                          if (v54)
                          {
                            if (CFGetTypeID(v54) == v55)
                            {
                              v56 = (const __CFDictionary *)CFDictionaryGetValue(v54, v165);
                              v57 = CFDictionaryGetTypeID();
                              if (v56)
                              {
                                if (CFGetTypeID(v56) == v57)
                                {
                                  v58 = (const __CFNumber *)CFDictionaryGetValue(v56, v161);
                                  v59 = CFNumberGetTypeID();
                                  if (v58 && CFGetTypeID(v58) == v59)
                                  {
                                    CFNumberGetValue(v58, kCFNumberIntType, &valuePtr);
                                    v42 = v162;
                                    if (valuePtr)
                                    {
                                      v60 = (const __CFArray *)CFDictionaryGetValue(v56, v156);
                                      v61 = CFArrayGetTypeID();
                                      if (v60)
                                      {
                                        if (CFGetTypeID(v60) == v61)
                                        {
                                          v160 = CFArrayGetCount(v60);
                                          if (v160 >= 1)
                                          {
                                            v62 = 0;
                                            v159 = v60;
                                            do
                                            {
                                              v63 = (const __CFString *)CFArrayGetValueAtIndex(v60, v62);
                                              v64 = CFStringGetTypeID();
                                              if (v63 && CFGetTypeID(v63) == v64)
                                              {
                                                v42 = v162;
                                                if (!v158)
                                                {
                                                  if (CFStringCompare(v63, &stru_1E25D5260, 0)
                                                    && CFStringCompare(v63, CFSTR("."), 0))
                                                  {
                                                    v158 = 0;
                                                  }
                                                  else
                                                  {
                                                    v158 = 1;
                                                    v154 = v46;
                                                    v155 = i;
                                                  }
                                                }
                                                if (_SC_domainEndsWithDomain(v31, v63))
                                                {
                                                  v149 = v153;
                                                  *v153 = ValueAtIndex;
                                                  CFRetain(ValueAtIndex);
                                                  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v54);
                                                  v151 = v157;
                                                  *v157 = MutableCopy;
                                                  CFDictionarySetValue(MutableCopy, CFSTR("OnDemandHostName"), v31);
                                                  CFDictionarySetValue(*v151, v152, v164);
                                                  addPasswordFromKeychain(*v149, v151);
                                                  v72 = 1;
                                                  a1 = v166;
LABEL_99:
                                                  CFRelease(v42);
                                                  v95 = v163;
LABEL_100:
                                                  CFRelease(v95);
LABEL_101:
                                                  if (debug >= 2)
                                                  {
                                                    v97 = __log_SCNetworkConnection_log;
                                                    if (!__log_SCNetworkConnection_log)
                                                    {
                                                      v97 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
                                                      __log_SCNetworkConnection_log = (uint64_t)v97;
                                                    }
                                                    v98 = _SC_syslog_os_log_mapping(6);
                                                    if (__SC_log_enabled(6, v97, (os_log_type_t)v98))
                                                    {
                                                      v99 = _os_log_pack_size();
                                                      v107 = (char *)&v152
                                                           - ((MEMORY[0x1E0C80A78](v99, v100, v101, v102, v103, v104, v105, v106)+ 15) & 0xFFFFFFFFFFFFFFF0);
                                                      __error();
                                                      v108 = _os_log_pack_fill();
                                                      v109 = "succeeded";
                                                      if (!(_DWORD)v72)
                                                        v109 = "failed";
                                                      *(_DWORD *)v108 = 136315138;
                                                      *(_QWORD *)(v108 + 4) = v109;
                                                      __SC_log_send(6, (uint64_t)v97, v98, v107);
                                                    }
                                                    v110 = __log_SCNetworkConnection_log;
                                                    if (!__log_SCNetworkConnection_log)
                                                    {
                                                      v110 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
                                                      __log_SCNetworkConnection_log = (uint64_t)v110;
                                                    }
                                                    v111 = _SC_syslog_os_log_mapping(6);
                                                    if (__SC_log_enabled(6, v110, (os_log_type_t)v111))
                                                    {
                                                      v112 = _os_log_pack_size();
                                                      v120 = (char *)&v152
                                                           - ((MEMORY[0x1E0C80A78](v112, v113, v114, v115, v116, v117, v118, v119)+ 15) & 0xFFFFFFFFFFFFFFF0);
                                                      __error();
                                                      v121 = _os_log_pack_fill();
                                                      *(_DWORD *)v121 = 138412290;
                                                      *(_QWORD *)(v121 + 4) = a1;
                                                      v122 = (uint64_t)v110;
                                                      v123 = v111;
                                                      goto LABEL_129;
                                                    }
                                                  }
                                                  return v72;
                                                }
                                              }
                                              else
                                              {
                                                v42 = v162;
                                              }
                                              ++v62;
                                              v60 = v159;
                                            }
                                            while (v160 != v62);
                                          }
                                        }
                                      }
                                    }
                                  }
                                  else
                                  {
                                    v42 = v162;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              ++v46;
              a1 = v166;
            }
            while (v46 != Count);
            if (v158)
            {
              v65 = (const __CFString *)CFArrayGetValueAtIndex(v42, v154);
              v66 = (const __CFArray *)CFDictionaryGetValue(v163, v65);
              v67 = (const __CFDictionary *)CFArrayGetValueAtIndex(v66, v155);
              v68 = v153;
              *v153 = v65;
              CFRetain(v65);
              v69 = CFDictionaryCreateMutableCopy(0, 0, v67);
              v70 = v157;
              *v157 = v69;
              CFDictionarySetValue(v69, CFSTR("OnDemandHostName"), v31);
              CFDictionarySetValue(*v70, v152, v164);
              v71 = *v68;
              v42 = v162;
              addPasswordFromKeychain(v71, v70);
              v72 = 1;
              goto LABEL_99;
            }
          }
        }
        v72 = 0;
        goto LABEL_99;
      }
    }
LABEL_67:
    v72 = 0;
    goto LABEL_101;
  }
  v33 = (const __CFString *)*MEMORY[0x1E0C9B260];
  v34 = (const __CFString *)CFPreferencesCopyValue(CFSTR("ServiceID"), CFSTR("com.apple.internetconnect"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  if (v34)
  {
    v35 = v34;
    if (SCNetworkConnectionPrivateIsPPPService(v34, CFSTR("PPPSerial"), CFSTR("PPPoE")))
    {
      NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("Setup:"), v35, CFSTR("Interface"));
      v37 = SCDynamicStoreCopyValue(0, NetworkServiceEntity);
      CFRelease(NetworkServiceEntity);
      if (v37)
      {
        CFRelease(v37);
        *a2 = (CFStringRef)CFRetain(v35);
        CFRelease(v35);
        goto LABEL_84;
      }
    }
    CFRelease(v35);
  }
  *a2 = 0;
  NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(0, CFSTR("Setup:"), CFSTR("IPv4"));
  if (!NetworkGlobalEntity)
  {
    v96 = 1;
    fwrite("Error, Setup Key == NULL!\n", 0x1AuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    v72 = 0;
    goto LABEL_122;
  }
  v74 = NetworkGlobalEntity;
  v75 = SCDynamicStoreCopyValue(0, NetworkGlobalEntity);
  v76 = CFDictionaryGetTypeID();
  if (!v75 || CFGetTypeID(v75) != v76)
  {
    fwrite("no global IPv4 entity\n", 0x16uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    v84 = 0;
    goto LABEL_82;
  }
  v77 = CFDictionaryGetValue((CFDictionaryRef)v75, CFSTR("ServiceOrder"));
  v78 = CFArrayGetTypeID();
  if (!v77 || CFGetTypeID(v77) != v78)
  {
    fwrite("service order not specified\n", 0x1CuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    goto LABEL_119;
  }
  v79 = CFArrayGetCount((CFArrayRef)v77);
  if (v79 < 1)
  {
LABEL_119:
    CFRelease(v74);
    v84 = 0;
    goto LABEL_120;
  }
  v80 = v79;
  v81 = a2;
  v157 = a3;
  v82 = 0;
  while (1)
  {
    v83 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v77, v82);
    if (SCNetworkConnectionPrivateIsPPPService(v83, CFSTR("PPPSerial"), CFSTR("PPPoE")))
      break;
    if (v80 == ++v82)
    {
      v84 = 0;
      a3 = v157;
      a2 = v81;
      goto LABEL_82;
    }
  }
  v148 = (const __CFString *)CFRetain(v83);
  a2 = v81;
  *v81 = v148;
  v84 = 1;
  a3 = v157;
LABEL_82:
  CFRelease(v74);
  if (!v75)
  {
    if (v84)
      goto LABEL_84;
LABEL_121:
    v72 = 0;
    v96 = 1;
    goto LABEL_122;
  }
LABEL_120:
  CFRelease(v75);
  if (!v84)
    goto LABEL_121;
LABEL_84:
  if (*a2)
  {
    v85 = (const __CFArray *)CFPreferencesCopyValue(*a2, CFSTR("com.apple.networkConnect"), v33, (CFStringRef)*MEMORY[0x1E0C9B250]);
    if (v85)
    {
      v86 = v85;
      v87 = CFArrayGetTypeID();
      if (CFGetTypeID(v86) == v87)
      {
        v88 = CFArrayGetCount(v86);
        if (v88 >= 1)
        {
          v89 = v88;
          v90 = 0;
          while (1)
          {
            v91 = (const __CFDictionary *)CFArrayGetValueAtIndex(v86, v90);
            v92 = CFDictionaryGetTypeID();
            if (v91)
            {
              if (CFGetTypeID(v91) == v92)
              {
                v93 = CFDictionaryGetValue(v91, CFSTR("ConnectByDefault"));
                v94 = CFBooleanGetTypeID();
                if (v93)
                {
                  if (CFGetTypeID(v93) == v94 && CFBooleanGetValue((CFBooleanRef)v93))
                    break;
                }
              }
            }
            if (v89 == ++v90)
              goto LABEL_95;
          }
          *a3 = CFDictionaryCreateCopy(0, v91);
        }
LABEL_95:
        addPasswordFromKeychain(*a2, a3);
      }
      else
      {
        v124 = __log_SCNetworkConnection_log;
        if (!__log_SCNetworkConnection_log)
        {
          v124 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
          __log_SCNetworkConnection_log = (uint64_t)v124;
        }
        v125 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v124, (os_log_type_t)v125))
        {
          v126 = _os_log_pack_size();
          v134 = (char *)&v152
               - ((MEMORY[0x1E0C80A78](v126, v127, v128, v129, v130, v131, v132, v133) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(6, (uint64_t)v124, v125, v134);
        }
      }
      CFRelease(v86);
    }
  }
  v96 = 0;
  v72 = 1;
LABEL_122:
  if (debug >= 2)
  {
    v135 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v135 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v135;
    }
    v136 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v135, (os_log_type_t)v136))
    {
      v137 = _os_log_pack_size();
      v120 = (char *)&v152
           - ((MEMORY[0x1E0C80A78](v137, v138, v139, v140, v141, v142, v143, v144) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v145 = _os_log_pack_fill();
      v146 = CFSTR("succeeded");
      if (v96)
        v146 = CFSTR("failed");
      *(_DWORD *)v145 = 138412290;
      *(_QWORD *)(v145 + 4) = v146;
      v122 = (uint64_t)v135;
      v123 = v136;
LABEL_129:
      __SC_log_send(6, v122, v123, v120);
    }
  }
  return v72;
}

uint64_t SCNetworkConnectionOnDemandShouldRetryOnFailure(CFDictionaryRef *cf)
{
  uint64_t v2;
  CFDictionaryRef v3;
  CFTypeID TypeID;
  const __CFDictionary *Value;
  CFTypeID v6;
  const __CFBoolean *v7;
  CFTypeID v8;
  int v10;

  if (__SCNetworkConnectionInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_14:
      v10 = 1002;
      goto LABEL_15;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (!cf)
      goto LABEL_14;
  }
  v2 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_14;
  if (!cf[10])
  {
    v10 = 5001;
LABEL_15:
    _SCErrorSet(v10);
    return 0;
  }
  v3 = cf[40];
  TypeID = CFDictionaryGetTypeID();
  if (v3)
  {
    if (CFGetTypeID(v3) == TypeID)
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(cf[40], CFSTR("OnDemandMatchInfo"));
      v6 = CFDictionaryGetTypeID();
      if (Value)
      {
        if (CFGetTypeID(Value) == v6)
        {
          v7 = (const __CFBoolean *)CFDictionaryGetValue(Value, CFSTR("OnDemandMatchInfoOnRetry"));
          v8 = CFBooleanGetTypeID();
          if (v7)
          {
            if (CFGetTypeID(v7) == v8)
              return CFBooleanGetValue(v7);
          }
        }
      }
    }
  }
  return 0;
}

uint64_t SCNetworkConnectionCanTunnelAddress(_QWORD *cf, uint64_t a2, _BYTE *a3)
{
  uint64_t v4;
  int v6;
  uint64_t v8;
  const __SCNetworkService *v9;
  CFStringRef ServiceID;
  CFTypeID TypeID;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  const void *v16;
  CFTypeID v17;
  const void *Value;
  CFTypeID v19;
  const void *v20;
  CFTypeID v21;
  int v22;
  const __CFDictionary *v23;
  const __CFDictionary *v24;
  const void *v25;
  const void *v26;
  const __CFDictionary *v27;
  const void *v28;
  const void *v29;

  v4 = a2;
  if (a3)
    *a3 = 0;
  if (a2)
  {
    v6 = *(unsigned __int8 *)(a2 + 1);
    if (v6 != 30 && v6 != 2)
      return 0;
    if (__SCNetworkConnectionInitialize_initialized == -1)
    {
      if (!cf)
        goto LABEL_42;
    }
    else
    {
      dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
      if (!cf)
        goto LABEL_42;
    }
    v8 = __kSCNetworkConnectionTypeID;
    if (CFGetTypeID(cf) == v8)
    {
      v9 = (const __SCNetworkService *)cf[10];
      if (v9)
      {
        ServiceID = SCNetworkServiceGetServiceID(v9);
        TypeID = CFStringGetTypeID();
        if (ServiceID)
        {
          if (CFGetTypeID(ServiceID) == TypeID)
          {
            v12 = (const __CFDictionary *)__SCNetworkConnectionCopyOnDemandConfiguration();
            if (v12)
            {
              v13 = v12;
              v14 = __SCNetworkConnectionCopyTriggerWithService(v12, ServiceID);
              if (v14)
              {
                v15 = v14;
                v16 = (const void *)cf[41];
                v17 = CFStringGetTypeID();
                if (v16
                  && CFGetTypeID(v16) == v17
                  && ((Value = CFDictionaryGetValue(v15, CFSTR("ProbeResults")), v19 = CFDictionaryGetTypeID(), !Value)
                   || CFGetTypeID(Value) != v19
                   || (v20 = CFDictionaryGetValue((CFDictionaryRef)Value, v16), v21 = CFBooleanGetTypeID(), v20)
                   && CFGetTypeID(v20) == v21
                   && !CFBooleanGetValue((CFBooleanRef)v20))
                  || __SCNetworkConnectionAddressMatchesRedirectedDNS(v15, v4))
                {
                  v4 = 1;
                  if (a3)
                    *a3 = 1;
                  goto LABEL_39;
                }
                v23 = (const __CFDictionary *)CFDictionaryGetValue(v15, CFSTR("TunneledNetworks"));
                if (isA_CFDictionary(v23))
                {
                  if (v6 == 2)
                  {
                    v24 = (const __CFDictionary *)CFDictionaryGetValue(v23, CFSTR("IPv4"));
                    if (isA_CFDictionary(v24))
                    {
                      v25 = CFDictionaryGetValue(v24, CFSTR("IncludedRoutes"));
                      if (__SCNetworkConnectionIPv4AddressMatchesRoutes(v4, v25))
                      {
                        v26 = CFDictionaryGetValue(v24, CFSTR("ExcludedRoutes"));
                        if (!__SCNetworkConnectionIPv4AddressMatchesRoutes(v4, v26))
                        {
LABEL_40:
                          v4 = 1;
                          goto LABEL_39;
                        }
                      }
                    }
                  }
                  else
                  {
                    v27 = (const __CFDictionary *)CFDictionaryGetValue(v23, CFSTR("IPv6"));
                    if (isA_CFDictionary(v27))
                    {
                      v28 = CFDictionaryGetValue(v27, CFSTR("IncludedRoutes"));
                      if (__SCNetworkConnectionIPv6AddressMatchesRoutes(v4, v28))
                      {
                        v29 = CFDictionaryGetValue(v27, CFSTR("ExcludedRoutes"));
                        if (!__SCNetworkConnectionIPv6AddressMatchesRoutes(v4, v29))
                          goto LABEL_40;
                      }
                    }
                  }
                }
                v4 = 0;
LABEL_39:
                CFRelease(v13);
                CFRelease(v15);
                return v4;
              }
              CFRelease(v13);
            }
          }
        }
        return 0;
      }
      v22 = 5001;
LABEL_43:
      _SCErrorSet(v22);
      return 0;
    }
LABEL_42:
    v22 = 1002;
    goto LABEL_43;
  }
  return v4;
}

const __CFDictionary *__SCNetworkConnectionCopyTriggerWithService(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const __CFDictionary *ValueAtIndex;
  CFTypeID v9;
  const void *v10;
  CFTypeID v11;

  Value = CFDictionaryGetValue(a1, CFSTR("Triggers"));
  TypeID = CFArrayGetTypeID();
  if (!Value)
    return 0;
  if (CFGetTypeID(Value) != TypeID)
    return 0;
  Count = CFArrayGetCount((CFArrayRef)Value);
  if (Count < 1)
    return 0;
  v6 = Count;
  v7 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)Value, v7);
    v9 = CFDictionaryGetTypeID();
    if (ValueAtIndex)
    {
      if (CFGetTypeID(ValueAtIndex) == v9)
      {
        v10 = CFDictionaryGetValue(ValueAtIndex, CFSTR("ServiceID"));
        v11 = CFStringGetTypeID();
        if (v10)
        {
          if (CFGetTypeID(v10) == v11 && CFEqual(v10, a2))
            break;
        }
      }
    }
    if (v6 == ++v7)
      return 0;
  }
  CFRetain(ValueAtIndex);
  return ValueAtIndex;
}

uint64_t __SCNetworkConnectionAddressMatchesRedirectedDNS(const __CFDictionary *a1, uint64_t a2)
{
  const void *Value;
  CFTypeID TypeID;
  const void *v6;
  CFTypeID v7;
  int v8;
  const void *v9;
  const void *v11;

  Value = CFDictionaryGetValue(a1, CFSTR("DNSRedirectDetected"));
  TypeID = CFBooleanGetTypeID();
  if (!Value)
    return 0;
  if (CFGetTypeID(Value) != TypeID)
    return 0;
  if (!CFBooleanGetValue((CFBooleanRef)Value))
    return 0;
  v6 = CFDictionaryGetValue(a1, CFSTR("DNSRedirectedAddresses"));
  v7 = CFDictionaryGetTypeID();
  if (!v6 || CFGetTypeID(v6) != v7)
    return 0;
  v8 = *(unsigned __int8 *)(a2 + 1);
  if (v8 != 30)
  {
    if (v8 == 2)
    {
      v9 = CFDictionaryGetValue((CFDictionaryRef)v6, CFSTR("IPv4"));
      return __SCNetworkConnectionIPv4AddressMatchesRoutes(a2, v9);
    }
    return 0;
  }
  v11 = CFDictionaryGetValue((CFDictionaryRef)v6, CFSTR("IPv6"));
  return __SCNetworkConnectionIPv6AddressMatchesRoutes(a2, v11);
}

uint64_t __SCNetworkConnectionIPv4AddressMatchesRoutes(uint64_t a1, const void *a2)
{
  CFTypeID TypeID;
  const void *Value;
  int *v6;
  CFTypeID v7;
  CFTypeID v8;
  CFIndex Length;
  const UInt8 *BytePtr;
  unint64_t v11;
  uint64_t result;
  unint64_t v13;
  int v14;
  int v15;

  TypeID = CFDictionaryGetTypeID();
  if (!a2)
    return 0;
  if (CFGetTypeID(a2) != TypeID)
    return 0;
  Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Addresses"));
  v6 = (int *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Masks"));
  v7 = CFDataGetTypeID();
  if (!Value || CFGetTypeID(Value) != v7)
    return 0;
  if (v6)
  {
    v8 = CFDataGetTypeID();
    if (CFGetTypeID(v6) != v8)
      return 0;
    Length = CFDataGetLength((CFDataRef)Value);
    if (Length != CFDataGetLength((CFDataRef)v6))
      return 0;
    BytePtr = CFDataGetBytePtr((CFDataRef)Value);
    v6 = (int *)CFDataGetBytePtr((CFDataRef)v6);
  }
  else
  {
    BytePtr = CFDataGetBytePtr((CFDataRef)Value);
  }
  v11 = CFDataGetLength((CFDataRef)Value);
  if (v11 < 4)
    return 0;
  v13 = v11 >> 2;
  while (1)
  {
    v14 = *(_DWORD *)BytePtr;
    if (!v6)
      break;
    v15 = *v6++;
    if (((*(_DWORD *)(a1 + 4) ^ v14) & v15) == 0)
      return 1;
LABEL_18:
    result = 0;
    BytePtr += 4;
    if (!--v13)
      return result;
  }
  if (*(_DWORD *)(a1 + 4) != v14)
  {
    v6 = 0;
    goto LABEL_18;
  }
  return 1;
}

uint64_t __SCNetworkConnectionIPv6AddressMatchesRoutes(uint64_t a1, const void *a2)
{
  CFTypeID TypeID;
  const void *Value;
  const void *v6;
  CFTypeID v7;
  CFTypeID v8;
  CFIndex Length;
  const UInt8 *BytePtr;
  const UInt8 *v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  __int128 *v15;
  unint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t i;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  TypeID = CFDictionaryGetTypeID();
  if (!a2)
    return 0;
  if (CFGetTypeID(a2) != TypeID)
    return 0;
  Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Addresses"));
  v6 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Masks"));
  v7 = CFDataGetTypeID();
  if (!Value || CFGetTypeID(Value) != v7)
    return 0;
  if (v6)
  {
    v8 = CFDataGetTypeID();
    if (CFGetTypeID(v6) != v8)
      return 0;
    Length = CFDataGetLength((CFDataRef)Value);
    if (Length != CFDataGetLength((CFDataRef)v6))
      return 0;
    BytePtr = CFDataGetBytePtr((CFDataRef)Value);
    v11 = CFDataGetBytePtr((CFDataRef)v6);
  }
  else
  {
    BytePtr = CFDataGetBytePtr((CFDataRef)Value);
    v11 = 0;
  }
  v12 = CFDataGetLength((CFDataRef)Value);
  if (v12 >= 0x10)
  {
    v14 = 0;
    v15 = (__int128 *)(a1 + 8);
    v16 = v12 >> 4;
    while (1)
    {
      if (v6)
      {
        v17 = 0;
        v18 = *v15;
        v22 = *(_OWORD *)BytePtr;
        v23 = v18;
        do
        {
          *((_BYTE *)&v22 + v17) &= v11[v17];
          ++v17;
        }
        while (v17 != 16);
        for (i = 0; i != 16; ++i)
          *((_BYTE *)&v23 + i) &= v11[i];
        if ((_QWORD)v22 == (_QWORD)v23 && *((_QWORD *)&v22 + 1) == *((_QWORD *)&v23 + 1))
          return 1;
        v11 += 16;
      }
      else if (*(_QWORD *)BytePtr == *(_QWORD *)v15 && *((_QWORD *)BytePtr + 1) == *(_QWORD *)(a1 + 16))
      {
        return 1;
      }
      result = 0;
      BytePtr += 16;
      if (++v14 == v16)
        return result;
    }
  }
  return 0;
}

BOOL SCNetworkConnectionSelectServiceWithOptions(char *cf, const void *a2)
{
  uint64_t v4;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  __CFDictionary *v7;
  _BOOL8 v8;
  CFTypeID TypeID;
  const void *v11;
  const void *v12;
  const __CFString *v13;
  __CFString *v14;
  CFTypeID v15;
  BOOL v16;
  int v17;
  int v18;
  const __CFString *v19;
  __int128 v20;
  CFStringRef v21;
  CFTypeID v22;
  const __CFDictionary *v23;
  const void *v24;
  CFTypeID v25;
  const __CFBoolean *v26;
  char v27;
  const __CFDictionary *v28;
  const void *v29;
  CFTypeID v30;
  CFTypeID v31;
  CFTypeID v32;
  __CFDictionary *Mutable;
  CFNumberRef v34;
  _QWORD *v35;
  const void *v36;
  int v37;
  const void *v38;
  const __CFAllocator *v39;
  __CFDictionary *MutableCopy;
  CFTypeRef v41;
  CFTypeRef v42;
  CFTypeRef cfa;
  CFTypeRef v44;
  int valuePtr;
  CFTypeRef v46;
  void *value[2];
  __int128 v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v46 = 0;
  valuePtr = -1;
  cfa = 0;
  v44 = 0;
  v42 = 0;
  if (__SCNetworkConnectionInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkConnectionInitialize_initialized, &__block_literal_global_8);
    if (cf)
      goto LABEL_3;
LABEL_5:
    _SCErrorSet(1002);
    v5 = 0;
    v6 = 0;
LABEL_6:
    v7 = 0;
    v8 = 0;
    goto LABEL_7;
  }
  if (!cf)
    goto LABEL_5;
LABEL_3:
  v4 = __kSCNetworkConnectionTypeID;
  if (CFGetTypeID(cf) != v4 || *((_QWORD *)cf + 10))
    goto LABEL_5;
  TypeID = CFDictionaryGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
  {
    v13 = 0;
    v14 = 0;
    v16 = 0;
LABEL_28:
    v17 = 1;
    goto LABEL_29;
  }
  v11 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("NoUserPrefs"));
  v12 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("OnDemandRetry"));
  v13 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("OnDemandAccountIdentifier"));
  v14 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("OnDemandHostName"));
  v15 = CFBooleanGetTypeID();
  v16 = v11 && CFGetTypeID(v11) == v15 && CFBooleanGetValue((CFBooleanRef)v11) != 0;
  v31 = CFBooleanGetTypeID();
  if (!v12 || CFGetTypeID(v12) != v31)
    goto LABEL_28;
  v17 = CFBooleanGetValue((CFBooleanRef)v12);
LABEL_29:
  v5 = (const __CFDictionary *)__SCNetworkConnectionCopyOnDemandConfiguration();
  v18 = *((_DWORD *)cf + 42);
  v19 = (const __CFString *)*((_QWORD *)cf + 24);
  v20 = *(_OWORD *)(cf + 140);
  *(_OWORD *)value = *(_OWORD *)(cf + 124);
  v48 = v20;
  v21 = VPNAppLayerCopyMatchingService(value, v18, (const unsigned __int8 *)cf + 172, v19, v14, v13);
  cfa = v21;
  v22 = CFDictionaryGetTypeID();
  if (v21)
  {
    if (v5 && CFGetTypeID(v5) == v22)
    {
      v23 = __SCNetworkConnectionCopyTriggerWithService(v5, v21);
      v6 = v23;
      if (v23)
      {
        value[0] = 0;
        if (!CFDictionaryGetValueIfPresent(v23, CFSTR("Status"), (const void **)value)
          || (v24 = value[0], v25 = CFNumberGetTypeID(), !v24)
          || CFGetTypeID(v24) != v25
          || !CFNumberGetValue((CFNumberRef)value[0], kCFNumberSInt32Type, &valuePtr))
        {
          valuePtr = -1;
        }
        if (__SCNetworkConnectionShouldIgnoreTrigger(v6) && valuePtr != 1 && valuePtr != 2)
        {
          CFRelease(v21);
          cfa = 0;
          if (v46)
          {
            CFRelease(v46);
            v46 = 0;
          }
          CFRelease(v6);
          v22 = CFDictionaryGetTypeID();
          goto LABEL_53;
        }
      }
    }
    else
    {
      v6 = 0;
    }
    v8 = 1;
    if (!v17)
    {
      if (v46)
      {
        if (valuePtr != 1 && valuePtr != 2)
        {
          v26 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v46, CFSTR("OnDemandMatchInfoOnRetry"));
          if (v26)
            v8 = CFBooleanGetValue(v26) == 0;
        }
      }
    }
    *((_DWORD *)cf + 76) = 3;
    goto LABEL_80;
  }
  if (!v5)
  {
    v27 = 1;
    goto LABEL_64;
  }
LABEL_53:
  v27 = 0;
  if (CFGetTypeID(v5) == v22 && v14)
  {
    LOBYTE(value[0]) = 0;
    v28 = (const __CFDictionary *)__SCNetworkConnectionCopyMatchingTriggerWithName(v5, v14, *((_DWORD *)cf + 42), v17, &v46, value, &v44);
    v6 = v28;
    if (v28)
    {
      v29 = CFDictionaryGetValue(v28, CFSTR("ServiceID"));
      cfa = v29;
      v30 = CFStringGetTypeID();
      if (v29 && CFGetTypeID(v29) == v30)
      {
        CFRetain(v29);
        *((_DWORD *)cf + 76) = 2;
      }
      else
      {
        cfa = 0;
      }
      v8 = LOBYTE(value[0]) != 0;
      goto LABEL_80;
    }
    if (!v17)
    {
LABEL_75:
      v8 = 1;
      goto LABEL_80;
    }
    if (v46)
    {
      CFRelease(v46);
      v46 = 0;
    }
    v27 = 0;
    if (v16)
    {
LABEL_74:
      v6 = 0;
      goto LABEL_75;
    }
    goto LABEL_65;
  }
LABEL_64:
  if (v16)
    goto LABEL_74;
LABEL_65:
  if (!__SCNetworkConnectionCopyUserPreferencesInternal((const __CFDictionary *)a2, (CFStringRef *)&cfa, (CFDictionaryRef *)&v42))goto LABEL_74;
  v32 = CFDictionaryGetTypeID();
  if ((v27 & 1) != 0)
  {
    v6 = 0;
  }
  else
  {
    v6 = 0;
    if (CFGetTypeID(v5) == v32 && v5)
      v6 = __SCNetworkConnectionCopyTriggerWithService(v5, cfa);
  }
  v8 = 1;
  *((_DWORD *)cf + 76) = 1;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v34 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, cf + 304);
  CFDictionarySetValue(Mutable, CFSTR("OnDemandMatchInfoVPNType"), v34);
  CFRelease(v34);
  v46 = Mutable;
LABEL_80:
  if (cfa)
  {
    v35 = _SCNetworkServiceCopyActive(0, (const __CFString *)cfa);
    *((_QWORD *)cf + 10) = v35;
    if (!v35)
    {
      _SCErrorSet(0);
      goto LABEL_6;
    }
    if (v6)
    {
      v36 = (const void *)*((_QWORD *)cf + 39);
      if (v36)
        CFRelease(v36);
      *((_QWORD *)cf + 39) = v6;
      CFRetain(v6);
      v37 = valuePtr;
      if (valuePtr == -1)
      {
        value[0] = 0;
        if (CFDictionaryGetValueIfPresent(v6, CFSTR("Status"), (const void **)value)
          && isA_CFNumber(value[0])
          && CFNumberGetValue((CFNumberRef)value[0], kCFNumberSInt32Type, &valuePtr))
        {
          v37 = valuePtr;
        }
        else
        {
          v37 = -1;
          valuePtr = -1;
        }
      }
      if (v37 == 2)
        goto LABEL_101;
      if (*((_DWORD *)cf + 76) == 3)
      {
        v38 = CFDictionaryGetValue(v6, CFSTR("OnDemandMatchAppEnabled"));
        if (!isA_CFBoolean(v38) || !CFBooleanGetValue((CFBooleanRef)v38))
          goto LABEL_101;
      }
    }
    else if (*((_DWORD *)cf + 76) != 1)
    {
      goto LABEL_101;
    }
    cf[308] = 1;
LABEL_101:
    v39 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v42)
      MutableCopy = CFDictionaryCreateMutableCopy(v39, 0, (CFDictionaryRef)v42);
    else
      MutableCopy = CFDictionaryCreateMutable(v39, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v7 = MutableCopy;
    if (v14)
      CFDictionarySetValue(MutableCopy, CFSTR("OnDemandHostName"), v14);
    if (cf[308] && v46)
      CFDictionarySetValue(v7, CFSTR("OnDemandMatchInfo"), v46);
    *((_QWORD *)cf + 40) = v7;
    CFRetain(v7);
    v41 = v44;
    if (v44)
    {
      *((_QWORD *)cf + 41) = v44;
      CFRetain(v41);
    }
LABEL_7:
    if (cfa)
      CFRelease(cfa);
    if (v5)
      goto LABEL_10;
    goto LABEL_11;
  }
  _SCErrorSet(0);
  v8 = 0;
  v7 = 0;
  if (v5)
LABEL_10:
    CFRelease(v5);
LABEL_11:
  if (v6)
    CFRelease(v6);
  if (v42)
    CFRelease(v42);
  if (v7)
    CFRelease(v7);
  if (v46)
    CFRelease(v46);
  if (v44)
    CFRelease(v44);
  return v8;
}

BOOL __SCNetworkConnectionShouldIgnoreTrigger(const __CFDictionary *a1)
{
  const void *Value;
  CFTypeID TypeID;

  Value = CFDictionaryGetValue(a1, CFSTR("Action"));
  TypeID = CFStringGetTypeID();
  return Value
      && CFGetTypeID(Value) == TypeID
      && (CFEqual(Value, CFSTR("Ignore")) || CFEqual(Value, CFSTR("Disconnect")));
}

const char *__SCNetworkConnectionGetControllerPortName()
{
  const char *result;

  result = (const char *)scnc_server_name;
  if (!scnc_server_name)
  {
    getpid();
    if (sandbox_check())
      result = "com.apple.SystemConfiguration.PPPController";
    else
      result = "com.apple.SystemConfiguration.PPPController-priv";
    scnc_server_name = (uint64_t)result;
  }
  return result;
}

void childForkHandler_0()
{
  scnc_server = 0;
  scnc_server_name = 0;
}

uint64_t __SCNetworkConnectionDeallocate(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  mach_port_name_t v14;
  ipc_space_t *v15;
  mach_port_name_t v16;
  const void *v17;
  __CFRunLoopSource *v18;
  const void *v19;
  __CFMachPort *v20;
  mach_port_name_t Port;
  mach_port_name_t v22;
  void (*v23)(_QWORD);
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  uint64_t result;
  _QWORD v30[2];

  v30[1] = *MEMORY[0x1E0C80C00];
  v2 = __log_SCNetworkConnection_log;
  if (!__log_SCNetworkConnection_log)
  {
    v2 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
    __log_SCNetworkConnection_log = (uint64_t)v2;
  }
  v3 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v2, (os_log_type_t)v3))
  {
    v4 = _os_log_pack_size();
    v12 = (char *)v30 - ((MEMORY[0x1E0C80A78](v4, v5, v6, v7, v8, v9, v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v13 = _os_log_pack_fill();
    *(_DWORD *)v13 = 136315138;
    *(_QWORD *)(v13 + 4) = a1 + 88;
    __SC_log_send(7, (uint64_t)v2, v3, v12);
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  v14 = *(_DWORD *)(a1 + 120);
  v15 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  if (v14)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v14);
  v16 = *(_DWORD *)(a1 + 156);
  if (v16)
    mach_port_deallocate(*v15, v16);
  v17 = *(const void **)(a1 + 192);
  if (v17)
    CFRelease(v17);
  v18 = *(__CFRunLoopSource **)(a1 + 224);
  if (v18)
  {
    CFRunLoopSourceInvalidate(v18);
    CFRelease(*(CFTypeRef *)(a1 + 224));
  }
  v19 = *(const void **)(a1 + 280);
  if (v19)
    CFRelease(v19);
  v20 = *(__CFMachPort **)(a1 + 208);
  if (v20)
  {
    Port = CFMachPortGetPort(v20);
    CFMachPortInvalidate(*(CFMachPortRef *)(a1 + 208));
    CFRelease(*(CFTypeRef *)(a1 + 208));
    mach_port_mod_refs(*v15, Port, 1u, -1);
  }
  v22 = *(_DWORD *)(a1 + 200);
  if (v22)
    mach_port_deallocate(*v15, v22);
  v23 = *(void (**)(_QWORD))(a1 + 264);
  if (v23)
    v23(*(_QWORD *)(a1 + 248));
  v24 = *(const void **)(a1 + 80);
  if (v24)
    CFRelease(v24);
  v25 = *(const void **)(a1 + 312);
  if (v25)
    CFRelease(v25);
  v26 = *(const void **)(a1 + 320);
  if (v26)
    CFRelease(v26);
  v27 = *(const void **)(a1 + 328);
  if (v27)
    CFRelease(v27);
  v28 = *(const void **)(a1 + 336);
  if (v28)
    CFRelease(v28);
  result = *(_QWORD *)(a1 + 344);
  if (result)
  {
    ne_session_set_event_handler();
    return ne_session_release();
  }
  return result;
}

__CFString *__SCNetworkConnectionCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  const char *v4;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCNetworkConnection, %p [%p]> {"), a1, v2);
  CFStringAppendFormat(Mutable, 0, CFSTR("service = %p"), *(_QWORD *)(a1 + 80));
  if (*(_DWORD *)(a1 + 200))
    CFStringAppendFormat(Mutable, 0, CFSTR(", server port = 0x%x"), *(unsigned int *)(a1 + 200));
  if (*(_QWORD *)(a1 + 344))
    v4 = "yes";
  else
    v4 = "no";
  CFStringAppendFormat(Mutable, 0, CFSTR("using NetworkExtension = %s"), v4);
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  return Mutable;
}

CFStringRef pppMPCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<SCNetworkConnection MP %p> {service = %@, callout = %p}"), a1, *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 232), *MEMORY[0x1E0C80C00]);
}

void __SCNetworkConnectionMachCallBack(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 20) == 70)
  {
    v5 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v5 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v5;
    }
    v6 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v5, (os_log_type_t)v6))
    {
      v7 = _os_log_pack_size();
      v15 = (char *)v16 - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v5, v6, v15);
    }
    __SCNetworkConnectionReconnectNotifications(a4);
  }
  __SCNetworkConnectionCallBack(a4);
}

uint64_t __SCNetworkConnectionServerPort(kern_return_t *a1)
{
  mach_port_t v2;
  const char *ControllerPortName;
  kern_return_t v4;
  uint64_t result;
  mach_port_t sp;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  sp = 0;
  v2 = *MEMORY[0x1E0C81720];
  ControllerPortName = __SCNetworkConnectionGetControllerPortName();
  v4 = bootstrap_look_up(v2, ControllerPortName, &sp);
  *a1 = v4;
  if (!v4)
    return sp;
  result = 0;
  scnc_server_name = 0;
  return result;
}

void __SCNetworkConnectionReconnectNotifications(uint64_t a1)
{
  pthread_mutex_t *v2;
  const __CFArray *v3;
  __CFRunLoopSource *v4;
  NSObject *v5;
  NSObject *v6;
  int v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  __CFRunLoop *ValueAtIndex;
  const __CFString *v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  int v37;
  const char *v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  _QWORD v50[2];

  v50[1] = *MEMORY[0x1E0C80C00];
  v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v3 = *(const __CFArray **)(a1 + 280);
  if (v3)
    *(_QWORD *)(a1 + 280) = 0;
  v4 = *(__CFRunLoopSource **)(a1 + 224);
  if (v4)
  {
    CFRunLoopSourceInvalidate(v4);
    CFRelease(*(CFTypeRef *)(a1 + 224));
    *(_QWORD *)(a1 + 224) = 0;
  }
  v5 = *(NSObject **)(a1 + 296);
  if (v5)
  {
    dispatch_source_cancel(v5);
    *(_QWORD *)(a1 + 296) = 0;
  }
  v6 = *(NSObject **)(a1 + 288);
  if (v6)
  {
    *(_QWORD *)(a1 + 288) = 0;
    dispatch_retain(v6);
    *(_BYTE *)(a1 + 217) = 0;
    pthread_mutex_unlock(v2);
    if (!v3)
    {
      if (SCNetworkConnectionSetDispatchQueue((SCNetworkConnectionRef)a1, v6))
      {
        v7 = 1;
      }
      else
      {
        if (SCError() != 1102)
        {
          v39 = __log_SCNetworkConnection_log;
          if (!__log_SCNetworkConnection_log)
          {
            v39 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
            __log_SCNetworkConnection_log = (uint64_t)v39;
          }
          v40 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v39, (os_log_type_t)v40))
          {
            v41 = _os_log_pack_size();
            v49 = (char *)v50
                - ((MEMORY[0x1E0C80A78](v41, v42, v43, v44, v45, v46, v47, v48) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            *(_WORD *)_os_log_pack_fill() = 0;
            __SC_log_send(5, (uint64_t)v39, v40, v49);
          }
        }
        v7 = 0;
      }
      goto LABEL_25;
    }
LABEL_12:
    Count = CFArrayGetCount(v3);
    if (Count < 1)
    {
      v7 = 1;
    }
    else
    {
      v9 = Count;
      v10 = 0;
      while (1)
      {
        ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v3, v10 + 1);
        v12 = (const __CFString *)CFArrayGetValueAtIndex(v3, v10 + 2);
        v13 = SCNetworkConnectionScheduleWithRunLoop((SCNetworkConnectionRef)a1, ValueAtIndex, v12);
        if (!v13)
          break;
        v7 = v13;
        v10 += 3;
        if (v10 >= v9)
          goto LABEL_24;
      }
      if (SCError() != 1102)
      {
        v14 = __log_SCNetworkConnection_log;
        if (!__log_SCNetworkConnection_log)
        {
          v14 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
          __log_SCNetworkConnection_log = (uint64_t)v14;
        }
        v15 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v14, (os_log_type_t)v15))
        {
          v16 = _os_log_pack_size();
          v24 = (char *)v50
              - ((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(5, (uint64_t)v14, v15, v24);
        }
      }
      v7 = 0;
    }
LABEL_24:
    CFRelease(v3);
    if (!v6)
    {
LABEL_26:
      if (v7)
        return;
      goto LABEL_27;
    }
LABEL_25:
    dispatch_release(v6);
    goto LABEL_26;
  }
  *(_BYTE *)(a1 + 217) = 0;
  pthread_mutex_unlock(v2);
  if (v3)
    goto LABEL_12;
LABEL_27:
  v25 = __log_SCNetworkConnection_log;
  if (!__log_SCNetworkConnection_log)
  {
    v25 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
    __log_SCNetworkConnection_log = (uint64_t)v25;
  }
  v26 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v25, (os_log_type_t)v26))
  {
    v27 = _os_log_pack_size();
    v35 = (char *)v50 - ((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v36 = _os_log_pack_fill();
    v37 = SCError();
    v38 = "failed";
    if (v37 == 1102)
      v38 = "shutdown";
    *(_DWORD *)v36 = 136315138;
    *(_QWORD *)(v36 + 4) = v38;
    __SC_log_send(5, (uint64_t)v25, v26, v35);
  }
}

void __SCNetworkConnectionCallBack(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t (*v3)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v4)(_QWORD);
  uint64_t v5;
  uint64_t (*v6)(uint64_t);
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t Status;
  __CFRunLoop *Current;
  __CFRunLoop *v21;
  CFRunLoopMode v22;
  NSObject *v23;
  SCNetworkConnectionStatus v24;
  _QWORD block[10];
  _QWORD v26[8];
  SCNetworkConnectionStatus v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (*(_BYTE *)(a1 + 217))
  {
    v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 232);
    if (v3)
    {
      v5 = *(_QWORD *)(a1 + 248);
      v4 = *(uint64_t (**)(_QWORD))(a1 + 256);
      if (v4 && v5)
      {
        v5 = v4(*(_QWORD *)(a1 + 248));
        v6 = *(uint64_t (**)(uint64_t))(a1 + 264);
      }
      else
      {
        v6 = 0;
      }
      if (*(_QWORD *)(a1 + 344))
      {
LABEL_13:
        pthread_mutex_unlock(v2);
        Status = SCNetworkConnectionGetStatus((SCNetworkConnectionRef)a1);
        __SCNetworkConnectionNotify(a1, v3, Status, v6, v5);
        CFRelease((CFTypeRef)a1);
        return;
      }
      CFRetain((CFTypeRef)a1);
      if (*(_QWORD *)(a1 + 280))
      {
        Current = CFRunLoopGetCurrent();
        if (!Current)
          __SCNetworkConnectionCallBack_cold_2();
        v21 = Current;
        if (Current != CFRunLoopGetMain())
          goto LABEL_13;
        CFRetain(v21);
        v22 = CFRunLoopCopyCurrentMode(v21);
        pthread_mutex_unlock(v2);
        if (__SCNetworkConnectionQueue_once != -1)
          dispatch_once(&__SCNetworkConnectionQueue_once, &__block_literal_global_91_0);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ____SCNetworkConnectionCallBack_block_invoke;
        block[3] = &__block_descriptor_tmp_102;
        block[4] = a1;
        block[5] = v21;
        block[6] = v22;
        block[7] = v3;
        block[8] = v6;
        block[9] = v5;
        dispatch_async((dispatch_queue_t)__SCNetworkConnectionQueue_q, block);
      }
      else
      {
        v23 = *(NSObject **)(a1 + 288);
        if (!v23)
          __SCNetworkConnectionCallBack_cold_1();
        pthread_mutex_unlock(v2);
        v24 = SCNetworkConnectionGetStatus((SCNetworkConnectionRef)a1);
        CFRetain((CFTypeRef)a1);
        v26[0] = MEMORY[0x1E0C809B0];
        v26[1] = 0x40000000;
        v26[2] = ____SCNetworkConnectionCallBackPerformDispatch_block_invoke;
        v26[3] = &__block_descriptor_tmp_105;
        v26[4] = a1;
        v26[5] = v3;
        v27 = v24;
        v26[6] = v6;
        v26[7] = v5;
        dispatch_async(v23, v26);
        CFRelease((CFTypeRef)a1);
      }
    }
    else
    {
      pthread_mutex_unlock(v2);
    }
  }
  else
  {
    v7 = __log_SCNetworkConnection_log;
    if (!__log_SCNetworkConnection_log)
    {
      v7 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
      __log_SCNetworkConnection_log = (uint64_t)v7;
    }
    v8 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v7, (os_log_type_t)v8))
    {
      v9 = _os_log_pack_size();
      v17 = (char *)block - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v18 = _os_log_pack_fill();
      *(_DWORD *)v18 = 136315138;
      *(_QWORD *)(v18 + 4) = a1 + 88;
      __SC_log_send(6, (uint64_t)v7, v8, v17);
    }
    pthread_mutex_unlock(v2);
  }
}

uint64_t __SCNetworkConnectionNotify(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, uint64_t), uint64_t a3, uint64_t (*a4)(uint64_t), uint64_t a5)
{
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t result;
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  v10 = __log_SCNetworkConnection_log;
  if (!__log_SCNetworkConnection_log)
  {
    v10 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
    __log_SCNetworkConnection_log = (uint64_t)v10;
  }
  v11 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v10, (os_log_type_t)v11))
  {
    v12 = _os_log_pack_size();
    v20 = (char *)v23 - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v21 = _os_log_pack_fill();
    *(_DWORD *)v21 = 136315394;
    *(_QWORD *)(v21 + 4) = a1 + 88;
    *(_WORD *)(v21 + 12) = 1024;
    *(_DWORD *)(v21 + 14) = a3;
    __SC_log_send(7, (uint64_t)v10, v11, v20);
  }
  result = a2(a1, a3, a5);
  if (a4)
  {
    if (a5)
      return a4(a5);
  }
  return result;
}

uint64_t __SCNetworkConnectionShouldNeverMatch(const __CFDictionary *a1, const __CFString *a2, int a3)
{
  const __CFArray *Value;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const __CFString *ValueAtIndex;
  CFTypeID v12;
  const __CFArray *v13;
  CFTypeID v14;
  CFIndex v15;
  CFIndex v16;
  CFIndex v17;
  const void *v18;
  CFTypeID v19;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  Value = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("OnDemandMatchDomainsNever"));
  TypeID = CFArrayGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) == TypeID)
    {
      Count = CFArrayGetCount(Value);
      if (Count >= 1)
      {
        v9 = Count;
        v10 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(Value, v10);
          v12 = CFStringGetTypeID();
          if (ValueAtIndex)
          {
            if (CFGetTypeID(ValueAtIndex) == v12 && _SC_domainEndsWithDomain(a2, ValueAtIndex))
              break;
          }
          if (v9 == ++v10)
            goto LABEL_9;
        }
        v21 = __log_SCNetworkConnection_log;
        if (!__log_SCNetworkConnection_log)
        {
          v21 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConnection");
          __log_SCNetworkConnection_log = (uint64_t)v21;
        }
        v22 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v21, (os_log_type_t)v22))
        {
          v23 = _os_log_pack_size();
          v31 = (char *)&v32
              - ((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(6, (uint64_t)v21, v22, v31);
          return 1;
        }
        return 1;
      }
    }
  }
LABEL_9:
  if (a3)
  {
    v13 = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("PluginPIDs"));
    v14 = CFArrayGetTypeID();
    if (v13)
    {
      if (CFGetTypeID(v13) == v14)
      {
        v15 = CFArrayGetCount(v13);
        if (v15 >= 1)
        {
          v16 = v15;
          v17 = 0;
          while (1)
          {
            HIDWORD(v32) = 0;
            v18 = CFArrayGetValueAtIndex(v13, v17);
            v19 = CFNumberGetTypeID();
            if (v18)
            {
              if (CFGetTypeID(v18) == v19
                && CFNumberGetValue((CFNumberRef)v18, kCFNumberIntType, (char *)&v32 + 4)
                && HIDWORD(v32) == a3)
              {
                break;
              }
            }
            if (v16 == ++v17)
              return 0;
          }
          return 1;
        }
      }
    }
  }
  return 0;
}

const __CFString *__SCNetworkConnectionDomainGetMatch(const __CFDictionary *a1, const __CFString *a2, int a3)
{
  const __CFString *v4;
  const void *Value;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  const __CFString *ValueAtIndex;
  CFTypeID v11;

  if (a3)
    v4 = CFSTR("OnDemandMatchDomainsOnRetry");
  else
    v4 = CFSTR("OnDemandMatchDomainsAlways");
  Value = CFDictionaryGetValue(a1, v4);
  TypeID = CFArrayGetTypeID();
  if (!Value)
    return 0;
  if (CFGetTypeID(Value) != TypeID)
    return 0;
  Count = CFArrayGetCount((CFArrayRef)Value);
  if (Count < 1)
    return 0;
  v8 = Count;
  v9 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)Value, v9);
    v11 = CFStringGetTypeID();
    if (ValueAtIndex)
    {
      if (CFGetTypeID(ValueAtIndex) == v11 && _SC_domainEndsWithDomain(a2, ValueAtIndex))
        break;
    }
    if (v8 == ++v9)
      return 0;
  }
  return ValueAtIndex;
}

void addPasswordFromKeychain(const __CFString *a1, CFDictionaryRef *a2)
{
  const __CFString *Value;
  CFTypeID TypeID;
  __CFString *MutableCopy;

  if (*a2)
  {
    Value = (const __CFString *)CFDictionaryGetValue(*a2, CFSTR("UniqueIdentifier"));
    TypeID = CFStringGetTypeID();
    if (Value)
    {
      if (CFGetTypeID(Value) == TypeID)
      {
        if (SCNetworkConnectionPrivateIsPPPService(a1, CFSTR("L2TP"), 0))
        {
          MutableCopy = CFStringCreateMutableCopy(0, 0, Value);
          CFStringAppend(MutableCopy, CFSTR(".SS"));
          CFRelease(MutableCopy);
        }
      }
    }
  }
}

const __CFString *SCNetworkConnectionPrivateIsPPPService(CFStringRef serviceID, const void *a2, const void *a3)
{
  const __CFString *result;
  const __CFString *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  CFTypeID TypeID;
  const void *Value;
  CFTypeID v11;
  int v12;
  const void *v13;
  CFTypeID v14;
  int v15;
  BOOL v16;

  result = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("Setup:"), serviceID, CFSTR("Interface"));
  if (!result)
    return result;
  v6 = result;
  v7 = (const __CFDictionary *)SCDynamicStoreCopyValue(0, result);
  if (v7)
  {
    v8 = v7;
    TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(v8) == TypeID)
    {
      Value = CFDictionaryGetValue(v8, CFSTR("Type"));
      v11 = CFStringGetTypeID();
      if (Value)
      {
        if (CFGetTypeID(Value) == v11)
          LODWORD(Value) = CFEqual(Value, CFSTR("PPP"));
        else
          LODWORD(Value) = 0;
      }
      v13 = CFDictionaryGetValue(v8, CFSTR("SubType"));
      v14 = CFStringGetTypeID();
      if (v13 && CFGetTypeID(v13) == v14)
      {
        v15 = CFEqual(v13, a2);
        v12 = v15;
        if (a3 && !v15)
          v12 = CFEqual(v13, a3);
        goto LABEL_16;
      }
    }
    else
    {
      LODWORD(Value) = 0;
    }
    v12 = 0;
LABEL_16:
    CFRelease(v8);
    goto LABEL_17;
  }
  LODWORD(Value) = 0;
  v12 = 0;
LABEL_17:
  CFRelease(v6);
  if ((_DWORD)Value)
    v16 = v12 == 0;
  else
    v16 = 1;
  return (const __CFString *)!v16;
}

uint64_t SCUserPreferencesGetTypeID()
{
  if (__SCUserPreferencesInitialize_initialized != -1)
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
  return __kSCUserPreferencesTypeID;
}

uint64_t SCUserPreferencesGetUniqueID(_QWORD *cf)
{
  uint64_t v2;

  if (__SCUserPreferencesInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (!cf)
      goto LABEL_6;
  }
  v2 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[3];
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

uint64_t SCUserPreferencesIsForced(CFStringRef *cf)
{
  uint64_t v2;

  if (__SCUserPreferencesInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (!cf)
      goto LABEL_6;
  }
  v2 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) == v2)
    return CFPreferencesAppValueIsForced(cf[2], CFSTR("com.apple.networkConnect"));
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

uint64_t SCUserPreferencesRemove(CFTypeRef cf)
{
  uint64_t v2;

  if (__SCUserPreferencesInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (!cf)
      goto LABEL_6;
  }
  v2 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) == v2)
    return processPreferences(*((const __CFString **)cf + 2), (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))removeCallout, *((_QWORD *)cf + 3), 0, 0);
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

uint64_t processPreferences(const __CFString *a1, uint64_t (*a2)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5)
{
  const __CFArray *v9;
  const __CFArray *v10;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v13;
  CFIndex v14;
  int v15;
  const void *ValueAtIndex;
  const void *v17;
  CFTypeID v18;
  void *v19;
  void *v20;
  const void *v21;
  __CFArray *v22;
  uint64_t v23;
  const __CFString *v24;
  const __CFString *v25;
  __CFArray *v28[2];

  v28[1] = *(__CFArray **)MEMORY[0x1E0C80C00];
  v28[0] = 0;
  CFPreferencesAppSynchronize(CFSTR("com.apple.networkConnect"));
  v9 = (const __CFArray *)CFPreferencesCopyAppValue(a1, CFSTR("com.apple.networkConnect"));
  if (v9)
  {
    v10 = v9;
    TypeID = CFArrayGetTypeID();
    if (CFGetTypeID(v10) == TypeID)
    {
      Count = CFArrayGetCount(v10);
      if (Count >= 1)
      {
        v13 = Count;
        v14 = 0;
        v15 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v10, v14);
          if (!ValueAtIndex)
            processPreferences_cold_1();
          v17 = ValueAtIndex;
          v18 = CFDictionaryGetTypeID();
          if (CFGetTypeID(v17) != v18)
            break;
          v19 = (void *)a2(a1, v17, a3, a4, a5);
          if (v19)
            goto LABEL_10;
          v15 = 1;
LABEL_13:
          if (v13 == ++v14)
            goto LABEL_16;
        }
        v19 = (void *)CFRetain(v17);
LABEL_10:
        if (!CFEqual(v17, v19))
          v15 = 1;
        addKey(v28, v19);
        CFRelease(v19);
        goto LABEL_13;
      }
    }
    v15 = 0;
LABEL_16:
    CFRelease(v10);
  }
  else
  {
    v15 = 0;
  }
  v20 = (void *)a2(a1, 0, a3, a4, a5);
  if (v20)
  {
    v21 = v20;
    addKey(v28, v20);
    CFRelease(v21);
    v22 = v28[0];
  }
  else
  {
    v22 = v28[0];
    if (!v15)
    {
      v23 = 1;
      if (!v28[0])
        return v23;
      goto LABEL_25;
    }
  }
  if (CFPreferencesAppValueIsForced(a1, CFSTR("com.apple.networkConnect")))
  {
    v23 = 0;
    if (!v22)
      return v23;
    goto LABEL_25;
  }
  logCFPreferencesChange(a1, v22);
  v24 = (const __CFString *)*MEMORY[0x1E0C9B260];
  v25 = (const __CFString *)*MEMORY[0x1E0C9B250];
  CFPreferencesSetValue(a1, v22, CFSTR("com.apple.networkConnect"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
  v23 = CFPreferencesSynchronize(CFSTR("com.apple.networkConnect"), v24, v25);
  notify_post("com.apple.networkConnect");
  if (v22)
LABEL_25:
    CFRelease(v22);
  return v23;
}

CFTypeRef removeCallout(int a1, CFDictionaryRef theDict, const void *a3)
{
  const void *Value;
  CFTypeID TypeID;

  if (!theDict)
    return 0;
  Value = CFDictionaryGetValue(theDict, CFSTR("UniqueIdentifier"));
  TypeID = CFStringGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && CFEqual(Value, a3))
    return 0;
  else
    return CFRetain(theDict);
}

uint64_t SCUserPreferencesSetCurrent(CFTypeRef cf)
{
  uint64_t v2;

  if (__SCUserPreferencesInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (!cf)
      goto LABEL_6;
  }
  v2 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) == v2)
    return processPreferences(*((const __CFString **)cf + 2), (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))setCurrentCallout, *((_QWORD *)cf + 3), 0, 0);
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

__CFDictionary *setCurrentCallout(int a1, CFDictionaryRef theDict, const void *a3)
{
  __CFDictionary *MutableCopy;
  const void *Value;
  CFTypeID TypeID;

  if (!theDict)
    return 0;
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  CFDictionaryRemoveValue(MutableCopy, CFSTR("ConnectByDefault"));
  Value = CFDictionaryGetValue(theDict, CFSTR("UniqueIdentifier"));
  TypeID = CFStringGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && CFEqual(Value, a3))
    CFDictionarySetValue(MutableCopy, CFSTR("ConnectByDefault"), (const void *)*MEMORY[0x1E0C9AE50]);
  return MutableCopy;
}

CFTypeRef SCUserPreferencesCopyName(CFTypeRef cf)
{
  uint64_t v2;
  int v3;
  CFTypeRef result;
  CFTypeRef cfa[2];

  cfa[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cfa[0] = 0;
  if (__SCUserPreferencesInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_8:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (!cf)
      goto LABEL_8;
  }
  v2 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_8;
  v3 = processPreferences(*((const __CFString **)cf + 2), (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))copyNameCallout, *((_QWORD *)cf + 3), 0, (uint64_t)cfa);
  result = cfa[0];
  if (!v3 && cfa[0])
  {
    CFRelease(cfa[0]);
    return 0;
  }
  return result;
}

CFTypeRef copyNameCallout(int a1, CFDictionaryRef theDict, const void *a3, uint64_t a4, CFTypeRef *a5)
{
  const void *Value;
  CFTypeID TypeID;
  const void *v10;
  CFTypeRef v11;
  CFTypeID v12;
  const __CFDictionary *v14;
  CFTypeID v15;

  if (!theDict)
    return 0;
  Value = CFDictionaryGetValue(theDict, CFSTR("UniqueIdentifier"));
  TypeID = CFStringGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && CFEqual(Value, a3))
  {
    if (*a5)
    {
      CFRelease(*a5);
      *a5 = 0;
    }
    v10 = CFDictionaryGetValue(theDict, CFSTR("UserDefinedName"));
    *a5 = v10;
    if (v10)
    {
      v11 = v10;
      v12 = CFStringGetTypeID();
    }
    else
    {
      v14 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("PPP"));
      v15 = CFDictionaryGetTypeID();
      if (v14 && CFGetTypeID(v14) == v15)
      {
        v11 = CFDictionaryGetValue(v14, CFSTR("UserDefinedName"));
        *a5 = v11;
      }
      else
      {
        v11 = *a5;
      }
      v12 = CFStringGetTypeID();
      if (!v11)
        goto LABEL_17;
    }
    if (CFGetTypeID(v11) == v12)
    {
      *a5 = v11;
      CFRetain(v11);
      return CFRetain(theDict);
    }
LABEL_17:
    *a5 = 0;
  }
  return CFRetain(theDict);
}

uint64_t SCUserPreferencesSetName(CFTypeRef cf, const void *a2)
{
  uint64_t v4;
  CFTypeID TypeID;

  if (__SCUserPreferencesInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_8;
  }
  else
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (!cf)
      goto LABEL_8;
  }
  v4 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) == v4)
  {
    if (!a2)
      return processPreferences(*((const __CFString **)cf + 2), (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))setNameCallout, *((_QWORD *)cf + 3), (uint64_t)a2, 0);
    TypeID = CFStringGetTypeID();
    if (CFGetTypeID(a2) == TypeID)
      return processPreferences(*((const __CFString **)cf + 2), (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))setNameCallout, *((_QWORD *)cf + 3), (uint64_t)a2, 0);
  }
LABEL_8:
  _SCErrorSet(1002);
  return 0;
}

__CFDictionary *setNameCallout(int a1, CFDictionaryRef theDict, const void *a3, const void *a4)
{
  __CFDictionary *MutableCopy;
  const void *Value;
  CFTypeID TypeID;
  const __CFDictionary *v11;
  CFTypeID v12;
  __CFDictionary *v13;
  __CFDictionary *v14;

  if (!theDict)
    return 0;
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  Value = CFDictionaryGetValue(theDict, CFSTR("UniqueIdentifier"));
  TypeID = CFStringGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && CFEqual(Value, a3))
  {
    if (a4)
      CFDictionarySetValue(MutableCopy, CFSTR("UserDefinedName"), a4);
    else
      CFDictionaryRemoveValue(MutableCopy, CFSTR("UserDefinedName"));
    v11 = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, CFSTR("PPP"));
    v12 = CFDictionaryGetTypeID();
    if (v11)
    {
      if (CFGetTypeID(v11) == v12)
      {
        v13 = CFDictionaryCreateMutableCopy(0, 0, v11);
        v14 = v13;
        if (a4)
          CFDictionarySetValue(v13, CFSTR("UserDefinedName"), a4);
        else
          CFDictionaryRemoveValue(v13, CFSTR("UserDefinedName"));
        CFDictionarySetValue(MutableCopy, CFSTR("PPP"), v14);
        CFRelease(v14);
      }
    }
  }
  return MutableCopy;
}

CFTypeRef SCUserPreferencesCopyInterfaceConfiguration(const void *a1, const void *a2)
{
  CFTypeID TypeID;
  __CFString *DefaultConfigurationType;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (a2)
  {
    if (CFGetTypeID(a2) == TypeID)
    {
      DefaultConfigurationType = __SCNetworkInterfaceGetDefaultConfigurationType((uint64_t)a2);
      if (DefaultConfigurationType)
        return SCUserPreferencesCopyInterfaceTypeConfiguration(a1, (uint64_t)DefaultConfigurationType);
    }
  }
  _SCErrorSet(1002);
  return 0;
}

CFTypeRef SCUserPreferencesCopyInterfaceTypeConfiguration(CFTypeRef cf, uint64_t a2)
{
  uint64_t v4;
  int v5;
  CFTypeRef result;
  CFTypeRef cfa[2];

  cfa[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cfa[0] = 0;
  if (__SCUserPreferencesInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_8:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (!cf)
      goto LABEL_8;
  }
  v4 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) != v4)
    goto LABEL_8;
  v5 = processPreferences(*((const __CFString **)cf + 2), (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))copyInterfaceConfigurationCallout, *((_QWORD *)cf + 3), a2, (uint64_t)cfa);
  result = cfa[0];
  if (!v5 && cfa[0])
  {
    CFRelease(cfa[0]);
    return 0;
  }
  return result;
}

CFTypeRef copyInterfaceConfigurationCallout(int a1, CFDictionaryRef theDict, const void *a3, const void *a4, CFTypeRef *a5)
{
  const void *Value;
  CFTypeID TypeID;
  const void *v11;
  CFTypeID v12;

  if (!theDict)
    return 0;
  Value = CFDictionaryGetValue(theDict, CFSTR("UniqueIdentifier"));
  TypeID = CFStringGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && CFEqual(Value, a3))
  {
    if (*a5)
    {
      CFRelease(*a5);
      *a5 = 0;
    }
    v11 = CFDictionaryGetValue(theDict, a4);
    *a5 = v11;
    v12 = CFDictionaryGetTypeID();
    if (v11 && CFGetTypeID(v11) == v12)
    {
      *a5 = v11;
      CFRetain(v11);
    }
    else
    {
      *a5 = 0;
    }
  }
  return CFRetain(theDict);
}

uint64_t SCUserPreferencesSetInterfaceConfiguration(const void *a1, const void *a2, uint64_t a3)
{
  CFTypeID TypeID;
  __CFString *DefaultConfigurationType;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (a2)
  {
    if (CFGetTypeID(a2) == TypeID)
    {
      DefaultConfigurationType = __SCNetworkInterfaceGetDefaultConfigurationType((uint64_t)a2);
      if (DefaultConfigurationType)
        return SCUserPreferencesSetInterfaceTypeConfiguration(a1, (uint64_t)DefaultConfigurationType, a3);
    }
  }
  _SCErrorSet(1002);
  return 0;
}

uint64_t SCUserPreferencesSetInterfaceTypeConfiguration(CFTypeRef cf, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  if (__SCUserPreferencesInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (!cf)
      goto LABEL_6;
  }
  v6 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) == v6)
    return processPreferences(*((const __CFString **)cf + 2), (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))setInterfaceConfigurationCallout, *((_QWORD *)cf + 3), a2, a3);
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

__CFDictionary *setInterfaceConfigurationCallout(int a1, CFDictionaryRef theDict, const void *a3, const void *a4, const void *a5)
{
  __CFDictionary *MutableCopy;
  const void *Value;
  CFTypeID TypeID;
  const void *v12;
  const void *v14;
  const void *v15;
  __CFDictionary *v16;

  if (!theDict)
    return 0;
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  Value = CFDictionaryGetValue(theDict, CFSTR("UniqueIdentifier"));
  TypeID = CFStringGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && CFEqual(Value, a3))
  {
    if (a5)
    {
      CFDictionarySetValue(MutableCopy, a4, a5);
      if (CFEqual(a4, CFSTR("PPP")))
      {
        v12 = CFDictionaryGetValue((CFDictionaryRef)a5, CFSTR("UserDefinedName"));
        if (v12)
        {
          CFDictionarySetValue(MutableCopy, CFSTR("UserDefinedName"), v12);
        }
        else
        {
          v14 = CFDictionaryGetValue(MutableCopy, CFSTR("UserDefinedName"));
          if (v14)
          {
            v15 = v14;
            v16 = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)a5);
            CFDictionarySetValue(v16, CFSTR("UserDefinedName"), v15);
            CFDictionarySetValue(MutableCopy, a4, v16);
            CFRelease(v16);
          }
        }
      }
    }
    else
    {
      CFDictionaryRemoveValue(MutableCopy, a4);
    }
  }
  return MutableCopy;
}

CFTypeRef SCUserPreferencesCopyExtendedInterfaceConfiguration(CFTypeRef cf, const void *a2, const void *a3)
{
  uint64_t v6;
  CFTypeID TypeID;
  int v8;
  CFTypeRef result;
  CFTypeRef cfa[2];

  cfa[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cfa[0] = 0;
  if (__SCUserPreferencesInitialize_initialized != -1)
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (cf)
      goto LABEL_3;
LABEL_11:
    _SCErrorSet(1002);
    return 0;
  }
  if (!cf)
    goto LABEL_11;
LABEL_3:
  v6 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) != v6)
    goto LABEL_11;
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!a2
    || CFGetTypeID(a2) != TypeID
    || !__SCNetworkInterfaceIsValidExtendedConfigurationType((const __SCNetworkInterface *)a2, a3, 0))
  {
    goto LABEL_11;
  }
  v8 = processPreferences(*((const __CFString **)cf + 2), (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))copyInterfaceConfigurationCallout, *((_QWORD *)cf + 3), (uint64_t)a3, (uint64_t)cfa);
  result = cfa[0];
  if (!v8 && cfa[0])
  {
    CFRelease(cfa[0]);
    return 0;
  }
  return result;
}

uint64_t SCUserPreferencesSetExtendedInterfaceConfiguration(CFTypeRef cf, const void *a2, const void *a3, uint64_t a4)
{
  uint64_t v8;
  CFTypeID TypeID;

  if (__SCUserPreferencesInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_9;
  }
  else
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (!cf)
      goto LABEL_9;
  }
  v8 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) == v8)
  {
    TypeID = SCNetworkInterfaceGetTypeID();
    if (a2)
    {
      if (CFGetTypeID(a2) == TypeID
        && __SCNetworkInterfaceIsValidExtendedConfigurationType((const __SCNetworkInterface *)a2, a3, 0))
      {
        return processPreferences(*((const __CFString **)cf + 2), (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))setInterfaceConfigurationCallout, *((_QWORD *)cf + 3), (uint64_t)a3, a4);
      }
    }
  }
LABEL_9:
  _SCErrorSet(1002);
  return 0;
}

CFTypeRef SCNetworkConnectionCopyAllUserPreferences(const __SCNetworkConnection *a1)
{
  const __CFString *v1;
  BOOL v2;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = 0;
  v1 = SCNetworkConnectionCopyServiceID(a1);
  if (processPreferences(v1, (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))copyAllCallout, 0, 0, (uint64_t)cf))v2 = 1;
  else
    v2 = cf[0] == 0;
  if (!v2)
  {
    CFRelease(cf[0]);
    cf[0] = 0;
  }
  CFRelease(v1);
  return cf[0];
}

CFTypeRef copyAllCallout(const __CFString *a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, __CFArray **a5)
{
  const __CFString *Value;
  CFTypeID TypeID;
  uint64_t Private;
  const void *v11;
  __CFArray *Mutable;

  if (!theDict)
    return 0;
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("UniqueIdentifier"));
  TypeID = CFStringGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) == TypeID)
    {
      Private = __SCUserPreferencesCreatePrivate(a1, Value);
      if (Private)
      {
        v11 = (const void *)Private;
        Mutable = *a5;
        if (!*a5)
        {
          Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
          *a5 = Mutable;
        }
        CFArrayAppendValue(Mutable, v11);
        CFRelease(v11);
      }
    }
  }
  return CFRetain(theDict);
}

CFTypeRef SCNetworkConnectionCopyCurrentUserPreferences(const __SCNetworkConnection *a1)
{
  const __CFString *v1;
  BOOL v2;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = 0;
  v1 = SCNetworkConnectionCopyServiceID(a1);
  if (processPreferences(v1, (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))copyCurrentCallout, 0, 0, (uint64_t)cf))v2 = 1;
  else
    v2 = cf[0] == 0;
  if (!v2)
  {
    CFRelease(cf[0]);
    cf[0] = 0;
  }
  CFRelease(v1);
  return cf[0];
}

CFTypeRef copyCurrentCallout(const __CFString *a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  const __CFString *Value;
  CFTypeID TypeID;
  const __CFBoolean *v10;
  CFTypeID v11;

  if (!theDict)
    return 0;
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("UniqueIdentifier"));
  TypeID = CFStringGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) == TypeID)
    {
      v10 = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("ConnectByDefault"));
      v11 = CFBooleanGetTypeID();
      if (v10)
      {
        if (CFGetTypeID(v10) == v11)
        {
          if (CFBooleanGetValue(v10))
            *a5 = __SCUserPreferencesCreatePrivate(a1, Value);
        }
      }
    }
  }
  return CFRetain(theDict);
}

uint64_t SCNetworkConnectionCreateUserPreferences(const __SCNetworkConnection *a1)
{
  const __CFString *v1;
  const __CFUUID *v2;
  const __CFString *v3;
  uint64_t Private;

  v1 = SCNetworkConnectionCopyServiceID(a1);
  v2 = CFUUIDCreate(0);
  v3 = CFUUIDCreateString(0, v2);
  CFRelease(v2);
  Private = __SCUserPreferencesCreatePrivate(v1, v3);
  if (Private)
    processPreferences(v1, (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))createCallout, (uint64_t)v3, 0, 0);
  CFRelease(v3);
  CFRelease(v1);
  return Private;
}

uint64_t __SCUserPreferencesCreatePrivate(const __CFString *a1, const __CFString *a2)
{
  uint64_t Instance;

  if (__SCUserPreferencesInitialize_initialized != -1)
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = CFStringCreateCopy(0, a1);
    *(_QWORD *)(Instance + 24) = CFStringCreateCopy(0, a2);
  }
  return Instance;
}

__CFDictionary *createCallout(int a1, CFTypeRef cf, const void *a3)
{
  __CFDictionary *Mutable;

  if (cf)
    return (__CFDictionary *)CFRetain(cf);
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, CFSTR("UniqueIdentifier"), a3);
  return Mutable;
}

CFDictionaryRef SCUserPreferencesCopyStartOptions(_QWORD *cf)
{
  uint64_t v2;
  const void *Value;
  CFTypeID TypeID;
  const __CFString *v5;
  const __CFString *v6;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  CFTypeID v10;
  __CFDictionary *v11;
  __CFDictionary *v12;
  const __CFDictionary *v13;
  CFTypeID v14;
  const void *v15;
  CFTypeID v16;
  const __CFString *v17;
  __CFString *v18;
  CFTypeID v19;
  __CFString *v20;
  CFTypeID v21;
  CFTypeID v22;
  const __CFString *UniqueID;
  uint64_t v24;
  const __CFData *v25;
  __CFDictionary *MutableCopy;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFStringRef v29;
  __CFDictionary *v30;
  uint64_t v31;
  const void *v32;
  __CFDictionary *v33;
  __CFDictionary *v34;
  CFDictionaryRef theDict[2];

  theDict[1] = *(CFDictionaryRef *)MEMORY[0x1E0C80C00];
  theDict[0] = 0;
  if (__SCUserPreferencesInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_49;
  }
  else
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (!cf)
      goto LABEL_49;
  }
  v2 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) == v2)
  {
    processPreferences((const __CFString *)cf[2], (uint64_t (*)(const __CFString *, const void *, uint64_t, uint64_t, uint64_t))copyOptionsCallout, cf[3], 0, (uint64_t)theDict);
    if (!theDict[0])
      return theDict[0];
    Value = CFDictionaryGetValue(theDict[0], CFSTR("PPP"));
    TypeID = CFDictionaryGetTypeID();
    if (!Value
      || CFGetTypeID(Value) != TypeID
      || ((v5 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("AuthPasswordEncryption"))) != 0
        ? (v6 = v5)
        : (v6 = CFSTR("Keychain")),
          (v7 = CFStringGetTypeID(), !v6) || CFGetTypeID(v6) != v7 || !CFEqual(v6, CFSTR("Keychain"))))
    {
LABEL_22:
      v13 = (const __CFDictionary *)CFDictionaryGetValue(theDict[0], CFSTR("IPSec"));
      v14 = CFDictionaryGetTypeID();
      if (v13)
      {
        if (CFGetTypeID(v13) == v14)
        {
          v15 = CFDictionaryGetValue(v13, CFSTR("AuthenticationMethod"));
          v16 = CFStringGetTypeID();
          if (v15)
          {
            if (CFGetTypeID(v15) == v16 && CFEqual(v15, CFSTR("SharedSecret")))
            {
              v17 = (const __CFString *)CFDictionaryGetValue(v13, CFSTR("SharedSecretEncryption"));
              v18 = v17 ? (__CFString *)v17 : CFSTR("Keychain");
              v19 = CFStringGetTypeID();
              if (v18)
              {
                if (CFGetTypeID(v18) == v19 && CFEqual(v18, CFSTR("Keychain")))
                {
                  v20 = (__CFString *)CFDictionaryGetValue(v13, CFSTR("SharedSecret"));
                  v21 = CFStringGetTypeID();
                  if (!v20)
                  {
                    CFDataGetTypeID();
                    goto LABEL_39;
                  }
                  if (CFGetTypeID(v20) == v21)
                  {
                    CFRetain(v20);
LABEL_40:
                    v24 = _SCSecKeychainPasswordItemCopy();
                    if (v24)
                    {
                      v25 = (const __CFData *)v24;
                      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v13);
                      BytePtr = CFDataGetBytePtr(v25);
                      Length = CFDataGetLength(v25);
                      v29 = CFStringCreateWithBytes(0, BytePtr, Length, 0x8000100u, 0);
                      CFRelease(v25);
                      CFDictionarySetValue(MutableCopy, CFSTR("SharedSecret"), v29);
                      CFRelease(v29);
                      CFDictionaryRemoveValue(MutableCopy, CFSTR("SharedSecretEncryption"));
                      v30 = CFDictionaryCreateMutableCopy(0, 0, theDict[0]);
                      CFDictionarySetValue(v30, CFSTR("IPSec"), MutableCopy);
                      CFRelease(MutableCopy);
                      CFRelease(theDict[0]);
                      theDict[0] = v30;
                    }
                    else
                    {
                      v31 = _SCSecKeychainCopySystemKeychain();
                      if (v31)
                      {
                        v32 = (const void *)v31;
                        if (_SCSecKeychainPasswordItemExists())
                        {
                          v33 = CFDictionaryCreateMutableCopy(0, 0, v13);
                          CFDictionarySetValue(v33, CFSTR("SharedSecret"), v20);
                          CFDictionarySetValue(v33, CFSTR("SharedSecretEncryption"), CFSTR("Keychain"));
                          v34 = CFDictionaryCreateMutableCopy(0, 0, theDict[0]);
                          CFDictionarySetValue(v34, CFSTR("IPSec"), v33);
                          CFRelease(v33);
                          CFRelease(theDict[0]);
                          theDict[0] = v34;
                        }
                        CFRelease(v32);
                      }
                    }
                    CFRelease(v20);
                    return theDict[0];
                  }
                  v22 = CFDataGetTypeID();
                  if (CFGetTypeID(v20) != v22 || (CFDataGetLength((CFDataRef)v20) & 1) != 0)
                  {
LABEL_39:
                    UniqueID = (const __CFString *)SCUserPreferencesGetUniqueID(cf);
                    v20 = CFStringCreateMutableCopy(0, 0, UniqueID);
                    CFStringAppend(v20, CFSTR(".SS"));
                    goto LABEL_40;
                  }
                }
              }
            }
          }
        }
      }
      return theDict[0];
    }
    v8 = CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("AuthPassword"));
    v9 = CFStringGetTypeID();
    if (v8)
    {
      if (CFGetTypeID(v8) == v9)
        goto LABEL_20;
      v10 = CFDataGetTypeID();
      if (CFGetTypeID(v8) == v10 && (CFDataGetLength((CFDataRef)v8) & 1) == 0)
        goto LABEL_22;
    }
    else
    {
      CFDataGetTypeID();
    }
    v8 = (const void *)SCUserPreferencesGetUniqueID(cf);
LABEL_20:
    if (_SCSecKeychainPasswordItemExists())
    {
      v11 = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)Value);
      CFDictionarySetValue(v11, CFSTR("AuthPassword"), v8);
      CFDictionarySetValue(v11, CFSTR("AuthPasswordEncryption"), CFSTR("Keychain"));
      v12 = CFDictionaryCreateMutableCopy(0, 0, theDict[0]);
      CFDictionarySetValue(v12, CFSTR("PPP"), v11);
      CFRelease(v11);
      CFRelease(theDict[0]);
      theDict[0] = v12;
    }
    goto LABEL_22;
  }
LABEL_49:
  _SCErrorSet(1002);
  return 0;
}

CFTypeRef copyOptionsCallout(int a1, CFDictionaryRef theDict, const void *a3, uint64_t a4, CFTypeRef *a5)
{
  const void *Value;
  CFTypeID TypeID;
  __CFDictionary *MutableCopy;

  if (!theDict)
    return 0;
  Value = CFDictionaryGetValue(theDict, CFSTR("UniqueIdentifier"));
  TypeID = CFStringGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && CFEqual(Value, a3))
  {
    if (*a5)
      CFRelease(*a5);
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
    *a5 = MutableCopy;
    CFDictionaryRemoveValue(MutableCopy, CFSTR("UniqueIdentifier"));
    CFDictionaryRemoveValue((CFMutableDictionaryRef)*a5, CFSTR("ConnectByDefault"));
  }
  return CFRetain(theDict);
}

uint64_t SCNetworkConnectionStartWithUserPreferences(const __SCNetworkConnection *a1, _QWORD *cf, Boolean a3)
{
  const __CFDictionary *started;
  uint64_t v6;

  started = SCUserPreferencesCopyStartOptions(cf);
  v6 = SCNetworkConnectionStart(a1, started, a3);
  if (started)
    CFRelease(started);
  return v6;
}

uint64_t SCUserPreferencesCheckInterfacePassword(_QWORD *a1, const void *a2, int a3)
{
  const __CFDictionary *v6;
  const void *UserPasswordID;
  const void **v8;
  const __CFDictionary *v9;
  __CFString *v10;
  const __CFString *v11;
  __CFString *v12;
  const void **v13;
  uint64_t password;
  const void *v15;

  if (!checkUserPreferencesPassword(a1, a2, a3))
    return 0;
  switch(a3)
  {
    case 1:
      v6 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      UserPasswordID = getUserPasswordID(v6, a1);
      v8 = (const void **)&kSCValNetPPPAuthPasswordEncryptionKeychain;
      goto LABEL_12;
    case 2:
      v9 = (const __CFDictionary *)SCUserPreferencesCopyExtendedInterfaceConfiguration(a1, a2, CFSTR("IPSec"));
      v10 = copyUserSharedSecretID(v9, a1);
      v11 = CFSTR("SharedSecret");
      v12 = CFSTR("SharedSecretEncryption");
      v13 = (const void **)&kSCValNetIPSecSharedSecretEncryptionKeychain;
      goto LABEL_6;
    case 4:
      v9 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      v10 = copyUserXAuthID(v9, a1);
      v11 = CFSTR("XAuthPassword");
      v12 = CFSTR("XAuthPasswordEncryption");
      v13 = (const void **)&kSCValNetIPSecXAuthPasswordEncryptionKeychain;
LABEL_6:
      password = __extract_password(0, v9, v11, v12, *v13, (uint64_t)v10, 0);
      if (v9)
        CFRelease(v9);
      v15 = v10;
      goto LABEL_14;
    case 5:
      v6 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      UserPasswordID = getUserPasswordID(v6, a1);
      v8 = (const void **)kSCValNetVPNAuthPasswordEncryptionKeychain;
LABEL_12:
      password = __extract_password(0, v6, CFSTR("AuthPassword"), CFSTR("AuthPasswordEncryption"), *v8, (uint64_t)UserPasswordID, 0);
      if (!v6)
        return password;
      v15 = v6;
LABEL_14:
      CFRelease(v15);
      break;
    default:
      _SCErrorSet(1002);
      return 0;
  }
  return password;
}

uint64_t checkUserPreferencesPassword(CFTypeRef cf, const void *a2, int a3)
{
  uint64_t v6;
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  CFTypeRef *v9;
  CFStringRef v10;
  const __SCNetworkInterface *Interface;
  uint64_t result;

  if (__SCUserPreferencesInitialize_initialized != -1)
  {
    dispatch_once(&__SCUserPreferencesInitialize_initialized, &__block_literal_global_9);
    if (cf)
      goto LABEL_3;
LABEL_16:
    _SCErrorSet(1002);
    return 0;
  }
  if (!cf)
    goto LABEL_16;
LABEL_3:
  v6 = __kSCUserPreferencesTypeID;
  if (CFGetTypeID(cf) != v6)
    goto LABEL_16;
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
    goto LABEL_16;
  switch(a3)
  {
    case 1:
      InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a2);
      v9 = (CFTypeRef *)&kSCNetworkInterfaceTypePPP;
      goto LABEL_13;
    case 2:
      v10 = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a2);
      if (!CFEqual(v10, CFSTR("PPP")))
        goto LABEL_16;
      Interface = SCNetworkInterfaceGetInterface((SCNetworkInterfaceRef)a2);
      if (!Interface)
        goto LABEL_16;
      InterfaceType = SCNetworkInterfaceGetInterfaceType(Interface);
      v9 = (CFTypeRef *)&kSCNetworkInterfaceTypeL2TP;
      goto LABEL_13;
    case 3:
      goto LABEL_16;
    case 4:
      InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a2);
      v9 = (CFTypeRef *)&kSCNetworkInterfaceTypeIPSec;
      goto LABEL_13;
    case 5:
      InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a2);
      v9 = (CFTypeRef *)kSCNetworkInterfaceTypeVPN;
LABEL_13:
      if (CFEqual(InterfaceType, *v9))
        goto LABEL_14;
      goto LABEL_16;
    default:
LABEL_14:
      result = 1;
      break;
  }
  return result;
}

const void *getUserPasswordID(const __CFDictionary *a1, _QWORD *cf)
{
  const void *Value;
  CFTypeID TypeID;
  const void *result;

  if (!a1)
    return (const void *)SCUserPreferencesGetUniqueID(cf);
  Value = CFDictionaryGetValue(a1, CFSTR("AuthPasswordEncryption"));
  TypeID = CFStringGetTypeID();
  if (!Value)
    return (const void *)SCUserPreferencesGetUniqueID(cf);
  if (CFGetTypeID(Value) != TypeID)
    return (const void *)SCUserPreferencesGetUniqueID(cf);
  if (!CFEqual(Value, CFSTR("Keychain")))
    return (const void *)SCUserPreferencesGetUniqueID(cf);
  result = CFDictionaryGetValue(a1, CFSTR("AuthPassword"));
  if (!result)
    return (const void *)SCUserPreferencesGetUniqueID(cf);
  return result;
}

__CFString *copyUserSharedSecretID(const __CFDictionary *a1, _QWORD *cf)
{
  const void *Value;
  CFTypeID TypeID;
  __CFString *v6;
  __CFString *MutableCopy;
  const __CFString *UserPasswordID;

  if (a1
    && (Value = CFDictionaryGetValue(a1, CFSTR("SharedSecretEncryption")), TypeID = CFStringGetTypeID(), Value)
    && CFGetTypeID(Value) == TypeID
    && CFEqual(Value, CFSTR("Keychain"))
    && (v6 = (__CFString *)CFDictionaryGetValue(a1, CFSTR("SharedSecret"))) != 0)
  {
    MutableCopy = v6;
    CFRetain(v6);
  }
  else
  {
    UserPasswordID = (const __CFString *)getUserPasswordID(a1, cf);
    MutableCopy = CFStringCreateMutableCopy(0, 0, UserPasswordID);
    CFStringAppend(MutableCopy, CFSTR(".SS"));
  }
  return MutableCopy;
}

__CFString *copyUserXAuthID(const __CFDictionary *a1, _QWORD *cf)
{
  const void *Value;
  CFTypeID TypeID;
  __CFString *v6;
  __CFString *MutableCopy;
  const __CFString *UserPasswordID;

  if (a1
    && (Value = CFDictionaryGetValue(a1, CFSTR("XAuthPasswordEncryption")), TypeID = CFStringGetTypeID(), Value)
    && CFGetTypeID(Value) == TypeID
    && CFEqual(Value, CFSTR("Keychain"))
    && (v6 = (__CFString *)CFDictionaryGetValue(a1, CFSTR("XAuthPassword"))) != 0)
  {
    MutableCopy = v6;
    CFRetain(v6);
  }
  else
  {
    UserPasswordID = (const __CFString *)getUserPasswordID(a1, cf);
    MutableCopy = CFStringCreateMutableCopy(0, 0, UserPasswordID);
    CFStringAppend(MutableCopy, CFSTR(".XAUTH"));
  }
  return MutableCopy;
}

uint64_t SCUserPreferencesCopyInterfacePassword(_QWORD *a1, const void *a2, int a3)
{
  const __CFDictionary *v6;
  const void *UserPasswordID;
  const void **v8;
  const __CFDictionary *v9;
  __CFString *v10;
  const __CFString *v11;
  __CFString *v12;
  const void **v13;
  const void *v14;
  uint64_t result;
  uint64_t v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v16[0] = 0;
  if (!checkUserPreferencesPassword(a1, a2, a3))
    return 0;
  switch(a3)
  {
    case 1:
      v6 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      UserPasswordID = getUserPasswordID(v6, a1);
      v8 = (const void **)&kSCValNetPPPAuthPasswordEncryptionKeychain;
      goto LABEL_12;
    case 2:
      v9 = (const __CFDictionary *)SCUserPreferencesCopyExtendedInterfaceConfiguration(a1, a2, CFSTR("IPSec"));
      v10 = copyUserSharedSecretID(v9, a1);
      v11 = CFSTR("SharedSecret");
      v12 = CFSTR("SharedSecretEncryption");
      v13 = (const void **)&kSCValNetIPSecSharedSecretEncryptionKeychain;
      goto LABEL_6;
    case 4:
      v9 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      v10 = copyUserXAuthID(v9, a1);
      v11 = CFSTR("XAuthPassword");
      v12 = CFSTR("XAuthPasswordEncryption");
      v13 = (const void **)&kSCValNetIPSecXAuthPasswordEncryptionKeychain;
LABEL_6:
      __extract_password(0, v9, v11, v12, *v13, (uint64_t)v10, v16);
      if (v9)
        CFRelease(v9);
      v14 = v10;
      goto LABEL_14;
    case 5:
      v6 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      UserPasswordID = getUserPasswordID(v6, a1);
      v8 = (const void **)kSCValNetVPNAuthPasswordEncryptionKeychain;
LABEL_12:
      __extract_password(0, v6, CFSTR("AuthPassword"), CFSTR("AuthPasswordEncryption"), *v8, (uint64_t)UserPasswordID, v16);
      if (!v6)
        goto LABEL_15;
      v14 = v6;
LABEL_14:
      CFRelease(v14);
LABEL_15:
      result = v16[0];
      break;
    default:
      _SCErrorSet(1002);
      return 0;
  }
  return result;
}

uint64_t SCUserPreferencesRemoveInterfacePassword(_QWORD *a1, const void *a2, int a3)
{
  const __CFDictionary *v6;
  const void *UserPasswordID;
  const void **v8;
  const __CFDictionary *v9;
  __CFString *v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  if (!checkUserPreferencesPassword(a1, a2, a3))
    return 0;
  switch(a3)
  {
    case 1:
      cf[0] = 0;
      v6 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      UserPasswordID = getUserPasswordID(v6, a1);
      v8 = (const void **)&kSCValNetPPPAuthPasswordEncryptionKeychain;
      goto LABEL_16;
    case 2:
      cf[0] = 0;
      v9 = (const __CFDictionary *)SCUserPreferencesCopyExtendedInterfaceConfiguration(a1, a2, CFSTR("IPSec"));
      v10 = copyUserSharedSecretID(v9, a1);
      if (!__remove_password(0, v9, CFSTR("SharedSecret"), CFSTR("SharedSecretEncryption"), CFSTR("Keychain"), (uint64_t)v10, (__CFDictionary **)cf))goto LABEL_21;
      v11 = SCUserPreferencesSetExtendedInterfaceConfiguration(a1, a2, CFSTR("IPSec"), (uint64_t)cf[0]);
      goto LABEL_8;
    case 4:
      cf[0] = 0;
      v9 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      v10 = copyUserXAuthID(v9, a1);
      if (__remove_password(0, v9, CFSTR("XAuthPassword"), CFSTR("XAuthPasswordEncryption"), CFSTR("Keychain"), (uint64_t)v10, (__CFDictionary **)cf))
      {
        v11 = SCUserPreferencesSetInterfaceConfiguration(a1, a2, (uint64_t)cf[0]);
LABEL_8:
        v12 = v11;
        if (cf[0])
          CFRelease(cf[0]);
        if (v9)
          goto LABEL_11;
      }
      else
      {
LABEL_21:
        v12 = 0;
        if (v9)
LABEL_11:
          CFRelease(v9);
      }
      v13 = v10;
LABEL_25:
      CFRelease(v13);
      return v12;
    case 5:
      cf[0] = 0;
      v6 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      UserPasswordID = getUserPasswordID(v6, a1);
      v8 = (const void **)kSCValNetVPNAuthPasswordEncryptionKeychain;
LABEL_16:
      if (!__remove_password(0, v6, CFSTR("AuthPassword"), CFSTR("AuthPasswordEncryption"), *v8, (uint64_t)UserPasswordID, (__CFDictionary **)cf))
      {
        v12 = 0;
        if (!v6)
          return v12;
        goto LABEL_24;
      }
      v12 = SCUserPreferencesSetInterfaceConfiguration(a1, a2, (uint64_t)cf[0]);
      if (cf[0])
        CFRelease(cf[0]);
      if (v6)
      {
LABEL_24:
        v13 = v6;
        goto LABEL_25;
      }
      return v12;
    default:
      _SCErrorSet(1002);
      return 0;
  }
}

uint64_t SCUserPreferencesSetInterfacePassword(_QWORD *a1, const void *a2, int a3)
{
  __CFBundle *v6;
  const __CFDictionary *v7;
  const void *UserPasswordID;
  const __CFDictionary *v9;
  __CFString *v10;
  CFTypeRef v11;
  __CFDictionary *Mutable;
  uint64_t v13;
  const __CFDictionary *v14;
  const void *v15;
  __CFString *v16;
  __CFDictionary *MutableCopy;
  CFTypeRef v18;
  __CFDictionary *v19;
  __CFDictionary *v20;
  __CFDictionary *v21;
  const void *v22;
  __CFDictionary *v23;
  const void **v24;
  __CFDictionary *v25;
  __CFString *v26;

  if (!checkUserPreferencesPassword(a1, a2, a3))
    return 0;
  v6 = (__CFBundle *)_SC_CFBundleGet();
  switch(a3)
  {
    case 1:
      v7 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      UserPasswordID = getUserPasswordID(v7, a1);
      if (v7)
        CFDictionaryGetValue(v7, CFSTR("AuthName"));
      v16 = (__CFString *)SCUserPreferencesCopyName(a1);
      if (v6)
        v6 = (__CFBundle *)CFBundleCopyLocalizedString(v6, CFSTR("KEYCHAIN_KIND_PPP_PASSWORD"), CFSTR("PPP Password"), 0);
      if (!_SCSecKeychainPasswordItemSet())
        goto LABEL_32;
      if (v7)
        MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v7);
      else
        MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v23 = MutableCopy;
      CFDictionarySetValue(MutableCopy, CFSTR("AuthPassword"), UserPasswordID);
      v24 = (const void **)&kSCValNetPPPAuthPasswordEncryptionKeychain;
      goto LABEL_58;
    case 2:
      v9 = (const __CFDictionary *)SCUserPreferencesCopyExtendedInterfaceConfiguration(a1, a2, CFSTR("IPSec"));
      v10 = copyUserSharedSecretID(v9, a1);
      v11 = SCUserPreferencesCopyName(a1);
      if (v6)
        v6 = (__CFBundle *)CFBundleCopyLocalizedString(v6, CFSTR("KEYCHAIN_KIND_IPSEC_SHARED_SECRET"), CFSTR("IPSec Shared Secret"), 0);
      if (_SCSecKeychainPasswordItemSet())
      {
        if (v9)
          Mutable = CFDictionaryCreateMutableCopy(0, 0, v9);
        else
          Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v21 = Mutable;
        CFDictionarySetValue(Mutable, CFSTR("SharedSecret"), v10);
        CFDictionarySetValue(v21, CFSTR("SharedSecretEncryption"), CFSTR("Keychain"));
        v13 = SCUserPreferencesSetExtendedInterfaceConfiguration(a1, a2, CFSTR("IPSec"), (uint64_t)v21);
        CFRelease(v21);
      }
      else
      {
        v13 = 0;
      }
      if (v9)
        CFRelease(v9);
      if (v6)
        CFRelease(v6);
      if (!v11)
        goto LABEL_54;
      v22 = v11;
      goto LABEL_53;
    case 4:
      v14 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      v10 = copyUserXAuthID(v14, a1);
      if (v14)
        CFDictionaryGetValue(v14, CFSTR("XAuthName"));
      v18 = SCUserPreferencesCopyName(a1);
      if (v6)
        v6 = (__CFBundle *)CFBundleCopyLocalizedString(v6, CFSTR("KEYCHAIN_KIND_IPSEC_XAUTH_PASSWORD"), CFSTR("IPSec XAuth Password"), 0);
      if (_SCSecKeychainPasswordItemSet())
      {
        if (v14)
          v19 = CFDictionaryCreateMutableCopy(0, 0, v14);
        else
          v19 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v25 = v19;
        CFDictionarySetValue(v19, CFSTR("XAuthPassword"), v10);
        CFDictionarySetValue(v25, CFSTR("XAuthPasswordEncryption"), CFSTR("Keychain"));
        v13 = SCUserPreferencesSetInterfaceConfiguration(a1, a2, (uint64_t)v25);
        CFRelease(v25);
      }
      else
      {
        v13 = 0;
      }
      if (v14)
        CFRelease(v14);
      if (v6)
        CFRelease(v6);
      if (!v18)
        goto LABEL_54;
      v22 = v18;
LABEL_53:
      CFRelease(v22);
LABEL_54:
      v26 = v10;
      goto LABEL_64;
    case 5:
      v7 = (const __CFDictionary *)SCUserPreferencesCopyInterfaceConfiguration(a1, a2);
      v15 = getUserPasswordID(v7, a1);
      if (v7)
        CFDictionaryGetValue(v7, CFSTR("AuthName"));
      v16 = (__CFString *)SCUserPreferencesCopyName(a1);
      if (v6)
        v6 = (__CFBundle *)CFBundleCopyLocalizedString(v6, CFSTR("KEYCHAIN_KIND_VPN_PASSWORD"), CFSTR("VPN Password"), 0);
      if (!_SCSecKeychainPasswordItemSet())
      {
LABEL_32:
        v13 = 0;
        if (!v7)
          goto LABEL_60;
        goto LABEL_59;
      }
      if (v7)
        v20 = CFDictionaryCreateMutableCopy(0, 0, v7);
      else
        v20 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v23 = v20;
      if (!v20)
        SCUserPreferencesSetInterfacePassword_cold_1();
      CFDictionarySetValue(v20, CFSTR("AuthPassword"), v15);
      v24 = (const void **)kSCValNetVPNAuthPasswordEncryptionKeychain;
LABEL_58:
      CFDictionarySetValue(v23, CFSTR("AuthPasswordEncryption"), *v24);
      v13 = SCUserPreferencesSetInterfaceConfiguration(a1, a2, (uint64_t)v23);
      CFRelease(v23);
      if (v7)
LABEL_59:
        CFRelease(v7);
LABEL_60:
      if (v6)
        CFRelease(v6);
      if (v16)
      {
        v26 = v16;
LABEL_64:
        CFRelease(v26);
      }
      break;
    default:
      _SCErrorSet(1002);
      return 0;
  }
  return v13;
}

void __SCUserPreferencesDeallocate(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 24));
  CFRelease(*(CFTypeRef *)(a1 + 16));
}

BOOL __SCUserPreferencesEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2 || CFEqual(*(CFTypeRef *)(a1 + 24), *(CFTypeRef *)(a2 + 24)) != 0;
}

CFHashCode __SCUserPreferencesHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 24));
}

__CFString *__SCUserPreferencesCopyDescription(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCUserPreferences %p [%p]> {"), a1, v2);
  CFStringAppendFormat(Mutable, 0, CFSTR("service = %@"), a1[2]);
  CFStringAppendFormat(Mutable, 0, CFSTR(", id = %@"), a1[3]);
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  return Mutable;
}

void logCFPreferencesChange(const __CFString *a1, const void *a2)
{
  CFPropertyListRef v4;
  const void *v5;
  CFTypeID TypeID;
  int Value;
  const __CFString *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  __CFString *v21;
  __CFString *v22;
  int v23;
  FILE *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  CFPropertyListRef v30;
  const void *v31;
  int v32;
  int v33;
  const __CFData *Data;
  const __CFData *v35;
  const UInt8 *BytePtr;
  size_t Length;
  int v38;
  int v39;
  const __CFData *v40;
  const __CFData *v41;
  const UInt8 *v42;
  size_t v43;
  const __CFData *v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  int *v57;
  const char *v58;
  NSObject *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  int *v71;
  const char *v72;
  NSObject *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char *v83;
  uint64_t v84;
  int *v85;
  const char *v86;
  NSObject *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  NSObject *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  char *v108;
  timeval v109;
  tm v110;
  char v111[256];
  UInt8 v112[256];
  uint64_t v113;

  v113 = *MEMORY[0x1E0C80C00];
  v4 = CFPreferencesCopyAppValue(CFSTR("LOG_SC_CHANGES"), CFSTR("com.apple.networkConnect"));
  if (!v4)
    return;
  v5 = v4;
  TypeID = CFBooleanGetTypeID();
  if (CFGetTypeID(v5) != TypeID)
  {
    CFRelease(v5);
    return;
  }
  Value = CFBooleanGetValue((CFBooleanRef)v5);
  CFRelease(v5);
  if (!Value)
    return;
  memset(&v110, 0, sizeof(v110));
  v109.tv_sec = 0;
  *(_QWORD *)&v109.tv_usec = 0;
  gettimeofday(&v109, 0);
  localtime_r(&v109.tv_sec, &v110);
  v8 = CFStringCreateWithFormat(0, 0, CFSTR("/var/tmp/com.apple.networkConnect-%@-%4d%02d%02d.%02d%02d%02d.%03d"), a1, (v110.tm_year + 1900), (v110.tm_mon + 1), v110.tm_mday, v110.tm_hour, v110.tm_min, v110.tm_sec, (v109.tv_usec / 1000));
  _SC_cfstring_to_cstring(v8, v112, 256, 0x8000100u);
  CFRelease(v8);
  v9 = __log_SCNetworkConfiguration();
  v10 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v9, (os_log_type_t)v10))
  {
    v11 = _os_log_pack_size();
    v19 = (char *)&v109 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v20 = _os_log_pack_fill();
    *(_DWORD *)v20 = 136315138;
    *(_QWORD *)(v20 + 4) = v112;
    __SC_log_send(5, (uint64_t)v9, v10, v19);
  }
  if (mkdir((const char *)v112, 0x1EDu) == -1)
  {
    v45 = __log_SCNetworkConfiguration();
    v46 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v45, (os_log_type_t)v46))
      return;
    goto LABEL_20;
  }
  v21 = _SC_copyBacktrace();
  if (v21)
  {
    v22 = v21;
    __strlcpy_chk();
    __strlcat_chk();
    v23 = open(v111, 3585, 420);
    if (v23 == -1)
    {
      v59 = __log_SCNetworkConfiguration();
      v60 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v59, (os_log_type_t)v60))
      {
        v61 = _os_log_pack_size();
        v69 = (char *)&v109
            - ((MEMORY[0x1E0C80A78](v61, v62, v63, v64, v65, v66, v67, v68) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v70 = _os_log_pack_fill();
        v71 = __error();
        v72 = SCErrorString(*v71);
        *(_DWORD *)v70 = 136315138;
        *(_QWORD *)(v70 + 4) = v72;
        __SC_log_send(5, (uint64_t)v59, v60, v69);
      }
      v44 = (const __CFData *)v22;
      goto LABEL_30;
    }
    v24 = fdopen(v23, "w");
    SCPrint(1, v24, (uint64_t)CFSTR("%@"), v25, v26, v27, v28, v29, (uint64_t)v22);
    fclose(v24);
    CFRelease(v22);
  }
  v30 = CFPreferencesCopyAppValue(a1, CFSTR("com.apple.networkConnect"));
  if (v30)
  {
    v31 = v30;
    __strlcpy_chk();
    __strlcat_chk();
    v32 = open(v111, 3585, 420);
    if (v32 == -1)
    {
      v73 = __log_SCNetworkConfiguration();
      v74 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v73, (os_log_type_t)v74))
      {
        v75 = _os_log_pack_size();
        v83 = (char *)&v109
            - ((MEMORY[0x1E0C80A78](v75, v76, v77, v78, v79, v80, v81, v82) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v84 = _os_log_pack_fill();
        v85 = __error();
        v86 = SCErrorString(*v85);
        *(_DWORD *)v84 = 136315138;
        *(_QWORD *)(v84 + 4) = v86;
        __SC_log_send(5, (uint64_t)v73, v74, v83);
      }
    }
    else
    {
      v33 = v32;
      Data = CFPropertyListCreateData(0, v31, kCFPropertyListXMLFormat_v1_0, 0, 0);
      if (Data)
      {
        v35 = Data;
        BytePtr = CFDataGetBytePtr(Data);
        Length = CFDataGetLength(v35);
        write(v33, BytePtr, Length);
        close(v33);
        CFRelease(v35);
        CFRelease(v31);
        goto LABEL_14;
      }
      v87 = __log_SCNetworkConfiguration();
      v88 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v87, (os_log_type_t)v88))
      {
        v89 = _os_log_pack_size();
        v97 = (char *)&v109
            - ((MEMORY[0x1E0C80A78](v89, v90, v91, v92, v93, v94, v95, v96) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v87, v88, v97);
      }
      close(v33);
    }
    v44 = (const __CFData *)v31;
    goto LABEL_30;
  }
LABEL_14:
  if (!a2)
    return;
  __strlcpy_chk();
  __strlcat_chk();
  v38 = open(v111, 3585, 420);
  if (v38 == -1)
  {
    v45 = __log_SCNetworkConfiguration();
    v46 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v45, (os_log_type_t)v46))
      return;
LABEL_20:
    v47 = _os_log_pack_size();
    v55 = (char *)&v109 - ((MEMORY[0x1E0C80A78](v47, v48, v49, v50, v51, v52, v53, v54) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v56 = _os_log_pack_fill();
    v57 = __error();
    v58 = SCErrorString(*v57);
    *(_DWORD *)v56 = 136315138;
    *(_QWORD *)(v56 + 4) = v58;
    __SC_log_send(5, (uint64_t)v45, v46, v55);
    return;
  }
  v39 = v38;
  v40 = CFPropertyListCreateData(0, a2, kCFPropertyListXMLFormat_v1_0, 0, 0);
  if (v40)
  {
    v41 = v40;
    v42 = CFDataGetBytePtr(v40);
    v43 = CFDataGetLength(v41);
    write(v39, v42, v43);
    close(v39);
    v44 = v41;
LABEL_30:
    CFRelease(v44);
    return;
  }
  v98 = __log_SCNetworkConfiguration();
  v99 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v98, (os_log_type_t)v99))
  {
    v100 = _os_log_pack_size();
    v108 = (char *)&v109
         - ((MEMORY[0x1E0C80A78](v100, v101, v102, v103, v104, v105, v106, v107) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(5, (uint64_t)v98, v99, v108);
  }
  close(v39);
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithAddressPair(CFAllocatorRef allocator, const sockaddr *localAddress, const sockaddr *remoteAddress)
{
  char *v3;
  sockaddr *v5;
  unsigned __int8 *v6;
  char *Private;
  int v8;
  sockaddr *v9;
  size_t v10;
  unsigned __int8 *v11;
  void *address;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  _QWORD v25[2];

  v25[1] = *MEMORY[0x1E0C80C00];
  if (!((unint64_t)localAddress | (unint64_t)remoteAddress))
    goto LABEL_2;
  v5 = (sockaddr *)remoteAddress;
  if (!localAddress)
  {
    v6 = 0;
    if (!remoteAddress)
      goto LABEL_10;
    goto LABEL_9;
  }
  v6 = is_valid_address(&localAddress->sa_len);
  if (!v6)
    goto LABEL_2;
  if (v5)
  {
LABEL_9:
    v5 = (sockaddr *)is_valid_address(&v5->sa_len);
    if (v5)
      goto LABEL_10;
LABEL_2:
    _SCErrorSet(1002);
    return 0;
  }
LABEL_10:
  Private = __SCNetworkReachabilityCreatePrivate();
  v3 = Private;
  if (!Private)
    return (SCNetworkReachabilityRef)v3;
  *((_DWORD *)Private + 20) = 1;
  if (v6)
  {
    *((_QWORD *)Private + 12) = nw_endpoint_create_address((const sockaddr *)v6);
    if (v5)
    {
      v8 = v6[1];
      if (v8 != v5->sa_family || *v6 != v5->sa_len)
        goto LABEL_28;
      if (v8 == 30)
      {
        if (*((_DWORD *)v6 + 6) != *(_DWORD *)&v5[1].sa_data[6])
          goto LABEL_28;
        v11 = v6 + 8;
        v9 = (sockaddr *)&v5->sa_data[6];
        v10 = 16;
      }
      else
      {
        if (v8 == 2)
          v9 = (sockaddr *)&v5->sa_data[2];
        else
          v9 = v5;
        if (v8 == 2)
          v10 = 4;
        else
          v10 = *v6;
        if (v8 == 2)
          v11 = v6 + 4;
        else
          v11 = v6;
      }
      if (!bcmp(v11, v9, v10))
      {
        address = nw_retain(*((void **)v3 + 12));
LABEL_29:
        *((_QWORD *)v3 + 13) = address;
        goto LABEL_30;
      }
LABEL_28:
      address = nw_endpoint_create_address(v5);
      goto LABEL_29;
    }
  }
  else if (v5)
  {
    goto LABEL_28;
  }
LABEL_30:
  *((_QWORD *)v3 + 29) = nw_parameters_create();
  MEMORY[0x18D78CC6C]();
  v13 = __log_SCNetworkReachability_log;
  if (!__log_SCNetworkReachability_log)
  {
    v13 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
    __log_SCNetworkReachability_log = (uint64_t)v13;
  }
  v14 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v13, (os_log_type_t)v14))
  {
    v15 = _os_log_pack_size();
    v23 = (char *)v25 - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v24 = _os_log_pack_fill();
    *(_DWORD *)v24 = 136315650;
    *(_QWORD *)(v24 + 4) = v3 + 193;
    *(_WORD *)(v24 + 12) = 2080;
    *(_QWORD *)(v24 + 14) = "create w/address pair";
    *(_WORD *)(v24 + 22) = 2112;
    *(_QWORD *)(v24 + 24) = v3;
    __SC_log_send(7, (uint64_t)v13, v14, v23);
  }
  return (SCNetworkReachabilityRef)v3;
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithOptions(const __CFAllocator *a1, const void *a2)
{
  CFTypeID TypeID;
  const __CFString *Value;
  CFTypeID v6;
  const void *v7;
  const void *v8;
  CFTypeID v9;
  const sockaddr *BytePtr;
  const void *v11;
  const void *v12;
  CFTypeID v13;
  unsigned __int8 *v14;
  const void *v15;
  const void *v16;
  CFTypeID v17;
  const sockaddr *v18;
  const __CFString *v19;
  CFTypeID v20;
  const void *v21;
  CFTypeID v22;
  const void *v23;
  CFTypeID v24;
  const __CFString *v25;
  CFTypeID v26;
  UInt8 *v27;
  SCNetworkReachabilityRef v28;
  const __SCNetworkReachability *v29;
  const sockaddr *v30;
  const sockaddr *v31;
  unsigned int v32;
  NSObject *v34;
  int v35;
  uint64_t v36;
  char *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  UInt8 *v50;
  UInt8 *v51;
  NSObject *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  _OWORD v64[2];
  UInt8 buffer[16];
  __int128 v66;
  char v67[16];
  uint64_t v68;
  CFRange v69;

  v68 = *MEMORY[0x1E0C80C00];
  TypeID = CFDictionaryGetTypeID();
  if (!a2)
    goto LABEL_52;
  if (CFGetTypeID(a2) != TypeID)
    goto LABEL_52;
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("nodename"));
  if (Value)
  {
    v6 = CFStringGetTypeID();
    if (CFGetTypeID(Value) != v6 || !CFStringGetLength(Value))
      goto LABEL_52;
  }
  v7 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("local-address"));
  if (v7)
  {
    v8 = v7;
    v9 = CFDataGetTypeID();
    if (CFGetTypeID(v8) != v9 || (unint64_t)CFDataGetLength((CFDataRef)v8) <= 0xF)
      goto LABEL_52;
    BytePtr = (const sockaddr *)CFDataGetBytePtr((CFDataRef)v8);
  }
  else
  {
    BytePtr = 0;
  }
  v11 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ptr-address"));
  if (v11)
  {
    v12 = v11;
    v13 = CFDataGetTypeID();
    if (CFGetTypeID(v12) != v13 || (unint64_t)CFDataGetLength((CFDataRef)v12) <= 0xF)
      goto LABEL_52;
    v14 = (unsigned __int8 *)CFDataGetBytePtr((CFDataRef)v12);
  }
  else
  {
    v14 = 0;
  }
  v15 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("remote-address"));
  if (v15)
  {
    v16 = v15;
    v17 = CFDataGetTypeID();
    if (CFGetTypeID(v16) != v17 || (unint64_t)CFDataGetLength((CFDataRef)v16) <= 0xF)
      goto LABEL_52;
    v18 = (const sockaddr *)CFDataGetBytePtr((CFDataRef)v16);
  }
  else
  {
    v18 = 0;
  }
  v19 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("interface"));
  if (v19)
  {
    v20 = CFStringGetTypeID();
    if (CFGetTypeID(v19) != v20 || !CFStringGetLength(v19))
      goto LABEL_52;
  }
  v21 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ResolverBypass"));
  if (v21)
  {
    v22 = CFBooleanGetTypeID();
    if (CFGetTypeID(v21) != v22)
      goto LABEL_52;
  }
  v23 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("SourceAppAuditToken"));
  if (v23)
  {
    v24 = CFDataGetTypeID();
    if (CFGetTypeID(v23) != v24 || CFDataGetLength((CFDataRef)v23) != 32)
      goto LABEL_52;
  }
  v25 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("SourceAppBundleIdentifier"));
  if (v25)
  {
    v26 = CFStringGetTypeID();
    if (CFGetTypeID(v25) != v26 || !CFStringGetLength(v25))
      goto LABEL_52;
  }
  if (!Value)
  {
    if (v14)
    {
      if ((unint64_t)BytePtr | (unint64_t)v18)
      {
LABEL_52:
        _SCErrorSet(1002);
        return 0;
      }
      v29 = (const __SCNetworkReachability *)__SCNetworkReachabilityCreateWithPTR(v14);
      goto LABEL_46;
    }
    if (BytePtr && v18)
    {
      v30 = BytePtr;
      v31 = v18;
    }
    else
    {
      if (v18)
      {
        v29 = SCNetworkReachabilityCreateWithAddress(0, v18);
        goto LABEL_46;
      }
      if (!BytePtr)
        goto LABEL_52;
      v30 = BytePtr;
      v31 = 0;
    }
    v29 = SCNetworkReachabilityCreateWithAddressPair(0, v30, v31);
LABEL_46:
    v28 = v29;
    goto LABEL_47;
  }
  if (BytePtr || v18 || v14)
    goto LABEL_52;
  v27 = _SC_cfstring_to_cstring(Value, 0, 0, 0x8000100u);
  v28 = SCNetworkReachabilityCreateWithName(a1, (const char *)v27);
  CFAllocatorDeallocate(0, v27);
LABEL_47:
  if (v28)
  {
    if (v19)
    {
      if (!_SC_cfstring_to_cstring(v19, (UInt8 *)v67, 16, 0x600u) || (v32 = if_nametoindex(v67)) == 0)
      {
        CFRelease(v28);
        goto LABEL_52;
      }
    }
    else
    {
      v32 = 0;
    }
    if (!*((_QWORD *)v28 + 29))
      *((_QWORD *)v28 + 29) = nw_parameters_create();
    if (v32)
    {
      v34 = nw_interface_create_with_index();
      nw_parameters_require_interface(*((nw_parameters_t *)v28 + 29), v34);
      nw_release(v34);
      v35 = 1;
    }
    else
    {
      v35 = 0;
    }
    if (v21)
    {
      *((_BYTE *)v28 + 192) = CFBooleanGetValue((CFBooleanRef)v21);
      v35 = 1;
    }
    if (v23)
    {
      *(_OWORD *)buffer = 0u;
      v66 = 0u;
      v69.length = CFDataGetLength((CFDataRef)v23);
      v69.location = 0;
      CFDataGetBytes((CFDataRef)v23, v69, buffer);
      v64[0] = *(_OWORD *)buffer;
      v64[1] = v66;
      nw_parameters_set_source_application();
    }
    else if (v25)
    {
      v50 = _SC_cfstring_to_cstring(v25, 0, 0, 0x8000100u);
      if (v50)
      {
        v51 = v50;
        nw_parameters_set_source_application_by_bundle_id();
        CFAllocatorDeallocate(0, v51);
      }
      else
      {
        v52 = __log_SCNetworkReachability_log;
        if (!__log_SCNetworkReachability_log)
        {
          v52 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
          __log_SCNetworkReachability_log = (uint64_t)v52;
        }
        v53 = _SC_syslog_os_log_mapping(4);
        if (__SC_log_enabled(4, v52, (os_log_type_t)v53))
        {
          v54 = _os_log_pack_size();
          v62 = (char *)v64
              - ((MEMORY[0x1E0C80A78](v54, v55, v56, v57, v58, v59, v60, v61) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v63 = _os_log_pack_fill();
          *(_DWORD *)v63 = 138412290;
          *(_QWORD *)(v63 + 4) = v25;
          __SC_log_send(4, (uint64_t)v52, v53, v62);
        }
      }
    }
    else if (!v35)
    {
      return v28;
    }
    v36 = *((int *)v28 + 20);
    if (v36 > 3)
      v37 = 0;
    else
      v37 = off_1E25D0EC0[v36];
    v38 = __log_SCNetworkReachability_log;
    if (!__log_SCNetworkReachability_log)
    {
      v38 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
      __log_SCNetworkReachability_log = (uint64_t)v38;
    }
    v39 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v38, (os_log_type_t)v39))
    {
      v40 = _os_log_pack_size();
      v48 = (char *)v64 - ((MEMORY[0x1E0C80A78](v40, v41, v42, v43, v44, v45, v46, v47) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v49 = _os_log_pack_fill();
      *(_DWORD *)v49 = 136315650;
      *(_QWORD *)(v49 + 4) = (char *)v28 + 193;
      *(_WORD *)(v49 + 12) = 2080;
      *(_QWORD *)(v49 + 14) = v37;
      *(_WORD *)(v49 + 22) = 2112;
      *(_QWORD *)(v49 + 24) = v28;
      __SC_log_send(7, (uint64_t)v38, v39, v48);
    }
  }
  return v28;
}

char *__SCNetworkReachabilityCreateWithPTR(unsigned __int8 *a1)
{
  unsigned __int8 *v1;
  const sockaddr *v2;
  char *Private;
  char *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v1 = is_valid_address(a1);
  if (v1)
  {
    v2 = (const sockaddr *)v1;
    Private = __SCNetworkReachabilityCreatePrivate();
    v4 = Private;
    if (Private)
    {
      *((_DWORD *)Private + 20) = 3;
      *((_QWORD *)Private + 13) = nw_endpoint_create_address(v2);
      *((_QWORD *)v4 + 29) = nw_parameters_create();
      nw_parameters_set_resolve_ptr();
      v5 = __log_SCNetworkReachability_log;
      if (!__log_SCNetworkReachability_log)
      {
        v5 = os_log_create("com.apple.SystemConfiguration", "SCNetworkReachability");
        __log_SCNetworkReachability_log = (uint64_t)v5;
      }
      v6 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v5, (os_log_type_t)v6))
      {
        v7 = _os_log_pack_size();
        v15 = (char *)v18 - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v16 = _os_log_pack_fill();
        *(_DWORD *)v16 = 136315650;
        *(_QWORD *)(v16 + 4) = v4 + 193;
        *(_WORD *)(v16 + 12) = 2080;
        *(_QWORD *)(v16 + 14) = "create w/ptr";
        *(_WORD *)(v16 + 22) = 2112;
        *(_QWORD *)(v16 + 24) = v4;
        __SC_log_send(7, (uint64_t)v5, v6, v15);
      }
    }
  }
  else
  {
    _SCErrorSet(1002);
    return 0;
  }
  return v4;
}

CFTypeID SCNetworkReachabilityGetTypeID(void)
{
  if (__SCNetworkReachabilityInitialize_initialized != -1)
    dispatch_once(&__SCNetworkReachabilityInitialize_initialized, &__block_literal_global_10);
  return __kSCNetworkReachabilityTypeID;
}

CFMutableArrayRef SCNetworkReachabilityCopyResolvedAddress(char *cf, _DWORD *a2)
{
  uint64_t v4;
  CFMutableArrayRef Mutable;
  int v6;

  if (__SCNetworkReachabilityInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkReachabilityInitialize_initialized, &__block_literal_global_10);
    if (cf)
      goto LABEL_3;
LABEL_14:
    Mutable = 0;
    v6 = 1002;
    goto LABEL_15;
  }
  if (!cf)
    goto LABEL_14;
LABEL_3:
  v4 = __kSCNetworkReachabilityTypeID;
  if (CFGetTypeID(cf) != v4 || *((_DWORD *)cf + 20) < 2u)
    goto LABEL_14;
  if (a2)
    *a2 = 0;
  if (pthread_mutex_lock((pthread_mutex_t *)(cf + 16)))
    SCNetworkReachabilityCopyResolvedAddress_cold_2();
  if (nw_array_get_count())
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    nw_array_apply();
  }
  else
  {
    Mutable = 0;
  }
  v6 = pthread_mutex_unlock((pthread_mutex_t *)(cf + 16));
  if (v6)
    SCNetworkReachabilityCopyResolvedAddress_cold_1();
LABEL_15:
  _SCErrorSet(v6);
  return Mutable;
}

uint64_t SCNetworkReachabilityGetInterfaceIndex(char *cf)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  uint64_t interface_index;

  if (__SCNetworkReachabilityInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_13:
      _SCErrorSet(1002);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkReachabilityInitialize_initialized, &__block_literal_global_10);
    if (!cf)
      goto LABEL_13;
  }
  v2 = __kSCNetworkReachabilityTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_13;
  v3 = (pthread_mutex_t *)(cf + 16);
  if (pthread_mutex_lock((pthread_mutex_t *)(cf + 16)))
    SCNetworkReachabilityGetInterfaceIndex_cold_2();
  if ((__SCNetworkReachabilityGetFlagsFromPath((uint64_t)(cf + 193), (uint64_t)"GetInterfaceIndex", *((nw_path_t *)cf + 31), *((_DWORD *)cf + 20), 0, 0, cf[288], *((_DWORD *)cf + 73)) & 6) == 2)
  {
    if (cf[288])
      interface_index = *((unsigned int *)cf + 74);
    else
      interface_index = nw_path_get_interface_index();
  }
  else
  {
    interface_index = 0xFFFFFFFFLL;
  }
  if (pthread_mutex_unlock(v3))
    SCNetworkReachabilityGetInterfaceIndex_cold_1();
  return interface_index;
}

CFStringRef reachRLSCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<SCNetworkReachability RLS> {target = %p}"), a1);
}

uint64_t _SC_checkResolverReachabilityByAddress(uint64_t a1, _DWORD *a2, char *a3)
{
  void *default_evaluator;
  NSObject *v6;
  char v7;

  default_evaluator = (void *)nw_path_create_default_evaluator();
  v6 = nw_path_evaluator_copy_path();
  if (nw_path_get_status(v6) == nw_path_status_unsatisfied)
  {
    if (a2)
      *a2 = 0;
    if (a3)
    {
      v7 = 0;
LABEL_10:
      *a3 = v7;
    }
  }
  else
  {
    if (a2)
      *a2 = 2;
    if (a3)
    {
      v7 = 1;
      goto LABEL_10;
    }
  }
  nw_release(default_evaluator);
  nw_release(v6);
  return 1;
}

CFStringRef SCDynamicStoreKeyCreateProxies(CFAllocatorRef allocator)
{
  return SCDynamicStoreKeyCreateNetworkGlobalEntity(allocator, CFSTR("State:"), CFSTR("Proxies"));
}

CFDataRef SCNetworkProxiesCreateProxyAgentData(void *a1)
{
  CFTypeID TypeID;
  CFArrayRef v3;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  CFDataRef v17;
  void *values[2];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  v17 = 0;
  values[0] = a1;
  TypeID = CFDictionaryGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID)
  {
    v3 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x1E0C9B378]);
    _SCSerialize(v3, &v17, 0, 0);
    CFRelease(v3);
    return v17;
  }
  else
  {
    v5 = _SC_LOG_DEFAULT();
    v6 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v5, (os_log_type_t)v6))
    {
      v7 = _os_log_pack_size();
      v15 = (char *)&v16 - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(3, (uint64_t)v5, v6, v15);
    }
    _SCErrorSet(1002);
    return 0;
  }
}

CFArrayRef SCNetworkProxiesCopyMatchingWithOptions(const void *a1, const __CFDictionary *a2)
{
  return _SCNetworkProxiesCopyMatchingInternal(a1, 0, 0, a2);
}

void normalize_services_proxy(const void *a1, uint64_t a2, __CFDictionary *a3)
{
  const void *v5;

  v5 = (const void *)__SCNetworkProxiesCopyNormalized(a2);
  CFDictionarySetValue(a3, a1, v5);
  CFRelease(v5);
}

void normalize_supplemental_proxy(uint64_t a1, __CFArray *a2)
{
  const void *v3;

  v3 = (const void *)__SCNetworkProxiesCopyNormalized(a1);
  CFArrayAppendValue(a2, v3);
  CFRelease(v3);
}

Boolean DHCPClientPreferencesSetApplicationOptions(CFStringRef applicationID, const UInt8 *options, CFIndex count)
{
  CFStringRef v5;
  const __CFString *v6;
  const __SCPreferences *v7;
  const __SCPreferences *v8;
  const __CFDictionary *Value;
  __CFDictionary *MutableCopy;
  int v11;
  void *v12;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v14;
  uint64_t v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFIndex v18;
  CFIndex v19;
  CFIndex v20;
  const void *ValueAtIndex;
  int valuePtr;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (applicationID && (v5 = CFStringCreateWithFormat(0, 0, CFSTR("/Application/%@"), applicationID)) != 0)
  {
    v6 = v5;
    v7 = SCPreferencesCreate(0, CFSTR("DHCPClientSetAppReqParams"), CFSTR("DHCPClient.xml"));
    if (!v7)
    {
      LOBYTE(v11) = 0;
      v12 = (void *)v6;
LABEL_35:
      CFRelease(v12);
      return v11;
    }
    v8 = v7;
    Value = SCPreferencesPathGetValue(v7, v6);
    if (Value)
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
    else
      MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v12 = MutableCopy;
    if (!MutableCopy)
      goto LABEL_33;
    if (options && count >= 1)
    {
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      if (!Mutable)
        goto LABEL_33;
      v14 = Mutable;
      v15 = 0;
      while (1)
      {
        if (options[v15] && options[v15] != 255)
        {
          valuePtr = options[v15];
          v16 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          if (!v16)
          {
            CFRelease(v14);
            goto LABEL_33;
          }
          v17 = v16;
          v18 = CFArrayGetCount(v14);
          if (v18 < 1)
          {
LABEL_21:
            CFArrayAppendValue(v14, v17);
          }
          else
          {
            v19 = v18;
            v20 = 0;
            while (1)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v14, v20);
              if (CFEqual(ValueAtIndex, v17))
                break;
              if (v19 == ++v20)
                goto LABEL_21;
            }
          }
          CFRelease(v17);
        }
        if (++v15 == count)
        {
          CFDictionarySetValue((CFMutableDictionaryRef)v12, CFSTR("DHCPRequestedParameterList"), v14);
          CFRelease(v14);
          goto LABEL_26;
        }
      }
    }
    CFDictionaryRemoveValue(MutableCopy, CFSTR("DHCPRequestedParameterList"));
LABEL_26:
    if (SCPreferencesLock(v8, 1u))
    {
      if (SCPreferencesPathSetValue(v8, v6, (CFDictionaryRef)v12))
      {
        v11 = SCPreferencesCommitChanges(v8);
        if (v11)
          SCPreferencesApplyChanges(v8);
      }
      else
      {
        LOBYTE(v11) = 0;
      }
      SCPreferencesUnlock(v8);
    }
    else
    {
LABEL_33:
      LOBYTE(v11) = 0;
    }
    CFRelease(v8);
    CFRelease(v6);
    if (v12)
      goto LABEL_35;
  }
  else
  {
    LOBYTE(v11) = 0;
  }
  return v11;
}

UInt8 *__cdecl DHCPClientPreferencesCopyApplicationOptions(CFStringRef applicationID, CFIndex *count)
{
  CFStringRef v3;
  const __CFString *v4;
  const __SCPreferences *v5;
  const __SCPreferences *v6;
  const __CFDictionary *Value;
  const __CFArray *v8;
  CFTypeID TypeID;
  size_t v10;
  CFIndex v11;
  UInt8 *v12;
  UInt8 *v13;
  CFIndex v14;
  CFIndex i;
  const __CFNumber *ValueAtIndex;
  CFTypeID v17;
  int valuePtr;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (applicationID)
  {
    v3 = CFStringCreateWithFormat(0, 0, CFSTR("/Application/%@"), applicationID);
    if (v3)
    {
      v4 = v3;
      v5 = SCPreferencesCreate(0, CFSTR("DHCPClientCopyAppReqParams"), CFSTR("DHCPClient.xml"));
      if (!v5)
      {
        v13 = 0;
LABEL_25:
        CFRelease(v4);
        return v13;
      }
      v6 = v5;
      Value = SCPreferencesPathGetValue(v5, v4);
      if (Value)
      {
        v8 = (const __CFArray *)CFDictionaryGetValue(Value, CFSTR("DHCPRequestedParameterList"));
        TypeID = CFArrayGetTypeID();
        if (v8)
        {
          if (CFGetTypeID(v8) == TypeID)
          {
            v10 = CFArrayGetCount(v8);
            v11 = v10;
            if (!v10 || (v12 = (UInt8 *)malloc_type_malloc(v10, 0x32FDCE9uLL)) == 0)
            {
              v13 = 0;
              *count = v11;
LABEL_24:
              CFRelease(v6);
              goto LABEL_25;
            }
            v13 = v12;
            if (v11 < 1)
            {
              *count = 0;
            }
            else
            {
              v14 = 0;
              for (i = 0; i != v11; ++i)
              {
                ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v8, i);
                v17 = CFNumberGetTypeID();
                if (ValueAtIndex)
                {
                  if (CFGetTypeID(ValueAtIndex) == v17)
                  {
                    valuePtr = 0;
                    if (CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr))
                      v13[v14++] = valuePtr;
                  }
                }
              }
              *count = v14;
              if (v14)
                goto LABEL_24;
            }
            free(v13);
          }
        }
      }
      v13 = 0;
      goto LABEL_24;
    }
  }
  return 0;
}

CFDictionaryRef SCDynamicStoreCopyDHCPInfo(SCDynamicStoreRef store, CFStringRef serviceID)
{
  const __CFString *Value;
  const __CFString *v4;
  const __CFString *NetworkServiceEntity;
  const __CFString *v6;
  const __CFDictionary *v7;
  CFTypeID TypeID;
  const __CFString *NetworkGlobalEntity;
  const __CFDictionary *v10;
  const __CFDictionary *v11;

  if (serviceID)
  {
    Value = serviceID;
    v4 = 0;
  }
  else
  {
    NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(0, CFSTR("State:"), CFSTR("IPv4"));
    if (!NetworkGlobalEntity)
      return 0;
    v4 = NetworkGlobalEntity;
    v10 = (const __CFDictionary *)SCDynamicStoreCopyValue(store, NetworkGlobalEntity);
    if (!v10)
    {
      v7 = 0;
      goto LABEL_18;
    }
    v11 = v10;
    Value = (const __CFString *)CFDictionaryGetValue(v10, CFSTR("PrimaryService"));
    CFRelease(v4);
    if (!Value)
    {
      v7 = 0;
      v4 = (const __CFString *)v11;
      goto LABEL_18;
    }
    v4 = (const __CFString *)v11;
  }
  NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), Value, CFSTR("DHCP"));
  if (!NetworkServiceEntity)
  {
    v7 = 0;
    if (!v4)
      return v7;
    goto LABEL_18;
  }
  v6 = NetworkServiceEntity;
  v7 = (const __CFDictionary *)SCDynamicStoreCopyValue(store, NetworkServiceEntity);
  if (v7)
  {
    TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(v7) != TypeID)
    {
      CFRelease(v7);
      v7 = 0;
    }
  }
  CFRelease(v6);
  if (v4)
LABEL_18:
    CFRelease(v4);
  return v7;
}

CFDataRef DHCPInfoGetOptionData(CFDictionaryRef info, UInt8 code)
{
  CFStringRef v3;
  CFStringRef v4;
  const void *Value;
  CFTypeID TypeID;

  v3 = CFStringCreateWithFormat(0, 0, CFSTR("Option_%d"), code);
  if (!v3)
    return 0;
  v4 = v3;
  Value = CFDictionaryGetValue(info, v3);
  TypeID = CFDataGetTypeID();
  if (Value && CFGetTypeID(Value) != TypeID)
    Value = 0;
  CFRelease(v4);
  return (CFDataRef)Value;
}

CFDateRef DHCPInfoGetLeaseStartTime(CFDictionaryRef info)
{
  return (CFDateRef)CFDictionaryGetValue(info, CFSTR("LeaseStartTime"));
}

CFDateRef DHCPInfoGetLeaseExpirationTime(CFDictionaryRef info)
{
  return (CFDateRef)CFDictionaryGetValue(info, CFSTR("LeaseExpirationTime"));
}

uint64_t __SCNetworkInterfaceCreateCapabilities(const void *a1, unsigned int a2, const __CFDictionary *a3)
{
  CFTypeID TypeID;
  const __CFString *BSDName;
  unsigned int *v8;
  int Capabilities;
  uint64_t v10;
  __CFString ***v11;
  int v12;
  CFNumberRef v13;
  CFTypeID v14;
  int v15;
  int v16;
  int v17;
  CFNumberRef number;
  int valuePtr;
  unsigned int v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v21 = a2;
  v22 = 0;
  TypeID = SCNetworkInterfaceGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID && (BSDName = SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)a1)) != 0)
  {
    if (a2 == -1)
      v8 = &v21;
    else
      v8 = 0;
    Capabilities = __getCapabilities(BSDName, v8, &v22);
    if (a3 && Capabilities && v22)
    {
      v10 = 0;
      v11 = &capabilityMappings;
      do
      {
        valuePtr = 0;
        number = 0;
        v12 = *((_DWORD *)v11 + 3);
        if ((v12 & v22) != 0 && ((0xDCuLL >> v10) & 1) == 0)
        {
          if (CFDictionaryGetValueIfPresent(a3, **v11, (const void **)&number))
          {
            v13 = number;
            v14 = CFNumberGetTypeID();
            if (v13)
            {
              if (CFGetTypeID(v13) == v14 && CFNumberGetValue(number, kCFNumberIntType, &valuePtr))
              {
                if (valuePtr)
                {
                  v15 = v22;
                  v16 = v21 | v22 & v12;
                  v17 = ~v12;
                }
                else
                {
                  v17 = ~v12;
                  v16 = v21 & ~v12;
                  v15 = v22;
                }
                v21 = v16;
                v22 = v15 & v17;
              }
            }
          }
        }
        ++v10;
        v11 += 2;
      }
      while (v10 != 10);
    }
  }
  else
  {
    _SCErrorSet(1002);
  }
  return v21;
}

uint64_t __getCapabilities(const __CFString *a1, _DWORD *a2, _DWORD *a3)
{
  int v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  int *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  int *v32;
  char *v33;
  int *v35;
  int v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  int *v49;
  char *v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = 0u;
  v52 = 0u;
  if (!_SC_cfstring_to_cstring(a1, (UInt8 *)&v51, 16, 0x600u))
  {
    v8 = __log_SCNetworkConfiguration();
    v9 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v8, (os_log_type_t)v9))
    {
      v10 = _os_log_pack_size();
      v18 = (char *)&v51 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v8, v9, v18);
    }
    _SCErrorSet(1002);
    return 0;
  }
  v5 = socket(2, 2, 0);
  if (v5 == -1)
  {
    v19 = __error();
    _SCErrorSet(*v19);
    v20 = __log_SCNetworkConfiguration();
    v21 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v20, (os_log_type_t)v21))
    {
      v22 = _os_log_pack_size();
      v30 = (char *)&v51 - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v31 = _os_log_pack_fill();
      v32 = __error();
      v33 = strerror(*v32);
      *(_DWORD *)v31 = 136315138;
      *(_QWORD *)(v31 + 4) = v33;
      __SC_log_send(3, (uint64_t)v20, v21, v30);
    }
    return 0;
  }
  v6 = v5;
  if (ioctl(v5, 0xC020695BuLL, &v51) == -1)
  {
    v35 = __error();
    _SCErrorSet(*v35);
    v7 = 0;
    v36 = *__error();
    if (v36 != 6 && v36 != 16)
    {
      v37 = __log_SCNetworkConfiguration();
      v38 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v37, (os_log_type_t)v38))
      {
        v39 = _os_log_pack_size();
        v47 = (char *)&v51 - ((MEMORY[0x1E0C80A78](v39, v40, v41, v42, v43, v44, v45, v46) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v48 = _os_log_pack_fill();
        v49 = __error();
        v50 = strerror(*v49);
        *(_DWORD *)v48 = 136315138;
        *(_QWORD *)(v48 + 4) = v50;
        __SC_log_send(5, (uint64_t)v37, v38, v47);
      }
      v7 = 0;
    }
  }
  else
  {
    if (a2)
      *a2 = DWORD1(v52);
    if (a3)
      *a3 = v52;
    v7 = 1;
  }
  close(v6);
  return v7;
}

CFNumberRef SCNetworkInterfaceCopyCapability(const void *a1, CFMutableDictionaryRef Mutable)
{
  CFTypeID TypeID;
  const __CFString *BSDName;
  uint64_t v6;
  uint64_t v7;
  int v8;
  const CFDictionaryKeyCallBacks *v9;
  const CFDictionaryValueCallBacks *v10;
  int v11;
  CFNumberRef v12;
  int v13;
  _BOOL4 valuePtr;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v16[0] = 0;
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID || (BSDName = SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)a1)) == 0)
  {
LABEL_19:
    _SCErrorSet(1002);
    return 0;
  }
  valuePtr = 0;
  if (!__getCapabilities(BSDName, (_DWORD *)v16 + 1, v16))
    return 0;
  if (Mutable)
  {
    v6 = 0;
    while (!CFEqual(Mutable, *(&capabilityMappings)[v6]))
    {
      v6 += 2;
      if (v6 == 20)
        goto LABEL_19;
    }
    v13 = HIDWORD((&capabilityMappings)[v6 + 1]);
    if ((v13 & ~LODWORD(v16[0])) == 0)
    {
      valuePtr = (v13 & ~HIDWORD(v16[0])) == 0;
      return CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    }
    goto LABEL_19;
  }
  v7 = 0;
  v8 = v16[0];
  v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  do
  {
    v11 = HIDWORD((&capabilityMappings)[v7 + 1]);
    if ((v11 & ~v8) == 0)
    {
      if (!Mutable)
        Mutable = CFDictionaryCreateMutable(0, 0, v9, v10);
      valuePtr = (v11 & ~HIDWORD(v16[0])) == 0;
      v12 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      CFDictionarySetValue(Mutable, *(&capabilityMappings)[v7], v12);
      CFRelease(v12);
      v8 = v16[0] & ~v11;
      LODWORD(v16[0]) = v8;
    }
    v7 += 2;
  }
  while (v7 != 20);
  return Mutable;
}

uint64_t SCNetworkInterfaceSetCapability(const void *a1, const void *a2, const void *a3)
{
  CFTypeID TypeID;
  CFStringRef BSDName;
  const __CFString *v8;
  uint64_t v9;
  __CFString ***v10;
  CFTypeID v11;
  const __CFDictionary *Configuration;
  __CFDictionary *MutableCopy;
  uint64_t v14;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!a1)
    goto LABEL_15;
  if (CFGetTypeID(a1) != TypeID)
    goto LABEL_15;
  BSDName = SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)a1);
  if (!BSDName)
    goto LABEL_15;
  v8 = BSDName;
  v9 = 0;
  v10 = &capabilityMappings;
  while (!CFEqual(a2, **v10))
  {
    ++v9;
    v10 += 2;
    if (v9 == 10)
      goto LABEL_15;
  }
  if (((0xDCuLL >> v9) & 1) != 0)
    goto LABEL_15;
  if (a3)
  {
    v11 = CFNumberGetTypeID();
    if (CFGetTypeID(a3) != v11)
      goto LABEL_15;
  }
  if (!__getCapabilities(v8, 0, &v16))
    return 0;
  if ((*((_DWORD *)v10 + 3) & v16) == 0)
  {
LABEL_15:
    _SCErrorSet(1002);
    return 0;
  }
  Configuration = SCNetworkInterfaceGetConfiguration((SCNetworkInterfaceRef)a1);
  if (Configuration)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Configuration);
    CFDictionaryRemoveValue(MutableCopy, CFSTR("__INACTIVE__"));
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  if (a3)
  {
    CFDictionarySetValue(MutableCopy, a2, a3);
  }
  else
  {
    CFDictionaryRemoveValue(MutableCopy, a2);
    if (!CFDictionaryGetCount(MutableCopy))
    {
      CFRelease(MutableCopy);
      return SCNetworkInterfaceSetConfiguration((SCNetworkInterfaceRef)a1, 0);
    }
  }
  v14 = SCNetworkInterfaceSetConfiguration((SCNetworkInterfaceRef)a1, MutableCopy);
  if (MutableCopy)
    CFRelease(MutableCopy);
  return v14;
}

uint64_t __SCNetworkInterfaceCreateMediaOptions(const void *a1, const __CFDictionary *a2)
{
  CFTypeID TypeID;
  const __CFString *BSDName;
  char *v6;
  int v7;
  char v8;
  int *v9;
  int *v10;
  uint64_t v11;
  const __CFString *Value;
  CFTypeID v14;
  UInt8 *v15;
  char *v16;
  uint64_t i;
  const char *v18;
  char *v19;
  int v20;
  const void *v21;
  CFTypeID v22;
  CFIndex Count;
  CFIndex v24;
  CFIndex v25;
  const __CFString *ValueAtIndex;
  CFTypeID v27;
  UInt8 *v28;
  char *v29;
  uint64_t v30;
  int *v31;
  const char *v32;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID || (BSDName = SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)a1)) == 0)
  {
    _SCErrorSet(1002);
    return 0xFFFFFFFFLL;
  }
  v6 = __copyMediaList(BSDName, 0);
  if (!v6)
    return 0xFFFFFFFFLL;
  if (*((int *)v6 + 8) <= 0)
  {
    __freeMediaList(v6);
    return 0xFFFFFFFFLL;
  }
  v7 = **(_DWORD **)(v6 + 36) & 0xE0;
  __freeMediaList(v6);
  if (v7 == 128)
  {
    v8 = 0;
    v9 = &ifm_subtype_ieee80211_descriptions;
    v10 = &ifm_subtype_ieee80211_option_descriptions;
  }
  else if (v7 == 32)
  {
    v8 = 0;
    v9 = &ifm_subtype_ethernet_descriptions;
    v10 = &ifm_subtype_ethernet_option_descriptions;
  }
  else
  {
    v10 = 0;
    v9 = 0;
    v8 = 1;
  }
  Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("MediaSubType"));
  v14 = CFStringGetTypeID();
  if (!Value)
    return 0xFFFFFFFFLL;
  if (CFGetTypeID(Value) != v14)
    return 0xFFFFFFFFLL;
  v15 = _SC_cfstring_to_cstring(Value, 0, 0, 0x600u);
  if (!v15)
    return 0xFFFFFFFFLL;
  v16 = (char *)v15;
  for (i = 0; i != 12; i += 4)
  {
    if (!strcasecmp(v16, *(const char **)&ifm_subtype_shared_descriptions[i + 2]))
    {
      v9 = &ifm_subtype_shared_descriptions[i];
      goto LABEL_28;
    }
  }
  if ((v8 & 1) != 0 || (v18 = (const char *)*((_QWORD *)v9 + 1)) == 0)
  {
LABEL_25:
    v19 = v16;
LABEL_26:
    CFAllocatorDeallocate(0, v19);
    return 0xFFFFFFFFLL;
  }
  while (strcasecmp(v16, v18))
  {
    v18 = (const char *)*((_QWORD *)v9 + 3);
    v9 += 4;
    if (!v18)
      goto LABEL_25;
  }
LABEL_28:
  v20 = *v9;
  CFAllocatorDeallocate(0, v16);
  v21 = CFDictionaryGetValue(a2, CFSTR("MediaOptions"));
  v22 = CFArrayGetTypeID();
  if (!v21 || CFGetTypeID(v21) != v22)
    return 0xFFFFFFFFLL;
  v11 = v20 | v7;
  Count = CFArrayGetCount((CFArrayRef)v21);
  if (Count < 1)
    return v11;
  v24 = Count;
  v25 = 0;
  while (2)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v21, v25);
    v27 = CFStringGetTypeID();
    if (!ValueAtIndex)
      return 0xFFFFFFFFLL;
    if (CFGetTypeID(ValueAtIndex) != v27)
      return 0xFFFFFFFFLL;
    v28 = _SC_cfstring_to_cstring(ValueAtIndex, 0, 0, 0x600u);
    if (!v28)
      return 0xFFFFFFFFLL;
    v29 = (char *)v28;
    v30 = 0;
    while (1)
    {
      v31 = &ifm_shared_option_descriptions[v30];
      if (!strcasecmp(v29, *(const char **)&ifm_shared_option_descriptions[v30 + 2]))
        break;
      v30 += 4;
      if (v30 == 32)
      {
        if ((v8 & 1) != 0 || (v32 = (const char *)*((_QWORD *)v10 + 1), v31 = v10, !v32))
        {
LABEL_45:
          v19 = v29;
          goto LABEL_26;
        }
        while (strcasecmp(v29, v32))
        {
          v32 = (const char *)*((_QWORD *)v31 + 3);
          v31 += 4;
          if (!v32)
            goto LABEL_45;
        }
        break;
      }
    }
    v11 = *v31 | v11;
    CFAllocatorDeallocate(0, v29);
    if (++v25 != v24)
      continue;
    return v11;
  }
}

char *__copyMediaList(const __CFString *a1, char *a2)
{
  char *v4;
  int v5;
  int v6;
  uint64_t v7;
  char v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  char *v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  int *v44;
  char *v45;
  _QWORD v47[2];

  v47[1] = *MEMORY[0x1E0C80C00];
  v4 = (char *)CFAllocatorAllocate(0, 44, 0);
  *(_OWORD *)v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *(_OWORD *)(v4 + 28) = 0u;
  if (!_SC_cfstring_to_cstring(a1, (UInt8 *)v4, 16, 0x600u))
  {
    v9 = __log_SCNetworkConfiguration();
    v10 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v9, (os_log_type_t)v10))
      goto LABEL_16;
    v11 = _os_log_pack_size();
    v19 = (char *)v47 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    v20 = 5;
LABEL_12:
    __SC_log_send(v20, (uint64_t)v9, v10, v19);
    goto LABEL_16;
  }
  v5 = socket(2, 2, 0);
  if (v5 == -1)
  {
    v9 = __log_SCNetworkConfiguration();
    v10 = _SC_syslog_os_log_mapping(3);
    if (!__SC_log_enabled(3, v9, (os_log_type_t)v10))
      goto LABEL_16;
    v21 = _os_log_pack_size();
    v19 = (char *)v47 - ((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v29 = _os_log_pack_fill();
    v30 = __error();
    v31 = strerror(*v30);
    *(_DWORD *)v29 = 136315138;
    *(_QWORD *)(v29 + 4) = v31;
    v20 = 3;
    goto LABEL_12;
  }
  v6 = v5;
  if (ioctl(v5, 0xC02C6948uLL, v4) != -1)
  {
    v7 = *((unsigned int *)v4 + 8);
    if ((int)v7 < 1
      || (*(_QWORD *)(v4 + 36) = CFAllocatorAllocate(0, 4 * v7, 0), ioctl(v6, 0xC02C6948uLL, v4) != -1))
    {
      close(v6);
      v8 = 1;
      if (!a2)
        return v4;
      goto LABEL_17;
    }
    v32 = __log_SCNetworkConfiguration();
    v33 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v32, (os_log_type_t)v33))
    {
      v34 = _os_log_pack_size();
      v42 = (char *)v47 - ((MEMORY[0x1E0C80A78](v34, v35, v36, v37, v38, v39, v40, v41) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v43 = _os_log_pack_fill();
      v44 = __error();
      v45 = strerror(*v44);
      *(_DWORD *)v43 = 136315138;
      *(_QWORD *)(v43 + 4) = v45;
      __SC_log_send(5, (uint64_t)v32, v33, v42);
    }
  }
  close(v6);
LABEL_16:
  __freeMediaList(v4);
  _SCErrorSet(1001);
  v8 = 0;
  v4 = 0;
  if (a2)
LABEL_17:
    *a2 = v8;
  return v4;
}

void __freeMediaList(char *ptr)
{
  void *v2;

  v2 = *(void **)(ptr + 36);
  if (v2)
    CFAllocatorDeallocate(0, v2);
  CFAllocatorDeallocate(0, ptr);
}

Boolean SCNetworkInterfaceCopyMediaOptions(SCNetworkInterfaceRef interface, CFDictionaryRef *current, CFDictionaryRef *active, CFArrayRef *available, Boolean filter)
{
  int v5;
  CFTypeID TypeID;
  const __CFString *BSDName;
  char *v12;
  char *v13;
  const __CFArray *Mutable;
  uint64_t v15;
  __CFDictionary *MediaDictionary;
  __CFDictionary *v17;
  int v18;
  const __CFDictionary *v19;
  CFRange v21;

  v5 = filter;
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!interface || CFGetTypeID(interface) != TypeID || (BSDName = SCNetworkInterfaceGetBSDName(interface)) == 0)
  {
    _SCErrorSet(1002);
    LOBYTE(v12) = 0;
    return v12;
  }
  v12 = __copyMediaList(BSDName, 0);
  if (v12)
  {
    v13 = v12;
    if (active)
      *active = 0;
    if (current)
      *current = 0;
    if (available)
    {
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      if (*((int *)v13 + 8) >= 1)
      {
        v15 = 0;
        do
        {
          MediaDictionary = __createMediaDictionary(*(_DWORD *)(*(_QWORD *)(v13 + 36) + 4 * v15), v5);
          if (MediaDictionary)
          {
            v17 = MediaDictionary;
            if (active && !*active && *((_DWORD *)v13 + 7) == *(_DWORD *)(*(_QWORD *)(v13 + 36) + 4 * v15))
              *active = (CFDictionaryRef)CFRetain(MediaDictionary);
            if (current && !*current && *((_DWORD *)v13 + 4) == *(_DWORD *)(*(_QWORD *)(v13 + 36) + 4 * v15))
              *current = (CFDictionaryRef)CFRetain(v17);
            v21.length = CFArrayGetCount(Mutable);
            v21.location = 0;
            if (!CFArrayContainsValue(Mutable, v21, v17))
              CFArrayAppendValue(Mutable, v17);
            CFRelease(v17);
          }
          ++v15;
        }
        while (v15 < *((int *)v13 + 8));
      }
      *available = Mutable;
    }
    if (active && !*active)
      *active = __createMediaDictionary(*((_DWORD *)v13 + 7), 0);
    if (!current || *current)
      goto LABEL_40;
    if (active)
    {
      v18 = *((_DWORD *)v13 + 4);
      if (*((_DWORD *)v13 + 7) == v18)
      {
        if (!*active)
        {
LABEL_40:
          __freeMediaList(v13);
          LOBYTE(v12) = 1;
          return v12;
        }
        v19 = (const __CFDictionary *)CFRetain(*active);
LABEL_39:
        *current = v19;
        goto LABEL_40;
      }
    }
    else
    {
      v18 = *((_DWORD *)v13 + 4);
    }
    v19 = __createMediaDictionary(v18, 0);
    goto LABEL_39;
  }
  return v12;
}

__CFDictionary *__createMediaDictionary(int a1, int a2)
{
  int v2;
  int *v4;
  int *v5;
  __CFDictionary *Mutable;
  uint64_t v7;
  int v8;
  CFStringRef v9;
  const char *v10;
  __CFArray *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  CFStringRef v15;
  const char **v16;
  int v17;
  CFStringRef v18;

  v2 = a1;
  if (a2)
  {
    if ((a1 & 0xF001F) == 2 || (a1 & 0x8000000) != 0)
      return 0;
  }
  if ((a1 & 0xE0) == 0x20)
  {
    v4 = &ifm_subtype_ethernet_descriptions;
    v5 = &ifm_subtype_ethernet_option_descriptions;
  }
  else
  {
    if ((a1 & 0xE0) != 0x80)
      return 0;
    v4 = &ifm_subtype_ieee80211_descriptions;
    v5 = &ifm_subtype_ieee80211_option_descriptions;
  }
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = 0;
  v8 = v2 & 0xF001F;
  while (v8 != ifm_subtype_shared_descriptions[v7])
  {
    v7 += 4;
    if (v7 == 12)
      goto LABEL_17;
  }
  v9 = CFStringCreateWithCString(0, *(const char **)&ifm_subtype_shared_descriptions[v7 + 2], 0x600u);
  if (v9)
  {
LABEL_22:
    CFDictionaryAddValue(Mutable, CFSTR("MediaSubType"), v9);
    CFRelease(v9);
    goto LABEL_23;
  }
LABEL_17:
  v10 = (const char *)*((_QWORD *)v4 + 1);
  if (v10)
  {
    while (v8 != *v4)
    {
      v10 = (const char *)*((_QWORD *)v4 + 3);
      v4 += 4;
      if (!v10)
        goto LABEL_23;
    }
    v9 = CFStringCreateWithCString(0, v10, 0x600u);
    if (v9)
      goto LABEL_22;
  }
LABEL_23:
  v11 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if ((v2 & 0xFF0FF00) != 0)
  {
    v12 = 0;
    while (1)
    {
      v13 = v12 + 16;
      if (v12 == 128)
        break;
      v14 = *(int *)((char *)ifm_shared_option_descriptions + v12);
      if ((v14 & v2) != 0)
      {
        v15 = CFStringCreateWithCString(0, *(const char **)((char *)&ifm_shared_option_descriptions[2] + v12), 0x600u);
        CFArrayAppendValue(v11, v15);
        CFRelease(v15);
        v2 &= ~v14;
      }
      v12 = v13;
      if ((v2 & 0xFF0FF00) == 0)
        goto LABEL_36;
    }
    if ((v2 & 0xFF0FF00) != 0)
    {
      v16 = (const char **)(v5 + 2);
      do
      {
        if (!*v16)
          break;
        v17 = *((_DWORD *)v16 - 2);
        if ((v17 & v2) != 0)
        {
          v18 = CFStringCreateWithCString(0, *v16, 0x600u);
          CFArrayAppendValue(v11, v18);
          CFRelease(v18);
          v2 &= ~v17;
        }
        v16 += 2;
      }
      while ((v2 & 0xFF0FF00) != 0);
    }
  }
LABEL_36:
  CFDictionaryAddValue(Mutable, CFSTR("MediaOptions"), v11);
  CFRelease(v11);
  return Mutable;
}

CFArrayRef SCNetworkInterfaceCopyMediaSubTypes(CFArrayRef available)
{
  CFTypeID TypeID;
  const __CFArray *Mutable;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  CFTypeID v8;
  const void *Value;
  CFTypeID v10;
  int v11;
  CFRange v13;

  TypeID = CFArrayGetTypeID();
  if (!available || CFGetTypeID(available) != TypeID)
  {
    v11 = 1002;
    goto LABEL_15;
  }
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  Count = CFArrayGetCount(available);
  if (Count >= 1)
  {
    v5 = Count;
    for (i = 0; i != v5; ++i)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(available, i);
      v8 = CFDictionaryGetTypeID();
      if (ValueAtIndex)
      {
        if (CFGetTypeID(ValueAtIndex) == v8)
        {
          Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaSubType"));
          v10 = CFStringGetTypeID();
          if (Value)
          {
            if (CFGetTypeID(Value) == v10)
            {
              v13.length = CFArrayGetCount(Mutable);
              v13.location = 0;
              if (!CFArrayContainsValue(Mutable, v13, Value))
                CFArrayAppendValue(Mutable, Value);
            }
          }
        }
      }
    }
  }
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    v11 = 0;
LABEL_15:
    _SCErrorSet(v11);
    return 0;
  }
  return Mutable;
}

CFArrayRef SCNetworkInterfaceCopyMediaSubTypeOptions(CFArrayRef available, CFStringRef subType)
{
  CFTypeID TypeID;
  const __CFArray *Mutable;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  CFTypeID v10;
  const void *Value;
  CFTypeID v12;
  const void *v13;
  CFTypeID v14;
  int v15;
  CFRange v17;

  TypeID = CFArrayGetTypeID();
  if (!available || CFGetTypeID(available) != TypeID)
  {
    v15 = 1002;
    goto LABEL_18;
  }
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  Count = CFArrayGetCount(available);
  if (Count >= 1)
  {
    v7 = Count;
    for (i = 0; i != v7; ++i)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(available, i);
      v10 = CFDictionaryGetTypeID();
      if (ValueAtIndex)
      {
        if (CFGetTypeID(ValueAtIndex) == v10)
        {
          Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaSubType"));
          v12 = CFStringGetTypeID();
          if (Value)
          {
            if (CFGetTypeID(Value) == v12)
            {
              if (CFEqual(subType, Value))
              {
                v13 = CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaOptions"));
                v14 = CFArrayGetTypeID();
                if (v13)
                {
                  if (CFGetTypeID(v13) == v14)
                  {
                    v17.length = CFArrayGetCount(Mutable);
                    v17.location = 0;
                    if (!CFArrayContainsValue(Mutable, v17, v13))
                      CFArrayAppendValue(Mutable, v13);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    v15 = 0;
LABEL_18:
    _SCErrorSet(v15);
    return 0;
  }
  return Mutable;
}

BOOL _SCNetworkInterfaceIsPhysicalEthernet(_DWORD *a1)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  const __CFString *BSDName;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  _SCErrorSet(0);
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
    goto LABEL_14;
  InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a1);
  if (!CFEqual(InterfaceType, CFSTR("Ethernet"))
    || _SCNetworkInterfaceIsHiddenConfiguration((unsigned __int8 *)a1)
    || _SCNetworkInterfaceIsHiddenInterface((unsigned __int8 *)a1)
    || _SCNetworkInterfaceIsTethered(a1)
    || _SCNetworkInterfaceIsBluetoothPAN(a1))
  {
    return 0;
  }
  BSDName = SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)a1);
  if (!BSDName)
  {
LABEL_14:
    _SCErrorSet(1002);
    return 0;
  }
  v5 = __copyMediaList(BSDName, &v11);
  if (v5)
  {
    v6 = v5;
    _SCErrorSet(0);
    v7 = 0;
    if ((*((_DWORD *)v6 + 4) & 0xE0) != 0x20)
    {
LABEL_24:
      __freeMediaList(v6);
      return v7;
    }
    v8 = *((unsigned int *)v6 + 8);
    if ((_DWORD)v8 == 1)
    {
      if ((**(_DWORD **)(v6 + 36) & 0xF001F) == 0)
        goto LABEL_22;
    }
    else if ((int)v8 < 1)
    {
LABEL_22:
      v7 = 0;
      goto LABEL_24;
    }
    v10 = *(_QWORD *)(v6 + 36);
    while ((*(_BYTE *)(v10 + 2) & 0x10) == 0)
    {
      v10 += 4;
      if (!--v8)
        goto LABEL_22;
    }
    v7 = 1;
    goto LABEL_24;
  }
  return v11 != 0;
}

Boolean SCNetworkInterfaceCopyMTU(SCNetworkInterfaceRef interface, int *mtu_cur, int *mtu_min, int *mtu_max)
{
  CFTypeID TypeID;
  const __CFString *BSDName;
  int v10;
  int v11;
  char v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  Boolean v24;
  int *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  int *v39;
  char *v40;
  int *v41;
  const __CFDictionary *v42;
  kern_return_t MatchingServices;
  io_registry_entry_t v44;
  io_object_t v45;
  const __CFNumber *CFProperty;
  const __CFNumber *v47;
  CFTypeID v48;
  const __CFNumber *v49;
  const __CFNumber *v50;
  CFTypeID v51;
  int v52;
  CFStringRef InterfaceType;
  const __CFArray *MemberInterfaces;
  const __CFArray *v55;
  CFIndex Count;
  CFIndex v57;
  int v58;
  CFIndex v59;
  const __SCNetworkInterface *ValueAtIndex;
  int v61;
  int valuePtr;
  io_registry_entry_t parent;
  io_iterator_t existing[2];
  char cStr[16];
  __int128 v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!interface || CFGetTypeID(interface) != TypeID || (BSDName = SCNetworkInterfaceGetBSDName(interface)) == 0)
  {
LABEL_15:
    _SCErrorSet(1002);
    return 0;
  }
  *(_OWORD *)cStr = 0u;
  v66 = 0u;
  if (!_SC_cfstring_to_cstring(BSDName, (UInt8 *)cStr, 16, 0x600u))
  {
    v13 = __log_SCNetworkConfiguration();
    v14 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v13, (os_log_type_t)v14))
    {
      v15 = _os_log_pack_size();
      v23 = (char *)&valuePtr
          - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v13, v14, v23);
    }
    goto LABEL_15;
  }
  v10 = socket(2, 2, 0);
  if (v10 != -1)
  {
    v11 = v10;
    if (ioctl(v10, 0xC0206933uLL, cStr) == -1)
    {
      v41 = __error();
      _SCErrorSet(*v41);
      v24 = 0;
LABEL_84:
      close(v11);
      return v24;
    }
    if (mtu_cur)
      *mtu_cur = v66;
    if (mtu_min)
    {
      *mtu_min = v66;
      if (!mtu_max)
      {
        if (!ioctl(v11, 0xC0206944uLL, cStr))
        {
          v58 = DWORD1(v66);
          if (SDWORD1(v66) <= 72)
            v58 = 72;
          *mtu_min = v58;
          v12 = 1;
          goto LABEL_75;
        }
        v12 = 1;
        goto LABEL_24;
      }
    }
    else if (!mtu_max)
    {
      goto LABEL_83;
    }
    *mtu_max = v66;
    if (!ioctl(v11, 0xC0206944uLL, cStr))
    {
      if (mtu_min)
      {
        v52 = DWORD1(v66);
        if (SDWORD1(v66) <= 72)
          v52 = 72;
        *mtu_min = v52;
      }
      v12 = 0;
      *mtu_max = DWORD2(v66);
      goto LABEL_73;
    }
    v12 = 0;
LABEL_24:
    *(_QWORD *)existing = 0;
    parent = 0;
    if (!__getIOMTULimits_masterPort && MEMORY[0x18D78C384](0, &__getIOMTULimits_masterPort))
      goto LABEL_53;
    v42 = _SC_IONetworkInterfaceBSDNameMatching(cStr);
    if (!v42)
      goto LABEL_53;
    MatchingServices = IOServiceGetMatchingServices(__getIOMTULimits_masterPort, v42, existing);
    v44 = 0;
    v45 = existing[0];
    if (!MatchingServices && existing[0])
    {
      v44 = IOIteratorNext(existing[0]);
      v45 = existing[0];
    }
    if (v45)
      IOObjectRelease(v45);
    if (v44)
    {
      CFProperty = (const __CFNumber *)IORegistryEntryCreateCFProperty(v44, CFSTR("IOInterfaceType"), 0, 0);
      if (CFProperty)
      {
        v47 = CFProperty;
        v48 = CFNumberGetTypeID();
        if (CFGetTypeID(v47) == v48)
          CFNumberGetValue(v47, kCFNumberIntType, &existing[1]);
        CFRelease(v47);
      }
      IORegistryEntryGetParentEntry(v44, "IOService", &parent);
      IOObjectRelease(v44);
      if (parent)
      {
        v49 = (const __CFNumber *)IORegistryEntryCreateCFProperty(parent, CFSTR("IOMaxPacketSize"), 0, 0);
        if (v49)
        {
          v50 = v49;
          v51 = CFNumberGetTypeID();
          if (CFGetTypeID(v50) == v51)
          {
            valuePtr = 0;
            CFNumberGetValue(v50, kCFNumberIntType, &valuePtr);
            if (existing[1] == 6)
              valuePtr -= 18;
            if (mtu_min)
              *mtu_min = 72;
            if ((v12 & 1) == 0)
              *mtu_max = valuePtr;
          }
          CFRelease(v50);
        }
        IOObjectRelease(parent);
      }
    }
    else
    {
LABEL_53:
      InterfaceType = SCNetworkInterfaceGetInterfaceType(interface);
      if (CFEqual(InterfaceType, CFSTR("Bridge")))
      {
        MemberInterfaces = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces(interface);
        if (MemberInterfaces)
        {
          v55 = MemberInterfaces;
          Count = CFArrayGetCount(MemberInterfaces);
          v57 = Count;
          if (Count < 2)
          {
            if (Count != 1)
              goto LABEL_73;
          }
          else
          {
            if (mtu_min)
              *mtu_min = 72;
            if ((v12 & 1) == 0)
              *mtu_max = 0xFFFF;
          }
          v59 = 0;
          do
          {
            *(_QWORD *)existing = 0;
            ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v55, v59);
            if (SCNetworkInterfaceCopyMTU(ValueAtIndex, 0, (int *)&existing[1], (int *)existing))
            {
              if (mtu_min && *mtu_min < (int)existing[1])
                *mtu_min = existing[1];
              if ((v12 & 1) == 0 && *mtu_max > (int)existing[0])
                *mtu_max = existing[0];
            }
            ++v59;
          }
          while (v57 != v59);
        }
      }
    }
LABEL_73:
    if (mtu_min)
    {
      v58 = *mtu_min;
LABEL_75:
      if (v58 <= 1279)
      {
        v58 = 1280;
        *mtu_min = 1280;
      }
      if (mtu_cur)
      {
        v61 = *mtu_cur;
        if (v58 > *mtu_cur)
        {
          *mtu_min = v61;
          v58 = v61;
        }
      }
      if ((v12 & 1) == 0 && v58 > *mtu_max)
        *mtu_min = *mtu_max;
    }
LABEL_83:
    v24 = 1;
    goto LABEL_84;
  }
  v26 = __error();
  _SCErrorSet(*v26);
  v27 = __log_SCNetworkConfiguration();
  v28 = _SC_syslog_os_log_mapping(3);
  if (__SC_log_enabled(3, v27, (os_log_type_t)v28))
  {
    v29 = _os_log_pack_size();
    v37 = (char *)&valuePtr
        - ((MEMORY[0x1E0C80A78](v29, v30, v31, v32, v33, v34, v35, v36) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v38 = _os_log_pack_fill();
    v39 = __error();
    v40 = strerror(*v39);
    *(_DWORD *)v38 = 136315138;
    *(_QWORD *)(v38 + 4) = v40;
    __SC_log_send(3, (uint64_t)v27, v28, v37);
  }
  return 0;
}

Boolean SCNetworkInterfaceSetMediaOptions(SCNetworkInterfaceRef interface, CFStringRef subtype, CFArrayRef options)
{
  CFTypeID TypeID;
  const __CFDictionary *Configuration;
  __CFDictionary *MutableCopy;
  CFArrayRef v9;
  const __CFArray *v10;
  const __CFArray *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  char v14;
  Boolean v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  NSObject *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63[2];
  CFArrayRef available[2];
  CFRange v65;
  CFRange v66;

  available[1] = *(CFArrayRef *)MEMORY[0x1E0C80C00];
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!interface || CFGetTypeID(interface) != TypeID)
  {
    _SCErrorSet(1002);
    return 0;
  }
  Configuration = SCNetworkInterfaceGetConfiguration(interface);
  if (Configuration)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Configuration);
    CFDictionaryRemoveValue(MutableCopy, CFSTR("__INACTIVE__"));
    if (subtype)
      goto LABEL_5;
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (subtype)
    {
LABEL_5:
      available[0] = 0;
      v9 = options;
      if (!options)
        v9 = CFArrayCreate(0, 0, 0, MEMORY[0x1E0C9B378]);
      if (SCNetworkInterfaceCopyMediaOptions(interface, 0, 0, available, 0))
      {
        if (available[0])
        {
          v10 = SCNetworkInterfaceCopyMediaSubTypes(available[0]);
          v11 = v10;
          if (v10 && (v65.length = CFArrayGetCount(v10), v65.location = 0, CFArrayContainsValue(v11, v65, subtype)))
          {
            v12 = SCNetworkInterfaceCopyMediaSubTypeOptions(available[0], subtype);
            v13 = v12;
            if (v12)
            {
              v66.length = CFArrayGetCount(v12);
              v66.location = 0;
              if (CFArrayContainsValue(v13, v66, v9))
              {
                CFDictionarySetValue(MutableCopy, CFSTR("MediaSubType"), subtype);
                CFDictionarySetValue(MutableCopy, CFSTR("MediaOptions"), v9);
                v14 = 0;
                goto LABEL_28;
              }
            }
            v50 = __log_SCNetworkConfiguration();
            v51 = _SC_syslog_os_log_mapping(6);
            if (__SC_log_enabled(6, v50, (os_log_type_t)v51))
            {
              v52 = _os_log_pack_size();
              v63[1] = (uint64_t)v63;
              v60 = MEMORY[0x1E0C80A78](v52, v53, v54, v55, v56, v57, v58, v59);
              v63[0] = (uint64_t)v50;
              v61 = (char *)v63 - ((v60 + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              v62 = _os_log_pack_fill();
              *(_DWORD *)v62 = 138412290;
              *(_QWORD *)(v62 + 4) = subtype;
              __SC_log_send(6, v63[0], v51, v61);
            }
            _SCErrorSet(1002);
          }
          else
          {
            v38 = __log_SCNetworkConfiguration();
            v39 = _SC_syslog_os_log_mapping(6);
            if (__SC_log_enabled(6, v38, (os_log_type_t)v39))
            {
              v40 = _os_log_pack_size();
              v48 = (char *)v63
                  - ((MEMORY[0x1E0C80A78](v40, v41, v42, v43, v44, v45, v46, v47) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              *(_WORD *)_os_log_pack_fill() = 0;
              __SC_log_send(6, (uint64_t)v38, v39, v48);
            }
            _SCErrorSet(1002);
            v13 = 0;
          }
          goto LABEL_27;
        }
        _SCErrorSet(1002);
      }
      else
      {
        v27 = __log_SCNetworkConfiguration();
        v28 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v27, (os_log_type_t)v28))
        {
          v29 = _os_log_pack_size();
          v37 = (char *)v63
              - ((MEMORY[0x1E0C80A78](v29, v30, v31, v32, v33, v34, v35, v36) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(6, (uint64_t)v27, v28, v37);
          v14 = 1;
          v13 = 0;
          v11 = 0;
          goto LABEL_28;
        }
      }
      v13 = 0;
      v11 = 0;
LABEL_27:
      v14 = 1;
LABEL_28:
      if (available[0])
        CFRelease(available[0]);
      if (v11)
        CFRelease(v11);
      if (v13)
        CFRelease(v13);
      if (options)
      {
        if ((v14 & 1) != 0)
          goto LABEL_38;
      }
      else
      {
        CFRelease(v9);
        if ((v14 & 1) != 0)
          goto LABEL_38;
      }
LABEL_43:
      v15 = SCNetworkInterfaceSetConfiguration(interface, MutableCopy);
      if (!MutableCopy)
        return v15;
      goto LABEL_39;
    }
  }
  if (!options)
  {
    CFDictionaryRemoveValue(MutableCopy, CFSTR("MediaSubType"));
    CFDictionaryRemoveValue(MutableCopy, CFSTR("MediaOptions"));
    if (!CFDictionaryGetCount(MutableCopy))
    {
      CFRelease(MutableCopy);
      MutableCopy = 0;
    }
    goto LABEL_43;
  }
  v16 = __log_SCNetworkConfiguration();
  v17 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v16, (os_log_type_t)v17))
  {
    v18 = _os_log_pack_size();
    v26 = (char *)v63 - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(6, (uint64_t)v16, v17, v26);
  }
  _SCErrorSet(1002);
LABEL_38:
  v15 = 0;
  if (MutableCopy)
LABEL_39:
    CFRelease(MutableCopy);
  return v15;
}

Boolean SCNetworkInterfaceSetMTU(SCNetworkInterfaceRef interface, int mtu)
{
  CFTypeID TypeID;
  const __CFDictionary *Configuration;
  __CFDictionary *MutableCopy;
  Boolean v7;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  CFNumberRef v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  _BYTE v32[12];
  int mtu_max[2];
  int valuePtr;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  valuePtr = mtu;
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!interface || CFGetTypeID(interface) != TypeID)
  {
    _SCErrorSet(1002);
    return 0;
  }
  *(_QWORD *)mtu_max = 0;
  if (!SCNetworkInterfaceCopyMTU(interface, 0, mtu_max, &mtu_max[1]))
  {
    v9 = __log_SCNetworkConfiguration();
    v10 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v9, (os_log_type_t)v10))
    {
      v11 = _os_log_pack_size();
      v19 = &v32[-((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v9, v10, v19);
    }
    return 0;
  }
  Configuration = SCNetworkInterfaceGetConfiguration(interface);
  if (Configuration)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Configuration);
    CFDictionaryRemoveValue(MutableCopy, CFSTR("__INACTIVE__"));
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  if (mtu_max[0] <= mtu && mtu_max[1] >= mtu)
  {
    v20 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(MutableCopy, CFSTR("MTU"), v20);
    goto LABEL_15;
  }
  if (!mtu)
  {
    CFDictionaryRemoveValue(MutableCopy, CFSTR("MTU"));
    if (CFDictionaryGetCount(MutableCopy))
    {
LABEL_16:
      v7 = SCNetworkInterfaceSetConfiguration(interface, MutableCopy);
      if (!MutableCopy)
        return v7;
      goto LABEL_22;
    }
    v20 = MutableCopy;
    MutableCopy = 0;
LABEL_15:
    CFRelease(v20);
    goto LABEL_16;
  }
  v21 = __log_SCNetworkConfiguration();
  v22 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v21, (os_log_type_t)v22))
  {
    v23 = _os_log_pack_size();
    v31 = &v32[-((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0)];
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(6, (uint64_t)v21, v22, v31);
  }
  _SCErrorSet(1002);
  v7 = 0;
  if (MutableCopy)
LABEL_22:
    CFRelease(MutableCopy);
  return v7;
}

CFStringRef SCPreferencesPathKeyCreate(const __CFAllocator *a1, CFStringRef format, ...)
{
  va_list va;

  va_start(va, format);
  return CFStringCreateWithFormatAndArguments(a1, 0, format, va);
}

CFStringRef SCPreferencesPathKeyCreateNetworkServices(const __CFAllocator *a1)
{
  return CFStringCreateWithFormat(a1, 0, CFSTR("/%@"), CFSTR("NetworkServices"));
}

CFStringRef SCPreferencesPathKeyCreateSetNetworkInterfaceEntity(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
    return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@/%@/%@/%@"), CFSTR("Sets"), a2, CFSTR("Network"), CFSTR("Interface"), a3, a4);
  else
    return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@/%@/%@"), CFSTR("Sets"), a2, CFSTR("Network"), CFSTR("Interface"), a3);
}

CFStringRef SCPreferencesPathKeyCreateCategories(const __CFAllocator *a1)
{
  return CFStringCreateWithFormat(a1, 0, CFSTR("/%@"), CFSTR("Categories"));
}

CFStringRef SCPreferencesPathKeyCreateCategory(const __CFAllocator *a1, uint64_t a2)
{
  return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@"), CFSTR("Categories"), a2);
}

CFStringRef SCPreferencesPathKeyCreateCategoryService(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a4)
    return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@/%@/%@"), CFSTR("Categories"), a2, a3, CFSTR("Service"), a4, v6);
  else
    return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@/%@"), CFSTR("Categories"), a2, a3, CFSTR("Service"), v5, v6);
}

CFStringRef SCPreferencesPathKeyCreateCategoryServiceEntity(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return CFStringCreateWithFormat(a1, 0, CFSTR("/%@/%@/%@/%@/%@/%@"), CFSTR("Categories"), a2, a3, CFSTR("Service"), a4, a5);
}

os_log_t __log_SCNetworkConfiguration()
{
  os_log_t result;

  result = (os_log_t)__log_SCNetworkConfiguration_log;
  if (!__log_SCNetworkConfiguration_log)
  {
    result = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
    __log_SCNetworkConfiguration_log = (uint64_t)result;
  }
  return result;
}

void __SCNetworkConfigurationReport(int a1, const char *a2, const __SCPreferences *a3, SCPreferencesRef prefs)
{
  logConfiguration_NetworkInterfaces(a1, a2, prefs);
  logConfiguration_preferences(a1, a2, a3);
}

void logConfiguration_NetworkInterfaces(int a1, const char *a2, SCPreferencesRef prefs)
{
  const __CFArray *Value;
  CFTypeID TypeID;
  const __CFString *v8;
  CFIndex Count;
  NSObject *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  const char *v23;
  const char *v24;
  const __CFString *v25;
  CFIndex v26;
  const __CFDictionary *ValueAtIndex;
  CFTypeID v28;
  const void *v29;
  CFTypeID v30;
  const __CFBoolean *v31;
  _BOOL4 v32;
  _BOOL4 v33;
  const __CFDictionary *v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  const __CFString *v47;
  const char *v48;
  const char *v49;
  __int128 v50;
  _BOOL4 v51;
  __int128 *v52;
  _BOOL4 v53;
  const __CFString *v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  Value = (const __CFArray *)SCPreferencesGetValue(prefs, CFSTR("Interfaces"));
  TypeID = CFArrayGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID)
  {
    v8 = (const __CFString *)SCPreferencesGetValue(prefs, CFSTR("Model"));
    Count = CFArrayGetCount(Value);
    v10 = __log_SCNetworkConfiguration_log;
    if (!__log_SCNetworkConfiguration_log)
    {
      v10 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
      __log_SCNetworkConfiguration_log = (uint64_t)v10;
    }
    v11 = _SC_syslog_os_log_mapping(a1);
    if (__SC_log_enabled(a1, v10, (os_log_type_t)v11))
    {
      v13 = _os_log_pack_size();
      v54 = (const __CFString *)&v50;
      v21 = (char *)&v50 - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v22 = _os_log_pack_fill();
      if (a2)
        v23 = a2;
      else
        v23 = "";
      v24 = " ";
      if (!a2)
        v24 = "";
      *(_DWORD *)v22 = 136315650;
      *(_QWORD *)(v22 + 4) = v23;
      if (v8)
        v25 = v8;
      else
        v25 = CFSTR("No model");
      *(_WORD *)(v22 + 12) = 2080;
      *(_QWORD *)(v22 + 14) = v24;
      *(_WORD *)(v22 + 22) = 2112;
      *(_QWORD *)(v22 + 24) = v25;
      __SC_log_send(a1, (uint64_t)v10, v11, v21);
    }
    if (Count >= 1)
    {
      v26 = 0;
      *(_QWORD *)&v12 = 138413058;
      v50 = v12;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v26);
        v28 = CFDictionaryGetTypeID();
        if (ValueAtIndex)
        {
          if (CFGetTypeID(ValueAtIndex) == v28)
          {
            v29 = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSD Name"));
            v30 = CFStringGetTypeID();
            if (v29)
            {
              if (CFGetTypeID(v29) == v30)
              {
                v31 = (const __CFBoolean *)CFDictionaryGetValue(ValueAtIndex, CFSTR("IOBuiltin"));
                if (v31)
                  v32 = CFBooleanGetValue(v31) != 0;
                else
                  v32 = 0;
                if (CFDictionaryContainsKey(ValueAtIndex, CFSTR("HiddenConfiguration")))
                  v33 = 1;
                else
                  v33 = CFDictionaryContainsKey(ValueAtIndex, CFSTR("HiddenInterface")) != 0;
                v53 = v33;
                v34 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SCNetworkInterfaceInfo"));
                v54 = (const __CFString *)CFDictionaryGetValue(v34, CFSTR("UserDefinedName"));
                v35 = __log_SCNetworkConfiguration_log;
                if (!__log_SCNetworkConfiguration_log)
                {
                  v35 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
                  __log_SCNetworkConfiguration_log = (uint64_t)v35;
                }
                v36 = _SC_syslog_os_log_mapping(a1);
                if (__SC_log_enabled(a1, v35, (os_log_type_t)v36))
                {
                  v37 = _os_log_pack_size();
                  v51 = v32;
                  v52 = &v50;
                  v45 = (char *)&v50
                      - ((MEMORY[0x1E0C80A78](v37, v38, v39, v40, v41, v42, v43, v44) + 15) & 0xFFFFFFFFFFFFFFF0);
                  __error();
                  v46 = _os_log_pack_fill();
                  v47 = CFSTR("???");
                  if (v54)
                    v47 = v54;
                  *(_DWORD *)v46 = v50;
                  *(_QWORD *)(v46 + 4) = v29;
                  v48 = "";
                  v49 = ", built-in";
                  if (!v51)
                    v49 = "";
                  *(_WORD *)(v46 + 12) = 2112;
                  if (v53)
                    v48 = ", hidden";
                  *(_QWORD *)(v46 + 14) = v47;
                  *(_WORD *)(v46 + 22) = 2080;
                  *(_QWORD *)(v46 + 24) = v49;
                  *(_WORD *)(v46 + 32) = 2080;
                  *(_QWORD *)(v46 + 34) = v48;
                  __SC_log_send(a1, (uint64_t)v35, v36, v45);
                }
              }
            }
          }
        }
        ++v26;
      }
      while (Count != v26);
    }
  }
}

void logConfiguration_preferences(int a1, const char *a2, SCPreferencesRef prefs)
{
  const __CFString *Value;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  const char *v18;
  const char *v19;
  const __CFString *v20;
  const __CFArray *v21;
  const __CFArray *v22;
  CFMutableArrayRef MutableCopy;
  const __CFArray *v24;
  CFMutableArrayRef Mutable;
  int v26;
  CFArrayRef v27;
  const __CFArray *v28;
  __int128 v29;
  CFIndex v30;
  const __SCNetworkSet *ValueAtIndex;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  CFStringRef SetID;
  CFStringRef Name;
  int v46;
  const char *v47;
  CFArrayRef v48;
  const __CFArray *v49;
  const __CFArray *ServiceOrder;
  const __CFArray *v51;
  CFIndex v52;
  CFIndex v53;
  const __CFArray *v54;
  CFIndex v55;
  const __CFArray *v56;
  const __SCNetworkService *v57;
  CFStringRef ServiceID;
  CFStringRef v59;
  const __CFString *v60;
  const __SCNetworkInterface *Interface;
  CFStringRef BSDName;
  const __CFString *UserDefinedName;
  const __CFString *v64;
  CFIndex FirstIndexOfValue;
  CFIndex v66;
  NSObject *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  const char *v79;
  const __CFString *v80;
  const char *v81;
  const char *v82;
  const char *v83;
  const char *v84;
  int v85;
  const char *v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  NSObject *v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  const char *v101;
  const __CFString *v102;
  const char *v103;
  const char *v104;
  const char *v105;
  const char *v106;
  int Enabled;
  const char *v108;
  CFIndex v109;
  NSObject *v110;
  uint64_t v111;
  __int128 v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  char *v121;
  CFIndex v122;
  const __SCNetworkService *v123;
  CFStringRef v124;
  CFStringRef v125;
  const __SCNetworkInterface *v126;
  CFStringRef v127;
  NSObject *v128;
  uint64_t v129;
  const __CFString *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  char *v139;
  uint64_t v140;
  SCNetworkInterfaceRef v141;
  int v142;
  const char *v143;
  const __CFString *v144;
  const __CFArray *v145;
  const __CFArray *v146;
  NSObject *v147;
  uint64_t v148;
  __int128 v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  char *v158;
  CFIndex v159;
  const __SCNetworkInterface *v160;
  CFStringRef v161;
  CFStringRef v162;
  __CFString *v163;
  const __CFArray *MemberInterfaces;
  const __CFArray *v165;
  CFIndex v166;
  CFIndex v167;
  CFIndex i;
  const __SCNetworkInterface *v169;
  CFStringRef v170;
  const __CFString *v171;
  const char *v172;
  NSObject *v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  char *v183;
  uint64_t v184;
  const __CFArray *v185;
  const __CFArray *v186;
  CFIndex v187;
  CFIndex v188;
  NSObject *v189;
  uint64_t v190;
  __int128 v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  char *v200;
  CFIndex v201;
  const __SCNetworkInterface *v202;
  CFStringRef v203;
  CFStringRef v204;
  const __SCNetworkInterface *PhysicalInterface;
  CFStringRef v206;
  CFNumberRef Tag;
  NSObject *v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  char *v218;
  uint64_t v219;
  const __CFString *v220;
  const __CFString *v221;
  char *v222;
  const __SCPreferences *v223;
  const __CFArray *v224;
  __int128 v225;
  SCNetworkSetRef v226;
  CFIndex Count;
  CFIndex v228;
  const __CFString *v229;
  const __CFArray *v230;
  CFIndex v231;
  const char *v232;
  const __CFString *v233;
  const char *v234;
  uint64_t v235;
  uint64_t v236;
  const __CFArray *v237;
  CFIndex v238;
  const __CFArray *v239;
  const __SCPreferences **v240;
  __int128 v241;
  CFIndex v242;
  int v243;
  uint64_t v244;
  CFRange v245;
  CFRange v246;
  CFRange v247;

  v244 = *MEMORY[0x1E0C80C00];
  v223 = prefs;
  Value = (const __CFString *)SCPreferencesGetValue(prefs, CFSTR("Model"));
  v6 = __log_SCNetworkConfiguration_log;
  if (!__log_SCNetworkConfiguration_log)
  {
    v6 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
    __log_SCNetworkConfiguration_log = (uint64_t)v6;
  }
  v7 = _SC_syslog_os_log_mapping(a1);
  if (__SC_log_enabled(a1, v6, (os_log_type_t)v7))
  {
    v8 = _os_log_pack_size();
    v16 = (char *)&v223 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v17 = _os_log_pack_fill();
    if (a2)
      v18 = a2;
    else
      v18 = "";
    v19 = " ";
    if (!a2)
      v19 = "";
    *(_DWORD *)v17 = 136315650;
    *(_QWORD *)(v17 + 4) = v18;
    if (Value)
      v20 = Value;
    else
      v20 = CFSTR("No model");
    *(_WORD *)(v17 + 12) = 2080;
    *(_QWORD *)(v17 + 14) = v19;
    *(_WORD *)(v17 + 22) = 2112;
    *(_QWORD *)(v17 + 24) = v20;
    __SC_log_send(a1, (uint64_t)v6, v7, v16);
  }
  v243 = a1;
  v21 = SCNetworkServiceCopyAll(v223);
  if (v21)
  {
    v22 = v21;
    MutableCopy = CFArrayCreateMutableCopy(0, 0, v21);
    v24 = v22;
    Mutable = MutableCopy;
    CFRelease(v24);
  }
  else
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  }
  v26 = v243;
  v27 = SCNetworkSetCopyAll(v223);
  v237 = Mutable;
  if (v27)
  {
    v28 = v27;
    v226 = SCNetworkSetCopyCurrent(v223);
    Count = CFArrayGetCount(v28);
    if (Count < 1)
      goto LABEL_103;
    v30 = 0;
    *(_QWORD *)&v29 = 138412802;
    v225 = v29;
    v224 = v28;
    while (1)
    {
      v228 = v30;
      ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v28, v30);
      v32 = __log_SCNetworkConfiguration_log;
      if (!__log_SCNetworkConfiguration_log)
      {
        v32 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
        __log_SCNetworkConfiguration_log = (uint64_t)v32;
      }
      v33 = _SC_syslog_os_log_mapping(v26);
      if (__SC_log_enabled(v26, v32, (os_log_type_t)v33))
      {
        v34 = _os_log_pack_size();
        v42 = (char *)&v223
            - ((MEMORY[0x1E0C80A78](v34, v35, v36, v37, v38, v39, v40, v41) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v43 = _os_log_pack_fill();
        SetID = SCNetworkSetGetSetID(ValueAtIndex);
        Name = SCNetworkSetGetName(ValueAtIndex);
        if (ValueAtIndex == v226)
        {
          v47 = ", current";
        }
        else if (!v226 || !ValueAtIndex || (v46 = CFEqual(ValueAtIndex, v226), v47 = ", current", !v46))
        {
          v47 = "";
        }
        *(_DWORD *)v43 = v225;
        *(_QWORD *)(v43 + 4) = SetID;
        *(_WORD *)(v43 + 12) = 2112;
        *(_QWORD *)(v43 + 14) = Name;
        *(_WORD *)(v43 + 22) = 2080;
        *(_QWORD *)(v43 + 24) = v47;
        v26 = v243;
        __SC_log_send(v243, (uint64_t)v32, v33, v42);
      }
      v48 = SCNetworkSetCopyServices(ValueAtIndex);
      if (!v48)
        goto LABEL_102;
      v49 = v48;
      ServiceOrder = SCNetworkSetGetServiceOrder(ValueAtIndex);
      v51 = ServiceOrder;
      if (ServiceOrder)
        v231 = CFArrayGetCount(ServiceOrder);
      else
        v231 = 0;
      v52 = CFArrayGetCount(v49);
      v53 = v52;
      if (v52 < 2)
      {
        if (v52 != 1)
          goto LABEL_101;
      }
      else
      {
        v54 = CFArrayCreateMutableCopy(0, 0, v49);
        v245.length = CFArrayGetCount(v54);
        v245.location = 0;
        CFArraySortValues(v54, v245, (CFComparatorFunction)_SCNetworkServiceCompare, v51);
        CFRelease(v49);
        v49 = v54;
      }
      v55 = 0;
      v56 = v237;
      v230 = v49;
      v238 = v53;
      v239 = v51;
      do
      {
        v57 = (const __SCNetworkService *)CFArrayGetValueAtIndex(v49, v55);
        ServiceID = SCNetworkServiceGetServiceID(v57);
        v59 = SCNetworkServiceGetName(v57);
        if (v59)
          v60 = v59;
        else
          v60 = &stru_1E25D5260;
        Interface = SCNetworkServiceGetInterface(v57);
        BSDName = SCNetworkInterfaceGetBSDName(Interface);
        UserDefinedName = (const __CFString *)__SCNetworkInterfaceGetUserDefinedName(Interface);
        *(_QWORD *)&v241 = v60;
        if (v60 == UserDefinedName || (v64 = UserDefinedName) != 0 && CFEqual(v60, UserDefinedName))
          v64 = 0;
        v242 = (CFIndex)ServiceID;
        if (!v51
          || (v246.location = 0,
              v246.length = v231,
              FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v51, v246, ServiceID),
              FirstIndexOfValue == -1))
        {
          v90 = __log_SCNetworkConfiguration_log;
          if (!__log_SCNetworkConfiguration_log)
          {
            v90 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
            __log_SCNetworkConfiguration_log = (uint64_t)v90;
          }
          v91 = v243;
          v92 = _SC_syslog_os_log_mapping(v243);
          if (__SC_log_enabled(v91, v90, (os_log_type_t)v92))
          {
            v93 = _os_log_pack_size();
            v240 = &v223;
            v77 = (char *)&v223
                - ((MEMORY[0x1E0C80A78](v93, v94, v95, v96, v97, v98, v99, v100) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v236 = _os_log_pack_fill();
            LODWORD(v235) = __SCNetworkInterfaceOrder(Interface);
            if (BSDName)
              v101 = ", ";
            else
              v101 = "";
            if (BSDName)
              v102 = BSDName;
            else
              v102 = &stru_1E25D5260;
            v233 = v102;
            v234 = v101;
            v103 = " : ";
            if (!v64)
              v103 = "";
            v232 = v103;
            if (!v64)
              v64 = &stru_1E25D5260;
            if (SCNetworkInterfaceGetDisablePrivateRelay((const __SCPreferences **)Interface))
              v104 = ", no-private-relay";
            else
              v104 = "";
            if (SCNetworkInterfaceGetDisableUntilNeeded((const __SCPreferences **)Interface))
              v105 = ", disable-until-needed";
            else
              v105 = "";
            if (_SCNetworkInterfaceIsHiddenConfiguration((unsigned __int8 *)Interface))
              v106 = ", hidden";
            else
              v106 = "";
            Enabled = SCNetworkServiceGetEnabled(v57);
            v108 = ", disabled";
            if (Enabled)
              v108 = "";
            __os_log_helper_1_2_11_8_64_4_0_8_64_8_32_8_64_8_32_8_64_8_32_8_32_8_32_8_32(v236, v242, v235, v241, (uint64_t)v234, (uint64_t)v233, (uint64_t)v232, (uint64_t)v64, (uint64_t)v104, (uint64_t)v105, (uint64_t)v106, (uint64_t)v108);
            v87 = v243;
            v88 = (uint64_t)v90;
            v89 = v92;
            goto LABEL_96;
          }
        }
        else
        {
          v66 = FirstIndexOfValue;
          v67 = __log_SCNetworkConfiguration_log;
          if (!__log_SCNetworkConfiguration_log)
          {
            v67 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
            __log_SCNetworkConfiguration_log = (uint64_t)v67;
          }
          v68 = v243;
          LODWORD(v236) = _SC_syslog_os_log_mapping(v243);
          if (__SC_log_enabled(v68, v67, (os_log_type_t)v236))
          {
            v69 = _os_log_pack_size();
            v240 = &v223;
            v77 = (char *)&v223
                - ((MEMORY[0x1E0C80A78](v69, v70, v71, v72, v73, v74, v75, v76) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v78 = _os_log_pack_fill();
            v234 = (const char *)(v66 + 1);
            v235 = v78;
            LODWORD(v233) = __SCNetworkInterfaceOrder(Interface);
            v79 = ", ";
            if (!BSDName)
              v79 = "";
            v232 = v79;
            if (BSDName)
              v80 = BSDName;
            else
              v80 = &stru_1E25D5260;
            v229 = v80;
            if (v64)
              v81 = " : ";
            else
              v81 = "";
            if (!v64)
              v64 = &stru_1E25D5260;
            if (SCNetworkInterfaceGetDisablePrivateRelay((const __SCPreferences **)Interface))
              v82 = ", no-private-relay";
            else
              v82 = "";
            if (SCNetworkInterfaceGetDisableUntilNeeded((const __SCPreferences **)Interface))
              v83 = ", disable-until-needed";
            else
              v83 = "";
            if (_SCNetworkInterfaceIsHiddenConfiguration((unsigned __int8 *)Interface))
              v84 = ", hidden";
            else
              v84 = "";
            v85 = SCNetworkServiceGetEnabled(v57);
            v86 = ", disabled";
            if (v85)
              v86 = "";
            __os_log_helper_1_2_12_8_0_8_64_4_0_8_64_8_32_8_64_8_32_8_64_8_32_8_32_8_32_8_32(v235, (uint64_t)v234, v242, (int)v233, v241, (uint64_t)v232, (uint64_t)v229, (uint64_t)v81, (uint64_t)v64, (uint64_t)v82, (uint64_t)v83, (uint64_t)v84, (uint64_t)v86);
            v87 = v243;
            v88 = (uint64_t)v67;
            v89 = v236;
LABEL_96:
            __SC_log_send(v87, v88, v89, v77);
            v56 = v237;
            v49 = v230;
          }
        }
        v247.length = CFArrayGetCount(v56);
        v247.location = 0;
        v109 = CFArrayGetFirstIndexOfValue(v56, v247, v57);
        if (v109 != -1)
          CFArrayRemoveValueAtIndex(v56, v109);
        ++v55;
        v51 = v239;
      }
      while (v238 != v55);
      v28 = v224;
      v26 = v243;
LABEL_101:
      CFRelease(v49);
LABEL_102:
      v30 = v228 + 1;
      if (v228 + 1 == Count)
      {
LABEL_103:
        CFRelease(v28);
        Mutable = v237;
        if (v226)
          CFRelease(v226);
        break;
      }
    }
  }
  v242 = CFArrayGetCount(Mutable);
  if (v242 >= 1)
  {
    v110 = __log_SCNetworkConfiguration_log;
    if (!__log_SCNetworkConfiguration_log)
    {
      v110 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
      __log_SCNetworkConfiguration_log = (uint64_t)v110;
    }
    v111 = _SC_syslog_os_log_mapping(v26);
    if (__SC_log_enabled(v26, v110, (os_log_type_t)v111))
    {
      v113 = _os_log_pack_size();
      v121 = (char *)&v223
           - ((MEMORY[0x1E0C80A78](v113, v114, v115, v116, v117, v118, v119, v120) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(v26, (uint64_t)v110, v111, v121);
    }
    v122 = 0;
    *(_QWORD *)&v112 = 138413314;
    v241 = v112;
    do
    {
      v123 = (const __SCNetworkService *)CFArrayGetValueAtIndex(v237, v122);
      v124 = SCNetworkServiceGetServiceID(v123);
      v125 = SCNetworkServiceGetName(v123);
      v126 = SCNetworkServiceGetInterface(v123);
      v127 = SCNetworkInterfaceGetBSDName(v126);
      v128 = __log_SCNetworkConfiguration_log;
      if (!__log_SCNetworkConfiguration_log)
      {
        v128 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
        __log_SCNetworkConfiguration_log = (uint64_t)v128;
      }
      v129 = _SC_syslog_os_log_mapping(v26);
      if (__SC_log_enabled(v26, v128, (os_log_type_t)v129))
      {
        if (v125)
          v130 = v125;
        else
          v130 = &stru_1E25D5260;
        v131 = _os_log_pack_size();
        v139 = (char *)&v223
             - ((MEMORY[0x1E0C80A78](v131, v132, v133, v134, v135, v136, v137, v138) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v140 = _os_log_pack_fill();
        v141 = SCNetworkServiceGetInterface(v123);
        v142 = __SCNetworkInterfaceOrder(v141);
        *(_DWORD *)v140 = v241;
        v143 = "";
        if (v127)
          v143 = ", ";
        *(_QWORD *)(v140 + 4) = v124;
        v144 = &stru_1E25D5260;
        if (v127)
          v144 = v127;
        *(_WORD *)(v140 + 12) = 1024;
        *(_DWORD *)(v140 + 14) = v142;
        *(_WORD *)(v140 + 18) = 2112;
        *(_QWORD *)(v140 + 20) = v130;
        v26 = v243;
        *(_WORD *)(v140 + 28) = 2080;
        *(_QWORD *)(v140 + 30) = v143;
        *(_WORD *)(v140 + 38) = 2112;
        *(_QWORD *)(v140 + 40) = v144;
        __SC_log_send(v26, (uint64_t)v128, v129, v139);
      }
      ++v122;
    }
    while (v242 != v122);
  }
  CFRelease(v237);
  v145 = (const __CFArray *)SCBridgeInterfaceCopyAll(v223);
  if (v145)
  {
    v146 = v145;
    v242 = CFArrayGetCount(v145);
    if (v242 >= 1)
    {
      v147 = __log_SCNetworkConfiguration_log;
      if (!__log_SCNetworkConfiguration_log)
      {
        v147 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
        __log_SCNetworkConfiguration_log = (uint64_t)v147;
      }
      v148 = _SC_syslog_os_log_mapping(v26);
      if (__SC_log_enabled(v26, v147, (os_log_type_t)v148))
      {
        v150 = _os_log_pack_size();
        v158 = (char *)&v223
             - ((MEMORY[0x1E0C80A78](v150, v151, v152, v153, v154, v155, v156, v157) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(v243, (uint64_t)v147, v148, v158);
        v26 = v243;
      }
      v159 = 0;
      *(_QWORD *)&v149 = 138412290;
      v241 = v149;
      do
      {
        v160 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v146, v159);
        v161 = SCNetworkInterfaceGetBSDName(v160);
        if (v161)
        {
          v162 = v161;
          v163 = CFStringCreateMutable(0, 0);
          CFStringAppendFormat(v163, 0, CFSTR("%@: "), v162);
          MemberInterfaces = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces(v160);
          if (MemberInterfaces)
          {
            v165 = MemberInterfaces;
            v166 = CFArrayGetCount(MemberInterfaces);
            if (v166 >= 1)
            {
              v167 = v166;
              for (i = 0; i != v167; ++i)
              {
                v169 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v165, i);
                v170 = SCNetworkInterfaceGetBSDName(v169);
                if (v170)
                  v171 = v170;
                else
                  v171 = CFSTR("?");
                if (i)
                  v172 = ", ";
                else
                  v172 = "";
                CFStringAppendFormat(v163, 0, CFSTR("%s%@"), v172, v171);
              }
            }
          }
          v173 = __log_SCNetworkConfiguration_log;
          if (!__log_SCNetworkConfiguration_log)
          {
            v173 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
            __log_SCNetworkConfiguration_log = (uint64_t)v173;
          }
          v26 = v243;
          v174 = _SC_syslog_os_log_mapping(v243);
          if (__SC_log_enabled(v26, v173, (os_log_type_t)v174))
          {
            v175 = _os_log_pack_size();
            v183 = (char *)&v223
                 - ((MEMORY[0x1E0C80A78](v175, v176, v177, v178, v179, v180, v181, v182) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v26 = v243;
            v184 = _os_log_pack_fill();
            *(_DWORD *)v184 = v241;
            *(_QWORD *)(v184 + 4) = v163;
            __SC_log_send(v26, (uint64_t)v173, v174, v183);
          }
          CFRelease(v163);
        }
        ++v159;
      }
      while (v159 != v242);
    }
    CFRelease(v146);
  }
  v185 = SCVLANInterfaceCopyAll(v223);
  if (v185)
  {
    v186 = v185;
    v187 = CFArrayGetCount(v185);
    if (v187 >= 1)
    {
      v188 = v187;
      v189 = __log_SCNetworkConfiguration_log;
      if (!__log_SCNetworkConfiguration_log)
      {
        v189 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
        __log_SCNetworkConfiguration_log = (uint64_t)v189;
      }
      v190 = _SC_syslog_os_log_mapping(v26);
      if (__SC_log_enabled(v26, v189, (os_log_type_t)v190))
      {
        v192 = _os_log_pack_size();
        v200 = (char *)&v223
             - ((MEMORY[0x1E0C80A78](v192, v193, v194, v195, v196, v197, v198, v199) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(v243, (uint64_t)v189, v190, v200);
        v26 = v243;
      }
      v201 = 0;
      *(_QWORD *)&v191 = 138412802;
      v241 = v191;
      v242 = (CFIndex)v186;
      do
      {
        v202 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v186, v201);
        v203 = SCNetworkInterfaceGetBSDName(v202);
        if (v203)
        {
          v204 = v203;
          PhysicalInterface = SCVLANInterfaceGetPhysicalInterface(v202);
          if (PhysicalInterface)
            v206 = SCNetworkInterfaceGetBSDName(PhysicalInterface);
          else
            v206 = 0;
          Tag = SCVLANInterfaceGetTag(v202);
          v208 = __log_SCNetworkConfiguration_log;
          if (!__log_SCNetworkConfiguration_log)
          {
            v208 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
            __log_SCNetworkConfiguration_log = (uint64_t)v208;
          }
          v209 = _SC_syslog_os_log_mapping(v26);
          if (__SC_log_enabled(v26, v208, (os_log_type_t)v209))
          {
            v210 = _os_log_pack_size();
            v218 = (char *)&v223
                 - ((MEMORY[0x1E0C80A78](v210, v211, v212, v213, v214, v215, v216, v217) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v219 = _os_log_pack_fill();
            v220 = CFSTR("?");
            if (v206)
              v221 = v206;
            else
              v221 = CFSTR("?");
            *(_DWORD *)v219 = v241;
            *(_QWORD *)(v219 + 4) = v204;
            if (Tag)
              v220 = (const __CFString *)Tag;
            *(_WORD *)(v219 + 12) = 2112;
            *(_QWORD *)(v219 + 14) = v221;
            *(_WORD *)(v219 + 22) = 2112;
            *(_QWORD *)(v219 + 24) = v220;
            v222 = v218;
            v26 = v243;
            __SC_log_send(v243, (uint64_t)v208, v209, v222);
            v186 = (const __CFArray *)v242;
          }
        }
        ++v201;
      }
      while (v188 != v201);
    }
    CFRelease(v186);
  }
}

CFDictionaryRef __SCNetworkConfigurationGetValue(const __SCPreferences *a1, const __CFString *a2)
{
  CFDictionaryRef Value;
  CFTypeID TypeID;
  CFIndex Count;

  Value = SCPreferencesPathGetValue(a1, a2);
  TypeID = CFDictionaryGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) != TypeID)
      return 0;
    Count = CFDictionaryGetCount(Value);
    if (!Count || Count == 1 && CFDictionaryContainsKey(Value, CFSTR("__INACTIVE__")))
      return 0;
  }
  return Value;
}

uint64_t __SCNetworkConfigurationSetValue(SCPreferencesRef prefs, CFStringRef path, const void *a3, int a4)
{
  CFTypeID TypeID;
  CFDictionaryRef Value;
  CFTypeID v10;
  __CFDictionary *Mutable;
  uint64_t result;
  CFTypeID v13;
  uint64_t v14;

  if (a3)
  {
    TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(a3) != TypeID)
    {
      _SCErrorSet(1002);
      return 0;
    }
  }
  Value = SCPreferencesPathGetValue(prefs, path);
  v10 = CFDictionaryGetTypeID();
  if (Value && CFGetTypeID(Value) != v10)
    Value = 0;
  if (!a3)
  {
    if (!a4)
    {
      if (!Value)
        return 1;
      goto LABEL_29;
    }
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_12;
  }
  Mutable = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)a3);
  if (a4)
  {
LABEL_12:
    v13 = CFDictionaryGetTypeID();
    if (Value && CFGetTypeID(Value) == v13 && CFDictionaryContainsKey(Value, CFSTR("__INACTIVE__")))
      CFDictionarySetValue(Mutable, CFSTR("__INACTIVE__"), (const void *)*MEMORY[0x1E0C9AE50]);
    else
      CFDictionaryRemoveValue(Mutable, CFSTR("__INACTIVE__"));
  }
  if (Value == Mutable)
  {
    if (!Value)
      return 1;
LABEL_23:
    CFRelease(Mutable);
    return 1;
  }
  if (Value && Mutable)
  {
    if (!CFEqual(Value, Mutable))
      goto LABEL_27;
    goto LABEL_23;
  }
  if (Mutable)
  {
LABEL_27:
    v14 = SCPreferencesPathSetValue(prefs, path, Mutable);
    CFRelease(Mutable);
    return v14;
  }
LABEL_29:
  result = SCPreferencesPathRemoveValue(prefs, path);
  if (!(_DWORD)result)
    return SCError() == 1004;
  return result;
}

uint64_t __setPrefsEnabled(const __SCPreferences *a1, const __CFString *a2, int a3)
{
  CFDictionaryRef Value;
  CFTypeID TypeID;
  __CFDictionary *MutableCopy;
  CFMutableDictionaryRef Mutable;
  uint64_t result;
  uint64_t v11;

  Value = SCPreferencesPathGetValue(a1, a2);
  if (Value)
  {
    TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(Value) != TypeID)
    {
      _SCErrorSet(1001);
      return 0;
    }
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
    Mutable = MutableCopy;
    if (a3)
      CFDictionaryRemoveValue(MutableCopy, CFSTR("__INACTIVE__"));
    else
      CFDictionarySetValue(MutableCopy, CFSTR("__INACTIVE__"), (const void *)*MEMORY[0x1E0C9AE50]);
    if (Value == Mutable)
      goto LABEL_13;
    if (Mutable)
    {
      if (CFEqual(Value, Mutable))
      {
LABEL_13:
        CFRelease(Mutable);
        return 1;
      }
LABEL_17:
      v11 = SCPreferencesPathSetValue(a1, a2, Mutable);
      CFRelease(Mutable);
      return v11;
    }
  }
  else
  {
    if (a3)
      return 1;
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(Mutable, CFSTR("__INACTIVE__"), (const void *)*MEMORY[0x1E0C9AE50]);
    if (!Mutable)
      return 1;
  }
  if (Mutable)
    goto LABEL_17;
  result = SCPreferencesPathRemoveValue(a1, a2);
  if (!(_DWORD)result)
    return SCError() == 1004;
  return result;
}

const void *__copyInterfaceTemplate(const void *a1, const __CFString *a2)
{
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  const void *Value;
  CFTypeID TypeID;
  CFIndex location;
  const __CFString *v9;
  CFStringRef v10;
  const void *v11;
  CFTypeID v12;

  v4 = (const __CFDictionary *)__copyTemplates();
  if (v4)
  {
    v5 = v4;
    Value = CFDictionaryGetValue(v4, CFSTR("Interface"));
    TypeID = CFDictionaryGetTypeID();
    if (!Value || CFGetTypeID(Value) != TypeID)
      goto LABEL_14;
    if (a2)
    {
      location = CFStringFind(a2, CFSTR("."), 0).location;
      v9 = CFSTR("*");
      if (location == -1)
        v9 = a2;
      v10 = CFStringCreateWithFormat(0, 0, CFSTR("%@-%@"), a1, v9);
      v11 = CFDictionaryGetValue((CFDictionaryRef)Value, v10);
      CFRelease(v10);
    }
    else
    {
      v11 = CFDictionaryGetValue((CFDictionaryRef)Value, a1);
    }
    v12 = CFDictionaryGetTypeID();
    if (!v11)
      goto LABEL_15;
    if (CFGetTypeID(v11) == v12 && CFDictionaryGetCount((CFDictionaryRef)v11) >= 1)
      CFRetain(v11);
    else
LABEL_14:
      v11 = 0;
LABEL_15:
    CFRelease(v5);
    return v11;
  }
  return 0;
}

CFPropertyListRef __copyTemplates()
{
  __CFBundle *v0;
  const __CFURL *v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  CFPropertyListRef v14;
  CFTypeID TypeID;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  _QWORD v29[2];

  v29[1] = *MEMORY[0x1E0C80C00];
  v0 = (__CFBundle *)_SC_CFBundleGet();
  if (!v0)
    return 0;
  v1 = CFBundleCopyResourceURL(v0, CFSTR("NetworkConfiguration"), CFSTR("plist"), 0);
  if (!v1)
  {
    v2 = __log_SCNetworkConfiguration_log;
    if (!__log_SCNetworkConfiguration_log)
    {
      v2 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
      __log_SCNetworkConfiguration_log = (uint64_t)v2;
    }
    v3 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v2, (os_log_type_t)v3))
    {
      v4 = _os_log_pack_size();
      v12 = (char *)v29 - ((MEMORY[0x1E0C80A78](v4, v5, v6, v7, v8, v9, v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v13 = _os_log_pack_fill();
      *(_DWORD *)v13 = 136315138;
      *(_QWORD *)(v13 + 4) = "NetworkConfiguration.plist";
      __SC_log_send(3, (uint64_t)v2, v3, v12);
    }
    v1 = CFURLCreateWithFileSystemPath(0, CFSTR("/System/Library/Frameworks/SystemConfiguration.framework/NetworkConfiguration.plist"), kCFURLPOSIXPathStyle, 1u);
    if (!v1)
    {
      v16 = __log_SCNetworkConfiguration_log;
      if (!__log_SCNetworkConfiguration_log)
      {
        v16 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
        __log_SCNetworkConfiguration_log = (uint64_t)v16;
      }
      v17 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v16, (os_log_type_t)v17))
      {
        v18 = _os_log_pack_size();
        v26 = (char *)v29 - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v27 = _os_log_pack_fill();
        *(_DWORD *)v27 = 136315138;
        *(_QWORD *)(v27 + 4) = "/System/Library/Frameworks/SystemConfiguration.framework/NetworkConfiguration.plist";
        __SC_log_send(3, (uint64_t)v16, v17, v26);
      }
      return 0;
    }
  }
  v14 = _SCCreatePropertyListFromResource(v1);
  CFRelease(v1);
  if (v14)
  {
    TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(v14) != TypeID)
    {
      CFRelease(v14);
      return 0;
    }
  }
  return v14;
}

const void *__copyProtocolTemplate(const void *a1, const __CFString *a2, const void *a3)
{
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  CFIndex location;
  const __CFString *v11;
  CFStringRef v12;
  const __CFDictionary *v13;
  const void *v14;
  CFTypeID v15;
  CFTypeID v16;

  v6 = (const __CFDictionary *)__copyTemplates();
  if (v6)
  {
    v7 = v6;
    Value = (const __CFDictionary *)CFDictionaryGetValue(v6, CFSTR("Protocol"));
    TypeID = CFDictionaryGetTypeID();
    if (Value && CFGetTypeID(Value) == TypeID)
    {
      if (a2)
      {
        location = CFStringFind(a2, CFSTR("."), 0).location;
        v11 = CFSTR("*");
        if (location == -1)
          v11 = a2;
        v12 = CFStringCreateWithFormat(0, 0, CFSTR("%@-%@"), a1, v11);
        v13 = (const __CFDictionary *)CFDictionaryGetValue(Value, v12);
        CFRelease(v12);
      }
      else
      {
        v13 = (const __CFDictionary *)CFDictionaryGetValue(Value, a1);
      }
      v15 = CFDictionaryGetTypeID();
      if (v13)
      {
        if (CFGetTypeID(v13) == v15)
        {
          v14 = CFDictionaryGetValue(v13, a3);
          v16 = CFDictionaryGetTypeID();
          if (!v14)
          {
LABEL_16:
            CFRelease(v7);
            return v14;
          }
          if (CFGetTypeID(v14) == v16)
          {
            CFRetain(v14);
            goto LABEL_16;
          }
        }
      }
    }
    v14 = 0;
    goto LABEL_16;
  }
  return 0;
}

BOOL __createInterface(int a1, const __CFString *a2)
{
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  _BOOL8 result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  int *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  int *v31;
  char *v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v33 = 0u;
  v34 = 0u;
  _SC_cfstring_to_cstring(a2, (UInt8 *)&v33, 16, 0x8000100u);
  if (ioctl(a1, 0xC0206978uLL, &v33) == -1)
  {
    v6 = __log_SCNetworkConfiguration_log;
    if (!__log_SCNetworkConfiguration_log)
    {
      v6 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
      __log_SCNetworkConfiguration_log = (uint64_t)v6;
    }
    v7 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v6, (os_log_type_t)v7);
    if (result)
    {
      v9 = _os_log_pack_size();
      v17 = (char *)&v33 - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v18 = _os_log_pack_fill();
      v19 = __error();
      v20 = strerror(*v19);
      *(_DWORD *)v18 = 138412546;
      *(_QWORD *)(v18 + 4) = a2;
      *(_WORD *)(v18 + 12) = 2080;
      *(_QWORD *)(v18 + 14) = v20;
      __SC_log_send(5, (uint64_t)v6, v7, v17);
      return 0;
    }
  }
  else
  {
    v33 = 0u;
    v34 = 0u;
    _SC_cfstring_to_cstring(a2, (UInt8 *)&v33, 16, 0x8000100u);
    if (ioctl(a1, 0xC0206911uLL, &v33) == -1)
    {
      v4 = __log_SCNetworkConfiguration_log;
      if (!__log_SCNetworkConfiguration_log)
      {
        v4 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
        __log_SCNetworkConfiguration_log = (uint64_t)v4;
      }
      v5 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v4, (os_log_type_t)v5))
        goto LABEL_16;
    }
    else if ((v34 & 1) == 0)
    {
      LOWORD(v34) = v34 | 1;
      if (ioctl(a1, 0x80206910uLL, &v33) == -1)
      {
        v4 = __log_SCNetworkConfiguration_log;
        if (!__log_SCNetworkConfiguration_log)
        {
          v4 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
          __log_SCNetworkConfiguration_log = (uint64_t)v4;
        }
        v5 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v4, (os_log_type_t)v5))
        {
LABEL_16:
          v21 = _os_log_pack_size();
          v29 = (char *)&v33
              - ((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v30 = _os_log_pack_fill();
          v31 = __error();
          v32 = strerror(*v31);
          *(_DWORD *)v30 = 138412546;
          *(_QWORD *)(v30 + 4) = a2;
          *(_WORD *)(v30 + 12) = 2080;
          *(_QWORD *)(v30 + 14) = v32;
          __SC_log_send(5, (uint64_t)v4, v5, v29);
          return 1;
        }
      }
    }
    return 1;
  }
  return result;
}

BOOL __destroyInterface(int a1, const __CFString *a2)
{
  _BOOL8 result;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int *v17;
  char *v18;
  _OWORD v19[2];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  memset(v19, 0, sizeof(v19));
  _SC_cfstring_to_cstring(a2, (UInt8 *)v19, 16, 0x8000100u);
  if (ioctl(a1, 0x80206979uLL, v19) != -1)
    return 1;
  v5 = __log_SCNetworkConfiguration_log;
  if (!__log_SCNetworkConfiguration_log)
  {
    v5 = os_log_create("com.apple.SystemConfiguration", "SCNetworkConfiguration");
    __log_SCNetworkConfiguration_log = (uint64_t)v5;
  }
  v6 = _SC_syslog_os_log_mapping(5);
  result = __SC_log_enabled(5, v5, (os_log_type_t)v6);
  if (result)
  {
    v7 = _os_log_pack_size();
    v15 = (char *)v19 - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v16 = _os_log_pack_fill();
    v17 = __error();
    v18 = strerror(*v17);
    *(_DWORD *)v16 = 138412546;
    *(_QWORD *)(v16 + 4) = a2;
    *(_WORD *)(v16 + 12) = 2080;
    *(_QWORD *)(v16 + 14) = v18;
    __SC_log_send(5, (uint64_t)v5, v6, v15);
    return 0;
  }
  return result;
}

uint64_t __extract_password(uint64_t a1, CFDictionaryRef theDict, const void *a3, void *key, const void *a5, uint64_t a6, uint64_t *a7)
{
  const void *Value;
  const void *v13;
  CFTypeID TypeID;
  uint64_t result;
  int v16;
  uint64_t v17;
  int v18;
  const __CFString *v19;

  if (theDict)
  {
    Value = CFDictionaryGetValue(theDict, key);
    if (Value)
    {
      v13 = Value;
      TypeID = CFStringGetTypeID();
      if (CFGetTypeID(v13) != TypeID)
        return 0;
      result = CFEqual(v13, a5);
      v16 = 0;
      if (!(_DWORD)result)
        return result;
      if (a7)
        goto LABEL_6;
LABEL_9:
      if (a1)
        result = _SCPreferencesSystemKeychainPasswordItemExists();
      else
        result = _SCSecKeychainPasswordItemExists();
      goto LABEL_14;
    }
  }
  v16 = 1;
  if (!a7)
    goto LABEL_9;
LABEL_6:
  if (a1)
    v17 = _SCPreferencesSystemKeychainPasswordItemCopy();
  else
    v17 = _SCSecKeychainPasswordItemCopy();
  *a7 = v17;
  result = v17 != 0;
LABEL_14:
  if ((_DWORD)result)
    v18 = 0;
  else
    v18 = v16;
  if (theDict)
  {
    if (v18)
    {
      v19 = (const __CFString *)CFDictionaryGetValue(theDict, a3);
      result = (uint64_t)__copy_legacy_password(v19);
      if (result)
      {
        if (a7)
          *a7 = result;
        else
          CFRelease((CFTypeRef)result);
        return 1;
      }
    }
  }
  return result;
}

CFDataRef __copy_legacy_password(const __CFString *a1)
{
  CFTypeID TypeID;
  CFIndex Length;
  CFStringEncoding v4;
  const UInt8 *BytePtr;
  const __CFString *v6;
  CFDataRef ExternalRepresentation;
  CFTypeID v9;

  if (!a1)
    return 0;
  TypeID = CFDataGetTypeID();
  if (CFGetTypeID(a1) != TypeID)
  {
    v9 = CFStringGetTypeID();
    if (CFGetTypeID(a1) == v9 && CFStringGetLength(a1) >= 1)
      return CFStringCreateExternalRepresentation(0, a1, 0x8000100u, 0);
    return 0;
  }
  Length = CFDataGetLength((CFDataRef)a1);
  if ((Length & 1) != 0)
    return 0;
  if (*CFDataGetBytePtr((CFDataRef)a1))
    v4 = 335544576;
  else
    v4 = 268435712;
  BytePtr = CFDataGetBytePtr((CFDataRef)a1);
  v6 = CFStringCreateWithBytes(0, BytePtr, Length, v4, 0);
  ExternalRepresentation = CFStringCreateExternalRepresentation(0, v6, 0x8000100u, 0);
  CFRelease(v6);
  return ExternalRepresentation;
}

uint64_t __remove_password(uint64_t a1, CFDictionaryRef theDict, const void *a3, void *key, const void *a5, uint64_t a6, __CFDictionary **a7)
{
  const void *Value;
  const void *v14;
  CFTypeID TypeID;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  const __CFString *v21;
  CFDataRef v22;
  __CFDictionary *MutableCopy;

  if (theDict && (Value = CFDictionaryGetValue(theDict, key)) != 0)
  {
    v14 = Value;
    TypeID = CFStringGetTypeID();
    if (CFGetTypeID(v14) != TypeID || (v16 = CFEqual(v14, a5), v17 = 0, !v16))
    {
LABEL_16:
      v19 = 0;
      goto LABEL_17;
    }
    if (a1)
      goto LABEL_6;
  }
  else
  {
    v17 = 1;
    if (a1)
    {
LABEL_6:
      v18 = _SCPreferencesSystemKeychainPasswordItemRemove();
      goto LABEL_9;
    }
  }
  v18 = _SCSecKeychainPasswordItemRemove();
LABEL_9:
  v19 = v18;
  if ((_DWORD)v18)
    v20 = 0;
  else
    v20 = v17;
  if (theDict && v20)
  {
    v21 = (const __CFString *)CFDictionaryGetValue(theDict, a3);
    v22 = __copy_legacy_password(v21);
    if (v22)
    {
      CFRelease(v22);
      v19 = 1;
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_17:
  if (a7)
  {
    MutableCopy = 0;
    if (theDict && (_DWORD)v19)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
      CFDictionaryRemoveValue(MutableCopy, a3);
      CFDictionaryRemoveValue(MutableCopy, key);
    }
    *a7 = MutableCopy;
  }
  return v19;
}

uint64_t __rank_to_str(int a1, __CFString **a2)
{
  __CFString *v2;
  __CFString **v3;
  uint64_t result;

  v2 = 0;
  switch(a1)
  {
    case 0:
      goto LABEL_8;
    case 1:
      v3 = kSCValNetServicePrimaryRankFirst;
      goto LABEL_7;
    case 2:
      v3 = kSCValNetServicePrimaryRankLast;
      goto LABEL_7;
    case 3:
      v3 = kSCValNetServicePrimaryRankNever;
      goto LABEL_7;
    case 4:
      v3 = kSCValNetServicePrimaryRankScoped;
LABEL_7:
      v2 = *v3;
LABEL_8:
      *a2 = v2;
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t __str_to_rank(const void *a1, int *a2)
{
  CFTypeID TypeID;
  int v5;
  uint64_t result;

  TypeID = CFStringGetTypeID();
  if (!a1)
  {
    v5 = 0;
    goto LABEL_6;
  }
  if (CFGetTypeID(a1) != TypeID)
    return 0;
  if (CFEqual(a1, CFSTR("First")))
  {
    v5 = 1;
LABEL_6:
    *a2 = v5;
    return 1;
  }
  if (CFEqual(a1, CFSTR("Last")))
  {
    v5 = 2;
    goto LABEL_6;
  }
  if (CFEqual(a1, CFSTR("Never")))
  {
    v5 = 3;
    goto LABEL_6;
  }
  result = CFEqual(a1, CFSTR("Scoped"));
  if ((_DWORD)result)
  {
    v5 = 4;
    goto LABEL_6;
  }
  return result;
}

uint64_t _SCNetworkConfigurationSetBypassSystemInterfaces(uint64_t a1, int a2)
{
  int v3;

  v3 = __SCPreferencesGetNetworkConfigurationFlags(a1) & 0xFFFFFFFC | (a2 != 0) | 2;
  return __SCPreferencesSetNetworkConfigurationFlags(a1, v3);
}

double __os_log_helper_1_2_12_8_0_8_64_4_0_8_64_8_32_8_64_8_32_8_64_8_32_8_32_8_32_8_32(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  double result;

  *(_QWORD *)&result = 134220802;
  *(_DWORD *)a1 = 134220802;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2112;
  *(_QWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 1024;
  *(_DWORD *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 28) = 2112;
  *(_QWORD *)(a1 + 30) = a5;
  *(_WORD *)(a1 + 38) = 2080;
  *(_QWORD *)(a1 + 40) = a6;
  *(_WORD *)(a1 + 48) = 2112;
  *(_QWORD *)(a1 + 50) = a7;
  *(_WORD *)(a1 + 58) = 2080;
  *(_QWORD *)(a1 + 60) = a8;
  *(_WORD *)(a1 + 68) = 2112;
  *(_QWORD *)(a1 + 70) = a9;
  *(_WORD *)(a1 + 78) = 2080;
  *(_QWORD *)(a1 + 80) = a10;
  *(_WORD *)(a1 + 88) = 2080;
  *(_QWORD *)(a1 + 90) = a11;
  *(_WORD *)(a1 + 98) = 2080;
  *(_QWORD *)(a1 + 100) = a12;
  *(_WORD *)(a1 + 108) = 2080;
  *(_QWORD *)(a1 + 110) = a13;
  return result;
}

double __os_log_helper_1_2_11_8_64_4_0_8_64_8_32_8_64_8_32_8_64_8_32_8_32_8_32_8_32(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  double result;

  *(_QWORD *)&result = 138414850;
  *(_DWORD *)a1 = 138414850;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 18) = 2112;
  *(_QWORD *)(a1 + 20) = a4;
  *(_WORD *)(a1 + 28) = 2080;
  *(_QWORD *)(a1 + 30) = a5;
  *(_WORD *)(a1 + 38) = 2112;
  *(_QWORD *)(a1 + 40) = a6;
  *(_WORD *)(a1 + 48) = 2080;
  *(_QWORD *)(a1 + 50) = a7;
  *(_WORD *)(a1 + 58) = 2112;
  *(_QWORD *)(a1 + 60) = a8;
  *(_WORD *)(a1 + 68) = 2080;
  *(_QWORD *)(a1 + 70) = a9;
  *(_WORD *)(a1 + 78) = 2080;
  *(_QWORD *)(a1 + 80) = a10;
  *(_WORD *)(a1 + 88) = 2080;
  *(_QWORD *)(a1 + 90) = a11;
  *(_WORD *)(a1 + 98) = 2080;
  *(_QWORD *)(a1 + 100) = a12;
  return result;
}

BOOL __SCNetworkInterfaceSupportsVLAN(const __CFString *a1)
{
  UInt8 *v1;
  UInt8 *v2;
  unsigned int v3;
  _BYTE *v4;
  _BOOL8 v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  int *v18;
  char *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  int *v32;
  char *v33;
  uint64_t v35;
  size_t v36;
  int v37[4];
  int v38;
  unsigned int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v36 = 0;
  v1 = _SC_cfstring_to_cstring(a1, 0, 0, 0x600u);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = if_nametoindex((const char *)v1);
  if (!v3)
  {
LABEL_10:
    v5 = 0;
    v4 = v2;
LABEL_17:
    CFAllocatorDeallocate(0, v4);
    return v5;
  }
  *(_OWORD *)v37 = xmmword_18D3FF490;
  v38 = 3;
  v39 = v3;
  if (sysctl(v37, 6u, 0, &v36, 0, 0) == -1)
  {
    v6 = __log_SCNetworkConfiguration();
    v7 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = (char *)&v35 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v17 = _os_log_pack_fill();
      v18 = __error();
      v19 = strerror(*v18);
      *(_DWORD *)v17 = 136315138;
      *(_QWORD *)(v17 + 4) = v19;
      __SC_log_send(5, (uint64_t)v6, v7, v16);
    }
    goto LABEL_10;
  }
  v4 = CFAllocatorAllocate(0, v36, 0);
  if (sysctl(v37, 6u, v4, &v36, 0, 0) != -1)
  {
    v5 = v4[3] == 14 && (v4[102] & 3) != 0;
    CFAllocatorDeallocate(0, v2);
    goto LABEL_17;
  }
  v20 = __log_SCNetworkConfiguration();
  v21 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v20, (os_log_type_t)v21))
  {
    v22 = _os_log_pack_size();
    v30 = (char *)&v35 - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v31 = _os_log_pack_fill();
    v32 = __error();
    v33 = strerror(*v32);
    *(_DWORD *)v31 = 136315138;
    *(_QWORD *)(v31 + 4) = v33;
    __SC_log_send(5, (uint64_t)v20, v21, v30);
  }
  CFAllocatorDeallocate(0, v2);
  v5 = 0;
  if (v4)
    goto LABEL_17;
  return v5;
}

CFDataRef __SCCopyMacAddress(const __CFString *a1)
{
  ifaddrs *v1;
  CFDataRef v2;
  _BYTE *v3;
  int *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int *v17;
  char *v18;
  ifaddrs *v20;
  char __s1[16];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  if (!_SC_cfstring_to_cstring(a1, (UInt8 *)__s1, 16, 0x8000100u))
    return 0;
  if (getifaddrs(&v20) == -1)
  {
    v4 = __error();
    _SCErrorSet(*v4);
    v5 = __log_SCNetworkConfiguration();
    v6 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v5, (os_log_type_t)v6))
    {
      v7 = _os_log_pack_size();
      v15 = &__s1[-((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
      __error();
      v16 = _os_log_pack_fill();
      v17 = __error();
      v18 = strerror(*v17);
      *(_DWORD *)v16 = 136315138;
      *(_QWORD *)(v16 + 4) = v18;
      __SC_log_send(5, (uint64_t)v5, v6, v15);
    }
    return 0;
  }
  v1 = v20;
  if (v20)
  {
    v2 = (CFDataRef)v20;
    while (1)
    {
      if (!strcmp(__s1, *((const char **)v2 + 1)))
      {
        v3 = (_BYTE *)*((_QWORD *)v2 + 3);
        if (v3[1] == 18)
          break;
      }
      v2 = *(CFDataRef *)v2;
      if (!v2)
        goto LABEL_14;
    }
    v2 = CFDataCreate(0, &v3[v3[5] + 8], v3[6]);
    v1 = v20;
  }
  else
  {
    v2 = 0;
  }
LABEL_14:
  MEMORY[0x18D78C7F8](v1);
  return v2;
}

uint64_t _SCBridgeInterfaceCreatePrivate(const __CFAllocator *a1, const __CFString *a2)
{
  uint64_t Private;
  uint64_t v5;
  const __CFString *Copy;

  Private = __SCNetworkInterfaceCreatePrivate((uint64_t)a1, 0, 0, 0);
  v5 = Private;
  if (Private)
  {
    *(_QWORD *)(Private + 16) = CFSTR("Bridge");
    *(_QWORD *)(Private + 128) = CFSTR("Ethernet");
    Copy = CFStringCreateCopy(a1, a2);
    *(_QWORD *)(v5 + 112) = Copy;
    *(_QWORD *)(v5 + 160) = __SCCopyMacAddress(Copy);
    *(_BYTE *)(v5 + 176) = 1;
    *(_BYTE *)(v5 + 368) = __SCNetworkInterfaceSupportsVLAN(a2);
    *(_DWORD *)(v5 + 312) = 10;
    *(_QWORD *)(v5 + 48) = CFSTR("bridge");
    *(_QWORD *)(v5 + 56) = CFRetain(*(CFTypeRef *)(v5 + 112));
    *(_QWORD *)(v5 + 352) = CFArrayCreate(0, 0, 0, MEMORY[0x1E0C9B378]);
  }
  return v5;
}

uint64_t _SCVLANInterfaceCreatePrivate(const __CFAllocator *a1, const __CFString *a2)
{
  uint64_t Private;
  uint64_t v5;
  const __CFString *Copy;

  Private = __SCNetworkInterfaceCreatePrivate((uint64_t)a1, 0, 0, 0);
  v5 = Private;
  if (Private)
  {
    *(_QWORD *)(Private + 16) = CFSTR("VLAN");
    *(_QWORD *)(Private + 128) = CFSTR("Ethernet");
    Copy = CFStringCreateCopy(a1, a2);
    *(_QWORD *)(v5 + 112) = Copy;
    *(_QWORD *)(v5 + 160) = __SCCopyMacAddress(Copy);
    *(_BYTE *)(v5 + 176) = 1;
    *(_DWORD *)(v5 + 312) = 9;
    *(_QWORD *)(v5 + 48) = CFSTR("vlan");
    *(_QWORD *)(v5 + 56) = CFRetain(*(CFTypeRef *)(v5 + 112));
  }
  return v5;
}

uint64_t __SCNetworkInterfaceOrder(_BYTE *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0x7FFFFFFFLL;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0x7FFFFFFFLL;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return (cf[176] == 0) | (2 * *((_DWORD *)cf + 78));
  return 0x7FFFFFFFLL;
}

__CFString *__SCNetworkInterfaceGetDefaultConfigurationType(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  __CFString ***i;

  if (!*(_QWORD *)(a1 + 96))
    goto LABEL_8;
  v2 = 0;
  v3 = *(const void **)(a1 + 16);
  for (i = &off_1E25D18D8; !CFEqual(v3, **(i - 1)); i += 5)
  {
    if (++v2 == 19)
      return *(__CFString **)(a1 + 16);
  }
  if (((0x61200uLL >> v2) & 1) == 0)
    return **i;
LABEL_8:
  _SCErrorSet(1002);
  return 0;
}

uint64_t findConfiguration(CFTypeRef cf1)
{
  uint64_t v2;
  CFTypeRef **i;

  v2 = 0;
  for (i = (CFTypeRef **)configurations; !CFEqual(cf1, **i); i += 5)
  {
    if (++v2 == 19)
      return -1;
  }
  return v2;
}

uint64_t __SCNetworkInterfaceIsValidExtendedConfigurationType(const __SCNetworkInterface *a1, const void *a2, int a3)
{
  __CFString *DefaultConfigurationType;
  uint64_t v7;
  const void *v8;
  CFTypeRef **v9;
  CFStringRef InterfaceType;
  const __SCNetworkInterface *Interface;
  CFStringRef v12;
  _BOOL8 v13;
  uint64_t v14;

  DefaultConfigurationType = __SCNetworkInterfaceGetDefaultConfigurationType((uint64_t)a1);
  if (!DefaultConfigurationType || CFEqual(a2, DefaultConfigurationType))
    goto LABEL_20;
  v7 = 0;
  v8 = (const void *)*((_QWORD *)a1 + 2);
  v9 = (CFTypeRef **)configurations;
  while (!CFEqual(v8, **v9))
  {
    ++v7;
    v9 += 5;
    if (v7 == 19)
      goto LABEL_20;
  }
  if (CFEqual(a2, CFSTR("IPSec")))
  {
    InterfaceType = SCNetworkInterfaceGetInterfaceType(a1);
    if (CFEqual(InterfaceType, CFSTR("PPP")))
    {
      Interface = SCNetworkInterfaceGetInterface(a1);
      if (Interface)
      {
        v12 = SCNetworkInterfaceGetInterfaceType(Interface);
        v13 = CFEqual(v12, CFSTR("L2TP")) != 0;
        if (!a3)
          goto LABEL_15;
        goto LABEL_13;
      }
    }
  }
  v13 = 0;
  if (a3)
  {
LABEL_13:
    if (((0x240ECuLL >> v7) & 1) != 0 || v13)
      goto LABEL_15;
LABEL_20:
    _SCErrorSet(1002);
    return 0;
  }
LABEL_15:
  v14 = 0;
  while (!CFEqual(a2, *configurations[v14]))
  {
    v14 += 5;
    if (v14 == 95)
      return 1;
  }
  if (!v13)
    goto LABEL_20;
  return v13;
}

__CFDictionary *__SCNetworkInterfaceCopyInterfaceEntity(SCNetworkInterfaceRef Interface)
{
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void **v8;
  const void **v9;
  uint64_t v10;
  const void *v11;
  const void **v12;
  const void ***v13;
  CFStringRef LocalizedDisplayName;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v3 = Mutable;
  v4 = (const void *)*((_QWORD *)Interface + 16);
  if (v4)
    CFDictionarySetValue(Mutable, CFSTR("Type"), v4);
  v5 = (const void *)*((_QWORD *)Interface + 17);
  if (v5)
    CFDictionarySetValue(v3, CFSTR("SubType"), v5);
  v6 = (const void *)*((_QWORD *)Interface + 14);
  if (v6)
    CFDictionarySetValue(v3, CFSTR("DeviceName"), v6);
  v7 = (const void *)*((_QWORD *)Interface + 15);
  if (v7)
    CFDictionarySetValue(v3, CFSTR("DeviceUniqueIdentifier"), v7);
  v8 = (const void **)MEMORY[0x1E0C9AE50];
  if (*((_BYTE *)Interface + 192))
    CFDictionarySetValue(v3, CFSTR("HiddenConfiguration"), (const void *)*MEMORY[0x1E0C9AE50]);
  if (*((_BYTE *)Interface + 240))
    CFDictionarySetValue(v3, CFSTR("TrustRequired"), *v8);
  do
  {
    v9 = (const void **)Interface;
    Interface = SCNetworkInterfaceGetInterface(Interface);
  }
  while (Interface);
  if (!CFEqual(v9, &__kSCNetworkInterfaceIPv4))
  {
    v10 = 0;
    v12 = v9 + 2;
    v11 = v9[2];
    v13 = (const void ***)&off_1E25D18D8;
    while (!CFEqual(v11, **(v13 - 1)))
    {
      ++v10;
      v13 += 5;
      if (v10 == 19)
        goto LABEL_21;
    }
    if (((0x61200uLL >> v10) & 1) != 0)
      goto LABEL_22;
    v12 = *v13;
LABEL_21:
    CFDictionarySetValue(v3, CFSTR("Hardware"), *v12);
LABEL_22:
    LocalizedDisplayName = SCNetworkInterfaceGetLocalizedDisplayName((SCNetworkInterfaceRef)v9);
    CFDictionarySetValue(v3, CFSTR("UserDefinedName"), LocalizedDisplayName);
  }
  return v3;
}

CFStringRef SCNetworkInterfaceGetLocalizedDisplayName(SCNetworkInterfaceRef interface)
{
  uint64_t v2;
  CFStringRef result;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
    {
LABEL_7:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_7;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) != v2)
    goto LABEL_7;
  result = (CFStringRef)*((_QWORD *)interface + 5);
  if (!result)
  {
    result = copy_display_name((uint64_t)interface, 1, 0);
    *((_QWORD *)interface + 5) = result;
  }
  return result;
}

SCNetworkInterfaceRef _SCNetworkInterfaceCreateWithBSDName(uint64_t a1, const __CFString *a2, char a3)
{
  int v5;
  int v6;
  const __CFDictionary *v7;
  __CFDictionary *MutableCopy;
  uint64_t v10;
  const void **v11;
  SCNetworkInterfaceRef v12;
  __CFArray *Mutable;
  CFStringRef NetworkServiceEntity;
  CFStringRef v16;
  CFIndex Count;
  const void **v18;
  const void **v19;
  uint64_t v20;
  const __CFString *v21;
  const __CFDictionary *v22;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFString *ValueAtIndex;
  CFStringRef v25;
  const __CFDictionary *v26;
  char v27;
  const __CFDictionary *theDict;
  void *value;
  __int128 v30;
  __int128 v31;
  void *values[2];
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  _OWORD keys[16];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v30 = 0u;
  v31 = 0u;
  if (!_SC_cfstring_to_cstring(a2, (UInt8 *)&v30, 16, 0x8000100u))
    goto LABEL_7;
  v5 = socket(2, 2, 0);
  if (v5 != -1)
  {
    v6 = v5;
    if (ioctl(v5, 0xC0206911uLL, &v30) == -1)
      LOWORD(v31) = 0;
    close(v6);
  }
  if ((v31 & 0x10) == 0)
  {
LABEL_7:
    LOBYTE(v7) = 1;
    goto LABEL_13;
  }
  if ((unsigned __int16)v30 != 28784 || BYTE2(v30) != 112)
    goto LABEL_12;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), CFSTR("[^/]+"), CFSTR("PPP"));
  CFArrayAppendValue(Mutable, NetworkServiceEntity);
  CFRelease(NetworkServiceEntity);
  v16 = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("Setup:"), CFSTR("[^/]+"), CFSTR("Interface"));
  CFArrayAppendValue(Mutable, v16);
  CFRelease(v16);
  v7 = SCDynamicStoreCopyMultiple(0, 0, Mutable);
  CFRelease(Mutable);
  if (!v7)
  {
LABEL_13:
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(MutableCopy, CFSTR("DeviceName"), a2);
    if ((v7 & 1) == 0)
      CFDictionarySetValue(MutableCopy, CFSTR("Type"), CFSTR("PointToPoint"));
    goto LABEL_15;
  }
  memset(keys, 0, sizeof(keys));
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  *(_OWORD *)values = 0u;
  v33 = 0u;
  Count = CFDictionaryGetCount(v7);
  if (Count < 33)
  {
    v18 = (const void **)keys;
    v19 = (const void **)values;
    CFDictionaryGetKeysAndValues(v7, (const void **)keys, (const void **)values);
    if (Count <= 0)
    {
      CFRelease(v7);
LABEL_12:
      LOBYTE(v7) = 0;
      goto LABEL_13;
    }
    theDict = v7;
    v27 = a3;
  }
  else
  {
    v27 = a3;
    v18 = (const void **)CFAllocatorAllocate(0, 8 * Count, 0);
    v19 = (const void **)CFAllocatorAllocate(0, 8 * Count, 0);
    theDict = v7;
    CFDictionaryGetKeysAndValues(v7, v18, v19);
  }
  v20 = 0;
  while (1)
  {
    value = 0;
    v21 = (const __CFString *)v18[v20];
    v22 = (const __CFDictionary *)v19[v20];
    if (CFStringHasSuffix(v21, CFSTR("PPP")))
    {
      if (CFDictionaryGetValueIfPresent(v22, CFSTR("InterfaceName"), (const void **)&value))
      {
        if (CFEqual(a2, value))
        {
          ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, v21, CFSTR("/"));
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 3);
          v25 = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("Setup:"), ValueAtIndex, CFSTR("Interface"));
          v26 = (const __CFDictionary *)CFDictionaryGetValue(theDict, v25);
          CFRelease(v25);
          CFRelease(ArrayBySeparatingStrings);
          if (v26)
            break;
        }
      }
    }
    if (Count == ++v20)
    {
      MutableCopy = 0;
      goto LABEL_32;
    }
  }
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v26);
LABEL_32:
  a3 = v27;
  if (v18 != (const void **)keys)
  {
    CFAllocatorDeallocate(0, v18);
    CFAllocatorDeallocate(0, v19);
  }
  CFRelease(theDict);
  if (!MutableCopy)
    goto LABEL_12;
LABEL_15:
  v11 = (const void **)MEMORY[0x1E0C9AE50];
  if ((a3 & 4) == 0)
    CFDictionarySetValue(MutableCopy, CFSTR("_NO_BRIDGE_INTERFACES_"), (const void *)*MEMORY[0x1E0C9AE50]);
  if ((a3 & 1) == 0)
    CFDictionarySetValue(MutableCopy, CFSTR("_NO_VLAN_INTERFACES_"), *v11);
  v12 = _SCNetworkInterfaceCreateWithEntity(v10, MutableCopy, (uint64_t)&__SCNetworkInterfaceSearchSystem);
  CFRelease(MutableCopy);
  return v12;
}

void __SCNetworkInterfaceSetIOInterfaceUnit(uint64_t a1, const void *a2)
{
  CFTypeID TypeID;
  CFStringRef BSDName;
  uint64_t v6;
  const void *v7;
  CFTypeID v8;
  CFMutableStringRef v9;
  CFMutableStringRef v10;
  CFTypeID v11;
  const void *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  CFStringRef v24;
  char v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  const void *v37;
  CFTypeID v38;
  CFStringRef v39;
  const void *v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  const void *v52;
  _QWORD v53[2];

  v53[1] = *MEMORY[0x1E0C80C00];
  TypeID = CFNumberGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
    return;
  BSDName = SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)a1);
  v6 = *(_QWORD *)(a1 + 232);
  if (!v6)
  {
    v7 = *(const void **)(a1 + 112);
    v8 = CFStringGetTypeID();
    if (v7 && CFGetTypeID(v7) == v8)
    {
      v9 = _SCNetworkInterfaceCopyPrefixFromBSDName(*(const __CFString **)(a1 + 112));
      if (v9)
      {
        v10 = v9;
        v11 = CFStringGetTypeID();
        if (CFGetTypeID(v10) == v11)
        {
          CFRetain(v10);
          v12 = *(const void **)(a1 + 232);
          if (v12)
            CFRelease(v12);
          *(_QWORD *)(a1 + 232) = v10;
        }
        CFRelease(v10);
      }
      else
      {
        v13 = __log_SCNetworkConfiguration();
        v14 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v13, (os_log_type_t)v14))
        {
          v15 = _os_log_pack_size();
          v23 = (char *)v53
              - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(6, (uint64_t)v13, v14, v23);
        }
      }
    }
    v6 = *(_QWORD *)(a1 + 232);
    if (!v6)
    {
      v24 = 0;
      goto LABEL_19;
    }
  }
  v24 = CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), v6, a2);
  if (!v24)
  {
LABEL_19:
    v25 = 1;
    goto LABEL_20;
  }
  v25 = 0;
  if (!__SCNetworkInterfaceUpdateBSDName((CFTypeRef)a1, BSDName, v24))
  {
LABEL_20:
    v26 = __log_SCNetworkConfiguration();
    v27 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v26, (os_log_type_t)v27))
    {
      v28 = _os_log_pack_size();
      v36 = (char *)v53 - ((MEMORY[0x1E0C80A78](v28, v29, v30, v31, v32, v33, v34, v35) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v26, v27, v36);
    }
  }
  v37 = *(const void **)(a1 + 208);
  v38 = CFStringGetTypeID();
  if (v37 && CFGetTypeID(v37) == v38)
  {
    v39 = CFStringCreateWithFormat(0, 0, CFSTR("Migrated_From: %@"), v37);
    v40 = *(const void **)(a1 + 208);
    if (v40)
      CFRelease(v40);
    *(_QWORD *)(a1 + 208) = CFRetain(v39);
    if (v39)
      CFRelease(v39);
  }
  else
  {
    v41 = __log_SCNetworkConfiguration();
    v42 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v41, (os_log_type_t)v42))
    {
      v43 = _os_log_pack_size();
      v51 = (char *)v53 - ((MEMORY[0x1E0C80A78](v43, v44, v45, v46, v47, v48, v49, v50) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v41, v42, v51);
    }
  }
  CFRetain(a2);
  v52 = *(const void **)(a1 + 256);
  if (v52)
    CFRelease(v52);
  *(_QWORD *)(a1 + 256) = a2;
  if ((v25 & 1) == 0)
    CFRelease(v24);
}

CFMutableStringRef _SCNetworkInterfaceCopyPrefixFromBSDName(const __CFString *a1)
{
  CFTypeID TypeID;
  CFMutableStringRef MutableCopy;
  CFIndex Length;
  CFIndex v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  _QWORD v18[2];
  CFRange v19;

  v18[1] = *MEMORY[0x1E0C80C00];
  TypeID = CFStringGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID)
  {
    MutableCopy = CFStringCreateMutableCopy(0, 0, a1);
    Length = CFStringGetLength(MutableCopy);
    if (Length >= 1)
    {
      do
      {
        v5 = Length - 1;
        if (CFStringGetCharacterAtIndex(MutableCopy, Length - 1) - 48 > 9)
          break;
        v19.location = v5;
        v19.length = 1;
        CFStringDelete(MutableCopy, v19);
        Length = CFStringGetLength(MutableCopy);
      }
      while (Length > 0);
    }
  }
  else
  {
    v6 = __log_SCNetworkConfiguration();
    v7 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = (char *)v18 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(7, (uint64_t)v6, v7, v16);
    }
    return 0;
  }
  return MutableCopy;
}

BOOL __SCNetworkInterfaceUpdateBSDName(CFTypeRef cf, const void *a2, const void *a3)
{
  uint64_t v6;
  const void *v7;
  _BOOL8 result;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_9:
      v9 = __log_SCNetworkConfiguration();
      v10 = _SC_syslog_os_log_mapping(6);
      result = __SC_log_enabled(6, v9, (os_log_type_t)v10);
      if (!result)
        return result;
      v11 = _os_log_pack_size();
      v19 = (char *)v20 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v9, v10, v19);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      goto LABEL_9;
  }
  v6 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) != v6)
    goto LABEL_9;
  if (CFEqual(a2, a3))
    return 0;
  v7 = (const void *)*((_QWORD *)cf + 14);
  if (v7)
    CFRelease(v7);
  *((_QWORD *)cf + 14) = CFRetain(a3);
  return 1;
}

__CFString *__SCNetworkInterfaceCopyStorageEntity(uint64_t a1)
{
  __CFString *BSDName;
  CFTypeID TypeID;
  const void *v4;
  const void *v5;
  const void *v6;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  const void *v10;
  CFTypeID v11;
  const void *v12;
  CFTypeID v13;
  void *v14;
  CFTypeID v15;
  __CFDictionary *v16;
  CFTypeID v17;
  CFStringRef InterfaceType;
  __CFString *v19;
  __CFDictionary *Mutable;
  const void *v21;
  CFTypeID v22;
  void *v24;
  CFTypeID v25;
  __CFDictionary *cf;

  BSDName = (__CFString *)SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)a1);
  TypeID = CFStringGetTypeID();
  if (BSDName)
  {
    if (CFGetTypeID(BSDName) != TypeID)
      return 0;
    v4 = (const void *)*MEMORY[0x1E0C9AE50];
    v5 = (const void *)(*(_BYTE *)(a1 + 176) ? *MEMORY[0x1E0C9AE50] : *MEMORY[0x1E0C9AE40]);
    v6 = *(const void **)(a1 + 232);
    v7 = CFStringGetTypeID();
    if (!v6)
      return 0;
    if (CFGetTypeID(v6) != v7)
      return 0;
    v8 = *(const void **)(a1 + 248);
    v9 = CFNumberGetTypeID();
    if (!v8)
      return 0;
    if (CFGetTypeID(v8) != v9)
      return 0;
    v10 = *(const void **)(a1 + 256);
    v11 = CFNumberGetTypeID();
    if (!v10)
      return 0;
    if (CFGetTypeID(v10) == v11
      && (v12 = *(const void **)(a1 + 160), v13 = CFDataGetTypeID(), v12)
      && CFGetTypeID(v12) == v13
      && (v14 = *(void **)(a1 + 208), v15 = CFStringGetTypeID(), v14)
      && CFGetTypeID(v14) == v15
      && (v16 = _SCNetworkInterfaceCopyInterfaceInfo(a1), v17 = CFDictionaryGetTypeID(), v16))
    {
      cf = v16;
      if (CFGetTypeID(v16) == v17
        && (InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a1),
            v25 = CFStringGetTypeID(),
            InterfaceType)
        && (v24 = v14, v19 = BSDName, CFGetTypeID(InterfaceType) == v25))
      {
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        BSDName = (__CFString *)Mutable;
        if (*(_BYTE *)(a1 + 24))
          CFDictionaryAddValue(Mutable, CFSTR("Active"), v4);
        CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("BSD Name"), v19);
        if (*(_BYTE *)(a1 + 192))
          CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("HiddenConfiguration"), v4);
        if (*(_BYTE *)(a1 + 193))
          CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("HiddenInterface"), v4);
        CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("IOBuiltin"), v5);
        CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("IOInterfaceNamePrefix"), v6);
        CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("IOInterfaceType"), v8);
        CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("IOInterfaceUnit"), v10);
        CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("IOMACAddress"), v12);
        CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("IOPathMatch"), v24);
        CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("SCNetworkInterfaceInfo"), cf);
        CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("SCNetworkInterfaceType"), InterfaceType);
        v21 = *(const void **)(a1 + 304);
        v22 = CFArrayGetTypeID();
        if (v21 && CFGetTypeID(v21) == v22)
          CFDictionaryAddValue((CFMutableDictionaryRef)BSDName, CFSTR("MatchingMACs"), *(const void **)(a1 + 304));
      }
      else
      {
        BSDName = 0;
      }
      CFRelease(cf);
    }
    else
    {
      return 0;
    }
  }
  return BSDName;
}

uint64_t _SCNetworkInterfaceGetIOInterfaceNamePrefix(uint64_t a1)
{
  return *(_QWORD *)(a1 + 232);
}

uint64_t _SCNetworkInterfaceGetIOInterfaceUnit(uint64_t a1)
{
  return *(_QWORD *)(a1 + 256);
}

uint64_t _SCNetworkInterfaceGetHardwareAddress(uint64_t a1)
{
  return *(_QWORD *)(a1 + 160);
}

uint64_t _SCNetworkInterfaceGetIOPath(uint64_t a1)
{
  return *(_QWORD *)(a1 + 208);
}

__CFDictionary *_SCNetworkInterfaceCopyInterfaceInfo(uint64_t a1)
{
  __CFDictionary *Mutable;
  CFStringRef NonLocalizedDisplayName;
  const void *v4;
  const void *v5;

  if (!a1)
    return 0;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  NonLocalizedDisplayName = __SCNetworkInterfaceGetNonLocalizedDisplayName((CFStringRef *)a1);
  if (NonLocalizedDisplayName)
    CFDictionaryAddValue(Mutable, CFSTR("UserDefinedName"), NonLocalizedDisplayName);
  v4 = *(const void **)(a1 + 288);
  if (v4 || *(_QWORD *)(a1 + 296))
  {
    if (*(_QWORD *)(a1 + 280))
    {
      CFDictionaryAddValue(Mutable, CFSTR("kUSBProductString"), *(const void **)(a1 + 280));
      v4 = *(const void **)(a1 + 288);
    }
    if (v4)
      CFDictionaryAddValue(Mutable, CFSTR("idVendor"), v4);
    v5 = *(const void **)(a1 + 296);
    if (v5)
      CFDictionaryAddValue(Mutable, CFSTR("idProduct"), v5);
  }
  if (!CFDictionaryGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t __SCNetworkInterfaceMatchesName(const __CFString *a1, const __CFString *a2)
{
  CFTypeID TypeID;
  uint64_t result;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  if (!bundle)
  {
    v6 = __log_SCNetworkConfiguration();
    v7 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v6, (os_log_type_t)v7);
    if (!(_DWORD)result)
      return result;
    v8 = _os_log_pack_size();
    v16 = (char *)v17 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(5, (uint64_t)v6, v7, v16);
    return 0;
  }
  TypeID = CFStringGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
    return 0;
  result = matchesName((__CFBundle *)bundle, a1, a2, 0);
  if (!(_DWORD)result)
    return matchesName((__CFBundle *)bundle, a1, a2, 1);
  return result;
}

uint64_t matchesName(__CFBundle *a1, const __CFString *a2, const __CFString *a3, int a4)
{
  CFStringRef v5;
  const __CFString *v6;
  uint64_t v7;
  CFIndex Length;
  CFIndex v9;
  CFStringRef v10;
  CFStringRef v11;
  CFRange v13;
  CFRange v14;

  v5 = copy_interface_string(a1, a3, a4);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = CFEqual(a2, v5);
  if (!(_DWORD)v7)
  {
    if (CFStringHasSuffix(v6, CFSTR(" %@")))
    {
      Length = CFStringGetLength(a2);
      do
      {
        v9 = Length;
        if (Length < 3)
          break;
        --Length;
      }
      while (CFStringGetCharacterAtIndex(a2, v9 - 1) - 58 > 0xFFFFFFF5);
      v13.location = 0;
      v13.length = v9;
      v10 = CFStringCreateWithSubstring(0, a2, v13);
      v14.length = CFStringGetLength(v6) - 2;
      v14.location = 0;
      v11 = CFStringCreateWithSubstring(0, v6, v14);
      v7 = CFEqual(v10, v11);
      CFRelease(v10);
      CFRelease(v11);
    }
    else
    {
      v7 = 0;
    }
  }
  CFRelease(v6);
  return v7;
}

void _SCNetworkInterfaceCacheOpen()
{
  _QWORD *v0;
  const void *v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  const void *v14;
  CFIndex v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD v26[2];

  v26[1] = *MEMORY[0x1E0C80C00];
  v0 = __SCGetThreadSpecificData();
  v1 = (const void *)v0[1];
  if (v1)
  {
    CFRetain(v1);
    v2 = __log_SCNetworkConfiguration();
    v3 = _SC_syslog_os_log_mapping(7);
    if (!__SC_log_enabled(7, v2, (os_log_type_t)v3))
      return;
    v4 = _os_log_pack_size();
    v12 = (char *)v26 - ((MEMORY[0x1E0C80A78](v4, v5, v6, v7, v8, v9, v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v13 = _os_log_pack_fill();
    v14 = (const void *)v0[1];
    v15 = CFGetRetainCount(v14);
    *(_DWORD *)v13 = 134218240;
    *(_QWORD *)(v13 + 4) = v14;
    *(_WORD *)(v13 + 12) = 2048;
    *(_QWORD *)(v13 + 14) = v15;
  }
  else
  {
    v0[1] = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v2 = __log_SCNetworkConfiguration();
    v3 = _SC_syslog_os_log_mapping(7);
    if (!__SC_log_enabled(7, v2, (os_log_type_t)v3))
      return;
    v16 = _os_log_pack_size();
    v12 = (char *)v26 - ((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v24 = _os_log_pack_fill();
    v25 = v0[1];
    *(_DWORD *)v24 = 134217984;
    *(_QWORD *)(v24 + 4) = v25;
  }
  __SC_log_send(7, (uint64_t)v2, v3, v12);
}

void _SCNetworkInterfaceCacheClose()
{
  _QWORD *v0;
  const void *v1;
  CFIndex v2;
  NSObject *v3;
  uint64_t v4;
  _BOOL4 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[2];

  v28[1] = *MEMORY[0x1E0C80C00];
  v0 = __SCGetThreadSpecificData();
  v1 = (const void *)v0[1];
  if (v1)
  {
    v2 = CFGetRetainCount(v1);
    CFRelease((CFTypeRef)v0[1]);
    v3 = __log_SCNetworkConfiguration();
    v4 = _SC_syslog_os_log_mapping(7);
    v5 = __SC_log_enabled(7, v3, (os_log_type_t)v4);
    if (v2 < 2)
    {
      if (v5)
      {
        v17 = _os_log_pack_size();
        v25 = (char *)v28 - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v26 = _os_log_pack_fill();
        v27 = v0[1];
        *(_DWORD *)v26 = 134217984;
        *(_QWORD *)(v26 + 4) = v27;
        __SC_log_send(7, (uint64_t)v3, v4, v25);
      }
      v0[1] = 0;
    }
    else if (v5)
    {
      v6 = _os_log_pack_size();
      v14 = (char *)v28 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v15 = _os_log_pack_fill();
      v16 = v0[1];
      *(_DWORD *)v15 = 134218240;
      *(_QWORD *)(v15 + 4) = v16;
      *(_WORD *)(v15 + 12) = 2048;
      *(_QWORD *)(v15 + 14) = v2;
      __SC_log_send(7, (uint64_t)v3, v4, v14);
    }
  }
}

CFTypeRef __SCNetworkInterfaceCreateCopy(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  uint64_t Private;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const __CFDictionary *v13;
  const void *v14;
  const void *v15;
  const __CFArray *v16;
  const __CFArray *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const __CFDictionary *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;

  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  if ((_UNKNOWN *)a2 == &__kSCNetworkInterfaceIPv4)
    return CFRetain(&__kSCNetworkInterfaceIPv4);
  Private = __SCNetworkInterfaceCreatePrivate(0, 0, a3, a4);
  *(_QWORD *)(Private + 16) = *(_QWORD *)(a2 + 16);
  if (*(_QWORD *)(a2 + 72))
    *(_QWORD *)(Private + 72) = __SCNetworkInterfaceCreateCopy();
  v8 = *(const void **)(a2 + 32);
  if (v8)
    *(_QWORD *)(Private + 32) = CFRetain(v8);
  v9 = *(const void **)(a2 + 232);
  if (v9)
    *(_QWORD *)(Private + 232) = CFRetain(v9);
  v10 = *(const void **)(a2 + 40);
  if (v10)
    *(_QWORD *)(Private + 40) = CFRetain(v10);
  v11 = *(const void **)(a2 + 56);
  *(_QWORD *)(Private + 48) = *(_QWORD *)(a2 + 48);
  if (v11)
    *(_QWORD *)(Private + 56) = CFRetain(v11);
  v12 = *(const void **)(a2 + 64);
  if (v12)
    *(_QWORD *)(Private + 64) = CFRetain(v12);
  v13 = *(const __CFDictionary **)(a2 + 104);
  if (v13)
    *(_QWORD *)(Private + 104) = CFDictionaryCreateMutableCopy(0, 0, v13);
  v14 = *(const void **)(a2 + 112);
  if (v14)
    *(_QWORD *)(Private + 112) = CFRetain(v14);
  v15 = *(const void **)(a2 + 120);
  if (v15)
    *(_QWORD *)(Private + 120) = CFRetain(v15);
  *(_OWORD *)(Private + 128) = *(_OWORD *)(a2 + 128);
  v16 = *(const __CFArray **)(a2 + 144);
  if (v16)
    *(_QWORD *)(Private + 144) = CFArrayCreateMutableCopy(0, 0, v16);
  v17 = *(const __CFArray **)(a2 + 152);
  if (v17)
    *(_QWORD *)(Private + 152) = CFArrayCreateMutableCopy(0, 0, v17);
  v18 = *(const void **)(a2 + 160);
  if (v18)
    *(_QWORD *)(Private + 160) = CFRetain(v18);
  *(_BYTE *)(Private + 176) = *(_BYTE *)(a2 + 176);
  v19 = *(const void **)(a2 + 184);
  if (v19)
    *(_QWORD *)(Private + 184) = CFRetain(v19);
  *(_WORD *)(Private + 192) = *(_WORD *)(a2 + 192);
  *(_BYTE *)(Private + 240) = *(_BYTE *)(a2 + 240);
  v20 = *(const void **)(a2 + 200);
  if (v20)
    *(_QWORD *)(Private + 200) = CFRetain(v20);
  v21 = *(const void **)(a2 + 208);
  if (v21)
    *(_QWORD *)(Private + 208) = CFRetain(v21);
  v22 = *(const __CFDictionary **)(a2 + 224);
  *(_QWORD *)(Private + 216) = *(_QWORD *)(a2 + 216);
  if (v22)
    *(_QWORD *)(Private + 224) = CFDictionaryCreateMutableCopy(0, 0, v22);
  v23 = *(const void **)(a2 + 248);
  if (v23)
    *(_QWORD *)(Private + 248) = CFRetain(v23);
  v24 = *(const void **)(a2 + 256);
  if (v24)
    *(_QWORD *)(Private + 256) = CFRetain(v24);
  v25 = *(const void **)(a2 + 264);
  if (v25)
    *(_QWORD *)(Private + 264) = CFRetain(v25);
  v26 = *(const void **)(a2 + 272);
  if (v26)
    *(_QWORD *)(Private + 272) = CFRetain(v26);
  v27 = *(const void **)(a2 + 280);
  if (v27)
    *(_QWORD *)(Private + 280) = CFRetain(v27);
  v28 = *(const void **)(a2 + 288);
  if (v28)
    *(_QWORD *)(Private + 288) = CFRetain(v28);
  v29 = *(const void **)(a2 + 296);
  if (v29)
    *(_QWORD *)(Private + 296) = CFRetain(v29);
  *(_DWORD *)(Private + 312) = *(_DWORD *)(a2 + 312);
  *(_BYTE *)(Private + 316) = *(_BYTE *)(a2 + 316);
  v30 = *(const void **)(a2 + 320);
  if (v30)
    *(_QWORD *)(Private + 320) = CFRetain(v30);
  v31 = *(const void **)(a2 + 328);
  if (v31)
    *(_QWORD *)(Private + 328) = CFRetain(v31);
  v32 = *(const void **)(a2 + 336);
  if (v32)
    *(_QWORD *)(Private + 336) = CFRetain(v32);
  *(_BYTE *)(Private + 344) = *(_BYTE *)(a2 + 344);
  v33 = *(const void **)(a2 + 352);
  if (v33)
    *(_QWORD *)(Private + 352) = CFRetain(v33);
  v34 = *(const void **)(a2 + 360);
  if (v34)
    *(_QWORD *)(Private + 360) = CFRetain(v34);
  *(_BYTE *)(Private + 368) = *(_BYTE *)(a2 + 368);
  v35 = *(const void **)(a2 + 376);
  if (v35)
    *(_QWORD *)(Private + 376) = CFRetain(v35);
  v36 = *(const void **)(a2 + 384);
  if (v36)
    *(_QWORD *)(Private + 384) = CFRetain(v36);
  v37 = *(const void **)(a2 + 392);
  if (v37)
    *(_QWORD *)(Private + 392) = CFRetain(v37);
  return (CFTypeRef)Private;
}

uint64_t processSerialInterface(uint64_t a1, io_registry_entry_t entry, const __CFDictionary *a3)
{
  const __CFBoolean *v6;
  const __CFBoolean *v7;
  CFTypeID TypeID;
  int Value;
  CFTypeRef v10;
  const void *v11;
  CFTypeID v12;
  _BOOL4 v13;
  const __CFString *v14;
  CFStringRef v15;
  const __CFString *v16;
  const __CFString *v17;
  CFIndex Length;
  CFTypeID v19;
  const __CFString *v20;
  const __CFString *v21;
  uint64_t v22;
  CFTypeID v23;
  const char *BytePtr;
  _BOOL4 v25;
  const __CFString *v26;
  int v27;
  const void *v28;
  CFTypeID v29;
  int v30;
  const void *v31;
  const __CFDictionary *v33;
  const __CFDictionary *v34;
  const __CFDictionary *v35;
  const void *v36;
  CFTypeID v37;
  const __CFString *v38;
  CFTypeID v39;
  const __CFString *v40;
  const __CFString *v41;
  CFMutableStringRef MutableCopy;
  CFStringRef v43;
  CFStringRef v44;
  CFStringRef v45;
  CFStringRef Copy;
  int updated;
  char v48;
  uint64_t v49;
  CFRange v50;

  v49 = *MEMORY[0x1E0C80C00];
  v6 = (const __CFBoolean *)IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("Initializing"), 0, 3u);
  if (v6)
  {
    v7 = v6;
    TypeID = CFBooleanGetTypeID();
    if (CFGetTypeID(v7) == TypeID)
    {
      Value = CFBooleanGetValue(v7);
      CFRelease(v7);
      if (Value)
        return 0;
    }
    else
    {
      CFRelease(v7);
    }
  }
  v10 = IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("WWAN"), 0, 3u);
  if (v10)
  {
    v11 = v10;
    v12 = CFBooleanGetTypeID();
    v13 = CFGetTypeID(v11) == v12 && CFBooleanGetValue((CFBooleanRef)v11) != 0;
    CFRelease(v11);
  }
  else
  {
    v13 = 0;
  }
  v14 = (const __CFString *)CFDictionaryGetValue(a3, CFSTR("IOTTYDevice"));
  v15 = IOCopyCFStringValue(v14);
  *(_QWORD *)(a1 + 112) = v15;
  if (!v15)
    return 0;
  v16 = (const __CFString *)CFDictionaryGetValue(a3, CFSTR("IOTTYBaseName"));
  v17 = IOCopyCFStringValue(v16);
  if (!v17)
    v17 = (const __CFString *)CFRetain(*(CFTypeRef *)(a1 + 112));
  Length = CFStringGetLength(CFSTR("bluetooth"));
  v19 = CFStringGetTypeID();
  if (!v17)
  {
    CFDataGetTypeID();
    goto LABEL_30;
  }
  if (CFGetTypeID(v17) == v19)
  {
    v20 = 0;
    v21 = v17;
    goto LABEL_22;
  }
  v23 = CFDataGetTypeID();
  if (CFGetTypeID(v17) != v23
    || (BytePtr = (const char *)CFDataGetBytePtr((CFDataRef)v17),
        v21 = CFStringCreateWithCStringNoCopy(0, BytePtr, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]),
        (v20 = v21) == 0))
  {
LABEL_30:
    v26 = CFSTR("Modem");
    if (v13)
    {
      v26 = CFSTR("WWAN");
      v27 = 4;
    }
    else
    {
      v27 = 2;
    }
    *(_QWORD *)(a1 + 16) = v26;
    *(_DWORD *)(a1 + 312) = v27;
    goto LABEL_34;
  }
LABEL_22:
  if (CFStringGetLength(v21) >= Length)
  {
    v50.location = 0;
    v50.length = Length;
    v25 = CFStringCompareWithOptions(v21, CFSTR("bluetooth"), v50, 1uLL) == kCFCompareEqualTo;
    if (!v20)
      goto LABEL_27;
    goto LABEL_26;
  }
  v25 = 0;
  if (v20)
LABEL_26:
    CFRelease(v20);
LABEL_27:
  if (!v25)
    goto LABEL_30;
  v48 = 0;
  *(_QWORD *)(a1 + 16) = CFSTR("Bluetooth");
  *(_DWORD *)(a1 + 312) = 3;
  *(_BYTE *)(a1 + 176) = isBluetoothBuiltin(&v48);
  if (!v48)
    goto LABEL_39;
LABEL_34:
  *(_QWORD *)(a1 + 128) = CFSTR("Modem");
  v28 = CFDictionaryGetValue(a3, CFSTR("IOSerialBSDClientType"));
  v29 = CFStringGetTypeID();
  if (v28 && CFGetTypeID(v28) == v29 && CFEqual(v28, CFSTR("IOSerialStream")))
  {
    if (CFEqual(v17, CFSTR("modem")))
    {
      v30 = 0;
      *(_BYTE *)(a1 + 176) = 1;
    }
    else
    {
      if (!CFEqual(v17, CFSTR("usbmodem")))
        goto LABEL_48;
      v30 = 1;
    }
    *(_DWORD *)(a1 + 312) = v30;
LABEL_48:
    merge_override(a1, entry, CFSTR("PPP"));
    merge_override(a1, entry, CFSTR("Modem"));
    v33 = *(const __CFDictionary **)(a1 + 224);
    if (!v33)
      goto LABEL_57;
    v34 = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("Modem"));
    if (!v34)
      goto LABEL_57;
    v35 = v34;
    v36 = CFDictionaryGetValue(v34, CFSTR("ConnectionScript"));
    v37 = CFStringGetTypeID();
    if (v36 && CFGetTypeID(v36) != v37)
      v36 = 0;
    v38 = (const __CFString *)CFDictionaryGetValue(v35, CFSTR("UniqueIdentifier"));
    v39 = CFStringGetTypeID();
    if (v38 && CFGetTypeID(v38) == v39)
    {
      CFRelease(*(CFTypeRef *)(a1 + 112));
      *(_QWORD *)(a1 + 112) = CFRetain(v17);
      *(_QWORD *)(a1 + 120) = CFStringCreateCopy(0, v38);
    }
    if (!v36)
    {
LABEL_57:
      v40 = (const __CFString *)IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("ModemCCL"), 0, 3u);
      if (v40)
      {
        v41 = v40;
        v36 = IOCopyCFStringValue(v40);
        if (v36)
        {
          set_connection_script(a1, v36);
          CFRelease(v36);
        }
        CFRelease(v41);
      }
      else
      {
        v36 = 0;
      }
    }
    if (CFEqual(*(CFTypeRef *)(a1 + 16), CFSTR("Bluetooth")))
    {
      *(_QWORD *)(a1 + 48) = CFSTR("bluetooth");
      goto LABEL_76;
    }
    MutableCopy = CFStringCreateMutableCopy(0, 0, v17);
    CFStringLowercase(MutableCopy, 0);
    if (bundle)
    {
      v43 = copy_interface_string((__CFBundle *)bundle, MutableCopy, 0);
      if (v43)
      {
        v44 = v43;
        if (!CFEqual(MutableCopy, v43))
        {
LABEL_69:
          *(_QWORD *)(a1 + 32) = v44;
          if (bundle)
          {
            v45 = copy_interface_string((__CFBundle *)bundle, MutableCopy, 1);
            if (v45)
            {
              Copy = v45;
              if (!CFEqual(MutableCopy, v45))
                goto LABEL_74;
              CFRelease(Copy);
            }
          }
          Copy = CFStringCreateCopy(0, v17);
LABEL_74:
          *(_QWORD *)(a1 + 40) = Copy;
          if (!CFEqual(v17, CFSTR("modem")))
          {
            processUSBInterface((_QWORD *)a1, entry);
            updated = update_interface_name((_QWORD *)a1, entry, 1);
            if (!v36 && updated && is_valid_connection_script(*(const __CFString **)(a1 + 32)))
              set_connection_script(a1, *(const void **)(a1 + 32));
          }
          CFRelease(MutableCopy);
LABEL_76:
          v22 = 1;
          if (!v17)
            return v22;
          goto LABEL_41;
        }
        CFRelease(v44);
      }
    }
    v44 = CFStringCreateCopy(0, v17);
    goto LABEL_69;
  }
LABEL_39:
  v31 = *(const void **)(a1 + 112);
  if (!v31)
  {
    v22 = 0;
    if (!v17)
      return v22;
    goto LABEL_41;
  }
  CFRelease(v31);
  v22 = 0;
  *(_QWORD *)(a1 + 112) = 0;
  if (v17)
LABEL_41:
    CFRelease(v17);
  return v22;
}

SCNetworkInterfaceRef SCNetworkInterfaceCreateWithInterface(SCNetworkInterfaceRef interface, CFStringRef interfaceType)
{
  uint64_t v4;
  CFTypeID TypeID;
  uint64_t Private;
  uint64_t v8;
  const void *v9;
  CFTypeRef **v10;
  __CFString **v11;
  const CFStringRef *v12;
  const __CFString *v13;
  const __CFString *v14;
  CFStringRef v15;
  const __CFDictionary *v16;
  const void *v17;
  const void *v18;
  int v19;
  __CFSet *Mutable;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  const __CFArray *ArrayBySeparatingStrings;
  CFIndex Count;
  CFIndex v26;
  const void *ValueAtIndex;
  const __CFString *v28;
  CFMutableStringRef MutableCopy;
  CFRange v30;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
    {
LABEL_7:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_7;
  }
  v4 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) != v4)
    goto LABEL_7;
  TypeID = CFStringGetTypeID();
  if (!interfaceType || CFGetTypeID(interfaceType) != TypeID || CFEqual(interface, &__kSCNetworkInterfaceLoopback))
    goto LABEL_7;
  v8 = 0;
  v9 = (const void *)*((_QWORD *)interface + 2);
  v10 = (CFTypeRef **)configurations;
  while (!CFEqual(v9, **v10))
  {
    ++v8;
    v10 += 5;
    if (v8 == 19)
    {
      v8 = -1;
      break;
    }
  }
  Private = __SCNetworkInterfaceCreatePrivate(0, interface, *((const void **)interface + 10), *((const void **)interface + 12));
  if (!Private)
  {
    _SCErrorSet(1001);
    return (SCNetworkInterfaceRef)Private;
  }
  if (CFEqual(interfaceType, CFSTR("PPP")))
  {
    *(_QWORD *)(Private + 16) = CFSTR("PPP");
    *(_QWORD *)(Private + 128) = CFSTR("PPP");
    if (v8 == -1)
    {
      v11 = (__CFString **)((char *)interface + 128);
      goto LABEL_23;
    }
    if (((0x6895DuLL >> v8) & 1) == 0)
    {
      v11 = configurations[5 * v8 + 3];
LABEL_23:
      *(_QWORD *)(Private + 136) = *v11;
      v13 = (const __CFString *)*((_QWORD *)interface + 14);
      if (v13)
        *(_QWORD *)(Private + 112) = CFStringCreateCopy(0, v13);
      v14 = (const __CFString *)*((_QWORD *)interface + 15);
      if (v14)
        *(_QWORD *)(Private + 120) = CFStringCreateCopy(0, v14);
      goto LABEL_32;
    }
    goto LABEL_52;
  }
  if (!CFEqual(interfaceType, CFSTR("L2TP")))
  {
    if (CFEqual(interfaceType, CFSTR("PPTP")))
    {
      if (v8 == 18)
      {
        *(_QWORD *)(Private + 16) = CFSTR("PPTP");
        *(_QWORD *)(Private + 48) = CFSTR("pptp");
        v12 = &kSCEntNetPPTP;
        goto LABEL_30;
      }
    }
    else if (CFEqual(interfaceType, CFSTR("6to4")))
    {
      if (v8 == 18)
      {
        *(_QWORD *)(Private + 16) = CFSTR("6to4");
        *(_QWORD *)(Private + 48) = CFSTR("6to4");
        *(_QWORD *)(Private + 128) = CFSTR("6to4");
        *(_QWORD *)(Private + 112) = CFRetain(CFSTR("stf0"));
        goto LABEL_32;
      }
    }
    else if (CFEqual(interfaceType, CFSTR("IPSec")))
    {
      if (v8 == 18)
      {
        *(_QWORD *)(Private + 16) = CFSTR("IPSec");
        *(_QWORD *)(Private + 48) = CFSTR("ipsec");
        v12 = &kSCValNetInterfaceTypeIPSec;
        goto LABEL_30;
      }
    }
    else if (CFEqual(interfaceType, CFSTR("VPN")))
    {
      if (v8 == -1)
      {
        *(_QWORD *)(Private + 16) = CFSTR("VPN");
        *(_QWORD *)(Private + 48) = CFSTR("vpn");
        *(_QWORD *)(Private + 56) = CFRetain(*((CFTypeRef *)interface + 16));
        *(_QWORD *)(Private + 128) = CFSTR("VPN");
        v21 = (const __CFString *)*((_QWORD *)interface + 16);
        *(_QWORD *)(Private + 136) = v21;
        v22 = (const __CFString *)*((_QWORD *)interface + 14);
        if (v22)
        {
          *(_QWORD *)(Private + 112) = CFStringCreateCopy(0, v22);
          v21 = *(const __CFString **)(Private + 136);
        }
        if (v21)
        {
          if (CFEqual(v21, CFSTR("com.cisco.anyconnect.applevpn.plugin")))
          {
            v23 = CFSTR("com.cisco.Cisco-AnyConnect.vpnplugin");
          }
          else if (CFEqual(*(CFTypeRef *)(Private + 136), CFSTR("net.juniper.sslvpn")))
          {
            v23 = CFSTR("net.juniper.Junos-Pulse.vpnplugin");
          }
          else
          {
            v23 = v21;
          }
          ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, v23, CFSTR("."));
          Count = CFArrayGetCount(ArrayBySeparatingStrings);
          if (Count >= 4)
          {
            v26 = Count;
            ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, Count - 1);
            if (CFEqual(ValueAtIndex, CFSTR("vpnplugin")))
            {
              v28 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v26 - 2);
              MutableCopy = CFStringCreateMutableCopy(0, 0, v28);
              v30.length = CFStringGetLength(MutableCopy);
              v30.location = 0;
              CFStringFindAndReplace(MutableCopy, CFSTR("-"), CFSTR(" "), v30, 0);
              *(_QWORD *)(Private + 40) = MutableCopy;
            }
          }
          CFRelease(ArrayBySeparatingStrings);
        }
        goto LABEL_32;
      }
    }
    else
    {
      if (CFStringFind(interfaceType, CFSTR("."), 0).location != -1)
      {
        pthread_mutex_lock(&lock_1);
        Mutable = (__CFSet *)vendor_interface_types;
        if (!vendor_interface_types)
        {
          Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
          vendor_interface_types = (uint64_t)Mutable;
        }
        CFSetAddValue(Mutable, interfaceType);
        *(_QWORD *)(Private + 16) = CFSetGetValue((CFSetRef)vendor_interface_types, interfaceType);
        pthread_mutex_unlock(&lock_1);
        v15 = *(CFStringRef *)(Private + 16);
        goto LABEL_31;
      }
      if (CFEqual(interfaceType, CFSTR("AppleVPN")))
      {
        *(_QWORD *)(Private + 16) = CFSTR("AppleVPN");
        *(_QWORD *)(Private + 128) = CFSTR("AppleVPN");
        goto LABEL_32;
      }
    }
LABEL_52:
    CFRelease((CFTypeRef)Private);
    goto LABEL_7;
  }
  if (v8 != 18)
    goto LABEL_52;
  *(_QWORD *)(Private + 16) = CFSTR("L2TP");
  *(_QWORD *)(Private + 48) = CFSTR("l2tp");
  v12 = &kSCEntNetL2TP;
LABEL_30:
  v15 = *v12;
LABEL_31:
  *(_QWORD *)(Private + 128) = v15;
LABEL_32:
  *(_WORD *)(Private + 192) = *((_WORD *)interface + 96);
  *(_BYTE *)(Private + 240) = *((_BYTE *)interface + 240);
  v16 = (const __CFDictionary *)*((_QWORD *)interface + 28);
  if (v16)
    *(_QWORD *)(Private + 224) = CFDictionaryCreateMutableCopy(0, 0, v16);
  v17 = *(const void **)(Private + 136);
  if (v17 && CFEqual(v17, CFSTR("PPPoE")))
  {
    v18 = (const void *)*((_QWORD *)interface + 2);
    if (v18 && CFEqual(v18, CFSTR("IEEE80211")))
      v19 = 6;
    else
      v19 = 5;
  }
  else
  {
    v19 = *((_DWORD *)interface + 78);
  }
  *(_DWORD *)(Private + 312) = v19;
  return (SCNetworkInterfaceRef)Private;
}

const __SCNetworkInterface *findBridgeInterface(const __SCPreferences *a1, const void *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  const __SCNetworkInterface *Interface;

  if (!a1)
    return 0;
  v3 = (const __CFArray *)SCBridgeInterfaceCopyAll(a1);
  if (!v3)
    return 0;
  v4 = v3;
  Interface = findInterface(v3, a2);
  CFRelease(v4);
  return Interface;
}

const __SCNetworkInterface *findVLANInterface(const __SCPreferences *a1, const void *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  const __SCNetworkInterface *Interface;

  if (!a1)
    return 0;
  v3 = SCVLANInterfaceCopyAll(a1);
  if (!v3)
    return 0;
  v4 = v3;
  Interface = findInterface(v3, a2);
  CFRelease(v4);
  return Interface;
}

CFStringRef __SCNetworkInterfaceGetNonLocalizedDisplayName(CFStringRef *cf)
{
  uint64_t v2;
  CFStringRef result;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_7:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      goto LABEL_7;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_7;
  result = cf[4];
  if (!result)
  {
    result = copy_display_name((uint64_t)cf, 0, 0);
    cf[4] = result;
  }
  return result;
}

void __SCNetworkInterfaceCacheAdd1(const void *a1, const void *a2)
{
  _QWORD *v4;
  CFArrayRef v5;
  const void *v6[2];

  v6[1] = *(const void **)MEMORY[0x1E0C80C00];
  v4 = __SCGetThreadSpecificData();
  if (a1 && v4[1])
  {
    if (a2)
    {
      v6[0] = a2;
      v5 = CFArrayCreate(0, v6, 1, MEMORY[0x1E0C9B378]);
      __SCNetworkInterfaceCacheAdd(a1, v5);
      CFRelease(v5);
    }
    else
    {
      __SCNetworkInterfaceCacheAdd(a1, 0);
    }
  }
}

CFArrayRef SCNetworkInterfaceGetSupportedInterfaceTypes(SCNetworkInterfaceRef interface)
{
  uint64_t v2;
  uint64_t v4;
  const void *v5;
  CFTypeRef **v6;
  SCNetworkInterfaceRef v7;
  __CFArray *Mutable;
  const __CFString *v9;
  __CFArray *v10;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
    {
LABEL_21:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_21;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) != v2)
    goto LABEL_21;
  if (!*((_QWORD *)interface + 18))
  {
    v4 = 0;
    v5 = (const void *)*((_QWORD *)interface + 2);
    v6 = (CFTypeRef **)configurations;
    while (!CFEqual(v5, **v6))
    {
      --v4;
      v6 += 5;
      if (v4 == -19)
      {
        v7 = SCNetworkInterfaceGetInterface(interface);
        if (v7 && CFEqual(v7, &__kSCNetworkInterfaceIPv4))
        {
          Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
          *((_QWORD *)interface + 18) = Mutable;
          v9 = CFSTR("VPN");
LABEL_19:
          CFArrayAppendValue(Mutable, v9);
          return (CFArrayRef)*((_QWORD *)interface + 18);
        }
        return (CFArrayRef)*((_QWORD *)interface + 18);
      }
    }
    if (((0x2C95DuLL >> -(char)v4) & 1) == 0)
    {
      v10 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      *((_QWORD *)interface + 18) = v10;
      if (v4 == -18)
      {
        CFArrayAppendValue(v10, CFSTR("6to4"));
        CFArrayAppendValue(*((CFMutableArrayRef *)interface + 18), CFSTR("L2TP"));
      }
      if (((0x6C95DuLL >> -(char)v4) & 1) == 0)
        CFArrayAppendValue(*((CFMutableArrayRef *)interface + 18), CFSTR("PPP"));
      if (v4 == -18)
      {
        Mutable = (__CFArray *)*((_QWORD *)interface + 18);
        v9 = CFSTR("IPSec");
        goto LABEL_19;
      }
    }
  }
  return (CFArrayRef)*((_QWORD *)interface + 18);
}

CFArrayRef SCNetworkInterfaceGetSupportedProtocolTypes(SCNetworkInterfaceRef interface)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  CFTypeRef **i;
  __CFArray *Mutable;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
    {
LABEL_18:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_18;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) != v2)
    goto LABEL_18;
  if (!*((_QWORD *)interface + 19))
  {
    v3 = 0;
    v4 = (const void *)*((_QWORD *)interface + 2);
    for (i = (CFTypeRef **)configurations; !CFEqual(v4, **i); i += 5)
    {
      if (++v3 == 19)
        return (CFArrayRef)*((_QWORD *)interface + 19);
    }
    if (((0x53612uLL >> v3) & 1) == 0)
    {
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      *((_QWORD *)interface + 19) = Mutable;
      if (((0x73613uLL >> v3) & 1) == 0)
      {
        CFArrayAppendValue(Mutable, CFSTR("DNS"));
        Mutable = (__CFArray *)*((_QWORD *)interface + 19);
      }
      if (((0x53613uLL >> v3) & 1) == 0)
      {
        CFArrayAppendValue(Mutable, CFSTR("IPv4"));
        Mutable = (__CFArray *)*((_QWORD *)interface + 19);
      }
      CFArrayAppendValue(Mutable, CFSTR("IPv6"));
      if (((0x73613uLL >> v3) & 1) == 0)
        CFArrayAppendValue(*((CFMutableArrayRef *)interface + 19), CFSTR("Proxies"));
    }
  }
  return (CFArrayRef)*((_QWORD *)interface + 19);
}

CFDictionaryRef __SCNetworkInterfaceGetDefaultConfiguration(const __SCNetworkSet *a1, uint64_t a2)
{
  __CFString *DefaultConfigurationType;
  CFDictionaryRef Value;
  __CFString *v6;
  CFStringRef SetID;
  const __CFString *SetNetworkInterfaceEntity;
  const __CFString *v9;
  CFTypeID TypeID;
  const __CFDictionary *v11;
  const __CFDictionary *v12;

  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  DefaultConfigurationType = __SCNetworkInterfaceGetDefaultConfigurationType(a2);
  Value = 0;
  if (a1)
  {
    v6 = DefaultConfigurationType;
    if (DefaultConfigurationType)
    {
      SetID = SCNetworkSetGetSetID(a1);
      SetNetworkInterfaceEntity = SCPreferencesPathKeyCreateSetNetworkInterfaceEntity(0, (uint64_t)SetID, *(_QWORD *)(a2 + 112), (uint64_t)v6);
      if (SetNetworkInterfaceEntity)
      {
        v9 = SetNetworkInterfaceEntity;
        Value = __SCNetworkConfigurationGetValue(*(const __SCPreferences **)(a2 + 80), SetNetworkInterfaceEntity);
        CFRelease(v9);
        if (Value)
        {
          TypeID = CFDictionaryGetTypeID();
LABEL_8:
          if (CFGetTypeID(Value) == TypeID && !CFDictionaryGetCount(Value))
            return 0;
          return Value;
        }
        v11 = *(const __CFDictionary **)(a2 + 104);
        if (v11)
        {
          v12 = (const __CFDictionary *)CFDictionaryGetValue(v11, v6);
          if (v12 != (const __CFDictionary *)*MEMORY[0x1E0C9B0D0])
          {
            Value = v12;
            TypeID = CFDictionaryGetTypeID();
            if (!Value)
              return Value;
            goto LABEL_8;
          }
        }
        CFDictionaryGetTypeID();
      }
      return 0;
    }
  }
  return Value;
}

CFDictionaryRef SCNetworkInterfaceGetConfiguration(SCNetworkInterfaceRef interface)
{
  uint64_t v2;
  __CFString *DefaultConfigurationType;
  __CFString *v4;
  const __CFDictionary *Configuration;
  int v6;
  const __CFString *NetworkServiceEntity;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
    {
LABEL_10:
      v6 = 1002;
      goto LABEL_11;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_10;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) != v2)
    goto LABEL_10;
  DefaultConfigurationType = __SCNetworkInterfaceGetDefaultConfigurationType((uint64_t)interface);
  if (!DefaultConfigurationType)
    return 0;
  v4 = DefaultConfigurationType;
  Configuration = (const __CFDictionary *)__SCNetworkInterfaceGetConfiguration((uint64_t)interface, DefaultConfigurationType);
  if (!Configuration)
  {
    v6 = CFEqual(v4, CFSTR("AirPort"));
    if (!v6)
    {
LABEL_11:
      _SCErrorSet(v6);
      return 0;
    }
    NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)interface + 12), (uint64_t)CFSTR("AirPort"));
    Configuration = __SCNetworkConfigurationGetValue(*((const __SCPreferences **)interface + 10), NetworkServiceEntity);
    CFRelease(NetworkServiceEntity);
    if (!Configuration)
    {
      v6 = 0;
      goto LABEL_11;
    }
  }
  return Configuration;
}

const void *__SCNetworkInterfaceGetConfiguration(uint64_t a1, const void *a2)
{
  __CFArray *v4;
  __CFArray *v5;
  const __CFString *ValueAtIndex;
  const void *Value;
  CFTypeID TypeID;
  const __CFDictionary *v9;

  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  v4 = copyConfigurationPaths(a1, (uint64_t)a2);
  if (v4)
  {
    v5 = v4;
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, 0);
    Value = __SCNetworkConfigurationGetValue(*(const __SCPreferences **)(a1 + 80), ValueAtIndex);
    CFRelease(v5);
  }
  else
  {
    v9 = *(const __CFDictionary **)(a1 + 104);
    if (!v9 || (Value = CFDictionaryGetValue(v9, a2), Value == (const void *)*MEMORY[0x1E0C9B0D0]))
    {
      CFDictionaryGetTypeID();
      return 0;
    }
  }
  TypeID = CFDictionaryGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && !CFDictionaryGetCount((CFDictionaryRef)Value))
    return 0;
  return Value;
}

CFDictionaryRef SCNetworkInterfaceGetExtendedConfiguration(SCNetworkInterfaceRef interface, CFStringRef extendedType)
{
  uint64_t v4;
  CFDictionaryRef result;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
      goto LABEL_8;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_8;
  }
  v4 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) == v4
    && __SCNetworkInterfaceIsValidExtendedConfigurationType(interface, extendedType, 1))
  {
    result = (CFDictionaryRef)__SCNetworkInterfaceGetConfiguration((uint64_t)interface, extendedType);
    if (result)
      return result;
    goto LABEL_9;
  }
LABEL_8:
  LODWORD(result) = 1002;
LABEL_9:
  _SCErrorSet((int)result);
  return 0;
}

uint64_t __SCNetworkInterfaceGetEntityType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 128);
}

uint64_t __SCNetworkInterfaceGetEntitySubType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 136);
}

CFStringRef SCNetworkInterfaceGetHardwareAddressString(SCNetworkInterfaceRef interface)
{
  uint64_t v2;
  const __CFData *v3;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v6;
  char *v7;
  char *v8;
  int v9;
  _BYTE v11[24];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
    {
LABEL_16:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_16;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) != v2)
    goto LABEL_16;
  v3 = (const __CFData *)*((_QWORD *)interface + 20);
  if (v3 && !*((_QWORD *)interface + 21))
  {
    BytePtr = CFDataGetBytePtr(v3);
    Length = CFDataGetLength(*((CFDataRef *)interface + 20));
    v6 = 3 * Length;
    if ((unint64_t)(3 * Length) < 0x19)
      v7 = v11;
    else
      v7 = (char *)CFAllocatorAllocate(0, v6, 0);
    if (Length)
    {
      v8 = v7;
      do
      {
        v9 = *BytePtr++;
        v8 += snprintf(v8, v6, "%2.2x:", v9);
        v6 -= 3;
      }
      while (v6);
    }
    *((_QWORD *)interface + 21) = CFStringCreateWithCString(0, v7, 0x8000100u);
    if (v7 != v11)
      CFAllocatorDeallocate(0, v7);
  }
  return (CFStringRef)*((_QWORD *)interface + 21);
}

CFStringRef __SCNetworkInterfaceCopyOldLocalizedDisplayName(CFTypeRef cf, uint64_t a2)
{
  uint64_t v4;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      goto LABEL_6;
  }
  v4 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v4)
    return copy_display_name((uint64_t)cf, 1, a2);
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

CFStringRef copy_display_name(uint64_t a1, int a2, uint64_t a3)
{
  CFMutableStringRef Mutable;
  void *v7;
  BOOL v8;
  uint64_t v9;
  const __CFString *v10;
  const __CFString *v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *NetworkServiceEntity;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  const __CFString *v17;
  CFTypeID v18;
  CFStringRef Copy;
  uint64_t v21;

  Mutable = CFStringCreateMutable(0, 0);
  if (a1)
  {
    while (1)
    {
      v7 = *(void **)(a1 + 72);
      if (v7)
        v8 = v7 == &__kSCNetworkInterfaceIPv4;
      else
        v8 = 1;
      if (v8 || CFEqual(*(CFTypeRef *)(a1 + 16), CFSTR("VPN")))
        v9 = 0;
      else
        v9 = *(_QWORD *)(a1 + 72);
      if (!bundle)
        goto LABEL_27;
      v10 = *(const __CFString **)(a1 + 48);
      if (!v10)
        goto LABEL_27;
      if (a3)
        v10 = CFStringCreateWithFormat(0, 0, CFSTR("%@-%@"), a3, v10);
      else
        CFRetain(*(CFTypeRef *)(a1 + 48));
      v11 = copy_interface_string((__CFBundle *)bundle, v10, a2);
      CFRelease(v10);
      if (v11)
      {
        if (a2)
        {
          localizeNumberString((CFStringRef *)(a1 + 56));
          localizeNumberString((CFStringRef *)(a1 + 64));
        }
        v12 = *(_QWORD *)(a1 + 56);
        if (v12)
        {
          if (*(_QWORD *)(a1 + 64))
            v21 = *(_QWORD *)(a1 + 64);
          CFStringAppendFormat(Mutable, 0, v11, v12, v21);
        }
        else
        {
          CFStringAppend(Mutable, v11);
        }
        CFRelease(v11);
        if (!v9)
          break;
      }
      else
      {
LABEL_27:
        if (*(_QWORD *)(a1 + 80))
        {
          v13 = *(_QWORD *)(a1 + 96);
          if (v13)
          {
            if (!v9)
            {
              NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, v13, (uint64_t)CFSTR("Interface"));
              Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 80), NetworkServiceEntity);
              CFRelease(NetworkServiceEntity);
              TypeID = CFDictionaryGetTypeID();
              if (Value)
              {
                if (CFGetTypeID(Value) == TypeID)
                {
                  v17 = (const __CFString *)CFDictionaryGetValue(Value, CFSTR("UserDefinedName"));
                  v18 = CFStringGetTypeID();
                  if (v17)
                  {
                    if (CFGetTypeID(v17) == v18)
                    {
                      CFStringAppend(Mutable, v17);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
        CFStringAppend(Mutable, *(CFStringRef *)(a1 + 16));
        if (*(_QWORD *)(a1 + 112) && !v9)
        {
          CFStringAppendFormat(Mutable, 0, CFSTR(" (%@)"), *(_QWORD *)(a1 + 112));
          break;
        }
        if (!v9)
          break;
      }
      CFStringAppend(Mutable, CFSTR(" --> "));
      a1 = v9;
    }
  }
  Copy = CFStringCreateCopy(0, Mutable);
  CFRelease(Mutable);
  return Copy;
}

CFStringRef __SCNetworkInterfaceCopyOldNonLocalizedDisplayName(CFTypeRef cf, uint64_t a2)
{
  uint64_t v4;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      goto LABEL_6;
  }
  v4 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v4)
    return copy_display_name((uint64_t)cf, 0, a2);
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

uint64_t __SCNetworkInterfaceGetUserDefinedName(_QWORD *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[4];
  return 0;
}

const void *__SCNetworkInterfaceGetTemplateOverrides(uint64_t a1, const void *a2)
{
  const __CFDictionary *v2;

  v2 = *(const __CFDictionary **)(a1 + 224);
  if (v2)
    return CFDictionaryGetValue(v2, a2);
  else
    return 0;
}

CFTypeID SCNetworkInterfaceGetTypeID(void)
{
  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  return __kSCNetworkInterfaceTypeID;
}

uint64_t __SCNetworkInterfaceSetDefaultConfiguration(const __SCNetworkSet *a1, uint64_t a2, __CFString *a3, const void *a4, int a5)
{
  __CFString *DefaultConfigurationType;
  CFTypeID TypeID;
  CFStringRef SetID;
  const __CFString *SetNetworkInterfaceEntity;
  const __CFString *v13;
  uint64_t v14;
  __CFDictionary *v15;
  __CFDictionary *Mutable;

  DefaultConfigurationType = a3;
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (a3)
      goto LABEL_4;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (DefaultConfigurationType)
      goto LABEL_4;
  }
  DefaultConfigurationType = __SCNetworkInterfaceGetDefaultConfigurationType(a2);
  if (!DefaultConfigurationType)
    return 0;
LABEL_4:
  TypeID = CFDictionaryGetTypeID();
  if (a4 && CFGetTypeID(a4) == TypeID && !CFDictionaryGetCount((CFDictionaryRef)a4))
    a4 = 0;
  if (!a1)
    return 0;
  SetID = SCNetworkSetGetSetID(a1);
  SetNetworkInterfaceEntity = SCPreferencesPathKeyCreateSetNetworkInterfaceEntity(0, (uint64_t)SetID, *(_QWORD *)(a2 + 112), (uint64_t)DefaultConfigurationType);
  if (SetNetworkInterfaceEntity)
  {
    v13 = SetNetworkInterfaceEntity;
    v14 = __SCNetworkConfigurationSetValue(*(SCPreferencesRef *)(a2 + 80), SetNetworkInterfaceEntity, a4, 0);
    CFRelease(v13);
    if ((_DWORD)v14)
    {
      v15 = *(__CFDictionary **)(a2 + 104);
      if (v15)
      {
        CFDictionaryRemoveValue(v15, DefaultConfigurationType);
        if (!CFDictionaryGetCount(*(CFDictionaryRef *)(a2 + 104)))
        {
          CFRelease(*(CFTypeRef *)(a2 + 104));
          *(_QWORD *)(a2 + 104) = 0;
        }
      }
    }
    return v14;
  }
  if (!a5)
  {
    _SCErrorSet(1004);
    return 0;
  }
  if (!a4)
    a4 = (const void *)*MEMORY[0x1E0C9B0D0];
  Mutable = *(__CFDictionary **)(a2 + 104);
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)(a2 + 104) = Mutable;
  }
  CFDictionarySetValue(Mutable, DefaultConfigurationType, a4);
  return 1;
}

uint64_t __SCNetworkInterfaceSetConfiguration(uint64_t a1, __CFString *a2, const void *a3, uint64_t a4)
{
  __CFString *DefaultConfigurationType;
  CFTypeID TypeID;
  __CFArray *v9;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  const __CFString *ValueAtIndex;
  __CFDictionary *v15;
  __CFDictionary *Mutable;

  DefaultConfigurationType = a2;
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (a2)
      goto LABEL_4;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (DefaultConfigurationType)
      goto LABEL_4;
  }
  DefaultConfigurationType = __SCNetworkInterfaceGetDefaultConfigurationType(a1);
  if (!DefaultConfigurationType)
    return 0;
LABEL_4:
  TypeID = CFDictionaryGetTypeID();
  if (a3 && CFGetTypeID(a3) == TypeID && !CFDictionaryGetCount((CFDictionaryRef)a3))
    a3 = 0;
  v9 = copyConfigurationPaths(a1, (uint64_t)DefaultConfigurationType);
  if (v9)
  {
    v10 = v9;
    Count = CFArrayGetCount(v9);
    if (Count < 1)
    {
      a4 = 0;
    }
    else
    {
      v12 = Count;
      v13 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v13);
        a4 = __SCNetworkConfigurationSetValue(*(SCPreferencesRef *)(a1 + 80), ValueAtIndex, a3, 0);
        if (!(_DWORD)a4)
          break;
        if (v12 == ++v13)
        {
          v15 = *(__CFDictionary **)(a1 + 104);
          if (v15)
          {
            CFDictionaryRemoveValue(v15, DefaultConfigurationType);
            if (!CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 104)))
            {
              CFRelease(*(CFTypeRef *)(a1 + 104));
              *(_QWORD *)(a1 + 104) = 0;
            }
          }
          break;
        }
      }
    }
    CFRelease(v10);
  }
  else if ((_DWORD)a4)
  {
    if (!a3)
      a3 = (const void *)*MEMORY[0x1E0C9B0D0];
    Mutable = *(__CFDictionary **)(a1 + 104);
    if (!Mutable)
    {
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      *(_QWORD *)(a1 + 104) = Mutable;
    }
    CFDictionarySetValue(Mutable, DefaultConfigurationType, a3);
    return 1;
  }
  else
  {
    _SCErrorSet(1004);
  }
  return a4;
}

__CFArray *copyConfigurationPaths(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  CFTypeRef **v6;
  uint64_t v7;
  CFStringRef NetworkServiceEntity;
  CFArrayRef v10;
  const void *v11[2];

  v4 = 0;
  v11[1] = *(const void **)MEMORY[0x1E0C80C00];
  v5 = *(const void **)(a1 + 16);
  v6 = (CFTypeRef **)configurations;
  while (!CFEqual(v5, **v6))
  {
    ++v4;
    v6 += 5;
    if (v4 == 19)
    {
      v7 = *(_QWORD *)(a1 + 96);
LABEL_8:
      NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, v7, a2);
      v11[0] = NetworkServiceEntity;
      v10 = CFArrayCreate(0, v11, 1, MEMORY[0x1E0C9B378]);
      CFRelease(NetworkServiceEntity);
      return v10;
    }
  }
  v7 = *(_QWORD *)(a1 + 96);
  if (((0x5BF13uLL >> v4) & 1) != 0)
    goto LABEL_8;
  if (v7)
    return copyPerInterfaceConfigurationPaths(a1, a2);
  return 0;
}

Boolean SCNetworkInterfaceSetConfiguration(SCNetworkInterfaceRef interface, CFDictionaryRef config)
{
  uint64_t v4;
  __CFString *DefaultConfigurationType;
  int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  CFDictionaryRef v19;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
    {
LABEL_11:
      _SCErrorSet(1002);
      goto LABEL_12;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_11;
  }
  v4 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) != v4)
    goto LABEL_11;
  DefaultConfigurationType = __SCNetworkInterfaceGetDefaultConfigurationType((uint64_t)interface);
  if (!DefaultConfigurationType)
  {
LABEL_12:
    LOBYTE(v6) = 0;
    return v6;
  }
  v6 = __SCNetworkInterfaceSetConfiguration((uint64_t)interface, DefaultConfigurationType, config, 0);
  if (v6)
  {
    v7 = __log_SCNetworkConfiguration();
    v8 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v7, (os_log_type_t)v8))
    {
      v9 = _os_log_pack_size();
      v17 = (char *)v21 - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v18 = _os_log_pack_fill();
      v19 = (CFDictionaryRef)CFSTR("NULL");
      if (config)
        v19 = config;
      *(_DWORD *)v18 = 138412546;
      *(_QWORD *)(v18 + 4) = interface;
      *(_WORD *)(v18 + 12) = 2112;
      *(_QWORD *)(v18 + 14) = v19;
      __SC_log_send(7, (uint64_t)v7, v8, v17);
    }
  }
  return v6;
}

Boolean SCNetworkInterfaceSetExtendedConfiguration(SCNetworkInterfaceRef interface, CFStringRef extendedType, CFDictionaryRef config)
{
  uint64_t v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  CFDictionaryRef v20;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!interface)
    {
LABEL_11:
      _SCErrorSet(1002);
      goto LABEL_12;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!interface)
      goto LABEL_11;
  }
  v6 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) != v6)
    goto LABEL_11;
  if (!__SCNetworkInterfaceIsValidExtendedConfigurationType(interface, extendedType, 1))
  {
LABEL_12:
    LOBYTE(v7) = 0;
    return v7;
  }
  v7 = __SCNetworkInterfaceSetConfiguration((uint64_t)interface, (__CFString *)extendedType, config, 0);
  if (v7)
  {
    v8 = __log_SCNetworkConfiguration();
    v9 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v8, (os_log_type_t)v9))
    {
      v10 = _os_log_pack_size();
      v18 = (char *)v22 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v19 = _os_log_pack_fill();
      v20 = (CFDictionaryRef)CFSTR("NULL");
      if (config)
        v20 = config;
      *(_DWORD *)v19 = 138412546;
      *(_QWORD *)(v19 + 4) = interface;
      *(_WORD *)(v19 + 12) = 2112;
      *(_QWORD *)(v19 + 14) = v20;
      __SC_log_send(7, (uint64_t)v8, v9, v18);
    }
  }
  return v7;
}

uint64_t _SCNetworkInterfaceForceConfigurationRefresh(const __CFString *a1)
{
  CFTypeID TypeID;
  const __CFString *NetworkInterfaceEntity;
  uint64_t v4;

  TypeID = CFStringGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID)
  {
    NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, CFSTR("State:"), a1, CFSTR("RefreshConfiguration"));
    v4 = SCDynamicStoreNotifyValue(0, NetworkInterfaceEntity);
    CFRelease(NetworkInterfaceEntity);
    return v4;
  }
  else
  {
    _SCErrorSet(1002);
    return 0;
  }
}

Boolean SCNetworkInterfaceForceConfigurationRefresh(SCNetworkInterfaceRef interface)
{
  uint64_t v2;
  const __CFString *BSDName;
  const __CFString *v4;
  uint64_t v5;
  int helper;
  mach_port_t *v7;
  int v8;
  int v9;
  int v11;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  if (__SCNetworkInterfaceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (interface)
      goto LABEL_3;
LABEL_20:
    v9 = 1002;
    goto LABEL_21;
  }
  if (!interface)
    goto LABEL_20;
LABEL_3:
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(interface) != v2)
    goto LABEL_20;
  BSDName = SCNetworkInterfaceGetBSDName(interface);
  if (!BSDName)
    goto LABEL_20;
  v4 = BSDName;
  v5 = *((_QWORD *)interface + 10);
  if (!v5 || !*(_QWORD *)(v5 + 312))
  {
    LOBYTE(helper) = _SCNetworkInterfaceForceConfigurationRefresh(BSDName);
    return helper;
  }
  cf[0] = 0;
  v11 = 0;
  if (*(_DWORD *)(v5 + 320) || (helper = __SCPreferencesCreate_helper(v5)) != 0)
  {
    v7 = (mach_port_t *)(v5 + 320);
    if (!_SCSerializeString(v4, (CFDataRef *)cf, 0, 0))
      goto LABEL_25;
    v11 = 0;
    v8 = _SCHelperExec(*v7, 200, (const __CFData *)cf[0], &v11, 0);
    if (cf[0])
      CFRelease(cf[0]);
    if (v8)
    {
      v9 = v11;
      if (!v11)
      {
        LOBYTE(helper) = 1;
        return helper;
      }
    }
    else
    {
LABEL_25:
      if (*v7)
        _SCHelperClose(v7);
      v9 = 1003;
      v11 = 1003;
    }
LABEL_21:
    _SCErrorSet(v9);
    LOBYTE(helper) = 0;
  }
  return helper;
}

uint64_t SCNetworkInterfaceCheckPassword(const __SCNetworkInterface *a1, int a2)
{
  const __CFDictionary *Configuration;
  const __CFDictionary *PasswordID;
  uint64_t v6;
  const void **v7;
  CFStringRef InterfaceType;
  const __CFDictionary *ExtendedConfiguration;
  const __CFDictionary *v10;
  const void *Value;
  CFTypeID TypeID;
  const __CFDictionary *v14;
  __CFString *v15;
  uint64_t v16;
  const __CFString *v17;
  __CFString *v18;
  const void **v19;
  uint64_t password;
  uint64_t v21;
  int v22[2];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v21 = 0;
  *(_QWORD *)v22 = 0;
  if (checkInterfacePassword(a1, a2, v22, &v21))
  {
    switch(a2)
    {
      case 1:
        Configuration = SCNetworkInterfaceGetConfiguration(a1);
        PasswordID = getPasswordID(Configuration, v21);
        v6 = *(_QWORD *)v22;
        v7 = (const void **)&kSCValNetPPPAuthPasswordEncryptionKeychain;
        return __extract_password(v6, Configuration, CFSTR("AuthPassword"), CFSTR("AuthPasswordEncryption"), *v7, (uint64_t)PasswordID, 0);
      case 2:
        InterfaceType = SCNetworkInterfaceGetInterfaceType(a1);
        if (CFEqual(InterfaceType, CFSTR("PPP")))
          ExtendedConfiguration = SCNetworkInterfaceGetExtendedConfiguration(a1, CFSTR("IPSec"));
        else
          ExtendedConfiguration = SCNetworkInterfaceGetConfiguration(a1);
        v14 = ExtendedConfiguration;
        v15 = copySharedSecretID(ExtendedConfiguration, v21);
        v16 = *(_QWORD *)v22;
        v17 = CFSTR("SharedSecret");
        v18 = CFSTR("SharedSecretEncryption");
        v19 = (const void **)&kSCValNetIPSecSharedSecretEncryptionKeychain;
        goto LABEL_16;
      case 3:
        v10 = SCNetworkInterfaceGetExtendedConfiguration(a1, CFSTR("EAPOL"));
        if (v10)
        {
          Value = CFDictionaryGetValue(v10, CFSTR("UserPasswordKeychainItemID"));
          TypeID = CFStringGetTypeID();
          if (Value && CFGetTypeID(Value) == TypeID)
            return _SCPreferencesSystemKeychainPasswordItemExists();
        }
        else
        {
          CFStringGetTypeID();
        }
        break;
      case 4:
        v14 = SCNetworkInterfaceGetConfiguration(a1);
        v15 = copyXAuthID(v14, v21);
        v16 = *(_QWORD *)v22;
        v17 = CFSTR("XAuthPassword");
        v18 = CFSTR("XAuthPasswordEncryption");
        v19 = (const void **)&kSCValNetIPSecXAuthPasswordEncryptionKeychain;
LABEL_16:
        password = __extract_password(v16, v14, v17, v18, *v19, (uint64_t)v15, 0);
        CFRelease(v15);
        return password;
      case 5:
        Configuration = SCNetworkInterfaceGetConfiguration(a1);
        PasswordID = getPasswordID(Configuration, v21);
        v6 = *(_QWORD *)v22;
        v7 = (const void **)kSCValNetVPNAuthPasswordEncryptionKeychain;
        return __extract_password(v6, Configuration, CFSTR("AuthPassword"), CFSTR("AuthPasswordEncryption"), *v7, (uint64_t)PasswordID, 0);
      default:
        _SCErrorSet(1002);
        return 0;
    }
  }
  return 0;
}

uint64_t checkInterfacePassword(CFTypeRef cf, int a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  CFStringRef InterfaceType;
  const __CFString *v13;
  CFStringRef v14;
  const __SCNetworkInterface *Interface;

  if (__SCNetworkInterfaceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (cf)
      goto LABEL_3;
LABEL_17:
    _SCErrorSet(1002);
    return 0;
  }
  if (!cf)
    goto LABEL_17;
LABEL_3:
  v8 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) != v8)
    goto LABEL_17;
  v9 = *((_QWORD *)cf + 12);
  *a4 = v9;
  if (!v9)
    goto LABEL_17;
  v10 = *((_QWORD *)cf + 10);
  *a3 = v10;
  if (!v10)
    goto LABEL_17;
  result = 1;
  switch(a2)
  {
    case 1:
      InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)cf);
      v13 = CFSTR("PPP");
      goto LABEL_14;
    case 2:
      v14 = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)cf);
      if (CFEqual(v14, CFSTR("PPP")))
      {
        Interface = SCNetworkInterfaceGetInterface((SCNetworkInterfaceRef)cf);
        if (!Interface)
          goto LABEL_17;
        InterfaceType = SCNetworkInterfaceGetInterfaceType(Interface);
        v13 = CFSTR("L2TP");
      }
      else
      {
        v13 = CFSTR("IPSec");
        InterfaceType = v14;
      }
LABEL_14:
      if (!CFEqual(InterfaceType, v13))
        goto LABEL_17;
      result = 1;
      break;
    case 4:
      InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)cf);
      v13 = CFSTR("IPSec");
      goto LABEL_14;
    case 5:
      InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)cf);
      v13 = CFSTR("VPN");
      goto LABEL_14;
    default:
      return result;
  }
  return result;
}

const __CFDictionary *getPasswordID(const __CFDictionary *result, uint64_t a2)
{
  const __CFDictionary *v3;
  const void *Value;
  CFTypeID TypeID;

  if (result)
  {
    v3 = result;
    Value = CFDictionaryGetValue(result, CFSTR("AuthPasswordEncryption"));
    TypeID = CFStringGetTypeID();
    if (Value && CFGetTypeID(Value) == TypeID && CFEqual(Value, CFSTR("Keychain")))
      result = (const __CFDictionary *)CFDictionaryGetValue(v3, CFSTR("AuthPassword"));
    else
      result = 0;
  }
  if (!result)
    return (const __CFDictionary *)a2;
  return result;
}

__CFString *copySharedSecretID(CFDictionaryRef theDict, uint64_t a2)
{
  const void *Value;
  CFTypeID TypeID;
  __CFString *v6;
  __CFString *MutableCopy;
  const __CFString *PasswordID;

  if (theDict
    && (Value = CFDictionaryGetValue(theDict, CFSTR("SharedSecretEncryption")), TypeID = CFStringGetTypeID(), Value)
    && CFGetTypeID(Value) == TypeID
    && CFEqual(Value, CFSTR("Keychain"))
    && (v6 = (__CFString *)CFDictionaryGetValue(theDict, CFSTR("SharedSecret"))) != 0)
  {
    MutableCopy = v6;
    CFRetain(v6);
  }
  else
  {
    PasswordID = (const __CFString *)getPasswordID(theDict, a2);
    MutableCopy = CFStringCreateMutableCopy(0, 0, PasswordID);
    CFStringAppend(MutableCopy, CFSTR(".SS"));
  }
  return MutableCopy;
}

__CFString *copyXAuthID(CFDictionaryRef theDict, uint64_t a2)
{
  const void *Value;
  CFTypeID TypeID;
  __CFString *v6;
  __CFString *MutableCopy;
  const __CFString *PasswordID;

  if (theDict
    && (Value = CFDictionaryGetValue(theDict, CFSTR("XAuthPasswordEncryption")), TypeID = CFStringGetTypeID(), Value)
    && CFGetTypeID(Value) == TypeID
    && CFEqual(Value, CFSTR("Keychain"))
    && (v6 = (__CFString *)CFDictionaryGetValue(theDict, CFSTR("XAuthPassword"))) != 0)
  {
    MutableCopy = v6;
    CFRetain(v6);
  }
  else
  {
    PasswordID = (const __CFString *)getPasswordID(theDict, a2);
    MutableCopy = CFStringCreateMutableCopy(0, 0, PasswordID);
    CFStringAppend(MutableCopy, CFSTR(".XAUTH"));
  }
  return MutableCopy;
}

uint64_t SCNetworkInterfaceCopyPassword(const __SCNetworkInterface *a1, int a2)
{
  const __CFDictionary *Configuration;
  const __CFDictionary *PasswordID;
  uint64_t v6;
  const void **v7;
  int v8;
  CFStringRef InterfaceType;
  const __CFDictionary *ExtendedConfiguration;
  const __CFDictionary *v11;
  const void *Value;
  CFTypeID TypeID;
  const __CFDictionary *v14;
  __CFString *v15;
  uint64_t v16;
  const __CFString *v17;
  __CFString *v18;
  const void **v19;
  uint64_t v21;
  int v22[2];
  uint64_t v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v22 = 0;
  v23[0] = 0;
  v21 = 0;
  if (checkInterfacePassword(a1, a2, v22, &v21))
  {
    switch(a2)
    {
      case 1:
        Configuration = SCNetworkInterfaceGetConfiguration(a1);
        PasswordID = getPasswordID(Configuration, v21);
        v6 = *(_QWORD *)v22;
        v7 = (const void **)&kSCValNetPPPAuthPasswordEncryptionKeychain;
        goto LABEL_13;
      case 2:
        InterfaceType = SCNetworkInterfaceGetInterfaceType(a1);
        if (CFEqual(InterfaceType, CFSTR("PPP")))
          ExtendedConfiguration = SCNetworkInterfaceGetExtendedConfiguration(a1, CFSTR("IPSec"));
        else
          ExtendedConfiguration = SCNetworkInterfaceGetConfiguration(a1);
        v14 = ExtendedConfiguration;
        v15 = copySharedSecretID(ExtendedConfiguration, v21);
        v16 = *(_QWORD *)v22;
        v17 = CFSTR("SharedSecret");
        v18 = CFSTR("SharedSecretEncryption");
        v19 = (const void **)&kSCValNetIPSecSharedSecretEncryptionKeychain;
        goto LABEL_20;
      case 3:
        v11 = SCNetworkInterfaceGetExtendedConfiguration(a1, CFSTR("EAPOL"));
        if (v11)
        {
          Value = CFDictionaryGetValue(v11, CFSTR("UserPasswordKeychainItemID"));
          TypeID = CFStringGetTypeID();
          if (Value && CFGetTypeID(Value) == TypeID)
          {
            v23[0] = _SCPreferencesSystemKeychainPasswordItemCopy();
            return v23[0];
          }
        }
        else
        {
          CFStringGetTypeID();
        }
        v8 = 1001;
LABEL_16:
        _SCErrorSet(v8);
        break;
      case 4:
        v14 = SCNetworkInterfaceGetConfiguration(a1);
        v15 = copyXAuthID(v14, v21);
        v16 = *(_QWORD *)v22;
        v17 = CFSTR("XAuthPassword");
        v18 = CFSTR("XAuthPasswordEncryption");
        v19 = (const void **)&kSCValNetIPSecXAuthPasswordEncryptionKeychain;
LABEL_20:
        __extract_password(v16, v14, v17, v18, *v19, (uint64_t)v15, v23);
        CFRelease(v15);
        return v23[0];
      case 5:
        Configuration = SCNetworkInterfaceGetConfiguration(a1);
        PasswordID = getPasswordID(Configuration, v21);
        v6 = *(_QWORD *)v22;
        v7 = (const void **)kSCValNetVPNAuthPasswordEncryptionKeychain;
LABEL_13:
        __extract_password(v6, Configuration, CFSTR("AuthPassword"), CFSTR("AuthPasswordEncryption"), *v7, (uint64_t)PasswordID, v23);
        return v23[0];
      default:
        v8 = 1002;
        goto LABEL_16;
    }
  }
  return 0;
}

uint64_t SCNetworkInterfaceRemovePassword(const __SCNetworkInterface *a1, int a2)
{
  const __CFDictionary *Configuration;
  const __CFDictionary *PasswordID;
  uint64_t v6;
  const void **v7;
  int v8;
  CFStringRef InterfaceType;
  int v10;
  const __CFDictionary *ExtendedConfiguration;
  const __CFDictionary *v12;
  const void *Value;
  CFTypeID TypeID;
  const __CFDictionary *v16;
  __CFString *v17;
  uint64_t v18;
  CFDictionaryRef v19;
  const __CFDictionary *v20;
  uint64_t v21;
  CFDictionaryRef config;
  uint64_t v23;
  int v24[2];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  *(_QWORD *)v24 = 0;
  if (checkInterfacePassword(a1, a2, v24, &v23))
  {
    switch(a2)
    {
      case 1:
        config = 0;
        Configuration = SCNetworkInterfaceGetConfiguration(a1);
        PasswordID = getPasswordID(Configuration, v23);
        v6 = *(_QWORD *)v24;
        v7 = (const void **)&kSCValNetPPPAuthPasswordEncryptionKeychain;
        goto LABEL_14;
      case 2:
        config = 0;
        InterfaceType = SCNetworkInterfaceGetInterfaceType(a1);
        v10 = CFEqual(InterfaceType, CFSTR("PPP"));
        if (v10)
          ExtendedConfiguration = SCNetworkInterfaceGetExtendedConfiguration(a1, CFSTR("IPSec"));
        else
          ExtendedConfiguration = SCNetworkInterfaceGetConfiguration(a1);
        v20 = ExtendedConfiguration;
        v17 = copySharedSecretID(ExtendedConfiguration, v23);
        if (!__remove_password(*(uint64_t *)v24, v20, CFSTR("SharedSecret"), CFSTR("SharedSecretEncryption"), CFSTR("Keychain"), (uint64_t)v17, &config))goto LABEL_28;
        if (!v10)
          goto LABEL_25;
        v21 = SCNetworkInterfaceSetExtendedConfiguration(a1, CFSTR("IPSec"), config);
        goto LABEL_26;
      case 3:
        v12 = SCNetworkInterfaceGetExtendedConfiguration(a1, CFSTR("EAPOL"));
        if (v12)
        {
          Value = CFDictionaryGetValue(v12, CFSTR("UserPasswordKeychainItemID"));
          TypeID = CFStringGetTypeID();
          if (Value && CFGetTypeID(Value) == TypeID)
            return _SCPreferencesSystemKeychainPasswordItemRemove();
        }
        else
        {
          CFStringGetTypeID();
        }
        v8 = 1001;
LABEL_19:
        _SCErrorSet(v8);
        break;
      case 4:
        config = 0;
        v16 = SCNetworkInterfaceGetConfiguration(a1);
        v17 = copyXAuthID(v16, v23);
        if (__remove_password(*(uint64_t *)v24, v16, CFSTR("XAuthPassword"), CFSTR("XAuthPasswordEncryption"), CFSTR("Keychain"), (uint64_t)v17, &config))
        {
LABEL_25:
          v21 = SCNetworkInterfaceSetConfiguration(a1, config);
LABEL_26:
          v18 = v21;
          if (config)
            CFRelease(config);
        }
        else
        {
LABEL_28:
          v18 = 0;
        }
        v19 = (CFDictionaryRef)v17;
        goto LABEL_30;
      case 5:
        config = 0;
        Configuration = SCNetworkInterfaceGetConfiguration(a1);
        PasswordID = getPasswordID(Configuration, v23);
        v6 = *(_QWORD *)v24;
        v7 = (const void **)kSCValNetVPNAuthPasswordEncryptionKeychain;
LABEL_14:
        if (!__remove_password(v6, Configuration, CFSTR("AuthPassword"), CFSTR("AuthPasswordEncryption"), *v7, (uint64_t)PasswordID, &config))return 0;
        v18 = SCNetworkInterfaceSetConfiguration(a1, config);
        v19 = config;
        if (!config)
          return v18;
LABEL_30:
        CFRelease(v19);
        return v18;
      default:
        v8 = 1002;
        goto LABEL_19;
    }
  }
  return 0;
}

uint64_t SCNetworkInterfaceSetPassword(const void *a1, int a2)
{
  const __CFDictionary *Configuration;
  const __CFString *v5;
  const __CFDictionary *PasswordID;
  const __SCNetworkService *Private;
  uint64_t v8;
  CFStringRef InterfaceType;
  int v10;
  CFDictionaryRef v11;
  const __CFDictionary *v12;
  const __CFDictionary *ExtendedConfiguration;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  const void *v16;
  CFTypeID TypeID;
  const __CFDictionary *v18;
  const __CFString *v19;
  __CFString *v20;
  const __CFDictionary *v21;
  const __CFString *v22;
  const __CFDictionary *v23;
  const __CFUUID *v24;
  CFStringRef v25;
  __CFDictionary *v26;
  const __CFString *v27;
  __CFString *v28;
  const __CFDictionary *v29;
  const __SCNetworkService *v30;
  __CFDictionary *MutableCopy;
  CFStringRef v32;
  __CFDictionary *v33;
  __CFDictionary *Mutable;
  CFStringRef LocalizedDisplayName;
  const __CFString *v36;
  CFStringRef v37;
  CFStringRef v38;
  __CFDictionary *v39;
  const void **v40;
  __CFDictionary *v41;
  const __CFDictionary *v42;
  const void *v43;
  const void *v44;
  __CFDictionary *v45;
  __CFDictionary *v46;
  uint64_t v47;
  int v49;
  void *value;
  void *v51;
  const __CFString *v52;
  const void *v53[2];

  v53[1] = *(const void **)MEMORY[0x1E0C80C00];
  v52 = 0;
  v53[0] = 0;
  if (!checkInterfacePassword(a1, a2, v53, &v52))
    return 0;
  switch(a2)
  {
    case 1:
      Configuration = SCNetworkInterfaceGetConfiguration((SCNetworkInterfaceRef)a1);
      v5 = v52;
      PasswordID = getPasswordID(Configuration, (uint64_t)v52);
      if (Configuration
        && (CFDictionaryGetValue(Configuration, CFSTR("AuthName")),
            CFDictionaryGetValue(Configuration, CFSTR("UserDefinedName"))))
      {
        Private = 0;
      }
      else
      {
        Private = (const __SCNetworkService *)__SCNetworkServiceCreatePrivate(0, v53[0], v5, a1);
        if (!SCNetworkServiceGetName(Private))
          SCNetworkInterfaceGetLocalizedDisplayName((SCNetworkInterfaceRef)a1);
      }
      if (bundle)
        v25 = CFBundleCopyLocalizedString((CFBundleRef)bundle, CFSTR("KEYCHAIN_KIND_PPP_PASSWORD"), CFSTR("PPP Password"), 0);
      else
        v25 = 0;
      if (!_SCPreferencesSystemKeychainPasswordItemSet())
        goto LABEL_52;
      if (Configuration)
        MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Configuration);
      else
        MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v39 = MutableCopy;
      CFDictionarySetValue(MutableCopy, CFSTR("AuthPassword"), PasswordID);
      v40 = (const void **)&kSCValNetPPPAuthPasswordEncryptionKeychain;
      goto LABEL_88;
    case 2:
      InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a1);
      v10 = CFEqual(InterfaceType, CFSTR("PPP"));
      v11 = SCNetworkInterfaceGetConfiguration((SCNetworkInterfaceRef)a1);
      v12 = v11;
      if (v10)
      {
        ExtendedConfiguration = SCNetworkInterfaceGetExtendedConfiguration((SCNetworkInterfaceRef)a1, CFSTR("IPSec"));
      }
      else
      {
        ExtendedConfiguration = v11;
        v12 = 0;
      }
      v27 = v52;
      v28 = copySharedSecretID(ExtendedConfiguration, (uint64_t)v52);
      v49 = v10;
      if (!ExtendedConfiguration)
        goto LABEL_54;
      value = 0;
      v51 = 0;
      if (CFDictionaryGetValueIfPresent(ExtendedConfiguration, CFSTR("LocalIdentifierType"), (const void **)&value)
        && CFEqual(value, CFSTR("KeyID"))
        && CFDictionaryGetValueIfPresent(ExtendedConfiguration, CFSTR("LocalIdentifier"), (const void **)&v51))
      {
        isA_CFString(v51);
      }
      if (((v29 = ExtendedConfiguration, !v10) || (v29 = v12) != 0)
        && CFDictionaryGetValue(v29, CFSTR("UserDefinedName")))
      {
        v30 = 0;
      }
      else
      {
LABEL_54:
        v30 = (const __SCNetworkService *)__SCNetworkServiceCreatePrivate(0, v53[0], v27, a1);
        if (!SCNetworkServiceGetName(v30))
          SCNetworkInterfaceGetLocalizedDisplayName((SCNetworkInterfaceRef)a1);
      }
      if (bundle)
        v32 = CFBundleCopyLocalizedString((CFBundleRef)bundle, CFSTR("KEYCHAIN_KIND_IPSEC_SHARED_SECRET"), CFSTR("IPSec Shared Secret"), 0);
      else
        v32 = 0;
      Private = (const __SCNetworkService *)v28;
      if (_SCPreferencesSystemKeychainPasswordItemSet())
      {
        if (ExtendedConfiguration)
          Mutable = CFDictionaryCreateMutableCopy(0, 0, ExtendedConfiguration);
        else
          Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v46 = Mutable;
        CFDictionarySetValue(Mutable, CFSTR("SharedSecret"), v28);
        CFDictionarySetValue(v46, CFSTR("SharedSecretEncryption"), CFSTR("Keychain"));
        if (v49)
          v47 = SCNetworkInterfaceSetExtendedConfiguration((SCNetworkInterfaceRef)a1, CFSTR("IPSec"), v46);
        else
          v47 = SCNetworkInterfaceSetConfiguration((SCNetworkInterfaceRef)a1, v46);
        v8 = v47;
        CFRelease(v46);
      }
      else
      {
        v8 = 0;
      }
      if (v32)
        CFRelease(v32);
      if (v30)
        CFRelease(v30);
      goto LABEL_105;
    case 3:
      v14 = SCNetworkInterfaceGetExtendedConfiguration((SCNetworkInterfaceRef)a1, CFSTR("EAPOL"));
      v15 = v14;
      if (v14
        && (v16 = CFDictionaryGetValue(v14, CFSTR("UserPasswordKeychainItemID")), TypeID = CFStringGetTypeID(), v16)
        && CFGetTypeID(v16) == TypeID)
      {
        CFRetain(v16);
      }
      else
      {
        v24 = CFUUIDCreate(0);
        v16 = CFUUIDCreateString(0, v24);
        CFRelease(v24);
        if (!v15)
          goto LABEL_68;
      }
      CFDictionaryGetValue(v15, CFSTR("UserName"));
LABEL_68:
      if (bundle)
      {
        LocalizedDisplayName = SCNetworkInterfaceGetLocalizedDisplayName((SCNetworkInterfaceRef)a1);
        if (LocalizedDisplayName)
        {
          v36 = CFBundleCopyLocalizedString((CFBundleRef)bundle, CFSTR("KEYCHAIN_DESCRIPTION_EAPOL_INTERFACE"), CFSTR("Network Connection (%@)"), 0);
          v37 = CFStringCreateWithFormat(0, 0, v36, LocalizedDisplayName);
          CFRelease(v36);
        }
        else
        {
          v37 = CFBundleCopyLocalizedString((CFBundleRef)bundle, CFSTR("KEYCHAIN_DESCRIPTION_EAPOL"), CFSTR("Network Connection"), 0);
        }
        v38 = CFBundleCopyLocalizedString((CFBundleRef)bundle, CFSTR("KEYCHAIN_KIND_EAPOL"), CFSTR("802.1X Password"), 0);
      }
      else
      {
        v38 = 0;
        v37 = 0;
      }
      if (_SCPreferencesSystemKeychainPasswordItemSet())
      {
        if (v15)
          v41 = CFDictionaryCreateMutableCopy(0, 0, v15);
        else
          v41 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v42 = v41;
        CFDictionarySetValue(v41, CFSTR("UserPasswordKeychainItemID"), v16);
        v8 = SCNetworkInterfaceSetExtendedConfiguration((SCNetworkInterfaceRef)a1, CFSTR("EAPOL"), v42);
        CFRelease(v42);
      }
      else
      {
        v8 = 0;
      }
      CFRelease(v16);
      if (v37)
        CFRelease(v37);
      if (!v38)
        return v8;
      v43 = v38;
      goto LABEL_106;
    case 4:
      v18 = SCNetworkInterfaceGetConfiguration((SCNetworkInterfaceRef)a1);
      v19 = v52;
      v20 = copyXAuthID(v18, (uint64_t)v52);
      if (v18 && (CFDictionaryGetValue(v18, CFSTR("XAuthName")), CFDictionaryGetValue(v18, CFSTR("UserDefinedName"))))
      {
        Private = 0;
      }
      else
      {
        Private = (const __SCNetworkService *)__SCNetworkServiceCreatePrivate(0, v53[0], v19, a1);
        if (!SCNetworkServiceGetName(Private))
          SCNetworkInterfaceGetLocalizedDisplayName((SCNetworkInterfaceRef)a1);
      }
      if (bundle)
        v25 = CFBundleCopyLocalizedString((CFBundleRef)bundle, CFSTR("KEYCHAIN_KIND_IPSEC_XAUTH_PASSWORD"), CFSTR("IPSec XAuth Password"), 0);
      else
        v25 = 0;
      if (_SCPreferencesSystemKeychainPasswordItemSet())
      {
        if (v18)
          v33 = CFDictionaryCreateMutableCopy(0, 0, v18);
        else
          v33 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v45 = v33;
        CFDictionarySetValue(v33, CFSTR("XAuthPassword"), v20);
        CFDictionarySetValue(v45, CFSTR("XAuthPasswordEncryption"), CFSTR("Keychain"));
        v8 = SCNetworkInterfaceSetConfiguration((SCNetworkInterfaceRef)a1, v45);
        CFRelease(v45);
      }
      else
      {
        v8 = 0;
      }
      v44 = v20;
      goto LABEL_92;
    case 5:
      v21 = SCNetworkInterfaceGetConfiguration((SCNetworkInterfaceRef)a1);
      v22 = v52;
      v23 = getPasswordID(v21, (uint64_t)v52);
      if (v21 && (CFDictionaryGetValue(v21, CFSTR("AuthName")), CFDictionaryGetValue(v21, CFSTR("UserDefinedName"))))
      {
        Private = 0;
      }
      else
      {
        Private = (const __SCNetworkService *)__SCNetworkServiceCreatePrivate(0, v53[0], v22, a1);
        if (!SCNetworkServiceGetName(Private))
          SCNetworkInterfaceGetLocalizedDisplayName((SCNetworkInterfaceRef)a1);
      }
      if (bundle)
        v25 = CFBundleCopyLocalizedString((CFBundleRef)bundle, CFSTR("KEYCHAIN_KIND_VPN_PASSWORD"), CFSTR("VPN Password"), 0);
      else
        v25 = 0;
      if (!_SCPreferencesSystemKeychainPasswordItemSet())
      {
LABEL_52:
        v8 = 0;
        if (!v25)
          goto LABEL_94;
        goto LABEL_93;
      }
      if (v21)
        v26 = CFDictionaryCreateMutableCopy(0, 0, v21);
      else
        v26 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v39 = v26;
      CFDictionarySetValue(v26, CFSTR("AuthPassword"), v23);
      v40 = (const void **)kSCValNetVPNAuthPasswordEncryptionKeychain;
LABEL_88:
      CFDictionarySetValue(v39, CFSTR("AuthPasswordEncryption"), *v40);
      v8 = SCNetworkInterfaceSetConfiguration((SCNetworkInterfaceRef)a1, v39);
      v44 = v39;
LABEL_92:
      CFRelease(v44);
      if (v25)
LABEL_93:
        CFRelease(v25);
LABEL_94:
      if (Private)
      {
LABEL_105:
        v43 = Private;
LABEL_106:
        CFRelease(v43);
      }
      break;
    default:
      _SCErrorSet(1002);
      return 0;
  }
  return v8;
}

uint64_t SCNetworkInterfaceSetAdvisory(const __SCNetworkInterface *a1, unsigned int a2, const __CFString *a3)
{
  _QWORD *IPMonitorControl;
  CFStringRef theString[2];

  theString[1] = *(CFStringRef *)MEMORY[0x1E0C80C00];
  theString[0] = 0;
  IPMonitorControl = (_QWORD *)_SCNetworkInterfaceGetIPMonitorControl(a1, theString);
  if (IPMonitorControl)
    return IPMonitorControlSetInterfaceAdvisory(IPMonitorControl, theString[0], a2, a3);
  else
    return 0;
}

uint64_t _SCNetworkInterfaceGetIPMonitorControl(const __SCNetworkInterface *a1, CFStringRef *a2)
{
  CFStringRef BSDName;
  uint64_t result;
  int v6;

  BSDName = SCNetworkInterfaceGetBSDName(a1);
  if (!BSDName)
  {
    v6 = 1002;
    goto LABEL_6;
  }
  result = *((_QWORD *)a1 + 50);
  if (!result)
  {
    result = IPMonitorControlCreate();
    if (result)
    {
      *((_QWORD *)a1 + 50) = result;
      goto LABEL_7;
    }
    v6 = 1001;
LABEL_6:
    _SCErrorSet(v6);
    result = 0;
  }
LABEL_7:
  *a2 = BSDName;
  return result;
}

BOOL SCNetworkInterfaceAdvisoryIsSpecificSet(const __SCNetworkInterface *a1, unsigned int a2)
{
  uint64_t IPMonitorControl;
  CFStringRef theString[2];

  theString[1] = *(CFStringRef *)MEMORY[0x1E0C80C00];
  theString[0] = 0;
  IPMonitorControl = _SCNetworkInterfaceGetIPMonitorControl(a1, theString);
  return IPMonitorControl && IPMonitorControlIsInterfaceAdvisorySet(IPMonitorControl, theString[0], a2);
}

BOOL SCNetworkInterfaceAdvisoryIsSet(const __SCNetworkInterface *a1)
{
  return SCNetworkInterfaceAdvisoryIsSpecificSet(a1, 0);
}

CFStringRef SCNetworkInterfaceCopyAdvisoryNotificationKey(const __SCNetworkInterface *a1)
{
  const __CFString *BSDName;

  BSDName = SCNetworkInterfaceGetBSDName(a1);
  if (BSDName)
    return IPMonitorControlCopyInterfaceAdvisoryNotificationKey(BSDName);
  _SCErrorSet(1002);
  return 0;
}

uint64_t SCNetworkInterfaceCopyAdvisoryInfo(const __SCNetworkInterface *a1)
{
  uint64_t result;
  CFStringRef v2[2];

  v2[1] = *(CFStringRef *)MEMORY[0x1E0C80C00];
  v2[0] = 0;
  result = _SCNetworkInterfaceGetIPMonitorControl(a1, v2);
  if (result)
  {
    result = IPMonitorControlCopyInterfaceAdvisoryInfo(result, v2[0]);
    if (!result)
    {
      _SCErrorSet(1001);
      return 0;
    }
  }
  return result;
}

uint64_t SCNetworkInterfaceAdvisoryInfoGetAdvisory(const __CFDictionary *a1)
{
  return InterfaceAdvisoryInfoGetAdvisory(a1);
}

uint64_t SCNetworkInterfaceAdvisoryInfoGetProcessID(const __CFDictionary *a1)
{
  return InterfaceRankAssertionInfoGetProcessID(a1);
}

const void *SCNetworkInterfaceAdvisoryInfoGetProcessName(const __CFDictionary *a1)
{
  return InterfaceRankAssertionInfoGetProcessName(a1);
}

uint64_t SCNetworkInterfaceAdvisoryCopyInterfaceNames()
{
  uint64_t v0;
  const void *v1;
  uint64_t v2;

  v0 = IPMonitorControlCreate();
  if (v0)
  {
    v1 = (const void *)v0;
    v2 = IPMonitorControlCopyInterfaceAdvisoryInterfaceNames(v0);
    if (!v2)
      _SCErrorSet(1001);
    CFRelease(v1);
  }
  else
  {
    _SCErrorSet(1001);
    return 0;
  }
  return v2;
}

uint64_t _SCNetworkInterfaceCreateWithIONetworkInterfaceObject(uint64_t object)
{
  void *v2;
  const __CFString *v3;
  uint64_t v4;
  int v5;

  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  if (IOObjectConformsTo(object, "IONetworkInterface"))
  {
    v2 = processNetworkInterface;
    v3 = CFSTR("HiddenInterface");
    v4 = object;
    v5 = 1;
    return createInterface(v4, (unsigned int (*)(uint64_t, uint64_t, __CFDictionary *, _QWORD, __CFDictionary *, _QWORD, __CFDictionary *))v2, v3, v5);
  }
  if (IOObjectConformsTo(object, "IOSerialBSDClient"))
  {
    v2 = processSerialInterface;
    v3 = CFSTR("HiddenPort");
    v4 = object;
    v5 = 0;
    return createInterface(v4, (unsigned int (*)(uint64_t, uint64_t, __CFDictionary *, _QWORD, __CFDictionary *, _QWORD, __CFDictionary *))v2, v3, v5);
  }
  return 0;
}

uint64_t _SCNetworkInterfaceGetConfigurationAction(uint64_t a1)
{
  return *(_QWORD *)(a1 + 184);
}

uint64_t _SCNetworkInterfaceIsBuiltin(unsigned __int8 *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[176];
  return 0;
}

uint64_t _SCNetworkInterfaceIsTrustRequired(unsigned __int8 *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[240];
  return 0;
}

const void *_SCNetworkInterfaceCopySlashDevPath(SCNetworkInterfaceRef interface)
{
  void *v1;
  const CFDictionaryKeyCallBacks *v3;
  const CFDictionaryValueCallBacks *v4;
  CFDictionaryRef v5;
  const __CFDictionary *v6;
  kern_return_t MatchingServices;
  kern_return_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  _DWORD *v20;
  const void *CFProperty;
  io_registry_entry_t v22;
  io_registry_entry_t v23;
  const __CFDictionary *v24;
  const __CFDictionary *v25;
  const void *Value;
  CFTypeRef v27;
  CFTypeID TypeID;
  CFTypeID v29;
  CFStringRef BSDName;
  uint64_t v32;
  void *values;
  CFDictionaryRef v34;
  void *keys;
  const __CFString *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  HIDWORD(v32) = 0;
  v1 = (void *)*((_QWORD *)interface + 14);
  if (!v1)
    return 0;
  keys = 0;
  v36 = 0;
  values = 0;
  v34 = 0;
  if (*((_QWORD *)interface + 15))
  {
    keys = CFSTR("IOTTYBaseName");
    values = v1;
    v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    v5 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    keys = CFSTR("IOProviderClass");
    v36 = CFSTR("IOPropertyMatch");
    values = CFSTR("IOSerialBSDClient");
    v34 = v5;
    v6 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 2, v3, v4);
    CFRelease(v5);
    MatchingServices = IOServiceGetMatchingServices(masterPort, v6, (io_iterator_t *)&v32 + 1);
    if (MatchingServices)
    {
      v8 = MatchingServices;
      v9 = __log_SCNetworkConfiguration();
      v10 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v9, (os_log_type_t)v10))
      {
        v11 = _os_log_pack_size();
        v19 = (char *)&v32 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v20 = (_DWORD *)_os_log_pack_fill();
        *v20 = 67109120;
        v20[1] = v8;
        __SC_log_send(6, (uint64_t)v9, v10, v19);
      }
      goto LABEL_24;
    }
    while (1)
    {
      v22 = IOIteratorNext(HIDWORD(v32));
      if (!v22)
      {
        IOObjectRelease(HIDWORD(v32));
        break;
      }
      v23 = v22;
      v24 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(v22, "IOService", CFSTR("NetworkConfigurationOverrides"), 0, 3u);
      if (v24)
      {
        v25 = v24;
        Value = CFDictionaryGetValue(v24, CFSTR("Modem"));
        if (Value)
        {
          v27 = Value;
          CFRetain(Value);
          CFRelease(v25);
          goto LABEL_13;
        }
        CFRelease(v25);
      }
      v27 = IORegistryEntrySearchCFProperty(v23, "IOService", CFSTR("DeviceModemOverrides"), 0, 3u);
      if (!v27)
      {
        CFProperty = 0;
        goto LABEL_21;
      }
LABEL_13:
      TypeID = CFDictionaryGetTypeID();
      if (CFGetTypeID(v27) != TypeID)
        goto LABEL_18;
      CFProperty = CFDictionaryGetValue((CFDictionaryRef)v27, CFSTR("UniqueIdentifier"));
      v29 = CFStringGetTypeID();
      if (CFProperty)
      {
        if (CFGetTypeID(CFProperty) != v29 || !CFEqual(*((CFTypeRef *)interface + 15), CFProperty))
        {
LABEL_18:
          CFProperty = 0;
          goto LABEL_19;
        }
        CFProperty = IORegistryEntryCreateCFProperty(v23, CFSTR("IOTTYDevice"), 0, 0);
      }
LABEL_19:
      CFRelease(v27);
LABEL_21:
      IOObjectRelease(v23);
      if (CFProperty)
      {
        IOObjectRelease(HIDWORD(v32));
        return CFProperty;
      }
    }
  }
LABEL_24:
  BSDName = SCNetworkInterfaceGetBSDName(interface);
  CFProperty = BSDName;
  if (BSDName)
    CFRetain(BSDName);
  return CFProperty;
}

BOOL _SCNetworkInterfaceIsCarPlay(_DWORD *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[78] == 21;
  return 0;
}

BOOL _SCNetworkInterfaceIsBluetoothPAN(_DWORD *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[78] == 18;
  return 0;
}

BOOL _SCNetworkInterfaceIsBluetoothPAN_NAP(_DWORD *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[78] == 19;
  return 0;
}

BOOL _SCNetworkInterfaceIsBluetoothP2P(_DWORD *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[78] == 20;
  return 0;
}

BOOL _SCNetworkInterfaceIsVMNET(_DWORD *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[78] == 23;
  return 0;
}

uint64_t _SCNetworkInterfaceIsHiddenInterface(unsigned __int8 *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[193];
  return 0;
}

const __CFString *_SCNetworkInterfaceIsQoSMarkingProfileInstalled(const __SCNetworkInterface *a1)
{
  const __CFString *result;
  const __CFString *NetworkInterfaceEntity;
  CFPropertyListRef v3;

  result = SCNetworkInterfaceGetBSDName(a1);
  if (result)
  {
    NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, CFSTR("State:"), result, CFSTR("QoSMarkingPolicy"));
    v3 = SCDynamicStoreCopyValue(0, NetworkInterfaceEntity);
    CFRelease(NetworkInterfaceEntity);
    if (v3)
    {
      CFRelease(v3);
      return (const __CFString *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL _SCNetworkInterfaceIsTethered(_DWORD *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return (cf[78] - 15) < 2;
  return 0;
}

BOOL _SCNetworkInterfaceIsTetheredHotspot(_DWORD *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[78] == 15;
  return 0;
}

uint64_t _SCNetworkInterfaceIsThunderbolt(CFTypeRef cf)
{
  uint64_t v2;
  CFStringRef InterfaceType;
  uint64_t result;
  const __CFArray *v5;
  uint64_t v6;
  CFIndex v7;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) != v2)
    return 0;
  InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)cf);
  if (!CFEqual(InterfaceType, CFSTR("Bridge")))
    return *((_DWORD *)cf + 78) == 13;
  result = SCBridgeInterfaceGetMemberInterfaces((const __SCNetworkInterface *)cf);
  if (result)
  {
    v5 = (const __CFArray *)result;
    result = CFArrayGetCount((CFArrayRef)result);
    if (result)
    {
      v6 = result;
      if (result < 1)
        return 1;
      v7 = 0;
      while (*((_DWORD *)CFArrayGetValueAtIndex(v5, v7) + 78) == 13)
      {
        ++v7;
        result = 1;
        if (v6 == v7)
          return result;
      }
      return 0;
    }
  }
  return result;
}

uint64_t _SCNetworkInterfaceIsEphemeral(unsigned __int8 *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[241];
  return 0;
}

uint64_t _SCNetworkInterfaceSupportsVMNETBridgedMode(unsigned __int8 *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[244];
  return 0;
}

uint64_t _SCNetworkInterfaceIsSelfNamed(unsigned __int8 *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[242];
  return 0;
}

uint64_t _SCNetworkInterfaceIsUserEthernet(unsigned __int8 *cf)
{
  uint64_t v2;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 0;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
    return cf[243];
  return 0;
}

const void *SCNetworkInterfaceGetQoSMarkingPolicy(CFTypeRef cf)
{
  uint64_t v2;
  const void *result;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_7;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      goto LABEL_7;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
  {
    result = __SCNetworkInterfaceGetConfiguration((uint64_t)cf, CFSTR("QoSMarkingPolicy"));
    if (result)
      return result;
    goto LABEL_8;
  }
LABEL_7:
  LODWORD(result) = 1002;
LABEL_8:
  _SCErrorSet((int)result);
  return 0;
}

uint64_t SCNetworkInterfaceSetQoSMarkingPolicy(CFTypeRef cf, const __CFString *a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  const __CFString *v18;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_10:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      goto LABEL_10;
  }
  v4 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) != v4)
    goto LABEL_10;
  v5 = __SCNetworkInterfaceSetConfiguration((uint64_t)cf, CFSTR("QoSMarkingPolicy"), a2, 0);
  if ((_DWORD)v5)
  {
    v6 = __log_SCNetworkConfiguration();
    v7 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = (char *)v20 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v17 = _os_log_pack_fill();
      v18 = CFSTR("NULL");
      if (a2)
        v18 = a2;
      *(_DWORD *)v17 = 138412546;
      *(_QWORD *)(v17 + 4) = cf;
      *(_WORD *)(v17 + 12) = 2112;
      *(_QWORD *)(v17 + 14) = v18;
      __SC_log_send(7, (uint64_t)v6, v7, v16);
    }
  }
  return v5;
}

uint64_t SCNetworkInterfaceSetAutoConfigure(const __SCNetworkInterface *cf, int a2)
{
  uint64_t v4;
  CFStringRef InterfaceType;
  uint64_t v7;
  CFStringRef v8;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_12;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      goto LABEL_12;
  }
  v4 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v4)
  {
    InterfaceType = SCNetworkInterfaceGetInterfaceType(cf);
    if (CFEqual(InterfaceType, CFSTR("Bridge")))
      return __SCBridgeInterfaceSetAutoConfigure((uint64_t)cf, a2);
  }
  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  v7 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v7)
  {
    v8 = SCNetworkInterfaceGetInterfaceType(cf);
    if (CFEqual(v8, CFSTR("VLAN")))
      return __SCVLANInterfaceSetAutoConfigure((uint64_t)cf, a2);
  }
LABEL_12:
  _SCErrorSet(1002);
  return 0;
}

uint64_t SCNetworkInterfaceGetAutoConfigure(const __SCNetworkInterface *cf)
{
  uint64_t v2;
  CFStringRef InterfaceType;
  uint64_t v5;
  CFStringRef v6;

  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 1;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!cf)
      return 1;
  }
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v2)
  {
    InterfaceType = SCNetworkInterfaceGetInterfaceType(cf);
    if (CFEqual(InterfaceType, CFSTR("Bridge")))
      return __SCBridgeInterfaceGetAutoConfigure((uint64_t)cf);
  }
  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  v5 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) == v5)
  {
    v6 = SCNetworkInterfaceGetInterfaceType(cf);
    if (CFEqual(v6, CFSTR("VLAN")))
      return __SCVLANInterfaceGetAutoConfigure((uint64_t)cf);
  }
  return 1;
}

__CFArray *__SCNetworkInterfaceCopyDeepConfiguration(const __SCNetworkSet *a1, const __SCNetworkInterface *Interface)
{
  CFMutableArrayRef Mutable;
  __CFArray *v5;
  CFDictionaryRef v6;
  const CFDictionaryKeyCallBacks *v7;
  const CFDictionaryValueCallBacks *v8;
  __CFDictionary *v9;
  __CFString *DefaultConfigurationType;
  __CFString *v11;
  CFDictionaryRef v12;
  CFDictionaryRef v13;
  const __CFArray *v14;
  const __CFArray *v15;
  const __SCNetworkSet *v16;
  const CFDictionaryValueCallBacks *v17;
  const CFDictionaryKeyCallBacks *v18;
  CFIndex Count;
  CFIndex v20;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFDictionary *Configuration;
  CFDictionaryRef v24;
  __CFArray *v26;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v5 = Mutable;
  if (Interface)
  {
    v6 = (CFDictionaryRef)*MEMORY[0x1E0C9B0D0];
    v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    v26 = Mutable;
    do
    {
      v9 = CFDictionaryCreateMutable(0, 0, v7, v8);
      DefaultConfigurationType = __SCNetworkInterfaceGetDefaultConfigurationType((uint64_t)Interface);
      if (DefaultConfigurationType)
      {
        v11 = DefaultConfigurationType;
        v12 = a1
            ? __SCNetworkInterfaceGetDefaultConfiguration(a1, (uint64_t)Interface)
            : (CFDictionaryRef)__SCNetworkInterfaceGetConfiguration((uint64_t)Interface, DefaultConfigurationType);
        v13 = v12 ? v12 : v6;
        CFDictionarySetValue(v9, v11, v13);
        v14 = extendedConfigurationTypes((uint64_t)Interface);
        if (v14)
        {
          v15 = v14;
          v16 = a1;
          v17 = v8;
          v18 = v7;
          Count = CFArrayGetCount(v14);
          if (Count >= 1)
          {
            v20 = Count;
            for (i = 0; i != v20; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v15, i);
              Configuration = (const __CFDictionary *)__SCNetworkInterfaceGetConfiguration((uint64_t)Interface, ValueAtIndex);
              if (Configuration)
                v24 = Configuration;
              else
                v24 = v6;
              CFDictionarySetValue(v9, ValueAtIndex, v24);
            }
          }
          CFRelease(v15);
          v7 = v18;
          v8 = v17;
          a1 = v16;
          v5 = v26;
        }
      }
      CFArrayAppendValue(v5, v9);
      CFRelease(v9);
      Interface = SCNetworkInterfaceGetInterface(Interface);
    }
    while (Interface);
  }
  return v5;
}

CFMutableArrayRef extendedConfigurationTypes(uint64_t a1)
{
  _QWORD *Private;
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const __SCNetworkSet *ValueAtIndex;
  const __CFArray *v9;
  int v10;
  const __CFArray *v11;
  CFStringRef SetID;
  const __CFString *SetNetworkInterfaceEntity;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  const __CFDictionary *v16;
  __CFString *context;
  CFMutableArrayRef Mutable;
  uint64_t v20;
  CFRange v21;

  v20 = *MEMORY[0x1E0C80C00];
  Mutable = 0;
  context = __SCNetworkInterfaceGetDefaultConfigurationType(a1);
  if (!context)
    return 0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (*(_QWORD *)(a1 + 96) && findPerInterfaceConfiguration(a1) != -1)
  {
    Private = __SCNetworkServiceCreatePrivate(0, *(const void **)(a1 + 80), *(const __CFString **)(a1 + 96), (const void *)a1);
    v3 = SCNetworkSetCopyAll(*(SCPreferencesRef *)(a1 + 80));
    if (v3)
    {
      v4 = v3;
      Count = CFArrayGetCount(v3);
      if (Count >= 1)
      {
        v6 = Count;
        v7 = 0;
        while (1)
        {
          ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v4, v7);
          v9 = SCNetworkSetCopyServices(ValueAtIndex);
          v21.length = CFArrayGetCount(v9);
          v21.location = 0;
          v10 = CFArrayContainsValue(v9, v21, Private);
          CFRelease(v9);
          if (v10)
            break;
          if (v6 == ++v7)
            goto LABEL_17;
        }
        SetID = SCNetworkSetGetSetID(ValueAtIndex);
        SetNetworkInterfaceEntity = SCPreferencesPathKeyCreateSetNetworkInterfaceEntity(0, (uint64_t)SetID, *(_QWORD *)(a1 + 112), 0);
        Value = __SCNetworkConfigurationGetValue(*(const __SCPreferences **)(a1 + 80), SetNetworkInterfaceEntity);
        CFRelease(SetNetworkInterfaceEntity);
        TypeID = CFDictionaryGetTypeID();
        if (Value && CFGetTypeID(Value) == TypeID)
          CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)__addExtendedConfigurationType, &context);
        v16 = *(const __CFDictionary **)(a1 + 104);
        if (v16)
          CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)__addExtendedConfigurationType, &context);
      }
LABEL_17:
      CFRelease(Private);
      v11 = v4;
    }
    else
    {
      v11 = (const __CFArray *)Private;
    }
    CFRelease(v11);
  }
  return Mutable;
}

uint64_t __SCNetworkInterfaceIsBusyMember(const __SCPreferences *a1, const __SCNetworkInterface *cf, int a3)
{
  SCNetworkInterfaceRef Interface;
  uint64_t v6;
  __CFSet *Mutable;
  const __CFArray *v8;
  const __CFArray *v9;
  uint64_t v10;
  uint64_t v11;

  Interface = cf;
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (!cf)
      return 0;
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (!Interface)
      return 0;
  }
  v6 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(Interface) != v6)
    return 0;
  Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  v8 = (const __CFArray *)SCBridgeInterfaceCopyAll(a1);
  if (v8)
  {
    v9 = v8;
    __SCBridgeInterfaceListCollectMembers(v8, Mutable, a3);
    CFRelease(v9);
  }
  if (CFSetGetCount(Mutable))
  {
    while (1)
    {
      v10 = CFSetContainsValue(Mutable, Interface);
      if ((_DWORD)v10)
        break;
      Interface = SCNetworkInterfaceGetInterface(Interface);
      if (!Interface)
        goto LABEL_9;
    }
    v11 = v10;
  }
  else
  {
LABEL_9:
    v11 = 0;
  }
  CFRelease(Mutable);
  return v11;
}

SCNetworkInterfaceRef __SCNetworkInterfaceSetDeepConfiguration(SCNetworkInterfaceRef result, const __SCNetworkInterface *a2, CFArrayRef theArray, __n128 a4)
{
  const __CFArray *v4;
  const __SCNetworkInterface *v5;
  const __SCNetworkSet *v6;
  CFIndex v7;
  __CFString *DefaultConfigurationType;
  __CFString *v9;
  CFDictionaryRef Value;
  __CFString *v11;
  const __CFString *v12;
  int v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  const __CFString *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  const __CFArray *v43;
  const __CFArray *v44;
  const __CFDictionary *v45;
  CFIndex i;
  __CFString *v47;
  const __CFString *v48;
  const __CFString *v49;
  int v50;
  NSObject *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  const __CFString *v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  SCNetworkInterfaceRef v80;
  CFArrayRef v81;
  CFIndex v82;
  __n128 v83;
  __n128 v84;
  const __CFDictionary *v85;
  CFDictionaryRef ValueAtIndex;
  CFIndex Count;
  int v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = theArray;
    v5 = a2;
    v6 = result;
    v7 = 0;
    v85 = (const __CFDictionary *)*MEMORY[0x1E0C9B0D0];
    a4.n128_u64[0] = 138412546;
    v83 = a4;
    a4.n128_u64[0] = 138412802;
    v84 = a4;
    v80 = result;
    v81 = theArray;
    do
    {
      v82 = v7;
      if (v4)
      {
        ValueAtIndex = (CFDictionaryRef)CFArrayGetValueAtIndex(v4, v7);
        DefaultConfigurationType = __SCNetworkInterfaceGetDefaultConfigurationType((uint64_t)v5);
        if (!DefaultConfigurationType)
          goto LABEL_44;
        v9 = DefaultConfigurationType;
        Value = ValueAtIndex;
        if (ValueAtIndex)
        {
          Value = (CFDictionaryRef)CFDictionaryGetValue(ValueAtIndex, v9);
          v88 = 0;
          goto LABEL_11;
        }
        ValueAtIndex = 0;
      }
      else
      {
        v11 = __SCNetworkInterfaceGetDefaultConfigurationType((uint64_t)v5);
        if (!v11)
          goto LABEL_44;
        v9 = v11;
        ValueAtIndex = 0;
        Value = 0;
      }
      v88 = 1;
LABEL_11:
      if (Value == v85)
        v12 = 0;
      else
        v12 = (const __CFString *)Value;
      if (v6)
        v13 = __SCNetworkInterfaceSetDefaultConfiguration(v6, (uint64_t)v5, v9, v12, 1);
      else
        v13 = __SCNetworkInterfaceSetConfiguration((uint64_t)v5, v9, v12, 1);
      v14 = v13;
      v15 = __log_SCNetworkConfiguration();
      if (v14)
      {
        v16 = _SC_syslog_os_log_mapping(7);
        if (!__SC_log_enabled(7, v15, (os_log_type_t)v16))
          goto LABEL_25;
        v17 = _os_log_pack_size();
        v25 = (char *)&v79 - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v26 = _os_log_pack_fill();
        *(_DWORD *)v26 = v84.n128_u32[0];
        v27 = CFSTR("NULL");
        if (v12)
          v27 = v12;
        *(_QWORD *)(v26 + 4) = v5;
        *(_WORD *)(v26 + 12) = 2112;
        *(_QWORD *)(v26 + 14) = v9;
        *(_WORD *)(v26 + 22) = 2112;
        *(_QWORD *)(v26 + 24) = v27;
        v28 = 7;
        v29 = (uint64_t)v15;
        v30 = v16;
        v31 = v25;
      }
      else
      {
        v32 = _SC_syslog_os_log_mapping(6);
        if (!__SC_log_enabled(6, v15, (os_log_type_t)v32))
          goto LABEL_25;
        v33 = _os_log_pack_size();
        v41 = (char *)&v79 - ((MEMORY[0x1E0C80A78](v33, v34, v35, v36, v37, v38, v39, v40) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v42 = _os_log_pack_fill();
        *(_DWORD *)v42 = v83.n128_u32[0];
        *(_QWORD *)(v42 + 4) = v5;
        *(_WORD *)(v42 + 12) = 2112;
        *(_QWORD *)(v42 + 14) = v9;
        v28 = 6;
        v29 = (uint64_t)v15;
        v30 = v32;
        v31 = v41;
      }
      __SC_log_send(v28, v29, v30, v31);
LABEL_25:
      v43 = extendedConfigurationTypes((uint64_t)v5);
      if (v43)
      {
        v44 = v43;
        Count = CFArrayGetCount(v43);
        v45 = v85;
        if (Count >= 1)
        {
          for (i = 0; Count != i; ++i)
          {
            v47 = (__CFString *)CFArrayGetValueAtIndex(v44, i);
            if ((v88 & 1) != 0)
              v48 = 0;
            else
              v48 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, v47);
            if (v48 == (const __CFString *)v45)
              v49 = 0;
            else
              v49 = v48;
            v50 = __SCNetworkInterfaceSetConfiguration((uint64_t)v5, v47, v49, 1);
            v51 = __log_SCNetworkConfiguration();
            if (v50)
            {
              v52 = _SC_syslog_os_log_mapping(7);
              if (__SC_log_enabled(7, v51, (os_log_type_t)v52))
              {
                v53 = _os_log_pack_size();
                v61 = (char *)&v79
                    - ((MEMORY[0x1E0C80A78](v53, v54, v55, v56, v57, v58, v59, v60) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v45 = v85;
                v62 = _os_log_pack_fill();
                *(_DWORD *)v62 = v84.n128_u32[0];
                v63 = CFSTR("NULL");
                if (v49)
                  v63 = v49;
                *(_QWORD *)(v62 + 4) = v5;
                *(_WORD *)(v62 + 12) = 2112;
                *(_QWORD *)(v62 + 14) = v47;
                *(_WORD *)(v62 + 22) = 2112;
                *(_QWORD *)(v62 + 24) = v63;
                v64 = 7;
                v65 = (uint64_t)v51;
                v66 = v52;
                v67 = v61;
                goto LABEL_41;
              }
            }
            else
            {
              v68 = _SC_syslog_os_log_mapping(6);
              if (__SC_log_enabled(6, v51, (os_log_type_t)v68))
              {
                v69 = _os_log_pack_size();
                v77 = (char *)&v79
                    - ((MEMORY[0x1E0C80A78](v69, v70, v71, v72, v73, v74, v75, v76) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v78 = _os_log_pack_fill();
                *(_DWORD *)v78 = v83.n128_u32[0];
                *(_QWORD *)(v78 + 4) = v5;
                *(_WORD *)(v78 + 12) = 2112;
                *(_QWORD *)(v78 + 14) = v47;
                v64 = 6;
                v65 = (uint64_t)v51;
                v66 = v68;
                v67 = v77;
LABEL_41:
                __SC_log_send(v64, v65, v66, v67);
              }
            }
          }
        }
        CFRelease(v44);
        v6 = v80;
        v4 = v81;
      }
LABEL_44:
      result = SCNetworkInterfaceGetInterface(v5);
      v5 = result;
      v7 = v82 + 1;
    }
    while (result);
  }
  return result;
}

SCNetworkInterfaceRef _SCNetworkInterfaceCopyActive(const void *a1, const __CFString *a2)
{
  SCNetworkInterfaceRef v3;
  SCNetworkInterfaceRef v4;

  v3 = _SCNetworkInterfaceCreateWithBSDName((uint64_t)a1, a2, -1);
  v4 = v3;
  if (a1 && v3)
  {
    CFRetain(a1);
    *((_QWORD *)v4 + 11) = a1;
  }
  return v4;
}

int64_t SCNetworkInterfaceGetPrimaryRank(const __SCNetworkInterface *a1)
{
  uint64_t v1;
  const __CFString *BSDName;

  v1 = *((_QWORD *)a1 + 50);
  if (v1)
  {
    BSDName = SCNetworkInterfaceGetBSDName(a1);
    if (BSDName)
      return IPMonitorControlGetInterfacePrimaryRank(v1, BSDName);
    _SCErrorSet(1002);
  }
  return 0;
}

uint64_t SCNetworkInterfaceSetPrimaryRank(const __SCNetworkInterface *a1, unsigned int a2)
{
  CFStringRef BSDName;
  const __CFString *v5;
  _QWORD *v6;
  int v8;

  BSDName = SCNetworkInterfaceGetBSDName(a1);
  if (BSDName)
  {
    v5 = BSDName;
    v6 = (_QWORD *)*((_QWORD *)a1 + 50);
    if (v6)
      return IPMonitorControlSetInterfacePrimaryRank(v6, v5, a2);
    v6 = (_QWORD *)IPMonitorControlCreate();
    if (v6)
    {
      *((_QWORD *)a1 + 50) = v6;
      return IPMonitorControlSetInterfacePrimaryRank(v6, v5, a2);
    }
    v8 = 1001;
  }
  else
  {
    v8 = 1002;
  }
  _SCErrorSet(v8);
  return 0;
}

CFStringRef SCNetworkInterfaceCopyRankAssertionNotificationKey(const __SCNetworkInterface *a1)
{
  const __CFString *BSDName;

  BSDName = SCNetworkInterfaceGetBSDName(a1);
  if (BSDName)
    return IPMonitorControlCopyInterfaceRankAssertionNotificationKey(BSDName);
  _SCErrorSet(1002);
  return 0;
}

uint64_t SCNetworkInterfaceCopyRankAssertionInfo(const __SCNetworkInterface *a1)
{
  uint64_t result;
  CFStringRef v2[2];

  v2[1] = *(CFStringRef *)MEMORY[0x1E0C80C00];
  v2[0] = 0;
  result = _SCNetworkInterfaceGetIPMonitorControl(a1, v2);
  if (result)
  {
    result = IPMonitorControlCopyInterfaceRankAssertionInfo(result, v2[0]);
    if (!result)
    {
      _SCErrorSet(1001);
      return 0;
    }
  }
  return result;
}

uint64_t SCNetworkInterfaceRankAssertionInfoGetPrimaryRank(const __CFDictionary *a1)
{
  return InterfaceRankAssertionInfoGetPrimaryRank(a1);
}

uint64_t SCNetworkInterfaceRankAssertionInfoGetProcessID(const __CFDictionary *a1)
{
  return InterfaceRankAssertionInfoGetProcessID(a1);
}

const void *SCNetworkInterfaceRankAssertionInfoGetProcessName(const __CFDictionary *a1)
{
  return InterfaceRankAssertionInfoGetProcessName(a1);
}

uint64_t SCNetworkInterfaceRankAssertionCopyInterfaceNames()
{
  uint64_t v0;
  const void *v1;
  uint64_t v2;

  v0 = IPMonitorControlCreate();
  if (v0)
  {
    v1 = (const void *)v0;
    v2 = IPMonitorControlCopyInterfaceRankAssertionInterfaceNames(v0);
    if (!v2)
      _SCErrorSet(1001);
    CFRelease(v1);
  }
  else
  {
    _SCErrorSet(1001);
    return 0;
  }
  return v2;
}

const void *__SCNetworkInterfaceGetDisableUntilNeededValue(const __SCPreferences **a1)
{
  return get_number_value(a1, CFSTR("DisableUntilNeeded"));
}

const void *get_number_value(const __SCPreferences **cf, const void *a2)
{
  uint64_t v4;
  __CFArray *v5;
  __CFArray *v6;
  const __CFString *ValueAtIndex;
  const __CFDictionary *Value;
  const void *v9;
  CFTypeID TypeID;
  CFTypeID v11;
  CFTypeID v12;

  if (__SCNetworkInterfaceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (cf)
      goto LABEL_3;
LABEL_16:
    v9 = 0;
    LODWORD(v5) = 1002;
    goto LABEL_17;
  }
  if (!cf)
    goto LABEL_16;
LABEL_3:
  v4 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) != v4 || !cf[10] || findPerInterfaceConfiguration((uint64_t)cf) == -1)
    goto LABEL_16;
  v5 = copyPerInterfaceConfigurationPaths((uint64_t)cf, 0);
  if (!v5)
  {
LABEL_13:
    v9 = 0;
    goto LABEL_17;
  }
  v6 = v5;
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, 0);
  Value = __SCNetworkConfigurationGetValue(cf[10], ValueAtIndex);
  CFRelease(v6);
  if (!Value)
  {
    LODWORD(v5) = 0;
    goto LABEL_13;
  }
  v9 = CFDictionaryGetValue(Value, a2);
  TypeID = CFNumberGetTypeID();
  if (v9)
  {
    v11 = TypeID;
    v12 = CFGetTypeID(v9);
    LODWORD(v5) = 0;
    if (v12 != v11)
      v9 = 0;
  }
  else
  {
    LODWORD(v5) = 0;
  }
LABEL_17:
  _SCErrorSet((int)v5);
  return v9;
}

BOOL SCNetworkInterfaceGetDisableUntilNeeded(const __SCPreferences **a1)
{
  const __CFNumber *number_value;
  int Value;
  _BOOL8 result;
  int valuePtr;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  number_value = (const __CFNumber *)get_number_value(a1, CFSTR("DisableUntilNeeded"));
  if (!number_value)
    return _SCNetworkInterfaceIsTethered(a1);
  valuePtr = 0;
  Value = CFNumberGetValue(number_value, kCFNumberIntType, &valuePtr);
  result = valuePtr != 0;
  if (!Value)
    return _SCNetworkInterfaceIsTethered(a1);
  return result;
}

uint64_t __SCNetworkInterfaceSetDisableUntilNeededValue(uint64_t a1, const void *a2)
{
  return set_number_value(a1, CFSTR("DisableUntilNeeded"), a2);
}

uint64_t set_number_value(uint64_t a1, const void *a2, const void *a3)
{
  CFTypeID TypeID;
  __CFArray *v7;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const CFDictionaryValueCallBacks *v12;
  const __CFString *ValueAtIndex;
  const __CFDictionary *Value;
  __CFDictionary *v15;
  const __CFDictionary *v16;
  const __SCPreferences *v17;
  const __CFDictionary *v18;
  uint64_t v19;

  if (*(_QWORD *)(a1 + 80)
    && (!a3 || (TypeID = CFNumberGetTypeID(), CFGetTypeID(a3) == TypeID))
    && findPerInterfaceConfiguration(a1) != -1
    && (v7 = copyPerInterfaceConfigurationPaths(a1, 0)) != 0)
  {
    v8 = v7;
    Count = CFArrayGetCount(v7);
    if (Count < 1)
    {
      v19 = 1;
LABEL_23:
      _SCErrorSet(0);
    }
    else
    {
      v10 = Count;
      v11 = 0;
      v12 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, v11);
        Value = __SCNetworkConfigurationGetValue(*(const __SCPreferences **)(a1 + 80), ValueAtIndex);
        v15 = Value
            ? CFDictionaryCreateMutableCopy(0, 0, Value)
            : CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], v12);
        v16 = v15;
        if (a3)
          CFDictionarySetValue(v15, a2, a3);
        else
          CFDictionaryRemoveValue(v15, a2);
        v17 = *(const __SCPreferences **)(a1 + 80);
        v18 = CFDictionaryGetCount(v16) <= 0 ? 0 : v16;
        v19 = __SCNetworkConfigurationSetValue(v17, ValueAtIndex, v18, 0);
        CFRelease(v16);
        if (!(_DWORD)v19)
          break;
        if (v10 == ++v11)
          goto LABEL_23;
      }
    }
    CFRelease(v8);
  }
  else
  {
    _SCErrorSet(1002);
    return 0;
  }
  return v19;
}

uint64_t SCNetworkInterfaceSetDisableUntilNeeded(uint64_t a1, int a2)
{
  return set_BOOLean_value(a1, CFSTR("DisableUntilNeeded"), a2);
}

uint64_t set_BOOLean_value(uint64_t a1, const void *a2, int a3)
{
  int *v5;
  CFNumberRef v6;
  uint64_t v7;
  int v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v10 = 1;
  if (a3)
    v5 = &v10;
  else
    v5 = &v9;
  v6 = CFNumberCreate(0, kCFNumberIntType, v5);
  v7 = set_number_value(a1, a2, v6);
  CFRelease(v6);
  return v7;
}

const void *__SCNetworkInterfaceGetDisablePrivateRelayValue(const __SCPreferences **a1)
{
  return get_number_value(a1, CFSTR("DisablePrivateRelay"));
}

const __CFNumber *SCNetworkInterfaceGetDisablePrivateRelay(const __SCPreferences **a1)
{
  const __CFNumber *result;
  BOOL v2;
  int valuePtr;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  result = (const __CFNumber *)get_number_value(a1, CFSTR("DisablePrivateRelay"));
  if (result)
  {
    valuePtr = 0;
    if (CFNumberGetValue(result, kCFNumberIntType, &valuePtr))
      v2 = valuePtr == 0;
    else
      v2 = 1;
    return (const __CFNumber *)!v2;
  }
  return result;
}

uint64_t __SCNetworkInterfaceSetDisablePrivateRelayValue(uint64_t a1, const void *a2)
{
  return set_number_value(a1, CFSTR("DisablePrivateRelay"), a2);
}

uint64_t SCNetworkInterfaceSetDisablePrivateRelay(uint64_t a1, int a2)
{
  return set_BOOLean_value(a1, CFSTR("DisablePrivateRelay"), a2);
}

BOOL SCNetworkInterfaceSupportsLowDataMode(void *cf)
{
  uint64_t v2;
  CFStringRef InterfaceType;

  if (__SCNetworkInterfaceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (cf)
      goto LABEL_3;
    return 0;
  }
  if (!cf)
    return 0;
LABEL_3:
  v2 = __kSCNetworkInterfaceTypeID;
  if (CFGetTypeID(cf) != v2
    || _SCNetworkInterfaceIsHiddenConfiguration((unsigned __int8 *)cf)
    || _SCNetworkInterfaceIsHiddenInterface((unsigned __int8 *)cf))
  {
    return 0;
  }
  InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)cf);
  return CFEqual(InterfaceType, CFSTR("Ethernet")) != 0;
}

const void *__SCNetworkInterfaceGetEnableLowDataModeValue(const __SCPreferences **a1)
{
  if (SCNetworkInterfaceSupportsLowDataMode(a1))
    return get_number_value(a1, CFSTR("EnableLowDataMode"));
  _SCErrorSet(1002);
  return 0;
}

const __CFNumber *SCNetworkInterfaceGetEnableLowDataMode(const __SCPreferences **a1)
{
  const __CFNumber *result;
  BOOL v2;
  int valuePtr;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  result = (const __CFNumber *)__SCNetworkInterfaceGetEnableLowDataModeValue(a1);
  if (result)
  {
    valuePtr = 0;
    if (CFNumberGetValue(result, kCFNumberIntType, &valuePtr))
      v2 = valuePtr == 0;
    else
      v2 = 1;
    return (const __CFNumber *)!v2;
  }
  return result;
}

uint64_t __SCNetworkInterfaceSetEnableLowDataModeValue(void *a1, const void *a2)
{
  if (SCNetworkInterfaceSupportsLowDataMode(a1))
    return set_number_value((uint64_t)a1, CFSTR("EnableLowDataMode"), a2);
  _SCErrorSet(1002);
  return 0;
}

uint64_t SCNetworkInterfaceSetEnableLowDataMode(void *a1, int a2)
{
  if (SCNetworkInterfaceSupportsLowDataMode(a1))
    return set_BOOLean_value((uint64_t)a1, CFSTR("EnableLowDataMode"), a2);
  _SCErrorSet(1002);
  return 0;
}

__CFArray *__SCNetworkInterfaceCopyStoredWithPreferences(const __SCPreferences *cf)
{
  SCPreferencesRef v1;
  const __CFArray *Value;
  CFTypeID TypeID;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  CFTypeID v8;
  const void *v9;
  const void *v10;

  v1 = cf;
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (cf)
    {
LABEL_3:
      CFRetain(v1);
      goto LABEL_6;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (v1)
      goto LABEL_3;
  }
  v1 = SCPreferencesCreate(0, CFSTR("SCNetworkInterface"), CFSTR("NetworkInterfaces.plist"));
  if (!v1)
    __SCNetworkInterfaceCopyStoredWithPreferences_cold_1();
LABEL_6:
  Value = (const __CFArray *)SCPreferencesGetValue(v1, CFSTR("Interfaces"));
  TypeID = CFArrayGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID)
  {
    Count = CFArrayGetCount(Value);
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, i);
        v8 = CFDictionaryGetTypeID();
        if (ValueAtIndex)
        {
          if (CFGetTypeID(ValueAtIndex) == v8)
          {
            v9 = (const void *)__SCNetworkInterfaceCreateWithStorageEntity(ValueAtIndex);
            if (v9)
            {
              v10 = v9;
              CFArrayAppendValue(Mutable, v9);
              CFRelease(v10);
            }
          }
        }
      }
    }
  }
  else
  {
    Mutable = 0;
  }
  CFRelease(v1);
  return Mutable;
}

uint64_t __SCNetworkInterfaceCreateWithStorageEntity(const __CFDictionary *a1)
{
  CFTypeID TypeID;
  const void *Value;
  CFTypeID v4;
  const void *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  int v17;
  const __CFBoolean *v18;
  const __CFBoolean *v19;
  const __CFString *v20;
  CFTypeID v21;
  const void *v22;
  CFTypeID v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const __CFBoolean *v35;
  const void *v36;
  CFTypeID v37;
  const void *v38;
  const __CFBoolean *v39;
  const void *v40;
  CFTypeID v41;
  const void *v42;
  CFTypeID v43;
  const __CFNumber *v44;
  CFTypeID v45;
  os_log_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  NSObject *v58;
  CFTypeID v59;
  uint64_t *v60;
  CFTypeID v61;
  const void *v62;
  CFTypeID v63;
  const __CFDictionary *v64;
  CFTypeID v65;
  const void *v66;
  CFTypeRef v67;
  const void *v68;
  NSObject *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  char *v79;
  const void *v80;
  CFTypeRef v81;
  const void *v82;
  const void *v83;
  CFTypeRef v84;
  const void *v85;
  const void *v86;
  CFTypeID v87;
  const void *v88;
  const void *v89;
  CFTypeID v90;
  const void *v91;
  const __CFString *v92;
  CFTypeID v93;
  __CFDictionary *Mutable;
  __CFDictionary *v95;
  CFStringRef v96;
  const CFStringRef *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t Configuration;
  const __CFString *v107;
  __CFDictionary *v108;
  CFTypeRef v109;
  CFTypeRef v110;
  CFTypeRef v111;
  CFTypeRef v112;
  uint64_t v113;
  const __CFString *v114;
  CFTypeRef v115;
  const void *v116;
  CFTypeRef v117;
  CFTypeRef v118;
  CFTypeRef v119;
  CFTypeRef v120;
  os_log_t v121;
  uint64_t *v122;
  int valuePtr;
  uint64_t v124;

  v124 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkInterfaceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
  valuePtr = 0;
  TypeID = CFDictionaryGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID)
  {
    Value = CFDictionaryGetValue(a1, CFSTR("Active"));
    v4 = CFBooleanGetTypeID();
    if (Value)
    {
      if (CFGetTypeID(Value) == v4)
        v5 = Value;
      else
        v5 = 0;
    }
    else
    {
      v5 = 0;
    }
    v18 = (const __CFBoolean *)*MEMORY[0x1E0C9AE40];
    if (v5)
      v19 = (const __CFBoolean *)Value;
    else
      v19 = (const __CFBoolean *)*MEMORY[0x1E0C9AE40];
    v20 = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("BSD Name"));
    v21 = CFStringGetTypeID();
    if (v20 && CFGetTypeID(v20) == v21)
    {
      v22 = CFDictionaryGetValue(a1, CFSTR("HiddenConfiguration"));
      v23 = CFBooleanGetTypeID();
      if (v22)
      {
        if (CFGetTypeID(v22) == v23)
          v24 = v22;
        else
          v24 = 0;
      }
      else
      {
        v24 = 0;
      }
      if (v24)
        v35 = (const __CFBoolean *)v22;
      else
        v35 = v18;
      v36 = CFDictionaryGetValue(a1, CFSTR("HiddenInterface"));
      v37 = CFBooleanGetTypeID();
      if (v36)
      {
        if (CFGetTypeID(v36) == v37)
          v38 = v36;
        else
          v38 = 0;
      }
      else
      {
        v38 = 0;
      }
      if (v38)
        v39 = (const __CFBoolean *)v36;
      else
        v39 = v18;
      v40 = CFDictionaryGetValue(a1, CFSTR("IOBuiltin"));
      v41 = CFBooleanGetTypeID();
      if (!v40 || CFGetTypeID(v40) != v41)
      {
        v6 = __log_SCNetworkConfiguration();
        v7 = _SC_syslog_os_log_mapping(6);
        if (!__SC_log_enabled(6, v6, (os_log_type_t)v7))
          return 0;
        goto LABEL_10;
      }
      v42 = CFDictionaryGetValue(a1, CFSTR("IOInterfaceNamePrefix"));
      v43 = CFStringGetTypeID();
      if (v42 && CFGetTypeID(v42) == v43)
      {
        CFRetain(v42);
LABEL_46:
        v44 = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("IOInterfaceType"));
        v45 = CFNumberGetTypeID();
        if (v44 && CFGetTypeID(v44) == v45)
        {
          if (!CFNumberGetValue(v44, kCFNumberIntType, &valuePtr))
          {
            v46 = __log_SCNetworkConfiguration();
            v47 = _SC_syslog_os_log_mapping(5);
            if (__SC_log_enabled(5, v46, (os_log_type_t)v47))
            {
              v48 = _os_log_pack_size();
              v121 = v46;
              v122 = &v113;
              v56 = MEMORY[0x1E0C80A78](v48, v49, v50, v51, v52, v53, v54, v55);
              LODWORD(v120) = v47;
              v57 = (char *)&v113 - ((v56 + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              *(_WORD *)_os_log_pack_fill() = 0;
              __SC_log_send(5, (uint64_t)v121, v120, v57);
            }
          }
          v58 = CFDictionaryGetValue(a1, CFSTR("IOInterfaceUnit"));
          v59 = CFNumberGetTypeID();
          if (v58 && CFGetTypeID(v58) == v59)
          {
            v121 = v58;
            v60 = (uint64_t *)CFDictionaryGetValue(a1, CFSTR("IOMACAddress"));
            v61 = CFDataGetTypeID();
            if (v60 && (v122 = v60, CFGetTypeID(v60) == v61))
            {
              v62 = CFDictionaryGetValue(a1, CFSTR("IOPathMatch"));
              v63 = CFStringGetTypeID();
              if (v62 && CFGetTypeID(v62) == v63)
              {
                v120 = v62;
                v64 = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("SCNetworkInterfaceInfo"));
                v65 = CFDictionaryGetTypeID();
                if (v64 && CFGetTypeID(v64) == v65)
                {
                  v114 = CFSTR("UserDefinedName");
                  v66 = CFDictionaryGetValue(v64, CFSTR("UserDefinedName"));
                  v119 = (CFTypeRef)CFStringGetTypeID();
                  if (v66)
                  {
                    v67 = (CFTypeRef)CFGetTypeID(v66);
                    if (v67 == v119)
                      v68 = v66;
                    else
                      v68 = 0;
                    v116 = v68;
                  }
                  else
                  {
                    v116 = 0;
                  }
                  v80 = CFDictionaryGetValue(v64, CFSTR("kUSBProductString"));
                  v119 = (CFTypeRef)CFStringGetTypeID();
                  if (v80)
                  {
                    v81 = (CFTypeRef)CFGetTypeID(v80);
                    if (v81 == v119)
                      v82 = v80;
                    else
                      v82 = 0;
                    v118 = v82;
                  }
                  else
                  {
                    v118 = 0;
                  }
                  v83 = CFDictionaryGetValue(v64, CFSTR("idProduct"));
                  v119 = (CFTypeRef)CFNumberGetTypeID();
                  if (v83)
                  {
                    v84 = (CFTypeRef)CFGetTypeID(v83);
                    if (v84 == v119)
                      v85 = v83;
                    else
                      v85 = 0;
                    v119 = v85;
                  }
                  else
                  {
                    v119 = 0;
                  }
                  v86 = CFDictionaryGetValue(v64, CFSTR("idVendor"));
                  v87 = CFNumberGetTypeID();
                  if (v86)
                  {
                    if (CFGetTypeID(v86) == v87)
                      v88 = v86;
                    else
                      v88 = 0;
                    v117 = v88;
                  }
                  else
                  {
                    v117 = 0;
                  }
                  v89 = CFDictionaryGetValue(a1, CFSTR("MatchingMACs"));
                  v90 = CFArrayGetTypeID();
                  if (v89)
                  {
                    if (CFGetTypeID(v89) == v90)
                      v91 = v89;
                    else
                      v91 = 0;
                    v115 = v91;
                  }
                  else
                  {
                    v115 = 0;
                  }
                  v92 = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("SCNetworkInterfaceType"));
                  v93 = CFStringGetTypeID();
                  if (v92 && CFGetTypeID(v92) == v93)
                  {
                    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                    v95 = Mutable;
                    if (valuePtr == 144)
                    {
                      v97 = &kSCValNetInterfaceTypeFireWire;
                    }
                    else
                    {
                      v96 = v92;
                      if (valuePtr != 6)
                        goto LABEL_113;
                      v97 = &kSCValNetInterfaceTypeEthernet;
                    }
                    v96 = *v97;
LABEL_113:
                    CFDictionarySetValue(Mutable, CFSTR("Type"), v96);
                    Configuration = findConfiguration(v92);
                    if (Configuration == -1)
                    {
                      v108 = v95;
                      v107 = v92;
                    }
                    else
                    {
                      if (((0x61200uLL >> Configuration) & 1) != 0)
                      {
LABEL_118:
                        CFDictionarySetValue(v95, CFSTR("DeviceName"), v20);
                        if (CFBooleanGetValue(v35))
                          CFDictionarySetValue(v95, CFSTR("HiddenConfiguration"), (const void *)*MEMORY[0x1E0C9AE50]);
                        if (v116)
                          CFDictionarySetValue(v95, v114, v116);
                        v33 = _SCNetworkInterfaceCreateWithEntity();
                        CFRelease(v95);
                        *(_BYTE *)(v33 + 24) = CFBooleanGetValue(v19);
                        *(_BYTE *)(v33 + 176) = CFBooleanGetValue((CFBooleanRef)v40);
                        *(_BYTE *)(v33 + 193) = CFBooleanGetValue(v39);
                        *(_QWORD *)(v33 + 232) = CFRetain(v42);
                        *(_QWORD *)(v33 + 248) = CFRetain(v44);
                        *(_QWORD *)(v33 + 256) = CFRetain(v121);
                        *(_QWORD *)(v33 + 160) = CFRetain(v122);
                        *(_QWORD *)(v33 + 208) = CFRetain(v120);
                        if (v118)
                          v109 = CFRetain(v118);
                        else
                          v109 = 0;
                        *(_QWORD *)(v33 + 280) = v109;
                        if (v119)
                          v110 = CFRetain(v119);
                        else
                          v110 = 0;
                        *(_QWORD *)(v33 + 296) = v110;
                        if (v117)
                          v111 = CFRetain(v117);
                        else
                          v111 = 0;
                        *(_QWORD *)(v33 + 288) = v111;
                        if (v115)
                          v112 = CFRetain(v115);
                        else
                          v112 = 0;
                        *(_QWORD *)(v33 + 304) = v112;
                        goto LABEL_110;
                      }
                      v107 = *configurations[5 * Configuration + 1];
                      v108 = v95;
                    }
                    CFDictionarySetValue(v108, CFSTR("Hardware"), v107);
                    goto LABEL_118;
                  }
                  v69 = __log_SCNetworkConfiguration();
                  v70 = _SC_syslog_os_log_mapping(6);
                  if (__SC_log_enabled(6, v69, (os_log_type_t)v70))
                    goto LABEL_107;
LABEL_109:
                  v33 = 0;
LABEL_110:
                  CFRelease(v42);
                  return v33;
                }
                v69 = __log_SCNetworkConfiguration();
                v70 = _SC_syslog_os_log_mapping(6);
                if (!__SC_log_enabled(6, v69, (os_log_type_t)v70))
                  goto LABEL_109;
              }
              else
              {
                v69 = __log_SCNetworkConfiguration();
                v70 = _SC_syslog_os_log_mapping(6);
                if (!__SC_log_enabled(6, v69, (os_log_type_t)v70))
                  goto LABEL_109;
              }
            }
            else
            {
              v69 = __log_SCNetworkConfiguration();
              v70 = _SC_syslog_os_log_mapping(6);
              if (!__SC_log_enabled(6, v69, (os_log_type_t)v70))
                goto LABEL_109;
            }
          }
          else
          {
            v69 = __log_SCNetworkConfiguration();
            v70 = _SC_syslog_os_log_mapping(6);
            if (!__SC_log_enabled(6, v69, (os_log_type_t)v70))
              goto LABEL_109;
          }
LABEL_107:
          v98 = _os_log_pack_size();
          v79 = (char *)&v113
              - ((MEMORY[0x1E0C80A78](v98, v99, v100, v101, v102, v103, v104, v105) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          goto LABEL_108;
        }
        v69 = __log_SCNetworkConfiguration();
        v70 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v69, (os_log_type_t)v70))
        {
          v71 = _os_log_pack_size();
          v79 = (char *)&v113
              - ((MEMORY[0x1E0C80A78](v71, v72, v73, v74, v75, v76, v77, v78) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
LABEL_108:
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(6, (uint64_t)v69, v70, v79);
          goto LABEL_109;
        }
        goto LABEL_109;
      }
      v42 = _SCNetworkInterfaceCopyPrefixFromBSDName(v20);
      if (v42)
        goto LABEL_46;
      v6 = __log_SCNetworkConfiguration();
      v7 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v6, (os_log_type_t)v7))
      {
LABEL_10:
        v8 = _os_log_pack_size();
        v16 = (char *)&v113 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        v17 = 6;
LABEL_23:
        __SC_log_send(v17, (uint64_t)v6, v7, v16);
      }
    }
    else
    {
      v6 = __log_SCNetworkConfiguration();
      v7 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v6, (os_log_type_t)v7))
      {
        v25 = _os_log_pack_size();
        v16 = (char *)&v113
            - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        v17 = 7;
        goto LABEL_23;
      }
    }
  }
  else
  {
    v6 = __log_SCNetworkConfiguration();
    v7 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v6, (os_log_type_t)v7))
      goto LABEL_10;
  }
  return 0;
}

uint64_t __SCNetworkInterfaceSaveStoredWithPreferences(SCPreferencesRef a1, const void *a2)
{
  CFTypeID TypeID;
  uint64_t v6;

  TypeID = CFArrayGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
    return 0;
  if (a1)
  {
    CFRetain(a1);
  }
  else
  {
    a1 = SCPreferencesCreate(0, CFSTR("SCNetworkInterface"), CFSTR("NetworkInterfaces.plist"));
    if (!a1)
      __SCNetworkInterfaceSaveStoredWithPreferences_cold_1();
  }
  v6 = SCPreferencesSetValue(a1, CFSTR("Interfaces"), a2);
  CFRelease(a1);
  return v6;
}

uint64_t __SCNetworkInterfaceCreateWithNIPreferencesUsingBSDName(int a1, const __SCPreferences *cf, const void *a3)
{
  SCPreferencesRef v4;
  const __CFArray *Value;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  const __CFDictionary *ValueAtIndex;
  CFTypeID v11;
  const void *v12;
  CFTypeID v13;
  uint64_t v14;

  v4 = cf;
  if (__SCNetworkInterfaceInitialize_initialized == -1)
  {
    if (cf)
    {
LABEL_3:
      CFRetain(v4);
      goto LABEL_6;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkInterfaceInitialize_initialized, &__block_literal_global_11);
    if (v4)
      goto LABEL_3;
  }
  v4 = SCPreferencesCreate(0, CFSTR("SCNetworkInterface"), CFSTR("NetworkInterfaces.plist"));
  if (!v4)
    __SCNetworkInterfaceCreateWithNIPreferencesUsingBSDName_cold_1();
LABEL_6:
  Value = (const __CFArray *)SCPreferencesGetValue(v4, CFSTR("Interfaces"));
  TypeID = CFArrayGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && (Count = CFArrayGetCount(Value), Count >= 1))
  {
    v8 = Count;
    v9 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v9);
      v11 = CFDictionaryGetTypeID();
      if (ValueAtIndex)
      {
        if (CFGetTypeID(ValueAtIndex) == v11)
        {
          v12 = CFDictionaryGetValue(ValueAtIndex, CFSTR("BSD Name"));
          v13 = CFStringGetTypeID();
          if (v12)
          {
            if (CFGetTypeID(v12) == v13 && CFEqual(a3, v12))
              break;
          }
        }
      }
      if (v8 == ++v9)
        goto LABEL_16;
    }
    v14 = __SCNetworkInterfaceCreateWithStorageEntity(ValueAtIndex);
  }
  else
  {
LABEL_16:
    v14 = 0;
  }
  CFRelease(v4);
  return v14;
}

__CFDictionary *__SCNetworkInterfaceCreateMappingUsingBSDName(const __CFArray *a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex v4;
  __CFDictionary *Mutable;
  const CFDictionaryKeyCallBacks *v6;
  const CFDictionaryValueCallBacks *v7;
  const __SCNetworkInterface *ValueAtIndex;
  CFStringRef BSDName;
  CFStringRef v10;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v3 = Count;
  v4 = 0;
  Mutable = 0;
  v6 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v7 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  do
  {
    ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(a1, v4);
    BSDName = SCNetworkInterfaceGetBSDName(ValueAtIndex);
    if (BSDName)
    {
      v10 = BSDName;
      if (!Mutable)
        Mutable = CFDictionaryCreateMutable(0, 0, v6, v7);
      CFDictionarySetValue(Mutable, v10, ValueAtIndex);
    }
    ++v4;
  }
  while (v3 != v4);
  return Mutable;
}

uint64_t SCNetworkInterfaceTypeSetTemporaryOverrideCost(const __SCPreferences *a1, CFTypeRef cf1, int a3)
{
  const __CFString *v6;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  __CFDictionary *MutableCopy;
  __CFDictionary *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFDictionary *v13;
  CFTypeID v14;
  const __CFNumber *v15;
  CFTypeID v16;
  int v17;
  CFAbsoluteTime Current;
  CFDateRef v19;
  __CFCalendar *v20;
  uint64_t v21;
  CFTypeID v22;
  uint64_t v24;
  CFAbsoluteTime valuePtr;
  unsigned int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (CFEqual(cf1, CFSTR("IEEE80211")) || CFEqual(cf1, CFSTR("Cellular")))
  {
    v6 = CFStringCreateWithFormat(0, 0, CFSTR("%@%@/%@/%@/%@/%@"), CFSTR("/"), CFSTR("System"), CFSTR("Network"), CFSTR("Override"), CFSTR("InterfaceType"), cf1);
    Value = SCPreferencesPathGetValue(a1, v6);
    TypeID = CFDictionaryGetTypeID();
    if (Value && CFGetTypeID(Value) == TypeID)
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
    else
      MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v10 = MutableCopy;
    v11 = CFSTR("Inexpensive");
    if (a3 != 1)
      v11 = 0;
    if (a3 == 2)
      v12 = CFSTR("Expensive");
    else
      v12 = v11;
    if (v12)
    {
      CFDictionarySetValue(MutableCopy, CFSTR("Cost"), v12);
      if (_SC_isAppleInternal_once_3 != -1)
        dispatch_once(&_SC_isAppleInternal_once_3, &__block_literal_global_431);
      if (!_SC_isAppleInternal_isInternal_3)
        goto LABEL_23;
      LODWORD(valuePtr) = 0;
      v13 = (const __CFDictionary *)SCDynamicStoreCopyValue(0, CFSTR("Global:NetworkInterfaceOverrideExpensiveExpiration"));
      v14 = CFDictionaryGetTypeID();
      if (!v13)
        goto LABEL_23;
      if (CFGetTypeID(v13) == v14)
      {
        v15 = (const __CFNumber *)CFDictionaryGetValue(v13, CFSTR("Delta"));
        v16 = CFNumberGetTypeID();
        if (v15)
        {
          if (CFGetTypeID(v15) == v16)
            CFNumberGetValue(v15, kCFNumberIntType, &valuePtr);
        }
      }
      CFRelease(v13);
      v17 = LODWORD(valuePtr);
      if (SLODWORD(valuePtr) < 1
        || (Current = CFAbsoluteTimeGetCurrent(), (v19 = CFDateCreate(0, Current + (double)v17)) == 0))
      {
LABEL_23:
        v26 = 0;
        v24 = 0;
        v20 = CFCalendarCreateWithIdentifier(0, (CFCalendarIdentifier)*MEMORY[0x1E0C9B008]);
        valuePtr = CFAbsoluteTimeGetCurrent();
        CFCalendarAddComponents(v20, &valuePtr, 0, "d", 1);
        CFCalendarDecomposeAbsoluteTime(v20, valuePtr, "yMd", &v24, (char *)&v24 + 4, &v26);
        CFCalendarComposeAbsoluteTime(v20, &valuePtr, "yMdHms", v24, HIDWORD(v24), v26, 5, 0, 0);
        CFRelease(v20);
        v19 = CFDateCreate(0, valuePtr);
      }
      CFDictionarySetValue(v10, CFSTR("Expiration"), v19);
      CFRelease(v19);
    }
    else
    {
      CFDictionaryRemoveValue(MutableCopy, CFSTR("Cost"));
      CFDictionaryRemoveValue(v10, CFSTR("Expiration"));
      if (!CFDictionaryGetCount(v10))
      {
        CFRelease(v10);
        goto LABEL_30;
      }
    }
    if (v10)
    {
      v21 = SCPreferencesPathSetValue(a1, v6, v10);
      CFRelease(v10);
      goto LABEL_33;
    }
LABEL_30:
    v22 = CFDictionaryGetTypeID();
    if (!Value || CFGetTypeID(Value) != v22)
    {
      CFRelease(v6);
      v21 = 1;
LABEL_36:
      _SCErrorSet(0);
      return v21;
    }
    v21 = SCPreferencesPathRemoveValue(a1, v6);
LABEL_33:
    CFRelease(v6);
    if (!(_DWORD)v21)
      return v21;
    goto LABEL_36;
  }
  _SCErrorSet(1002);
  return 0;
}

uint64_t SCNetworkInterfaceTypeGetTemporaryOverrideCost(const __SCPreferences *a1, uint64_t a2)
{
  const __CFString *v3;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  const void *v6;
  CFTypeID v7;
  CFAbsoluteTime Current;
  const __CFDate *v9;
  CFComparisonResult v10;
  const void *v12;
  CFTypeID v13;

  v3 = CFStringCreateWithFormat(0, 0, CFSTR("%@%@/%@/%@/%@/%@"), CFSTR("/"), CFSTR("System"), CFSTR("Network"), CFSTR("Override"), CFSTR("InterfaceType"), a2);
  Value = SCPreferencesPathGetValue(a1, v3);
  CFRelease(v3);
  TypeID = CFDictionaryGetTypeID();
  if (!Value)
    return 0;
  if (CFGetTypeID(Value) != TypeID)
    return 0;
  v6 = CFDictionaryGetValue(Value, CFSTR("Expiration"));
  v7 = CFDateGetTypeID();
  if (!v6)
    return 0;
  if (CFGetTypeID(v6) != v7)
    return 0;
  Current = CFAbsoluteTimeGetCurrent();
  v9 = CFDateCreate(0, Current);
  v10 = CFDateCompare(v9, (CFDateRef)v6, 0);
  CFRelease(v9);
  if (v10 != kCFCompareLessThan)
    return 0;
  v12 = CFDictionaryGetValue(Value, CFSTR("Cost"));
  v13 = CFStringGetTypeID();
  if (!v12 || CFGetTypeID(v12) != v13)
    return 0;
  if (CFEqual(v12, CFSTR("Expensive")))
    return 2;
  return CFEqual(v12, CFSTR("Inexpensive")) != 0;
}

uint64_t __SCNetworkInterfaceEqual(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const void *v5;
  const void *v6;
  CFStringRef v7;
  CFStringRef v8;
  CFStringRef NonLocalizedDisplayName;
  CFStringRef v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;

  if (a1 == a2)
    return 1;
  result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if ((_DWORD)result)
  {
    v5 = *(const void **)(a1 + 112);
    v6 = *(const void **)(a2 + 112);
    if (v5 == v6 || (result = 0, v5) && v6 && (result = CFEqual(*(CFTypeRef *)(a1 + 112), v6), (_DWORD)result))
    {
      v7 = *(CFStringRef *)(a1 + 120);
      v8 = *(CFStringRef *)(a2 + 120);
      if (v7)
      {
        if (v8)
        {
          if (v7 == v8)
            goto LABEL_17;
          goto LABEL_16;
        }
      }
      else if (!v8)
      {
        goto LABEL_17;
      }
      NonLocalizedDisplayName = __SCNetworkInterfaceGetNonLocalizedDisplayName((CFStringRef *)a1);
      v10 = __SCNetworkInterfaceGetNonLocalizedDisplayName((CFStringRef *)a2);
      if (!NonLocalizedDisplayName)
        goto LABEL_17;
      v8 = v10;
      if (!v10 || NonLocalizedDisplayName == v10)
        goto LABEL_17;
      v7 = NonLocalizedDisplayName;
LABEL_16:
      result = CFEqual(v7, v8);
      if (!(_DWORD)result)
        return result;
LABEL_17:
      if (!CFEqual(*(CFTypeRef *)(a1 + 16), CFSTR("Bond")))
        goto LABEL_49;
      v11 = *(const void **)(a1 + 320);
      v12 = *(const void **)(a2 + 320);
      if (v11 == v12 || (result = 0, v11) && v12 && (result = CFEqual(*(CFTypeRef *)(a1 + 320), v12), (_DWORD)result))
      {
        v13 = *(const void **)(a1 + 328);
        v14 = *(const void **)(a2 + 328);
        if (v13 == v14
          || (result = 0, v13) && v14 && (result = CFEqual(*(CFTypeRef *)(a1 + 328), v14), (_DWORD)result))
        {
LABEL_49:
          if (!CFEqual(*(CFTypeRef *)(a1 + 16), CFSTR("Bridge"))
            || (v15 = *(const void **)(a1 + 352), v16 = *(const void **)(a2 + 352), v15 == v16)
            || (result = 0, v15) && v16 && (result = CFEqual(*(CFTypeRef *)(a1 + 352), v16), (_DWORD)result))
          {
            if (!CFEqual(*(CFTypeRef *)(a1 + 16), CFSTR("VLAN")))
              goto LABEL_40;
            v17 = *(const void **)(a1 + 376);
            v18 = *(const void **)(a2 + 376);
            if (v17 == v18
              || (result = 0, v17) && v18 && (result = CFEqual(*(CFTypeRef *)(a1 + 376), v18), (_DWORD)result))
            {
              v19 = *(const void **)(a1 + 384);
              v20 = *(const void **)(a2 + 384);
              if (v19 == v20
                || (result = 0, v19) && v20 && (result = CFEqual(*(CFTypeRef *)(a1 + 384), v20), (_DWORD)result))
              {
LABEL_40:
                v21 = *(const void **)(a1 + 72);
                v22 = *(const void **)(a2 + 72);
                return v21 == v22 || v21 && v22 && CFEqual(v21, v22);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFHashCode __SCNetworkInterfaceHash(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  CFHashCode v4;

  v2 = *(const void **)(a1 + 112);
  if (!v2)
    return 0;
  v3 = *(_QWORD *)(a1 + 120);
  v4 = CFHash(v2);
  if (v3)
    v4 ^= CFHash(*(CFTypeRef *)(a1 + 120));
  return v4;
}

__CFString *__SCNetworkInterfaceCopyFormattingDescription(uint64_t a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFIndex v8;
  uint64_t i;
  const char *v10;
  const char *v11;
  const void *v12;
  CFTypeID TypeID;
  const void *v14;
  CFTypeID v15;
  const void *v16;
  CFStringRef v17;
  uint64_t v18;
  const char *v19;
  const __CFArray *v20;
  CFIndex Count;
  CFIndex v22;
  CFIndex j;
  const __SCNetworkInterface *ValueAtIndex;
  const char *v25;
  CFStringRef BSDName;
  const void *v27;
  CFStringRef v28;
  const __CFArray *v29;
  CFIndex v30;
  CFIndex v31;
  CFIndex k;
  const __SCNetworkInterface *v33;
  const char *v34;
  CFStringRef v35;
  const void *v36;
  CFStringRef v37;
  const __SCNetworkInterface *v38;
  CFStringRef v39;
  const void *v40;
  CFStringRef v41;
  _QWORD valuePtr[2];

  valuePtr[1] = *MEMORY[0x1E0C80C00];
  v4 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v4, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCNetworkInterface %p [%p]> {"), a1, v4);
  CFStringAppendFormat(Mutable, 0, CFSTR("type = %@"), *(_QWORD *)(a1 + 16));
  CFStringAppendFormat(Mutable, 0, CFSTR(", entity_device = %@"), *(_QWORD *)(a1 + 112));
  if (*(_QWORD *)(a1 + 120))
    CFStringAppendFormat(Mutable, 0, CFSTR("+%@"), *(_QWORD *)(a1 + 120));
  CFStringAppendFormat(Mutable, 0, CFSTR(", entity_type = %@"), *(_QWORD *)(a1 + 128));
  if (*(_QWORD *)(a1 + 136))
    CFStringAppendFormat(Mutable, 0, CFSTR(" / %@"), *(_QWORD *)(a1 + 136));
  if (*(_QWORD *)(a1 + 32))
    CFStringAppendFormat(Mutable, 0, CFSTR(", name = %@"), *(_QWORD *)(a1 + 32));
  if (*(_QWORD *)(a1 + 40))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR(", name(l) = %@"), *(_QWORD *)(a1 + 40));
  }
  else if (*(_QWORD *)(a1 + 48))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR(", name(k) = \"%@\""), *(_QWORD *)(a1 + 48));
    if (*(_QWORD *)(a1 + 56))
      CFStringAppendFormat(Mutable, 0, CFSTR("+\"%@\""), *(_QWORD *)(a1 + 56));
    if (*(_QWORD *)(a1 + 64))
      CFStringAppendFormat(Mutable, 0, CFSTR("+\"%@\""), *(_QWORD *)(a1 + 64));
  }
  if (*(_QWORD *)(a1 + 160))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR(", address = "));
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 160));
    Length = CFDataGetLength(*(CFDataRef *)(a1 + 160));
    if (Length >= 1)
    {
      v8 = Length;
      for (i = 0; i != v8; ++i)
      {
        if (i)
          v10 = ":";
        else
          v10 = "";
        CFStringAppendFormat(Mutable, 0, CFSTR("%s%02x"), v10, BytePtr[i]);
      }
    }
  }
  if (*(_BYTE *)(a1 + 176))
    v11 = "TRUE";
  else
    v11 = "FALSE";
  CFStringAppendFormat(Mutable, 0, CFSTR(", builtin = %s"), v11);
  if (*(_BYTE *)(a1 + 192))
    CFStringAppendFormat(Mutable, 0, CFSTR(", hidden = TRUE"));
  if (*(_BYTE *)(a1 + 193))
    CFStringAppendFormat(Mutable, 0, CFSTR(", HIDDEN"));
  if (*(_BYTE *)(a1 + 240))
    CFStringAppendFormat(Mutable, 0, CFSTR(", trust required = TRUE"));
  if (*(_BYTE *)(a1 + 241))
    CFStringAppendFormat(Mutable, 0, CFSTR(", ephemeral"));
  if (*(_BYTE *)(a1 + 242))
    CFStringAppendFormat(Mutable, 0, CFSTR(", self-named"));
  if (*(_QWORD *)(a1 + 200))
    CFStringAppendFormat(Mutable, 0, CFSTR(", location = %@"), *(_QWORD *)(a1 + 200));
  if (*(_QWORD *)(a1 + 208))
    CFStringAppendFormat(Mutable, 0, CFSTR(", path = %@"), *(_QWORD *)(a1 + 208));
  if (*(_QWORD *)(a1 + 216))
    CFStringAppendFormat(Mutable, 0, CFSTR(", entryID = 0x%llx"), *(_QWORD *)(a1 + 216));
  if (*(_QWORD *)(a1 + 248))
    CFStringAppendFormat(Mutable, 0, CFSTR(", type = %@"), *(_QWORD *)(a1 + 248));
  if (*(_QWORD *)(a1 + 256))
    CFStringAppendFormat(Mutable, 0, CFSTR(", unit = %@"), *(_QWORD *)(a1 + 256));
  if (*(_QWORD *)(a1 + 264))
    CFStringAppendFormat(Mutable, 0, CFSTR(", family = %@"), *(_QWORD *)(a1 + 264));
  if (*(_QWORD *)(a1 + 272))
    CFStringAppendFormat(Mutable, 0, CFSTR(", subfamily = %@"), *(_QWORD *)(a1 + 272));
  v12 = *(const void **)(a1 + 296);
  if (*(_OWORD *)(a1 + 288) != 0)
  {
    valuePtr[0] = 0;
    TypeID = CFNumberGetTypeID();
    if (!v12
      || CFGetTypeID(v12) != TypeID
      || !CFNumberGetValue(*(CFNumberRef *)(a1 + 296), kCFNumberIntType, (char *)valuePtr + 4))
    {
      HIDWORD(valuePtr[0]) = 0;
    }
    v14 = *(const void **)(a1 + 288);
    v15 = CFNumberGetTypeID();
    if (!v14 || CFGetTypeID(v14) != v15 || !CFNumberGetValue(*(CFNumberRef *)(a1 + 288), kCFNumberIntType, valuePtr))
      LODWORD(valuePtr[0]) = 0;
    if (*(_QWORD *)(a1 + 280))
      CFStringAppendFormat(Mutable, 0, CFSTR(", USB name = %@"), *(_QWORD *)(a1 + 280));
    CFStringAppendFormat(Mutable, 0, CFSTR(", USB vid/pid = %d/%d"), LODWORD(valuePtr[0]), HIDWORD(valuePtr[0]));
  }
  if (*(_QWORD *)(a1 + 184))
    CFStringAppendFormat(Mutable, 0, CFSTR(", action = %@"), *(_QWORD *)(a1 + 184));
  v16 = *(const void **)(a1 + 224);
  if (v16)
  {
    v17 = _SCCopyDescription(v16, a2);
    CFStringAppendFormat(Mutable, a2, CFSTR(", overrides = %@"), v17);
    CFRelease(v17);
  }
  v18 = *(unsigned int *)(a1 + 312);
  if (v18 > 0x18)
    v19 = "?";
  else
    v19 = sortOrderName[v18];
  CFStringAppendFormat(Mutable, 0, CFSTR(", order = %u (%s)"), *(unsigned int *)(a1 + 312), v19);
  if (*(_QWORD *)(a1 + 80))
    CFStringAppendFormat(Mutable, 0, CFSTR(", prefs = %p"), *(_QWORD *)(a1 + 80));
  if (*(_QWORD *)(a1 + 96))
    CFStringAppendFormat(Mutable, 0, CFSTR(", service = %@"), *(_QWORD *)(a1 + 96));
  if (*(_QWORD *)(a1 + 72))
    CFStringAppendFormat(Mutable, 0, CFSTR(", interface = %@"), *(_QWORD *)(a1 + 72));
  if (*(_QWORD *)(a1 + 104))
    CFStringAppendFormat(Mutable, a2, CFSTR(", unsaved = %@"), *(_QWORD *)(a1 + 104));
  v20 = *(const __CFArray **)(a1 + 320);
  if (v20)
  {
    Count = CFArrayGetCount(v20);
    if (Count >= 1)
    {
      v22 = Count;
      for (j = 0; j != v22; ++j)
      {
        ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 320), j);
        if (j)
          v25 = ",";
        else
          v25 = ", interfaces = ";
        BSDName = SCNetworkInterfaceGetBSDName(ValueAtIndex);
        CFStringAppendFormat(Mutable, 0, CFSTR("%s%@"), v25, BSDName);
      }
    }
  }
  if (*(_QWORD *)(a1 + 328))
    CFStringAppendFormat(Mutable, 0, CFSTR(", mode = %@"), *(_QWORD *)(a1 + 328));
  v27 = *(const void **)(a1 + 336);
  if (v27)
  {
    v28 = _SCCopyDescription(v27, a2);
    CFStringAppendFormat(Mutable, a2, CFSTR(", options = %@"), v28);
    CFRelease(v28);
  }
  v29 = *(const __CFArray **)(a1 + 352);
  if (v29)
  {
    v30 = CFArrayGetCount(v29);
    if (v30 >= 1)
    {
      v31 = v30;
      for (k = 0; k != v31; ++k)
      {
        v33 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 352), k);
        if (k)
          v34 = ",";
        else
          v34 = ", interfaces = ";
        v35 = SCNetworkInterfaceGetBSDName(v33);
        CFStringAppendFormat(Mutable, 0, CFSTR("%s%@"), v34, v35);
      }
    }
  }
  v36 = *(const void **)(a1 + 360);
  if (v36)
  {
    v37 = _SCCopyDescription(v36, a2);
    CFStringAppendFormat(Mutable, a2, CFSTR(", options = %@"), v37);
    CFRelease(v37);
  }
  v38 = *(const __SCNetworkInterface **)(a1 + 376);
  if (v38)
  {
    v39 = SCNetworkInterfaceGetBSDName(v38);
    CFStringAppendFormat(Mutable, 0, CFSTR(", interface = %@"), v39);
  }
  if (*(_QWORD *)(a1 + 384))
    CFStringAppendFormat(Mutable, 0, CFSTR(", tag = %@"), *(_QWORD *)(a1 + 384));
  v40 = *(const void **)(a1 + 392);
  if (v40)
  {
    v41 = _SCCopyDescription(v40, a2);
    CFStringAppendFormat(Mutable, a2, CFSTR(", options = %@"), v41);
    CFRelease(v41);
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  return Mutable;
}

__CFString *__SCNetworkInterfaceCopyDescription(uint64_t a1)
{
  return __SCNetworkInterfaceCopyFormattingDescription(a1, 0);
}

CFStringRef copy_interface_string(__CFBundle *a1, const __CFString *a2, int a3)
{
  CFStringRef v6;
  CFStringRef v7;
  CFStringRef v8;
  CFStringRef v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  _QWORD v35[2];

  v35[1] = *MEMORY[0x1E0C80C00];
  v6 = copy_string_from_bundle(a1, a2, a3);
  v7 = v6;
  if (v6)
  {
    if (CFEqual(v6, a2) && (copy_interface_string_reported & 1) == 0)
    {
      v8 = copy_string_from_bundle(a1, CFSTR("airport"), a3);
      v9 = v8;
      if (v8)
      {
        if (!CFEqual(v8, CFSTR("airport")))
          goto LABEL_9;
      }
      v10 = __log_SCNetworkConfiguration();
      v11 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v10, (os_log_type_t)v11))
      {
        v12 = _os_log_pack_size();
        v20 = (char *)v35 - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v21 = _os_log_pack_fill();
        *(_DWORD *)v21 = 138412802;
        *(_QWORD *)(v21 + 4) = a1;
        *(_WORD *)(v21 + 12) = 2112;
        *(_QWORD *)(v21 + 14) = CFSTR("airport");
        *(_WORD *)(v21 + 22) = 1024;
        *(_DWORD *)(v21 + 24) = a3;
        __SC_log_send(3, (uint64_t)v10, v11, v20);
      }
      _SC_crash("Failed to retrieve interface string", 0, 0);
      copy_interface_string_reported = 1;
      if (v9)
LABEL_9:
        CFRelease(v9);
    }
  }
  else
  {
    v22 = __log_SCNetworkConfiguration();
    v23 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v22, (os_log_type_t)v23))
    {
      v24 = _os_log_pack_size();
      v32 = (char *)v35 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v33 = _os_log_pack_fill();
      *(_DWORD *)v33 = 138412802;
      *(_QWORD *)(v33 + 4) = a1;
      *(_WORD *)(v33 + 12) = 2112;
      *(_QWORD *)(v33 + 14) = a2;
      *(_WORD *)(v33 + 22) = 1024;
      *(_DWORD *)(v33 + 24) = a3;
      __SC_log_send(3, (uint64_t)v22, v23, v32);
    }
  }
  return v7;
}

CFStringRef copy_string_from_bundle(__CFBundle *a1, CFStringRef value, int a3)
{
  if (a3)
    return CFBundleCopyLocalizedString(a1, value, value, CFSTR("NetworkInterface"));
  else
    return (CFStringRef)CFBundleCopyLocalizedStringForLocalization();
}

uint64_t isBuiltin(io_registry_entry_t a1)
{
  CFMutableStringRef v1;

  v1 = pci_slot(a1, 0);
  if (!v1)
    return 1;
  CFRelease(v1);
  return 0;
}

uint64_t pci_slot_info(io_registry_entry_t a1, int a2, CFMutableStringRef *a3, CFStringRef *a4)
{
  CFStringRef v8;
  CFMutableStringRef v9;
  uint64_t v10;
  CFTypeRef cf;
  CFMutableDictionaryRef properties[2];

  properties[1] = *(CFMutableDictionaryRef *)MEMORY[0x1E0C80C00];
  cf = 0;
  properties[0] = 0;
  *a3 = 0;
  *a4 = 0;
  IORegistryEntryCreateCFProperties(a1, properties, 0, 0);
  if (properties[0])
  {
    v8 = IODictionaryCopyBSDName(properties[0]);
    CFRelease(properties[0]);
    if (v8)
    {
      v9 = pci_slot(a1, &cf);
      *a3 = v9;
      if (v9)
      {
        if (!cf)
        {
          v10 = 1;
LABEL_11:
          CFRelease(v8);
          return v10;
        }
        *a4 = pci_port((void *)cf, a2, v8);
        v10 = 1;
      }
      else
      {
        v10 = 0;
      }
      if (cf)
        CFRelease(cf);
      goto LABEL_11;
    }
  }
  return 0;
}

uint64_t isThunderbolt(io_registry_entry_t a1)
{
  uint64_t result;

  result = (uint64_t)IORegistryEntrySearchCFProperty(a1, "IOService", CFSTR("PCI-Thunderbolt"), 0, 3u);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 1;
  }
  return result;
}

_QWORD *processUSBInterface(_QWORD *result, io_registry_entry_t entry)
{
  _QWORD *v3;

  v3 = result;
  if (!result[35])
  {
    result = IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("kUSBProductString"), 0, 3u);
    v3[35] = result;
  }
  if (!v3[36])
  {
    result = IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("idVendor"), 0, 3u);
    v3[36] = result;
  }
  if (!v3[37])
  {
    result = IORegistryEntrySearchCFProperty(entry, "IOService", CFSTR("idProduct"), 0, 3u);
    v3[37] = result;
  }
  return result;
}

CFMutableStringRef pci_slot(io_registry_entry_t a1, CFTypeRef *a2)
{
  const __CFString *CFProperty;
  const __CFString *v5;
  CFMutableStringRef Mutable;
  CFTypeID TypeID;
  CFTypeID v8;
  const char *BytePtr;
  uint64_t i;
  const __CFString *v11;
  CFIndex Length;
  kern_return_t ParentEntry;
  kern_return_t v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeRef v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  _DWORD *v29;
  uint64_t v31;
  CFTypeRef v32;
  io_registry_entry_t parent;
  uint64_t v34;
  CFRange v35;

  v34 = *MEMORY[0x1E0C80C00];
  if (a2)
    *a2 = 0;
  CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(a1, CFSTR("AAPL,slot-name"), 0, 0);
  if (CFProperty)
  {
    v5 = CFProperty;
    Mutable = CFStringCreateMutable(0, 0);
    TypeID = CFStringGetTypeID();
    if (CFGetTypeID(v5) == TypeID)
    {
      if (a2)
        *a2 = CFStringCreateCopy(0, v5);
      CFStringAppend(Mutable, v5);
    }
    else
    {
      v8 = CFDataGetTypeID();
      if (CFGetTypeID(v5) == v8)
      {
        if (a2)
          *a2 = CFDataCreateCopy(0, (CFDataRef)v5);
        BytePtr = (const char *)CFDataGetBytePtr((CFDataRef)v5);
        CFStringAppendCString(Mutable, BytePtr, 0x8000100u);
      }
    }
    for (i = 0; i != 3; ++i)
    {
      v11 = slot_prefixes[i];
      Length = CFStringGetLength(v11);
      if (CFStringGetLength(Mutable) > Length)
      {
        v35.location = 0;
        v35.length = Length;
        CFStringFindAndReplace(Mutable, v11, &stru_1E25D5260, v35, 9uLL);
      }
    }
    CFStringTrimWhitespace(Mutable);
    CFRelease(v5);
  }
  else
  {
    Mutable = 0;
  }
  parent = 0;
  ParentEntry = IORegistryEntryGetParentEntry(a1, "IOService", &parent);
  if (ParentEntry != -536870208)
  {
    v14 = ParentEntry;
    if (!ParentEntry)
    {
      v32 = 0;
      v15 = pci_slot(parent, &v32);
      if (v15)
      {
        v16 = v15;
        if (Mutable)
          CFRelease(Mutable);
        if (a2)
        {
          if (*a2)
            CFRelease(*a2);
          v17 = v32;
          *a2 = v32;
          if (!v17)
            goto LABEL_33;
          CFRetain(v17);
        }
      }
      else
      {
        v16 = (uint64_t)Mutable;
      }
      if (v32)
        CFRelease(v32);
LABEL_33:
      IOObjectRelease(parent);
      return (CFMutableStringRef)v16;
    }
    v18 = __log_SCNetworkConfiguration();
    v19 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v18, (os_log_type_t)v19))
    {
      v20 = _os_log_pack_size();
      v28 = (char *)&v31 - ((MEMORY[0x1E0C80A78](v20, v21, v22, v23, v24, v25, v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v29 = (_DWORD *)_os_log_pack_fill();
      *v29 = 67109120;
      v29[1] = v14;
      __SC_log_send(6, (uint64_t)v18, v19, v28);
    }
  }
  return Mutable;
}

CFStringRef pci_port(void *a1, int a2, const void *a3)
{
  const CFDictionaryKeyCallBacks *v5;
  const CFDictionaryValueCallBacks *v6;
  CFDictionaryRef v7;
  const __CFDictionary *v8;
  kern_return_t MatchingServices;
  kern_return_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  _DWORD *v22;
  __CFArray *Mutable;
  uint64_t v24;
  uint64_t v25;
  int v26;
  const void *Value;
  const void *v28;
  CFTypeID TypeID;
  CFStringRef v30;
  CFStringRef v31;
  io_object_t v32;
  io_registry_entry_t v33;
  uint64_t Count;
  CFIndex v35;
  CFIndex FirstIndexOfValue;
  CFStringRef v37;
  int v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  _DWORD *v51;
  _BYTE v53[4];
  int valuePtr;
  CFMutableDictionaryRef properties;
  io_iterator_t v56;
  io_iterator_t existing;
  void *values;
  CFDictionaryRef v59;
  void *keys;
  const __CFString *v61;
  uint64_t v62;
  CFRange v63;
  CFRange v64;

  v62 = *MEMORY[0x1E0C80C00];
  existing = 0;
  keys = CFSTR("AAPL,slot-name");
  v61 = 0;
  values = a1;
  v59 = 0;
  v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v7 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  keys = CFSTR("IOProviderClass");
  v61 = CFSTR("IOPropertyMatch");
  values = CFSTR("IOPCIDevice");
  v59 = v7;
  v8 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 2, v5, v6);
  CFRelease(v7);
  MatchingServices = IOServiceGetMatchingServices(masterPort, v8, &existing);
  if (MatchingServices)
  {
    v10 = MatchingServices;
    v11 = __log_SCNetworkConfiguration();
    v12 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v11, (os_log_type_t)v12))
    {
      v13 = _os_log_pack_size();
      v21 = &v53[-((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v22 = (_DWORD *)_os_log_pack_fill();
      *v22 = 67109120;
      v22[1] = v10;
      __SC_log_send(6, (uint64_t)v11, v12, v21);
    }
    return 0;
  }
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v24 = IOIteratorNext(existing);
  if ((_DWORD)v24)
  {
    v25 = v24;
    while (1)
    {
      v56 = 0;
      v26 = MEMORY[0x18D78C3C0](v25, "IOService", 1, &v56);
      if (v26)
        break;
      while (1)
      {
        v32 = IOIteratorNext(v56);
        v33 = v32;
        if (!v32)
          break;
        if (IOObjectConformsTo(v32, "IONetworkInterface"))
        {
          properties = 0;
          IORegistryEntryCreateCFProperties(v33, &properties, 0, 0);
          if (properties)
          {
            valuePtr = a2;
            Value = CFDictionaryGetValue(properties, CFSTR("IOInterfaceType"));
            if (Value)
            {
              v28 = Value;
              TypeID = CFNumberGetTypeID();
              if (CFGetTypeID(v28) != TypeID || !CFNumberGetValue((CFNumberRef)v28, kCFNumberIntType, &valuePtr))
                valuePtr = a2;
            }
            if (valuePtr == a2)
            {
              v30 = IODictionaryCopyBSDName(properties);
              if (v30)
              {
                v31 = v30;
                CFArrayAppendValue(Mutable, v30);
                CFRelease(v31);
              }
            }
            CFRelease(properties);
          }
        }
        IOObjectRelease(v33);
      }
      IOObjectRelease(v56);
      IOObjectRelease(v25);
      v25 = IOIteratorNext(existing);
      if (!(_DWORD)v25)
        goto LABEL_21;
    }
    v38 = v26;
    v39 = __log_SCNetworkConfiguration();
    v40 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v39, (os_log_type_t)v40))
    {
      v42 = _os_log_pack_size();
      v50 = &v53[-((MEMORY[0x1E0C80A78](v42, v43, v44, v45, v46, v47, v48, v49) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v51 = (_DWORD *)_os_log_pack_fill();
      *v51 = 67109120;
      v51[1] = v38;
      __SC_log_send(6, (uint64_t)v39, v40, v50);
    }
    CFRelease(Mutable);
    return 0;
  }
LABEL_21:
  IOObjectRelease(existing);
  Count = CFArrayGetCount(Mutable);
  if (Count < 2
    || (v35 = Count,
        v63.location = 0,
        v63.length = Count,
        CFArraySortValues(Mutable, v63, (CFComparatorFunction)compare_bsdNames, 0),
        v64.location = 0,
        v64.length = v35,
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(Mutable, v64, a3),
        FirstIndexOfValue == -1))
  {
    v37 = 0;
  }
  else
  {
    v37 = CFStringCreateWithFormat(0, 0, CFSTR("%ld"), FirstIndexOfValue + 1);
  }
  CFRelease(Mutable);
  return v37;
}

CFComparisonResult compare_bsdNames(const __CFString *a1, const __CFString *a2)
{
  return CFStringCompare(a1, a2, 0);
}

uint64_t isBluetoothBuiltin(_BYTE *a1)
{
  mach_port_t v2;
  const __CFDictionary *v3;
  kern_return_t MatchingServices;
  io_iterator_t v5;
  BOOL v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  _DWORD *v18;
  uint64_t v19;
  io_registry_entry_t v20;
  const __CFNumber *CFProperty;
  const __CFNumber *v22;
  CFTypeID TypeID;
  BOOL v24;
  int valuePtr;
  io_iterator_t existing;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  existing = 0;
  v2 = masterPort;
  v3 = IOServiceMatching("IOBluetoothHCIController");
  MatchingServices = IOServiceGetMatchingServices(v2, v3, &existing);
  v5 = existing;
  if (MatchingServices)
    v6 = 1;
  else
    v6 = existing == 0;
  if (v6)
  {
    if (MatchingServices)
    {
      v7 = __log_SCNetworkConfiguration();
      v8 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v7, (os_log_type_t)v8))
      {
        v9 = _os_log_pack_size();
        v17 = (char *)&valuePtr
            - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v18 = (_DWORD *)_os_log_pack_fill();
        *v18 = 67109120;
        v18[1] = MatchingServices;
        __SC_log_send(6, (uint64_t)v7, v8, v17);
      }
    }
    v19 = 0;
    *a1 = 0;
  }
  else
  {
    *a1 = 1;
    v20 = IOIteratorNext(v5);
    IOObjectRelease(existing);
    if (v20)
    {
      CFProperty = (const __CFNumber *)IORegistryEntryCreateCFProperty(v20, CFSTR("idVendor"), 0, 0);
      if (CFProperty)
      {
        v22 = CFProperty;
        valuePtr = 0;
        TypeID = CFNumberGetTypeID();
        v19 = 0;
        if (CFGetTypeID(v22) == TypeID)
        {
          if (CFNumberGetValue(v22, kCFNumberIntType, &valuePtr))
            v24 = valuePtr == 1452;
          else
            v24 = 0;
          v19 = v24;
        }
        CFRelease(v22);
      }
      else
      {
        v19 = 0;
      }
      IOObjectRelease(v20);
    }
    else
    {
      return 0;
    }
  }
  return v19;
}

void set_connection_script(uint64_t a1, const void *a2)
{
  const __CFDictionary *Mutable;
  const __CFDictionary *Value;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v7;
  CFIndex Count;
  __CFDictionary *v9;

  Mutable = *(const __CFDictionary **)(a1 + 224);
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)(a1 + 224) = Mutable;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(Mutable, CFSTR("Modem"));
  if (Value)
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
  else
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = MutableCopy;
  if (a2)
    CFDictionarySetValue(MutableCopy, CFSTR("ConnectionScript"), a2);
  else
    CFDictionaryRemoveValue(MutableCopy, CFSTR("ConnectionScript"));
  Count = CFDictionaryGetCount(v7);
  v9 = *(__CFDictionary **)(a1 + 224);
  if (Count < 1)
    CFDictionaryRemoveValue(v9, CFSTR("Modem"));
  else
    CFDictionarySetValue(v9, CFSTR("Modem"), v7);
  CFRelease(v7);
  if (!CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 224)))
  {
    CFRelease(*(CFTypeRef *)(a1 + 224));
    *(_QWORD *)(a1 + 224) = 0;
  }
}

uint64_t is_valid_connection_script(const __CFString *a1)
{
  uint64_t started;
  uint64_t result;
  __int128 v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  size_t v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  int *v35;
  char *v36;
  __int128 v37;
  stat v38;
  char v39[1024];
  UInt8 v40[1024];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  _SC_cfstring_to_cstring(a1, v40, 1024, 0x8000100u);
  started = sysdir_start_search_path_enumeration(SYSDIR_DIRECTORY_LIBRARY, SYSDIR_DOMAIN_MASK_SYSTEM|SYSDIR_DOMAIN_MASK_LOCAL);
  result = MEMORY[0x18D78D0D4](started, v39);
  if ((_DWORD)result)
  {
    v4 = result;
    *(_QWORD *)&v3 = 136315138;
    v37 = v3;
    do
    {
      memset(&v38, 0, sizeof(v38));
      if (v40[0] == 47)
        v39[0] = 0;
      else
        __strlcat_chk();
      __strlcat_chk();
      if (stat(v39, &v38))
      {
        if (*__error() != 2)
        {
          v5 = __log_SCNetworkConfiguration();
          v6 = _SC_syslog_os_log_mapping(6);
          if (__SC_log_enabled(6, v5, (os_log_type_t)v6))
          {
            v7 = _os_log_pack_size();
            v15 = (char *)&v37
                - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v16 = _os_log_pack_fill();
            v17 = __error();
            v18 = strerror(*v17);
            *(_DWORD *)v16 = v37;
            *(_QWORD *)(v16 + 4) = v18;
            v19 = (uint64_t)v5;
            v20 = v6;
            v21 = v15;
LABEL_17:
            __SC_log_send(6, v19, v20, v21);
            goto LABEL_19;
          }
          goto LABEL_19;
        }
      }
      else if ((v38.st_mode & 0xF000) == 0x8000)
      {
        return 1;
      }
      v22 = strlen(v39);
      if (v22 < 5 || !strstr(&v39[v22 - 6], ".ccl"))
      {
        __strlcat_chk();
        if (stat(v39, &v38))
        {
          if (*__error() == 2)
            goto LABEL_19;
          v23 = __log_SCNetworkConfiguration();
          v24 = _SC_syslog_os_log_mapping(6);
          if (!__SC_log_enabled(6, v23, (os_log_type_t)v24))
            goto LABEL_19;
          v25 = _os_log_pack_size();
          v33 = (char *)&v37
              - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v34 = _os_log_pack_fill();
          v35 = __error();
          v36 = strerror(*v35);
          *(_DWORD *)v34 = v37;
          *(_QWORD *)(v34 + 4) = v36;
          v19 = (uint64_t)v23;
          v20 = v24;
          v21 = v33;
          goto LABEL_17;
        }
      }
      if ((v38.st_mode & 0xF000) == 0x4000)
        return 1;
LABEL_19:
      result = MEMORY[0x18D78D0D4](v4, v39);
      v4 = result;
    }
    while ((_DWORD)result);
  }
  return result;
}

const __SCNetworkInterface *findInterface(const __CFArray *a1, const void *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const __SCNetworkInterface *ValueAtIndex;
  CFStringRef BSDName;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v5 = Count;
  v6 = 0;
  while (1)
  {
    ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(a1, v6);
    BSDName = SCNetworkInterfaceGetBSDName(ValueAtIndex);
    if (BSDName)
    {
      if (CFEqual(BSDName, a2))
        break;
    }
    if (v5 == ++v6)
      return 0;
  }
  CFRetain(ValueAtIndex);
  return ValueAtIndex;
}

void localizeNumberString(CFStringRef *a1)
{
  const __CFString *v1;
  CFIndex Length;
  const __CFLocale *v4;
  __CFNumberFormatter *v5;
  const __CFNumber *v6;
  CFIndex v7;
  const __CFString *StringWithNumber;
  const __CFString *v9;
  CFRange rangep;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v1 = *a1;
  if (*a1)
  {
    Length = CFStringGetLength(*a1);
    rangep.location = 0;
    rangep.length = Length;
    v4 = CFLocaleCopyCurrent();
    v5 = CFNumberFormatterCreate(0, v4, kCFNumberFormatterNoStyle);
    v6 = CFNumberFormatterCreateNumberFromString(0, v5, v1, &rangep, 1uLL);
    if (v6 && (v7 = rangep.length, v7 == CFStringGetLength(v1)))
      StringWithNumber = CFNumberFormatterCreateStringWithNumber(0, v5, v6);
    else
      StringWithNumber = (const __CFString *)CFRetain(v1);
    v9 = StringWithNumber;
    if (v4)
      CFRelease(v4);
    if (v5)
      CFRelease(v5);
    if (v6)
      CFRelease(v6);
    CFRelease(v1);
    *a1 = v9;
  }
}

__CFArray *copyPerInterfaceConfigurationPaths(uint64_t a1, uint64_t a2)
{
  _QWORD *Private;
  const __CFArray *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  __CFArray *Mutable;
  CFIndex v10;
  const CFArrayCallBacks *v11;
  const __SCNetworkSet *ValueAtIndex;
  const __CFArray *v13;
  CFStringRef SetID;
  CFStringRef SetNetworkInterfaceEntity;
  CFRange v17;

  Private = __SCNetworkServiceCreatePrivate(0, *(const void **)(a1 + 80), *(const __CFString **)(a1 + 96), (const void *)a1);
  v5 = SCNetworkSetCopyAll(*(SCPreferencesRef *)(a1 + 80));
  if (v5)
  {
    v6 = v5;
    Count = CFArrayGetCount(v5);
    if (Count < 1)
    {
      Mutable = 0;
    }
    else
    {
      v8 = Count;
      Mutable = 0;
      v10 = 0;
      v11 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      do
      {
        ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v6, v10);
        v13 = SCNetworkSetCopyServices(ValueAtIndex);
        v17.length = CFArrayGetCount(v13);
        v17.location = 0;
        if (CFArrayContainsValue(v13, v17, Private))
        {
          SetID = SCNetworkSetGetSetID(ValueAtIndex);
          SetNetworkInterfaceEntity = SCPreferencesPathKeyCreateSetNetworkInterfaceEntity(0, (uint64_t)SetID, *(_QWORD *)(a1 + 112), a2);
          if (!Mutable)
            Mutable = CFArrayCreateMutable(0, 0, v11);
          CFArrayAppendValue(Mutable, SetNetworkInterfaceEntity);
          CFRelease(SetNetworkInterfaceEntity);
        }
        CFRelease(v13);
        ++v10;
      }
      while (v8 != v10);
    }
    CFRelease(Private);
    CFRelease(v6);
  }
  else
  {
    CFRelease(Private);
    return 0;
  }
  return Mutable;
}

uint64_t findPerInterfaceConfiguration(uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  CFTypeRef **i;

  v1 = 0;
  v2 = *(const void **)(a1 + 16);
  for (i = (CFTypeRef **)configurations; !CFEqual(v2, **i); i += 5)
  {
    if (++v1 == 19)
      return -1;
  }
  if (((0x5BF13uLL >> v1) & 1) != 0)
    return -1;
  else
    return v1;
}

void __addExtendedConfigurationType(const void *a1, uint64_t a2, uint64_t a3)
{
  const __CFArray *v5;
  CFRange v6;

  if (!CFEqual(a1, *(CFTypeRef *)a3))
  {
    v5 = *(const __CFArray **)(a3 + 8);
    v6.length = CFArrayGetCount(v5);
    v6.location = 0;
    if (!CFArrayContainsValue(v5, v6, a1))
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 8), a1);
  }
}

uint64_t _SCDynamicStoreCacheIsActive(unsigned __int8 *a1)
{
  CFTypeID TypeID;

  TypeID = SCDynamicStoreGetTypeID();
  if (a1 && CFGetTypeID(a1) == TypeID)
    return a1[200];
  _SCErrorSet(2001);
  return 0;
}

uint64_t _SCDynamicStoreCacheOpen(uint64_t a1)
{
  CFTypeID TypeID;
  uint64_t result;

  TypeID = SCDynamicStoreGetTypeID();
  if (a1 && CFGetTypeID((CFTypeRef)a1) == TypeID)
  {
    __SCDynamicStoreCacheRelease((_QWORD *)a1);
    result = 1;
    *(_BYTE *)(a1 + 200) = 1;
  }
  else
  {
    _SCErrorSet(2001);
    return 0;
  }
  return result;
}

void __SCDynamicStoreCacheRelease(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  v2 = (const void *)a1[26];
  if (v2)
  {
    CFRelease(v2);
    a1[26] = 0;
  }
  v3 = (const void *)a1[27];
  if (v3)
  {
    CFRelease(v3);
    a1[27] = 0;
  }
  v4 = (const void *)a1[28];
  if (v4)
  {
    CFRelease(v4);
    a1[28] = 0;
  }
  v5 = (const void *)a1[29];
  if (v5)
  {
    CFRelease(v5);
    a1[29] = 0;
  }
}

uint64_t _SCDynamicStoreCacheCommitChanges(uint64_t a1)
{
  CFTypeID TypeID;
  const __CFArray *v3;
  uint64_t v4;
  int v6;

  TypeID = SCDynamicStoreGetTypeID();
  if (!a1 || CFGetTypeID((CFTypeRef)a1) != TypeID)
  {
    v6 = 2001;
LABEL_9:
    _SCErrorSet(v6);
    return 0;
  }
  if (!*(_BYTE *)(a1 + 200))
  {
    v6 = 1001;
    goto LABEL_9;
  }
  v3 = *(const __CFArray **)(a1 + 224);
  if (*(_OWORD *)(a1 + 216) != 0)
  {
LABEL_7:
    v4 = SCDynamicStoreSetMultiple((SCDynamicStoreRef)a1, *(CFDictionaryRef *)(a1 + 216), v3, *(CFArrayRef *)(a1 + 232));
    __SCDynamicStoreCacheRelease((_QWORD *)a1);
    return v4;
  }
  if (*(_QWORD *)(a1 + 232))
  {
    v3 = 0;
    goto LABEL_7;
  }
  return 1;
}

uint64_t _SCDynamicStoreCacheClose(uint64_t a1)
{
  CFTypeID TypeID;
  int v4;

  TypeID = SCDynamicStoreGetTypeID();
  if (a1 && CFGetTypeID((CFTypeRef)a1) == TypeID)
  {
    if (*(_BYTE *)(a1 + 200))
    {
      __SCDynamicStoreCacheRelease((_QWORD *)a1);
      *(_BYTE *)(a1 + 200) = 0;
      return 1;
    }
    v4 = 1001;
  }
  else
  {
    v4 = 2001;
  }
  _SCErrorSet(v4);
  return 0;
}

uint64_t __SCNetworkProtocolCreatePrivate(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t Instance;

  if (__SCNetworkProtocolInitialize_initialized != -1)
    dispatch_once(&__SCNetworkProtocolInitialize_initialized, &__block_literal_global_12);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = CFStringCreateCopy(0, a2);
    *(_QWORD *)(Instance + 24) = CFRetain(a3);
  }
  return Instance;
}

BOOL __SCNetworkProtocolIsValidType(const __CFString *cf1)
{
  uint64_t v2;
  CFRange v4;

  v2 = 0;
  while (!CFEqual(cf1, *__SCNetworkProtocolIsValidType_valid_types[v2]))
  {
    if (++v2 == 4)
    {
      v4.length = CFStringGetLength(cf1);
      v4.location = 0;
      return CFStringFindWithOptions(cf1, CFSTR("."), v4, 0, 0) != 0;
    }
  }
  return 1;
}

CFComparisonResult _SCNetworkProtocolCompare(const __SCNetworkProtocol *a1, const __SCNetworkProtocol *a2)
{
  const __CFString *ProtocolType;
  const __CFString *v4;

  ProtocolType = SCNetworkProtocolGetProtocolType(a1);
  v4 = SCNetworkProtocolGetProtocolType(a2);
  return CFStringCompare(ProtocolType, v4, 0);
}

CFStringRef SCNetworkProtocolGetProtocolType(SCNetworkProtocolRef protocol)
{
  uint64_t v2;

  if (__SCNetworkProtocolInitialize_initialized == -1)
  {
    if (!protocol)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCNetworkProtocolInitialize_initialized, &__block_literal_global_12);
    if (!protocol)
      goto LABEL_6;
  }
  v2 = __kSCNetworkProtocolTypeID;
  if (CFGetTypeID(protocol) == v2)
    return (CFStringRef)*((_QWORD *)protocol + 2);
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

CFTypeID SCNetworkProtocolGetTypeID(void)
{
  if (__SCNetworkProtocolInitialize_initialized != -1)
    dispatch_once(&__SCNetworkProtocolInitialize_initialized, &__block_literal_global_12);
  return __kSCNetworkProtocolTypeID;
}

CFDictionaryRef SCNetworkProtocolGetConfiguration(SCNetworkProtocolRef protocol)
{
  uint64_t v2;
  uint64_t v3;
  const __CFString *NetworkServiceEntity;
  const __CFDictionary *Value;

  if (__SCNetworkProtocolInitialize_initialized == -1)
  {
    if (!protocol)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCNetworkProtocolInitialize_initialized, &__block_literal_global_12);
    if (!protocol)
      goto LABEL_6;
  }
  v2 = __kSCNetworkProtocolTypeID;
  if (CFGetTypeID(protocol) == v2)
  {
    v3 = *((_QWORD *)protocol + 3);
    NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *(_QWORD *)(v3 + 16), *((_QWORD *)protocol + 2));
    Value = __SCNetworkConfigurationGetValue(*(const __SCPreferences **)(v3 + 32), NetworkServiceEntity);
    CFRelease(NetworkServiceEntity);
    return Value;
  }
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

Boolean SCNetworkProtocolGetEnabled(SCNetworkProtocolRef protocol)
{
  uint64_t v2;
  uint64_t v3;
  const __CFString *NetworkServiceEntity;
  Boolean PrefsEnabled;

  if (__SCNetworkProtocolInitialize_initialized == -1)
  {
    if (!protocol)
      goto LABEL_6;
  }
  else
  {
    dispatch_once(&__SCNetworkProtocolInitialize_initialized, &__block_literal_global_12);
    if (!protocol)
      goto LABEL_6;
  }
  v2 = __kSCNetworkProtocolTypeID;
  if (CFGetTypeID(protocol) == v2)
  {
    v3 = *((_QWORD *)protocol + 3);
    NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *(_QWORD *)(v3 + 16), *((_QWORD *)protocol + 2));
    PrefsEnabled = __getPrefsEnabled(*(const __SCPreferences **)(v3 + 32), NetworkServiceEntity);
    CFRelease(NetworkServiceEntity);
    return PrefsEnabled;
  }
LABEL_6:
  _SCErrorSet(1002);
  return 0;
}

Boolean SCNetworkProtocolSetConfiguration(SCNetworkProtocolRef protocol, CFDictionaryRef config)
{
  uint64_t v4;
  uint64_t v5;
  const __CFString *NetworkServiceEntity;
  int v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  CFDictionaryRef v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkProtocolInitialize_initialized == -1)
  {
    if (!protocol)
    {
LABEL_14:
      _SCErrorSet(1002);
      LOBYTE(v7) = 0;
      return v7;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkProtocolInitialize_initialized, &__block_literal_global_12);
    if (!protocol)
      goto LABEL_14;
  }
  v4 = __kSCNetworkProtocolTypeID;
  if (CFGetTypeID(protocol) != v4)
    goto LABEL_14;
  v5 = *((_QWORD *)protocol + 3);
  if (!__SCNetworkServiceExists(v5))
  {
    v21 = __log_SCNetworkConfiguration();
    v22 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v21, (os_log_type_t)v22))
    {
      v23 = _os_log_pack_size();
      v31 = (char *)block - ((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v32 = _os_log_pack_fill();
      v33 = *((_QWORD *)protocol + 2);
      *(_DWORD *)v32 = 138412546;
      *(_QWORD *)(v32 + 4) = v33;
      *(_WORD *)(v32 + 12) = 2112;
      *(_QWORD *)(v32 + 14) = v5;
      __SC_log_send(3, (uint64_t)v21, v22, v31);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_2;
    block[3] = &__block_descriptor_tmp_27_0;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkProtocolSetConfiguration() w/removed service";
    if (_SC_crash_once_once_2 != -1)
      dispatch_once(&_SC_crash_once_once_2, block);
    goto LABEL_14;
  }
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *(_QWORD *)(*((_QWORD *)protocol + 3) + 16), *((_QWORD *)protocol + 2));
  v7 = __SCNetworkConfigurationSetValue(*(SCPreferencesRef *)(v5 + 32), NetworkServiceEntity, config, 1);
  CFRelease(NetworkServiceEntity);
  if (v7)
  {
    v8 = __log_SCNetworkConfiguration();
    v9 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v8, (os_log_type_t)v9))
    {
      v10 = _os_log_pack_size();
      v18 = (char *)block - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v19 = _os_log_pack_fill();
      v20 = (CFDictionaryRef)CFSTR("NULL");
      if (config)
        v20 = config;
      *(_DWORD *)v19 = 138412546;
      *(_QWORD *)(v19 + 4) = protocol;
      *(_WORD *)(v19 + 12) = 2112;
      *(_QWORD *)(v19 + 14) = v20;
      __SC_log_send(7, (uint64_t)v8, v9, v18);
    }
  }
  return v7;
}

Boolean SCNetworkProtocolSetEnabled(SCNetworkProtocolRef protocol, Boolean enabled)
{
  int v2;
  uint64_t v4;
  uint64_t v5;
  const __CFString *NetworkServiceEntity;
  int v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  const char *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD block[8];

  v2 = enabled;
  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkProtocolInitialize_initialized == -1)
  {
    if (!protocol)
    {
LABEL_14:
      _SCErrorSet(1002);
      LOBYTE(v7) = 0;
      return v7;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkProtocolInitialize_initialized, &__block_literal_global_12);
    if (!protocol)
      goto LABEL_14;
  }
  v4 = __kSCNetworkProtocolTypeID;
  if (CFGetTypeID(protocol) != v4)
    goto LABEL_14;
  v5 = *((_QWORD *)protocol + 3);
  if (!__SCNetworkServiceExists(v5))
  {
    v21 = __log_SCNetworkConfiguration();
    v22 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v21, (os_log_type_t)v22))
    {
      v23 = _os_log_pack_size();
      v31 = (char *)block - ((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v32 = _os_log_pack_fill();
      v33 = *((_QWORD *)protocol + 2);
      *(_DWORD *)v32 = 138412546;
      *(_QWORD *)(v32 + 4) = v33;
      *(_WORD *)(v32 + 12) = 2112;
      *(_QWORD *)(v32 + 14) = v5;
      __SC_log_send(3, (uint64_t)v21, v22, v31);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_2;
    block[3] = &__block_descriptor_tmp_27_0;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkProtocolSetEnabled() w/removed service";
    if (_SC_crash_once_once_2 != -1)
      dispatch_once(&_SC_crash_once_once_2, block);
    goto LABEL_14;
  }
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *(_QWORD *)(*((_QWORD *)protocol + 3) + 16), *((_QWORD *)protocol + 2));
  v7 = __setPrefsEnabled(*(const __SCPreferences **)(v5 + 32), NetworkServiceEntity, v2);
  CFRelease(NetworkServiceEntity);
  if (v7)
  {
    v8 = __log_SCNetworkConfiguration();
    v9 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v8, (os_log_type_t)v9))
    {
      v10 = _os_log_pack_size();
      v18 = (char *)block - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v19 = _os_log_pack_fill();
      v20 = "Enabled";
      if (!v2)
        v20 = "Disabled";
      *(_DWORD *)v19 = 138412546;
      *(_QWORD *)(v19 + 4) = protocol;
      *(_WORD *)(v19 + 12) = 2080;
      *(_QWORD *)(v19 + 14) = v20;
      __SC_log_send(7, (uint64_t)v8, v9, v18);
    }
  }
  return v7;
}

void __SCNetworkProtocolDeallocate(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 16));
  CFRelease(*(CFTypeRef *)(a1 + 24));
}

uint64_t __SCNetworkProtocolEqual(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const void *v5;
  const void *v6;

  if (a1 == a2)
    return 1;
  result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if (!(_DWORD)result)
    return result;
  v5 = *(const void **)(a1 + 24);
  v6 = *(const void **)(a2 + 24);
  return v5 == v6 || v5 && v6 && CFEqual(v5, v6);
}

CFHashCode __SCNetworkProtocolHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 16));
}

__CFString *__SCNetworkProtocolCopyDescription(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCNetworkProtocol %p [%p]> {"), a1, v2);
  CFStringAppendFormat(Mutable, 0, CFSTR("id = %@"), a1[2]);
  CFStringAppendFormat(Mutable, 0, CFSTR(", service = %p"), a1[3]);
  CFStringAppendFormat(Mutable, 0, CFSTR(", prefs = %p"), *(_QWORD *)(a1[3] + 32));
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  return Mutable;
}

CFComparisonResult _SCNetworkServiceCompare(const __SCNetworkService *a1, const __SCNetworkService *a2, const __CFArray *a3)
{
  const __CFString *ServiceID;
  const __CFString *v6;
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  CFIndex v9;
  BOOL v10;
  uint64_t v11;
  CFRange v13;
  CFRange v14;

  ServiceID = SCNetworkServiceGetServiceID(a1);
  v6 = SCNetworkServiceGetServiceID(a2);
  if (!a3)
    return CFStringCompare(ServiceID, v6, 0);
  Count = CFArrayGetCount(a3);
  v13.location = 0;
  v13.length = Count;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(a3, v13, ServiceID);
  v14.location = 0;
  v14.length = Count;
  v9 = CFArrayGetFirstIndexOfValue(a3, v14, v6);
  if (FirstIndexOfValue > v9)
  {
    v10 = v9 == -1;
    v11 = -1;
    goto LABEL_6;
  }
  if (FirstIndexOfValue >= v9)
    return CFStringCompare(ServiceID, v6, 0);
  v10 = FirstIndexOfValue == -1;
  v11 = 1;
LABEL_6:
  if (v10)
    return v11;
  else
    return -v11;
}

__CFArray *__SCNetworkServiceCopyAllEnabled(const __SCPreferences *a1)
{
  const __CFArray *v1;
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  __CFArray *Mutable;
  CFIndex v6;
  const CFArrayCallBacks *v7;
  const __SCNetworkSet *ValueAtIndex;
  const __CFArray *v9;
  const __CFArray *v10;
  CFIndex v11;
  CFIndex v12;
  CFIndex i;
  const void *v14;
  CFRange v16;

  v1 = SCNetworkSetCopyAll(a1);
  if (!v1)
    return 0;
  v2 = v1;
  Count = CFArrayGetCount(v1);
  if (Count >= 1)
  {
    v4 = Count;
    Mutable = 0;
    v6 = 0;
    v7 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    while (1)
    {
      ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v2, v6);
      v9 = SCNetworkSetCopyServices(ValueAtIndex);
      if (v9)
      {
        v10 = v9;
        v11 = CFArrayGetCount(v9);
        if (v11 >= 1)
        {
          v12 = v11;
          for (i = 0; v12 != i; ++i)
          {
            v14 = CFArrayGetValueAtIndex(v10, i);
            if (SCNetworkServiceGetEnabled((SCNetworkServiceRef)v14))
            {
              if (!Mutable)
              {
                Mutable = CFArrayCreateMutable(0, 0, v7);
LABEL_12:
                CFArrayAppendValue(Mutable, v14);
                continue;
              }
              v16.length = CFArrayGetCount(Mutable);
              v16.location = 0;
              if (!CFArrayContainsValue(Mutable, v16, v14))
                goto LABEL_12;
            }
          }
        }
        CFRelease(v10);
      }
      if (++v6 == v4)
        goto LABEL_19;
    }
  }
  Mutable = 0;
LABEL_19:
  CFRelease(v2);
  return Mutable;
}

uint64_t __SCNetworkServiceExistsForInterface(const void *a1, const void *a2)
{
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const __SCNetworkService *ValueAtIndex;
  SCNetworkInterfaceRef Interface;
  const __SCNetworkInterface *v10;
  uint64_t result;

  TypeID = CFArrayGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) != TypeID)
    return 0;
  Count = CFArrayGetCount((CFArrayRef)a1);
  if (Count < 1)
    return 0;
  v6 = Count;
  v7 = 0;
  while (1)
  {
    ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex((CFArrayRef)a1, v7);
    Interface = SCNetworkServiceGetInterface(ValueAtIndex);
    if (Interface)
      break;
LABEL_9:
    result = 0;
    if (++v7 == v6)
      return result;
  }
  v10 = Interface;
  while (!CFEqual(a2, v10))
  {
    v10 = SCNetworkInterfaceGetInterface(v10);
    if (!v10)
      goto LABEL_9;
  }
  return 1;
}

Boolean SCNetworkServiceAddProtocolType(SCNetworkServiceRef service, CFStringRef protocolType)
{
  uint64_t v4;
  const __CFString *NetworkServiceEntity;
  int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  const __CFDictionary *v20;
  int v21;
  SCNetworkProtocolRef v22;
  const __SCNetworkProtocol *v23;
  uint64_t v24;
  CFStringRef InterfaceType;
  const __SCNetworkInterface *Interface;
  const __SCNetworkInterface *v27;
  const __CFString *v28;
  const __CFDictionary *v29;
  const __CFDictionary *v30;
  const __CFDictionary *TemplateOverrides;
  CFTypeID TypeID;
  CFMutableDictionaryRef MutableCopy;
  Boolean v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkServiceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (service)
      goto LABEL_3;
LABEL_15:
    _SCErrorSet(1002);
    LOBYTE(v6) = 0;
    return v6;
  }
  if (!service)
    goto LABEL_15;
LABEL_3:
  v4 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) != v4 || !*((_QWORD *)service + 4) || !__SCNetworkProtocolIsValidType(protocolType))
    goto LABEL_15;
  if (!__SCNetworkServiceExists((uint64_t)service))
  {
    v7 = _SC_LOG_DEFAULT();
    v8 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v7, (os_log_type_t)v8))
    {
      v9 = _os_log_pack_size();
      v17 = (char *)block - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v18 = _os_log_pack_fill();
      *(_DWORD *)v18 = 138412546;
      *(_QWORD *)(v18 + 4) = service;
      *(_WORD *)(v18 + 12) = 2112;
      *(_QWORD *)(v18 + 14) = protocolType;
      __SC_log_send(3, (uint64_t)v7, v8, v17);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_3;
    block[3] = &__block_descriptor_tmp_40;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkServiceAddProtocolType() w/removed service";
    if (_SC_crash_once_once_3 != -1)
      dispatch_once(&_SC_crash_once_once_3, block);
    goto LABEL_15;
  }
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)service + 2), (uint64_t)protocolType);
  if (!SCPreferencesPathGetValue(*((SCPreferencesRef *)service + 4), NetworkServiceEntity))
  {
    v20 = CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v21 = SCPreferencesPathSetValue(*((SCPreferencesRef *)service + 4), NetworkServiceEntity, v20);
    CFRelease(v20);
    if (!v21)
      goto LABEL_9;
    v22 = SCNetworkServiceCopyProtocol(service, protocolType);
    if (!v22)
      SCNetworkServiceAddProtocolType_cold_1();
    v23 = v22;
    v24 = *((_QWORD *)service + 3);
    if (v24)
    {
      InterfaceType = SCNetworkInterfaceGetInterfaceType(*((SCNetworkInterfaceRef *)service + 3));
      Interface = SCNetworkInterfaceGetInterface(*((SCNetworkInterfaceRef *)service + 3));
      if (Interface)
      {
        v27 = Interface;
        v28 = SCNetworkInterfaceGetInterfaceType(Interface);
        v29 = (const __CFDictionary *)__copyProtocolTemplate(InterfaceType, v28, protocolType);
        if (v29)
        {
          v30 = v29;
          do
          {
            v24 = (uint64_t)v27;
            v27 = SCNetworkInterfaceGetInterface(v27);
          }
          while (v27);
LABEL_26:
          TemplateOverrides = (const __CFDictionary *)__SCNetworkInterfaceGetTemplateOverrides(v24, protocolType);
          TypeID = CFDictionaryGetTypeID();
          if (TemplateOverrides && CFGetTypeID(TemplateOverrides) == TypeID)
          {
            MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v30);
            CFDictionaryApplyFunction(TemplateOverrides, (CFDictionaryApplierFunction)mergeDict, MutableCopy);
            CFRelease(v30);
            v30 = MutableCopy;
          }
          if (v30)
            goto LABEL_31;
        }
      }
      else
      {
        v30 = (const __CFDictionary *)__copyProtocolTemplate(InterfaceType, 0, protocolType);
        if (v30)
          goto LABEL_26;
      }
    }
    v30 = CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!v30)
      SCNetworkServiceAddProtocolType_cold_2();
LABEL_31:
    if (SCNetworkProtocolSetConfiguration(v23, v30))
    {
      v34 = CFDictionaryContainsKey(v30, CFSTR("__INACTIVE__")) == 0;
      v6 = SCNetworkProtocolSetEnabled(v23, v34);
    }
    else
    {
      v6 = 0;
    }
    CFRelease(v30);
    CFRelease(v23);
    if (v6)
    {
      v35 = _SC_LOG_DEFAULT();
      v36 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v35, (os_log_type_t)v36))
      {
        v37 = _os_log_pack_size();
        v45 = (char *)block
            - ((MEMORY[0x1E0C80A78](v37, v38, v39, v40, v41, v42, v43, v44) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v46 = _os_log_pack_fill();
        *(_DWORD *)v46 = 138412546;
        *(_QWORD *)(v46 + 4) = service;
        *(_WORD *)(v46 + 12) = 2112;
        *(_QWORD *)(v46 + 14) = protocolType;
        __SC_log_send(7, (uint64_t)v35, v36, v45);
      }
    }
    goto LABEL_10;
  }
  _SCErrorSet(1005);
LABEL_9:
  LOBYTE(v6) = 0;
LABEL_10:
  CFRelease(NetworkServiceEntity);
  return v6;
}

BOOL __SCNetworkServiceExists(uint64_t a1)
{
  const __CFString *NetworkServiceEntity;
  CFDictionaryRef Value;
  CFTypeID TypeID;

  if (*(_QWORD *)(a1 + 32)
    && (NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *(_QWORD *)(a1 + 16), (uint64_t)CFSTR("Interface")), Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 32), NetworkServiceEntity), CFRelease(NetworkServiceEntity), TypeID = CFDictionaryGetTypeID(), Value))
  {
    return CFGetTypeID(Value) == TypeID;
  }
  else
  {
    return 0;
  }
}

SCNetworkProtocolRef SCNetworkServiceCopyProtocol(SCNetworkServiceRef service, CFStringRef protocolType)
{
  uint64_t v4;
  CFTypeID TypeID;
  const __CFString *NetworkServiceEntity;
  CFDictionaryRef Value;
  CFTypeID v8;
  __CFSet *v9;
  int v10;
  const __SCNetworkProtocol *Private;
  int v12;

  if (__SCNetworkServiceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (service)
      goto LABEL_3;
LABEL_18:
    v12 = 1002;
    goto LABEL_19;
  }
  if (!service)
    goto LABEL_18;
LABEL_3:
  v4 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) != v4)
    goto LABEL_18;
  if (!*((_QWORD *)service + 4))
    goto LABEL_18;
  TypeID = CFStringGetTypeID();
  if (!protocolType || CFGetTypeID(protocolType) != TypeID)
    goto LABEL_18;
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)service + 2), 0);
  Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)service + 4), NetworkServiceEntity);
  CFRelease(NetworkServiceEntity);
  v8 = CFDictionaryGetTypeID();
  if (!Value || CFGetTypeID(Value) != v8)
  {
    v12 = 1001;
LABEL_19:
    _SCErrorSet(v12);
    return 0;
  }
  v9 = _copyInterfaceEntityTypes(Value);
  if (CFSetContainsValue(v9, protocolType))
  {
    v10 = 1002;
  }
  else
  {
    if (CFDictionaryContainsKey(Value, protocolType))
    {
      Private = (const __SCNetworkProtocol *)__SCNetworkProtocolCreatePrivate(0, protocolType, service);
      goto LABEL_15;
    }
    v10 = 1004;
  }
  _SCErrorSet(v10);
  Private = 0;
LABEL_15:
  CFRelease(v9);
  return Private;
}

CFArrayRef SCNetworkServiceCopyAll(SCPreferencesRef prefs)
{
  const __CFString *NetworkServices;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  const __CFArray *Mutable;
  CFIndex Count;
  CFIndex v7;
  const void **v8;
  const void **v9;
  uint64_t v11;
  __int128 v12;
  const void *v13;
  CFTypeID v14;
  const void *v15;
  CFTypeID v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  const void *v42;
  char *v43;
  NSObject *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const void *v55;
  _QWORD *Private;
  const void *v57;
  SCPreferencesRef v58;
  CFMutableArrayRef v59;
  __int128 v60;
  __int128 v61;
  const __CFString *v62;
  _OWORD v63[32];
  _OWORD v64[32];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  NetworkServices = SCPreferencesPathKeyCreateNetworkServices(0);
  Value = SCPreferencesPathGetValue(prefs, NetworkServices);
  CFRelease(NetworkServices);
  if (!Value)
    return CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  TypeID = CFDictionaryGetTypeID();
  if (CFGetTypeID(Value) != TypeID)
    return 0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  Count = CFDictionaryGetCount(Value);
  if (Count < 1)
    return Mutable;
  v7 = Count;
  memset(v64, 0, sizeof(v64));
  memset(v63, 0, sizeof(v63));
  v58 = prefs;
  v59 = Mutable;
  if ((unint64_t)Count < 0x41)
  {
    v8 = (const void **)v64;
    v9 = (const void **)v63;
  }
  else
  {
    v8 = (const void **)CFAllocatorAllocate(0, 8 * Count, 0);
    v9 = (const void **)CFAllocatorAllocate(0, 8 * v7, 0);
  }
  CFDictionaryGetKeysAndValues(Value, v8, v9);
  v11 = 0;
  v62 = CFSTR("Interface");
  *(_QWORD *)&v12 = 138412290;
  v61 = v12;
  *(_QWORD *)&v12 = 138412546;
  v60 = v12;
  do
  {
    v13 = v9[v11];
    v14 = CFDictionaryGetTypeID();
    if (!v13 || CFGetTypeID(v13) != v14)
    {
      v30 = _SC_LOG_DEFAULT();
      v31 = _SC_syslog_os_log_mapping(6);
      if (!__SC_log_enabled(6, v30, (os_log_type_t)v31))
        goto LABEL_23;
      v32 = _os_log_pack_size();
      v40 = (char *)&v58 - ((MEMORY[0x1E0C80A78](v32, v33, v34, v35, v36, v37, v38, v39) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v41 = _os_log_pack_fill();
      v42 = v8[v11];
      *(_DWORD *)v41 = v61;
      *(_QWORD *)(v41 + 4) = v42;
      v28 = (uint64_t)v30;
      v29 = v31;
      v43 = v40;
      goto LABEL_22;
    }
    v15 = CFDictionaryGetValue((CFDictionaryRef)v9[v11], v62);
    v16 = CFDictionaryGetTypeID();
    if (!v15 || CFGetTypeID(v15) != v16)
    {
      v44 = _SC_LOG_DEFAULT();
      v45 = _SC_syslog_os_log_mapping(6);
      if (!__SC_log_enabled(6, v44, (os_log_type_t)v45))
        goto LABEL_23;
      v46 = _os_log_pack_size();
      v27 = (char *)&v58 - ((MEMORY[0x1E0C80A78](v46, v47, v48, v49, v50, v51, v52, v53) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v54 = _os_log_pack_fill();
      v55 = v8[v11];
      *(_DWORD *)v54 = v60;
      *(_QWORD *)(v54 + 4) = v62;
      *(_WORD *)(v54 + 12) = 2112;
      *(_QWORD *)(v54 + 14) = v55;
      v28 = (uint64_t)v44;
      v29 = v45;
      goto LABEL_21;
    }
    if (__SCNetworkInterfaceEntityIsPPTP((const __CFDictionary *)v15))
    {
      v17 = _SC_LOG_DEFAULT();
      v18 = _SC_syslog_os_log_mapping(6);
      if (!__SC_log_enabled(6, v17, (os_log_type_t)v18))
        goto LABEL_23;
      v19 = _os_log_pack_size();
      v27 = (char *)&v58 - ((MEMORY[0x1E0C80A78](v19, v20, v21, v22, v23, v24, v25, v26) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      v28 = (uint64_t)v17;
      v29 = v18;
LABEL_21:
      v43 = v27;
LABEL_22:
      __SC_log_send(6, v28, v29, v43);
      goto LABEL_23;
    }
    Private = __SCNetworkServiceCreatePrivate(0, v58, (const __CFString *)v8[v11], 0);
    if (!Private)
      SCNetworkServiceCopyAll_cold_1();
    v57 = Private;
    CFArrayAppendValue(v59, Private);
    CFRelease(v57);
LABEL_23:
    ++v11;
  }
  while (v7 != v11);
  if (v8 != (const void **)v64)
  {
    CFAllocatorDeallocate(0, v8);
    CFAllocatorDeallocate(0, v9);
  }
  return v59;
}

__CFArray *__SCNetworkServiceCopyAllInterfaces(const __SCPreferences *a1)
{
  const __CFArray *v1;
  const __CFArray *v2;
  CFIndex Count;
  uint64_t v4;
  __CFArray *Mutable;
  CFIndex i;
  const __SCNetworkService *ValueAtIndex;
  SCNetworkInterfaceRef Interface;
  CFTypeID TypeID;

  v1 = SCNetworkServiceCopyAll(a1);
  if (!v1)
    return 0;
  v2 = v1;
  Count = CFArrayGetCount(v1);
  if (Count)
  {
    v4 = Count;
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    if (v4 >= 1)
    {
      for (i = 0; i != v4; ++i)
      {
        ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(v2, i);
        Interface = SCNetworkServiceGetInterface(ValueAtIndex);
        TypeID = SCNetworkInterfaceGetTypeID();
        if (Interface && CFGetTypeID(Interface) == TypeID)
          CFArrayAppendValue(Mutable, Interface);
      }
    }
    if (CFArrayGetCount(Mutable))
      goto LABEL_12;
    CFRelease(Mutable);
  }
  Mutable = 0;
LABEL_12:
  CFRelease(v2);
  return Mutable;
}

SCNetworkServiceRef SCNetworkServiceCopy(SCPreferencesRef prefs, CFStringRef serviceID)
{
  CFTypeID TypeID;
  const __CFString *NetworkServiceEntity;
  CFDictionaryRef Value;
  CFTypeID v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  int v19;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  TypeID = CFStringGetTypeID();
  if (!serviceID || CFGetTypeID(serviceID) != TypeID)
  {
    v19 = 1002;
    goto LABEL_10;
  }
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, (uint64_t)serviceID, (uint64_t)CFSTR("Interface"));
  Value = SCPreferencesPathGetValue(prefs, NetworkServiceEntity);
  CFRelease(NetworkServiceEntity);
  v7 = CFDictionaryGetTypeID();
  if (!Value || CFGetTypeID(Value) != v7)
  {
LABEL_8:
    v19 = 1004;
LABEL_10:
    _SCErrorSet(v19);
    return 0;
  }
  if (__SCNetworkInterfaceEntityIsPPTP(Value))
  {
    v8 = _SC_LOG_DEFAULT();
    v9 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v8, (os_log_type_t)v9))
    {
      v10 = _os_log_pack_size();
      v18 = (char *)v21 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v8, v9, v18);
    }
    goto LABEL_8;
  }
  return (SCNetworkServiceRef)__SCNetworkServiceCreatePrivate(0, prefs, serviceID, 0);
}

_QWORD *_SCNetworkServiceCopyActive(const void *a1, const __CFString *a2)
{
  CFTypeID TypeID;
  _QWORD *Private;
  _QWORD *v6;

  TypeID = CFStringGetTypeID();
  if (a2 && CFGetTypeID(a2) == TypeID)
  {
    Private = __SCNetworkServiceCreatePrivate(0, 0, a2, 0);
    if (!Private)
      _SCNetworkServiceCopyActive_cold_1();
    v6 = Private;
    if (a1)
    {
      Private[5] = a1;
      CFRetain(a1);
    }
  }
  else
  {
    _SCErrorSet(1002);
    return 0;
  }
  return v6;
}

__CFSet *_copyInterfaceEntityTypes(const __CFDictionary *a1)
{
  __CFSet *Mutable;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  uint64_t i;
  const void *v6;
  CFTypeID v7;
  _QWORD v9[4];

  v9[3] = *MEMORY[0x1E0C80C00];
  Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("Interface"));
  TypeID = CFDictionaryGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID)
  {
    v9[0] = CFSTR("Type");
    v9[1] = CFSTR("SubType");
    v9[2] = CFSTR("Hardware");
    CFSetAddValue(Mutable, CFSTR("Interface"));
    for (i = 0; i != 3; ++i)
    {
      v6 = CFDictionaryGetValue(Value, (const void *)v9[i]);
      v7 = CFStringGetTypeID();
      if (v6 && CFGetTypeID(v6) == v7)
        CFSetAddValue(Mutable, v6);
    }
    CFSetAddValue(Mutable, CFSTR("PPP"));
  }
  return Mutable;
}

CFArrayRef SCNetworkServiceCopyProtocols(SCNetworkServiceRef service)
{
  uint64_t v2;
  const __CFString *NetworkServiceEntity;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  __CFSet *v6;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v9;
  const void **v10;
  const void **v11;
  int v12;
  uint64_t i;
  const void *v14;
  CFTypeID v15;
  const void *Private;
  _OWORD v18[32];
  _OWORD v19[32];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkServiceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (service)
      goto LABEL_3;
LABEL_22:
    v12 = 1002;
    goto LABEL_23;
  }
  if (!service)
    goto LABEL_22;
LABEL_3:
  v2 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) != v2 || !*((_QWORD *)service + 4))
    goto LABEL_22;
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)service + 2), 0);
  Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)service + 4), NetworkServiceEntity);
  CFRelease(NetworkServiceEntity);
  TypeID = CFDictionaryGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID)
  {
    v12 = 1001;
LABEL_23:
    _SCErrorSet(v12);
    return 0;
  }
  v6 = _copyInterfaceEntityTypes(Value);
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  Count = CFDictionaryGetCount(Value);
  if (Count >= 1)
  {
    v9 = Count;
    memset(v19, 0, sizeof(v19));
    memset(v18, 0, sizeof(v18));
    if ((unint64_t)Count < 0x41)
    {
      v11 = (const void **)v18;
      v10 = (const void **)v19;
    }
    else
    {
      v10 = (const void **)CFAllocatorAllocate(0, 8 * Count, 0);
      v11 = (const void **)CFAllocatorAllocate(0, 8 * v9, 0);
    }
    CFDictionaryGetKeysAndValues(Value, v10, v11);
    for (i = 0; i != v9; ++i)
    {
      v14 = v11[i];
      v15 = CFDictionaryGetTypeID();
      if (v14 && CFGetTypeID(v14) == v15 && !CFSetContainsValue(v6, v10[i]))
      {
        Private = (const void *)__SCNetworkProtocolCreatePrivate(0, (const __CFString *)v10[i], service);
        CFArrayAppendValue(Mutable, Private);
        CFRelease(Private);
      }
    }
    if (v10 != (const void **)v19)
    {
      CFAllocatorDeallocate(0, v10);
      CFAllocatorDeallocate(0, v11);
    }
  }
  CFRelease(v6);
  return Mutable;
}

SCNetworkServiceRef SCNetworkServiceCreate(SCPreferencesRef prefs, SCNetworkInterfaceRef interface)
{
  CFTypeID TypeID;
  const __CFString *InterfaceType;
  int v6;
  CFStringRef UniqueChild;
  const __CFString *NetworkServices;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFString *ValueAtIndex;
  const __SCNetworkInterface *Copy;
  __int128 v13;
  const __CFString *v14;
  const __CFString *v15;
  const CFDictionaryKeyCallBacks *v16;
  const CFDictionaryValueCallBacks *v17;
  CFStringRef v18;
  const __SCNetworkInterface *v19;
  const __CFString *v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  __CFDictionary *MutableCopy;
  const void *TemplateOverrides;
  CFTypeID v25;
  CFTypeID v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const CFDictionaryValueCallBacks *v37;
  char *v38;
  uint64_t v39;
  char *v40;
  const __CFString *v41;
  const __CFString *NetworkServiceEntity;
  __CFDictionary *v43;
  __CFArray *v44;
  __n128 v45;
  const __CFString *Name;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  const __CFString *v60;
  const __CFString *v61;
  CFStringRef v62;
  const __CFString *v63;
  const __CFString *v64;
  __int128 v65;
  const __CFString *v66;
  const __CFString *v67;
  const __CFString *v68;
  const __CFString *v69;
  const __CFString *v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!interface
    || CFGetTypeID(interface) != TypeID
    || !SCNetworkInterfaceGetSupportedProtocolTypes(interface)
    && (InterfaceType = SCNetworkInterfaceGetInterfaceType(interface),
        CFStringFind(InterfaceType, CFSTR("."), 0).location == -1))
  {
    v6 = 1002;
    goto LABEL_8;
  }
  if (__SCNetworkInterfaceIsBusyMember(prefs, interface, 1))
  {
    v6 = 1001;
LABEL_8:
    _SCErrorSet(v6);
    return 0;
  }
  NetworkServices = SCPreferencesPathKeyCreateNetworkServices(0);
  UniqueChild = SCPreferencesPathCreateUniqueChild(prefs, NetworkServices);
  CFRelease(NetworkServices);
  if (!UniqueChild)
    return (SCNetworkServiceRef)UniqueChild;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, UniqueChild, CFSTR("/"));
  CFRelease(UniqueChild);
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 2);
  UniqueChild = (CFStringRef)__SCNetworkServiceCreatePrivate(0, prefs, ValueAtIndex, 0);
  CFRelease(ArrayBySeparatingStrings);
  Copy = (const __SCNetworkInterface *)__SCNetworkInterfaceCreateCopy(0, (uint64_t)interface, prefs, ValueAtIndex);
  UniqueChild->length = (uint64_t)Copy;
  if (!Copy)
    goto LABEL_43;
  v62 = UniqueChild;
  v14 = CFSTR("Bluetooth");
  v64 = CFSTR("Serial");
  v63 = CFSTR("WWAN");
  v15 = CFSTR("ConnectionScript");
  v70 = CFSTR("ConnectionPersonality");
  v69 = CFSTR("DeviceVendor");
  v68 = CFSTR("DeviceModel");
  v61 = CFSTR("PPP");
  v16 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v17 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v60 = CFSTR("VPN");
  *(_QWORD *)&v13 = 138412290;
  v65 = v13;
  v66 = CFSTR("ConnectionScript");
  v67 = CFSTR("Bluetooth");
  do
  {
    v18 = SCNetworkInterfaceGetInterfaceType(Copy);
    v19 = SCNetworkInterfaceGetInterface(Copy);
    if (v19)
      v20 = SCNetworkInterfaceGetInterfaceType(v19);
    else
      v20 = 0;
    v21 = (const __CFDictionary *)__copyInterfaceTemplate(v18, v20);
    if (v21)
    {
      v22 = v21;
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v21);
      CFRelease(v22);
    }
    else
    {
      MutableCopy = CFDictionaryCreateMutable(0, 0, v16, v17);
    }
    if (CFEqual(v18, v14) || CFEqual(v18, CFSTR("Modem")) || CFEqual(v18, v64) || CFEqual(v18, v63))
    {
      TemplateOverrides = __SCNetworkInterfaceGetTemplateOverrides((uint64_t)Copy, CFSTR("Modem"));
      v25 = CFDictionaryGetTypeID();
      if (!TemplateOverrides)
      {
        CFDictionaryGetTypeID();
        goto LABEL_31;
      }
      if (CFGetTypeID(TemplateOverrides) == v25 && CFDictionaryContainsKey((CFDictionaryRef)TemplateOverrides, v15))
      {
        CFDictionaryRemoveValue(MutableCopy, v70);
        CFDictionaryRemoveValue(MutableCopy, v15);
        CFDictionaryRemoveValue(MutableCopy, v69);
        CFDictionaryRemoveValue(MutableCopy, v68);
      }
      v26 = CFDictionaryGetTypeID();
LABEL_28:
      if (CFGetTypeID(TemplateOverrides) == v26)
        CFDictionaryApplyFunction((CFDictionaryRef)TemplateOverrides, (CFDictionaryApplierFunction)mergeDict, MutableCopy);
      goto LABEL_31;
    }
    v41 = v61;
    if (!CFEqual(v18, v61))
    {
      if (CFEqual(v18, v60))
        v41 = v61;
      else
        v41 = v18;
    }
    TemplateOverrides = __SCNetworkInterfaceGetTemplateOverrides((uint64_t)Copy, v41);
    v26 = CFDictionaryGetTypeID();
    if (TemplateOverrides)
      goto LABEL_28;
LABEL_31:
    if (CFDictionaryGetCount(MutableCopy) >= 1
      && !__SCNetworkInterfaceSetConfiguration((uint64_t)Copy, 0, MutableCopy, 1))
    {
      v27 = _SC_LOG_DEFAULT();
      v28 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v27, (os_log_type_t)v28))
      {
        v29 = _os_log_pack_size();
        v37 = v17;
        v38 = (char *)&v59 - ((MEMORY[0x1E0C80A78](v29, v30, v31, v32, v33, v34, v35, v36) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v39 = _os_log_pack_fill();
        *(_DWORD *)v39 = v65;
        *(_QWORD *)(v39 + 4) = Copy;
        v40 = v38;
        v17 = v37;
        __SC_log_send(6, (uint64_t)v27, v28, v40);
        v15 = v66;
        v14 = v67;
      }
    }
    CFRelease(MutableCopy);
    Copy = SCNetworkInterfaceGetInterface(Copy);
  }
  while (Copy);
  UniqueChild = v62;
  Copy = (const __SCNetworkInterface *)v62->length;
LABEL_43:
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, (uint64_t)UniqueChild->data, (uint64_t)CFSTR("Interface"));
  v43 = __SCNetworkInterfaceCopyInterfaceEntity(Copy);
  SCPreferencesPathSetValue((SCPreferencesRef)UniqueChild[1].isa, NetworkServiceEntity, v43);
  CFRelease(v43);
  CFRelease(NetworkServiceEntity);
  v44 = __SCNetworkInterfaceCopyDeepConfiguration(0, (const __SCNetworkInterface *)UniqueChild->length);
  __SCNetworkInterfaceSetDeepConfiguration(0, (const __SCNetworkInterface *)UniqueChild->length, v44, v45);
  if (v44)
    CFRelease(v44);
  Name = __SCNetworkServiceGetName(UniqueChild, 1);
  if (Name)
    SCNetworkServiceSetName((SCNetworkServiceRef)UniqueChild, Name);
  v47 = _SC_LOG_DEFAULT();
  v48 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v47, (os_log_type_t)v48))
  {
    v49 = _os_log_pack_size();
    v57 = (char *)&v59 - ((MEMORY[0x1E0C80A78](v49, v50, v51, v52, v53, v54, v55, v56) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v58 = _os_log_pack_fill();
    *(_DWORD *)v58 = 138412290;
    *(_QWORD *)(v58 + 4) = UniqueChild;
    __SC_log_send(7, (uint64_t)v47, v48, v57);
  }
  return (SCNetworkServiceRef)UniqueChild;
}

void mergeDict(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

CFStringRef SCNetworkServiceGetName(SCNetworkServiceRef service)
{
  return __SCNetworkServiceGetName(service, 1);
}

Boolean SCNetworkServiceSetName(SCNetworkServiceRef service, CFStringRef name)
{
  uint64_t v4;
  CFTypeID TypeID;
  CFTypeRef v6;
  const __SCNetworkInterface *Interface;
  const __SCNetworkInterface *v8;
  CFStringRef LocalizedDisplayName;
  const __CFString *v10;
  CFStringRef NonLocalizedDisplayName;
  CFStringRef v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  CFStringRef v25;
  int v26;
  int v27;
  CFIndex Length;
  CFStringRef v30;
  CFStringRef v31;
  CFStringRef v32;
  const __CFArray *v33;
  const __CFArray *v34;
  CFIndex v35;
  const __SCNetworkSet *ValueAtIndex;
  const __CFArray *v37;
  CFIndex v38;
  CFIndex v39;
  int v40;
  int v41;
  CFIndex i;
  const __SCNetworkService *v43;
  CFStringRef ServiceID;
  const __CFString *v45;
  const __CFString *NetworkServiceEntity;
  const __CFDictionary *Value;
  CFTypeID v48;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v50;
  const void *v51;
  NSObject *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  CFTypeRef v64;
  CFIndex Count;
  _QWORD block[8];
  CFRange v67;

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkServiceInitialize_initialized == -1)
  {
    if (!service)
      goto LABEL_21;
  }
  else
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (!service)
      goto LABEL_21;
  }
  v4 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) != v4 || !*((_QWORD *)service + 4))
    goto LABEL_21;
  if (!__SCNetworkServiceExists((uint64_t)service))
  {
    v13 = _SC_LOG_DEFAULT();
    v14 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v13, (os_log_type_t)v14))
    {
      v15 = _os_log_pack_size();
      v23 = (char *)&v64 - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v24 = _os_log_pack_fill();
      v25 = CFSTR("<NULL>");
      if (name)
        v25 = name;
      *(_DWORD *)v24 = 138412546;
      *(_QWORD *)(v24 + 4) = service;
      *(_WORD *)(v24 + 12) = 2112;
      *(_QWORD *)(v24 + 14) = v25;
      __SC_log_send(3, (uint64_t)v13, v14, v23);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_3;
    block[3] = &__block_descriptor_tmp_40;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkServiceSetName() w/removed service";
    if (_SC_crash_once_once_3 != -1)
      dispatch_once(&_SC_crash_once_once_3, block);
    goto LABEL_21;
  }
  if (!name)
  {
    v6 = 0;
    goto LABEL_46;
  }
  TypeID = CFStringGetTypeID();
  if (CFGetTypeID(name) != TypeID)
  {
LABEL_21:
    v26 = 1002;
LABEL_22:
    _SCErrorSet(v26);
    LOBYTE(v27) = 0;
    return v27;
  }
  v6 = CFRetain(name);
  Interface = SCNetworkServiceGetInterface(service);
  while (Interface)
  {
    v8 = Interface;
    Interface = SCNetworkInterfaceGetInterface(Interface);
    if (!Interface)
    {
      LocalizedDisplayName = SCNetworkInterfaceGetLocalizedDisplayName(v8);
      if (LocalizedDisplayName)
      {
        v10 = LocalizedDisplayName;
        if (CFEqual(name, LocalizedDisplayName))
        {
          NonLocalizedDisplayName = __SCNetworkInterfaceGetNonLocalizedDisplayName((CFStringRef *)v8);
          if (NonLocalizedDisplayName)
          {
            v12 = NonLocalizedDisplayName;
            CFRelease(v6);
            v6 = CFRetain(v12);
          }
        }
        else if (CFStringHasPrefix(name, v10))
        {
          Length = CFStringGetLength(v10);
          v67.length = CFStringGetLength(name) - Length;
          v67.location = Length;
          v30 = CFStringCreateWithSubstring(0, name, v67);
          v31 = __SCNetworkInterfaceGetNonLocalizedDisplayName((CFStringRef *)v8);
          if (v31)
          {
            v32 = v31;
            CFRelease(v6);
            v6 = CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), v32, v30);
          }
          CFRelease(v30);
        }
      }
      break;
    }
  }
  v33 = SCNetworkSetCopyAll(*((SCPreferencesRef *)service + 4));
  if (v33)
  {
    v34 = v33;
    v64 = v6;
    Count = CFArrayGetCount(v33);
    if (Count >= 1)
    {
      v35 = 0;
      while (1)
      {
        ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v34, v35);
        v37 = SCNetworkSetCopyServices(ValueAtIndex);
        v38 = CFArrayGetCount(v37);
        if (v38 < 1)
        {
          v41 = 0;
          v40 = 0;
        }
        else
        {
          v39 = v38;
          v40 = 0;
          v41 = 0;
          for (i = 0; i != v39; ++i)
          {
            v43 = (const __SCNetworkService *)CFArrayGetValueAtIndex(v37, i);
            ServiceID = SCNetworkServiceGetServiceID(v43);
            if (CFEqual(*((CFTypeRef *)service + 2), ServiceID))
            {
              v40 = 1;
            }
            else
            {
              v45 = __SCNetworkServiceGetName(v43, 1);
              if (v45 && CFEqual(name, v45))
                v41 = 1;
            }
          }
        }
        CFRelease(v37);
        if (v40)
        {
          if (v41)
            break;
        }
        if (++v35 == Count)
          goto LABEL_45;
      }
      CFRelease(v34);
      if (v64)
        CFRelease(v64);
      v26 = 1005;
      goto LABEL_22;
    }
LABEL_45:
    CFRelease(v34);
    v6 = v64;
  }
LABEL_46:
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)service + 2), 0);
  Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)service + 4), NetworkServiceEntity);
  v48 = CFDictionaryGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) == v48)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
LABEL_51:
      v50 = MutableCopy;
      if (v6)
        CFDictionarySetValue(MutableCopy, CFSTR("UserDefinedName"), v6);
      else
        CFDictionaryRemoveValue(MutableCopy, CFSTR("UserDefinedName"));
      v27 = SCPreferencesPathSetValue(*((SCPreferencesRef *)service + 4), NetworkServiceEntity, v50);
      CFRelease(v50);
      goto LABEL_56;
    }
  }
  else if (name)
  {
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_51;
  }
  v27 = 0;
LABEL_56:
  CFRelease(NetworkServiceEntity);
  if (v6)
    CFRelease(v6);
  v51 = (const void *)*((_QWORD *)service + 6);
  if (v51)
    CFRelease(v51);
  if (name)
    CFRetain(name);
  *((_QWORD *)service + 6) = name;
  if (v27)
  {
    v52 = _SC_LOG_DEFAULT();
    v53 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v52, (os_log_type_t)v53))
    {
      v54 = _os_log_pack_size();
      v62 = (char *)&v64 - ((MEMORY[0x1E0C80A78](v54, v55, v56, v57, v58, v59, v60, v61) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v63 = _os_log_pack_fill();
      *(_DWORD *)v63 = 138412290;
      *(_QWORD *)(v63 + 4) = service;
      __SC_log_send(7, (uint64_t)v52, v53, v62);
    }
  }
  return v27;
}

const __SCNetworkService *_SCNetworkServiceCreatePreconfigured(const __SCPreferences *a1, SCNetworkInterfaceRef interface)
{
  const __CFString *BSDName;
  SCNetworkServiceRef v5;
  const __SCNetworkService *v6;
  CFStringRef v7;
  CFStringRef v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  int v22;
  const char *v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  int v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  int v59;
  const char *v60;
  _QWORD v62[2];

  v62[1] = *MEMORY[0x1E0C80C00];
  BSDName = SCNetworkInterfaceGetBSDName(interface);
  v5 = SCNetworkServiceCreate(a1, interface);
  if (!v5)
  {
    v24 = _SC_LOG_DEFAULT();
    v25 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v24, (os_log_type_t)v25))
    {
      v26 = _os_log_pack_size();
      v34 = (char *)v62 - ((MEMORY[0x1E0C80A78](v26, v27, v28, v29, v30, v31, v32, v33) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v35 = _os_log_pack_fill();
      v36 = SCError();
      v37 = SCErrorString(v36);
      *(_DWORD *)v35 = 138412546;
      *(_QWORD *)(v35 + 4) = BSDName;
      *(_WORD *)(v35 + 12) = 2080;
      *(_QWORD *)(v35 + 14) = v37;
      __SC_log_send(3, (uint64_t)v24, v25, v34);
    }
    return 0;
  }
  v6 = v5;
  v7 = _SC_copyInterfaceUUID(BSDName);
  if (!v7)
  {
    v10 = _SC_LOG_DEFAULT();
    v11 = _SC_syslog_os_log_mapping(3);
    if (!__SC_log_enabled(3, v10, (os_log_type_t)v11))
      goto LABEL_11;
    v38 = _os_log_pack_size();
    v20 = (char *)v62 - ((MEMORY[0x1E0C80A78](v38, v39, v40, v41, v42, v43, v44, v45) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v46 = _os_log_pack_fill();
    *(_DWORD *)v46 = 138412290;
    *(_QWORD *)(v46 + 4) = BSDName;
    goto LABEL_10;
  }
  v8 = v7;
  v9 = _SCNetworkServiceSetServiceID((uint64_t)v6, v7);
  CFRelease(v8);
  if (!v9)
  {
    v10 = _SC_LOG_DEFAULT();
    v11 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v10, (os_log_type_t)v11))
    {
      v12 = _os_log_pack_size();
      v20 = (char *)v62 - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v21 = _os_log_pack_fill();
      v22 = SCError();
      v23 = SCErrorString(v22);
      *(_DWORD *)v21 = 136315138;
      *(_QWORD *)(v21 + 4) = v23;
LABEL_10:
      __SC_log_send(3, (uint64_t)v10, v11, v20);
    }
  }
LABEL_11:
  if (!SCNetworkServiceEstablishDefaultConfiguration(v6))
  {
    v47 = _SC_LOG_DEFAULT();
    v48 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v47, (os_log_type_t)v48))
    {
      v49 = _os_log_pack_size();
      v57 = (char *)v62 - ((MEMORY[0x1E0C80A78](v49, v50, v51, v52, v53, v54, v55, v56) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v58 = _os_log_pack_fill();
      v59 = SCError();
      v60 = SCErrorString(v59);
      *(_DWORD *)v58 = 138412546;
      *(_QWORD *)(v58 + 4) = BSDName;
      *(_WORD *)(v58 + 12) = 2080;
      *(_QWORD *)(v58 + 14) = v60;
      __SC_log_send(3, (uint64_t)v47, v48, v57);
    }
    SCNetworkServiceRemove(v6);
    CFRelease(v6);
    return 0;
  }
  return v6;
}

uint64_t _SCNetworkServiceSetServiceID(uint64_t cf, const void *a2)
{
  uint64_t v4;
  CFTypeID TypeID;
  uint64_t v6;
  const __CFString *NetworkServiceEntity;
  CFDictionaryRef Value;
  CFTypeID v9;
  const __CFArray *v10;
  const __CFString *v11;
  const __CFDictionary *v12;
  CFTypeID v13;
  uint64_t v14;
  CFTypeRef Copy;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  _QWORD v41[2];
  uint64_t context;
  const void *v43;
  _QWORD block[8];
  CFRange v45;

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkServiceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (cf)
      goto LABEL_3;
LABEL_26:
    _SCErrorSet(1002);
    return 0;
  }
  if (!cf)
    goto LABEL_26;
LABEL_3:
  v4 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID((CFTypeRef)cf) != v4)
    goto LABEL_26;
  if (!*(_QWORD *)(cf + 32))
    goto LABEL_26;
  TypeID = CFStringGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
    goto LABEL_26;
  if (CFEqual(a2, *(CFTypeRef *)(cf + 16)))
    return 1;
  context = 0;
  v43 = 0;
  if (!__SCNetworkServiceExists(cf))
  {
    v28 = _SC_LOG_DEFAULT();
    v29 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v28, (os_log_type_t)v29))
    {
      v30 = _os_log_pack_size();
      v38 = (char *)v41 - ((MEMORY[0x1E0C80A78](v30, v31, v32, v33, v34, v35, v36, v37) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v39 = _os_log_pack_fill();
      *(_DWORD *)v39 = 138412546;
      *(_QWORD *)(v39 + 4) = cf;
      *(_WORD *)(v39 + 12) = 2112;
      *(_QWORD *)(v39 + 14) = a2;
      __SC_log_send(3, (uint64_t)v28, v29, v38);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_3;
    block[3] = &__block_descriptor_tmp_40;
    block[5] = 0;
    block[6] = 0;
    block[4] = "_SCNetworkServiceSetServiceID() w/removed service";
    if (_SC_crash_once_once_3 != -1)
      dispatch_once(&_SC_crash_once_once_3, block);
    goto LABEL_26;
  }
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, (uint64_t)a2, 0);
  Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(cf + 32), NetworkServiceEntity);
  v9 = CFDictionaryGetTypeID();
  if (!Value || CFGetTypeID(Value) != v9)
  {
    v11 = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *(_QWORD *)(cf + 16), 0);
    v12 = SCPreferencesPathGetValue(*(SCPreferencesRef *)(cf + 32), v11);
    v13 = CFDictionaryGetTypeID();
    if (v12 && CFGetTypeID(v12) == v13)
    {
      if (SCPreferencesPathSetValue(*(SCPreferencesRef *)(cf + 32), NetworkServiceEntity, v12))
      {
        v6 = SCPreferencesPathRemoveValue(*(SCPreferencesRef *)(cf + 32), v11);
        if ((_DWORD)v6)
        {
          v10 = SCNetworkSetCopyAll(*(SCPreferencesRef *)(cf + 32));
          context = *(_QWORD *)(cf + 16);
          v43 = a2;
          v45.length = CFArrayGetCount(v10);
          v45.location = 0;
          CFArrayApplyFunction(v10, v45, (CFArrayApplierFunction)replaceServiceID, &context);
          v14 = *(_QWORD *)(cf + 24);
          if (v14)
          {
            Copy = __SCNetworkInterfaceCreateCopy(0, v14, *(const void **)(cf + 32), a2);
            CFRelease(*(CFTypeRef *)(cf + 24));
            *(_QWORD *)(cf + 24) = Copy;
          }
          v16 = _SC_LOG_DEFAULT();
          v17 = _SC_syslog_os_log_mapping(7);
          if (__SC_log_enabled(7, v16, (os_log_type_t)v17))
          {
            v18 = _os_log_pack_size();
            v41[1] = v41;
            v26 = (char *)v41
                - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v27 = _os_log_pack_fill();
            *(_DWORD *)v27 = 138412546;
            *(_QWORD *)(v27 + 4) = cf;
            *(_WORD *)(v27 + 12) = 2112;
            *(_QWORD *)(v27 + 14) = a2;
            __SC_log_send(7, (uint64_t)v16, v17, v26);
          }
          CFRetain(a2);
          CFRelease(*(CFTypeRef *)(cf + 16));
          *(_QWORD *)(cf + 16) = a2;
          goto LABEL_31;
        }
LABEL_30:
        v10 = 0;
LABEL_31:
        if (v11)
          CFRelease(v11);
        goto LABEL_33;
      }
    }
    else
    {
      _SCErrorSet(1004);
    }
    v6 = 0;
    goto LABEL_30;
  }
  _SCErrorSet(1005);
  v10 = 0;
  v6 = 0;
LABEL_33:
  if (NetworkServiceEntity)
    CFRelease(NetworkServiceEntity);
  if (v10)
    CFRelease(v10);
  return v6;
}

Boolean SCNetworkServiceEstablishDefaultConfiguration(SCNetworkServiceRef service)
{
  uint64_t v2;
  const __SCNetworkInterface *Interface;
  const __CFArray *SupportedProtocolTypes;
  const __CFArray *v5;
  CFIndex Count;
  __int128 v7;
  CFIndex v8;
  CFIndex v9;
  const __CFString *ValueAtIndex;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  const void *TemplateOverrides;
  CFTypeID TypeID;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v38;
  const __SCNetworkInterface *v39;
  __int128 v40;
  unsigned int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkServiceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (service)
      goto LABEL_3;
LABEL_23:
    _SCErrorSet(1002);
    LOBYTE(Interface) = 0;
    return Interface;
  }
  if (!service)
    goto LABEL_23;
LABEL_3:
  v2 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) != v2 || !*((_QWORD *)service + 4))
    goto LABEL_23;
  Interface = SCNetworkServiceGetInterface(service);
  if (Interface)
  {
    v39 = Interface;
    SupportedProtocolTypes = SCNetworkInterfaceGetSupportedProtocolTypes(Interface);
    if (SupportedProtocolTypes)
    {
      v5 = SupportedProtocolTypes;
      Count = CFArrayGetCount(SupportedProtocolTypes);
      if (Count >= 1)
      {
        v8 = Count;
        v9 = 0;
        *(_QWORD *)&v7 = 138412290;
        v40 = v7;
        do
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, v9);
          if (!SCNetworkServiceAddProtocolType(service, ValueAtIndex))
          {
            v11 = _SC_LOG_DEFAULT();
            v12 = _SC_syslog_os_log_mapping(6);
            if (__SC_log_enabled(6, v11, (os_log_type_t)v12))
            {
              v13 = _os_log_pack_size();
              v21 = (char *)&v38
                  - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              v22 = _os_log_pack_fill();
              *(_DWORD *)v22 = v40;
              *(_QWORD *)(v22 + 4) = ValueAtIndex;
              __SC_log_send(6, (uint64_t)v11, v12, v21);
            }
          }
          ++v9;
        }
        while (v8 != v9);
      }
    }
    TemplateOverrides = __SCNetworkInterfaceGetTemplateOverrides((uint64_t)v39, CFSTR("PrimaryRank"));
    TypeID = CFStringGetTypeID();
    if (!TemplateOverrides || CFGetTypeID(TemplateOverrides) != TypeID)
      goto LABEL_21;
    v41 = 0;
    if (__str_to_rank(TemplateOverrides, (int *)&v41))
    {
      if (SCNetworkServiceSetPrimaryRank((uint64_t)service, v41))
        goto LABEL_21;
      v25 = _SC_LOG_DEFAULT();
      v26 = _SC_syslog_os_log_mapping(6);
      if (!__SC_log_enabled(6, v25, (os_log_type_t)v26))
        goto LABEL_21;
    }
    else
    {
      v25 = _SC_LOG_DEFAULT();
      v26 = _SC_syslog_os_log_mapping(6);
      if (!__SC_log_enabled(6, v25, (os_log_type_t)v26))
      {
LABEL_21:
        LOBYTE(Interface) = 1;
        return Interface;
      }
    }
    v27 = _os_log_pack_size();
    v35 = (char *)&v38 - ((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v36 = _os_log_pack_fill();
    *(_DWORD *)v36 = 138412290;
    *(_QWORD *)(v36 + 4) = TemplateOverrides;
    __SC_log_send(6, (uint64_t)v25, v26, v35);
    goto LABEL_21;
  }
  return Interface;
}

Boolean SCNetworkServiceRemove(SCNetworkServiceRef service)
{
  uint64_t v2;
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const __SCNetworkSet *ValueAtIndex;
  const __CFString *NetworkServiceEntity;
  int v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkServiceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (service)
      goto LABEL_3;
LABEL_20:
    _SCErrorSet(1002);
LABEL_21:
    LOBYTE(v10) = 0;
    return v10;
  }
  if (!service)
    goto LABEL_20;
LABEL_3:
  v2 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) != v2 || !*((_QWORD *)service + 4))
    goto LABEL_20;
  if (!__SCNetworkServiceExists((uint64_t)service))
  {
    v23 = _SC_LOG_DEFAULT();
    v24 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v23, (os_log_type_t)v24))
    {
      v25 = _os_log_pack_size();
      v33 = (char *)block - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v34 = _os_log_pack_fill();
      *(_DWORD *)v34 = 138412290;
      *(_QWORD *)(v34 + 4) = service;
      __SC_log_send(3, (uint64_t)v23, v24, v33);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_3;
    block[3] = &__block_descriptor_tmp_40;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkServiceRemove() w/removed service";
    if (_SC_crash_once_once_3 != -1)
      dispatch_once(&_SC_crash_once_once_3, block);
    goto LABEL_20;
  }
  _SCNetworkInterfaceCacheOpen();
  v3 = SCNetworkSetCopyAll(*((SCPreferencesRef *)service + 4));
  if (v3)
  {
    v4 = v3;
    Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      v6 = Count;
      v7 = 0;
      while (1)
      {
        ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v4, v7);
        if (!SCNetworkSetRemoveService(ValueAtIndex, service) && SCError() != 1004)
          break;
        if (v6 == ++v7)
          goto LABEL_12;
      }
      CFRelease(v4);
      goto LABEL_21;
    }
LABEL_12:
    CFRelease(v4);
  }
  _SCNetworkInterfaceCacheClose();
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)service + 2), 0);
  v10 = SCPreferencesPathRemoveValue(*((SCPreferencesRef *)service + 4), NetworkServiceEntity);
  CFRelease(NetworkServiceEntity);
  if (v10)
  {
    v11 = _SC_LOG_DEFAULT();
    v12 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v11, (os_log_type_t)v12))
    {
      v13 = _os_log_pack_size();
      v21 = (char *)block - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v22 = _os_log_pack_fill();
      *(_DWORD *)v22 = 138412290;
      *(_QWORD *)(v22 + 4) = service;
      __SC_log_send(7, (uint64_t)v11, v12, v21);
    }
  }
  return v10;
}

uint64_t SCNetworkServiceSetPrimaryRank(uint64_t cf, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  const __CFString *NetworkServiceEntity;
  CFDictionaryRef Value;
  const __CFDictionary *v8;
  CFTypeID TypeID;
  __CFDictionary *Mutable;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  CFPropertyListRef v23;
  const void *v24;
  CFTypeID v25;
  const __CFDictionary *MutableCopy;
  CFIndex Count;
  const __SCPreferences *v28;
  uint64_t v29;
  CFIndex v30;
  const __SCDynamicStore *v31;
  unsigned int v32;
  uint64_t v34;
  __CFString *v35;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  v35 = 0;
  if (__SCNetworkServiceInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_45;
  }
  else
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (!cf)
      goto LABEL_45;
  }
  v4 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID((CFTypeRef)cf) != v4)
    goto LABEL_45;
  if (*(_QWORD *)(cf + 32) && !__SCNetworkServiceExists(cf))
  {
    v11 = _SC_LOG_DEFAULT();
    v12 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v11, (os_log_type_t)v12))
    {
      v13 = _os_log_pack_size();
      v21 = (char *)&v34 - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v22 = _os_log_pack_fill();
      *(_DWORD *)v22 = 138412290;
      *(_QWORD *)(v22 + 4) = cf;
      __SC_log_send(3, (uint64_t)v11, v12, v21);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_3;
    block[3] = &__block_descriptor_tmp_40;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkServiceSetPrimaryRank() w/removed service";
    if (_SC_crash_once_once_3 != -1)
      dispatch_once(&_SC_crash_once_once_3, block);
    goto LABEL_45;
  }
  v5 = __rank_to_str(a2, &v35);
  if (!(_DWORD)v5)
  {
    _SCErrorSet(1002);
    return v5;
  }
  if (*(_QWORD *)(cf + 32))
  {
    if (a2 <= 4 && ((1 << a2) & 0x19) != 0)
    {
      NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *(_QWORD *)(cf + 16), 0);
      Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(cf + 32), NetworkServiceEntity);
      if (!Value)
      {
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        goto LABEL_23;
      }
      v8 = Value;
      TypeID = CFDictionaryGetTypeID();
      if (CFGetTypeID(v8) == TypeID)
      {
        Mutable = CFDictionaryCreateMutableCopy(0, 0, v8);
LABEL_23:
        MutableCopy = Mutable;
        if (v35)
          CFDictionarySetValue(Mutable, CFSTR("PrimaryRank"), v35);
        else
          CFDictionaryRemoveValue(Mutable, CFSTR("PrimaryRank"));
        Count = CFDictionaryGetCount(MutableCopy);
        v28 = *(const __SCPreferences **)(cf + 32);
        if (Count < 1)
          v29 = SCPreferencesPathRemoveValue(v28, NetworkServiceEntity);
        else
          v29 = SCPreferencesPathSetValue(v28, NetworkServiceEntity, MutableCopy);
        goto LABEL_37;
      }
LABEL_33:
      _SCErrorSet(1001);
      goto LABEL_39;
    }
LABEL_45:
    _SCErrorSet(1002);
    return 0;
  }
  if (!*(_QWORD *)(cf + 40))
    goto LABEL_45;
  NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), *(CFStringRef *)(cf + 16), 0);
  v23 = SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(cf + 40), NetworkServiceEntity);
  if (v23)
  {
    v24 = v23;
    v25 = CFDictionaryGetTypeID();
    if (CFGetTypeID(v24) != v25)
    {
      CFRelease(v24);
      goto LABEL_33;
    }
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)v24);
    CFRelease(v24);
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  if (v35)
    CFDictionarySetValue(MutableCopy, CFSTR("PrimaryRank"), v35);
  else
    CFDictionaryRemoveValue(MutableCopy, CFSTR("PrimaryRank"));
  v30 = CFDictionaryGetCount(MutableCopy);
  v31 = *(const __SCDynamicStore **)(cf + 40);
  if (v30 < 1)
  {
    v32 = SCDynamicStoreRemoveValue(v31, NetworkServiceEntity);
    if (SCError() == 1004)
      v5 = 1;
    else
      v5 = v32;
    goto LABEL_38;
  }
  v29 = SCDynamicStoreSetValue(v31, NetworkServiceEntity, MutableCopy);
LABEL_37:
  v5 = v29;
LABEL_38:
  CFRelease(MutableCopy);
LABEL_39:
  if (NetworkServiceEntity)
    CFRelease(NetworkServiceEntity);
  return v5;
}

const __CFString *__SCNetworkServiceGetName(CFTypeRef cf, int a2)
{
  uint64_t v4;
  const __CFString *Value;
  const __CFString *NetworkServiceEntity;
  CFTypeID TypeID;
  CFTypeID v8;
  const __SCNetworkInterface *Interface;
  const __SCNetworkInterface *v10;
  CFStringRef InterfaceType;
  SCNetworkInterfaceRef v12;
  int v13;
  CFStringRef NonLocalizedDisplayName;
  const __CFString *v15;
  CFStringRef v16;
  CFStringRef v17;
  _BOOL4 v18;
  CFIndex Length;
  CFStringRef LocalizedDisplayName;
  CFRange v22;

  if (__SCNetworkServiceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (cf)
      goto LABEL_3;
LABEL_51:
    _SCErrorSet(1002);
    return 0;
  }
  if (!cf)
    goto LABEL_51;
LABEL_3:
  v4 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(cf) != v4 || !*((_QWORD *)cf + 4))
    goto LABEL_51;
  Value = (const __CFString *)*((_QWORD *)cf + 6);
  if (Value)
  {
    if (a2)
      return Value;
    goto LABEL_16;
  }
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)cf + 2), 0);
  Value = (const __CFString *)SCPreferencesPathGetValue(*((SCPreferencesRef *)cf + 4), NetworkServiceEntity);
  CFRelease(NetworkServiceEntity);
  TypeID = CFDictionaryGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) != TypeID)
    {
      Value = 0;
      goto LABEL_16;
    }
    Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("UserDefinedName"));
    v8 = CFStringGetTypeID();
    if (Value && CFGetTypeID(Value) == v8)
    {
      *((_QWORD *)cf + 6) = CFRetain(Value);
      if (_SCNetworkConfigurationBypassSystemInterfaces(*((_QWORD *)cf + 4)))
        return (const __CFString *)*((_QWORD *)cf + 6);
      goto LABEL_16;
    }
    if (a2)
      goto LABEL_16;
    return 0;
  }
LABEL_16:
  Interface = SCNetworkServiceGetInterface((SCNetworkServiceRef)cf);
  do
  {
    if (!Interface)
      return (const __CFString *)*((_QWORD *)cf + 6);
    v10 = Interface;
    InterfaceType = SCNetworkInterfaceGetInterfaceType(Interface);
    if (CFEqual(InterfaceType, CFSTR("VPN")))
      break;
    v12 = SCNetworkInterfaceGetInterface(Interface);
    if (!v12)
      break;
    Interface = v12;
  }
  while (!CFEqual(v12, &__kSCNetworkInterfaceIPv4));
  v13 = 0;
  while (1)
  {
    if (!*((_QWORD *)cf + 6))
    {
      v17 = 0;
      goto LABEL_40;
    }
    if (v13 == 2)
    {
      v16 = __SCNetworkInterfaceCopyOldNonLocalizedDisplayName(v10, (uint64_t)CFSTR("Y"));
      goto LABEL_30;
    }
    if (v13 != 1)
      break;
    v16 = __SCNetworkInterfaceCopyOldLocalizedDisplayName(v10, (uint64_t)CFSTR("Y"));
LABEL_30:
    v15 = v16;
    if (v16)
      goto LABEL_31;
LABEL_34:
    if (++v13 == 5)
    {
      v17 = 0;
      v18 = *((_QWORD *)cf + 6) == 0;
      goto LABEL_41;
    }
  }
  if (v13)
    goto LABEL_34;
  NonLocalizedDisplayName = __SCNetworkInterfaceGetNonLocalizedDisplayName((CFStringRef *)v10);
  if (!NonLocalizedDisplayName)
    goto LABEL_34;
  v15 = NonLocalizedDisplayName;
  CFRetain(NonLocalizedDisplayName);
LABEL_31:
  if (CFEqual(Value, v15))
  {
    v17 = 0;
    goto LABEL_39;
  }
  if (!CFStringHasPrefix(Value, v15))
  {
    CFRelease(v15);
    goto LABEL_34;
  }
  Length = CFStringGetLength(v15);
  v22.length = CFStringGetLength(Value) - Length;
  v22.location = Length;
  v17 = CFStringCreateWithSubstring(0, Value, v22);
LABEL_39:
  CFRelease(v15);
  CFRelease(*((CFTypeRef *)cf + 6));
  *((_QWORD *)cf + 6) = 0;
LABEL_40:
  v18 = 1;
LABEL_41:
  if (a2 && v18 && (LocalizedDisplayName = SCNetworkInterfaceGetLocalizedDisplayName(v10)) != 0)
  {
    if (v17)
    {
      *((_QWORD *)cf + 6) = CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), LocalizedDisplayName, v17);
      goto LABEL_47;
    }
    *((_QWORD *)cf + 6) = CFRetain(LocalizedDisplayName);
  }
  else if (v17)
  {
LABEL_47:
    CFRelease(v17);
  }
  return (const __CFString *)*((_QWORD *)cf + 6);
}

CFTypeID SCNetworkServiceGetTypeID(void)
{
  if (__SCNetworkServiceInitialize_initialized != -1)
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
  return __kSCNetworkServiceTypeID;
}

Boolean SCNetworkServiceRemoveProtocolType(SCNetworkServiceRef service, CFStringRef protocolType)
{
  uint64_t v4;
  const __CFString *NetworkServiceEntity;
  int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkServiceInitialize_initialized == -1)
  {
    if (!service)
      goto LABEL_15;
  }
  else
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (!service)
      goto LABEL_15;
  }
  v4 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) != v4 || !*((_QWORD *)service + 4))
    goto LABEL_15;
  if (!__SCNetworkServiceExists((uint64_t)service))
  {
    v19 = _SC_LOG_DEFAULT();
    v20 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v19, (os_log_type_t)v20))
    {
      v21 = _os_log_pack_size();
      v29 = (char *)block - ((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v30 = _os_log_pack_fill();
      *(_DWORD *)v30 = 138412546;
      *(_QWORD *)(v30 + 4) = service;
      *(_WORD *)(v30 + 12) = 2112;
      *(_QWORD *)(v30 + 14) = protocolType;
      __SC_log_send(3, (uint64_t)v19, v20, v29);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_3;
    block[3] = &__block_descriptor_tmp_40;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkServiceRemoveProtocolType() w/removed service";
    if (_SC_crash_once_once_3 != -1)
      dispatch_once(&_SC_crash_once_once_3, block);
    goto LABEL_15;
  }
  if (!__SCNetworkProtocolIsValidType(protocolType))
  {
LABEL_15:
    _SCErrorSet(1002);
    LOBYTE(v6) = 0;
    return v6;
  }
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)service + 2), (uint64_t)protocolType);
  if (SCPreferencesPathGetValue(*((SCPreferencesRef *)service + 4), NetworkServiceEntity))
  {
    v6 = SCPreferencesPathRemoveValue(*((SCPreferencesRef *)service + 4), NetworkServiceEntity);
    if (v6)
    {
      v7 = _SC_LOG_DEFAULT();
      v8 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v7, (os_log_type_t)v8))
      {
        v9 = _os_log_pack_size();
        v17 = (char *)block - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v18 = _os_log_pack_fill();
        *(_DWORD *)v18 = 138412546;
        *(_QWORD *)(v18 + 4) = service;
        *(_WORD *)(v18 + 12) = 2112;
        *(_QWORD *)(v18 + 14) = protocolType;
        __SC_log_send(7, (uint64_t)v7, v8, v17);
      }
    }
  }
  else
  {
    _SCErrorSet(1004);
    LOBYTE(v6) = 0;
  }
  CFRelease(NetworkServiceEntity);
  return v6;
}

Boolean SCNetworkServiceSetEnabled(SCNetworkServiceRef service, Boolean enabled)
{
  int v2;
  uint64_t v4;
  const __SCNetworkInterface *Interface;
  int v6;
  const __CFString *NetworkServiceEntity;
  int v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  const char *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  _QWORD block[8];

  v2 = enabled;
  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkServiceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (service)
      goto LABEL_3;
LABEL_19:
    v6 = 1002;
    goto LABEL_20;
  }
  if (!service)
    goto LABEL_19;
LABEL_3:
  v4 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(service) != v4 || !*((_QWORD *)service + 4))
    goto LABEL_19;
  if (!__SCNetworkServiceExists((uint64_t)service))
  {
    v22 = _SC_LOG_DEFAULT();
    v23 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v22, (os_log_type_t)v23))
    {
      v24 = _os_log_pack_size();
      v32 = (char *)block - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v33 = _os_log_pack_fill();
      *(_DWORD *)v33 = 138412290;
      *(_QWORD *)(v33 + 4) = service;
      __SC_log_send(3, (uint64_t)v22, v23, v32);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_3;
    block[3] = &__block_descriptor_tmp_40;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkProtocolSetEnabled() w/removed service";
    if (_SC_crash_once_once_3 != -1)
      dispatch_once(&_SC_crash_once_once_3, block);
    goto LABEL_19;
  }
  if (v2)
  {
    Interface = SCNetworkServiceGetInterface(service);
    if (Interface)
    {
      if (__SCNetworkInterfaceIsBusyMember(*((const __SCPreferences **)service + 4), Interface, 1))
      {
        v6 = 1001;
LABEL_20:
        _SCErrorSet(v6);
        LOBYTE(v8) = 0;
        return v8;
      }
    }
  }
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)service + 2), 0);
  v8 = __setPrefsEnabled(*((const __SCPreferences **)service + 4), NetworkServiceEntity, v2);
  CFRelease(NetworkServiceEntity);
  if (v8)
  {
    v9 = _SC_LOG_DEFAULT();
    v10 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v9, (os_log_type_t)v10))
    {
      v11 = _os_log_pack_size();
      v19 = (char *)block - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v20 = _os_log_pack_fill();
      v21 = "Enabled";
      if (!v2)
        v21 = "Disabled";
      *(_DWORD *)v20 = 138412546;
      *(_QWORD *)(v20 + 4) = service;
      *(_WORD *)(v20 + 12) = 2080;
      *(_QWORD *)(v20 + 14) = v21;
      __SC_log_send(7, (uint64_t)v9, v10, v19);
    }
  }
  return v8;
}

uint64_t SCNetworkServiceGetPrimaryRank(CFTypeRef cf)
{
  uint64_t v2;
  const __CFString *NetworkServiceEntity;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  const void *v6;
  const __CFString *v7;
  const __CFDictionary *v8;
  CFTypeID v9;
  const void *v10;
  int v11;
  int v12;
  unsigned int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  if (__SCNetworkServiceInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_18;
  }
  else
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (!cf)
      goto LABEL_18;
  }
  v2 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_18;
  if (*((_QWORD *)cf + 4))
  {
    NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)cf + 2), 0);
    Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)cf + 4), NetworkServiceEntity);
    CFRelease(NetworkServiceEntity);
    TypeID = CFDictionaryGetTypeID();
    if (!Value || CFGetTypeID(Value) != TypeID)
      goto LABEL_14;
    v6 = CFDictionaryGetValue(Value, CFSTR("PrimaryRank"));
    if (__str_to_rank(v6, (int *)&v14))
      goto LABEL_8;
    goto LABEL_17;
  }
  if (!*((_QWORD *)cf + 5))
  {
LABEL_18:
    v12 = 1002;
    goto LABEL_19;
  }
  v7 = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), *((CFStringRef *)cf + 2), 0);
  v8 = (const __CFDictionary *)SCDynamicStoreCopyValue(*((SCDynamicStoreRef *)cf + 5), v7);
  CFRelease(v7);
  if (!v8)
  {
LABEL_14:
    v12 = 0;
LABEL_19:
    _SCErrorSet(v12);
    return v14;
  }
  v9 = CFDictionaryGetTypeID();
  if (CFGetTypeID(v8) == v9)
  {
    v10 = CFDictionaryGetValue(v8, CFSTR("PrimaryRank"));
    v11 = __str_to_rank(v10, (int *)&v14);
  }
  else
  {
    v11 = 1;
  }
  CFRelease(v8);
  if (!v11)
  {
LABEL_17:
    v14 = 0;
    goto LABEL_18;
  }
LABEL_8:
  if (!v14)
    goto LABEL_14;
  return v14;
}

const __SCNetworkInterface *_SCNetworkServiceIsVPN(const __SCNetworkService *a1)
{
  const __SCNetworkInterface *result;
  const __SCNetworkInterface *v2;
  CFStringRef InterfaceType;
  CFTypeRef *v4;

  result = SCNetworkServiceGetInterface(a1);
  if (result)
  {
    v2 = result;
    InterfaceType = SCNetworkInterfaceGetInterfaceType(result);
    if (CFEqual(InterfaceType, CFSTR("PPP")))
    {
      result = SCNetworkInterfaceGetInterface(v2);
      if (!result)
        return result;
      InterfaceType = SCNetworkInterfaceGetInterfaceType(result);
      if (CFEqual(InterfaceType, CFSTR("L2TP")))
        return (const __SCNetworkInterface *)1;
      v4 = (CFTypeRef *)&kSCNetworkInterfaceTypePPTP;
    }
    else
    {
      if (CFEqual(InterfaceType, CFSTR("VPN")))
        return (const __SCNetworkInterface *)1;
      v4 = (CFTypeRef *)&kSCNetworkInterfaceTypeIPSec;
    }
    return (const __SCNetworkInterface *)(CFEqual(InterfaceType, *v4) != 0);
  }
  return result;
}

uint64_t SCNetworkServiceSetExternalID(uint64_t cf, const void *a2, const void *a3)
{
  uint64_t v6;
  CFTypeID TypeID;
  CFTypeID v8;
  CFStringRef v9;
  const __CFString *NetworkServiceEntity;
  const __CFDictionary *Value;
  CFTypeID v12;
  __CFDictionary *MutableCopy;
  const __CFDictionary *Mutable;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  __CFDictionary *v29;
  __CFDictionary *v30;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkServiceInitialize_initialized == -1)
  {
    if (!cf)
      goto LABEL_18;
  }
  else
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (!cf)
      goto LABEL_18;
  }
  v6 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID((CFTypeRef)cf) != v6)
    goto LABEL_18;
  if (!*(_QWORD *)(cf + 32))
    goto LABEL_18;
  TypeID = CFStringGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
    goto LABEL_18;
  if (!__SCNetworkServiceExists(cf))
  {
    v15 = _SC_LOG_DEFAULT();
    v16 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v15, (os_log_type_t)v16))
    {
      v17 = _os_log_pack_size();
      v25 = (char *)block - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v26 = _os_log_pack_fill();
      *(_DWORD *)v26 = 138412546;
      *(_QWORD *)(v26 + 4) = cf;
      *(_WORD *)(v26 + 12) = 2112;
      *(_QWORD *)(v26 + 14) = a3;
      __SC_log_send(3, (uint64_t)v15, v16, v25);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_3;
    block[3] = &__block_descriptor_tmp_40;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkServiceSetExternalID() w/removed service";
    if (_SC_crash_once_once_3 != -1)
      dispatch_once(&_SC_crash_once_once_3, block);
    goto LABEL_18;
  }
  if (a3)
  {
    v8 = CFStringGetTypeID();
    if (CFGetTypeID(a3) != v8)
    {
LABEL_18:
      _SCErrorSet(1002);
      return 0;
    }
  }
  v9 = CFStringCreateWithFormat(0, 0, CFSTR("%s%@"), "_", a2);
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *(_QWORD *)(cf + 16), 0);
  Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(cf + 32), NetworkServiceEntity);
  v12 = CFDictionaryGetTypeID();
  if (!Value)
  {
    if (!a3)
    {
      CFRelease(NetworkServiceEntity);
      v27 = 0;
LABEL_30:
      v30 = *(__CFDictionary **)(cf + 56);
      if (v30)
        CFDictionaryRemoveValue(v30, v9);
      goto LABEL_32;
    }
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_22;
  }
  if (CFGetTypeID(Value) == v12)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
    Mutable = MutableCopy;
    if (!a3)
    {
      CFDictionaryRemoveValue(MutableCopy, v9);
LABEL_23:
      v27 = SCPreferencesPathSetValue(*(SCPreferencesRef *)(cf + 32), NetworkServiceEntity, Mutable);
      CFRelease(Mutable);
      goto LABEL_25;
    }
LABEL_22:
    CFDictionarySetValue(Mutable, v9, a3);
    goto LABEL_23;
  }
  v27 = 0;
LABEL_25:
  CFRelease(NetworkServiceEntity);
  if (!a3)
    goto LABEL_30;
  v29 = *(__CFDictionary **)(cf + 56);
  if (!v29)
  {
    v29 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)(cf + 56) = v29;
  }
  CFDictionarySetValue(v29, v9, a3);
LABEL_32:
  CFRelease(v9);
  if (!(_DWORD)v27)
    _SCErrorSet(1001);
  return v27;
}

const __CFDictionary *SCNetworkServiceCopyExternalID(CFTypeRef cf, const void *a2)
{
  uint64_t v4;
  CFTypeID TypeID;
  CFStringRef v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFDictionary *Value;
  const __CFString *NetworkServiceEntity;
  CFTypeID v11;
  const __CFDictionary *v12;
  __CFDictionary *Mutable;

  if (__SCNetworkServiceInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (cf)
      goto LABEL_3;
LABEL_20:
    _SCErrorSet(1002);
    return 0;
  }
  if (!cf)
    goto LABEL_20;
LABEL_3:
  v4 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID(cf) != v4)
    goto LABEL_20;
  if (!*((_QWORD *)cf + 4))
    goto LABEL_20;
  TypeID = CFStringGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
    goto LABEL_20;
  v6 = CFStringCreateWithFormat(0, 0, CFSTR("%s%@"), "_", a2);
  v7 = (const __CFDictionary *)*((_QWORD *)cf + 7);
  if (v7 && (v8 = (const __CFDictionary *)CFDictionaryGetValue(v7, v6)) != 0)
  {
    Value = v8;
    CFRetain(v8);
    CFRelease(v6);
  }
  else
  {
    NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)cf + 2), 0);
    Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)cf + 4), NetworkServiceEntity);
    v11 = CFDictionaryGetTypeID();
    if (Value)
    {
      if (CFGetTypeID(Value) == v11)
      {
        v12 = (const __CFDictionary *)CFDictionaryGetValue(Value, v6);
        Value = v12;
        if (v12)
        {
          CFRetain(v12);
          Mutable = (__CFDictionary *)*((_QWORD *)cf + 7);
          if (!Mutable)
          {
            Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            *((_QWORD *)cf + 7) = Mutable;
          }
          CFDictionarySetValue(Mutable, v6, Value);
        }
      }
      else
      {
        Value = 0;
      }
    }
    CFRelease(NetworkServiceEntity);
    CFRelease(v6);
    if (!Value)
      _SCErrorSet(1004);
  }
  return Value;
}

void replaceServiceID(uint64_t a1, CFTypeRef *a2)
{
  const __CFArray *ServiceOrder;
  CFTypeID TypeID;
  const __CFArray *MutableCopy;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFString *SetNetworkServiceEntity;
  const __CFString *NetworkServiceEntity;
  CFRange v13;

  ServiceOrder = SCNetworkSetGetServiceOrder((SCNetworkSetRef)a1);
  TypeID = CFArrayGetTypeID();
  if (ServiceOrder)
  {
    if (CFGetTypeID(ServiceOrder) == TypeID)
    {
      v13.length = CFArrayGetCount(ServiceOrder);
      v13.location = 0;
      if (CFArrayContainsValue(ServiceOrder, v13, *a2))
      {
        MutableCopy = CFArrayCreateMutableCopy(0, 0, ServiceOrder);
        Count = CFArrayGetCount(MutableCopy);
        if (Count >= 1)
        {
          v8 = Count;
          for (i = 0; i != v8; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, i);
            if (CFEqual(ValueAtIndex, *a2))
              CFArraySetValueAtIndex(MutableCopy, i, a2[1]);
          }
        }
        SCNetworkSetSetServiceOrder((SCNetworkSetRef)a1, MutableCopy);
        CFRelease(MutableCopy);
      }
    }
  }
  SetNetworkServiceEntity = SCPreferencesPathKeyCreateSetNetworkServiceEntity(0, *(_QWORD *)(a1 + 16), (uint64_t)*a2, 0);
  if (SCPreferencesPathGetLink(*(SCPreferencesRef *)(a1 + 24), SetNetworkServiceEntity))
  {
    SCPreferencesPathRemoveValue(*(SCPreferencesRef *)(a1 + 24), SetNetworkServiceEntity);
    CFRelease(SetNetworkServiceEntity);
    SetNetworkServiceEntity = SCPreferencesPathKeyCreateSetNetworkServiceEntity(0, *(_QWORD *)(a1 + 16), (uint64_t)a2[1], 0);
    NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, (uint64_t)a2[1], 0);
    SCPreferencesPathSetLink(*(SCPreferencesRef *)(a1 + 24), SetNetworkServiceEntity, NetworkServiceEntity);
    if (!SetNetworkServiceEntity)
      goto LABEL_13;
    goto LABEL_12;
  }
  NetworkServiceEntity = 0;
  if (SetNetworkServiceEntity)
LABEL_12:
    CFRelease(SetNetworkServiceEntity);
LABEL_13:
  if (NetworkServiceEntity)
    CFRelease(NetworkServiceEntity);
}

void __SCNetworkServiceAddProtocolToService(const __SCNetworkService *a1, const __CFString *a2, const __CFDictionary *a3, Boolean a4)
{
  const __SCNetworkProtocol *v8;

  v8 = SCNetworkServiceCopyProtocol(a1, a2);
  if (v8
    || SCError() == 1004
    && SCNetworkServiceAddProtocolType(a1, a2)
    && (v8 = SCNetworkServiceCopyProtocol(a1, a2)) != 0)
  {
    SCNetworkProtocolSetConfiguration(v8, a3);
    SCNetworkProtocolSetEnabled(v8, a4);
    CFRelease(v8);
  }
}

uint64_t __SCNetworkServiceMigrateNew(const __SCPreferences *a1, uint64_t cf, const __CFDictionary *a3, const __CFDictionary *a4, const __CFDictionary *a5)
{
  uint64_t v8;
  uint64_t v10;
  const void *v11;
  CFTypeID TypeID;
  const __CFString *v13;
  SCNetworkServiceRef v14;
  SCNetworkServiceRef v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  const __SCNetworkInterface *Interface;
  __CFDictionary *v28;
  const __CFDictionary *v29;
  const __CFString *v30;
  const __CFString *v31;
  const __CFDictionary *v32;
  const __CFDictionary *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  char *v46;
  __CFDictionary *MutableCopy;
  const __CFString *v48;
  const __CFString *v49;
  CFMutableStringRef v50;
  NSObject *v51;
  uint64_t v52;
  const __SCNetworkInterface *v53;
  SCNetworkServiceRef v54;
  Boolean Enabled;
  __int128 v56;
  CFIndex v57;
  const void *ValueAtIndex;
  const __SCNetworkSet *v59;
  const __SCNetworkSet *v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  CFStringRef SetID;
  NSObject *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  const __CFString *Name;
  NSObject *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  const __CFArray *v97;
  const __CFArray *v98;
  CFIndex v99;
  const __SCNetworkProtocol *v100;
  const __CFDictionary *Configuration;
  const __CFString *ProtocolType;
  Boolean v103;
  NSObject *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  char *v123;
  NSObject *v125;
  uint64_t v126;
  NSObject *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  char *v146;
  __int128 v147;
  __int128 *v148;
  const __SCNetworkInterface *v149;
  const __CFDictionary *v150;
  void *value[2];
  CFRange v152;

  v8 = cf;
  value[1] = *(void **)MEMORY[0x1E0C80C00];
  value[0] = 0;
  if (__SCNetworkServiceInitialize_initialized == -1)
  {
    if (!cf)
      return v8;
  }
  else
  {
    dispatch_once(&__SCNetworkServiceInitialize_initialized, &__block_literal_global_13);
    if (!v8)
      return v8;
  }
  v10 = __kSCNetworkServiceTypeID;
  if (CFGetTypeID((CFTypeRef)v8) != v10)
    return 0;
  v11 = *(const void **)(v8 + 24);
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!v11 || CFGetTypeID(v11) != TypeID || !*(_QWORD *)(v8 + 32))
    return 0;
  v13 = *(const __CFString **)(v8 + 16);
  v14 = SCNetworkServiceCopy(a1, v13);
  if (v14)
  {
    v15 = v14;
    v16 = _SC_LOG_DEFAULT();
    v17 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v16, (os_log_type_t)v17))
    {
      v18 = _os_log_pack_size();
      v26 = (char *)&v147 - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v16, v17, v26);
    }
    v8 = 0;
LABEL_11:
    CFRelease(v15);
    return v8;
  }
  Interface = SCNetworkServiceGetInterface((SCNetworkServiceRef)v8);
  if (!Interface)
  {
    v51 = _SC_LOG_DEFAULT();
    v52 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v51, (os_log_type_t)v52))
      goto LABEL_63;
    return 0;
  }
  v28 = __SCNetworkInterfaceCopyInterfaceEntity(Interface);
  if (!v28)
  {
    v51 = _SC_LOG_DEFAULT();
    v52 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v51, (os_log_type_t)v52))
    {
LABEL_63:
      v115 = _os_log_pack_size();
      v123 = (char *)&v147
           - ((MEMORY[0x1E0C80A78](v115, v116, v117, v118, v119, v120, v121, v122) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v51, v52, v123);
    }
    return 0;
  }
  v29 = v28;
  if (a3
    && (v30 = (const __CFString *)CFDictionaryGetValue(v28, CFSTR("DeviceName"))) != 0
    && (v31 = v30, (v32 = (const __CFDictionary *)CFDictionaryGetValue(a3, v30)) != 0))
  {
    v33 = v32;
    v34 = _SC_LOG_DEFAULT();
    LODWORD(v149) = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v34, (os_log_type_t)v149))
    {
      v35 = _os_log_pack_size();
      *(_QWORD *)&v147 = v34;
      v148 = &v147;
      v43 = MEMORY[0x1E0C80A78](v35, v36, v37, v38, v39, v40, v41, v42);
      v150 = v33;
      v44 = (char *)&v147 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v45 = _os_log_pack_fill();
      *(_DWORD *)v45 = 138412546;
      *(_QWORD *)(v45 + 4) = v31;
      *(_WORD *)(v45 + 12) = 2112;
      *(_QWORD *)(v45 + 14) = v150;
      v46 = v44;
      v33 = v150;
      __SC_log_send(6, v147, v149, v46);
    }
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v29);
    CFDictionarySetValue(MutableCopy, CFSTR("DeviceName"), v33);
    v150 = MutableCopy;
    v48 = (const __CFString *)CFDictionaryGetValue(MutableCopy, CFSTR("UserDefinedName"));
    if (v48)
    {
      v49 = (const __CFString *)v33;
      v50 = CFStringCreateMutableCopy(0, 0, v48);
      v152.length = CFStringGetLength(v50);
      v152.location = 0;
      CFStringFindAndReplace(v50, v31, v49, v152, 0);
      CFDictionarySetValue(v150, CFSTR("UserDefinedName"), v50);
      CFRelease(v50);
    }
    CFRelease(v29);
  }
  else
  {
    v150 = v29;
  }
  v53 = _SCNetworkInterfaceCreateWithEntity(0, v150, (uint64_t)&__SCNetworkInterfaceSearchExternal);
  if (!a4 || !a5 || !CFDictionaryGetValueIfPresent(a5, (const void *)v8, (const void **)value))
  {
    v104 = _SC_LOG_DEFAULT();
    v105 = _SC_syslog_os_log_mapping(6);
    if (!__SC_log_enabled(6, v104, (os_log_type_t)v105))
    {
LABEL_55:
      v8 = 0;
      v15 = 0;
      goto LABEL_56;
    }
LABEL_54:
    v106 = _os_log_pack_size();
    v114 = (char *)&v147
         - ((MEMORY[0x1E0C80A78](v106, v107, v108, v109, v110, v111, v112, v113) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(6, (uint64_t)v104, v105, v114);
    goto LABEL_55;
  }
  v54 = SCNetworkServiceCreate(a1, v53);
  if (!v54)
  {
    v104 = _SC_LOG_DEFAULT();
    v105 = _SC_syslog_os_log_mapping(6);
    if (!__SC_log_enabled(6, v104, (os_log_type_t)v105))
      goto LABEL_55;
    goto LABEL_54;
  }
  v15 = v54;
  Enabled = SCNetworkServiceGetEnabled((SCNetworkServiceRef)v8);
  if (!SCNetworkServiceSetEnabled(v15, Enabled))
  {
    SCNetworkServiceRemove(v15);
    v125 = _SC_LOG_DEFAULT();
    v126 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v125, (os_log_type_t)v126))
      goto LABEL_75;
    goto LABEL_76;
  }
  if (!SCNetworkServiceEstablishDefaultConfiguration(v15))
  {
    SCNetworkServiceRemove(v15);
    v125 = _SC_LOG_DEFAULT();
    v126 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v125, (os_log_type_t)v126))
    {
LABEL_75:
      v138 = _os_log_pack_size();
      v146 = (char *)&v147
           - ((MEMORY[0x1E0C80A78](v138, v139, v140, v141, v142, v143, v144, v145) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v125, v126, v146);
    }
LABEL_76:
    v8 = 0;
    goto LABEL_56;
  }
  _SCNetworkServiceSetServiceID((uint64_t)v15, v13);
  if (CFArrayGetCount((CFArrayRef)value[0]) < 1)
    goto LABEL_72;
  LODWORD(v148) = 0;
  v57 = 0;
  *(_QWORD *)&v56 = 138412290;
  v147 = v56;
  v149 = v53;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)value[0], v57);
    v59 = (const __SCNetworkSet *)CFDictionaryGetValue(a4, ValueAtIndex);
    if (v59)
    {
      v60 = v59;
      v61 = _SC_LOG_DEFAULT();
      v62 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v61, (os_log_type_t)v62))
      {
        v63 = _os_log_pack_size();
        v71 = (char *)&v147
            - ((MEMORY[0x1E0C80A78](v63, v64, v65, v66, v67, v68, v69, v70) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v72 = _os_log_pack_fill();
        SetID = SCNetworkSetGetSetID(v60);
        *(_DWORD *)v72 = v147;
        *(_QWORD *)(v72 + 4) = SetID;
        __SC_log_send(6, (uint64_t)v61, v62, v71);
      }
      if (SCNetworkSetAddService(v60, v15))
      {
        LODWORD(v148) = 1;
      }
      else
      {
        v74 = _SC_LOG_DEFAULT();
        v75 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v74, (os_log_type_t)v75))
        {
          v76 = _os_log_pack_size();
          v84 = (char *)&v147
              - ((MEMORY[0x1E0C80A78](v76, v77, v78, v79, v80, v81, v82, v83) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(6, (uint64_t)v74, v75, v84);
        }
      }
      v53 = v149;
    }
    ++v57;
  }
  while (v57 < CFArrayGetCount((CFArrayRef)value[0]));
  if (!(_DWORD)v148)
  {
LABEL_72:
    SCNetworkServiceRemove(v15);
    v127 = _SC_LOG_DEFAULT();
    v128 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v127, (os_log_type_t)v128))
    {
      v129 = _os_log_pack_size();
      v137 = (char *)&v147
           - ((MEMORY[0x1E0C80A78](v129, v130, v131, v132, v133, v134, v135, v136) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v127, v128, v137);
    }
    goto LABEL_76;
  }
  Name = __SCNetworkServiceGetName((CFTypeRef)v8, 0);
  if (Name)
  {
    if (!SCNetworkServiceSetName(v15, Name))
    {
      v86 = _SC_LOG_DEFAULT();
      v87 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v86, (os_log_type_t)v87))
      {
        v88 = _os_log_pack_size();
        v96 = (char *)&v147
            - ((MEMORY[0x1E0C80A78](v88, v89, v90, v91, v92, v93, v94, v95) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(6, (uint64_t)v86, v87, v96);
      }
    }
  }
  v97 = SCNetworkServiceCopyProtocols((SCNetworkServiceRef)v8);
  if (v97)
  {
    v98 = v97;
    if (CFArrayGetCount(v97) >= 1)
    {
      v99 = 0;
      do
      {
        v100 = (const __SCNetworkProtocol *)CFArrayGetValueAtIndex(v98, v99);
        Configuration = SCNetworkProtocolGetConfiguration(v100);
        ProtocolType = SCNetworkProtocolGetProtocolType(v100);
        v103 = SCNetworkProtocolGetEnabled(v100);
        __SCNetworkServiceAddProtocolToService(v15, ProtocolType, Configuration, v103);
        ++v99;
      }
      while (v99 < CFArrayGetCount(v98));
    }
    CFRelease(v98);
  }
  copyInterfaceConfiguration((const __SCNetworkService *)v8, v15);
  v8 = 1;
LABEL_56:
  if (v150)
    CFRelease(v150);
  if (v53)
    CFRelease(v53);
  if (v15)
    goto LABEL_11;
  return v8;
}

SCNetworkInterfaceRef copyInterfaceConfiguration(const __SCNetworkService *a1, const __SCNetworkService *a2)
{
  const __SCNetworkInterface *Interface;
  SCNetworkInterfaceRef result;
  const __SCNetworkInterface *v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFDictionary *Configuration;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  CFStringRef InterfaceType;
  const __SCNetworkInterface *v22;
  CFStringRef v23;
  const __CFDictionary *ExtendedConfiguration;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  const __CFDictionary *v36;
  const __CFDictionary *v37;
  const __CFDictionary *v38;
  const __CFDictionary *v39;
  const __CFDictionary *v40;
  const __CFString *v41;
  const __CFString *v42;
  const __CFString *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  Interface = SCNetworkServiceGetInterface(a1);
  result = SCNetworkServiceGetInterface(a2);
  if (Interface)
  {
    v5 = result;
    if (result)
    {
      v6 = CFSTR("PPP");
      v43 = CFSTR("L2TP");
      v7 = CFSTR("IPSec");
      v41 = CFSTR("IPSec");
      v42 = CFSTR("PPP");
      do
      {
        Configuration = SCNetworkInterfaceGetConfiguration(Interface);
        if ((Configuration || !SCError()) && !SCNetworkInterfaceSetConfiguration(v5, Configuration))
        {
          v9 = _SC_LOG_DEFAULT();
          v10 = _SC_syslog_os_log_mapping(6);
          if (__SC_log_enabled(6, v9, (os_log_type_t)v10))
          {
            v11 = _os_log_pack_size();
            v19 = (char *)&v41
                - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            *(_WORD *)_os_log_pack_fill() = 0;
            v20 = v19;
            v7 = v41;
            __SC_log_send(6, (uint64_t)v9, v10, v20);
            v6 = v42;
          }
        }
        InterfaceType = SCNetworkInterfaceGetInterfaceType(Interface);
        if (CFEqual(InterfaceType, v6))
        {
          v22 = SCNetworkInterfaceGetInterface(Interface);
          if (v22)
          {
            v23 = SCNetworkInterfaceGetInterfaceType(v22);
            if (CFEqual(v23, v43))
            {
              ExtendedConfiguration = SCNetworkInterfaceGetExtendedConfiguration(Interface, v7);
              if ((ExtendedConfiguration || !SCError())
                && !SCNetworkInterfaceSetExtendedConfiguration(v5, v7, ExtendedConfiguration))
              {
                v25 = _SC_LOG_DEFAULT();
                v26 = _SC_syslog_os_log_mapping(6);
                if (__SC_log_enabled(6, v25, (os_log_type_t)v26))
                {
                  v27 = _os_log_pack_size();
                  v35 = (char *)&v41
                      - ((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0);
                  __error();
                  v7 = v41;
                  *(_WORD *)_os_log_pack_fill() = 0;
                  __SC_log_send(6, (uint64_t)v25, v26, v35);
                  v6 = v42;
                }
              }
            }
          }
        }
        v36 = SCNetworkInterfaceGetExtendedConfiguration(Interface, CFSTR("EAPOL"));
        if (v36 || !SCError())
          SCNetworkInterfaceSetExtendedConfiguration(v5, CFSTR("EAPOL"), v36);
        v37 = SCNetworkInterfaceGetExtendedConfiguration(Interface, CFSTR("com.apple.payload"));
        if (v37 || !SCError())
          SCNetworkInterfaceSetExtendedConfiguration(v5, CFSTR("com.apple.payload"), v37);
        v38 = SCNetworkInterfaceGetExtendedConfiguration(Interface, CFSTR("EAP"));
        if (v38 || !SCError())
          SCNetworkInterfaceSetExtendedConfiguration(v5, CFSTR("EAP"), v38);
        v39 = SCNetworkInterfaceGetExtendedConfiguration(Interface, CFSTR("EAPOL.LoginWindow"));
        if (v39 || !SCError())
          SCNetworkInterfaceSetExtendedConfiguration(v5, CFSTR("EAPOL.LoginWindow"), v39);
        v40 = SCNetworkInterfaceGetExtendedConfiguration(Interface, CFSTR("IPSec"));
        if (v40 || !SCError())
          SCNetworkInterfaceSetExtendedConfiguration(v5, CFSTR("IPSec"), v40);
        Interface = SCNetworkInterfaceGetInterface(Interface);
        result = SCNetworkInterfaceGetInterface(v5);
        if (!Interface)
          break;
        v5 = result;
      }
      while (result);
    }
  }
  return result;
}

uint64_t __SCNetworkServiceCreate(SCPreferencesRef prefs, const __SCNetworkInterface *cf, const __CFString *a3)
{
  const __CFString *UserDefinedName;
  const __SCNetworkService *v6;
  const __SCNetworkService *v7;
  const __SCNetworkSet *v8;
  SCNetworkSetRef v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  int v34;
  const char *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  int v60;
  const char *v61;
  NSObject *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  _QWORD v74[2];

  v74[1] = *MEMORY[0x1E0C80C00];
  if (!cf)
    return 0;
  UserDefinedName = a3;
  if (!a3)
  {
    UserDefinedName = (const __CFString *)__SCNetworkInterfaceGetUserDefinedName(cf);
    if (!UserDefinedName)
    {
      v39 = _SC_LOG_DEFAULT();
      v40 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v39, (os_log_type_t)v40))
      {
        v41 = _os_log_pack_size();
        v49 = (char *)v74 - ((MEMORY[0x1E0C80A78](v41, v42, v43, v44, v45, v46, v47, v48) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(6, (uint64_t)v39, v40, v49);
      }
      return 0;
    }
  }
  v6 = SCNetworkServiceCreate(prefs, cf);
  v7 = v6;
  if (!v6)
  {
    v22 = _SC_LOG_DEFAULT();
    v23 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v22, (os_log_type_t)v23))
    {
      v24 = _os_log_pack_size();
      v32 = (char *)v74 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v33 = _os_log_pack_fill();
      v34 = SCError();
      v35 = SCErrorString(v34);
      *(_DWORD *)v33 = 136315138;
      *(_QWORD *)(v33 + 4) = v35;
      __SC_log_send(6, (uint64_t)v22, v23, v32);
    }
    v9 = SCNetworkSetCopyCurrent(prefs);
    v36 = 0;
    v10 = 0;
    if (v9)
      goto LABEL_16;
    goto LABEL_26;
  }
  if (!SCNetworkServiceSetName(v6, UserDefinedName))
  {
    v37 = _SC_LOG_DEFAULT();
    v38 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v37, (os_log_type_t)v38))
      goto LABEL_23;
    goto LABEL_24;
  }
  if (!SCNetworkServiceEstablishDefaultConfiguration(v7))
  {
    v37 = _SC_LOG_DEFAULT();
    v38 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v37, (os_log_type_t)v38))
    {
LABEL_23:
      v50 = _os_log_pack_size();
      v58 = (char *)v74 - ((MEMORY[0x1E0C80A78](v50, v51, v52, v53, v54, v55, v56, v57) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v59 = _os_log_pack_fill();
      v60 = SCError();
      v61 = SCErrorString(v60);
      *(_DWORD *)v59 = 136315138;
      *(_QWORD *)(v59 + 4) = v61;
      __SC_log_send(6, (uint64_t)v37, v38, v58);
    }
LABEL_24:
    v36 = 0;
LABEL_29:
    SCNetworkServiceRemove(v7);
    CFRelease(v7);
    return v36;
  }
  v8 = SCNetworkSetCopyCurrent(prefs);
  if (v8)
  {
    v9 = v8;
    v10 = SCNetworkSetAddService(v8, v7);
    if (!(_DWORD)v10)
    {
      v11 = _SC_LOG_DEFAULT();
      v12 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v11, (os_log_type_t)v12))
      {
        v13 = _os_log_pack_size();
        v21 = (char *)v74 - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(6, (uint64_t)v11, v12, v21);
      }
      SCNetworkServiceRemove(v7);
    }
    CFRelease(v7);
LABEL_16:
    CFRelease(v9);
    return v10;
  }
  v36 = 1;
LABEL_26:
  v62 = _SC_LOG_DEFAULT();
  v63 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v62, (os_log_type_t)v63))
  {
    v64 = _os_log_pack_size();
    v72 = (char *)v74 - ((MEMORY[0x1E0C80A78](v64, v65, v66, v67, v68, v69, v70, v71) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(6, (uint64_t)v62, v63, v72);
  }
  if (v7)
    goto LABEL_29;
  return v36;
}

_QWORD *__SCNetworkServiceIsPPTP(_QWORD *result)
{
  if (result)
  {
    result = (_QWORD *)result[3];
    if (result)
    {
      result = (_QWORD *)__SCNetworkInterfaceGetEntitySubType((uint64_t)result);
      if (result)
        return (_QWORD *)(CFEqual(result, CFSTR("PPTP")) != 0);
    }
  }
  return result;
}

BOOL __SCNetworkServiceEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
    return 1;
  if (*(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32))
    return CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16)) != 0;
  return 0;
}

CFHashCode __SCNetworkServiceHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 16));
}

__CFString *__SCNetworkServiceCopyDescription(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCNetworkService %p [%p]> {"), a1, v2);
  CFStringAppendFormat(Mutable, 0, CFSTR("id = %@"), a1[2]);
  if (a1[4])
  {
    CFStringAppendFormat(Mutable, 0, CFSTR(", prefs = %p"), a1[4]);
  }
  else if (a1[5])
  {
    CFStringAppendFormat(Mutable, 0, CFSTR(", store = %p"), a1[5]);
  }
  if (a1[6])
    CFStringAppendFormat(Mutable, 0, CFSTR(", name = %@"), a1[6]);
  if (!__SCNetworkServiceExists((uint64_t)a1))
    CFStringAppendFormat(Mutable, 0, CFSTR(", REMOVED"));
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  return Mutable;
}

Boolean SCNetworkSetAddService(SCNetworkSetRef set, SCNetworkServiceRef service)
{
  uint64_t v4;
  CFTypeID TypeID;
  const __CFArray *v6;
  const __CFArray *v7;
  int v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  const __SCNetworkInterface *Interface;
  int v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  const __SCNetworkInterface *v37;
  __CFArray *v38;
  const __CFString *SetNetworkServiceEntity;
  _BOOL4 v40;
  const __CFString *NetworkServiceEntity;
  __n128 v42;
  NSObject *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t block;
  uint64_t v56;
  void (*v57)(uint64_t);
  void *v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  CFRange v63;

  v62 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!set)
    {
LABEL_22:
      v23 = 1002;
      goto LABEL_23;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!set)
      goto LABEL_22;
  }
  v4 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(set) != v4)
    goto LABEL_22;
  TypeID = SCNetworkServiceGetTypeID();
  if (!service || CFGetTypeID(service) != TypeID || !*((_QWORD *)service + 4))
    goto LABEL_22;
  if (!__SCNetworkSetExists((uint64_t)set))
  {
    v10 = __log_SCNetworkConfiguration();
    v11 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v10, (os_log_type_t)v11))
    {
      v12 = _os_log_pack_size();
      v20 = (char *)&block - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v21 = _os_log_pack_fill();
      *(_DWORD *)v21 = 138412546;
      *(_QWORD *)(v21 + 4) = set;
      *(_WORD *)(v21 + 12) = 2112;
      *(_QWORD *)(v21 + 14) = service;
      __SC_log_send(3, (uint64_t)v10, v11, v20);
    }
    block = MEMORY[0x1E0C809B0];
    v56 = 0x40000000;
    v57 = ___SC_crash_once_block_invoke_4;
    v58 = &__block_descriptor_tmp_16;
    v60 = 0;
    v61 = 0;
    v59 = "SCNetworkSetAddService() w/removed set";
    if (_SC_crash_once_once_4 == -1)
      goto LABEL_22;
LABEL_41:
    dispatch_once(&_SC_crash_once_once_4, &block);
    goto LABEL_22;
  }
  if (!__SCNetworkServiceExists((uint64_t)service))
  {
    v24 = __log_SCNetworkConfiguration();
    v25 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v24, (os_log_type_t)v25))
    {
      v26 = _os_log_pack_size();
      v34 = (char *)&block - ((MEMORY[0x1E0C80A78](v26, v27, v28, v29, v30, v31, v32, v33) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v35 = _os_log_pack_fill();
      *(_DWORD *)v35 = 138412546;
      *(_QWORD *)(v35 + 4) = set;
      *(_WORD *)(v35 + 12) = 2112;
      *(_QWORD *)(v35 + 14) = service;
      __SC_log_send(3, (uint64_t)v24, v25, v34);
    }
    block = MEMORY[0x1E0C809B0];
    v56 = 0x40000000;
    v57 = ___SC_crash_once_block_invoke_4;
    v58 = &__block_descriptor_tmp_16;
    v60 = 0;
    v61 = 0;
    v59 = "SCNetworkSetAddService() w/removed service";
    if (_SC_crash_once_once_4 == -1)
      goto LABEL_22;
    goto LABEL_41;
  }
  v6 = SCNetworkSetCopyServices(set);
  if (v6)
  {
    v7 = v6;
    v63.length = CFArrayGetCount(v6);
    v63.location = 0;
    v8 = CFArrayContainsValue(v7, v63, service);
    CFRelease(v7);
    if (v8)
    {
      LOBYTE(v9) = 1;
      return v9;
    }
  }
  Interface = SCNetworkServiceGetInterface(service);
  if (Interface
    && __SCNetworkInterfaceIsBusyMember(*((const __SCPreferences **)service + 4), Interface, 1))
  {
    v23 = 1001;
LABEL_23:
    _SCErrorSet(v23);
    LOBYTE(v9) = 0;
    return v9;
  }
  v37 = SCNetworkServiceGetInterface(service);
  if (v37)
    v38 = __SCNetworkInterfaceCopyDeepConfiguration(set, v37);
  else
    v38 = 0;
  SetNetworkServiceEntity = SCPreferencesPathKeyCreateSetNetworkServiceEntity(0, *((_QWORD *)set + 2), *((_QWORD *)service + 2), 0);
  v40 = SCPreferencesPathGetLink(*((SCPreferencesRef *)set + 3), SetNetworkServiceEntity) != 0;
  NetworkServiceEntity = SCPreferencesPathKeyCreateNetworkServiceEntity(0, *((_QWORD *)service + 2), 0);
  if (SCPreferencesPathSetLink(*((SCPreferencesRef *)set + 3), SetNetworkServiceEntity, NetworkServiceEntity))
  {
    _SCNetworkInterfaceCacheOpen();
    v9 = ensure_unique_service_name(service);
    _SCNetworkInterfaceCacheClose();
    if (!v9)
      SCPreferencesPathRemoveValue(*((SCPreferencesRef *)set + 3), SetNetworkServiceEntity);
  }
  else
  {
    v9 = 0;
  }
  CFRelease(SetNetworkServiceEntity);
  CFRelease(NetworkServiceEntity);
  if (v9)
  {
    if (v37)
      __SCNetworkInterfaceSetDeepConfiguration(set, v37, v38, v42);
    _serviceOrder_add((SCPreferencesRef *)set, service, v40);
    *((_BYTE *)set + 40) = 1;
    v43 = __log_SCNetworkConfiguration();
    v44 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v43, (os_log_type_t)v44))
    {
      v45 = _os_log_pack_size();
      v53 = (char *)&block - ((MEMORY[0x1E0C80A78](v45, v46, v47, v48, v49, v50, v51, v52) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v54 = _os_log_pack_fill();
      *(_DWORD *)v54 = 138412546;
      *(_QWORD *)(v54 + 4) = set;
      *(_WORD *)(v54 + 12) = 2112;
      *(_QWORD *)(v54 + 14) = service;
      __SC_log_send(7, (uint64_t)v43, v44, v53);
    }
  }
  if (v38)
    CFRelease(v38);
  return v9;
}

BOOL __SCNetworkSetExists(uint64_t a1)
{
  const __CFString *Set;
  CFDictionaryRef Value;
  CFTypeID TypeID;

  if (*(_QWORD *)(a1 + 24)
    && (Set = SCPreferencesPathKeyCreateSet(0, *(_QWORD *)(a1 + 16)),
        Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 24), Set),
        CFRelease(Set),
        TypeID = CFDictionaryGetTypeID(),
        Value))
  {
    return CFGetTypeID(Value) == TypeID;
  }
  else
  {
    return 0;
  }
}

uint64_t ensure_unique_service_name(const __SCNetworkService *a1)
{
  const __SCNetworkInterface *Interface;
  CFStringRef Name;
  const __CFString *v4;
  uint64_t v5;
  uint64_t v6;
  const CFArrayCallBacks *v7;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v9;
  __CFArray *MutableCopy;
  CFIndex Count;
  CFIndex v12;
  const __CFString *ValueAtIndex;
  SInt32 IntValue;
  uint64_t v15;
  CFStringRef v16;
  const __CFString *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  CFStringRef LocalizedDisplayName;
  int v32;
  const char *v33;
  _QWORD v35[2];

  v35[1] = *MEMORY[0x1E0C80C00];
  Interface = SCNetworkServiceGetInterface(a1);
  Name = SCNetworkServiceGetName(a1);
  v4 = Name;
  if (Name)
    CFRetain(Name);
  v5 = SCNetworkServiceSetName(a1, v4);
  if ((_DWORD)v5)
  {
    v6 = v5;
  }
  else
  {
    v7 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    while (SCError() == 1005)
    {
      if (!v4)
        goto LABEL_18;
      ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, v4, CFSTR(" "));
      if (ArrayBySeparatingStrings)
      {
        v9 = ArrayBySeparatingStrings;
        MutableCopy = CFArrayCreateMutableCopy(0, 0, ArrayBySeparatingStrings);
        CFRelease(v9);
      }
      else
      {
        MutableCopy = CFArrayCreateMutable(0, 0, v7);
        CFArrayAppendValue(MutableCopy, v4);
      }
      Count = CFArrayGetCount(MutableCopy);
      if (Count < 2
        || (v12 = Count - 1,
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, Count - 1),
            IntValue = CFStringGetIntValue(ValueAtIndex),
            IntValue < 1))
      {
        v15 = 2;
      }
      else
      {
        v15 = (IntValue + 1);
        CFArrayRemoveValueAtIndex(MutableCopy, v12);
      }
      v16 = CFStringCreateWithFormat(0, 0, CFSTR("%d"), v15);
      CFArrayAppendValue(MutableCopy, v16);
      CFRelease(v16);
      v17 = CFStringCreateByCombiningStrings(0, MutableCopy, CFSTR(" "));
      CFRelease(MutableCopy);
      if (!v17)
      {
LABEL_18:
        v19 = __log_SCNetworkConfiguration();
        v20 = _SC_syslog_os_log_mapping(6);
        if (!__SC_log_enabled(6, v19, (os_log_type_t)v20))
          goto LABEL_22;
        goto LABEL_21;
      }
      CFRelease(v4);
      v18 = SCNetworkServiceSetName(a1, v17);
      v4 = v17;
      if ((_DWORD)v18)
      {
        v6 = v18;
        goto LABEL_24;
      }
    }
    v19 = __log_SCNetworkConfiguration();
    v20 = _SC_syslog_os_log_mapping(6);
    if (!__SC_log_enabled(6, v19, (os_log_type_t)v20))
      goto LABEL_22;
LABEL_21:
    v21 = _os_log_pack_size();
    v29 = (char *)v35 - ((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v30 = _os_log_pack_fill();
    LocalizedDisplayName = SCNetworkInterfaceGetLocalizedDisplayName(Interface);
    v32 = SCError();
    v33 = SCErrorString(v32);
    *(_DWORD *)v30 = 138412546;
    *(_QWORD *)(v30 + 4) = LocalizedDisplayName;
    *(_WORD *)(v30 + 12) = 2080;
    *(_QWORD *)(v30 + 14) = v33;
    __SC_log_send(6, (uint64_t)v19, v20, v29);
LABEL_22:
    v6 = 0;
  }
  v17 = v4;
  if (v4)
LABEL_24:
    CFRelease(v17);
  return v6;
}

void _serviceOrder_add(SCPreferencesRef *a1, SCNetworkServiceRef service, int a3)
{
  CFStringRef ServiceID;
  uint64_t v7;
  const __CFArray *ServiceOrder;
  const __CFArray *MutableCopy;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  uint64_t v13;
  CFIndex i;
  const void *ValueAtIndex;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  const char *v41;
  CFIndex v42;
  CFIndex v43;
  CFIndex v44;
  CFIndex v45;
  const __CFString *v46;
  CFTypeID TypeID;
  const __SCNetworkService *v48;
  const __SCNetworkService *v49;
  uint64_t v50[2];
  uint64_t block;
  uint64_t v52;
  void (*v53)(uint64_t);
  void *v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  ServiceID = SCNetworkServiceGetServiceID(service);
  v7 = _serviceOrder(service);
  ServiceOrder = SCNetworkSetGetServiceOrder((SCNetworkSetRef)a1);
  if (ServiceOrder)
    MutableCopy = CFArrayCreateMutableCopy(0, 0, ServiceOrder);
  else
    MutableCopy = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v10 = MutableCopy;
  if (!MutableCopy)
    _serviceOrder_add_cold_1();
  Count = CFArrayGetCount(MutableCopy);
  if (Count < 1)
    goto LABEL_12;
  v12 = Count;
  v13 = 0;
  for (i = 0; i != v12; ++i)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v10, i);
    if (CFEqual(ValueAtIndex, ServiceID))
      ++v13;
  }
  if (v13 == 1)
  {
    CFRelease(v10);
    return;
  }
  if (v13)
  {
    v28 = __log_SCNetworkConfiguration();
    v29 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v28, (os_log_type_t)v29))
    {
      v30 = _os_log_pack_size();
      v50[1] = (uint64_t)v50;
      v38 = MEMORY[0x1E0C80A78](v30, v31, v32, v33, v34, v35, v36, v37);
      v50[0] = (uint64_t)v28;
      v39 = (char *)v50 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v40 = _os_log_pack_fill();
      v41 = "";
      *(_DWORD *)v40 = 136315650;
      if (!a3)
        v41 = "new ";
      *(_QWORD *)(v40 + 4) = v41;
      *(_WORD *)(v40 + 12) = 2048;
      *(_QWORD *)(v40 + 14) = v13;
      *(_WORD *)(v40 + 22) = 2112;
      *(_QWORD *)(v40 + 24) = service;
      __SC_log_send(3, v50[0], v29, v39);
    }
    block = MEMORY[0x1E0C809B0];
    v52 = 0x40000000;
    v53 = ___SC_crash_once_block_invoke_4;
    v54 = &__block_descriptor_tmp_16;
    v56 = 0;
    v57 = 0;
    v55 = "SCNetworkSetAddService() w/multiple ServiceOrder references";
    if (_SC_crash_once_once_4 != -1)
      dispatch_once(&_SC_crash_once_once_4, &block);
    _serviceOrder_clear(v10, ServiceID);
  }
  else
  {
LABEL_12:
    if (a3)
    {
      v16 = __log_SCNetworkConfiguration();
      v17 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v16, (os_log_type_t)v17))
      {
        v18 = _os_log_pack_size();
        v26 = (char *)v50 - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v27 = _os_log_pack_fill();
        *(_DWORD *)v27 = 138412290;
        *(_QWORD *)(v27 + 4) = service;
        __SC_log_send(3, (uint64_t)v16, v17, v26);
      }
      block = MEMORY[0x1E0C809B0];
      v52 = 0x40000000;
      v53 = ___SC_crash_once_block_invoke_4;
      v54 = &__block_descriptor_tmp_16;
      v56 = 0;
      v57 = 0;
      v55 = "SCNetworkSetAddService() w/updated service not in ServiceOrder";
      if (_SC_crash_once_once_4 != -1)
        dispatch_once(&_SC_crash_once_once_4, &block);
    }
  }
  v42 = CFArrayGetCount(v10);
  if (v42 < 1)
  {
    v45 = 0;
  }
  else
  {
    v43 = v42;
    v44 = 0;
    v45 = 0;
    do
    {
      v46 = (const __CFString *)CFArrayGetValueAtIndex(v10, v44);
      TypeID = CFStringGetTypeID();
      if (v46)
      {
        if (CFGetTypeID(v46) == TypeID)
        {
          v48 = SCNetworkServiceCopy(a1[3], v46);
          if (v48)
          {
            v49 = v48;
            if (v7 >= _serviceOrder(v48))
              v45 = v44 + 1;
            CFRelease(v49);
          }
        }
      }
      ++v44;
    }
    while (v43 != v44);
  }
  CFArrayInsertValueAtIndex(v10, v45, ServiceID);
  SCNetworkSetSetServiceOrder((SCNetworkSetRef)a1, v10);
  CFRelease(v10);
}

SCNetworkSetRef SCNetworkSetCopy(SCPreferencesRef prefs, CFStringRef setID)
{
  CFTypeID TypeID;
  const __CFString *Set;
  CFDictionaryRef Value;
  CFTypeID v7;
  SCNetworkSetRef result;
  int v9;

  TypeID = CFStringGetTypeID();
  if (!setID || CFGetTypeID(setID) != TypeID)
  {
    v9 = 1002;
LABEL_9:
    _SCErrorSet(v9);
    return 0;
  }
  Set = SCPreferencesPathKeyCreateSet(0, (uint64_t)setID);
  Value = SCPreferencesPathGetValue(prefs, Set);
  CFRelease(Set);
  v7 = CFDictionaryGetTypeID();
  if (!Value || CFGetTypeID(Value) != v7)
  {
    v9 = 1004;
    goto LABEL_9;
  }
  result = (SCNetworkSetRef)__SCNetworkSetCreatePrivate(prefs, setID);
  if (!result)
    SCNetworkSetCopy_cold_1();
  *((_BYTE *)result + 40) = 1;
  return result;
}

Boolean SCNetworkSetContainsInterface(SCNetworkSetRef set, SCNetworkInterfaceRef interface)
{
  CFArrayRef v3;
  CFArrayRef v4;
  Boolean v5;

  v3 = SCNetworkSetCopyServices(set);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = __SCNetworkServiceExistsForInterface(v3, interface);
  CFRelease(v4);
  return v5;
}

__CFArray *SCNetworkSetCopyAvailableInterfaces(uint64_t a1)
{
  const __SCPreferences *v1;
  __CFArray *v2;
  CFIndex Count;
  BOOL v4;
  __CFArray *v5;
  uint64_t v6;
  __CFSet *Mutable;
  const __CFArray *v8;
  const __CFArray *v9;
  CFIndex i;
  const void *ValueAtIndex;

  v1 = *(const __SCPreferences **)(a1 + 24);
  v2 = _SCNetworkInterfaceCopyAllWithPreferences(v1);
  Count = CFArrayGetCount(v2);
  if (v1)
    v4 = Count == 0;
  else
    v4 = 1;
  if (v4)
    return v2;
  v6 = Count;
  Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  v8 = (const __CFArray *)SCBridgeInterfaceCopyAll(v1);
  if (v8)
  {
    v9 = v8;
    __SCBridgeInterfaceListCollectMembers(v8, Mutable, 0);
    CFRelease(v9);
  }
  if (!CFSetGetCount(Mutable))
  {
    if (Mutable)
      CFRelease(Mutable);
    return v2;
  }
  v5 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (v6 >= 1)
  {
    for (i = 0; i != v6; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v2, i);
      if (!CFSetContainsValue(Mutable, ValueAtIndex))
        CFArrayAppendValue(v5, ValueAtIndex);
    }
  }
  CFRelease(v2);
  CFRelease(Mutable);
  return v5;
}

SCNetworkSetRef SCNetworkSetCreate(SCPreferencesRef prefs)
{
  const __CFString *Sets;
  const __CFString *UniqueChild;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFString *ValueAtIndex;
  uint64_t Private;
  _BYTE *v7;
  const __CFDictionary *v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  Sets = SCPreferencesPathKeyCreateSets(0);
  UniqueChild = SCPreferencesPathCreateUniqueChild(prefs, Sets);
  CFRelease(Sets);
  if (!UniqueChild)
    return 0;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, UniqueChild, CFSTR("/"));
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 2);
  Private = __SCNetworkSetCreatePrivate(prefs, ValueAtIndex);
  if (!Private)
    SCNetworkSetCreate_cold_1();
  v7 = (_BYTE *)Private;
  CFRelease(ArrayBySeparatingStrings);
  v7[40] = 0;
  v8 = CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v9 = SCPreferencesPathSetValue(prefs, UniqueChild, v8);
  CFRelease(UniqueChild);
  CFRelease(v8);
  if (!v9)
  {
    CFRelease(v7);
    return 0;
  }
  v10 = __log_SCNetworkConfiguration();
  v11 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v10, (os_log_type_t)v11))
  {
    v12 = _os_log_pack_size();
    v20 = (char *)v23 - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v21 = _os_log_pack_fill();
    *(_DWORD *)v21 = 138412290;
    *(_QWORD *)(v21 + 4) = v7;
    __SC_log_send(7, (uint64_t)v10, v11, v20);
  }
  return (SCNetworkSetRef)v7;
}

const __SCNetworkSet *_SCNetworkSetCreateDefault(const __SCPreferences *a1)
{
  SCNetworkSetRef v2;
  SCNetworkSetRef v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  const __SCNetworkSet *v15;
  SCNetworkSetRef v17;
  const __CFString *v18;
  int v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  int v33;
  const char *v34;
  const void *v35;
  CFNumberRef v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  int v49;
  const char *v50;
  NSObject *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  int v63;
  const char *v64;
  _BYTE v65[4];
  int valuePtr;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v2 = SCNetworkSetCopyCurrent(a1);
  if (v2)
  {
    v3 = v2;
    v4 = __log_SCNetworkConfiguration();
    v5 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v4, (os_log_type_t)v5))
    {
      v6 = _os_log_pack_size();
      v14 = &v65[-((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v4, v5, v14);
    }
    CFRelease(v3);
    _SCErrorSet(1005);
    return 0;
  }
  v17 = SCNetworkSetCreate(a1);
  if (!v17)
  {
    v37 = __log_SCNetworkConfiguration();
    v38 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v37, (os_log_type_t)v38))
    {
      v39 = _os_log_pack_size();
      v47 = &v65[-((MEMORY[0x1E0C80A78](v39, v40, v41, v42, v43, v44, v45, v46) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v48 = _os_log_pack_fill();
      v49 = SCError();
      v50 = SCErrorString(v49);
      *(_DWORD *)v48 = 136315138;
      *(_QWORD *)(v48 + 4) = v50;
      __SC_log_send(5, (uint64_t)v37, v38, v47);
    }
    return 0;
  }
  v15 = v17;
  v18 = copy_default_set_name(1);
  v19 = SCNetworkSetSetName(v15, v18);
  CFRelease(v18);
  *((_QWORD *)v15 + 6) = *MEMORY[0x1E0C9AE50];
  if (!v19)
  {
    v51 = __log_SCNetworkConfiguration();
    v52 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v51, (os_log_type_t)v52))
    {
      v53 = _os_log_pack_size();
      v61 = &v65[-((MEMORY[0x1E0C80A78](v53, v54, v55, v56, v57, v58, v59, v60) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v62 = _os_log_pack_fill();
      v63 = SCError();
      v64 = SCErrorString(v63);
      *(_DWORD *)v62 = 136315138;
      *(_QWORD *)(v62 + 4) = v64;
      __SC_log_send(5, (uint64_t)v51, v52, v61);
    }
    goto LABEL_22;
  }
  v20 = SCNetworkSetSetCurrent(v15);
  if (!v20)
  {
    v21 = __log_SCNetworkConfiguration();
    v22 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v21, (os_log_type_t)v22))
    {
      v23 = _os_log_pack_size();
      v31 = &v65[-((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v32 = _os_log_pack_fill();
      v33 = SCError();
      v34 = SCErrorString(v33);
      *(_DWORD *)v32 = 136315138;
      *(_QWORD *)(v32 + 4) = v34;
      __SC_log_send(5, (uint64_t)v21, v22, v31);
    }
  }
  if (!SCPreferencesGetValue(a1, CFSTR("Model")))
  {
    v35 = (const void *)_SC_hw_model(0);
    SCPreferencesSetValue(a1, CFSTR("Model"), v35);
  }
  if (!SCPreferencesGetValue(a1, CFSTR("__VERSION__")))
  {
    valuePtr = 20191120;
    v36 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    SCPreferencesSetValue(a1, CFSTR("__VERSION__"), v36);
    CFRelease(v36);
  }
  if (!v20)
  {
LABEL_22:
    SCNetworkSetRemove(v15);
    CFRelease(v15);
    return 0;
  }
  return v15;
}

const __CFString *copy_default_set_name(int a1)
{
  uint64_t *v1;
  const __CFString *v2;
  const __CFString *v3;

  if (a1)
  {
    if (copy_default_set_name_once_40 != -1)
      dispatch_once(&copy_default_set_name_once_40, &__block_literal_global_42_0);
    v1 = &copy_default_set_name_localized;
  }
  else
  {
    if (copy_default_set_name_once != -1)
      dispatch_once(&copy_default_set_name_once, &__block_literal_global_14);
    v1 = &copy_default_set_name_non_localized;
  }
  v2 = (const __CFString *)*v1;
  if (v2)
    v3 = v2;
  else
    v3 = CFSTR("Automatic");
  CFRetain(v3);
  return v3;
}

Boolean SCNetworkSetSetName(SCNetworkSetRef set, CFStringRef name)
{
  uint64_t v4;
  CFTypeID TypeID;
  const __CFString *v6;
  int v7;
  const __CFString *v8;
  const __CFString *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  CFStringRef v22;
  int v23;
  const __CFString *v25;
  CFStringRef v26;
  int v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  int v40;
  const __CFArray *v41;
  const __CFArray *v42;
  CFIndex Count;
  CFIndex v44;
  CFIndex v45;
  const __SCNetworkSet *ValueAtIndex;
  CFStringRef SetID;
  CFStringRef v48;
  const __CFString *v49;
  const __CFDictionary *Value;
  CFTypeID v51;
  __CFDictionary *MutableCopy;
  const __CFDictionary *Mutable;
  NSObject *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!set)
      goto LABEL_16;
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!set)
      goto LABEL_16;
  }
  v4 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(set) != v4)
    goto LABEL_16;
  if (!__SCNetworkSetExists((uint64_t)set))
  {
    v10 = __log_SCNetworkConfiguration();
    v11 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v10, (os_log_type_t)v11))
    {
      v12 = _os_log_pack_size();
      v20 = (char *)block - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v21 = _os_log_pack_fill();
      v22 = CFSTR("<NULL>");
      if (name)
        v22 = name;
      *(_DWORD *)v21 = 138412546;
      *(_QWORD *)(v21 + 4) = set;
      *(_WORD *)(v21 + 12) = 2112;
      *(_QWORD *)(v21 + 14) = v22;
      __SC_log_send(3, (uint64_t)v10, v11, v20);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_4;
    block[3] = &__block_descriptor_tmp_16;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkSetSetName() w/removed set";
    if (_SC_crash_once_once_4 != -1)
      dispatch_once(&_SC_crash_once_once_4, block);
    goto LABEL_16;
  }
  if (!name)
  {
    v9 = 0;
    v6 = 0;
    goto LABEL_19;
  }
  TypeID = CFStringGetTypeID();
  if (CFGetTypeID(name) != TypeID)
  {
LABEL_16:
    _SCErrorSet(1002);
    LOBYTE(v23) = 0;
    return v23;
  }
  v6 = copy_default_set_name(0);
  v7 = CFEqual(name, v6);
  v8 = copy_default_set_name(1);
  v9 = v8;
  if (!v7)
  {
    if (CFEqual(name, v6))
    {
LABEL_34:
      v41 = SCNetworkSetCopyAll(*((SCPreferencesRef *)set + 3));
      if (v41)
      {
        v42 = v41;
        Count = CFArrayGetCount(v41);
        if (Count >= 1)
        {
          v44 = Count;
          v45 = 0;
          while (1)
          {
            ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v42, v45);
            SetID = SCNetworkSetGetSetID(ValueAtIndex);
            if (!CFEqual(*((CFTypeRef *)set + 2), SetID))
            {
              v48 = SCNetworkSetGetName(ValueAtIndex);
              if (v48)
              {
                if (CFEqual(name, v48))
                  break;
              }
            }
            if (v44 == ++v45)
              goto LABEL_41;
          }
          CFRelease(v42);
          v40 = 1005;
          goto LABEL_29;
        }
LABEL_41:
        CFRelease(v42);
      }
LABEL_42:
      if (v6)
      {
        if (!v9)
          v9 = copy_default_set_name(1);
        if (CFEqual(name, v9))
          name = v6;
      }
      goto LABEL_47;
    }
LABEL_19:
    v25 = copy_default_set_name(1);
    v26 = SCNetworkSetGetName(set);
    if (v26 == v25)
    {
      CFRelease(v25);
    }
    else
    {
      if (!v25 || !v26)
      {
        CFRelease(v25);
        goto LABEL_31;
      }
      v27 = CFEqual(v26, v25);
      CFRelease(v25);
      if (!v27)
      {
LABEL_31:
        if (!name)
          goto LABEL_47;
        goto LABEL_42;
      }
    }
    if (geteuid())
    {
      v28 = __log_SCNetworkConfiguration();
      v29 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v28, (os_log_type_t)v29))
      {
        v30 = _os_log_pack_size();
        v38 = (char *)block
            - ((MEMORY[0x1E0C80A78](v30, v31, v32, v33, v34, v35, v36, v37) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v39 = _os_log_pack_fill();
        *(_DWORD *)v39 = 138412290;
        *(_QWORD *)(v39 + 4) = set;
        __SC_log_send(3, (uint64_t)v28, v29, v38);
      }
      _SC_crash("The \"Automatic\" network set cannot be renamed", 0, 0);
      v40 = 1002;
LABEL_29:
      _SCErrorSet(v40);
      goto LABEL_58;
    }
    goto LABEL_31;
  }
  name = v8;
  if (v8)
    goto LABEL_34;
LABEL_47:
  v49 = SCPreferencesPathKeyCreateSet(0, *((_QWORD *)set + 2));
  Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)set + 3), v49);
  v51 = CFDictionaryGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) == v51)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
      Mutable = MutableCopy;
      if (!name)
      {
        CFDictionaryRemoveValue(MutableCopy, CFSTR("UserDefinedName"));
LABEL_54:
        v23 = SCPreferencesPathSetValue(*((SCPreferencesRef *)set + 3), v49, Mutable);
        CFRelease(Mutable);
        CFRelease(v49);
        if (v23)
        {
          v54 = __log_SCNetworkConfiguration();
          v55 = _SC_syslog_os_log_mapping(7);
          if (__SC_log_enabled(7, v54, (os_log_type_t)v55))
          {
            v56 = _os_log_pack_size();
            v64 = (char *)block
                - ((MEMORY[0x1E0C80A78](v56, v57, v58, v59, v60, v61, v62, v63) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v65 = _os_log_pack_fill();
            *(_DWORD *)v65 = 138412290;
            *(_QWORD *)(v65 + 4) = set;
            __SC_log_send(7, (uint64_t)v54, v55, v64);
          }
        }
        goto LABEL_59;
      }
LABEL_53:
      CFDictionarySetValue(Mutable, CFSTR("UserDefinedName"), name);
      goto LABEL_54;
    }
  }
  else if (name)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_53;
  }
  CFRelease(v49);
LABEL_58:
  LOBYTE(v23) = 0;
LABEL_59:
  if (v9)
    CFRelease(v9);
  if (v6)
    CFRelease(v6);
  return v23;
}

Boolean SCNetworkSetSetCurrent(SCNetworkSetRef set)
{
  uint64_t v2;
  CFStringRef v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!set)
    {
LABEL_12:
      _SCErrorSet(1002);
      LOBYTE(v4) = 0;
      return v4;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!set)
      goto LABEL_12;
  }
  v2 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(set) != v2)
    goto LABEL_12;
  if (!__SCNetworkSetExists((uint64_t)set))
  {
    v17 = __log_SCNetworkConfiguration();
    v18 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v17, (os_log_type_t)v18))
    {
      v19 = _os_log_pack_size();
      v27 = (char *)block - ((MEMORY[0x1E0C80A78](v19, v20, v21, v22, v23, v24, v25, v26) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v28 = _os_log_pack_fill();
      *(_DWORD *)v28 = 138412290;
      *(_QWORD *)(v28 + 4) = set;
      __SC_log_send(3, (uint64_t)v17, v18, v27);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_4;
    block[3] = &__block_descriptor_tmp_16;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkSetSetCurrent() w/removed set";
    if (_SC_crash_once_once_4 != -1)
      dispatch_once(&_SC_crash_once_once_4, block);
    goto LABEL_12;
  }
  v3 = SCPreferencesPathKeyCreateSet(0, *((_QWORD *)set + 2));
  v4 = SCPreferencesSetValue(*((SCPreferencesRef *)set + 3), CFSTR("CurrentSet"), v3);
  CFRelease(v3);
  if (v4)
  {
    v5 = __log_SCNetworkConfiguration();
    v6 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v5, (os_log_type_t)v6))
    {
      v7 = _os_log_pack_size();
      v15 = (char *)block - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v16 = _os_log_pack_fill();
      *(_DWORD *)v16 = 138412290;
      *(_QWORD *)(v16 + 4) = set;
      __SC_log_send(7, (uint64_t)v5, v6, v15);
    }
  }
  return v4;
}

Boolean SCNetworkSetRemove(SCNetworkSetRef set)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  CFPropertyListRef Value;
  CFStringRef v16;
  CFTypeID TypeID;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  int v43;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!set)
    {
LABEL_20:
      _SCErrorSet(1002);
LABEL_21:
      LOBYTE(v43) = 0;
      return v43;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!set)
      goto LABEL_20;
  }
  v2 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(set) != v2)
    goto LABEL_20;
  if (!__SCNetworkSetExists((uint64_t)set))
  {
    v31 = __log_SCNetworkConfiguration();
    v32 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v31, (os_log_type_t)v32))
    {
      v33 = _os_log_pack_size();
      v41 = (char *)block - ((MEMORY[0x1E0C80A78](v33, v34, v35, v36, v37, v38, v39, v40) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v42 = _os_log_pack_fill();
      *(_DWORD *)v42 = 138412290;
      *(_QWORD *)(v42 + 4) = set;
      __SC_log_send(3, (uint64_t)v31, v32, v41);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_4;
    block[3] = &__block_descriptor_tmp_16;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkSetRemove() w/removed set";
    if (_SC_crash_once_once_4 != -1)
      dispatch_once(&_SC_crash_once_once_4, block);
    goto LABEL_20;
  }
  if (_SCNetworkSetIsDefault((const __CFBoolean **)set) && geteuid())
  {
    v3 = __log_SCNetworkConfiguration();
    v4 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v3, (os_log_type_t)v4))
    {
      v5 = _os_log_pack_size();
      v13 = (char *)block - ((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v14 = _os_log_pack_fill();
      *(_DWORD *)v14 = 138412290;
      *(_QWORD *)(v14 + 4) = set;
      __SC_log_send(3, (uint64_t)v3, v4, v13);
    }
    _SC_crash("The \"Automatic\" network set cannot be removed", 0, 0);
    goto LABEL_20;
  }
  Value = SCPreferencesGetValue(*((SCPreferencesRef *)set + 3), CFSTR("CurrentSet"));
  v16 = SCPreferencesPathKeyCreateSet(0, *((_QWORD *)set + 2));
  TypeID = CFStringGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && CFEqual(Value, v16))
  {
    v18 = __log_SCNetworkConfiguration();
    v19 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v18, (os_log_type_t)v19))
    {
      v20 = _os_log_pack_size();
      v28 = (char *)block - ((MEMORY[0x1E0C80A78](v20, v21, v22, v23, v24, v25, v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v29 = _os_log_pack_fill();
      v30 = *((_QWORD *)set + 2);
      *(_DWORD *)v29 = 138412290;
      *(_QWORD *)(v29 + 4) = v30;
      __SC_log_send(7, (uint64_t)v18, v19, v28);
    }
    _SCErrorSet(1002);
    CFRelease(v16);
    goto LABEL_21;
  }
  v43 = SCPreferencesPathRemoveValue(*((SCPreferencesRef *)set + 3), v16);
  CFRelease(v16);
  if (v43)
  {
    v45 = __log_SCNetworkConfiguration();
    v46 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v45, (os_log_type_t)v46))
    {
      v47 = _os_log_pack_size();
      v55 = (char *)block - ((MEMORY[0x1E0C80A78](v47, v48, v49, v50, v51, v52, v53, v54) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v56 = _os_log_pack_fill();
      *(_DWORD *)v56 = 138412290;
      *(_QWORD *)(v56 + 4) = set;
      __SC_log_send(7, (uint64_t)v45, v46, v55);
    }
  }
  return v43;
}

uint64_t _SCNetworkSetIsDefault(const __CFBoolean **cf)
{
  uint64_t v2;
  const __CFBoolean *v3;
  CFTypeRef v5;
  const __CFBoolean *v6;
  const __CFString *v7;
  const __CFBoolean **v8;
  uint64_t Value;

  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_17:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!cf)
      goto LABEL_17;
  }
  v2 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_17;
  v3 = cf[6];
  if (v3)
    return CFBooleanGetValue(v3);
  v5 = _SCNetworkSetCopyUserDefinedName(cf);
  v6 = cf[6];
  if (!v6)
  {
    v7 = copy_default_set_name(0);
    if (v5 && CFEqual(v5, v7))
      v8 = (const __CFBoolean **)MEMORY[0x1E0C9AE50];
    else
      v8 = (const __CFBoolean **)MEMORY[0x1E0C9AE40];
    v6 = *v8;
    if (v7)
      CFRelease(v7);
    cf[6] = v6;
  }
  Value = CFBooleanGetValue(v6);
  if (v5)
    CFRelease(v5);
  return Value;
}

CFTypeID SCNetworkSetGetTypeID(void)
{
  if (__SCNetworkSetInitialize_initialized != -1)
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
  return __kSCNetworkSetTypeID;
}

Boolean SCNetworkSetRemoveService(SCNetworkSetRef set, SCNetworkServiceRef service)
{
  uint64_t v4;
  CFTypeID TypeID;
  const __CFString *SetNetworkServiceEntity;
  const __SCNetworkInterface *Interface;
  __CFArray *v8;
  __n128 v9;
  const void *DisablePrivateRelayValue;
  const void *v11;
  const void *DisableUntilNeededValue;
  const void *v13;
  const void *EnableLowDataModeValue;
  const void *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  int v40;
  int v42;
  const __CFArray *v43;
  __n128 v44;
  const __CFArray *v45;
  CFIndex Count;
  CFIndex v47;
  CFIndex v48;
  const __SCNetworkService *ValueAtIndex;
  SCNetworkInterfaceRef v50;
  int v51;
  const __CFArray *v52;
  CFTypeRef v53;
  const void *v54;
  const void *v55;
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  __CFArray *v69;
  int v70;
  CFTypeRef v71;
  uint64_t block;
  uint64_t v73;
  void (*v74)(uint64_t);
  void *v75;
  const char *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!set)
    {
LABEL_26:
      _SCErrorSet(1002);
      LOBYTE(v40) = 0;
      return v40;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!set)
      goto LABEL_26;
  }
  v4 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(set) != v4)
    goto LABEL_26;
  TypeID = SCNetworkServiceGetTypeID();
  if (!service || CFGetTypeID(service) != TypeID || !*((_QWORD *)service + 4))
    goto LABEL_26;
  if (!__SCNetworkSetExists((uint64_t)set))
  {
    v16 = __log_SCNetworkConfiguration();
    v17 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v16, (os_log_type_t)v17))
    {
      v18 = _os_log_pack_size();
      v26 = (char *)&v68 - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v27 = _os_log_pack_fill();
      *(_DWORD *)v27 = 138412546;
      *(_QWORD *)(v27 + 4) = set;
      *(_WORD *)(v27 + 12) = 2112;
      *(_QWORD *)(v27 + 14) = service;
      __SC_log_send(3, (uint64_t)v16, v17, v26);
    }
    block = MEMORY[0x1E0C809B0];
    v73 = 0x40000000;
    v74 = ___SC_crash_once_block_invoke_4;
    v75 = &__block_descriptor_tmp_16;
    v77 = 0;
    v78 = 0;
    v76 = "SCNetworkSetRemoveService() w/removed set";
    if (_SC_crash_once_once_4 == -1)
      goto LABEL_26;
LABEL_75:
    dispatch_once(&_SC_crash_once_once_4, &block);
    goto LABEL_26;
  }
  if (!__SCNetworkServiceExists((uint64_t)service))
  {
    v28 = __log_SCNetworkConfiguration();
    v29 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v28, (os_log_type_t)v29))
    {
      v30 = _os_log_pack_size();
      v38 = (char *)&v68 - ((MEMORY[0x1E0C80A78](v30, v31, v32, v33, v34, v35, v36, v37) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v39 = _os_log_pack_fill();
      *(_DWORD *)v39 = 138412546;
      *(_QWORD *)(v39 + 4) = set;
      *(_WORD *)(v39 + 12) = 2112;
      *(_QWORD *)(v39 + 14) = service;
      __SC_log_send(3, (uint64_t)v28, v29, v38);
    }
    block = MEMORY[0x1E0C809B0];
    v73 = 0x40000000;
    v74 = ___SC_crash_once_block_invoke_4;
    v75 = &__block_descriptor_tmp_16;
    v77 = 0;
    v78 = 0;
    v76 = "SCNetworkSetRemoveService() w/removed service";
    if (_SC_crash_once_once_4 == -1)
      goto LABEL_26;
    goto LABEL_75;
  }
  _serviceOrder_remove(set, service);
  SetNetworkServiceEntity = SCPreferencesPathKeyCreateSetNetworkServiceEntity(0, *((_QWORD *)set + 2), *((_QWORD *)service + 2), 0);
  if (SCPreferencesPathGetLink(*((SCPreferencesRef *)set + 3), SetNetworkServiceEntity))
  {
    Interface = SCNetworkServiceGetInterface(service);
    if (Interface)
    {
      v8 = __SCNetworkInterfaceCopyDeepConfiguration(set, Interface);
      if (v8)
        __SCNetworkInterfaceSetDeepConfiguration(set, Interface, 0, v9);
      DisablePrivateRelayValue = __SCNetworkInterfaceGetDisablePrivateRelayValue((const __SCPreferences **)Interface);
      v11 = DisablePrivateRelayValue;
      if (DisablePrivateRelayValue)
      {
        CFRetain(DisablePrivateRelayValue);
        __SCNetworkInterfaceSetDisablePrivateRelayValue((uint64_t)Interface, 0);
      }
      DisableUntilNeededValue = __SCNetworkInterfaceGetDisableUntilNeededValue((const __SCPreferences **)Interface);
      v13 = DisableUntilNeededValue;
      if (DisableUntilNeededValue)
      {
        CFRetain(DisableUntilNeededValue);
        __SCNetworkInterfaceSetDisableUntilNeededValue((uint64_t)Interface, 0);
      }
      EnableLowDataModeValue = __SCNetworkInterfaceGetEnableLowDataModeValue((const __SCPreferences **)Interface);
      v15 = EnableLowDataModeValue;
      if (EnableLowDataModeValue)
      {
        CFRetain(EnableLowDataModeValue);
        __SCNetworkInterfaceSetEnableLowDataModeValue(Interface, 0);
      }
    }
    else
    {
      v8 = 0;
      v11 = 0;
      v13 = 0;
      v15 = 0;
    }
    v40 = SCPreferencesPathRemoveValue(*((SCPreferencesRef *)set + 3), SetNetworkServiceEntity);
    if (v40)
      v42 = 0;
    else
      v42 = SCError();
    if (v8 || v11 || v13 || v15)
    {
      v70 = v42;
      v71 = v11;
      v43 = SCNetworkSetCopyServices(set);
      if (v43)
      {
        v45 = v43;
        Count = CFArrayGetCount(v43);
        if (Count < 1)
        {
          v51 = 0;
        }
        else
        {
          v47 = Count;
          v69 = v8;
          v48 = 0;
          while (1)
          {
            ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(v45, v48);
            v50 = SCNetworkServiceGetInterface(ValueAtIndex);
            if (v50)
            {
              if (CFEqual(Interface, v50))
                break;
            }
            if (v47 == ++v48)
            {
              v51 = 0;
              goto LABEL_47;
            }
          }
          v51 = 1;
LABEL_47:
          v8 = v69;
        }
        CFRelease(v45);
      }
      else
      {
        v51 = 0;
      }
      if (v8)
      {
        if (v51)
          v52 = v8;
        else
          v52 = 0;
        __SCNetworkInterfaceSetDeepConfiguration(set, Interface, v52, v44);
        CFRelease(v8);
      }
      if (v71)
      {
        if (v51)
          v53 = v71;
        else
          v53 = 0;
        __SCNetworkInterfaceSetDisablePrivateRelayValue((uint64_t)Interface, v53);
        CFRelease(v71);
      }
      if (v13)
      {
        if (v51)
          v54 = v13;
        else
          v54 = 0;
        __SCNetworkInterfaceSetDisableUntilNeededValue((uint64_t)Interface, v54);
        CFRelease(v13);
      }
      v42 = v70;
      if (v15)
      {
        if (v51)
          v55 = v15;
        else
          v55 = 0;
        __SCNetworkInterfaceSetEnableLowDataModeValue(Interface, v55);
        CFRelease(v15);
      }
    }
    CFRelease(SetNetworkServiceEntity);
    if (!v40)
    {
      _SCErrorSet(v42);
      return v40;
    }
  }
  else
  {
    CFRelease(SetNetworkServiceEntity);
    LOBYTE(v40) = 1;
  }
  v56 = __log_SCNetworkConfiguration();
  v57 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v56, (os_log_type_t)v57))
  {
    v58 = _os_log_pack_size();
    v66 = (char *)&v68 - ((MEMORY[0x1E0C80A78](v58, v59, v60, v61, v62, v63, v64, v65) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v67 = _os_log_pack_fill();
    *(_DWORD *)v67 = 138412546;
    *(_QWORD *)(v67 + 4) = set;
    *(_WORD *)(v67 + 12) = 2112;
    *(_QWORD *)(v67 + 14) = service;
    __SC_log_send(7, (uint64_t)v56, v57, v66);
  }
  return v40;
}

void _serviceOrder_remove(const __SCNetworkSet *a1, const __SCNetworkService *a2)
{
  const __CFArray *ServiceOrder;
  const __CFArray *MutableCopy;
  CFStringRef ServiceID;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  ServiceOrder = SCNetworkSetGetServiceOrder(a1);
  if (ServiceOrder)
  {
    MutableCopy = CFArrayCreateMutableCopy(0, 0, ServiceOrder);
    ServiceID = SCNetworkServiceGetServiceID(a2);
    v7 = _serviceOrder_clear(MutableCopy, ServiceID);
    if (v7 >= 2)
    {
      v8 = v7;
      v9 = __log_SCNetworkConfiguration();
      v10 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v9, (os_log_type_t)v10))
      {
        v11 = _os_log_pack_size();
        v19 = (char *)v21 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v20 = _os_log_pack_fill();
        *(_DWORD *)v20 = 138412546;
        *(_QWORD *)(v20 + 4) = a2;
        *(_WORD *)(v20 + 12) = 2048;
        *(_QWORD *)(v20 + 14) = v8;
        __SC_log_send(3, (uint64_t)v9, v10, v19);
      }
    }
    SCNetworkSetSetServiceOrder(a1, MutableCopy);
    CFRelease(MutableCopy);
  }
}

Boolean SCNetworkSetSetServiceOrder(SCNetworkSetRef set, CFArrayRef newOrder)
{
  uint64_t v4;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const void *ValueAtIndex;
  CFTypeID v10;
  const __CFString *SetNetworkGlobalEntity;
  const __CFString *v12;
  const __CFDictionary *Value;
  __CFDictionary *MutableCopy;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  Boolean v27;
  const __CFArray *Mutable;
  CFIndex v30;
  __int128 v31;
  CFIndex v32;
  CFIndex v33;
  CFIndex v34;
  const void *v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  CFIndex v48;
  const __CFDictionary *v49;
  const __CFString *v50;
  CFIndex v51;
  const __SCPreferences *v52;
  Boolean v53;
  CFMutableDictionaryRef v54;
  const __CFString *v55;
  __int128 v56;
  CFMutableDictionaryRef *v57;
  _QWORD block[8];
  CFRange v59;

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!set)
      goto LABEL_19;
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!set)
      goto LABEL_19;
  }
  v4 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(set) != v4)
    goto LABEL_19;
  if (!__SCNetworkSetExists((uint64_t)set))
  {
    v15 = __log_SCNetworkConfiguration();
    v16 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v15, (os_log_type_t)v16))
    {
      v17 = _os_log_pack_size();
      v25 = (char *)&v54 - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v26 = _os_log_pack_fill();
      *(_DWORD *)v26 = 138412290;
      *(_QWORD *)(v26 + 4) = set;
      __SC_log_send(3, (uint64_t)v15, v16, v25);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_4;
    block[3] = &__block_descriptor_tmp_16;
    block[5] = 0;
    block[6] = 0;
    block[4] = "SCNetworkSetSetServiceOrder() w/removed set";
    if (_SC_crash_once_once_4 != -1)
      dispatch_once(&_SC_crash_once_once_4, block);
    goto LABEL_19;
  }
  TypeID = CFArrayGetTypeID();
  if (!newOrder || CFGetTypeID(newOrder) != TypeID)
  {
LABEL_19:
    _SCErrorSet(1002);
    return 0;
  }
  Count = CFArrayGetCount(newOrder);
  if (Count >= 1)
  {
    v7 = Count;
    v8 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(newOrder, v8);
      v10 = CFStringGetTypeID();
      if (!ValueAtIndex || CFGetTypeID(ValueAtIndex) != v10)
        goto LABEL_19;
    }
    while (v7 != ++v8);
  }
  SetNetworkGlobalEntity = SCPreferencesPathKeyCreateSetNetworkGlobalEntity(0, *((_QWORD *)set + 2), (uint64_t)CFSTR("IPv4"));
  if (!SetNetworkGlobalEntity)
    return 0;
  v12 = SetNetworkGlobalEntity;
  Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)set + 3), SetNetworkGlobalEntity);
  v55 = v12;
  if (Value)
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
  else
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v54 = MutableCopy;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v30 = CFArrayGetCount(newOrder);
  if (v30 >= 1)
  {
    v32 = v30;
    v33 = 0;
    *(_QWORD *)&v31 = 138412290;
    v56 = v31;
    do
    {
      v34 = CFArrayGetCount(Mutable);
      v35 = CFArrayGetValueAtIndex(newOrder, v33);
      if (v34 && (v59.location = 0, v59.length = v34, CFArrayContainsValue(Mutable, v59, v35)))
      {
        v36 = __log_SCNetworkConfiguration();
        v37 = _SC_syslog_os_log_mapping(3);
        if (__SC_log_enabled(3, v36, (os_log_type_t)v37))
        {
          v38 = _os_log_pack_size();
          v57 = &v54;
          v46 = (char *)&v54
              - ((MEMORY[0x1E0C80A78](v38, v39, v40, v41, v42, v43, v44, v45) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v47 = _os_log_pack_fill();
          *(_DWORD *)v47 = v56;
          *(_QWORD *)(v47 + 4) = v35;
          __SC_log_send(3, (uint64_t)v36, v37, v46);
        }
      }
      else
      {
        CFArrayAppendValue(Mutable, v35);
      }
      ++v33;
    }
    while (v32 != v33);
  }
  v48 = CFArrayGetCount(Mutable);
  v49 = v54;
  if (v48 < 1)
    CFDictionaryRemoveValue(v54, CFSTR("ServiceOrder"));
  else
    CFDictionarySetValue(v54, CFSTR("ServiceOrder"), Mutable);
  v50 = v55;
  CFRelease(Mutable);
  v51 = CFDictionaryGetCount(v49);
  v52 = (const __SCPreferences *)*((_QWORD *)set + 3);
  if (v51 < 1)
    v53 = SCPreferencesPathRemoveValue(v52, v50);
  else
    v53 = SCPreferencesPathSetValue(v52, v50, v49);
  v27 = v53;
  CFRelease(v49);
  CFRelease(v50);
  return v27;
}

CFComparisonResult _SCNetworkSetCompare(const __SCNetworkSet *a1, const __SCNetworkSet *a2)
{
  CFStringRef Name;
  CFStringRef v5;
  const __CFString *v6;
  const __CFString *v7;
  CFStringRef SetID;

  Name = SCNetworkSetGetName(a1);
  v5 = SCNetworkSetGetName(a2);
  v6 = v5;
  if (Name)
  {
    if (!v5)
      return -1;
    v7 = Name;
  }
  else
  {
    if (v5)
      return 1;
    SetID = SCNetworkSetGetSetID(a1);
    v6 = SCNetworkSetGetSetID(a2);
    v7 = SetID;
  }
  return CFStringCompare(v7, v6, 0);
}

uint64_t SCNetworkSetEstablishDefaultConfiguration(const __SCPreferences **cf)
{
  uint64_t v2;
  __CFArray *v3;
  __CFArray *v4;
  uint64_t v5;

  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_7:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!cf)
      goto LABEL_7;
  }
  v2 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_7;
  v3 = _SCNetworkInterfaceCopyAllWithPreferences(cf[3]);
  if (v3)
  {
    v4 = v3;
    v5 = __SCNetworkSetEstablishDefaultConfigurationForInterfaces((uint64_t)cf, v3, 1);
    CFRelease(v4);
    return v5;
  }
  return 0;
}

uint64_t __SCNetworkSetEstablishDefaultConfigurationForInterfaces(uint64_t a1, const __CFArray *a2, int a3)
{
  uint64_t v5;
  const __CFArray *v6;
  const __CFArray *v7;
  const __CFArray *v8;
  const __CFArray *v9;
  CFIndex Count;
  const void *ValueAtIndex;
  const __CFArray *v12;
  CFArrayRef v13;
  CFArrayRef v14;
  const __SCPreferences *v15;
  __CFSet *Mutable;
  const __CFArray *v17;
  const __CFArray *v18;
  int v19;
  CFIndex v20;
  __int128 v21;
  CFIndex v22;
  CFIndex v23;
  const void *v24;
  const void *v25;
  const void *ConfigurationAction;
  CFTypeID TypeID;
  __CFArray *v28;
  const __SCNetworkInterface *v29;
  const __CFArray *SupportedProtocolTypes;
  const __SCNetworkService *v31;
  const __SCNetworkService *v32;
  int v33;
  const __CFArray *SupportedInterfaceTypes;
  const __CFArray *v35;
  CFIndex v36;
  CFIndex v37;
  CFIndex i;
  const __CFString *v39;
  SCNetworkInterfaceRef v40;
  SCNetworkInterfaceRef v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  CFStringRef LocalizedDisplayName;
  int v55;
  const char *v56;
  NSObject *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  CFStringRef v70;
  int v71;
  const char *v72;
  int v73;
  CFArrayRef v74;
  const __CFArray *v75;
  CFIndex v76;
  CFIndex v77;
  CFIndex j;
  const __SCNetworkService *v79;
  const void *v80;
  _QWORD v82[2];
  __int128 v83;
  const __CFArray *v84;
  int v85;
  CFArrayRef v86;
  uint64_t v87;
  int v88;
  CFArrayRef v89;
  uint64_t v90;

  v5 = a1;
  v90 = *MEMORY[0x1E0C80C00];
  v6 = SCNetworkSetCopyAll(*(SCPreferencesRef *)(a1 + 24));
  if (v6)
  {
    v7 = v6;
    if (CFArrayGetCount(v6) != 1
      || (v8 = SCNetworkSetCopyServices((SCNetworkSetRef)v5)) != 0
      && (v9 = v8, Count = CFArrayGetCount(v8), CFRelease(v9), Count)
      || (ValueAtIndex = CFArrayGetValueAtIndex(v7, 0), !CFEqual((CFTypeRef)v5, ValueAtIndex)))
    {
      v12 = 0;
    }
    else
    {
      v12 = SCNetworkServiceCopyAll(*(SCPreferencesRef *)(v5 + 24));
    }
    CFRelease(v7);
  }
  else
  {
    v12 = 0;
  }
  v13 = SCNetworkSetCopyServices((SCNetworkSetRef)v5);
  v14 = v13;
  v86 = v12;
  if (v13 && *(_BYTE *)(v5 + 40))
  {
    CFRelease(v13);
    v14 = SCNetworkServiceCopyAll(*(SCPreferencesRef *)(v5 + 24));
  }
  v15 = *(const __SCPreferences **)(v5 + 24);
  Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  v17 = (const __CFArray *)SCBridgeInterfaceCopyAll(v15);
  if (v17)
  {
    v18 = v17;
    __SCBridgeInterfaceListCollectMembers(v17, Mutable, 0);
    CFRelease(v18);
  }
  v88 = 0;
  v19 = 1;
  v89 = v14;
  if (a2 && v14)
  {
    v20 = CFArrayGetCount(a2);
    if (v20 < 1)
    {
      v73 = 0;
      v74 = v89;
      goto LABEL_54;
    }
    v22 = v20;
    v23 = 0;
    v88 = 0;
    *(_QWORD *)&v21 = 138412546;
    v83 = v21;
    v87 = v5;
    v85 = a3;
    v84 = a2;
    do
    {
      v24 = CFArrayGetValueAtIndex(a2, v23);
      v25 = v24;
      if (!a3
        || (ConfigurationAction = (const void *)_SCNetworkInterfaceGetConfigurationAction((uint64_t)v24),
            TypeID = CFStringGetTypeID(),
            !ConfigurationAction)
        || CFGetTypeID(ConfigurationAction) != TypeID
        || !CFEqual(ConfigurationAction, CFSTR("None")))
      {
        if (!CFSetContainsValue(Mutable, v25) && !__SCNetworkServiceExistsForInterface(v89, v25))
        {
          v28 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
          CFArrayAppendValue(v28, v25);
          if (v19)
          {
            while (CFArrayGetCount(v28) >= 1)
            {
              v29 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v28, 0);
              SupportedProtocolTypes = SCNetworkInterfaceGetSupportedProtocolTypes(v29);
              if (SupportedProtocolTypes && CFArrayGetCount(SupportedProtocolTypes) >= 1)
              {
                v31 = SCNetworkServiceCreate(*(SCPreferencesRef *)(v5 + 24), v29);
                if (!v31)
                {
                  v42 = __log_SCNetworkConfiguration();
                  v43 = _SC_syslog_os_log_mapping(3);
                  if (__SC_log_enabled(3, v42, (os_log_type_t)v43))
                  {
                    v44 = _os_log_pack_size();
                    v52 = (char *)v82
                        - ((MEMORY[0x1E0C80A78](v44, v45, v46, v47, v48, v49, v50, v51) + 15) & 0xFFFFFFFFFFFFFFF0);
                    __error();
                    v53 = _os_log_pack_fill();
                    LocalizedDisplayName = SCNetworkInterfaceGetLocalizedDisplayName(v29);
                    v55 = SCError();
                    v56 = SCErrorString(v55);
                    *(_DWORD *)v53 = v83;
                    *(_QWORD *)(v53 + 4) = LocalizedDisplayName;
                    *(_WORD *)(v53 + 12) = 2080;
                    *(_QWORD *)(v53 + 14) = v56;
                    __SC_log_send(3, (uint64_t)v42, v43, v52);
                    v5 = v87;
                  }
                  goto LABEL_48;
                }
                v32 = v31;
                if (!SCNetworkServiceEstablishDefaultConfiguration(v31))
                {
                  v57 = __log_SCNetworkConfiguration();
                  v58 = _SC_syslog_os_log_mapping(3);
                  if (__SC_log_enabled(3, v57, (os_log_type_t)v58))
                  {
LABEL_46:
                    v59 = (uint64_t)v57;
                    v60 = _os_log_pack_size();
                    v82[1] = v82;
                    v68 = (char *)v82
                        - ((MEMORY[0x1E0C80A78](v60, v61, v62, v63, v64, v65, v66, v67) + 15) & 0xFFFFFFFFFFFFFFF0);
                    __error();
                    v69 = _os_log_pack_fill();
                    v70 = SCNetworkInterfaceGetLocalizedDisplayName(v29);
                    v71 = SCError();
                    v72 = SCErrorString(v71);
                    *(_DWORD *)v69 = v83;
                    *(_QWORD *)(v69 + 4) = v70;
                    *(_WORD *)(v69 + 12) = 2080;
                    *(_QWORD *)(v69 + 14) = v72;
                    __SC_log_send(3, v59, v58, v68);
                    v5 = v87;
                  }
LABEL_47:
                  SCNetworkServiceRemove(v32);
                  CFRelease(v32);
LABEL_48:
                  CFArrayRemoveValueAtIndex(v28, 0);
                  v19 = 0;
                  break;
                }
                v33 = SCNetworkSetAddService((SCNetworkSetRef)v5, v32);
                if (!v33)
                {
                  v57 = __log_SCNetworkConfiguration();
                  v58 = _SC_syslog_os_log_mapping(3);
                  if (__SC_log_enabled(3, v57, (os_log_type_t)v58))
                    goto LABEL_46;
                  goto LABEL_47;
                }
                v19 = v33;
                CFRelease(v32);
                v88 = 1;
              }
              else
              {
                SupportedInterfaceTypes = SCNetworkInterfaceGetSupportedInterfaceTypes(v29);
                if (SupportedInterfaceTypes)
                {
                  v35 = SupportedInterfaceTypes;
                  v36 = CFArrayGetCount(SupportedInterfaceTypes);
                  if (v36 >= 1)
                  {
                    v37 = v36;
                    for (i = 0; i != v37; ++i)
                    {
                      v39 = (const __CFString *)CFArrayGetValueAtIndex(v35, i);
                      v40 = SCNetworkInterfaceCreateWithInterface(v29, v39);
                      if (v40)
                      {
                        v41 = v40;
                        CFArrayAppendValue(v28, v40);
                        CFRelease(v41);
                      }
                    }
                    v5 = v87;
                  }
                }
              }
              CFArrayRemoveValueAtIndex(v28, 0);
            }
          }
          CFRelease(v28);
          a3 = v85;
          a2 = v84;
        }
      }
      ++v23;
    }
    while (v23 != v22);
  }
  v73 = v88;
  v74 = v89;
  if (v89)
LABEL_54:
    CFRelease(v74);
  CFRelease(Mutable);
  v75 = v86;
  if (v86)
  {
    if (v19)
    {
      if (v73)
      {
        v76 = CFArrayGetCount(v86);
        if (v76 >= 1)
        {
          v77 = v76;
          for (j = 0; j != v77; ++j)
          {
            v79 = (const __SCNetworkService *)CFArrayGetValueAtIndex(v75, j);
            if (_SCNetworkServiceIsVPN(v79))
            {
              v19 = SCNetworkSetAddService((SCNetworkSetRef)v5, v79);
              if (!v19)
                break;
            }
          }
        }
      }
    }
    CFRelease(v75);
  }
  if (v19)
  {
    if (v73)
    {
      if (!SCPreferencesGetValue(*(SCPreferencesRef *)(v5 + 24), CFSTR("Model")))
      {
        v80 = (const void *)_SC_hw_model(0);
        SCPreferencesSetValue(*(SCPreferencesRef *)(v5 + 24), CFSTR("Model"), v80);
      }
    }
    else
    {
      _SCErrorSet(0);
    }
  }
  return v73;
}

uint64_t SCNetworkSetEstablishDefaultInterfaceConfiguration(CFTypeRef cf, const void *a2)
{
  uint64_t v4;
  CFTypeID TypeID;
  const __CFArray *v6;
  const __CFArray *v7;
  uint64_t v8;
  const void *v10[2];

  v10[1] = *(const void **)MEMORY[0x1E0C80C00];
  v10[0] = a2;
  if (__SCNetworkSetInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (cf)
      goto LABEL_3;
LABEL_9:
    _SCErrorSet(1002);
    return 0;
  }
  if (!cf)
    goto LABEL_9;
LABEL_3:
  v4 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(cf) != v4)
    goto LABEL_9;
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
    goto LABEL_9;
  v6 = CFArrayCreate(0, v10, 1, MEMORY[0x1E0C9B378]);
  if (!v6)
    SCNetworkSetEstablishDefaultInterfaceConfiguration_cold_1();
  v7 = v6;
  v8 = __SCNetworkSetEstablishDefaultConfigurationForInterfaces((uint64_t)cf, v6, 0);
  CFRelease(v7);
  return v8;
}

__CFArray *SCNetworkSetCopySelectedVPNService(CFTypeRef cf)
{
  uint64_t v2;
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  __CFArray *Mutable;
  const CFArrayCallBacks *v9;
  const void *ValueAtIndex;
  CFIndex v11;
  CFIndex v12;
  CFArrayRef ServiceOrder;
  const __CFArray *MutableCopy;
  CFPropertyListRef v15;
  const void *v16;
  CFIndex v17;
  CFStringRef ServiceID;
  CFRange v20;

  if (__SCNetworkSetInitialize_initialized == -1)
  {
    if (!cf)
    {
LABEL_27:
      _SCErrorSet(1002);
      return 0;
    }
  }
  else
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (!cf)
      goto LABEL_27;
  }
  v2 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(cf) != v2)
    goto LABEL_27;
  v3 = SCNetworkSetCopyServices((SCNetworkSetRef)cf);
  if (!v3)
    return 0;
  v4 = v3;
  Count = CFArrayGetCount(v3);
  if (Count < 1)
  {
    CFRelease(v4);
    return 0;
  }
  v6 = Count;
  v7 = 0;
  Mutable = 0;
  v9 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v4, v7);
    if (SCNetworkServiceGetEnabled((SCNetworkServiceRef)ValueAtIndex)
      && _SCNetworkServiceIsVPN((const __SCNetworkService *)ValueAtIndex))
    {
      if (!Mutable)
        Mutable = CFArrayCreateMutable(0, 0, v9);
      CFArrayAppendValue(Mutable, ValueAtIndex);
    }
    ++v7;
  }
  while (v6 != v7);
  CFRelease(v4);
  if (Mutable)
  {
    v11 = CFArrayGetCount(Mutable);
    if (v11 < 2)
    {
      MutableCopy = Mutable;
    }
    else
    {
      v12 = v11;
      ServiceOrder = SCNetworkSetGetServiceOrder((SCNetworkSetRef)cf);
      MutableCopy = CFArrayCreateMutableCopy(0, 0, Mutable);
      v20.length = CFArrayGetCount(MutableCopy);
      v20.location = 0;
      CFArraySortValues(MutableCopy, v20, (CFComparatorFunction)_SCNetworkServiceCompare, ServiceOrder);
      CFRelease(Mutable);
      CFPreferencesAppSynchronize(CFSTR("com.apple.mobilevpn"));
      v15 = CFPreferencesCopyAppValue(CFSTR("activeVPNID"), CFSTR("com.apple.mobilevpn"));
      if (v15)
      {
        v16 = v15;
        v17 = 0;
        while (1)
        {
          Mutable = (__CFArray *)CFArrayGetValueAtIndex(MutableCopy, v17);
          ServiceID = SCNetworkServiceGetServiceID(Mutable);
          if (CFEqual(ServiceID, v16))
            break;
          if (v12 == ++v17)
          {
            CFRelease(v16);
            goto LABEL_22;
          }
        }
        CFRetain(Mutable);
        CFRelease(v16);
        if (Mutable)
          goto LABEL_23;
      }
    }
LABEL_22:
    Mutable = (__CFArray *)CFArrayGetValueAtIndex(MutableCopy, 0);
    CFRetain(Mutable);
LABEL_23:
    CFRelease(MutableCopy);
  }
  return Mutable;
}

uint64_t SCNetworkSetSetSelectedVPNService(CFTypeRef cf, const void *a2)
{
  uint64_t v4;
  CFTypeID TypeID;
  const __CFArray *v6;
  const __CFArray *v7;
  uint64_t Count;
  uint64_t v9;
  int v10;
  const void *ValueAtIndex;
  Boolean v12;
  CFRange v15;

  if (__SCNetworkSetInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (cf)
      goto LABEL_3;
LABEL_21:
    _SCErrorSet(1002);
    LOBYTE(v10) = 0;
    return v10;
  }
  if (!cf)
    goto LABEL_21;
LABEL_3:
  v4 = __kSCNetworkSetTypeID;
  if (CFGetTypeID(cf) != v4)
    goto LABEL_21;
  TypeID = SCNetworkServiceGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID || !_SCNetworkServiceIsVPN((const __SCNetworkService *)a2))
    goto LABEL_21;
  v6 = SCNetworkSetCopyServices((SCNetworkSetRef)cf);
  if (v6)
  {
    v7 = v6;
    Count = CFArrayGetCount(v6);
    v15.location = 0;
    v15.length = Count;
    if (CFArrayContainsValue(v7, v15, a2))
    {
      if (Count < 1)
      {
        LOBYTE(v10) = 1;
      }
      else
      {
        v9 = 1;
        v10 = 1;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v7, v9 - 1);
          if (_SCNetworkServiceIsVPN((const __SCNetworkService *)ValueAtIndex))
          {
            v12 = CFEqual(a2, ValueAtIndex);
            v10 = SCNetworkServiceSetEnabled((SCNetworkServiceRef)ValueAtIndex, v12);
          }
          if (!v10)
            break;
        }
        while (v9++ < Count);
      }
    }
    else
    {
      _SCErrorSet(1002);
      LOBYTE(v10) = 0;
    }
    CFRelease(v7);
  }
  else
  {
    LOBYTE(v10) = 1;
  }
  return v10;
}

uint64_t _SCNetworkSetSetSetID(uint64_t cf, const void *a2)
{
  uint64_t v4;
  CFTypeID TypeID;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  const __CFString *Set;
  CFDictionaryRef Value;
  CFTypeID v22;
  const __CFString *v23;
  const __CFDictionary *v24;
  CFTypeID v25;
  SCNetworkSetRef v26;
  SCNetworkSetRef v27;
  _BOOL4 v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  _QWORD v41[2];
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (__SCNetworkSetInitialize_initialized != -1)
  {
    dispatch_once(&__SCNetworkSetInitialize_initialized, &__block_literal_global_44_0);
    if (cf)
      goto LABEL_3;
LABEL_13:
    _SCErrorSet(1002);
    return 0;
  }
  if (!cf)
    goto LABEL_13;
LABEL_3:
  v4 = __kSCNetworkSetTypeID;
  if (CFGetTypeID((CFTypeRef)cf) != v4)
    goto LABEL_13;
  TypeID = CFStringGetTypeID();
  if (!a2 || CFGetTypeID(a2) != TypeID)
    goto LABEL_13;
  if (!__SCNetworkSetExists(cf))
  {
    v7 = __log_SCNetworkConfiguration();
    v8 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v7, (os_log_type_t)v8))
    {
      v9 = _os_log_pack_size();
      v17 = (char *)v41 - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v18 = _os_log_pack_fill();
      *(_DWORD *)v18 = 138412546;
      *(_QWORD *)(v18 + 4) = cf;
      *(_WORD *)(v18 + 12) = 2112;
      *(_QWORD *)(v18 + 14) = a2;
      __SC_log_send(3, (uint64_t)v7, v8, v17);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SC_crash_once_block_invoke_4;
    block[3] = &__block_descriptor_tmp_16;
    block[5] = 0;
    block[6] = 0;
    block[4] = "_SCNetworkSetSetSetID() w/removed set";
    if (_SC_crash_once_once_4 != -1)
      dispatch_once(&_SC_crash_once_once_4, block);
    goto LABEL_13;
  }
  if (CFEqual(a2, *(CFTypeRef *)(cf + 16)))
    return 1;
  Set = SCPreferencesPathKeyCreateSet(0, (uint64_t)a2);
  Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(cf + 24), Set);
  v22 = CFDictionaryGetTypeID();
  if (!Value || CFGetTypeID(Value) != v22)
  {
    v23 = SCPreferencesPathKeyCreateSet(0, *(_QWORD *)(cf + 16));
    v24 = SCPreferencesPathGetValue(*(SCPreferencesRef *)(cf + 24), v23);
    v25 = CFDictionaryGetTypeID();
    if (v24 && CFGetTypeID(v24) == v25)
    {
      if (SCPreferencesPathSetValue(*(SCPreferencesRef *)(cf + 24), Set, v24))
      {
        v6 = SCPreferencesPathRemoveValue(*(SCPreferencesRef *)(cf + 24), v23);
        if ((_DWORD)v6)
        {
          v26 = SCNetworkSetCopyCurrent(*(SCPreferencesRef *)(cf + 24));
          if (v26)
          {
            v27 = v26;
            v28 = CFEqual(*((CFTypeRef *)v26 + 2), *(CFTypeRef *)(cf + 16)) != 0;
            CFRelease(v27);
          }
          else
          {
            v28 = 0;
          }
          v29 = __log_SCNetworkConfiguration();
          v30 = _SC_syslog_os_log_mapping(7);
          if (__SC_log_enabled(7, v29, (os_log_type_t)v30))
          {
            v31 = _os_log_pack_size();
            v41[1] = v41;
            v39 = (char *)v41
                - ((MEMORY[0x1E0C80A78](v31, v32, v33, v34, v35, v36, v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v40 = _os_log_pack_fill();
            *(_DWORD *)v40 = 138412546;
            *(_QWORD *)(v40 + 4) = cf;
            *(_WORD *)(v40 + 12) = 2112;
            *(_QWORD *)(v40 + 14) = a2;
            __SC_log_send(7, (uint64_t)v29, v30, v39);
          }
          CFRetain(a2);
          CFRelease(*(CFTypeRef *)(cf + 16));
          *(_QWORD *)(cf + 16) = a2;
          if (v28)
            SCNetworkSetSetCurrent((SCNetworkSetRef)cf);
        }
        goto LABEL_26;
      }
    }
    else
    {
      _SCErrorSet(1004);
    }
    v6 = 0;
LABEL_26:
    if (v23)
      CFRelease(v23);
    goto LABEL_28;
  }
  _SCErrorSet(1005);
  v6 = 0;
LABEL_28:
  if (Set)
    CFRelease(Set);
  return v6;
}

uint64_t _serviceOrder(const __SCNetworkService *a1)
{
  uint64_t v2;
  SCNetworkInterfaceRef Interface;
  _BYTE *v4;

  v2 = 100000;
  Interface = SCNetworkServiceGetInterface(a1);
  if (Interface)
  {
    v4 = Interface;
    if (!_SCNetworkServiceIsVPN(a1))
      return (int)__SCNetworkInterfaceOrder(v4);
  }
  return v2;
}

uint64_t _serviceOrder_clear(const __CFArray *a1, const void *a2)
{
  CFIndex Count;
  CFIndex v5;
  uint64_t v6;
  CFIndex v7;
  const void *ValueAtIndex;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v5 = Count;
  v6 = 0;
  v7 = 0;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(a1, v7);
    if (CFEqual(ValueAtIndex, a2))
    {
      CFArrayRemoveValueAtIndex(a1, v7);
      --v5;
      ++v6;
    }
    else
    {
      ++v7;
    }
  }
  while (v7 < v5);
  return v6;
}

uint64_t __copy_default_set_name_block_invoke()
{
  uint64_t result;

  result = _SC_CFBundleGet();
  if (result)
  {
    result = CFBundleCopyLocalizedStringForLocalization();
    copy_default_set_name_non_localized = result;
  }
  return result;
}

__CFBundle *__copy_default_set_name_block_invoke_2()
{
  __CFBundle *result;

  result = (__CFBundle *)_SC_CFBundleGet();
  if (result)
  {
    result = (__CFBundle *)CFBundleCopyLocalizedString(result, CFSTR("DEFAULT_SET_NAME"), CFSTR("Automatic"), 0);
    copy_default_set_name_localized = (uint64_t)result;
  }
  return result;
}

BOOL __SCNetworkSetEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
    return 1;
  if (*(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24))
    return CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16)) != 0;
  return 0;
}

CFHashCode __SCNetworkSetHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 16));
}

__CFString *__SCNetworkSetCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCNetworkSet %p [%p]> {"), a1, v2);
  CFStringAppendFormat(Mutable, 0, CFSTR("id = %@"), *(_QWORD *)(a1 + 16));
  CFStringAppendFormat(Mutable, 0, CFSTR(", prefs = %p"), *(_QWORD *)(a1 + 24));
  if (*(_QWORD *)(a1 + 32))
    CFStringAppendFormat(Mutable, 0, CFSTR(", name = %@"), *(_QWORD *)(a1 + 32));
  if (*(_BYTE *)(a1 + 40))
    CFStringAppendFormat(Mutable, 0, CFSTR(", new"));
  if (!__SCNetworkSetExists(a1))
    CFStringAppendFormat(Mutable, 0, CFSTR(", REMOVED"));
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  return Mutable;
}

__CFArray *_SCNetworkConfigurationCopyMigrationPaths()
{
  __CFArray *Mutable;
  void *v1;
  const void *v2;
  void *value;
  void *v5[2];

  v5[1] = *(void **)MEMORY[0x1E0C80C00];
  value = 0;
  v5[0] = 0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  _SCNetworkConfigurationCopyMigrationPathsWithBaseURL(0, &value, v5);
  v1 = value;
  CFArrayAppendValue(Mutable, value);
  v2 = v5[0];
  CFArrayAppendValue(Mutable, v5[0]);
  CFRelease(v1);
  CFRelease(v2);
  return Mutable;
}

void _SCNetworkConfigurationCopyMigrationPathsWithBaseURL(const __CFURL *a1, _QWORD *a2, _QWORD *a3)
{
  CFURLRef v5;

  if (a1)
  {
    v5 = a1;
    CFRetain(a1);
  }
  else
  {
    v5 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)"/Library/Preferences/SystemConfiguration", 40, 1u);
  }
  *a2 = MEMORY[0x18D78C2DC](0, "preferences.plist", 17, 0, v5);
  *a3 = MEMORY[0x18D78C2DC](0, "NetworkInterfaces.plist", 23, 0, v5);
  CFRelease(v5);
}

__CFArray *_SCNetworkConfigurationPerformMigration(const __CFURL *a1, uint64_t a2, const __CFURL *a3, const __CFString *a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  int isInstallEnvironment;
  const char *v21;
  const __CFString *v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  CFURLRef v48;
  CFURLRef v49;
  CFTypeRef v50;
  NSObject *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  __CFArray *v71;
  const void *v73;
  CFTypeRef v74;
  const void *v75;
  NSObject *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  BOOL v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  NSObject *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  char *v110;
  uint64_t v111;
  NSObject *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  char *v122;
  NSObject *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  char *v133;
  NSObject *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  char *v144;
  uint64_t v145;
  int v146;
  const char *v147;
  _QWORD v148[2];

  v148[1] = *MEMORY[0x1E0C80C00];
  v8 = __log_SCNetworkConfiguration();
  v9 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v8, (os_log_type_t)v9))
  {
    v10 = _os_log_pack_size();
    v18 = (char *)v148 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v19 = _os_log_pack_fill();
    isInstallEnvironment = _SC_isInstallEnvironment();
    v21 = " (INSTALLER ENVIRONMENT)";
    *(_DWORD *)v19 = 136316162;
    if (!isInstallEnvironment)
      v21 = "";
    *(_QWORD *)(v19 + 4) = v21;
    *(_WORD *)(v19 + 12) = 2112;
    *(_QWORD *)(v19 + 14) = a1;
    v22 = CFSTR("None");
    *(_WORD *)(v19 + 22) = 2112;
    if (a4)
      v22 = a4;
    *(_QWORD *)(v19 + 24) = a2;
    *(_WORD *)(v19 + 32) = 2112;
    *(_QWORD *)(v19 + 34) = a3;
    *(_WORD *)(v19 + 42) = 2112;
    *(_QWORD *)(v19 + 44) = v22;
    __SC_log_send(6, (uint64_t)v8, v9, v18);
  }
  if (a1 && !CFURLHasDirectoryPath(a1))
  {
    v34 = __log_SCNetworkConfiguration();
    v35 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v34, (os_log_type_t)v35))
    {
      v36 = _os_log_pack_size();
      v44 = (char *)v148 - ((MEMORY[0x1E0C80A78](v36, v37, v38, v39, v40, v41, v42, v43) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v45 = _os_log_pack_fill();
      *(_DWORD *)v45 = 138412290;
      *(_QWORD *)(v45 + 4) = a1;
      v46 = (uint64_t)v34;
      v47 = v35;
LABEL_25:
      __SC_log_send(5, v46, v47, v44);
      return 0;
    }
    return 0;
  }
  if (a2 && !CFURLHasDirectoryPath((CFURLRef)a2))
  {
    v51 = __log_SCNetworkConfiguration();
    v52 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v51, (os_log_type_t)v52))
    {
      v53 = _os_log_pack_size();
      v44 = (char *)v148 - ((MEMORY[0x1E0C80A78](v53, v54, v55, v56, v57, v58, v59, v60) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v61 = _os_log_pack_fill();
      *(_DWORD *)v61 = 138412290;
      *(_QWORD *)(v61 + 4) = a2;
LABEL_24:
      v46 = (uint64_t)v51;
      v47 = v52;
      goto LABEL_25;
    }
    return 0;
  }
  if (a3 && !CFURLHasDirectoryPath(a3))
  {
    v51 = __log_SCNetworkConfiguration();
    v52 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v51, (os_log_type_t)v52))
    {
      v62 = _os_log_pack_size();
      v44 = (char *)v148 - ((MEMORY[0x1E0C80A78](v62, v63, v64, v65, v66, v67, v68, v69) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v70 = _os_log_pack_fill();
      *(_DWORD *)v70 = 138412290;
      *(_QWORD *)(v70 + 4) = a3;
      goto LABEL_24;
    }
    return 0;
  }
  if (!((unint64_t)a1 | a2))
  {
    v23 = __log_SCNetworkConfiguration();
    v24 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v23, (os_log_type_t)v24))
    {
      v25 = _os_log_pack_size();
      v33 = (char *)v148 - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v23, v24, v33);
    }
    return 0;
  }
  v48 = CFURLCreateWithString(0, CFSTR("/Library/Preferences/SystemConfiguration"), 0);
  v49 = v48;
  if (a1)
    v50 = (CFTypeRef)MEMORY[0x18D78C2F4](0, CFSTR("Library/Preferences/SystemConfiguration/"), 0, 1, a1);
  else
    v50 = CFRetain(v48);
  v73 = v50;
  if (a2)
    a2 = MEMORY[0x18D78C2F4](0, CFSTR("Library/Preferences/SystemConfiguration/"), 0, 1, a2);
  if (a3)
    v74 = (CFTypeRef)MEMORY[0x18D78C2F4](0, CFSTR("Library/Preferences/SystemConfiguration/"), 0, 1, a3);
  else
    v74 = CFRetain(v49);
  v75 = v74;
  if (CFEqual(v73, v74))
  {
    v76 = __log_SCNetworkConfiguration();
    v77 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v76, (os_log_type_t)v77))
      goto LABEL_37;
    goto LABEL_36;
  }
  v87 = a2 == 0;
  if (a2 && CFEqual((CFTypeRef)a2, v75))
  {
    v87 = 1;
LABEL_57:
    if (CFEqual(v73, (CFTypeRef)a2))
    {
      v112 = __log_SCNetworkConfiguration();
      v113 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v112, (os_log_type_t)v113))
      {
        v114 = _os_log_pack_size();
        v122 = (char *)v148
             - ((MEMORY[0x1E0C80A78](v114, v115, v116, v117, v118, v119, v120, v121) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v112, v113, v122);
      }
LABEL_61:
      v123 = __log_SCNetworkConfiguration();
      v124 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v123, (os_log_type_t)v124))
      {
        v125 = _os_log_pack_size();
        v133 = (char *)v148
             - ((MEMORY[0x1E0C80A78](v125, v126, v127, v128, v129, v130, v131, v132) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v123, v124, v133);
      }
      v71 = _SCNetworkConfigurationCopyMigrationPaths();
      if (!a2)
        goto LABEL_39;
      goto LABEL_38;
    }
    goto LABEL_60;
  }
  if (!_SCNetworkConfigurationMakePathIfNeeded((const __CFURL *)v75))
  {
    v76 = __log_SCNetworkConfiguration();
    v77 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v76, (os_log_type_t)v77))
    {
LABEL_36:
      v78 = _os_log_pack_size();
      v86 = (char *)v148 - ((MEMORY[0x1E0C80A78](v78, v79, v80, v81, v82, v83, v84, v85) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v76, v77, v86);
      goto LABEL_37;
    }
    goto LABEL_37;
  }
  if (!SCNetworkConfigurationCopyConfigurationFiles(a2, (uint64_t)v75, v88, v89, v90, v91, v92, v93))
  {
    v100 = __log_SCNetworkConfiguration();
    v101 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v100, (os_log_type_t)v101))
    {
      v102 = _os_log_pack_size();
      v110 = (char *)v148
           - ((MEMORY[0x1E0C80A78](v102, v103, v104, v105, v106, v107, v108, v109) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v111 = _os_log_pack_fill();
      *(_DWORD *)v111 = 138412546;
      *(_QWORD *)(v111 + 4) = a2;
      *(_WORD *)(v111 + 12) = 2112;
      *(_QWORD *)(v111 + 14) = v75;
      __SC_log_send(5, (uint64_t)v100, v101, v110);
    }
    v87 = 1;
  }
  if (a2)
    goto LABEL_57;
LABEL_60:
  if (_SCNetworkConfigurationMigrateConfiguration((uint64_t)v73, (uint64_t)v75, v94, v95, v96, v97, v98, v99))goto LABEL_61;
  v134 = __log_SCNetworkConfiguration();
  v135 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v134, (os_log_type_t)v135))
  {
    v136 = _os_log_pack_size();
    v144 = (char *)v148
         - ((MEMORY[0x1E0C80A78](v136, v137, v138, v139, v140, v141, v142, v143) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v145 = _os_log_pack_fill();
    v146 = SCError();
    v147 = SCErrorString(v146);
    *(_DWORD *)v145 = 136315138;
    *(_QWORD *)(v145 + 4) = v147;
    __SC_log_send(5, (uint64_t)v134, v135, v144);
  }
  if (!v87)
    _SCNetworkConfigurationRemoveConfigurationFiles((const __CFURL *)v75);
LABEL_37:
  v71 = 0;
  if (a2)
LABEL_38:
    CFRelease((CFTypeRef)a2);
LABEL_39:
  if (v49)
    CFRelease(v49);
  if (v73)
    CFRelease(v73);
  if (v75)
    CFRelease(v75);
  return v71;
}

uint64_t _SCNetworkConfigurationMakePathIfNeeded(const __CFURL *a1)
{
  int v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t i;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  int *v41;
  char *v42;
  UInt8 v44[1024];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v2 = CFURLGetFileSystemRepresentation(a1, 1u, v44, 1024);
  v3 = __log_SCNetworkConfiguration();
  if (v2)
  {
    v4 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v3, (os_log_type_t)v4))
    {
      v5 = _os_log_pack_size();
      v13 = (char *)&v44[-((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
      __error();
      v14 = _os_log_pack_fill();
      *(_DWORD *)v14 = 136315138;
      *(_QWORD *)(v14 + 4) = v44;
      __SC_log_send(6, (uint64_t)v3, v4, v13);
    }
    for (i = v44[0] == 47; ; ++i)
    {
      if (v44[i])
      {
        if (v44[i] != 47)
        {
          LODWORD(v16) = 0;
          goto LABEL_14;
        }
        v16 = 0;
        v44[i] = 0;
      }
      else
      {
        v16 = 1;
      }
      if (mkdir((const char *)v44, 0x1EDu) && *__error() != 17 && *__error() != 21)
      {
        v29 = __log_SCNetworkConfiguration();
        v30 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v29, (os_log_type_t)v30))
        {
          v31 = _os_log_pack_size();
          v39 = (char *)&v44[-((MEMORY[0x1E0C80A78](v31, v32, v33, v34, v35, v36, v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0)
                           - 8];
          __error();
          v40 = _os_log_pack_fill();
          v41 = __error();
          v42 = strerror(*v41);
          *(_DWORD *)v40 = 136315394;
          *(_QWORD *)(v40 + 4) = v44;
          *(_WORD *)(v40 + 12) = 2080;
          *(_QWORD *)(v40 + 14) = v42;
          __SC_log_send(5, (uint64_t)v29, v30, v39);
        }
        return v16;
      }
      v44[i] = 47;
LABEL_14:
      if ((_DWORD)v16)
        return 1;
    }
  }
  v17 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v3, (os_log_type_t)v17))
  {
    v18 = _os_log_pack_size();
    v26 = (char *)&v44[-((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
    __error();
    v27 = _os_log_pack_fill();
    *(_DWORD *)v27 = 138412290;
    *(_QWORD *)(v27 + 4) = a1;
    __SC_log_send(5, (uint64_t)v3, v17, v26);
  }
  return 0;
}

uint64_t SCNetworkConfigurationCopyConfigurationFiles(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const __CFURL *v9;
  const __CFURL *v10;
  const __CFURL *v11;
  CFURLRef v12;
  CFURLRef v13;
  CFURLRef v14;
  _copyfile_state *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  int *v28;
  char *v29;
  UInt8 *v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int *v76;
  uint64_t v78;
  CFURLRef url;
  CFURLRef v80;
  CFURLRef v81;
  CFURLRef v82;
  UInt8 v83[1024];
  UInt8 v84[1024];
  UInt8 v85[1024];
  UInt8 v86[1024];
  uint64_t v87;

  v8 = MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6, a7, a8);
  v10 = v9;
  v11 = (const __CFURL *)v8;
  v87 = *MEMORY[0x1E0C80C00];
  v81 = 0;
  v82 = 0;
  url = 0;
  v80 = 0;
  _SCNetworkConfigurationCopyMigrationPathsWithBaseURL(v9, &url, &v80);
  v12 = url;
  if (!CFURLGetFileSystemRepresentation(url, 1u, v83, 1024))
  {
    v31 = __log_SCNetworkConfiguration();
    v32 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v31, (os_log_type_t)v32))
      goto LABEL_12;
    goto LABEL_13;
  }
  v12 = v80;
  if (!CFURLGetFileSystemRepresentation(v80, 1u, v84, 1024))
  {
    v31 = __log_SCNetworkConfiguration();
    v32 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v31, (os_log_type_t)v32))
    {
LABEL_12:
      v33 = _os_log_pack_size();
      v41 = (char *)&v78 - ((MEMORY[0x1E0C80A78](v33, v34, v35, v36, v37, v38, v39, v40) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v42 = _os_log_pack_fill();
      *(_DWORD *)v42 = 138412290;
      *(_QWORD *)(v42 + 4) = v12;
      __SC_log_send(5, (uint64_t)v31, v32, v41);
    }
LABEL_13:
    v43 = 0;
    goto LABEL_28;
  }
  if (!v11)
  {
    v13 = 0;
    v43 = 1;
    goto LABEL_26;
  }
  _SCNetworkConfigurationCopyMigrationPathsWithBaseURL(v11, &v81, &v82);
  v13 = v81;
  if (!CFURLGetFileSystemRepresentation(v81, 1u, v85, 1024))
  {
    v44 = __log_SCNetworkConfiguration();
    v45 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v44, (os_log_type_t)v45))
    {
      v46 = _os_log_pack_size();
      v54 = (char *)&v78 - ((MEMORY[0x1E0C80A78](v46, v47, v48, v49, v50, v51, v52, v53) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v55 = _os_log_pack_fill();
      *(_DWORD *)v55 = 138412290;
      *(_QWORD *)(v55 + 4) = v13;
      __SC_log_send(5, (uint64_t)v44, v45, v54);
    }
LABEL_19:
    v43 = 0;
    if (!v13)
      goto LABEL_28;
LABEL_27:
    CFRelease(v13);
    goto LABEL_28;
  }
  v14 = v82;
  if (!CFURLGetFileSystemRepresentation(v82, 1u, v86, 1024))
  {
    v56 = __log_SCNetworkConfiguration();
    v57 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v56, (os_log_type_t)v57))
    {
      v58 = _os_log_pack_size();
      v66 = (char *)&v78 - ((MEMORY[0x1E0C80A78](v58, v59, v60, v61, v62, v63, v64, v65) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v67 = _os_log_pack_fill();
      *(_DWORD *)v67 = 138412290;
      *(_QWORD *)(v67 + 4) = v14;
      __SC_log_send(5, (uint64_t)v56, v57, v66);
    }
    goto LABEL_19;
  }
  v15 = copyfile_state_alloc();
  if (copyfile((const char *)v85, (const char *)v83, v15, 0xFu))
  {
    v16 = __log_SCNetworkConfiguration();
    v17 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v16, (os_log_type_t)v17))
    {
      v18 = _os_log_pack_size();
      v26 = (char *)&v78 - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v27 = _os_log_pack_fill();
      v28 = __error();
      v29 = strerror(*v28);
      *(_DWORD *)v27 = 136315650;
      *(_QWORD *)(v27 + 4) = v85;
      *(_WORD *)(v27 + 12) = 2080;
      v30 = v83;
LABEL_24:
      *(_QWORD *)(v27 + 14) = v30;
      *(_WORD *)(v27 + 22) = 2080;
      *(_QWORD *)(v27 + 24) = v29;
      __SC_log_send(5, (uint64_t)v16, v17, v26);
      goto LABEL_25;
    }
    goto LABEL_25;
  }
  copyfile_state_free(v15);
  chmod((const char *)v83, 0x1EDu);
  v15 = copyfile_state_alloc();
  if (copyfile((const char *)v86, (const char *)v84, v15, 0xFu))
  {
    v16 = __log_SCNetworkConfiguration();
    v17 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v16, (os_log_type_t)v17))
    {
      v68 = _os_log_pack_size();
      v26 = (char *)&v78 - ((MEMORY[0x1E0C80A78](v68, v69, v70, v71, v72, v73, v74, v75) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v27 = _os_log_pack_fill();
      v76 = __error();
      v29 = strerror(*v76);
      *(_DWORD *)v27 = 136315650;
      *(_QWORD *)(v27 + 4) = v86;
      *(_WORD *)(v27 + 12) = 2080;
      v30 = v84;
      goto LABEL_24;
    }
LABEL_25:
    copyfile_state_free(v15);
    v43 = 0;
LABEL_26:
    _SCNetworkConfigurationRemoveConfigurationFiles(v10);
    if (!v13)
      goto LABEL_28;
    goto LABEL_27;
  }
  copyfile_state_free(v15);
  chmod((const char *)v84, 0x1EDu);
  v43 = 1;
  if (v13)
    goto LABEL_27;
LABEL_28:
  if (v82)
    CFRelease(v82);
  if (url)
    CFRelease(url);
  if (v80)
    CFRelease(v80);
  return v43;
}

uint64_t _SCNetworkConfigurationMigrateConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFURL *v8;
  const __CFURL *v9;
  const __CFURL *v10;
  const __CFURL *ValueAtIndex;
  const __CFArray *v12;
  CFStringRef v13;
  CFStringRef v14;
  const __SCPreferences *v15;
  uint64_t v16;
  uint64_t v17;
  __CFDictionary *Mutable;
  const __SCPreferences *v19;
  _BOOL4 v20;
  const __CFArray *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  const __SCPreferences *v45;
  const __SCPreferences *Companion;
  const __CFDictionary *ServiceMappingUsingBSDNameMapping;
  __CFArray *v48;
  __CFDictionary *v49;
  __CFDictionary *v50;
  const __CFDictionary *BSDNameMapping;
  const __SCPreferences *v52;
  const __SCPreferences *v53;
  const __CFURL *v55;
  CFStringRef v56;
  CFStringRef v57;
  const __SCPreferences *v58;
  uint64_t v59;
  NSObject *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  char *v70;
  NSObject *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  char *v81;
  uint64_t v82;
  char *v83;
  const char *v84;
  NSObject *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  uint64_t v96;
  int v97;
  NSObject *v98;
  uint64_t v99;
  _BOOL4 v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  char *v109;
  uint64_t v110;
  const char *v111;
  char *v112;
  const char *v113;
  const __CFString *v114;
  const char *v115;
  const __CFString *v116;
  __CFArray *NetworkInterfaceArray;
  const __SCPreferences *v118;
  __CFDictionary *v119;
  uint64_t v120;
  const __CFDictionary *v121;
  os_log_t v122;
  int v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  NSObject *v132;
  uint64_t v133;
  char *v134;
  const __SCPreferences *v135;
  NSObject *v136;
  uint64_t v137;
  _BOOL4 v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  char *v147;
  uint64_t v148;
  char *v149;
  const __CFDictionary *Value;
  const __CFDictionary *v151;
  const __CFDictionary *v152;
  const __CFDictionary *v153;
  __CFDictionary *v154;
  NSObject *v155;
  uint64_t v156;
  _BOOL4 v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  char *v166;
  uint64_t v167;
  const char *v168;
  char *v169;
  __CFDictionary *SetMapping;
  const __CFDictionary *v171;
  NSObject *v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  char *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  char *v191;
  os_log_t v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  NSObject *v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  char *v212;
  char *v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  char *v224;
  NSObject *v225;
  uint64_t v226;
  const char *v227;
  char *v228;
  int v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  const char *v239;
  NSObject *v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  int v250;
  const char *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  char *v260;
  NSObject *v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t *v271;
  uint64_t *v272;
  CFTypeRef v273;
  const __SCPreferences *v274;
  const __CFDictionary *ServiceSetMapping;
  const __CFDictionary *v276;
  char *v277;
  char *v278;
  CFStringRef v279;
  CFStringRef v280;
  CFStringRef v281;
  CFStringRef v282;
  const __SCPreferences *v283;
  const __SCPreferences *v284;
  char v285;
  CFArrayRef v286;
  CFArrayRef theArray;
  _QWORD v288[2];
  UInt8 v289[1024];
  UInt8 v290[1024];
  UInt8 v291[1024];
  UInt8 v292[1024];
  uint64_t v293;

  v8 = (const __CFURL *)MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6, a7, a8);
  v10 = v9;
  ValueAtIndex = v8;
  v293 = *MEMORY[0x1E0C80C00];
  v286 = 0;
  theArray = 0;
  if (!__SCNetworkConfigurationMigrateConfigurationFilesPresent(v8, &theArray, 1))
  {
    v33 = __log_SCNetworkConfiguration();
    v34 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v33, (os_log_type_t)v34))
      goto LABEL_15;
    goto LABEL_16;
  }
  v12 = theArray;
  ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(theArray, 0);
  if (!CFURLGetFileSystemRepresentation(ValueAtIndex, 1u, v291, 1024))
  {
    v33 = __log_SCNetworkConfiguration();
    v34 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v33, (os_log_type_t)v34))
      goto LABEL_15;
    goto LABEL_16;
  }
  ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v12, 1);
  if (!CFURLGetFileSystemRepresentation(ValueAtIndex, 1u, v292, 1024))
  {
    v33 = __log_SCNetworkConfiguration();
    v34 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v33, (os_log_type_t)v34))
    {
LABEL_15:
      v35 = _os_log_pack_size();
      v43 = (char *)&v270 - ((MEMORY[0x1E0C80A78](v35, v36, v37, v38, v39, v40, v41, v42) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v44 = _os_log_pack_fill();
      *(_DWORD *)v44 = 138412290;
      *(_QWORD *)(v44 + 4) = ValueAtIndex;
      __SC_log_send(5, (uint64_t)v33, v34, v43);
    }
LABEL_16:
    Mutable = 0;
    v45 = 0;
    v279 = 0;
    v280 = 0;
    Companion = 0;
    v282 = 0;
    v283 = 0;
    v284 = 0;
    v281 = 0;
LABEL_17:
    ServiceMappingUsingBSDNameMapping = 0;
    v48 = 0;
    v17 = 0;
    v49 = 0;
LABEL_18:
    v50 = 0;
LABEL_19:
    BSDNameMapping = 0;
    goto LABEL_20;
  }
  v13 = CFStringCreateWithCString(0, (const char *)v291, 0x8000100u);
  v14 = CFStringCreateWithCString(0, (const char *)v292, 0x8000100u);
  v282 = v13;
  v15 = (const __SCPreferences *)__SCPreferencesCreateForMigration(CFSTR("System Migration"), v13);
  v281 = v14;
  v16 = __SCPreferencesCreateForMigration(CFSTR("System Migration"), v14);
  v17 = 0;
  Mutable = 0;
  v283 = v15;
  v284 = (const __SCPreferences *)v16;
  if (!v15 || (v19 = (const __SCPreferences *)v16) == 0)
  {
    v45 = 0;
    v279 = 0;
    v280 = 0;
    Companion = 0;
    ServiceMappingUsingBSDNameMapping = 0;
    v48 = 0;
    v49 = 0;
    v50 = 0;
    BSDNameMapping = 0;
    goto LABEL_20;
  }
  v20 = __SCNetworkConfigurationMigrateConfigurationFilesPresent(v10, &v286, 0);
  v21 = v286;
  if (!v20 && !v286)
  {
    v22 = __log_SCNetworkConfiguration();
    v23 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v22, (os_log_type_t)v23))
    {
      v24 = _os_log_pack_size();
      v32 = (char *)&v270 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v22, v23, v32);
    }
    goto LABEL_66;
  }
  v55 = (const __CFURL *)CFArrayGetValueAtIndex(v286, 0);
  if (!CFURLGetFileSystemRepresentation(v55, 1u, v289, 1024))
  {
    v71 = __log_SCNetworkConfiguration();
    v72 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v71, (os_log_type_t)v72))
      goto LABEL_65;
    goto LABEL_66;
  }
  v55 = (const __CFURL *)CFArrayGetValueAtIndex(v21, 1);
  if (!CFURLGetFileSystemRepresentation(v55, 1u, v290, 1024))
  {
    v71 = __log_SCNetworkConfiguration();
    v72 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v71, (os_log_type_t)v72))
    {
LABEL_65:
      v73 = _os_log_pack_size();
      v81 = (char *)&v270 - ((MEMORY[0x1E0C80A78](v73, v74, v75, v76, v77, v78, v79, v80) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v82 = _os_log_pack_fill();
      *(_DWORD *)v82 = 138412290;
      *(_QWORD *)(v82 + 4) = v55;
      __SC_log_send(5, (uint64_t)v71, v72, v81);
    }
LABEL_66:
    Mutable = 0;
    v45 = 0;
    v279 = 0;
    v280 = 0;
    Companion = 0;
    goto LABEL_17;
  }
  v56 = CFStringCreateWithCString(0, (const char *)v289, 0x8000100u);
  v57 = CFStringCreateWithCString(0, (const char *)v290, 0x8000100u);
  v280 = v56;
  v58 = (const __SCPreferences *)__SCPreferencesCreateForMigration(CFSTR("System Migration"), v56);
  v45 = v58;
  v279 = v57;
  if (v20)
  {
    v59 = __SCPreferencesCreateForMigration(CFSTR("System Migration"), v57);
    Companion = (const __SCPreferences *)v59;
    if (!v45 || !v59)
    {
      v60 = __log_SCNetworkConfiguration();
      v61 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v60, (os_log_type_t)v61))
      {
        v62 = _os_log_pack_size();
        v70 = (char *)&v270
            - ((MEMORY[0x1E0C80A78](v62, v63, v64, v65, v66, v67, v68, v69) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v60, v61, v70);
      }
      Mutable = 0;
      goto LABEL_17;
    }
  }
  else
  {
    __SCNetworkPopulateDefaultPrefs(v58);
    Companion = (const __SCPreferences *)SCPreferencesCreateCompanion((uint64_t)v45, CFSTR("NetworkInterfaces.plist"));
    __SCNetworkPopulateDefaultNIPrefs(Companion);
  }
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v83 = (char *)*MEMORY[0x1E0C9AE50];
  CFDictionaryAddValue(Mutable, CFSTR("ConfigurationRepair"), (const void *)*MEMORY[0x1E0C9AE50]);
  _SCNetworkConfigurationSetBypassSystemInterfaces((uint64_t)v15, 1);
  _SCNetworkConfigurationSetBypassSystemInterfaces((uint64_t)v45, 1);
  v277 = v83;
  if (!hasSameModel(v15, v45))
  {
    v84 = "model change (preferences)";
    goto LABEL_74;
  }
  if (!hasSameModel(v19, Companion))
  {
    v84 = "model change (interfaces)";
    goto LABEL_74;
  }
  if (hasInterfaceConflict(v19, Companion))
  {
    v84 = "interface conflicts";
LABEL_74:
    v85 = __log_SCNetworkConfiguration();
    v86 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v85, (os_log_type_t)v86))
    {
      v87 = _os_log_pack_size();
      v278 = (char *)&v270;
      v95 = (char *)&v270 - ((MEMORY[0x1E0C80A78](v87, v88, v89, v90, v91, v92, v93, v94) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v96 = _os_log_pack_fill();
      *(_DWORD *)v96 = 136315138;
      *(_QWORD *)(v96 + 4) = v84;
      __SC_log_send(5, (uint64_t)v85, v86, v95);
      v97 = 1;
LABEL_76:
      v15 = v283;
      v19 = v284;
      goto LABEL_78;
    }
    v97 = 1;
    goto LABEL_78;
  }
  v172 = __log_SCNetworkConfiguration();
  v173 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v172, (os_log_type_t)v173))
  {
    v174 = _os_log_pack_size();
    v278 = (char *)&v270;
    v182 = (char *)&v270
         - ((MEMORY[0x1E0C80A78](v174, v175, v176, v177, v178, v179, v180, v181) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(5, (uint64_t)v172, v173, v182);
    v97 = 0;
    goto LABEL_76;
  }
  v97 = 0;
LABEL_78:
  v98 = __log_SCNetworkConfiguration();
  v99 = _SC_syslog_os_log_mapping(6);
  v100 = __SC_log_enabled(6, v98, (os_log_type_t)v99);
  LODWORD(v278) = v97;
  if (v100)
  {
    v101 = _os_log_pack_size();
    v109 = (char *)&v270
         - ((MEMORY[0x1E0C80A78](v101, v102, v103, v104, v105, v106, v107, v108) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v15 = v283;
    v110 = _os_log_pack_fill();
    *(_DWORD *)v110 = 138413570;
    v111 = ", new";
    *(_QWORD *)(v110 + 4) = v15;
    if (v20)
      v111 = "";
    *(_WORD *)(v110 + 12) = 2112;
    *(_QWORD *)(v110 + 14) = v284;
    *(_WORD *)(v110 + 22) = 2112;
    *(_QWORD *)(v110 + 24) = v45;
    *(_WORD *)(v110 + 32) = 2080;
    *(_QWORD *)(v110 + 34) = v111;
    *(_WORD *)(v110 + 42) = 2112;
    *(_QWORD *)(v110 + 44) = Companion;
    *(_WORD *)(v110 + 52) = 2080;
    *(_QWORD *)(v110 + 54) = v111;
    v112 = v109;
    v19 = v284;
    __SC_log_send(6, (uint64_t)v98, v99, v112);
    v97 = (int)v278;
  }
  if (v97)
    v113 = "migration";
  else
    v113 = "upgrade";
  v114 = CFStringCreateWithFormat(0, 0, CFSTR("pre-%s-source"), v113);
  __SCNetworkConfigurationBackup(v15, v114, (uint64_t)v45);
  __SCNetworkConfigurationBackup(v19, v114, (uint64_t)v45);
  CFRelease(v114);
  v115 = "new-";
  if (v20)
    v115 = "";
  v116 = CFStringCreateWithFormat(0, 0, CFSTR("pre-%s-%starget"), v113, v115);
  __SCNetworkConfigurationBackup(v45, v116, (uint64_t)v45);
  __SCNetworkConfigurationBackup(Companion, v116, (uint64_t)v45);
  CFRelease(v116);
  __SCNetworkConfigurationReport(5, "Source", v15, v19);
  __SCNetworkConfigurationReport(5, "Target", v45, Companion);
  _SCNetworkConfigurationCreateBuiltinInterfaceServices(v15, v19);
  if (!_SCNetworkConfigurationCheckValidityWithPreferences(v15, v19, Mutable))
  {
    v132 = __log_SCNetworkConfiguration();
    v133 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v132, (os_log_type_t)v133))
      goto LABEL_118;
LABEL_117:
    v183 = _os_log_pack_size();
    v191 = (char *)&v270
         - ((MEMORY[0x1E0C80A78](v183, v184, v185, v186, v187, v188, v189, v190) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(5, (uint64_t)v132, v133, v191);
LABEL_118:
    BSDNameMapping = 0;
    v50 = 0;
    v49 = 0;
    v48 = 0;
    ServiceMappingUsingBSDNameMapping = 0;
    ServiceSetMapping = 0;
    v276 = 0;
    if (!v97)
      goto LABEL_135;
    goto LABEL_119;
  }
  if (v20)
  {
    _SCNetworkConfigurationCreateBuiltinInterfaceServices(v45, Companion);
    if (!_SCNetworkConfigurationCheckValidityWithPreferences(v45, Companion, Mutable))
    {
      v132 = __log_SCNetworkConfiguration();
      v133 = _SC_syslog_os_log_mapping(5);
      if (!__SC_log_enabled(5, v132, (os_log_type_t)v133))
        goto LABEL_118;
      goto LABEL_117;
    }
  }
  if ((v97 & 1) == 0)
  {
    v285 = 0;
    v134 = (char *)__SCPreferencesCreateForMigration(CFSTR("Upgrade Source Prefs"), 0);
    v135 = (const __SCPreferences *)__SCPreferencesCreateForMigration(CFSTR("Upgrade Source NI Prefs"), CFSTR("NetworkInterfaces.plist"));
    _SCNetworkConfigurationSetBypassSystemInterfaces((uint64_t)v134, 1);
    v136 = __log_SCNetworkConfiguration();
    v137 = _SC_syslog_os_log_mapping(6);
    v138 = __SC_log_enabled(6, v136, (os_log_type_t)v137);
    v274 = (const __SCPreferences *)v134;
    if (v138)
    {
      v139 = _os_log_pack_size();
      v147 = (char *)&v270
           - ((MEMORY[0x1E0C80A78](v139, v140, v141, v142, v143, v144, v145, v146) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v148 = _os_log_pack_fill();
      *(_DWORD *)v148 = 138412546;
      *(_QWORD *)(v148 + 4) = v274;
      *(_WORD *)(v148 + 12) = 2112;
      *(_QWORD *)(v148 + 14) = v135;
      v149 = v147;
      v19 = v284;
      __SC_log_send(6, (uint64_t)v136, v137, v149);
      v134 = (char *)v274;
    }
    Value = SCPreferencesPathGetValue(v45, CFSTR("/"));
    v151 = SCPreferencesPathGetValue(Companion, CFSTR("/"));
    SCPreferencesPathSetValue((SCPreferencesRef)v134, CFSTR("/"), Value);
    SCPreferencesPathSetValue(v135, CFSTR("/"), v151);
    v152 = SCPreferencesPathGetValue(v283, CFSTR("/"));
    v153 = SCPreferencesPathGetValue(v19, CFSTR("/"));
    SCPreferencesPathSetValue(v45, CFSTR("/"), v152);
    SCPreferencesPathSetValue(Companion, CFSTR("/"), v153);
    v273 = v135;
    v154 = _SCNetworkConfigurationCopyExternalInterfaceMapping(v135, Companion);
    v49 = v154;
    if (v154)
    {
      v288[0] = 6;
      v288[1] = "Upgrading, external interface mapping";
      CFDictionaryApplyFunction(v154, (CFDictionaryApplierFunction)logMapping_one, v288);
    }
    v48 = _SCNetworkMigrationCreateNetworkInterfaceArray(Companion, v49, &v285);
    v155 = __log_SCNetworkConfiguration();
    v156 = _SC_syslog_os_log_mapping(6);
    v157 = __SC_log_enabled(6, v155, (os_log_type_t)v156);
    v97 = (int)v278;
    if (v157)
    {
      v158 = _os_log_pack_size();
      v276 = (const __CFDictionary *)&v270;
      v166 = (char *)&v270
           - ((MEMORY[0x1E0C80A78](v158, v159, v160, v161, v162, v163, v164, v165) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v97 = (int)v278;
      v167 = _os_log_pack_fill();
      if (v285)
        v168 = "found";
      else
        v168 = "no";
      *(_DWORD *)v167 = 136315138;
      *(_QWORD *)(v167 + 4) = v168;
      v169 = v166;
      v134 = (char *)v274;
      __SC_log_send(6, (uint64_t)v155, v156, v169);
    }
    if (!v285)
    {
      ServiceSetMapping = 0;
      v276 = 0;
      ServiceMappingUsingBSDNameMapping = 0;
      BSDNameMapping = 0;
      goto LABEL_126;
    }
    if (v48)
    {
      if (__SCNetworkInterfaceSaveStoredWithPreferences(Companion, v48))
      {
        BSDNameMapping = _SCNetworkMigrationCreateBSDNameMapping(0, v49);
        ServiceMappingUsingBSDNameMapping = _SCNetworkMigrationCreateServiceMappingUsingBSDNameMapping((const __SCPreferences *)v134, v45, BSDNameMapping);
        SetMapping = _SCNetworkMigrationCreateSetMapping((const __SCPreferences *)v134, v45);
        ServiceSetMapping = _SCNetworkMigrationCreateServiceSetMapping(v274);
        v276 = SetMapping;
        v171 = SetMapping;
        v134 = (char *)v274;
        _SCNetworkMigrationDoServiceMigration((uint64_t)v274, (uint64_t)v45, ServiceMappingUsingBSDNameMapping, BSDNameMapping, v171, ServiceSetMapping);
LABEL_126:
        CFRelease(v134);
        CFRelease(v273);
        v50 = 0;
        goto LABEL_135;
      }
      v225 = __log_SCNetworkConfiguration();
      v226 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v225, (os_log_type_t)v226))
        goto LABEL_158;
    }
    else
    {
      v225 = __log_SCNetworkConfiguration();
      v226 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v225, (os_log_type_t)v226))
      {
LABEL_158:
        v252 = _os_log_pack_size();
        v278 = (char *)&v270;
        v260 = (char *)&v270
             - ((MEMORY[0x1E0C80A78](v252, v253, v254, v255, v256, v257, v258, v259) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v225, v226, v260);
        v134 = (char *)v274;
      }
    }
    CFRelease(v134);
    CFRelease(v273);
    ServiceMappingUsingBSDNameMapping = 0;
    v17 = 0;
    goto LABEL_18;
  }
  v50 = _SCNetworkConfigurationCopyBuiltinMapping(v19, Companion);
  v49 = _SCNetworkConfigurationCopyExternalInterfaceMapping(v19, Companion);
  NetworkInterfaceArray = _SCNetworkMigrationCreateNetworkInterfaceArray(Companion, v49, 0);
  if (!NetworkInterfaceArray)
  {
    v202 = __log_SCNetworkConfiguration();
    v203 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v202, (os_log_type_t)v203))
    {
      v204 = _os_log_pack_size();
      v278 = (char *)&v270;
      v212 = (char *)&v270
           - ((MEMORY[0x1E0C80A78](v204, v205, v206, v207, v208, v209, v210, v211) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v202, v203, v212);
    }
    ServiceMappingUsingBSDNameMapping = 0;
    v48 = 0;
    goto LABEL_130;
  }
  v48 = NetworkInterfaceArray;
  if (!__SCNetworkInterfaceSaveStoredWithPreferences(Companion, NetworkInterfaceArray))
  {
    v213 = (char *)__log_SCNetworkConfiguration();
    v214 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, (os_log_t)v213, (os_log_type_t)v214))
    {
      v215 = _os_log_pack_size();
      v278 = (char *)&v270;
      v223 = MEMORY[0x1E0C80A78](v215, v216, v217, v218, v219, v220, v221, v222);
      v277 = v213;
      v224 = (char *)&v270 - ((v223 + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v277, v214, v224);
    }
    ServiceMappingUsingBSDNameMapping = 0;
LABEL_130:
    v17 = 0;
    goto LABEL_19;
  }
  BSDNameMapping = _SCNetworkMigrationCreateBSDNameMapping(v50, v49);
  v118 = v283;
  ServiceMappingUsingBSDNameMapping = _SCNetworkMigrationCreateServiceMappingUsingBSDNameMapping(v283, v45, BSDNameMapping);
  if (!ServiceMappingUsingBSDNameMapping)
  {
    v17 = 0;
    goto LABEL_20;
  }
  v276 = _SCNetworkMigrationCreateSetMapping(v118, v45);
  v119 = _SCNetworkMigrationCreateServiceSetMapping(v118);
  v120 = (uint64_t)v118;
  v121 = v276;
  ServiceSetMapping = v119;
  if (!_SCNetworkMigrationDoServiceMigration(v120, (uint64_t)v45, ServiceMappingUsingBSDNameMapping, BSDNameMapping, v276, v119))
  {
    v261 = __log_SCNetworkConfiguration();
    LODWORD(v277) = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v261, (os_log_type_t)v277))
      goto LABEL_151;
    v262 = _os_log_pack_size();
    v273 = v261;
    v274 = (const __SCPreferences *)&v270;
    v278 = (char *)&v270
         - ((MEMORY[0x1E0C80A78](v262, v263, v264, v265, v266, v267, v268, v269) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    goto LABEL_150;
  }
  if (!_SCNetworkMigrationDoServiceOrderMigration(v121))
  {
    v122 = __log_SCNetworkConfiguration();
    v123 = _SC_syslog_os_log_mapping(5);
    v273 = v122;
    LODWORD(v272) = v123;
    if (__SC_log_enabled(5, v122, (os_log_type_t)v123))
    {
      v124 = _os_log_pack_size();
      v271 = &v270;
      v274 = (const __SCPreferences *)((char *)&v270
                                     - ((MEMORY[0x1E0C80A78](v124, v125, v126, v127, v128, v129, v130, v131) + 15) & 0xFFFFFFFFFFFFFFF0));
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v273, v272, (char *)v274);
    }
  }
  v97 = (int)v278;
LABEL_119:
  if (!_SCNetworkMigrationDoSystemMigration(v283, v45))
  {
    v192 = __log_SCNetworkConfiguration();
    v193 = _SC_syslog_os_log_mapping(5);
    v273 = v192;
    LODWORD(v272) = v193;
    if (__SC_log_enabled(5, v192, (os_log_type_t)v193))
    {
      v194 = _os_log_pack_size();
      v271 = &v270;
      v274 = (const __SCPreferences *)((char *)&v270
                                     - ((MEMORY[0x1E0C80A78](v194, v195, v196, v197, v198, v199, v200, v201) + 15) & 0xFFFFFFFFFFFFFFF0));
      __error();
      v97 = (int)v278;
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v273, v272, (char *)v274);
    }
    else
    {
      v97 = (int)v278;
    }
  }
LABEL_135:
  CFDictionaryAddValue(Mutable, CFSTR("ConfigurationRepairModel"), v277);
  if (!_SCNetworkConfigurationCheckValidityWithPreferences(v45, Companion, Mutable))
  {
    v228 = (char *)__log_SCNetworkConfiguration();
    v229 = _SC_syslog_os_log_mapping(5);
    v274 = (const __SCPreferences *)v228;
    LODWORD(v273) = v229;
    if (__SC_log_enabled(5, (os_log_t)v228, (os_log_type_t)v229))
    {
      v230 = _os_log_pack_size();
      v272 = &v270;
      v277 = (char *)&v270
           - ((MEMORY[0x1E0C80A78](v230, v231, v232, v233, v234, v235, v236, v237) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v238 = _os_log_pack_fill();
      v239 = "Upgraded";
      if ((_DWORD)v278)
        v239 = "Migrated";
      *(_DWORD *)v238 = 136315138;
      *(_QWORD *)(v238 + 4) = v239;
      __SC_log_send(5, (uint64_t)v274, v273, v277);
    }
    goto LABEL_151;
  }
  if (SCPreferencesCommitChanges(v45))
  {
    if (SCPreferencesCommitChanges(Companion))
    {
      if (v97)
        v227 = "Migrated";
      else
        v227 = "Upgraded";
      __SCNetworkConfigurationReport(5, v227, v45, Companion);
      v17 = 1;
      goto LABEL_152;
    }
    v240 = __log_SCNetworkConfiguration();
    LODWORD(v277) = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v240, (os_log_type_t)v277))
      goto LABEL_149;
  }
  else
  {
    v240 = __log_SCNetworkConfiguration();
    LODWORD(v277) = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v240, (os_log_type_t)v277))
    {
LABEL_149:
      v241 = _os_log_pack_size();
      v273 = v240;
      v274 = (const __SCPreferences *)&v270;
      v278 = (char *)&v270
           - ((MEMORY[0x1E0C80A78](v241, v242, v243, v244, v245, v246, v247, v248) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v249 = _os_log_pack_fill();
      v250 = SCError();
      v251 = SCErrorString(v250);
      *(_DWORD *)v249 = 136315138;
      *(_QWORD *)(v249 + 4) = v251;
LABEL_150:
      __SC_log_send(5, (uint64_t)v273, v277, v278);
    }
  }
LABEL_151:
  v17 = 0;
LABEL_152:
  if (v276)
    CFRelease(v276);
  if (ServiceSetMapping)
    CFRelease(ServiceSetMapping);
LABEL_20:
  if (theArray)
    CFRelease(theArray);
  if (v286)
    CFRelease(v286);
  if (v282)
    CFRelease(v282);
  if (v281)
    CFRelease(v281);
  if (v280)
    CFRelease(v280);
  if (v279)
    CFRelease(v279);
  if (v48)
    CFRelease(v48);
  if (v50)
    CFRelease(v50);
  v52 = v283;
  if (v49)
    CFRelease(v49);
  if (BSDNameMapping)
    CFRelease(BSDNameMapping);
  v53 = v284;
  if (ServiceMappingUsingBSDNameMapping)
    CFRelease(ServiceMappingUsingBSDNameMapping);
  if (v45)
    CFRelease(v45);
  if (v52)
    CFRelease(v52);
  if (v53)
    CFRelease(v53);
  if (Companion)
    CFRelease(Companion);
  if (Mutable)
    CFRelease(Mutable);
  return v17;
}

void _SCNetworkConfigurationRemoveConfigurationFiles(const __CFURL *a1)
{
  CFURLRef v1;
  std::error_code *v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  int *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CFURLRef v26;
  std::error_code *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  int *v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  CFURLRef v52;
  CFURLRef url;
  std::__fs::filesystem::path v54[42];
  std::__fs::filesystem::path v55[42];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v52 = 0;
  url = 0;
  _SCNetworkConfigurationCopyMigrationPathsWithBaseURL(a1, &url, &v52);
  v1 = url;
  if (!CFURLGetFileSystemRepresentation(url, 1u, (UInt8 *)v55, 1024))
  {
    v3 = __log_SCNetworkConfiguration();
    v4 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v3, (os_log_type_t)v4))
      goto LABEL_9;
    v17 = _os_log_pack_size();
    v13 = (char *)&v51 - ((MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22, v23, v24) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v25 = _os_log_pack_fill();
    *(_DWORD *)v25 = 138412290;
    *(_QWORD *)(v25 + 4) = v1;
    goto LABEL_8;
  }
  if (remove(v55, v2) && *__error() != 2)
  {
    v3 = __log_SCNetworkConfiguration();
    v4 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v3, (os_log_type_t)v4))
    {
      v5 = _os_log_pack_size();
      v13 = (char *)&v51 - ((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v14 = _os_log_pack_fill();
      v15 = __error();
      v16 = strerror(*v15);
      *(_DWORD *)v14 = 136315394;
      *(_QWORD *)(v14 + 4) = v55;
      *(_WORD *)(v14 + 12) = 2080;
      *(_QWORD *)(v14 + 14) = v16;
LABEL_8:
      __SC_log_send(5, (uint64_t)v3, v4, v13);
    }
  }
LABEL_9:
  CFRelease(v1);
  v26 = v52;
  if (CFURLGetFileSystemRepresentation(v52, 1u, (UInt8 *)v54, 1024))
  {
    if (remove(v54, v27) && *__error() != 2)
    {
      v28 = __log_SCNetworkConfiguration();
      v29 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v28, (os_log_type_t)v29))
      {
        v30 = _os_log_pack_size();
        v38 = (char *)&v51 - ((MEMORY[0x1E0C80A78](v30, v31, v32, v33, v34, v35, v36, v37) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v39 = _os_log_pack_fill();
        v40 = __error();
        v41 = strerror(*v40);
        *(_DWORD *)v39 = 136315394;
        *(_QWORD *)(v39 + 4) = v54;
        *(_WORD *)(v39 + 12) = 2080;
        *(_QWORD *)(v39 + 14) = v41;
LABEL_16:
        __SC_log_send(5, (uint64_t)v28, v29, v38);
      }
    }
  }
  else
  {
    v28 = __log_SCNetworkConfiguration();
    v29 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v28, (os_log_type_t)v29))
    {
      v42 = _os_log_pack_size();
      v38 = (char *)&v51 - ((MEMORY[0x1E0C80A78](v42, v43, v44, v45, v46, v47, v48, v49) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v50 = _os_log_pack_fill();
      *(_DWORD *)v50 = 138412290;
      *(_QWORD *)(v50 + 4) = v26;
      goto LABEL_16;
    }
  }
  CFRelease(v26);
}

uint64_t _SCNetworkConfigurationCheckValidityWithPreferences(const __SCPreferences *a1, const __SCPreferences *a2, const __CFDictionary *a3)
{
  CFTypeID TypeID;
  const __CFBoolean *Value;
  CFTypeID v7;
  int v8;
  const __CFBoolean *v9;
  CFTypeID v10;
  NSObject *v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  BOOL v24;
  int v25;
  const __SCPreferences *v26;
  const __SCPreferences *v27;
  const char *v28;
  _BOOL4 v29;
  const char *v30;
  _BOOL4 v31;
  CFPropertyListRef v32;
  CFPropertyListRef v33;
  CFTypeID v34;
  CFTypeID v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  CFTypeID v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  CFTypeID v60;
  const void *v61;
  CFTypeID v62;
  NSObject *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  CFTypeID v74;
  NSObject *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  CFTypeID v86;
  CFTypeID v87;
  __CFArray *v88;
  __CFArray *v89;
  __CFDictionary *MappingUsingBSDName;
  CFTypeID v91;
  __CFArray *v92;
  const __CFArray *v93;
  __CFDictionary *v94;
  int v95;
  const CFArrayCallBacks *v96;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v98;
  const CFArrayCallBacks *v99;
  CFMutableArrayRef v100;
  CFMutableArrayRef v101;
  CFMutableDictionaryRef v102;
  NSObject *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char *v113;
  uint64_t v114;
  const __CFArray *v115;
  CFMutableArrayRef v116;
  CFArrayRef v117;
  CFArrayRef v118;
  uint64_t *v119;
  NSObject *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  uint64_t v131;
  NSObject *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char *v142;
  uint64_t v143;
  const char *v144;
  _BOOL4 v146;
  NSObject *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  char *v157;
  uint64_t v158;
  NSObject *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  char *v169;
  uint64_t v170;
  CFTypeID v171;
  CFTypeID v172;
  __int128 v173;
  CFIndex v174;
  const __CFArray *v175;
  CFIndex v176;
  const void *v177;
  NSObject *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  __CFArray *v188;
  const char *v189;
  char *v190;
  uint64_t v191;
  char *v192;
  NSObject *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  char *v204;
  const __CFArray *ServiceOrder;
  const __CFArray *v206;
  CFIndex v207;
  const void *v208;
  NSObject *v209;
  int v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  char *v220;
  uint64_t v221;
  NSObject *v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  char *v232;
  uint64_t v233;
  NSObject *v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  char *v244;
  uint64_t v245;
  char *v246;
  const __CFArray *v247;
  const __CFArray *v248;
  CFIndex Count;
  CFIndex v250;
  NSObject *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  char *v261;
  uint64_t v262;
  char *v263;
  CFIndex v264;
  const __SCPreferences *v265;
  const __SCPreferences *v266;
  const __CFArray *v267;
  const __SCPreferences *v268;
  int v269;
  NSObject *v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  char *v280;
  char *v281;
  const __CFArray *v282;
  const __CFArray *v283;
  CFArrayRef v284;
  const __CFArray *v285;
  _QWORD *v286;
  const __SCPreferences *v287;
  const void *v288;
  const void *v289;
  NSObject *v290;
  NSObject *v291;
  __int128 v292;
  uint64_t *v293;
  CFIndex v294;
  _BOOL4 v295;
  __CFArray *v296;
  CFMutableArrayRef v297;
  const __SCPreferences *v298;
  uint64_t *v299;
  SCNetworkSetRef ValueAtIndex;
  const __SCPreferences *v301;
  unsigned __int8 v302;
  __int128 v303;
  __int128 v304;
  __int128 v305;
  __int128 v306;
  __int128 v307;
  uint64_t v308;
  uint64_t context;
  const char *v310;
  uint64_t v311;
  CFRange v312;
  CFRange v313;
  CFRange v314;
  CFRange v315;
  CFRange v316;
  CFRange v317;
  CFRange v318;
  CFRange v319;

  v301 = a1;
  v311 = *MEMORY[0x1E0C80C00];
  v302 = 1;
  TypeID = CFDictionaryGetTypeID();
  if (a3 && CFGetTypeID(a3) == TypeID)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("ConfigurationRepair"));
    v7 = CFBooleanGetTypeID();
    if (Value && CFGetTypeID(Value) == v7)
      LODWORD(ValueAtIndex) = CFBooleanGetValue(Value);
    else
      LODWORD(ValueAtIndex) = 0;
    v9 = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("ConfigurationRepairModel"));
    v10 = CFBooleanGetTypeID();
    if (v9 && CFGetTypeID(v9) == v10)
      v8 = CFBooleanGetValue(v9);
    else
      v8 = 0;
  }
  else
  {
    v8 = 0;
    LODWORD(ValueAtIndex) = 0;
  }
  v308 = 0;
  v306 = 0u;
  v307 = 0u;
  v304 = 0u;
  v305 = 0u;
  v303 = 0u;
  v11 = __log_SCNetworkConfiguration();
  v12 = _SC_syslog_os_log_mapping(6);
  v13 = "";
  if (__SC_log_enabled(6, v11, (os_log_type_t)v12))
  {
    v14 = _os_log_pack_size();
    v299 = (uint64_t *)&v290;
    v22 = (char *)&v290 - ((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v23 = _os_log_pack_fill();
    v24 = v8 == 0;
    v25 = v8;
    v26 = v301;
    if (!v24)
      v13 = ", w/repair-model";
    v27 = a2;
    if ((_DWORD)ValueAtIndex)
      v28 = ", w/repair-configuration";
    else
      v28 = "";
    v29 = _SCNetworkConfigurationBypassSystemInterfaces((uint64_t)v301);
    *(_DWORD *)v23 = 136316162;
    v30 = ", bypass system interfaces";
    *(_QWORD *)(v23 + 4) = v13;
    v13 = "";
    if (!v29)
      v30 = "";
    *(_WORD *)(v23 + 12) = 2080;
    *(_QWORD *)(v23 + 14) = v28;
    a2 = v27;
    *(_WORD *)(v23 + 22) = 2080;
    *(_QWORD *)(v23 + 24) = v30;
    *(_WORD *)(v23 + 32) = 2112;
    *(_QWORD *)(v23 + 34) = v26;
    v8 = v25;
    *(_WORD *)(v23 + 42) = 2112;
    *(_QWORD *)(v23 + 44) = v27;
    __SC_log_send(6, (uint64_t)v11, v12, v22);
  }
  v31 = _SCNetworkConfigurationBypassSystemInterfaces((uint64_t)v301);
  if (!v31)
    _SCNetworkConfigurationSetBypassSystemInterfaces((uint64_t)v301, 1);
  v32 = SCPreferencesGetValue(v301, CFSTR("Model"));
  v33 = SCPreferencesGetValue(a2, CFSTR("Model"));
  v34 = CFStringGetTypeID();
  if (!v32 || CFGetTypeID(v32) != v34)
  {
    if (v8)
    {
      v35 = CFStringGetTypeID();
      if (v33)
      {
        if (CFGetTypeID(v33) == v35)
        {
          v36 = __log_SCNetworkConfiguration();
          v37 = _SC_syslog_os_log_mapping(6);
          if (__SC_log_enabled(6, v36, (os_log_type_t)v37))
          {
            v38 = _os_log_pack_size();
            v46 = (char *)&v290
                - ((MEMORY[0x1E0C80A78](v38, v39, v40, v41, v42, v43, v44, v45) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            *(_WORD *)_os_log_pack_fill() = 0;
            __SC_log_send(6, (uint64_t)v36, v37, v46);
          }
          SCPreferencesSetValue(v301, CFSTR("Model"), v33);
          v47 = CFStringGetTypeID();
          v32 = v33;
LABEL_35:
          v61 = v32;
          if (CFGetTypeID(v33) == v47)
            goto LABEL_45;
          goto LABEL_36;
        }
      }
    }
    v48 = __log_SCNetworkConfiguration();
    v49 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v48, (os_log_type_t)v49))
    {
      v50 = _os_log_pack_size();
      v298 = a2;
      v58 = (char *)&v290 - ((MEMORY[0x1E0C80A78](v50, v51, v52, v53, v54, v55, v56, v57) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      v59 = v58;
      v13 = "";
      __SC_log_send(6, (uint64_t)v48, v49, v59);
      a2 = v298;
    }
  }
  v60 = CFStringGetTypeID();
  if (v33)
  {
    v47 = v60;
    goto LABEL_35;
  }
LABEL_36:
  if (v8)
  {
    v62 = CFStringGetTypeID();
    if (v32)
    {
      if (CFGetTypeID(v32) == v62)
      {
        v63 = __log_SCNetworkConfiguration();
        v64 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v63, (os_log_type_t)v64))
        {
          v65 = _os_log_pack_size();
          v73 = (char *)&v290
              - ((MEMORY[0x1E0C80A78](v65, v66, v67, v68, v69, v70, v71, v72) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(6, (uint64_t)v63, v64, v73);
        }
        SCPreferencesSetValue(a2, CFSTR("Model"), v32);
        v74 = CFStringGetTypeID();
        v61 = v32;
        goto LABEL_47;
      }
    }
  }
  v75 = __log_SCNetworkConfiguration();
  v76 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v75, (os_log_type_t)v76))
  {
    v77 = _os_log_pack_size();
    v85 = (char *)&v290 - ((MEMORY[0x1E0C80A78](v77, v78, v79, v80, v81, v82, v83, v84) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(6, (uint64_t)v75, v76, v85);
  }
  v61 = v32;
LABEL_45:
  v86 = CFStringGetTypeID();
  if (!v61)
    goto LABEL_51;
  v74 = v86;
  v32 = v33;
LABEL_47:
  if (CFGetTypeID(v61) == v74)
  {
    v87 = CFStringGetTypeID();
    if (v32)
    {
      if (CFGetTypeID(v32) == v87 && !CFEqual(v61, v32))
      {
        v302 = 0;
        v159 = __log_SCNetworkConfiguration();
        v160 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v159, (os_log_type_t)v160))
        {
          v161 = _os_log_pack_size();
          v169 = (char *)&v290
               - ((MEMORY[0x1E0C80A78](v161, v162, v163, v164, v165, v166, v167, v168) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v170 = _os_log_pack_fill();
          *(_DWORD *)v170 = 138412546;
          *(_QWORD *)(v170 + 4) = v301;
          *(_WORD *)(v170 + 12) = 2112;
          *(_QWORD *)(v170 + 14) = a2;
          __SC_log_send(5, (uint64_t)v159, v160, v169);
        }
        goto LABEL_80;
      }
    }
  }
LABEL_51:
  v88 = __SCNetworkInterfaceCopyStoredWithPreferences(a2);
  if (v88)
  {
    v89 = v88;
    MappingUsingBSDName = __SCNetworkInterfaceCreateMappingUsingBSDName(v88);
    CFRelease(v89);
    v91 = CFDictionaryGetTypeID();
    if (!MappingUsingBSDName || CFGetTypeID(MappingUsingBSDName) != v91)
    {
      v302 = 0;
      v103 = __log_SCNetworkConfiguration();
      v104 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v103, (os_log_type_t)v104))
      {
        v105 = _os_log_pack_size();
        v113 = (char *)&v290
             - ((MEMORY[0x1E0C80A78](v105, v106, v107, v108, v109, v110, v111, v112) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v114 = _os_log_pack_fill();
        *(_DWORD *)v114 = 138412290;
        *(_QWORD *)(v114 + 4) = a2;
        __SC_log_send(5, (uint64_t)v103, v104, v113);
      }
      v115 = 0;
      v94 = 0;
      v299 = 0;
      v101 = 0;
      v116 = 0;
      Mutable = 0;
      v117 = 0;
      v118 = 0;
      if (!MappingUsingBSDName)
        goto LABEL_63;
      goto LABEL_132;
    }
    v92 = __SCNetworkServiceCopyAllInterfaces(v301);
    if (v92)
    {
      v93 = v92;
      logInterfaces((uint64_t)"interfaces", v92, 1);
      v94 = __SCNetworkInterfaceCreateMappingUsingBSDName(v93);
      CFRelease(v93);
      if (v94)
      {
        v298 = a2;
        context = 7;
        v310 = "mappingServiceBSDNameToInterface";
        CFDictionaryApplyFunction(v94, (CFDictionaryApplierFunction)logMapping_one, &context);
        v95 = (int)ValueAtIndex;
        if ((_DWORD)ValueAtIndex)
        {
          v96 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
          Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
          v98 = CFArrayCreateMutable(0, 0, v96);
          v99 = v96;
          v100 = v98;
          v101 = CFArrayCreateMutable(0, 0, v99);
          v102 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        }
        else
        {
          v102 = 0;
          v101 = 0;
          v100 = 0;
          Mutable = 0;
        }
        *(_QWORD *)&v305 = &v302;
        *((_QWORD *)&v305 + 1) = Mutable;
        v297 = v100;
        *(_QWORD *)&v306 = v100;
        *((_QWORD *)&v306 + 1) = v101;
        *(_QWORD *)&v304 = 0;
        *((_QWORD *)&v304 + 1) = MappingUsingBSDName;
        v303 = 0uLL;
        LOBYTE(v308) = v95;
        *(_QWORD *)&v307 = v102;
        *((_QWORD *)&v307 + 1) = v301;
        v299 = (uint64_t *)v102;
        CFDictionaryApplyFunction(v94, (CFDictionaryApplierFunction)_SCNetworkConfigurationValidateInterface, &v303);
        v296 = v101;
        if (!v302)
        {
          v234 = __log_SCNetworkConfiguration();
          v235 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v234, (os_log_type_t)v235))
          {
            v236 = _os_log_pack_size();
            v244 = (char *)&v290
                 - ((MEMORY[0x1E0C80A78](v236, v237, v238, v239, v240, v241, v242, v243) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v245 = _os_log_pack_fill();
            *(_DWORD *)v245 = 138412546;
            *(_QWORD *)(v245 + 4) = v301;
            *(_WORD *)(v245 + 12) = 2112;
            *(_QWORD *)(v245 + 14) = v298;
            v246 = v244;
            v101 = v296;
            __SC_log_send(5, (uint64_t)v234, v235, v246);
            v95 = (int)ValueAtIndex;
          }
          if (!v95)
          {
            v118 = 0;
            v117 = 0;
            v115 = 0;
LABEL_131:
            v116 = v297;
            goto LABEL_132;
          }
          v247 = (const __CFArray *)*((_QWORD *)&v305 + 1);
          v248 = (const __CFArray *)v306;
          Count = CFArrayGetCount(*((CFArrayRef *)&v305 + 1));
          v250 = CFArrayGetCount(v248);
          if (!(Count | v250))
          {
            v118 = 0;
            v117 = 0;
            v115 = 0;
            v302 = 0;
            v116 = v297;
            v101 = v296;
LABEL_132:
            CFRelease(MappingUsingBSDName);
            if (v94)
              CFRelease(v94);
LABEL_63:
            if (v118)
              CFRelease(v118);
            if (v117)
              CFRelease(v117);
            if (v115)
              CFRelease(v115);
            v119 = v299;
            if (Mutable)
              CFRelease(Mutable);
            if (v116)
              CFRelease(v116);
            if (v101)
              CFRelease(v101);
            if (v119)
              CFRelease(v119);
            goto LABEL_80;
          }
          v264 = v250;
          ValueAtIndex = Mutable;
          v265 = v301;
          __SCNetworkConfigurationBackup(v301, CFSTR("pre-repair"), (uint64_t)v301);
          v266 = v298;
          __SCNetworkConfigurationBackup(v298, CFSTR("pre-repair"), (uint64_t)v265);
          __SCNetworkConfigurationReport(7, "pre-repair", v265, v266);
          if (v247)
            logInterfaces((uint64_t)"Interfaces to be removed", v247, 0);
          if (v248)
            logInterfaces((uint64_t)"Interfaces to be replaced", v248, 0);
          v267 = SCNetworkServiceCopyAll(v301);
          v315.length = CFArrayGetCount(v267);
          v315.location = 0;
          CFArrayApplyFunction(v267, v315, (CFArrayApplierFunction)create_bsd_name_service_protocol_mapping, &v303);
          if ((_QWORD)v307)
          {
            context = 7;
            v310 = "BSD name / Service Protocol mapping";
            CFDictionaryApplyFunction((CFDictionaryRef)v307, (CFDictionaryApplierFunction)logMapping_one, &context);
          }
          v316.length = CFArrayGetCount(v267);
          v316.location = 0;
          CFArrayApplyFunction(v267, v316, (CFArrayApplierFunction)remove_service, &v303);
          v317.location = 0;
          v317.length = v264;
          CFArrayApplyFunction(v248, v317, (CFArrayApplierFunction)add_service, &v303);
          CFRelease(v267);
          v268 = v301;
          __SCNetworkConfigurationReport(7, "post-repair", v301, v266);
          v302 = 1;
          v269 = SCPreferencesCommitChanges(v268);
          Mutable = ValueAtIndex;
          v101 = v296;
          if (!v269)
          {
            v270 = __log_SCNetworkConfiguration();
            v271 = _SC_syslog_os_log_mapping(5);
            if (__SC_log_enabled(5, v270, (os_log_type_t)v271))
            {
              v272 = _os_log_pack_size();
              v280 = (char *)&v290
                   - ((MEMORY[0x1E0C80A78](v272, v273, v274, v275, v276, v277, v278, v279) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              *(_WORD *)_os_log_pack_fill() = 0;
              v281 = v280;
              v101 = v296;
              __SC_log_send(5, (uint64_t)v270, v271, v281);
            }
          }
        }
        v118 = SCNetworkServiceCopyAll(v301);
        v171 = CFArrayGetTypeID();
        v295 = v31;
        if (v118 && CFGetTypeID(v118) == v171)
        {
          v117 = SCNetworkSetCopyAll(v301);
          v172 = CFArrayGetTypeID();
          if (v117 && CFGetTypeID(v117) == v172)
          {
            v115 = 0;
            if (CFArrayGetCount(v117) >= 1 && v302)
            {
              v174 = 0;
              *(_QWORD *)&v173 = 138412546;
              v292 = v173;
              do
              {
                ValueAtIndex = (SCNetworkSetRef)CFArrayGetValueAtIndex(v117, v174);
                v175 = SCNetworkSetCopyServices(ValueAtIndex);
                if (v175)
                {
                  v115 = v175;
                  v294 = v174;
                  if (CFArrayGetCount(v175) >= 1)
                  {
                    v176 = 0;
                    while (1)
                    {
                      v177 = CFArrayGetValueAtIndex(v115, v176);
                      v312.length = CFArrayGetCount(v118);
                      v312.location = 0;
                      if (!CFArrayContainsValue(v118, v312, v177))
                        break;
                      if (++v176 >= CFArrayGetCount(v115))
                        goto LABEL_114;
                    }
                    v302 = 0;
                    v193 = __log_SCNetworkConfiguration();
                    v194 = _SC_syslog_os_log_mapping(5);
                    if (__SC_log_enabled(5, v193, (os_log_type_t)v194))
                    {
                      v195 = _os_log_pack_size();
                      v293 = (uint64_t *)&v290;
                      v203 = MEMORY[0x1E0C80A78](v195, v196, v197, v198, v199, v200, v201, v202);
                      v291 = v193;
                      v204 = (char *)&v290 - ((v203 + 15) & 0xFFFFFFFFFFFFFFF0);
                      __error();
                      *(_WORD *)_os_log_pack_fill() = 0;
                      __SC_log_send(5, (uint64_t)v291, v194, v204);
                    }
                  }
LABEL_114:
                  if (!v302)
                  {
                    v13 = "";
                    break;
                  }
                  ServiceOrder = SCNetworkSetGetServiceOrder(ValueAtIndex);
                  if (ServiceOrder)
                  {
                    v206 = ServiceOrder;
                    if (CFArrayGetCount(ServiceOrder) >= 1)
                    {
                      v207 = 0;
                      while (1)
                      {
                        v208 = CFArrayGetValueAtIndex(v206, v207);
                        v313.length = CFArrayGetCount(v206);
                        v313.location = 0;
                        if (!CFArrayContainsValue(v206, v313, v208))
                        {
                          v314.length = CFArrayGetCount(v118);
                          v314.location = 0;
                          if (!CFArrayContainsValue(v118, v314, v208))
                            break;
                        }
                        if (++v207 >= CFArrayGetCount(v206))
                          goto LABEL_121;
                      }
                      v209 = __log_SCNetworkConfiguration();
                      v210 = _SC_syslog_os_log_mapping(5);
                      if (__SC_log_enabled(5, v209, (os_log_type_t)v210))
                      {
                        v211 = _os_log_pack_size();
                        LODWORD(v291) = v210;
                        v293 = (uint64_t *)&v290;
                        v219 = MEMORY[0x1E0C80A78](v211, v212, v213, v214, v215, v216, v217, v218);
                        v290 = v209;
                        v220 = (char *)&v290 - ((v219 + 15) & 0xFFFFFFFFFFFFFFF0);
                        __error();
                        v221 = _os_log_pack_fill();
                        *(_DWORD *)v221 = v292;
                        *(_QWORD *)(v221 + 4) = v208;
                        *(_WORD *)(v221 + 12) = 2112;
                        *(_QWORD *)(v221 + 14) = ValueAtIndex;
                        __SC_log_send(5, (uint64_t)v290, v291, v220);
                      }
                    }
                  }
LABEL_121:
                  CFRelease(v115);
                  v13 = "";
                  v174 = v294;
                }
                else
                {
                  v178 = __log_SCNetworkConfiguration();
                  v179 = _SC_syslog_os_log_mapping(5);
                  if (__SC_log_enabled(5, v178, (os_log_type_t)v179))
                  {
                    v180 = _os_log_pack_size();
                    v294 = v174;
                    v293 = (uint64_t *)&v290;
                    v188 = Mutable;
                    v189 = v13;
                    v190 = (char *)&v290
                         - ((MEMORY[0x1E0C80A78](v180, v181, v182, v183, v184, v185, v186, v187) + 15) & 0xFFFFFFFFFFFFFFF0);
                    __error();
                    v174 = v294;
                    v191 = _os_log_pack_fill();
                    *(_DWORD *)v191 = v292;
                    *(_QWORD *)(v191 + 4) = v301;
                    *(_WORD *)(v191 + 12) = 2112;
                    *(_QWORD *)(v191 + 14) = ValueAtIndex;
                    v192 = v190;
                    v13 = v189;
                    Mutable = v188;
                    __SC_log_send(5, (uint64_t)v178, v179, v192);
                  }
                }
                ++v174;
                v115 = 0;
              }
              while (v174 < CFArrayGetCount(v117) && v302);
            }
            v282 = (const __CFArray *)SCBridgeInterfaceCopyAll(v301);
            if (v282)
            {
              v283 = v282;
              v318.length = CFArrayGetCount(v282);
              v318.location = 0;
              CFArrayApplyFunction(v283, v318, (CFArrayApplierFunction)validate_bridge, v298);
              CFRelease(v283);
            }
            v284 = SCVLANInterfaceCopyAll(v301);
            if (v284)
            {
              v285 = v284;
              v286 = malloc_type_calloc(1uLL, 0x18uLL, 0x6004045F868BCuLL);
              v287 = v298;
              *v286 = v301;
              v286[1] = v287;
              v288 = (const void *)*MEMORY[0x1E0C9B0D0];
              v286[2] = *MEMORY[0x1E0C9B0D0];
              v319.length = CFArrayGetCount(v285);
              v319.location = 0;
              CFArrayApplyFunction(v285, v319, (CFArrayApplierFunction)validate_vlan, v286);
              v289 = (const void *)v286[2];
              if (v289 && v289 != v288)
                CFRelease(v289);
              free(v286);
              CFRelease(v285);
            }
            v31 = v295;
            v116 = v297;
            v101 = v296;
            goto LABEL_132;
          }
          v302 = 0;
          v251 = __log_SCNetworkConfiguration();
          v252 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v251, (os_log_type_t)v252))
          {
            v253 = _os_log_pack_size();
            v261 = (char *)&v290
                 - ((MEMORY[0x1E0C80A78](v253, v254, v255, v256, v257, v258, v259, v260) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v262 = _os_log_pack_fill();
            *(_DWORD *)v262 = 138412290;
            *(_QWORD *)(v262 + 4) = v301;
            v263 = v261;
            v101 = v296;
            __SC_log_send(5, (uint64_t)v251, v252, v263);
            v13 = "";
          }
        }
        else
        {
          v302 = 0;
          v222 = __log_SCNetworkConfiguration();
          v223 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v222, (os_log_type_t)v223))
          {
            v224 = _os_log_pack_size();
            v232 = (char *)&v290
                 - ((MEMORY[0x1E0C80A78](v224, v225, v226, v227, v228, v229, v230, v231) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v233 = _os_log_pack_fill();
            *(_DWORD *)v233 = 138412290;
            *(_QWORD *)(v233 + 4) = v301;
            __SC_log_send(5, (uint64_t)v222, v223, v232);
            v101 = v296;
          }
          v117 = 0;
        }
        v115 = 0;
        v31 = v295;
        goto LABEL_131;
      }
      v146 = v31;
      v302 = 0;
      v147 = __log_SCNetworkConfiguration();
      v148 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v147, (os_log_type_t)v148))
        goto LABEL_91;
    }
    else
    {
      v146 = v31;
      v302 = 0;
      v147 = __log_SCNetworkConfiguration();
      v148 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v147, (os_log_type_t)v148))
      {
LABEL_91:
        v149 = _os_log_pack_size();
        v157 = (char *)&v290
             - ((MEMORY[0x1E0C80A78](v149, v150, v151, v152, v153, v154, v155, v156) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v158 = _os_log_pack_fill();
        *(_DWORD *)v158 = 138412290;
        *(_QWORD *)(v158 + 4) = v301;
        __SC_log_send(5, (uint64_t)v147, v148, v157);
      }
    }
    v118 = 0;
    v117 = 0;
    Mutable = 0;
    v116 = 0;
    v299 = 0;
    v94 = 0;
    v115 = 0;
    v31 = v146;
    v101 = 0;
    goto LABEL_132;
  }
  v120 = __log_SCNetworkConfiguration();
  v121 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v120, (os_log_type_t)v121))
  {
    v122 = _os_log_pack_size();
    v130 = (char *)&v290
         - ((MEMORY[0x1E0C80A78](v122, v123, v124, v125, v126, v127, v128, v129) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v131 = _os_log_pack_fill();
    *(_DWORD *)v131 = 138412290;
    *(_QWORD *)(v131 + 4) = a2;
    __SC_log_send(5, (uint64_t)v120, v121, v130);
  }
  v302 = 0;
LABEL_80:
  if (!v31)
    _SCNetworkConfigurationSetBypassSystemInterfaces((uint64_t)v301, 0);
  v132 = __log_SCNetworkConfiguration();
  v133 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v132, (os_log_type_t)v133))
  {
    v134 = _os_log_pack_size();
    v142 = (char *)&v290
         - ((MEMORY[0x1E0C80A78](v134, v135, v136, v137, v138, v139, v140, v141) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v143 = _os_log_pack_fill();
    if (v302)
      v144 = v13;
    else
      v144 = "not ";
    *(_DWORD *)v143 = 136315138;
    *(_QWORD *)(v143 + 4) = v144;
    __SC_log_send(6, (uint64_t)v132, v133, v142);
  }
  return v302;
}

void logInterfaces(uint64_t a1, const __CFArray *a2, int a3)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  __CFArray *Mutable;
  CFIndex Count;
  __int128 v18;
  CFIndex v19;
  CFIndex v20;
  const __SCNetworkInterface *ValueAtIndex;
  CFTypeID TypeID;
  CFStringRef BSDName;
  const __CFString *v24;
  uint64_t UserDefinedName;
  CFTypeID v26;
  const __CFString *Value;
  const __CFDictionary *v28;
  const __CFString *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  const __CFArray *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  const __CFString *v43;
  CFStringRef v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  const __CFString *v58;
  __int128 v59;
  __CFArray *v60;
  CFIndex v61;
  uint64_t v62;

  v57 = a1;
  v62 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v4 = __log_SCNetworkConfiguration();
    v5 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v4, (os_log_type_t)v5))
    {
      v6 = _os_log_pack_size();
      v14 = (char *)&v57 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v15 = _os_log_pack_fill();
      *(_DWORD *)v15 = 136315138;
      *(_QWORD *)(v15 + 4) = v57;
      __SC_log_send(7, (uint64_t)v4, v5, v14);
    }
    Mutable = 0;
  }
  else
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  }
  Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    v19 = Count;
    v20 = 0;
    v58 = CFSTR("UserDefinedName");
    *(_QWORD *)&v18 = 138412546;
    v59 = v18;
    v60 = Mutable;
    v61 = Count;
    do
    {
      ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(a2, v20);
      TypeID = SCNetworkInterfaceGetTypeID();
      if (!ValueAtIndex)
      {
        CFDictionaryGetTypeID();
LABEL_19:
        v29 = 0;
        v24 = CFSTR("?");
        if (!Mutable)
          goto LABEL_22;
        goto LABEL_20;
      }
      if (CFGetTypeID(ValueAtIndex) == TypeID)
      {
        BSDName = SCNetworkInterfaceGetBSDName(ValueAtIndex);
        if (BSDName)
        {
          v24 = BSDName;
          UserDefinedName = __SCNetworkInterfaceGetUserDefinedName(ValueAtIndex);
LABEL_17:
          v29 = (const __CFString *)UserDefinedName;
          if (!Mutable)
            goto LABEL_22;
          goto LABEL_20;
        }
      }
      else
      {
        v26 = CFDictionaryGetTypeID();
        if (CFGetTypeID(ValueAtIndex) != v26)
          goto LABEL_19;
        Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("BSD Name"));
        if (Value)
        {
          v24 = Value;
          v28 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SCNetworkInterfaceInfo"));
          if (v28)
          {
            UserDefinedName = (uint64_t)CFDictionaryGetValue(v28, v58);
            goto LABEL_17;
          }
          v29 = 0;
          if (!Mutable)
          {
LABEL_22:
            v30 = __log_SCNetworkConfiguration();
            v31 = _SC_syslog_os_log_mapping(7);
            if (__SC_log_enabled(7, v30, (os_log_type_t)v31))
            {
              v32 = _os_log_pack_size();
              v33 = a2;
              v41 = (char *)&v57
                  - ((MEMORY[0x1E0C80A78](v32, v34, v35, v36, v37, v38, v39, v40) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              v42 = _os_log_pack_fill();
              *(_DWORD *)v42 = v59;
              if (v29)
                v43 = v29;
              else
                v43 = CFSTR("?");
              *(_QWORD *)(v42 + 4) = v24;
              *(_WORD *)(v42 + 12) = 2112;
              *(_QWORD *)(v42 + 14) = v43;
              __SC_log_send(7, (uint64_t)v30, v31, v41);
              a2 = v33;
              Mutable = v60;
              v19 = v61;
            }
            goto LABEL_27;
          }
LABEL_20:
          CFArrayAppendValue(Mutable, v24);
        }
      }
LABEL_27:
      ++v20;
    }
    while (v19 != v20);
  }
  if (Mutable)
  {
    v44 = CFStringCreateByCombiningStrings(0, Mutable, CFSTR(", "));
    v45 = __log_SCNetworkConfiguration();
    v46 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v45, (os_log_type_t)v46))
    {
      v47 = _os_log_pack_size();
      v55 = (char *)&v57 - ((MEMORY[0x1E0C80A78](v47, v48, v49, v50, v51, v52, v53, v54) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v56 = _os_log_pack_fill();
      *(_DWORD *)v56 = 136315394;
      *(_QWORD *)(v56 + 4) = v57;
      *(_WORD *)(v56 + 12) = 2112;
      *(_QWORD *)(v56 + 14) = v44;
      __SC_log_send(7, (uint64_t)v45, v46, v55);
    }
    CFRelease(v44);
    CFRelease(Mutable);
  }
}

void _SCNetworkConfigurationValidateInterface(void *key, _QWORD *a2, uint64_t a3)
{
  int v3;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  __CFArray *v9;
  __CFArray *v10;
  const __CFDictionary *v11;
  _QWORD *Value;
  const void *v13;
  const __CFString *UserDefinedName;
  const __CFString *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  CFTypeID TypeID;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __CFArray *v41;
  char *v42;
  uint64_t v43;
  char *v44;
  CFTypeID v45;
  __CFArray *v46;
  CFTypeID v47;
  __CFArray *v48;
  NSObject *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  __CFArray *v62;
  __CFArray *v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned __int8 *)(a3 + 80);
  if (**(_BYTE **)(a3 + 32) | v3)
  {
    v8 = *(const __CFDictionary **)a3;
    v7 = *(const __CFDictionary **)(a3 + 8);
    v9 = *(__CFArray **)(a3 + 40);
    v63 = *(__CFArray **)(a3 + 48);
    v10 = *(__CFArray **)(a3 + 56);
    v11 = *(const __CFDictionary **)(a3 + 16);
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 24), key);
    if (Value)
    {
      v13 = Value;
      UserDefinedName = (const __CFString *)__SCNetworkInterfaceGetUserDefinedName(Value);
      v15 = (const __CFString *)__SCNetworkInterfaceGetUserDefinedName(a2);
      if (!__SCNetworkConfigurationInterfaceNameIsEquiv(UserDefinedName, v15))
      {
        v16 = __log_SCNetworkConfiguration();
        v17 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v16, (os_log_type_t)v17))
        {
          v18 = _os_log_pack_size();
          v61 = (uint64_t)&v61;
          v26 = MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25);
          v62 = v9;
          v27 = (char *)&v61 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v28 = _os_log_pack_fill();
          *(_DWORD *)v28 = 138412546;
          *(_QWORD *)(v28 + 4) = UserDefinedName;
          *(_WORD *)(v28 + 12) = 2112;
          *(_QWORD *)(v28 + 14) = v15;
          v29 = v27;
          v9 = v62;
          __SC_log_send(5, (uint64_t)v16, v17, v29);
        }
        **(_BYTE **)(a3 + 32) = 0;
        TypeID = CFArrayGetTypeID();
        if (v10 && CFGetTypeID(v10) == TypeID && __SCNetworkInterfaceMatchesName(UserDefinedName, v15))
        {
          v31 = __log_SCNetworkConfiguration();
          v32 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v31, (os_log_type_t)v32))
          {
            v33 = _os_log_pack_size();
            v62 = (__CFArray *)&v61;
            v41 = v9;
            v42 = (char *)&v61
                - ((MEMORY[0x1E0C80A78](v33, v34, v35, v36, v37, v38, v39, v40) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v43 = _os_log_pack_fill();
            *(_DWORD *)v43 = 138412546;
            *(_QWORD *)(v43 + 4) = v15;
            *(_WORD *)(v43 + 12) = 2112;
            *(_QWORD *)(v43 + 14) = UserDefinedName;
            v44 = v42;
            v9 = v41;
            __SC_log_send(5, (uint64_t)v31, v32, v44);
          }
          CFArrayAppendValue(v10, a2);
        }
        v45 = CFArrayGetTypeID();
        v46 = v63;
        if (v63 && CFGetTypeID(v63) == v45)
          CFArrayAppendValue(v46, v13);
        v47 = CFArrayGetTypeID();
        if (v9)
        {
          if (CFGetTypeID(v9) == v47)
            CFArrayAppendValue(v9, a2);
        }
      }
    }
    else if (v8
           && !CFDictionaryContainsKey(v8, key)
           && v7
           && !CFDictionaryContainsKey(v7, key)
           && v11
           && !CFDictionaryContainsKey(v11, key))
    {
      v48 = v9;
      v49 = __log_SCNetworkConfiguration();
      v50 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v49, (os_log_type_t)v50))
      {
        v51 = _os_log_pack_size();
        v59 = (char *)&v61 - ((MEMORY[0x1E0C80A78](v51, v52, v53, v54, v55, v56, v57, v58) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v60 = _os_log_pack_fill();
        *(_DWORD *)v60 = 138412290;
        *(_QWORD *)(v60 + 4) = key;
        __SC_log_send(5, (uint64_t)v49, v50, v59);
      }
      if (v3)
        CFArrayAppendValue(v48, a2);
      **(_BYTE **)(a3 + 32) = 0;
    }
  }
}

void validate_bridge(const __SCNetworkInterface *a1, const __SCPreferences *a2)
{
  const __CFArray *MemberInterfaces;
  __CFArray *Mutable;
  CFIndex v6;
  const __SCNetworkInterface *ValueAtIndex;
  CFStringRef BSDName;
  const void *v9;
  const void *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  MemberInterfaces = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces(a1);
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (CFArrayGetCount(MemberInterfaces) >= 1)
  {
    v6 = 0;
    do
    {
      ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(MemberInterfaces, v6);
      BSDName = SCNetworkInterfaceGetBSDName(ValueAtIndex);
      if (BSDName)
      {
        v9 = (const void *)__SCNetworkInterfaceCreateWithNIPreferencesUsingBSDName(0, a2, BSDName);
        if (v9)
        {
          v10 = v9;
          CFArrayAppendValue(Mutable, v9);
          CFRelease(v10);
        }
      }
      ++v6;
    }
    while (v6 < CFArrayGetCount(MemberInterfaces));
  }
  if (CFArrayGetCount(Mutable))
  {
    SCBridgeInterfaceSetMemberInterfaces((const __SCPreferences **)a1, Mutable);
  }
  else
  {
    v11 = __log_SCNetworkConfiguration();
    v12 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v11, (os_log_type_t)v12))
    {
      v13 = _os_log_pack_size();
      v21 = (char *)v23 - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v22 = _os_log_pack_fill();
      *(_DWORD *)v22 = 138412290;
      *(_QWORD *)(v22 + 4) = a1;
      __SC_log_send(5, (uint64_t)v11, v12, v21);
    }
    SCBridgeInterfaceRemove((SCPreferencesRef *)a1);
  }
  CFRelease(Mutable);
}

void validate_vlan(const __SCNetworkInterface *a1, const __SCPreferences **a2)
{
  const __SCNetworkInterface *PhysicalInterface;
  CFStringRef BSDName;
  CFStringRef v6;
  const void *v7;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const __SCNetworkInterface *ValueAtIndex;
  CFStringRef v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  _QWORD v26[2];

  v26[1] = *MEMORY[0x1E0C80C00];
  PhysicalInterface = SCVLANInterfaceGetPhysicalInterface(a1);
  BSDName = SCNetworkInterfaceGetBSDName(PhysicalInterface);
  if (!BSDName)
    goto LABEL_14;
  v6 = BSDName;
  v7 = (const void *)__SCNetworkInterfaceCreateWithNIPreferencesUsingBSDName(0, a2[1], BSDName);
  if (v7)
  {
    CFRelease(v7);
    return;
  }
  v8 = a2[2];
  if (v8 == (const __CFArray *)*MEMORY[0x1E0C9B0D0])
  {
    v8 = (const __CFArray *)SCBridgeInterfaceCopyAll(*a2);
    a2[2] = v8;
    if (v8)
      goto LABEL_8;
LABEL_14:
    v14 = __log_SCNetworkConfiguration();
    v15 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v14, (os_log_type_t)v15))
    {
      v16 = _os_log_pack_size();
      v24 = (char *)v26 - ((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v25 = _os_log_pack_fill();
      *(_DWORD *)v25 = 138412290;
      *(_QWORD *)(v25 + 4) = a1;
      __SC_log_send(5, (uint64_t)v14, v15, v24);
    }
    SCVLANInterfaceRemove(a1);
    return;
  }
  if (!v8)
    goto LABEL_14;
LABEL_8:
  Count = CFArrayGetCount(v8);
  if (Count < 1)
    goto LABEL_14;
  v10 = Count;
  v11 = 0;
  while (1)
  {
    ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v8, v11);
    v13 = SCNetworkInterfaceGetBSDName(ValueAtIndex);
    if (v13 == v6 || v13 && CFEqual(v6, v13))
      break;
    if (v10 == ++v11)
      goto LABEL_14;
  }
}

uint64_t _SCNetworkConfigurationCheckValidity(uint64_t a1, const __CFDictionary *a2)
{
  const void *v3;
  const __CFURL *v4;
  const __CFURL *v5;
  const __CFString *v6;
  const __CFString *v7;
  const __SCPreferences *v8;
  const __SCPreferences *v9;
  const __SCPreferences *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  UInt8 *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  UInt8 v46[1024];
  UInt8 v47[1024];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = (const void *)MEMORY[0x18D78C2F4](0, CFSTR("Library/Preferences/SystemConfiguration/"), 0, 1, a1);
    v4 = (const __CFURL *)MEMORY[0x18D78C2DC](0, "preferences.plist", 18, 0, v3);
    v5 = (const __CFURL *)MEMORY[0x18D78C2DC](0, "NetworkInterfaces.plist", 24, 0, v3);
    if (CFURLGetFileSystemRepresentation(v4, 1u, v46, 1024))
    {
      if (CFURLGetFileSystemRepresentation(v5, 1u, v47, 1024))
      {
        v6 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v46);
        v7 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v47);
        v8 = (const __SCPreferences *)__SCPreferencesCreateForMigration(CFSTR("System Migration"), v6);
        v9 = (const __SCPreferences *)__SCPreferencesCreateForMigration(CFSTR("System Migration"), v7);
        v10 = v9;
        v11 = 0;
        if (v8 && v9)
          v11 = _SCNetworkConfigurationCheckValidityWithPreferences(v8, v9, a2);
        goto LABEL_16;
      }
      v24 = __log_SCNetworkConfiguration();
      v25 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v24, (os_log_type_t)v25))
      {
        v36 = _os_log_pack_size();
        v34 = &v46[-((MEMORY[0x1E0C80A78](v36, v37, v38, v39, v40, v41, v42, v43) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v44 = _os_log_pack_fill();
        *(_DWORD *)v44 = 138412290;
        *(_QWORD *)(v44 + 4) = v5;
        goto LABEL_14;
      }
    }
    else
    {
      v24 = __log_SCNetworkConfiguration();
      v25 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v24, (os_log_type_t)v25))
      {
        v26 = _os_log_pack_size();
        v34 = &v46[-((MEMORY[0x1E0C80A78](v26, v27, v28, v29, v30, v31, v32, v33) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v35 = _os_log_pack_fill();
        *(_DWORD *)v35 = 138412290;
        *(_QWORD *)(v35 + 4) = v4;
LABEL_14:
        __SC_log_send(5, (uint64_t)v24, v25, (char *)v34);
      }
    }
    v11 = 0;
    v6 = 0;
    v8 = 0;
    v10 = 0;
    v7 = 0;
LABEL_16:
    if (v3)
      CFRelease(v3);
    if (v6)
      CFRelease(v6);
    if (v7)
      CFRelease(v7);
    if (v8)
      CFRelease(v8);
    if (v10)
      CFRelease(v10);
    if (v4)
      CFRelease(v4);
    if (v5)
      CFRelease(v5);
    return v11;
  }
  v12 = __log_SCNetworkConfiguration();
  v13 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v12, (os_log_type_t)v13))
  {
    v14 = _os_log_pack_size();
    v22 = (char *)&v46[-((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0)];
    __error();
    v23 = _os_log_pack_fill();
    *(_DWORD *)v23 = 138412290;
    *(_QWORD *)(v23 + 4) = CFSTR("NULL");
    __SC_log_send(5, (uint64_t)v12, v13, v22);
  }
  return 0;
}

uint64_t __SCPreferencesCreateForMigration(const __CFString *a1, const __CFString *a2)
{
  const __CFDictionary *v4;
  uint64_t v5;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  keys[0] = CFSTR("allow-model-conflict");
  values = (void *)*MEMORY[0x1E0C9AE50];
  v4 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = SCPreferencesCreateWithOptions(0, a1, a2, 0, v4);
  CFRelease(v4);
  return v5;
}

BOOL _SCNetworkMigrationAreConfigurationsIdentical(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  _BOOL8 v10;
  uint64_t v11;
  const void *v12;
  const __CFURL *v13;
  const __CFURL *v14;
  const void *v15;
  const __CFURL *v16;
  const __CFURL *v17;
  CFStringRef v18;
  const __CFString *v19;
  CFStringRef v20;
  const __SCPreferences *v21;
  uint64_t v22;
  CFTypeRef v23;
  const __SCPreferences *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  const __CFURL *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  const __CFURL *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  unint64_t Count;
  const __CFDictionary *v71;
  CFTypeID v72;
  const void **v73;
  NSObject *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  const void *v84;
  char *v85;
  char *v86;
  const __SCPreferences *v87;
  SCPreferencesRef v88;
  const __CFString *v89;
  const __CFString *v90;
  NSObject *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  NSObject *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  NSObject *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  char *v134;
  uint64_t v135;
  const __CFURL *v136;
  uint64_t v137;
  const void **v138;
  const __CFArray *Mutable;
  __CFArray *v140;
  uint64_t v141;
  const void **v142;
  const void *v143;
  CFTypeID v144;
  const void **v145;
  const void **v146;
  const void **v147;
  const void *v148;
  CFTypeID v149;
  CFIndex v150;
  BOOL v151;
  CFIndex v152;
  CFIndex v153;
  const void *ValueAtIndex;
  CFIndex v155;
  CFIndex v156;
  CFIndex v157;
  const void *v158;
  CFPropertyListRef v159;
  CFTypeID v160;
  const __CFArray *MutableCopy;
  CFIndex v162;
  CFPropertyListRef v163;
  CFTypeID v164;
  CFTypeID v165;
  CFTypeID v166;
  CFIndex v167;
  int v168;
  CFIndex v169;
  CFIndex v170;
  CFIndex v171;
  CFIndex v172;
  const void *v173;
  uint64_t v174;
  CFIndex v175;
  CFIndex v176;
  const void *v177;
  CFArrayRef v178;
  const void *v179;
  const __CFDictionary *v180;
  const __CFURL *v181;
  const __CFURL *v182;
  const __CFURL *v183;
  CFStringRef v184;
  CFStringRef v185;
  const __CFString *v186;
  const __SCPreferences *v187;
  const __SCPreferences *v188;
  const __CFString *v189;
  CFTypeRef v190;
  SCPreferencesRef v191;
  UInt8 v192[1024];
  UInt8 v193[1024];
  UInt8 v194[1024];
  UInt8 v195[1024];
  _BYTE v196[512];
  _BYTE v197[512];
  uint64_t v198;

  v8 = MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6, a7, a8);
  v10 = 0;
  v198 = *MEMORY[0x1E0C80C00];
  if (!v8)
    return v10;
  v11 = v9;
  if (!v9)
    return v10;
  v12 = (const void *)MEMORY[0x18D78C2F4](0, CFSTR("Library/Preferences/SystemConfiguration/"), 0, 1, v8);
  v13 = (const __CFURL *)MEMORY[0x18D78C2DC](0, "preferences.plist", 18, 0, v12);
  if (!CFURLResourceIsReachable(v13, 0))
  {
    v25 = __log_SCNetworkConfiguration();
    v26 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v25, (os_log_type_t)v26))
    {
      v27 = _os_log_pack_size();
      v35 = (char *)&v174 - ((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v36 = _os_log_pack_fill();
      *(_DWORD *)v36 = 138412290;
      *(_QWORD *)(v36 + 4) = v13;
      __SC_log_send(5, (uint64_t)v25, v26, v35);
    }
    v185 = 0;
    v186 = 0;
    v184 = 0;
    v189 = 0;
    v16 = 0;
    v37 = 0;
    v24 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v14 = 0;
    goto LABEL_24;
  }
  v14 = (const __CFURL *)MEMORY[0x18D78C2DC](0, "NetworkInterfaces.plist", 24, 0, v12);
  if (CFURLResourceIsReachable(v14, 0))
  {
    if (CFURLGetFileSystemRepresentation(v13, 1u, v193, 1024))
    {
      if (CFURLGetFileSystemRepresentation(v14, 1u, v195, 1024))
      {
        v15 = (const void *)MEMORY[0x18D78C2F4](0, CFSTR("Library/Preferences/SystemConfiguration/"), 0, 1, v11);
        v16 = (const __CFURL *)MEMORY[0x18D78C2DC](0, "preferences.plist", 18, 0, v15);
        if (!CFURLResourceIsReachable(v16, 0))
        {
          v92 = __log_SCNetworkConfiguration();
          v93 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v92, (os_log_type_t)v93))
          {
            v94 = _os_log_pack_size();
            v191 = (SCPreferencesRef)&v174;
            v102 = (char *)&v174
                 - ((MEMORY[0x1E0C80A78](v94, v95, v96, v97, v98, v99, v100, v101) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            *(_WORD *)_os_log_pack_fill() = 0;
            __SC_log_send(5, (uint64_t)v92, v93, v102);
          }
          v185 = 0;
          v186 = 0;
          v184 = 0;
          v189 = 0;
          v37 = 0;
          goto LABEL_73;
        }
        v17 = (const __CFURL *)MEMORY[0x18D78C2DC](0, "NetworkInterfaces.plist", 24, 0, v15);
        v181 = v17;
        if (CFURLResourceIsReachable(v17, 0))
        {
          if (CFURLGetFileSystemRepresentation(v16, 1u, v192, 1024))
          {
            if (CFURLGetFileSystemRepresentation(v17, 1u, v194, 1024))
            {
              v18 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v193);
              v189 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v195);
              v19 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v192);
              v20 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v194);
              v185 = v18;
              v190 = (CFTypeRef)__SCPreferencesCreateForMigration(CFSTR("System Migration"), v18);
              v186 = v19;
              v21 = (const __SCPreferences *)__SCPreferencesCreateForMigration(CFSTR("System Migration"), v19);
              v22 = __SCPreferencesCreateForMigration(CFSTR("System Migration"), v189);
              v23 = v190;
              v184 = v20;
              v24 = (const __SCPreferences *)__SCPreferencesCreateForMigration(CFSTR("System Migration"), v20);
LABEL_80:
              v37 = v181;
              goto LABEL_25;
            }
            v123 = __log_SCNetworkConfiguration();
            v124 = _SC_syslog_os_log_mapping(5);
            if (__SC_log_enabled(5, v123, (os_log_type_t)v124))
            {
              v125 = _os_log_pack_size();
              v179 = v15;
              v191 = (SCPreferencesRef)&v174;
              v133 = MEMORY[0x1E0C80A78](v125, v126, v127, v128, v129, v130, v131, v132);
              v182 = v16;
              v134 = (char *)&v174 - ((v133 + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              v15 = v179;
              v135 = _os_log_pack_fill();
              *(_DWORD *)v135 = 138412290;
              v136 = v181;
              v16 = v182;
              *(_QWORD *)(v135 + 4) = v181;
              v137 = (uint64_t)v123;
              v37 = v136;
              __SC_log_send(5, v137, v124, v134);
              v185 = 0;
              v186 = 0;
              v184 = 0;
              v189 = 0;
LABEL_73:
              v24 = 0;
              v21 = 0;
              v22 = 0;
              v23 = 0;
              goto LABEL_25;
            }
LABEL_79:
            v185 = 0;
            v186 = 0;
            v184 = 0;
            v189 = 0;
            v24 = 0;
            v21 = 0;
            v22 = 0;
            v23 = 0;
            goto LABEL_80;
          }
          v103 = __log_SCNetworkConfiguration();
          v104 = _SC_syslog_os_log_mapping(5);
          if (!__SC_log_enabled(5, v103, (os_log_type_t)v104))
            goto LABEL_79;
          v114 = _os_log_pack_size();
          v179 = v15;
          v191 = (SCPreferencesRef)&v174;
          v113 = (char *)&v174
               - ((MEMORY[0x1E0C80A78](v114, v115, v116, v117, v118, v119, v120, v121) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v15 = v179;
          v122 = _os_log_pack_fill();
          *(_DWORD *)v122 = 138412290;
          *(_QWORD *)(v122 + 4) = v16;
        }
        else
        {
          v103 = __log_SCNetworkConfiguration();
          v104 = _SC_syslog_os_log_mapping(5);
          if (!__SC_log_enabled(5, v103, (os_log_type_t)v104))
            goto LABEL_79;
          v105 = _os_log_pack_size();
          v191 = (SCPreferencesRef)&v174;
          v113 = (char *)&v174
               - ((MEMORY[0x1E0C80A78](v105, v106, v107, v108, v109, v110, v111, v112) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
        }
        __SC_log_send(5, (uint64_t)v103, v104, v113);
        goto LABEL_79;
      }
      v38 = __log_SCNetworkConfiguration();
      v39 = _SC_syslog_os_log_mapping(5);
      if (!__SC_log_enabled(5, v38, (os_log_type_t)v39))
        goto LABEL_23;
      v59 = _os_log_pack_size();
      v41 = v14;
      v49 = (char *)&v174 - ((MEMORY[0x1E0C80A78](v59, v60, v61, v62, v63, v64, v65, v66) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      goto LABEL_21;
    }
    v38 = __log_SCNetworkConfiguration();
    v39 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v38, (os_log_type_t)v39))
    {
      v50 = _os_log_pack_size();
      v49 = (char *)&v174 - ((MEMORY[0x1E0C80A78](v50, v51, v52, v53, v54, v55, v56, v57) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v58 = _os_log_pack_fill();
      *(_DWORD *)v58 = 138412290;
      *(_QWORD *)(v58 + 4) = v13;
LABEL_22:
      __SC_log_send(5, (uint64_t)v38, v39, v49);
    }
  }
  else
  {
    v38 = __log_SCNetworkConfiguration();
    v39 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v38, (os_log_type_t)v39))
    {
      v40 = _os_log_pack_size();
      v41 = v14;
      v49 = (char *)&v174 - ((MEMORY[0x1E0C80A78](v40, v42, v43, v44, v45, v46, v47, v48) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
LABEL_21:
      v14 = v41;
      v67 = _os_log_pack_fill();
      *(_DWORD *)v67 = 138412290;
      *(_QWORD *)(v67 + 4) = v41;
      goto LABEL_22;
    }
  }
LABEL_23:
  v185 = 0;
  v186 = 0;
  v184 = 0;
  v189 = 0;
  v16 = 0;
  v37 = 0;
  v24 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
LABEL_24:
  v15 = 0;
LABEL_25:
  v187 = v24;
  v188 = (const __SCPreferences *)v22;
  v190 = v23;
  v191 = v21;
  if (v23 && v21 && v22 && v24)
  {
    v183 = v13;
    Value = (const __CFDictionary *)SCPreferencesGetValue((SCPreferencesRef)v23, CFSTR("NetworkServices"));
    TypeID = CFDictionaryGetTypeID();
    if (Value)
    {
      if (CFGetTypeID(Value) == TypeID)
      {
        Count = CFDictionaryGetCount(Value);
        v71 = (const __CFDictionary *)SCPreferencesGetValue(v191, CFSTR("NetworkServices"));
        v72 = CFDictionaryGetTypeID();
        if (v71)
        {
          if (CFGetTypeID(v71) == v72 && Count == CFDictionaryGetCount(v71))
          {
            v180 = v71;
            v181 = v37;
            v179 = v15;
            v182 = v16;
            if (Count < 0x41)
              v73 = (const void **)v196;
            else
              v73 = (const void **)CFAllocatorAllocate(0, 8 * Count, 0);
            v177 = v12;
            memset(v197, 0, sizeof(v197));
            memset(v196, 0, sizeof(v196));
            v138 = v73;
            CFDictionaryGetKeysAndValues(Value, 0, v73);
            Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
            if (Count)
            {
              v140 = Mutable;
              v141 = 0;
              v142 = v138;
              do
              {
                v143 = v142[v141];
                v144 = CFDictionaryGetTypeID();
                if (v143 && CFGetTypeID(v143) == v144)
                  CFArrayAppendValue(v140, v143);
                ++v141;
                v142 = v138;
              }
              while (Count != v141);
              v178 = (CFArrayRef)CFArrayGetCount(v140);
              if (Count > 0x40)
              {
                v145 = (const void **)CFAllocatorAllocate(0, Count, 0);
                goto LABEL_94;
              }
            }
            else
            {
              v140 = Mutable;
              v178 = (CFArrayRef)CFArrayGetCount(Mutable);
            }
            v145 = (const void **)v197;
LABEL_94:
            v146 = v145;
            CFDictionaryGetKeysAndValues(v180, 0, v145);
            v180 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
            if (Count)
            {
              v147 = v146;
              do
              {
                v148 = *v147;
                v149 = CFDictionaryGetTypeID();
                if (v148 && CFGetTypeID(v148) == v149)
                  CFArrayAppendValue(v180, v148);
                ++v147;
                --Count;
              }
              while (Count);
            }
            v150 = CFArrayGetCount(v180);
            v151 = 1;
            if (v178 == (CFArrayRef)v150)
            {
              v13 = v183;
              if (v150 >= 1)
              {
                v152 = 0;
                while (1)
                {
                  v153 = v152;
                  ValueAtIndex = CFArrayGetValueAtIndex(v180, v152);
                  v155 = CFArrayGetCount(v140);
                  v151 = v155 < 1;
                  if (v155 < 1)
                    break;
                  v156 = v155;
                  v157 = 0;
                  while (1)
                  {
                    v158 = CFArrayGetValueAtIndex(v140, v157);
                    if (CFEqual(ValueAtIndex, v158))
                      break;
                    if (v156 == ++v157)
                    {
                      v151 = 1;
                      goto LABEL_110;
                    }
                  }
                  v152 = v153 + 1;
                  v13 = v183;
                  if ((CFArrayRef)(v153 + 1) == v178)
                    goto LABEL_111;
                }
                v151 = 1;
              }
            }
            else
            {
LABEL_110:
              v13 = v183;
            }
LABEL_111:
            if (v138 != (const void **)v196)
              CFAllocatorDeallocate(0, v138);
            v87 = v188;
            if (v146 != (const void **)v197)
              CFAllocatorDeallocate(0, v146);
            if (v151)
            {
              v10 = 0;
              v12 = v177;
              v37 = v181;
              v16 = v182;
              v15 = v179;
              goto LABEL_41;
            }
            v159 = SCPreferencesGetValue(v87, CFSTR("Interfaces"));
            v160 = CFArrayGetTypeID();
            if (!v159 || CFGetTypeID(v159) != v160)
            {
              v168 = 0;
              v12 = v177;
              v37 = v181;
              v16 = v182;
              v15 = v179;
              goto LABEL_138;
            }
            MutableCopy = CFArrayCreateMutableCopy(0, 0, (CFArrayRef)v159);
            v162 = CFArrayGetCount(MutableCopy);
            v163 = SCPreferencesGetValue(v187, CFSTR("Interfaces"));
            v164 = CFArrayGetTypeID();
            v12 = v177;
            if (v163)
            {
              v165 = v164;
              v166 = CFGetTypeID(v163);
              v16 = v182;
              if (v166 == v165)
              {
                v178 = (CFArrayRef)v163;
                v167 = CFArrayGetCount((CFArrayRef)v163);
                v168 = 0;
                v15 = v179;
                if (v162 == v167)
                {
                  v175 = v162;
                  v37 = v181;
                  if (v167 >= 1)
                  {
                    v169 = 0;
                    while (1)
                    {
                      v176 = v169;
                      v180 = (const __CFDictionary *)CFArrayGetValueAtIndex(v178, v169);
                      v170 = CFArrayGetCount(MutableCopy);
                      if (v170 < 1)
                        break;
                      v171 = v170;
                      v172 = 0;
                      while (1)
                      {
                        v173 = CFArrayGetValueAtIndex((CFArrayRef)v159, v172);
                        if (CFEqual(v180, v173))
                          break;
                        if (v171 == ++v172)
                          goto LABEL_140;
                      }
                      v169 = v176 + 1;
                      v168 = 1;
                      v13 = v183;
                      if (v176 + 1 == v175)
                        goto LABEL_136;
                    }
LABEL_140:
                    v168 = 0;
                    v13 = v183;
                    if (!MutableCopy)
                      goto LABEL_138;
                    goto LABEL_137;
                  }
                  goto LABEL_136;
                }
LABEL_135:
                v37 = v181;
LABEL_136:
                if (MutableCopy)
LABEL_137:
                  CFRelease(MutableCopy);
LABEL_138:
                v87 = v188;
                v10 = v168 != 0;
                goto LABEL_41;
              }
              v168 = 0;
            }
            else
            {
              v168 = 0;
              v16 = v182;
            }
            v15 = v179;
            goto LABEL_135;
          }
        }
      }
    }
    v10 = 0;
    v13 = v183;
  }
  else
  {
    v74 = __log_SCNetworkConfiguration();
    v75 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v74, (os_log_type_t)v75))
    {
      v76 = _os_log_pack_size();
      v182 = v16;
      v183 = (const __CFURL *)&v174;
      v84 = v12;
      v85 = (char *)&v174 - ((MEMORY[0x1E0C80A78](v76, v77, v78, v79, v80, v81, v82, v83) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      v86 = v85;
      v12 = v84;
      __SC_log_send(5, (uint64_t)v74, v75, v86);
      v16 = v182;
    }
    v10 = 0;
  }
  v87 = v188;
LABEL_41:
  if (v12)
    CFRelease(v12);
  v88 = v191;
  if (v13)
    CFRelease(v13);
  if (v14)
    CFRelease(v14);
  if (v15)
    CFRelease(v15);
  v89 = v189;
  if (v16)
    CFRelease(v16);
  if (v37)
    CFRelease(v37);
  if (v185)
    CFRelease(v185);
  v90 = v186;
  if (v89)
    CFRelease(v89);
  if (v90)
    CFRelease(v90);
  if (v184)
    CFRelease(v184);
  if (v190)
    CFRelease(v190);
  if (v88)
    CFRelease(v88);
  if (v87)
    CFRelease(v87);
  if (v187)
    CFRelease(v187);
  return v10;
}

__CFArray *_SCNetworkConfigurationCopyMigrationRemovePaths(const __CFArray *a1, uint64_t a2)
{
  __CFArray *Mutable;
  __int128 v5;
  CFIndex v6;
  const void *ValueAtIndex;
  size_t v8;
  const __CFURL *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  __int128 v23;
  uint64_t v24;
  UInt8 v25[1024];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (CFArrayGetCount(a1) >= 1)
  {
    v6 = 0;
    *(_QWORD *)&v5 = 138412290;
    v23 = v5;
    v24 = a2;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v6);
      if (CFURLGetFileSystemRepresentation((CFURLRef)ValueAtIndex, 1u, v25, 1024))
      {
        v8 = strnlen((const char *)v25, 0x400uLL);
        v9 = (const __CFURL *)MEMORY[0x18D78C2DC](0, v25, v8, 0, a2);
        if (!CFURLResourceIsReachable(v9, 0))
          CFArrayAppendValue(Mutable, ValueAtIndex);
        CFRelease(v9);
      }
      else
      {
        v10 = __log_SCNetworkConfiguration();
        v11 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v10, (os_log_type_t)v11))
        {
          v12 = _os_log_pack_size();
          v20 = (char *)&v23
              - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v21 = _os_log_pack_fill();
          *(_DWORD *)v21 = v23;
          *(_QWORD *)(v21 + 4) = ValueAtIndex;
          __SC_log_send(5, (uint64_t)v10, v11, v20);
          a2 = v24;
        }
      }
      ++v6;
    }
    while (v6 < CFArrayGetCount(a1));
  }
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

void logMapping_one(const __SCNetworkService *a1, const __SCNetworkService *a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeID TypeID;
  CFStringRef ServiceID;
  CFTypeID v21;
  CFTypeID v22;
  CFTypeID v23;
  CFStringRef SetID;
  __CFString *Mutable;
  CFTypeID v26;
  char v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  CFTypeID v40;
  CFStringRef BSDName;
  uint64_t UserDefinedName;
  const __CFString *v43;
  CFTypeID v44;
  CFTypeID v45;
  CFIndex Count;
  CFIndex i;
  const __SCNetworkSet *ValueAtIndex;
  CFTypeID v49;
  const char *v50;
  _QWORD v51[2];

  v51[1] = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a3 + 8))
  {
    v6 = __log_SCNetworkConfiguration();
    v7 = _SC_syslog_os_log_mapping(*(_DWORD *)a3);
    if (__SC_log_enabled(*(_DWORD *)a3, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = (char *)v51 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v17 = _os_log_pack_fill();
      v18 = *(_QWORD *)(a3 + 8);
      *(_DWORD *)v17 = 136315138;
      *(_QWORD *)(v17 + 4) = v18;
      __SC_log_send(*(_DWORD *)a3, (uint64_t)v6, v7, v16);
    }
    *(_QWORD *)(a3 + 8) = 0;
  }
  TypeID = SCNetworkServiceGetTypeID();
  if (!a1)
  {
    SCNetworkSetGetTypeID();
    SCNetworkInterfaceGetTypeID();
    goto LABEL_14;
  }
  if (CFGetTypeID(a1) == TypeID)
  {
    ServiceID = SCNetworkServiceGetServiceID(a1);
  }
  else
  {
    v21 = SCNetworkSetGetTypeID();
    if (CFGetTypeID(a1) == v21)
    {
      ServiceID = SCNetworkSetGetSetID(a1);
    }
    else
    {
      v22 = SCNetworkInterfaceGetTypeID();
      if (CFGetTypeID(a1) != v22)
        goto LABEL_14;
      ServiceID = SCNetworkInterfaceGetBSDName(a1);
    }
  }
  a1 = (const __SCNetworkService *)ServiceID;
LABEL_14:
  v23 = SCNetworkServiceGetTypeID();
  if (!a2)
  {
    SCNetworkSetGetTypeID();
    SCNetworkInterfaceGetTypeID();
    CFBooleanGetTypeID();
    CFArrayGetTypeID();
    Mutable = 0;
LABEL_21:
    v27 = 1;
    goto LABEL_22;
  }
  if (CFGetTypeID(a2) == v23)
  {
    SetID = SCNetworkServiceGetServiceID(a2);
LABEL_20:
    Mutable = (__CFString *)SetID;
    goto LABEL_21;
  }
  v26 = SCNetworkSetGetTypeID();
  if (CFGetTypeID(a2) == v26)
  {
    SetID = SCNetworkSetGetSetID(a2);
    goto LABEL_20;
  }
  v40 = SCNetworkInterfaceGetTypeID();
  if (CFGetTypeID(a2) == v40)
  {
    BSDName = SCNetworkInterfaceGetBSDName(a2);
    UserDefinedName = __SCNetworkInterfaceGetUserDefinedName(a2);
    v43 = CFSTR("?");
    if (UserDefinedName)
      v43 = (const __CFString *)UserDefinedName;
    Mutable = (__CFString *)CFStringCreateWithFormat(0, 0, CFSTR("%@ (%@)"), BSDName, v43);
LABEL_31:
    v27 = 0;
    goto LABEL_22;
  }
  v44 = CFBooleanGetTypeID();
  if (CFGetTypeID(a2) == v44)
  {
    Mutable = CFSTR("None");
    goto LABEL_21;
  }
  v45 = CFArrayGetTypeID();
  if (CFGetTypeID(a2) == v45)
  {
    Count = CFArrayGetCount(a2);
    Mutable = CFStringCreateMutable(0, 0);
    CFStringAppendFormat(Mutable, 0, CFSTR("( "));
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(a2, i);
        v49 = SCNetworkSetGetTypeID();
        if (ValueAtIndex && CFGetTypeID(ValueAtIndex) == v49)
          ValueAtIndex = (const __SCNetworkSet *)SCNetworkSetGetSetID(ValueAtIndex);
        v50 = ", ";
        if (!i)
          v50 = "";
        CFStringAppendFormat(Mutable, 0, CFSTR("%s%@"), v50, ValueAtIndex);
      }
    }
    CFStringAppendFormat(Mutable, 0, CFSTR(")"));
    goto LABEL_31;
  }
  v27 = 1;
  Mutable = (__CFString *)a2;
LABEL_22:
  v28 = __log_SCNetworkConfiguration();
  v29 = _SC_syslog_os_log_mapping(*(_DWORD *)a3);
  if (__SC_log_enabled(*(_DWORD *)a3, v28, (os_log_type_t)v29))
  {
    v30 = _os_log_pack_size();
    v38 = (char *)v51 - ((MEMORY[0x1E0C80A78](v30, v31, v32, v33, v34, v35, v36, v37) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v39 = _os_log_pack_fill();
    *(_DWORD *)v39 = 138412546;
    *(_QWORD *)(v39 + 4) = a1;
    *(_WORD *)(v39 + 12) = 2112;
    *(_QWORD *)(v39 + 14) = Mutable;
    __SC_log_send(*(_DWORD *)a3, (uint64_t)v28, v29, v38);
  }
  if ((v27 & 1) == 0)
    CFRelease(Mutable);
}

uint64_t __SCNetworkConfigurationInterfaceNameIsEquiv(const __CFString *a1, const __CFString *a2)
{
  CFTypeID TypeID;
  CFTypeID v5;
  CFStringRef v6;
  CFStringRef v7;
  const __CFString *v8;
  uint64_t result;
  int v10;
  uint64_t v11;
  __CFString *v12;

  TypeID = CFStringGetTypeID();
  if (!a1)
    return 0;
  if (CFGetTypeID(a1) != TypeID)
    return 0;
  v5 = CFStringGetTypeID();
  if (!a2 || CFGetTypeID(a2) != v5)
    return 0;
  if (!CFEqual(a1, a2)
    && (!CFEqual(a1, CFSTR("AirPort")) && !CFEqual(a1, CFSTR("Wi-Fi"))
     || !CFEqual(a2, CFSTR("AirPort")) && !CFEqual(a2, CFSTR("Wi-Fi")))
    && (!CFEqual(a1, CFSTR("Ethernet")) && !CFEqual(a1, CFSTR("Ethernet 1"))
     || !CFEqual(a2, CFSTR("Ethernet")) && !CFEqual(a2, CFSTR("Ethernet 1"))))
  {
    v6 = interfaceNameCreateWithoutPortSuffix(a1);
    if (v6)
    {
      v7 = v6;
      v8 = a2;
    }
    else
    {
      v6 = interfaceNameCreateWithoutPortSuffix(a2);
      if (!v6)
        goto LABEL_21;
      v7 = v6;
      v8 = a1;
    }
    v10 = CFEqual(v6, v8);
    CFRelease(v7);
    if (v10)
      return 1;
LABEL_21:
    v11 = 0;
    while (1)
    {
      v12 = off_1E25D1F60[v11];
      if ((CFEqual(a1, v12) || __SCNetworkInterfaceMatchesName(a1, v12))
        && (CFEqual(a2, v12) || __SCNetworkInterfaceMatchesName(a2, v12)))
      {
        break;
      }
      result = 0;
      if (++v11 == 6)
        return result;
    }
  }
  return 1;
}

CFStringRef interfaceNameCreateWithoutPortSuffix(const __CFString *a1)
{
  CFRange v2;
  CFIndex Length;
  CFIndex v4;
  CFIndex v5;
  CFRange v7;

  v2 = CFStringFind(a1, CFSTR(", Port "), 4uLL);
  if (v2.location != -1)
  {
    Length = CFStringGetLength(a1);
    v4 = v2.location + v2.length;
    if (v2.location + v2.length >= Length)
    {
LABEL_6:
      v7.location = 0;
      v7.length = v2.location;
      return CFStringCreateWithSubstring(0, a1, v7);
    }
    v5 = Length;
    while (CFStringGetCharacterAtIndex(a1, v4) - 48 < 0xA)
    {
      if (++v4 >= v5)
        goto LABEL_6;
    }
  }
  return 0;
}

void create_bsd_name_service_protocol_mapping(const __SCNetworkService *a1, uint64_t a2)
{
  __CFDictionary *v3;
  const __CFArray *v4;
  SCNetworkInterfaceRef Interface;
  const __SCNetworkInterface *v6;
  CFStringRef BSDName;
  CFTypeID TypeID;
  CFArrayRef v9;
  const __CFArray *v10;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v13;
  CFIndex v14;
  const void *v15;
  const void *v16;
  const __SCNetworkProtocol *ValueAtIndex;
  CFDictionaryRef Configuration;
  CFStringRef ProtocolType;
  int Enabled;
  int v21;
  __CFDictionary *v22;
  const void *v23;
  CFStringRef v24;
  __CFDictionary *v25;
  CFRange v26;

  v4 = *(const __CFArray **)(a2 + 56);
  v3 = *(__CFDictionary **)(a2 + 64);
  Interface = SCNetworkServiceGetInterface(a1);
  if (Interface)
  {
    v6 = Interface;
    v26.length = CFArrayGetCount(v4);
    v26.location = 0;
    if (CFArrayContainsValue(v4, v26, v6))
    {
      BSDName = SCNetworkInterfaceGetBSDName(v6);
      TypeID = CFStringGetTypeID();
      if (BSDName)
      {
        if (CFGetTypeID(BSDName) == TypeID)
        {
          v9 = SCNetworkServiceCopyProtocols(a1);
          if (v9)
          {
            v10 = v9;
            v24 = BSDName;
            v25 = v3;
            Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
            Count = CFArrayGetCount(v10);
            if (Count >= 1)
            {
              v13 = Count;
              v14 = 0;
              v15 = (const void *)*MEMORY[0x1E0C9AE50];
              v16 = (const void *)*MEMORY[0x1E0C9AE40];
              do
              {
                ValueAtIndex = (const __SCNetworkProtocol *)CFArrayGetValueAtIndex(v10, v14);
                Configuration = SCNetworkProtocolGetConfiguration(ValueAtIndex);
                ProtocolType = SCNetworkProtocolGetProtocolType(ValueAtIndex);
                Enabled = SCNetworkProtocolGetEnabled(ValueAtIndex);
                if (Configuration && ProtocolType)
                {
                  v21 = Enabled;
                  v22 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                  CFDictionaryAddValue(v22, CFSTR("Protocol Type"), ProtocolType);
                  CFDictionaryAddValue(v22, CFSTR("Protocol Configuration"), Configuration);
                  if (v21)
                    v23 = v15;
                  else
                    v23 = v16;
                  CFDictionaryAddValue(v22, CFSTR("Protocol Enabled"), v23);
                  CFArrayAppendValue(Mutable, v22);
                  CFRelease(v22);
                }
                ++v14;
              }
              while (v13 != v14);
            }
            CFDictionaryAddValue(v25, v24, Mutable);
            CFRelease(v10);
            CFRelease(Mutable);
          }
        }
      }
    }
  }
}

SCNetworkInterfaceRef remove_service(const __SCNetworkService *a1, uint64_t a2)
{
  const __CFArray *v3;
  SCNetworkInterfaceRef result;
  const void *v5;
  CFStringRef ServiceID;
  CFStringRef Name;
  CFStringRef BSDName;
  NSObject *v9;
  uint64_t v10;
  const __CFString *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  const char *v22;
  const __CFString *v23;
  _QWORD v24[2];
  CFRange v25;

  v24[1] = *MEMORY[0x1E0C80C00];
  v3 = *(const __CFArray **)(a2 + 40);
  result = SCNetworkServiceGetInterface(a1);
  if (result)
  {
    v5 = result;
    v25.length = CFArrayGetCount(v3);
    v25.location = 0;
    result = (SCNetworkInterfaceRef)CFArrayContainsValue(v3, v25, v5);
    if ((_DWORD)result)
    {
      ServiceID = SCNetworkServiceGetServiceID(a1);
      Name = SCNetworkServiceGetName(a1);
      BSDName = SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)v5);
      v9 = __log_SCNetworkConfiguration();
      v10 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v9, (os_log_type_t)v10))
      {
        if (Name)
          v11 = Name;
        else
          v11 = &stru_1E25D5260;
        v12 = _os_log_pack_size();
        v20 = (char *)v24 - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v21 = _os_log_pack_fill();
        v22 = ", ";
        *(_DWORD *)v21 = 138413058;
        *(_QWORD *)(v21 + 4) = ServiceID;
        *(_WORD *)(v21 + 12) = 2112;
        if (!BSDName)
          v22 = "";
        *(_QWORD *)(v21 + 14) = v11;
        if (BSDName)
          v23 = BSDName;
        else
          v23 = &stru_1E25D5260;
        *(_WORD *)(v21 + 22) = 2080;
        *(_QWORD *)(v21 + 24) = v22;
        *(_WORD *)(v21 + 32) = 2112;
        *(_QWORD *)(v21 + 34) = v23;
        __SC_log_send(6, (uint64_t)v9, v10, v20);
      }
      return (SCNetworkInterfaceRef)SCNetworkServiceRemove(a1);
    }
  }
  return result;
}

void add_service(const __SCNetworkInterface *a1, uint64_t a2)
{
  const __CFDictionary *v3;
  const __SCPreferences *v4;
  CFStringRef BSDName;
  CFTypeID TypeID;
  const __CFArray *Value;
  const __SCNetworkService *v8;
  const __SCNetworkService *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v14;
  const __CFString *v15;
  const __CFBoolean *v16;
  Boolean v17;
  const __SCNetworkSet *v18;
  const __SCNetworkSet *v19;
  CFStringRef ServiceID;
  CFStringRef Name;
  NSObject *v22;
  uint64_t v23;
  const __CFString *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  const char *v35;
  const __CFString *v36;
  const __CFString *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  NSObject *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  const __SCNetworkService *v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  CFStringRef v73;
  SCPreferencesRef v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  v3 = *(const __CFDictionary **)(a2 + 64);
  v4 = *(const __SCPreferences **)(a2 + 72);
  BSDName = SCNetworkInterfaceGetBSDName(a1);
  TypeID = CFStringGetTypeID();
  if (BSDName && CFGetTypeID(BSDName) == TypeID)
    Value = (const __CFArray *)CFDictionaryGetValue(v3, BSDName);
  else
    Value = 0;
  v8 = SCNetworkServiceCreate(v4, a1);
  if (v8)
  {
    v9 = v8;
    if (SCNetworkServiceEstablishDefaultConfiguration(v8))
    {
      v73 = BSDName;
      v74 = v4;
      if (Value)
      {
        Count = CFArrayGetCount(Value);
        if (Count >= 1)
        {
          v11 = Count;
          for (i = 0; i != v11; ++i)
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, i);
            v14 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, CFSTR("Protocol Configuration"));
            v15 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("Protocol Type"));
            v16 = (const __CFBoolean *)CFDictionaryGetValue(ValueAtIndex, CFSTR("Protocol Enabled"));
            if (v16)
              v17 = CFBooleanGetValue(v16);
            else
              v17 = 0;
            __SCNetworkServiceAddProtocolToService(v9, v15, v14, v17);
          }
        }
      }
      v18 = SCNetworkSetCopyCurrent(v74);
      if (v18)
      {
        v19 = v18;
        if (SCNetworkSetAddService(v18, v9))
        {
          ServiceID = SCNetworkServiceGetServiceID(v9);
          Name = SCNetworkServiceGetName(v9);
          v22 = __log_SCNetworkConfiguration();
          v23 = _SC_syslog_os_log_mapping(6);
          if (__SC_log_enabled(6, v22, (os_log_type_t)v23))
          {
            if (Name)
              v24 = Name;
            else
              v24 = &stru_1E25D5260;
            v25 = _os_log_pack_size();
            v33 = (char *)&v72
                - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v34 = _os_log_pack_fill();
            v35 = ", ";
            *(_DWORD *)v34 = 138413058;
            *(_QWORD *)(v34 + 4) = ServiceID;
            *(_WORD *)(v34 + 12) = 2112;
            v36 = v73;
            if (!v73)
              v35 = "";
            *(_QWORD *)(v34 + 14) = v24;
            if (v36)
              v37 = v36;
            else
              v37 = &stru_1E25D5260;
            *(_WORD *)(v34 + 22) = 2080;
            *(_QWORD *)(v34 + 24) = v35;
            *(_WORD *)(v34 + 32) = 2112;
            *(_QWORD *)(v34 + 34) = v37;
            __SC_log_send(6, (uint64_t)v22, v23, v33);
          }
        }
        else
        {
          v61 = __log_SCNetworkConfiguration();
          v62 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v61, (os_log_type_t)v62))
          {
            v63 = _os_log_pack_size();
            v71 = (char *)&v72
                - ((MEMORY[0x1E0C80A78](v63, v64, v65, v66, v67, v68, v69, v70) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            *(_WORD *)_os_log_pack_fill() = 0;
            __SC_log_send(5, (uint64_t)v61, v62, v71);
          }
          SCNetworkServiceRemove(v9);
        }
        CFRelease(v9);
        v60 = v19;
        goto LABEL_37;
      }
      v49 = __log_SCNetworkConfiguration();
      v50 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v49, (os_log_type_t)v50))
        goto LABEL_31;
    }
    else
    {
      v49 = __log_SCNetworkConfiguration();
      v50 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v49, (os_log_type_t)v50))
      {
LABEL_31:
        v51 = _os_log_pack_size();
        v59 = (char *)&v72 - ((MEMORY[0x1E0C80A78](v51, v52, v53, v54, v55, v56, v57, v58) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v49, v50, v59);
      }
    }
    SCNetworkServiceRemove(v9);
    v60 = v9;
LABEL_37:
    CFRelease(v60);
    return;
  }
  v38 = __log_SCNetworkConfiguration();
  v39 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v38, (os_log_type_t)v39))
  {
    v40 = _os_log_pack_size();
    v48 = (char *)&v72 - ((MEMORY[0x1E0C80A78](v40, v41, v42, v43, v44, v45, v46, v47) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(5, (uint64_t)v38, v39, v48);
  }
}

BOOL __SCNetworkConfigurationMigrateConfigurationFilesPresent(const __CFURL *a1, CFArrayRef *a2, int a3)
{
  __CFArray *Mutable;
  const void *v7;
  const void *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const __CFURL *ValueAtIndex;
  _BOOL8 result;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  const void *v42;
  const void *v43[2];

  v43[1] = *(const void **)MEMORY[0x1E0C80C00];
  if (a1)
  {
    v42 = 0;
    v43[0] = 0;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    _SCNetworkConfigurationCopyMigrationPathsWithBaseURL(a1, &v42, v43);
    v7 = v42;
    CFArrayAppendValue(Mutable, v42);
    v8 = v43[0];
    CFArrayAppendValue(Mutable, v43[0]);
    CFRelease(v7);
    CFRelease(v8);
    *a2 = Mutable;
    Count = CFArrayGetCount(Mutable);
    if (Count < 1)
      return 1;
    v10 = Count;
    v11 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(*a2, v11);
      if (!_SCNetworkConfigurationMigrateIsFilePresent(ValueAtIndex))
        break;
      if (v10 == ++v11)
        return 1;
    }
    if (!a3)
      return 0;
    v29 = __log_SCNetworkConfiguration();
    v30 = _SC_syslog_os_log_mapping(6);
    result = __SC_log_enabled(6, v29, (os_log_type_t)v30);
    if (!result)
      return result;
    v31 = _os_log_pack_size();
    v39 = (char *)&v41 - ((MEMORY[0x1E0C80A78](v31, v32, v33, v34, v35, v36, v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v40 = _os_log_pack_fill();
    *(_DWORD *)v40 = 138412290;
    *(_QWORD *)(v40 + 4) = ValueAtIndex;
    v25 = 6;
    v26 = (uint64_t)v29;
    v27 = v30;
    v28 = v39;
  }
  else
  {
    v14 = __log_SCNetworkConfiguration();
    v15 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v14, (os_log_type_t)v15);
    if (!result)
      return result;
    v16 = _os_log_pack_size();
    v24 = (char *)&v41 - ((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    v25 = 5;
    v26 = (uint64_t)v14;
    v27 = v15;
    v28 = v24;
  }
  __SC_log_send(v25, v26, v27, v28);
  return 0;
}

void __SCNetworkPopulateDefaultPrefs(const __SCPreferences *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  const __SCPreferences **Default;
  const void *v15;
  CFNumberRef v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = __log_SCNetworkConfiguration();
  v3 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v2, (os_log_type_t)v3))
  {
    v4 = _os_log_pack_size();
    v12 = (char *)&v17 - ((MEMORY[0x1E0C80A78](v4, v5, v6, v7, v8, v9, v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v13 = _os_log_pack_fill();
    *(_DWORD *)v13 = 138412290;
    *(_QWORD *)(v13 + 4) = a1;
    __SC_log_send(6, (uint64_t)v2, v3, v12);
  }
  Default = (const __SCPreferences **)SCNetworkSetCopyCurrent(a1);
  if (!Default)
    Default = (const __SCPreferences **)_SCNetworkSetCreateDefault(a1);
  SCNetworkSetEstablishDefaultConfiguration(Default);
  CFRelease(Default);
  if (!SCPreferencesGetValue(a1, CFSTR("Model")))
  {
    v15 = (const void *)_SC_hw_model(0);
    SCPreferencesSetValue(a1, CFSTR("Model"), v15);
  }
  if (!SCPreferencesGetValue(a1, CFSTR("__VERSION__")))
  {
    HIDWORD(v17) = 20191120;
    v16 = CFNumberCreate(0, kCFNumberIntType, (char *)&v17 + 4);
    SCPreferencesSetValue(a1, CFSTR("__VERSION__"), v16);
    CFRelease(v16);
  }
}

void __SCNetworkPopulateDefaultNIPrefs(const __SCPreferences *a1)
{
  CFPropertyListRef Value;
  CFTypeID TypeID;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  __CFArray *v16;
  const __CFArray *v17;
  const __CFArray *Mutable;
  CFIndex v19;
  const void *ValueAtIndex;
  __CFString *v21;
  __CFString *v22;
  const __CFNumber *IOInterfaceType;
  uint64_t IOInterfaceUnit;
  const __CFNumber *v25;
  CFIndex v26;
  const __CFDictionary *v27;
  const __CFNumber *v28;
  const __CFNumber *v29;
  CFComparisonResult v30;
  const __SCPreferences *v31;
  const void *v32;
  CFNumberRef v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  SCPreferencesRef v45;
  const __CFArray *v46;
  int valuePtr;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  Value = SCPreferencesGetValue(a1, CFSTR("Interfaces"));
  TypeID = CFArrayGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID)
  {
    v4 = __log_SCNetworkConfiguration();
    v5 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v4, (os_log_type_t)v5))
    {
      v6 = _os_log_pack_size();
      v14 = (char *)&v45 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v15 = _os_log_pack_fill();
      *(_DWORD *)v15 = 138412290;
      *(_QWORD *)(v15 + 4) = a1;
      __SC_log_send(6, (uint64_t)v4, v5, v14);
    }
    v16 = __SCNetworkInterfaceCopyAll_IONetworkInterface(1);
    if (v16)
    {
      v17 = v16;
      v45 = a1;
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      if (CFArrayGetCount(v17) >= 1)
      {
        v19 = 0;
        v46 = v17;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v17, v19);
          v21 = __SCNetworkInterfaceCopyStorageEntity((uint64_t)ValueAtIndex);
          if (v21)
          {
            v22 = v21;
            IOInterfaceType = (const __CFNumber *)_SCNetworkInterfaceGetIOInterfaceType((uint64_t)ValueAtIndex);
            IOInterfaceUnit = _SCNetworkInterfaceGetIOInterfaceUnit((uint64_t)ValueAtIndex);
            if (IOInterfaceType)
            {
              v25 = (const __CFNumber *)IOInterfaceUnit;
              if (IOInterfaceUnit)
              {
                if (CFArrayGetCount(Mutable) < 1)
                {
                  v26 = 0;
                }
                else
                {
                  v26 = 0;
                  do
                  {
                    v27 = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v26);
                    v28 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("IOInterfaceType"));
                    v29 = (const __CFNumber *)CFDictionaryGetValue(v27, CFSTR("IOInterfaceUnit"));
                    v30 = CFNumberCompare(IOInterfaceType, v28, 0);
                    if (v30 == kCFCompareEqualTo)
                      v30 = CFNumberCompare(v25, v29, 0);
                    if (v30 == kCFCompareLessThan)
                      break;
                    ++v26;
                  }
                  while (v26 < CFArrayGetCount(Mutable));
                }
                CFArrayInsertValueAtIndex(Mutable, v26, v22);
                v17 = v46;
              }
            }
            CFRelease(v22);
          }
          ++v19;
        }
        while (v19 < CFArrayGetCount(v17));
      }
      v31 = v45;
      SCPreferencesSetValue(v45, CFSTR("Interfaces"), Mutable);
      CFRelease(Mutable);
      if (!SCPreferencesGetValue(v31, CFSTR("Model")))
      {
        v32 = (const void *)_SC_hw_model(0);
        SCPreferencesSetValue(v31, CFSTR("Model"), v32);
      }
      if (!SCPreferencesGetValue(v31, CFSTR("__VERSION__")))
      {
        valuePtr = 20191120;
        v33 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
        SCPreferencesSetValue(v31, CFSTR("__VERSION__"), v33);
        CFRelease(v33);
      }
      CFRelease(v17);
    }
    else
    {
      v34 = __log_SCNetworkConfiguration();
      v35 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v34, (os_log_type_t)v35))
      {
        v36 = _os_log_pack_size();
        v44 = (char *)&v45 - ((MEMORY[0x1E0C80A78](v36, v37, v38, v39, v40, v41, v42, v43) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v34, v35, v44);
      }
    }
  }
}

BOOL hasSameModel(const __SCPreferences *a1, const __SCPreferences *a2)
{
  CFPropertyListRef Value;
  CFPropertyListRef v4;
  CFTypeID TypeID;
  CFTypeID v6;

  Value = SCPreferencesGetValue(a1, CFSTR("Model"));
  v4 = SCPreferencesGetValue(a2, CFSTR("Model"));
  TypeID = CFStringGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && (v6 = CFStringGetTypeID(), v4) && CFGetTypeID(v4) == v6)
    return CFEqual(Value, v4) != 0;
  else
    return 0;
}

uint64_t hasInterfaceConflict(const __SCPreferences *a1, const __SCPreferences *a2)
{
  __CFArray *v3;
  __CFArray *v4;
  __CFDictionary *MappingUsingBSDName;
  __CFArray *v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const __SCNetworkInterface *ValueAtIndex;
  CFStringRef BSDName;
  uint64_t v13;
  CFTypeRef cf2[2];

  cf2[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v3 = __SCNetworkInterfaceCopyStoredWithPreferences(a1);
  if (v3)
  {
    v4 = v3;
    MappingUsingBSDName = __SCNetworkInterfaceCreateMappingUsingBSDName(v3);
    CFRelease(v4);
  }
  else
  {
    MappingUsingBSDName = 0;
  }
  v6 = __SCNetworkInterfaceCopyStoredWithPreferences(a2);
  if (!v6)
  {
    v13 = 0;
    if (!MappingUsingBSDName)
      return v13;
    goto LABEL_17;
  }
  v7 = v6;
  Count = CFArrayGetCount(v6);
  if (Count < 1)
  {
LABEL_12:
    v13 = 0;
  }
  else
  {
    v9 = Count;
    v10 = 0;
    while (1)
    {
      cf2[0] = 0;
      ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v7, v10);
      BSDName = SCNetworkInterfaceGetBSDName(ValueAtIndex);
      if (BSDName)
      {
        if (!MappingUsingBSDName
          || !CFDictionaryGetValueIfPresent(MappingUsingBSDName, BSDName, cf2)
          || !CFEqual(ValueAtIndex, cf2[0]))
        {
          break;
        }
      }
      if (v9 == ++v10)
        goto LABEL_12;
    }
    v13 = 1;
  }
  CFRelease(v7);
  if (MappingUsingBSDName)
LABEL_17:
    CFRelease(MappingUsingBSDName);
  return v13;
}

void _SCNetworkConfigurationCreateBuiltinInterfaceServices(const __SCPreferences *a1, const __SCPreferences *cf)
{
  __CFArray *v3;
  __CFArray *v4;
  __CFDictionary *MappingUsingBSDName;
  CFTypeID TypeID;
  __CFArray *v7;
  __CFArray *v8;
  __CFDictionary *v9;
  CFTypeID v10;
  const __CFArray *Mutable;
  CFIndex Count;
  __int128 v13;
  CFIndex v14;
  CFIndex v15;
  const __SCNetworkInterface *ValueAtIndex;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  __CFDictionary *v51;
  uint64_t v52;
  __CFDictionary *v53;
  __int128 v54;
  uint64_t *v55;
  __CFDictionary *context;
  const __CFArray *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  context = 0;
  v57 = 0;
  v3 = __SCNetworkInterfaceCopyStoredWithPreferences(cf);
  if (!v3)
  {
    v29 = __log_SCNetworkConfiguration();
    v30 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v29, (os_log_type_t)v30))
    {
      v31 = _os_log_pack_size();
      v39 = (char *)&v52 - ((MEMORY[0x1E0C80A78](v31, v32, v33, v34, v35, v36, v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v29, v30, v39);
    }
    return;
  }
  v4 = v3;
  MappingUsingBSDName = __SCNetworkInterfaceCreateMappingUsingBSDName(v3);
  CFRelease(v4);
  TypeID = CFDictionaryGetTypeID();
  if (!MappingUsingBSDName)
    return;
  if (CFGetTypeID(MappingUsingBSDName) != TypeID)
    goto LABEL_19;
  v7 = __SCNetworkServiceCopyAllInterfaces(a1);
  if (!v7)
  {
    v40 = __log_SCNetworkConfiguration();
    v41 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v40, (os_log_type_t)v41))
    {
      v42 = _os_log_pack_size();
      v50 = (char *)&v52 - ((MEMORY[0x1E0C80A78](v42, v43, v44, v45, v46, v47, v48, v49) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v40, v41, v50);
    }
    goto LABEL_19;
  }
  v8 = v7;
  v9 = __SCNetworkInterfaceCreateMappingUsingBSDName(v7);
  CFRelease(v8);
  v10 = CFDictionaryGetTypeID();
  if (!v9)
  {
LABEL_19:
    v51 = MappingUsingBSDName;
LABEL_20:
    CFRelease(v51);
    return;
  }
  if (CFGetTypeID(v9) == v10)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    context = v9;
    v57 = Mutable;
    CFDictionaryApplyFunction(MappingUsingBSDName, (CFDictionaryApplierFunction)_SCNetworkConfigurationCollectMissingService, &context);
    Count = CFArrayGetCount(Mutable);
    if (Count >= 1)
    {
      v14 = Count;
      v53 = v9;
      v15 = 0;
      *(_QWORD *)&v13 = 138412290;
      v54 = v13;
      do
      {
        ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(Mutable, v15);
        if (!__SCNetworkInterfaceIsBusyMember(a1, ValueAtIndex, 0)
          && !__SCNetworkServiceCreate(a1, ValueAtIndex, 0))
        {
          v17 = __log_SCNetworkConfiguration();
          v18 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v17, (os_log_type_t)v18))
          {
            v19 = _os_log_pack_size();
            v55 = &v52;
            v27 = (char *)&v52
                - ((MEMORY[0x1E0C80A78](v19, v20, v21, v22, v23, v24, v25, v26) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v28 = _os_log_pack_fill();
            *(_DWORD *)v28 = v54;
            *(_QWORD *)(v28 + 4) = ValueAtIndex;
            __SC_log_send(5, (uint64_t)v17, v18, v27);
          }
        }
        ++v15;
      }
      while (v14 != v15);
      v9 = v53;
    }
  }
  else
  {
    Mutable = 0;
  }
  CFRelease(MappingUsingBSDName);
  CFRelease(v9);
  if (Mutable)
  {
    v51 = Mutable;
    goto LABEL_20;
  }
}

__CFDictionary *_SCNetworkConfigurationCopyExternalInterfaceMapping(const __SCPreferences *a1, const __SCPreferences *a2)
{
  __CFArray *v3;
  CFTypeID TypeID;
  __CFArray *v5;
  CFTypeID v6;
  const __CFDictionary *v7;
  __CFDictionary *Mutable;
  void *Companion;
  CFIndex i;
  void *ValueAtIndex;
  CFIndex v12;
  CFIndex v13;
  CFIndex j;
  const void *v15;
  const void *HardwareAddress;
  const void *v17;
  CFIndex v18;
  unsigned __int8 *v19;
  const void *v20;
  CFTypeID v21;
  __CFString *v22;
  const void *IOInterfaceType;
  const __CFNumber *Value;
  int v25;
  __CFArray *v26;
  CFIndex v27;
  CFNumberRef v28;
  CFTypeRef Copy;
  const void *IOInterfaceUnit;
  CFTypeID v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  NSObject *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  NSObject *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  CFMutableDictionaryRef v67;
  CFIndex Count;
  uint64_t v69;
  int valuePtr;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v69 = 0;
  v3 = _SCNetworkInterfaceCopyInterfacesFilteredByBuiltinWithPreferences(a1, 0);
  TypeID = CFArrayGetTypeID();
  if (v3 && CFGetTypeID(v3) == TypeID)
  {
    Count = CFArrayGetCount(v3);
    if (Count)
    {
      v5 = _SCNetworkInterfaceCopyInterfacesFilteredByBuiltinWithPreferences(a2, 0);
      v6 = CFArrayGetTypeID();
      if (v5 && CFGetTypeID(v5) == v6)
      {
        v7 = _SCNetworkInterfaceStorageCopyMaxUnitPerInterfaceType(a2);
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        Companion = SCPreferencesCreateCompanion((uint64_t)a2, 0);
        if (Count >= 1)
        {
          v67 = Mutable;
          for (i = 0; i != Count; ++i)
          {
            ValueAtIndex = (void *)CFArrayGetValueAtIndex(v3, i);
            v12 = CFArrayGetCount(v5);
            if (v12 < 1)
            {
LABEL_18:
              if (!_SCNetworkInterfaceIsHiddenInterface((unsigned __int8 *)ValueAtIndex))
              {
                v20 = (const void *)*((_QWORD *)ValueAtIndex + 36);
                v21 = CFNumberGetTypeID();
                if (!v20
                  || CFGetTypeID(v20) != v21
                  || (valuePtr = 0, !CFNumberGetValue(*((CFNumberRef *)ValueAtIndex + 36), kCFNumberIntType, &valuePtr))
                  || valuePtr != 1452
                  || (v22 = (__CFString *)*((_QWORD *)ValueAtIndex + 4), v22 != CFSTR("iBridge"))
                  && (!v22 || !CFEqual(v22, CFSTR("iBridge"))))
                {
                  IOInterfaceType = (const void *)_SCNetworkInterfaceGetIOInterfaceType((uint64_t)ValueAtIndex);
                  Value = (const __CFNumber *)CFDictionaryGetValue(v7, IOInterfaceType);
                  if (Value)
                  {
                    CFNumberGetValue(Value, kCFNumberIntType, (char *)&v69 + 4);
                    v25 = HIDWORD(v69) + 1;
                  }
                  else
                  {
                    v25 = 0;
                  }
                  LODWORD(v69) = v25;
                  v28 = CFNumberCreate(0, kCFNumberIntType, &v69);
                  CFDictionarySetValue(v7, IOInterfaceType, v28);
                  Copy = __SCNetworkInterfaceCreateCopy(0, (uint64_t)ValueAtIndex, Companion, 0);
                  IOInterfaceUnit = (const void *)_SCNetworkInterfaceGetIOInterfaceUnit((uint64_t)Copy);
                  v31 = CFNumberGetTypeID();
                  if (!IOInterfaceUnit || CFGetTypeID(IOInterfaceUnit) != v31 || !CFEqual(IOInterfaceUnit, v28))
                    __SCNetworkInterfaceSetIOInterfaceUnit((uint64_t)Copy, v28);
                  CFDictionaryAddValue(v67, ValueAtIndex, Copy);
                  CFRelease(Copy);
                  CFRelease(v28);
                }
              }
            }
            else
            {
              v13 = v12;
              for (j = 0; j != v13; ++j)
              {
                v15 = CFArrayGetValueAtIndex(v5, j);
                HardwareAddress = (const void *)_SCNetworkInterfaceGetHardwareAddress((uint64_t)ValueAtIndex);
                v17 = (const void *)_SCNetworkInterfaceGetHardwareAddress((uint64_t)v15);
                if (HardwareAddress == v17 || HardwareAddress && v17 && CFEqual(HardwareAddress, v17))
                {
                  CFDictionaryAddValue(v67, ValueAtIndex, v15);
                  v26 = v5;
                  v27 = j;
                  goto LABEL_29;
                }
              }
              v18 = 0;
              while (1)
              {
                v19 = (unsigned __int8 *)CFArrayGetValueAtIndex(v5, v18);
                if (_SCNetworkConfigurationIsInterfaceNamerMappable((unsigned __int8 *)ValueAtIndex, v19))
                  break;
                if (v13 == ++v18)
                  goto LABEL_18;
              }
              CFDictionaryAddValue(v67, ValueAtIndex, v19);
              v26 = v5;
              v27 = v18;
LABEL_29:
              CFArrayRemoveValueAtIndex(v26, v27);
            }
          }
          Mutable = v67;
        }
        goto LABEL_55;
      }
      v44 = __log_SCNetworkConfiguration();
      v45 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v44, (os_log_type_t)v45))
      {
        v46 = _os_log_pack_size();
        v54 = (char *)&v66 - ((MEMORY[0x1E0C80A78](v46, v47, v48, v49, v50, v51, v52, v53) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(6, (uint64_t)v44, v45, v54);
      }
    }
    else
    {
      v55 = __log_SCNetworkConfiguration();
      v56 = _SC_syslog_os_log_mapping(6);
      if (!__SC_log_enabled(6, v55, (os_log_type_t)v56))
      {
        Mutable = 0;
        v7 = 0;
        v5 = 0;
        goto LABEL_54;
      }
      v57 = _os_log_pack_size();
      v65 = (char *)&v66 - ((MEMORY[0x1E0C80A78](v57, v58, v59, v60, v61, v62, v63, v64) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v55, v56, v65);
      v5 = 0;
    }
    Mutable = 0;
    v7 = 0;
LABEL_54:
    Companion = 0;
LABEL_55:
    CFRelease(v3);
    if (v5)
      CFRelease(v5);
    goto LABEL_44;
  }
  v32 = __log_SCNetworkConfiguration();
  v33 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v32, (os_log_type_t)v33))
  {
    v34 = _os_log_pack_size();
    v42 = (char *)&v66 - ((MEMORY[0x1E0C80A78](v34, v35, v36, v37, v38, v39, v40, v41) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(6, (uint64_t)v32, v33, v42);
  }
  Companion = 0;
  v5 = 0;
  v7 = 0;
  Mutable = 0;
  if (v3)
    goto LABEL_55;
LABEL_44:
  if (v7)
    CFRelease(v7);
  if (Companion)
    CFRelease(Companion);
  return Mutable;
}

__CFArray *_SCNetworkMigrationCreateNetworkInterfaceArray(const __SCPreferences *a1, const __CFDictionary *a2, _BYTE *a3)
{
  CFPropertyListRef Value;
  CFTypeID TypeID;
  CFIndex Count;
  uint64_t v9;
  __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID v13;
  CFTypeID v14;
  __CFArray *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  _QWORD context[2];
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v40 = 0;
  if (!a1)
  {
    v27 = __log_SCNetworkConfiguration();
    v28 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v27, (os_log_type_t)v28))
    {
LABEL_22:
      v29 = _os_log_pack_size();
      v37 = (char *)context
          - ((MEMORY[0x1E0C80A78](v29, v30, v31, v32, v33, v34, v35, v36) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v27, v28, v37);
    }
    return 0;
  }
  Value = SCPreferencesGetValue(a1, CFSTR("Interfaces"));
  TypeID = CFArrayGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID || (Count = CFArrayGetCount((CFArrayRef)Value)) == 0)
  {
    v27 = __log_SCNetworkConfiguration();
    v28 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v27, (os_log_type_t)v28))
      goto LABEL_22;
    return 0;
  }
  v9 = Count;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (v9 >= 1)
  {
    for (i = 0; i != v9; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)Value, i);
      v13 = CFDictionaryGetTypeID();
      if (ValueAtIndex && CFGetTypeID(ValueAtIndex) == v13)
        CFArrayAppendValue(Mutable, ValueAtIndex);
    }
  }
  v14 = CFDictionaryGetTypeID();
  if (a2 && CFGetTypeID(a2) == v14)
  {
    v15 = _SCNetworkInterfaceCopyInterfacesFilteredByBuiltinWithPreferences(a1, 0);
    context[0] = v15;
    context[1] = Mutable;
    LOBYTE(v40) = 0;
    v16 = __log_SCNetworkConfiguration();
    v17 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v16, (os_log_type_t)v17))
    {
      v18 = _os_log_pack_size();
      v26 = (char *)context
          - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(7, (uint64_t)v16, v17, v26);
    }
    logInterfaces((uint64_t)"  externalInterfaceList", v15, 0);
    logInterfaces((uint64_t)"  networkInterfaceList", Mutable, 0);
    CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)_SCNetworkConfigurationCollectInterfaceStorageEntity, context);
    if (a3)
      *a3 = v40;
    if (v15)
      CFRelease(v15);
  }
  return Mutable;
}

CFMutableDictionaryRef _SCNetworkMigrationCreateBSDNameMapping(const __CFDictionary *a1, const __CFDictionary *a2)
{
  CFMutableDictionaryRef Mutable;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if ((unint64_t)a1 | (unint64_t)a2)
  {
    if (a1)
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)SCNetworkMigrationMapSourceToTargetName, Mutable);
    if (a2)
      CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)SCNetworkMigrationMapSourceToTargetName, Mutable);
  }
  return Mutable;
}

CFDictionaryRef _SCNetworkMigrationCreateServiceMappingUsingBSDNameMapping(const __SCPreferences *a1, const __SCPreferences *a2, const __CFDictionary *a3)
{
  const __CFArray *v5;
  CFTypeID TypeID;
  CFArrayRef v7;
  CFTypeID v8;
  CFIndex Count;
  const __CFArray *MutableCopy;
  const __CFArray *v11;
  const __CFDictionary *Mutable;
  __int128 v13;
  CFDictionaryRef v14;
  CFIndex v15;
  CFIndex v16;
  const __SCNetworkService *ValueAtIndex;
  SCNetworkInterfaceRef Interface;
  SCNetworkInterfaceRef v19;
  const void *EntityType;
  CFTypeID v21;
  const void *EntitySubType;
  CFTypeID v23;
  CFStringRef BSDName;
  CFTypeID v25;
  CFTypeID v26;
  CFStringRef InterfaceType;
  CFTypeID v28;
  CFStringRef v29;
  CFTypeID v30;
  CFStringRef v31;
  CFTypeID v32;
  CFIndex v33;
  const __SCNetworkService *v34;
  const __SCNetworkInterface *v35;
  uint64_t v36;
  CFStringRef v37;
  CFTypeID v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  const void *v53;
  CFTypeID v54;
  const void *v55;
  CFTypeID v56;
  NSObject *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  int v69;
  NSObject *v70;
  uint64_t v71;
  CFTypeID v72;
  CFTypeID v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  char *v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  NSObject *v93;
  uint64_t v94;
  _BOOL4 v95;
  __CFDictionary *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  char *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  char *v109;
  NSObject *v110;
  uint64_t v111;
  _BOOL4 v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  char *v121;
  uint64_t v122;
  NSObject *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  char *v133;
  NSObject *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  char *v144;
  NSObject *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  char *v156;
  uint64_t v157;
  const __CFString *v158;
  const __CFString *v159;
  const __CFArray *v160;
  const __CFArray *v161;
  CFDictionaryRef v162;
  const __CFString *v163;
  const void *v164;
  const __CFString *v165;
  const __CFString *v166;
  const __CFString *v167;
  CFTypeRef v168;
  const __CFString *v169;
  CFDictionaryRef v170;
  __int128 v171;
  const __CFString *v172;
  const __CFArray *v173;
  CFTypeRef v174;
  const __SCNetworkService *v175;
  CFIndex v176;
  const __CFArray *v177;
  void *value[3];

  value[1] = *(void **)MEMORY[0x1E0C80C00];
  value[0] = 0;
  if (a3)
  {
    v5 = SCNetworkServiceCopyAll(a1);
    TypeID = CFArrayGetTypeID();
    if (v5 && CFGetTypeID(v5) == TypeID)
    {
      v7 = SCNetworkServiceCopyAll(a2);
      v8 = CFArrayGetTypeID();
      if (!v7 || CFGetTypeID(v7) != v8)
      {
        v146 = __log_SCNetworkConfiguration();
        v147 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v146, (os_log_type_t)v147))
        {
          v148 = _os_log_pack_size();
          v156 = (char *)&v157
               - ((MEMORY[0x1E0C80A78](v148, v149, v150, v151, v152, v153, v154, v155) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(5, (uint64_t)v146, v147, v156);
        }
        v14 = 0;
        MutableCopy = 0;
        v11 = 0;
        goto LABEL_93;
      }
      Count = CFArrayGetCount(v5);
      MutableCopy = CFArrayCreateMutableCopy(0, 0, v5);
      v11 = CFArrayCreateMutableCopy(0, 0, v7);
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v14 = Mutable;
      v176 = Count;
      if (Count < 1)
        goto LABEL_93;
      v162 = a3;
      v170 = Mutable;
      v160 = v7;
      v161 = v5;
      v15 = 0;
      v172 = CFSTR("VPN");
      v166 = CFSTR("PPP");
      v169 = CFSTR("Bond");
      v167 = CFSTR("Bridge");
      v165 = CFSTR("VLAN");
      v163 = CFSTR("IPSec");
      v159 = CFSTR("6to4");
      v158 = CFSTR("Loopback");
      v164 = (const void *)*MEMORY[0x1E0C9AE40];
      *(_QWORD *)&v13 = 138412290;
      v171 = v13;
      v173 = MutableCopy;
      v177 = v11;
      while (1)
      {
        value[0] = 0;
        v16 = CFArrayGetCount(v11);
        ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(MutableCopy, v15);
        Interface = SCNetworkServiceGetInterface(ValueAtIndex);
        if (!Interface)
        {
          v70 = __log_SCNetworkConfiguration();
          v71 = _SC_syslog_os_log_mapping(5);
          if (!__SC_log_enabled(5, v70, (os_log_type_t)v71))
            goto LABEL_67;
LABEL_65:
          v74 = _os_log_pack_size();
          v82 = (char *)&v157
              - ((MEMORY[0x1E0C80A78](v74, v75, v76, v77, v78, v79, v80, v81) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          MutableCopy = v173;
          *(_WORD *)_os_log_pack_fill() = 0;
          v83 = 5;
          goto LABEL_66;
        }
        v19 = Interface;
        EntityType = (const void *)__SCNetworkInterfaceGetEntityType((uint64_t)Interface);
        v21 = CFStringGetTypeID();
        if (EntityType && CFGetTypeID(EntityType) == v21 && (CFEqual(EntityType, v172) || CFEqual(EntityType, v166)))
        {
          EntitySubType = (const void *)__SCNetworkInterfaceGetEntitySubType((uint64_t)v19);
          v23 = CFStringGetTypeID();
          if (!EntitySubType || CFGetTypeID(EntitySubType) != v23)
          {
            v70 = __log_SCNetworkConfiguration();
            v71 = _SC_syslog_os_log_mapping(5);
            if (!__SC_log_enabled(5, v70, (os_log_type_t)v71))
              goto LABEL_67;
            goto LABEL_65;
          }
          v168 = EntitySubType;
          v174 = EntityType;
          v175 = ValueAtIndex;
          BSDName = 0;
        }
        else
        {
          v175 = ValueAtIndex;
          v25 = SCNetworkInterfaceGetTypeID();
          v26 = CFGetTypeID(v19);
          v174 = EntityType;
          if (v26 == v25)
          {
            InterfaceType = SCNetworkInterfaceGetInterfaceType(v19);
            if (CFEqual(InterfaceType, v169))
              goto LABEL_22;
          }
          if ((v28 = SCNetworkInterfaceGetTypeID(), CFGetTypeID(v19) == v28)
            && (v29 = SCNetworkInterfaceGetInterfaceType(v19), CFEqual(v29, v167))
            || (v30 = SCNetworkInterfaceGetTypeID(), CFGetTypeID(v19) == v30)
            && (v31 = SCNetworkInterfaceGetInterfaceType(v19), CFEqual(v31, v165)))
          {
LABEL_22:
            BSDName = SCNetworkInterfaceGetBSDName(v19);
            v32 = CFStringGetTypeID();
            if (!BSDName || CFGetTypeID(BSDName) != v32)
              goto LABEL_67;
            v168 = 0;
            value[0] = (void *)BSDName;
          }
          else
          {
            v72 = CFStringGetTypeID();
            if (EntityType
              && CFGetTypeID(v174) == v72
              && (CFEqual(v174, v163) || CFEqual(v174, v159) || CFEqual(v174, v158)))
            {
              goto LABEL_67;
            }
            BSDName = SCNetworkInterfaceGetBSDName(v19);
            v73 = CFStringGetTypeID();
            if (!BSDName || CFGetTypeID(BSDName) != v73)
              goto LABEL_67;
            if (!CFDictionaryGetValueIfPresent(v162, BSDName, (const void **)value) || !isA_CFString(value[0]))
            {
              v70 = __log_SCNetworkConfiguration();
              v71 = _SC_syslog_os_log_mapping(6);
              if (!__SC_log_enabled(6, v70, (os_log_type_t)v71))
                goto LABEL_67;
              v84 = _os_log_pack_size();
              v82 = (char *)&v157
                  - ((MEMORY[0x1E0C80A78](v84, v85, v86, v87, v88, v89, v90, v91) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              MutableCopy = v173;
              v92 = _os_log_pack_fill();
              *(_DWORD *)v92 = v171;
              *(_QWORD *)(v92 + 4) = BSDName;
              v83 = 6;
LABEL_66:
              __SC_log_send(v83, (uint64_t)v70, v71, v82);
              v11 = v177;
              goto LABEL_67;
            }
            v168 = 0;
          }
        }
        if (v16 < 1)
          goto LABEL_50;
        v33 = 0;
        while (1)
        {
          v34 = (const __SCNetworkService *)CFArrayGetValueAtIndex(v11, v33);
          v35 = SCNetworkServiceGetInterface(v34);
          if (v35)
            break;
          v39 = __log_SCNetworkConfiguration();
          v40 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v39, (os_log_type_t)v40))
          {
            v41 = _os_log_pack_size();
            v49 = (char *)&v157
                - ((MEMORY[0x1E0C80A78](v41, v42, v43, v44, v45, v46, v47, v48) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            *(_WORD *)_os_log_pack_fill() = 0;
            v50 = (uint64_t)v39;
            v51 = v40;
            v52 = v49;
LABEL_48:
            __SC_log_send(5, v50, v51, v52);
            v11 = v177;
          }
LABEL_49:
          if (v16 == ++v33)
            goto LABEL_50;
        }
        v36 = (uint64_t)v35;
        if (BSDName)
        {
          v37 = SCNetworkInterfaceGetBSDName(v35);
          v38 = CFStringGetTypeID();
          if (v37 && CFGetTypeID(v37) == v38 && CFEqual(v37, value[0]))
          {
            v93 = __log_SCNetworkConfiguration();
            v94 = _SC_syslog_os_log_mapping(5);
            v95 = __SC_log_enabled(5, v93, (os_log_type_t)v94);
            v96 = v170;
            if (v95)
            {
              v97 = _os_log_pack_size();
              v105 = (char *)&v157
                   - ((MEMORY[0x1E0C80A78](v97, v98, v99, v100, v101, v102, v103, v104) + 15) & 0xFFFFFFFFFFFFFFF0);
              __error();
              v106 = _os_log_pack_fill();
              *(_DWORD *)v106 = v171;
              *(_QWORD *)(v106 + 4) = v37;
              v107 = (uint64_t)v93;
              v108 = v94;
              v109 = v105;
LABEL_73:
              __SC_log_send(5, v107, v108, v109);
              v11 = v177;
              goto LABEL_74;
            }
            goto LABEL_74;
          }
          goto LABEL_49;
        }
        v53 = (const void *)__SCNetworkInterfaceGetEntityType((uint64_t)v35);
        v54 = CFStringGetTypeID();
        if (!v53 || CFGetTypeID(v53) != v54 || !CFEqual(v53, v172) && !CFEqual(v53, v166))
        {
          v57 = __log_SCNetworkConfiguration();
          v58 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v57, (os_log_type_t)v58))
            goto LABEL_47;
          goto LABEL_49;
        }
        v55 = (const void *)__SCNetworkInterfaceGetEntitySubType(v36);
        v56 = CFStringGetTypeID();
        if (!v55 || CFGetTypeID(v55) != v56)
          break;
        if (!CFEqual(v53, v174) || !CFEqual(v55, v168))
          goto LABEL_49;
        v110 = __log_SCNetworkConfiguration();
        v111 = _SC_syslog_os_log_mapping(5);
        v112 = __SC_log_enabled(5, v110, (os_log_type_t)v111);
        v96 = v170;
        if (v112)
        {
          v113 = _os_log_pack_size();
          v121 = (char *)&v157
               - ((MEMORY[0x1E0C80A78](v113, v114, v115, v116, v117, v118, v119, v120) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v122 = _os_log_pack_fill();
          *(_DWORD *)v122 = v171;
          *(_QWORD *)(v122 + 4) = 0;
          v107 = (uint64_t)v110;
          v108 = v111;
          v109 = v121;
          goto LABEL_73;
        }
LABEL_74:
        CFDictionaryAddValue(v96, v175, v34);
        CFArrayRemoveValueAtIndex(v11, v33);
LABEL_50:
        v69 = CFDictionaryContainsKey(v170, v175);
        MutableCopy = v173;
        if (!v69)
          CFDictionaryAddValue(v170, v175, v164);
LABEL_67:
        if (++v15 == v176)
        {
          v5 = v161;
          v7 = v160;
          v14 = v170;
          if (!v161)
            goto LABEL_80;
LABEL_93:
          CFRelease(v5);
          if (!v7)
            goto LABEL_82;
LABEL_81:
          CFRelease(v7);
          goto LABEL_82;
        }
      }
      v57 = __log_SCNetworkConfiguration();
      v58 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v57, (os_log_type_t)v58))
      {
LABEL_47:
        v59 = _os_log_pack_size();
        v67 = (char *)&v157
            - ((MEMORY[0x1E0C80A78](v59, v60, v61, v62, v63, v64, v65, v66) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v68 = _os_log_pack_fill();
        *(_DWORD *)v68 = v171;
        *(_QWORD *)(v68 + 4) = v36;
        v50 = (uint64_t)v57;
        v51 = v58;
        v52 = v67;
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    v123 = __log_SCNetworkConfiguration();
    v124 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v123, (os_log_type_t)v124))
    {
      v125 = _os_log_pack_size();
      v133 = (char *)&v157
           - ((MEMORY[0x1E0C80A78](v125, v126, v127, v128, v129, v130, v131, v132) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v123, v124, v133);
    }
    v11 = 0;
    v7 = 0;
    MutableCopy = 0;
    v14 = 0;
    if (v5)
      goto LABEL_93;
LABEL_80:
    if (v7)
      goto LABEL_81;
LABEL_82:
    if (MutableCopy)
      CFRelease(MutableCopy);
    if (v11)
      CFRelease(v11);
  }
  else
  {
    v134 = __log_SCNetworkConfiguration();
    v135 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v134, (os_log_type_t)v135))
    {
      v136 = _os_log_pack_size();
      v144 = (char *)&v157
           - ((MEMORY[0x1E0C80A78](v136, v137, v138, v139, v140, v141, v142, v143) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v134, v135, v144);
    }
    return 0;
  }
  return v14;
}

__CFDictionary *_SCNetworkMigrationCreateSetMapping(const __SCPreferences *a1, const __SCPreferences *a2)
{
  CFArrayRef v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const __CFArray *v7;
  const __CFArray *MutableCopy;
  CFIndex Count;
  __CFDictionary *Mutable;
  SCNetworkSetRef v11;
  const void *ValueAtIndex;
  const __CFString *Name;
  CFIndex v14;
  const __SCNetworkSet *v15;
  const __SCNetworkSet *v16;
  CFIndex v17;
  const __CFString *v18;
  const void *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  _QWORD v33[2];

  v33[1] = *MEMORY[0x1E0C80C00];
  v4 = SCNetworkSetCopyAll(a1);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = SCNetworkSetCopyAll(a2);
  if (!v6)
  {
    Mutable = 0;
    v11 = v5;
LABEL_23:
    CFRelease(v11);
    return Mutable;
  }
  v7 = v6;
  MutableCopy = CFArrayCreateMutableCopy(0, 0, v6);
  Count = CFArrayGetCount(MutableCopy);
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v11 = SCNetworkSetCopyCurrent(a1);
  if (!v11)
    goto LABEL_6;
  if (Count >= 1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, 0);
    CFRetain(ValueAtIndex);
    CFArrayRemoveValueAtIndex(MutableCopy, 0);
    Name = SCNetworkSetGetName(v11);
    SCNetworkSetSetName((SCNetworkSetRef)ValueAtIndex, Name);
    CFDictionaryAddValue(Mutable, v11, ValueAtIndex);
    SCNetworkSetSetCurrent((SCNetworkSetRef)ValueAtIndex);
    CFRelease(ValueAtIndex);
LABEL_6:
    if (CFArrayGetCount(v5) >= 1)
    {
      v14 = 0;
      do
      {
        v15 = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v5, v14);
        v16 = v15;
        if (!v11 || !CFEqual(v15, v11))
        {
          v17 = CFArrayGetCount(MutableCopy);
          v18 = SCNetworkSetGetName(v16);
          if (v17 < 1)
          {
            v19 = SCNetworkSetCreate(a2);
          }
          else
          {
            v19 = CFArrayGetValueAtIndex(MutableCopy, 0);
            CFRetain(v19);
            CFArrayRemoveValueAtIndex(MutableCopy, 0);
          }
          SCNetworkSetSetName((SCNetworkSetRef)v19, v18);
          CFDictionaryAddValue(Mutable, v16, v19);
          CFRelease(v19);
        }
        ++v14;
      }
      while (v14 < CFArrayGetCount(v5));
    }
    goto LABEL_20;
  }
  v20 = __log_SCNetworkConfiguration();
  v21 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v20, (os_log_type_t)v21))
  {
    v22 = _os_log_pack_size();
    v33[0] = v33;
    v30 = (char *)v33 - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v31 = _os_log_pack_fill();
    *(_DWORD *)v31 = 134217984;
    *(_QWORD *)(v31 + 4) = Count;
    __SC_log_send(5, (uint64_t)v20, v21, v30);
  }
LABEL_20:
  CFRelease(v5);
  CFRelease(v7);
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (v11)
    goto LABEL_23;
  return Mutable;
}

__CFDictionary *_SCNetworkMigrationCreateServiceSetMapping(const __SCPreferences *a1)
{
  __CFDictionary *Mutable;
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex v5;
  const CFArrayCallBacks *v6;
  const void *ValueAtIndex;
  CFMutableArrayRef v8;
  const __CFArray *v9;
  const __CFArray *v10;
  CFIndex v11;
  const __SCNetworkSet *v12;
  const __CFArray *v13;
  CFIndex v14;
  const void *v15;
  __CFArray *Value;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v3 = SCNetworkServiceCopyAll(a1);
  if (v3)
  {
    v4 = v3;
    if (CFArrayGetCount(v3) >= 1)
    {
      v5 = 0;
      v6 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v4, v5);
        v8 = CFArrayCreateMutable(0, 0, v6);
        CFDictionaryAddValue(Mutable, ValueAtIndex, v8);
        CFRelease(v8);
        ++v5;
      }
      while (v5 < CFArrayGetCount(v4));
    }
    CFRelease(v4);
    v9 = SCNetworkSetCopyAll(a1);
    if (v9)
    {
      v10 = v9;
      if (CFArrayGetCount(v9) >= 1)
      {
        v11 = 0;
        do
        {
          v12 = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v10, v11);
          v13 = SCNetworkSetCopyServices(v12);
          if (CFArrayGetCount(v13) >= 1)
          {
            v14 = 0;
            do
            {
              v15 = CFArrayGetValueAtIndex(v13, v14);
              Value = (__CFArray *)CFDictionaryGetValue(Mutable, v15);
              if (Value)
                CFArrayAppendValue(Value, v12);
              ++v14;
            }
            while (v14 < CFArrayGetCount(v13));
          }
          CFRelease(v13);
          ++v11;
        }
        while (v11 < CFArrayGetCount(v10));
      }
      CFRelease(v10);
    }
  }
  return Mutable;
}

BOOL _SCNetworkMigrationDoServiceMigration(uint64_t a1, uint64_t a2, const __CFDictionary *a3, const __CFDictionary *a4, const __CFDictionary *a5, const __CFDictionary *a6)
{
  CFTypeID TypeID;
  CFTypeID v12;
  NSObject *v13;
  uint64_t v14;
  _BOOL8 result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  __int128 v47;
  __int128 v48;
  uint64_t context;
  const char *v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v47 = 0u;
  v48 = 0u;
  if (a1
    && a2
    && (TypeID = CFDictionaryGetTypeID(), a3)
    && CFGetTypeID(a3) == TypeID
    && (v12 = CFDictionaryGetTypeID(), a4)
    && CFGetTypeID(a4) == v12)
  {
    context = 6;
    v50 = "BSD name mapping";
    CFDictionaryApplyFunction(a4, (CFDictionaryApplierFunction)logMapping_one, &context);
    context = 6;
    v50 = "SCNetworkService mapping";
    CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)logMapping_one, &context);
    if (a5)
    {
      context = 6;
      v50 = "SCNetworkSet mapping";
      CFDictionaryApplyFunction(a5, (CFDictionaryApplierFunction)logMapping_one, &context);
    }
    else
    {
      v25 = __log_SCNetworkConfiguration();
      v26 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v25, (os_log_type_t)v26))
      {
        v27 = _os_log_pack_size();
        v35 = (char *)&v47 - ((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v25, v26, v35);
      }
    }
    if (a6)
    {
      context = 6;
      v50 = "SCNetworkService/SCNetworkSet mapping";
      CFDictionaryApplyFunction(a6, (CFDictionaryApplierFunction)logMapping_one, &context);
    }
    else
    {
      v36 = __log_SCNetworkConfiguration();
      v37 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v36, (os_log_type_t)v37))
      {
        v38 = _os_log_pack_size();
        v46 = (char *)&v47 - ((MEMORY[0x1E0C80A78](v38, v39, v40, v41, v42, v43, v44, v45) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v36, v37, v46);
      }
    }
    *(_QWORD *)&v47 = a2;
    *((_QWORD *)&v47 + 1) = a4;
    *(_QWORD *)&v48 = a5;
    *((_QWORD *)&v48 + 1) = a6;
    CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)ServiceMigrationAddOrReplace, &v47);
    return 1;
  }
  else
  {
    v13 = __log_SCNetworkConfiguration();
    v14 = _SC_syslog_os_log_mapping(6);
    result = __SC_log_enabled(6, v13, (os_log_type_t)v14);
    if (result)
    {
      v16 = _os_log_pack_size();
      v24 = (char *)&v47 - ((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v13, v14, v24);
      return 0;
    }
  }
  return result;
}

__CFDictionary *_SCNetworkConfigurationCopyBuiltinMapping(const __SCPreferences *a1, const __SCPreferences *a2)
{
  __CFArray *v3;
  CFTypeID TypeID;
  CFIndex Count;
  __CFArray *v6;
  CFTypeID v7;
  __CFDictionary *Mutable;
  CFIndex i;
  unsigned __int8 *ValueAtIndex;
  CFIndex v11;
  CFIndex v12;
  CFIndex v13;
  unsigned __int8 *v14;
  const void *HardwareAddress;
  const void *v16;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  _QWORD v40[2];

  v40[1] = *MEMORY[0x1E0C80C00];
  v3 = _SCNetworkInterfaceCopyInterfacesFilteredByBuiltinWithPreferences(a1, 1);
  TypeID = CFArrayGetTypeID();
  if (v3 && CFGetTypeID(v3) == TypeID)
  {
    Count = CFArrayGetCount(v3);
    v6 = _SCNetworkInterfaceCopyInterfacesFilteredByBuiltinWithPreferences(a2, 1);
    v7 = CFArrayGetTypeID();
    if (v6 && CFGetTypeID(v6) == v7)
    {
      if (Count >= 1)
      {
        Mutable = 0;
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (unsigned __int8 *)CFArrayGetValueAtIndex(v3, i);
          v11 = CFArrayGetCount(v6);
          if (v11 >= 1)
          {
            v12 = v11;
            v13 = 0;
            while (1)
            {
              v14 = (unsigned __int8 *)CFArrayGetValueAtIndex(v6, v13);
              HardwareAddress = (const void *)_SCNetworkInterfaceGetHardwareAddress((uint64_t)ValueAtIndex);
              v16 = (const void *)_SCNetworkInterfaceGetHardwareAddress((uint64_t)v14);
              if (HardwareAddress == v16 || HardwareAddress && v16 && CFEqual(HardwareAddress, v16))
                break;
              if (v12 == ++v13)
              {
                v13 = 0;
                while (1)
                {
                  v14 = (unsigned __int8 *)CFArrayGetValueAtIndex(v6, v13);
                  if (_SCNetworkConfigurationIsInterfaceNamerMappable(ValueAtIndex, v14))
                    goto LABEL_18;
                  if (v12 == ++v13)
                    goto LABEL_21;
                }
              }
            }
LABEL_18:
            if (!Mutable)
              Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            CFDictionaryAddValue(Mutable, ValueAtIndex, v14);
            CFArrayRemoveValueAtIndex(v6, v13);
          }
LABEL_21:
          ;
        }
        goto LABEL_32;
      }
    }
    else
    {
      v29 = __log_SCNetworkConfiguration();
      v30 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v29, (os_log_type_t)v30))
      {
        v31 = _os_log_pack_size();
        v39 = (char *)v40 - ((MEMORY[0x1E0C80A78](v31, v32, v33, v34, v35, v36, v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(6, (uint64_t)v29, v30, v39);
      }
    }
    Mutable = 0;
LABEL_32:
    CFRelease(v3);
    if (v6)
      CFRelease(v6);
    return Mutable;
  }
  v18 = __log_SCNetworkConfiguration();
  v19 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v18, (os_log_type_t)v19))
  {
    v20 = _os_log_pack_size();
    v28 = (char *)v40 - ((MEMORY[0x1E0C80A78](v20, v21, v22, v23, v24, v25, v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(6, (uint64_t)v18, v19, v28);
  }
  v6 = 0;
  Mutable = 0;
  if (v3)
    goto LABEL_32;
  return Mutable;
}

uint64_t _SCNetworkMigrationDoServiceOrderMigration(const void *a1)
{
  CFTypeID TypeID;
  unsigned __int8 context;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  context = 1;
  TypeID = CFDictionaryGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
    return 0;
  CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)preserve_service_order, &context);
  return context;
}

uint64_t _SCNetworkMigrationDoSystemMigration(const __SCPreferences *a1, const __SCPreferences *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  const __CFString *HostName;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  const __CFString *v27;
  const __CFString *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  const __CFString *v40;
  const __CFString *v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  _BYTE v54[4];
  CFStringEncoding v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v55 = 0;
  v4 = __log_SCNetworkConfiguration();
  v5 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v4, (os_log_type_t)v5))
  {
    v6 = _os_log_pack_size();
    v14 = &v54[-((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0)];
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(5, (uint64_t)v4, v5, v14);
  }
  if (!a2)
    return 0;
  HostName = (const __CFString *)SCPreferencesGetHostName(a1);
  if (HostName)
  {
    SCPreferencesSetHostName(a2, HostName);
    v16 = __log_SCNetworkConfiguration();
    v17 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v16, (os_log_type_t)v17))
    {
      v18 = _os_log_pack_size();
      v26 = &v54[-((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v16, v17, v26);
    }
  }
  v27 = (const __CFString *)_SCPreferencesCopyLocalHostName(a1);
  if (v27)
  {
    v28 = v27;
    SCPreferencesSetLocalHostName(a2, v27);
    CFRelease(v28);
    v29 = __log_SCNetworkConfiguration();
    v30 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v29, (os_log_type_t)v30))
    {
      v31 = _os_log_pack_size();
      v39 = &v54[-((MEMORY[0x1E0C80A78](v31, v32, v33, v34, v35, v36, v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v29, v30, v39);
    }
  }
  v40 = (const __CFString *)_SCPreferencesCopyComputerName(a1, &v55);
  if (!v40)
    return 1;
  v41 = v40;
  SCPreferencesSetComputerName(a2, v40, v55);
  CFRelease(v41);
  v42 = __log_SCNetworkConfiguration();
  v43 = _SC_syslog_os_log_mapping(5);
  if (!__SC_log_enabled(5, v42, (os_log_type_t)v43))
    return 1;
  v44 = _os_log_pack_size();
  v52 = &v54[-((MEMORY[0x1E0C80A78](v44, v45, v46, v47, v48, v49, v50, v51) + 15) & 0xFFFFFFFFFFFFFFF0)];
  __error();
  *(_WORD *)_os_log_pack_fill() = 0;
  __SC_log_send(5, (uint64_t)v42, v43, v52);
  return 1;
}

uint64_t _SCNetworkConfigurationMigrateIsFilePresent(const __CFURL *a1)
{
  const __CFString *v2;
  const void *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  int v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  stat v59;
  UInt8 v60[1024];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  memset(&v59, 0, sizeof(v59));
  if (!a1)
  {
    v17 = __log_SCNetworkConfiguration();
    v18 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v17, (os_log_type_t)v18))
    {
      v19 = _os_log_pack_size();
      v27 = (char *)&v59 - ((MEMORY[0x1E0C80A78](v19, v20, v21, v22, v23, v24, v25, v26) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v17, v18, v27);
    }
    return 0;
  }
  if (!CFURLGetFileSystemRepresentation(a1, 1u, v60, 1024))
  {
    v28 = __log_SCNetworkConfiguration();
    v29 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v28, (os_log_type_t)v29))
    {
      v30 = _os_log_pack_size();
      v38 = (char *)&v59 - ((MEMORY[0x1E0C80A78](v30, v31, v32, v33, v34, v35, v36, v37) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
LABEL_14:
      v39 = _os_log_pack_fill();
      *(_DWORD *)v39 = 138412290;
      *(_QWORD *)(v39 + 4) = a1;
      v40 = 5;
LABEL_15:
      __SC_log_send(v40, (uint64_t)v28, v29, v38);
    }
    return 0;
  }
  if (stat((const char *)v60, &v59))
    return 0;
  if (!v59.st_size)
  {
    v28 = __log_SCNetworkConfiguration();
    v29 = _SC_syslog_os_log_mapping(6);
    if (!__SC_log_enabled(6, v28, (os_log_type_t)v29))
      return 0;
    v42 = _os_log_pack_size();
    v38 = (char *)&v59 - ((MEMORY[0x1E0C80A78](v42, v43, v44, v45, v46, v47, v48, v49) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v50 = _os_log_pack_fill();
    *(_DWORD *)v50 = 138412290;
    *(_QWORD *)(v50 + 4) = a1;
    v40 = 6;
    goto LABEL_15;
  }
  v2 = CFStringCreateWithCString(0, (const char *)v60, 0x8000100u);
  v3 = (const void *)__SCPreferencesCreateForMigration(CFSTR("System Migration"), v2);
  CFRelease(v2);
  if (!v3)
  {
    v28 = __log_SCNetworkConfiguration();
    v29 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v28, (os_log_type_t)v29))
      return 0;
    v51 = _os_log_pack_size();
    v38 = (char *)&v59 - ((MEMORY[0x1E0C80A78](v51, v52, v53, v54, v55, v56, v57, v58) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    goto LABEL_14;
  }
  if (__SCPreferencesIsEmpty((uint64_t)v3))
  {
    v4 = __log_SCNetworkConfiguration();
    v5 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v4, (os_log_type_t)v5))
    {
      v6 = _os_log_pack_size();
      v14 = (char *)&v59 - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v15 = _os_log_pack_fill();
      *(_DWORD *)v15 = 138412290;
      *(_QWORD *)(v15 + 4) = a1;
      __SC_log_send(5, (uint64_t)v4, v5, v14);
    }
    v16 = 0;
  }
  else
  {
    v16 = 1;
  }
  CFRelease(v3);
  return v16;
}

void _SCNetworkConfigurationCollectMissingService(const void *a1, void *a2, const __CFDictionary **a3)
{
  __CFArray *v5;
  const __CFDictionary *v6;
  CFTypeID TypeID;

  v6 = *a3;
  v5 = a3[1];
  TypeID = SCNetworkInterfaceGetTypeID();
  if (a2
    && CFGetTypeID(a2) == TypeID
    && _SCNetworkInterfaceIsBuiltin((unsigned __int8 *)a2)
    && !CFDictionaryContainsKey(v6, a1))
  {
    CFArrayAppendValue(v5, a2);
  }
}

__CFArray *_SCNetworkInterfaceCopyInterfacesFilteredByBuiltinWithPreferences(const __SCPreferences *a1, int a2)
{
  __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  __CFArray *Mutable;
  void *Companion;
  CFIndex i;
  unsigned __int8 *ValueAtIndex;
  CFTypeRef Copy;

  v4 = __SCNetworkInterfaceCopyStoredWithPreferences(a1);
  if (!v4)
    return 0;
  v5 = v4;
  Count = CFArrayGetCount(v4);
  if (Count < 1)
  {
    Mutable = 0;
    Companion = v5;
LABEL_11:
    CFRelease(Companion);
    return Mutable;
  }
  v7 = Count;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  Companion = SCPreferencesCreateCompanion((uint64_t)a1, 0);
  for (i = 0; i != v7; ++i)
  {
    ValueAtIndex = (unsigned __int8 *)CFArrayGetValueAtIndex(v5, i);
    if (_SCNetworkInterfaceIsBuiltin(ValueAtIndex) == a2)
    {
      Copy = __SCNetworkInterfaceCreateCopy(0, (uint64_t)ValueAtIndex, Companion, 0);
      CFArrayAppendValue(Mutable, Copy);
      CFRelease(Copy);
    }
  }
  CFRelease(v5);
  if (Companion)
    goto LABEL_11;
  return Mutable;
}

const __CFDictionary *_SCNetworkInterfaceStorageCopyMaxUnitPerInterfaceType(const __SCPreferences *a1)
{
  __CFArray *v1;
  const __CFArray *v2;
  const __CFDictionary *Mutable;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID TypeID;
  const void *IOInterfaceType;
  CFTypeID v10;
  const void *Value;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  const void *IOInterfaceUnit;
  CFTypeID v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  _BYTE v37[4];
  int valuePtr;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v1 = __SCNetworkInterfaceCopyStoredWithPreferences(a1);
  if (v1)
  {
    v2 = v1;
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    Count = CFArrayGetCount(v2);
    if (Count >= 1)
    {
      v5 = Count;
      for (i = 0; i != v5; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v2, i);
        TypeID = SCNetworkInterfaceGetTypeID();
        if (ValueAtIndex && CFGetTypeID(ValueAtIndex) == TypeID)
        {
          IOInterfaceType = (const void *)_SCNetworkInterfaceGetIOInterfaceType((uint64_t)ValueAtIndex);
          v10 = CFNumberGetTypeID();
          if (IOInterfaceType && CFGetTypeID(IOInterfaceType) == v10)
          {
            if (CFDictionaryContainsKey(Mutable, IOInterfaceType)
              || (valuePtr = 0,
                  Value = CFNumberCreate(0, kCFNumberIntType, &valuePtr),
                  CFDictionaryAddValue(Mutable, IOInterfaceType, Value),
                  CFRelease(Value),
                  !Value))
            {
              Value = CFDictionaryGetValue(Mutable, IOInterfaceType);
            }
            IOInterfaceUnit = (const void *)_SCNetworkInterfaceGetIOInterfaceUnit((uint64_t)ValueAtIndex);
            v24 = CFNumberGetTypeID();
            if (IOInterfaceUnit
              && CFGetTypeID(IOInterfaceUnit) == v24
              && CFNumberCompare((CFNumberRef)IOInterfaceUnit, (CFNumberRef)Value, 0) == kCFCompareGreaterThan)
            {
              CFDictionarySetValue(Mutable, IOInterfaceType, IOInterfaceUnit);
            }
          }
          else
          {
            v12 = __log_SCNetworkConfiguration();
            v13 = _SC_syslog_os_log_mapping(6);
            if (__SC_log_enabled(6, v12, (os_log_type_t)v13))
            {
              v14 = _os_log_pack_size();
              v22 = &v37[-((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0)];
              __error();
              *(_WORD *)_os_log_pack_fill() = 0;
              __SC_log_send(6, (uint64_t)v12, v13, v22);
            }
          }
        }
      }
    }
    CFRelease(v2);
  }
  else
  {
    v25 = __log_SCNetworkConfiguration();
    v26 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v25, (os_log_type_t)v26))
    {
      v27 = _os_log_pack_size();
      v35 = &v37[-((MEMORY[0x1E0C80A78](v27, v28, v29, v30, v31, v32, v33, v34) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v25, v26, v35);
    }
    return 0;
  }
  return Mutable;
}

uint64_t _SCNetworkConfigurationIsInterfaceNamerMappable(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int IsBuiltin;
  CFStringRef InterfaceType;
  CFStringRef v6;
  CFStringRef v7;
  uint64_t result;
  const void *IOInterfaceNamePrefix;
  uint64_t v10;
  const void *v11;
  CFStringRef LocalizedDisplayName;
  CFStringRef v13;
  const __CFString *v14;

  if (a1 == a2)
    return 1;
  IsBuiltin = _SCNetworkInterfaceIsBuiltin(a1);
  if (IsBuiltin != _SCNetworkInterfaceIsBuiltin(a2))
    return 0;
  InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a1);
  v6 = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a2);
  if (InterfaceType == v6
    || (v7 = v6, result = 0, InterfaceType) && v7 && (result = CFEqual(InterfaceType, v7), (_DWORD)result))
  {
    IOInterfaceNamePrefix = (const void *)_SCNetworkInterfaceGetIOInterfaceNamePrefix((uint64_t)a1);
    v10 = _SCNetworkInterfaceGetIOInterfaceNamePrefix((uint64_t)a2);
    if (IOInterfaceNamePrefix == (const void *)v10
      || (v11 = (const void *)v10, result = 0, IOInterfaceNamePrefix)
      && v11
      && (result = CFEqual(IOInterfaceNamePrefix, v11), (_DWORD)result))
    {
      LocalizedDisplayName = SCNetworkInterfaceGetLocalizedDisplayName((SCNetworkInterfaceRef)a1);
      v13 = SCNetworkInterfaceGetLocalizedDisplayName((SCNetworkInterfaceRef)a2);
      if (LocalizedDisplayName == v13)
        return 1;
      v14 = v13;
      if (LocalizedDisplayName)
      {
        if (v13 && CFEqual(LocalizedDisplayName, v13))
          return 1;
      }
      return IsBuiltin && __SCNetworkConfigurationInterfaceNameIsEquiv(LocalizedDisplayName, v14);
    }
  }
  return result;
}

void _SCNetworkConfigurationCollectInterfaceStorageEntity(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  const __CFArray *v5;
  CFIndex FirstIndexOfValue;
  CFIndex v7;
  _QWORD *ValueAtIndex;
  const void *UserDefinedName;
  const void *v10;
  BOOL v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  __CFString *v36;
  __CFString *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  _QWORD v50[2];
  CFRange v51;

  v50[1] = *MEMORY[0x1E0C80C00];
  v5 = *(const __CFArray **)a3;
  v51.length = CFArrayGetCount(*(CFArrayRef *)a3);
  v51.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v5, v51, a2);
  if (FirstIndexOfValue != -1)
  {
    v7 = FirstIndexOfValue;
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a3, FirstIndexOfValue);
    UserDefinedName = (const void *)__SCNetworkInterfaceGetUserDefinedName(ValueAtIndex);
    v10 = (const void *)__SCNetworkInterfaceGetUserDefinedName(a2);
    if (UserDefinedName == v10
      || (UserDefinedName ? (v11 = v10 == 0) : (v11 = 1), !v11 && CFEqual(UserDefinedName, v10)))
    {
      v12 = __log_SCNetworkConfiguration();
      v13 = _SC_syslog_os_log_mapping(7);
      if (__SC_log_enabled(7, v12, (os_log_type_t)v13))
      {
        v14 = _os_log_pack_size();
        v22 = (char *)v50 - ((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v23 = _os_log_pack_fill();
        *(_DWORD *)v23 = 138412290;
        *(_QWORD *)(v23 + 4) = a2;
        __SC_log_send(7, (uint64_t)v12, v13, v22);
      }
      return;
    }
    v24 = __log_SCNetworkConfiguration();
    v25 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v24, (os_log_type_t)v25))
    {
      v26 = _os_log_pack_size();
      v34 = (char *)v50 - ((MEMORY[0x1E0C80A78](v26, v27, v28, v29, v30, v31, v32, v33) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v35 = _os_log_pack_fill();
      *(_DWORD *)v35 = 138412290;
      *(_QWORD *)(v35 + 4) = ValueAtIndex;
      __SC_log_send(7, (uint64_t)v24, v25, v34);
    }
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)a3, v7);
  }
  *(_BYTE *)(a3 + 16) = 1;
  v36 = __SCNetworkInterfaceCopyStorageEntity((uint64_t)a2);
  if (v36)
  {
    v37 = v36;
    v38 = __log_SCNetworkConfiguration();
    v39 = _SC_syslog_os_log_mapping(7);
    if (__SC_log_enabled(7, v38, (os_log_type_t)v39))
    {
      v40 = _os_log_pack_size();
      v48 = (char *)v50 - ((MEMORY[0x1E0C80A78](v40, v41, v42, v43, v44, v45, v46, v47) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v49 = _os_log_pack_fill();
      *(_DWORD *)v49 = 138412290;
      *(_QWORD *)(v49 + 4) = v37;
      __SC_log_send(7, (uint64_t)v38, v39, v48);
    }
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 8), v37);
    CFRelease(v37);
  }
}

void SCNetworkMigrationMapSourceToTargetName(const __SCNetworkInterface *a1, const __SCNetworkInterface *a2, __CFDictionary *a3)
{
  CFStringRef BSDName;
  CFTypeID TypeID;
  CFStringRef v7;
  CFTypeID v8;

  BSDName = SCNetworkInterfaceGetBSDName(a1);
  TypeID = CFStringGetTypeID();
  if (BSDName)
  {
    if (CFGetTypeID(BSDName) == TypeID)
    {
      v7 = SCNetworkInterfaceGetBSDName(a2);
      v8 = CFStringGetTypeID();
      if (v7)
      {
        if (CFGetTypeID(v7) == v8 && !CFDictionaryContainsKey(a3, BSDName))
          CFDictionaryAddValue(a3, BSDName, v7);
      }
    }
  }
}

void ServiceMigrationAddOrReplace(SCNetworkServiceRef service, const __SCNetworkService *a2, const __SCPreferences **a3)
{
  const __CFDictionary *v4;
  const __SCPreferences *v5;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  CFTypeID TypeID;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  _QWORD v46[2];

  v46[1] = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  v4 = a3[1];
  v6 = a3[2];
  v7 = a3[3];
  if (*((_OWORD *)a3 + 1) != 0)
  {
    TypeID = SCNetworkServiceGetTypeID();
    if (a2)
    {
      if (CFGetTypeID(a2) == TypeID)
      {
        SCNetworkServiceGetName(a2);
        v10 = __log_SCNetworkConfiguration();
        v11 = _SC_syslog_os_log_mapping(6);
        if (__SC_log_enabled(6, v10, (os_log_type_t)v11))
        {
          v12 = _os_log_pack_size();
          v46[0] = v46;
          v20 = (char *)v46
              - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v21 = _os_log_pack_fill();
          *(_DWORD *)v21 = 138412290;
          *(_QWORD *)(v21 + 4) = a2;
          __SC_log_send(6, (uint64_t)v10, v11, v20);
        }
        SCNetworkServiceRemove(a2);
      }
    }
  }
  SCNetworkServiceGetName(service);
  v22 = __log_SCNetworkConfiguration();
  v23 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v22, (os_log_type_t)v23))
  {
    v24 = _os_log_pack_size();
    v32 = (char *)v46 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v33 = _os_log_pack_fill();
    *(_DWORD *)v33 = 138412290;
    *(_QWORD *)(v33 + 4) = service;
    __SC_log_send(6, (uint64_t)v22, v23, v32);
  }
  if (!__SCNetworkServiceMigrateNew(v5, (uint64_t)service, v4, v6, v7))
  {
    SCNetworkServiceGetName(service);
    v34 = __log_SCNetworkConfiguration();
    v35 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v34, (os_log_type_t)v35))
    {
      v36 = _os_log_pack_size();
      v44 = (char *)v46 - ((MEMORY[0x1E0C80A78](v36, v37, v38, v39, v40, v41, v42, v43) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v45 = _os_log_pack_fill();
      *(_DWORD *)v45 = 138412290;
      *(_QWORD *)(v45 + 4) = service;
      __SC_log_send(6, (uint64_t)v34, v35, v44);
    }
  }
}

void preserve_service_order(const __SCNetworkSet *a1, const __SCNetworkSet *a2, _BYTE *a3)
{
  const CFArrayCallBacks *v6;
  const __CFArray *Mutable;
  const __CFArray *v8;
  CFArrayRef ServiceOrder;
  const __CFArray *v10;
  CFArrayRef v11;
  const __CFArray *v12;
  CFIndex v13;
  const __SCNetworkService *ValueAtIndex;
  __int128 v15;
  CFIndex v16;
  const __SCNetworkService *v17;
  const __SCNetworkInterface *Interface;
  CFStringRef BSDName;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  int v33;
  const __CFArray *v34;
  const char *v35;
  CFStringRef ServiceID;
  const __CFString *v37;
  __int128 v38;
  NSObject *v39;
  __int128 *v40;
  __int128 v41;
  __int128 v42;
  __int128 context;
  __int128 v44;
  uint64_t v45;
  CFRange v46;
  CFRange v47;

  v45 = *MEMORY[0x1E0C80C00];
  if (*a3)
  {
    context = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v6 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    v8 = CFArrayCreateMutable(0, 0, v6);
    ServiceOrder = SCNetworkSetGetServiceOrder(a1);
    if (ServiceOrder)
    {
      v10 = ServiceOrder;
      v11 = SCNetworkSetGetServiceOrder(a2);
      if (v11)
      {
        v12 = v11;
        *(_QWORD *)&context = 0;
        *((_QWORD *)&context + 1) = v11;
        *(_QWORD *)&v44 = Mutable;
        *((_QWORD *)&v44 + 1) = a3;
        v46.length = CFArrayGetCount(v10);
        v46.location = 0;
        CFArrayApplyFunction(v10, v46, (CFArrayApplierFunction)create_migrated_order, &context);
        if (*a3)
        {
          *(_QWORD *)&v41 = *((_QWORD *)a2 + 3);
          *((_QWORD *)&v41 + 1) = v8;
          *(_QWORD *)&v42 = Mutable;
          *((_QWORD *)&v42 + 1) = a3;
          v47.length = CFArrayGetCount(v12);
          v47.location = 0;
          CFArrayApplyFunction(v12, v47, (CFArrayApplierFunction)create_non_migrated_service_list, &v41);
          if (CFArrayGetCount(v8) >= 1)
          {
            v13 = 0;
            do
            {
              ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(v8, v13);
              SCNetworkSetRemoveService(a2, ValueAtIndex);
              ++v13;
            }
            while (v13 < CFArrayGetCount(v8));
          }
          SCNetworkSetSetServiceOrder(a2, Mutable);
          if (CFArrayGetCount(v8) >= 1)
          {
            v16 = 0;
            *(_QWORD *)&v15 = 136315650;
            v38 = v15;
            do
            {
              v17 = (const __SCNetworkService *)CFArrayGetValueAtIndex(v8, v16);
              if (!SCNetworkSetAddService(a2, v17))
              {
                Interface = SCNetworkServiceGetInterface(v17);
                BSDName = SCNetworkInterfaceGetBSDName(Interface);
                v20 = __log_SCNetworkConfiguration();
                v21 = _SC_syslog_os_log_mapping(5);
                if (__SC_log_enabled(5, v20, (os_log_type_t)v21))
                {
                  v22 = _os_log_pack_size();
                  v40 = &v38;
                  v30 = MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29);
                  v39 = v20;
                  v31 = (char *)&v38 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
                  __error();
                  v32 = _os_log_pack_fill();
                  v33 = SCError();
                  v34 = Mutable;
                  v35 = SCErrorString(v33);
                  ServiceID = SCNetworkServiceGetServiceID(v17);
                  *(_DWORD *)v32 = v38;
                  v37 = CFSTR("?");
                  if (BSDName)
                    v37 = BSDName;
                  *(_QWORD *)(v32 + 4) = v35;
                  Mutable = v34;
                  *(_WORD *)(v32 + 12) = 2112;
                  *(_QWORD *)(v32 + 14) = ServiceID;
                  *(_WORD *)(v32 + 22) = 2112;
                  *(_QWORD *)(v32 + 24) = v37;
                  __SC_log_send(5, (uint64_t)v39, v21, v31);
                }
              }
              ++v16;
            }
            while (v16 < CFArrayGetCount(v8));
          }
        }
      }
    }
    CFRelease(Mutable);
    CFRelease(v8);
  }
}

void create_migrated_order(const void *a1, uint64_t a2)
{
  __CFArray *v3;
  const __CFArray *v4;
  CFIndex v5;
  const void *ValueAtIndex;

  if (**(_BYTE **)(a2 + 24))
  {
    v4 = *(const __CFArray **)(a2 + 8);
    v3 = *(__CFArray **)(a2 + 16);
    if (CFArrayGetCount(v4) >= 1)
    {
      v5 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v4, v5);
        if (CFEqual(a1, ValueAtIndex))
          break;
        if (++v5 >= CFArrayGetCount(v4))
          return;
      }
      CFArrayAppendValue(v3, a1);
    }
  }
}

void create_non_migrated_service_list(const __CFString *a1, uint64_t a2)
{
  _BYTE *v2;
  __CFArray *v4;
  const __SCPreferences *v5;
  const __CFArray *v6;
  SCNetworkServiceRef v7;
  SCNetworkServiceRef v8;
  CFRange v9;

  v2 = *(_BYTE **)(a2 + 24);
  if (*v2)
  {
    v5 = *(const __SCPreferences **)a2;
    v4 = *(__CFArray **)(a2 + 8);
    v6 = *(const __CFArray **)(a2 + 16);
    v9.length = CFArrayGetCount(v6);
    v9.location = 0;
    if (CFArrayGetFirstIndexOfValue(v6, v9, a1) == -1)
    {
      v7 = SCNetworkServiceCopy(v5, a1);
      if (v7)
      {
        v8 = v7;
        CFArrayAppendValue(v4, v7);
        CFRelease(v8);
      }
      else
      {
        *v2 = 0;
      }
    }
  }
}

BOOL _SCHelperOpen(const __CFData *a1, mach_port_name_t *a2)
{
  int v4;
  ipc_space_t *v5;
  int v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  _DWORD *v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  _BOOL8 result;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD v43[2];

  v43[1] = *MEMORY[0x1E0C80C00];
  v43[0] = 0;
  *a2 = 0;
  v4 = _helper_server;
  v5 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  if (!_helper_server)
  {
    do
    {
LABEL_3:
      pthread_mutex_lock(&_helper_lock);
      v7 = _helper_server;
      if (_helper_server)
      {
        if (v4 != _helper_server)
          goto LABEL_7;
        mach_port_deallocate(*v5, v4);
      }
      v7 = __SCHelperServerPort((_DWORD *)v43 + 1);
      _helper_server = v7;
      if (!v7)
      {
        LODWORD(v43[0]) = HIDWORD(v43[0]);
        pthread_mutex_unlock(&_helper_lock);
        goto LABEL_12;
      }
LABEL_7:
      pthread_mutex_unlock(&_helper_lock);
      v4 = v7;
    }
    while (!v7);
  }
  v6 = helperinit(v4, a2, v43);
  HIDWORD(v43[0]) = v6;
  if (v6 == 268435459)
    goto LABEL_3;
  if (v6)
    LODWORD(v43[0]) = v6;
LABEL_12:
  if (!*a2)
  {
    v21 = __log_SCPreferences();
    v22 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v21, (os_log_type_t)v22);
    if (!result)
      return result;
    v24 = _os_log_pack_size();
    v32 = (char *)v43 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v33 = _os_log_pack_fill();
    v34 = SCErrorString(v43[0]);
    *(_DWORD *)v33 = 136315138;
    *(_QWORD *)(v33 + 4) = v34;
    __SC_log_send(5, (uint64_t)v21, v22, v32);
    return 0;
  }
  if (!_SCHelperExec(*a2, 1, a1, v43, 0))
  {
    v8 = __log_SCPreferences();
    v9 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v8, (os_log_type_t)v9))
      goto LABEL_22;
    v35 = _os_log_pack_size();
    v18 = (char *)v43 - ((MEMORY[0x1E0C80A78](v35, v36, v37, v38, v39, v40, v41, v42) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
LABEL_21:
    __SC_log_send(5, (uint64_t)v8, v9, v18);
LABEL_22:
    if (*a2)
    {
      mach_port_deallocate(*v5, *a2);
      result = 0;
      *a2 = 0;
      return result;
    }
    return 0;
  }
  if (LODWORD(v43[0]))
  {
    v8 = __log_SCPreferences();
    v9 = _SC_syslog_os_log_mapping(5);
    if (!__SC_log_enabled(5, v8, (os_log_type_t)v9))
      goto LABEL_22;
    v10 = _os_log_pack_size();
    v18 = (char *)v43 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v19 = (_DWORD *)_os_log_pack_fill();
    v20 = v43[0];
    *v19 = 67109120;
    v19[1] = v20;
    goto LABEL_21;
  }
  return 1;
}

uint64_t __SCHelperServerPort(_DWORD *a1)
{
  int v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  int *v28;
  char *v29;
  _BYTE v30[4];
  unsigned int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  getenv("SCHELPER_SERVER");
  v2 = bootstrap_look_up2();
  *a1 = v2;
  if (v2)
  {
    if (__SCHelperServerPort_once != -1)
      dispatch_once(&__SCHelperServerPort_once, &__block_literal_global_15);
    getpid();
    v3 = sandbox_check();
    if (v3)
    {
      if (v3 == 1)
      {
        v4 = __log_SCPreferences();
        v5 = _SC_syslog_os_log_mapping(5);
        result = __SC_log_enabled(5, v4, (os_log_type_t)v5);
        if ((_DWORD)result)
        {
          v7 = _os_log_pack_size();
          v15 = &v30[-((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0)];
          __error();
          *(_WORD *)_os_log_pack_fill() = 0;
          __SC_log_send(5, (uint64_t)v4, v5, v15);
          return 0;
        }
        return result;
      }
      v16 = __log_SCPreferences();
      v17 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v16, (os_log_type_t)v17))
      {
        v18 = _os_log_pack_size();
        v26 = &v30[-((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v27 = _os_log_pack_fill();
        v28 = __error();
        v29 = strerror(*v28);
        *(_DWORD *)v27 = 136315138;
        *(_QWORD *)(v27 + 4) = v29;
        __SC_log_send(5, (uint64_t)v16, v17, v26);
      }
    }
  }
  if (*a1)
    return 0;
  else
    return v31;
}

uint64_t _SCHelperExec(mach_port_t a1, int a2, const __CFData *a3, _DWORD *a4, _QWORD *a5)
{
  __CFString *v10;
  CFDataRef v11;
  const UInt8 *BytePtr;
  const UInt8 *v13;
  int Length;
  mach_error_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t result;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  const UInt8 *v43;
  CFDataRef v44;
  CFDataRef v45[2];

  v45[1] = *(CFDataRef *)MEMORY[0x1E0C80C00];
  v43 = 0;
  v44 = 0;
  v42 = 0;
  v45[0] = 0;
  if (_SCHelperExecCopyBacktrace_once != -1)
    dispatch_once(&_SCHelperExecCopyBacktrace_once, &__block_literal_global_8);
  if (_SCHelperExecCopyBacktrace_loggingEnabled != 1)
  {
    v11 = 0;
    if (a3)
      goto LABEL_7;
LABEL_10:
    BytePtr = 0;
    if (v11)
      goto LABEL_8;
    goto LABEL_11;
  }
  v10 = _SC_copyBacktrace();
  v11 = (CFDataRef)v10;
  if (v10)
  {
    _SCSerializeString(v10, v45, 0, 0);
    CFRelease(v11);
    v11 = v45[0];
  }
  if (!a3)
    goto LABEL_10;
LABEL_7:
  BytePtr = CFDataGetBytePtr(a3);
  LODWORD(a3) = CFDataGetLength(a3);
  if (v11)
  {
LABEL_8:
    v13 = CFDataGetBytePtr(v11);
    Length = CFDataGetLength(v11);
    v15 = helperexec(a1, a2, (uint64_t)BytePtr, (int)a3, (uint64_t)v13, Length, (int *)&v42, &v43, (_DWORD *)&v42 + 1);
    CFRelease(v11);
    goto LABEL_12;
  }
LABEL_11:
  v15 = helperexec(a1, a2, (uint64_t)BytePtr, (int)a3, 0, 0, (int *)&v42, &v43, (_DWORD *)&v42 + 1);
LABEL_12:
  if (v15)
  {
    if (v43)
      MEMORY[0x18D78D14C](*MEMORY[0x1E0C83DA0], v43, HIDWORD(v42));
    if (v15 != 268435459)
    {
      v16 = __log_SCPreferences();
      v17 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v16, (os_log_type_t)v17))
      {
        v18 = _os_log_pack_size();
        v26 = (char *)&v41 - ((MEMORY[0x1E0C80A78](v18, v19, v20, v21, v22, v23, v24, v25) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v27 = _os_log_pack_fill();
        v28 = mach_error_string(v15);
        *(_DWORD *)v27 = 136315138;
        *(_QWORD *)(v27 + 4) = v28;
        __SC_log_send(5, (uint64_t)v16, v17, v26);
      }
    }
    _SCErrorSet(v15);
    return 0;
  }
  else if (!v43 || (result = _SCUnserializeData(&v44, v43, HIDWORD(v42)), (_DWORD)result))
  {
    if (a4)
    {
      __SCPreferencesHandleInternalStatus((int *)&v42);
      *a4 = v42;
    }
    if (a5)
    {
      *a5 = v44;
    }
    else if (v44)
    {
      v30 = __log_SCPreferences();
      v31 = _SC_syslog_os_log_mapping(6);
      if (__SC_log_enabled(6, v30, (os_log_type_t)v31))
      {
        v32 = _os_log_pack_size();
        v40 = (char *)&v41 - ((MEMORY[0x1E0C80A78](v32, v33, v34, v35, v36, v37, v38, v39) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(6, (uint64_t)v30, v31, v40);
      }
      CFRelease(v44);
    }
    return 1;
  }
  return result;
}

void _SCHelperClose(mach_port_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  if (!_SCHelperExec(*a1, 9999, 0, 0, 0))
  {
    v2 = __log_SCPreferences();
    v3 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v2, (os_log_type_t)v3))
    {
      v4 = _os_log_pack_size();
      v12 = (char *)v13 - ((MEMORY[0x1E0C80A78](v4, v5, v6, v7, v8, v9, v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(6, (uint64_t)v2, v3, v12);
    }
  }
  if (*a1)
  {
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], *a1);
    *a1 = 0;
  }
}

uint64_t _SCSecKeychainCopySystemKeychain()
{
  _SCErrorSet(1003);
  return 0;
}

uint64_t _SCSecKeychainPasswordItemCopy()
{
  _SCErrorSet(1003);
  return 0;
}

uint64_t _SCSecKeychainPasswordItemExists()
{
  _SCErrorSet(1003);
  return 0;
}

uint64_t _SCSecKeychainPasswordItemRemove()
{
  _SCErrorSet(1003);
  return 0;
}

uint64_t _SCSecKeychainPasswordItemSet()
{
  _SCErrorSet(1003);
  return 0;
}

uint64_t _SCPreferencesSystemKeychainPasswordItemCopy()
{
  _SCErrorSet(1003);
  return 0;
}

uint64_t _SCPreferencesSystemKeychainPasswordItemExists()
{
  _SCErrorSet(1003);
  return 0;
}

uint64_t _SCPreferencesSystemKeychainPasswordItemRemove()
{
  _SCErrorSet(1003);
  return 0;
}

uint64_t _SCPreferencesSystemKeychainPasswordItemSet()
{
  _SCErrorSet(1003);
  return 0;
}

const void *SCNetworkSignatureCopyActiveIdentifierForAddress(uint64_t a1, uint64_t a2)
{
  const __CFArray *v2;
  const __CFArray *v3;
  const void *v4;
  CFStringRef v5;
  const CFArrayCallBacks *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const void *v10;
  CFTypeID TypeID;
  const __CFString *v12;
  const __CFDictionary *Value;
  const void *v14;
  const void *v15;
  CFTypeRef NetworkServiceEntity;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  NetworkServiceEntity = 0;
  cf[0] = 0;
  if (!a2 || *(_BYTE *)(a2 + 1) != 2 || *(_BYTE *)a2 != 16 || *(_DWORD *)(a2 + 4))
  {
    _SCErrorSet(1002);
    v2 = 0;
    v3 = 0;
LABEL_6:
    _SCErrorSet(1001);
    v4 = 0;
    v5 = 0;
    goto LABEL_7;
  }
  cf[0] = SCDynamicStoreKeyCreateNetworkGlobalEntity(0, CFSTR("State:"), CFSTR("IPv4"));
  v7 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  v2 = CFArrayCreate(0, cf, 1, MEMORY[0x1E0C9B378]);
  NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), CFSTR("[^/]+"), CFSTR("IPv4"));
  v3 = CFArrayCreate(0, &NetworkServiceEntity, 1, v7);
  v8 = SCDynamicStoreCopyMultiple(0, v2, v3);
  if (!v8)
    goto LABEL_6;
  v9 = v8;
  if (CFDictionaryGetCount(v8)
    && (v10 = CFDictionaryGetValue(v9, cf[0]), TypeID = CFDictionaryGetTypeID(), v10)
    && CFGetTypeID(v10) == TypeID
    && (v12 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v10, CFSTR("PrimaryService")), isA_CFString(v12)))
  {
    v5 = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), v12, CFSTR("IPv4"));
    Value = (const __CFDictionary *)CFDictionaryGetValue(v9, v5);
    if (isA_CFDictionary(Value) && CFDictionaryGetCount(Value))
    {
      v14 = CFDictionaryGetValue(Value, CFSTR("NetworkSignature"));
      v15 = isA_CFString(v14);
      v4 = v15;
      if (v15)
        CFRetain(v15);
      else
        _SCErrorSet(1001);
      goto LABEL_29;
    }
  }
  else
  {
    v5 = 0;
  }
  _SCErrorSet(1001);
  v4 = 0;
LABEL_29:
  CFRelease(v9);
LABEL_7:
  if (cf[0])
    CFRelease(cf[0]);
  if (v5)
    CFRelease(v5);
  if (v2)
    CFRelease(v2);
  if (v3)
    CFRelease(v3);
  if (NetworkServiceEntity)
    CFRelease(NetworkServiceEntity);
  return v4;
}

__CFArray *SCNetworkSignatureCopyActiveIdentifiers()
{
  const CFArrayCallBacks *v0;
  __CFArray *Mutable;
  const __CFArray *v2;
  CFStringRef NetworkServiceEntity;
  CFStringRef v4;
  const __CFDictionary *v5;
  const __CFDictionary *MutableCopy;
  const __CFDictionary *v7;
  const void *Value;
  CFTypeID TypeID;
  const __CFArray *v10;
  CFTypeID v11;
  CFIndex Count;
  __CFArray *v13;
  CFIndex v14;
  const __CFString *ValueAtIndex;
  CFTypeID v16;
  uint64_t v17;
  char v18;
  char v19;
  CFStringRef v20;
  const __CFDictionary *v21;
  CFTypeID v22;
  const void *v23;
  CFTypeID v24;
  CFIndex v25;
  const void **v26;
  CFIndex v27;
  uint64_t v28;
  __CFArray *v29;
  uint64_t i;
  const __CFDictionary *v31;
  CFTypeID v32;
  const void *v33;
  CFTypeID v34;
  const __CFDictionary *cf;
  const __CFArray *v37;
  const __CFArray *v38;
  CFIndex v39;
  const __CFString *v40;
  CFIndex range;
  const __CFString *v42;
  void *values;
  _QWORD v44[2];
  void *v45[2];
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  CFRange v51;
  CFRange v52;

  v50 = *MEMORY[0x1E0C80C00];
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  *(_OWORD *)v45 = 0u;
  v0 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  values = (void *)SCDynamicStoreKeyCreateNetworkGlobalEntity(0, CFSTR("Setup:"), CFSTR("IPv4"));
  v2 = CFArrayCreate(0, (const void **)&values, 1, v0);
  NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), CFSTR("[^/]+"), CFSTR("IPv4"));
  CFArrayAppendValue(Mutable, NetworkServiceEntity);
  v4 = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), CFSTR("[^/]+"), CFSTR("IPv6"));
  CFArrayAppendValue(Mutable, v4);
  v5 = SCDynamicStoreCopyMultiple(0, v2, Mutable);
  if (!v5)
  {
    v26 = 0;
    v13 = 0;
    goto LABEL_42;
  }
  MutableCopy = v5;
  if (CFDictionaryGetCount(v5))
  {
    v40 = NetworkServiceEntity;
    v37 = v2;
    v7 = MutableCopy;
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, MutableCopy);
    CFDictionaryRemoveValue(MutableCopy, values);
    cf = v7;
    Value = CFDictionaryGetValue(v7, values);
    TypeID = CFDictionaryGetTypeID();
    v42 = v4;
    if (Value
      && CFGetTypeID(Value) == TypeID
      && (v10 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("ServiceOrder")),
          v11 = CFArrayGetTypeID(),
          v10)
      && CFGetTypeID(v10) == v11)
    {
      Count = CFArrayGetCount(v10);
      v13 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      v39 = Count;
      if (Count >= 1)
      {
        v14 = 0;
        range = 0;
        v38 = v10;
        do
        {
          v44[0] = CFSTR("IPv4");
          v44[1] = CFSTR("IPv6");
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v14);
          v16 = CFStringGetTypeID();
          if (ValueAtIndex && CFGetTypeID(ValueAtIndex) == v16)
          {
            v17 = 0;
            v18 = 1;
            do
            {
              v19 = v18;
              v20 = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), ValueAtIndex, (CFStringRef)v44[v17]);
              v21 = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, v20);
              v22 = CFDictionaryGetTypeID();
              if (v21 && CFGetTypeID(v21) == v22)
              {
                v23 = CFDictionaryGetValue(v21, CFSTR("NetworkSignature"));
                v24 = CFStringGetTypeID();
                if (v23)
                {
                  if (CFGetTypeID(v23) == v24)
                  {
                    v51.location = 0;
                    v51.length = range;
                    if (!CFArrayContainsValue(v13, v51, v23))
                    {
                      CFArrayAppendValue(v13, v23);
                      ++range;
                    }
                  }
                }
                CFDictionaryRemoveValue(MutableCopy, v20);
              }
              CFRelease(v20);
              v18 = 0;
              v17 = 1;
            }
            while ((v19 & 1) != 0);
          }
          ++v14;
          v4 = v42;
          v10 = v38;
        }
        while (v14 != v39);
        v25 = range;
LABEL_25:
        v27 = CFDictionaryGetCount(MutableCopy);
        NetworkServiceEntity = v40;
        if (!v27)
        {
          v26 = 0;
          goto LABEL_40;
        }
        v28 = v27;
        if (v27 < 11)
        {
          v26 = (const void **)v45;
          CFDictionaryGetKeysAndValues(MutableCopy, 0, (const void **)v45);
          if (v28 < 1)
            goto LABEL_40;
        }
        else
        {
          v26 = (const void **)malloc_type_malloc(8 * v27, 0xC0040B8AA526DuLL);
          CFDictionaryGetKeysAndValues(MutableCopy, 0, v26);
        }
        v29 = Mutable;
        for (i = 0; i != v28; ++i)
        {
          v31 = (const __CFDictionary *)v26[i];
          v32 = CFDictionaryGetTypeID();
          if (v31)
          {
            if (CFGetTypeID(v31) == v32)
            {
              v33 = CFDictionaryGetValue(v31, CFSTR("NetworkSignature"));
              v34 = CFStringGetTypeID();
              if (v33)
              {
                if (CFGetTypeID(v33) == v34)
                {
                  v52.location = 0;
                  v52.length = v25;
                  if (!CFArrayContainsValue(v13, v52, v33))
                  {
                    CFArrayAppendValue(v13, v33);
                    ++v25;
                  }
                }
              }
            }
          }
        }
        Mutable = v29;
        NetworkServiceEntity = v40;
        v4 = v42;
LABEL_40:
        CFRelease(cf);
        v2 = v37;
        if (!MutableCopy)
          goto LABEL_42;
        goto LABEL_41;
      }
    }
    else
    {
      v13 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    }
    v25 = 0;
    goto LABEL_25;
  }
  v26 = 0;
  v13 = 0;
LABEL_41:
  CFRelease(MutableCopy);
LABEL_42:
  if (values)
    CFRelease(values);
  if (NetworkServiceEntity)
    CFRelease(NetworkServiceEntity);
  if (v4)
    CFRelease(v4);
  if (v26 && v26 != (const void **)v45)
    free(v26);
  if (v2)
    CFRelease(v2);
  if (Mutable)
    CFRelease(Mutable);
  if (!v13)
    goto LABEL_58;
  if (!CFArrayGetCount(v13))
  {
    CFRelease(v13);
LABEL_58:
    _SCErrorSet(1001);
    return 0;
  }
  return v13;
}

CFTypeRef SCNetworkSignatureCopyIdentifierForConnectedSocket()
{
  CFStringRef v0;
  const void **v1;
  CFStringRef v2;
  CFTypeRef v3;
  const __CFDictionary *v4;
  int v5;
  int v7;
  const void *v8;
  const CFStringRef *v9;
  CFStringRef v10;
  CFStringRef *v11;
  const __CFArray *v12;
  CFIndex Count;
  uint64_t v14;
  uint64_t v15;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  const void *v18;
  CFTypeID v19;
  const void *v20;
  CFTypeID v21;
  const void *v22;
  CFTypeID v23;
  const __CFArray *v24;
  CFTypeID v25;
  void *keys[2];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  void *values[8];
  CFRange v32;

  values[6] = *(void **)MEMORY[0x1E0C80C00];
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  *(_OWORD *)keys = 0u;
  if (copyconninfo())
    goto LABEL_2;
  if ((MEMORY[0] & 2) == 0)
  {
    v4 = 0;
    v3 = 0;
    v2 = 0;
    v1 = 0;
    v5 = 1001;
    freeconninfo();
    goto LABEL_5;
  }
  if (MEMORY[8])
  {
    v7 = *(unsigned __int8 *)(MEMORY[8] + 1);
    if (v7 == 30)
    {
      v8 = (const void *)(MEMORY[8] + 8);
      v9 = &kSCPropNetIPv6Addresses;
    }
    else
    {
      if (v7 != 2)
      {
LABEL_2:
        v0 = 0;
        v1 = 0;
        v2 = 0;
        v3 = 0;
        v4 = 0;
        v5 = 1002;
        goto LABEL_3;
      }
      v8 = (const void *)(MEMORY[8] + 4);
      v9 = &kSCPropNetIPv4Addresses;
    }
    v10 = *v9;
    v11 = (CFStringRef *)&kSCEntNetIPv6;
    if (v7 == 2)
      v11 = (CFStringRef *)&kSCEntNetIPv4;
    values[0] = (void *)SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), CFSTR("[^/]+"), *v11);
    v12 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x1E0C9B378]);
    CFRelease(values[0]);
    v4 = SCDynamicStoreCopyMultiple(0, 0, v12);
    CFRelease(v12);
    if (v4 && inet_ntop(v7, v8, (char *)values, 0x2Eu))
    {
      v2 = CFStringCreateWithCString(0, (const char *)values, 0x600u);
      if (v2)
      {
        if (MEMORY[4] && if_indextoname(MEMORY[4], (char *)values))
          v0 = CFStringCreateWithCString(0, (const char *)values, 0x600u);
        else
          v0 = 0;
        Count = CFDictionaryGetCount(v4);
        v14 = Count;
        if (Count >= 11)
        {
          v1 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
          CFDictionaryGetKeysAndValues(v4, v1, 0);
          goto LABEL_39;
        }
        v1 = (const void **)keys;
        CFDictionaryGetKeysAndValues(v4, (const void **)keys, 0);
        if (v14 >= 1)
        {
LABEL_39:
          v15 = 0;
          while (1)
          {
            Value = (const __CFDictionary *)CFDictionaryGetValue(v4, v1[v15]);
            TypeID = CFDictionaryGetTypeID();
            if (Value)
            {
              if (CFGetTypeID(Value) == TypeID)
              {
                v18 = CFDictionaryGetValue(Value, CFSTR("NetworkSignature"));
                v19 = CFStringGetTypeID();
                if (v18)
                {
                  if (CFGetTypeID(v18) == v19)
                  {
                    if (!v0
                      || (v20 = CFDictionaryGetValue(Value, CFSTR("InterfaceName")), v21 = CFStringGetTypeID(), v20)
                      && CFGetTypeID(v20) == v21
                      && CFEqual(v20, v0)
                      && ((v22 = CFDictionaryGetValue(Value, CFSTR("ConfirmedInterfaceName")),
                           v23 = CFStringGetTypeID(),
                           !v22)
                       || CFGetTypeID(v22) != v23
                       || CFEqual(v22, v0)))
                    {
                      v24 = (const __CFArray *)CFDictionaryGetValue(Value, v10);
                      v25 = CFArrayGetTypeID();
                      if (v24)
                      {
                        if (CFGetTypeID(v24) == v25)
                        {
                          v32.length = CFArrayGetCount(v24);
                          v32.location = 0;
                          if (CFArrayContainsValue(v24, v32, v2))
                            break;
                        }
                      }
                    }
                  }
                }
              }
            }
            ++v15;
            v5 = 1001;
            if (v14 == v15)
            {
              v3 = 0;
              goto LABEL_3;
            }
          }
          v3 = CFRetain(v18);
          v5 = 0;
          goto LABEL_3;
        }
      }
      else
      {
        v0 = 0;
        v1 = 0;
      }
    }
    else
    {
      v0 = 0;
      v1 = 0;
      v2 = 0;
    }
    v3 = 0;
  }
  else
  {
    v0 = 0;
    v1 = 0;
    v2 = 0;
    v3 = 0;
    v4 = 0;
  }
  v5 = 1001;
LABEL_3:
  if (v0)
    CFRelease(v0);
LABEL_5:
  if (v2)
    CFRelease(v2);
  if (v1 && v1 != (const void **)keys)
    free(v1);
  if (v4)
    CFRelease(v4);
  if (v5)
    _SCErrorSet(v5);
  return v3;
}

Boolean CNSetSupportedSSIDs(CFArrayRef ssidArray)
{
  uint64_t (*v2)(CFArrayRef);

  v2 = (uint64_t (*)(CFArrayRef))CNSetSupportedSSIDs_dyfunc;
  if (CNSetSupportedSSIDs_dyfunc)
    return v2(ssidArray);
  if (__loadCaptiveNetwork_once != -1)
    dispatch_once(&__loadCaptiveNetwork_once, &__block_literal_global_16);
  if (__loadCaptiveNetwork_image)
  {
    v2 = (uint64_t (*)(CFArrayRef))dlsym((void *)__loadCaptiveNetwork_image, "__CNSetSupportedSSIDs");
    CNSetSupportedSSIDs_dyfunc = v2;
    if (v2)
      return v2(ssidArray);
  }
  else
  {
    v2 = (uint64_t (*)(CFArrayRef))CNSetSupportedSSIDs_dyfunc;
    if (CNSetSupportedSSIDs_dyfunc)
      return v2(ssidArray);
  }
  return 0;
}

Boolean CNMarkPortalOnline(CFStringRef interfaceName)
{
  uint64_t (*v2)(CFStringRef);

  v2 = (uint64_t (*)(CFStringRef))CNMarkPortalOnline_dyfunc;
  if (CNMarkPortalOnline_dyfunc)
    return v2(interfaceName);
  if (__loadCaptiveNetwork_once != -1)
    dispatch_once(&__loadCaptiveNetwork_once, &__block_literal_global_16);
  if (__loadCaptiveNetwork_image)
  {
    v2 = (uint64_t (*)(CFStringRef))dlsym((void *)__loadCaptiveNetwork_image, "__CNMarkPortalOnline");
    CNMarkPortalOnline_dyfunc = v2;
    if (v2)
      return v2(interfaceName);
  }
  else
  {
    v2 = (uint64_t (*)(CFStringRef))CNMarkPortalOnline_dyfunc;
    if (CNMarkPortalOnline_dyfunc)
      return v2(interfaceName);
  }
  return 0;
}

Boolean CNMarkPortalOffline(CFStringRef interfaceName)
{
  uint64_t (*v2)(CFStringRef);

  v2 = (uint64_t (*)(CFStringRef))CNMarkPortalOffline_dyfunc;
  if (CNMarkPortalOffline_dyfunc)
    return v2(interfaceName);
  if (__loadCaptiveNetwork_once != -1)
    dispatch_once(&__loadCaptiveNetwork_once, &__block_literal_global_16);
  if (__loadCaptiveNetwork_image)
  {
    v2 = (uint64_t (*)(CFStringRef))dlsym((void *)__loadCaptiveNetwork_image, "__CNMarkPortalOffline");
    CNMarkPortalOffline_dyfunc = v2;
    if (v2)
      return v2(interfaceName);
  }
  else
  {
    v2 = (uint64_t (*)(CFStringRef))CNMarkPortalOffline_dyfunc;
    if (CNMarkPortalOffline_dyfunc)
      return v2(interfaceName);
  }
  return 0;
}

CFArrayRef CNCopySupportedInterfaces(void)
{
  uint64_t (*v0)(void);

  v0 = (uint64_t (*)(void))CNCopySupportedInterfaces_dyfunc;
  if (CNCopySupportedInterfaces_dyfunc)
    return (CFArrayRef)v0();
  if (__loadCaptiveNetwork_once != -1)
    dispatch_once(&__loadCaptiveNetwork_once, &__block_literal_global_16);
  if (__loadCaptiveNetwork_image)
  {
    v0 = (uint64_t (*)(void))dlsym((void *)__loadCaptiveNetwork_image, "__CNCopySupportedInterfaces");
    CNCopySupportedInterfaces_dyfunc = v0;
    if (v0)
      return (CFArrayRef)v0();
  }
  else
  {
    v0 = (uint64_t (*)(void))CNCopySupportedInterfaces_dyfunc;
    if (CNCopySupportedInterfaces_dyfunc)
      return (CFArrayRef)v0();
  }
  return 0;
}

CFDictionaryRef CNCopyCurrentNetworkInfo(CFStringRef interfaceName)
{
  uint64_t (*v2)(CFStringRef);

  v2 = (uint64_t (*)(CFStringRef))CNCopyCurrentNetworkInfo_dyfunc;
  if (CNCopyCurrentNetworkInfo_dyfunc)
    return (CFDictionaryRef)v2(interfaceName);
  if (__loadCaptiveNetwork_once != -1)
    dispatch_once(&__loadCaptiveNetwork_once, &__block_literal_global_16);
  if (__loadCaptiveNetwork_image)
  {
    v2 = (uint64_t (*)(CFStringRef))dlsym((void *)__loadCaptiveNetwork_image, "__CNCopyCurrentNetworkInfo");
    CNCopyCurrentNetworkInfo_dyfunc = v2;
    if (v2)
      return (CFDictionaryRef)v2(interfaceName);
  }
  else
  {
    v2 = (uint64_t (*)(CFStringRef))CNCopyCurrentNetworkInfo_dyfunc;
    if (CNCopyCurrentNetworkInfo_dyfunc)
      return (CFDictionaryRef)v2(interfaceName);
  }
  return 0;
}

void *____loadCaptiveNetwork_block_invoke()
{
  void *result;

  result = _SC_dlopen("/System/Library/PrivateFrameworks/CaptiveNetwork.framework/CaptiveNetwork");
  __loadCaptiveNetwork_image = (uint64_t)result;
  return result;
}

uint64_t VPNConfigurationCreate()
{
  return 0;
}

uint64_t VPNConfigurationCreateWithOptions()
{
  return 0;
}

uint64_t VPNConfigurationGetTunnelType()
{
  return 1;
}

uint64_t VPNConfigurationCopyAll()
{
  return 0;
}

uint64_t VPNConfigurationCopy()
{
  return 0;
}

uint64_t VPNConfigurationSet()
{
  return 0;
}

uint64_t VPNConfigurationRemove()
{
  return 0;
}

uint64_t VPNConfigurationSetName()
{
  return 0;
}

uint64_t VPNConfigurationGetName()
{
  return 0;
}

uint64_t VPNConfigurationSetEnabled()
{
  return 0;
}

uint64_t VPNConfigurationGetEnabled()
{
  return 0;
}

uint64_t VPNConfigurationEnableVPNType()
{
  return 1;
}

uint64_t VPNConfigurationIsVPNTypeEnabled()
{
  return 1;
}

uint64_t VPNConfigurationCopyVendorData()
{
  return 0;
}

uint64_t VPNConfigurationSetVendorData()
{
  return 0;
}

uint64_t VPNCopyLastError()
{
  return 0;
}

uint64_t VPNConfigurationSetCallback()
{
  return 0;
}

uint64_t VPNConfigurationSetMessageCallback()
{
  return 0;
}

uint64_t VPNConfigurationScheduleWithRunLoop()
{
  return 0;
}

uint64_t VPNConfigurationUnscheduleFromRunLoop()
{
  return 0;
}

uint64_t VPNConfigurationConnectionStart()
{
  return 0;
}

uint64_t VPNConfigurationConnectionStop()
{
  return 0;
}

uint64_t VPNConfigurationGetStatus()
{
  return 0xFFFFFFFFLL;
}

uint64_t VPNConfigurationSendMessage()
{
  return 0;
}

uint64_t VPNConfigurationCopyIdentities()
{
  return 0;
}

uint64_t VPNConfigurationCopyCertificate()
{
  return 0;
}

uint64_t VPNConfigurationCopyLastConnectionError()
{
  return 0;
}

uint64_t VPNConfigurationSetPersistentData()
{
  return 0;
}

uint64_t VPNConfigurationCopyPersistentData()
{
  return 0;
}

uint64_t VPNConfigurationValidateCertificate()
{
  return 3;
}

uint64_t VPNConfigurationCopyAppRuleIDs()
{
  return 0;
}

uint64_t VPNConfigurationCopyAppRule()
{
  return 0;
}

uint64_t VPNConfigurationRemoveAppRule()
{
  return 0;
}

uint64_t VPNConfigurationSetAppRule()
{
  return 0;
}

uint64_t VPNTunnelSetStatus(uint64_t (**a1)(void))
{
  return (*a1)();
}

uint64_t VPNTunnelSetPersistentData(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 8))();
}

uint64_t VPNTunnelFetchCredentialComplete(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 24))();
}

uint64_t VPNTunnelCopyPersistentData(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

uint64_t VPNTunnelAuthenticate(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

uint64_t VPNTunnelDisplayBanner(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 40))();
}

uint64_t VPNTunnelSetConfigurationEntities(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 48))();
}

uint64_t VPNTunnelSetTunnelSocket(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 56))();
}

uint64_t VPNTunnelCryptoEnable(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 64))();
}

uint64_t VPNTunnelCryptoDisable(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 72))();
}

uint64_t VPNTunnelCryptoAddConfigurations(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 80))();
}

uint64_t VPNTunnelCryptoRemoveConfigurations(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 88))();
}

uint64_t VPNTunnelCryptoGenerateIndex(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 96))();
}

uint64_t VPNTunnelCryptoStopDataTraffic(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 104))();
}

uint64_t VPNTunnelCryptoStartDataTraffic(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 112))();
}

uint64_t VPNTunnelClearConfiguration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 120))();
}

uint64_t VPNTunnelIPCSendMessage(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 128))();
}

uint64_t VPNTunnelUpdatePlugin(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 136))();
}

uint64_t VPNTunnelEnvironmentEventComplete(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 144))();
}

uint64_t VPNTunnelCopySocketInfo(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 160))();
}

uint64_t VPNTunnelIncrementDataSent(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 192))();
}

uint64_t VPNTunnelIncrementDataReceived(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 200))();
}

void VPNTunnelLog(uint64_t a1, uint64_t a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFStringRef v11;

  if (a3)
  {
    v11 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a3, &a9);
    (*(void (**)(uint64_t, uint64_t, CFStringRef))(a1 + 152))(a1, a2, v11);
    CFRelease(v11);
  }
}

uint64_t VPNTunnelCopySavedConfiguration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 168))();
}

uint64_t VPNTunnelCopySavedVendorData(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 176))();
}

uint64_t VPNTunnelCopySavedConfigurationName(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 184))();
}

void add_configured_interface(const __CFString *a1, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t Private;
  const __SCNetworkInterface *v6;
  const __CFArray *Value;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v10;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID v13;
  CFArrayRef v14;
  const __CFDictionary *v15;
  CFTypeID v16;
  const __CFString *v17;
  CFTypeID v18;
  CFTypeID v19;
  const void *v20;
  CFArrayRef theArray[2];

  theArray[1] = *(CFArrayRef *)MEMORY[0x1E0C80C00];
  theArray[0] = 0;
  Private = _SCBridgeInterfaceCreatePrivate(0, a1);
  if (!Private)
    add_configured_interface_cold_1();
  v6 = (const __SCNetworkInterface *)Private;
  *(_QWORD *)(Private + 80) = CFRetain(*(CFTypeRef *)(a3 + 16));
  Value = (const __CFArray *)CFDictionaryGetValue(a2, CFSTR("Interfaces"));
  TypeID = CFArrayGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) == TypeID)
    {
      Count = CFArrayGetCount(Value);
      if (Count >= 1)
      {
        v10 = Count;
        for (i = 0; i != v10; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(Value, i);
          v13 = CFStringGetTypeID();
          if (ValueAtIndex && CFGetTypeID(ValueAtIndex) == v13)
            add_interface(theArray, ValueAtIndex, *(const __SCPreferences **)(a3 + 8));
        }
        v14 = theArray[0];
        if (theArray[0])
        {
          __SCBridgeInterfaceSetMemberInterfaces((uint64_t)v6, theArray[0]);
          CFRelease(v14);
        }
      }
    }
  }
  v15 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("Options"));
  v16 = CFDictionaryGetTypeID();
  if (v15)
  {
    if (CFGetTypeID(v15) == v16)
    {
      SCBridgeInterfaceSetOptions(v6, v15);
      v15 = (const __CFDictionary *)CFDictionaryGetValue(v15, CFSTR("__AUTO__"));
    }
    else
    {
      v15 = 0;
    }
  }
  v17 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("UserDefinedName"));
  v18 = CFStringGetTypeID();
  if (v17 && CFGetTypeID(v17) == v18)
  {
    SCBridgeInterfaceSetLocalizedDisplayName((uint64_t)v6, v17);
  }
  else
  {
    v19 = CFStringGetTypeID();
    if (v15)
    {
      if (CFGetTypeID(v15) == v19)
      {
        *((_QWORD *)v6 + 6) = v15;
        v20 = (const void *)*((_QWORD *)v6 + 7);
        if (v20)
        {
          CFRelease(v20);
          *((_QWORD *)v6 + 7) = 0;
        }
      }
    }
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)a3, v6);
  CFRelease(v6);
}

void __SCBridgeInterfaceListCollectMembers(const __CFArray *a1, __CFSet *a2, int a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const __SCNetworkInterface *ValueAtIndex;
  const __SCNetworkInterface *v10;
  const __CFArray *MemberInterfaces;
  const __CFArray *v12;
  CFIndex v13;
  CFIndex v14;
  CFIndex j;
  const void *v16;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v7 = Count;
    for (i = 0; i != v7; ++i)
    {
      ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(a1, i);
      v10 = ValueAtIndex;
      if (!a3 || !SCBridgeInterfaceGetAllowConfiguredMembers(ValueAtIndex))
      {
        MemberInterfaces = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces(v10);
        if (MemberInterfaces)
        {
          v12 = MemberInterfaces;
          v13 = CFArrayGetCount(MemberInterfaces);
          if (v13 >= 1)
          {
            v14 = v13;
            for (j = 0; j != v14; ++j)
            {
              v16 = CFArrayGetValueAtIndex(v12, j);
              CFSetAddValue(a2, v16);
            }
          }
        }
      }
    }
  }
}

uint64_t SCBridgeInterfaceGetAllowConfiguredMembers(_QWORD *a1)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  const __CFDictionary *v4;
  const __CFBoolean *Value;
  CFTypeID v6;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (a1
    && CFGetTypeID(a1) == TypeID
    && (InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a1),
        CFEqual(InterfaceType, CFSTR("Bridge"))))
  {
    v4 = (const __CFDictionary *)a1[45];
    if (v4)
    {
      Value = (const __CFBoolean *)CFDictionaryGetValue(v4, CFSTR("AllowConfiguredMembers"));
      v6 = CFBooleanGetTypeID();
      if (Value && CFGetTypeID(Value) == v6)
        return CFBooleanGetValue(Value);
    }
    else
    {
      CFBooleanGetTypeID();
    }
  }
  else
  {
    _SCErrorSet(1002);
  }
  return 0;
}

uint64_t SCBridgeInterfaceGetMemberInterfaces(const __SCNetworkInterface *a1)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (a1)
  {
    if (CFGetTypeID(a1) == TypeID)
    {
      InterfaceType = SCNetworkInterfaceGetInterfaceType(a1);
      if (CFEqual(InterfaceType, CFSTR("Bridge")))
        return *((_QWORD *)a1 + 44);
    }
  }
  _SCErrorSet(1002);
  return 0;
}

__CFArray *SCBridgeInterfaceCopyAvailableMemberInterfaces(const __SCPreferences *a1)
{
  __CFArray *Mutable;
  __CFSet *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;
  const __SCNetworkInterface *ValueAtIndex;
  SCNetworkInterfaceRef PhysicalInterface;
  __CFArray *v13;
  const __CFArray *v14;
  CFIndex v15;
  CFIndex v16;
  CFIndex j;
  _BYTE *v18;
  const void *v19;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v3 = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  v4 = (const __CFArray *)SCBridgeInterfaceCopyAll(a1);
  if (v4)
  {
    v5 = v4;
    __SCBridgeInterfaceListCollectMembers(v4, v3, 0);
    CFRelease(v5);
  }
  v6 = SCVLANInterfaceCopyAll(a1);
  if (v6)
  {
    v7 = v6;
    Count = CFArrayGetCount(v6);
    if (Count >= 1)
    {
      v9 = Count;
      for (i = 0; i != v9; ++i)
      {
        ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v7, i);
        PhysicalInterface = SCVLANInterfaceGetPhysicalInterface(ValueAtIndex);
        CFSetAddValue(v3, PhysicalInterface);
      }
    }
    CFRelease(v7);
  }
  v13 = __SCNetworkInterfaceCopyAll_IONetworkInterface(0);
  if (v13)
  {
    v14 = v13;
    v15 = CFArrayGetCount(v13);
    if (v15 >= 1)
    {
      v16 = v15;
      for (j = 0; j != v16; ++j)
      {
        v18 = CFArrayGetValueAtIndex(v14, j);
        if (v18[344])
        {
          v19 = v18;
          if (!CFSetContainsValue(v3, v18))
            CFArrayAppendValue(Mutable, v19);
        }
      }
    }
    CFRelease(v14);
  }
  CFRelease(v3);
  return Mutable;
}

__CFArray *_SCBridgeInterfaceCopyActive()
{
  int v0;
  int v1;
  __CFArray *Mutable;
  ifaddrs *v3;
  unsigned __int8 *ifa_data;
  const char *ifa_name;
  size_t v6;
  _DWORD *v7;
  _DWORD *v8;
  unsigned int v9;
  size_t v10;
  const __CFString *v11;
  const void *Private;
  uint64_t v13;
  unint64_t v14;
  CFStringRef v15;
  const __CFArray *v16;
  int *v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  int *v30;
  char *v31;
  int *v32;
  int *v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  char *v48;
  int *v49;
  char *v50;
  uint64_t v51;
  __CFArray *v52;
  CFMutableArrayRef v53;
  ifaddrs *v54;
  __int128 v55;
  __int128 v56;
  _DWORD *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v54 = 0;
  if (getifaddrs(&v54) == -1)
  {
    v17 = __error();
    _SCErrorSet(*v17);
    v18 = __log_SCNetworkConfiguration();
    v19 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v18, (os_log_type_t)v19))
    {
      v20 = _os_log_pack_size();
      v28 = (char *)&v51 - ((MEMORY[0x1E0C80A78](v20, v21, v22, v23, v24, v25, v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v29 = _os_log_pack_fill();
      v30 = __error();
      v31 = strerror(*v30);
      *(_DWORD *)v29 = 136315138;
      *(_QWORD *)(v29 + 4) = v31;
      __SC_log_send(5, (uint64_t)v18, v19, v28);
    }
    return 0;
  }
  v0 = inet_dgram_socket();
  if (v0 == -1)
  {
    v32 = __error();
    _SCErrorSet(*v32);
    Mutable = 0;
    goto LABEL_33;
  }
  v1 = v0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v3 = v54;
  if (!v54)
    goto LABEL_28;
  while (1)
  {
    v53 = 0;
    ifa_data = (unsigned __int8 *)v3->ifa_data;
    if (ifa_data)
    {
      if (v3->ifa_addr->sa_family == 18 && *ifa_data == 209)
      {
        ifa_name = v3->ifa_name;
        v6 = strlen(ifa_name);
        if (v6 < 4
          || (ifa_name[v6 - 1] - 48) > 9
          || (ifa_name[v6 - 2] - 48) > 9
          || (ifa_name[v6 - 3] - 48) >= 0xA)
        {
          v57 = 0;
          v55 = 0u;
          v56 = 0u;
          __strlcpy_chk();
          *(_QWORD *)&v56 = 6;
          v7 = malloc_type_malloc(0x50CuLL, 0xFC8CFC7FuLL);
          if (v7)
          {
            v8 = v7;
            v9 = 1280;
            v10 = 1292;
            while (1)
            {
              bzero(v8, v10);
              *v8 = v9;
              *(_QWORD *)(v8 + 1) = v8 + 3;
              *((_QWORD *)&v56 + 1) = 12;
              v57 = v8;
              if (ioctl(v1, 0xC028697BuLL, &v55) == -1)
              {
                free(v8);
                goto LABEL_18;
              }
              if ((unint64_t)*v8 + 80 < v9)
                break;
              v9 *= 2;
              v10 = v9 | 0xC;
              v8 = reallocf(v8, v10);
              if (!v8)
                goto LABEL_18;
            }
            v11 = CFStringCreateWithCString(0, v3->ifa_name, 0x600u);
            Private = (const void *)_SCBridgeInterfaceCreatePrivate(0, v11);
            CFRelease(v11);
            if (*v8 >= 0x50u)
            {
              v52 = Mutable;
              v13 = 0;
              v14 = 0;
              do
              {
                v15 = CFStringCreateWithCString(0, (const char *)(*(_QWORD *)(v8 + 1) + v13), 0x600u);
                add_interface(&v53, v15, 0);
                CFRelease(v15);
                ++v14;
                v13 += 80;
              }
              while (v14 < *v8 / 0x50uLL);
              v16 = v53;
              free(v8);
              Mutable = v52;
              if (v16)
              {
                __SCBridgeInterfaceSetMemberInterfaces((uint64_t)Private, v16);
                CFRelease(v16);
              }
            }
            else
            {
              free(v8);
            }
            CFArrayAppendValue(Mutable, Private);
            CFRelease(Private);
            goto LABEL_27;
          }
LABEL_18:
          if (*__error() != 16)
            break;
        }
      }
    }
LABEL_27:
    v3 = v3->ifa_next;
    if (!v3)
      goto LABEL_28;
  }
  v34 = __error();
  _SCErrorSet(*v34);
  v35 = __log_SCNetworkConfiguration();
  v36 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v35, (os_log_type_t)v36))
  {
    v38 = _os_log_pack_size();
    v46 = (char *)&v51 - ((MEMORY[0x1E0C80A78](v38, v39, v40, v41, v42, v43, v44, v45) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v47 = _os_log_pack_fill();
    v48 = v3->ifa_name;
    v49 = __error();
    v50 = strerror(*v49);
    *(_DWORD *)v47 = 136315394;
    *(_QWORD *)(v47 + 4) = v48;
    *(_WORD *)(v47 + 12) = 2080;
    *(_QWORD *)(v47 + 14) = v50;
    __SC_log_send(5, (uint64_t)v35, v36, v46);
  }
  CFRelease(Mutable);
  Mutable = 0;
LABEL_28:
  close(v1);
LABEL_33:
  MEMORY[0x18D78C7F8](v54);
  return Mutable;
}

uint64_t inet_dgram_socket()
{
  uint64_t v0;
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  int *v13;
  char *v14;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v0 = socket(2, 2, 0);
  if ((_DWORD)v0 == -1)
  {
    v1 = __log_SCNetworkConfiguration();
    v2 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v1, (os_log_type_t)v2))
    {
      v3 = _os_log_pack_size();
      v11 = (char *)v16 - ((MEMORY[0x1E0C80A78](v3, v4, v5, v6, v7, v8, v9, v10) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v12 = _os_log_pack_fill();
      v13 = __error();
      v14 = strerror(*v13);
      *(_DWORD *)v12 = 136315138;
      *(_QWORD *)(v12 + 4) = v14;
      __SC_log_send(3, (uint64_t)v1, v2, v11);
    }
  }
  return v0;
}

void add_interface(CFMutableArrayRef *a1, const void *a2, const __SCPreferences *cf)
{
  const void *v6;

  if (*a1)
  {
    if (!cf)
    {
LABEL_6:
      v6 = (const void *)_SCNetworkInterfaceCreateWithBSDName(0, a2, 0);
      if (!v6)
        return;
      goto LABEL_7;
    }
  }
  else
  {
    *a1 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    if (!cf)
      goto LABEL_6;
  }
  v6 = (const void *)__SCNetworkInterfaceCreateWithNIPreferencesUsingBSDName(0, cf, a2);
  if (!v6)
    goto LABEL_6;
LABEL_7:
  CFArrayAppendValue(*a1, v6);
  CFRelease(v6);
}

uint64_t __SCBridgeInterfaceSetMemberInterfaces(uint64_t a1, CFArrayRef theArray)
{
  CFIndex Count;
  const __CFString *v5;
  CFDictionaryRef Value;
  CFTypeID TypeID;
  __CFArray *v8;
  CFIndex j;
  const __SCNetworkInterface *v10;
  CFStringRef BSDName;
  __CFDictionary *MutableCopy;
  uint64_t v13;
  __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeRef Copy;

  if (theArray)
    Count = CFArrayGetCount(theArray);
  else
    Count = 0;
  if (!*(_QWORD *)(a1 + 80))
  {
    v13 = 1;
LABEL_16:
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
        Copy = __SCNetworkInterfaceCreateCopy(0, (uint64_t)ValueAtIndex, *(const void **)(a1 + 80), *(const void **)(a1 + 96));
        CFArrayAppendValue(Mutable, Copy);
        CFRelease(Copy);
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 352));
    *(_QWORD *)(a1 + 352) = Mutable;
    return v13;
  }
  v5 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("Bridge"), *(_QWORD *)(a1 + 112));
  Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 80), v5);
  TypeID = CFDictionaryGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID)
  {
    CFRelease(v5);
    _SCErrorSet(1001);
    return 0;
  }
  v8 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (Count >= 1)
  {
    for (j = 0; j != Count; ++j)
    {
      v10 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(theArray, j);
      BSDName = SCNetworkInterfaceGetBSDName(v10);
      CFArrayAppendValue(v8, BSDName);
    }
  }
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
  CFDictionarySetValue(MutableCopy, CFSTR("Interfaces"), v8);
  CFRelease(v8);
  if (CFEqual(Value, MutableCopy))
    v13 = 1;
  else
    v13 = SCPreferencesPathSetValue(*(SCPreferencesRef *)(a1 + 80), v5, MutableCopy);
  CFRelease(MutableCopy);
  CFRelease(v5);
  if ((_DWORD)v13)
    goto LABEL_16;
  return v13;
}

uint64_t SCBridgeInterfaceCreate(const void *a1)
{
  const __CFAllocator *v2;
  CFStringRef v3;
  CFStringRef v4;
  uint64_t v5;
  __CFDictionary *Mutable;
  CFArrayRef v7;
  int v8;
  uint64_t Private;

  if (!a1)
  {
    _SCErrorSet(1002);
    return 0;
  }
  v2 = CFGetAllocator(a1);
  v3 = CFStringCreateWithFormat(v2, 0, CFSTR("bridge%ld"), 0);
  v4 = CFStringCreateWithFormat(v2, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("Bridge"), v3);
  if (SCPreferencesPathGetValue((SCPreferencesRef)a1, v4))
  {
    v5 = 1;
    do
    {
      CFRelease(v4);
      CFRelease(v3);
      v3 = CFStringCreateWithFormat(v2, 0, CFSTR("bridge%ld"), v5);
      v4 = CFStringCreateWithFormat(v2, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("Bridge"), v3);
      ++v5;
    }
    while (SCPreferencesPathGetValue((SCPreferencesRef)a1, v4));
  }
  Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = CFArrayCreate(v2, 0, 0, MEMORY[0x1E0C9B378]);
  CFDictionaryAddValue(Mutable, CFSTR("Interfaces"), v7);
  CFRelease(v7);
  v8 = SCPreferencesPathSetValue((SCPreferencesRef)a1, v4, Mutable);
  CFRelease(Mutable);
  CFRelease(v4);
  if (!v8)
  {
    CFRelease(v3);
    return 0;
  }
  Private = _SCBridgeInterfaceCreatePrivate(v2, v3);
  CFRelease(v3);
  *(_QWORD *)(Private + 80) = CFRetain(a1);
  return Private;
}

uint64_t SCBridgeInterfaceRemove(SCPreferencesRef *a1)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  CFStringRef BSDName;
  const __CFString *v5;
  uint64_t v6;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (a1
    && CFGetTypeID(a1) == TypeID
    && (InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a1),
        CFEqual(InterfaceType, CFSTR("Bridge")))
    && a1[10])
  {
    BSDName = SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)a1);
    v5 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("Bridge"), BSDName);
    v6 = SCPreferencesPathRemoveValue(a1[10], v5);
    CFRelease(v5);
    return v6;
  }
  else
  {
    _SCErrorSet(1002);
    return 0;
  }
}

uint64_t SCBridgeInterfaceGetOptions(const __SCNetworkInterface *a1)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (a1)
  {
    if (CFGetTypeID(a1) == TypeID)
    {
      InterfaceType = SCNetworkInterfaceGetInterfaceType(a1);
      if (CFEqual(InterfaceType, CFSTR("Bridge")))
        return *((_QWORD *)a1 + 45);
    }
  }
  _SCErrorSet(1002);
  return 0;
}

uint64_t SCBridgeInterfaceSetMemberInterfaces(const __SCPreferences **a1, const void *a2)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  CFTypeID v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  const void *ValueAtIndex;
  CFTypeID v11;
  const __CFArray *MemberInterfaces;
  const __CFArray *v13;
  CFIndex v14;
  int v15;
  __CFArray *v17;
  const __CFArray *v18;
  CFIndex v19;
  CFIndex v20;
  CFIndex v21;
  CFIndex v22;
  __CFArray *v23;
  const void *v24;
  int v25;
  int v26;
  int AllowConfiguredMembers;
  CFRange v28;
  CFRange v29;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (!a1)
    goto LABEL_15;
  if (CFGetTypeID(a1) != TypeID)
    goto LABEL_15;
  InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a1);
  if (!CFEqual(InterfaceType, CFSTR("Bridge")))
    goto LABEL_15;
  AllowConfiguredMembers = SCBridgeInterfaceGetAllowConfiguredMembers(a1);
  if (!a2)
    goto LABEL_12;
  v6 = CFArrayGetTypeID();
  if (CFGetTypeID(a2) != v6)
  {
LABEL_15:
    v15 = 1002;
LABEL_16:
    _SCErrorSet(v15);
    return 0;
  }
  Count = CFArrayGetCount((CFArrayRef)a2);
  if (Count >= 1)
  {
    v8 = Count;
    v9 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v9);
      v11 = SCNetworkInterfaceGetTypeID();
      if (!ValueAtIndex
        || CFGetTypeID(ValueAtIndex) != v11
        || !SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)ValueAtIndex))
      {
        goto LABEL_15;
      }
    }
    while (v8 != ++v9);
  }
LABEL_12:
  if (!a1[10])
    return __SCBridgeInterfaceSetMemberInterfaces((uint64_t)a1, (CFArrayRef)a2);
  MemberInterfaces = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces((const __SCNetworkInterface *)a1);
  v13 = MemberInterfaces;
  if (MemberInterfaces)
    v14 = CFArrayGetCount(MemberInterfaces);
  else
    v14 = 0;
  v17 = SCBridgeInterfaceCopyAvailableMemberInterfaces(a1[10]);
  v18 = v17;
  if (!v17)
  {
    v19 = 0;
    if (!a2)
      goto LABEL_38;
    goto LABEL_22;
  }
  v19 = CFArrayGetCount(v17);
  if (a2)
  {
LABEL_22:
    v20 = CFArrayGetCount((CFArrayRef)a2);
    if (v20 < 1)
      goto LABEL_38;
    v21 = v20;
    v22 = 0;
    v23 = 0;
    while (1)
    {
      v24 = CFArrayGetValueAtIndex((CFArrayRef)a2, v22);
      if (!v13)
        break;
      v28.location = 0;
      v28.length = v14;
      v25 = CFArrayContainsValue(v13, v28, v24);
      if (v18 && !v25)
        goto LABEL_30;
      if (!v25)
      {
        v26 = 1002;
        if (v18)
          goto LABEL_45;
        goto LABEL_46;
      }
LABEL_35:
      if (v21 == ++v22)
      {
        v26 = 0;
        if (v18)
          goto LABEL_45;
        goto LABEL_46;
      }
    }
    if (!v18)
    {
      v26 = 1002;
      goto LABEL_46;
    }
LABEL_30:
    v29.location = 0;
    v29.length = v19;
    if (!CFArrayContainsValue(v18, v29, v24))
    {
      v26 = 1002;
      goto LABEL_45;
    }
    if (!AllowConfiguredMembers && (v23 || (v23 = __SCNetworkServiceCopyAllEnabled(a1[10])) != 0))
    {
      if (__SCNetworkServiceExistsForInterface(v23, v24))
      {
        v26 = 1005;
        goto LABEL_45;
      }
    }
    goto LABEL_35;
  }
LABEL_38:
  v26 = 0;
  v23 = 0;
  if (v18)
LABEL_45:
    CFRelease(v18);
LABEL_46:
  if (v23)
    CFRelease(v23);
  if (v26)
  {
    v15 = v26;
    goto LABEL_16;
  }
  return __SCBridgeInterfaceSetMemberInterfaces((uint64_t)a1, (CFArrayRef)a2);
}

uint64_t SCBridgeInterfaceSetLocalizedDisplayName(uint64_t a1, const __CFString *a2)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  CFTypeID v6;
  const __CFString *v7;
  const __CFDictionary *Value;
  CFTypeID v9;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v11;
  int v12;
  uint64_t v13;
  const void *v15;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (!a1
    || CFGetTypeID((CFTypeRef)a1) != TypeID
    || (InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a1),
        !CFEqual(InterfaceType, CFSTR("Bridge")))
    || a2 && (v6 = CFStringGetTypeID(), CFGetTypeID(a2) != v6))
  {
    v12 = 1002;
    goto LABEL_12;
  }
  if (*(_QWORD *)(a1 + 80))
  {
    v7 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("Bridge"), *(_QWORD *)(a1 + 112));
    Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 80), v7);
    v9 = CFDictionaryGetTypeID();
    if (Value && CFGetTypeID(Value) == v9)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
      v11 = MutableCopy;
      if (a2)
        CFDictionarySetValue(MutableCopy, CFSTR("UserDefinedName"), a2);
      else
        CFDictionaryRemoveValue(MutableCopy, CFSTR("UserDefinedName"));
      if (CFEqual(Value, v11))
        v13 = 1;
      else
        v13 = SCPreferencesPathSetValue(*(SCPreferencesRef *)(a1 + 80), v7, v11);
      CFRelease(v11);
      CFRelease(v7);
      if (!(_DWORD)v13)
        return v13;
      goto LABEL_21;
    }
    CFRelease(v7);
    v12 = 1001;
LABEL_12:
    _SCErrorSet(v12);
    return 0;
  }
  v13 = 1;
LABEL_21:
  v15 = *(const void **)(a1 + 40);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(a1 + 40) = 0;
  }
  if (a2)
    *(_QWORD *)(a1 + 40) = CFStringCreateCopy(0, a2);
  return v13;
}

uint64_t SCBridgeInterfaceSetOptions(const __SCNetworkInterface *a1, const __CFDictionary *a2)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  CFTypeID v6;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (a1)
  {
    if (CFGetTypeID(a1) == TypeID)
    {
      InterfaceType = SCNetworkInterfaceGetInterfaceType(a1);
      if (CFEqual(InterfaceType, CFSTR("Bridge")))
      {
        if (!a2)
          return __SCBridgeInterfaceSetOptions((uint64_t)a1, a2);
        v6 = CFDictionaryGetTypeID();
        if (CFGetTypeID(a2) == v6)
          return __SCBridgeInterfaceSetOptions((uint64_t)a1, a2);
      }
    }
  }
  _SCErrorSet(1002);
  return 0;
}

uint64_t __SCBridgeInterfaceSetOptions(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFString *v4;
  const __CFDictionary *v5;
  CFTypeID v6;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  const void *v24;
  CFTypeID TypeID;
  const void *v26;
  void *value[2];

  value[1] = *(void **)MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 80))
  {
    v21 = 1;
LABEL_15:
    v22 = *(const void **)(a1 + 360);
    if (v22)
    {
      CFRelease(v22);
      *(_QWORD *)(a1 + 360) = 0;
    }
    if (theDict)
    {
      value[0] = 0;
      *(_QWORD *)(a1 + 360) = CFDictionaryCreateCopy(0, theDict);
      if (!*(_QWORD *)(a1 + 40))
      {
        if (CFDictionaryGetValueIfPresent(theDict, CFSTR("__AUTO__"), (const void **)value))
        {
          v24 = value[0];
          TypeID = CFStringGetTypeID();
          if (v24)
          {
            if (CFGetTypeID(v24) == TypeID)
            {
              *(void **)(a1 + 48) = value[0];
              v26 = *(const void **)(a1 + 56);
              if (v26)
              {
                CFRelease(v26);
                *(_QWORD *)(a1 + 56) = 0;
              }
            }
          }
        }
      }
    }
    return v21;
  }
  v4 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("Bridge"), *(_QWORD *)(a1 + 112));
  v5 = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 80), v4);
  v6 = CFDictionaryGetTypeID();
  if (v5 && CFGetTypeID(v5) == v6)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v5);
    v8 = MutableCopy;
    if (theDict)
      CFDictionarySetValue(MutableCopy, CFSTR("Options"), theDict);
    else
      CFDictionaryRemoveValue(MutableCopy, CFSTR("Options"));
    if (CFEqual(v5, v8))
      v21 = 1;
    else
      v21 = SCPreferencesPathSetValue(*(SCPreferencesRef *)(a1 + 80), v4, v8);
    CFRelease(v8);
    CFRelease(v4);
    if (!(_DWORD)v21)
      return v21;
    goto LABEL_15;
  }
  v9 = __log_SCNetworkConfiguration();
  v10 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v9, (os_log_type_t)v10))
  {
    v11 = _os_log_pack_size();
    v19 = (char *)value - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v20 = _os_log_pack_fill();
    *(_DWORD *)v20 = 136315138;
    *(_QWORD *)(v20 + 4) = "__SCBridgeInterfaceSetOptions";
    __SC_log_send(5, (uint64_t)v9, v10, v19);
  }
  CFRelease(v4);
  _SCErrorSet(1001);
  return 0;
}

uint64_t __SCBridgeInterfaceSetAutoConfigure(uint64_t a1, int a2)
{
  const __CFDictionary *v4;
  __CFDictionary *MutableCopy;
  _BOOL4 v6;
  uint64_t v7;

  v4 = *(const __CFDictionary **)(a1 + 360);
  if (v4)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v4);
    v6 = 0;
    if (a2)
      goto LABEL_3;
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v6 = 1;
    if (a2)
    {
LABEL_3:
      CFDictionaryRemoveValue(MutableCopy, CFSTR("AutoConfigure"));
      if (!v4)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  CFDictionarySetValue(MutableCopy, CFSTR("AutoConfigure"), (const void *)*MEMORY[0x1E0C9AE40]);
  if (v4)
LABEL_4:
    v6 = CFEqual(v4, MutableCopy) == 0;
LABEL_5:
  if (v6)
    v7 = __SCBridgeInterfaceSetOptions(a1, MutableCopy);
  else
    v7 = 1;
  CFRelease(MutableCopy);
  return v7;
}

uint64_t __SCBridgeInterfaceGetAutoConfigure(uint64_t a1)
{
  const __CFDictionary *v1;
  const __CFBoolean *Value;
  CFTypeID TypeID;

  v1 = *(const __CFDictionary **)(a1 + 360);
  if (v1)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v1, CFSTR("AutoConfigure"));
    TypeID = CFBooleanGetTypeID();
    if (Value && CFGetTypeID(Value) == TypeID)
      return CFBooleanGetValue(Value);
  }
  else
  {
    CFBooleanGetTypeID();
  }
  return 1;
}

uint64_t SCBridgeInterfaceSetAllowConfiguredMembers(CFDictionaryRef *a1, int a2)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  CFDictionaryRef v6;
  __CFDictionary *MutableCopy;
  _BOOL4 v8;
  uint64_t v9;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (!a1
    || CFGetTypeID(a1) != TypeID
    || (InterfaceType = SCNetworkInterfaceGetInterfaceType((SCNetworkInterfaceRef)a1),
        !CFEqual(InterfaceType, CFSTR("Bridge"))))
  {
    _SCErrorSet(1002);
    return 0;
  }
  v6 = a1[45];
  if (v6)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a1[45]);
    v8 = 0;
    if (a2)
      goto LABEL_6;
LABEL_13:
    CFDictionaryRemoveValue(MutableCopy, CFSTR("AllowConfiguredMembers"));
    if (!v6)
      goto LABEL_8;
    goto LABEL_7;
  }
  MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v8 = 1;
  if (!a2)
    goto LABEL_13;
LABEL_6:
  CFDictionarySetValue(MutableCopy, CFSTR("AllowConfiguredMembers"), (const void *)*MEMORY[0x1E0C9AE50]);
  if (v6)
LABEL_7:
    v8 = CFEqual(v6, MutableCopy) == 0;
LABEL_8:
  if (v8)
    v9 = __SCBridgeInterfaceSetOptions((uint64_t)a1, MutableCopy);
  else
    v9 = 1;
  CFRelease(MutableCopy);
  return v9;
}

uint64_t _SCBridgeInterfaceUpdateConfiguration(const __SCPreferences *a1)
{
  const __CFArray *v2;
  const __CFArray *v3;
  CFIndex Count;
  unsigned __int8 v5;
  __CFArray *v6;
  const __CFArray *v7;
  CFIndex v8;
  int v9;
  const __SCNetworkInterface *ValueAtIndex;
  CFStringRef BSDName;
  CFIndex v12;
  const __SCNetworkInterface *v13;
  CFStringRef v14;
  int *v15;
  const __CFArray *MemberInterfaces;
  const __CFArray *v17;
  CFIndex v18;
  const __CFArray *v19;
  const __CFArray *v20;
  CFIndex v21;
  CFIndex v22;
  CFIndex v23;
  const __SCNetworkInterface *v24;
  const __CFString *v25;
  CFIndex v26;
  const __SCNetworkInterface *v27;
  int AllowConfiguredMembers;
  const __CFString *v29;
  const __CFArray *v30;
  const __CFArray *v31;
  uint64_t v32;
  CFIndex v33;
  const __SCNetworkInterface *v34;
  CFStringRef v35;
  const __CFArray *v36;
  const __CFArray *v37;
  CFIndex v38;
  CFIndex v39;
  BOOL v40;
  const __SCNetworkInterface *v41;
  const __SCNetworkInterface *v42;
  const __CFData *HardwareAddress;
  const __CFString *v44;
  int *v45;
  int v46;
  const void *v47;
  const void *v48;
  BOOL v49;
  CFIndex i;
  const __SCNetworkInterface *v51;
  const __CFString *v52;
  CFIndex v53;
  BOOL v54;
  const __SCNetworkInterface *v55;
  const __CFData *v56;
  const __CFString *v57;
  int *v58;
  int v60;
  const __CFArray *v61;
  CFIndex v62;
  const __SCPreferences *v63;
  CFIndex v64;
  int v65;
  BOOL v66;
  CFIndex v67;
  const __CFArray *theArray;
  CFRange v69;
  CFRange v70;
  CFRange v71;

  if (!a1)
  {
    _SCErrorSet(1002);
    return 0;
  }
  v2 = (const __CFArray *)SCBridgeInterfaceCopyAll(a1);
  v3 = v2;
  if (v2)
    Count = CFArrayGetCount(v2);
  else
    Count = 0;
  v6 = _SCBridgeInterfaceCopyActive();
  v61 = v3;
  v62 = Count;
  v63 = a1;
  theArray = v6;
  if (!v6)
  {
    v60 = 0;
    v67 = 0;
LABEL_34:
    v5 = 1;
    v9 = -1;
    goto LABEL_35;
  }
  v7 = v6;
  v67 = CFArrayGetCount(v6);
  if (v67 < 1)
  {
    v60 = 0;
    goto LABEL_34;
  }
  v8 = 0;
  v9 = -1;
  v5 = 1;
  while (1)
  {
    ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v7, v8);
    BSDName = SCNetworkInterfaceGetBSDName(ValueAtIndex);
    if (Count >= 1)
    {
      v12 = 0;
      while (1)
      {
        v13 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v3, v12);
        v14 = SCNetworkInterfaceGetBSDName(v13);
        if (CFEqual(BSDName, v14))
          break;
        if (Count == ++v12)
          goto LABEL_13;
      }
      MemberInterfaces = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces(v13);
      v17 = MemberInterfaces;
      if (MemberInterfaces)
        v18 = CFArrayGetCount(MemberInterfaces);
      else
        v18 = 0;
      v19 = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces(ValueAtIndex);
      if (v19)
      {
        v20 = v19;
        v21 = CFArrayGetCount(v19);
        if (v21 >= 1)
        {
          v22 = v21;
          v23 = 0;
          while (1)
          {
            v24 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v20, v23);
            if (!v18 || (v69.location = 0, v69.length = v18, !CFArrayContainsValue(v17, v69, v24)))
            {
              if (v9 == -1)
              {
                v9 = inet_dgram_socket();
                if (v9 == -1)
                  goto LABEL_94;
              }
              v25 = SCNetworkInterfaceGetBSDName(v24);
              if (!__bridge_remove_interface(v9, BSDName, v25))
                v5 = 0;
            }
            if (v22 == ++v23)
              goto LABEL_30;
          }
        }
      }
      goto LABEL_30;
    }
LABEL_13:
    if (v9 == -1)
    {
      v9 = inet_dgram_socket();
      if (v9 == -1)
        break;
    }
    if (!__destroyInterface(v9, BSDName))
    {
      v15 = __error();
      _SCErrorSet(*v15);
      v5 = 0;
    }
LABEL_30:
    ++v8;
    v7 = theArray;
    v3 = v61;
    Count = v62;
    if (v8 == v67)
    {
      v60 = 1;
LABEL_35:
      if (Count < 1)
        goto LABEL_95;
      v26 = 0;
      while (1)
      {
        v27 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v3, v26);
        AllowConfiguredMembers = SCBridgeInterfaceGetAllowConfiguredMembers(v27);
        v29 = SCNetworkInterfaceGetBSDName(v27);
        v30 = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces(v27);
        v31 = v30;
        v64 = v26;
        v65 = AllowConfiguredMembers;
        if (v30)
          v32 = CFArrayGetCount(v30);
        else
          v32 = 0;
        if (!v60)
        {
LABEL_47:
          if (v9 == -1)
          {
            v9 = inet_dgram_socket();
            if (v9 == -1)
              goto LABEL_94;
          }
          if (__createInterface(v9, v29))
          {
            if (v32 >= 1)
            {
              v39 = 0;
              v40 = v65 == 0;
              do
              {
                v41 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v31, v39);
                if (*((_BYTE *)v41 + 344))
                {
                  v42 = v41;
                  if (v40)
                  {
                    HardwareAddress = (const __CFData *)_SCNetworkInterfaceGetHardwareAddress((uint64_t)v41);
                    if (!__bridge_set_mac(v9, v29, HardwareAddress))
                      v5 = 0;
                  }
                  v44 = SCNetworkInterfaceGetBSDName(v42);
                  v40 = 0;
                  if (!__bridge_add_interface(v63, v9, v29, v44))
                    v5 = 0;
                }
                ++v39;
              }
              while (v32 != v39);
            }
          }
          else
          {
            v45 = __error();
            _SCErrorSet(*v45);
            v5 = 0;
          }
          goto LABEL_91;
        }
        v33 = 0;
        while (1)
        {
          v34 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(theArray, v33);
          v35 = SCNetworkInterfaceGetBSDName(v34);
          v36 = (const __CFArray *)SCBridgeInterfaceGetMemberInterfaces(v34);
          v37 = v36;
          v38 = v36 ? CFArrayGetCount(v36) : 0;
          if (CFEqual(v29, v35))
            break;
          if (v67 == ++v33)
            goto LABEL_47;
        }
        if (v31 == v37 || v31 && v37 && CFEqual(v31, v37))
          goto LABEL_92;
        if (v9 == -1)
        {
          v9 = inet_dgram_socket();
          if (v9 == -1)
            goto LABEL_94;
        }
        v46 = v65;
        if (!v65 && v32 >= 1 && v38 >= 1)
        {
          v47 = CFArrayGetValueAtIndex(v31, 0);
          v48 = CFArrayGetValueAtIndex(v37, 0);
          if (CFEqual(v47, v48))
          {
            v49 = 0;
LABEL_79:
            v53 = 0;
            v66 = v49;
            if (v46)
              v54 = 0;
            else
              v54 = v49;
            do
            {
              v55 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v31, v53);
              if (v66 || (v71.location = 0, v71.length = v38, !CFArrayContainsValue(v37, v71, v55)))
              {
                if (*((_BYTE *)v55 + 344))
                {
                  if (v54)
                  {
                    v56 = (const __CFData *)_SCNetworkInterfaceGetHardwareAddress((uint64_t)v55);
                    if (!__bridge_set_mac(v9, v29, v56))
                      v5 = 0;
                  }
                  v57 = SCNetworkInterfaceGetBSDName(v55);
                  v54 = 0;
                  if (!__bridge_add_interface(v63, v9, v29, v57))
                    v5 = 0;
                }
              }
              ++v53;
            }
            while (v32 != v53);
            goto LABEL_91;
          }
          for (i = 0; i != v38; ++i)
          {
            v51 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v37, i);
            v70.location = 0;
            v70.length = v32;
            if (CFArrayContainsValue(v31, v70, v51))
            {
              v52 = SCNetworkInterfaceGetBSDName(v51);
              if (!__bridge_remove_interface(v9, v35, v52))
                v5 = 0;
            }
          }
          v38 = 0;
          v46 = 0;
        }
        v49 = v38 == 0;
        if (v32 >= 1)
          goto LABEL_79;
LABEL_91:
        v3 = v61;
LABEL_92:
        v26 = v64 + 1;
        if (v64 + 1 == v62)
          goto LABEL_95;
      }
    }
  }
LABEL_94:
  v58 = __error();
  _SCErrorSet(*v58);
  v5 = 0;
  v9 = -1;
  v3 = v61;
LABEL_95:
  if (theArray)
    CFRelease(theArray);
  if (v3)
    CFRelease(v3);
  if (v9 != -1)
    close(v9);
  return v5;
}

BOOL __bridge_remove_interface(int a1, const __CFString *a2, const __CFString *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  _BOOL8 result;
  int *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  int *v32;
  char *v33;
  __int128 v34;
  __int128 v35;
  _OWORD *v36;
  _OWORD v37[5];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v36 = 0;
  v34 = 0u;
  v35 = 0u;
  _SC_cfstring_to_cstring(a2, (UInt8 *)&v34, 16, 0x600u);
  v35 = xmmword_18D3FF4F0;
  v36 = v37;
  memset(v37, 0, sizeof(v37));
  _SC_cfstring_to_cstring(a3, (UInt8 *)v37, 16, 0x600u);
  if (ioctl(a1, 0x8028697BuLL, &v34) == -1)
  {
    v19 = __error();
    _SCErrorSet(*v19);
    v20 = __log_SCNetworkConfiguration();
    v21 = _SC_syslog_os_log_mapping(3);
    result = __SC_log_enabled(3, v20, (os_log_type_t)v21);
    if (result)
    {
      v22 = _os_log_pack_size();
      v30 = (char *)&v34 - ((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v31 = _os_log_pack_fill();
      v32 = __error();
      v33 = strerror(*v32);
      *(_DWORD *)v31 = 138412802;
      *(_QWORD *)(v31 + 4) = a3;
      *(_WORD *)(v31 + 12) = 2112;
      *(_QWORD *)(v31 + 14) = a2;
      *(_WORD *)(v31 + 22) = 2080;
      *(_QWORD *)(v31 + 24) = v33;
      __SC_log_send(3, (uint64_t)v20, v21, v30);
      return 0;
    }
  }
  else
  {
    v6 = __log_SCNetworkConfiguration();
    v7 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = (char *)&v34 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v17 = _os_log_pack_fill();
      *(_DWORD *)v17 = 138412546;
      *(_QWORD *)(v17 + 4) = a2;
      *(_WORD *)(v17 + 12) = 2112;
      *(_QWORD *)(v17 + 14) = a3;
      __SC_log_send(6, (uint64_t)v6, v7, v16);
    }
    return 1;
  }
  return result;
}

BOOL __bridge_set_mac(int a1, const __CFString *a2, const __CFData *a3)
{
  unsigned __int8 Length;
  NSObject *v7;
  uint64_t v8;
  _BOOL8 result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  int *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int *v43;
  char *v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  CFRange v48;

  v47 = *MEMORY[0x1E0C80C00];
  v45 = 0u;
  v46 = 0u;
  _SC_cfstring_to_cstring(a2, (UInt8 *)&v45, 16, 0x600u);
  Length = CFDataGetLength(a3);
  LOBYTE(v46) = Length;
  if (Length >= 0xFuLL)
  {
    _SCErrorSet(1002);
    v7 = __log_SCNetworkConfiguration();
    v8 = _SC_syslog_os_log_mapping(3);
    result = __SC_log_enabled(3, v7, (os_log_type_t)v8);
    if (!result)
      return result;
    v10 = _os_log_pack_size();
    v18 = (char *)&v45 - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v19 = _os_log_pack_fill();
    v20 = v46;
    *(_DWORD *)v19 = 138412802;
    *(_QWORD *)(v19 + 4) = a2;
    *(_WORD *)(v19 + 12) = 1024;
    *(_DWORD *)(v19 + 14) = v20;
    *(_WORD *)(v19 + 18) = 2048;
    *(_QWORD *)(v19 + 20) = 14;
LABEL_10:
    __SC_log_send(3, (uint64_t)v7, v8, v18);
    return 0;
  }
  v48.location = 0;
  v48.length = Length;
  CFDataGetBytes(a3, v48, (UInt8 *)&v46 + 2);
  if (ioctl(a1, 0x8020693CuLL, &v45) == -1)
  {
    v33 = __error();
    _SCErrorSet(*v33);
    v7 = __log_SCNetworkConfiguration();
    v8 = _SC_syslog_os_log_mapping(3);
    result = __SC_log_enabled(3, v7, (os_log_type_t)v8);
    if (!result)
      return result;
    v34 = _os_log_pack_size();
    v18 = (char *)&v45 - ((MEMORY[0x1E0C80A78](v34, v35, v36, v37, v38, v39, v40, v41) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v42 = _os_log_pack_fill();
    v43 = __error();
    v44 = strerror(*v43);
    *(_DWORD *)v42 = 138412546;
    *(_QWORD *)(v42 + 4) = a2;
    *(_WORD *)(v42 + 12) = 2080;
    *(_QWORD *)(v42 + 14) = v44;
    goto LABEL_10;
  }
  v21 = __log_SCNetworkConfiguration();
  v22 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v21, (os_log_type_t)v22))
  {
    v23 = _os_log_pack_size();
    v31 = (char *)&v45 - ((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v32 = _os_log_pack_fill();
    *(_DWORD *)v32 = 138412547;
    *(_QWORD *)(v32 + 4) = a2;
    *(_WORD *)(v32 + 12) = 2113;
    *(_QWORD *)(v32 + 14) = a3;
    __SC_log_send(6, (uint64_t)v21, v22, v31);
  }
  return 1;
}

BOOL __bridge_add_interface(const __SCPreferences *a1, int a2, const __CFString *a3, const __CFString *a4)
{
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  _BOOL8 result;
  int *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  int *v33;
  char *v34;
  __int128 v35;
  __int128 v36;
  _OWORD *v37;
  _OWORD v38[5];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  set_configured_mtu(a1, a2, a4);
  v37 = 0;
  v35 = 0u;
  v36 = 0u;
  _SC_cfstring_to_cstring(a3, (UInt8 *)&v35, 16, 0x600u);
  v36 = xmmword_18D3FF500;
  v37 = v38;
  memset(v38, 0, sizeof(v38));
  _SC_cfstring_to_cstring(a4, (UInt8 *)v38, 16, 0x600u);
  if (ioctl(a2, 0x8028697BuLL, &v35) == -1)
  {
    v20 = __error();
    _SCErrorSet(*v20);
    v21 = __log_SCNetworkConfiguration();
    v22 = _SC_syslog_os_log_mapping(3);
    result = __SC_log_enabled(3, v21, (os_log_type_t)v22);
    if (result)
    {
      v23 = _os_log_pack_size();
      v31 = (char *)&v35 - ((MEMORY[0x1E0C80A78](v23, v24, v25, v26, v27, v28, v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v32 = _os_log_pack_fill();
      v33 = __error();
      v34 = strerror(*v33);
      *(_DWORD *)v32 = 138412802;
      *(_QWORD *)(v32 + 4) = a4;
      *(_WORD *)(v32 + 12) = 2112;
      *(_QWORD *)(v32 + 14) = a3;
      *(_WORD *)(v32 + 22) = 2080;
      *(_QWORD *)(v32 + 24) = v34;
      __SC_log_send(3, (uint64_t)v21, v22, v31);
      return 0;
    }
  }
  else
  {
    v7 = __log_SCNetworkConfiguration();
    v8 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v7, (os_log_type_t)v8))
    {
      v9 = _os_log_pack_size();
      v17 = (char *)&v35 - ((MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14, v15, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v18 = _os_log_pack_fill();
      *(_DWORD *)v18 = 138412546;
      *(_QWORD *)(v18 + 4) = a3;
      *(_WORD *)(v18 + 12) = 2112;
      *(_QWORD *)(v18 + 14) = a4;
      __SC_log_send(6, (uint64_t)v7, v8, v17);
    }
    return 1;
  }
  return result;
}

void set_configured_mtu(const __SCPreferences *a1, int a2, const __CFString *a3)
{
  const __SCNetworkSet *v6;
  const __SCNetworkSet *v7;
  CFStringRef SetID;
  const __CFString *SetNetworkInterfaceEntity;
  const __CFDictionary *Value;
  const void *v11;
  CFTypeID TypeID;
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  int v26;
  int v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int *v50;
  char *v51;
  int v52;
  _BYTE v53[12];
  int valuePtr;
  __int128 v55;
  __int128 v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v55 = 0u;
  v56 = 0u;
  valuePtr = 0;
  v6 = SCNetworkSetCopyCurrent(a1);
  if (v6)
  {
    v7 = v6;
    SetID = SCNetworkSetGetSetID(v6);
    SetNetworkInterfaceEntity = SCPreferencesPathKeyCreateSetNetworkInterfaceEntity(0, (uint64_t)SetID, (uint64_t)a3, (uint64_t)CFSTR("Ethernet"));
    Value = SCPreferencesPathGetValue(a1, SetNetworkInterfaceEntity);
    CFRelease(SetNetworkInterfaceEntity);
    if (!Value)
      goto LABEL_14;
    v11 = CFDictionaryGetValue(Value, CFSTR("MTU"));
    TypeID = CFNumberGetTypeID();
    if (!v11 || CFGetTypeID(v11) != TypeID || !CFNumberGetValue((CFNumberRef)v11, kCFNumberIntType, &valuePtr))
      goto LABEL_14;
    v55 = 0u;
    v56 = 0u;
    _SC_cfstring_to_cstring(a3, (UInt8 *)&v55, 16, 0x8000100u);
    LODWORD(v56) = valuePtr;
    v13 = ioctl(a2, 0x80206934uLL, &v55);
    v14 = __log_SCNetworkConfiguration();
    if (v13 < 0)
    {
      v15 = _SC_syslog_os_log_mapping(3);
      if (__SC_log_enabled(3, v14, (os_log_type_t)v15))
      {
        v40 = _os_log_pack_size();
        v24 = &v53[-((MEMORY[0x1E0C80A78](v40, v41, v42, v43, v44, v45, v46, v47) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v48 = _os_log_pack_fill();
        v49 = valuePtr;
        v50 = __error();
        v51 = strerror(*v50);
        v52 = *__error();
        *(_DWORD *)v48 = 136316162;
        *(_QWORD *)(v48 + 4) = "BridgeConfiguration";
        *(_WORD *)(v48 + 12) = 2080;
        *(_QWORD *)(v48 + 14) = &v55;
        *(_WORD *)(v48 + 22) = 1024;
        *(_DWORD *)(v48 + 24) = v49;
        *(_WORD *)(v48 + 28) = 2080;
        *(_QWORD *)(v48 + 30) = v51;
        *(_WORD *)(v48 + 38) = 1024;
        *(_DWORD *)(v48 + 40) = v52;
        v27 = 3;
        goto LABEL_13;
      }
    }
    else
    {
      v15 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v14, (os_log_type_t)v15))
      {
        v16 = _os_log_pack_size();
        v24 = &v53[-((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v25 = _os_log_pack_fill();
        v26 = valuePtr;
        *(_DWORD *)v25 = 136315650;
        *(_QWORD *)(v25 + 4) = "BridgeConfiguration";
        *(_WORD *)(v25 + 12) = 2080;
        *(_QWORD *)(v25 + 14) = &v55;
        *(_WORD *)(v25 + 22) = 1024;
        *(_DWORD *)(v25 + 24) = v26;
        v27 = 5;
LABEL_13:
        __SC_log_send(v27, (uint64_t)v14, v15, v24);
      }
    }
LABEL_14:
    CFRelease(v7);
    return;
  }
  v28 = __log_SCNetworkConfiguration();
  v29 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v28, (os_log_type_t)v29))
  {
    v30 = _os_log_pack_size();
    v38 = &v53[-((MEMORY[0x1E0C80A78](v30, v31, v32, v33, v34, v35, v36, v37) + 15) & 0xFFFFFFFFFFFFFFF0)];
    __error();
    v39 = _os_log_pack_fill();
    *(_DWORD *)v39 = 136315138;
    *(_QWORD *)(v39 + 4) = "set_configured_mtu";
    __SC_log_send(5, (uint64_t)v28, v29, v38);
  }
}

uint64_t SCNSManagerCreate(uint64_t a1)
{
  return __SCNSManagerCreateCommon(a1, 0, 0);
}

uint64_t __SCNSManagerCreateCommon(uint64_t a1, const AuthorizationOpaqueRef *a2, int a3)
{
  const __CFString *v5;
  SCPreferencesRef v6;
  SCPreferencesRef v7;
  uint64_t Instance;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  int v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD v34[2];

  v34[1] = *MEMORY[0x1E0C80C00];
  v5 = CFStringCreateWithFormat(0, 0, CFSTR("SCNSManager(%@)"), a1);
  if (a3)
    v6 = SCPreferencesCreateWithAuthorization(0, v5, 0, a2);
  else
    v6 = SCPreferencesCreate(0, v5, 0);
  v7 = v6;
  CFRelease(v5);
  if (!v7)
  {
    v10 = _SC_LOG_DEFAULT();
    v11 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v10, (os_log_type_t)v11))
    {
      v12 = _os_log_pack_size();
      v20 = (char *)v34 - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v21 = _os_log_pack_fill();
      v22 = SCError();
      v23 = SCErrorString(v22);
      *(_DWORD *)v21 = 136315138;
      *(_QWORD *)(v21 + 4) = v23;
LABEL_13:
      __SC_log_send(5, (uint64_t)v10, v11, v20);
    }
    return 0;
  }
  if (__SCNetworkSettingsInitialize_initialized != -1)
    dispatch_once(&__SCNetworkSettingsInitialize_initialized, &__block_literal_global_17);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    CFRelease(v7);
    v10 = _SC_LOG_DEFAULT();
    v11 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v10, (os_log_type_t)v11))
    {
      v24 = _os_log_pack_size();
      v20 = (char *)v34 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v32 = _os_log_pack_fill();
      *(_DWORD *)v32 = 136315138;
      *(_QWORD *)(v32 + 4) = "__SCNSManagerCreateCommon";
      goto LABEL_13;
    }
    return 0;
  }
  v9 = Instance;
  CFRetain(v7);
  *(_QWORD *)(v9 + 16) = v7;
  CFRelease(v7);
  return v9;
}

uint64_t SCNSManagerCreateWithAuthorization(uint64_t a1, const AuthorizationOpaqueRef *a2)
{
  return __SCNSManagerCreateCommon(a1, a2, 1);
}

void SCNSManagerRefresh(uint64_t a1)
{
  SCPreferencesSynchronize(*(SCPreferencesRef *)(a1 + 16));
}

void SCNSManagerRemoveService(uint64_t a1, void *value)
{
  __CFSet *v4;
  __CFSet *Mutable;

  v4 = *(__CFSet **)(a1 + 48);
  if (v4)
    CFSetRemoveValue(v4, value);
  Mutable = *(__CFSet **)(a1 + 56);
  if (!Mutable)
  {
    Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
    *(_QWORD *)(a1 + 56) = Mutable;
  }
  CFSetAddValue(Mutable, value);
}

uint64_t SCNSManagerApplyChanges(SCPreferencesRef *a1)
{
  const __CFSet *v2;
  const __CFSet *v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  const __CFSet *v18;
  const __CFSet *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  int v32;
  const char *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  int v58;
  const char *v59;
  SCPreferencesRef v60;
  SCPreferencesRef v61;
  _BYTE v63[6];
  char context;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v2 = a1[6];
  if (!v2 || !CFSetGetCount(v2))
  {
    v3 = a1[7];
    if (!v3 || !CFSetGetCount(v3))
    {
      v5 = _SC_LOG_DEFAULT();
      v6 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v5, (os_log_type_t)v6))
      {
        v7 = _os_log_pack_size();
        v15 = &v63[-((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0)];
        __error();
        v16 = _os_log_pack_fill();
        *(_DWORD *)v16 = 136315138;
        *(_QWORD *)(v16 + 4) = "SCNSManagerApplyChanges";
        __SC_log_send(5, (uint64_t)v5, v6, v15);
      }
      v17 = 1;
      goto LABEL_34;
    }
  }
  v4 = 10;
  while (1)
  {
    if (SCPreferencesLock(a1[2], 1u))
    {
      v18 = a1[7];
      if (v18)
      {
        if (CFSetGetCount(v18))
        {
          context = 0;
          CFSetApplyFunction(a1[7], (CFSetApplierFunction)managerRemove, &context);
          v17 = 0;
          if (context)
            goto LABEL_33;
        }
      }
      v19 = a1[6];
      if (v19)
      {
        if (CFSetGetCount(v19))
        {
          v65 = 0;
          CFSetApplyFunction(a1[6], (CFSetApplierFunction)managerChange, &v65);
          v17 = 0;
          if (v65)
            goto LABEL_33;
        }
      }
      if (SCPreferencesCommitChanges(a1[2]))
      {
        if (SCPreferencesApplyChanges(a1[2]))
        {
          v17 = 1;
LABEL_33:
          SCPreferencesUnlock(a1[2]);
          goto LABEL_34;
        }
        v46 = _SC_LOG_DEFAULT();
        v47 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v46, (os_log_type_t)v47))
          goto LABEL_31;
      }
      else
      {
        v46 = _SC_LOG_DEFAULT();
        v47 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v46, (os_log_type_t)v47))
        {
LABEL_31:
          v48 = _os_log_pack_size();
          v56 = &v63[-((MEMORY[0x1E0C80A78](v48, v49, v50, v51, v52, v53, v54, v55) + 15) & 0xFFFFFFFFFFFFFFF0)];
          __error();
          v57 = _os_log_pack_fill();
          v58 = SCError();
          v59 = SCErrorString(v58);
          *(_DWORD *)v57 = 136315394;
          *(_QWORD *)(v57 + 4) = "SCNSManagerApplyChanges";
          *(_WORD *)(v57 + 12) = 2080;
          *(_QWORD *)(v57 + 14) = v59;
          __SC_log_send(5, (uint64_t)v46, v47, v56);
        }
      }
      v17 = 0;
      goto LABEL_33;
    }
    if (SCError() != 3005)
      break;
    SCPreferencesSynchronize(a1[2]);
    if (!--v4)
      goto LABEL_24;
  }
  v20 = _SC_LOG_DEFAULT();
  v21 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v20, (os_log_type_t)v21))
  {
    v22 = _os_log_pack_size();
    v30 = &v63[-((MEMORY[0x1E0C80A78](v22, v23, v24, v25, v26, v27, v28, v29) + 15) & 0xFFFFFFFFFFFFFFF0)];
    __error();
    v31 = _os_log_pack_fill();
    v32 = SCError();
    v33 = SCErrorString(v32);
    *(_DWORD *)v31 = 136315394;
    *(_QWORD *)(v31 + 4) = "SCNSManagerApplyChanges";
    *(_WORD *)(v31 + 12) = 2080;
    *(_QWORD *)(v31 + 14) = v33;
    __SC_log_send(5, (uint64_t)v20, v21, v30);
  }
LABEL_24:
  v34 = _SC_LOG_DEFAULT();
  v35 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v34, (os_log_type_t)v35))
  {
    v36 = _os_log_pack_size();
    v44 = &v63[-((MEMORY[0x1E0C80A78](v36, v37, v38, v39, v40, v41, v42, v43) + 15) & 0xFFFFFFFFFFFFFFF0)];
    __error();
    v45 = _os_log_pack_fill();
    *(_DWORD *)v45 = 136315138;
    *(_QWORD *)(v45 + 4) = "SCNSManagerApplyChanges";
    __SC_log_send(5, (uint64_t)v34, v35, v44);
  }
  v17 = 0;
LABEL_34:
  v60 = a1[6];
  if (v60)
  {
    CFRelease(v60);
    a1[6] = 0;
  }
  v61 = a1[7];
  if (v61)
  {
    CFRelease(v61);
    a1[7] = 0;
  }
  return v17;
}

_QWORD *SCNSManagerCopyService(const void **a1, const void *a2, const __CFString *a3, const __CFString *a4)
{
  if (!a3 || a4)
    return __SCNSManagerCopyService(a1, a2, a3, a4, 0);
  _SCErrorSet(1002);
  return 0;
}

_QWORD *__SCNSManagerCopyService(const void **a1, const void *a2, const __CFString *a3, const __CFString *a4, int a5)
{
  const __SCNetworkService *v9;
  _BOOL4 v10;
  const void *v12;
  const __CFArray *v13;
  const __CFArray *v14;
  CFStringRef SetID;
  const __SCNetworkSet *v16;
  const __SCNetworkSet *v17;
  const __CFArray *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD v34[2];

  v9 = 0;
  v34[1] = *MEMORY[0x1E0C80C00];
  v10 = 1;
  if (a3 && a4)
  {
    v12 = (const void *)SCNetworkCategoryCreate(a1[2], a3);
    v13 = (const __CFArray *)SCNetworkCategoryCopyServices((uint64_t)v12, (uint64_t)a4);
    if (v13)
    {
      v14 = v13;
      v9 = copy_service_in_list(v13, a2);
      CFRelease(v14);
      if (!v12)
      {
LABEL_6:
        v10 = a5 != 0;
        goto LABEL_7;
      }
    }
    else
    {
      v9 = 0;
      if (!v12)
        goto LABEL_6;
    }
    CFRelease(v12);
    goto LABEL_6;
  }
LABEL_7:
  SetID = 0;
  if (!v9 && v10)
  {
    v16 = SCNetworkSetCopyCurrent((SCPreferencesRef)a1[2]);
    if (!v16)
    {
      v19 = _SC_LOG_DEFAULT();
      v20 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v19, (os_log_type_t)v20))
      {
        v21 = _os_log_pack_size();
        v29 = (char *)v34 - ((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v30 = _os_log_pack_fill();
        *(_DWORD *)v30 = 136315138;
        *(_QWORD *)(v30 + 4) = "__SCNSManagerCopyService";
        __SC_log_send(5, (uint64_t)v19, v20, v29);
      }
      SetID = 0;
LABEL_28:
      _SCErrorSet(1004);
      v32 = 0;
      if (!SetID)
        return v32;
      goto LABEL_26;
    }
    v17 = v16;
    v18 = SCNetworkSetCopyServices(v16);
    SetID = (CFStringRef)v18;
    if (v18)
    {
      v9 = copy_service_in_list(v18, a2);
      CFRelease(SetID);
      if (v9)
      {
        SetID = SCNetworkSetGetSetID(v17);
        CFRetain(SetID);
      }
      else
      {
        SetID = 0;
      }
    }
    else
    {
      v9 = 0;
    }
    CFRelease(v17);
  }
  if (!v9)
    goto LABEL_28;
  v31 = __SCNSServiceCreate(a1, a3, a4, a2, v9);
  v32 = v31;
  if (SetID && v31)
  {
    v31[5] = SetID;
    CFRetain(SetID);
  }
  CFRelease(v9);
  if (SetID)
LABEL_26:
    CFRelease(SetID);
  return v32;
}

const __CFString *SCNSManagerCreateService(SCPreferencesRef *a1, const void *a2, const __CFString *a3, const __CFString *a4)
{
  const __CFString *v4;
  __CFString *v7;
  CFStringRef SetID;
  const __SCNetworkSet *v9;
  const __SCNetworkSet *v10;
  __CFString *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  _QWORD v25[2];

  v4 = a4;
  v25[1] = *MEMORY[0x1E0C80C00];
  if (a3 && !a4)
  {
    _SCErrorSet(1002);
    return v4;
  }
  if (a3)
  {
    v7 = (__CFString *)__SCNSServiceCreate(a1, a3, a4, a2, 0);
    SetID = 0;
    v4 = 0;
    if (!v7)
      return v4;
    goto LABEL_6;
  }
  v9 = SCNetworkSetCopyCurrent(a1[2]);
  if (v9)
  {
    v10 = v9;
    SetID = SCNetworkSetGetSetID(v9);
    CFRetain(SetID);
    CFRelease(v10);
    v11 = (__CFString *)__SCNSServiceCreate(a1, 0, v4, a2, 0);
    if (!v11)
    {
      v4 = 0;
      if (!SetID)
        return v4;
      goto LABEL_7;
    }
    v7 = v11;
    if (SetID)
    {
      CFRetain(SetID);
      v7[1].info = (uint64_t)SetID;
    }
LABEL_6:
    __SCNSManagerServiceChanged((uint64_t)a1, v7);
    v4 = v7;
    if (!SetID)
      return v4;
LABEL_7:
    CFRelease(SetID);
    return v4;
  }
  v12 = _SC_LOG_DEFAULT();
  v13 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v12, (os_log_type_t)v13))
  {
    v14 = _os_log_pack_size();
    v22 = (char *)v25 - ((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v23 = _os_log_pack_fill();
    *(_DWORD *)v23 = 136315138;
    *(_QWORD *)(v23 + 4) = "SCNSManagerCreateService";
    __SC_log_send(5, (uint64_t)v12, v13, v22);
  }
  return 0;
}

_QWORD *__SCNSServiceCreate(const void *a1, const __CFString *a2, const __CFString *a3, const void *a4, const void *a5)
{
  uint64_t Instance;
  _QWORD *v11;

  if (__SCNetworkSettingsInitialize_initialized != -1)
    dispatch_once(&__SCNetworkSettingsInitialize_initialized, &__block_literal_global_17);
  Instance = _CFRuntimeCreateInstance();
  v11 = (_QWORD *)Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = a1;
    CFRetain(a1);
    if (a2 && a3)
    {
      v11[6] = CFStringCreateCopy(0, a2);
      v11[7] = CFStringCreateCopy(0, a3);
    }
    if (a4)
    {
      CFRetain(a4);
      v11[4] = a4;
    }
    if (a5)
    {
      CFRetain(a5);
      v11[3] = a5;
    }
  }
  return v11;
}

void __SCNSManagerServiceChanged(uint64_t a1, void *value)
{
  __CFSet *v4;
  __CFSet *Mutable;

  v4 = *(__CFSet **)(a1 + 56);
  if (v4)
    CFSetRemoveValue(v4, value);
  Mutable = *(__CFSet **)(a1 + 48);
  if (!Mutable)
  {
    Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
    *(_QWORD *)(a1 + 48) = Mutable;
  }
  CFSetAddValue(Mutable, value);
}

_QWORD *SCNSManagerCopyCurrentService(const void **a1, SCNetworkInterfaceRef interface, const __CFString *a3)
{
  _xpc_connection_s *v6;
  const __CFString *v7;
  _QWORD *v8;

  if (!a3)
    return __SCNSManagerCopyService(a1, interface, 0, 0, 1);
  v6 = __SCNetworkCategoryManagerCopyActiveValueNoSession(a3, interface);
  if (v6)
    v7 = a3;
  else
    v7 = 0;
  v8 = __SCNSManagerCopyService(a1, interface, v7, (const __CFString *)v6, 1);
  if (v6)
    CFRelease(v6);
  return v8;
}

uint64_t SCNSManagerSetEventHandler(uint64_t a1, NSObject *a2, const void *a3)
{
  NSObject *v4;
  uint64_t result;
  const void *v8;
  const void *v9;
  const void *v10;

  v4 = *(NSObject **)(a1 + 24);
  if (!a2)
  {
    if (v4)
    {
      dispatch_release(v4);
      *(_QWORD *)(a1 + 24) = 0;
      v9 = *(const void **)(a1 + 32);
      if (v9)
      {
        _Block_release(v9);
        *(_QWORD *)(a1 + 32) = 0;
      }
      SCPreferencesSetDispatchQueue(*(SCPreferencesRef *)(a1 + 16), 0);
      SCPreferencesSetCallback(*(SCPreferencesRef *)(a1 + 16), 0, 0);
      v10 = *(const void **)(a1 + 40);
      if (v10)
      {
        CFRelease(v10);
        *(_QWORD *)(a1 + 40) = 0;
      }
    }
    return 1;
  }
  if (!a3 || v4)
  {
    _SCErrorSet(1002);
  }
  else
  {
    result = (uint64_t)store_create((void *)a1, a2);
    if (!result)
      return result;
    v8 = (const void *)result;
    if (__SCNSManagerEnablePrefsCallback((SCPreferencesRef *)a1, a2))
    {
      *(_QWORD *)(a1 + 24) = a2;
      dispatch_retain(a2);
      *(_QWORD *)(a1 + 32) = _Block_copy(a3);
      *(_QWORD *)(a1 + 40) = CFRetain(v8);
      CFRelease(v8);
      return 1;
    }
    CFRelease(v8);
  }
  return 0;
}

uint64_t SCNSServiceGetInterface(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

CFStringRef SCNSServiceGetServiceID(uint64_t a1)
{
  const __SCNetworkService *v1;

  v1 = *(const __SCNetworkService **)(a1 + 24);
  if (v1)
    return SCNetworkServiceGetServiceID(v1);
  else
    return CFSTR("n/a");
}

CFStringRef SCNSServiceGetName(uint64_t a1)
{
  const __SCNetworkService *v1;

  v1 = *(const __SCNetworkService **)(a1 + 24);
  if (v1)
    return SCNetworkServiceGetName(v1);
  else
    return CFSTR("n/a");
}

CFDictionaryRef SCNSServiceCopyProtocolEntity(uint64_t a1, __CFString *cf1)
{
  const __SCNetworkProtocol *v4;
  CFDictionaryRef Configuration;
  int v6;
  const __SCNetworkService *v7;
  const __SCNetworkProtocol *v8;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = 0;
  if (!__SCNetworkProtocolIsValidType(cf1))
  {
    v4 = 0;
    v6 = 1002;
    goto LABEL_11;
  }
  if (!__SCNSServiceGetEntity(a1, cf1, cf))
  {
    v7 = *(const __SCNetworkService **)(a1 + 24);
    if (v7)
    {
      v8 = SCNetworkServiceCopyProtocol(v7, cf1);
      if (v8)
      {
        v4 = v8;
        Configuration = SCNetworkProtocolGetConfiguration(v8);
        if (!Configuration)
          goto LABEL_10;
LABEL_4:
        CFRetain(Configuration);
        if (!v4)
          return Configuration;
        goto LABEL_12;
      }
    }
  }
  v4 = 0;
  Configuration = (CFDictionaryRef)cf[0];
  if (cf[0])
    goto LABEL_4;
LABEL_10:
  v6 = 1004;
LABEL_11:
  _SCErrorSet(v6);
  Configuration = 0;
  if (v4)
LABEL_12:
    CFRelease(v4);
  return Configuration;
}

uint64_t __SCNSServiceGetEntity(uint64_t a1, void *value, _QWORD *a3)
{
  const __CFSet *v6;
  const void *v7;
  uint64_t result;

  v6 = *(const __CFSet **)(a1 + 80);
  if (v6 && CFSetContainsValue(v6, value))
  {
    v7 = 0;
    result = 1;
  }
  else
  {
    result = *(_QWORD *)(a1 + 72);
    if (result)
    {
      v7 = CFDictionaryGetValue((CFDictionaryRef)result, value);
      result = v7 != 0;
    }
    else
    {
      v7 = 0;
    }
  }
  *a3 = v7;
  return result;
}

uint64_t SCNSServiceSetProtocolEntity(uint64_t *a1, const __CFString *cf1, void *a3)
{
  if (__SCNetworkProtocolIsValidType(cf1))
    return __SCNSServiceSetEntity(a1, cf1, a3);
  _SCErrorSet(1002);
  return 0;
}

uint64_t __SCNSServiceSetEntity(uint64_t *a1, CFTypeRef cf1, void *value)
{
  __CFDictionary *Mutable;
  __CFSet *v7;
  __CFSet *v8;
  int v9;
  const __CFString *v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  __CFDictionary *v25;
  _QWORD v26[2];

  v26[1] = *MEMORY[0x1E0C80C00];
  if (value)
  {
    Mutable = (__CFDictionary *)a1[9];
    if (!Mutable)
    {
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      a1[9] = (uint64_t)Mutable;
    }
    CFDictionarySetValue(Mutable, cf1, value);
    v7 = (__CFSet *)a1[10];
    if (v7)
      CFSetRemoveValue(v7, cf1);
LABEL_17:
    __SCNSManagerServiceChanged(a1[2], a1);
    return 1;
  }
  v8 = (__CFSet *)a1[10];
  if (!v8)
  {
    v8 = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
    a1[10] = (uint64_t)v8;
  }
  v9 = CFEqual(cf1, CFSTR("IPv4"));
  v10 = CFSTR("IPv6");
  if (!v9 && (v11 = CFEqual(cf1, CFSTR("IPv6")), v10 = CFSTR("IPv4"), !v11) || !v10 || !CFSetContainsValue(v8, v10))
  {
    CFSetAddValue(v8, cf1);
    v25 = (__CFDictionary *)a1[9];
    if (v25)
      CFDictionaryRemoveValue(v25, cf1);
    goto LABEL_17;
  }
  v12 = _SC_LOG_DEFAULT();
  v13 = _SC_syslog_os_log_mapping(3);
  if (__SC_log_enabled(3, v12, (os_log_type_t)v13))
  {
    v14 = _os_log_pack_size();
    v22 = (char *)v26 - ((MEMORY[0x1E0C80A78](v14, v15, v16, v17, v18, v19, v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v23 = _os_log_pack_fill();
    *(_DWORD *)v23 = 136315138;
    *(_QWORD *)(v23 + 4) = "__SCNSServiceSetEntity";
    __SC_log_send(3, (uint64_t)v12, v13, v22);
  }
  _SCErrorSet(1002);
  return 0;
}

void SCNSServiceUseDefaultProtocolEntities(void *value)
{
  const void *v2;
  const void *v3;

  *((_BYTE *)value + 88) = 1;
  v2 = (const void *)*((_QWORD *)value + 10);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)value + 10) = 0;
  }
  v3 = (const void *)*((_QWORD *)value + 9);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)value + 9) = 0;
  }
  __SCNSManagerServiceChanged(*((_QWORD *)value + 2), value);
}

const __CFDictionary *SCNSServiceCopyActiveEntity(uint64_t a1, __CFString *a2)
{
  const __CFDictionary *v4;
  const __CFDictionary *Value;
  CFDictionaryRef v6;
  const __CFDictionary *v7;

  v4 = *(const __CFDictionary **)(a1 + 64);
  if (!v4)
  {
    SCNSServiceRefreshActiveState(a1);
    v4 = *(const __CFDictionary **)(a1 + 64);
    if (!v4)
      return 0;
  }
  if (!CFDictionaryContainsKey(v4, CFSTR("IPv4"))
    && !CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 64), CFSTR("IPv6")))
  {
    return 0;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), a2);
  v6 = SCNSServiceCopyProtocolEntity(a1, a2);
  v7 = v6;
  if (Value && v6)
  {
    Value = CFDictionaryCreateMutableCopy(0, 0, Value);
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)dict_merge_value, Value);
LABEL_10:
    CFRelease(v7);
    return Value;
  }
  if (v6)
  {
    CFRetain(v6);
    Value = v7;
    goto LABEL_10;
  }
  if (Value)
    CFRetain(Value);
  return Value;
}

void SCNSServiceRefreshActiveState(uint64_t a1)
{
  const void *v2;
  const __CFString *ServiceID;
  const __CFArray *v4;
  const __CFDictionary *v5;
  CFMutableDictionaryRef Mutable;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v2 = *(const void **)(a1 + 64);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 64) = 0;
  }
  ServiceID = SCNetworkServiceGetServiceID(*(SCNetworkServiceRef *)(a1 + 24));
  cf[0] = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), ServiceID, CFSTR("[^/]+"));
  v4 = CFArrayCreate(0, cf, 1, MEMORY[0x1E0C9B378]);
  CFRelease(cf[0]);
  v5 = SCDynamicStoreCopyMultiple(0, 0, v4);
  CFRelease(v4);
  if (v5)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)state_dict_entity_key, Mutable);
    CFRelease(v5);
  }
  else
  {
    Mutable = 0;
  }
  *(_QWORD *)(a1 + 64) = Mutable;
}

uint64_t SCNSServiceGetCategoryID(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t SCNSServiceGetCategoryValue(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t SCNSServiceSetQoSMarkingPolicy(uint64_t *a1, void *value)
{
  return __SCNSServiceSetEntity(a1, CFSTR("QoSMarkingPolicy"), value);
}

CFTypeRef SCNSServiceCopyQoSMarkingPolicy(_QWORD *a1)
{
  const __SCNetworkService *v2;
  BOOL v3;
  CFTypeRef ServiceQoSMarkingPolicy;
  const __CFString *v5;
  uint64_t v6;
  const void *v7;
  SCNetworkInterfaceRef Interface;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = 0;
  v2 = (const __SCNetworkService *)a1[3];
  if (__SCNSServiceGetEntity((uint64_t)a1, CFSTR("QoSMarkingPolicy"), cf))
    v3 = 1;
  else
    v3 = v2 == 0;
  if (v3)
    goto LABEL_6;
  v5 = (const __CFString *)a1[6];
  if (v5)
  {
    v6 = a1[7];
    v7 = (const void *)SCNetworkCategoryCreate(*(const void **)(a1[2] + 16), v5);
    ServiceQoSMarkingPolicy = SCNetworkCategoryGetServiceQoSMarkingPolicy((uint64_t)v7, v6, v2);
    if (v7)
      CFRelease(v7);
    if (ServiceQoSMarkingPolicy)
      goto LABEL_12;
LABEL_15:
    _SCErrorSet(1004);
    return ServiceQoSMarkingPolicy;
  }
  Interface = SCNetworkServiceGetInterface(v2);
  if (!Interface)
  {
LABEL_6:
    ServiceQoSMarkingPolicy = cf[0];
    if (!cf[0])
      goto LABEL_15;
  }
  else
  {
    ServiceQoSMarkingPolicy = SCNetworkInterfaceGetQoSMarkingPolicy(Interface);
    if (!ServiceQoSMarkingPolicy)
      goto LABEL_15;
  }
LABEL_12:
  CFRetain(ServiceQoSMarkingPolicy);
  return ServiceQoSMarkingPolicy;
}

void __SCNSManagerDeallocate(uint64_t a1)
{
  const __SCPreferences *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  NSObject *v7;
  const void *v8;

  v2 = *(const __SCPreferences **)(a1 + 16);
  if (v2)
  {
    SCPreferencesSetDispatchQueue(v2, 0);
    SCPreferencesSetCallback(*(SCPreferencesRef *)(a1 + 16), 0, 0);
    v3 = *(const void **)(a1 + 16);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
  v4 = *(const void **)(a1 + 48);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v5 = *(const void **)(a1 + 56);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v6 = *(const void **)(a1 + 40);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v7 = *(NSObject **)(a1 + 24);
  if (v7)
  {
    dispatch_release(v7);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v8 = *(const void **)(a1 + 32);
  if (v8)
  {
    _Block_release(v8);
    *(_QWORD *)(a1 + 32) = 0;
  }
}

__CFString *__SCNSManagerCopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<%s %p> {}"), "SCNSManager", a1);
  return Mutable;
}

void __SCNSServiceDeallocate(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  v5 = (const void *)a1[5];
  if (v5)
  {
    CFRelease(v5);
    a1[5] = 0;
  }
  v6 = (const void *)a1[6];
  if (v6)
  {
    CFRelease(v6);
    a1[6] = 0;
  }
  v7 = (const void *)a1[7];
  if (v7)
  {
    CFRelease(v7);
    a1[7] = 0;
  }
  v8 = (const void *)a1[8];
  if (v8)
  {
    CFRelease(v8);
    a1[8] = 0;
  }
  v9 = (const void *)a1[9];
  if (v9)
  {
    CFRelease(v9);
    a1[9] = 0;
  }
  v10 = (const void *)a1[10];
  if (v10)
  {
    CFRelease(v10);
    a1[10] = 0;
  }
}

__CFString *__SCNSServiceCopyDescription(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  uint64_t v4;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<%s %p> { service %@"), "SCNSService", a1, a1[3]);
  if (a1[6])
  {
    v4 = a1[7];
    if (v4)
      CFStringAppendFormat(Mutable, 0, CFSTR(" category (%@, %@)"), a1[6], v4);
  }
  CFStringAppend(Mutable, CFSTR(" }"));
  return Mutable;
}

void managerRemove(_QWORD *a1, _BYTE *a2)
{
  const __SCNetworkService *v3;
  CFStringRef ServiceID;
  uint64_t v6;
  const __CFString *v7;
  const void *v8;
  const __SCNetworkService *v9;
  const __SCNetworkService *v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  const __CFString *v14;
  const __SCNetworkSet *v15;
  const __SCNetworkSet *v16;
  const __CFArray *v17;
  const __CFArray *v18;
  const __SCNetworkService *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  NSObject *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD v62[2];

  v62[1] = *MEMORY[0x1E0C80C00];
  if (!*a2)
  {
    v3 = (const __SCNetworkService *)a1[3];
    if (v3)
    {
      ServiceID = SCNetworkServiceGetServiceID(v3);
      v6 = a1[2];
      v7 = (const __CFString *)a1[6];
      if (v7)
      {
        v8 = (const void *)SCNetworkCategoryCreate(*(const void **)(v6 + 16), v7);
        v9 = copy_service_for_category_and_ID((uint64_t)v8, a1[7], ServiceID);
        if (v9)
        {
          v10 = v9;
          v11 = SCNetworkCategoryRemoveService((uint64_t)v8, a1[7], v9);
          CFRelease(v10);
          if (v11)
            goto LABEL_25;
          v12 = _SC_LOG_DEFAULT();
          v13 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v12, (os_log_type_t)v13))
            goto LABEL_16;
        }
        else
        {
          v12 = _SC_LOG_DEFAULT();
          v13 = _SC_syslog_os_log_mapping(5);
          if (__SC_log_enabled(5, v12, (os_log_type_t)v13))
          {
LABEL_16:
            v21 = _os_log_pack_size();
            v29 = (char *)v62
                - ((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0);
            __error();
            v30 = _os_log_pack_fill();
            v31 = a1[6];
            v32 = a1[7];
            *(_DWORD *)v30 = 136315906;
            *(_QWORD *)(v30 + 4) = "managerRemove";
            *(_WORD *)(v30 + 12) = 2112;
            *(_QWORD *)(v30 + 14) = ServiceID;
            *(_WORD *)(v30 + 22) = 2112;
            *(_QWORD *)(v30 + 24) = v31;
            *(_WORD *)(v30 + 32) = 2112;
            *(_QWORD *)(v30 + 34) = v32;
            __SC_log_send(5, (uint64_t)v12, v13, v29);
          }
        }
LABEL_24:
        *a2 = 1;
LABEL_25:
        if (v8)
          CFRelease(v8);
        return;
      }
      v14 = (const __CFString *)a1[5];
      if (v14 && (v15 = SCNetworkSetCopy(*(SCPreferencesRef *)(v6 + 16), v14)) != 0)
      {
        v16 = v15;
        v17 = SCNetworkSetCopyServices(v15);
        if (v17 && (v18 = v17, v19 = copy_service_in_list_by_ID(v17, ServiceID), CFRelease(v18), v19))
        {
          v20 = SCNetworkSetRemoveService(v16, v19);
          CFRelease(v16);
          if (v20)
            return;
        }
        else
        {
          CFRelease(v16);
        }
        v49 = _SC_LOG_DEFAULT();
        v50 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v49, (os_log_type_t)v50))
        {
          v51 = _os_log_pack_size();
          v59 = (char *)v62
              - ((MEMORY[0x1E0C80A78](v51, v52, v53, v54, v55, v56, v57, v58) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v60 = _os_log_pack_fill();
          v61 = a1[5];
          *(_DWORD *)v60 = 136315650;
          *(_QWORD *)(v60 + 4) = "managerRemove";
          *(_WORD *)(v60 + 12) = 2112;
          *(_QWORD *)(v60 + 14) = ServiceID;
          *(_WORD *)(v60 + 22) = 2112;
          *(_QWORD *)(v60 + 24) = v61;
          v46 = (uint64_t)v49;
          v47 = v50;
          v48 = v59;
          goto LABEL_22;
        }
      }
      else
      {
        v33 = _SC_LOG_DEFAULT();
        v34 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v33, (os_log_type_t)v34))
        {
          v35 = _os_log_pack_size();
          v43 = (char *)v62
              - ((MEMORY[0x1E0C80A78](v35, v36, v37, v38, v39, v40, v41, v42) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v44 = _os_log_pack_fill();
          v45 = a1[5];
          *(_DWORD *)v44 = 136315394;
          *(_QWORD *)(v44 + 4) = "managerRemove";
          *(_WORD *)(v44 + 12) = 2112;
          *(_QWORD *)(v44 + 14) = v45;
          v46 = (uint64_t)v33;
          v47 = v34;
          v48 = v43;
LABEL_22:
          __SC_log_send(5, v46, v47, v48);
          v8 = 0;
          goto LABEL_24;
        }
      }
      v8 = 0;
      goto LABEL_24;
    }
  }
}

const __SCNetworkService *copy_service_for_category_and_ID(uint64_t a1, uint64_t a2, const void *a3)
{
  const __CFArray *v4;
  const __CFArray *v5;
  const __SCNetworkService *v6;

  v4 = (const __CFArray *)SCNetworkCategoryCopyServices(a1, a2);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = copy_service_in_list_by_ID(v4, a3);
  CFRelease(v5);
  return v6;
}

const __SCNetworkService *copy_service_in_list_by_ID(const __CFArray *a1, const void *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const __SCNetworkService *ValueAtIndex;
  CFStringRef ServiceID;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v5 = Count;
  v6 = 0;
  while (1)
  {
    ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(a1, v6);
    ServiceID = SCNetworkServiceGetServiceID(ValueAtIndex);
    if (CFEqual(a2, ServiceID))
      break;
    if (v5 == ++v6)
      return 0;
  }
  CFRetain(ValueAtIndex);
  return ValueAtIndex;
}

void managerChange(uint64_t a1, _BYTE *a2)
{
  const __CFSet *v4;
  const __CFDictionary *v5;
  int v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  _BOOL4 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t context;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (!*a2)
  {
    if (*(_QWORD *)(a1 + 24))
    {
      if (!__SCNSServiceUpdateService(a1))
        goto LABEL_19;
    }
    else if (!__SCNSServiceInstantiateService(a1))
    {
      goto LABEL_19;
    }
    if (*(_BYTE *)(a1 + 88) && !service_establish_default(*(const __SCNetworkService **)(a1 + 24)))
      goto LABEL_12;
    v4 = *(const __CFSet **)(a1 + 80);
    if (v4)
    {
      context = a1;
      v38 = 0;
      CFSetApplyFunction(v4, (CFSetApplierFunction)entityRemove, &context);
      if ((_BYTE)v38)
        goto LABEL_12;
    }
    v5 = *(const __CFDictionary **)(a1 + 72);
    if (v5
      && (context = a1,
          v38 = 0,
          CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)entityChange, &context),
          (_BYTE)v38))
    {
LABEL_12:
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
    v7 = *(const void **)(a1 + 80);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(a1 + 80) = 0;
    }
    v8 = *(const void **)(a1 + 72);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(a1 + 72) = 0;
    }
    *(_BYTE *)(a1 + 88) = 0;
    if (v6)
    {
LABEL_19:
      v9 = *(_QWORD *)(a1 + 48);
      v10 = _SC_LOG_DEFAULT();
      v11 = _SC_syslog_os_log_mapping(5);
      v12 = __SC_log_enabled(5, v10, (os_log_type_t)v11);
      if (v9)
      {
        if (v12)
        {
          v13 = _os_log_pack_size();
          v21 = (char *)&v36
              - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v22 = _os_log_pack_fill();
          v23 = *(_QWORD *)(a1 + 32);
          v24 = *(_QWORD *)(a1 + 48);
          v25 = *(_QWORD *)(a1 + 56);
          *(_DWORD *)v22 = 136315906;
          *(_QWORD *)(v22 + 4) = "managerChange";
          *(_WORD *)(v22 + 12) = 2112;
          *(_QWORD *)(v22 + 14) = v23;
          *(_WORD *)(v22 + 22) = 2112;
          *(_QWORD *)(v22 + 24) = v24;
          *(_WORD *)(v22 + 32) = 2112;
          *(_QWORD *)(v22 + 34) = v25;
LABEL_24:
          __SC_log_send(5, (uint64_t)v10, v11, v21);
        }
      }
      else if (v12)
      {
        v26 = _os_log_pack_size();
        v21 = (char *)&v36 - ((MEMORY[0x1E0C80A78](v26, v27, v28, v29, v30, v31, v32, v33) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v34 = _os_log_pack_fill();
        v35 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)v34 = 136315394;
        *(_QWORD *)(v34 + 4) = "managerChange";
        *(_WORD *)(v34 + 12) = 2112;
        *(_QWORD *)(v34 + 14) = v35;
        goto LABEL_24;
      }
      *a2 = 1;
    }
  }
}

uint64_t __SCNSServiceInstantiateService(uint64_t a1)
{
  uint64_t v2;
  const __CFString *v3;
  SCNetworkServiceRef service_in_set;
  uint64_t v5;
  const __CFString *v6;
  const __SCNetworkSet *v7;
  const __SCNetworkSet *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  int v34;
  const char *v35;
  _QWORD v37[2];

  v37[1] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(const __CFString **)(a1 + 48);
  if (!v3)
  {
    v6 = *(const __CFString **)(a1 + 40);
    if (v6 && (v7 = SCNetworkSetCopy(*(SCPreferencesRef *)(v2 + 16), v6)) != 0)
    {
      v8 = v7;
      service_in_set = create_service_in_set(*(const __SCPreferences **)(v2 + 16), v7, *(SCNetworkInterfaceRef *)(a1 + 32));
      CFRelease(v8);
      if (service_in_set)
        goto LABEL_3;
    }
    else
    {
      v9 = _SC_LOG_DEFAULT();
      v10 = _SC_syslog_os_log_mapping(5);
      if (__SC_log_enabled(5, v9, (os_log_type_t)v10))
      {
        v11 = _os_log_pack_size();
        v19 = (char *)v37 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v20 = _os_log_pack_fill();
        v21 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)v20 = 136315394;
        *(_QWORD *)(v20 + 4) = "__SCNSServiceInstantiateService";
        *(_WORD *)(v20 + 12) = 2112;
        *(_QWORD *)(v20 + 14) = v21;
        __SC_log_send(5, (uint64_t)v9, v10, v19);
      }
    }
    return 0;
  }
  service_in_set = create_service_in_category(*(const void **)(v2 + 16), v3, *(_QWORD *)(a1 + 56), *(const __SCNetworkInterface **)(a1 + 32));
  if (!service_in_set)
    return 0;
LABEL_3:
  if (SCNetworkServiceEstablishDefaultConfiguration(service_in_set))
  {
    if (!*(_QWORD *)(a1 + 72) && !*(_QWORD *)(a1 + 80))
      *(_BYTE *)(a1 + 88) = 0;
    CFRetain(service_in_set);
    *(_QWORD *)(a1 + 24) = service_in_set;
    v5 = 1;
  }
  else
  {
    v22 = _SC_LOG_DEFAULT();
    v23 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v22, (os_log_type_t)v23))
    {
      v24 = _os_log_pack_size();
      v32 = (char *)v37 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v33 = _os_log_pack_fill();
      v34 = SCError();
      v35 = SCErrorString(v34);
      *(_DWORD *)v33 = 136315394;
      *(_QWORD *)(v33 + 4) = "__SCNSServiceInstantiateService";
      *(_WORD *)(v33 + 12) = 2080;
      *(_QWORD *)(v33 + 14) = v35;
      __SC_log_send(5, (uint64_t)v22, v23, v32);
    }
    v5 = 0;
  }
  CFRelease(service_in_set);
  return v5;
}

BOOL __SCNSServiceUpdateService(uint64_t a1)
{
  uint64_t v2;
  CFStringRef ServiceID;
  const __CFString *v4;
  const void *v5;
  const __SCNetworkService *v6;
  _BOOL8 result;
  const __CFString *v8;
  const __SCNetworkSet *v9;
  const __SCNetworkSet *v10;
  const __CFArray *v11;
  const __CFArray *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD v50[2];

  v50[1] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 16);
  ServiceID = SCNetworkServiceGetServiceID(*(SCNetworkServiceRef *)(a1 + 24));
  v4 = *(const __CFString **)(a1 + 48);
  if (v4)
  {
    v5 = (const void *)SCNetworkCategoryCreate(*(const void **)(v2 + 16), v4);
    v6 = copy_service_for_category_and_ID((uint64_t)v5, *(_QWORD *)(a1 + 56), ServiceID);
    if (v5)
      CFRelease(v5);
    if (v6)
      goto LABEL_5;
    v13 = _SC_LOG_DEFAULT();
    v14 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v13, (os_log_type_t)v14);
    if (result)
    {
      v15 = _os_log_pack_size();
      v23 = (char *)v50 - ((MEMORY[0x1E0C80A78](v15, v16, v17, v18, v19, v20, v21, v22) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v24 = _os_log_pack_fill();
      v25 = *(_QWORD *)(a1 + 48);
      v26 = *(_QWORD *)(a1 + 56);
      *(_DWORD *)v24 = 136315906;
      *(_QWORD *)(v24 + 4) = "__SCNSServiceUpdateService";
      *(_WORD *)(v24 + 12) = 2112;
      *(_QWORD *)(v24 + 14) = ServiceID;
      *(_WORD *)(v24 + 22) = 2112;
      *(_QWORD *)(v24 + 24) = v25;
      *(_WORD *)(v24 + 32) = 2112;
      *(_QWORD *)(v24 + 34) = v26;
LABEL_18:
      __SC_log_send(5, (uint64_t)v13, v14, v23);
      return 0;
    }
  }
  else
  {
    v8 = *(const __CFString **)(a1 + 40);
    if (!v8 || (v9 = SCNetworkSetCopy(*(SCPreferencesRef *)(v2 + 16), v8)) == 0)
    {
      v27 = _SC_LOG_DEFAULT();
      v28 = _SC_syslog_os_log_mapping(5);
      result = __SC_log_enabled(5, v27, (os_log_type_t)v28);
      if (!result)
        return result;
      v29 = _os_log_pack_size();
      v37 = (char *)v50 - ((MEMORY[0x1E0C80A78](v29, v30, v31, v32, v33, v34, v35, v36) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v38 = _os_log_pack_fill();
      v39 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)v38 = 136315394;
      *(_QWORD *)(v38 + 4) = "__SCNSServiceUpdateService";
      *(_WORD *)(v38 + 12) = 2112;
      *(_QWORD *)(v38 + 14) = v39;
      __SC_log_send(5, (uint64_t)v27, v28, v37);
      return 0;
    }
    v10 = v9;
    v11 = SCNetworkSetCopyServices(v9);
    if (v11)
    {
      v12 = v11;
      v6 = copy_service_in_list_by_ID(v11, ServiceID);
      CFRelease(v12);
      CFRelease(v10);
      if (v6)
      {
LABEL_5:
        CFRelease(*(CFTypeRef *)(a1 + 24));
        CFRetain(v6);
        *(_QWORD *)(a1 + 24) = v6;
        CFRelease(v6);
        return 1;
      }
    }
    else
    {
      CFRelease(v10);
    }
    v13 = _SC_LOG_DEFAULT();
    v14 = _SC_syslog_os_log_mapping(5);
    result = __SC_log_enabled(5, v13, (os_log_type_t)v14);
    if (result)
    {
      v40 = _os_log_pack_size();
      v23 = (char *)v50 - ((MEMORY[0x1E0C80A78](v40, v41, v42, v43, v44, v45, v46, v47) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v48 = _os_log_pack_fill();
      v49 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)v48 = 136315650;
      *(_QWORD *)(v48 + 4) = "__SCNSServiceUpdateService";
      *(_WORD *)(v48 + 12) = 2112;
      *(_QWORD *)(v48 + 14) = ServiceID;
      *(_WORD *)(v48 + 22) = 2112;
      *(_QWORD *)(v48 + 24) = v49;
      goto LABEL_18;
    }
  }
  return result;
}

SCNetworkServiceRef create_service_in_category(const void *a1, const __CFString *a2, uint64_t a3, const __SCNetworkInterface *a4)
{
  const void *v7;
  SCNetworkServiceRef v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  int v21;
  const char *v22;
  _QWORD v24[2];

  v24[1] = *MEMORY[0x1E0C80C00];
  v7 = (const void *)SCNetworkCategoryCreate(a1, a2);
  v8 = SCNetworkServiceCreate((SCPreferencesRef)a1, a4);
  if (!SCNetworkCategoryAddService((uint64_t)v7, a3, v8))
  {
    v9 = _SC_LOG_DEFAULT();
    v10 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v9, (os_log_type_t)v10))
    {
      v11 = _os_log_pack_size();
      v19 = (char *)v24 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v20 = _os_log_pack_fill();
      v21 = SCError();
      v22 = SCErrorString(v21);
      *(_DWORD *)v20 = 136315394;
      *(_QWORD *)(v20 + 4) = "create_service_in_category";
      *(_WORD *)(v20 + 12) = 2080;
      *(_QWORD *)(v20 + 14) = v22;
      __SC_log_send(5, (uint64_t)v9, v10, v19);
    }
    CFRelease(v8);
    v8 = 0;
  }
  CFRelease(v7);
  return v8;
}

SCNetworkServiceRef create_service_in_set(const __SCPreferences *a1, const __SCNetworkSet *a2, SCNetworkInterfaceRef interface)
{
  SCNetworkServiceRef v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int v17;
  const char *v18;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  v4 = SCNetworkServiceCreate(a1, interface);
  if (!SCNetworkSetAddService(a2, v4))
  {
    CFRelease(v4);
    v5 = _SC_LOG_DEFAULT();
    v6 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v5, (os_log_type_t)v6))
    {
      v7 = _os_log_pack_size();
      v15 = (char *)v20 - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v16 = _os_log_pack_fill();
      v17 = SCError();
      v18 = SCErrorString(v17);
      *(_DWORD *)v16 = 136315394;
      *(_QWORD *)(v16 + 4) = "create_service_in_set";
      *(_WORD *)(v16 + 12) = 2080;
      *(_QWORD *)(v16 + 14) = v18;
      __SC_log_send(5, (uint64_t)v5, v6, v15);
    }
    return 0;
  }
  return v4;
}

uint64_t service_establish_default(const __SCNetworkService *a1)
{
  const __CFArray *v2;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const __SCNetworkProtocol *ValueAtIndex;
  const __CFString *ProtocolType;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  int v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  int v39;
  const char *v40;
  _QWORD v42[2];

  v42[1] = *MEMORY[0x1E0C80C00];
  v2 = SCNetworkServiceCopyProtocols(a1);
  v3 = v2;
  if (v2)
  {
    Count = CFArrayGetCount(v2);
    if (Count >= 1)
    {
      v5 = Count;
      v6 = 0;
      while (1)
      {
        ValueAtIndex = (const __SCNetworkProtocol *)CFArrayGetValueAtIndex(v3, v6);
        ProtocolType = SCNetworkProtocolGetProtocolType(ValueAtIndex);
        if (!SCNetworkServiceRemoveProtocolType(a1, ProtocolType))
          break;
        if (v5 == ++v6)
          goto LABEL_6;
      }
      v27 = _SC_LOG_DEFAULT();
      v28 = _SC_syslog_os_log_mapping(5);
      if (!__SC_log_enabled(5, v27, (os_log_type_t)v28))
        goto LABEL_12;
      v29 = _os_log_pack_size();
      v37 = (char *)v42 - ((MEMORY[0x1E0C80A78](v29, v30, v31, v32, v33, v34, v35, v36) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v38 = _os_log_pack_fill();
      v39 = SCError();
      v40 = SCErrorString(v39);
      *(_DWORD *)v38 = 136315650;
      *(_QWORD *)(v38 + 4) = "service_establish_default";
      *(_WORD *)(v38 + 12) = 2112;
      *(_QWORD *)(v38 + 14) = ProtocolType;
      *(_WORD *)(v38 + 22) = 2080;
      *(_QWORD *)(v38 + 24) = v40;
      v24 = (uint64_t)v27;
      v25 = v28;
      v26 = v37;
      goto LABEL_11;
    }
  }
LABEL_6:
  v9 = SCNetworkServiceEstablishDefaultConfiguration(a1);
  if ((_DWORD)v9)
    goto LABEL_13;
  v10 = _SC_LOG_DEFAULT();
  v11 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v10, (os_log_type_t)v11))
  {
    v12 = _os_log_pack_size();
    v20 = (char *)v42 - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v21 = _os_log_pack_fill();
    v22 = SCError();
    v23 = SCErrorString(v22);
    *(_DWORD *)v21 = 136315394;
    *(_QWORD *)(v21 + 4) = "service_establish_default";
    *(_WORD *)(v21 + 12) = 2080;
    *(_QWORD *)(v21 + 14) = v23;
    v24 = (uint64_t)v10;
    v25 = v11;
    v26 = v20;
LABEL_11:
    __SC_log_send(5, v24, v25, v26);
  }
LABEL_12:
  v9 = 0;
LABEL_13:
  if (v3)
    CFRelease(v3);
  return v9;
}

void entityRemove(const __CFString *a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  const char *v19;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a2;
  if (CFEqual(a1, CFSTR("QoSMarkingPolicy")))
  {
    if (__SCNSServiceSetQoSMarkingPolicy(v4, 0))
      return;
  }
  else if (SCNetworkServiceRemoveProtocolType(*(SCNetworkServiceRef *)(v4 + 24), a1))
  {
    return;
  }
  if (SCError() != 1004)
  {
    v5 = _SC_LOG_DEFAULT();
    v6 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v5, (os_log_type_t)v6))
    {
      v7 = _os_log_pack_size();
      v15 = (char *)v20 - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v16 = _os_log_pack_fill();
      v17 = *(_QWORD *)(v4 + 24);
      v18 = SCError();
      v19 = SCErrorString(v18);
      *(_DWORD *)v16 = 136315906;
      *(_QWORD *)(v16 + 4) = "entityRemove";
      *(_WORD *)(v16 + 12) = 2112;
      *(_QWORD *)(v16 + 14) = a1;
      *(_WORD *)(v16 + 22) = 2112;
      *(_QWORD *)(v16 + 24) = v17;
      *(_WORD *)(v16 + 32) = 2080;
      *(_QWORD *)(v16 + 34) = v19;
      __SC_log_send(3, (uint64_t)v5, v6, v15);
    }
    *(_BYTE *)(a2 + 8) = 1;
  }
}

uint64_t entityChange(const __CFString *a1, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t result;

  v6 = *(_QWORD *)a3;
  if (CFEqual(a1, CFSTR("QoSMarkingPolicy")))
  {
    result = __SCNSServiceSetQoSMarkingPolicy(v6, a2);
    if ((_DWORD)result)
      return result;
    goto LABEL_3;
  }
  result = __SCNSServiceSetProtocol(v6, a1, a2);
  if (!(_DWORD)result)
LABEL_3:
    *(_BYTE *)(a3 + 8) = 1;
  return result;
}

uint64_t __SCNSServiceSetQoSMarkingPolicy(uint64_t a1, const __CFDictionary *a2)
{
  const __SCNetworkService *v3;
  const __CFString *v4;
  uint64_t v5;
  const void *v6;
  uint64_t v7;
  SCNetworkInterfaceRef Interface;

  v3 = *(const __SCNetworkService **)(a1 + 24);
  v4 = *(const __CFString **)(a1 + 48);
  if (v4)
  {
    v5 = *(_QWORD *)(a1 + 56);
    v6 = (const void *)SCNetworkCategoryCreate(*(const void **)(*(_QWORD *)(a1 + 16) + 16), v4);
    v7 = SCNetworkCategorySetServiceQoSMarkingPolicy((uint64_t)v6, v5, v3, a2);
    if (v6)
      CFRelease(v6);
  }
  else
  {
    Interface = SCNetworkServiceGetInterface(*(SCNetworkServiceRef *)(a1 + 24));
    if (Interface)
      return SCNetworkInterfaceSetQoSMarkingPolicy(Interface, (const __CFString *)a2);
    return 0;
  }
  return v7;
}

uint64_t __SCNSServiceSetProtocol(uint64_t a1, const __CFString *a2, const __CFDictionary *a3)
{
  const __SCNetworkService *v5;
  const __SCNetworkProtocol *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  int v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  int v34;
  const char *v35;
  _QWORD v37[2];

  v37[1] = *MEMORY[0x1E0C80C00];
  v5 = *(const __SCNetworkService **)(a1 + 24);
  v6 = SCNetworkServiceCopyProtocol(v5, a2);
  if (v6)
    goto LABEL_2;
  if (!SCNetworkServiceAddProtocolType(v5, a2))
  {
    v8 = _SC_LOG_DEFAULT();
    v9 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v8, (os_log_type_t)v9))
    {
LABEL_13:
      v24 = _os_log_pack_size();
      v32 = (char *)v37 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v33 = _os_log_pack_fill();
      v34 = SCError();
      v35 = SCErrorString(v34);
      *(_DWORD *)v33 = 136315906;
      *(_QWORD *)(v33 + 4) = "__SCNSServiceSetProtocol";
      *(_WORD *)(v33 + 12) = 2112;
      *(_QWORD *)(v33 + 14) = v5;
      *(_WORD *)(v33 + 22) = 2112;
      *(_QWORD *)(v33 + 24) = a2;
      *(_WORD *)(v33 + 32) = 2080;
      *(_QWORD *)(v33 + 34) = v35;
      __SC_log_send(3, (uint64_t)v8, v9, v32);
    }
    return 0;
  }
  v6 = SCNetworkServiceCopyProtocol(v5, a2);
  if (!v6)
  {
    v8 = _SC_LOG_DEFAULT();
    v9 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v8, (os_log_type_t)v9))
      goto LABEL_13;
    return 0;
  }
LABEL_2:
  if (SCNetworkProtocolSetConfiguration(v6, a3))
  {
    v7 = 1;
  }
  else
  {
    v10 = _SC_LOG_DEFAULT();
    v11 = _SC_syslog_os_log_mapping(3);
    if (__SC_log_enabled(3, v10, (os_log_type_t)v11))
    {
      v12 = _os_log_pack_size();
      v20 = (char *)v37 - ((MEMORY[0x1E0C80A78](v12, v13, v14, v15, v16, v17, v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v21 = _os_log_pack_fill();
      v22 = SCError();
      v23 = SCErrorString(v22);
      *(_DWORD *)v21 = 136315906;
      *(_QWORD *)(v21 + 4) = "__SCNSServiceSetProtocol";
      *(_WORD *)(v21 + 12) = 2112;
      *(_QWORD *)(v21 + 14) = v5;
      *(_WORD *)(v21 + 22) = 2112;
      *(_QWORD *)(v21 + 24) = a2;
      *(_WORD *)(v21 + 32) = 2080;
      *(_QWORD *)(v21 + 34) = v23;
      __SC_log_send(3, (uint64_t)v10, v11, v20);
    }
    v7 = 0;
  }
  CFRelease(v6);
  return v7;
}

const __SCNetworkService *copy_service_in_list(const __CFArray *a1, const void *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const __SCNetworkService *ValueAtIndex;
  SCNetworkInterfaceRef Interface;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v5 = Count;
  v6 = 0;
  while (1)
  {
    ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(a1, v6);
    Interface = SCNetworkServiceGetInterface(ValueAtIndex);
    if (CFEqual(a2, Interface))
      break;
    if (v5 == ++v6)
      return 0;
  }
  CFRetain(ValueAtIndex);
  return ValueAtIndex;
}

const __SCDynamicStore *store_create(void *a1, NSObject *a2)
{
  const __SCDynamicStore *v3;
  const __SCDynamicStore *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int v17;
  const char *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  int v31;
  const char *v32;
  SCDynamicStoreContext context;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  context.version = 0;
  memset(&context.retain, 0, 24);
  context.info = a1;
  v3 = SCDynamicStoreCreate(0, CFSTR("SCNSManager"), (SCDynamicStoreCallBack)__SCNSManagerStoreCallback, &context);
  if (!v3)
  {
    v19 = _SC_LOG_DEFAULT();
    v20 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v19, (os_log_type_t)v20))
    {
      v21 = _os_log_pack_size();
      v29 = (char *)&context
          - ((MEMORY[0x1E0C80A78](v21, v22, v23, v24, v25, v26, v27, v28) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v30 = _os_log_pack_fill();
      v31 = SCError();
      v32 = SCErrorString(v31);
      *(_DWORD *)v30 = 136315394;
      *(_QWORD *)(v30 + 4) = "store_create";
      *(_WORD *)(v30 + 12) = 2080;
      *(_QWORD *)(v30 + 14) = v32;
      __SC_log_send(5, (uint64_t)v19, v20, v29);
    }
    return 0;
  }
  v4 = v3;
  if (!store_set_notification_keys(v3))
  {
LABEL_6:
    CFRelease(v4);
    return 0;
  }
  if (!SCDynamicStoreSetDispatchQueue(v4, a2))
  {
    v5 = _SC_LOG_DEFAULT();
    v6 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v5, (os_log_type_t)v6))
    {
      v7 = _os_log_pack_size();
      v15 = (char *)&context - ((MEMORY[0x1E0C80A78](v7, v8, v9, v10, v11, v12, v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v16 = _os_log_pack_fill();
      v17 = SCError();
      v18 = SCErrorString(v17);
      *(_DWORD *)v16 = 136315394;
      *(_QWORD *)(v16 + 4) = "store_create";
      *(_WORD *)(v16 + 12) = 2080;
      *(_QWORD *)(v16 + 14) = v18;
      __SC_log_send(5, (uint64_t)v5, v6, v15);
    }
    goto LABEL_6;
  }
  return v4;
}

uint64_t __SCNSManagerEnablePrefsCallback(SCPreferencesRef *a1, NSObject *a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  int v18;
  const char *v19;
  SCPreferencesContext context;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  context.version = 0;
  memset(&context.retain, 0, 24);
  context.info = a1;
  v4 = SCPreferencesSetCallback(a1[2], (SCPreferencesCallBack)__SCNSManagerPrefsCallback, &context);
  if ((_DWORD)v4)
  {
    v5 = v4;
    if (SCPreferencesSetDispatchQueue(a1[2], a2))
      return 1;
    else
      SCPreferencesSetCallback(a1[2], 0, 0);
  }
  else
  {
    v6 = _SC_LOG_DEFAULT();
    v7 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v6, (os_log_type_t)v7))
    {
      v8 = _os_log_pack_size();
      v16 = (char *)&context - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v17 = _os_log_pack_fill();
      v18 = SCError();
      v19 = SCErrorString(v18);
      *(_DWORD *)v17 = 136315394;
      *(_QWORD *)(v17 + 4) = "__SCNSManagerEnablePrefsCallback";
      *(_WORD *)(v17 + 12) = 2080;
      *(_QWORD *)(v17 + 14) = v19;
      __SC_log_send(5, (uint64_t)v6, v7, v16);
    }
    return 0;
  }
  return v5;
}

uint64_t __SCNSManagerStoreCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = *(_QWORD *)(a3 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(result + 16))(result, a3, 0);
  return result;
}

uint64_t store_set_notification_keys(const __SCDynamicStore *a1)
{
  const CFArrayCallBacks *v2;
  __CFArray *Mutable;
  __CFArray *v4;
  uint64_t i;
  CFStringRef NetworkServiceEntity;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  int v20;
  const char *v21;
  _QWORD v24[5];

  v24[4] = *MEMORY[0x1E0C80C00];
  v24[0] = CFSTR("IPv4");
  v24[1] = CFSTR("IPv6");
  v24[2] = CFSTR("Proxies");
  v24[3] = CFSTR("DNS");
  v2 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(Mutable, CFSTR("com.apple.scnetworkcategory"));
  v4 = CFArrayCreateMutable(0, 0, v2);
  for (i = 0; i != 4; ++i)
  {
    NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(0, CFSTR("State:"), CFSTR("[^/]+"), (CFStringRef)v24[i]);
    CFArrayAppendValue(v4, NetworkServiceEntity);
    CFRelease(NetworkServiceEntity);
  }
  v7 = SCDynamicStoreSetNotificationKeys(a1, Mutable, v4);
  if (!(_DWORD)v7)
  {
    v8 = _SC_LOG_DEFAULT();
    v9 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v8, (os_log_type_t)v9))
    {
      v10 = _os_log_pack_size();
      v18 = (char *)&v24[-1]
          - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v19 = _os_log_pack_fill();
      v20 = SCError();
      v21 = SCErrorString(v20);
      *(_DWORD *)v19 = 136315394;
      *(_QWORD *)(v19 + 4) = "store_set_notification_keys";
      *(_WORD *)(v19 + 12) = 2080;
      *(_QWORD *)(v19 + 14) = v21;
      __SC_log_send(5, (uint64_t)v8, v9, v18);
    }
  }
  CFRelease(Mutable);
  CFRelease(v4);
  return v7;
}

uint64_t __SCNSManagerPrefsCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = *(_QWORD *)(a3 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(result + 16))(result, a3, 0);
  return result;
}

void dict_merge_value(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

void state_dict_entity_key(CFStringRef theString, const void *a2, __CFDictionary *a3)
{
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v6;
  CFIndex Count;
  const void *ValueAtIndex;

  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, theString, CFSTR("/"));
  if (ArrayBySeparatingStrings)
  {
    v6 = ArrayBySeparatingStrings;
    Count = CFArrayGetCount(ArrayBySeparatingStrings);
    if (Count >= 1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v6, Count - 1);
      CFDictionarySetValue(a3, ValueAtIndex, a2);
    }
    CFRelease(v6);
  }
}

void add_configured_interface_0(const __CFString *a1, CFDictionaryRef theDict, uint64_t a3)
{
  const __CFString *Value;
  CFTypeID TypeID;
  const __CFNumber *v8;
  CFTypeID v9;
  uint64_t Private;
  const __SCNetworkInterface *v11;
  const __SCPreferences *v12;
  const __SCNetworkInterface *v13;
  const __CFString *v14;
  CFTypeID v15;
  const __CFDictionary *v16;
  CFTypeID v17;

  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("Interface"));
  TypeID = CFStringGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) == TypeID)
    {
      v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("Tag"));
      v9 = CFNumberGetTypeID();
      if (v8)
      {
        if (CFGetTypeID(v8) == v9)
        {
          Private = _SCVLANInterfaceCreatePrivate(0, a1);
          if (!Private)
            add_configured_interface_cold_1_0();
          v11 = (const __SCNetworkInterface *)Private;
          v12 = *(const __SCPreferences **)(a3 + 8);
          if (!v12
            || (v13 = (const __SCNetworkInterface *)__SCNetworkInterfaceCreateWithNIPreferencesUsingBSDName(0, v12, Value)) == 0)
          {
            v13 = _SCNetworkInterfaceCreateWithBSDName(0, Value, 2);
            if (!v13)
              add_configured_interface_cold_2();
          }
          *((_BYTE *)v13 + 368) = 1;
          SCVLANInterfaceSetPhysicalInterfaceAndTag(v11, v13, v8);
          CFRelease(v13);
          v14 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("UserDefinedName"));
          v15 = CFStringGetTypeID();
          if (v14 && CFGetTypeID(v14) == v15)
            SCVLANInterfaceSetLocalizedDisplayName(v11, v14);
          v16 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("Options"));
          v17 = CFDictionaryGetTypeID();
          if (v16)
          {
            if (CFGetTypeID(v16) == v17)
              SCVLANInterfaceSetOptions(v11, v16);
          }
          *((_QWORD *)v11 + 10) = CFRetain(*(CFTypeRef *)(a3 + 16));
          CFArrayAppendValue(*(CFMutableArrayRef *)a3, v11);
          CFRelease(v11);
        }
      }
    }
  }
}

CFArrayRef SCVLANInterfaceCopyAvailablePhysicalInterfaces(void)
{
  __CFArray *Mutable;
  const __SCPreferences *v1;
  const __SCPreferences *v2;
  const __CFArray *v3;
  __CFSet *v4;
  __CFArray *v5;
  __CFArray *v6;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v1 = SCPreferencesCreate(0, CFSTR("SCVLANInterfaceCopyAvailablePhysicalInterfaces"), 0);
  if (v1)
  {
    v2 = v1;
    v3 = (const __CFArray *)SCBridgeInterfaceCopyAll(v1);
    if (v3)
    {
      v4 = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
      __SCBridgeInterfaceListCollectMembers(v3, v4, 0);
    }
    else
    {
      v4 = 0;
    }
    CFRelease(v2);
  }
  else
  {
    v3 = 0;
    v4 = 0;
  }
  v5 = __SCNetworkInterfaceCopyAll_IONetworkInterface(0);
  if (v5)
  {
    v6 = v5;
    addAvailableInterfaces(Mutable, v5, v4);
    CFRelease(v6);
  }
  if (v3)
  {
    addAvailableInterfaces(Mutable, v3, 0);
    CFRelease(v3);
  }
  if (v4)
    CFRelease(v4);
  return Mutable;
}

void addAvailableInterfaces(__CFArray *a1, CFArrayRef theArray, const __CFSet *a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  _BYTE *ValueAtIndex;

  Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    v7 = Count;
    for (i = 0; i != v7; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
      if (!a3 || !CFSetContainsValue(a3, ValueAtIndex))
      {
        if (ValueAtIndex[368])
          CFArrayAppendValue(a1, ValueAtIndex);
      }
    }
  }
}

__CFArray *_SCVLANInterfaceCopyActive()
{
  int v0;
  int v1;
  __CFArray *Mutable;
  ifaddrs *v3;
  __int128 v4;
  unsigned __int8 *ifa_data;
  const __CFString *v6;
  uint64_t Private;
  const __SCNetworkInterface *v8;
  const __CFString *v9;
  SCNetworkInterfaceRef v10;
  const __SCNetworkInterface *v11;
  const __CFNumber *v12;
  const __CFNumber *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  int *v26;
  char *v27;
  int *v28;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  int *v42;
  char *v43;
  _BYTE v44[12];
  int valuePtr;
  ifaddrs *v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int16 v49;
  char cStr[16];
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v46 = 0;
  if (getifaddrs(&v46) == -1)
  {
    v14 = __log_SCNetworkConfiguration();
    v15 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v14, (os_log_type_t)v15))
    {
      v16 = _os_log_pack_size();
      v24 = &v44[-((MEMORY[0x1E0C80A78](v16, v17, v18, v19, v20, v21, v22, v23) + 15) & 0xFFFFFFFFFFFFFFF0)];
      __error();
      v25 = _os_log_pack_fill();
      v26 = __error();
      v27 = strerror(*v26);
      *(_DWORD *)v25 = 136315138;
      *(_QWORD *)(v25 + 4) = v27;
      __SC_log_send(5, (uint64_t)v14, v15, v24);
    }
    _SCErrorSet(1001);
    return 0;
  }
  v0 = inet_dgram_socket();
  if (v0 == -1)
  {
    v28 = __error();
    _SCErrorSet(*v28);
    Mutable = 0;
    goto LABEL_19;
  }
  v1 = v0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v3 = v46;
  if (!v46)
    goto LABEL_14;
  v4 = 0uLL;
  while (1)
  {
    v51 = v4;
    v52 = v4;
    valuePtr = 0;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    ifa_data = (unsigned __int8 *)v3->ifa_data;
    if (ifa_data)
    {
      if (v3->ifa_addr->sa_family == 18 && *ifa_data == 135)
        break;
    }
LABEL_13:
    v3 = v3->ifa_next;
    if (!v3)
      goto LABEL_14;
  }
  v51 = v4;
  v52 = v4;
  v49 = 0;
  v47 = 0;
  v48 = 0;
  __strlcpy_chk();
  *(_QWORD *)&v52 = &v47;
  if (ioctl(v1, 0xC020697FuLL, &v51) != -1)
  {
    v6 = CFStringCreateWithCString(0, v3->ifa_name, 0x600u);
    Private = _SCVLANInterfaceCreatePrivate(0, v6);
    if (!Private)
      _SCVLANInterfaceCopyActive_cold_1();
    v8 = (const __SCNetworkInterface *)Private;
    CFRelease(v6);
    __strlcpy_chk();
    v9 = CFStringCreateWithCString(0, cStr, 0x600u);
    v10 = _SCNetworkInterfaceCreateWithBSDName(0, v9, 2);
    if (!v10)
      _SCVLANInterfaceCopyActive_cold_2();
    v11 = v10;
    CFRelease(v9);
    valuePtr = v49;
    v12 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    if (!v12)
      _SCVLANInterfaceCopyActive_cold_3();
    v13 = v12;
    SCVLANInterfaceSetPhysicalInterfaceAndTag(v8, v11, v12);
    CFRelease(v11);
    CFRelease(v13);
    CFArrayAppendValue(Mutable, v8);
    CFRelease(v8);
    v4 = 0uLL;
    goto LABEL_13;
  }
  v30 = __log_SCNetworkConfiguration();
  v31 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v30, (os_log_type_t)v31))
  {
    v32 = _os_log_pack_size();
    v40 = &v44[-((MEMORY[0x1E0C80A78](v32, v33, v34, v35, v36, v37, v38, v39) + 15) & 0xFFFFFFFFFFFFFFF0)];
    __error();
    v41 = _os_log_pack_fill();
    v42 = __error();
    v43 = strerror(*v42);
    *(_DWORD *)v41 = 136315138;
    *(_QWORD *)(v41 + 4) = v43;
    __SC_log_send(5, (uint64_t)v30, v31, v40);
  }
  CFRelease(Mutable);
  _SCErrorSet(1001);
  Mutable = 0;
LABEL_14:
  close(v1);
LABEL_19:
  MEMORY[0x18D78C7F8](v46);
  return Mutable;
}

Boolean SCVLANInterfaceSetPhysicalInterfaceAndTag(SCVLANInterfaceRef vlan, SCNetworkInterfaceRef physical, CFNumberRef tag)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  CFTypeID v8;
  CFTypeID v9;
  const __SCPreferences *v10;
  CFTypeRef VLANInterfaceAndTag;
  const void *v12;
  int v13;
  const __CFString *v14;
  CFDictionaryRef Value;
  CFTypeID v16;
  __CFDictionary *MutableCopy;
  CFStringRef BSDName;
  int v19;
  int v20;
  const void *v22;
  CFTypeRef Copy;
  const void *v24;
  const void *v25;
  int valuePtr;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!vlan)
    goto LABEL_18;
  if (CFGetTypeID(vlan) != TypeID)
    goto LABEL_18;
  InterfaceType = SCNetworkInterfaceGetInterfaceType(vlan);
  if (!CFEqual(InterfaceType, CFSTR("VLAN")))
    goto LABEL_18;
  v8 = SCNetworkInterfaceGetTypeID();
  if (!physical || CFGetTypeID(physical) != v8)
    goto LABEL_18;
  if (!*((_BYTE *)physical + 368))
  {
    if (__SCPreferencesUsingDefaultPrefs(*((_QWORD *)physical + 10)))
    {
LABEL_18:
      v20 = 1002;
LABEL_19:
      _SCErrorSet(v20);
      LOBYTE(v19) = 0;
      return v19;
    }
    *((_BYTE *)physical + 368) = 1;
  }
  v9 = CFNumberGetTypeID();
  if (!tag)
    goto LABEL_18;
  if (CFGetTypeID(tag) != v9)
    goto LABEL_18;
  valuePtr = 0;
  CFNumberGetValue(tag, kCFNumberIntType, &valuePtr);
  if ((valuePtr - 1) >= 0xFFE)
    goto LABEL_18;
  v10 = (const __SCPreferences *)*((_QWORD *)vlan + 10);
  if (!v10)
  {
    v22 = 0;
    LOBYTE(v19) = 1;
    goto LABEL_23;
  }
  VLANInterfaceAndTag = findVLANInterfaceAndTag(v10, physical, tag);
  if (VLANInterfaceAndTag)
  {
    v12 = VLANInterfaceAndTag;
    v13 = CFEqual(vlan, VLANInterfaceAndTag);
    CFRelease(v12);
    if (!v13)
    {
      v20 = 1005;
      goto LABEL_19;
    }
  }
  v14 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("VLAN"), *((_QWORD *)vlan + 14));
  Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)vlan + 10), v14);
  v16 = CFDictionaryGetTypeID();
  if (!Value || CFGetTypeID(Value) != v16)
  {
    CFRelease(v14);
    v20 = 1001;
    goto LABEL_19;
  }
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
  BSDName = SCNetworkInterfaceGetBSDName(physical);
  CFDictionarySetValue(MutableCopy, CFSTR("Interface"), BSDName);
  CFDictionarySetValue(MutableCopy, CFSTR("Tag"), tag);
  if (CFEqual(Value, MutableCopy))
    v19 = 1;
  else
    v19 = SCPreferencesPathSetValue(*((SCPreferencesRef *)vlan + 10), v14, MutableCopy);
  CFRelease(MutableCopy);
  CFRelease(v14);
  if (!v19)
    return v19;
  v22 = (const void *)*((_QWORD *)vlan + 10);
LABEL_23:
  Copy = __SCNetworkInterfaceCreateCopy(0, (uint64_t)physical, v22, *((const void **)vlan + 12));
  v24 = (const void *)*((_QWORD *)vlan + 47);
  *((_QWORD *)vlan + 47) = Copy;
  if (v24)
    CFRelease(v24);
  v25 = (const void *)*((_QWORD *)vlan + 48);
  *((_QWORD *)vlan + 48) = CFRetain(tag);
  if (v25)
    CFRelease(v25);
  return v19;
}

SCVLANInterfaceRef SCVLANInterfaceCreate(SCPreferencesRef prefs, SCNetworkInterfaceRef physical, CFNumberRef tag)
{
  CFTypeID TypeID;
  CFTypeID v7;
  CFTypeRef VLANInterfaceAndTag;
  int v9;
  const __SCNetworkInterface *Private;
  const __CFAllocator *v12;
  CFStringRef v13;
  CFStringRef v14;
  uint64_t v15;
  const __CFDictionary *v16;
  int v17;
  int valuePtr;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!prefs)
    goto LABEL_11;
  TypeID = SCNetworkInterfaceGetTypeID();
  if (!physical || CFGetTypeID(physical) != TypeID)
    goto LABEL_11;
  if (!*((_BYTE *)physical + 368))
  {
    if (__SCPreferencesUsingDefaultPrefs((uint64_t)prefs))
    {
LABEL_11:
      v9 = 1002;
      goto LABEL_12;
    }
    *((_BYTE *)physical + 368) = 1;
  }
  v7 = CFNumberGetTypeID();
  if (!tag)
    goto LABEL_11;
  if (CFGetTypeID(tag) != v7)
    goto LABEL_11;
  valuePtr = 0;
  CFNumberGetValue(tag, kCFNumberIntType, &valuePtr);
  if ((valuePtr - 1) >= 0xFFE)
    goto LABEL_11;
  VLANInterfaceAndTag = findVLANInterfaceAndTag(prefs, physical, tag);
  if (VLANInterfaceAndTag)
  {
    CFRelease(VLANInterfaceAndTag);
    v9 = 1005;
  }
  else
  {
    v12 = CFGetAllocator(prefs);
    v13 = CFStringCreateWithFormat(v12, 0, CFSTR("vlan%ld"), 0);
    v14 = CFStringCreateWithFormat(v12, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("VLAN"), v13);
    if (SCPreferencesPathGetValue(prefs, v14))
    {
      v15 = 1;
      do
      {
        CFRelease(v14);
        CFRelease(v13);
        v13 = CFStringCreateWithFormat(v12, 0, CFSTR("vlan%ld"), v15);
        v14 = CFStringCreateWithFormat(v12, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("VLAN"), v13);
        ++v15;
      }
      while (SCPreferencesPathGetValue(prefs, v14));
    }
    v16 = CFDictionaryCreate(v12, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v17 = SCPreferencesPathSetValue(prefs, v14, v16);
    CFRelease(v16);
    CFRelease(v14);
    if (v17)
    {
      Private = (const __SCNetworkInterface *)_SCVLANInterfaceCreatePrivate(v12, v13);
      CFRelease(v13);
      *((_QWORD *)Private + 10) = CFRetain(prefs);
      SCVLANInterfaceSetPhysicalInterfaceAndTag(Private, physical, tag);
      return Private;
    }
    CFRelease(v13);
    v9 = 1001;
  }
LABEL_12:
  _SCErrorSet(v9);
  return 0;
}

CFTypeRef findVLANInterfaceAndTag(const __SCPreferences *a1, const void *a2, const void *a3)
{
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const __SCNetworkInterface *ValueAtIndex;
  SCNetworkInterfaceRef PhysicalInterface;
  CFNumberRef Tag;
  CFNumberRef v12;
  CFTypeRef v13;

  v5 = SCVLANInterfaceCopyAll(a1);
  Count = CFArrayGetCount(v5);
  if (Count < 1)
  {
LABEL_8:
    v13 = 0;
  }
  else
  {
    v7 = Count;
    v8 = 0;
    while (1)
    {
      ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v5, v8);
      PhysicalInterface = SCVLANInterfaceGetPhysicalInterface(ValueAtIndex);
      Tag = SCVLANInterfaceGetTag(ValueAtIndex);
      if (PhysicalInterface)
      {
        v12 = Tag;
        if (Tag)
        {
          if (CFEqual(a2, PhysicalInterface) && CFEqual(a3, v12))
            break;
        }
      }
      if (v7 == ++v8)
        goto LABEL_8;
    }
    v13 = CFRetain(ValueAtIndex);
  }
  CFRelease(v5);
  return v13;
}

Boolean SCVLANInterfaceRemove(SCVLANInterfaceRef vlan)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  CFStringRef BSDName;
  const __CFString *v5;
  Boolean v6;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (vlan
    && CFGetTypeID(vlan) == TypeID
    && (InterfaceType = SCNetworkInterfaceGetInterfaceType(vlan), CFEqual(InterfaceType, CFSTR("VLAN")))
    && *((_QWORD *)vlan + 10))
  {
    BSDName = SCNetworkInterfaceGetBSDName(vlan);
    v5 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("VLAN"), BSDName);
    v6 = SCPreferencesPathRemoveValue(*((SCPreferencesRef *)vlan + 10), v5);
    CFRelease(v5);
    return v6;
  }
  else
  {
    _SCErrorSet(1002);
    return 0;
  }
}

SCNetworkInterfaceRef SCVLANInterfaceGetPhysicalInterface(SCVLANInterfaceRef vlan)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (vlan)
  {
    if (CFGetTypeID(vlan) == TypeID)
    {
      InterfaceType = SCNetworkInterfaceGetInterfaceType(vlan);
      if (CFEqual(InterfaceType, CFSTR("VLAN")))
        return (SCNetworkInterfaceRef)*((_QWORD *)vlan + 47);
    }
  }
  _SCErrorSet(1002);
  return 0;
}

CFNumberRef SCVLANInterfaceGetTag(SCVLANInterfaceRef vlan)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (vlan)
  {
    if (CFGetTypeID(vlan) == TypeID)
    {
      InterfaceType = SCNetworkInterfaceGetInterfaceType(vlan);
      if (CFEqual(InterfaceType, CFSTR("VLAN")))
        return (CFNumberRef)*((_QWORD *)vlan + 48);
    }
  }
  _SCErrorSet(1002);
  return 0;
}

CFDictionaryRef SCVLANInterfaceGetOptions(SCVLANInterfaceRef vlan)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (vlan)
  {
    if (CFGetTypeID(vlan) == TypeID)
    {
      InterfaceType = SCNetworkInterfaceGetInterfaceType(vlan);
      if (CFEqual(InterfaceType, CFSTR("VLAN")))
        return (CFDictionaryRef)*((_QWORD *)vlan + 49);
    }
  }
  _SCErrorSet(1002);
  return 0;
}

Boolean SCVLANInterfaceSetLocalizedDisplayName(SCVLANInterfaceRef vlan, CFStringRef newName)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  CFTypeID v6;
  const __CFString *v7;
  const __CFDictionary *Value;
  CFTypeID v9;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v11;
  int v12;
  int v13;
  const void *v15;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (!vlan
    || CFGetTypeID(vlan) != TypeID
    || (InterfaceType = SCNetworkInterfaceGetInterfaceType(vlan), !CFEqual(InterfaceType, CFSTR("VLAN")))
    || newName && (v6 = CFStringGetTypeID(), CFGetTypeID(newName) != v6))
  {
    v12 = 1002;
    goto LABEL_12;
  }
  if (*((_QWORD *)vlan + 10))
  {
    v7 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("VLAN"), *((_QWORD *)vlan + 14));
    Value = SCPreferencesPathGetValue(*((SCPreferencesRef *)vlan + 10), v7);
    v9 = CFDictionaryGetTypeID();
    if (Value && CFGetTypeID(Value) == v9)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
      v11 = MutableCopy;
      if (newName)
        CFDictionarySetValue(MutableCopy, CFSTR("UserDefinedName"), newName);
      else
        CFDictionaryRemoveValue(MutableCopy, CFSTR("UserDefinedName"));
      if (CFEqual(Value, v11))
        v13 = 1;
      else
        v13 = SCPreferencesPathSetValue(*((SCPreferencesRef *)vlan + 10), v7, v11);
      CFRelease(v11);
      CFRelease(v7);
      if (!v13)
        return v13;
      goto LABEL_21;
    }
    CFRelease(v7);
    v12 = 1001;
LABEL_12:
    _SCErrorSet(v12);
    LOBYTE(v13) = 0;
    return v13;
  }
  LOBYTE(v13) = 1;
LABEL_21:
  v15 = (const void *)*((_QWORD *)vlan + 5);
  if (v15)
  {
    CFRelease(v15);
    *((_QWORD *)vlan + 5) = 0;
  }
  if (newName)
    *((_QWORD *)vlan + 5) = CFStringCreateCopy(0, newName);
  return v13;
}

Boolean SCVLANInterfaceSetOptions(SCVLANInterfaceRef vlan, CFDictionaryRef newOptions)
{
  CFTypeID TypeID;
  CFStringRef InterfaceType;
  CFTypeID v6;

  TypeID = SCNetworkInterfaceGetTypeID();
  if (vlan)
  {
    if (CFGetTypeID(vlan) == TypeID)
    {
      InterfaceType = SCNetworkInterfaceGetInterfaceType(vlan);
      if (CFEqual(InterfaceType, CFSTR("VLAN")))
      {
        if (!newOptions)
          return __SCVLANInterfaceSetOptions((uint64_t)vlan, newOptions);
        v6 = CFDictionaryGetTypeID();
        if (CFGetTypeID(newOptions) == v6)
          return __SCVLANInterfaceSetOptions((uint64_t)vlan, newOptions);
      }
    }
  }
  _SCErrorSet(1002);
  return 0;
}

uint64_t __SCVLANInterfaceSetOptions(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFString *v4;
  const __CFDictionary *Value;
  CFTypeID TypeID;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  _QWORD v24[2];

  v24[1] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 80))
  {
    v21 = 1;
LABEL_15:
    v22 = *(const void **)(a1 + 392);
    if (v22)
    {
      CFRelease(v22);
      *(_QWORD *)(a1 + 392) = 0;
    }
    if (theDict)
      *(_QWORD *)(a1 + 392) = CFDictionaryCreateCopy(0, theDict);
    return v21;
  }
  v4 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@/%@"), CFSTR("VirtualNetworkInterfaces"), CFSTR("VLAN"), *(_QWORD *)(a1 + 112));
  Value = SCPreferencesPathGetValue(*(SCPreferencesRef *)(a1 + 80), v4);
  TypeID = CFDictionaryGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
    v8 = MutableCopy;
    if (theDict)
      CFDictionarySetValue(MutableCopy, CFSTR("Options"), theDict);
    else
      CFDictionaryRemoveValue(MutableCopy, CFSTR("Options"));
    if (CFEqual(Value, v8))
      v21 = 1;
    else
      v21 = SCPreferencesPathSetValue(*(SCPreferencesRef *)(a1 + 80), v4, v8);
    CFRelease(v8);
    CFRelease(v4);
    if (!(_DWORD)v21)
      return v21;
    goto LABEL_15;
  }
  v9 = __log_SCNetworkConfiguration();
  v10 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v9, (os_log_type_t)v10))
  {
    v11 = _os_log_pack_size();
    v19 = (char *)v24 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v20 = _os_log_pack_fill();
    *(_DWORD *)v20 = 136315138;
    *(_QWORD *)(v20 + 4) = "__SCVLANInterfaceSetOptions";
    __SC_log_send(5, (uint64_t)v9, v10, v19);
  }
  CFRelease(v4);
  _SCErrorSet(1001);
  return 0;
}

uint64_t __SCVLANInterfaceSetAutoConfigure(uint64_t a1, int a2)
{
  const __CFDictionary *v4;
  __CFDictionary *MutableCopy;
  _BOOL4 v6;
  uint64_t v7;

  v4 = *(const __CFDictionary **)(a1 + 392);
  if (v4)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v4);
    v6 = 0;
    if (a2)
      goto LABEL_3;
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v6 = 1;
    if (a2)
    {
LABEL_3:
      CFDictionaryRemoveValue(MutableCopy, CFSTR("AutoConfigure"));
      if (!v4)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  CFDictionarySetValue(MutableCopy, CFSTR("AutoConfigure"), (const void *)*MEMORY[0x1E0C9AE40]);
  if (v4)
LABEL_4:
    v6 = CFEqual(v4, MutableCopy) == 0;
LABEL_5:
  if (v6)
    v7 = __SCVLANInterfaceSetOptions(a1, MutableCopy);
  else
    v7 = 1;
  CFRelease(MutableCopy);
  return v7;
}

uint64_t __SCVLANInterfaceGetAutoConfigure(uint64_t a1)
{
  const __CFDictionary *v1;
  const __CFBoolean *Value;
  CFTypeID TypeID;

  v1 = *(const __CFDictionary **)(a1 + 392);
  if (v1)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v1, CFSTR("AutoConfigure"));
    TypeID = CFBooleanGetTypeID();
    if (Value && CFGetTypeID(Value) == TypeID)
      return CFBooleanGetValue(Value);
  }
  else
  {
    CFBooleanGetTypeID();
  }
  return 1;
}

uint64_t _SCVLANInterfaceUpdateConfiguration(const __SCPreferences *a1)
{
  const __CFArray *v1;
  const __CFArray *v2;
  CFIndex Count;
  unsigned __int8 v4;
  __CFArray *v5;
  const __CFArray *v6;
  CFIndex v7;
  CFIndex v8;
  uint64_t v9;
  const __SCNetworkInterface *ValueAtIndex;
  CFStringRef BSDName;
  const __SCNetworkInterface *v12;
  CFStringRef v13;
  CFIndex v14;
  const __SCNetworkInterface *v15;
  CFStringRef v16;
  uint64_t v17;
  int *v18;
  CFIndex v19;
  const __SCNetworkInterface *v20;
  CFStringRef v21;
  SCNetworkInterfaceRef PhysicalInterface;
  _BYTE *v23;
  uint64_t IOPath;
  const void *Value;
  CFIndex v26;
  const __SCNetworkInterface *v27;
  CFStringRef v28;
  int v29;
  int v30;
  const __CFString *v31;
  const __CFNumber *v32;
  int *v33;
  int v34;
  CFStringRef v35;
  const __CFNumber *Tag;
  const __CFString *v37;
  int *v39;
  const void *v40;
  const void *v41;
  char v42;
  const __CFArray *v43;
  int v44;
  const __CFDictionary *theDict;
  int v46;
  CFIndex v47;

  if (!a1)
  {
    _SCErrorSet(1002);
    return 0;
  }
  v1 = SCVLANInterfaceCopyAll(a1);
  v2 = v1;
  if (v1)
    Count = CFArrayGetCount(v1);
  else
    Count = 0;
  theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = _SCVLANInterfaceCopyActive();
  v6 = v5;
  if (!v5)
  {
    v44 = 0;
    v7 = 0;
LABEL_23:
    LODWORD(v9) = -1;
    v42 = 1;
    goto LABEL_24;
  }
  v7 = CFArrayGetCount(v5);
  if (v7 < 1)
  {
    v44 = 0;
    goto LABEL_23;
  }
  v8 = 0;
  v42 = 1;
  v9 = 0xFFFFFFFFLL;
  while (1)
  {
    ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v6, v8);
    BSDName = SCNetworkInterfaceGetBSDName(ValueAtIndex);
    if (Count >= 1)
    {
      v12 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v2, 0);
      v13 = SCNetworkInterfaceGetBSDName(v12);
      if (CFEqual(BSDName, v13))
        goto LABEL_19;
      v14 = 1;
      do
      {
        if (Count == v14)
          goto LABEL_15;
        v15 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v2, v14);
        v16 = SCNetworkInterfaceGetBSDName(v15);
        ++v14;
      }
      while (!CFEqual(BSDName, v16));
      if (v14 - 1 < Count)
        goto LABEL_19;
    }
LABEL_15:
    v17 = v9;
    if ((_DWORD)v9 == -1)
    {
      v17 = inet_dgram_socket();
      if ((_DWORD)v17 == -1)
        break;
    }
    v9 = v17;
    if (!__destroyInterface(v17, BSDName))
    {
      v18 = __error();
      _SCErrorSet(*v18);
      v42 = 0;
    }
LABEL_19:
    if (++v8 == v7)
    {
      v44 = 1;
LABEL_24:
      v46 = v9;
      if (Count >= 1)
      {
        v19 = 0;
        v41 = (const void *)*MEMORY[0x1E0C9AE50];
        v40 = (const void *)*MEMORY[0x1E0C9AE40];
        v43 = v2;
        v47 = Count;
        do
        {
          v20 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v2, v19);
          v21 = SCNetworkInterfaceGetBSDName(v20);
          PhysicalInterface = SCVLANInterfaceGetPhysicalInterface(v20);
          if (PhysicalInterface)
          {
            v23 = PhysicalInterface;
            IOPath = _SCNetworkInterfaceGetIOPath((uint64_t)PhysicalInterface);
            Value = CFDictionaryGetValue(theDict, v23);
            if (!Value)
            {
              if (v23[368])
                Value = v41;
              else
                Value = v40;
              CFDictionaryAddValue(theDict, v23, Value);
            }
            if (v44)
            {
              v26 = 0;
              while (1)
              {
                v27 = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v6, v26);
                v28 = SCNetworkInterfaceGetBSDName(v27);
                if (CFEqual(v21, v28))
                  break;
                if (v7 == ++v26)
                  goto LABEL_36;
              }
              if (CFEqual(v20, v27))
              {
LABEL_44:
                v2 = v43;
LABEL_45:
                Count = v47;
                goto LABEL_56;
              }
              v34 = v46;
              v2 = v43;
              Count = v47;
              if (v46 == -1)
              {
                v34 = inet_dgram_socket();
                if (v34 == -1)
                  goto LABEL_66;
              }
              v46 = v34;
              if (!CFBooleanGetValue((CFBooleanRef)Value)
                || !__vlan_clear(v46, v21)
                || (v35 = SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)v23),
                    Tag = SCVLANInterfaceGetTag(v20),
                    v37 = v35,
                    Count = v47,
                    !__vlan_set(v46, v21, v37, Tag)))
              {
                if (!CFBooleanGetValue((CFBooleanRef)Value))
                  _SCErrorSet(1001);
                __destroyInterface(v46, v21);
                goto LABEL_55;
              }
            }
            else
            {
LABEL_36:
              v29 = CFBooleanGetValue((CFBooleanRef)Value);
              if (!IOPath)
                goto LABEL_44;
              v2 = v43;
              Count = v47;
              if (v29)
              {
                v30 = v46;
                if (v46 == -1)
                {
                  v30 = inet_dgram_socket();
                  if (v30 == -1)
                    goto LABEL_66;
                }
                v46 = v30;
                if (!__createInterface(v30, v21))
                {
                  v33 = __error();
                  _SCErrorSet(*v33);
LABEL_55:
                  v42 = 0;
                  goto LABEL_56;
                }
                v31 = SCNetworkInterfaceGetBSDName((SCNetworkInterfaceRef)v23);
                v32 = SCVLANInterfaceGetTag(v20);
                if (!__vlan_set(v30, v21, v31, v32))
                {
                  __destroyInterface(v30, v21);
                  v42 = 0;
                }
                goto LABEL_45;
              }
            }
          }
LABEL_56:
          ++v19;
        }
        while (v19 != Count);
      }
      if (!v6)
        goto LABEL_59;
LABEL_58:
      CFRelease(v6);
      goto LABEL_59;
    }
  }
LABEL_66:
  v39 = __error();
  _SCErrorSet(*v39);
  v42 = 0;
  v46 = -1;
  if (v6)
    goto LABEL_58;
LABEL_59:
  if (v2)
    CFRelease(v2);
  if (theDict)
    CFRelease(theDict);
  v4 = v42;
  if (v46 != -1)
    close(v46);
  return v4;
}

uint64_t __vlan_clear(int a1, const __CFString *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  int *v16;
  char *v17;
  _QWORD v19[2];
  __int16 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v21 = 0u;
  v22 = 0u;
  _SC_cfstring_to_cstring(a2, (UInt8 *)&v21, 16, 0x600u);
  *(_QWORD *)&v22 = v19;
  v19[0] = 0;
  v19[1] = 0;
  v20 = 0;
  if (ioctl(a1, 0x8020697EuLL, &v21) != -1)
    return 1;
  v4 = __log_SCNetworkConfiguration();
  v5 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v4, (os_log_type_t)v5))
  {
    v6 = _os_log_pack_size();
    v14 = (char *)&v19[-1] - ((MEMORY[0x1E0C80A78](v6, v7, v8, v9, v10, v11, v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v15 = _os_log_pack_fill();
    v16 = __error();
    v17 = strerror(*v16);
    *(_DWORD *)v15 = 136315138;
    *(_QWORD *)(v15 + 4) = v17;
    __SC_log_send(5, (uint64_t)v4, v5, v14);
  }
  _SCErrorSet(1001);
  return 0;
}

uint64_t __vlan_set(int a1, const __CFString *a2, const __CFString *a3, const __CFNumber *a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  int *v20;
  char *v21;
  uint64_t v22;
  _QWORD v23[2];
  __int16 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  HIDWORD(v22) = 0;
  v25 = 0u;
  v26 = 0u;
  v23[0] = 0;
  v23[1] = 0;
  v24 = 0;
  _SC_cfstring_to_cstring(a2, (UInt8 *)&v25, 16, 0x600u);
  *(_QWORD *)&v26 = v23;
  _SC_cfstring_to_cstring(a3, (UInt8 *)v23, 16, 0x600u);
  CFNumberGetValue(a4, kCFNumberIntType, (char *)&v22 + 4);
  v24 = WORD2(v22);
  if (ioctl(a1, 0x8020697EuLL, &v25) != -1)
    return 1;
  v8 = __log_SCNetworkConfiguration();
  v9 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v8, (os_log_type_t)v9))
  {
    v10 = _os_log_pack_size();
    v18 = (char *)&v23[-1] - ((MEMORY[0x1E0C80A78](v10, v11, v12, v13, v14, v15, v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v19 = _os_log_pack_fill();
    v20 = __error();
    v21 = strerror(*v20);
    *(_DWORD *)v19 = 136315138;
    *(_QWORD *)(v19 + 4) = v21;
    __SC_log_send(5, (uint64_t)v8, v9, v18);
  }
  _SCErrorSet(1001);
  return 0;
}

char *_scprefs_observer_watch(int a1, char *__s, uint64_t a3, const void *a4)
{
  size_t v8;
  size_t v9;
  char *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  _QWORD block[6];

  block[5] = *MEMORY[0x1E0C80C00];
  if (_scprefs_observer_watch_initialized != -1)
    dispatch_once(&_scprefs_observer_watch_initialized, &__block_literal_global_18);
  v8 = strlen(__s);
  v9 = v8 + 1;
  v10 = (char *)malloc_type_malloc(v8 + 41, 0x5A000366uLL);
  *(_OWORD *)v10 = 0u;
  *((_OWORD *)v10 + 1) = 0u;
  *((_QWORD *)v10 + 4) = 0;
  *(_DWORD *)v10 = a1;
  strlcpy(v10 + 40, __s, v9);
  *((_QWORD *)v10 + 4) = a3;
  *((_QWORD *)v10 + 1) = _Block_copy(a4);
  v11 = __log_SCPreferences();
  v12 = _SC_syslog_os_log_mapping(6);
  if (__SC_log_enabled(6, v11, (os_log_type_t)v12))
  {
    v13 = _os_log_pack_size();
    v21 = (char *)block - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v22 = _os_log_pack_fill();
    *(_DWORD *)v22 = 136315138;
    *(_QWORD *)(v22 + 4) = v10 + 40;
    __SC_log_send(6, (uint64_t)v11, v12, v21);
  }
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___scprefs_observer_watch_block_invoke_1;
  block[3] = &__block_descriptor_tmp_2;
  block[4] = v10;
  dispatch_sync((dispatch_queue_t)prefs_observer_queue, block);
  return v10;
}

void ___scprefs_observer_watch_block_invoke()
{
  _prefs_observer_init();
}

void _prefs_observer_init()
{
  uint32_t v0;
  uint32_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  _DWORD *v13;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  prefs_observer_queue = (uint64_t)dispatch_queue_create("com.apple.SystemConfiguration.SCPreferencesObserver", 0);
  head_0 = 0;
  v0 = notify_register_dispatch("com.apple.ManagedConfiguration.profileListChanged", (int *)&_prefs_observer_init_token, (dispatch_queue_t)prefs_observer_queue, &__block_literal_global_8_0);
  if (v0)
  {
    v1 = v0;
    v2 = __log_SCPreferences();
    v3 = _SC_syslog_os_log_mapping(6);
    if (__SC_log_enabled(6, v2, (os_log_type_t)v3))
    {
      v4 = _os_log_pack_size();
      v12 = (char *)v14 - ((MEMORY[0x1E0C80A78](v4, v5, v6, v7, v8, v9, v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v13 = (_DWORD *)_os_log_pack_fill();
      *v13 = 67109120;
      v13[1] = v1;
      __SC_log_send(6, (uint64_t)v2, v3, v12);
    }
  }
}

uint64_t ___scprefs_observer_watch_block_invoke_1(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(result + 32) + 24) = head_0;
  head_0 = *(_QWORD *)(result + 32);
  return result;
}

void _scprefs_observer_cancel(uint64_t a1)
{
  _QWORD v1[6];

  v1[5] = *MEMORY[0x1E0C80C00];
  v1[0] = MEMORY[0x1E0C809B0];
  v1[1] = 0x40000000;
  v1[2] = ___scprefs_observer_cancel_block_invoke;
  v1[3] = &__block_descriptor_tmp_3_0;
  v1[4] = a1;
  dispatch_sync((dispatch_queue_t)prefs_observer_queue, v1);
}

void ___scprefs_observer_cancel_block_invoke(uint64_t a1)
{
  _QWORD *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;

  v1 = *(_QWORD **)(a1 + 32);
  v2 = &head_0;
  v3 = head_0;
  if ((_QWORD *)head_0 != v1)
  {
    do
    {
      v4 = v3;
      v3 = *(_QWORD *)(v3 + 24);
    }
    while ((_QWORD *)v3 != v1);
    v2 = (uint64_t *)(v4 + 24);
  }
  *v2 = v1[3];
  v5 = (const void *)v1[2];
  if (v5)
    CFRelease(v5);
  free(v1);
}

void ___prefs_observer_init_block_invoke()
{
  prefs_observer_handle_notifications();
}

void prefs_observer_handle_notifications()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t i;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v0 = __log_SCPreferences();
  v1 = _SC_syslog_os_log_mapping(7);
  if (__SC_log_enabled(7, v0, (os_log_type_t)v1))
  {
    v2 = _os_log_pack_size();
    v10 = (char *)v12 - ((MEMORY[0x1E0C80A78](v2, v3, v4, v5, v6, v7, v8, v9) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    *(_WORD *)_os_log_pack_fill() = 0;
    __SC_log_send(7, (uint64_t)v0, v1, v10);
  }
  for (i = head_0; i; i = *(_QWORD *)(i + 24))
  {
    if (has_changed((int *)i))
      dispatch_async(*(dispatch_queue_t *)(i + 32), *(dispatch_block_t *)(i + 8));
  }
}

BOOL has_changed(int *a1)
{
  int v2;
  const char *v3;
  const char *v4;
  CC_LONG v5;
  CFDataRef v6;
  CFDataRef v7;
  _BOOL8 v8;
  int v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  const char *v23;
  CC_SHA256_CTX v25;
  stat v26;
  unsigned __int8 v27[1024];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = (const char *)(a1 + 10);
  v2 = *a1;
  *(_QWORD *)&v25.wbuf[14] = 0;
  if (v2 == 2)
    v4 = "/Library/Managed Preferences/mobile";
  else
    v4 = 0;
  memset(&v25, 0, 96);
  CC_SHA256_Init(&v25);
  memset(&v26, 0, sizeof(v26));
  snprintf((char *)v27, 0x400uLL, "%s/%s", v4, v3);
  if (stat((const char *)v27, &v26) || (v26.st_mode & 0xF000) != 0x8000)
  {
    CC_SHA256_Final(v27, &v25);
    v6 = 0;
  }
  else
  {
    v5 = strlen((const char *)v27);
    CC_SHA256_Update(&v25, v27, v5);
    CC_SHA256_Update(&v25, &v26.st_mtimespec, 0x10u);
    CC_SHA256_Final(v27, &v25);
    v6 = CFDataCreate(0, v27, 32);
  }
  v7 = (CFDataRef)*((_QWORD *)a1 + 2);
  if (v6 == v7)
  {
    v8 = 0;
    v7 = v6;
    if (v6)
LABEL_13:
      CFRelease(v7);
  }
  else
  {
    v8 = 1;
    if (v6 && v7)
    {
      v9 = CFEqual(v6, v7);
      v7 = (CFDataRef)*((_QWORD *)a1 + 2);
      v8 = v9 == 0;
    }
    if (v7)
      goto LABEL_13;
  }
  *((_QWORD *)a1 + 2) = v6;
  v10 = __log_SCPreferences();
  if (v8)
    v11 = 6;
  else
    v11 = 7;
  v12 = _SC_syslog_os_log_mapping(v11);
  if (__SC_log_enabled(v11, v10, (os_log_type_t)v12))
  {
    v13 = _os_log_pack_size();
    v21 = (char *)&v25 - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v22 = _os_log_pack_fill();
    v23 = "did not change";
    if (v8)
      v23 = "changed";
    *(_DWORD *)v22 = 136315394;
    *(_QWORD *)(v22 + 4) = v3;
    *(_WORD *)(v22 + 12) = 2080;
    *(_QWORD *)(v22 + 14) = v23;
    __SC_log_send(v11, (uint64_t)v10, v12, v21);
  }
  return v8;
}

__CFArray *VPNServiceCopyAllMatchingExternalID(const __SCPreferences *a1, const void *a2, const void *a3)
{
  CFTypeID TypeID;
  CFTypeID v7;
  __CFArray *result;

  if (a1
    && (TypeID = CFStringGetTypeID(), a2)
    && CFGetTypeID(a2) == TypeID
    && (v7 = CFStringGetTypeID(), a3)
    && CFGetTypeID(a3) == v7)
  {
    result = copy_matching_services(a1, a2, a3);
    if (result)
      return result;
  }
  else
  {
    LODWORD(result) = 1002;
  }
  _SCErrorSet((int)result);
  return 0;
}

__CFArray *copy_matching_services(const __SCPreferences *a1, const void *a2, const void *a3)
{
  const __CFArray *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  uint64_t v9;
  CFIndex v10;
  __CFArray *Mutable;
  const void *ValueAtIndex;
  CFTypeID TypeID;
  CFTypeID v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  int v17;
  CFIndex v18;
  const __CFAllocator *allocator;

  v5 = SCNetworkServiceCopyAll(a1);
  if (!v5)
    return 0;
  v6 = v5;
  Count = CFArrayGetCount(v5);
  if (Count < 1)
  {
    Mutable = 0;
  }
  else
  {
    v8 = Count;
    v9 = 0;
    v10 = 0;
    Mutable = 0;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v6, v10);
      if (isA_VPNService(ValueAtIndex))
      {
        TypeID = CFStringGetTypeID();
        if (!a2
          || CFGetTypeID(a2) != TypeID
          || (v14 = CFStringGetTypeID(), !a3)
          || CFGetTypeID(a3) != v14
          || (v15 = SCNetworkServiceCopyExternalID(ValueAtIndex, a2)) != 0
          && (v16 = v15, v17 = CFEqual(v15, a3), CFRelease(v16), v17))
        {
          if (!Mutable)
          {
            v18 = CFArrayGetCount(v6);
            Mutable = CFArrayCreateMutable(allocator, v18 + v9, MEMORY[0x1E0C9B378]);
          }
          CFArrayAppendValue(Mutable, ValueAtIndex);
        }
      }
      ++v10;
      --v9;
    }
    while (v8 != v10);
  }
  CFRelease(v6);
  return Mutable;
}

__CFArray *VPNServiceCopyAll(const __SCPreferences *a1)
{
  __CFArray *result;

  if (a1)
  {
    result = copy_matching_services(a1, 0, 0);
    if (result)
      return result;
  }
  else
  {
    LODWORD(result) = 1002;
  }
  _SCErrorSet((int)result);
  return 0;
}

__CFArray *VPNServiceCopyAppRuleIDs(const void *a1)
{
  const __SCNetworkInterface *Interface;
  CFDictionaryRef Configuration;
  CFTypeID TypeID;
  const void *Value;
  CFTypeID v6;
  uint64_t Count;
  __CFArray *Mutable;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  CFTypeID v11;
  const void *v12;
  CFTypeID v13;
  const void *v14;
  int v15;

  if (!isA_VPNService(a1) || (Interface = SCNetworkServiceGetInterface((SCNetworkServiceRef)a1)) == 0)
  {
    v15 = 1002;
LABEL_21:
    _SCErrorSet(v15);
    return 0;
  }
  Configuration = SCNetworkInterfaceGetConfiguration(Interface);
  TypeID = CFDictionaryGetTypeID();
  if (!Configuration
    || CFGetTypeID(Configuration) != TypeID
    || (Value = CFDictionaryGetValue(Configuration, CFSTR("AppRules")), v6 = CFArrayGetTypeID(), !Value)
    || CFGetTypeID(Value) != v6)
  {
LABEL_20:
    v15 = 0;
    goto LABEL_21;
  }
  Count = CFArrayGetCount((CFArrayRef)Value);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)Value, i);
      v11 = CFDictionaryGetTypeID();
      if (ValueAtIndex)
      {
        if (CFGetTypeID(ValueAtIndex) == v11)
        {
          v12 = CFDictionaryGetValue(ValueAtIndex, CFSTR("Identifier"));
          v13 = CFStringGetTypeID();
          if (v12)
          {
            if (CFGetTypeID(v12) == v13)
            {
              v14 = CFDictionaryGetValue(ValueAtIndex, CFSTR("Identifier"));
              CFArrayAppendValue(Mutable, v14);
            }
          }
        }
      }
    }
  }
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    goto LABEL_20;
  }
  if (!Mutable)
    goto LABEL_20;
  return Mutable;
}

const __SCNetworkInterface *isA_VPNService(const void *a1)
{
  CFTypeID TypeID;
  const __SCNetworkInterface *result;
  CFStringRef InterfaceType;

  TypeID = SCNetworkServiceGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
    return 0;
  result = SCNetworkServiceGetInterface((SCNetworkServiceRef)a1);
  if (result)
  {
    InterfaceType = SCNetworkInterfaceGetInterfaceType(result);
    return (const __SCNetworkInterface *)(CFEqual(InterfaceType, CFSTR("VPN")) != 0);
  }
  return result;
}

uint64_t VPNServiceSetAppRule(const void *a1, const void *a2, const __CFDictionary *a3)
{
  CFTypeID v6;
  SCNetworkInterfaceRef Interface;
  const __SCNetworkInterface *v8;
  const void *Value;
  const void *v10;
  const __CFDictionary *Configuration;
  CFTypeID TypeID;
  CFIndex app_rule;
  const __CFAllocator *v14;
  const __CFDictionary *MutableCopy;
  const __CFArray *v17;
  CFTypeID v18;
  CFMutableArrayRef Mutable;
  __CFArray *v20;
  __CFDictionary *v21;
  CFArrayRef theArray;

  if (isA_VPNService(a1)
    && (v6 = CFStringGetTypeID(), a2)
    && CFGetTypeID(a2) == v6
    && validate_app_rule(a3, 1)
    && (Interface = SCNetworkServiceGetInterface((SCNetworkServiceRef)a1)) != 0)
  {
    v8 = Interface;
    Value = CFDictionaryGetValue(a3, CFSTR("ExecutableMatch"));
    v10 = CFDictionaryGetValue(a3, CFSTR("DNSDomainMatch"));
    theArray = (CFArrayRef)CFDictionaryGetValue(a3, CFSTR("AccountIdentifierMatch"));
    Configuration = SCNetworkInterfaceGetConfiguration(v8);
    TypeID = CFDictionaryGetTypeID();
    if (Configuration && CFGetTypeID(Configuration) == TypeID)
    {
      app_rule = find_app_rule(Configuration, a2);
      v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, Configuration);
    }
    else
    {
      v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      MutableCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      app_rule = -1;
    }
    v17 = (const __CFArray *)CFDictionaryGetValue(MutableCopy, CFSTR("AppRules"));
    v18 = CFArrayGetTypeID();
    if (v17 && CFGetTypeID(v17) == v18)
      Mutable = CFArrayCreateMutableCopy(v14, 0, v17);
    else
      Mutable = CFArrayCreateMutable(v14, 0, MEMORY[0x1E0C9B378]);
    v20 = Mutable;
    v21 = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(v21, CFSTR("Identifier"), a2);
    if (Value && CFArrayGetCount((CFArrayRef)Value) >= 1)
      CFDictionarySetValue(v21, CFSTR("ExecutableMatch"), Value);
    if (v10 && CFArrayGetCount((CFArrayRef)v10) >= 1)
      CFDictionarySetValue(v21, CFSTR("DNSDomainMatch"), v10);
    if (theArray && CFArrayGetCount(theArray) >= 1)
      CFDictionarySetValue(v21, CFSTR("AccountIdentifierMatch"), theArray);
    if (app_rule < 0)
      CFArrayAppendValue(v20, v21);
    else
      CFArraySetValueAtIndex(v20, app_rule, v21);
    CFDictionarySetValue(MutableCopy, CFSTR("AppRules"), v20);
    SCNetworkInterfaceSetConfiguration(v8, MutableCopy);
    CFRelease(MutableCopy);
    CFRelease(v20);
    CFRelease(v21);
    return 1;
  }
  else
  {
    _SCErrorSet(1002);
    return 0;
  }
}

__SecTask *validate_app_rule(const void *a1, int a2)
{
  CFTypeID TypeID;
  const __CFArray *Value;
  CFTypeID v6;
  CFIndex Count;
  CFIndex v8;
  uint64_t v9;
  const __CFDictionary *ValueAtIndex;
  CFTypeID v11;
  const __CFString *v12;
  const __CFString *v13;
  CFTypeID v14;
  __SecTask *result;
  char v16;
  char v17;
  CFTypeID v18;
  __SecTask *v19;
  CFTypeRef v20;
  CFTypeID v21;
  _BOOL4 v22;
  const __CFArray *v23;
  CFTypeID v24;
  CFIndex v25;
  int v26;
  CFIndex v27;
  const void *v28;
  CFTypeID v29;
  const void *v30;
  const void *v31;
  CFTypeID v32;
  CFIndex v33;
  CFIndex v34;
  const void *v35;
  CFTypeID v36;
  BOOL v37;
  int v39;
  const __CFAllocator *allocator;
  int v41;

  TypeID = CFDictionaryGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID)
    return 0;
  Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("ExecutableMatch"));
  v6 = CFArrayGetTypeID();
  if (Value && CFGetTypeID(Value) == v6)
  {
    Count = CFArrayGetCount(Value);
    if (Count >= 1)
    {
      v8 = 0;
      v41 = 0;
      allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v9 = -1;
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v8);
        v11 = CFDictionaryGetTypeID();
        if (ValueAtIndex && CFGetTypeID(ValueAtIndex) == v11)
        {
          v12 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SigningIdentifier"));
          v13 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DesignatedRequirement"));
          v14 = CFStringGetTypeID();
          if (!v12 || CFGetTypeID(v12) != v14)
            return 0;
          result = (__SecTask *)CFStringGetLength(v12);
          if (!result)
            return result;
          if (a2 && CFStringHasPrefix(v12, CFSTR("com.apple.")))
          {
            v9 = 0;
            v16 = 1;
            do
            {
              v17 = v16;
              if (CFStringCompare(v12, *(&g_apple_app_exceptions + 2 * v9), 0) == kCFCompareEqualTo)
              {
                v41 = 1;
                goto LABEL_20;
              }
              v16 = 0;
              v9 = 1;
            }
            while ((v17 & 1) != 0);
            if (v41)
            {
              v41 = 1;
            }
            else
            {
              result = SecTaskCreateFromSelf(allocator);
              if (!result)
                return result;
              v19 = result;
              v20 = SecTaskCopyValueForEntitlement(result, CFSTR("com.apple.private.app-vpn-config"), 0);
              v21 = CFBooleanGetTypeID();
              if (!v20)
              {
                CFRelease(v19);
                return 0;
              }
              v22 = CFGetTypeID(v20) == v21 && CFBooleanGetValue((CFBooleanRef)v20) != 0;
              CFRelease(v20);
              CFRelease(v19);
              if (!v22)
                return 0;
              v41 = 0;
            }
            v9 = 2;
            if (v13)
            {
LABEL_21:
              v18 = CFStringGetTypeID();
              if (CFGetTypeID(v13) != v18)
                return 0;
              result = (__SecTask *)CFStringGetLength(v13);
              if (!result)
                return result;
            }
          }
          else
          {
LABEL_20:
            if (v13)
              goto LABEL_21;
          }
        }
        if (++v8 == Count)
        {
          Count = 1;
          v39 = v41;
          goto LABEL_36;
        }
      }
    }
  }
  else
  {
    Count = 0;
  }
  v39 = 0;
  v9 = -1;
LABEL_36:
  v23 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("AccountIdentifierMatch"));
  v24 = CFArrayGetTypeID();
  if (v23 && CFGetTypeID(v23) == v24)
  {
    v25 = CFArrayGetCount(v23);
    if (v25 >= 1)
    {
      v26 = v39;
      v27 = 0;
      while (1)
      {
        v28 = CFArrayGetValueAtIndex(v23, v27);
        v29 = CFStringGetTypeID();
        if (!v28 || CFGetTypeID(v28) != v29)
          return 0;
        if (v25 == ++v27)
        {
          v25 = 1;
          v39 = v26;
          break;
        }
      }
    }
  }
  else
  {
    v25 = 0;
  }
  if (!(v25 | Count))
    return 0;
  v30 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("DNSDomainMatch"));
  if (v30)
  {
    v31 = v30;
    v32 = CFArrayGetTypeID();
    if (CFGetTypeID(v31) != v32)
      return 0;
    v33 = CFArrayGetCount((CFArrayRef)v31);
    if (v33 >= 1)
    {
      v34 = 0;
      while (1)
      {
        v35 = CFArrayGetValueAtIndex((CFArrayRef)v31, v34);
        v36 = CFStringGetTypeID();
        if (!v35 || CFGetTypeID(v35) != v36)
          return 0;
        if (v33 == ++v34)
        {
          v33 = 1;
          break;
        }
      }
    }
  }
  else
  {
    v33 = 0;
  }
  if (v33)
    v37 = 1;
  else
    v37 = v39 == 0;
  return (__SecTask *)(v37 || v9 < 0);
}

uint64_t find_app_rule(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const __CFDictionary *ValueAtIndex;
  CFTypeID v9;
  const void *v10;

  Value = CFDictionaryGetValue(a1, CFSTR("AppRules"));
  TypeID = CFArrayGetTypeID();
  if (!Value)
    return -1;
  if (CFGetTypeID(Value) != TypeID)
    return -1;
  Count = CFArrayGetCount((CFArrayRef)Value);
  if (Count < 1)
    return -1;
  v6 = Count;
  v7 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)Value, v7);
    v9 = CFDictionaryGetTypeID();
    if (ValueAtIndex)
    {
      if (CFGetTypeID(ValueAtIndex) == v9)
      {
        v10 = CFDictionaryGetValue(ValueAtIndex, CFSTR("Identifier"));
        if (CFEqual(a2, v10))
          break;
      }
    }
    if (v6 == ++v7)
      return -1;
  }
  return v7;
}

CFTypeRef VPNServiceCopyAppRule(const void *a1, const void *a2)
{
  CFTypeID v4;
  const __SCNetworkInterface *Interface;
  const __CFDictionary *Configuration;
  CFTypeID TypeID;
  uint64_t app_rule;
  CFIndex v9;
  const __CFArray *Value;
  const void *ValueAtIndex;
  int v13;

  if (isA_VPNService(a1)
    && (v4 = CFStringGetTypeID(), a2)
    && CFGetTypeID(a2) == v4
    && (Interface = SCNetworkServiceGetInterface((SCNetworkServiceRef)a1)) != 0)
  {
    Configuration = SCNetworkInterfaceGetConfiguration(Interface);
    TypeID = CFDictionaryGetTypeID();
    if (Configuration && CFGetTypeID(Configuration) == TypeID)
    {
      app_rule = find_app_rule(Configuration, a2);
      if (app_rule < 0)
      {
        v13 = 1004;
        goto LABEL_11;
      }
      v9 = app_rule;
      Value = (const __CFArray *)CFDictionaryGetValue(Configuration, CFSTR("AppRules"));
      ValueAtIndex = CFArrayGetValueAtIndex(Value, v9);
      if (validate_app_rule(ValueAtIndex, 0))
        return CFRetain(ValueAtIndex);
    }
    v13 = 1001;
  }
  else
  {
    v13 = 1002;
  }
LABEL_11:
  _SCErrorSet(v13);
  return 0;
}

uint64_t VPNServiceRemoveAppRule(const void *a1, const void *a2)
{
  CFTypeID TypeID;
  const __SCNetworkInterface *Interface;
  const __SCNetworkInterface *v6;
  CFDictionaryRef Configuration;
  CFTypeID v8;
  uint64_t app_rule;
  CFIndex v10;
  const void *Value;
  CFTypeID v12;
  const __CFAllocator *v13;
  __CFDictionary *MutableCopy;
  __CFArray *v15;
  int v16;

  if (!isA_VPNService(a1)
    || (TypeID = CFStringGetTypeID(), !a2)
    || CFGetTypeID(a2) != TypeID
    || (Interface = SCNetworkServiceGetInterface((SCNetworkServiceRef)a1)) == 0)
  {
    v16 = 1002;
LABEL_13:
    _SCErrorSet(v16);
    return 0;
  }
  v6 = Interface;
  Configuration = SCNetworkInterfaceGetConfiguration(Interface);
  v8 = CFDictionaryGetTypeID();
  if (!Configuration || CFGetTypeID(Configuration) != v8)
    goto LABEL_14;
  app_rule = find_app_rule(Configuration, a2);
  if (app_rule < 0)
  {
    v16 = 1004;
    goto LABEL_13;
  }
  v10 = app_rule;
  Value = CFDictionaryGetValue(Configuration, CFSTR("AppRules"));
  v12 = CFArrayGetTypeID();
  if (!Value || CFGetTypeID(Value) != v12)
  {
LABEL_14:
    v16 = 1001;
    goto LABEL_13;
  }
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, Configuration);
  v15 = CFArrayCreateMutableCopy(v13, 0, (CFArrayRef)Value);
  CFArrayRemoveValueAtIndex(v15, v10);
  if (CFArrayGetCount(v15) < 1)
    CFDictionaryRemoveValue(MutableCopy, CFSTR("AppRules"));
  else
    CFDictionarySetValue(MutableCopy, CFSTR("AppRules"), v15);
  SCNetworkInterfaceSetConfiguration(v6, MutableCopy);
  CFRelease(MutableCopy);
  CFRelease(v15);
  return 1;
}

BOOL VPNServiceIsManagedAppVPN(const void *a1)
{
  const __CFDictionary *v1;
  CFTypeID TypeID;
  _BOOL8 v3;

  v1 = SCNetworkServiceCopyExternalID(a1, CFSTR("MCVPNUUID"));
  TypeID = CFStringGetTypeID();
  if (!v1)
    return 0;
  v3 = CFGetTypeID(v1) == TypeID;
  CFRelease(v1);
  return v3;
}

CFStringRef VPNAppLayerCopyMatchingService(_OWORD *a1, int a2, const unsigned __int8 *a3, const __CFString *a4, __CFString *a5, const __CFString *a6)
{
  __int128 v12;
  void *v13;
  CFStringRef v14;
  _BYTE v16[37];
  uuid_t uu;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!ne_session_app_vpn_configs_present())
    return 0;
  v12 = a1[1];
  *(_OWORD *)v16 = *a1;
  *(_OWORD *)&v16[16] = v12;
  v13 = (void *)copy_path_for_app(v16, a2, a3, a4, a5, a6);
  if (v13 && nw_path_is_flow_divert())
  {
    memset(uu, 0, sizeof(uu));
    uuid_clear(uu);
    v14 = 0;
    if (nw_path_get_vpn_config_id())
    {
      memset(v16, 0, sizeof(v16));
      uuid_unparse(uu, v16);
      v14 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v16, 0x600u);
    }
  }
  else
  {
    v14 = 0;
  }
  nw_release(v13);
  return v14;
}

uint64_t copy_path_for_app(_QWORD *a1, int a2, const unsigned __int8 *a3, const __CFString *a4, __CFString *host, const __CFString *a6)
{
  nw_parameters_t v12;
  CFIndex Length;
  char *v14;
  CFIndex v15;
  CFIndex v16;
  char *v17;
  CFIndex v18;
  CFIndex v19;
  char *v20;
  CFIndex v21;
  uint64_t evaluator_for_endpoint;
  void *v23;
  uint64_t v24;

  v12 = nw_parameters_create();
  if (a3 && !uuid_is_null(a3))
    nw_parameters_set_e_proc_uuid();
  if (a2)
    nw_parameters_set_pid();
  if (host)
  {
    Length = CFStringGetLength(host);
    v14 = (char *)malloc_type_malloc(Length + 1, 0x1015FBDEuLL);
    v15 = CFStringGetLength(host);
    if (CFStringGetCString(host, v14, v15 + 1, 0x600u))
    {
      host = (__CFString *)nw_endpoint_create_host(v14, "80");
      if (!v14)
        goto LABEL_10;
      goto LABEL_9;
    }
    host = 0;
    if (v14)
LABEL_9:
      free(v14);
  }
LABEL_10:
  if (a6)
  {
    v16 = CFStringGetLength(a6);
    v17 = (char *)malloc_type_malloc(v16 + 1, 0x63C7C1B7uLL);
    v18 = CFStringGetLength(a6);
    if (CFStringGetCString(a6, v17, v18 + 1, 0x600u))
      nw_parameters_set_account_id();
    if (v17)
      free(v17);
  }
  if (a4)
  {
    v19 = CFStringGetLength(a4);
    v20 = (char *)malloc_type_malloc(v19 + 1, 0x2417055BuLL);
    v21 = CFStringGetLength(a4);
    if (CFStringGetCString(a4, v20, v21 + 1, 0x600u))
      nw_parameters_set_effective_bundle_id();
    if (v20)
      free(v20);
  }
  if (*a1 | a1[1] | a1[2] | a1[3])
    nw_parameters_set_effective_audit_token();
  if (host || (host = (__CFString *)nw_endpoint_create_host("0.0.0.0", "0")) != 0)
  {
    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint();
    if (evaluator_for_endpoint)
    {
      v23 = (void *)evaluator_for_endpoint;
      v24 = nw_path_evaluator_copy_path();
      nw_release(v23);
    }
    else
    {
      v24 = 0;
    }
    nw_release(host);
  }
  else
  {
    v24 = 0;
  }
  nw_release(v12);
  return v24;
}

uint64_t _SCControlPrefsCreate(const char *a1, uint64_t a2, uint64_t a3)
{
  _QWORD v4[3];

  v4[2] = *MEMORY[0x1E0C80C00];
  v4[0] = a2;
  v4[1] = 0;
  return _SCControlPrefsCreateCommon(a1, (uint64_t)v4, a3);
}

uint64_t _SCControlPrefsCreateCommon(const char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t Instance;
  const __SCPreferences *prefs;
  const __SCPreferences *v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  int v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  int v35;
  const char *v36;
  dispatch_queue_global_t global_queue;
  CFRunLoopSourceContext *v38;
  __CFRunLoop *v39;
  __CFRunLoopSource *v40;
  SCPreferencesContext context;
  _QWORD v43[6];
  CFRunLoopSourceContext v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (__SCControlPrefsInitialize_initialized != -1)
    dispatch_once(&__SCControlPrefsInitialize_initialized, &__block_literal_global_19);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = strdup(a1);
    prefs = (const __SCPreferences *)get_prefs(Instance);
    if (prefs)
    {
      if (*(_QWORD *)a2)
      {
        v8 = prefs;
        context.version = 0;
        memset(&context.retain, 0, 24);
        context.info = (void *)Instance;
        *(_OWORD *)(Instance + 48) = *(_OWORD *)a2;
        *(_QWORD *)(Instance + 40) = a3;
        if (SCPreferencesSetCallback(prefs, (SCPreferencesCallBack)prefs_changed_sc, &context))
        {
          if (*(_BYTE *)(a2 + 8))
          {
            if (!SCPreferencesSetDispatchQueue(v8, *(dispatch_queue_t *)a2))
            {
              v9 = _SC_LOG_DEFAULT();
              v10 = _SC_syslog_os_log_mapping(5);
              if (__SC_log_enabled(5, v9, (os_log_type_t)v10))
                goto LABEL_15;
              goto LABEL_16;
            }
          }
          else
          {
            CFRetain(*(CFTypeRef *)a2);
            if (!SCPreferencesScheduleWithRunLoop(v8, *(CFRunLoopRef *)a2, (CFStringRef)*MEMORY[0x1E0C9B270]))
            {
              v9 = _SC_LOG_DEFAULT();
              v10 = _SC_syslog_os_log_mapping(5);
              if (__SC_log_enabled(5, v9, (os_log_type_t)v10))
              {
LABEL_15:
                v25 = _os_log_pack_size();
                v33 = (char *)&context
                    - ((MEMORY[0x1E0C80A78](v25, v26, v27, v28, v29, v30, v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0);
                __error();
                v34 = _os_log_pack_fill();
                v35 = SCError();
                v36 = SCErrorString(v35);
                *(_DWORD *)v34 = 136315138;
                *(_QWORD *)(v34 + 4) = v36;
                __SC_log_send(5, (uint64_t)v9, v10, v33);
              }
LABEL_16:
              SCPreferencesSetCallback(v8, 0, 0);
            }
          }
          if (*(_BYTE *)(Instance + 56))
          {
            global_queue = *(dispatch_queue_global_t *)(Instance + 48);
            v44.version = MEMORY[0x1E0C809B0];
            v44.info = (void *)0x40000000;
            v44.retain = (const void *(__cdecl *)(const void *))__enable_prefs_observer_block_invoke;
            v44.release = (void (__cdecl *)(const void *))&__block_descriptor_tmp_17;
            v44.copyDescription = (CFStringRef (__cdecl *)(const void *))Instance;
            v38 = &v44;
          }
          else
          {
            v44.version = 0;
            v44.info = (void *)Instance;
            v44.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C98BD0];
            v44.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C98BC0];
            memset(&v44.copyDescription, 0, 40);
            v44.perform = (void (__cdecl *)(void *))prefs_changed;
            v39 = *(__CFRunLoop **)(Instance + 48);
            v40 = CFRunLoopSourceCreate(0, 0, &v44);
            CFRunLoopAddSource(v39, v40, (CFRunLoopMode)*MEMORY[0x1E0C9B270]);
            global_queue = dispatch_get_global_queue(0, 0);
            v43[0] = MEMORY[0x1E0C809B0];
            v43[1] = 0x40000000;
            v43[2] = __enable_prefs_observer_block_invoke_2;
            v43[3] = &__block_descriptor_tmp_18;
            v43[4] = v40;
            v43[5] = v39;
            v38 = (CFRunLoopSourceContext *)v43;
          }
          _scprefs_observer_watch(2, *(char **)(Instance + 16), (uint64_t)global_queue, v38);
          return Instance;
        }
        v11 = _SC_LOG_DEFAULT();
        v12 = _SC_syslog_os_log_mapping(5);
        if (__SC_log_enabled(5, v11, (os_log_type_t)v12))
        {
          v13 = _os_log_pack_size();
          v21 = (char *)&context
              - ((MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18, v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0);
          __error();
          v22 = _os_log_pack_fill();
          v23 = SCError();
          v24 = SCErrorString(v23);
          *(_DWORD *)v22 = 136315138;
          *(_QWORD *)(v22 + 4) = v24;
          __SC_log_send(5, (uint64_t)v11, v12, v21);
        }
      }
    }
  }
  return Instance;
}

uint64_t _SCControlPrefsCreateWithQueue(const char *a1, uint64_t a2, uint64_t a3)
{
  _QWORD v4[3];

  v4[2] = *MEMORY[0x1E0C80C00];
  v4[0] = a2;
  v4[1] = 1;
  return _SCControlPrefsCreateCommon(a1, (uint64_t)v4, a3);
}

uint64_t _SCControlPrefsGetBoolean(uint64_t a1, CFStringRef key)
{
  const __SCPreferences *v4;
  const __CFString *v5;
  CFPropertyListRef Value;
  CFTypeID TypeID;
  const __SCPreferences *prefs;
  CFTypeID v9;
  uint64_t v10;

  v4 = *(const __SCPreferences **)(a1 + 32);
  if (v4
    || (v5 = CFStringCreateWithFormat(0, 0, CFSTR("%s%s"), "/Library/Managed Preferences/mobile/", *(_QWORD *)(a1 + 16)), *(_QWORD *)(a1 + 32) = make_prefs(v5), CFRelease(v5), (v4 = *(const __SCPreferences **)(a1 + 32)) != 0))
  {
    Value = SCPreferencesGetValue(v4, key);
    TypeID = CFBooleanGetTypeID();
    if (Value && CFGetTypeID(Value) == TypeID)
      goto LABEL_9;
    SCPreferencesSynchronize(v4);
  }
  prefs = (const __SCPreferences *)get_prefs(a1);
  if (!prefs)
    return 0;
  v4 = prefs;
  Value = SCPreferencesGetValue(prefs, key);
  v9 = CFBooleanGetTypeID();
  if (!Value || CFGetTypeID(Value) != v9)
  {
    v10 = 0;
    goto LABEL_11;
  }
LABEL_9:
  v10 = CFBooleanGetValue((CFBooleanRef)Value);
LABEL_11:
  SCPreferencesSynchronize(v4);
  return v10;
}

uint64_t get_prefs(uint64_t a1)
{
  uint64_t result;
  const __CFString *v3;

  result = *(_QWORD *)(a1 + 24);
  if (!result)
  {
    v3 = CFStringCreateWithCString(0, *(const char **)(a1 + 16), 0x8000100u);
    *(_QWORD *)(a1 + 24) = make_prefs(v3);
    CFRelease(v3);
    return *(_QWORD *)(a1 + 24);
  }
  return result;
}

uint64_t _SCControlPrefsSetBoolean(uint64_t a1, const __CFString *a2, int a3)
{
  const __SCPreferences *prefs;
  const __SCPreferences *v6;
  uint64_t v8;

  prefs = (const __SCPreferences *)get_prefs(a1);
  if (!prefs)
    return 0;
  v6 = prefs;
  if (a3)
    SCPreferencesSetValue(prefs, a2, (CFPropertyListRef)*MEMORY[0x1E0C9AE50]);
  else
    SCPreferencesRemoveValue(prefs, a2);
  v8 = SCPreferencesCommitChanges(v6);
  SCPreferencesSynchronize(v6);
  return v8;
}

uint64_t prefs_changed_sc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v3)(uint64_t);
  uint64_t result;

  v3 = *(uint64_t (**)(uint64_t))(a3 + 40);
  if (v3)
    return v3(a3);
  return result;
}

void __SCControlPrefsDeallocate(uint64_t a1)
{
  const __SCPreferences *v2;
  void *v3;
  const void *v4;
  const void *v5;

  if (*(_QWORD *)(a1 + 40) && *(_QWORD *)(a1 + 48))
  {
    v2 = *(const __SCPreferences **)(a1 + 24);
    if (*(_BYTE *)(a1 + 56))
    {
      SCPreferencesSetDispatchQueue(v2, 0);
    }
    else
    {
      SCPreferencesSetCallback(v2, 0, 0);
      SCPreferencesUnscheduleFromRunLoop(*(SCPreferencesRef *)(a1 + 24), *(CFRunLoopRef *)(a1 + 48), (CFStringRef)*MEMORY[0x1E0C9B270]);
      CFRelease(*(CFTypeRef *)(a1 + 48));
    }
  }
  v3 = *(void **)(a1 + 16);
  if (v3)
    free(v3);
  v4 = *(const void **)(a1 + 24);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 32);
  if (v5)
    CFRelease(v5);
}

__CFString *__SCControlPrefsCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  uint64_t v4;
  const char *v5;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<SCControlPrefs %p [%p]> {"), a1, v2);
  CFStringAppendFormat(Mutable, 0, CFSTR(" prefsPlist = %s"), *(_QWORD *)(a1 + 16));
  if (*(_QWORD *)(a1 + 24))
    CFStringAppendFormat(Mutable, 0, CFSTR(", prefs = %p"), *(_QWORD *)(a1 + 24));
  if (*(_QWORD *)(a1 + 32))
    CFStringAppendFormat(Mutable, 0, CFSTR(", prefs_managed = %p"), *(_QWORD *)(a1 + 32));
  if (*(_QWORD *)(a1 + 40))
    CFStringAppendFormat(Mutable, 0, CFSTR(", callback = %p"), *(_QWORD *)(a1 + 40));
  v4 = *(_QWORD *)(a1 + 48);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 56))
      v5 = "queue";
    else
      v5 = "runloop";
    CFStringAppendFormat(Mutable, 0, CFSTR(", %s = %p"), v5, v4);
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("}"));
  return Mutable;
}

uint64_t prefs_changed(uint64_t result)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(result + 40);
  if (v1)
    return v1();
  return result;
}

uint64_t __enable_prefs_observer_block_invoke(uint64_t a1)
{
  uint64_t result;
  uint64_t (*v2)(void);

  result = *(_QWORD *)(a1 + 32);
  v2 = *(uint64_t (**)(void))(result + 40);
  if (v2)
    return v2();
  return result;
}

void __enable_prefs_observer_block_invoke_2(uint64_t a1)
{
  CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 32));
  CFRunLoopWakeUp(*(CFRunLoopRef *)(a1 + 40));
}

uint64_t make_prefs(const __CFString *a1)
{
  __CFDictionary *Mutable;
  uint64_t v3;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, CFSTR("remove-when-empty"), (const void *)*MEMORY[0x1E0C9AE50]);
  v3 = SCPreferencesCreateWithOptions(0, CFSTR("_SCControlPrefs"), a1, 0, Mutable);
  CFRelease(Mutable);
  return v3;
}

uint64_t SCNetworkCategoryManagerGetTypeID()
{
  if (__SCNetworkCategoryManagerInitialize_initialized != -1)
    dispatch_once(&__SCNetworkCategoryManagerInitialize_initialized, &__block_literal_global_7_0);
  return __kSCNetworkCategoryManagerTypeID;
}

uint64_t SCNetworkCategoryManagerCreateWithInterface(const __CFString *a1, SCNetworkInterfaceRef interface, unsigned int a3, uint64_t a4)
{
  uint64_t Instance;
  int v6;
  CFStringRef BSDName;
  const __CFString *v9;
  NSObject *v10;
  uint64_t v11;
  _xpc_connection_s *v12;
  int v13;
  _QWORD v15[6];

  Instance = 0;
  v15[5] = *MEMORY[0x1E0C80C00];
  v6 = 1002;
  if (a3 <= 1 && !a4)
  {
    Instance = 0;
    if (a1)
    {
      if (interface)
      {
        BSDName = SCNetworkInterfaceGetBSDName(interface);
        if (!BSDName)
          goto LABEL_17;
        v9 = BSDName;
        if (__SCNetworkCategoryManagerInitialize_initialized != -1)
          dispatch_once(&__SCNetworkCategoryManagerInitialize_initialized, &__block_literal_global_7_0);
        Instance = _CFRuntimeCreateInstance();
        if (Instance)
        {
          *(_QWORD *)(Instance + 16) = CFStringCreateCopy(0, a1);
          *(_DWORD *)(Instance + 32) = a3;
          *(_QWORD *)(Instance + 24) = CFStringCreateCopy(0, v9);
        }
        v10 = dispatch_queue_create("SCNetworkCategoryManager", 0);
        v11 = MEMORY[0x1E0C809B0];
        *(_QWORD *)(Instance + 56) = v10;
        v15[0] = v11;
        v15[1] = 0x40000000;
        v15[2] = __SCNetworkCategoryManagerCreateWithInterface_block_invoke;
        v15[3] = &__block_descriptor_tmp_22;
        v15[4] = Instance;
        v12 = CategoryManagerConnectionCreate(v10, (uint64_t)v15);
        *(_QWORD *)(Instance + 48) = v12;
        if (!v12)
        {
          CFRelease((CFTypeRef)Instance);
          goto LABEL_17;
        }
        v6 = CategoryManagerConnectionRegister(v12, *(const __CFString **)(Instance + 16), *(const __CFString **)(Instance + 24), *(_DWORD *)(Instance + 32));
        if (v6)
        {
          v13 = v6;
          CFRelease((CFTypeRef)Instance);
          if (v13 == 1)
          {
            Instance = 0;
            v6 = 1003;
            goto LABEL_18;
          }
          if (v13 == 2)
          {
            Instance = 0;
            v6 = 2002;
            goto LABEL_18;
          }
          if (v13 != 22)
          {
            Instance = 0;
            v6 = 1001;
            goto LABEL_18;
          }
LABEL_17:
          Instance = 0;
          v6 = 1002;
        }
      }
    }
  }
LABEL_18:
  _SCErrorSet(v6);
  return Instance;
}

void SCNetworkCategoryManagerDeliverNotification(uint64_t a1)
{
  CFStringRef v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  NSObject *global_queue;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  _QWORD block[6];
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  v2 = CategoryManagerConnectionCopyActiveValue(*(_xpc_connection_s **)(a1 + 48), &v31);
  v3 = _SC_LOG_DEFAULT();
  v4 = _SC_syslog_os_log_mapping(5);
  if (__SC_log_enabled(5, v3, (os_log_type_t)v4))
  {
    v5 = _os_log_pack_size();
    v13 = (char *)block - ((MEMORY[0x1E0C80A78](v5, v6, v7, v8, v9, v10, v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0);
    __error();
    v14 = _os_log_pack_fill();
    v15 = v31;
    *(_DWORD *)v14 = 136315650;
    *(_QWORD *)(v14 + 4) = "SCNetworkCategoryManagerDeliverNotification";
    *(_WORD *)(v14 + 12) = 2112;
    *(_QWORD *)(v14 + 14) = v2;
    *(_WORD *)(v14 + 22) = 1024;
    *(_DWORD *)(v14 + 24) = v15;
    __SC_log_send(5, (uint64_t)v3, v4, v13);
  }
  v16 = *(_QWORD *)(a1 + 64);
  if (v16)
  {
    global_queue = *(NSObject **)(a1 + 72);
    if (!global_queue)
      global_queue = dispatch_get_global_queue(0, 0);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SCNetworkCategoryManagerDeliverNotification_block_invoke;
    block[3] = &unk_1E25D2260;
    block[4] = v16;
    block[5] = v2;
    dispatch_async(global_queue, block);
  }
  else
  {
    v18 = _SC_LOG_DEFAULT();
    v19 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v18, (os_log_type_t)v19))
    {
      v20 = _os_log_pack_size();
      v28 = (char *)block - ((MEMORY[0x1E0C80A78](v20, v21, v22, v23, v24, v25, v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      v29 = _os_log_pack_fill();
      *(_DWORD *)v29 = 136315138;
      *(_QWORD *)(v29 + 4) = "SCNetworkCategoryManagerDeliverNotification";
      __SC_log_send(5, (uint64_t)v18, v19, v28);
    }
    if (v2)
      CFRelease(v2);
  }
}

void SCNetworkCategoryManagerSetNotifyHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[8];

  v3[7] = *MEMORY[0x1E0C80C00];
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __SCNetworkCategoryManagerSetNotifyHandler_block_invoke;
  v3[3] = &unk_1E25D21B0;
  v3[5] = a2;
  v3[6] = a1;
  v3[4] = a3;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 56), v3);
}

BOOL SCNetworkCategoryManagerActivateValue(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  _BOOL8 v7;
  _QWORD v9[7];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __SCNetworkCategoryManagerActivateValue_block_invoke;
  v9[3] = &unk_1E25D21D8;
  v9[4] = &v10;
  v9[5] = a1;
  v9[6] = a2;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 56), v9);
  v2 = *((_DWORD *)v11 + 6);
  if (v2 == 22)
    v3 = 1002;
  else
    v3 = 1001;
  if (v2 == 2)
    v4 = 2002;
  else
    v4 = v3;
  if (v2 == 1)
    v5 = 1003;
  else
    v5 = 1001;
  if (!v2)
    v5 = 0;
  if (v2 <= 1)
    v6 = v5;
  else
    v6 = v4;
  _SCErrorSet(v6);
  v7 = *((_DWORD *)v11 + 6) == 0;
  _Block_object_dispose(&v10, 8);
  return v7;
}

_xpc_connection_s *__SCNetworkCategoryManagerCopyActiveValueNoSession(const __CFString *a1, SCNetworkInterfaceRef interface)
{
  _xpc_connection_s *result;
  const __CFString *v5;
  int v6;
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v7 = 0;
  if (__SCNetworkCategoryManagerCopyActiveValueNoSession_initialized != -1)
    dispatch_once(&__SCNetworkCategoryManagerCopyActiveValueNoSession_initialized, &__block_literal_global_20);
  result = (_xpc_connection_s *)__SCNetworkCategoryManagerCopyActiveValueNoSession_connection;
  if (__SCNetworkCategoryManagerCopyActiveValueNoSession_connection)
  {
    if (interface)
    {
      result = (_xpc_connection_s *)SCNetworkInterfaceGetBSDName(interface);
      if (!result)
        return result;
      v5 = (const __CFString *)result;
      result = (_xpc_connection_s *)__SCNetworkCategoryManagerCopyActiveValueNoSession_connection;
    }
    else
    {
      v5 = 0;
    }
    result = (_xpc_connection_s *)CategoryManagerConnectionCopyActiveValueNoSession(result, a1, v5, &v7);
    if (!result)
    {
      v6 = 1001;
      if (v7 > 1)
      {
        if (v7 == 2)
        {
          v6 = 2002;
        }
        else if (v7 == 22)
        {
          v6 = 1002;
        }
      }
      else if (v7)
      {
        if (v7 == 1)
          v6 = 1003;
      }
      else
      {
        v6 = 0;
      }
      _SCErrorSet(v6);
      return 0;
    }
  }
  return result;
}

void __SCNetworkCategoryManagerDeallocate(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  void *v5;
  NSObject *v6;
  NSObject *v7;
  const void *v8;

  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  v5 = (void *)a1[6];
  if (v5)
  {
    xpc_release(v5);
    a1[6] = 0;
  }
  v6 = a1[7];
  if (v6)
  {
    dispatch_release(v6);
    a1[7] = 0;
  }
  v7 = a1[9];
  if (v7)
  {
    dispatch_release(v7);
    a1[9] = 0;
  }
  v8 = (const void *)a1[8];
  if (v8)
  {
    _Block_release(v8);
    a1[8] = 0;
  }
}

uint64_t __SCNetworkCategoryManagerEqual(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  uint64_t result;

  if (a1 == a2)
    return 1;
  if (*(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 32))
    return 0;
  v4 = *(const void **)(a1 + 24);
  v5 = *(const void **)(a2 + 24);
  if (v4 == v5)
    return CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  result = 0;
  if (v4)
  {
    if (v5)
    {
      result = CFEqual(*(CFTypeRef *)(a1 + 24), v5);
      if ((_DWORD)result)
        return CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
    }
  }
  return result;
}

CFHashCode __SCNetworkCategoryManagerHash(uint64_t a1)
{
  CFHashCode v2;
  const void *v3;

  v2 = CFHash(*(CFTypeRef *)(a1 + 16));
  v3 = *(const void **)(a1 + 24);
  if (v3)
    v2 ^= CFHash(v3);
  return v2;
}

__CFString *__SCNetworkCategoryManagerCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<%s %p [%p]> { ID = %@, ifname = %@, flags = 0x%x }"), "SCNetworkCategoryManager", a1, v2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(unsigned int *)(a1 + 32));
  return Mutable;
}

uint64_t IPMonitorControlCreate()
{
  uint64_t Instance;
  NSObject *v1;
  _xpc_connection_s *mach_service;
  _QWORD v4[6];

  v4[5] = *MEMORY[0x1E0C80C00];
  if (__IPMonitorControlRegisterClass_once != -1)
    dispatch_once(&__IPMonitorControlRegisterClass_once, &__block_literal_global_21);
  Instance = _CFRuntimeCreateInstance();
  v1 = dispatch_queue_create("IPMonitorControl", 0);
  mach_service = xpc_connection_create_mach_service("com.apple.SystemConfiguration.IPMonitorControl", v1, 2uLL);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __IPMonitorControlCreate_block_invoke;
  v4[3] = &__block_descriptor_tmp_23;
  v4[4] = Instance;
  xpc_connection_set_event_handler(mach_service, v4);
  *(_QWORD *)(Instance + 16) = v1;
  *(_QWORD *)(Instance + 24) = mach_service;
  xpc_connection_resume(mach_service);
  return Instance;
}

BOOL IPMonitorControlHandleResponse(void *a1, int a2, char *a3)
{
  uint64_t v6;
  const char *string;
  NSObject *v8;
  uint64_t v9;
  _BOOL8 result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  int64_t int64;
  _QWORD v43[2];

  v43[1] = *MEMORY[0x1E0C80C00];
  v6 = MEMORY[0x18D78D248]();
  if (v6 == MEMORY[0x1E0C812F8])
  {
    if (a2)
    {
      v22 = _SC_LOG_DEFAULT();
      v23 = _SC_syslog_os_log_mapping(5);
      result = __SC_log_enabled(5, v22, (os_log_type_t)v23);
      if (result)
      {
        v24 = _os_log_pack_size();
        v32 = (char *)v43 - ((MEMORY[0x1E0C80A78](v24, v25, v26, v27, v28, v29, v30, v31) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        *(_WORD *)_os_log_pack_fill() = 0;
        __SC_log_send(5, (uint64_t)v22, v23, v32);
LABEL_12:
        result = 0;
        goto LABEL_13;
      }
      goto LABEL_13;
    }
    int64 = xpc_dictionary_get_int64(a1, "Error");
    v41 = 0;
    result = int64 == 0;
  }
  else
  {
    string = (const char *)v6;
    if (v6 != MEMORY[0x1E0C81310])
    {
      v8 = _SC_LOG_DEFAULT();
      v9 = _SC_syslog_os_log_mapping(5);
      result = __SC_log_enabled(5, v8, (os_log_type_t)v9);
      if (result)
      {
        v11 = _os_log_pack_size();
        v19 = (char *)v43 - ((MEMORY[0x1E0C80A78](v11, v12, v13, v14, v15, v16, v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v20 = _os_log_pack_fill();
        v21 = 134217984;
LABEL_11:
        *(_DWORD *)v20 = v21;
        *(_QWORD *)(v20 + 4) = string;
        __SC_log_send(5, (uint64_t)v8, v9, v19);
        goto LABEL_12;
      }
      goto LABEL_13;
    }
    if (a1 != (void *)MEMORY[0x1E0C81258])
    {
      string = xpc_dictionary_get_string(a1, (const char *)*MEMORY[0x1E0C81270]);
      v8 = _SC_LOG_DEFAULT();
      v9 = _SC_syslog_os_log_mapping(5);
      result = __SC_log_enabled(5, v8, (os_log_type_t)v9);
      if (result)
      {
        v33 = _os_log_pack_size();
        v19 = (char *)v43 - ((MEMORY[0x1E0C80A78](v33, v34, v35, v36, v37, v38, v39, v40) + 15) & 0xFFFFFFFFFFFFFFF0);
        __error();
        v20 = _os_log_pack_fill();
        v21 = 136315138;
        goto LABEL_11;
      }
LABEL_13:
      v41 = 0;
      goto LABEL_14;
    }
    result = 0;
    v41 = 1;
  }
LABEL_14:
  if (a3)
    *a3 = v41;
  return result;
}

void ApplyInterfaceRank(const __CFString *a1, const __CFNumber *a2, _xpc_connection_s *a3)
{
  xpc_object_t request_dictionary;
  unsigned int valuePtr;
  char buffer[16];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  if (CFStringGetCString(a1, buffer, 16, 0x8000100u))
  {
    if (CFNumberGetValue(a2, kCFNumberSInt32Type, &valuePtr))
    {
      request_dictionary = create_request_dictionary();
      xpc_dictionary_set_int64(request_dictionary, "Type", 1);
      xpc_dictionary_set_string(request_dictionary, "InterfaceName", buffer);
      xpc_dictionary_set_int64(request_dictionary, "PrimaryRank", valuePtr);
      xpc_connection_send_message(a3, request_dictionary);
      xpc_release(request_dictionary);
    }
  }
}

void ApplyInterfaceAdvisory(const __CFString *a1, const __CFNumber *a2, _xpc_connection_s *a3)
{
  xpc_object_t request_dictionary;
  unsigned int valuePtr;
  char buffer[16];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  if (CFStringGetCString(a1, buffer, 16, 0x8000100u))
  {
    if (CFNumberGetValue(a2, kCFNumberSInt32Type, &valuePtr))
    {
      request_dictionary = create_request_dictionary();
      xpc_dictionary_set_int64(request_dictionary, "Type", 3);
      xpc_dictionary_set_string(request_dictionary, "InterfaceName", buffer);
      xpc_dictionary_set_int64(request_dictionary, "Advisory", valuePtr);
      xpc_connection_send_message(a3, request_dictionary);
      xpc_release(request_dictionary);
    }
  }
}

uint64_t IPMonitorControlSetInterfacePrimaryRank(_QWORD *a1, CFStringRef theString, unsigned int a3)
{
  uint64_t result;
  xpc_object_t request_dictionary;
  xpc_object_t v8;
  NSObject *v9;
  _QWORD v10[6];
  unsigned int v11;
  char buffer[16];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  result = CFStringGetCString(theString, buffer, 16, 0x8000100u);
  if ((_DWORD)result)
  {
    request_dictionary = create_request_dictionary();
    xpc_dictionary_set_int64(request_dictionary, "Type", 1);
    xpc_dictionary_set_string(request_dictionary, "InterfaceName", buffer);
    xpc_dictionary_set_int64(request_dictionary, "PrimaryRank", a3);
    v8 = IPMonitorControlSendRequest((uint64_t)a1, request_dictionary);
    xpc_release(request_dictionary);
    if (v8)
    {
      xpc_release(v8);
      CFRetain(theString);
      CFRetain(a1);
      v9 = a1[2];
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 0x40000000;
      v10[2] = __IPMonitorControlSetInterfacePrimaryRank_block_invoke;
      v10[3] = &__block_descriptor_tmp_7_1;
      v10[4] = a1;
      v10[5] = theString;
      v11 = a3;
      dispatch_async(v9, v10);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

xpc_object_t create_request_dictionary()
{
  xpc_object_t v0;
  const char *v1;

  v0 = xpc_dictionary_create(0, 0, 0);
  v1 = getprogname();
  if (v1)
    xpc_dictionary_set_string(v0, "ProcessName", v1);
  return v0;
}

xpc_object_t IPMonitorControlSendRequest(uint64_t a1, void *a2)
{
  xpc_object_t v4;
  xpc_object_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  HIBYTE(v18) = 0;
  v4 = xpc_connection_send_message_with_reply_sync(*(xpc_connection_t *)(a1 + 24), a2);
  if (v4)
  {
    v5 = v4;
    while (!IPMonitorControlHandleResponse(v5, 0, (char *)&v18 + 7))
    {
      xpc_release(v5);
      if (!HIBYTE(v18))
      {
        v6 = _SC_LOG_DEFAULT();
        v7 = _SC_syslog_os_log_mapping(5);
        if (!__SC_log_enabled(5, v6, (os_log_type_t)v7))
          return 0;
        goto LABEL_9;
      }
      HIBYTE(v18) = 0;
      v5 = xpc_connection_send_message_with_reply_sync(*(xpc_connection_t *)(a1 + 24), a2);
      if (!v5)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v6 = _SC_LOG_DEFAULT();
    v7 = _SC_syslog_os_log_mapping(5);
    if (__SC_log_enabled(5, v6, (os_log_type_t)v7))
    {
LABEL_9:
      v8 = _os_log_pack_size();
      v16 = (char *)&v18 - ((MEMORY[0x1E0C80A78](v8, v9, v10, v11, v12, v13, v14, v15) + 15) & 0xFFFFFFFFFFFFFFF0);
      __error();
      *(_WORD *)_os_log_pack_fill() = 0;
      __SC_log_send(5, (uint64_t)v6, v7, v16);
    }
    return 0;
  }
  return v5;
}

int64_t IPMonitorControlGetInterfacePrimaryRank(uint64_t a1, CFStringRef theString)
{
  xpc_object_t request_dictionary;
  xpc_object_t v4;
  void *v5;
  int64_t int64;
  char buffer[16];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (!CFStringGetCString(theString, buffer, 16, 0x8000100u))
    return 0;
  request_dictionary = create_request_dictionary();
  xpc_dictionary_set_int64(request_dictionary, "Type", 2);
  xpc_dictionary_set_string(request_dictionary, "InterfaceName", buffer);
  v4 = IPMonitorControlSendRequest(a1, request_dictionary);
  if (v4)
  {
    v5 = v4;
    int64 = xpc_dictionary_get_int64(v4, "PrimaryRank");
    xpc_release(v5);
  }
  else
  {
    int64 = 0;
  }
  xpc_release(request_dictionary);
  return int64;
}

CFStringRef IPMonitorControlCopyInterfaceRankAssertionNotificationKey(CFStringRef ifname)
{
  return SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, CFSTR("State:"), ifname, CFSTR("RankAssertion"));
}

uint64_t InterfaceRankAssertionInfoGetPrimaryRank(const __CFDictionary *a1)
{
  return cfdict_get_number(a1, CFSTR("PrimaryRank"));
}

uint64_t cfdict_get_number(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  CFTypeID TypeID;
  _QWORD v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  v5[0] = 0;
  Value = CFDictionaryGetValue(a1, a2);
  TypeID = CFNumberGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID)
    return 0;
  CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt64Type, v5);
  return v5[0];
}

uint64_t InterfaceRankAssertionInfoGetProcessID(const __CFDictionary *a1)
{
  return cfdict_get_number(a1, CFSTR("ProcessID"));
}

const void *InterfaceRankAssertionInfoGetProcessName(const __CFDictionary *a1)
{
  return CFDictionaryGetValue(a1, CFSTR("ProcessName"));
}

uint64_t IPMonitorControlCopyInterfaceRankAssertionInfo(uint64_t a1, const __CFString *a2)
{
  return CopyAssertionOrAdvisoryInfo(a1, a2, 6u, "RankAssertionInfo");
}

uint64_t CopyAssertionOrAdvisoryInfo(uint64_t a1, CFStringRef theString, unsigned int a3, const char *a4)
{
  xpc_object_t request_dictionary;
  xpc_object_t v8;
  void *v9;
  uint64_t v10;
  char buffer[16];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!CFStringGetCString(theString, buffer, 16, 0x8000100u))
    return 0;
  request_dictionary = create_request_dictionary();
  xpc_dictionary_set_int64(request_dictionary, "Type", a3);
  xpc_dictionary_set_string(request_dictionary, "InterfaceName", buffer);
  v8 = IPMonitorControlSendRequest(a1, request_dictionary);
  if (v8)
  {
    v9 = v8;
    if (xpc_dictionary_get_value(v8, a4))
      v10 = _CFXPCCreateCFObjectFromXPCObject();
    else
      v10 = 0;
    xpc_release(v9);
  }
  else
  {
    v10 = 0;
  }
  xpc_release(request_dictionary);
  return v10;
}

uint64_t IPMonitorControlCopyInterfaceRankAssertionInterfaceNames(uint64_t a1)
{
  return CopyInterfaceNames(a1, 8u);
}

uint64_t CopyInterfaceNames(uint64_t a1, unsigned int a2)
{
  xpc_object_t request_dictionary;
  xpc_object_t v5;
  void *v6;
  uint64_t v7;

  request_dictionary = create_request_dictionary();
  xpc_dictionary_set_int64(request_dictionary, "Type", a2);
  v5 = IPMonitorControlSendRequest(a1, request_dictionary);
  if (v5)
  {
    v6 = v5;
    if (xpc_dictionary_get_value(v5, "InterfaceNames"))
      v7 = _CFXPCCreateCFObjectFromXPCObject();
    else
      v7 = 0;
    xpc_release(v6);
  }
  else
  {
    v7 = 0;
  }
  xpc_release(request_dictionary);
  return v7;
}

uint64_t IPMonitorControlSetInterfaceAdvisory(_QWORD *a1, CFStringRef theString, unsigned int a3, const __CFString *a4)
{
  uint64_t result;
  UInt8 *v9;
  xpc_object_t request_dictionary;
  xpc_object_t v11;
  NSObject *v12;
  _QWORD v13[6];
  unsigned int v14;
  char buffer[16];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  result = CFStringGetCString(theString, buffer, 16, 0x8000100u);
  if ((_DWORD)result)
  {
    if (a4)
      v9 = _SC_cfstring_to_cstring(a4, 0, 0, 0x8000100u);
    else
      v9 = 0;
    request_dictionary = create_request_dictionary();
    xpc_dictionary_set_int64(request_dictionary, "Type", 3);
    xpc_dictionary_set_string(request_dictionary, "InterfaceName", buffer);
    xpc_dictionary_set_int64(request_dictionary, "Advisory", a3);
    if (v9)
    {
      xpc_dictionary_set_string(request_dictionary, "Reason", (const char *)v9);
      CFAllocatorDeallocate(0, v9);
    }
    v11 = IPMonitorControlSendRequest((uint64_t)a1, request_dictionary);
    xpc_release(request_dictionary);
    if (v11)
    {
      xpc_release(v11);
      CFRetain(theString);
      CFRetain(a1);
      v12 = a1[2];
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 0x40000000;
      v13[2] = __IPMonitorControlSetInterfaceAdvisory_block_invoke;
      v13[3] = &__block_descriptor_tmp_16;
      v13[4] = a1;
      v13[5] = theString;
      v14 = a3;
      dispatch_async(v12, v13);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL IPMonitorControlIsInterfaceAdvisorySet(uint64_t a1, CFStringRef theString, unsigned int a3)
{
  xpc_object_t request_dictionary;
  xpc_object_t v6;
  _BOOL8 v7;
  char buffer[16];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!CFStringGetCString(theString, buffer, 16, 0x8000100u))
    return 0;
  request_dictionary = create_request_dictionary();
  xpc_dictionary_set_int64(request_dictionary, "Type", 4);
  xpc_dictionary_set_string(request_dictionary, "InterfaceName", buffer);
  if (a3)
    xpc_dictionary_set_int64(request_dictionary, "Advisory", a3);
  v6 = IPMonitorControlSendRequest(a1, request_dictionary);
  xpc_release(request_dictionary);
  if (!v6)
    return 0;
  v7 = xpc_dictionary_get_BOOL(v6, "AdvisoryIsSet");
  xpc_release(v6);
  return v7;
}

BOOL IPMonitorControlAnyInterfaceAdvisoryIsSet(uint64_t a1)
{
  xpc_object_t request_dictionary;
  xpc_object_t v3;
  _BOOL8 v4;

  request_dictionary = create_request_dictionary();
  xpc_dictionary_set_int64(request_dictionary, "Type", 5);
  v3 = IPMonitorControlSendRequest(a1, request_dictionary);
  xpc_release(request_dictionary);
  if (!v3)
    return 0;
  v4 = xpc_dictionary_get_BOOL(v3, "AdvisoryIsSet");
  xpc_release(v3);
  return v4;
}

CFStringRef IPMonitorControlCopyInterfaceAdvisoryNotificationKey(CFStringRef ifname)
{
  return SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, CFSTR("State:"), ifname, CFSTR("Advisory"));
}

uint64_t InterfaceAdvisoryInfoGetAdvisory(const __CFDictionary *a1)
{
  return cfdict_get_number(a1, CFSTR("Advisory"));
}

uint64_t IPMonitorControlCopyInterfaceAdvisoryInfo(uint64_t a1, const __CFString *a2)
{
  return CopyAssertionOrAdvisoryInfo(a1, a2, 7u, "AdvisoryInfo");
}

uint64_t IPMonitorControlCopyInterfaceAdvisoryInterfaceNames(uint64_t a1)
{
  return CopyInterfaceNames(a1, 9u);
}

void __IPMonitorControlDeallocate(_QWORD *a1)
{
  void *v2;
  NSObject *v3;
  const void *v4;
  const void *v5;

  v2 = (void *)a1[3];
  if (v2)
    xpc_release(v2);
  v3 = a1[2];
  if (v3)
    dispatch_release(v3);
  v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  v5 = (const void *)a1[4];
  if (v5)
  {
    CFRelease(v5);
    a1[4] = 0;
  }
}

CFStringRef __IPMonitorControlCopyDebugDesc(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<IPMonitorControl %p>"), a1);
}

uint64_t configlist(mach_port_t a1, uint64_t a2, unsigned int a3, unsigned int a4, _QWORD *a5, unsigned int *a6, _DWORD *a7)
{
  mach_port_t special_reply_port;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  mach_msg_header_t msg;
  int v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  msg.msgh_id = 0;
  v21 = 0;
  v22 = 0u;
  *(_OWORD *)&msg.msgh_size = 0u;
  v17 = 1;
  v18 = a2;
  v19 = 16777472;
  v20 = a3;
  v21 = *MEMORY[0x1E0C804E8];
  *(_QWORD *)&v22 = __PAIR64__(a4, a3);
  special_reply_port = mig_get_special_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  msg.msgh_bits = -2147478253;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4E2800000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v12 = mach_msg(&msg, 3162115, 0x3Cu, 0x44u, special_reply_port, 0, 0);
  v13 = v12;
  if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v12)
    {
      if (msg.msgh_id == 71)
      {
        v13 = 4294966988;
      }
      else if (msg.msgh_id == 20108)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 36)
          {
            v13 = 4294966996;
            if (HIDWORD(v18))
            {
              if (msg.msgh_remote_port)
                v13 = 4294966996;
              else
                v13 = HIDWORD(v18);
            }
          }
          else
          {
            v13 = 4294966996;
          }
          goto LABEL_24;
        }
        v13 = 4294966996;
        if (v17 == 1 && msg.msgh_size == 60 && !msg.msgh_remote_port && HIBYTE(v19) == 1)
        {
          v14 = v20;
          if (v20 == (_DWORD)v22)
          {
            v13 = 0;
            *a5 = v18;
            *a6 = v14;
            *a7 = DWORD1(v22);
            return v13;
          }
        }
      }
      else
      {
        v13 = 4294966995;
      }
LABEL_24:
      mach_msg_destroy(&msg);
      return v13;
    }
    mig_dealloc_special_reply_port();
  }
  return v13;
}

uint64_t configadd(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int *a6, _DWORD *a7)
{
  mach_port_t special_reply_port;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  int v15;
  mach_msg_header_t msg;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v17 = 2;
  v18 = a2;
  v19 = 16777472;
  v20 = a3;
  v21 = a4;
  v22 = 16777472;
  v23 = a5;
  v24 = *MEMORY[0x1E0C804E8];
  v25 = a3;
  v26 = a5;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4E2900000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v11 = mach_msg(&msg, 3162115, 0x4Cu, 0x34u, special_reply_port, 0, 0);
  v12 = v11;
  if ((v11 - 268435458) > 0xE || ((1 << (v11 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v11)
    {
      if (msg.msgh_id == 71)
      {
        v12 = 4294966988;
      }
      else if (msg.msgh_id == 20109)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 44)
          {
            if (!msg.msgh_remote_port)
            {
              v12 = HIDWORD(v18);
              if (!HIDWORD(v18))
              {
                v15 = v20;
                *a6 = v19;
                *a7 = v15;
                return v12;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v13 = 1;
            else
              v13 = HIDWORD(v18) == 0;
            if (v13)
              v12 = 4294966996;
            else
              v12 = HIDWORD(v18);
            goto LABEL_22;
          }
        }
        v12 = 4294966996;
      }
      else
      {
        v12 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v12;
    }
    mig_dealloc_special_reply_port();
  }
  return v12;
}

uint64_t configremove(mach_port_t a1, uint64_t a2, int a3, int *a4)
{
  mach_port_t special_reply_port;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  mach_msg_header_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v12 = 1;
  v13 = a2;
  v14 = 16777472;
  v15 = a3;
  v16 = *MEMORY[0x1E0C804E8];
  v17 = a3;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&v11.msgh_bits = 2147489043;
  v11.msgh_remote_port = a1;
  v11.msgh_local_port = special_reply_port;
  *(_QWORD *)&v11.msgh_voucher_port = 0x4E2C00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&v11);
    special_reply_port = v11.msgh_local_port;
  }
  v7 = mach_msg(&v11, 3162115, 0x38u, 0x30u, special_reply_port, 0, 0);
  v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v7)
    {
      if (v11.msgh_id == 71)
      {
        v8 = 4294966988;
      }
      else if (v11.msgh_id == 20112)
      {
        if ((v11.msgh_bits & 0x80000000) == 0)
        {
          if (v11.msgh_size == 40)
          {
            if (!v11.msgh_remote_port)
            {
              v8 = HIDWORD(v13);
              if (!HIDWORD(v13))
              {
                *a4 = v14;
                return v8;
              }
              goto LABEL_22;
            }
          }
          else if (v11.msgh_size == 36)
          {
            if (v11.msgh_remote_port)
              v9 = 1;
            else
              v9 = HIDWORD(v13) == 0;
            if (v9)
              v8 = 4294966996;
            else
              v8 = HIDWORD(v13);
            goto LABEL_22;
          }
        }
        v8 = 4294966996;
      }
      else
      {
        v8 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&v11);
      return v8;
    }
    mig_dealloc_special_reply_port();
  }
  return v8;
}

uint64_t configadd_s(mach_port_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int *a6, _DWORD *a7)
{
  mach_port_t special_reply_port;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  int v15;
  mach_msg_header_t msg;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v17 = 2;
  v18 = a2;
  v19 = 16777472;
  v20 = a3;
  v21 = a4;
  v22 = 16777472;
  v23 = a5;
  v24 = *MEMORY[0x1E0C804E8];
  v25 = a3;
  v26 = a5;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4E2E00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v11 = mach_msg(&msg, 3162115, 0x4Cu, 0x34u, special_reply_port, 0, 0);
  v12 = v11;
  if ((v11 - 268435458) > 0xE || ((1 << (v11 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v11)
    {
      if (msg.msgh_id == 71)
      {
        v12 = 4294966988;
      }
      else if (msg.msgh_id == 20114)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 44)
          {
            if (!msg.msgh_remote_port)
            {
              v12 = HIDWORD(v18);
              if (!HIDWORD(v18))
              {
                v15 = v20;
                *a6 = v19;
                *a7 = v15;
                return v12;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v13 = 1;
            else
              v13 = HIDWORD(v18) == 0;
            if (v13)
              v12 = 4294966996;
            else
              v12 = HIDWORD(v18);
            goto LABEL_22;
          }
        }
        v12 = 4294966996;
      }
      else
      {
        v12 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v12;
    }
    mig_dealloc_special_reply_port();
  }
  return v12;
}

uint64_t confignotify(mach_port_t a1, uint64_t a2, int a3, int *a4)
{
  mach_port_t special_reply_port;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  mach_msg_header_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v12 = 1;
  v13 = a2;
  v14 = 16777472;
  v15 = a3;
  v16 = *MEMORY[0x1E0C804E8];
  v17 = a3;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&v11.msgh_bits = 2147489043;
  v11.msgh_remote_port = a1;
  v11.msgh_local_port = special_reply_port;
  *(_QWORD *)&v11.msgh_voucher_port = 0x4E2F00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&v11);
    special_reply_port = v11.msgh_local_port;
  }
  v7 = mach_msg(&v11, 3162115, 0x38u, 0x30u, special_reply_port, 0, 0);
  v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v7)
    {
      if (v11.msgh_id == 71)
      {
        v8 = 4294966988;
      }
      else if (v11.msgh_id == 20115)
      {
        if ((v11.msgh_bits & 0x80000000) == 0)
        {
          if (v11.msgh_size == 40)
          {
            if (!v11.msgh_remote_port)
            {
              v8 = HIDWORD(v13);
              if (!HIDWORD(v13))
              {
                *a4 = v14;
                return v8;
              }
              goto LABEL_22;
            }
          }
          else if (v11.msgh_size == 36)
          {
            if (v11.msgh_remote_port)
              v9 = 1;
            else
              v9 = HIDWORD(v13) == 0;
            if (v9)
              v8 = 4294966996;
            else
              v8 = HIDWORD(v13);
            goto LABEL_22;
          }
        }
        v8 = 4294966996;
      }
      else
      {
        v8 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&v11);
      return v8;
    }
    mig_dealloc_special_reply_port();
  }
  return v8;
}

uint64_t notifyremove(mach_port_t a1, uint64_t a2, int a3, int a4, int *a5)
{
  mach_port_t special_reply_port;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  mach_msg_header_t msg;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v13 = 1;
  v14 = a2;
  v15 = 16777472;
  v16 = a3;
  v17 = *MEMORY[0x1E0C804E8];
  v18 = a3;
  v19 = a4;
  special_reply_port = mig_get_special_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = special_reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4E3300000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    special_reply_port = msg.msgh_local_port;
  }
  v8 = mach_msg(&msg, 3162115, 0x3Cu, 0x30u, special_reply_port, 0, 0);
  v9 = v8;
  if ((v8 - 268435458) > 0xE || ((1 << (v8 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v8)
    {
      if (msg.msgh_id == 71)
      {
        v9 = 4294966988;
      }
      else if (msg.msgh_id == 20119)
      {
        if ((msg.msgh_bits & 0x80000000) == 0)
        {
          if (msg.msgh_size == 40)
          {
            if (!msg.msgh_remote_port)
            {
              v9 = HIDWORD(v14);
              if (!HIDWORD(v14))
              {
                *a5 = v15;
                return v9;
              }
              goto LABEL_22;
            }
          }
          else if (msg.msgh_size == 36)
          {
            if (msg.msgh_remote_port)
              v10 = 1;
            else
              v10 = HIDWORD(v14) == 0;
            if (v10)
              v9 = 4294966996;
            else
              v9 = HIDWORD(v14);
            goto LABEL_22;
          }
        }
        v9 = 4294966996;
      }
      else
      {
        v9 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(&msg);
      return v9;
    }
    mig_dealloc_special_reply_port();
  }
  return v9;
}

uint64_t notifycancel(mach_port_t a1, mach_port_t *a2)
{
  mach_port_t special_reply_port;
  uint64_t v5;
  uint64_t msgh_remote_port;
  BOOL v7;
  mach_msg_header_t msg[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&msg[1].msgh_remote_port = 0u;
  *(_OWORD *)&msg[0].msgh_id = 0u;
  msg[0].msgh_size = 0;
  special_reply_port = mig_get_special_reply_port();
  msg[0].msgh_remote_port = a1;
  msg[0].msgh_local_port = special_reply_port;
  msg[0].msgh_bits = 5395;
  *(_QWORD *)&msg[0].msgh_voucher_port = 0x4E3800000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(msg);
    special_reply_port = msg[0].msgh_local_port;
  }
  v5 = mach_msg(msg, 3162115, 0x18u, 0x30u, special_reply_port, 0, 0);
  msgh_remote_port = v5;
  if ((v5 - 268435458) > 0xE || ((1 << (v5 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v5)
    {
      if (msg[0].msgh_id == 71)
      {
        msgh_remote_port = 4294966988;
      }
      else if (msg[0].msgh_id == 20124)
      {
        if ((msg[0].msgh_bits & 0x80000000) == 0)
        {
          if (msg[0].msgh_size == 40)
          {
            if (!msg[0].msgh_remote_port)
            {
              msgh_remote_port = msg[1].msgh_remote_port;
              if (!msg[1].msgh_remote_port)
              {
                *a2 = msg[1].msgh_local_port;
                return msgh_remote_port;
              }
              goto LABEL_22;
            }
          }
          else if (msg[0].msgh_size == 36)
          {
            if (msg[0].msgh_remote_port)
              v7 = 1;
            else
              v7 = msg[1].msgh_remote_port == 0;
            if (v7)
              msgh_remote_port = 4294966996;
            else
              msgh_remote_port = msg[1].msgh_remote_port;
            goto LABEL_22;
          }
        }
        msgh_remote_port = 4294966996;
      }
      else
      {
        msgh_remote_port = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(msg);
      return msgh_remote_port;
    }
    mig_dealloc_special_reply_port();
  }
  return msgh_remote_port;
}

uint64_t notifyviafd(int a1, int a2, int a3, int *a4)
{
  mach_port_name_t special_reply_port;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  _BYTE msg[36];
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&msg[20] = 0u;
  *(_OWORD *)&msg[4] = 0u;
  *(_DWORD *)&msg[24] = 1;
  *(_DWORD *)&msg[28] = a2;
  v12 = 1114112;
  v13 = *MEMORY[0x1E0C804E8];
  v14 = a3;
  special_reply_port = mig_get_special_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = special_reply_port;
  *(_DWORD *)msg = -2147478253;
  *(_QWORD *)&msg[16] = 0x4E3A00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    special_reply_port = *(_DWORD *)&msg[12];
  }
  v7 = mach_msg((mach_msg_header_t *)msg, 3162115, 0x34u, 0x30u, special_reply_port, 0, 0);
  v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v7)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v8 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 20126)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 40)
          {
            if (!*(_DWORD *)&msg[8])
            {
              v8 = *(unsigned int *)&msg[32];
              if (!*(_DWORD *)&msg[32])
              {
                *a4 = v12;
                return v8;
              }
              goto LABEL_22;
            }
          }
          else if (*(_DWORD *)&msg[4] == 36)
          {
            if (*(_DWORD *)&msg[8])
              v9 = 1;
            else
              v9 = *(_DWORD *)&msg[32] == 0;
            if (v9)
              v8 = 4294966996;
            else
              v8 = *(unsigned int *)&msg[32];
            goto LABEL_22;
          }
        }
        v8 = 4294966996;
      }
      else
      {
        v8 = 4294966995;
      }
LABEL_22:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v8;
    }
    mig_dealloc_special_reply_port();
  }
  return v8;
}

uint64_t snapshot(mach_port_t a1, mach_port_t *a2)
{
  mach_port_t special_reply_port;
  uint64_t v5;
  uint64_t msgh_remote_port;
  BOOL v7;
  mach_msg_header_t msg[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&msg[1].msgh_remote_port = 0u;
  *(_OWORD *)&msg[0].msgh_id = 0u;
  msg[0].msgh_size = 0;
  special_reply_port = mig_get_special_reply_port();
  msg[0].msgh_remote_port = a1;
  msg[0].msgh_local_port = special_reply_port;
  msg[0].msgh_bits = 5395;
  *(_QWORD *)&msg[0].msgh_voucher_port = 0x4E3D00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(msg);
    special_reply_port = msg[0].msgh_local_port;
  }
  v5 = mach_msg(msg, 3162115, 0x18u, 0x30u, special_reply_port, 0, 0);
  msgh_remote_port = v5;
  if ((v5 - 268435458) > 0xE || ((1 << (v5 - 2)) & 0x4003) == 0)
  {
    if (!(_DWORD)v5)
    {
      if (msg[0].msgh_id == 71)
      {
        msgh_remote_port = 4294966988;
      }
      else if (msg[0].msgh_id == 20129)
      {
        if ((msg[0].msgh_bits & 0x80000000) == 0)
        {
          if (msg[0].msgh_size == 40)
          {
            if (!msg[0].msgh_remote_port)
            {
              msgh_remote_port = msg[1].msgh_remote_port;
              if (!msg[1].msgh_remote_port)
              {
                *a2 = msg[1].msgh_local_port;
                return msgh_remote_port;
              }
              goto LABEL_22;
            }
          }
          else if (msg[0].msgh_size == 36)
          {
            if (msg[0].msgh_remote_port)
              v7 = 1;
            else
              v7 = msg[1].msgh_remote_port == 0;
            if (v7)
              msgh_remote_port = 4294966996;
            else
              msgh_remote_port = msg[1].msgh_remote_port;
            goto LABEL_22;
          }
        }
        msgh_remote_port = 4294966996;
      }
      else
      {
        msgh_remote_port = 4294966995;
      }
LABEL_22:
      mach_msg_destroy(msg);
      return msgh_remote_port;
    }
    mig_dealloc_special_reply_port();
  }
  return msgh_remote_port;
}

uint64_t helperinit(int a1, _DWORD *a2, _DWORD *a3)
{
  mach_port_name_t reply_port;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _BYTE msg[36];
  __int128 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  *(_OWORD *)&msg[20] = 0u;
  v12 = 0u;
  *(_DWORD *)&msg[4] = 0;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(_QWORD *)&msg[16] = 0x55F000000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    reply_port = *(_DWORD *)&msg[12];
  }
  v7 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x3Cu, reply_port, 0, 0);
  v8 = v7;
  if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
  }
  else
  {
    if (!(_DWORD)v7)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v8 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 22100)
      {
        if ((*(_DWORD *)msg & 0x80000000) != 0)
        {
          v8 = 4294966996;
          if (*(_DWORD *)&msg[24] == 1
            && *(_DWORD *)&msg[4] == 52
            && !*(_DWORD *)&msg[8]
            && WORD1(v12) << 16 == 1114112)
          {
            v8 = 0;
            v9 = HIDWORD(v12);
            *a2 = *(_DWORD *)&msg[28];
            *a3 = v9;
            return v8;
          }
        }
        else if (*(_DWORD *)&msg[4] == 36)
        {
          v8 = 4294966996;
          if (*(_DWORD *)&msg[32])
          {
            if (*(_DWORD *)&msg[8])
              v8 = 4294966996;
            else
              v8 = *(unsigned int *)&msg[32];
          }
        }
        else
        {
          v8 = 4294966996;
        }
      }
      else
      {
        v8 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v8;
    }
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
  }
  return v8;
}

uint64_t helperexec(mach_port_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int a6, int *a7, _QWORD *a8, _DWORD *a9)
{
  mach_port_t reply_port;
  uint64_t v13;
  uint64_t v14;
  int v15;
  mach_msg_header_t msg;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v18 = 2;
  v19 = a3;
  v20 = 16777472;
  v21 = a4;
  v22 = a5;
  v23 = 16777472;
  v24 = a6;
  v25 = *MEMORY[0x1E0C804E8];
  v26 = a2;
  v27 = a4;
  v28 = a6;
  reply_port = mig_get_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x55F100000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v13 = mach_msg(&msg, 3, 0x50u, 0x44u, reply_port, 0, 0);
  v14 = v13;
  if ((v13 - 268435458) <= 0xE && ((1 << (v13 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
  }
  else
  {
    if (!(_DWORD)v13)
    {
      if (msg.msgh_id == 71)
      {
        v14 = 4294966988;
      }
      else if (msg.msgh_id == 22101)
      {
        if ((msg.msgh_bits & 0x80000000) != 0)
        {
          v14 = 4294966996;
          if (v18 == 1 && msg.msgh_size == 60 && !msg.msgh_remote_port && HIBYTE(v20) == 1)
          {
            v15 = v21;
            if (v21 == v24)
            {
              v14 = 0;
              *a7 = v23;
              *a8 = v19;
              *a9 = v15;
              return v14;
            }
          }
        }
        else if (msg.msgh_size == 36)
        {
          v14 = 4294966996;
          if (HIDWORD(v19))
          {
            if (msg.msgh_remote_port)
              v14 = 4294966996;
            else
              v14 = HIDWORD(v19);
          }
        }
        else
        {
          v14 = 4294966996;
        }
      }
      else
      {
        v14 = 4294966995;
      }
      mach_msg_destroy(&msg);
      return v14;
    }
    mig_dealloc_reply_port(msg.msgh_local_port);
  }
  return v14;
}

uint64_t pppcontroller_attach(mach_port_t a1, uint64_t a2, int a3, unsigned int a4, unsigned int a5, unsigned int a6, _DWORD *a7, _DWORD *a8)
{
  mach_port_t reply_port;
  uint64_t v12;
  uint64_t v13;
  int v14;
  mach_msg_header_t msg;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  msg.msgh_id = 0;
  *(_OWORD *)&msg.msgh_size = 0u;
  v17 = 4;
  v18 = a2;
  v19 = 16777472;
  v20 = a3;
  v21 = a4;
  v22 = 1245184;
  v23 = a5;
  v24 = 1114112;
  v25 = a6;
  v26 = 1245184;
  v27 = *MEMORY[0x1E0C804E8];
  v28 = a3;
  reply_port = mig_get_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  *(_QWORD *)&msg.msgh_voucher_port = 0x465000000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v12 = mach_msg(&msg, 3, 0x5Cu, 0x3Cu, reply_port, 0, 0);
  v13 = v12;
  if ((v12 - 268435458) <= 0xE && ((1 << (v12 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
  }
  else
  {
    if (!(_DWORD)v12)
    {
      if (msg.msgh_id == 71)
      {
        v13 = 4294966988;
      }
      else if (msg.msgh_id == 18100)
      {
        if ((msg.msgh_bits & 0x80000000) != 0)
        {
          v13 = 4294966996;
          if (v17 == 1 && msg.msgh_size == 52 && !msg.msgh_remote_port && HIWORD(v19) << 16 == 1114112)
          {
            v13 = 0;
            v14 = HIDWORD(v21);
            *a7 = v18;
            *a8 = v14;
            return v13;
          }
        }
        else if (msg.msgh_size == 36)
        {
          v13 = 4294966996;
          if (HIDWORD(v18))
          {
            if (msg.msgh_remote_port)
              v13 = 4294966996;
            else
              v13 = HIDWORD(v18);
          }
        }
        else
        {
          v13 = 4294966996;
        }
      }
      else
      {
        v13 = 4294966995;
      }
      mach_msg_destroy(&msg);
      return v13;
    }
    mig_dealloc_reply_port(msg.msgh_local_port);
  }
  return v13;
}

uint64_t pppcontroller_getstatus(int a1, _DWORD *a2, _DWORD *a3)
{
  mach_port_name_t reply_port;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  int v11;
  _BYTE msg[36];
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0u;
  *(_OWORD *)&msg[20] = 0u;
  *(_DWORD *)&msg[4] = 0;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(_QWORD *)&msg[16] = 0x465100000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    reply_port = *(_DWORD *)&msg[12];
  }
  v7 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x34u, reply_port, 0, 0);
  v8 = v7;
  if ((v7 - 268435458) > 0xE || ((1 << (v7 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v7)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
      return v8;
    }
    if (*(_DWORD *)&msg[20] == 71)
    {
      v8 = 4294966988;
    }
    else if (*(_DWORD *)&msg[20] == 18101)
    {
      if ((*(_DWORD *)msg & 0x80000000) == 0)
      {
        if (*(_DWORD *)&msg[4] == 44)
        {
          if (!*(_DWORD *)&msg[8])
          {
            v8 = *(unsigned int *)&msg[32];
            if (!*(_DWORD *)&msg[32])
            {
              v11 = DWORD1(v13);
              *a2 = v13;
              *a3 = v11;
              return v8;
            }
            goto LABEL_23;
          }
        }
        else if (*(_DWORD *)&msg[4] == 36)
        {
          if (*(_DWORD *)&msg[8])
            v9 = 1;
          else
            v9 = *(_DWORD *)&msg[32] == 0;
          if (v9)
            v8 = 4294966996;
          else
            v8 = *(unsigned int *)&msg[32];
          goto LABEL_23;
        }
      }
      v8 = 4294966996;
    }
    else
    {
      v8 = 4294966995;
    }
LABEL_23:
    mach_msg_destroy((mach_msg_header_t *)msg);
    return v8;
  }
  mig_put_reply_port(*(mach_port_t *)&msg[12]);
  return v8;
}

uint64_t pppcontroller_copyextendedstatus(int a1, _QWORD *a2, _DWORD *a3, _DWORD *a4)
{
  mach_port_name_t reply_port;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _BYTE msg[36];
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v15 = 0u;
  v14 = 0u;
  *(_OWORD *)&msg[20] = 0u;
  *(_DWORD *)&msg[4] = 0;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(_QWORD *)&msg[16] = 0x465200000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    reply_port = *(_DWORD *)&msg[12];
  }
  v9 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x44u, reply_port, 0, 0);
  v10 = v9;
  if ((v9 - 268435458) <= 0xE && ((1 << (v9 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
  }
  else
  {
    if (!(_DWORD)v9)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v10 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 18102)
      {
        if ((*(_DWORD *)msg & 0x80000000) != 0)
        {
          v10 = 4294966996;
          if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 60 && !*(_DWORD *)&msg[8] && BYTE3(v14) == 1)
          {
            v11 = DWORD1(v14);
            if (DWORD1(v14) == (_DWORD)v15)
            {
              v10 = 0;
              *a2 = *(_QWORD *)&msg[28];
              *a3 = v11;
              *a4 = DWORD1(v15);
              return v10;
            }
          }
        }
        else if (*(_DWORD *)&msg[4] == 36)
        {
          v10 = 4294966996;
          if (*(_DWORD *)&msg[32])
          {
            if (*(_DWORD *)&msg[8])
              v10 = 4294966996;
            else
              v10 = *(unsigned int *)&msg[32];
          }
        }
        else
        {
          v10 = 4294966996;
        }
      }
      else
      {
        v10 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v10;
    }
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
  }
  return v10;
}

uint64_t pppcontroller_copystatistics(int a1, _QWORD *a2, _DWORD *a3, _DWORD *a4)
{
  mach_port_name_t reply_port;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _BYTE msg[36];
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v15 = 0u;
  v14 = 0u;
  *(_OWORD *)&msg[20] = 0u;
  *(_DWORD *)&msg[4] = 0;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(_QWORD *)&msg[16] = 0x465300000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    reply_port = *(_DWORD *)&msg[12];
  }
  v9 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x44u, reply_port, 0, 0);
  v10 = v9;
  if ((v9 - 268435458) <= 0xE && ((1 << (v9 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
  }
  else
  {
    if (!(_DWORD)v9)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v10 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 18103)
      {
        if ((*(_DWORD *)msg & 0x80000000) != 0)
        {
          v10 = 4294966996;
          if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 60 && !*(_DWORD *)&msg[8] && BYTE3(v14) == 1)
          {
            v11 = DWORD1(v14);
            if (DWORD1(v14) == (_DWORD)v15)
            {
              v10 = 0;
              *a2 = *(_QWORD *)&msg[28];
              *a3 = v11;
              *a4 = DWORD1(v15);
              return v10;
            }
          }
        }
        else if (*(_DWORD *)&msg[4] == 36)
        {
          v10 = 4294966996;
          if (*(_DWORD *)&msg[32])
          {
            if (*(_DWORD *)&msg[8])
              v10 = 4294966996;
            else
              v10 = *(unsigned int *)&msg[32];
          }
        }
        else
        {
          v10 = 4294966996;
        }
      }
      else
      {
        v10 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v10;
    }
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
  }
  return v10;
}

uint64_t pppcontroller_copyuseroptions(int a1, _QWORD *a2, _DWORD *a3, _DWORD *a4)
{
  mach_port_name_t reply_port;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _BYTE msg[36];
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v15 = 0u;
  v14 = 0u;
  *(_OWORD *)&msg[20] = 0u;
  *(_DWORD *)&msg[4] = 0;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(_QWORD *)&msg[16] = 0x465400000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    reply_port = *(_DWORD *)&msg[12];
  }
  v9 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x44u, reply_port, 0, 0);
  v10 = v9;
  if ((v9 - 268435458) <= 0xE && ((1 << (v9 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
  }
  else
  {
    if (!(_DWORD)v9)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v10 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 18104)
      {
        if ((*(_DWORD *)msg & 0x80000000) != 0)
        {
          v10 = 4294966996;
          if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 60 && !*(_DWORD *)&msg[8] && BYTE3(v14) == 1)
          {
            v11 = DWORD1(v14);
            if (DWORD1(v14) == (_DWORD)v15)
            {
              v10 = 0;
              *a2 = *(_QWORD *)&msg[28];
              *a3 = v11;
              *a4 = DWORD1(v15);
              return v10;
            }
          }
        }
        else if (*(_DWORD *)&msg[4] == 36)
        {
          v10 = 4294966996;
          if (*(_DWORD *)&msg[32])
          {
            if (*(_DWORD *)&msg[8])
              v10 = 4294966996;
            else
              v10 = *(unsigned int *)&msg[32];
          }
        }
        else
        {
          v10 = 4294966996;
        }
      }
      else
      {
        v10 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v10;
    }
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
  }
  return v10;
}

uint64_t pppcontroller_start(mach_port_t a1, uint64_t a2, int a3, int a4, int *a5)
{
  mach_port_t reply_port;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  mach_msg_header_t msg;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v13 = 1;
  v14 = a2;
  v15 = 16777472;
  v16 = a3;
  v17 = *MEMORY[0x1E0C804E8];
  v18 = a3;
  v19 = a4;
  reply_port = mig_get_reply_port();
  *(_QWORD *)&msg.msgh_bits = 2147489043;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = reply_port;
  *(_QWORD *)&msg.msgh_voucher_port = 0x465500000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v8 = mach_msg(&msg, 3, 0x3Cu, 0x30u, reply_port, 0, 0);
  v9 = v8;
  if ((v8 - 268435458) > 0xE || ((1 << (v8 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v8)
    {
      mig_dealloc_reply_port(msg.msgh_local_port);
      return v9;
    }
    if (msg.msgh_id == 71)
    {
      v9 = 4294966988;
    }
    else if (msg.msgh_id == 18105)
    {
      if ((msg.msgh_bits & 0x80000000) == 0)
      {
        if (msg.msgh_size == 40)
        {
          if (!msg.msgh_remote_port)
          {
            v9 = HIDWORD(v14);
            if (!HIDWORD(v14))
            {
              *a5 = v15;
              return v9;
            }
            goto LABEL_23;
          }
        }
        else if (msg.msgh_size == 36)
        {
          if (msg.msgh_remote_port)
            v10 = 1;
          else
            v10 = HIDWORD(v14) == 0;
          if (v10)
            v9 = 4294966996;
          else
            v9 = HIDWORD(v14);
          goto LABEL_23;
        }
      }
      v9 = 4294966996;
    }
    else
    {
      v9 = 4294966995;
    }
LABEL_23:
    mach_msg_destroy(&msg);
    return v9;
  }
  mig_put_reply_port(msg.msgh_local_port);
  return v9;
}

uint64_t pppcontroller_stop(int a1, int a2, _DWORD *a3)
{
  mach_port_name_t reply_port;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  int msg;
  _BYTE msg_4[44];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  memset(&msg_4[16], 0, 28);
  *(_OWORD *)msg_4 = 0u;
  *(_QWORD *)&msg_4[20] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&msg_4[28] = a2;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = a1;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(_QWORD *)&msg_4[12] = 0x465600000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    reply_port = *(_DWORD *)&msg_4[8];
  }
  v6 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x30u, reply_port, 0, 0);
  v7 = v6;
  if ((v6 - 268435458) > 0xE || ((1 << (v6 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v6)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
      return v7;
    }
    if (*(_DWORD *)&msg_4[16] == 71)
    {
      v7 = 4294966988;
    }
    else if (*(_DWORD *)&msg_4[16] == 18106)
    {
      if ((msg & 0x80000000) == 0)
      {
        if (*(_DWORD *)msg_4 == 40)
        {
          if (!*(_DWORD *)&msg_4[4])
          {
            v7 = *(unsigned int *)&msg_4[28];
            if (!*(_DWORD *)&msg_4[28])
            {
              *a3 = *(_DWORD *)&msg_4[32];
              return v7;
            }
            goto LABEL_23;
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          if (*(_DWORD *)&msg_4[4])
            v8 = 1;
          else
            v8 = *(_DWORD *)&msg_4[28] == 0;
          if (v8)
            v7 = 4294966996;
          else
            v7 = *(unsigned int *)&msg_4[28];
          goto LABEL_23;
        }
      }
      v7 = 4294966996;
    }
    else
    {
      v7 = 4294966995;
    }
LABEL_23:
    mach_msg_destroy((mach_msg_header_t *)&msg);
    return v7;
  }
  mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  return v7;
}

uint64_t pppcontroller_suspend(mach_port_t a1, mach_port_t *a2)
{
  mach_port_t reply_port;
  uint64_t v5;
  uint64_t msgh_remote_port;
  BOOL v7;
  mach_msg_header_t msg[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&msg[1].msgh_remote_port = 0u;
  *(_OWORD *)&msg[0].msgh_id = 0u;
  msg[0].msgh_size = 0;
  reply_port = mig_get_reply_port();
  msg[0].msgh_remote_port = a1;
  msg[0].msgh_local_port = reply_port;
  msg[0].msgh_bits = 5395;
  *(_QWORD *)&msg[0].msgh_voucher_port = 0x465700000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(msg);
    reply_port = msg[0].msgh_local_port;
  }
  v5 = mach_msg(msg, 3, 0x18u, 0x30u, reply_port, 0, 0);
  msgh_remote_port = v5;
  if ((v5 - 268435458) > 0xE || ((1 << (v5 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v5)
    {
      mig_dealloc_reply_port(msg[0].msgh_local_port);
      return msgh_remote_port;
    }
    if (msg[0].msgh_id == 71)
    {
      msgh_remote_port = 4294966988;
    }
    else if (msg[0].msgh_id == 18107)
    {
      if ((msg[0].msgh_bits & 0x80000000) == 0)
      {
        if (msg[0].msgh_size == 40)
        {
          if (!msg[0].msgh_remote_port)
          {
            msgh_remote_port = msg[1].msgh_remote_port;
            if (!msg[1].msgh_remote_port)
            {
              *a2 = msg[1].msgh_local_port;
              return msgh_remote_port;
            }
            goto LABEL_23;
          }
        }
        else if (msg[0].msgh_size == 36)
        {
          if (msg[0].msgh_remote_port)
            v7 = 1;
          else
            v7 = msg[1].msgh_remote_port == 0;
          if (v7)
            msgh_remote_port = 4294966996;
          else
            msgh_remote_port = msg[1].msgh_remote_port;
          goto LABEL_23;
        }
      }
      msgh_remote_port = 4294966996;
    }
    else
    {
      msgh_remote_port = 4294966995;
    }
LABEL_23:
    mach_msg_destroy(msg);
    return msgh_remote_port;
  }
  mig_put_reply_port(msg[0].msgh_local_port);
  return msgh_remote_port;
}

uint64_t pppcontroller_resume(mach_port_t a1, mach_port_t *a2)
{
  mach_port_t reply_port;
  uint64_t v5;
  uint64_t msgh_remote_port;
  BOOL v7;
  mach_msg_header_t msg[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&msg[1].msgh_remote_port = 0u;
  *(_OWORD *)&msg[0].msgh_id = 0u;
  msg[0].msgh_size = 0;
  reply_port = mig_get_reply_port();
  msg[0].msgh_remote_port = a1;
  msg[0].msgh_local_port = reply_port;
  msg[0].msgh_bits = 5395;
  *(_QWORD *)&msg[0].msgh_voucher_port = 0x465800000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(msg);
    reply_port = msg[0].msgh_local_port;
  }
  v5 = mach_msg(msg, 3, 0x18u, 0x30u, reply_port, 0, 0);
  msgh_remote_port = v5;
  if ((v5 - 268435458) > 0xE || ((1 << (v5 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v5)
    {
      mig_dealloc_reply_port(msg[0].msgh_local_port);
      return msgh_remote_port;
    }
    if (msg[0].msgh_id == 71)
    {
      msgh_remote_port = 4294966988;
    }
    else if (msg[0].msgh_id == 18108)
    {
      if ((msg[0].msgh_bits & 0x80000000) == 0)
      {
        if (msg[0].msgh_size == 40)
        {
          if (!msg[0].msgh_remote_port)
          {
            msgh_remote_port = msg[1].msgh_remote_port;
            if (!msg[1].msgh_remote_port)
            {
              *a2 = msg[1].msgh_local_port;
              return msgh_remote_port;
            }
            goto LABEL_23;
          }
        }
        else if (msg[0].msgh_size == 36)
        {
          if (msg[0].msgh_remote_port)
            v7 = 1;
          else
            v7 = msg[1].msgh_remote_port == 0;
          if (v7)
            msgh_remote_port = 4294966996;
          else
            msgh_remote_port = msg[1].msgh_remote_port;
          goto LABEL_23;
        }
      }
      msgh_remote_port = 4294966996;
    }
    else
    {
      msgh_remote_port = 4294966995;
    }
LABEL_23:
    mach_msg_destroy(msg);
    return msgh_remote_port;
  }
  mig_put_reply_port(msg[0].msgh_local_port);
  return msgh_remote_port;
}

uint64_t pppcontroller_notification(int a1, int a2, _DWORD *a3)
{
  mach_port_name_t reply_port;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  int msg;
  _BYTE msg_4[44];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  memset(&msg_4[16], 0, 28);
  *(_OWORD *)msg_4 = 0u;
  *(_QWORD *)&msg_4[20] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&msg_4[28] = a2;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = a1;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(_QWORD *)&msg_4[12] = 0x465900000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    reply_port = *(_DWORD *)&msg_4[8];
  }
  v6 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x30u, reply_port, 0, 0);
  v7 = v6;
  if ((v6 - 268435458) > 0xE || ((1 << (v6 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v6)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
      return v7;
    }
    if (*(_DWORD *)&msg_4[16] == 71)
    {
      v7 = 4294966988;
    }
    else if (*(_DWORD *)&msg_4[16] == 18109)
    {
      if ((msg & 0x80000000) == 0)
      {
        if (*(_DWORD *)msg_4 == 40)
        {
          if (!*(_DWORD *)&msg_4[4])
          {
            v7 = *(unsigned int *)&msg_4[28];
            if (!*(_DWORD *)&msg_4[28])
            {
              *a3 = *(_DWORD *)&msg_4[32];
              return v7;
            }
            goto LABEL_23;
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          if (*(_DWORD *)&msg_4[4])
            v8 = 1;
          else
            v8 = *(_DWORD *)&msg_4[28] == 0;
          if (v8)
            v7 = 4294966996;
          else
            v7 = *(unsigned int *)&msg_4[28];
          goto LABEL_23;
        }
      }
      v7 = 4294966996;
    }
    else
    {
      v7 = 4294966995;
    }
LABEL_23:
    mach_msg_destroy((mach_msg_header_t *)&msg);
    return v7;
  }
  mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  return v7;
}

uint64_t pppcontroller_attach_proxy(int a1, uint64_t a2, int a3, unsigned int a4, unsigned int a5, unsigned int a6, int a7, int a8, int a9, _DWORD *a10, _DWORD *a11)
{
  mach_port_name_t reply_port;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v17;
  _BYTE rcv_name[24];
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&rcv_name[16] = 0x400000000;
  *(_OWORD *)rcv_name = 0u;
  v19 = a2;
  v20 = 16777472;
  v21 = a3;
  v22 = a4;
  v23 = 1245184;
  v24 = a5;
  v25 = 1114112;
  v26 = a6;
  v27 = 1245184;
  v28 = *MEMORY[0x1E0C804E8];
  v29 = a3;
  v30 = a7;
  v31 = a8;
  v32 = a9;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&rcv_name[4] = a1;
  *(_DWORD *)&rcv_name[8] = reply_port;
  v17 = -2147478253;
  *(_QWORD *)&rcv_name[12] = 0x465D00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&v17);
    reply_port = *(_DWORD *)&rcv_name[8];
  }
  v13 = mach_msg((mach_msg_header_t *)&v17, 3, 0x68u, 0x3Cu, reply_port, 0, 0);
  v14 = v13;
  if ((v13 - 268435458) <= 0xE && ((1 << (v13 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&rcv_name[8]);
  }
  else
  {
    if (!(_DWORD)v13)
    {
      if (*(_DWORD *)&rcv_name[16] == 71)
      {
        v14 = 4294966988;
      }
      else if (*(_DWORD *)&rcv_name[16] == 18113)
      {
        if (v17 < 0)
        {
          v14 = 4294966996;
          if (*(_DWORD *)&rcv_name[20] == 1
            && *(_DWORD *)rcv_name == 52
            && !*(_DWORD *)&rcv_name[4]
            && HIWORD(v20) << 16 == 1114112)
          {
            v14 = 0;
            v15 = HIDWORD(v22);
            *a10 = v19;
            *a11 = v15;
            return v14;
          }
        }
        else if (*(_DWORD *)rcv_name == 36)
        {
          v14 = 4294966996;
          if (HIDWORD(v19))
          {
            if (*(_DWORD *)&rcv_name[4])
              v14 = 4294966996;
            else
              v14 = HIDWORD(v19);
          }
        }
        else
        {
          v14 = 4294966996;
        }
      }
      else
      {
        v14 = 4294966995;
      }
      mach_msg_destroy((mach_msg_header_t *)&v17);
      return v14;
    }
    mig_dealloc_reply_port(*(mach_port_t *)&rcv_name[8]);
  }
  return v14;
}

void _SCCopyDescription_cold_1()
{
  __assert_rtn("_SCCopyDescription", "SCD.c", 253, "nFormatOptions != NULL");
}

void _SCDPluginSpawnCommand_cold_1(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  strerror(a1);
  OUTLINED_FUNCTION_0(&dword_18D387000, MEMORY[0x1E0C81028], v1, "posix_spawn() failed: %s\n", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_1();
}

void _SCDPluginExecCommand2_cold_1(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  strerror(a1);
  OUTLINED_FUNCTION_0(&dword_18D387000, MEMORY[0x1E0C81028], v1, "fork() failed: %s\n", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_1();
}

void _SCDPluginExecCommand2_cold_2()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v0 = __error();
  strerror(*v0);
  OUTLINED_FUNCTION_0(&dword_18D387000, MEMORY[0x1E0C81028], v1, "setenv() failed: %s\n", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_1();
}

void __SCDynamicStoreNormalize_cold_1()
{
  __assert_rtn("__SCDynamicStoreNormalize", "SCDOpen.c", 867, "store != NULL");
}

void __SCPreferencesIsEmpty_cold_1()
{
  __assert_rtn("__SCPreferencesIsEmpty", "SCP.c", 263, "prefs != NULL");
}

void SCPreferencesCreateCompanion_cold_1()
{
  __assert_rtn("SCPreferencesCreateCompanion", "SCPOpen.c", 873, "newPrefsID != NULL");
}

void __SCPreferencesScheduleWithRunLoop_cold_1()
{
  __assert_rtn("__SCPreferencesScheduleWithRunLoop", "SCPOpen.c", 1231, "prefsPrivate->session != NULL");
}

void lockWithSync_cold_1()
{
  __assert_rtn("lockWithSync", "SCNetworkConfigurationPrivate.c", 184, "prefs != NULL");
}

void ObjectWrapperRelease_cold_1()
{
  __assert_rtn("ObjectWrapperRelease", "SCNetworkInterfaceProvider.c", 93, "new_val > 0");
}

void SCPreferencesPathCreateUniqueChild_cold_1()
{
  __assert_rtn("SCPreferencesPathCreateUniqueChild", "SCPPath.c", 379, "newDict != NULL");
}

void __SCNetworkConnectionCallBack_cold_1()
{
  __assert_rtn("__SCNetworkConnectionCallBack", "SCNetworkConnection.c", 589, "q != NULL");
}

void __SCNetworkConnectionCallBack_cold_2()
{
  __assert_rtn("__SCNetworkConnectionCallBack", "SCNetworkConnection.c", 563, "rl != NULL");
}

void processPreferences_cold_1()
{
  __assert_rtn("processPreferences", "SCNetworkConnectionPrivate.c", 409, "dict != NULL");
}

void SCUserPreferencesSetInterfacePassword_cold_1()
{
  __assert_rtn("SCUserPreferencesSetInterfacePassword", "SCNetworkConnectionPrivate.c", 2249, "newConfig != NULL");
}

void __SCNetworkReachabilityCreatePrivate_cold_1()
{
  __assert_rtn("__SCNetworkReachabilityCreatePrivate", "SCNetworkReachability.c", 439, "_lock_");
}

void SCNetworkReachabilityCopyResolvedAddress_cold_1()
{
  __assert_rtn("SCNetworkReachabilityCopyResolvedAddress", "SCNetworkReachability.c", 1047, "_unlock_");
}

void SCNetworkReachabilityCopyResolvedAddress_cold_2()
{
  __assert_rtn("SCNetworkReachabilityCopyResolvedAddress", "SCNetworkReachability.c", 998, "_lock_");
}

void SCNetworkReachabilityGetInterfaceIndex_cold_1()
{
  __assert_rtn("SCNetworkReachabilityGetInterfaceIndex", "SCNetworkReachability.c", 1279, "_unlock_");
}

void SCNetworkReachabilityGetInterfaceIndex_cold_2()
{
  __assert_rtn("SCNetworkReachabilityGetInterfaceIndex", "SCNetworkReachability.c", 1258, "_lock_");
}

void SCNetworkReachabilityGetFlags_cold_1()
{
  __assert_rtn("SCNetworkReachabilityGetFlags", "SCNetworkReachability.c", 1431, "_unlock_");
}

void SCNetworkReachabilityGetFlags_cold_2()
{
  __assert_rtn("SCNetworkReachabilityGetFlags", "SCNetworkReachability.c", 1384, "_lock_");
}

void SCNetworkReachabilitySetCallback_cold_1()
{
  __assert_rtn("SCNetworkReachabilitySetCallback", "SCNetworkReachability.c", 1543, "_unlock_");
}

void SCNetworkReachabilitySetCallback_cold_2()
{
  __assert_rtn("SCNetworkReachabilitySetCallback", "SCNetworkReachability.c", 1524, "_lock_");
}

void SCNetworkReachabilityScheduleWithRunLoop_cold_1()
{
  __assert_rtn("SCNetworkReachabilityScheduleWithRunLoop", "SCNetworkReachability.c", 1640, "_unlock_");
}

void SCNetworkReachabilityScheduleWithRunLoop_cold_2()
{
  __assert_rtn("SCNetworkReachabilityScheduleWithRunLoop", "SCNetworkReachability.c", 1602, "_unlock_");
}

void SCNetworkReachabilityScheduleWithRunLoop_cold_3()
{
  __assert_rtn("SCNetworkReachabilityScheduleWithRunLoop", "SCNetworkReachability.c", 1599, "_unlock_");
}

void SCNetworkReachabilityScheduleWithRunLoop_cold_4()
{
  __assert_rtn("SCNetworkReachabilityScheduleWithRunLoop", "SCNetworkReachability.c", 1585, "_lock_");
}

void reachPerform_cold_1()
{
  __assert_rtn("reachPerform", "SCNetworkReachability.c", 1497, "_lock_");
}

void SCNetworkReachabilityUnscheduleFromRunLoop_cold_1()
{
  __assert_rtn("SCNetworkReachabilityUnscheduleFromRunLoop", "SCNetworkReachability.c", 1661, "_unlock_");
}

void SCNetworkReachabilityUnscheduleFromRunLoop_cold_2()
{
  __assert_rtn("SCNetworkReachabilityUnscheduleFromRunLoop", "SCNetworkReachability.c", 1688, "_unlock_");
}

void SCNetworkReachabilityUnscheduleFromRunLoop_cold_3()
{
  __assert_rtn("SCNetworkReachabilityUnscheduleFromRunLoop", "SCNetworkReachability.c", 1658, "_lock_");
}

void SCNetworkReachabilitySetDispatchQueue_cold_1()
{
  __assert_rtn("SCNetworkReachabilitySetDispatchQueue", "SCNetworkReachability.c", 2089, "_unlock_");
}

void SCNetworkReachabilitySetDispatchQueue_cold_2()
{
  __assert_rtn("SCNetworkReachabilitySetDispatchQueue", "SCNetworkReachability.c", 2087, "_lock_");
}

void __SCNetworkReachabilityDeallocate_cold_1()
{
  __assert_rtn("__SCNetworkReachabilityDeallocate", "SCNetworkReachability.c", 396, "_unlock_");
}

void __SCNetworkReachabilityDeallocate_cold_2()
{
  __assert_rtn("__SCNetworkReachabilityDeallocate", "SCNetworkReachability.c", 360, "_lock_");
}

void __SCNetworkReachabilityCopyDescription_cold_1()
{
  __assert_rtn("__SCNetworkReachabilityCopyDescription", "SCNetworkReachability.c", 345, "_unlock_");
}

void __SCNetworkReachabilityCopyDescription_cold_2()
{
  __assert_rtn("__SCNetworkReachabilityCopyDescription", "SCNetworkReachability.c", 292, "_lock_");
}

void reachPerformAndUnlock_cold_1()
{
  __assert_rtn("reachPerformAndUnlock", "SCNetworkReachability.c", 1451, "_unlock_");
}

void reachPerformAndUnlock_cold_2()
{
  __assert_rtn("reachPerformAndUnlock", "SCNetworkReachability.c", 1474, "_unlock_");
}

void reachUpdateAndUnlock_cold_1()
{
  __assert_rtn("reachUpdateAndUnlock", "SCNetworkReachability.c", 1511, "_unlock_");
}

void createInterface_cold_1()
{
  __assert_rtn("createInterface", "SCNetworkInterface.c", 2755, "interfacePrivate != NULL");
}

void __SCNetworkInterfaceCopyStoredWithPreferences_cold_1()
{
  __assert_rtn("__SCNetworkInterfaceCopyStoredWithPreferences", "SCNetworkInterface.c", 9350, "ni_prefs");
}

void __SCNetworkInterfaceSaveStoredWithPreferences_cold_1()
{
  __assert_rtn("__SCNetworkInterfaceSaveStoredWithPreferences", "SCNetworkInterface.c", 9393, "ni_prefs");
}

void __SCNetworkInterfaceCreateWithNIPreferencesUsingBSDName_cold_1()
{
  __assert_rtn("__SCNetworkInterfaceCreateWithNIPreferencesUsingBSDName", "SCNetworkInterface.c", 9416, "ni_prefs");
}

void SCNetworkServiceAddProtocolType_cold_1()
{
  __assert_rtn("SCNetworkServiceAddProtocolType", "SCNetworkService.c", 434, "protocol != NULL");
}

void SCNetworkServiceAddProtocolType_cold_2()
{
  __assert_rtn("SCNetworkServiceAddProtocolType", "SCNetworkService.c", 437, "newEntity != NULL");
}

void SCNetworkServiceCopyAll_cold_1()
{
  __assert_rtn("SCNetworkServiceCopyAll", "SCNetworkService.c", 527, "servicePrivate != NULL");
}

void _SCNetworkServiceCopyActive_cold_1()
{
  __assert_rtn("_SCNetworkServiceCopyActive", "SCNetworkService.c", 681, "servicePrivate != NULL");
}

void _serviceOrder_add_cold_1()
{
  __assert_rtn("_serviceOrder_add", "SCNetworkSet.c", 260, "newOrder != NULL");
}

void SCNetworkSetCopy_cold_1()
{
  __assert_rtn("SCNetworkSetCopy", "SCNetworkSet.c", 714, "setPrivate != NULL");
}

void SCNetworkSetCopyAll_cold_1()
{
  __assert_rtn("SCNetworkSetCopyAll", "SCNetworkSet.c", 779, "setPrivate != NULL");
}

void SCNetworkSetCopyCurrent_cold_1()
{
  __assert_rtn("SCNetworkSetCopyCurrent", "SCNetworkSet.c", 894, "setPrivate != NULL");
}

void SCNetworkSetCreate_cold_1()
{
  __assert_rtn("SCNetworkSetCreate", "SCNetworkSet.c", 1040, "setPrivate != NULL");
}

void SCNetworkSetEstablishDefaultInterfaceConfiguration_cold_1()
{
  __assert_rtn("SCNetworkSetEstablishDefaultInterfaceConfiguration", "SCNetworkSet.c", 2367, "interfaces != NULL");
}

void add_configured_interface_cold_1()
{
  __assert_rtn("add_configured_interface", "BridgeConfiguration.c", 225, "bridge != NULL");
}

void add_configured_interface_cold_1_0()
{
  __assert_rtn("add_configured_interface", "VLANConfiguration.c", 106, "vlan != NULL");
}

void add_configured_interface_cold_2()
{
  __assert_rtn("add_configured_interface", "VLANConfiguration.c", 117, "vlan_physical != NULL");
}

void _SCVLANInterfaceCopyActive_cold_1()
{
  __assert_rtn("_SCVLANInterfaceCopyActive", "VLANConfiguration.c", 401, "vlan != NULL");
}

void _SCVLANInterfaceCopyActive_cold_2()
{
  __assert_rtn("_SCVLANInterfaceCopyActive", "VLANConfiguration.c", 409, "vlan_physical != NULL");
}

void _SCVLANInterfaceCopyActive_cold_3()
{
  __assert_rtn("_SCVLANInterfaceCopyActive", "VLANConfiguration.c", 414, "vlan_tag != NULL");
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x1E0C80370](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x1E0C80378](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1E0C80380](c, data, *(_QWORD *)&len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  return (void *)MEMORY[0x1E0C97C98](allocator, size, hint);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
  MEMORY[0x1E0C97CB0](allocator, ptr);
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  MEMORY[0x1E0C97CE8](theArray, otherArray, otherRange.location, otherRange.length);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x1E0C97D00](theArray, range.location, range.length, applier, context);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D10](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1E0C97D20](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1E0C97D30](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D50](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D78](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
  MEMORY[0x1E0C97DA8](theArray, range.location, range.length, values);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DB0](theArray, idx, value);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x1E0C97DC0](theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DD0](theArray, idx, value);
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  MEMORY[0x1E0C97DE0](theArray, range.location, range.length, comparator, context);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

CFURLRef CFBundleCopyExecutableURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1E0C98020](bundle);
}

CFStringRef CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return (CFStringRef)MEMORY[0x1E0C98050](bundle, key, value, tableName);
}

uint64_t CFBundleCopyLocalizedStringForLocalization()
{
  return MEMORY[0x1E0C98060]();
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1E0C98080](bundle, resourceName, resourceType, subDirName);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return (CFBundleRef)MEMORY[0x1E0C980D0](allocator, bundleURL);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1E0C980E8](bundleID);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1E0C98120](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1E0C98150]();
}

Boolean CFCalendarAddComponents(CFCalendarRef calendar, CFAbsoluteTime *at, CFOptionFlags options, const char *componentDesc, ...)
{
  return MEMORY[0x1E0C98220](calendar, at, options, componentDesc);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return MEMORY[0x1E0C98228](calendar, at, componentDesc);
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return (CFCalendarRef)MEMORY[0x1E0C98240](allocator, identifier);
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, componentDesc);
  v3 = va_arg(va, _QWORD);
  return MEMORY[0x1E0C98248](calendar, v3, at);
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
  MEMORY[0x1E0C98298](calendar, tz);
}

CFCharacterSetRef CFCharacterSetCreateInvertedSet(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982C0](alloc, theSet);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982E8](alloc, theString);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1E0C98350](cf);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1E0C983B0](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983B8](allocator, capacity);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1E0C983C8](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  MEMORY[0x1E0C983F0](theData, range.location, range.length, buffer);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1E0C98418]();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  MEMORY[0x1E0C98430](theData, length);
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return MEMORY[0x1E0C98440](theDate, otherDate, context);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1E0C98448](allocator, at);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C984D8](theDate);
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1E0C984E8]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98538](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98558](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x1E0C985A0](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1E0C985C8](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  MEMORY[0x1E0C985D8](theDict);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C985F8](theDict, key, value);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1E0C98650](allocator, domain, code, userInfo);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1E0C98718](cf);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x1E0C98720](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1E0C98758](cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x1E0C98770]();
}

CFMachPortRef CFMachPortCreate(CFAllocatorRef allocator, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)MEMORY[0x1E0C98810](allocator, callout, context, shouldFreeInfo);
}

CFRunLoopSourceRef CFMachPortCreateRunLoopSource(CFAllocatorRef allocator, CFMachPortRef port, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x1E0C98818](allocator, port, order);
}

CFMachPortRef CFMachPortCreateWithPort(CFAllocatorRef allocator, mach_port_t portNum, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)MEMORY[0x1E0C98820](allocator, *(_QWORD *)&portNum, callout, context, shouldFreeInfo);
}

mach_port_t CFMachPortGetPort(CFMachPortRef port)
{
  return MEMORY[0x1E0C98830](port);
}

void CFMachPortInvalidate(CFMachPortRef port)
{
  MEMORY[0x1E0C98840](port);
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x1E0C98910](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFNumberFormatterRef CFNumberFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  return (CFNumberFormatterRef)MEMORY[0x1E0C98938](allocator, locale, style);
}

CFNumberRef CFNumberFormatterCreateNumberFromString(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFOptionFlags options)
{
  return (CFNumberRef)MEMORY[0x1E0C98940](allocator, formatter, string, rangep, options);
}

CFStringRef CFNumberFormatterCreateStringWithNumber(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberRef number)
{
  return (CFStringRef)MEMORY[0x1E0C98948](allocator, formatter, number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x1E0C98A30](applicationID);
}

Boolean CFPreferencesAppValueIsForced(CFStringRef key, CFStringRef applicationID)
{
  return MEMORY[0x1E0C98A38](key, applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A40](key, applicationID);
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFArrayRef)MEMORY[0x1E0C98A50](applicationID, userName, hostName);
}

CFDictionaryRef CFPreferencesCopyMultiple(CFArrayRef keysToFetch, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98A58](keysToFetch, applicationID, userName, hostName);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A60](key, applicationID, userName, hostName);
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  MEMORY[0x1E0C98A90](key, value, applicationID, userName, hostName);
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return MEMORY[0x1E0C98A98](applicationID, userName, hostName);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1E0C98AA0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AD0](allocator, data, options, format, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  MEMORY[0x1E0C98B10](stream);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1E0C98B48](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1E0C98B80](stream);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1E0C98B88](stream, buffer, bufferLength);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98BF8](rl, source, mode);
}

Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  return MEMORY[0x1E0C98C10](rl, source, mode);
}

CFRunLoopMode CFRunLoopCopyCurrentMode(CFRunLoopRef rl)
{
  return (CFRunLoopMode)MEMORY[0x1E0C98C28](rl);
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1E0C98C30]();
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x1E0C98C40]();
}

Boolean CFRunLoopIsWaiting(CFRunLoopRef rl)
{
  return MEMORY[0x1E0C98C58](rl);
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
  MEMORY[0x1E0C98C80](rl, mode, block);
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C90](rl, source, mode);
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x1E0C98CC8](allocator, order, context);
}

void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source)
{
  MEMORY[0x1E0C98CE0](source);
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
  MEMORY[0x1E0C98CF0](source);
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
  MEMORY[0x1E0C98D68](rl);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98D70](theSet, value);
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98D78](theSet, applier, context);
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1E0C98D80](theSet, value);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98D98](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1E0C98DA8](theSet);
}

const void *__cdecl CFSetGetValue(CFSetRef theSet, const void *value)
{
  return (const void *)MEMORY[0x1E0C98DC0](theSet, value);
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98DE0](theSet, value);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x1E0C98ED8](theString, appendedString);
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
  MEMORY[0x1E0C98EE0](theString, cStr, *(_QWORD *)&encoding);
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  MEMORY[0x1E0C98EF0](theString, formatOptions, format);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F18](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1E0C98F58](alloc, theString, separatorString);
}

CFArrayRef CFStringCreateArrayWithFindResults(CFAllocatorRef alloc, CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return (CFArrayRef)MEMORY[0x1E0C98F60](alloc, theString, stringToFind, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1E0C98F68](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1E0C98F78](alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return (CFDataRef)MEMORY[0x1E0C98F80](alloc, theString, *(_QWORD *)&encoding, lossByte);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98F88](alloc, data, *(_QWORD *)&encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F90](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F98](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1E0C98FB8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FE0](alloc, cStr, *(_QWORD *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1E0C99020](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99030](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
  MEMORY[0x1E0C99038](theString, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99050](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C99058](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99060](theString, theSet, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99068](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1E0C99080](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1E0C990B0](theString, idx);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C990E0](string, buffer, maxBufLen);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1E0C990F0](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  return MEMORY[0x1E0C99128](string);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x1E0C99168]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1E0C99180](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1E0C99190](theString, suffix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  MEMORY[0x1E0C991B8](str, idx, insertedStr);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x1E0C991D0](theString, locale);
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
  MEMORY[0x1E0C991F0](theString, range.location, range.length, replacement);
}

void CFStringTrim(CFMutableStringRef theString, CFStringRef trimString)
{
  MEMORY[0x1E0C99250](theString, trimString);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
  MEMORY[0x1E0C99258](theString);
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1E0C99280]();
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99318](anURL);
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  return MEMORY[0x1E0C99338](url, key, propertyValueTypeRefPtr, error);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C993C8](allocator, buffer, bufLen, isDirectory);
}

CFURLRef CFURLCreateFromFileSystemRepresentationRelativeToBase(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C993D8](allocator, buffer, bufLen, isDirectory, baseURL);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPathRelativeToBase(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99438](allocator, filePath, pathStyle, isDirectory, baseURL);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99448](allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C99490](url, resolveAgainstBase, buffer, maxBufLen);
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  return MEMORY[0x1E0C994C0](anURL);
}

Boolean CFURLResourceIsReachable(CFURLRef url, CFErrorRef *error)
{
  return MEMORY[0x1E0C994D0](url, error);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1E0C99518](alloc);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x1E0C99530](alloc, *(_QWORD *)&bytes.byte0, *(_QWORD *)&bytes.byte8);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1E0C99538](alloc, uuid);
}

CFTypeID CFUUIDGetTypeID(void)
{
  return MEMORY[0x1E0C99560]();
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1;
  uint64_t v2;
  CFUUIDBytes result;

  v1 = MEMORY[0x1E0C99568](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

SInt32 CFUserNotificationDisplayNotice(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle)
{
  return MEMORY[0x1E0C995D0](flags, iconURL, soundURL, localizationURL, alertHeader, alertMessage, defaultButtonTitle, timeout);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x1E0CBB660](*(_QWORD *)&iterator);
}

kern_return_t IOMainPort(mach_port_t bootstrapPort, mach_port_t *mainPort)
{
  return MEMORY[0x1E0CBB688](*(_QWORD *)&bootstrapPort, mainPort);
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return MEMORY[0x1E0CBB6C0](*(_QWORD *)&object, className);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x1E0CBB6E8](*(_QWORD *)&object);
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  return MEMORY[0x1E0CBB8E8](*(_QWORD *)&entry, properties, allocator, *(_QWORD *)&options);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1E0CBB8F8](*(_QWORD *)&entry, key, allocator, *(_QWORD *)&options);
}

kern_return_t IORegistryEntryCreateIterator(io_registry_entry_t entry, const io_name_t plane, IOOptionBits options, io_iterator_t *iterator)
{
  return MEMORY[0x1E0CBB908](*(_QWORD *)&entry, plane, *(_QWORD *)&options, iterator);
}

kern_return_t IORegistryEntryGetLocationInPlane(io_registry_entry_t entry, const io_name_t plane, io_name_t location)
{
  return MEMORY[0x1E0CBB930](*(_QWORD *)&entry, plane, location);
}

kern_return_t IORegistryEntryGetNameInPlane(io_registry_entry_t entry, const io_name_t plane, io_name_t name)
{
  return MEMORY[0x1E0CBB948](*(_QWORD *)&entry, plane, name);
}

kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  return MEMORY[0x1E0CBB950](*(_QWORD *)&entry, plane, parent);
}

kern_return_t IORegistryEntryGetPath(io_registry_entry_t entry, const io_name_t plane, io_string_t path)
{
  return MEMORY[0x1E0CBB968](*(_QWORD *)&entry, plane, path);
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  return MEMORY[0x1E0CBB980](*(_QWORD *)&entry, entryID);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1E0CBB998](*(_QWORD *)&entry, plane, key, allocator, *(_QWORD *)&options);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return MEMORY[0x1E0CBB9E8](*(_QWORD *)&mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0CBB9F8](name);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1E0CD65F8](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x1E0CD6618](allocator);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1E0C9A498]();
}

uint64_t _CFRuntimeInitStaticInstance()
{
  return MEMORY[0x1E0C9A4A8]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1E0C9A4B0]();
}

uint64_t _CFStringCreateWithFormatAndArgumentsAux()
{
  return MEMORY[0x1E0C9A508]();
}

uint64_t _CFStringGetUserDefaultEncoding()
{
  return MEMORY[0x1E0C9A538]();
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return MEMORY[0x1E0C9A800]();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return MEMORY[0x1E0C9A818]();
}

char ***_NSGetEnviron(void)
{
  return (char ***)MEMORY[0x1E0C809D0]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x1E0C80A58](a1, a2, *(_QWORD *)&a3, a4);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1E0C80B50](*(_QWORD *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1E0C80B68]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x1E0C80C40]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1E0C80C48]();
}

void _exit(int a1)
{
  MEMORY[0x1E0C80F80](*(_QWORD *)&a1);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _os_log_pack_fill()
{
  return MEMORY[0x1E0C81058]();
}

uint64_t _os_log_pack_size()
{
  return MEMORY[0x1E0C81060]();
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1E0C813D0](a1, *(_QWORD *)&a2);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1E0C81608](a1, a2);
}

mach_port_name_t audit_session_self(void)
{
  return MEMORY[0x1E0C816A8]();
}

gid_t audit_token_to_egid(audit_token_t *atoken)
{
  return MEMORY[0x1E0DE40D8](atoken);
}

uid_t audit_token_to_euid(audit_token_t *atoken)
{
  return MEMORY[0x1E0DE40E0](atoken);
}

pid_t audit_token_to_pid(audit_token_t *atoken)
{
  return MEMORY[0x1E0DE40F0](atoken);
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1E0C816B8](a1, *(_QWORD *)&a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return (char **)MEMORY[0x1E0C816C8](a1, *(_QWORD *)&a2);
}

int bcmp(const void *a1, const void *a2, size_t a3)
{
  return MEMORY[0x1E0C816E8](a1, a2, a3);
}

kern_return_t bootstrap_look_up(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1E0C81708](*(_QWORD *)&bp, service_name, sp);
}

uint64_t bootstrap_look_up2()
{
  return MEMORY[0x1E0C81710]();
}

uint64_t bootstrap_look_up_per_user()
{
  return MEMORY[0x1E0C81718]();
}

const char *__cdecl bootstrap_strerror(kern_return_t r)
{
  return (const char *)MEMORY[0x1E0C81730](*(_QWORD *)&r);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C82638](a1, a2);
}

int chown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x1E0C82640](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

uint64_t copyconninfo()
{
  return MEMORY[0x1E0CCED28]();
}

int copyfile(const char *from, const char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return MEMORY[0x1E0C82B18](from, to, state, *(_QWORD *)&flags);
}

copyfile_state_t copyfile_state_alloc(void)
{
  return (copyfile_state_t)MEMORY[0x1E0C82B20]();
}

int copyfile_state_free(copyfile_state_t a1)
{
  return MEMORY[0x1E0C82B28](a1);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA8](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
  MEMORY[0x1E0C82EE0](object, context);
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
  MEMORY[0x1E0C82EE8](object, finalizer);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F48](source, handler);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

int dup2(int a1, int a2)
{
  return MEMORY[0x1E0C83088](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

uint64_t dyld_process_is_restricted()
{
  return MEMORY[0x1E0C83128]();
}

int execv(const char *__path, char *const *__argv)
{
  return MEMORY[0x1E0C83268](__path, __argv);
}

void exit(int a1)
{
  MEMORY[0x1E0C83278](*(_QWORD *)&a1);
}

int fchmod(int a1, mode_t a2)
{
  return MEMORY[0x1E0C832D0](*(_QWORD *)&a1, a2);
}

int fchown(int a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x1E0C832E0](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  return (FILE *)MEMORY[0x1E0C83318](*(_QWORD *)&a1, a2);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1E0C83370](a1);
}

uint64_t fileport_makeport()
{
  return MEMORY[0x1E0C833C0]();
}

pid_t fork(void)
{
  return MEMORY[0x1E0C83468]();
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1E0C83488](*(_QWORD *)&a1, a2);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

uint64_t freeconninfo()
{
  return MEMORY[0x1E0CCED30]();
}

void freeifaddrs(ifaddrs *a1)
{
  MEMORY[0x1E0C834D0](a1);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1E0C83560](*(_QWORD *)&a1, a2);
}

int fstatfs(int a1, statfs *a2)
{
  return MEMORY[0x1E0C83570](*(_QWORD *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x1E0C83610](a1, a2, a3, a4, *(_QWORD *)&a5);
}

int getdtablesize(void)
{
  return MEMORY[0x1E0C83650]();
}

gid_t getegid(void)
{
  return MEMORY[0x1E0C83658]();
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1E0C83660](a1);
}

uid_t geteuid(void)
{
  return MEMORY[0x1E0C83668]();
}

int getgrnam_r(const char *a1, group *a2, char *a3, size_t a4, group **a5)
{
  return MEMORY[0x1E0C83698](a1, a2, a3, a4, a5);
}

int getifaddrs(ifaddrs **a1)
{
  return MEMORY[0x1E0C836C8](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x1E0C83760]();
}

const char *getprogname(void)
{
  return (const char *)MEMORY[0x1E0C83778]();
}

int getpwuid_r(uid_t a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x1E0C837A8](*(_QWORD *)&a1, a2, a3, a4, a5);
}

servent *__cdecl getservbyname(const char *a1, const char *a2)
{
  return (servent *)MEMORY[0x1E0C837F8](a1, a2);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1E0C83820](a1, a2);
}

char *__cdecl if_indextoname(unsigned int a1, char *a2)
{
  return (char *)MEMORY[0x1E0C83900](*(_QWORD *)&a1, a2);
}

unsigned int if_nametoindex(const char *a1)
{
  return MEMORY[0x1E0C83910](a1);
}

char *__cdecl index(const char *a1, int a2)
{
  return (char *)MEMORY[0x1E0C83948](a1, *(_QWORD *)&a2);
}

int inet_aton(const char *a1, in_addr *a2)
{
  return MEMORY[0x1E0C83958](a1, a2);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return (const char *)MEMORY[0x1E0C83968](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

int inet_pton(int a1, const char *a2, void *a3)
{
  return MEMORY[0x1E0C83970](*(_QWORD *)&a1, a2, a3);
}

int initgroups(const char *a1, int a2)
{
  return MEMORY[0x1E0C83978](a1, *(_QWORD *)&a2);
}

int ioctl(int a1, unint64_t a2, ...)
{
  return MEMORY[0x1E0C83980](*(_QWORD *)&a1, a2);
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1E0C83BB0](a1, a2);
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1E0C83C80](*(_QWORD *)&error_value);
}

uint64_t mach_get_times()
{
  return MEMORY[0x1E0C83C88]();
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x1E0C83CB0](msg, *(_QWORD *)&option, *(_QWORD *)&send_size, *(_QWORD *)&rcv_size, *(_QWORD *)&rcv_name, *(_QWORD *)&timeout, *(_QWORD *)&notify);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
  MEMORY[0x1E0C83CC0](a1);
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return MEMORY[0x1E0C83CE0](*(_QWORD *)&task, *(_QWORD *)&right, name);
}

kern_return_t mach_port_construct(ipc_space_t task, mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  return MEMORY[0x1E0C83CE8](*(_QWORD *)&task, options, context, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1E0C83CF8](*(_QWORD *)&task, *(_QWORD *)&name);
}

kern_return_t mach_port_destruct(ipc_space_t task, mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  return MEMORY[0x1E0C83D08](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&srdelta, guard);
}

kern_return_t mach_port_get_attributes(ipc_space_read_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  return MEMORY[0x1E0C83D20](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&flavor, port_info_out, port_info_outCnt);
}

kern_return_t mach_port_get_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_urefs_t *refs)
{
  return MEMORY[0x1E0C83D30](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&right, refs);
}

kern_return_t mach_port_insert_right(ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return MEMORY[0x1E0C83D48](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&poly, *(_QWORD *)&polyPoly);
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return MEMORY[0x1E0C83D58](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&right, *(_QWORD *)&delta);
}

kern_return_t mach_port_names(ipc_space_t task, mach_port_name_array_t *names, mach_msg_type_number_t *namesCnt, mach_port_type_array_t *types, mach_msg_type_number_t *typesCnt)
{
  return MEMORY[0x1E0C83D68](*(_QWORD *)&task, names, namesCnt, types, typesCnt);
}

kern_return_t mach_port_request_notification(ipc_space_t task, mach_port_name_t name, mach_msg_id_t msgid, mach_port_mscount_t sync, mach_port_t notify, mach_msg_type_name_t notifyPoly, mach_port_t *previous)
{
  return MEMORY[0x1E0C83D70](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&msgid, *(_QWORD *)&sync, *(_QWORD *)&notify, *(_QWORD *)&notifyPoly, previous);
}

kern_return_t mach_port_set_attributes(ipc_space_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info, mach_msg_type_number_t port_infoCnt)
{
  return MEMORY[0x1E0C83D78](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&flavor, port_info, *(_QWORD *)&port_infoCnt);
}

kern_return_t mach_port_type(ipc_space_t task, mach_port_name_t name, mach_port_type_t *ptype)
{
  return MEMORY[0x1E0C83D88](*(_QWORD *)&task, *(_QWORD *)&name, ptype);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void mig_dealloc_reply_port(mach_port_t reply_port)
{
  MEMORY[0x1E0C840E8](*(_QWORD *)&reply_port);
}

uint64_t mig_dealloc_special_reply_port()
{
  return MEMORY[0x1E0C840F0]();
}

mach_port_t mig_get_reply_port(void)
{
  return MEMORY[0x1E0C84100]();
}

uint64_t mig_get_special_reply_port()
{
  return MEMORY[0x1E0C84108]();
}

void mig_put_reply_port(mach_port_t reply_port)
{
  MEMORY[0x1E0C84110](*(_QWORD *)&reply_port);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C84160](a1, a2);
}

uint64_t ne_session_always_on_vpn_configs_present()
{
  return MEMORY[0x1E0C84258]();
}

uint64_t ne_session_app_vpn_configs_present()
{
  return MEMORY[0x1E0C84260]();
}

uint64_t ne_session_cancel()
{
  return MEMORY[0x1E0C84268]();
}

uint64_t ne_session_copy_policy_match()
{
  return MEMORY[0x1E0C84278]();
}

uint64_t ne_session_create()
{
  return MEMORY[0x1E0C84280]();
}

uint64_t ne_session_get_info()
{
  return MEMORY[0x1E0C84298]();
}

uint64_t ne_session_get_status()
{
  return MEMORY[0x1E0C842A0]();
}

uint64_t ne_session_policy_match_get_service()
{
  return MEMORY[0x1E0C842B0]();
}

uint64_t ne_session_policy_match_get_service_action()
{
  return MEMORY[0x1E0C842B8]();
}

uint64_t ne_session_policy_match_get_service_type()
{
  return MEMORY[0x1E0C842C0]();
}

uint64_t ne_session_release()
{
  return MEMORY[0x1E0C842C8]();
}

uint64_t ne_session_retain()
{
  return MEMORY[0x1E0C842D0]();
}

uint64_t ne_session_send_barrier()
{
  return MEMORY[0x1E0C842D8]();
}

uint64_t ne_session_set_event_handler()
{
  return MEMORY[0x1E0C842F0]();
}

uint64_t ne_session_start_on_behalf_of()
{
  return MEMORY[0x1E0C842F8]();
}

uint64_t ne_session_start_with_options()
{
  return MEMORY[0x1E0C84300]();
}

uint64_t ne_session_stop()
{
  return MEMORY[0x1E0C84308]();
}

uint64_t ne_session_use_as_system_vpn()
{
  return MEMORY[0x1E0C84310]();
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1E0C843D8](*(_QWORD *)&token);
}

uint32_t notify_check(int token, int *check)
{
  return MEMORY[0x1E0C843E0](*(_QWORD *)&token, check);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1E0C843E8](*(_QWORD *)&token, state64);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1E0C843F8](name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x1E0C84400](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

uint64_t nw_array_apply()
{
  return MEMORY[0x1E0CCEE98]();
}

uint64_t nw_array_get_count()
{
  return MEMORY[0x1E0CCEEA8]();
}

nw_endpoint_t nw_endpoint_create_address(const sockaddr *address)
{
  return (nw_endpoint_t)MEMORY[0x1E0CCF388](address);
}

nw_endpoint_t nw_endpoint_create_host(const char *hostname, const char *port)
{
  return (nw_endpoint_t)MEMORY[0x1E0CCF3B0](hostname, port);
}

const sockaddr *__cdecl nw_endpoint_get_address(nw_endpoint_t endpoint)
{
  return (const sockaddr *)MEMORY[0x1E0CCF3D8](endpoint);
}

const char *__cdecl nw_endpoint_get_hostname(nw_endpoint_t endpoint)
{
  return (const char *)MEMORY[0x1E0CCF410](endpoint);
}

uint16_t nw_endpoint_get_port(nw_endpoint_t endpoint)
{
  return MEMORY[0x1E0CCF428](endpoint);
}

nw_endpoint_type_t nw_endpoint_get_type(nw_endpoint_t endpoint)
{
  return MEMORY[0x1E0CCF440](endpoint);
}

uint64_t nw_interface_create_with_index()
{
  return MEMORY[0x1E0CCF6F0]();
}

uint64_t nw_interface_get_subtype()
{
  return MEMORY[0x1E0CCF720]();
}

nw_interface_type_t nw_interface_get_type(nw_interface_t interface)
{
  return MEMORY[0x1E0CCF728](interface);
}

uint64_t nw_nat64_copy_prefixes()
{
  return MEMORY[0x1E0CCF848]();
}

uint64_t nw_nat64_synthesize_v6()
{
  return MEMORY[0x1E0CCF868]();
}

nw_parameters_t nw_parameters_copy(nw_parameters_t parameters)
{
  return (nw_parameters_t)MEMORY[0x1E0CCF8B8](parameters);
}

nw_parameters_t nw_parameters_create(void)
{
  return (nw_parameters_t)MEMORY[0x1E0CCF930]();
}

uint64_t nw_parameters_get_required_interface_index()
{
  return MEMORY[0x1E0CCF9F0]();
}

void nw_parameters_require_interface(nw_parameters_t parameters, nw_interface_t interface)
{
  MEMORY[0x1E0CCFA48](parameters, interface);
}

uint64_t nw_parameters_set_account_id()
{
  return MEMORY[0x1E0CCFA50]();
}

uint64_t nw_parameters_set_e_proc_uuid()
{
  return MEMORY[0x1E0CCFAB8]();
}

uint64_t nw_parameters_set_effective_audit_token()
{
  return MEMORY[0x1E0CCFAC8]();
}

uint64_t nw_parameters_set_effective_bundle_id()
{
  return MEMORY[0x1E0CCFAD0]();
}

uint64_t nw_parameters_set_local_address()
{
  return MEMORY[0x1E0CCFB30]();
}

uint64_t nw_parameters_set_pid()
{
  return MEMORY[0x1E0CCFB70]();
}

uint64_t nw_parameters_set_required_address_family()
{
  return MEMORY[0x1E0CCFBE8]();
}

uint64_t nw_parameters_set_resolve_ptr()
{
  return MEMORY[0x1E0CCFC10]();
}

uint64_t nw_parameters_set_source_application()
{
  return MEMORY[0x1E0CCFC38]();
}

uint64_t nw_parameters_set_source_application_by_bundle_id()
{
  return MEMORY[0x1E0CCFC40]();
}

uint64_t nw_path_copy_derived_parameters()
{
  return MEMORY[0x1E0CCFCA8]();
}

uint64_t nw_path_copy_endpoint()
{
  return MEMORY[0x1E0CCFCC0]();
}

uint64_t nw_path_copy_interface()
{
  return MEMORY[0x1E0CCFCD0]();
}

uint64_t nw_path_copy_netagent_dictionary()
{
  return MEMORY[0x1E0CCFCE0]();
}

uint64_t nw_path_create_default_evaluator()
{
  return MEMORY[0x1E0CCFD00]();
}

uint64_t nw_path_create_evaluator_for_endpoint()
{
  return MEMORY[0x1E0CCFD10]();
}

uint64_t nw_path_evaluator_cancel()
{
  return MEMORY[0x1E0CCFD20]();
}

uint64_t nw_path_evaluator_copy_path()
{
  return MEMORY[0x1E0CCFD38]();
}

uint64_t nw_path_evaluator_set_cancel_handler()
{
  return MEMORY[0x1E0CCFD48]();
}

uint64_t nw_path_evaluator_set_update_handler()
{
  return MEMORY[0x1E0CCFD58]();
}

uint64_t nw_path_get_flow_divert_unit()
{
  return MEMORY[0x1E0CCFD80]();
}

uint64_t nw_path_get_interface_index()
{
  return MEMORY[0x1E0CCFD90]();
}

nw_path_status_t nw_path_get_status(nw_path_t path)
{
  return MEMORY[0x1E0CCFDE0](path);
}

uint64_t nw_path_get_vpn_config_id()
{
  return MEMORY[0x1E0CCFDF0]();
}

uint64_t nw_path_is_direct()
{
  return MEMORY[0x1E0CCFE18]();
}

uint64_t nw_path_is_flow_divert()
{
  return MEMORY[0x1E0CCFE28]();
}

uint64_t nw_path_is_local()
{
  return MEMORY[0x1E0CCFE30]();
}

BOOL nw_path_uses_interface_type(nw_path_t path, nw_interface_type_t interface_type)
{
  return MEMORY[0x1E0CCFE88](path, *(_QWORD *)&interface_type);
}

void nw_release(void *obj)
{
  MEMORY[0x1E0CD0248](obj);
}

uint64_t nw_resolver_cancel()
{
  return MEMORY[0x1E0CD0290]();
}

uint64_t nw_resolver_create_with_endpoint()
{
  return MEMORY[0x1E0CD02F8]();
}

uint64_t nw_resolver_create_with_path()
{
  return MEMORY[0x1E0CD0300]();
}

uint64_t nw_resolver_set_cancel_handler()
{
  return MEMORY[0x1E0CD0308]();
}

uint64_t nw_resolver_set_update_handler()
{
  return MEMORY[0x1E0CD0310]();
}

void *__cdecl nw_retain(void *obj)
{
  return (void *)MEMORY[0x1E0CD0318](obj);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1E0C84480](a1, *(_QWORD *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x1E0C84488](a1, *(_QWORD *)&a2, *(_QWORD *)&a3, *(_QWORD *)&a4);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

uint64_t os_log_pack_compose()
{
  return MEMORY[0x1E0C84738]();
}

uint64_t os_log_pack_send()
{
  return MEMORY[0x1E0C84740]();
}

uint64_t os_log_pack_send_and_compose()
{
  return MEMORY[0x1E0C84748]();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

uint64_t os_log_with_args()
{
  return MEMORY[0x1E0C84790]();
}

uint64_t os_state_add_handler()
{
  return MEMORY[0x1E0C84940]();
}

uint64_t os_variant_has_internal_content()
{
  return MEMORY[0x1E0C849F0]();
}

void perror(const char *a1)
{
  MEMORY[0x1E0C84AF0](a1);
}

int pipe(int a1[2])
{
  return MEMORY[0x1E0C84B10](a1);
}

int posix_spawn(pid_t *a1, const char *a2, const posix_spawn_file_actions_t *a3, const posix_spawnattr_t *a4, char *const __argv[], char *const __envp[])
{
  return MEMORY[0x1E0C84B38](a1, a2, a3, a4, __argv, __envp);
}

int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *a1, int a2, int a3)
{
  return MEMORY[0x1E0C84B48](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *a1, int a2, const char *a3, int a4, mode_t a5)
{
  return MEMORY[0x1E0C84B58](a1, *(_QWORD *)&a2, a3, *(_QWORD *)&a4, a5);
}

int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *a1)
{
  return MEMORY[0x1E0C84B60](a1);
}

int posix_spawn_file_actions_init(posix_spawn_file_actions_t *a1)
{
  return MEMORY[0x1E0C84B68](a1);
}

int posix_spawnattr_destroy(posix_spawnattr_t *a1)
{
  return MEMORY[0x1E0C84B70](a1);
}

int posix_spawnattr_init(posix_spawnattr_t *a1)
{
  return MEMORY[0x1E0C84B78](a1);
}

int posix_spawnattr_setflags(posix_spawnattr_t *a1, __int16 a2)
{
  return MEMORY[0x1E0C84B90](a1, a2);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return MEMORY[0x1E0C84C40](*(_QWORD *)&pid, *(_QWORD *)&flavor, arg, buffer, *(_QWORD *)&buffersize);
}

int pthread_atfork(void (*a1)(void), void (*a2)(void), void (*a3)(void))
{
  return MEMORY[0x1E0C84CA8](a1, a2, a3);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return (void *)MEMORY[0x1E0C84DC0](a1);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1E0C84DE0](a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E18](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E48](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1E0C84E60](a1, *(_QWORD *)&a2);
}

int pthread_setcanceltype(int a1, int *a2)
{
  return MEMORY[0x1E0C84F00](*(_QWORD *)&a1, a2);
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x1E0C84F18](a1, a2);
}

void pthread_testcancel(void)
{
  MEMORY[0x1E0C84F30]();
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1E0C85000](*(_QWORD *)&a1, a2, a3);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1E0C85030](__ptr, __size);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return MEMORY[0x1E0C850B8](__p, __ec);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x1E0C85100](__from, __to, __ec);
}

uint64_t sandbox_check()
{
  return MEMORY[0x1E0C85178]();
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  return MEMORY[0x1E0C85328](__name, __value, *(_QWORD *)&__overwrite);
}

int setgid(gid_t a1)
{
  return MEMORY[0x1E0C85338](*(_QWORD *)&a1);
}

int setuid(uid_t a1)
{
  return MEMORY[0x1E0C85390](*(_QWORD *)&a1);
}

int sigaction(int a1, const sigaction *a2, sigaction *a3)
{
  return MEMORY[0x1E0C853E0](*(_QWORD *)&a1, a2, a3);
}

int sigprocmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  return MEMORY[0x1E0C85400](*(_QWORD *)&a1, a2, a3);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x1E0C85450](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C85498](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x1E0C85500](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C85518](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1E0C85548](*(_QWORD *)&__errnum);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85568](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85570](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1E0C855C0](__s1, __n);
}

char *__cdecl strptime(const char *a1, const char *a2, tm *a3)
{
  return (char *)MEMORY[0x1E0C855D8](a1, a2, a3);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C855E8](__s, *(_QWORD *)&__c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85610](__s1, __s2);
}

uint64_t strtoq(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85690](__str, __endptr, *(_QWORD *)&__base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1E0C85798](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1E0C857A0](a1, a2, a3, a4, a5);
}

sysdir_search_path_enumeration_state sysdir_get_next_search_path_enumeration(sysdir_search_path_enumeration_state state, char *path)
{
  return MEMORY[0x1E0C857B8](*(_QWORD *)&state, path);
}

sysdir_search_path_enumeration_state sysdir_start_search_path_enumeration(sysdir_search_path_directory_t dir, sysdir_search_path_domain_mask_t domainMask)
{
  return MEMORY[0x1E0C857C0](*(_QWORD *)&dir, *(_QWORD *)&domainMask);
}

int unlink(const char *a1)
{
  return MEMORY[0x1E0C859B8](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1E0C859E0](*(_QWORD *)&a1);
}

void uuid_clear(uuid_t uu)
{
  MEMORY[0x1E0C85A00](uu);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
  MEMORY[0x1E0C85A10](dst, src);
}

int uuid_is_null(const uuid_t uu)
{
  return MEMORY[0x1E0C85A30](uu);
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return MEMORY[0x1E0C85A38](in, uu);
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
  MEMORY[0x1E0C85A40](uu, out);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x1E0C85A80](*(_QWORD *)&target_task, address, size, *(_QWORD *)&flags);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1E0C85A98](*(_QWORD *)&target_task, address, size);
}

BOOLean_t voucher_mach_msg_set(mach_msg_header_t *msg)
{
  return MEMORY[0x1E0C85B60](msg);
}

pid_t wait4(pid_t a1, int *a2, int a3, rusage *a4)
{
  return MEMORY[0x1E0C85BC8](*(_QWORD *)&a1, a2, *(_QWORD *)&a3, a4);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1E0C85D40](*(_QWORD *)&__fd, __buf, __nbyte);
}

void xpc_connection_activate(xpc_connection_t connection)
{
  MEMORY[0x1E0C85F50](connection);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1E0C85FB0](name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
  MEMORY[0x1E0C86018](connection);
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
  MEMORY[0x1E0C86030](connection, message);
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1E0C86048](connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
  MEMORY[0x1E0C86080](connection, handler);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return MEMORY[0x1E0C861F0](xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C86208](keys, values, count);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C86260](xdict, key);
}

size_t xpc_dictionary_get_count(xpc_object_t xdict)
{
  return MEMORY[0x1E0C86270](xdict);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x1E0C86278](xdict, key, length);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862A0](xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1E0C862C8](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C862E0](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
  MEMORY[0x1E0C86310](xdict, key, value);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
  MEMORY[0x1E0C86360](xdict, key, value);
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x1E0C86390](xdict, key, string);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1E0C86520](object);
}

void xpc_release(xpc_object_t object)
{
  MEMORY[0x1E0C86658](object);
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1E0C86660](object);
}

uint64_t xpc_user_sessions_enabled()
{
  return MEMORY[0x1E0C867C8]();
}

