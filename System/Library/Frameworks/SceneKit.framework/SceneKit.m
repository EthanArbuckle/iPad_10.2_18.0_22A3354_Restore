void C3DArrayApply(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DArrayGetCount_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (*(_DWORD *)(a1 + 24))
  {
    v12 = 0;
    do
    {
      (*(void (**)(uint64_t, unint64_t, _QWORD))(a2 + 16))(a2, v12, *(_QWORD *)(a1 + 16) + (*(_DWORD *)(a1 + 32) * v12));
      ++v12;
    }
    while (v12 < *(unsigned int *)(a1 + 24));
  }
}

void C3DProgramHashCodeRelease(uint64_t a1)
{
  _QWORD block[5];

  if (a1)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __C3DProgramHashCodeRelease_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = a1;
    dispatch_sync((dispatch_queue_t)s_ProgramHashCodeDictionaryQueue, block);
  }
}

uint64_t C3DTransactionFlush()
{
  uint64_t result;
  uint64_t v1;
  char v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t Stack;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  BOOL v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  __CFSet *Mutable;
  __CFArray *v21;
  _QWORD *v22;
  uint64_t v23;
  double v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  uint64_t AnimationManager;
  uint64_t v31;
  float32x4_t *v32;
  const __CFString *v33;
  const __CFString *v34;
  uint64_t TargetAddress;
  unint64_t v36;
  char v37;
  char v38;
  uint64x2_t v39;
  int8x16_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  uint32x4_t v45;
  int32x4_t v46;
  __CFString *v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  const __CFString *v51;
  size_t Length;
  uint64_t v53;
  uint64_t v54;
  size_t v55;
  size_t v56;
  const void *v57;
  double v58;
  size_t v59;
  float v60;
  const void *v61;
  uint64_t ModelValueStorage;
  __CFString *v63;
  void *v64;
  size_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  const void *v69;
  _QWORD *v70;
  const void *v71;
  const void *v72;
  const void *v73;
  const void *v74;
  _QWORD *v75;
  CFNotificationCenterRef LocalCenter;
  NSObject *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  void *v87;
  void *v88;
  const void *v89;
  char *v90;
  void *v91;
  char *v92;
  char *v93;
  char *data;
  uint64_t v95;
  CFTypeRef cf;
  uint64_t v97;
  const __CFString *v98;
  __CFString *v99;
  int BaseType;
  void *v101;
  __CFSet *v102;
  void *v103;
  char *v104;
  UInt8 bytes[32];
  uint64_t v106;
  CFRange v107;

  v106 = *MEMORY[0x1E0C80C00];
  result = ((uint64_t (*)(void))C3DTransactionGetStack)();
  if ((*(_BYTE *)(result + 52) & 4) != 0)
    return result;
  v1 = result;
  if (*(_DWORD *)(result + 48))
  {
    v2 = *(_BYTE *)(result + 52) | 2;
LABEL_4:
    *(_BYTE *)(v1 + 52) = v2;
    return result;
  }
  pthread_rwlock_rdlock(&gCommandQueueFlushLock);
  os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
  v3 = gTransactionStacks;
  if (!gTransactionStacks)
  {
LABEL_9:
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    return pthread_rwlock_unlock(&gCommandQueueFlushLock);
  }
  while (!*(_QWORD *)(v3 + 32))
  {
    v3 = *(_QWORD *)(v3 + 8);
    if (!v3)
      goto LABEL_9;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
  v4 = pthread_rwlock_unlock(&gCommandQueueFlushLock);
  Stack = C3DTransactionGetStack(v4);
  pthread_rwlock_wrlock(&gCommandQueueFlushLock);
  *(_BYTE *)(Stack + 52) |= 1u;
  kdebug_trace();
  os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
  v6 = gTransactionStacks;
  if (!gTransactionStacks)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
LABEL_75:
    v67 = kdebug_trace();
    v1 = C3DTransactionGetStack(v67);
    result = pthread_rwlock_unlock(&gCommandQueueFlushLock);
    v2 = *(_BYTE *)(v1 + 52) & 0xFE;
    goto LABEL_4;
  }
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = 0;
    v10 = v8;
    v11 = 3.40282347e38;
    do
    {
      v12 = v9;
      v13 = *(_QWORD *)(v6 + 32);
      if (!v13)
      {
        v9 = v12;
LABEL_22:
        v15 = v11;
        goto LABEL_23;
      }
      v14 = *(_QWORD *)(v13 + 32);
      v15 = *(double *)(v14 + 40);
      v16 = v15 != 0.0 && v15 < v11;
      v9 = v6;
      if (!v16)
      {
        if ((*(_BYTE *)(v14 + 60) & 2) != 0)
          v9 = v6;
        else
          v9 = v12;
        goto LABEL_22;
      }
LABEL_23:
      v6 = *(_QWORD *)(v6 + 8);
      v11 = v15;
    }
    while (v6);
    if (!v9)
      break;
    v17 = *(_QWORD **)(v9 + 32);
    v18 = v17[4];
    v8 = v17;
    if (v10)
    {
      if (v7)
        *v7 = v17;
      v8 = v10;
    }
    while (1)
    {
      v7 = v17;
      if (!v17[5] && v17[4] == v18)
        break;
      v17 = (_QWORD *)*v17;
      if (!*v7)
      {
        *(_QWORD *)(v9 + 32) = 0;
LABEL_33:
        *(_QWORD *)(v9 + 40) = 0;
        goto LABEL_34;
      }
    }
    v19 = *v17;
    *(_QWORD *)(v9 + 32) = *v17;
    if (!v19)
      goto LABEL_33;
LABEL_34:
    *v7 = 0;
    v6 = gTransactionStacks;
  }
  while (gTransactionStacks);
  os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
  if (!v8)
    goto LABEL_75;
  Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  *(_BYTE *)(v1 + 52) |= 4u;
  v21 = 0;
  gAtomicTime = CACurrentMediaTime();
  v22 = v8;
  do
  {
    v23 = v22[4];
    if (v22[5])
    {
      gCurrentlyCommittedTransaction = v22[4];
      v24 = 0.0;
      if ((*(_BYTE *)(v23 + 60) & 4) == 0)
        v24 = *(double *)(v23 + 32);
      v25 = *(const void **)(v23 + 24);
      if (!v25)
      {
        C3DTimingFunctionGetDefaultFunction();
        v25 = v26;
      }
      v27 = (const void *)v22[2];
      if (v27)
      {
        if (CFTypeIsC3DEntity(v27))
        {
          v28 = (const void *)C3DGetScene((_QWORD *)v22[2]);
          if (v28)
          {
            v29 = v28;
            if (!CFSetContainsValue(Mutable, v28))
            {
              CFSetAddValue(Mutable, v29);
              C3DSceneLock((uint64_t)v29);
            }
            AnimationManager = C3DSceneGetAnimationManager((uint64_t)v29);
            if (AnimationManager)
            {
              v31 = AnimationManager;
              v32 = (float32x4_t *)v22[2];
              if (v32)
              {
                v33 = (const __CFString *)v22[3];
                if (v33)
                {
                  v102 = Mutable;
                  v103 = (void *)v22[2];
                  v34 = C3DCFTypeCopyModelInfoAtPath(v32, v33, 0);
                  TargetAddress = C3DModelTargetGetTargetAddress((uint64_t)v34);
                  if (v34 && TargetAddress)
                  {
                    v97 = v31;
                    v36 = TargetAddress;
                    BaseType = C3DModelTargetGetBaseType((uint64_t)v34);
                    v37 = BYTE2(v34[1].isa);
                    v98 = v34;
                    v38 = BYTE3(v34[1].isa);
                    qmemcpy(bytes, "transition-0x", 13);
                    v101 = (void *)v36;
                    v39 = (uint64x2_t)vdupq_n_s64(v36);
                    v40.i64[0] = 0xF0000000FLL;
                    v40.i64[1] = 0xF0000000FLL;
                    v41 = (int32x4_t)vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1DD02B040), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1DD02B030)), v40);
                    v42 = (int32x4_t)vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1DD02B060), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1DD02B050)), v40);
                    v43 = (int32x4_t)vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1DD02B080), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1DD02B070)), v40);
                    v44 = (int32x4_t)vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1DD02B0A0), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1DD02B090)), v40);
                    v45.i64[0] = 0xA0000000ALL;
                    v45.i64[1] = 0xA0000000ALL;
                    v46.i64[0] = 0x5700000057;
                    v46.i64[1] = 0x5700000057;
                    *(int8x16_t *)&bytes[13] = vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v45, (uint32x4_t)v42), (int8x16_t)(*(_OWORD *)&v42 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v42, v46)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v45, (uint32x4_t)v41), (int8x16_t)(*(_OWORD *)&v41 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v41, v46))), (int8x16_t)vuzp1q_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v45, (uint32x4_t)v44), (int8x16_t)(*(_OWORD *)&v44 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v44, v46)), (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u32(v45, (uint32x4_t)v43), (int8x16_t)(*(_OWORD *)&v43 | __PAIR128__(0x3000000030, 0x3000000030)), (int8x16_t)vaddq_s32(v43, v46))));
                    bytes[29] = v37 + 97;
                    bytes[30] = v38 + 97;
                    bytes[31] = 0;
                    v47 = (__CFString *)CFStringCreateWithBytes(0, bytes, 31, 0x8000100u, 0);
                    v99 = v47;
                    if (v24 > 0.0)
                    {
                      v50 = C3DValueCreate(BaseType, 1);
                      v51 = v98;
                      data = v98->data;
                      cf = (CFTypeRef)v50;
                      v91 = (void *)C3DValueGetBytes(v50);
                      Length = C3DValueGetLength(v50);
                      C3DGetValue(data, v101, v91, Length, SBYTE2(v51[1].isa), BYTE3(v51[1].isa));
                      (*(void (**)(double))(v22[5] + 16))(v24);
                      v53 = C3DValueCreate(BaseType, 1);
                      v92 = v98->data;
                      v95 = v53;
                      v54 = v53;
                      v88 = (void *)C3DValueGetBytes(v53);
                      v55 = C3DValueGetLength(v54);
                      C3DGetValue(v92, v101, v88, v55, SBYTE2(v51[1].isa), BYTE3(v51[1].isa));
                      v93 = v98->data;
                      v89 = (const void *)C3DValueGetBytes((uint64_t)cf);
                      v56 = C3DValueGetLength((uint64_t)cf);
                      C3DSetValue(v93, v101, v89, v56, SBYTE2(v51[1].isa), BYTE3(v51[1].isa));
                      v57 = (const void *)C3DSimpleAnimationCreate();
                      C3DAnimationSetIsSceneTimeBased((uint64_t)v57, 0);
                      C3DSimpleAnimationSetEndValue((uint64_t)v57, v95);
                      v58 = *(double *)&gAtomicTime;
                      if (*(double *)&gAtomicTime == 0.0)
                      {
                        v58 = CACurrentMediaTime();
                        gAtomicTime = *(_QWORD *)&v58;
                      }
                      C3DAnimationManagerSetSystemTime(v97, v58);
                      v34 = v98;
                      C3DAnimationManagerApplyAnimationsForTarget(v97, (uint64_t)v98);
                      v90 = v98->data;
                      v87 = (void *)C3DValueGetBytes((uint64_t)cf);
                      v59 = C3DValueGetLength((uint64_t)cf);
                      C3DGetValue(v90, v101, v87, v59, SBYTE2(v34[1].isa), BYTE3(v34[1].isa));
                      C3DSimpleAnimationSetStartValue((uint64_t)v57, (uint64_t)cf);
                      C3DAnimationSetIsImplicit((uint64_t)v57, 1);
                      v60 = v24;
                      C3DAnimationSetDuration((uint64_t)v57, v60);
                      C3DAnimationSetTimingFunction((uint64_t)v57, v25);
                      C3DAnimationManagerExecRemoveAnimation(v97, v103, v99);
                      C3DAnimationManagerAddAnimationForKey(v97, v57, v98, v103, v99);
                      CFRelease(v57);
                      CFRelease(cf);
                      v61 = (const void *)v95;
                      if (v95)
                      {
                        ModelValueStorage = C3DSceneGetModelValueStorage((uint64_t)v29);
                        C3DModelValueStorageUpdateModelValueWithValue(ModelValueStorage, (uint64_t)v98, v95);
                        v63 = v99;
LABEL_74:
                        CFRelease(v63);
                        CFRelease(v34);
                        CFRelease(v61);
                        Mutable = v102;
                        goto LABEL_66;
                      }
                    }
                    else
                    {
                      C3DAnimationManagerExecRemoveAnimation(v97, v103, v47);
                    }
                    (*(void (**)(double))(v22[5] + 16))(v24);
                    v61 = (const void *)C3DValueCreate(BaseType, 1);
                    v104 = v34->data;
                    v64 = (void *)C3DValueGetBytes((uint64_t)v61);
                    v65 = C3DValueGetLength((uint64_t)v61);
                    C3DGetValue(v104, v101, v64, v65, SBYTE2(v34[1].isa), BYTE3(v34[1].isa));
                    v66 = C3DSceneGetModelValueStorage((uint64_t)v29);
                    C3DModelValueStorageUpdateModelValueWithValue(v66, (uint64_t)v34, (uint64_t)v61);
                    v63 = v99;
                    goto LABEL_74;
                  }
                  if (v34)
                    CFRelease(v34);
                  v48 = scn_default_log();
                  Mutable = v102;
                  if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                  {
                    v49 = v22[3];
                    *(_DWORD *)bytes = 138412546;
                    *(_QWORD *)&bytes[4] = v49;
                    *(_WORD *)&bytes[12] = 2112;
                    *(_QWORD *)&bytes[14] = v103;
                    _os_log_impl(&dword_1DCCB8000, v48, OS_LOG_TYPE_DEFAULT, "Warning: invalid keypath: %@ sent to object %@", bytes, 0x16u);
                  }
                }
              }
            }
          }
        }
      }
      (*(void (**)(double))(v22[5] + 16))(v24);
LABEL_66:
      gCurrentlyCommittedTransaction = 0;
      goto LABEL_67;
    }
    if (!v21)
      v21 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    CFArrayAppendValue(v21, (const void *)v23);
LABEL_67:
    v22 = (_QWORD *)*v22;
  }
  while (v22);
  if (v21)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
    v107.length = CFArrayGetCount(v21);
    v107.location = 0;
    CFArrayApplyFunction(v21, v107, (CFArrayApplierFunction)_transactionsDidFlush, 0);
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    CFRelease(v21);
  }
  v68 = v8;
  do
  {
    v70 = (_QWORD *)*v68;
    v69 = (const void *)v68[1];
    if (v69)
    {
      CFRelease(v69);
      v68[1] = 0;
    }
    v71 = (const void *)v68[2];
    if (v71)
    {
      CFRelease(v71);
      v68[2] = 0;
    }
    v72 = (const void *)v68[3];
    if (v72)
    {
      CFRelease(v72);
      v68[3] = 0;
    }
    v73 = (const void *)v68[4];
    if (v73)
    {
      CFRelease(v73);
      v68[4] = 0;
    }
    v74 = (const void *)v68[5];
    if (v74)
      _Block_release(v74);
    v68 = v70;
  }
  while (v70);
  os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
  do
  {
    v75 = (_QWORD *)*v8;
    C3DAllocatorDelete(gCommandAllocator, (unint64_t)v8);
    v8 = v75;
  }
  while (v75);
  os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
  CFSetApplyFunction(Mutable, (CFSetApplierFunction)_C3DUnlockScenesAndBumpStateStamps, 0);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  if (!LocalCenter)
  {
    v77 = scn_default_log();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
      C3DTransactionFlush_cold_1(v77, v78, v79, v80, v81, v82, v83, v84);
  }
  CFSetApplyFunction(Mutable, (CFSetApplierFunction)_C3DPostSceneDidChangeNotifications, LocalCenter);
  *(_BYTE *)(v1 + 52) &= ~4u;
  if (Mutable)
    CFRelease(Mutable);
  v86 = C3DTransactionGetStack(v85);
  pthread_rwlock_unlock(&gCommandQueueFlushLock);
  *(_BYTE *)(v86 + 52) &= ~1u;
  return kdebug_trace();
}

uint64_t C3DGetScene(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DGeometryFillLibraryForSerialization_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((CFTypeIsC3DEntity(a1) & 1) == 0)
  {
    v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      C3DGetScene_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
  }
  return a1[6];
}

const void *CFTypeIsC3DEntity(const void *result)
{
  const void *v1;

  if (result)
  {
    v1 = (const void *)CFGetTypeID(result);
    if (CFTypeIsC3DEntity_onceToken != -1)
      dispatch_once(&CFTypeIsC3DEntity_onceToken, &__block_literal_global_24);
    return (const void *)(CFDictionaryGetValue((CFDictionaryRef)CFTypeIsC3DEntity__cfTypeRegistry, v1) != 0);
  }
  return result;
}

void C3DAllocatorDelete(uint64_t a1, unint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  NSObject *v21;
  uint64_t v22;
  char *v23;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DAllocatorNew_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v13 = (uint64_t *)(a1 + 48);
  v12 = *(_QWORD *)(a1 + 48);
  if (v12 < 1)
  {
LABEL_11:
    v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      C3DAllocatorDelete_cold_1(v21);
  }
  else
  {
    v14 = 0;
    v15 = 0;
    v16 = *(_QWORD *)(a1 + 16);
    v17 = *(_QWORD *)(a1 + 24);
    v18 = *(_QWORD *)(a1 + 32);
    while (1)
    {
      v19 = *(_QWORD *)(v18 + v14);
      if (v19 <= a2 && v19 + v17 * v16 > a2)
        break;
      ++v15;
      v14 += 16;
      if (!--v12)
        goto LABEL_11;
    }
    C3DIndexSetAddIndex(*(_QWORD *)(a1 + 40), (a2 - v19) / v16 + v15 * v17);
    v22 = *(int *)(v18 + v14 + 8) + 1;
    *(_DWORD *)(v18 + v14 + 8) = v22;
    if (*(_QWORD *)(a1 + 24) == v22 && (!*(_BYTE *)(a1 + 64) || *v13 >= 2))
    {
      ++*(_QWORD *)(a1 + 56);
      free(*(void **)(*(_QWORD *)(a1 + 32) + v14));
      v23 = *(char **)(a1 + 32);
      *(_QWORD *)&v23[v14] = 0;
      if (*(_QWORD *)(a1 + 56) == *(_QWORD *)(a1 + 48))
      {
        free(v23);
        *(_QWORD *)(a1 + 32) = 0;
        C3DIndexSetRemoveAllIndexes(*(_QWORD *)(a1 + 40));
        *v13 = 0;
        *(_QWORD *)(a1 + 56) = 0;
      }
    }
  }
}

void C3DIndexSetAddIndexesInRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;

  if (!a3)
    return;
  v3 = a3;
  v6 = a2 + a3;
  v7 = _indexOfRangeBeforeOrContainingIndex(a1, a2);
  if (v7 == -1)
    v8 = 0;
  else
    v8 = v7;
  v9 = a1 + 24;
  for (i = 16 * v8; ; i += 16)
  {
    v11 = (*(_BYTE *)(a1 + 16) & 1) == 0;
    if ((*(_BYTE *)(a1 + 16) & 3) == 0)
      v11 = *(_QWORD *)(*(_QWORD *)v9 + 8);
    if (v8 >= v11)
      break;
    v12 = a1 + 24;
    if ((*(_BYTE *)(a1 + 16) & 2) == 0)
      v12 = *(_QWORD *)v9 + 56;
    v13 = (uint64_t *)(v12 + i);
    v14 = *v13;
    v15 = v6 - *v13;
    if (v6 < *v13)
    {
      _insertRange(a1, a2, v3, v8);
      return;
    }
    v16 = v13[1] + v14;
    if (a2 < v14)
    {
      v14 = a2;
      if (v6 <= v16)
        v15 = v16 - a2;
      else
        v15 = v3;
      if (v6 <= v16)
        v3 = v16 - a2;
LABEL_22:
      _replaceRangeInArrayAtIndex(a1, v8, v14, v15);
      break;
    }
    if (v6 <= v16)
      return;
    if (v16 >= a2)
      goto LABEL_22;
    ++v8;
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    if (v8)
      goto LABEL_38;
    v18 = 1;
  }
  else if ((*(_BYTE *)(a1 + 16) & 2) != 0)
  {
    if (v8 != 1)
      goto LABEL_38;
    v18 = 2;
  }
  else
  {
    v17 = *(_QWORD *)(*(_QWORD *)v9 + 8);
    if (v17 != v8)
      goto LABEL_38;
    v18 = v17 + 1;
  }
  _ensureRangeCapacity(a1, v18);
  v19 = *(_BYTE *)(a1 + 16);
  if ((v19 & 2) != 0)
  {
    *(_QWORD *)(a1 + 24) = a2;
    *(_QWORD *)(a1 + 32) = v3;
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48) = 0;
    v20 = *(_QWORD *)(a1 + 24);
    if ((*(_BYTE *)(a1 + 16) & 2) != 0)
      v21 = a1 + 24;
    else
      v21 = v20 + 56;
    v22 = *(_QWORD *)(v20 + 8);
    *(_QWORD *)(v20 + 8) = v22 + 1;
    v23 = (uint64_t *)(v21 + 16 * v22);
    *v23 = a2;
    v23[1] = v3;
    *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) += v3;
    v19 = *(_BYTE *)(a1 + 16);
  }
  *(_BYTE *)(a1 + 16) = v19 & 0xFE;
LABEL_38:
  while (1)
  {
    if ((*(_BYTE *)(a1 + 16) & 1) != 0)
      v24 = 0;
    else
      v24 = (*(_BYTE *)(a1 + 16) & 2) != 0 ? 1 : *(_QWORD *)(*(_QWORD *)v9 + 8);
    if (v8 >= v24 - 1)
      break;
    v25 = a1 + 24;
    if ((*(_BYTE *)(a1 + 16) & 2) == 0)
      v25 = *(_QWORD *)v9 + 56;
    v26 = (uint64_t *)(v25 + 16 * v8);
    v27 = *v26;
    v28 = v26[1];
    v29 = (uint64_t *)(v25 + 16 * (v8 + 1));
    v30 = v28 + v27;
    if (v30 < *v29)
      break;
    v31 = v29[1] + *v29;
    if (v30 < v31)
    {
      _replaceRangeInArrayAtIndex(a1, v8, v27, v31 - v27);
      _removeRangeInArrayAtIndex(a1, ++v8);
    }
    else
    {
      _removeRangeInArrayAtIndex(a1, v8 + 1);
    }
  }
}

void C3DTransactionAddCommandBlock(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char **Stack;
  char *appended;
  CFTypeRef v30;
  CFTypeRef v31;
  CFTypeRef v32;
  CFTypeRef v33;

  if (!a6 && (v12 = scn_default_log(), os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)))
  {
    C3DTransactionAddCommandBlock_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
    if (a1)
      goto LABEL_6;
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  v20 = scn_default_log();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
    C3DTransactionAddCommandBlock_cold_1(v20, v21, v22, v23, v24, v25, v26, v27);
LABEL_6:
  Stack = (char **)C3DTransactionGetStack();
  os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
  appended = C3DCommandQueueAppendNewCommand(Stack + 4);
  if (a4 || (a4 = a2) != 0)
    v30 = CFRetain(a4);
  else
    v30 = 0;
  *((_QWORD *)appended + 2) = v30;
  if (a5)
    v31 = CFRetain(a5);
  else
    v31 = 0;
  *((_QWORD *)appended + 3) = v31;
  if (a3)
    v32 = CFRetain(a3);
  else
    v32 = 0;
  *((_QWORD *)appended + 1) = v32;
  *((_QWORD *)appended + 5) = _Block_copy(a6);
  if (a1)
    v33 = CFRetain(a1);
  else
    v33 = 0;
  *((_QWORD *)appended + 4) = v33;
  os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
}

const void *C3DTransactionGetCurrent()
{
  const __CFArray *v0;
  CFIndex v1;

  v0 = *(const __CFArray **)(C3DTransactionGetStack() + 16);
  v1 = CFArrayGetCount(v0) - 1;
  return CFArrayGetValueAtIndex(v0, v1);
}

void *C3DTransactionGetStack()
{
  void *v0;
  _QWORD *v1;
  _opaque_pthread_t *v3;
  __CFRunLoop *Current;
  CFRunLoopMode v5;
  __CFRunLoopObserver *v6;
  char __s1[64];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (_setupTransactionIfNeeded_onceToken != -1)
    dispatch_once(&_setupTransactionIfNeeded_onceToken, &__block_literal_global_9_3);
  v0 = pthread_getspecific(gTransactionKey);
  if (!v0)
  {
    v0 = malloc_type_calloc(0x38uLL, 1uLL, 0xFB6EB80uLL);
    *((_QWORD *)v0 + 2) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    pthread_setspecific(gTransactionKey, v0);
    _C3DTransactionBegin(1, 0.0);
    os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
    v1 = (_QWORD *)gTransactionStacks;
    *((_QWORD *)v0 + 1) = gTransactionStacks;
    if (v1)
      *v1 = v0;
    gTransactionStacks = (uint64_t)v0;
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    if (!*((_QWORD *)v0 + 3))
    {
      v3 = pthread_self();
      pthread_getname_np(v3, __s1, 0x40uLL);
      if (strcmp(__s1, "com.apple.scenekit.scnview-renderer"))
      {
        Current = CFRunLoopGetCurrent();
        v5 = CFRunLoopCopyCurrentMode(Current);
        v6 = CFRunLoopObserverCreate(0, 0xA0uLL, 1u, 2000000, (CFRunLoopObserverCallBack)_commitImplicitTransaction, 0);
        *((_QWORD *)v0 + 3) = v6;
        if (v6)
          CFRunLoopAddObserver(Current, v6, (CFRunLoopMode)*MEMORY[0x1E0C9B270]);
        if (v5)
        {
          if (*((_QWORD *)v0 + 3) && v5 != (CFRunLoopMode)*MEMORY[0x1E0C9B280])
          {
            if (!C3DTransactionStackStartImplicitTransactionIfNeeded_tracking_mode
              && CFEqual(v5, CFSTR("UITrackingRunLoopMode")))
            {
              C3DTransactionStackStartImplicitTransactionIfNeeded_tracking_mode = (uint64_t)CFRetain(v5);
              CFRunLoopAddObserver(Current, *((CFRunLoopObserverRef *)v0 + 3), v5);
            }
            if (v5 != (CFRunLoopMode)C3DTransactionStackStartImplicitTransactionIfNeeded_tracking_mode)
              CFRunLoopAddObserver(Current, *((CFRunLoopObserverRef *)v0 + 3), v5);
          }
          CFRelease(v5);
        }
      }
    }
  }
  return v0;
}

char *C3DCommandQueueAppendNewCommand(char **a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *result;
  char **v11;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineNotificationQueueStartObserving_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = C3DAllocatorNew(gCommandAllocator);
  *(_OWORD *)result = 0u;
  *((_OWORD *)result + 1) = 0u;
  *((_OWORD *)result + 2) = 0u;
  v11 = (char **)a1[1];
  if (!v11)
    v11 = a1;
  *v11 = result;
  a1[1] = result;
  return result;
}

char *C3DAllocatorNew(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t FirstIndex;
  uint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DAllocatorNew_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  FirstIndex = C3DIndexSetGetFirstIndex(*(_QWORD *)(a1 + 40));
  if (FirstIndex == -1)
  {
    v11 = *(_QWORD *)(a1 + 48);
    if (v11)
    {
      *(_QWORD *)(a1 + 48) = v11 + 1;
      v12 = (char *)malloc_type_realloc(*(void **)(a1 + 32), 16 * (v11 + 1), 0x10800409227ACB4uLL);
      *(_QWORD *)(a1 + 32) = v12;
      v13 = &v12[16 * v11];
      *(_QWORD *)v13 = malloc_type_malloc(*(_QWORD *)(a1 + 24) * *(_QWORD *)(a1 + 16), 0x2213EC01uLL);
      v14 = *(_QWORD *)(a1 + 24);
      *((_DWORD *)v13 + 2) = v14;
      v15 = *(_QWORD *)(a1 + 40);
      v16 = v14 * v11;
    }
    else
    {
      v17 = malloc_type_calloc(0x10uLL, 1uLL, 0x299EC358uLL);
      *(_QWORD *)(a1 + 32) = v17;
      *(_QWORD *)v17 = malloc_type_malloc(*(_QWORD *)(a1 + 24) * *(_QWORD *)(a1 + 16), 0x2213EC01uLL);
      v14 = *(_QWORD *)(a1 + 24);
      v17[2] = v14;
      *(_QWORD *)(a1 + 48) = 1;
      v15 = *(_QWORD *)(a1 + 40);
      v16 = 0;
    }
    C3DIndexSetAddIndexesInRange(v15, v16, v14);
    FirstIndex = C3DIndexSetGetFirstIndex(*(_QWORD *)(a1 + 40));
  }
  C3DIndexSetRemoveIndex(*(_QWORD *)(a1 + 40), FirstIndex);
  v18 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(a1 + 32) + 16 * (FirstIndex / v18);
  --*(_DWORD *)(v19 + 8);
  v20 = *(char **)v19;
  if (!*(_QWORD *)v19)
  {
    v20 = (char *)malloc_type_malloc(*(_QWORD *)(a1 + 16) * v18, 0x2213EC01uLL);
    *(_QWORD *)v19 = v20;
    *(_DWORD *)(v19 + 8) = *(_DWORD *)(a1 + 24) - 1;
    --*(_QWORD *)(a1 + 56);
  }
  return &v20[*(_QWORD *)(a1 + 16) * (FirstIndex % v18)];
}

void _replaceRangeInArrayAtIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    v4 = 0;
  }
  else if ((*(_BYTE *)(a1 + 16) & 2) != 0)
  {
    v4 = 1;
  }
  else
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8);
  }
  if (a4 <= 0)
  {
    _removeRangeInArrayAtIndex(a1, a2);
  }
  else if (v4 >= a2)
  {
    v6 = a1 + 24;
    v7 = a1 + 24;
    if ((*(_BYTE *)(a1 + 16) & 2) == 0)
      v7 = *(_QWORD *)v6 + 56;
    v8 = (_QWORD *)(v7 + 16 * a2);
    v9 = v8[1];
    *v8 = a3;
    v8[1] = a4;
    if ((*(_BYTE *)(a1 + 16) & 2) == 0)
    {
      *(_QWORD *)(*(_QWORD *)v6 + 48) = 0;
      *(_QWORD *)(*(_QWORD *)v6 + 16) -= v9;
      *(_QWORD *)(*(_QWORD *)v6 + 16) += a4;
    }
  }
  else
  {
    v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      _insertRange_cold_1();
  }
}

uint64_t C3DIndexSetGetFirstIndex(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;

  if ((*(_BYTE *)(a1 + 16) & 1) == 0)
  {
    v1 = (uint64_t *)(a1 + 24);
    if ((*(_BYTE *)(a1 + 16) & 2) != 0)
      return *v1;
    v2 = *v1;
    if (*(_QWORD *)(v2 + 8))
    {
      v1 = (uint64_t *)(v2 + 56);
      return *v1;
    }
  }
  return -1;
}

void C3DIndexSetRemoveIndexesInRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  if (a3)
  {
    if (a2 < 1)
    {
      v6 = 0;
    }
    else
    {
      v6 = _indexOfRangeAfterOrContainingIndex(a1, a2);
      if (v6 == -1)
        return;
    }
    v7 = a2 + a3;
    v8 = a1 + 24;
    while (1)
    {
      if ((*(_BYTE *)(a1 + 16) & 1) != 0)
        v9 = 0;
      else
        v9 = (*(_BYTE *)(a1 + 16) & 2) != 0 ? 1 : *(_QWORD *)(*(_QWORD *)v8 + 8);
      if (v6 >= v9)
        break;
      v10 = a1 + 24;
      if ((*(_BYTE *)(a1 + 16) & 2) == 0)
        v10 = *(_QWORD *)v8 + 56;
      v11 = (uint64_t *)(v10 + 16 * v6);
      v12 = *v11;
      if (v7 < *v11)
        break;
      v13 = v11[1] + v12;
      if (a2 > v12)
      {
        if (v13 > v7)
        {
          _replaceRangeInArrayAtIndex(a1, v6, v7, v13 - v7);
          _insertRange(a1, v12, a2 - v12, v6);
          return;
        }
        if (a2 < v13)
          _replaceRangeInArrayAtIndex(a1, v6, v12, a2 - v12);
        ++v6;
      }
      else
      {
        if (v13 > v7)
        {
          _replaceRangeInArrayAtIndex(a1, v6, v7, v13 - v7);
          return;
        }
        _removeRangeInArrayAtIndex(a1, v6);
      }
    }
  }
}

void C3DIndexSetRemoveIndex(uint64_t a1, uint64_t a2)
{
  C3DIndexSetRemoveIndexesInRange(a1, a2, 1);
}

uint64_t _indexOfRangeAfterOrContainingIndex(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  BOOL v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;

  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    return -1;
  v2 = (uint64_t *)(a1 + 24);
  if ((*(_BYTE *)(a1 + 16) & 2) != 0)
    goto LABEL_6;
  v3 = *v2;
  v4 = *(_QWORD *)(v3 + 8);
  v5 = v4 == 1;
  v6 = v4 < 1;
  v7 = v4 - 1;
  if (v6)
    return -1;
  v2 = (uint64_t *)(v3 + 56);
  if (!v5)
  {
    v9 = 0;
    v10 = v7;
    do
    {
      v11 = v10 + v9;
      if (v10 + v9 < 0 != __OFADD__(v10, v9))
        ++v11;
      result = v11 >> 1;
      v12 = &v2[2 * (v11 >> 1)];
      if (*v12 <= a2)
      {
        if (v12[1] + *v12 > a2)
          return result;
        v9 = result + 1;
      }
      else
      {
        v10 = result;
      }
    }
    while (v9 < v10);
    goto LABEL_7;
  }
LABEL_6:
  v7 = 0;
  v9 = 0;
LABEL_7:
  if (v2[2 * v9 + 1] + v2[2 * v9] > a2)
    return v9;
  if (v9 < v7)
    return v9 + 1;
  return -1;
}

uint64_t _indexOfRangeBeforeOrContainingIndex(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t *v11;

  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    return -1;
  v2 = (uint64_t *)(a1 + 24);
  if ((*(_BYTE *)(a1 + 16) & 2) != 0)
    goto LABEL_5;
  v3 = *v2;
  v4 = *(_QWORD *)(v3 + 8);
  if (v4 < 1)
    return -1;
  v2 = (uint64_t *)(v3 + 56);
  v5 = v4 - 1;
  if (v4 != 1)
  {
    v6 = 0;
    do
    {
      v10 = v5 + v6;
      if (v5 + v6 < 0 != __OFADD__(v5, v6))
        ++v10;
      result = v10 >> 1;
      v11 = &v2[2 * (v10 >> 1)];
      if (*v11 <= a2)
      {
        if (v11[1] + *v11 > a2)
          return result;
        v6 = result + 1;
      }
      else
      {
        v5 = result;
      }
    }
    while (v6 < v5);
    goto LABEL_6;
  }
LABEL_5:
  v6 = 0;
LABEL_6:
  v7 = v2[2 * v6];
  v8 = v6 - 1;
  if (v6 <= 0)
    v8 = -1;
  if (v7 > a2)
    return v8;
  else
    return v6;
}

void C3DIndexSetAddIndex(uint64_t a1, uint64_t a2)
{
  C3DIndexSetAddIndexesInRange(a1, a2, 1);
}

void C3DTimingFunctionGetDefaultFunction()
{
  uint64_t v0;

  if (!C3DTimingFunctionGetDefaultFunction_func)
  {
    C3DTimingFunctionCreateWithName(CFSTR("default"));
    C3DTimingFunctionGetDefaultFunction_func = v0;
  }
}

uint64_t C3DEffectSlotGetTextureSampler(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 56);
}

uint64_t C3DTextureSamplerCreateEx(int a1, int a2, int a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8, float a9)
{
  uint64_t result;
  unsigned int v19;

  result = C3DTextureSamplerCreate();
  *(_DWORD *)(result + 16) = a4;
  *(_DWORD *)(result + 20) = a5;
  *(_DWORD *)(result + 24) = a6;
  *(_DWORD *)(result + 28) = a1;
  *(_DWORD *)(result + 32) = a2;
  *(_DWORD *)(result + 36) = a3;
  v19 = 1;
  *(_QWORD *)(result + 48) = a7;
  *(_QWORD *)(result + 56) = a8;
  *(float *)(result + 64) = a9;
  if (a9 <= 128.0)
    v19 = ((a9 * 65536.0 * 0.0078125) << 19) | 1;
  *(_QWORD *)(result + 80) = (a2 << 12) | (a1 << 10) | (a3 << 14) | (2 * a4) | (16 * a5) | (a6 << 7) | v19 | (*(unsigned __int8 *)(result + 68) << 16);
  return result;
}

uint64_t C3DTextureSamplerCreate()
{
  uint64_t Instance;
  float v1;
  unsigned int v2;
  int8x16_t v3;

  if (C3DTextureSamplerGetTypeID_onceToken != -1)
    dispatch_once(&C3DTextureSamplerGetTypeID_onceToken, &__block_literal_global_29);
  Instance = C3DTypeCreateInstance_(C3DTextureSamplerGetTypeID_typeID, 0x50uLL);
  *(_OWORD *)(Instance + 16) = xmmword_1DD0092F0;
  *(_QWORD *)(Instance + 32) = 2;
  *(_DWORD *)(Instance + 64) = 1065353216;
  C3DColor4Make((float *)(Instance + 48), 0.0, 0.0, 0.0, 1.0);
  v1 = *(float *)(Instance + 64);
  v2 = 1;
  if (v1 <= 128.0)
    v2 = ((v1 * 65536.0 * 0.0078125) << 19) | 1;
  v3 = (int8x16_t)vshlq_u32(*(uint32x4_t *)(Instance + 16), (uint32x4_t)xmmword_1DD009300);
  *(int8x8_t *)v3.i8 = vorr_s8(*(int8x8_t *)v3.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v3, v3, 8uLL));
  *(_QWORD *)(Instance + 80) = v3.i32[0] | v3.i32[1] | (*(_DWORD *)(Instance + 32) << 12) | (*(_DWORD *)(Instance + 36) << 14) | (*(unsigned __int8 *)(Instance + 68) << 16) | v2;
  return Instance;
}

uint64_t C3DTypeCreateInstance_(CFTypeID a1, size_t a2)
{
  uint64_t v2;
  uint64_t Instance;
  CFStringRef v6;

  if (HIDWORD(a2))
    return 0;
  Instance = _CFRuntimeCreateInstance();
  v2 = Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), a2);
  }
  else
  {
    v6 = CFCopyTypeIDDescription(a1);
    CFRelease(v6);
  }
  return v2;
}

float *C3DColor4Make(float *result, float a2, float a3, float a4, float a5)
{
  *result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  return result;
}

CFTypeRef scn_NSColorFromCGColorIfApplicable(CFTypeRef cf)
{
  CFTypeID v2;

  if (cf && (v2 = CFGetTypeID(cf), v2 == CGColorGetTypeID()))
    return (CFTypeRef)objc_msgSend(MEMORY[0x1E0CEA478], "colorWithCGColor:", cf);
  else
    return cf;
}

void C3DEffectSlotSetColor(uint64_t a1, float *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  _BOOL4 IsBlack;
  _BOOL4 v14;
  _BOOL4 v15;
  int v16;
  _QWORD v17[2];

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v17[0] = 0;
  v17[1] = 0;
  *(_WORD *)(a1 + 48) &= ~0x200u;
  if (!a2)
  {
    a2 = (float *)v17;
    C3DColor4Make((float *)v17, 0.0, 0.0, 0.0, 1.0);
  }
  if (!C3DColor4IsEqualToColor4(a2, (float *)(a1 + 16)))
  {
    v12 = *(float *)(a1 + 28);
    IsBlack = C3DColor4IsBlack((float *)(a1 + 16));
    v14 = C3DColor4IsBlack(a2);
    *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
    if (v12 != 0.0 || a2[3] == 0.0)
      v15 = v12 == 1.0 && a2[3] != 1.0;
    else
      v15 = 1;
    v16 = IsBlack ^ v14;
    if (*(_BYTE *)(a1 + 50) != 5)
      v16 = 0;
    __PostParentDidChangeNotification(a1, v15 | v16, 0);
  }
}

BOOL C3DColor4IsBlack(float *a1)
{
  return *a1 <= 0.001 && a1[1] <= 0.001 && a1[2] <= 0.001;
}

void C3DEffectSlotSetTextureSampler(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef v12;
  CFTypeRef v13;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = *(CFTypeRef *)(a1 + 56);
  if (v12 != cf)
  {
    if (v12)
    {
      CFRelease(v12);
      *(_QWORD *)(a1 + 56) = 0;
    }
    if (cf)
      v13 = CFRetain(cf);
    else
      v13 = 0;
    *(_QWORD *)(a1 + 56) = v13;
    __PostParentDidChangeNotification(a1, 0, 0);
  }
}

void __PostCommonProfileDidChangeNotification(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    v3 = C3DGetScene(v2);
    C3DScenePostPipelineEvent(v3, 3, *(const void **)(a1 + 16), 0);
  }
  else
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      __PostCommonProfileDidChangeNotification_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  C3DMaterialTouchValueStorageModificationCount(*(_QWORD *)(a1 + 16));
}

void C3DScenePostPipelineEvent(uint64_t a1, int a2, const void *a3, const void *a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t NotificationQueue;

  if (!a3 && (v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DScenePostPipelineEvent_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (!a1)
      return;
  }
  else if (!a1)
  {
    return;
  }
  NotificationQueue = C3DEnginePipelineGetNotificationQueue(*(_QWORD *)(a1 + 120));
  C3DEngineNotificationQueueEnqueueEvent(NotificationQueue, a2, a3, a4);
}

void C3DMaterialTouchValueStorageModificationCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  ++*(_DWORD *)(a1 + 96);
}

void __PostParentDidChangeNotification(uint64_t a1, int a2, int a3)
{
  uint64_t CommonProfile;
  _QWORD *v7;
  const void *v8;
  CFTypeID v9;
  void *v10;
  _QWORD *v11;
  CFTypeID v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  CommonProfile = _C3DEffectSlotGetCommonProfile(a1);
  if (CommonProfile)
  {
    if (a2)
      *(_WORD *)(CommonProfile + 194) &= ~0x80u;
    if (a3)
      *(_WORD *)(CommonProfile + 194) &= ~0x40u;
    __PostCommonProfileDidChangeNotification(CommonProfile);
  }
  else
  {
    switch(*(_BYTE *)(a1 + 50))
    {
      case 0x16:
      case 0x17:
        v7 = *(_QWORD **)(a1 + 80);
        if (v7)
          __C3DLightDidChange(v7);
        break;
      case 0x19:
        v8 = *(const void **)(a1 + 80);
        if (v8 && a3)
        {
          v9 = CFGetTypeID(v8);
          if (v9 == C3DLightGetTypeID())
          {
            __C3DLightProbeEnvironmentDidChange((uint64_t)v8);
          }
          else
          {
            if (v9 != C3DSceneGetTypeID())
            {
              v13 = scn_default_log();
              if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
                __PostParentDidChangeNotification_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
            }
            __C3DSceneLightEnvironmentDidChange((uint64_t)v8);
          }
        }
        break;
      case 0x1A:
        v10 = *(void **)(a1 + 80);
        if (v10)
          _C3DCameraInvalidatePasses(v10);
        break;
      case 0x1B:
        v11 = *(_QWORD **)(a1 + 80);
        if (v11)
        {
          v12 = CFGetTypeID(v11);
          if (v12 == C3DGeometryGetTypeID())
          {
            _C3DGeometryShadingDidUpdate(v11);
          }
          else if (v12 == C3DMaterialGetTypeID())
          {
            _C3DMaterialShadingDidUpdate(v11);
          }
        }
        break;
      default:
        return;
    }
  }
}

uint64_t _C3DEffectSlotGetCommonProfile(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(char *)(a1 + 50) > 20)
    return 0;
  else
    return *(_QWORD *)(a1 + 80);
}

BOOL C3DColor4IsEqualToColor4(float *a1, float *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3];
}

uint64_t C3DTextureSamplerGetWrapModeP(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 24);
}

uint64_t C3DMaterialGetCommonProfile(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 64);
}

uint64_t C3DWasLinkedBeforeMajorOSYear2017()
{
  if (C3DWasLinkedBeforeMajorOSYear2017_onceToken != -1)
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2017_onceToken, &__block_literal_global_4_1);
  return C3DWasLinkedBeforeMajorOSYear2017_linkedBeforeMajorOSYear2017;
}

CGColorRef C3DCGColorCreateExtendedSRGBWithC3DColor(uint64_t a1, unint64_t a2)
{
  float32x2_t v4;
  float32x2_t v5;
  float32x4_t v7;
  CGFloat components[2];
  float64x2_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v7.i64[0] = a1;
  v7.i64[1] = a2;
  if (C3DLinearRenderingIsEnabled())
  {
    C3DColor4ConvertToNonLinear(&v7);
    v5 = *(float32x2_t *)&v7.u32[2];
    v4 = *(float32x2_t *)v7.f32;
  }
  else
  {
    v4 = (float32x2_t)a1;
    v5 = (float32x2_t)vzip1_s32((int32x2_t)a2, (int32x2_t)HIDWORD(a2));
  }
  *(float64x2_t *)components = vcvtq_f64_f32(v4);
  v9 = vcvtq_f64_f32(v5);
  if (C3DColorSpaceExtendedSRGB_onceToken != -1)
    dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_9);
  return CGColorCreate((CGColorSpaceRef)C3DColorSpaceExtendedSRGB_kC3DColorSpaceExtendedSRGB, components);
}

uint64_t C3DLinearRenderingIsEnabled()
{
  if (C3DLinearRenderingIsEnabled_onceToken != -1)
    dispatch_once(&C3DLinearRenderingIsEnabled_onceToken, &__block_literal_global_167);
  return _gC3DEnableLinearRendering;
}

float64_t C3DColor4ConvertToNonLinear(float32x4_t *a1)
{
  float64_t result;
  float64x2_t v3;

  v3.f64[0] = 0.0;
  v3.f64[1] = a1->f32[3];
  if (C3DWideGamutIsUsed())
  {
    if (C3DGetColorTransformToExtendedSRGB_onceToken != -1)
      dispatch_once(&C3DGetColorTransformToExtendedSRGB_onceToken, &__block_literal_global_32);
    if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1)
      dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_11);
  }
  else
  {
    if (C3DGetColorTransformToSRGB_onceToken != -1)
      dispatch_once(&C3DGetColorTransformToSRGB_onceToken, &__block_literal_global_34);
    if (C3DColorSpaceLinearSRGB_onceToken != -1)
      dispatch_once(&C3DColorSpaceLinearSRGB_onceToken, &__block_literal_global_3);
  }
  CGColorTransformConvertColorComponents();
  result = v3.f64[0];
  *a1 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)0), v3);
  return result;
}

uint64_t C3DWideGamutIsUsed()
{
  if (C3DWideGamutIsUsed_onceToken != -1)
    dispatch_once(&C3DWideGamutIsUsed_onceToken, &__block_literal_global_171);
  return C3DWideGamutIsUsed_useWideGamut;
}

uint64_t C3DEffectCommonProfileGetImage(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (result)
  {
    if (*(_BYTE *)(result + 48))
      return 0;
    else
      return *(_QWORD *)(result + 40);
  }
  return result;
}

MDLTextureSampler *setupSCNMaterialProperty(MDLTextureSampler *result, MDLMaterial *a2, MDLMaterialSemantic a3, int a4, NSDictionary *a5)
{
  MDLTextureSampler *v7;
  MDLMaterialProperty *v8;
  uint64_t v9;
  NSString *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  int v16;
  void *v17;
  float v18;
  double v19;
  float v20;
  double v21;
  float v22;
  double v23;
  float v24;
  double v25;
  float v26;
  float v27;
  float v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  SCNMatrix4 *v33;
  float32x4_t v34;
  uint64_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x2_t v38;
  float32x4_t v39;
  int8x16_t v40;
  float32x2_t v41;
  int8x16_t v42;
  float32x2_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  __int128 v51;
  uint64_t v52;
  float32x4_t v53;
  uint64_t v54;
  float32x4_t v55;
  float32x4_t v56;
  uint64_t v57;
  MDLTextureSampler *v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  SCNMatrix4 v66;
  SCNMatrix4 v67;
  SCNMatrix4 v68;
  SCNMatrix4 v69;
  SCNMatrix4 v70;
  SCNMatrix4 v71;
  SCNMatrix4 v72;
  SCNMatrix4 v73;
  SCNMatrix4 v74;
  SCNMatrix4 v75;
  SCNMatrix4 v76;
  SCNMatrix4 v77;
  SCNMatrix4 b;
  SCNMatrix4 a;
  SCNMatrix4 v80;
  SCNMatrix4 v81;
  SCNMatrix4 v82;

  if (!result)
    return result;
  v7 = result;
  v8 = -[MDLMaterial propertyWithSemantic:](a2, "propertyWithSemantic:", a3);
  if (-[MDLMaterialProperty type](v8, "type") == MDLMaterialPropertyTypeURL
    && -[MDLMaterialProperty URLValue](v8, "URLValue"))
  {
    v9 = -[MDLMaterialProperty URLValue](v8, "URLValue");
LABEL_32:
    -[MDLTextureSampler setContents:](v7, "setContents:", v9);
    goto LABEL_33;
  }
  if (-[MDLMaterialProperty type](v8, "type") == MDLMaterialPropertyTypeString
    && -[MDLMaterialProperty stringValue](v8, "stringValue"))
  {
    if (!-[MDLMaterialProperty URLValue](v8, "URLValue"))
    {
      v9 = -[MDLMaterialProperty stringValue](v8, "stringValue");
      goto LABEL_32;
    }
    v10 = -[NSURL path](-[MDLMaterialProperty URLValue](v8, "URLValue"), "path");
    if (-[MDLMaterialProperty stringValue](v8, "stringValue"))
    {
      if (-[NSString isEqualToString:](-[NSString pathExtension](v10, "pathExtension"), "isEqualToString:", CFSTR("usdz")))
      {
        v11 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3978], "currentThread"), "threadDictionary"), "valueForKey:", CFSTR("SCN_MDLCurrentAssetResolver"));
        if (v11)
        {
          v12 = (void *)v11;
          if ((objc_opt_respondsToSelector() & 1) != 0)
          {
            v13 = (void *)objc_msgSend(v12, "resolveInsideArchiveWithAssetNamed:", -[MDLMaterialProperty stringValue](v8, "stringValue"));
            if ((unint64_t)objc_msgSend(v13, "count") >= 2)
            {
              v14 = objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:", v10);
              v15 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3998]), "initWithURL:resolvingAgainstBaseURL:", v14, 0);
              v16 = 1;
              objc_msgSend(v15, "setQuery:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("offset=%d&size=%d"), objc_msgSend((id)objc_msgSend(v13, "objectAtIndexedSubscript:", 0), "intValue"), objc_msgSend((id)objc_msgSend(v13, "objectAtIndexedSubscript:", 1), "intValue")));
              -[MDLTextureSampler setContents:](v7, "setContents:", objc_msgSend(v15, "URL"));

              goto LABEL_34;
            }
          }
        }
      }
    }
    -[MDLTextureSampler _setImagePath:withResolvedPath:](v7, "_setImagePath:withResolvedPath:", -[MDLMaterialProperty stringValue](v8, "stringValue"), -[NSURL absoluteString](-[MDLMaterialProperty URLValue](v8, "URLValue"), "absoluteString"));
LABEL_33:
    v16 = 1;
    goto LABEL_34;
  }
  if (-[MDLMaterialProperty type](v8, "type") != MDLMaterialPropertyTypeTexture)
  {
    if (-[MDLMaterialProperty type](v8, "type") == MDLMaterialPropertyTypeFloat4)
    {
      -[MDLMaterialProperty float4Value](v8, "float4Value");
      v17 = (void *)MEMORY[0x1E0CEA478];
      v19 = v18;
      v21 = v20;
      v23 = v22;
      v25 = v24;
    }
    else
    {
      if (-[MDLMaterialProperty type](v8, "type") != MDLMaterialPropertyTypeFloat3)
      {
        if (-[MDLMaterialProperty type](v8, "type") == MDLMaterialPropertyTypeFloat)
        {
          -[MDLMaterialProperty floatValue](v8, "floatValue");
          v9 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
          goto LABEL_32;
        }
        if (-[MDLMaterialProperty type](v8, "type") == MDLMaterialPropertyTypeColor)
        {
          v9 = objc_msgSend(MEMORY[0x1E0CEA478], "colorWithCGColor:", -[MDLMaterialProperty color](v8, "color"));
          goto LABEL_32;
        }
        goto LABEL_33;
      }
      -[MDLMaterialProperty float3Value](v8, "float3Value");
      v17 = (void *)MEMORY[0x1E0CEA478];
      v19 = v26;
      v21 = v27;
      v23 = v28;
      v25 = 1.0;
    }
    v9 = objc_msgSend(v17, "scn_colorWithModelIORed:green:blue:alpha:options:", a5, v19, v21, v23, v25);
    goto LABEL_32;
  }
  if (-[MDLMaterialProperty textureSamplerValue](v8, "textureSamplerValue")
    && -[MDLTextureSampler texture](-[MDLMaterialProperty textureSamplerValue](v8, "textureSamplerValue"), "texture"))
  {
    -[MDLTextureSampler setContents:](v7, "setContents:", -[MDLTextureSampler texture](-[MDLMaterialProperty textureSamplerValue](v8, "textureSamplerValue"), "texture"));
    v16 = 0;
  }
  else
  {
    v16 = 1;
  }
  if (C3DWasLinkedBeforeMajorOSYear2018())
  {
    memset(&a.m22, 0, 40);
    *(_OWORD *)&a.m12 = 0u;
    a.m11 = 1.0;
    a.m22 = -1.0;
    a.m33 = 1.0;
    a.m44 = 1.0;
    *(_QWORD *)&b.m14 = 0;
    *(_QWORD *)&b.m12 = 0;
    b.m11 = 1.0;
    b.m22 = 1.0;
    *(_QWORD *)&b.m31 = 0;
    *(_QWORD *)&b.m23 = 0;
    *(_OWORD *)&b.m33 = xmmword_1DD007880;
    *(_QWORD *)&b.m43 = 0x3F80000000000000;
    SCNMatrix4Mult(&v80, &a, &b);
    v77 = v80;
    -[MDLTextureSampler setContentsTransform:](v7, "setContentsTransform:", &v77);
  }
LABEL_34:
  if (v16)
  {
    if (a4)
    {
      -[MDLTextureSampler setWrapS:](v7, "setWrapS:", 2);
      -[MDLTextureSampler setWrapT:](v7, "setWrapT:", 2);
      if (C3DWasLinkedBeforeMajorOSYear2018())
      {
        memset(&v75.m22, 0, 40);
        *(_OWORD *)&v75.m12 = 0u;
        v75.m11 = 1.0;
        v75.m22 = -1.0;
        v75.m33 = 1.0;
        v75.m44 = 1.0;
        *(_QWORD *)&v74.m14 = 0;
        *(_QWORD *)&v74.m12 = 0;
        v74.m11 = 1.0;
        v74.m22 = 1.0;
        *(_QWORD *)&v74.m31 = 0;
        *(_QWORD *)&v74.m23 = 0;
        *(_OWORD *)&v74.m33 = xmmword_1DD007880;
        *(_QWORD *)&v74.m43 = 0x3F80000000000000;
        SCNMatrix4Mult(&v76, &v75, &v74);
        v73 = v76;
        -[MDLTextureSampler setContentsTransform:](v7, "setContentsTransform:", &v73);
      }
    }
  }
  result = -[MDLMaterialProperty textureSamplerValue](v8, "textureSamplerValue");
  if (!result)
    return result;
  -[MDLTextureSampler setTextureComponents:](v7, "setTextureComponents:", __rbit32(-[MDLTextureSampler textureComponents](-[MDLMaterialProperty textureSamplerValue](v8, "textureSamplerValue"), "textureComponents")) >> 28);
  -[MDLTextureSampler setMappingChannel:](v7, "setMappingChannel:", -[MDLTextureSampler mappingChannel](-[MDLMaterialProperty textureSamplerValue](v8, "textureSamplerValue"), "mappingChannel"));
  if (-[MDLTextureSampler transform](-[MDLMaterialProperty textureSamplerValue](v8, "textureSamplerValue"), "transform"))
  {
    if (C3DWasLinkedBeforeMajorOSYear2018())
    {
      memset(&v82, 0, sizeof(v82));
      memset(&v72.m22, 0, 40);
      *(_OWORD *)&v72.m12 = 0u;
      v72.m11 = 1.0;
      v72.m22 = -1.0;
      v72.m33 = 1.0;
      v72.m44 = 1.0;
      *(_QWORD *)&v71.m14 = 0;
      *(_QWORD *)&v71.m12 = 0;
      v71.m11 = 1.0;
      v71.m22 = 1.0;
      *(_QWORD *)&v71.m23 = 0;
      *(_QWORD *)&v71.m31 = 0;
      *(_OWORD *)&v71.m33 = xmmword_1DD007880;
      *(_QWORD *)&v71.m43 = 0x3F80000000000000;
      SCNMatrix4Mult(&v82, &v72, &v71);
      -[MDLTransform matrix](-[MDLTextureSampler transform](-[MDLMaterialProperty textureSamplerValue](v8, "textureSamplerValue"), "transform"), "matrix");
      *(_OWORD *)&v69.m11 = v29;
      *(_OWORD *)&v69.m21 = v30;
      *(_OWORD *)&v69.m31 = v31;
      *(_OWORD *)&v69.m41 = v32;
      v68 = v82;
      SCNMatrix4Mult(&v70, &v69, &v68);
      v67 = v70;
      v33 = &v67;
    }
    else
    {
      -[MDLTransform matrix](-[MDLTextureSampler transform](-[MDLMaterialProperty textureSamplerValue](v8, "textureSamplerValue"), "transform"), "matrix");
      v35 = 0;
      v37 = (int8x16_t)vmulq_f32(v36, v36);
      v38 = (float32x2_t)vextq_s8(v37, v37, 8uLL).u64[0];
      v38.f32[0] = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v37.i8, v38)));
      v40 = (int8x16_t)vmulq_f32(v39, v39);
      v41 = (float32x2_t)vextq_s8(v40, v40, 8uLL).u64[0];
      v41.f32[0] = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v40.i8, v41)));
      v42 = (int8x16_t)vmulq_f32(v34, v34);
      v43 = (float32x2_t)vextq_s8(v42, v42, 8uLL).u64[0];
      v43.f32[0] = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v42.i8, v43)));
      v44 = vdivq_f32(v36, (float32x4_t)vdupq_lane_s32((int32x2_t)v38, 0));
      v45 = vdivq_f32(v39, (float32x4_t)vdupq_lane_s32((int32x2_t)v41, 0));
      v46 = *(float32x4_t *)MEMORY[0x1E0C83FF0];
      v47 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 16);
      v48 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 32);
      v49 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 48);
      LODWORD(v51) = v50.i32[0];
      DWORD1(v51) = vnegq_f32(v50).i32[1];
      *((_QWORD *)&v51 + 1) = __PAIR64__(1.0, v50.u32[2]);
      *(_OWORD *)&v81.m11 = *MEMORY[0x1E0C83FF0];
      *(float32x4_t *)&v81.m21 = v47;
      *(float32x4_t *)&v81.m31 = v48;
      *(_OWORD *)&v81.m41 = v51;
      do
      {
        *(float32x4_t *)((char *)&v82.m11 + v35) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v46, COERCE_FLOAT(*(_OWORD *)((char *)&v81.m11 + v35))), v47, *(float32x2_t *)((char *)&v81.m11 + v35), 1), v48, *(float32x4_t *)((char *)&v81.m11 + v35), 2), (float32x4_t)xmmword_1DD007890, *(float32x4_t *)((char *)&v81.m11 + v35), 3);
        v35 += 16;
      }
      while (v35 != 64);
      v52 = 0;
      v53 = vdivq_f32(v34, (float32x4_t)vdupq_lane_s32((int32x2_t)v43, 0));
      v44.i32[1] = vnegq_f32(v44).i32[1];
      v45.f32[0] = -v45.f32[0];
      v81 = v82;
      do
      {
        *(float32x4_t *)((char *)&v82.m11 + v52) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v44, COERCE_FLOAT(*(_OWORD *)((char *)&v81.m11 + v52))), v45, *(float32x2_t *)((char *)&v81.m11 + v52), 1), v53, *(float32x4_t *)((char *)&v81.m11 + v52), 2), v49, *(float32x4_t *)((char *)&v81.m11 + v52), 3);
        v52 += 16;
      }
      while (v52 != 64);
      v54 = 0;
      v55.i32[0] = 0;
      v55.i64[1] = 0;
      v55.i32[1] = v41.i32[0];
      v56.i64[0] = 0;
      v56.i64[1] = v43.u32[0];
      v81 = v82;
      do
      {
        *(float32x4_t *)((char *)&v82.m11 + v54) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v38.u32[0], COERCE_FLOAT(*(_OWORD *)((char *)&v81.m11 + v54))), v55, *(float32x2_t *)((char *)&v81.m11 + v54), 1), v56, *(float32x4_t *)((char *)&v81.m11 + v54), 2), (float32x4_t)xmmword_1DD007610, *(float32x4_t *)((char *)&v81.m11 + v54), 3);
        v54 += 16;
      }
      while (v54 != 64);
      v57 = 0;
      v81 = v82;
      do
      {
        *(float32x4_t *)((char *)&v82.m11 + v57) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v46, COERCE_FLOAT(*(_OWORD *)((char *)&v81.m11 + v57))), v47, *(float32x2_t *)((char *)&v81.m11 + v57), 1), v48, *(float32x4_t *)((char *)&v81.m11 + v57), 2), (float32x4_t)xmmword_1DD0078A0, *(float32x4_t *)((char *)&v81.m11 + v57), 3);
        v57 += 16;
      }
      while (v57 != 64);
      v66 = v82;
      v33 = &v66;
    }
    -[MDLTextureSampler setContentsTransform:](v7, "setContentsTransform:", v33);
  }
  result = -[MDLTextureSampler hardwareFilter](-[MDLMaterialProperty textureSamplerValue](v8, "textureSamplerValue"), "hardwareFilter");
  if (!result)
    return result;
  v58 = result;
  v59 = -[MDLTextureSampler sWrapMode](result, "sWrapMode");
  if (v59 <= 2)
    -[MDLTextureSampler setWrapS:](v7, "setWrapS:", qword_1DD007868[v59]);
  v60 = -[MDLTextureSampler tWrapMode](v58, "tWrapMode");
  if (v60 <= 2)
    -[MDLTextureSampler setWrapT:](v7, "setWrapT:", qword_1DD007868[v60]);
  v61 = -[MDLTextureSampler minFilter](v58, "minFilter");
  if (v61)
  {
    if (v61 != 1)
      goto LABEL_62;
    v62 = 2;
  }
  else
  {
    v62 = 1;
  }
  -[MDLTextureSampler setMinificationFilter:](v7, "setMinificationFilter:", v62);
LABEL_62:
  v63 = -[MDLTextureSampler magFilter](v58, "magFilter");
  if (!v63)
  {
    v64 = 1;
    goto LABEL_66;
  }
  if (v63 == 1)
  {
    v64 = 2;
LABEL_66:
    -[MDLTextureSampler setMagnificationFilter:](v7, "setMagnificationFilter:", v64);
  }
  result = (MDLTextureSampler *)-[MDLTextureSampler mipFilter](v58, "mipFilter");
  if (result)
  {
    if (result != (MDLTextureSampler *)1)
      return result;
    v65 = 2;
  }
  else
  {
    v65 = 1;
  }
  return (MDLTextureSampler *)-[MDLTextureSampler setMipFilter:](v7, "setMipFilter:", v65);
}

uint64_t C3DWasLinkedBeforeMajorOSYear2018()
{
  if (C3DWasLinkedBeforeMajorOSYear2018_onceToken != -1)
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2018_onceToken, &__block_literal_global_5_2);
  return C3DWasLinkedBeforeMajorOSYear2018_linkedBeforeMajorOSYear2018;
}

uint64_t C3DTransactionAllowImmediate(uint64_t a1, id *a2)
{
  unsigned int v2;
  id *v4;
  id **v5;
  NSObject *v8;

  v2 = *(unsigned __int8 *)(a1 + 60);
  if ((v2 & 8) != 0)
  {
    v5 = (id **)(a1 + 48);
    v4 = *(id **)(a1 + 48);
    if (v4 != a2 && a2 != 0 && v4 != 0 && (C3DTransactionAllowImmediate_done & 1) == 0)
    {
      C3DTransactionAllowImmediate_done = 1;
      v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        C3DTransactionAllowImmediate_cold_1(a2, v5, v8);
    }
  }
  return (v2 >> 3) & 1;
}

const __CFDictionary *C3DEntityGetAnimations(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return _C3DEntityGetSubAttributeOrderedDictionary(a1, CFSTR("kAnimationsKey"), 0);
}

uint64_t C3DWasLinkedBeforeMajorOSYear2016()
{
  if (C3DWasLinkedBeforeMajorOSYear2016_onceToken != -1)
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2016_onceToken, &__block_literal_global_3_2);
  return C3DWasLinkedBeforeMajorOSYear2016_linkedBeforeMajorOSYear2016;
}

uint64_t C3DEffectSlotDefaultSRGBForPropertyType(unsigned int a1)
{
  return (a1 > 0x1A) | (0x37F325Fu >> a1) & 1;
}

CFStringRef C3DEntitySetName(uint64_t a1, CFStringRef theString)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFStringRef result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(CFStringRef *)(a1 + 32);
  if (result != theString)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 32) = 0;
    }
    if (theString)
      result = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theString);
    else
      result = 0;
    *(_QWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t C3DEnginePipelineGetNotificationQueue(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextRenderScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 32);
}

uint64_t C3DModelTargetGetTargetAddress(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 24);
}

void C3DEffectSlotSetTextureComponents(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = *(unsigned __int16 *)(a1 + 48);
  if (((v12 >> 11) & 0xF) != a2)
  {
    *(_WORD *)(a1 + 48) = v12 & 0x87FF | ((a2 & 0xF) << 11);
    __PostParentDidChangeNotification(a1, 0, 0);
  }
}

uint64_t C3DSceneGetModelValueStorage(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 96);
}

void C3DModelValueStorageUpdateModelValueWithValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __n128 *ModelValueIfAny;

  if (!a1 && (v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DConstraintApplyIK_cold_3(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    C3DAnimationManagerApplyAnimationsForTarget_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
LABEL_6:
  ModelValueIfAny = (__n128 *)C3DModelValueStorageGetModelValueIfAny(a1, a2);
  if (ModelValueIfAny)
    C3DModelValueStorageUpdateItemModelValueWithValue(ModelValueIfAny, a2, a3);
}

const void *C3DModelValueStorageGetModelValueIfAny(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *TargetAddress;
  const void *result;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DConstraintApplyIK_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DAnimationManagerApplyAnimationsForTarget_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  TargetAddress = (const void *)C3DModelTargetGetTargetAddress(a2);
  if (*(const void **)(a1 + 24) == TargetAddress)
    return *(const void **)(a1 + 32);
  *(_QWORD *)(a1 + 24) = TargetAddress;
  result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), TargetAddress);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

uint64_t C3DModelTargetGetBaseType(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DAnimationManagerAddAnimationForKey_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(__int16 *)(a1 + 32);
}

void *C3DGetValue(CFTypeRef cf, const void *a2, void *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *ClassWithTypeID;
  uint64_t (*v21)(CFTypeRef, const void *, void *, size_t, uint64_t, uint64_t);

  if (!cf)
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      _C3DGeometryFillLibraryForSerialization_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (_QWORD *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696
    && (v21 = (uint64_t (*)(CFTypeRef, const void *, void *, size_t, uint64_t, uint64_t))ClassWithTypeID[13]) != 0)
  {
    return (void *)v21(cf, a2, a3, a4, a5, a6);
  }
  else
  {
    return memcpy(a3, a2, a4);
  }
}

void _removeRangeInArrayAtIndex(uint64_t a1, uint64_t a2)
{
  char v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _OWORD *v8;
  uint64_t v9;
  char v10;

  v2 = *(_BYTE *)(a1 + 16);
  if ((v2 & 1) != 0)
  {
    v3 = 0;
  }
  else if ((*(_BYTE *)(a1 + 16) & 2) != 0)
  {
    v3 = 1;
  }
  else
  {
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8);
  }
  if (v3 >= a2)
  {
    v5 = (_QWORD *)(a1 + 24);
    if ((*(_BYTE *)(a1 + 16) & 2) == 0)
      v5 = (_QWORD *)(*v5 + 56);
    v6 = &v5[2 * a2];
    v7 = v6[1];
    if (a2 + 1 < v3)
    {
      v8 = v6 + 2;
      v9 = ~a2 + v3;
      do
      {
        *(v8 - 1) = *v8;
        ++v8;
        --v9;
      }
      while (v9);
      v2 = *(_BYTE *)(a1 + 16);
    }
    if ((v2 & 2) != 0)
    {
      v10 = v2 | 1;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48) = 0;
      --*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8);
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) -= v7;
      v10 = *(_BYTE *)(a1 + 16) & 0xFE | (*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8) == 0);
    }
    *(_BYTE *)(a1 + 16) = v10;
  }
  else
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      _insertRange_cold_1();
  }
}

uint64_t C3DTextureSamplerGetBorderColor(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return a1 + 48;
}

uint64_t C3DEffectSlotGetSRGB(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 48) >> 10) & 1;
}

void _C3DNodeGetValue(uint64_t a1, const void *a2, void *__dst, size_t __n, int a5, unsigned int a6)
{
  if ((const void *)(a1 + 96) == a2)
    C3DTransformGetValue((uint64_t)a2, __dst, __n, a5, a6);
  else
    memcpy(__dst, a2, __n);
}

void C3DNodeSetOpacity(uint64_t a1, float a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  uint64_t v14;
  _QWORD v15[5];

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = *(float *)(a1 + 204);
  if (v12 != a2)
  {
    if (a2 >= 1.0 && v12 < 1.0)
    {
      *(float *)(a1 + 204) = a2;
      __DirtyWorldAlpha(a1, 1);
    }
    else
    {
      if (a2 >= 1.0)
      {
        *(float *)(a1 + 204) = a2;
        __DirtyWorldAlpha(a1, 0);
        goto LABEL_15;
      }
      *(float *)(a1 + 204) = a2;
      __DirtyWorldAlpha(a1, v12 >= 1.0);
      if (v12 < 1.0)
        goto LABEL_15;
    }
    v14 = *(_QWORD *)(a1 + 48);
    C3DScenePostPipelineEvent(v14, 4, (const void *)a1, 0);
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 0x40000000;
    v15[2] = ____IsOpaqueDidChange_block_invoke;
    v15[3] = &__block_descriptor_tmp_125;
    v15[4] = v14;
    C3DNodeApplyHierarchy(a1, (uint64_t)v15);
LABEL_15:
    if (a2 == 0.0 || v12 == 0.0)
      __UpdateCullingSystemFlags(a1, 1);
  }
}

void __C3DSceneLightEnvironmentDidChange(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  ++*(_DWORD *)(a1 + 320);
}

__n128 C3DTimingFunctionCreateWithName(__CFString *a1)
{
  uint64_t Instance;
  __n128 result;
  __int128 *v4;

  if (C3DTimingFunctionGetTypeID_onceToken != -1)
    dispatch_once(&C3DTimingFunctionGetTypeID_onceToken, &__block_literal_global_22);
  Instance = C3DTypeCreateInstance_(C3DTimingFunctionGetTypeID_typeID, 0x20uLL);
  *(_QWORD *)(Instance + 16) = C3DTimingFunctionCurve;
  if (CFSTR("default") == a1)
  {
    v4 = &function_values;
  }
  else if (CFSTR("easeIn") == a1)
  {
    v4 = &xmmword_1DD0083C4;
  }
  else if (CFSTR("easeOut") == a1)
  {
    v4 = &xmmword_1DD0083D4;
  }
  else
  {
    if (CFSTR("easeInEaseOut") != a1)
    {
      *(_QWORD *)(Instance + 16) = C3DTimingFunctionLinear;
      return result;
    }
    v4 = &xmmword_1DD0083E4;
  }
  result = (__n128)*v4;
  *(_OWORD *)(Instance + 24) = *v4;
  return result;
}

__n128 C3DSceneSetFogColor(__n128 *a1, __n128 *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *a2;
  a1[22] = *a2;
  return result;
}

void C3DNodeSetCamera(uint64_t a1, const __CFDictionary *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *Camera;
  _BOOL4 v13;
  uint64_t v14;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (C3DGetSceneRef(a1))
  {
    Camera = C3DNodeGetCamera(a1);
    if (Camera)
      C3DRemoveSceneRef(Camera, *(_QWORD *)(a1 + 48));
  }
  v13 = C3DGetSceneRef(a1) != 0;
  _C3DEntitySetAttribute((CFTypeRef *)a1, CFSTR("kCameraKey"), a2, v13);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFFFBFF | ((a2 != 0) << 10);
  if (a2)
  {
    v14 = *(_QWORD *)(a1 + 48);
    if (v14)
      C3DAddSceneRef((uint64_t *)a2, v14);
  }
}

void C3DEffectSlotSetPrecomputedLightingEnvironment(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef v12;
  CFTypeRef v13;
  uint64_t CommonProfile;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (*(_BYTE *)(a1 + 50) == 25 && (cf || *(_WORD *)(a1 + 48) == 4))
  {
    *(_WORD *)(a1 + 48) = *(_WORD *)(a1 + 48) & 0xFF00 | 4;
    v12 = *(CFTypeRef *)(a1 + 40);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(_QWORD *)(a1 + 40) = 0;
      }
      if (cf)
        v13 = CFRetain(cf);
      else
        v13 = 0;
      *(_QWORD *)(a1 + 40) = v13;
      CommonProfile = _C3DEffectSlotGetCommonProfile(a1);
      if (CommonProfile)
        *(_WORD *)(CommonProfile + 196) &= 0xE000u;
      __PostParentDidChangeNotification(a1, 0, 1);
    }
  }
}

void C3DEffectSlotSetHasNoContents(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEffectSlotSetHasNoContents_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  *(_WORD *)(a1 + 48) |= 0x200u;
}

unint64_t _C3DRasterizerStatesCFHash(uint64_t a1)
{
  return __hashCodeFromDesc((int *)(a1 + 16));
}

void _C3DValueCFFinalize(uint64_t a1)
{
  free(*(void **)(a1 + 24));
}

uint64_t C3DFXMetalProgramGetBufferBindings(CFTypeRef cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeID v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DResourceManagerMakeProgramResident_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
  }
  return *((_QWORD *)cf + 17);
}

void SCNMTLRenderPipelineDescRelease(uint64_t a1)
{
  void *v2;
  const void *v3;

  v2 = *(void **)(a1 + 8);

  v3 = *(const void **)(a1 + 200);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 200) = 0;
  }

}

id _pipelineDescriptorForPipelineDesc(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  void *v8;
  NSObject *v9;
  NSObject *v10;
  id v11;
  uint64_t i;
  uint64_t j;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  uint8_t v20[8];
  uint64_t v21;

  v2 = *(_QWORD *)(a1 + 280);
  if (v2)
  {
    v21 = 0;
    v3 = objc_msgSend(*(id *)(a1 + 104), "newFunctionWithName:constantValues:error:", *(_QWORD *)(a1 + 296), v2, &v21);
    if (!v3)
    {
      v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        _pipelineDescriptorForPipelineDesc_cold_3();
      return 0;
    }
    v4 = (void *)v3;
    v5 = objc_msgSend(*(id *)(a1 + 104), "newFunctionWithName:constantValues:error:", *(_QWORD *)(a1 + 304), *(_QWORD *)(a1 + 280), &v21);
    if (!v5)
    {
      v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        _pipelineDescriptorForPipelineDesc_cold_4();
LABEL_35:

      return 0;
    }
  }
  else
  {
    v7 = objc_msgSend(*(id *)(a1 + 104), "newFunctionWithName:", *(_QWORD *)(a1 + 296));
    if (!v7)
    {
      v10 = scn_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        _pipelineDescriptorForPipelineDesc_cold_1();
      return 0;
    }
    v4 = (void *)v7;
    if (!*(_QWORD *)(a1 + 304))
    {
      v8 = 0;
      goto LABEL_15;
    }
    v5 = objc_msgSend(*(id *)(a1 + 104), "newFunctionWithName:");
    if (!v5)
    {
      v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        _pipelineDescriptorForPipelineDesc_cold_2();
      goto LABEL_35;
    }
  }
  v8 = (void *)v5;
LABEL_15:
  v11 = objc_alloc_init(MEMORY[0x1E0CC6B68]);
  objc_msgSend(v11, "setVertexFunction:", v4);

  objc_msgSend(v11, "setFragmentFunction:", v8);
  objc_msgSend(v11, "setFragmentLinkedFunctions:", *(_QWORD *)(a1 + 320));
  objc_msgSend(v11, "setVertexLinkedFunctions:", *(_QWORD *)(a1 + 312));
  for (i = 0; i != 8; ++i)
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", i), "setPixelFormat:", *(_QWORD *)(a1 + 112 + 8 * i));
  if (*(_BYTE *)(a1 + 339))
  {
    for (j = 0; j != 8; ++j)
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", j), "setWriteMask:", *(_QWORD *)(a1 + 208 + 8 * j));
  }
  v14 = *(_QWORD *)(a1 + 200);
  if (v14)
    C3DApplyBlendStatesToRenderPipelineDescriptor(v14, v11);
  objc_msgSend(v11, "setVertexDescriptor:", *(_QWORD *)(a1 + 288));
  if (*(unsigned __int8 *)(a1 + 192) <= 1u)
    v15 = 1;
  else
    v15 = *(unsigned __int8 *)(a1 + 192);
  objc_msgSend(v11, "setRasterSampleCount:", v15);
  objc_msgSend(v11, "setDepthAttachmentPixelFormat:", *(_QWORD *)(a1 + 176));
  objc_msgSend(v11, "setStencilAttachmentPixelFormat:", *(_QWORD *)(a1 + 184));
  if (*(unsigned __int8 *)(a1 + 67) >= 2uLL)
    objc_msgSend(v11, "setMaxVertexAmplificationCount:");
  v16 = *(_QWORD *)(a1 + 328);
  if (v16)
    (*(void (**)(uint64_t, id))(v16 + 16))(v16, v11);
  if (!objc_msgSend(v11, "vertexFunction"))
  {
    v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v20 = 0;
      _os_log_impl(&dword_1DCCB8000, v17, OS_LOG_TYPE_INFO, "Info: Shaders without a vertex function are not allowed", v20, 2u);
    }
    return 0;
  }
  objc_msgSend(v11, "setInputPrimitiveTopology:", *(unsigned __int8 *)(a1 + 272));
  return v11;
}

id SCNMTLRenderPipelineDescRetain(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  id v5;
  id v6;
  const void *v7;
  id v8;
  id v9;
  id v10;

  v2 = *(void **)(a1 + 8);
  v3 = *(id *)a1;
  v4 = v2;
  v5 = *(id *)(a1 + 104);
  v6 = *(id *)(a1 + 288);
  v7 = *(const void **)(a1 + 200);
  if (v7)
    CFRetain(v7);
  v8 = *(id *)(a1 + 280);
  v9 = *(id *)(a1 + 296);
  v10 = *(id *)(a1 + 304);
  return *(id *)(a1 + 328);
}

NSUInteger SCNObject_resolveInstanceMethod(objc_class *a1, SEL aSelector)
{
  NSString *v4;
  _BOOL4 v5;
  void *v6;
  unsigned int v7;
  unsigned __int16 v8;
  unsigned int v9;
  NSUInteger result;
  uint64_t v11;
  void (*v12)(void);
  Method *v13;
  Method *v14;
  uint64_t v15;
  const __CFString *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  const char *Name;
  uint64_t v21;
  NSObject *v22;
  unsigned int outCount;

  v4 = NSStringFromSelector(aSelector);
  v5 = -[NSString hasPrefix:](v4, "hasPrefix:", CFSTR("set"));
  if (!v5)
  {
    result = -[NSString length](v4, "length");
    if (!result)
      return result;
    outCount = 0;
    v13 = class_copyMethodList(a1, &outCount);
    if (v13)
    {
      v14 = v13;
      v15 = -[NSString capitalizedString](-[NSString substringWithRange:](v4, "substringWithRange:", 0, 1), "capitalizedString");
      if (-[NSString length](v4, "length") < 2)
        v16 = &stru_1EA5A6480;
      else
        v16 = -[NSString substringFromIndex:](v4, "substringFromIndex:", 1);
      v17 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("is%@%@"), v15, v16);
      if (outCount)
      {
        v18 = (void *)v17;
        v19 = 0;
        while (1)
        {
          Name = method_getName(v14[v19]);
          if ((objc_msgSend(v18, "isEqualToString:", NSStringFromSelector(Name)) & 1) != 0)
            break;
          if (++v19 >= (unint64_t)outCount)
            goto LABEL_13;
        }
        free(v14);
        return 1;
      }
LABEL_13:
      free(v14);
    }
    result = (NSUInteger)SCNBaseTypeOfObjCProperty(a1, v4);
    v8 = result;
    if (!(_DWORD)result)
      return result;
    v21 = (int)result - 1;
    if ((unsigned __int16)(result - 1) >= 0xEu || ((0x27FFu >> v21) & 1) == 0)
    {
LABEL_17:
      v22 = scn_default_log();
      result = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        SCNObject_resolveInstanceMethod_cold_1(v8, v22);
        return 0;
      }
      return result;
    }
    v11 = qword_1DD02C548[v21];
    v12 = (void (*)(void))off_1EA5A4D38[(__int16)v21];
LABEL_31:
    class_addMethod(a1, aSelector, v12, (&method_encodings[2 * v11])[!v5]);
    return 1;
  }
  v6 = (void *)propertyNameForSetter(v4);
  v7 = SCNBaseTypeOfObjCProperty(a1, v6);
  v8 = v7;
  v9 = v7;
  result = 0;
  v11 = v8;
  v12 = (void (*)(void))SCNFloat_setter;
  switch(v9)
  {
    case 0u:
      return result;
    case 1u:
      goto LABEL_31;
    case 2u:
      v12 = (void (*)(void))SCNInteger_setter;
      v11 = 2;
      goto LABEL_31;
    case 3u:
      v12 = (void (*)(void))SCNBoolean_setter;
      v11 = 3;
      goto LABEL_31;
    case 4u:
      v12 = (void (*)(void))SCNChar_setter;
      v11 = 4;
      goto LABEL_31;
    case 5u:
      v12 = (void (*)(void))SCNPointer_setter;
      v11 = 5;
      goto LABEL_31;
    case 6u:
      v12 = (void (*)(void))SCNDouble_setter;
      v11 = 6;
      goto LABEL_31;
    case 7u:
      v12 = (void (*)(void))SCNC3DFloat_setter;
      v11 = 7;
      goto LABEL_31;
    case 8u:
      v12 = (void (*)(void))SCNVector2_setter;
      v11 = 8;
      goto LABEL_31;
    case 9u:
      v12 = (void (*)(void))SCNVector3_setter;
      v11 = 9;
      goto LABEL_31;
    case 0xAu:
      v12 = (void (*)(void))SCNVector4_setter;
      v11 = 10;
      goto LABEL_31;
    case 0xBu:
      v12 = (void (*)(void))SCNMatrix4x4_setter;
      v11 = 11;
      goto LABEL_31;
    case 0xEu:
      v12 = (void (*)(void))SCNShort_setter;
      v11 = 14;
      goto LABEL_31;
    default:
      goto LABEL_17;
  }
  return result;
}

unint64_t `anonymous namespace'::add_geometry_sources(_anonymous_namespace_ *this, NSMutableArray *a2, NSMutableArray *a3, MDLMesh *a4, NSDictionary *a5)
{
  void *v6;
  unint64_t result;
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  int v16;
  int v17;
  SCNGeometrySource *v18;

  v6 = (void *)-[NSMutableArray vertexDescriptor](a3, "vertexDescriptor");
  result = objc_msgSend((id)objc_msgSend(v6, "attributes"), "count");
  if (result)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = *MEMORY[0x1E0CC7760];
    v12 = *MEMORY[0x1E0CC7750];
    v13 = *MEMORY[0x1E0CC7738];
    v14 = *MEMORY[0x1E0CC7740];
    do
    {
      v15 = (void *)objc_msgSend((id)objc_msgSend(v6, "attributes"), "objectAtIndexedSubscript:", v8);
      if (objc_msgSend(v15, "format"))
      {
        v16 = objc_msgSend((id)objc_msgSend(v15, "name"), "containsString:", v11);
        if ((v10 & v16 & 1) != 0)
        {
          v10 = 1;
        }
        else
        {
          v10 |= v16;
          v17 = objc_msgSend((id)objc_msgSend(v15, "name"), "containsString:", v12);
          if ((v9 & v17 & 1) != 0)
          {
            v9 = 1;
          }
          else
          {
            v9 |= v17;
            if ((objc_msgSend((id)objc_msgSend(v15, "name"), "containsString:", v13) & 1) == 0
              && (objc_msgSend((id)objc_msgSend(v15, "name"), "containsString:", v14) & 1) == 0
              && (objc_msgSend((id)objc_msgSend(v15, "name"), "hasSuffix:", CFSTR("UVi")) & 1) == 0)
            {
              v18 = +[SCNGeometrySource geometrySourceWithMDLVertexAttribute:mesh:](SCNGeometrySource, "geometrySourceWithMDLVertexAttribute:mesh:", v15, a3);
              if (v18)
              {
                -[_anonymous_namespace_ addObject:](this, "addObject:", v18);
                -[NSMutableArray addObject:](a2, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", v8));
              }
            }
          }
        }
      }
      ++v8;
      result = objc_msgSend((id)objc_msgSend(v6, "attributes"), "count");
    }
    while (v8 < result);
  }
  return result;
}

void sub_1DCCC0A68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t C3DBaseTypeFromDescription(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v4;
  char v5;
  char v6;
  unint64_t v7;
  char v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;

  LOWORD(v4) = 6;
  switch(a1)
  {
    case 1:
      if (a3)
        goto LABEL_10;
      goto LABEL_21;
    case 2:
      v5 = a2 - 1;
      if (a3)
      {
        if ((unint64_t)(a2 - 1) >= 4)
          goto LABEL_10;
        v6 = 16 * v5;
        v7 = 0x2D002C002B000FLL;
      }
      else
      {
        if ((unint64_t)(a2 - 1) >= 4)
          goto LABEL_21;
        v6 = 16 * v5;
        v7 = 0x2200210020000ELL;
      }
      goto LABEL_20;
    case 4:
      v8 = a2 - 1;
      if (a3)
      {
        if ((unint64_t)(a2 - 1) < 4)
        {
          v4 = 0xA000900080001uLL >> (16 * v8);
          return (__int16)v4;
        }
LABEL_10:
        if ((C3DBaseTypeFromDescription_done & 1) == 0)
        {
          C3DBaseTypeFromDescription_done = 1;
          v9 = scn_default_log();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            C3DBaseTypeFromDescription_cold_2();
        }
        if (a2 == 1)
        {
          LOWORD(v4) = 21;
          return (__int16)v4;
        }
        if (a2 == 4)
        {
          LOWORD(v4) = 27;
          return (__int16)v4;
        }
LABEL_27:
        v11 = scn_default_log();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          C3DBaseTypeFromDescription_cold_1();
        LOWORD(v4) = 0;
        return (__int16)v4;
      }
      if ((unint64_t)(a2 - 1) >= 4)
      {
LABEL_21:
        if ((C3DBaseTypeFromDescription_done_109 & 1) == 0)
        {
          C3DBaseTypeFromDescription_done_109 = 1;
          v10 = scn_default_log();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            C3DBaseTypeFromDescription_cold_2();
        }
        if (a2 == 1)
        {
          LOWORD(v4) = 16;
          return (__int16)v4;
        }
        if (a2 == 4)
        {
          LOWORD(v4) = 25;
          return (__int16)v4;
        }
        goto LABEL_27;
      }
      v6 = 16 * v8;
      v7 = 0x14001300120002;
LABEL_20:
      v4 = v7 >> v6;
      return (__int16)v4;
    case 8:
      return (__int16)v4;
    default:
      goto LABEL_27;
  }
}

void flip_UVs(MDLVertexFormat a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  float *v5;
  NSObject *v6;
  uint8_t v7[16];

  if (a1 == MDLVertexFormatFloat2)
  {
    if (a5)
    {
      v5 = (float *)&a2[a3 + 4];
      do
      {
        *v5 = 1.0 - *v5;
        v5 = (float *)((char *)v5 + a4);
        --a5;
      }
      while (a5);
    }
  }
  else
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v7 = 0;
      _os_log_impl(&dword_1DCCB8000, v6, OS_LOG_TYPE_DEFAULT, "Warning: Warning: unable to flip non-float2 texture coordinates, skipping\n", v7, 2u);
    }
  }
}

void sub_1DCCC17E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SCNMTLFunctionTypeToProgramStage(uint64_t a1)
{
  NSObject *v2;

  if (a1 != 3)
    return a1 == 2;
  v2 = scn_default_log();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    SCNMTLFunctionTypeToProgramStage_cold_1(v2);
  return 2;
}

uint64_t __structMemberSize(MTLStructMember *a1)
{
  int i;
  MTLDataType v3;
  MTLArrayType *v4;
  int v5;
  int Size;

  for (i = 0; ; i += -[MTLStructMember offset](a1, "offset"))
  {
    v3 = -[MTLStructMember dataType](a1, "dataType");
    if (v3 != MTLDataTypeStruct)
      break;
    a1 = -[NSArray lastObject](-[MTLStructType members](-[MTLStructMember structType](a1, "structType"), "members"), "lastObject");
  }
  if (v3 == MTLDataTypeArray)
  {
    v4 = -[MTLStructMember arrayType](a1, "arrayType");
    v5 = -[MTLArrayType arrayLength](v4, "arrayLength");
    Size = SCNMTLDataTypeGetSize(-[MTLArrayType elementType](v4, "elementType")) * v5;
  }
  else
  {
    Size = SCNMTLDataTypeGetSize(v3);
  }
  return (Size + i);
}

uint64_t SCNMTLDataTypeGetSize(uint64_t a1)
{
  return mtl_DataTypeSize[a1];
}

objc_property *SCNBaseTypeOfObjCProperty(objc_class *a1, void *a2)
{
  objc_property *result;
  const char *v3;

  result = class_getProperty(a1, (const char *)objc_msgSend(a2, "UTF8String"));
  if (result)
  {
    v3 = (const char *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", property_getAttributes(result)), "componentsSeparatedByString:", CFSTR(",")), "objectAtIndex:", 0), "substringFromIndex:", 1), "UTF8String");
    return (objc_property *)SCNObjCEncodedTypeToC3DBaseType(v3);
  }
  return result;
}

uint64_t propertyNameForSetter(void *a1)
{
  const char *v1;
  size_t v2;
  _BYTE *v3;
  uint64_t v4;

  v1 = (const char *)objc_msgSend(a1, "UTF8String");
  v2 = strlen(v1);
  v3 = malloc_type_malloc(v2 - 3, 0x52FC7095uLL);
  memcpy(v3, v1 + 3, v2 - 4);
  *v3 = __tolower((char)*v3);
  v3[v2 - 4] = 0;
  v4 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v3);
  free(v3);
  return v4;
}

uint64_t C3DProgramHashCodeCreate(_QWORD *a1, __C3DGeometry *a2, uint64_t a3, uint64_t a4, _BYTE *a5, uint64_t a6, unint64_t a7)
{
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 updated;
  float v13;
  float v14;
  float *CommonProfile;
  uint64_t v16;
  float *Color;
  int LightingModel;
  int v19;
  int v20;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  __C3DGeometry *v25;
  _BOOL4 WantsHardwareTessellation;
  int v27;
  _BOOL4 v28;
  CFTypeID v29;
  uint64_t Skinner;
  uint64_t v31;
  uint64_t OverrideMaterial;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int MaxInfluencesPerVertex;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  int v49;
  _BOOL4 PathTypeSupportsSingleCrease;
  uint64_t PrimvarDataTypeHash;
  int v52;
  char v53;
  unint64_t v54;
  unsigned int v55;
  uint64_t v56;
  char v57;
  uint64_t v58;
  unsigned int v59;
  unsigned int EffectPropertyHashCode;
  int v61;
  int v62;
  int v63;
  int v64;
  float Intensity;
  unsigned int v66;
  int v67;
  NSObject *v68;
  uint64_t v69;
  int v70;
  unsigned int v71;
  unsigned __int8 v72;
  uint64_t v73;
  unsigned __int8 *v74;
  uint64_t v75;
  int v76;
  char *v77;
  uint64_t EffectSlot;
  uint64_t v79;
  uint64_t v80;
  __int16 v81;
  _BOOL4 HasImageOrTexture;
  __int16 v83;
  _BOOL4 v84;
  __int16 v85;
  __int16 v86;
  __int16 v87;
  _BOOL4 EffectiveDataKindForRendering;
  __int16 v89;
  __int16 v90;
  __int16 v91;
  uint64_t v92;
  int IsOpaque;
  int v94;
  int v95;
  int BlendStatesUseConstantAlpha;
  int v97;
  _BOOL4 v98;
  __int16 v99;
  __int16 v100;
  __int16 v101;
  __int16 v102;
  int v103;
  uint64_t CategoryBitMask;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  __int16 v111;
  int IsDynamicBatchingEnabled;
  int v113;
  __int16 v114;
  __int16 v115;
  uint64_t v116;
  char v117;
  int v118;
  char v119;
  const __CFArray *v120;
  uint64_t i;
  uint64_t v122;
  uint64_t v123;
  char *v124;
  uint8x16_t v125;
  int8x16_t v126;
  int8x16_t v127;
  int8x16_t v128;
  uint8x16_t v129;
  int8x16_t v130;
  int8x16_t v131;
  CFStringRef v132;
  uint64_t v133;
  char v134;
  char v135;
  const void *v136;
  unsigned int v137;
  unint64_t v138;
  const void *v139;
  uint64_t v141;
  int v143;
  int TransparencyMode;
  NSObject *v145;
  __int16 v146;
  __int16 v147;
  _BOOL4 v148;
  _BOOL4 v154;
  int v155;
  _QWORD block[13];
  __n128 v157;
  int v158;
  int data;
  _QWORD v160[5];
  int v161;
  CC_SHA256_CTX c;
  uint8_t buf[4];
  uint64_t v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  _BYTE v175[32];
  __int128 v176;
  _QWORD v177[12];
  char cStr[8];
  char *v179;
  uint64_t v180;
  uint64_t v181;
  char v182;
  unsigned __int8 md[32];
  uint64_t v184;
  int8x16x2_t v185;

  v184 = *MEMORY[0x1E0C80C00];
  if (!a6)
    return 0;
  if (a5)
  {
    v8 = *(unsigned __int16 *)a5;
    v9 = (v8 >> 1) & 1;
    v143 = (v8 >> 4) & 7;
    v10 = v8 & 1;
  }
  else
  {
    LOWORD(v143) = 0;
    v9 = 0;
    v10 = 1;
  }
  v176 = 0u;
  memset(v177, 0, 88);
  memset(v175, 0, sizeof(v175));
  v173 = 0u;
  v174 = 0u;
  v171 = 0u;
  v172 = 0u;
  v169 = 0u;
  v170 = 0u;
  v167 = 0u;
  v168 = 0u;
  v165 = 0u;
  v166 = 0u;
  WORD4(v176) = 7;
  WORD2(v176) = a7;
  BYTE6(v176) = BYTE2(a7);
  BYTE7(v176) = BYTE3(a7);
  v158 = 0;
  updated = __UpdateShaderModifiersInProgramHashCode((uint64_t)&v165, a6, 0, (_WORD *)&v158 + 1, &v158);
  v146 = __UpdateShaderModifiersInProgramHashCode((uint64_t)&v165, (uint64_t)a2, 1, (_WORD *)&v158 + 1, &v158);
  C3DNodeGetWorldAlpha((uint64_t)a1);
  v14 = v13;
  CommonProfile = (float *)C3DMaterialGetCommonProfile(a6);
  TransparencyMode = C3DEffectCommonProfileGetTransparencyMode((uint64_t)CommonProfile);
  if (TransparencyMode == 1)
  {
    v148 = v14 >= 1.0;
    Color = (float *)C3DEffectCommonProfileGetColor((uint64_t)CommonProfile, 5);
    v16 = a3;
    if ((C3DEffectCommonProfileContainsContentForEffectProperty((uint64_t)CommonProfile, 5) & 1) != 0
      || !C3DColor4IsBlack(Color) && C3DEffectCommonProfileGetFloatProperty(CommonProfile, 18) != 0.0)
    {
      v148 = 0;
    }
  }
  else
  {
    v148 = (float)(v14 * C3DEffectCommonProfileGetFloatProperty(CommonProfile, 18)) >= 1.0;
    v16 = a3;
  }
  LightingModel = C3DEffectCommonProfileGetLightingModel((uint64_t)CommonProfile);
  v19 = LightingModel;
  if (LightingModel == 5)
    v20 = 1;
  else
    v20 = v9;
  v22 = LightingModel != 4 && v10 == 0 || LightingModel == 5;
  if ((LightingModel | 4) == 4)
    v20 = 0;
  v155 = v20;
  if (a1)
  {
    v23 = C3DNodeGetLightmapInfo((uint64_t)a1) != 0;
    if (v16)
    {
LABEL_25:
      v24 = C3DMeshContainsSourcesWithSemantic(v16, 2);
      goto LABEL_28;
    }
  }
  else
  {
    v23 = 0;
    if (v16)
      goto LABEL_25;
  }
  v24 = 0;
LABEL_28:
  v25 = a2;
  v154 = v22;
  if (a2)
  {
    WantsHardwareTessellation = C3DGeometryGetWantsHardwareTessellation(a2);
    if (WantsHardwareTessellation)
    {
      C3DGeometryGetTessellator((uint64_t)a2, &v157);
      v27 = v157.n128_u8[12];
      v25 = a2;
    }
    else
    {
      v27 = 0;
    }
    v29 = CFGetTypeID(v25);
    v28 = v29 == C3DBezierCurveGeometryGetTypeID();
  }
  else
  {
    v27 = 0;
    WantsHardwareTessellation = 0;
    v28 = 0;
  }
  if (a1
    && (Skinner = C3DNodeGetSkinner((uint64_t)a1), (v31 = Skinner) != 0)
    && C3DSkinnerGetEffectiveCalculationMode(Skinner, a2) == 1)
  {
    OverrideMaterial = C3DGeometryGetOverrideMaterial(v31);
    if (!OverrideMaterial)
    {
      v145 = scn_default_log();
      if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT))
        C3DSkinnerUpdateJointsAndBoundingBox_cold_7(v145, v33, v34, v35, v36, v37, v38, v39);
    }
    MaxInfluencesPerVertex = C3DSkinGetMaxInfluencesPerVertex(OverrideMaterial);
    if (MaxInfluencesPerVertex >= 4)
      LODWORD(v41) = 4;
    else
      LODWORD(v41) = MaxInfluencesPerVertex;
    v41 = (int)v41;
  }
  else
  {
    v41 = 0;
  }
  v141 = v41;
  v42 = v23 | ((_DWORD)v41 << 28);
  if (v24)
    v43 = 2;
  else
    v43 = 0;
  v44 = v42 | v43;
  if (WantsHardwareTessellation)
    v45 = 4;
  else
    v45 = 0;
  v46 = v44 | v45 | (8 * v27);
  if (v28)
    v47 = 0x8000000;
  else
    v47 = 0;
  HIDWORD(v172) = v46 | v47;
  WORD4(v172) = C3DEffectCommonProfileGetHashCode((uint64_t)CommonProfile);
  if (!C3DGeometryOpenSubdivGPUIsActive(a2))
  {
    v53 = BYTE10(v176) & 0xF8;
    goto LABEL_64;
  }
  memset(&c, 0, 24);
  C3DGeometryGetTessellator((uint64_t)a2, (__n128 *)&c);
  v48 = (a7 >> 24) & 7;
  v49 = BYTE1(c.hash[2]);
  if ((c.hash[2] & 0x100) != 0)
  {
    if (C3DGeometryOpenSubdivGetGPUCanBenefitFromSingleCreasePatches((uint64_t)a2))
    {
      PathTypeSupportsSingleCrease = C3DSubdivisionGetPathTypeSupportsSingleCrease(v48);
      v49 = BYTE1(c.hash[2]);
      PrimvarDataTypeHash = C3DGeometryOsdGetPrimvarDataTypeHash(a2);
      if (PathTypeSupportsSingleCrease)
        v52 = 96;
      else
        v52 = 32;
      goto LABEL_63;
    }
    v49 = BYTE1(c.hash[2]);
  }
  PrimvarDataTypeHash = C3DGeometryOsdGetPrimvarDataTypeHash(a2);
  v52 = 32;
LABEL_63:
  HIDWORD(v172) |= v52 & 0xF80000FF | ((PrimvarDataTypeHash & 0x7FFFF) << 8) | (v49 << 6) & 0x80;
  v53 = BYTE10(v176) & 0xF8 | v48;
LABEL_64:
  BYTE10(v176) = v53;
  v147 = v146 | updated;
  if (a5)
  {
    v54 = *(unsigned __int16 *)a5;
    v55 = *(unsigned __int16 *)a5;
    v56 = (v54 >> 7);
    if ((v54 >> 7))
    {
      __memcpy_chk();
      bzero((char *)&v173 + 4 * v56, (32 - (4 * v56)) & 0x3FFFFFFFCLL);
    }
    else
    {
      v173 = 0u;
      v174 = 0u;
    }
    v57 = v55 >> 7;
  }
  else
  {
    v57 = 0;
    v173 = 0u;
    v174 = 0u;
  }
  v58 = 0;
  v175[0] = v57;
  v59 = HIWORD(v158);
  do
  {
    EffectPropertyHashCode = C3DEffectCommonProfileGetEffectPropertyHashCode(CommonProfile, (char)v58);
    if ((EffectPropertyHashCode & 1) != 0 || ((v59 >> v58) & 1) != 0)
      EffectPropertyHashCode = __UpdateHashCodeWithTextureType((uint64_t)&v165, a3, (uint64_t)CommonProfile, (char)v58, EffectPropertyHashCode, v59 != 0);
    v61 = v155;
    if (v58 != 1)
      v61 = v154;
    if (v61)
      v62 = v19;
    else
      v62 = 4;
    if (C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel(v62, (char)v58))
    {
      v63 = 1;
      switch(v58)
      {
        case 2:
        case 10:
        case 11:
          goto LABEL_114;
        case 5:
          v63 = (EffectPropertyHashCode >> 5) & 1;
          if ((EffectPropertyHashCode & 8) == 0)
            v63 = 1;
          v64 = EffectPropertyHashCode & 1;
          if ((EffectPropertyHashCode & 2) == 0)
            v64 = 1;
          if (TransparencyMode == 1)
            v63 = v64;
          if ((EffectPropertyHashCode & 0x2000) == 0)
            goto LABEL_121;
          goto LABEL_115;
        case 6:
          v63 = (EffectPropertyHashCode & 4) == 0;
          if ((EffectPropertyHashCode & 1) != 0)
            v63 = 1;
          if ((EffectPropertyHashCode & 0x2000) == 0)
            goto LABEL_121;
          goto LABEL_115;
        case 13:
          v63 = (BYTE5(v170) >> 3) & 1;
          if ((EffectPropertyHashCode & 3) == 2)
            v63 = 0;
          if ((EffectPropertyHashCode & 0x2000) == 0)
            goto LABEL_121;
          goto LABEL_115;
        case 14:
          v63 = EffectPropertyHashCode & ((BYTE5(v170) & 8) >> 3);
          if ((EffectPropertyHashCode & 0x2000) == 0)
            goto LABEL_121;
          goto LABEL_115;
        case 15:
          v63 = EffectPropertyHashCode & 1;
          if ((EffectPropertyHashCode & 0x2000) == 0)
            goto LABEL_121;
          goto LABEL_115;
        case 16:
          v63 = (BYTE1(v168) >> 3) & 1;
          if ((EffectPropertyHashCode & 0x2000) == 0)
            goto LABEL_121;
          goto LABEL_115;
        case 17:
          goto LABEL_129;
        case 18:
          v63 = C3DEffectCommonProfileGetFloatProperty(CommonProfile, 18) < 1.0;
          if ((EffectPropertyHashCode & 0x2000) == 0)
            goto LABEL_121;
          goto LABEL_115;
        case 19:
          v63 = (EffectPropertyHashCode & 0x10) == 0;
          if ((EffectPropertyHashCode & 0x2000) == 0)
            goto LABEL_121;
          goto LABEL_115;
        case 20:
          if ((EffectPropertyHashCode & 0x10) == 0)
            goto LABEL_114;
          LODWORD(v172) = 0;
          goto LABEL_129;
        default:
          if ((EffectPropertyHashCode & 1) != 0)
          {
            v63 = 1;
LABEL_114:
            if ((EffectPropertyHashCode & 0x2000) == 0)
              goto LABEL_121;
          }
          else
          {
            if (v58 == 6)
            {
              if ((EffectPropertyHashCode & 4) != 0)
                goto LABEL_129;
            }
            else if ((EffectPropertyHashCode & 2) != 0)
            {
              goto LABEL_129;
            }
            v63 = !((v19 == 4) & C3DEffectCommonProfileGetEnableNormals((uint64_t)CommonProfile));
            if ((EffectPropertyHashCode & 0x2000) == 0)
              goto LABEL_121;
          }
LABEL_115:
          if (v58 != 2 && v63)
          {
            Intensity = C3DEffectCommonProfileGetIntensity((uint64_t)CommonProfile, (char)v58);
            if (Intensity == 0.0)
              goto LABEL_129;
            v66 = EffectPropertyHashCode & 0xFFFFF7FF | ((Intensity != 0.0) << 11);
            goto LABEL_126;
          }
LABEL_121:
          if (v63)
            v67 = 2048;
          else
            v67 = 0;
          if ((v63 & 1) == 0)
            goto LABEL_129;
          v66 = v67 | EffectPropertyHashCode & 0xFFFFF7FF;
LABEL_126:
          *((_DWORD *)&v167 + v58 + 1) = v66;
          if (v66 >= 0x400000)
          {
            v68 = scn_default_log();
            if (os_log_type_enabled(v68, OS_LOG_TYPE_FAULT))
              C3DProgramHashCodeCreate_cold_1(buf, &v164, v68);
          }
          break;
      }
    }
    else
    {
LABEL_129:
      *((_DWORD *)&v167 + v58 + 1) = 0;
    }
    ++v58;
  }
  while (v58 != 21);
  v69 = MEMORY[0x1E0C809B0];
  *(_QWORD *)c.count = MEMORY[0x1E0C809B0];
  *(_QWORD *)c.hash = 3221225472;
  *(_QWORD *)&c.hash[2] = ____ComputeCustomSlotsUsage_block_invoke;
  *(_QWORD *)&c.hash[4] = &__block_descriptor_40_e25_v24__0____CFString__8_v16l;
  *(_QWORD *)&c.hash[6] = &v165;
  C3DEntityEnumerateKeyValuesWithBlockBySortingKeys(a6, (uint64_t)&c);
  *(_QWORD *)c.count = v69;
  *(_QWORD *)c.hash = 3221225472;
  *(_QWORD *)&c.hash[2] = ____ComputeCustomSlotsUsage_block_invoke;
  *(_QWORD *)&c.hash[4] = &__block_descriptor_40_e25_v24__0____CFString__8_v16l;
  *(_QWORD *)&c.hash[6] = &v165;
  C3DEntityEnumerateKeyValuesWithBlockBySortingKeys((uint64_t)a2, (uint64_t)&c);
  v70 = 0;
  v71 = (unsigned __int16)v158;
  v72 = v175[3];
  do
  {
    if (((v71 >> v70) & 1) != 0)
    {
      if (v72)
      {
        v73 = v72;
        v74 = &v175[4];
        v75 = v72;
        while (1)
        {
          v76 = *v74;
          v74 += 2;
          if (v70 == v76)
            break;
          if (!--v75)
            goto LABEL_139;
        }
      }
      else
      {
        v73 = 0;
LABEL_139:
        v77 = (char *)&v165 + 2 * v73;
        v77[164] = v70;
        v77[165] = -1;
        v175[3] = ++v72;
      }
    }
    ++v70;
  }
  while (v70 != 16);
  EffectSlot = C3DEffectCommonProfileGetEffectSlot((uint64_t)CommonProfile, 7, 0);
  v79 = C3DEffectCommonProfileGetEffectSlot((uint64_t)CommonProfile, 14, 0);
  v80 = C3DEffectCommonProfileGetEffectSlot((uint64_t)CommonProfile, 15, 0);
  if (EffectSlot)
  {
    if (C3DEffectSlotHasImageOrTexture(EffectSlot))
      v81 = 16;
    else
      v81 = 0;
    WORD4(v176) = WORD4(v176) & 0xFFEF | v81;
  }
  if (v80)
  {
    HasImageOrTexture = C3DEffectSlotHasImageOrTexture(v80);
    v83 = BYTE8(v176) & 0x10;
    if (HasImageOrTexture)
      v83 = 16;
    WORD4(v176) = v83 | WORD4(v176) & 0xFFEF;
  }
  if (v79)
  {
    v84 = C3DEffectSlotHasImageOrTexture(v79);
    v85 = BYTE8(v176) & 0x10;
    if (v84)
      v85 = 16;
    v86 = v85 | WORD4(v176) & 0xFFEF;
  }
  else
  {
    v86 = WORD4(v176);
  }
  WORD4(v176) = v86 | (4 * v147) & 0x10;
  if (v86 & 0x10 | (4 * (_BYTE)v147) & 0x10)
  {
    v87 = C3DMeshGetSourcesCountForSemantic(a3, 3) > 0;
    WORD4(v176) = WORD4(v176) & 0xFFEF | (16 * v87);
  }
  EffectiveDataKindForRendering = C3DGeometryGetEffectiveDataKindForRendering(a2);
  if (a3)
  {
    v89 = C3DMeshGetSourceWithSemanticAtIndex(a3, 1, 0, EffectiveDataKindForRendering) != 0;
    v90 = WORD4(v176);
    v91 = 8 * v89;
  }
  else
  {
    v91 = 0;
    v90 = WORD4(v176);
  }
  WORD4(v176) = v90 & 0xFFF7 | v91;
  if (a1)
  {
    v92 = C3DGetScene(a1);
    if (v92)
    {
      if (C3DSceneGetFogEndDistance(v92) > 0.0)
        WORD4(v176) |= 0x80u;
    }
  }
  if (v148)
    IsOpaque = C3DEffectCommonProfileIsOpaque((uint64_t)CommonProfile);
  else
    IsOpaque = 0;
  if ((v147 & 2) != 0)
  {
    v95 = 0;
    BlendStatesUseConstantAlpha = 0;
  }
  else
  {
    v94 = (v147 & 2) >> 1;
    if (a3 && C3DMeshHasNonOpaqueColorSources(a3))
      v94 = 1;
    v95 = 0;
    BlendStatesUseConstantAlpha = 0;
    if (v19 != 6 && !v94)
    {
      BlendStatesUseConstantAlpha = C3DMaterialGetBlendStatesUseConstantAlpha(a6, IsOpaque);
      v95 = IsOpaque;
    }
  }
  if (v19 == 5)
    BlendStatesUseConstantAlpha &= ~((TransparencyMode != 1) & C3DPBROpacityIsEnabled());
  v97 = C3DWasLinkedBeforeMajorOSYear2017();
  v98 = v154;
  if ((v97 & v154) == 1)
    v98 = C3DMeshGetNormalSource(a3, 0) != 0;
  if (v95)
    v99 = 4;
  else
    v99 = 0;
  if (BlendStatesUseConstantAlpha)
    v100 = 2;
  else
    v100 = 0;
  if (v98)
    v101 = 32;
  else
    v101 = 0;
  if (v155)
    v102 = 64;
  else
    v102 = 0;
  WORD4(v176) = v102 | v148 | v99 | v100 | v101 | WORD4(v176) & 0xFF98;
  LOBYTE(v103) = (_BYTE)a5;
  if (a5)
  {
    BYTE10(v176) = (2 * *a5) & 0x18 | BYTE10(v176) & 0xE7;
    CategoryBitMask = C3DNodeGetCategoryBitMask((uint64_t)a1);
    v105 = *(unsigned __int16 *)a5;
    v106 = (v105 >> 7);
    if ((v105 >> 7))
    {
      v107 = 0;
      v103 = 0;
      v108 = (uint64_t)a2;
      do
      {
        v109 = *(_QWORD *)&a5[8 * v107 + 40];
        v110 = v103 | (1 << v107);
        if ((v109 & CategoryBitMask) == 0)
          v110 = v103;
        if (v19 != 5)
          v103 |= 1 << v107;
        if (v109 != 0xDEFA017DEFA017)
          v103 = v110;
        ++v107;
      }
      while (v106 != v107);
      goto LABEL_205;
    }
    LOBYTE(v103) = 0;
  }
  else
  {
    BYTE10(v176) &= 0xE7u;
  }
  v108 = (uint64_t)a2;
LABEL_205:
  v175[1] = v103;
  v111 = ((_WORD)v143 << 11) | 0x400;
  if (v19 != 5)
    v111 = 0;
  WORD4(v176) = v111 | WORD4(v176) & 0xC3FF;
  IsDynamicBatchingEnabled = C3DGeometryIsDynamicBatchingEnabled(v108);
  if (v141)
    v113 = 0;
  else
    v113 = IsDynamicBatchingEnabled;
  if ((v113 & v148) != 0)
    v114 = 256;
  else
    v114 = 0;
  WORD4(v176) = v114 | WORD4(v176) & 0xFCFF;
  if (a4)
  {
    v115 = C3DMeshElementGetType(a4) == 3;
    WORD4(v176) = WORD4(v176) & 0xFDFF | (v115 << 9);
  }
  memset(&c, 0, sizeof(c));
  CC_SHA256_Init(&c);
  v116 = 0;
  v117 = 1;
  do
  {
    v118 = 0;
    v119 = v117;
    v120 = (const __CFArray *)*((_QWORD *)&v166 + v116);
    do
    {
      v160[0] = v69;
      v160[1] = 3221225472;
      v160[2] = ____createHashCode_block_invoke;
      v160[3] = &__block_descriptor_44_e13_v24__0q8r_v16l;
      v161 = v118;
      v160[4] = &c;
      C3DCFArrayApplyBlock(v120, (uint64_t)v160);
      ++v118;
    }
    while (v118 != 4);
    v117 = 0;
    v116 = 1;
  }
  while ((v119 & 1) != 0);
  for (i = 216; i != 280; i += 8)
  {
    v122 = *(_QWORD *)((char *)&v165 + i);
    if (v122)
      CFStringUpdateHash(v122);
  }
  CC_SHA256_Update(&c, (char *)&v167 + 4, 0xB4u);
  data = 2;
  CC_SHA256_Update(&c, &data, 4u);
  CC_SHA256_Final(md, &c);
  v123 = 0;
  v124 = cStr;
  v125.i64[0] = 0xA0A0A0A0A0A0A0A0;
  v125.i64[1] = 0xA0A0A0A0A0A0A0A0;
  v126.i64[0] = 0x3737373737373737;
  v126.i64[1] = 0x3737373737373737;
  v127.i64[0] = 0x3030303030303030;
  v127.i64[1] = 0x3030303030303030;
  v128.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v128.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  v129.i64[0] = 0xA0A0A0A0A0A0A0ALL;
  v129.i64[1] = 0xA0A0A0A0A0A0A0ALL;
  do
  {
    v130 = *(int8x16_t *)&md[v123];
    v185.val[0] = (int8x16_t)vsraq_n_u8((uint8x16_t)vbslq_s8((int8x16_t)vcgtq_u8(v125, (uint8x16_t)v130), v127, v126), (uint8x16_t)v130, 4uLL);
    v131 = vandq_s8(v130, v128);
    v185.val[1] = vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v129, (uint8x16_t)v131), v127, v126), v131);
    vst2q_s8(v124, v185);
    v124 += 32;
    v123 += 16;
  }
  while (v123 != 32);
  v182 = 0;
  v132 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x600u);
  if (C3DProgramHashCodeCreate_once != -1)
    dispatch_once(&C3DProgramHashCodeCreate_once, &__block_literal_global_9_2);
  *(_QWORD *)c.count = 0;
  *(_QWORD *)c.hash = &c;
  *(_QWORD *)&c.hash[2] = 0x2020000000;
  *(_QWORD *)&c.hash[4] = 0;
  *(_QWORD *)cStr = 0;
  v179 = cStr;
  v180 = 0x2020000000;
  v181 = 0;
  block[0] = v69;
  block[1] = 3221225472;
  block[2] = __C3DProgramHashCodeCreate_block_invoke_2;
  block[3] = &unk_1EA5A3870;
  block[4] = cStr;
  block[5] = &c;
  block[6] = v132;
  block[7] = &v165;
  block[8] = a1;
  block[9] = a2;
  block[10] = a3;
  block[11] = a5;
  block[12] = a6;
  dispatch_sync((dispatch_queue_t)s_ProgramHashCodeDictionaryQueue, block);
  CFRelease(v132);
  v133 = 0;
  v134 = 1;
  do
  {
    v135 = v134;
    v136 = (const void *)*((_QWORD *)&v166 + v133);
    if (v136)
    {
      CFRelease(v136);
      *((_QWORD *)&v166 + v133) = 0;
    }
    v134 = 0;
    v133 = 1;
  }
  while ((v135 & 1) != 0);
  v137 = v175[2];
  if (v175[2])
  {
    v138 = 0;
    do
    {
      v139 = (const void *)v177[v138 + 1];
      if (v139)
      {
        CFRelease(v139);
        v177[v138 + 1] = 0;
        v137 = v175[2];
      }
      ++v138;
    }
    while (v138 < v137);
  }
  v11 = *(_QWORD *)(*(_QWORD *)c.hash + 24);
  _Block_object_dispose(cStr, 8);
  _Block_object_dispose(&c, 8);
  return v11;
}

void sub_1DCCC2E5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  uint64_t v43;

  _Block_object_dispose((const void *)(v43 - 224), 8);
  _Block_object_dispose(&a43, 8);
  _Unwind_Resume(a1);
}

uint64_t C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel(int a1, int a2)
{
  uint64_t v2;
  int v4;
  int v5;

  if ((C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapsReady & 1) == 0)
  {
    v4 = a1;
    v5 = a2;
    v2 = 0;
    *(int *)((char *)&dword_1F03C4A02 + 1) = 0;
    xmmword_1F03C49E4 = 0u;
    unk_1F03C49F4 = 0u;
    xmmword_1F03C49C4 = 0u;
    unk_1F03C49D4 = 0u;
    xmmword_1F03C49A4 = 0u;
    unk_1F03C49B4 = 0u;
    xmmword_1F03C4984 = 0u;
    unk_1F03C4994 = 0u;
    C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities = 0u;
    while (2)
    {
      switch(v2)
      {
        case 0:
          LODWORD(C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities) = 65793;
          WORD2(C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities) = 257;
          BYTE6(C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities) = 1;
          *(_DWORD *)((char *)&C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities
                    + 7) = 0;
          BYTE11(C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities) = 0;
          HIDWORD(C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities) = 0x1000000;
          LOBYTE(xmmword_1F03C4984) = 0;
          *(_DWORD *)((char *)&xmmword_1F03C4984 + 1) = 16843009;
          goto LABEL_10;
        case 1:
          *(_QWORD *)((char *)&xmmword_1F03C4984 + 5) = 0x101010100010101;
          *(_WORD *)((char *)&xmmword_1F03C4984 + 13) = 257;
          *(_DWORD *)((char *)&xmmword_1F03C4984 + 15) = 0;
          byte_1F03C4997 = 0;
          unk_1F03C4998 = 1;
          unk_1F03C499A = 16843009;
          goto LABEL_10;
        case 2:
          unk_1F03C499E = 0x101010101010101;
          WORD1(xmmword_1F03C49A4) = 257;
          DWORD1(xmmword_1F03C49A4) = 0;
          BYTE8(xmmword_1F03C49A4) = 0;
          *(_DWORD *)((char *)&xmmword_1F03C49A4 + 9) = 16843009;
          *(_WORD *)((char *)&xmmword_1F03C49A4 + 13) = 257;
          goto LABEL_10;
        case 3:
          *(_QWORD *)((char *)&xmmword_1F03C49A4 + 15) = 0x101010101010101;
          word_1F03C49BB = 257;
          unk_1F03C49BD = 0;
          byte_1F03C49C1 = 0;
          *(_DWORD *)algn_1F03C49C2 = 16843009;
          WORD1(xmmword_1F03C49C4) = 257;
          goto LABEL_10;
        case 4:
          DWORD1(xmmword_1F03C49C4) = 65537;
          WORD4(xmmword_1F03C49C4) = 257;
          BYTE10(xmmword_1F03C49C4) = 1;
          *(_QWORD *)((char *)&xmmword_1F03C49C4 + 11) = 0;
          unk_1F03C49D7 = 1;
          unk_1F03C49D9 = 16843009;
          goto LABEL_10;
        case 5:
          dword_1F03C49DD = 65537;
          word_1F03C49E1 = 256;
          byte_1F03C49E3 = C3DWasLinkedBeforeMajorOSYear2018() ^ 1;
          *(_QWORD *)&xmmword_1F03C49E4 = 0x101010101010101;
          BYTE8(xmmword_1F03C49E4) = 1;
          *(_DWORD *)((char *)&xmmword_1F03C49E4 + 9) = 0x10000;
          BYTE13(xmmword_1F03C49E4) = 0;
          goto LABEL_10;
        case 6:
          *(_QWORD *)((char *)&xmmword_1F03C49E4 + 14) = 0;
          unk_1F03C49FA = 0;
          dword_1F03C4A02 = 0x10000;
          byte_1F03C4A06 = 0;
          goto LABEL_11;
        default:
LABEL_10:
          if (++v2 != 7)
            continue;
LABEL_11:
          C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapsReady = 1;
          a1 = v4;
          a2 = v5;
          break;
      }
      break;
    }
  }
  return *((unsigned __int8 *)&C3DEffectCommonProfileIsEffectPropertyEnabledForLightingModel_lightingModelsCapabilities
         + 21 * a1
         + a2);
}

uint64_t C3DEffectCommonProfileGetEffectPropertyHashCode(float *a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t EffectSlot;

  v4 = 0;
  EffectSlot = C3DEffectCommonProfileGetEffectSlot((uint64_t)a1, a2, 0);
  if (a2 < 0x10)
    return _C3DEffectSlotGetHashCode(EffectSlot, a2);
  if (a2 <= 0x14 && ((1 << a2) & 0x1D0000) != 0)
    return 16 * (C3DEffectCommonProfileGetFloatProperty(a1, a2) == 0.0);
  return v4;
}

uint64_t C3DEffectCommonProfileGetEffectSlot(uint64_t a1, int a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t result;
  uint64_t v16;
  float *v17;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      _C3DEffectCommonProfileReleaseSlot_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  switch(a2)
  {
    case 0:
      v14 = (uint64_t *)(a1 + 32);
      goto LABEL_22;
    case 1:
      v14 = (uint64_t *)(a1 + 40);
      goto LABEL_22;
    case 2:
      v14 = (uint64_t *)(a1 + 48);
      goto LABEL_22;
    case 3:
      v14 = (uint64_t *)(a1 + 56);
      goto LABEL_22;
    case 4:
      v14 = (uint64_t *)(a1 + 64);
      goto LABEL_22;
    case 5:
      v14 = (uint64_t *)(a1 + 72);
      goto LABEL_22;
    case 6:
      v14 = (uint64_t *)(a1 + 80);
      goto LABEL_22;
    case 7:
      v14 = (uint64_t *)(a1 + 88);
      goto LABEL_22;
    case 8:
      v14 = (uint64_t *)(a1 + 104);
      goto LABEL_22;
    case 9:
      v14 = (uint64_t *)(a1 + 96);
      goto LABEL_22;
    case 10:
      v14 = (uint64_t *)(a1 + 112);
      goto LABEL_22;
    case 11:
      v14 = (uint64_t *)(a1 + 120);
      goto LABEL_22;
    case 12:
      v14 = (uint64_t *)(a1 + 136);
      goto LABEL_22;
    case 13:
      v14 = (uint64_t *)(a1 + 144);
      goto LABEL_22;
    case 14:
      v14 = (uint64_t *)(a1 + 152);
      goto LABEL_22;
    case 15:
      v14 = (uint64_t *)(a1 + 128);
LABEL_22:
      result = *v14;
      if (a3)
      {
        if (!result)
        {
          v16 = C3DEffectSlotCreate(a1, a2);
          *v14 = v16;
          v17 = (float *)C3DEffectCommonProfileDefaultColorForEffectProperty(a2);
          C3DEffectSlotSetColor(v16, v17);
          result = *v14;
        }
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t _C3DEffectSlotGetHashCode(uint64_t a1, int a2)
{
  BOOL HasImageOrTexture;
  int v4;
  _BOOL4 v5;
  _BOOL4 IsWhite;
  _BOOL4 IsBlack;
  float *v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  BOOL v15;
  int v16;
  int v17;
  int v18;
  int v19;

  if (!a1)
  {
    v8 = (float *)C3DEffectCommonProfileDefaultColorForEffectProperty(a2);
    goto LABEL_5;
  }
  HasImageOrTexture = C3DEffectSlotHasImageOrTexture(a1);
  v4 = 1;
  if (!HasImageOrTexture)
  {
    v12 = *(unsigned __int8 *)(a1 + 50);
    v13 = v12 > 0xF;
    v14 = (1 << v12) & 0x8C80;
    v15 = v13 || v14 == 0;
    if (!v15)
    {
      v5 = 0;
      IsWhite = 0;
      IsBlack = 0;
      v4 = 0;
      goto LABEL_12;
    }
    v8 = (float *)(a1 + 16);
LABEL_5:
    IsBlack = C3DColor4IsBlack(v8);
    IsWhite = C3DColor4IsWhite(v8);
    v4 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v5 = v8[3] >= 1.0;
    if (!a1)
      goto LABEL_15;
    goto LABEL_12;
  }
  v5 = 0;
  IsWhite = 0;
  IsBlack = 0;
LABEL_12:
  v9 = (*(float *)(a1 + 72) != 1.0) << 13;
  v16 = (*(unsigned __int16 *)(a1 + 48) >> 11) & 0xF;
  v15 = v16 == 15;
  v11 = v16 << 14;
  if (v15)
    v11 = 0;
  v10 = v4;
LABEL_15:
  if (IsBlack)
    v17 = 2;
  else
    v17 = 0;
  if (IsWhite)
    v18 = 4;
  else
    v18 = 0;
  if (v5)
    v19 = 8;
  else
    v19 = 0;
  return v10 | v9 | v17 | v18 | v11 | v19;
}

void *C3DEffectCommonProfileGetColor(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t EffectSlot;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (EffectSlot)
    return (void *)(EffectSlot + 16);
  else
    return C3DEffectCommonProfileDefaultColorForEffectProperty(a2);
}

void *C3DEffectCommonProfileDefaultColorForEffectProperty(int a1)
{
  uint64_t v1;

  v1 = a1 - 1;
  if (v1 > 0xD)
    return &c3dBlack;
  else
    return *(&off_1EA5A1060 + v1);
}

float C3DEffectCommonProfileGetFloatProperty(float *a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = 0.0;
  switch(a2)
  {
    case 16:
      result = a1[40];
      break;
    case 18:
      result = a1[41];
      break;
    case 19:
      result = a1[42];
      break;
    case 20:
      result = a1[43];
      break;
    default:
      return result;
  }
  return result;
}

BOOL C3DColor4IsWhite(float *a1)
{
  return fabsf(*a1 + -1.0) <= 0.001 && fabsf(a1[1] + -1.0) <= 0.001 && fabsf(a1[2] + -1.0) <= 0.001;
}

uint64_t C3DEffectSlotCreate(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  __int16 v6;
  __int16 v7;

  if (C3DEffectSlotGetTypeID_onceToken != -1)
    dispatch_once(&C3DEffectSlotGetTypeID_onceToken, &__block_literal_global_25_0);
  result = C3DTypeCreateInstance_(C3DEffectSlotGetTypeID_typeID, 0x50uLL);
  *(_BYTE *)(result + 50) = a2;
  *(_QWORD *)(result + 72) = 0xFFFFFFFE3F800000;
  *(_QWORD *)(result + 80) = a1;
  v5 = a2 - 5;
  if (v5 > 0x15)
    v6 = 1024;
  else
    v6 = word_1DD02A0BC[v5];
  if (a2 == 15)
    v7 = 0x4000;
  else
    v7 = 30720;
  *(_WORD *)(result + 48) = v6 | v7 | *(_WORD *)(result + 48) & 0x83FF;
  return result;
}

void C3DCFArrayApplyBlock(const __CFArray *a1, uint64_t a2)
{
  _QWORD v3[2];
  CFRange v4;

  if (a1)
  {
    if (a2)
    {
      v3[0] = 0;
      v3[1] = a2;
      v4.length = CFArrayGetCount(a1);
      v4.location = 0;
      CFArrayApplyFunction(a1, v4, (CFArrayApplierFunction)_C3DCFArrayApplyBlock, v3);
    }
  }
}

BOOL C3DEffectSlotHasImageOrTexture(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Image;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  Image = C3DEffectSlotGetImage(a1);
  return Image && (C3DImageIsValid(Image) & 1) != 0
      || C3DEffectSlotGetImageProxy(a1)
      || C3DEffectSlotGetTexture(a1)
      || C3DEffectSlotGetMTLTexture(a1) != 0;
}

uint64_t C3DEffectSlotGetImage(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(_BYTE *)(a1 + 48))
    return 0;
  else
    return *(_QWORD *)(a1 + 40);
}

uint64_t C3DEffectSlotGetImageProxy(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(_BYTE *)(a1 + 48) == 2)
    return *(_QWORD *)(a1 + 40);
  else
    return 0;
}

uint64_t C3DEffectSlotGetMTLTexture(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(_BYTE *)(a1 + 48) == 3)
    return *(_QWORD *)(a1 + 40);
  else
    return 0;
}

uint64_t C3DEffectSlotGetTexture(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(unsigned __int8 *)(a1 + 48);
  if (v10 == 2)
    return *(_QWORD *)(a1 + 32);
  if (v10 == 1)
    return *(_QWORD *)(a1 + 40);
  return 0;
}

uint64_t C3DImageIsValid(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  const __CFBoolean *Attribute;
  int Value;
  int v13;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(unsigned __int8 *)(a1 + 116);
  if ((v10 & 0x20) == 0)
  {
    Attribute = C3DImageGetAttribute(a1, CFSTR("isAttachment"));
    if (Attribute)
    {
      Value = CFBooleanGetValue(Attribute);
      if (*(_DWORD *)(a1 + 96) == 5 || Value)
        goto LABEL_8;
    }
    else if (*(_DWORD *)(a1 + 96) == 5)
    {
LABEL_8:
      v13 = *(unsigned __int8 *)(a1 + 116) | 0x10;
LABEL_11:
      v10 = v13 | 0x20;
      *(_BYTE *)(a1 + 116) = v10;
      return (v10 >> 4) & 1;
    }
    C3DImageGetSize(a1);
    v13 = *(unsigned __int8 *)(a1 + 116);
    goto LABEL_11;
  }
  return (v10 >> 4) & 1;
}

BOOL C3DGeometryOpenSubdivGPUIsActive(__C3DGeometry *a1)
{
  return a1->var11.var0 == 4 && a1->var10.var0 && C3DGeometryMeshElementsSupportsSubdivision(a1);
}

uint64_t C3DEffectCommonProfileGetTransparencyMode(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 180);
}

uint64_t __UpdateShaderModifiersInProgramHashCode(uint64_t a1, uint64_t a2, int a3, _WORD *a4, _WORD *a5)
{
  const __CFDictionary *ShaderModifiers;
  uint64_t v11;
  unint64_t v12;
  const __CFArray *v13;
  uint64_t v14;
  CFIndex Count;
  uint64_t v16;
  CFArrayRef Copy;
  CFArrayRef v18;
  CFTypeRef v19;
  const void *v20;
  int v21;
  const __CFDictionary *ShadableMinimumMTLLanguageVersion;
  unint64_t v23;
  CFIndex v24;
  const void *ValueAtIndex;
  unint64_t valuePtr;

  ShaderModifiers = C3DEntityGetShaderModifiers(a2);
  v11 = a1 + 16;
  v12 = *(_QWORD *)(a1 + 16 + 8 * a3);
  if (!((unint64_t)ShaderModifiers | v12))
    goto LABEL_25;
  v13 = ShaderModifiers;
  if (ShaderModifiers)
  {
    if (v12 && CFEqual(ShaderModifiers, (CFTypeRef)v12))
      goto LABEL_25;
  }
  v14 = a3;
  Count = CFArrayGetCount(v13);
  if (v13)
  {
    v16 = Count;
    if (Count)
    {
      Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v13);
      v18 = *(CFArrayRef *)(v11 + 8 * v14);
      if (v18 != Copy)
      {
        if (v18)
        {
          CFRelease(v18);
          *(_QWORD *)(v11 + 8 * v14) = 0;
        }
        if (Copy)
          v19 = CFRetain(Copy);
        else
          v19 = 0;
        *(_QWORD *)(v11 + 8 * v14) = v19;
      }
      CFRelease(Copy);
      ShadableMinimumMTLLanguageVersion = C3DEntityGetShadableMinimumMTLLanguageVersion(a2);
      if (ShadableMinimumMTLLanguageVersion)
      {
        valuePtr = 0;
        CFNumberGetValue(ShadableMinimumMTLLanguageVersion, kCFNumberNSIntegerType, &valuePtr);
        v23 = *(unsigned int *)(a1 + 32);
        if (valuePtr > v23)
          LODWORD(v23) = valuePtr;
        *(_DWORD *)(a1 + 32) = v23;
      }
      if (v16 >= 1)
      {
        v24 = 0;
        v21 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v13, v24);
          v21 |= C3DShaderModifierGetFlags((uint64_t)ValueAtIndex);
          *a4 |= C3DShaderModifierGetEffectPropertyMaskForTexcoordsUse((uint64_t)ValueAtIndex);
          *a5 |= C3DShaderModifierGetMappingChannelyMaskForTexcoordsUse((uint64_t)ValueAtIndex);
          ++v24;
        }
        while (v16 != v24);
        return (__int16)v21;
      }
LABEL_25:
      LOWORD(v21) = 0;
      return (__int16)v21;
    }
  }
  v20 = *(const void **)(v11 + 8 * v14);
  if (v20)
  {
    CFRelease(v20);
    *(_QWORD *)(v11 + 8 * v14) = 0;
  }
  LOWORD(v21) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  return (__int16)v21;
}

const __CFDictionary *C3DEntityEnumerateKeyValuesWithBlockBySortingKeys(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(const __CFDictionary **)(a1 + 40);
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("_kvc"));
    if (result)
      return (const __CFDictionary *)C3DKeyValueStoreEnumerateBySortingKeys((uint64_t)result, a2);
  }
  return result;
}

uint64_t __UpdateHashCodeWithTextureType(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, char a6)
{
  int v12;
  uint64_t EffectSlot;
  _BOOL4 HasInterpolationModesPerKey;
  uint64_t UVSet;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 v33;
  unsigned __int8 v34;
  int v35;

  v12 = C3DEffectCommonProfileContainsContentForEffectProperty(a3, a4);
  EffectSlot = C3DEffectCommonProfileGetEffectSlot(a3, a4, 0);
  HasInterpolationModesPerKey = 0;
  if (a4 != 4 && EffectSlot)
    HasInterpolationModesPerKey = C3DKeyframeControllerHasInterpolationModesPerKey(EffectSlot);
  if (!a3 || a4 == 4)
  {
    v18 = a5 & 0xFFFFFFFE | v12;
    if (!v12)
      return v18;
  }
  else
  {
    UVSet = C3DEffectCommonProfileGetUVSet(a3, a4);
    if (UVSet == -1)
      UVSet = C3DMaterialDefaultUVSetForProperty(a4);
    if (UVSet == -1)
      v16 = 0;
    else
      v16 = v12;
    if (v16 == 1)
    {
      if (C3DMeshGetSourceWithSemanticAtIndex(a2, 3, UVSet, 0))
      {
        v17 = 1;
        goto LABEL_24;
      }
LABEL_21:
      if (UVSet == -1 || (a6 & 1) == 0)
        return a5 & 0xFFC3FFFE | ((UVSet & 0xF) << 18);
      v17 = 0;
LABEL_24:
      v18 = a5 & 0xFFC3FFFE | v17 & 0xFFC3FFFF | ((__UpdateHashCodeUVSetForEffectProperty(a1, UVSet, HasInterpolationModesPerKey, a4) & 0xF) << 18);
      if ((v17 & 1) == 0)
        return v18;
      goto LABEL_25;
    }
    if (UVSet == -1)
      v19 = v12;
    else
      v19 = 0;
    if (v19 != 1)
      goto LABEL_21;
    LODWORD(v18) = a5 | 0x3C0001;
  }
LABEL_25:
  v35 = 0;
  v34 = 0;
  v33 = 1;
  v20 = C3DEffectCommonProfileGetEffectSlot(a3, a4, 0);
  if (!v20 || (C3DEffectSlotGetTextureInfo(v20, &v35, &v34, &v33), (v21 = v35) == 0))
  {
    v21 = 2;
    v35 = 2;
  }
  v22 = v18 & 0xFFFFE81F | (32 * v34) | (v33 << 10);
  if (HasInterpolationModesPerKey)
    v23 = 4096;
  else
    v23 = 0;
  if (v21 >= 7)
  {
    v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      __UpdateHashCodeWithTextureType_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
  }
  return v22 | v23 | (v35 << 6);
}

uint64_t C3DEffectCommonProfileContainsContentForEffectProperty(uint64_t a1, int a2)
{
  uint64_t result;

  result = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (result)
    return C3DEffectSlotHasImageOrTexture(result);
  return result;
}

BOOL C3DKeyframeControllerHasInterpolationModesPerKey(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64) != 0;
}

uint64_t C3DEffectCommonProfileGetUVSet(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t EffectSlot;
  int v13;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (!EffectSlot)
    return -1;
  v13 = *(_DWORD *)(EffectSlot + 76);
  if (v13 == -2)
  {
    if (*(_BYTE *)(EffectSlot + 50) == 4)
      return -1;
    else
      return 0;
  }
  return v13;
}

uint64_t C3DEffectSlotGetTextureInfo(uint64_t a1, int *a2, _BYTE *a3, _BYTE *a4)
{
  void *MTLTexture;
  uint64_t result;
  uint64_t ImageProxy;
  uint64_t v11;
  uint64_t v12;
  const __CFBoolean *Attribute;
  char TextureOptions;
  int v15;
  unsigned int ImageType;
  char v17;

  if (!C3DEffectSlotGetTextureSampler(a1))
    C3DTextureSamplerGetDefault();
  MTLTexture = (void *)C3DEffectSlotGetMTLTexture(a1);
  if (MTLTexture)
  {
    *a2 = SCNMTLTextureToC3DTextureType(MTLTexture);
    result = C3DEffectSlotIsOpaque(a1);
    *a3 = result ^ 1;
    *a4 = 0;
    return result;
  }
  ImageProxy = C3DEffectSlotGetImageProxy(a1);
  if (ImageProxy)
  {
    v11 = ImageProxy;
    *a2 = C3DEngineContextInferTextureTypeForImageTypeAndTextureSampler(1u);
    *a3 = C3DImageProxyIsOpaque(v11) ^ 1;
    result = C3DImageProxyIsPremultiplied(v11);
    *a4 = result;
    return result;
  }
  result = C3DEffectSlotGetImage(a1);
  if (result)
  {
    v12 = result;
    result = C3DImageIsValid(result);
    if ((_DWORD)result)
    {
      Attribute = C3DImageGetAttribute(v12, CFSTR("isAttachment"));
      if (Attribute)
      {
        result = CFBooleanGetValue(Attribute);
        if ((_DWORD)result)
        {
          *a2 = 2;
          *a3 = 1;
          return result;
        }
      }
      TextureOptions = C3DEffectSlotGetTextureOptions(a1);
      if (C3DMetalIsUsed() && (TextureOptions & 2) != 0 && C3DImageIsConvertibleToCubeMap(v12))
      {
        v15 = 4;
      }
      else
      {
        ImageType = C3DImageGetImageType(v12);
        if (ImageType > 7)
        {
LABEL_20:
          result = C3DImageHasAlpha(v12);
          *a3 = result;
          if ((_DWORD)result)
          {
            result = C3DImageNeedsUnpremultiply(v12);
            v17 = result ^ 1;
          }
          else
          {
            v17 = 0;
          }
          *a4 = v17;
          return result;
        }
        v15 = dword_1DD02A0E8[ImageType];
      }
      *a2 = v15;
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t C3DEffectSlotGetTextureOptions(uint64_t a1)
{
  int v1;
  unsigned int v2;
  int v3;
  int v4;

  v1 = *(char *)(a1 + 50);
  v2 = v1 - 24;
  if (v1 == 4)
    v3 = 2;
  else
    v3 = 0;
  if (v1 == 26)
    v4 = 8;
  else
    v4 = v3;
  if (v2 < 2)
    v4 = 6;
  return v4 | ((*(_WORD *)(a1 + 48) & 0x400) == 0);
}

uint64_t C3DImageGetImageType(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 120);
}

uint64_t C3DImageHasAlpha(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v11;
  CFTypeRef v12;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (C3DImageIsCubeMap(a1))
    return 0;
  v11 = *(_BYTE *)(a1 + 116);
  if (*(_DWORD *)(a1 + 96) != 5 && (*(_BYTE *)(a1 + 116) & 4) == 0)
  {
    pthread_mutex_lock(&bitmapAccessSharedMutex);
    if ((*(_BYTE *)(a1 + 80) & 2) != 0 || C3DImageGetTextureRawData(a1))
    {
      if ((*(_BYTE *)(a1 + 116) & 4) == 0)
        *(_BYTE *)(a1 + 116) = *(_BYTE *)(a1 + 116) & 0xFE | *(_BYTE *)(*(_QWORD *)(a1 + 72) + 6) & 1 | 4;
    }
    else
    {
      pthread_mutex_unlock(&bitmapAccessSharedMutex);
      pthread_mutex_lock(&bitmapAccessSharedMutex);
      v12 = C3DImageCopyBitmap(a1, 1);
      if (v12)
        CFRelease(v12);
    }
    pthread_mutex_unlock(&bitmapAccessSharedMutex);
    v11 = *(_BYTE *)(a1 + 116);
  }
  return v11 & 1;
}

BOOL C3DImageIsCubeMap(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(_DWORD *)(a1 + 120) - 3) < 5;
}

uint64_t C3DMetalIsUsed()
{
  return gMetalIsUsed;
}

const __CFDictionary *C3DImageGetAttribute(uint64_t a1, void *key)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return C3DEntityGetAttribute(a1, key);
}

uint64_t C3DPBROpacityIsEnabled()
{
  if (C3DPBROpacityIsEnabled_onceToken != -1)
    dispatch_once(&C3DPBROpacityIsEnabled_onceToken, &__block_literal_global_188_0);
  return C3DPBROpacityIsEnabled_usePBROpacity;
}

void _C3DRendererElementSync(uint64_t a1, char a2)
{
  uint64_t v4;
  unsigned int RenderingOrder;
  __int16 v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t Material;
  const __CFArray *ShaderModifiers;
  __int16 ModifierFlags;
  uint64_t Geometry;
  uint64_t v19;
  const __CFArray *v20;
  uint64_t Mesh;
  uint64_t v22;
  __int16 v23;
  float v24;
  uint64_t v25;
  int IsOpaque;
  __int16 v27;
  uint64_t SharedInstance;
  uint64_t v29;
  uint64_t CommonProfileIfNoTechnique;
  uint64_t v31;
  __int16 v32;
  _WORD *v33;
  __int16 v34;
  __int16 v35;
  uint64_t v36;

  if ((a2 & 4) != 0)
  {
    v4 = *(_QWORD *)(a1 + 8);
    if ((*(_WORD *)(a1 + 72) & 7) == 5)
    {
      RenderingOrder = 0x80000000;
    }
    else if (v4)
    {
      RenderingOrder = C3DNodeGetRenderingOrder(*(_QWORD *)(a1 + 8));
    }
    else
    {
      RenderingOrder = 0;
    }
    *(_DWORD *)(a1 + 64) = RenderingOrder;
    if (v4)
    {
      if (C3DNodeGetCastsShadow(v4))
        v6 = 16;
      else
        v6 = 0;
    }
    else
    {
      v6 = 0;
    }
    *(_WORD *)(a1 + 72) = *(_WORD *)(a1 + 72) & 0xFFEF | v6;
  }
  if ((a2 & 8) != 0)
  {
    if (!a1)
    {
      v7 = scn_default_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
        _C3DRendererElementSync_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    Material = C3DRendererElementGetMaterial(a1);
    if (Material)
    {
      ShaderModifiers = C3DEntityGetShaderModifiers(Material);
      ModifierFlags = _GetModifierFlags(ShaderModifiers);
    }
    else
    {
      ModifierFlags = 0;
    }
    Geometry = C3DRendererElementGetGeometry(a1);
    if (!Geometry
      || (v19 = Geometry,
          v20 = C3DEntityGetShaderModifiers(Geometry),
          ModifierFlags |= _GetModifierFlags(v20),
          C3DGeometryUsesDeformerBasedDynamicMesh(v19))
      || (Mesh = C3DGeometryGetMesh(v19)) == 0
      || (C3DMeshHasNonOpaqueColorSources(Mesh) & 1) == 0)
    {
      if ((ModifierFlags & 1) != 0)
      {
        v23 = *(_WORD *)(a1 + 72);
        goto LABEL_35;
      }
      if ((ModifierFlags & 2) == 0)
      {
        v22 = *(_QWORD *)(a1 + 8);
        if (!v22)
          goto LABEL_29;
        v23 = *(_WORD *)(a1 + 72);
        if ((v23 & 7) == 1)
          goto LABEL_35;
        C3DNodeGetWorldAlpha(v22);
        if (v24 >= 1.0)
        {
LABEL_29:
          v25 = *(_QWORD *)(a1 + 40);
          if (v25)
          {
            IsOpaque = C3DFXTechniqueIsOpaque(v25);
            goto LABEL_31;
          }
          v23 = *(_WORD *)(a1 + 72);
          if ((v23 & 7) != 1)
          {
            v36 = *(_QWORD *)(a1 + 32);
            if (v36)
            {
              IsOpaque = C3DMaterialIsOpaque(v36);
LABEL_31:
              v23 = *(_WORD *)(a1 + 72);
              if (((IsOpaque ^ ((v23 & 8) == 0)) & 1) != 0)
                goto LABEL_40;
              if (!IsOpaque)
              {
LABEL_38:
                v27 = 0;
                goto LABEL_39;
              }
LABEL_36:
              v27 = 8;
LABEL_39:
              *(_WORD *)(a1 + 72) = v23 & 0xFFF7 | v27;
              SharedInstance = C3DNotificationCenterGetSharedInstance();
              C3DNotificationCenterPostNotification(SharedInstance, CFSTR("kC3DNotificationRendererElementWillDie"), (const void *)a1, 0, 1u);
              goto LABEL_40;
            }
          }
LABEL_35:
          if ((v23 & 8) != 0)
            goto LABEL_40;
          goto LABEL_36;
        }
      }
    }
    v23 = *(_WORD *)(a1 + 72);
    if ((v23 & 8) == 0)
      goto LABEL_40;
    goto LABEL_38;
  }
LABEL_40:
  if ((a2 & 0x10) == 0)
    return;
  v29 = *(_QWORD *)(a1 + 32);
  if (!v29)
  {
    v33 = (_WORD *)(a1 + 72);
    v35 = -65;
    goto LABEL_51;
  }
  CommonProfileIfNoTechnique = C3DMaterialGetCommonProfileIfNoTechnique(v29);
  v31 = CommonProfileIfNoTechnique;
  if (CommonProfileIfNoTechnique
    && (C3DEffectCommonProfileGetLightingModel(CommonProfileIfNoTechnique) & 0xFFFFFFFB) != 0)
  {
    v32 = 64;
  }
  else
  {
    v32 = 0;
  }
  if (!v31)
    v32 = 0;
  v34 = *(_WORD *)(a1 + 72);
  v33 = (_WORD *)(a1 + 72);
  *v33 = v34 & 0xFFBF | v32;
  if (!C3DMaterialGetEnableWriteInDepthBuffer(*((_QWORD *)v33 - 5)))
  {
    v35 = -17;
LABEL_51:
    *v33 &= v35;
  }
}

const __CFDictionary *C3DEntityGetShaderModifiers(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return C3DEntityGetAttribute(a1, CFSTR("kShaderModifiers"));
}

const __CFDictionary *C3DEntityGetAttribute(uint64_t a1, void *key)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFDictionary *result;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (key)
      goto LABEL_6;
  }
  else if (key)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DEntityGetAttribute_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  result = *(const __CFDictionary **)(a1 + 40);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, key);
  return result;
}

uint64_t C3DRendererElementGetMaterial(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DRendererElementSync_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 32);
}

void C3DNodeGetWorldAlpha(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(_DWORD *)(a1 + 220);
  if ((v10 & 0x20) != 0)
  {
    *(_DWORD *)(a1 + 256) = *(_DWORD *)(a1 + 204);
    if (*(_QWORD *)(a1 + 64))
    {
      *(float *)(a1 + 256) = C3DNodeGetWorldAlpha() * *(float *)(a1 + 256);
      v10 = *(_DWORD *)(a1 + 220);
    }
    *(_DWORD *)(a1 + 220) = v10 & 0xFFFFFFDF;
  }
}

uint64_t C3DRendererElementGetGeometry(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DRendererElementSync_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_WORD *)(a1 + 72) & 5 | 2) == 3)
    return 0;
  else
    return *(_QWORD *)(a1 + 16);
}

uint64_t _GetModifierFlags(const __CFArray *a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex v4;
  int v5;
  const void *ValueAtIndex;

  if (a1 && (Count = CFArrayGetCount(a1), Count >= 1))
  {
    v3 = Count;
    v4 = 0;
    v5 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v4);
      v5 |= C3DShaderModifierGetFlags((uint64_t)ValueAtIndex);
      ++v4;
    }
    while (v3 != v4);
  }
  else
  {
    LOWORD(v5) = 0;
  }
  return (__int16)v5;
}

uint64_t C3DMeshHasNonOpaqueColorSources(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 200) >> 7;
}

BOOL C3DMaterialGetEnableWriteInDepthBuffer(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_BYTE *)(a1 + 88) != 0;
}

uint64_t C3DEffectCommonProfileIsOpaque(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  float *Color;
  int v13;
  int v14;
  int v15;
  NSObject *v17;
  BOOL v18;
  float *v19;
  _DWORD v20[2];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(unsigned __int16 *)(a1 + 194);
  if ((v10 & 0x80) == 0)
  {
    v11 = *(unsigned __int8 *)(a1 + 180);
    *(_WORD *)(a1 + 194) = v10 | 0x80;
    if (*(float *)(a1 + 164) >= 1.0
      && __imageSlotIsOpaque(a1, 5)
      && __imageSlotIsOpaque(a1, 2))
    {
      Color = (float *)C3DEffectCommonProfileGetColor(a1, 5);
      v13 = *(unsigned __int8 *)(a1 + 180);
      if ((v13 - 2) < 2)
      {
LABEL_11:
        v14 = Color[3] >= 1.0;
LABEL_21:
        if (v14)
          v18 = v11 == 1;
        else
          v18 = 1;
        if (!v18)
        {
          v19 = (float *)C3DEffectCommonProfileGetColor(a1, 2);
          v15 = *(unsigned __int16 *)(a1 + 194);
          if (v19[3] < 1.0)
          {
            v14 = 0;
            goto LABEL_15;
          }
LABEL_30:
          v14 = 256;
          goto LABEL_15;
        }
        v15 = *(unsigned __int16 *)(a1 + 194);
        if (v14)
          goto LABEL_30;
LABEL_15:
        v10 = v15 & 0xFFFFFEFF | v14;
        *(_WORD *)(a1 + 194) = v10;
        return (v10 >> 8) & 1;
      }
      if (v13 != 1)
      {
        if (*(_BYTE *)(a1 + 180))
        {
          v17 = scn_default_log();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            v20[0] = 67109120;
            v20[1] = v13;
            _os_log_impl(&dword_1DCCB8000, v17, OS_LOG_TYPE_DEFAULT, "Warning: __OpacityFromColorSlot:unexpected transparency mode %d", (uint8_t *)v20, 8u);
          }
          v14 = 1;
          goto LABEL_21;
        }
        goto LABEL_11;
      }
      if (*Color <= 0.0 && Color[1] <= 0.0)
      {
        v14 = Color[2] <= 0.0;
        goto LABEL_21;
      }
    }
    v14 = 0;
    v15 = *(unsigned __int16 *)(a1 + 194);
    goto LABEL_15;
  }
  return (v10 >> 8) & 1;
}

uint64_t C3DMaterialGetCommonProfileIfNoTechnique(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(_QWORD *)(a1 + 72))
    return 0;
  else
    return *(_QWORD *)(a1 + 64);
}

uint64_t __imageSlotIsOpaque(uint64_t a1, int a2)
{
  uint64_t EffectSlot;
  uint64_t v5;

  EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  v5 = EffectSlot;
  if (a2 != 5)
  {
LABEL_5:
    if (v5)
      return C3DEffectSlotIsOpaque(v5);
    return 1;
  }
  if (*(_BYTE *)(a1 + 180) == 1)
  {
    if (!C3DEffectCommonProfileGetImageProxy(a1, 5) && !C3DEffectCommonProfileGetImage(a1, 5))
      goto LABEL_5;
    return 0;
  }
  if (EffectSlot)
  {
    if ((*(_WORD *)(EffectSlot + 48) & 0x800) != 0)
      return C3DEffectSlotIsOpaque(v5);
    return 0;
  }
  return 1;
}

uint64_t C3DEffectSlotIsOpaque(uint64_t a1)
{
  uint64_t ImageProxy;
  uint64_t Image;
  int HasAlpha;
  uint64_t Texture;

  ImageProxy = C3DEffectSlotGetImageProxy(a1);
  if (ImageProxy)
    return C3DImageProxyIsOpaque(ImageProxy);
  Image = C3DEffectSlotGetImage(a1);
  if (Image)
  {
    HasAlpha = C3DImageHasAlpha(Image);
    return HasAlpha ^ 1u;
  }
  Texture = C3DEffectSlotGetTexture(a1);
  if (Texture)
  {
    HasAlpha = C3DTextureHasAlpha(Texture);
    return HasAlpha ^ 1u;
  }
  if (C3DEffectSlotGetMTLTexture(a1))
    return HIBYTE(*(unsigned __int16 *)(a1 + 48)) & 1;
  else
    return 1;
}

double C3DNodeGetMatrix@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double result;
  uint64_t v13;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)&result = C3DTransformGetMatrix(a1 + 96, a2).n128_u64[0];
  v13 = *(_QWORD *)(a1 + 192);
  if (v13)
  {
    if (*(float *)(v13 + 124) == 0.0)
    {
      C3DMatrix4x4Invert((simd_float4x4 *)v13, (simd_float4x4 *)(v13 + 64));
      v13 = *(_QWORD *)(a1 + 192);
    }
    return C3DMatrix4x4Mult(v13 + 64, (float32x4_t *)a2, (_OWORD *)a2);
  }
  return result;
}

__n128 C3DTransformGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v4;
  __n128 result;
  __int128 v6;

  if ((*(_BYTE *)(a1 + 92) & 8) == 0)
    _updateMatrix((float32x4_t *)a1);
  v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  result = *(__n128 *)(a1 + 32);
  v6 = *(_OWORD *)(a1 + 48);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v6;
  return result;
}

const __CFDictionary *C3DNodeGetRenderingOrder(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFDictionary *result;
  uint64_t valuePtr;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = C3DEntityGetAttribute(a1, CFSTR("kRenderingPriorityKey"));
  if (result)
  {
    valuePtr = 0;
    CFNumberGetValue(result, kCFNumberLongType, &valuePtr);
    return (const __CFDictionary *)valuePtr;
  }
  return result;
}

float C3DNodeGetOpacity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 204);
}

uint64_t __C3DCullingSystem::_updateNodeMasksAtIndex(uint64_t this, unsigned int a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t CategoryBitMask;
  uint64_t v7;
  __int16 v8;
  __int16 v9;
  __int16 v10;
  __int16 v11;

  if (*(_DWORD *)(this + 16) > a2)
  {
    v2 = (_QWORD *)this;
    v3 = *(_QWORD *)(this + 104);
    v4 = *(_QWORD *)(v3 + 8 * a2);
    if (v4)
    {
      v5 = a2;
      CategoryBitMask = C3DNodeGetCategoryBitMask(*(_QWORD *)(v3 + 8 * a2));
      v7 = v2[10];
      *(_DWORD *)(v2[9] + 4 * v5) = CategoryBitMask;
      *(_DWORD *)(v7 + 4 * v5) = HIDWORD(CategoryBitMask);
      C3DNodeIsHiddenOrTransparentOrIsHiddenOrTransparentByAncestor(v4);
      v9 = v8;
      if (C3DNodeGetMovability(v4))
        v10 = 4;
      else
        v10 = 2;
      v11 = v10 | v9;
      if (C3DNodeGetCastsShadow(v4))
        v11 |= 8u;
      if (C3DNodeIsLighted(v4))
        v11 |= 0x20u;
      if ((C3DNodeIsAlwaysRendered(v4) & 1) != 0 || (*(_BYTE *)(v4 + 221) & 0x20) != 0)
        v11 |= 0x10u;
      this = C3DNodeGetLayerIndex(v4);
      *(_WORD *)(v2[11] + 2 * v5) = (256 << this) | v11;
    }
  }
  return this;
}

uint64_t C3DNodeGetCategoryBitMask(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 208);
}

uint64_t C3DNodeGetCastsShadow(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(unsigned __int8 *)(a1 + 222) >> 5) & 1;
}

uint64_t C3DNodeGetMovability(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(_DWORD *)(a1 + 220) >> 22) & 1;
}

uint64_t C3DNodeGetLayerIndex(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 220) >> 23) & 7;
}

uint64_t C3DNodeIsLighted(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 240);
  if (result)
  {
    result = (uint64_t)C3DGeometryGetMaterialAtIndex(result, 0);
    if (result)
    {
      result = C3DMaterialGetCommonProfile(result);
      if (result)
        return (C3DEffectCommonProfileGetLightingModel(result) & 0xFFFFFFFB) != 0;
    }
  }
  return result;
}

uint64_t C3DEffectCommonProfileGetLightingModel(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 24);
}

float C3DNodeIsHiddenOrTransparentOrIsHiddenOrTransparentByAncestor(uint64_t a1)
{
  uint64_t v1;
  float result;

  v1 = a1;
  if (!C3DNodeIsHiddenOrTransparent(a1))
  {
    do
    {
      v1 = *(_QWORD *)(v1 + 64);
      if (!v1)
        break;
      if (*(_BYTE *)(v1 + 200))
        break;
      result = *(float *)(v1 + 204);
    }
    while (result > 0.0);
  }
  return result;
}

BOOL C3DNodeIsHiddenOrTransparent(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_BYTE *)(a1 + 200) || *(float *)(a1 + 204) <= 0.0;
}

uint64_t C3DNodeIsAlwaysRendered(uint64_t a1)
{
  unsigned int v1;
  const __CFDictionary *RendererDelegate;
  uint64_t v4;
  int v5;

  v1 = *(_DWORD *)(a1 + 220);
  if ((v1 & 2) != 0)
  {
    if ((v1 & 4) != 0)
    {
      v5 = 0;
    }
    else
    {
      RendererDelegate = C3DNodeGetRendererDelegate(a1);
      v4 = *(_QWORD *)(a1 + 240);
      if (v4)
        LODWORD(v4) = C3DGeometryIsAlwaysRendered(v4);
      if (RendererDelegate)
        v5 = 1;
      else
        v5 = v4;
      v1 = *(_DWORD *)(a1 + 220);
    }
    v1 = v1 & 0xFFFFFFFC | v5;
    *(_DWORD *)(a1 + 220) = v1;
  }
  return v1 & 1;
}

uint64_t C3DNodeIsJoint(uint64_t a1)
{
  return *(_BYTE *)(a1 + 221) & 1;
}

BOOL C3DNodeGetHasPivot(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 192) != 0;
}

uint64_t C3DEnginePipelineAddNodeToRendering(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;

  result = C3DNodeIsHiddenOrIsHiddenByAncestor((uint64_t)a3);
  if ((result & 1) == 0 && !a3[57])
  {
    result = C3DNodeGetRenderableAttributeHash((uint64_t)a3);
    if ((_DWORD)result)
    {
      _C3DEnginePipelineAllocateAndTrackRendererElements(a1, a2, (uint64_t)a3, result);
      return __TrackRenderNodeDependencies(a1, a3);
    }
  }
  return result;
}

uint64_t C3DNodeIsHiddenOrIsHiddenByAncestor(uint64_t a1)
{
  uint64_t v1;
  _BOOL8 v2;

  v1 = a1;
  if ((C3DNodeIsHidden(a1) & 1) != 0)
    return 1;
  do
  {
    v1 = *(_QWORD *)(v1 + 64);
    v2 = v1 != 0;
  }
  while (v1 && !C3DNodeIsHidden(v1));
  return v2;
}

uint64_t C3DNodeIsHidden(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 200);
}

uint64_t C3DNodeGetRenderableAttributeHash(uint64_t a1)
{
  unsigned int v2;
  const __CFDictionary *Light;

  if (C3DNodeGetRendererDelegate(a1))
  {
    v2 = 2;
  }
  else if (C3DNodeGetFilters(a1))
  {
    v2 = 8;
  }
  else
  {
    v2 = C3DNodeGetGeometry(a1) != 0;
  }
  Light = C3DNodeGetLight(a1);
  if (Light && C3DLightGetType((uint64_t)Light) == 6)
    v2 |= 0x10u;
  if (C3DNodeGetUsesDepthPrePass(a1))
    return v2 | 0x20;
  else
    return v2;
}

const __CFDictionary *C3DNodeGetRendererDelegate(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 221) & 0x20) != 0)
    return C3DEntityGetAttribute(a1, CFSTR("rendererDelegate"));
  else
    return 0;
}

__C3DMesh *_C3DNodeGetMeshToRender(uint64_t a1, __C3DGeometry *a2)
{
  if ((__C3DGeometry *)C3DNodeGetGeometry(a1) == a2)
    return C3DNodeGetPresentationMesh(a1);
  else
    return C3DGeometryGetRenderingMesh(a2);
}

uint64_t C3DNodeGetGeometry(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 240);
}

uint64_t C3DNodeGetUsesDepthPrePass(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(unsigned __int8 *)(a1 + 223) >> 2) & 1;
}

const __CFDictionary *C3DNodeGetFilters(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFDictionary *result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 221) & 0x40) == 0)
    return 0;
  result = C3DEntityGetAttribute(a1, CFSTR("kFilterKey"));
  if (result)
    return (const __CFDictionary *)C3DModelTargetGetTarget((uint64_t)result);
  return result;
}

uint64_t C3DEntityGetName(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 32);
}

void C3DNodeBoundingBoxDidUpdate(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *CullingSystem;
  __int128 v12;
  _OWORD v13[2];

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 220) & 4) == 0)
    __C3DComputeLocalBoundingBox(a1);
  if (*(_DWORD *)(a1 + 216) != -1)
  {
    v10 = *(_QWORD *)(a1 + 48);
    if (v10)
    {
      CullingSystem = (_QWORD *)C3DSceneGetCullingSystem(v10);
      v12 = *(_OWORD *)(a1 + 288);
      v13[0] = *(_OWORD *)(a1 + 272);
      v13[1] = v12;
      if ((vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(a1 + 288))) & 0x80000000) != 0)
        C3DCullingSystemUpdateBoundingBox(CullingSystem, *(_DWORD *)(a1 + 216), v13);
    }
  }
}

__n128 __C3DComputeLocalBoundingBox(uint64_t a1)
{
  uint64_t DeformerStack;
  __n128 result;
  const void *Geometry;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;

  *(_OWORD *)(a1 + 272) = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 48);
  *(_OWORD *)(a1 + 288) = xmmword_1DD0076D0;
  DeformerStack = C3DNodeGetDeformerStack(a1);
  if (!DeformerStack || !C3DDeformerStackGetLocalBoundingBox(DeformerStack, a1 + 272))
  {
    Geometry = (const void *)C3DNodeGetGeometry(a1);
    if (Geometry)
    {
      v8 = 0uLL;
      v7 = 0uLL;
      if (C3DGetBoundingBox(Geometry, 0, (uint64_t)&v8, (uint64_t)&v7))
      {
        v5.i64[0] = 0x3F0000003F000000;
        v5.i64[1] = 0x3F0000003F000000;
        v6 = vmulq_f32(vaddq_f32(v8, v7), v5);
        result = (__n128)vmulq_f32(vsubq_f32(v7, v8), v5);
        v6.i32[3] = 1.0;
        result.n128_u32[3] = 0;
        *(float32x4_t *)(a1 + 272) = v6;
        *(__n128 *)(a1 + 288) = result;
      }
    }
  }
  return result;
}

uint64_t C3DNodeGetDeformerStack(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 248);
}

uint64_t C3DGetBoundingBox(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *ClassWithTypeID;
  uint64_t (*v17)(CFTypeRef, uint64_t, uint64_t, uint64_t);

  if (!cf)
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (_QWORD *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696
    && (v17 = (uint64_t (*)(CFTypeRef, uint64_t, uint64_t, uint64_t))ClassWithTypeID[15]) != 0)
  {
    return v17(cf, a2, a3, a4);
  }
  else
  {
    return 0;
  }
}

uint64_t _C3DGeometryGetBoundingBox(uint64_t a1, uint64_t a2, _OWORD *a3, _OWORD *a4)
{
  float32x4_t *v6;
  uint64_t result;

  v6 = *(float32x4_t **)(a1 + 104);
  if (v6)
  {
    *a3 = vsubq_f32(*v6, v6[1]);
    *a4 = vaddq_f32(*(float32x4_t *)*(_QWORD *)(a1 + 104), *(float32x4_t *)(*(_QWORD *)(a1 + 104) + 16));
    return 1;
  }
  else
  {
    result = C3DGeometryGetMesh(a1);
    if (result)
      return C3DMeshGetBoundingBox(result, a3, a4);
  }
  return result;
}

uint64_t C3DGeometryGetMesh(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (**v10)(uint64_t);

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(void (***)(uint64_t))(a1 + 120);
  if (v10)
    (*v10)(a1);
  return *(_QWORD *)(a1 + 64);
}

uint64_t C3DMeshGetBoundingBox(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD *v14;
  const void *SourceWithSemanticAtIndex;
  uint64_t Content;
  uint64_t v17;
  float32x4_t v18;
  uint64_t v19;
  uint64_t v20;
  float32x4_t v21;
  uint64_t v22;
  float32x4_t v23;
  uint64_t v24;
  float32x4_t v25;
  unsigned int v26;
  int v27;
  int v28;
  _OWORD *v29;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  v14 = *(_OWORD **)(a1 + 192);
  if (!v14)
  {
    SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, 0);
    v33 = 0u;
    if (SourceWithSemanticAtIndex
      && (Content = C3DMeshSourceGetContent((uint64_t)SourceWithSemanticAtIndex), v19 = v17, (_DWORD)v17))
    {
      v20 = Content;
      v21 = 0uLL;
      if (Content)
      {
        if ((v17 & 0xFF000000000000) == 0x1000000000000)
        {
          v22 = 0;
          v23 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
          v21.i64[0] = 0x80000000800000;
          v21.i64[1] = 0x80000000800000;
          do
          {
            v24 = Content + v22;
            v25.i64[0] = *(_QWORD *)v24;
            v25.i64[1] = *(unsigned int *)(v24 + 8);
            v23 = vminnmq_f32(v23, v25);
            v21 = vmaxnmq_f32(v21, v25);
            v22 += BYTE5(v17);
            --v19;
          }
          while (v19);
        }
        else
        {
          v26 = 0;
          v27 = BYTE4(v17);
          v23 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
          v28 = BYTE5(v17);
          v21.i64[0] = 0x80000000800000;
          v21.i64[1] = 0x80000000800000;
          do
          {
            v31 = v21;
            v34 = v23;
            *(double *)v18.i64 = C3DConvertFloatingTypeToFloat4(v27, (float *)(v20 + v26), v18, v23.f32[0], v21.f32[0]);
            v23 = vminnmq_f32(v34, v18);
            v21 = vmaxnmq_f32(v31, v18);
            v26 += v28;
            --v19;
          }
          while (v19);
        }
        v33 = v23;
      }
    }
    else
    {
      v21 = 0uLL;
    }
    v32 = v21;
    v29 = C3DMalloc(0x20uLL);
    *(_QWORD *)(a1 + 192) = v29;
    *v29 = v33;
    *(float32x4_t *)(*(_QWORD *)(a1 + 192) + 16) = v32;
    v14 = *(_OWORD **)(a1 + 192);
  }
  *a2 = *v14;
  *a3 = *(_OWORD *)(*(_QWORD *)(a1 + 192) + 16);
  return 1;
}

void *C3DMalloc(size_t a1)
{
  return malloc_type_malloc(a1, 0xDC03DFB5uLL);
}

uint64_t C3DMaterialIsOpaque(uint64_t a1)
{
  uint64_t Technique;
  uint64_t CommonProfile;

  Technique = C3DMaterialGetTechnique(a1);
  if (Technique)
    return C3DFXTechniqueIsOpaque(Technique);
  if (*(_BYTE *)(a1 + 92) == 5)
    return 1;
  if (*(_BYTE *)(a1 + 92))
    return 0;
  CommonProfile = C3DMaterialGetCommonProfile(a1);
  return C3DEffectCommonProfileIsOpaque(CommonProfile);
}

float C3DSceneGetFogEndDistance(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 332);
}

void _C3DEnginePipelineAllocateAndTrackRendererElements(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  unint64_t SpanForNode;
  unint64_t v7;
  unint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void *ElementInSpanAtIndex;
  uint64_t Geometry;
  const __CFArray *LOD;
  CFIndex Count;
  CFIndex v22;
  uint64_t i;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  const void *v28;

  SpanForNode = C3DRendererElementStoreAllocateSpanForNode(a1, a2, a3, a4);
  if (SpanForNode != 0xFFFFFFFF)
  {
    v7 = SpanForNode;
    v8 = HIDWORD(SpanForNode);
    if (HIDWORD(SpanForNode))
    {
      v17 = 0;
      *(_QWORD *)(a3 + 224) = SpanForNode;
      do
      {
        ElementInSpanAtIndex = (const void *)C3DRendererElementStoreGetElementInSpanAtIndex(*(_QWORD *)(a1 + 48), *(_QWORD *)(a3 + 224), v17);
        __TrackRendererElementsDependencies(a1, ElementInSpanAtIndex);
        ++v17;
      }
      while (v8 != v17);
    }
    else
    {
      v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
        _C3DEnginePipelineAllocateAndTrackRendererElements_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
      *(_QWORD *)(a3 + 224) = v7;
    }
    if ((C3DNodeHasGeometryLOD(a3) & 1) != 0)
    {
      Geometry = C3DNodeGetGeometry(a3);
      if (Geometry)
      {
        LOD = (const __CFArray *)C3DGeometryGetLOD(Geometry);
        Count = CFArrayGetCount(LOD);
        if (Count >= 1)
        {
          v22 = Count;
          for (i = 0; i != v22; ++i)
          {
            v24 = *(_QWORD *)(a3 + 232) + 12 * i;
            v25 = *(unsigned int *)(v24 + 16);
            if ((_DWORD)v25)
            {
              v26 = 0;
              v27 = *(unsigned int *)(v24 + 12) | (unint64_t)(v25 << 32);
              do
              {
                v28 = (const void *)C3DRendererElementStoreGetElementInSpanAtIndex(*(_QWORD *)(a1 + 48), v27, v26);
                if (v28)
                  __TrackRendererElementsDependencies(a1, v28);
                ++v26;
              }
              while (v25 != v26);
            }
          }
        }
      }
    }
  }
}

void __TrackRendererElementsDependencies(uint64_t a1, const void *a2)
{
  const void *Material;
  const void *v5;
  void *Value;

  Material = (const void *)C3DRendererElementGetMaterial((uint64_t)a2);
  if (Material)
  {
    v5 = Material;
    Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), Material);
    if (!Value)
    {
      Value = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v5, Value);
      CFRelease(Value);
    }
    CFSetAddValue((CFMutableSetRef)Value, a2);
  }
}

uint64_t C3DRendererElementStoreGetElementInSpanAtIndex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unsigned int v4;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v4 = a2;
  v6 = HIDWORD(a2);
  if (!a1)
  {
    v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      C3DRendererElementStoreDeallocateSpanForNode_cold_2(v7, v8, v9, v10, v11, v12, v13, v14);
  }
  if (v6 <= a3)
  {
    v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      C3DRendererElementStoreGetElementInSpanAtIndex_cold_1(v15, v16, v17, v18, v19, v20, v21, v22);
  }
  return C3DSpanAllocatorGetElementInSpanAtIndex(*(_QWORD *)(a1 + 16), v4, a3);
}

const __CFDictionary *C3DNodeGetLightmapInfo(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 221) & 8) != 0)
    return C3DEntityGetAttribute(a1, CFSTR("kLightmapInfoKey"));
  else
    return 0;
}

BOOL C3DMeshContainsSourcesWithSemantic(uint64_t a1, int a2)
{
  return *(_BYTE *)(a1 + 2 * a2 + 73) != 0;
}

uint64_t C3DMaterialGetBlendStatesUseConstantAlpha(uint64_t a1, char a2)
{
  int v3;
  uint64_t result;
  int v5;

  v3 = *(unsigned __int8 *)(a1 + 92);
  result = *(_BYTE *)(a1 + 92) == 0;
  if (!v3 && (a2 & 1) == 0)
  {
    v5 = 1065353216;
    return C3DEffectCommonProfileHasConstantAlpha(*(float **)(a1 + 64), (float *)&v5);
  }
  return result;
}

uint64_t C3DGeometryIsDynamicBatchingEnabled(uint64_t a1)
{
  return *(_BYTE *)(a1 + 112) & 1;
}

uint64_t C3DEffectCommonProfileGetEnableNormals(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(unsigned __int16 *)(a1 + 194) >> 2) & 1;
}

void C3DCullingSystemUpdateBoundingBox(_QWORD *a1, unsigned int a2, _OWORD *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  _OWORD *v17;
  float32x4_t *WorldMatrix;
  float32x4_t v19;
  float32x4_t v20;
  __n128 v21;
  float32x4_t v22;
  __n128 v23;
  NSObject *v24;
  float32x4_t v25;
  int32x4_t v26;

  if (!a1 && (v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DCullingSystemAdd_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if ((a2 & 0x80000000) != 0)
      goto LABEL_10;
  }
  else if ((a2 & 0x80000000) != 0)
  {
    goto LABEL_10;
  }
  v14 = a1[4];
  if (a2 < (unint64_t)((a1[5] - v14) >> 2))
  {
    v15 = *(unsigned int *)(v14 + 4 * a2);
    v16 = a3[1];
    v17 = (_OWORD *)(a1[8] + 32 * v15);
    *v17 = *a3;
    v17[1] = v16;
    if ((*(_WORD *)(a1[11] + 2 * v15) & 0x10) != 0)
    {
      v23 = (__n128)xmmword_1DD007E60;
      v21 = *(__n128 *)(MEMORY[0x1E0C83FF0] + 48);
    }
    else
    {
      v25 = *(float32x4_t *)a3;
      v26 = *((int32x4_t *)a3 + 1);
      WorldMatrix = C3DNodeGetWorldMatrix(*(float32x4_t **)(a1[13] + 8 * v15));
      v19 = WorldMatrix[1];
      v20 = WorldMatrix[2];
      v21 = (__n128)vaddq_f32(WorldMatrix[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v19, *(float32x2_t *)v25.f32, 1), *WorldMatrix, v25.f32[0]), v20, v25, 2));
      v21.n128_u32[3] = 1.0;
      v22 = (float32x4_t)v26;
      v22.i32[1] = v26.i32[0];
      v22.i32[2] = v26.i32[0];
      v23 = (__n128)vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(v22, *WorldMatrix)), vabsq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v26.i8, 1), v26), v19))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32(v26, v26), v26), v20)));
    }
    __C3DCullingSystem::_setWorldAABBAtIndex((uint64_t)a1, v15, v21, v23);
    return;
  }
LABEL_10:
  v24 = scn_default_log();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    C3DCullingSystemUpdateBoundingBox_cold_1(a2, v24);
}

uint64_t C3DMeshGetSourcesCountForSemantic(uint64_t a1, int a2)
{
  return *(unsigned __int8 *)(a1 + 2 * a2 + 73);
}

uint64_t C3DEffectCommonProfileHasConstantAlpha(float *a1, float *a2)
{
  uint64_t result;
  int v5;
  char v6;
  float FloatProperty;
  float v8;
  float *Color;

  if ((C3DEffectCommonProfileContainsContentForEffectProperty((uint64_t)a1, 5) & 1) != 0)
    return 0;
  v5 = C3DEffectCommonProfileContainsContentForEffectProperty((uint64_t)a1, 2);
  v6 = v5;
  if (!v5 || (result = __imageSlotIsOpaque((uint64_t)a1, 2), (_DWORD)result))
  {
    FloatProperty = C3DEffectCommonProfileGetFloatProperty(a1, 18);
    v8 = FloatProperty * *((float *)C3DEffectCommonProfileGetColor((uint64_t)a1, 5) + 3);
    Color = (float *)C3DEffectCommonProfileGetColor((uint64_t)a1, 2);
    if ((v6 & 1) == 0)
      v8 = v8 * Color[3];
    *a2 = v8;
    return 1;
  }
  return result;
}

float32x4_t _updateMatrix(float32x4_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float v22;
  __float2 v23;
  float32x2_t v24;
  float32x2_t v25;
  float v26;
  float v27;
  __float2 v28;
  __float2 v29;
  __float2 v30;
  float32x4_t result;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float v42;
  float32x4_t v43;

  if ((a1[5].i8[12] & 4) == 0)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _updateMatrix_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((a1[5].i8[12] & 8) != 0)
  {
    v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      _updateMatrix_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
  }
  v18 = (float32x4_t *)MEMORY[0x1E0C83FF0];
  if ((a1[5].i32[3] & 3) == 2)
  {
    v20 = a1[4];
    v21 = vmulq_f32(v20, v20);
    v22 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0];
    if (v22 <= 0.000000001)
    {
      v19 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 48);
    }
    else
    {
      v42 = v22;
      v43 = a1[4];
      v23 = __sincosf_stret(vmuls_lane_f32(0.5, v20, 3));
      v24 = vrsqrte_f32((float32x2_t)LODWORD(v42));
      v25 = vmul_f32(v24, vrsqrts_f32((float32x2_t)LODWORD(v42), vmul_f32(v24, v24)));
      v19 = vmulq_n_f32(vmulq_n_f32(v43, vmul_f32(v25, vrsqrts_f32((float32x2_t)LODWORD(v42), vmul_f32(v25, v25))).f32[0]), v23.__sinval);
      v19.i32[3] = LODWORD(v23.__cosval);
    }
  }
  else if ((a1[5].i32[3] & 3) != 0)
  {
    v26 = a1[4].f32[1];
    v27 = a1[4].f32[2];
    v28 = __sincosf_stret(a1[4].f32[0] * 0.5);
    v29 = __sincosf_stret(v26 * 0.5);
    v30 = __sincosf_stret(v27 * 0.5);
    v19.f32[0] = (float)(v28.__sinval * (float)(v29.__cosval * v30.__cosval))
               - (float)(v28.__cosval * (float)(v29.__sinval * v30.__sinval));
    v19.f32[1] = (float)(v30.__sinval * (float)(v28.__sinval * v29.__cosval))
               + (float)((float)(v28.__cosval * v29.__sinval) * v30.__cosval);
    v19.f32[2] = (float)(v30.__cosval * (float)-(float)(v28.__sinval * v29.__sinval))
               + (float)((float)(v28.__cosval * v29.__cosval) * v30.__sinval);
    v19.f32[3] = (float)(v28.__sinval * (float)(v29.__sinval * v30.__sinval))
               + (float)(v28.__cosval * (float)(v29.__cosval * v30.__cosval));
  }
  else
  {
    v19 = a1[4];
  }
  result = a1[5];
  v32 = *v18;
  v33 = v18[1];
  v34 = vmulq_f32(v19, v19);
  v35 = vaddq_f32(v34, v34);
  v36 = vmulq_laneq_f32(v19, v19, 3);
  v37 = vmulq_lane_f32(v19, *(float32x2_t *)v19.f32, 1).f32[0];
  v32.f32[0] = (float)(1.0 - v35.f32[1]) - v35.f32[2];
  v32.f32[1] = (float)(v37 + v36.f32[2]) + (float)(v37 + v36.f32[2]);
  v33.f32[0] = (float)(v37 - v36.f32[2]) + (float)(v37 - v36.f32[2]);
  v35.f32[0] = 1.0 - v35.f32[0];
  v33.f32[1] = v35.f32[0] - v35.f32[2];
  v38 = vmul_laneq_f32(*(float32x2_t *)v19.f32, v19, 2);
  v32.f32[2] = (float)(v38.f32[0] - v36.f32[1]) + (float)(v38.f32[0] - v36.f32[1]);
  v33.f32[2] = (float)(v38.f32[1] + v36.f32[0]) + (float)(v38.f32[1] + v36.f32[0]);
  *(int32x2_t *)v36.f32 = vrev64_s32(*(int32x2_t *)v36.f32);
  v39.i32[0] = vadd_f32(v38, *(float32x2_t *)v36.f32).u32[0];
  v39.i32[1] = vsub_f32(v38, *(float32x2_t *)&v36).i32[1];
  *(float32x2_t *)v40.f32 = vadd_f32(v39, v39);
  v40.i32[3] = HIDWORD(v18[2].i64[1]);
  v40.f32[2] = v35.f32[0] - v35.f32[1];
  v41 = vaddq_f32(a1[3], v18[3]);
  v41.i32[3] = HIDWORD(*(_OWORD *)&v18[3]);
  *a1 = vmulq_n_f32(v32, result.f32[0]);
  a1[1] = vmulq_lane_f32(v33, *(float32x2_t *)result.f32, 1);
  a1[2] = vmulq_laneq_f32(v40, result, 2);
  a1[3] = v41;
  a1[5].i32[3] = result.i32[3] | 8;
  return result;
}

const __CFDictionary *C3DEntityGetShadableMinimumMTLLanguageVersion(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return C3DEntityGetAttribute(a1, CFSTR("kShadableMinimumMTLLanguageVersionKey"));
}

BOOL _C3DRasterizerStatesCFEqual(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16)
      && *(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24)
      && *(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32)
      && *(_DWORD *)(a1 + 40) == (unint64_t)*(unsigned int *)(a2 + 40);
}

void __removeMatchingProgram(const void *value, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  __CFArray *Mutable;

  if (!*a3 || a2[2] == *a3)
  {
    v5 = a3[1];
    if (!v5 || a2[3] == v5)
    {
      Mutable = (__CFArray *)a3[2];
      if (!Mutable)
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
        a3[2] = Mutable;
      }
      CFArrayAppendValue(Mutable, value);
    }
  }
}

void _C3DModelTargetCFFinalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

__n128 C3DRasterizerStatesGetDesc@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRasterizerStatesGetDesc_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 16);
  result = *(__n128 *)(a1 + 28);
  *(__n128 *)(a2 + 12) = result;
  return result;
}

uint64_t C3DComparisonFuncToMTLCompareFunctionReverse(unsigned int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 8)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DComparisonFuncToMTLCompareFunction_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return mtl_ComparisonFuncReverse[a1];
}

void sub_1DCCC7424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void C3DMeshApplySources(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void *ValueAtIndex;

  if (a2 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    v5 = a1 + 112;
  }
  else if (a2)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      C3DMeshApplySources_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    v5 = 0;
  }
  else
  {
    v5 = a1 + 64;
  }
  for (i = 0; i != 9; ++i)
  {
    v15 = v5 + 2 * i;
    v18 = *(char *)(v15 + 8);
    v16 = v15 + 8;
    v17 = v18;
    if (v18 != -1)
    {
      v19 = *(unsigned __int8 *)(v16 + 1);
      if (*(_BYTE *)(v16 + 1))
      {
        v20 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)v5, v17 + v20);
          (*(void (**)(uint64_t, const void *, _QWORD, uint64_t, _QWORD))(a3 + 16))(a3, ValueAtIndex, (char)i, v20, *(unsigned __int8 *)(v17 + v20 + *(_QWORD *)(v5 + 40)));
          ++v20;
        }
        while (v19 != v20);
      }
    }
  }
}

uint64_t C3DGenericSourceIsMutable(uint64_t a1)
{
  return *(_BYTE *)(a1 + 88) & 1;
}

const void *C3DMeshGetElementAtIndex(uint64_t a1, CFIndex idx, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFArray *v22;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  if (!*(_QWORD *)(a1 + 96))
  {
    v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      C3DMeshGetElementAtIndex_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
  if (a3 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    v22 = *(const __CFArray **)(a1 + 144);
    return CFArrayGetValueAtIndex(v22, idx);
  }
  if (!a3)
  {
    v22 = *(const __CFArray **)(a1 + 96);
    return CFArrayGetValueAtIndex(v22, idx);
  }
  v24 = scn_default_log();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    C3DMeshGetElementAtIndex_cold_1(v24, v25, v26, v27, v28, v29, v30, v31);
  return 0;
}

const void *C3DMeshGetSourceWithSemanticAtIndex(uint64_t a1, int a2, uint64_t a3, int a4)
{
  CFArrayRef *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFIndex v17;

  if (a4 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    v8 = (CFArrayRef *)(a1 + 112);
  }
  else if (a4)
  {
    v9 = scn_default_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      C3DMeshApplySources_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
    v8 = 0;
  }
  else
  {
    v8 = (CFArrayRef *)(a1 + 64);
  }
  v17 = __indexOfSourceWithSemanticAtIndex(a1, a2, a3, a4);
  if (v17 == -1)
    return 0;
  else
    return CFArrayGetValueAtIndex(*v8, v17);
}

void C3DMeshBuildRenderableData(uint64_t a1, char a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  const void *v13;
  __CFArray *v14;
  __CFArray *v15;
  CFIndex Count;
  CFIndex v17;
  CFIndex v18;
  const void *ValueAtIndex;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __CFArray *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  CFMutableArrayRef Mutable;
  const __CFArray *v37;
  CFIndex v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  unint64_t v41;
  unint64_t Length;
  const UInt8 *BytePtr;
  unsigned int v44;
  const unsigned __int8 *v45;
  uint64_t v46;
  int v47;
  int v48;
  unsigned int IndexInBuffer;
  int v50;
  CFIndex v51;
  CFDataRef v52;
  _OWORD *v53;
  CFDataRef v54;
  unsigned __int8 *v55;
  int v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  unsigned int v61;
  NSObject *v62;
  int v63;
  int v64;
  unsigned __int8 *v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  unsigned int *v70;
  uint64_t v71;
  _DWORD *v72;
  void *v73;
  unsigned int v74;
  unint64_t v75;
  NSObject *v76;
  CFDataRef v77;
  uint64_t ElementAtIndex;
  NSObject *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unsigned int *v87;
  unsigned int *v88;
  NSObject *v89;
  uint64_t v90;
  NSObject *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  NSObject *v99;
  unsigned int v100;
  const __CFAllocator *bytesDeallocator;
  uint64_t v102;
  unsigned int v103;
  unsigned int v104;
  uint64_t v105;
  unsigned int v106;
  unsigned int v107;
  uint64_t v108;
  const __CFAllocator *allocator;
  unsigned __int8 *v110;
  uint64_t v111;
  unsigned int v112;
  char v113;
  int v114;
  int v115;
  int v116;
  __CFArray *theArray;
  int v118;
  int v119;
  _DWORD *v120;
  unsigned int v121;
  int v122;
  int v123;
  int v124;
  CFIndex idx;
  unsigned int *v126;
  unsigned int v127;
  unsigned int *v128;
  __CFArray *v129;
  __CFArray *v130;
  uint8_t v131;
  char v132[15];
  uint8_t buf[4];
  int v134;
  __int16 v135;
  unsigned int v136;
  __int16 v137;
  int v138;
  __int16 v139;
  unsigned int v140;
  __int16 v141;
  int v142;
  uint64_t v143;

  v3 = a1;
  v143 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = *(const void **)(v3 + 112);
  if (v12)
  {
    if (*(_QWORD *)(v3 + 144))
      return;
    CFRelease(v12);
    *(_QWORD *)(v3 + 112) = 0;
  }
  v113 = a2;
  v13 = *(const void **)(v3 + 144);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(v3 + 144) = 0;
  }
  free(*(void **)(v3 + 168));
  *(_QWORD *)(v3 + 168) = 0;
  *(_DWORD *)(v3 + 160) = 0;
  free(*(void **)(v3 + 176));
  *(_QWORD *)(v3 + 176) = 0;
  v129 = 0;
  v130 = 0;
  v128 = 0;
  v127 = 0;
  v126 = 0;
  __C3DMeshDeindex((CFArrayRef *)v3, &v130, &v129, &v128, &v127, &v126);
  v14 = v130;
  if (v130)
  {
    v15 = v129;
    if (!v129)
    {
      v28 = scn_default_log();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        C3DMeshBuildRenderableData_cold_1(v3, v28, v29, v30, v31, v32, v33, v34);
      v27 = v14;
      goto LABEL_83;
    }
    Count = CFArrayGetCount(v130);
    if (Count < 1)
    {
LABEL_15:
      v111 = 0;
    }
    else
    {
      v17 = Count;
      v18 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v14, v18);
        if (!C3DMeshSourceGetSemantic((uint64_t)ValueAtIndex))
          break;
        if (v17 == ++v18)
          goto LABEL_15;
      }
      v111 = (uint64_t)ValueAtIndex;
    }
    v35 = CFArrayGetCount(v15);
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v35, MEMORY[0x1E0C9B378]);
    v37 = Mutable;
    if (v35 < 1)
    {
LABEL_72:
      CFRelease(v15);
      if (v35 != CFArrayGetCount(v37))
      {
        v79 = scn_default_log();
        if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT))
          C3DMeshBuildRenderableData_cold_4(v79, v80, v81, v82, v83, v84, v85, v86);
      }
      *(_QWORD *)(v3 + 112) = v130;
      *(_QWORD *)(v3 + 144) = v37;
      v87 = v128;
      *(_DWORD *)(v3 + 160) = v127;
      v88 = v126;
      *(_QWORD *)(v3 + 168) = v87;
      *(_QWORD *)(v3 + 176) = v88;
      __BuildRenderableSourceChannelsAndSemanticInfos(v3);
      if ((v113 & 1) == 0)
        __DropOriginalTopology(v3);
      return;
    }
    v38 = 0;
    bytesDeallocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE10];
    theArray = Mutable;
    v105 = v35;
LABEL_26:
    idx = v38;
    v39 = (unsigned __int8 *)CFArrayGetValueAtIndex(v129, v38);
    v40 = v39;
    if (v39[88] != 4)
    {
      v53 = CFRetain(v39);
      if (v53)
        goto LABEL_68;
      goto LABEL_80;
    }
    if (!*((_QWORD *)v39 + 12))
      goto LABEL_80;
    if (C3DMeshElementGetIndicesChannelCount((uint64_t)v39) != 1)
    {
      v99 = scn_default_log();
      if (os_log_type_enabled(v99, OS_LOG_TYPE_FAULT))
        C3DMeshBuildRenderableData_cold_7();
      goto LABEL_80;
    }
    v41 = v40[80];
    Length = CFDataGetLength(*((CFDataRef *)v40 + 12));
    BytePtr = CFDataGetBytePtr(*((CFDataRef *)v40 + 12));
    v44 = *((_DWORD *)v40 + 26);
    if (v44)
    {
      v45 = BytePtr;
      v46 = 0;
      v47 = 0;
      LOBYTE(v48) = 1;
      do
      {
        IndexInBuffer = __readIndexInBuffer(v45, v47, v41, Length);
        v50 = IndexInBuffer;
        if (IndexInBuffer <= 2)
        {
          if ((__C3DMeshElementCreateRenderablePrimitiveTypeCopy(__C3DMeshElement *,__C3DMeshSource const*)::done & 1) == 0)
          {
            __C3DMeshElementCreateRenderablePrimitiveTypeCopy(__C3DMeshElement *,__C3DMeshSource const*)::done = 1;
            v89 = scn_default_log();
            if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
              C3DMeshBuildRenderableData_cold_6(v50, v89, v90);
          }
          goto LABEL_80;
        }
        v48 = (IndexInBuffer == 3) & v48;
        v46 += IndexInBuffer - 2;
        ++v47;
      }
      while (v44 != v47);
      if (v48)
      {
        v51 = CFDataGetLength(*((CFDataRef *)v40 + 12));
        v52 = CFDataCreate(allocator, &v45[v44 * (unint64_t)v41], v51 - v44 * (unint64_t)v41);
        v53 = (_OWORD *)C3DMeshElementCreate();
        C3DMeshElementInit((uint64_t)v53, 0, *((_DWORD *)v40 + 26), v52, v41);
        v54 = v52;
        goto LABEL_67;
      }
      v55 = (unsigned __int8 *)malloc_type_malloc(v46 * 3 * v41, 0xC4A196F0uLL);
      if (!v55)
        goto LABEL_80;
      v110 = v55;
      v108 = v46 * 3 * v41;
      v56 = 0;
      v112 = 0;
      v57 = 0;
      v106 = v44 + 2;
      v107 = v44 + 1;
      v100 = v44 + 3;
      v102 = v3;
      v121 = v44;
      while (1)
      {
        v58 = __readIndexInBuffer(v45, v56, v41, Length);
        if (v58 >= 3)
          break;
LABEL_65:
        if (++v56 == v44)
        {
          v77 = CFDataCreateWithBytesNoCopy(allocator, v110, v46 * 3 * v41, bytesDeallocator);
          v53 = (_OWORD *)C3DMeshElementCreate();
          C3DMeshElementInit((uint64_t)v53, 0, v46, v77, v41);
          v54 = v77;
LABEL_67:
          CFRelease(v54);
          v35 = v105;
          if (!v53)
            goto LABEL_80;
LABEL_68:
          ElementAtIndex = C3DMeshGetElementAtIndex(v3, idx);
          if (ElementAtIndex)
          {
            v53[11] = *(_OWORD *)(ElementAtIndex + 176);
            v53[12] = *(_OWORD *)(ElementAtIndex + 192);
          }
          v37 = theArray;
          CFArrayAppendValue(theArray, v53);
          CFRelease(v53);
          v38 = idx + 1;
          if (idx + 1 == v35)
          {
            v15 = v129;
            goto LABEL_72;
          }
          goto LABEL_26;
        }
      }
      v59 = v58;
      v60 = v57 + v44;
      v61 = v57 + v44 + v58 - 1;
      if (v41 * (unint64_t)v61 > Length)
      {
        v122 = v57;
        v62 = scn_default_log();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67110144;
          v134 = v56;
          v135 = 1024;
          v136 = v59;
          v137 = 1024;
          v138 = v60;
          v139 = 1024;
          v140 = v61;
          v141 = 1024;
          v142 = Length / v41;
          _os_log_error_impl(&dword_1DCCB8000, v62, OS_LOG_TYPE_ERROR, "Error: __C3DMeshElementCreateRenderablePrimitiveTypeCopy - polygon %u (%u vertices, indices [%u, %u]) does not fit in index buffer (%u elements)", buf, 0x20u);
        }
        v46 -= v59 - 2;
        v44 = v121;
        v57 = v122;
        goto LABEL_65;
      }
      if (v58 == 4)
      {
        v103 = __readIndexInBuffer(v45, v60, v41, Length);
        v115 = __readIndexInBuffer(v45, v57 + v107, v41, Length);
        v104 = __readIndexInBuffer(v45, v57 + v106, v41, Length);
        v123 = v57 + 4;
        v119 = __readIndexInBuffer(v45, v100 + v57, v41, Length);
        __writeIndexInBuffer(v110, v112, v103, v41, v108);
        __writeIndexInBuffer(v110, v112 + 1, v115, v41, v108);
        __writeIndexInBuffer(v110, v112 + 2, v104, v41, v108);
        __writeIndexInBuffer(v110, v112 + 3, v103, v41, v108);
        v116 = v112 + 5;
        __writeIndexInBuffer(v110, v112 + 4, v104, v41, v108);
        v112 += 6;
        v65 = v110;
        v66 = v116;
        v67 = v119;
        v68 = v41;
        v69 = v108;
        goto LABEL_50;
      }
      if (v58 == 3)
      {
        v63 = __readIndexInBuffer(v45, v60, v41, Length);
        v118 = __readIndexInBuffer(v45, v57 + v107, v41, Length);
        v123 = v57 + 3;
        v114 = __readIndexInBuffer(v45, v57 + v106, v41, Length);
        __writeIndexInBuffer(v110, v112, v63, v41, v108);
        v64 = v112 + 2;
        __writeIndexInBuffer(v110, v112 + 1, v118, v41, v108);
        v112 += 3;
        v65 = v110;
        v66 = v64;
        v67 = v114;
        v68 = v41;
        v69 = v108;
        v3 = v102;
LABEL_50:
        __writeIndexInBuffer(v65, v66, v67, v68, v69);
        v57 = v123;
LABEL_64:
        v44 = v121;
        goto LABEL_65;
      }
      if (!v111)
        goto LABEL_64;
      v70 = (unsigned int *)malloc_type_malloc(4 * v58, 0x100004052888210uLL);
      v71 = 0;
      v124 = v57;
      do
      {
        v70[v71] = __readIndexInBuffer(v45, v121 + v57 + v71, v41, Length);
        ++v71;
      }
      while (v59 != v71);
      *(_DWORD *)buf = 0;
      v72 = C3DDelaunayTriangulationForSimplePlanarPolygon(v111, v70, v59, (int *)buf);
      v73 = v72;
      v74 = v59 - 2;
      if (*(_DWORD *)buf)
      {
        if (*(_DWORD *)buf == 3 * v74)
        {
          v75 = 0;
          v120 = v72;
          do
          {
            __writeIndexInBuffer(v110, v112 + v75, v120[v75], v41, v108);
            ++v75;
          }
          while (v75 < *(unsigned int *)buf);
          v112 += v75;
          v3 = v102;
          v73 = v120;
          goto LABEL_62;
        }
        v76 = scn_default_log();
        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
          C3DMeshBuildRenderableData_cold_5(&v131, v132, v76);
      }
      v46 -= v74;
      v3 = v102;
      if (!v73)
      {
LABEL_63:
        free(v70);
        v57 = v59 + v124;
        goto LABEL_64;
      }
LABEL_62:
      free(v73);
      goto LABEL_63;
    }
    v53 = (_OWORD *)C3DMeshElementCreate();
    C3DMeshElementInit((uint64_t)v53, 0, 0, 0, 0);
    if (v53)
      goto LABEL_68;
LABEL_80:
    v91 = scn_default_log();
    if (os_log_type_enabled(v91, OS_LOG_TYPE_FAULT))
      C3DMeshBuildRenderableData_cold_3(v91, v92, v93, v94, v95, v96, v97, v98);
    v27 = theArray;
LABEL_83:
    CFRelease(v27);
  }
  else
  {
    v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      C3DMeshBuildRenderableData_cold_1(v3, v20, v21, v22, v23, v24, v25, v26);
    v27 = v129;
    if (v129)
      goto LABEL_83;
  }
}

uint64_t __indexOfSourceWithSemanticAtIndex(uint64_t a1, int a2, uint64_t a3, int a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFArrayRef *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  CFIndex v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  if (!a1)
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v8, v9, v10, v11, v12, v13, v14, v15);
  }
  if (a4 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    v16 = (CFArrayRef *)(a1 + 112);
  }
  else if (a4)
  {
    v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      C3DMeshApplySources_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
    v16 = 0;
  }
  else
  {
    v16 = (CFArrayRef *)(a1 + 64);
  }
  v25 = (char *)v16 + 2 * a2;
  v28 = v25[8];
  v27 = v25 + 8;
  v26 = v28;
  if (v28 == -1 || v27[1] <= a3)
    return -1;
  v29 = v26 + a3;
  if (v29 >= CFArrayGetCount(*v16))
  {
    v30 = scn_default_log();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
      __indexOfSourceWithSemanticAtIndex_cold_1(v30, v31, v32, v33, v34, v35, v36, v37);
  }
  return v29;
}

uint64_t C3DGenericSourceIsVolatile(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 88) >> 2) & 1;
}

uint64_t C3DGenericSourceGetMTLBuffer(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGenericSourceCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(_QWORD *)(a1 + 80))
    return *(_QWORD *)(a1 + 72);
  else
    return 0;
}

void *C3DGenericSourceGetData(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGenericSourceCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = (void *)a1[9];
  if (a1[10])
    return (void *)C3DDataFromMTLBuffer(result);
  if (!result)
  {
    result = (void *)a1[8];
    if (result)
      return C3DSourceAccessorGetData((uint64_t)result);
  }
  return result;
}

uint64_t C3DMeshSourceGetContent(uint64_t a1)
{
  _QWORD *Accessor;
  void *Data;
  uint64_t v4;
  uint64_t Count;
  uint64_t VolatileValuePtrAtIndex;
  unsigned int ComponentsValueType;
  int ComponentsCountPerValue;

  Accessor = (_QWORD *)C3DGenericSourceGetAccessor(a1);
  Data = C3DSourceAccessorGetData((uint64_t)Accessor);
  v4 = 0;
  Count = C3DSourceAccessorGetCount((uint64_t)Accessor);
  if (Data && Count)
  {
    if (C3DGenericSourceIsVolatile(a1))
      VolatileValuePtrAtIndex = C3DSourceAccessorGetVolatileValuePtrAtIndex(Accessor, 0);
    else
      VolatileValuePtrAtIndex = (uint64_t)C3DSourceAccessorGetValuePtrAtIndex(Accessor, 0);
    v4 = VolatileValuePtrAtIndex;
  }
  C3DSceneSourceGetLibrary((uint64_t)Accessor);
  ComponentsValueType = C3DSourceAccessorGetComponentsValueType((uint64_t)Accessor);
  ComponentsCountPerValue = C3DSourceAccessorGetComponentsCountPerValue((uint64_t)Accessor);
  if (ComponentsValueType != C3DBaseTypeGetComponentType(ComponentsValueType))
    C3DBaseTypeGetComponentCount(ComponentsValueType);
  C3DBaseTypeGetCompoundType(ComponentsValueType, ComponentsCountPerValue);
  return v4;
}

uint64_t C3DSourceAccessorGetCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t _fillVertexDescriptor(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  char v8;
  NSObject *v9;
  uint64_t Accessor;
  int ComponentsValueType;
  int ComponentsCountPerValue;
  int CompoundType;
  uint64_t MTLVertexFormat;
  uint64_t v15;
  NSObject *v16;
  unsigned int InstancingDivisor;
  uint64_t v18;

  v8 = 0;
  switch(a3)
  {
    case 0:
      break;
    case 1:
      v8 = 1;
      break;
    case 2:
      v8 = 3;
      break;
    case 3:
      if (a4 == -1)
      {
        v8 = 6;
      }
      else
      {
        v8 = a4 + 6;
        if ((a4 + 6) == 14)
          goto LABEL_6;
      }
      break;
    case 4:
      v8 = 2;
      break;
    case 5:
      v8 = 4;
      break;
    case 6:
      v8 = 5;
      break;
    default:
LABEL_6:
      v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
        _fillVertexDescriptor();
      v8 = 14;
      break;
  }
  Accessor = C3DMeshSourceGetAccessor(a2);
  ComponentsValueType = C3DSourceAccessorGetComponentsValueType(Accessor);
  ComponentsCountPerValue = C3DSourceAccessorGetComponentsCountPerValue(Accessor);
  CompoundType = C3DBaseTypeGetCompoundType(ComponentsValueType, ComponentsCountPerValue);
  MTLVertexFormat = C3DMeshSourceGetMTLVertexFormat(a2);
  v15 = a5 + 18;
  if (!MTLVertexFormat)
    MTLVertexFormat = SCNMTLVertexFormatFromC3DBaseType(CompoundType);
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "attributes"), "objectAtIndexedSubscript:", v8), "setFormat:", MTLVertexFormat);
  if (!objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "attributes"), "objectAtIndexedSubscript:", v8), "format"))
  {
    v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      _fillVertexDescriptor(CompoundType, v16);
  }
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "attributes"), "objectAtIndexedSubscript:", v8), "setOffset:", C3DSourceAccessorGetOffset(Accessor));
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "attributes"), "objectAtIndexedSubscript:", v8), "setBufferIndex:", v15);
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "layouts"), "objectAtIndexedSubscript:", v15), "setStride:", C3DSceneSourceGetLibrary(Accessor));
  InstancingDivisor = C3DMeshSourceGetInstancingDivisor(a2);
  if (!InstancingDivisor)
    return objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "layouts"), "objectAtIndexedSubscript:", v15), "setStepFunction:", 1);
  v18 = InstancingDivisor;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "layouts"), "objectAtIndexedSubscript:", v15), "setStepFunction:", 2);
  return objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "layouts"), "objectAtIndexedSubscript:", v15), "setStepRate:", v18);
}

uint64_t C3DSceneSourceGetLibrary(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t C3DSourceAccessorGetComponentsValueType(uint64_t a1)
{
  return *(__int16 *)(a1 + 24);
}

uint64_t C3DSourceAccessorGetComponentsCountPerValue(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 26);
}

uint64_t C3DGenericSourceGetAccessor(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DKeyframedAnimationCopy_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 64);
}

uint64_t C3DBaseTypeGetCompoundType(int a1, int a2)
{
  unint64_t v2;
  char v3;
  unint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;

  LOWORD(v2) = a1;
  switch(a1)
  {
    case 1:
      if ((a2 - 1) < 4)
      {
        v3 = 16 * (a2 - 1);
        v4 = 0xA000900080001;
        goto LABEL_20;
      }
      v13 = scn_default_log();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        C3DBaseTypeGetCompoundType_cold_11();
      return (__int16)v2;
    case 2:
      if ((a2 - 1) < 4)
      {
        v3 = 16 * (a2 - 1);
        v4 = 0x14001300120002;
        goto LABEL_20;
      }
      v14 = scn_default_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        C3DBaseTypeGetCompoundType_cold_12();
      return (__int16)v2;
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 18:
    case 19:
    case 20:
      goto LABEL_8;
    case 4:
      if (a2 == 1)
      {
        LOWORD(v2) = 4;
      }
      else if (a2 == 4)
      {
        LOWORD(v2) = 26;
      }
      else
      {
        v20 = scn_default_log();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          C3DBaseTypeGetCompoundType_cold_4();
      }
      return (__int16)v2;
    case 14:
      if ((a2 - 1) < 4)
      {
        v3 = 16 * (a2 - 1);
        v4 = 0x2200210020000ELL;
        goto LABEL_20;
      }
      v15 = scn_default_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        C3DBaseTypeGetCompoundType_cold_8();
      break;
    case 15:
      if ((a2 - 1) >= 4)
      {
        v16 = scn_default_log();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          C3DBaseTypeGetCompoundType_cold_10();
      }
      else
      {
        v3 = 16 * (a2 - 1);
        v4 = 0x2D002C002B000FLL;
LABEL_20:
        v2 = v4 >> v3;
      }
      break;
    case 16:
      if (a2 == 1)
      {
        LOWORD(v2) = 16;
      }
      else if (a2 == 4)
      {
        LOWORD(v2) = 25;
      }
      else
      {
        v21 = scn_default_log();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          C3DBaseTypeGetCompoundType_cold_2();
      }
      return (__int16)v2;
    case 17:
      if ((a2 - 1) >= 4)
      {
        v17 = scn_default_log();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          C3DBaseTypeGetCompoundType_cold_6();
      }
      else
      {
        v2 = 0x1F001E001D0011uLL >> (16 * (a2 - 1));
      }
      return (__int16)v2;
    case 21:
      if (a2 == 1)
      {
        LOWORD(v2) = 21;
      }
      else if (a2 == 4)
      {
        LOWORD(v2) = 27;
      }
      else
      {
        v22 = scn_default_log();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          C3DBaseTypeGetCompoundType_cold_3();
      }
      return (__int16)v2;
    case 22:
      if (a2 == 1)
      {
        LOWORD(v2) = 22;
      }
      else if (a2 == 4)
      {
        LOWORD(v2) = 28;
      }
      else
      {
        v23 = scn_default_log();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          C3DBaseTypeGetCompoundType_cold_5();
      }
      return (__int16)v2;
    default:
      if (a1 == 35)
      {
        if ((a2 - 1) >= 4)
        {
          v19 = scn_default_log();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            C3DBaseTypeGetCompoundType_cold_7();
        }
        else
        {
          LOWORD(v2) = a2 + 34;
        }
      }
      else if (a1 == 39)
      {
        if ((a2 - 1) >= 4)
        {
          v18 = scn_default_log();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            C3DBaseTypeGetCompoundType_cold_9();
        }
        else
        {
          LOWORD(v2) = a2 + 38;
        }
      }
      else
      {
LABEL_8:
        if (a2 != 1)
        {
          v5 = scn_default_log();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
            C3DBaseTypeGetCompoundType_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
        }
      }
      return (__int16)v2;
  }
  return (__int16)v2;
}

uint64_t SCNMTLVertexFormatFromC3DBaseType(int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 46)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      SCNMTLDataTypeFromC3DBaseType_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return __SCNMTLAttributeFormatFromC3DBaseType[a1];
}

uint64_t C3DSourceAccessorGetOffset(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSourceAccessorGetData_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 48);
}

uint64_t C3DMeshSourceGetMTLVertexFormat(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t C3DMeshSourceGetInstancingDivisor(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DKeyframedAnimationCopy_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 98);
}

const UInt8 *C3DSourceAccessorGetValuePtrAtIndex(_QWORD *a1, uint64_t a2)
{
  const __CFData *Data;
  NSObject *v6;
  NSObject *v7;

  if (a1[4] <= a2)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      C3DSourceAccessorGetValuePtrAtIndex_cold_2();
  }
  else
  {
    Data = (const __CFData *)C3DSourceAccessorGetData((uint64_t)a1);
    if (Data)
      return &CFDataGetBytePtr(Data)[a1[6] + a1[5] * a2];
    v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      C3DSourceAccessorGetValuePtrAtIndex_cold_1();
  }
  return 0;
}

void *C3DSourceAccessorGetData(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSourceAccessorGetData_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = *(void **)(a1 + 16);
  if (result)
    return C3DGenericSourceGetOwnData((uint64_t)result);
  return result;
}

void *C3DGenericSourceGetOwnData(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGenericSourceCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = *(void **)(a1 + 72);
  if (*(_QWORD *)(a1 + 80))
    return (void *)C3DDataFromMTLBuffer(result);
  return result;
}

uint64_t C3DBaseTypeGetComponentType(unsigned int a1)
{
  NSObject *v1;

  if (a1 < 0x2E)
  {
    return (__int16)__C3DBaseTypeDescArray[3 * (unsigned __int16)a1];
  }
  else
  {
    v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      C3DBaseTypeGetComponentType_cold_1();
    return 0;
  }
}

void __BuildRenderableSourceChannelsAndSemanticInfos(uint64_t a1)
{
  uint64_t v2;
  CFIndex Count;

  v2 = a1 + 112;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 112));
  free(*(void **)(a1 + 152));
  *(_QWORD *)(a1 + 152) = malloc_type_calloc(Count, 1uLL, 0x100004077774924uLL);
  __BuildSemanticInfosForData(a1, v2);
}

uint64_t C3DMeshSourceGetCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshSourceCreateWithAccessor_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return C3DSourceAccessorGetCount(*(_QWORD *)(a1 + 64));
}

uint64_t C3DMeshGetSourcesCount(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  v2 = 0;
  result = 0;
  v4 = a1 + 73;
  do
  {
    result += *(unsigned __int8 *)(v4 + v2);
    v2 += 2;
  }
  while (v2 != 18);
  return result;
}

uint64_t C3DMeshElementTypeMapsToMTLPrimitiveType(unsigned int a1)
{
  return (a1 < 6) & (0xFu >> a1);
}

uint64_t C3DMeshCreateWithMeshSourcesAndMeshElements(const __CFArray *a1, const __CFArray *a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFIndex Count;
  CFIndex v16;
  CFIndex i;
  const void *ValueAtIndex;
  CFIndex v19;
  CFIndex v20;
  CFIndex j;
  const void *v22;

  if (!a3)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DMeshCreateWithMeshSourcesAndMeshElements_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  v14 = C3DMeshCreate();
  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v16 = Count;
    for (i = 0; i != v16; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      C3DMeshAddSource(v14, ValueAtIndex, *(_BYTE *)(a3 + i), 0);
    }
  }
  v19 = CFArrayGetCount(a2);
  if (v19 >= 1)
  {
    v20 = v19;
    for (j = 0; j != v20; ++j)
    {
      v22 = CFArrayGetValueAtIndex(a2, j);
      C3DMeshAppendElement(v14, v22);
    }
  }
  return v14;
}

uint64_t __C3DMeshAddSourceWithDataKind(uint64_t a1, const void *a2, char a3, int a4, int a5)
{
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CFArrayRef *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int Semantic;
  int v36;
  unsigned __int8 v37;
  NSObject *v38;
  char *v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  CFIndex v45;
  CFIndex Count;
  void *v47;
  _BYTE *v48;
  uint64_t v49;
  _QWORD v50[6];

  if (!a1 && (v10 = scn_default_log(), os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)))
  {
    C3DCreateTangentsWithGeometryOptimized_cold_8(v10, v11, v12, v13, v14, v15, v16, v17);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
    C3DKeyframedAnimationCopy_cold_2(v18, v19, v20, v21, v22, v23, v24, v25);
LABEL_6:
  if (a5 == 1)
  {
    C3DMeshBuildRenderableData(a1, 1);
    v26 = (CFArrayRef *)(a1 + 112);
  }
  else if (a5)
  {
    v27 = scn_default_log();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      C3DMeshApplySources_cold_1(v27, v28, v29, v30, v31, v32, v33, v34);
    v26 = 0;
  }
  else
  {
    v26 = (CFArrayRef *)(a1 + 64);
  }
  Semantic = C3DMeshSourceGetSemantic((uint64_t)a2);
  v36 = Semantic;
  if (Semantic)
  {
    v37 = Semantic;
    if ((Semantic & 0x80000000) == 0)
      goto LABEL_21;
LABEL_23:
    v45 = 0;
    goto LABEL_25;
  }
  if (!C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, a5))
  {
    C3DMeshResetBoundingVolumes(a1);
    v37 = v36;
LABEL_21:
    while (1)
    {
      v40 = (char *)v26 + 2 * v37;
      v43 = v40[8];
      v41 = v40 + 8;
      v42 = v43;
      if (v43 != -1)
        break;
      v44 = (char)v37--;
      if (v44 < 1)
        goto LABEL_23;
    }
    v45 = v41[1] + v42;
LABEL_25:
    Count = CFArrayGetCount(*v26);
    CFArrayInsertValueAtIndex(*v26, v45, a2);
    if (a5)
    {
      __BuildRenderableSourceChannelsAndSemanticInfos(a1);
      if (!a4)
        return *((unsigned __int8 *)v26 + 2 * v36 + 9) - 1;
    }
    else
    {
      v47 = *(void **)(a1 + 152);
      if (v47)
      {
        free(v47);
        *(_QWORD *)(a1 + 152) = 0;
      }
      v48 = malloc_type_realloc(*(void **)(a1 + 104), Count + 1, 0x28E62344uLL);
      *(_QWORD *)(a1 + 104) = v48;
      if (Count > v45)
      {
        do
        {
          *(_BYTE *)(*(_QWORD *)(a1 + 104) + Count) = *(_BYTE *)(*(_QWORD *)(a1 + 104) + Count - 1);
          --Count;
        }
        while (Count > v45);
        v48 = *(_BYTE **)(a1 + 104);
      }
      v48[v45] = a3;
      __BuildSemanticInfosForData(a1, (uint64_t)v26);
      v49 = MEMORY[0x1E0C809B0];
      *(_BYTE *)(a1 + 200) &= ~4u;
      v50[0] = v49;
      v50[1] = 0x40000000;
      v50[2] = ____UpdateSourcesMutability_block_invoke;
      v50[3] = &__block_descriptor_tmp_35;
      v50[4] = a1;
      C3DMeshApplySources(a1, 0, (uint64_t)v50);
      __C3DMeshInvalidateRenderableData(a1);
      if (!a4)
        return *((unsigned __int8 *)v26 + 2 * v36 + 9) - 1;
    }
    __MeshWillDieNotification(a1);
    return *((unsigned __int8 *)v26 + 2 * v36 + 9) - 1;
  }
  v38 = scn_default_log();
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v50[0]) = 0;
    _os_log_impl(&dword_1DCCB8000, v38, OS_LOG_TYPE_DEFAULT, "Warning: Can't add two position sources", (uint8_t *)v50, 2u);
  }
  return -1;
}

void __BuildSemanticInfosForData(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  char v8;
  const void *ValueAtIndex;
  int Semantic;
  int v11;
  NSObject *v12;
  uint64_t v13;
  unsigned __int8 v14;
  NSObject *v15;
  uint64_t Name;
  const __CFString *v17;
  NSObject *v18;
  uint64_t v19;
  _BYTE *v20;
  int v21;
  NSObject *v22;
  int HasNonOpaqueColors;
  char v24;
  char v25;
  uint8_t v26[4];
  uint64_t v27;
  uint8_t v28[4];
  uint64_t v29;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  const __CFString *v33;
  uint8_t v34[4];
  _DWORD v35[7];

  v4 = 0;
  *(_QWORD *)&v35[5] = *MEMORY[0x1E0C80C00];
  do
  {
    *(_WORD *)(a2 + v4 + 8) = 255;
    v4 += 2;
  }
  while (v4 != 18);
  *(_BYTE *)(a1 + 200) &= ~0x80u;
  Count = CFArrayGetCount(*(CFArrayRef *)a2);
  if (Count >= 1)
  {
    v6 = Count;
    v7 = 0;
    v8 = -1;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a2, v7);
      Semantic = C3DMeshSourceGetSemantic((uint64_t)ValueAtIndex);
      v11 = Semantic;
      if (Semantic == v8)
      {
        if (!v8)
        {
          if (*(_BYTE *)(a2 + 9))
          {
            v12 = scn_default_log();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
              __BuildSemanticInfosForData_cold_1(v34, v35, v12);
          }
        }
        v13 = a2 + 2 * v8;
        v14 = *(_BYTE *)(v13 + 9) + 1;
        *(_BYTE *)(v13 + 9) = v14;
        if (v8 != 3 && v14 >= 2u)
        {
          v15 = scn_default_log();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            Name = C3DEntityGetName(a1);
            v17 = C3DMeshSourceSemanticToSemanticString(v8);
            *(_DWORD *)buf = 138412546;
            v31 = Name;
            v32 = 2112;
            v33 = v17;
            _os_log_impl(&dword_1DCCB8000, v15, OS_LOG_TYPE_DEFAULT, "Warning: Mesh '%@' : sources of redundant semantic '%@' will be ignored in rendering", buf, 0x16u);
          }
        }
      }
      else
      {
        if (Semantic <= v8)
        {
          v18 = scn_default_log();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
            __BuildSemanticInfosForData_cold_3(v28, &v29, v18);
        }
        v19 = a2 + 2 * v11;
        v21 = *(unsigned __int8 *)(v19 + 8);
        v20 = (_BYTE *)(v19 + 8);
        if (v21 != 255)
        {
          v22 = scn_default_log();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
            __BuildSemanticInfosForData_cold_2(v26, &v27, v22);
        }
        *v20 = v7;
        *(_BYTE *)(a2 + 2 * v11 + 9) = 1;
        v8 = v11;
      }
      if (v11 == 2)
      {
        HasNonOpaqueColors = C3DMeshSourceHasNonOpaqueColors((uint64_t)ValueAtIndex);
        v24 = *(_BYTE *)(a1 + 200);
        v25 = v24 & 0x80;
        if (HasNonOpaqueColors)
          v25 = 0x80;
        *(_BYTE *)(a1 + 200) = v25 & 0x80 | v24 & 0x7F;
      }
      ++v7;
    }
    while (v6 != v7);
  }
}

uint64_t C3DMeshSourceGetSemantic(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshSourceCreateWithAccessor_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(char *)(a1 + 96);
}

void __C3DMeshInvalidateRenderableData(uint64_t a1)
{
  const void *v2;
  const void *v3;
  uint64_t i;

  v2 = *(const void **)(a1 + 144);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 144) = 0;
  }
  v3 = *(const void **)(a1 + 112);
  if (v3)
  {
    for (i = 0; i != 18; i += 2)
      *(_WORD *)(a1 + i + 120) = 255;
    CFRelease(v3);
    *(_QWORD *)(a1 + 112) = 0;
  }
}

uint64_t C3DMeshAddSource(uint64_t a1, const void *a2, char a3, int a4)
{
  return __C3DMeshAddSourceWithDataKind(a1, a2, a3, a4, 0);
}

void C3DMeshResetBoundingVolumes(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(void **)(a1 + 184);
  if (v10)
    free(v10);
  v11 = *(void **)(a1 + 192);
  if (v11)
    free(v11);
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_BYTE *)(a1 + 200) &= ~2u;
}

uint64_t C3DMeshCreate()
{
  uint64_t Instance;
  const __CFAllocator *v1;
  const CFArrayCallBacks *v2;

  if (C3DMeshGetTypeID_onceToken != -1)
    dispatch_once(&C3DMeshGetTypeID_onceToken, &__block_literal_global_63);
  Instance = C3DTypeCreateInstance_(C3DMeshGetTypeID_typeID, 0xD0uLL);
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v2 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  *(_QWORD *)(Instance + 64) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(Instance + 96) = CFArrayCreateMutable(v1, 0, v2);
  *(_QWORD *)(Instance + 112) = 0;
  *(_QWORD *)(Instance + 144) = 0;
  *(_BYTE *)(Instance + 200) = *(_BYTE *)(Instance + 200) & 0x87 | 0x18;
  __BuildSemanticInfosForData(Instance, Instance + 64);
  return Instance;
}

void C3DMeshAppendElement(uint64_t a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_BYTE *)(a1 + 200) &= ~2u;
  __C3DMeshInvalidateRenderableData(a1);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 96), a2);
}

uint64_t C3DMeshIsMutable(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(unsigned __int8 *)(a1 + 200) >> 2) & 1;
}

uint64_t SCNResourceRegistrySetup(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t result;

  if (a2)
    v3 = 0;
  else
    v3 = 258;
  result = objc_msgSend(objc_alloc(MEMORY[0x1E0CB3748]), "initWithKeyOptions:valueOptions:capacity:", v3, 0, 100);
  *a1 = result;
  return result;
}

const __CFString *__stringForProperty(int a1)
{
  const __CFString *result;
  __CFString **v3;

  result = CFSTR("multiply");
  switch(a1)
  {
    case 0:
      v3 = kC3DEmission;
      goto LABEL_18;
    case 1:
      v3 = kC3DAmbient;
      goto LABEL_18;
    case 2:
      v3 = kC3DDiffuse;
      goto LABEL_18;
    case 3:
      v3 = kC3DSpecular;
      goto LABEL_18;
    case 4:
      v3 = kC3DReflective;
      goto LABEL_18;
    case 5:
      v3 = kC3DTransparent;
      goto LABEL_18;
    case 6:
      return result;
    case 7:
      v3 = kC3DNormal;
      goto LABEL_18;
    case 8:
      v3 = kC3DAmbientOcclusion;
      goto LABEL_18;
    case 9:
      v3 = kC3DSelfIllumination;
      goto LABEL_18;
    case 10:
      v3 = kC3DMetalness;
      goto LABEL_18;
    case 11:
      v3 = kC3DRoughness;
      goto LABEL_18;
    case 12:
      v3 = kC3DClearCoat;
      goto LABEL_18;
    case 13:
      v3 = kC3DClearCoatRoughness;
      goto LABEL_18;
    case 14:
      v3 = kC3DClearCoatNormal;
      goto LABEL_18;
    case 15:
      v3 = kC3DDisplacement;
LABEL_18:
      result = *v3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

_QWORD *C3DEngineContextCreateWithOptions(const __CFDictionary *a1)
{
  _QWORD *Instance;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t i;

  if (C3DEngineContextGetTypeID_onceToken != -1)
    dispatch_once(&C3DEngineContextGetTypeID_onceToken, &__block_literal_global_31);
  Instance = (_QWORD *)C3DTypeCreateInstance_(C3DEngineContextGetTypeID_typeID, 0x740uLL);
  v3 = Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[17] = 0;
    Instance[53] = 0x7FF0000000000000;
    Instance[205] = C3DRendererElementStateCreate();
    *((_WORD *)v3 + 106) = 1;
    *((_DWORD *)v3 + 51) = 1065353216;
    v3[216] = C3DRenderGraphCreate((__C3DEngineContext *)v3);
    C3DSetupHaltonFilterKernel((uint64_t)(v3 + 217), 16, 1.0, 1.0);
    *((_BYTE *)v3 + 1724) = 1;
    *((_OWORD *)v3 + 103) = 0u;
    *((_OWORD *)v3 + 104) = 0u;
    *((_OWORD *)v3 + 105) = 0u;
    *((_BYTE *)v3 + 1632) = 2;
    if (a1)
      v3[47] = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a1);
    v4 = 0;
    v5 = v3 + 60;
    do
    {
      for (i = 0; i != 48; i += 8)
        C3DMatrix4x4MakeIdentity((uint64_t)&v5[i]);
      ++v4;
      v5 += 48;
    }
    while (v4 != 3);
    v3[22] = C3DProgramHashCodeStoreCreate();
    v3[23] = C3DSortSystemCreate();
    v3[21] = C3DStackAllocatorCreate(0x10000);
  }
  return v3;
}

void sub_1DCCCA2C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,_QWORD *a34,uint64_t a35,char a36,_QWORD *a37)
{
  std::__tree<char>::destroy((uint64_t)&a33, a34);
  std::__tree<char>::destroy((uint64_t)&a36, a37);
  _Unwind_Resume(a1);
}

void sub_1DCCCA978(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1DCCCAB00(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1DCCCAC0C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t C3DNodeCreate()
{
  uint64_t Instance;
  unsigned int v1;

  if (C3DNodeGetTypeID_onceToken != -1)
    dispatch_once(&C3DNodeGetTypeID_onceToken, &__block_literal_global_62);
  Instance = C3DTypeCreateInstance_(C3DNodeGetTypeID_typeID, 0x120uLL);
  C3DTransformInit(Instance + 96);
  *(_DWORD *)(Instance + 204) = 1065353216;
  *(_BYTE *)(Instance + 200) = 0;
  v1 = *(_DWORD *)(Instance + 220) & 0xFFDFFFD1 | 0x20002A;
  *(_QWORD *)(Instance + 208) = 1;
  *(_DWORD *)(Instance + 216) = -1;
  *(_DWORD *)(Instance + 220) = v1;
  *(_DWORD *)(Instance + 88) = -1;
  *(_OWORD *)(Instance + 272) = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 48);
  *(_OWORD *)(Instance + 288) = xmmword_1DD0076D0;
  return Instance;
}

__n128 C3DMatrix4x4MakeIdentity(uint64_t a1)
{
  uint64_t v1;
  __int128 v2;
  __n128 result;
  __int128 v4;

  v1 = MEMORY[0x1E0C83FF0];
  v2 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 16);
  *(_OWORD *)a1 = *MEMORY[0x1E0C83FF0];
  *(_OWORD *)(a1 + 16) = v2;
  result = *(__n128 *)(v1 + 32);
  v4 = *(_OWORD *)(v1 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

double C3DTransformInit(uint64_t a1)
{
  double result;

  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFF3 | 8;
  *(_QWORD *)&result = C3DMatrix4x4MakeIdentity(a1).n128_u64[0];
  return result;
}

void std::__tree<char>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<char>::destroy(a1, *a2);
    std::__tree<char>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t *`anonymous namespace'::build_crease_map(void *a1, uint64_t **a2, uint64_t **a3)
{
  uint64_t *result;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  unsigned int *v11;
  int v12;
  unint64_t *v13;
  int *v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t *v18;

  result = (uint64_t *)objc_msgSend(a1, "topology");
  if (result)
  {
    if (objc_msgSend((id)objc_msgSend(a1, "topology"), "edgeCreases"))
    {
      if (objc_msgSend((id)objc_msgSend(a1, "topology"), "edgeCreaseIndices"))
      {
        v7 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "edgeCreaseIndices"), "map"), "bytes");
        v8 = (int *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "edgeCreases"), "map"), "bytes");
        v9 = objc_msgSend((id)objc_msgSend(a1, "topology"), "edgeCreaseCount");
        if (v9 >= 1)
        {
          v10 = v9;
          v11 = (unsigned int *)(v7 + 4);
          do
          {
            v17 = *v11 | ((unint64_t)*(v11 - 1) << 32);
            v12 = *v8++;
            v18 = &v17;
            *((_DWORD *)std::__tree<std::__value_type<unsigned long long,float>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,float>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,float>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a2, &v17, (uint64_t)&std::piecewise_construct, &v18)+ 10) = v12;
            v11 += 2;
            --v10;
          }
          while (v10);
        }
      }
    }
    result = (uint64_t *)objc_msgSend((id)objc_msgSend(a1, "topology"), "vertexCreases");
    if (result)
    {
      result = (uint64_t *)objc_msgSend((id)objc_msgSend(a1, "topology"), "vertexCreaseIndices");
      if (result)
      {
        v13 = (unint64_t *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "vertexCreaseIndices"), "map"), "bytes");
        v14 = (int *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "vertexCreases"), "map"), "bytes");
        result = (uint64_t *)objc_msgSend((id)objc_msgSend(a1, "topology"), "vertexCreaseCount");
        if ((int)result >= 1)
        {
          v15 = result;
          do
          {
            v16 = *v14++;
            v18 = v13;
            result = std::__tree<std::__value_type<unsigned int,float>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,float>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(a3, (unsigned int *)v13, (uint64_t)&std::piecewise_construct, (unsigned int **)&v18);
            *((_DWORD *)result + 8) = v16;
            v13 = (unint64_t *)((char *)v13 + 4);
            --v15;
          }
          while (v15);
        }
      }
    }
  }
  return result;
}

SCNGeometryElement *`anonymous namespace'::add_creases(SCNGeometryElement *result, _QWORD *a2, SCNGeometryElement **a3)
{
  NSData *elementData;
  SCNGeometryElement *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  __C3DMeshElement *isa;
  unsigned int v14;
  __CFString *var3;
  __C3DMeshElement *var1;
  __C3DMeshElement **v17;
  BOOL v18;

  elementData = result->_elementData;
  if (elementData)
  {
    v6 = result;
    v7 = 4 * (_QWORD)elementData;
    v8 = (void *)objc_msgSend(MEMORY[0x1E0C99DF0], "dataWithLength:", 4 * (_QWORD)elementData);
    objc_msgSend(v8, "setLength:", v7);
    v9 = objc_msgSend(v8, "mutableBytes");
    v10 = 8 * (uint64_t)v6->_elementData;
    v11 = (void *)objc_msgSend(MEMORY[0x1E0C99DF0], "dataWithLength:", v10);
    objc_msgSend(v11, "setLength:", v10);
    v12 = objc_msgSend(v11, "mutableBytes");
    isa = (__C3DMeshElement *)v6->super.isa;
    if ((__C3DMeshElement **)v6->super.isa != &v6->_meshElement)
    {
      v14 = 0;
      do
      {
        var3 = isa->var0.var3;
        *(_DWORD *)(v12 + 8 * v14) = HIDWORD(var3);
        *(_DWORD *)(v12 + 4 * ((2 * v14) | 1)) = (_DWORD)var3;
        *(_DWORD *)(v9 + 4 * v14) = isa->var0.var4;
        var1 = (__C3DMeshElement *)isa->var0.var0.var1;
        if (var1)
        {
          do
          {
            v17 = (__C3DMeshElement **)var1;
            var1 = (__C3DMeshElement *)var1->var0.var0.var0;
          }
          while (var1);
        }
        else
        {
          do
          {
            v17 = (__C3DMeshElement **)isa->var0.var1;
            v18 = *v17 == isa;
            isa = (__C3DMeshElement *)v17;
          }
          while (!v18);
        }
        ++v14;
        isa = (__C3DMeshElement *)v17;
      }
      while (v17 != &v6->_meshElement);
    }
    *a2 = +[SCNGeometrySource geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:](SCNGeometrySource, "geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:", v8, CFSTR("kGeometrySourceSemanticEdgeCrease"), v6->_elementData, 1, 1, 4, 0, 4);
    result = +[SCNGeometryElement geometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:](SCNGeometryElement, "geometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:", v11, 2, v6->_elementData, 4);
    *a3 = result;
  }
  return result;
}

SCNGeometrySource *`anonymous namespace'::add_corners(SCNGeometrySource *result, _QWORD *a2, void *a3)
{
  SCNGeometrySource *v5;
  void *v6;
  void *v7;
  NSObject *v8;
  unint64_t v9;
  unint64_t v10;
  void *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  BOOL v18;

  if (a2[2])
  {
    v5 = result;
    v6 = (void *)objc_msgSend(a3, "vertexDescriptor");
    v7 = (void *)objc_msgSend(v6, "attributeNamed:", *MEMORY[0x1E0CC7760]);
    if (!v7)
    {
      v8 = scn_default_log();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    }
    v9 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a3, "vertexBuffers"), "objectAtIndexedSubscript:", objc_msgSend(v7, "bufferIndex")), "length");
    v10 = v9
        / objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a3, "vertexDescriptor"), "layouts"), "objectAtIndexedSubscript:", objc_msgSend(v7, "bufferIndex")), "stride");
    v11 = (void *)objc_msgSend(MEMORY[0x1E0C99DF0], "dataWithLength:", 4 * v10);
    objc_msgSend(v11, "setLength:", 4 * v10);
    v12 = (void *)objc_msgSend(v11, "mutableBytes");
    bzero(v12, 4 * v10);
    v15 = (_QWORD *)*a2;
    v14 = a2 + 1;
    v13 = v15;
    if (v15 != v14)
    {
      do
      {
        *((_DWORD *)v12 + *((unsigned int *)v13 + 7)) = *((_DWORD *)v13 + 8);
        v16 = (_QWORD *)v13[1];
        if (v16)
        {
          do
          {
            v17 = v16;
            v16 = (_QWORD *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            v17 = (_QWORD *)v13[2];
            v18 = *v17 == (_QWORD)v13;
            v13 = v17;
          }
          while (!v18);
        }
        v13 = v17;
      }
      while (v17 != v14);
    }
    result = +[SCNGeometrySource geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:](SCNGeometrySource, "geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:", v11, CFSTR("kGeometrySourceSemanticVertexCrease"), v10, 1, 1, 4, 0, 4);
    if (result)
      return (SCNGeometrySource *)-[SCNGeometrySource addObject:](v5, "addObject:", result);
  }
  return result;
}

void sub_1DCCCCD18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void C3DTextureSamplerSetBorderColor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DTextureSamplerSetAnisotropy_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  *(_QWORD *)(a1 + 48) = a2;
  *(_QWORD *)(a1 + 56) = a3;
}

float C3DSetupHaltonFilterKernel(uint64_t a1, int a2, float result, float a4)
{
  uint64_t i;
  float v5;
  float v6;
  unsigned int v7;
  float v8;
  BOOL v9;
  float v10;
  int v11;
  float v12;
  unsigned int v13;
  uint64_t v14;

  if (a2 >= 1)
  {
    for (i = 0; i != a2; *(_QWORD *)(a1 + 8 * i++) = v14)
    {
      if (i)
      {
        v5 = 0.5;
        v6 = 0.0;
        v7 = i;
        do
        {
          if ((v7 & 1) != 0)
            v8 = v5;
          else
            v8 = -0.0;
          v6 = v6 + v8;
          v5 = v5 * 0.5;
          v9 = v7 > 1;
          v7 >>= 1;
        }
        while (v9);
        v10 = 0.0;
        v11 = i;
        v12 = 0.33333;
        do
        {
          if (v11 != 3 * (v11 / 3))
            v10 = v10 + (float)((float)(v11 % 3) * v12);
          v12 = v12 * 0.33333;
          v13 = v11 + 2;
          v11 /= 3;
        }
        while (v13 > 4);
      }
      else
      {
        v6 = 0.0;
        v10 = 0.0;
      }
      *(float *)&v14 = (float)((float)(v6 * 2.0) + -1.0) * result;
      *((float *)&v14 + 1) = (float)((float)(v10 * 2.0) + -1.0) * a4;
    }
  }
  return result;
}

_QWORD *C3DRendererElementStateCreate()
{
  _QWORD *Instance;
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;

  if (C3DRendererElementStateGetTypeID_onceToken != -1)
    dispatch_once(&C3DRendererElementStateGetTypeID_onceToken, &__block_literal_global_33);
  Instance = (_QWORD *)C3DTypeCreateInstance_(C3DRendererElementStateGetTypeID_typeID, 0x1A0uLL);
  if (!Instance)
  {
    v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT))
      C3DRendererElementStateCreate_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
  }
  Instance[7] = 0;
  v9 = (const void *)Instance[41];
  if (v9)
  {
    CFRelease(v9);
    Instance[41] = 0;
  }
  Instance[42] = 0;
  return Instance;
}

float32x4_t *C3DNodeGetLastFrameWorldMatrix(float32x4_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t TransformTree;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = a1[3].i64[0];
  if (!v10)
    return C3DTransformGetMatrixPtr(a1 + 6);
  TransformTree = C3DSceneGetTransformTree(v10);
  if (a1[5].i32[2] == -1)
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      C3DNodeGetWorldMatrix_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  return (float32x4_t *)C3DTransformTreeGetLastFrameWorldTransformPtr(TransformTree, a1[5].i32[2]);
}

uint64_t C3DTransformTreeGetLastFrameWorldTransformPtr(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DTransformTreeAddNode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (a2 == -1)
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      __C3DTransformTree::remove();
  }
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * a2);
  v14 = HIDWORD(v13);
  if (HIDWORD(v13) == 0xFFFFFFFF)
    v15 = 0;
  else
    v15 = -1;
  if (HIDWORD(v13) == 0xFFFFFFFF)
    LODWORD(v16) = 0;
  else
    v16 = HIDWORD(v13);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * a2) == 0xFFFFFFFFLL)
  {
    LODWORD(v13) = v15;
    LODWORD(v14) = v16;
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * (int)v13 + 8) + ((uint64_t)(int)v14 << 6);
}

uint64_t C3DMeshSourceCreateWithData(__int16 a1, const void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const void *v30;
  uint64_t v31;

  if (!a2)
  {
    v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      C3DMeshSourceCreateWithData_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
  if (a4 >= 5)
  {
    v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      C3DMeshSourceCreateWithData_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
  }
  v30 = (const void *)C3DSourceAccessorCreate(a3, a4, a5, a6, a7);
  v31 = C3DMeshSourceCreateWithAccessor(v30, a1);
  *(_QWORD *)(v31 + 72) = CFRetain(a2);
  C3DSourceAccessorSetSource((uint64_t)v30, v31);
  if (v30)
    CFRelease(v30);
  return v31;
}

uint64_t C3DSourceAccessorSetSource(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

uint64_t C3DSourceAccessorCreate(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;

  v10 = _C3DSourceAccessorCreate();
  *(_WORD *)(v10 + 24) = a1;
  *(_WORD *)(v10 + 26) = a2;
  if (!a4)
    a4 = C3DSizeOfBaseType(a1) * a2;
  *(_QWORD *)(v10 + 32) = a3;
  *(_QWORD *)(v10 + 40) = a4;
  *(_QWORD *)(v10 + 48) = a5;
  *(_QWORD *)(v10 + 56) = 0;
  return v10;
}

uint64_t _C3DSourceAccessorCreate()
{
  if (C3DSourceAccessorGetTypeID_onceToken != -1)
    dispatch_once(&C3DSourceAccessorGetTypeID_onceToken, &__block_literal_global_88);
  return C3DTypeCreateInstance_(C3DSourceAccessorGetTypeID_typeID, 0x30uLL);
}

uint64_t C3DMeshSourceCreateWithAccessor(const void *a1, __int16 a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = _C3DMeshSourceCreate();
  if (!v4)
  {
    v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      C3DMeshSourceCreateWithAccessor_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
  }
  C3DGenericSourceInit(v4, a1);
  *(_WORD *)(v4 + 96) = a2;
  return v4;
}

uint64_t _C3DMeshSourceCreate()
{
  if (C3DMeshSourceGetTypeID_onceToken != -1)
    dispatch_once(&C3DMeshSourceGetTypeID_onceToken, &__block_literal_global_17);
  return C3DTypeCreateInstance_(C3DMeshSourceGetTypeID_typeID, 0x58uLL);
}

CFTypeRef C3DGenericSourceInit(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (!cf && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DSourceAccessorGetData_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a1)
      goto LABEL_6;
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DKeyframedAnimationCopy_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  *(_QWORD *)(a1 + 64) = cf;
  return CFRetain(cf);
}

uint64_t SCNGeometrySourceSemanticToMeshSourceSemantic(void *a1)
{
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("kGeometrySourceSemanticVertex")) & 1) != 0)
    return 0;
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("kGeometrySourceSemanticNormal")) & 1) != 0)
    return 1;
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("kGeometrySourceSemanticColor")) & 1) != 0)
    return 2;
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("kGeometrySourceSemanticTexcoord")) & 1) != 0)
    return 3;
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("kGeometrySourceSemanticTangent")) & 1) != 0)
    return 4;
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("kGeometrySourceSemanticVertexCrease")) & 1) != 0)
    return 7;
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("kGeometrySourceSemanticEdgeCrease")) & 1) != 0)
    return 8;
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("kGeometrySourceSemanticBoneIndices")) & 1) != 0)
    return 5;
  if (objc_msgSend(a1, "isEqualToString:", CFSTR("kGeometrySourceSemanticBoneWeights")))
    return 6;
  return 0;
}

void C3DMeshSourceSetModelKitSemantic(uint64_t a1, char a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DMeshSourceCreateWithAccessor_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_BYTE *)(a1 + 99) = a2;
}

id C3DEntitySetObjCWrapper(uint64_t a1, id obj)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return objc_storeWeak((id *)(a1 + 16), obj);
}

uint64_t C3DGeometryCreate()
{
  uint64_t Instance;

  if (C3DGeometryGetTypeID_onceToken != -1)
    dispatch_once(&C3DGeometryGetTypeID_onceToken, &__block_literal_global_5);
  Instance = C3DTypeCreateInstance_(C3DGeometryGetTypeID_typeID, 0xC8uLL);
  *(_QWORD *)(Instance + 80) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(Instance + 104) = 0;
  *(_BYTE *)(Instance + 208) = 0;
  *(_QWORD *)(Instance + 120) = 0;
  *(_QWORD *)(Instance + 128) = 0;
  C3DGeometryInitSubdivision(Instance);
  return Instance;
}

double C3DGeometryInitSubdivision(uint64_t a1)
{
  double result;

  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_BYTE *)(a1 + 137) = C3DWasLinkedBeforeMajorOSYear2017() ^ 1;
  *(_QWORD *)&result = 17105153;
  *(_DWORD *)(a1 + 138) = 17105153;
  return result;
}

uint64_t C3DGeometryOsdGetWantsAdaptiveSubdivision(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 137);
}

uint64_t C3DGeometryOsdGetSubdivisionSettings(uint64_t a1)
{
  return *(unsigned int *)(a1 + 138);
}

uint64_t C3DGeometryOsdGetEdgeCreasesSource(uint64_t a1)
{
  return *(_QWORD *)(a1 + 152);
}

uint64_t C3DGeometryOsdGetEdgeCreasesElement(uint64_t a1)
{
  return *(_QWORD *)(a1 + 144);
}

void __buildSourceChannels(void *a1, size_t a2, void *a3, void *a4)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned __int8 v12;
  unsigned int v13;
  NSObject *v14;
  size_t v15;
  unsigned int v16;
  signed int v17;
  unsigned int v18;
  NSObject *v19;
  NSObject *v20;
  const char *v21;
  uint32_t v22;
  NSObject *v23;
  uint8_t buf[4];
  unsigned int v25;
  __int16 v26;
  unsigned int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v8 = objc_msgSend(a1, "count");
  if (!v8)
  {
    bzero(a4, a2);
    return;
  }
  v9 = objc_msgSend(a3, "count");
  if (!v9)
  {
    v11 = 0;
    if (!a2)
      return;
    goto LABEL_17;
  }
  v10 = 0;
  v11 = 0;
  do
  {
    v12 = objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", v10), "indicesChannelCount");
    if (v10)
    {
      v13 = v12;
      if (v12 != v11)
      {
        v14 = scn_default_log();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1DCCB8000, v14, OS_LOG_TYPE_DEFAULT, "Warning: Found elements with different channel counts in the same geometry", buf, 2u);
        }
        if (v13 < v11)
          v11 = v13;
      }
    }
    else
    {
      v11 = v12;
    }
    ++v10;
  }
  while (v9 != v10);
  if (a2)
  {
LABEL_17:
    v15 = 0;
    v16 = 1;
    do
    {
      if (v16 - 1 >= v8)
      {
        v23 = scn_default_log();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          v25 = v16 - 1;
          v20 = v23;
          v21 = "Error: Missing channel for source at index %u";
          v22 = 8;
          goto LABEL_28;
        }
      }
      else
      {
        v17 = objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", v15), "intValue");
        v18 = v17;
        if ((v17 & 0x80000000) == 0 && v17 <= (int)v11)
          goto LABEL_25;
        v19 = scn_default_log();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          v25 = v18;
          v26 = 1024;
          v27 = v16 - 1;
          v20 = v19;
          v21 = "Error: Invalid channel (%d) for source at index %u";
          v22 = 14;
LABEL_28:
          _os_log_error_impl(&dword_1DCCB8000, v20, OS_LOG_TYPE_ERROR, v21, buf, v22);
        }
      }
      LOBYTE(v18) = 0;
LABEL_25:
      *((_BYTE *)a4 + v15) = v18;
      v15 = v16++;
    }
    while (v15 < a2);
  }
}

void C3DGeometryAppendMaterial(uint64_t a1, void *value)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (value)
      goto LABEL_6;
  }
  else if (value)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DGeometryAppendMaterial_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 80), value);
  v20 = C3DGetSceneRef(a1);
  C3DAddSceneRef((uint64_t *)value, v20);
  __PostGeometryMaterialDidChangeNotification((_QWORD *)a1);
}

CFIndex _C3DMeshEnumerateSubEntities(CFArrayRef *a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const void *ValueAtIndex;
  CFIndex v8;
  CFIndex v9;
  CFIndex j;
  const void *v11;
  const __CFArray *v12;
  CFIndex v13;
  CFIndex v14;
  CFIndex k;
  const void *v16;
  CFIndex result;
  CFIndex v18;
  CFIndex m;
  const void *v20;

  Count = CFArrayGetCount(a1[8]);
  if (Count >= 1)
  {
    v5 = Count;
    for (i = 0; i != v5; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1[8], i);
      (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex);
    }
  }
  v8 = CFArrayGetCount(a1[12]);
  if (v8 >= 1)
  {
    v9 = v8;
    for (j = 0; j != v9; ++j)
    {
      v11 = CFArrayGetValueAtIndex(a1[12], j);
      (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, v11);
    }
  }
  v12 = a1[14];
  if (v12)
  {
    v13 = CFArrayGetCount(v12);
    if (v13 >= 1)
    {
      v14 = v13;
      for (k = 0; k != v14; ++k)
      {
        v16 = CFArrayGetValueAtIndex(a1[14], k);
        (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, v16);
      }
    }
  }
  result = (CFIndex)a1[18];
  if (result)
  {
    result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      v18 = result;
      for (m = 0; m != v18; ++m)
      {
        v20 = CFArrayGetValueAtIndex(a1[18], m);
        result = (*(uint64_t (**)(uint64_t, const void *))(a2 + 16))(a2, v20);
      }
    }
  }
  return result;
}

void C3DAddSceneRef(uint64_t *cf, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *ClassWithTypeID;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  void (*v17)(uint64_t *, uint64_t);
  void (*v18)(uint64_t *, uint64_t);
  void (*v19)(uint64_t *, uint64_t);
  void (*v20)(uint64_t *, uint64_t);
  void (*v21)(uint64_t *, _QWORD *);
  void (*v22)(uint64_t *, uint64_t);
  void (*v23)(uint64_t *, uint64_t);
  void (*v24)(uint64_t *, uint64_t);
  void (*v25)(uint64_t *, uint64_t);
  _QWORD v26[5];

  if (!cf && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (!a2)
      return;
  }
  else if (!a2)
  {
    return;
  }
  if (_C3DEntityGetSceneLink_onceToken != -1)
    dispatch_once(&_C3DEntityGetSceneLink_onceToken, &__block_literal_global_11);
  v12 = (_QWORD *)_C3DEntityGetSceneLink_sceneLink;
  CFGetTypeID(cf);
  ClassWithTypeID = (_QWORD *)_CFRuntimeGetClassWithTypeID();
  v14 = *ClassWithTypeID;
  if (*ClassWithTypeID == 749405696)
    v15 = ClassWithTypeID;
  else
    v15 = 0;
  v16 = cf[6];
  if (!v16 || v16 == a2)
  {
    ++cf[7];
    if (v16)
      return;
  }
  else
  {
    if (v14 == 749405696)
    {
      v17 = (void (*)(uint64_t *, uint64_t))v15[19];
      if (v17)
        v17(cf, cf[6]);
    }
    v18 = (void (*)(uint64_t *, uint64_t))v12[2];
    if (v18)
      v18(cf, v16);
    _removeFromScene(cf, v16);
    cf[7] = 1;
  }
  cf[6] = a2;
  v19 = (void (*)(uint64_t *, uint64_t))v12[1];
  if (v19)
    v19(cf, a2);
  if (v14 == 749405696)
  {
    v20 = (void (*)(uint64_t *, uint64_t))v15[18];
    if (v20)
      v20(cf, a2);
    v21 = (void (*)(uint64_t *, _QWORD *))v15[17];
    if (v21)
    {
      v26[0] = MEMORY[0x1E0C809B0];
      v26[1] = 0x40000000;
      v26[2] = __C3DAddSceneRef_block_invoke;
      v26[3] = &__block_descriptor_tmp_3_0;
      v26[4] = a2;
      v21(cf, v26);
    }
  }
  if (v16)
  {
    v22 = (void (*)(uint64_t *, uint64_t))v12[4];
    if (v22)
      v22(cf, v16);
    if (v14 == 749405696)
    {
      v23 = (void (*)(uint64_t *, uint64_t))v15[21];
      if (v23)
        v23(cf, v16);
    }
  }
  v24 = (void (*)(uint64_t *, uint64_t))v12[3];
  if (v24)
    v24(cf, a2);
  if (v14 == 749405696)
  {
    v25 = (void (*)(uint64_t *, uint64_t))v15[20];
    if (v25)
      v25(cf, a2);
  }
}

const __CFDictionary *_C3DEntityFinalizeAddToScene(float32x4_t *a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t AnimationManager;
  const __CFDictionary *SubAttributeOrderedDictionary;
  const __CFDictionary *v22;
  const __CFDictionary *result;
  const __CFDictionary *v24;
  const __CFDictionary *v25;
  uint64_t v26;
  const __CFDictionary *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  float32x4_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DSceneCreateHitTestResultsWithSegment_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  AnimationManager = C3DSceneGetAnimationManager(a2);
  SubAttributeOrderedDictionary = _C3DEntityGetSubAttributeOrderedDictionary((uint64_t)a1, CFSTR("kAnimationsKey"), 0);
  if (SubAttributeOrderedDictionary)
  {
    v32 = a1;
    v33 = AnimationManager;
    v34 = a2;
    C3DOrderedDictionaryApplyFunction(SubAttributeOrderedDictionary, (const char *)_fillAnimationManager, (uint64_t)&v32);
  }
  v22 = _C3DEntityGetSubAttributeOrderedDictionary((uint64_t)a1, CFSTR("kActionsKey"), 0);
  if (v22)
  {
    v32 = a1;
    v33 = AnimationManager;
    C3DOrderedDictionaryApplyFunction(v22, (const char *)_fillAnimationManagerWithActions, (uint64_t)&v32);
  }
  result = _C3DEntityGetSubAttributeArray((uint64_t)a1, CFSTR("kBindingsKey"), 0);
  if (result)
  {
    v24 = result;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    result = (const __CFDictionary *)-[__CFDictionary countByEnumeratingWithState:objects:count:](result, "countByEnumeratingWithState:objects:count:", &v28, &v32, 16);
    if (result)
    {
      v25 = result;
      v26 = *(_QWORD *)v29;
      do
      {
        v27 = 0;
        do
        {
          if (*(_QWORD *)v29 != v26)
            objc_enumerationMutation(v24);
          C3DAnimationManagerAddBinding(AnimationManager, a1, (CFStringRef)objc_msgSend(*(id *)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)v27), "keyPathDst"), (float32x4_t *)objc_msgSend(*(id *)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)v27), "sourceObject"), (const __CFString *)objc_msgSend(*(id *)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)v27), "keyPathSrc"), (void *)objc_msgSend(*(id *)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)v27), "options"));
          v27 = (const __CFDictionary *)((char *)v27 + 1);
        }
        while (v25 != v27);
        result = (const __CFDictionary *)-[__CFDictionary countByEnumeratingWithState:objects:count:](v24, "countByEnumeratingWithState:objects:count:", &v28, &v32, 16);
        v25 = result;
      }
      while (result);
    }
  }
  return result;
}

const __CFDictionary *_C3DEntityGetSubAttributeOrderedDictionary(uint64_t a1, void *key, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFDictionary *v14;
  const __CFDictionary *Value;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  v14 = *(const __CFDictionary **)(a1 + 40);
  if (v14)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v14, key);
    if (Value)
      return Value;
  }
  else
  {
    Value = 0;
  }
  if (a3)
  {
    Value = (const __CFDictionary *)C3DOrderedDictionaryCreate();
    _C3DEntitySetAttribute((CFTypeRef *)a1, key, Value, 1);
    if (CFGetRetainCount(Value) <= 1)
    {
      v16 = scn_default_log();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
        _C3DEntityGetSubAttributeOrderedDictionary_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
    }
    CFRelease(Value);
  }
  return Value;
}

uint64_t C3DSceneGetAnimationManager(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 72);
}

const __CFDictionary *_C3DEntityGetSubAttributeArray(uint64_t a1, void *key, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFDictionary *v14;
  const __CFDictionary *Value;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  v14 = *(const __CFDictionary **)(a1 + 40);
  if (v14)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v14, key);
    if (Value)
      return Value;
  }
  else
  {
    Value = 0;
  }
  if (a3)
  {
    Value = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    _C3DEntitySetAttribute((CFTypeRef *)a1, key, Value, 1);
    CFRelease(Value);
  }
  return Value;
}

void __UpdateCullingHandle(uint64_t a1, uint64_t a2)
{
  int ShouldBePutInCullingSystem;
  int v5;
  __C3DCullingSystem *CullingSystem;
  int v7;
  uint64_t TransformTree;

  ShouldBePutInCullingSystem = C3DNodeShouldBePutInCullingSystem(a1);
  if (((ShouldBePutInCullingSystem ^ (*(_DWORD *)(a1 + 216) == -1)) & 1) == 0)
  {
    v5 = ShouldBePutInCullingSystem;
    CullingSystem = (__C3DCullingSystem *)C3DSceneGetCullingSystem(a2);
    if (v5)
    {
      v7 = C3DCullingSystemAdd(CullingSystem, (__C3DNode *)a1);
    }
    else
    {
      C3DCullingSystemRemove(CullingSystem, *(_DWORD *)(a1 + 216));
      v7 = -1;
    }
    *(_DWORD *)(a1 + 216) = v7;
    TransformTree = C3DSceneGetTransformTree(a2);
    C3DTransformTreeUpdateCullingHandle(TransformTree, *(_DWORD *)(a1 + 88), *(_DWORD *)(a1 + 216));
  }
}

void _C3DNodeWasAddedToScene(uint64_t a1, uint64_t a2)
{
  __C3DTransformTree *TransformTree;
  uint64_t v5;
  int v6;

  TransformTree = (__C3DTransformTree *)C3DSceneGetTransformTree(a2);
  v5 = *(_QWORD *)(a1 + 64);
  if (v5)
    v6 = *(_DWORD *)(v5 + 88);
  else
    v6 = -1;
  *(_DWORD *)(a1 + 88) = C3DTransformTreeAddNode(TransformTree, (__C3DNode *)a1, v6);
  __UpdateCullingHandle(a1, a2);
}

float32x4_t *C3DNodeGetWorldMatrix(float32x4_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t TransformTree;
  __C3DTransformTree *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v22;
  uint8_t v23[16];

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = a1[3].i64[0];
  if (!v10)
    return C3DTransformGetMatrixPtr(a1 + 6);
  TransformTree = C3DSceneGetTransformTree(v10);
  if (!TransformTree)
  {
    v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v23 = 0;
      _os_log_impl(&dword_1DCCB8000, v22, OS_LOG_TYPE_DEFAULT, "Warning: C3DNodeGetWorldMatrix - no transform tree", v23, 2u);
    }
    return C3DTransformGetMatrixPtr(a1 + 6);
  }
  v12 = (__C3DTransformTree *)TransformTree;
  if (a1[5].i32[2] == -1)
  {
    v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      C3DNodeGetWorldMatrix_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
  }
  return (float32x4_t *)C3DTransformTreeGetWorldTransformPtr(v12, a1[5].i32[2]);
}

uint64_t C3DSceneGetTransformTree(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 152);
}

uint64_t C3DTransformTreeGetWorldTransformPtr(__C3DTransformTree *this, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  int v17;

  if (!this)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DTransformTreeAddNode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (a2 == -1)
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      __C3DTransformTree::remove();
  }
  v13 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * a2);
  if (*((_BYTE *)this + 68))
    __C3DTransformTree::updateWorldTransforms(this);
  if (HIDWORD(v13) == 0xFFFFFFFF)
    LODWORD(v14) = 0;
  else
    v14 = HIDWORD(v13);
  if (HIDWORD(v13) == 0xFFFFFFFF)
    v15 = 0;
  else
    v15 = -1;
  if (v13 == 0xFFFFFFFFLL)
    LODWORD(v16) = v14;
  else
    v16 = HIDWORD(v13);
  if (v13 == 0xFFFFFFFFLL)
    v17 = v15;
  else
    v17 = v13;
  return *(_QWORD *)(*((_QWORD *)this + 7) + 80 * v17) + ((uint64_t)(int)v16 << 6);
}

void _C3DNodeFinalizeAddToScene(float32x4_t *a1)
{
  uint64_t v2;
  uint64_t Skinner;
  uint64_t v4;

  if (!a1[4].i64[0])
    __UpdateNodeVisibilityIfNeeded((uint64_t)a1, 1);
  v2 = a1[15].i64[1];
  if (v2)
  {
    Skinner = C3DDeformerStackGetSkinner(v2);
    if (Skinner)
    {
      v4 = Skinner;
      if (C3DGeometryGetOverrideMaterial(Skinner))
        C3DSkinnerUpdateJointsAndBoundingBox(v4, a1);
    }
  }
}

uint64_t _C3DNodeEnumerateSubEntities(_QWORD *a1, void (**a2)(_QWORD))
{
  const __CFDictionary *Attributes;
  uint64_t Morpher;
  uint64_t v6;
  uint64_t Skinner;
  const __CFArray *ParticleSystems;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t result;
  const __CFArray *v15;
  uint64_t v16;
  CFIndex j;
  const void *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[2];
  uint64_t (*v22)(uint64_t);
  void *v23;
  void (**v24)(_QWORD);

  Attributes = (const __CFDictionary *)C3DEntityGetAttributes((uint64_t)a1);
  if (Attributes)
    CFDictionaryApplyFunction(Attributes, (CFDictionaryApplierFunction)_C3DNodeEnumerateAttributeEntities, a2);
  if (a1[30])
    a2[2](a2);
  Morpher = C3DNodeGetMorpher((uint64_t)a1);
  if (Morpher)
    ((void (*)(void (**)(_QWORD), uint64_t))a2[2])(a2, Morpher);
  v6 = a1[31];
  if (v6)
  {
    Skinner = C3DDeformerStackGetSkinner(v6);
    if (Skinner)
      ((void (*)(void (**)(_QWORD), uint64_t))a2[2])(a2, Skinner);
  }
  ParticleSystems = C3DNodeGetParticleSystems((uint64_t)a1);
  if (ParticleSystems)
  {
    v9 = ParticleSystems;
    Count = CFArrayGetCount(ParticleSystems);
    if (Count >= 1)
    {
      v11 = Count;
      for (i = 0; i != v11; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v9, i);
        ((void (*)(void (**)(_QWORD), const void *))a2[2])(a2, ValueAtIndex);
      }
    }
  }
  result = (uint64_t)C3DNodeGetConstraints((uint64_t)a1);
  if (result)
  {
    v15 = (const __CFArray *)result;
    result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      v16 = result;
      for (j = 0; j != v16; ++j)
      {
        v18 = CFArrayGetValueAtIndex(v15, j);
        result = ((uint64_t (*)(void (**)(_QWORD), const void *))a2[2])(a2, v18);
      }
    }
  }
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 0x40000000;
  v22 = ___C3DNodeEnumerateSubEntities_block_invoke;
  v23 = &unk_1EA5A1AC0;
  v24 = a2;
  v19 = a1[9];
  if (v19)
  {
    v20 = 0;
    do
    {
      result = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t))v22)(v21, v19, v20++);
      v19 = *(_QWORD *)(v19 + 80);
    }
    while (v19);
  }
  return result;
}

__C3DMesh *C3DNodeGetPresentationMesh(uint64_t a1)
{
  uint64_t v2;
  uint64_t Skinner;
  uint64_t Morpher;

  if (!*(_QWORD *)(a1 + 240))
    return 0;
  v2 = *(_QWORD *)(a1 + 248);
  if (v2)
  {
    Skinner = C3DDeformerStackGetSkinner(v2);
    if (Skinner)
      return (__C3DMesh *)C3DSkinnerGetSkinnedMeshLegacy(Skinner, a1);
  }
  Morpher = C3DNodeGetMorpher(a1);
  if (Morpher)
    return (__C3DMesh *)C3DMorpherGetMorphedMeshLegacy(Morpher);
  else
    return C3DGeometryGetRenderingMesh(*(__C3DGeometry **)(a1 + 240));
}

uint64_t C3DNodeGetMorpher(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = *(_QWORD *)(a1 + 248);
  if (result)
    return C3DDeformerStackGetMorpher(result);
  return result;
}

uint64_t C3DEntityGetAttributes(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 40);
}

uint64_t C3DTransformTreeAddNode(__C3DTransformTree *this, __C3DNode *a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (!this)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DTransformTreeAddNode_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  return __C3DTransformTree::add(this, a2, a3);
}

uint64_t __C3DTransformTree::add(__C3DTransformTree *this, __C3DNode *a2, int a3)
{
  int *v5;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int *v14;
  uint64_t v15;
  char *v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  unint64_t v23;
  int *v24;
  char *v25;
  int v26;
  unint64_t v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _OWORD *v41;
  uint64_t v42;
  uint64_t v43;
  _OWORD v45[4];

  if (a3 == -1)
  {
    v6 = -1;
    v7 = -1;
  }
  else
  {
    v5 = (int *)(*((_QWORD *)this + 3) + 8 * a3);
    v6 = *v5;
    v7 = v5[1];
  }
  v8 = v6;
  v9 = v6 + 1;
  if ((int)v9 >= *((_DWORD *)this + 16))
    __C3DTransformTree::_setLevelCount(this, v6 + 2);
  v10 = *((_QWORD *)this + 7);
  v11 = v10 + 80 * v9;
  v13 = *(_DWORD *)(v11 + 72);
  v12 = *(_DWORD *)(v11 + 76);
  v14 = (int *)(v11 + 72);
  if (v13 == v12)
  {
    C3DTransformLevel::allocateData((C3DTransformLevel *)(v10 + 80 * v9), 2 * v13);
    v13 = *v14;
  }
  v15 = v10 + 80 * v9;
  v18 = *(char **)(v15 + 24);
  v17 = (_QWORD *)(v15 + 24);
  v16 = v18;
  v19 = v13;
  if (!v13)
    goto LABEL_16;
  v20 = v13;
  v21 = v16;
  v22 = &v16[4 * v13];
  do
  {
    v23 = v20 >> 1;
    v24 = (int *)&v21[4 * (v20 >> 1)];
    v26 = *v24;
    v25 = (char *)(v24 + 1);
    v20 += ~(v20 >> 1);
    if (v7 < v26)
      v20 = v23;
    else
      v21 = v25;
  }
  while (v20);
  if (v21 == v22)
  {
LABEL_16:
    v27 = 4 * v19;
  }
  else
  {
    v27 = v21 - v16;
    __C3DTransformTree::_offset((uint64_t)this, v9 | ((unint64_t)((unint64_t)(v21 - v16) >> 2) << 32), v8 | ((unint64_t)v7 << 32), 1);
  }
  if ((v27 >> 2) == -1)
  {
    v28 = scn_default_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
      __C3DTransformTree::add(v28, v29, v30, v31, v32, v33, v34, v35);
  }
  ++*v14;
  v36 = (_QWORD *)(v10 + 80 * v9);
  *(_QWORD *)(v36[5] + ((uint64_t)(v27 << 30) >> 29)) = a2;
  v37 = (uint64_t)(v27 << 30) >> 30;
  *(_DWORD *)(v36[7] + v37) = *((_DWORD *)a2 + 54);
  *(_DWORD *)(*v17 + v37) = v7;
  *(_DWORD *)(v36[4] + v37) = -1;
  C3DNodeGetMatrix((uint64_t)a2, (uint64_t)v45);
  v38 = v45[1];
  v39 = v45[2];
  v40 = v45[3];
  v41 = (_OWORD *)(v36[2] + ((uint64_t)(v27 << 30) >> 26));
  *v41 = v45[0];
  v41[1] = v38;
  v41[2] = v39;
  v41[3] = v40;
  __C3DTransformTree::updateWorldTransformOnInsertion((uint64_t)this, v9 | (v27 << 30));
  v42 = __C3DTransformTree::_newHandle((uint64_t)this, v9 | (v27 << 30));
  *(_DWORD *)(v36[6] + v37) = v42;
  if (v8 != -1)
  {
    v43 = *(_QWORD *)(*((_QWORD *)this + 7) + 80 * (int)v8 + 32);
    if (*(_DWORD *)(v43 + 4 * v7) == -1)
      *(_DWORD *)(v43 + 4 * v7) = v27 >> 2;
  }
  __C3DTransformTree::_fixupParentAndSiblings((uint64_t)this, v9 | (v27 << 30), v8 | ((unint64_t)v7 << 32), -1);
  ++*((_DWORD *)this + 18);
  return v42;
}

__n128 __C3DTransformTree::updateWorldTransformOnInsertion(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  __int128 *v7;
  _OWORD *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float32x4_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __n128 result;
  __int128 v22;
  __int128 v23;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = a2;
  v4 = (_QWORD *)(v2 + 80 * (int)a2);
  v5 = a2 >> 32;
  v6 = a2 - 1;
  if ((_DWORD)a2 == 0x100000000)
  {
    v7 = (__int128 *)(*(_QWORD *)(v2 + 80 * (int)a2 + 16) + (v5 << 6));
    v8 = (_OWORD *)(*v4 + (v5 << 6));
    v9 = *v7;
    v10 = v7[1];
    v11 = v7[3];
    v8[2] = v7[2];
    v8[3] = v11;
    *v8 = v9;
    v8[1] = v10;
  }
  else
  {
    v13 = v2 + 80 * (int)a2;
    v14 = *(int *)(*(_QWORD *)(v13 + 24) + 4 * v5);
    __C3DTransformTree::updateWorldTransformOnInsertion();
    v15 = 0;
    v16 = (float32x4_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * v6) + (v14 << 6));
    v17 = *v4 + (v5 << 6);
    v18 = *(_QWORD *)(v13 + 16) + (v5 << 6);
    do
    {
      *(float32x4_t *)(v17 + v15) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v16[1], *(float32x2_t *)(v18 + v15), 1), *v16, COERCE_FLOAT(*(_OWORD *)(v18 + v15))), v16[2], *(float32x4_t *)(v18 + v15), 2), v16[3], *(float32x4_t *)(v18 + v15), 3);
      v15 += 16;
    }
    while (v15 != 64);
  }
  v19 = *v4 + (v5 << 6);
  v20 = *(_QWORD *)(v2 + 80 * v3 + 8) + (v5 << 6);
  result = *(__n128 *)v19;
  v22 = *(_OWORD *)(v19 + 16);
  v23 = *(_OWORD *)(v19 + 48);
  *(_OWORD *)(v20 + 32) = *(_OWORD *)(v19 + 32);
  *(_OWORD *)(v20 + 48) = v23;
  *(__n128 *)v20 = result;
  *(_OWORD *)(v20 + 16) = v22;
  return result;
}

void __C3DTransformTree::_fixupParentAndSiblings(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v6;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v6 = HIDWORD(a2);
  if ((_DWORD)a3 + 1 != (_DWORD)a2)
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      __C3DTransformTree::_fixupParentAndSiblings(v8, v9, v10, v11, v12, v13, v14, v15);
  }
  if ((_DWORD)a3 != -1)
  {
    v16 = *(_QWORD *)(a1 + 56);
    if (v16)
    {
      v17 = *(_QWORD *)(v16 + 80 * (int)a3 + 32);
      if (*(_DWORD *)(v17 + 4 * (a3 >> 32)) == a4)
        *(_DWORD *)(v17 + 4 * (a3 >> 32)) = v6;
    }
  }
}

uint64_t __C3DTransformTree::_newHandle(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  result = *(unsigned int *)(a1 + 48);
  if ((_DWORD)result == -1)
  {
    v6 = *(_QWORD *)(a1 + 40);
    v7 = *(_QWORD **)(a1 + 32);
    if ((unint64_t)v7 >= v6)
    {
      v9 = *(_QWORD *)(a1 + 24);
      v10 = ((uint64_t)v7 - v9) >> 3;
      if ((unint64_t)(v10 + 1) >> 61)
        abort();
      v11 = v6 - v9;
      v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1))
        v12 = v10 + 1;
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
        v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>(a1 + 40, v13);
      else
        v14 = 0;
      v15 = &v14[8 * v10];
      v16 = &v14[8 * v13];
      *(_QWORD *)v15 = a2;
      v8 = v15 + 8;
      v18 = *(char **)(a1 + 24);
      v17 = *(char **)(a1 + 32);
      if (v17 != v18)
      {
        do
        {
          v19 = *((_QWORD *)v17 - 1);
          v17 -= 8;
          *((_QWORD *)v15 - 1) = v19;
          v15 -= 8;
        }
        while (v17 != v18);
        v17 = *(char **)(a1 + 24);
      }
      *(_QWORD *)(a1 + 24) = v15;
      *(_QWORD *)(a1 + 32) = v8;
      *(_QWORD *)(a1 + 40) = v16;
      if (v17)
        operator delete(v17);
    }
    else
    {
      *v7 = a2;
      v8 = v7 + 1;
    }
    *(_QWORD *)(a1 + 32) = v8;
    return (((unint64_t)v8 - *(_QWORD *)(a1 + 24)) >> 3) - 1;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 24) + 8 * (int)result;
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(v5 + 4);
    *(_QWORD *)v5 = a2;
  }
  return result;
}

const __CFDictionary *C3DNodeGetParticleSystems(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 222) & 4) != 0)
    return C3DEntityGetAttribute(a1, CFSTR("kParticleSystem"));
  else
    return 0;
}

const __CFDictionary *C3DNodeGetConstraints(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 222) & 1) != 0)
    return C3DEntityGetAttribute(a1, CFSTR("kConstraints"));
  else
    return 0;
}

uint64_t C3DSceneGetCullingSystem(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 144);
}

CFIndex _C3DGeometryEnumerateSubEntities(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  const void *ValueAtIndex;
  CFIndex result;
  CFIndex v10;
  CFIndex j;
  const void *v12;

  if (*(_QWORD *)(a1 + 64))
    (*(void (**)(uint64_t))(a2 + 16))(a2);
  v4 = *(const __CFArray **)(a1 + 80);
  if (v4)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
    if (Count >= 1)
    {
      v6 = Count;
      for (i = 0; i != v6; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v4, i);
        (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex);
      }
    }
  }
  result = *(_QWORD *)(a1 + 96);
  if (result)
  {
    result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      v10 = result;
      for (j = 0; j != v10; ++j)
      {
        v12 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), j);
        result = (*(uint64_t (**)(uint64_t, const void *))(a2 + 16))(a2, v12);
      }
    }
  }
  return result;
}

void C3DTransformTreeUpdateCullingHandle(uint64_t a1, int a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  int *v15;
  uint64_t v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DTransformTreeAddNode_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  if (a2 == -1)
  {
    v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      __C3DTransformTree::remove();
  }
  v15 = (int *)(*(_QWORD *)(a1 + 24) + 8 * a2);
  v16 = v15[1];
  if ((_DWORD)v16 != -1)
  {
    v17 = *v15;
    if (*v15 >= *(_DWORD *)(a1 + 64))
    {
      v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
        C3DTransformTreeUpdateCullingHandle_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 80 * v17 + 56) + 4 * v16) = a3;
  }
}

uint64_t C3DCullingSystemAdd(__C3DCullingSystem *a1, __C3DNode *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DCullingSystemAdd_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return __C3DCullingSystem::add(a1, a2);
}

uint64_t __C3DCullingSystem::add(__C3DCullingSystem *this, __C3DNode *a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  __int128 v7;
  _OWORD *v8;
  _OWORD v10[2];

  v5 = *((_DWORD *)this + 4);
  v4 = *((_DWORD *)this + 5);
  if (v5 >= v4)
  {
    __C3DCullingSystem::_allocateData(this, 2 * v4);
    v5 = *((_DWORD *)this + 4);
  }
  *((_DWORD *)this + 4) = v5 + 1;
  v6 = __C3DCullingSystem::_newHandle(this, v5);
  C3DNodeGetLocalBoundingBox((uint64_t)a2, v10);
  v7 = v10[1];
  v8 = (_OWORD *)(*((_QWORD *)this + 8) + 32 * v5);
  *v8 = v10[0];
  v8[1] = v7;
  *(_QWORD *)(*((_QWORD *)this + 13) + 8 * v5) = a2;
  __C3DCullingSystem::_updateNodeMasksAtIndex((uint64_t)this, v5);
  __C3DCullingSystem::_updateWorldAABBAtIndex(this, v5);
  return v6;
}

uint64_t __C3DCullingSystem::_updateWorldAABBAtIndex(__C3DCullingSystem *this, unsigned int a2)
{
  float32x4_t *WorldMatrix;
  float32x4_t *v5;
  float32x4_t v6;
  float32x4_t v7;
  __n128 v8;
  float32x4_t v9;
  __n128 v10;

  if ((*(_WORD *)(*((_QWORD *)this + 11) + 2 * a2) & 0x10) != 0)
  {
    v10 = (__n128)xmmword_1DD007E60;
    v8 = *(__n128 *)(MEMORY[0x1E0C83FF0] + 48);
  }
  else
  {
    WorldMatrix = C3DNodeGetWorldMatrix(*(float32x4_t **)(*((_QWORD *)this + 13) + 8 * a2));
    v5 = (float32x4_t *)(*((_QWORD *)this + 8) + 32 * a2);
    v6 = WorldMatrix[1];
    v7 = WorldMatrix[2];
    v8 = (__n128)vaddq_f32(WorldMatrix[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v6, *(float32x2_t *)v5->f32, 1), *WorldMatrix, COERCE_FLOAT(*v5)), v7, *v5, 2));
    v8.n128_u32[3] = 1.0;
    v9 = v5[1];
    v9.i32[1] = v9.i32[0];
    v9.i32[2] = (__int32)v5[1];
    v10 = (__n128)vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(*WorldMatrix, v9)), vabsq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v5[1].f32, 1), (int32x4_t)v5[1]), v6))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v5[1], (int32x4_t)v5[1]), (int32x4_t)v5[1]), v7)));
  }
  return __C3DCullingSystem::_setWorldAABBAtIndex((uint64_t)this, a2, v8, v10);
}

uint64_t __C3DCullingSystem::_newHandle(__C3DCullingSystem *this, int a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  _DWORD *v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  int v17;

  result = *((unsigned int *)this + 14);
  if ((_DWORD)result == -1)
  {
    v6 = *((_QWORD *)this + 6);
    v7 = (char *)*((_QWORD *)this + 5);
    if ((unint64_t)v7 >= v6)
    {
      v9 = (char *)*((_QWORD *)this + 4);
      v10 = (v7 - v9) >> 2;
      v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 62)
        abort();
      v12 = v6 - (_QWORD)v9;
      if (v12 >> 1 > v11)
        v11 = v12 >> 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
        v13 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v13 = v11;
      if (v13)
      {
        v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)this + 48, v13);
        v9 = (char *)*((_QWORD *)this + 4);
        v7 = (char *)*((_QWORD *)this + 5);
      }
      else
      {
        v14 = 0;
      }
      v15 = &v14[4 * v10];
      v16 = &v14[4 * v13];
      *(_DWORD *)v15 = a2;
      v8 = v15 + 4;
      while (v7 != v9)
      {
        v17 = *((_DWORD *)v7 - 1);
        v7 -= 4;
        *((_DWORD *)v15 - 1) = v17;
        v15 -= 4;
      }
      *((_QWORD *)this + 4) = v15;
      *((_QWORD *)this + 5) = v8;
      *((_QWORD *)this + 6) = v16;
      if (v9)
        operator delete(v9);
    }
    else
    {
      *(_DWORD *)v7 = a2;
      v8 = v7 + 4;
    }
    *((_QWORD *)this + 5) = v8;
    return (((unint64_t)v8 - *((_QWORD *)this + 4)) >> 2) - 1;
  }
  else
  {
    v5 = *((_QWORD *)this + 4);
    *((_DWORD *)this + 14) = *(_DWORD *)(v5 + 4 * (int)result);
    *(_DWORD *)(v5 + 4 * (int)result) = a2;
  }
  return result;
}

uint64_t C3DNodeGetLocalBoundingBox(uint64_t a1, _OWORD *a2)
{
  __int128 v2;

  v2 = *(_OWORD *)(a1 + 288);
  *a2 = *(_OWORD *)(a1 + 272);
  a2[1] = v2;
  return vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(a1 + 288))) >> 31;
}

void __C3DMeshElementSetPrimitiveRanges(uint64_t a1, void *a2)
{
  unsigned __int16 v4;
  __int16 v5;
  void *v6;
  _QWORD v7[5];

  v4 = objc_msgSend(a2, "count");
  v5 = v4;
  if (v4)
  {
    v6 = malloc_type_malloc(16 * v4, 0x1000040451B5BE8uLL);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ____C3DMeshElementSetPrimitiveRanges_block_invoke;
    v7[3] = &__block_descriptor_40_e24_v32__0__NSValue_8Q16_B24l;
    v7[4] = v6;
    objc_msgSend(a2, "enumerateObjectsUsingBlock:", v7);
  }
  else
  {
    v6 = 0;
  }
  C3DMeshElementSetPrimitiveRangesNoCopy(a1, (uint64_t)v6, v5);
}

void C3DMeshElementSetPrimitiveRangesNoCopy(uint64_t a1, uint64_t a2, __int16 a3)
{
  free(*(void **)(a1 + 120));
  *(_QWORD *)(a1 + 120) = a2;
  *(_WORD *)(a1 + 128) = a3;
}

void C3DMeshElementInitIndexed(uint64_t a1, char a2, int a3, char a4, char a5, const void *a6, char a7)
{
  C3DMeshElementSetType(a1, a2);
  *(_BYTE *)(a1 + 130) = a4;
  *(_BYTE *)(a1 + 131) = a5;
  *(_DWORD *)(a1 + 104) = a3;
  __SetIndexes(a1, a6, a7);
  free(*(void **)(a1 + 120));
  *(_QWORD *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 128) = 0;
}

void __SetIndexes(uint64_t a1, CFTypeRef cf, char a3)
{
  CFTypeRef v3;
  CFTypeRef v5;
  void *v6;
  CFIndex Length;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  const void *v11;

  v3 = cf;
  *(_BYTE *)(a1 + 80) = a3;
  v5 = *(CFTypeRef *)(a1 + 96);
  if (v5 != cf)
  {
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 96) = 0;
    }
    if (v3)
      v3 = CFRetain(v3);
    *(_QWORD *)(a1 + 96) = v3;
  }
  v6 = *(void **)(a1 + 112);
  if (v6)
  {
    free(v6);
    *(_QWORD *)(a1 + 112) = 0;
    v3 = *(CFTypeRef *)(a1 + 96);
  }
  if (v3)
  {
    Length = CFDataGetLength((CFDataRef)v3);
    v8 = *(unsigned int *)(a1 + 64);
    v9 = *(unsigned __int8 *)(a1 + 80);
    if (Length < v8 + C3DMeshElementGetIndexCount(a1) * v9)
    {
      v10 = scn_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        __SetIndexes_cold_1();
      v11 = *(const void **)(a1 + 96);
      if (v11)
      {
        CFRelease(v11);
        *(_QWORD *)(a1 + 96) = 0;
      }
    }
  }
}

uint64_t C3DMeshElementGetIndexCountWithTypeAndPrimitiveCount(int a1, uint64_t a2)
{
  NSObject *v2;

  switch(a1)
  {
    case 0:
      a2 *= 3;
      break;
    case 1:
    case 5:
      a2 += 2;
      break;
    case 2:
      a2 *= 2;
      break;
    case 3:
      return a2;
    default:
      v2 = scn_default_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        C3DMeshElementGetIndexCountWithTypeAndPrimitiveCount_cold_1();
      a2 = 0;
      break;
  }
  return a2;
}

void C3DMeshElementSetType(uint64_t a1, char a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_BYTE *)(a1 + 88) = a2;
}

uint64_t C3DMeshElementCreate()
{
  uint64_t Instance;
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (C3DMeshElementGetTypeID_onceToken != -1)
    dispatch_once(&C3DMeshElementGetTypeID_onceToken, &__block_literal_global_7);
  Instance = C3DTypeCreateInstance_(C3DMeshElementGetTypeID_typeID, 0xD0uLL);
  if (!Instance)
  {
    v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
  }
  *(_BYTE *)(Instance + 88) = 0;
  *(_QWORD *)(Instance + 96) = 0;
  *(_DWORD *)(Instance + 128) = 0x10000;
  *(_QWORD *)(Instance + 112) = 0;
  *(_QWORD *)(Instance + 120) = 0;
  *(_DWORD *)(Instance + 68) = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(Instance + 144) = _D0;
  *(_DWORD *)(Instance + 152) = 1065353216;
  return Instance;
}

uint64_t C3DNodeApplyHierarchy(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  if (result)
  {
    v3 = (_QWORD *)result;
    v4 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, result);
    if (v4 == 2)
      return 1;
    v5 = v3;
    while (1)
    {
      if (v4 == 1 || (v6 = (_QWORD *)v5[9]) == 0)
      {
        if (v5 == v3)
          return 0;
        while (1)
        {
          v6 = (_QWORD *)v5[10];
          if (v6)
            break;
          v5 = (_QWORD *)v5[8];
          if (v5)
            v7 = v5 == v3;
          else
            v7 = 1;
          if (v7)
            return 0;
        }
      }
      v4 = (*(uint64_t (**)(uint64_t, _QWORD *))(a2 + 16))(a2, v6);
      v5 = v6;
      if (v4 == 2)
        return 1;
    }
  }
  return result;
}

const __CFDictionary *C3DNodeGetLight(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 221) & 2) != 0)
    return C3DEntityGetAttribute(a1, CFSTR("kLightKey"));
  else
    return 0;
}

uint64_t C3DNodeShouldBePutInCullingSystem(uint64_t a1)
{
  int v1;
  const __CFDictionary *Light;

  if (*(_QWORD *)(a1 + 240))
    return 1;
  v1 = *(_DWORD *)(a1 + 220);
  if ((v1 & 0x6000) != 0)
    return 1;
  if ((v1 & 0x200) == 0)
    return 0;
  Light = C3DNodeGetLight(a1);
  return C3DLightGetDrawsArea((uint64_t)Light);
}

void *C3DSceneNodeWasAdded(uint64_t a1, float32x4_t *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int32 v20;
  const __CFArray *AudioPlayers;
  const __CFArray *v22;
  CFIndex Count;
  CFIndex v24;
  CFIndex i;
  void *ValueAtIndex;
  NSObject *v27;
  void *result;
  _QWORD *ParticleManager;
  uint8_t v30[4];
  _DWORD v31[7];

  *(_QWORD *)&v31[5] = *MEMORY[0x1E0C80C00];
  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DGeometryTrackNode_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  if (!a1)
    goto LABEL_14;
  v20 = a2[13].i32[3];
  if ((v20 & 0x10000) != 0)
  {
    C3DSceneRegisterNodeConstrains(a1, a2);
    v20 = a2[13].i32[3];
    if ((v20 & 0x40000) == 0)
    {
LABEL_9:
      if ((v20 & 0x40) == 0)
        goto LABEL_10;
      goto LABEL_26;
    }
  }
  else if ((v20 & 0x40000) == 0)
  {
    goto LABEL_9;
  }
  ParticleManager = C3DSceneGetParticleManager(a1, 1);
  C3DParticleManagerRegisterSystem((uint64_t)ParticleManager, a2);
  v20 = a2[13].i32[3];
  if ((v20 & 0x40) == 0)
  {
LABEL_10:
    if ((v20 & 0x100000) == 0)
      goto LABEL_11;
    goto LABEL_27;
  }
LABEL_26:
  C3DSceneRegisterNodePhysicsBody((id *)a1, (id *)a2);
  v20 = a2[13].i32[3];
  if ((v20 & 0x100000) == 0)
  {
LABEL_11:
    if ((v20 & 0x4000) == 0)
      goto LABEL_12;
LABEL_28:
    C3DSceneRegisterNodeFilters((CFTypeRef *)a1, a2);
    if ((a2[13].i32[3] & 0x200) == 0)
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_27:
  C3DSceneRegisterNodePhysicsField((id *)a1, (id *)a2);
  v20 = a2[13].i32[3];
  if ((v20 & 0x4000) != 0)
    goto LABEL_28;
LABEL_12:
  if ((v20 & 0x200) != 0)
LABEL_13:
    C3DLightingSystemAdd(*(_QWORD *)(a1 + 128), a2);
LABEL_14:
  AudioPlayers = C3DNodeGetAudioPlayers((uint64_t)a2);
  if (AudioPlayers)
  {
    v22 = AudioPlayers;
    Count = CFArrayGetCount(AudioPlayers);
    if (Count >= 1)
    {
      v24 = Count;
      for (i = 0; i != v24; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v22, i);
        if (!ValueAtIndex)
        {
          v27 = scn_default_log();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
            C3DSceneNodeWasAdded_cold_1(v30, v31, v27);
        }
        C3DAudioManagerAddVoice(ValueAtIndex);
      }
    }
  }
  result = *(void **)(a1 + 416);
  if (result)
    return (void *)C3DAuthoringEnvironment2NodeAddedToScene(result, (id *)a2);
  return result;
}

uint64_t C3DNodeGetFloor(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 221) & 0x10) != 0)
    return C3DNodeGetGeometry(a1);
  else
    return 0;
}

const __CFDictionary *C3DNodeGetAudioPlayers(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 222) & 8) != 0)
    return C3DEntityGetAttribute(a1, CFSTR("kAudioPlayer"));
  else
    return 0;
}

uint64_t C3DCullingSystemUpdateFlags(__C3DCullingSystem *this, unsigned int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;

  if (!this && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DCullingSystemAdd_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if ((a2 & 0x80000000) == 0)
    {
LABEL_4:
      if (a2 < (unint64_t)((uint64_t)(*((_QWORD *)this + 5) - *((_QWORD *)this + 4)) >> 2))
        return __C3DCullingSystem::_updateNodeMasksAtIndex((uint64_t)this, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * (int)a2));
    }
  }
  else if ((a2 & 0x80000000) == 0)
  {
    goto LABEL_4;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DCullingSystemUpdateFlags_cold_1();
  return __C3DCullingSystem::_updateNodeMasksAtIndex((uint64_t)this, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * (int)a2));
}

void __C3DTransformTree::_setLevelCount(__C3DTransformTree *this, int a2)
{
  char *v4;
  char *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _OWORD *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  char *v15;
  _OWORD *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int v20;
  C3DTransformLevel *v21;
  unint64_t v22;
  uint64_t v23;

  if (*((_DWORD *)this + 16) != a2)
  {
    v4 = (char *)malloc_type_calloc(0x50uLL, a2, 0xC1404B04uLL);
    v5 = v4;
    v6 = *((_DWORD *)this + 16);
    if (v6 >= a2)
    {
      if (a2 < 1)
      {
        v20 = 0;
      }
      else
      {
        v14 = 0;
        do
        {
          v15 = &v4[v14];
          v16 = (_OWORD *)(*((_QWORD *)this + 7) + v14);
          *(_OWORD *)v15 = *v16;
          v17 = v16[1];
          v18 = v16[2];
          v19 = v16[4];
          *((_OWORD *)v15 + 3) = v16[3];
          *((_OWORD *)v15 + 4) = v19;
          *((_OWORD *)v15 + 1) = v17;
          *((_OWORD *)v15 + 2) = v18;
          v14 += 80;
        }
        while (80 * a2 != v14);
        v6 = *((_DWORD *)this + 16);
        v20 = a2;
      }
      if (v20 < v6)
      {
        v23 = 80 * v20;
        do
        {
          C3DTransformLevel::deallocateData((void **)(*((_QWORD *)this + 7) + v23));
          v23 += 80;
          ++v20;
        }
        while (*((_DWORD *)this + 16) > v20);
      }
    }
    else
    {
      if (v6 < 1)
      {
        LODWORD(v8) = 0;
      }
      else
      {
        v7 = 0;
        v8 = 0;
        do
        {
          v9 = &v4[v7];
          v10 = (_OWORD *)(*((_QWORD *)this + 7) + v7);
          *(_OWORD *)v9 = *v10;
          v11 = v10[1];
          v12 = v10[2];
          v13 = v10[4];
          *((_OWORD *)v9 + 3) = v10[3];
          *((_OWORD *)v9 + 4) = v13;
          *((_OWORD *)v9 + 1) = v11;
          *((_OWORD *)v9 + 2) = v12;
          ++v8;
          v7 += 80;
        }
        while (v8 < *((int *)this + 16));
      }
      if ((int)v8 < a2)
      {
        v21 = (C3DTransformLevel *)&v4[80 * v8];
        v22 = a2 - (unint64_t)v8;
        do
        {
          C3DTransformLevel::allocateData(v21, 0x80u);
          v21 = (C3DTransformLevel *)((char *)v21 + 80);
          --v22;
        }
        while (v22);
      }
    }
    free(*((void **)this + 7));
    *((_QWORD *)this + 7) = v5;
    *((_DWORD *)this + 16) = a2;
  }
}

double C3DTransformLevel::allocateData(C3DTransformLevel *this, unsigned int a2)
{
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  char *v8;
  size_t v9;
  void *v10;
  char *v11;
  void *v12;
  char *v13;
  int v14;
  uint64_t v15;
  void *v16;
  char *v17;
  int v18;
  void *v19;
  char *v20;
  uint64_t v21;
  void *v22;
  char *v23;
  size_t v24;
  void *v25;
  char *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  size_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  double result;
  void *memptr;

  v4 = (unint64_t)a2 << 6;
  v5 = *((int *)this + 19);
  v6 = v5 << 6;
  v7 = *(void **)this;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL))
    v8 = 0;
  else
    v8 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v8, v7, v5 << 6);
  v9 = (v4 - v6);
  if ((int)v9 >= 1)
    bzero(&v8[v6], (v4 - v6));
  if (v7)
    free(v7);
  *(_QWORD *)this = v8;
  v10 = (void *)*((_QWORD *)this + 1);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL))
    v11 = 0;
  else
    v11 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v11, v10, v5 << 6);
  if ((int)v9 >= 1)
    bzero(&v11[v6], (v4 - v6));
  if (v10)
    free(v10);
  *((_QWORD *)this + 1) = v11;
  v12 = (void *)*((_QWORD *)this + 2);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL))
    v13 = 0;
  else
    v13 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v13, v12, v5 << 6);
  v14 = 4 * a2;
  if ((int)v9 >= 1)
    bzero(&v13[v6], v9);
  v15 = 4 * v5;
  if (v12)
    free(v12);
  *((_QWORD *)this + 2) = v13;
  v16 = (void *)*((_QWORD *)this + 3);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL))
    v17 = 0;
  else
    v17 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v17, v16, 4 * v5);
  v18 = v14 - v15;
  if (v14 - (int)v15 >= 1)
    bzero(&v17[v15], (v14 - v15));
  if (v16)
    free(v16);
  *((_QWORD *)this + 3) = v17;
  v19 = (void *)*((_QWORD *)this + 4);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL))
    v20 = 0;
  else
    v20 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v20, v19, 4 * v5);
  if (v18 >= 1)
    bzero(&v20[v15], (v14 - v15));
  v21 = 8 * v5;
  if (v19)
    free(v19);
  *((_QWORD *)this + 4) = v20;
  v22 = (void *)*((_QWORD *)this + 5);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 8 * a2, 0xBA8A1232uLL))
    v23 = 0;
  else
    v23 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v23, v22, 8 * v5);
  v24 = 8 * a2 - v21;
  if ((int)v24 >= 1)
    bzero(&v23[v21], v24);
  if (v22)
    free(v22);
  *((_QWORD *)this + 5) = v23;
  v25 = (void *)*((_QWORD *)this + 6);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL))
    v26 = 0;
  else
    v26 = (char *)memptr;
  if ((_DWORD)v5)
    memcpy(v26, v25, 4 * v5);
  if (v18 >= 1)
    bzero(&v26[v15], (v14 - v15));
  if (v25)
    free(v25);
  *((_QWORD *)this + 6) = v26;
  v27 = (void *)*((_QWORD *)this + 7);
  v28 = *((int *)this + 19);
  v29 = 4 * v28;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL))
    v30 = 0;
  else
    v30 = (char *)memptr;
  if ((_DWORD)v28)
    memcpy(v30, v27, 4 * v28);
  v31 = (v14 - v29);
  if ((int)v31 >= 1)
    bzero(&v30[v29], v31);
  if (v27)
    free(v27);
  *((_QWORD *)this + 7) = v30;
  if ((int)v24 >= 1)
    bzero((void *)(*((_QWORD *)this + 5) + v21), v24);
  v32 = a2 - 1;
  v33 = *((unsigned int *)this + 19);
  v34 = *((_QWORD *)this + 3);
  if (v33 < v32)
  {
    do
    {
      *(_DWORD *)(v34 + 4 * v33) = v33 + 1;
      ++v33;
    }
    while (v32 != v33);
  }
  *(_DWORD *)(v34 + 4 * v32) = -1;
  *(_QWORD *)&result = 0x800000007FFFFFFFLL;
  *((_QWORD *)this + 8) = 0x800000007FFFFFFFLL;
  *((_DWORD *)this + 19) = a2;
  return result;
}

const __CFDictionary *C3DEntityHasAttribute(uint64_t a1, void *key)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFDictionary *result;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (key)
      goto LABEL_6;
  }
  else if (key)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DEntityGetAttribute_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  result = *(const __CFDictionary **)(a1 + 40);
  if (result)
    return (const __CFDictionary *)(CFDictionaryContainsKey(result, key) != 0);
  return result;
}

id _C3DMaterialCFFinalize(uint64_t a1)
{
  uint64_t SharedInstance;
  const void *v3;
  const void *v4;

  SharedInstance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, CFSTR("kC3DNotificationMaterialWillDie"), (const void *)a1, 0, 1u);
  v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v4 = *(const void **)(a1 + 72);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 72) = 0;
  }
  C3DRasterizerStatesRelease(*(CFTypeRef *)(a1 + 80));
  return C3DEntityCFFinalize(a1);
}

void _C3DEffectCommonProfileCFFinalize(_QWORD *a1)
{
  uint64_t SharedInstance;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;

  SharedInstance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, CFSTR("kC3DNotificationProfileWillDie"), a1, 0, 1u);
  if (a1)
  {
    v3 = (_QWORD *)a1[4];
    if (v3)
      v3[10] = 0;
    v4 = (_QWORD *)a1[5];
    if (v4)
      v4[10] = 0;
    v5 = a1[6];
    if (v5)
      *(_QWORD *)(v5 + 80) = 0;
    v6 = a1[7];
    if (v6)
      *(_QWORD *)(v6 + 80) = 0;
    v7 = a1[8];
    if (v7)
      *(_QWORD *)(v7 + 80) = 0;
    v8 = a1[9];
    if (v8)
      *(_QWORD *)(v8 + 80) = 0;
    v9 = a1[10];
    if (v9)
      *(_QWORD *)(v9 + 80) = 0;
    v10 = a1[11];
    if (v10)
      *(_QWORD *)(v10 + 80) = 0;
    v11 = a1[13];
    if (v11)
      *(_QWORD *)(v11 + 80) = 0;
    v12 = a1[12];
    if (v12)
      *(_QWORD *)(v12 + 80) = 0;
    v13 = a1[14];
    if (v13)
      *(_QWORD *)(v13 + 80) = 0;
    v14 = a1[15];
    if (v14)
      *(_QWORD *)(v14 + 80) = 0;
    v15 = a1[16];
    if (v15)
      *(_QWORD *)(v15 + 80) = 0;
    v16 = a1[17];
    if (v16)
      *(_QWORD *)(v16 + 80) = 0;
    v17 = a1[18];
    if (v17)
      *(_QWORD *)(v17 + 80) = 0;
    v18 = a1[19];
    if (v18)
      *(_QWORD *)(v18 + 80) = 0;
    if (v3)
    {
      CFRelease(v3);
      a1[4] = 0;
      v4 = (_QWORD *)a1[5];
    }
    if (v4)
    {
      CFRelease(v4);
      a1[5] = 0;
    }
    v19 = (const void *)a1[6];
    if (v19)
    {
      CFRelease(v19);
      a1[6] = 0;
    }
    v20 = (const void *)a1[7];
    if (v20)
    {
      CFRelease(v20);
      a1[7] = 0;
    }
    v21 = (const void *)a1[8];
    if (v21)
    {
      CFRelease(v21);
      a1[8] = 0;
    }
    v22 = (const void *)a1[9];
    if (v22)
    {
      CFRelease(v22);
      a1[9] = 0;
    }
    v23 = (const void *)a1[10];
    if (v23)
    {
      CFRelease(v23);
      a1[10] = 0;
    }
    v24 = (const void *)a1[11];
    if (v24)
    {
      CFRelease(v24);
      a1[11] = 0;
    }
    v25 = (const void *)a1[13];
    if (v25)
    {
      CFRelease(v25);
      a1[13] = 0;
    }
    v26 = (const void *)a1[12];
    if (v26)
    {
      CFRelease(v26);
      a1[12] = 0;
    }
    v27 = (const void *)a1[14];
    if (v27)
    {
      CFRelease(v27);
      a1[14] = 0;
    }
    v28 = (const void *)a1[15];
    if (v28)
    {
      CFRelease(v28);
      a1[15] = 0;
    }
    v29 = (const void *)a1[17];
    if (v29)
    {
      CFRelease(v29);
      a1[17] = 0;
    }
    v30 = (const void *)a1[18];
    if (v30)
    {
      CFRelease(v30);
      a1[18] = 0;
    }
    v31 = (const void *)a1[19];
    if (v31)
    {
      CFRelease(v31);
      a1[19] = 0;
    }
    v32 = (const void *)a1[16];
    if (v32)
    {
      CFRelease(v32);
      a1[16] = 0;
    }
  }
}

uint64_t C3DNotificationCenterGetSharedInstance()
{
  if (C3DNotificationCenterGetSharedInstance_onceToken != -1)
    dispatch_once(&C3DNotificationCenterGetSharedInstance_onceToken, &__block_literal_global_3_4);
  return C3DNotificationCenterGetSharedInstance_sharedInstance;
}

void C3DNotificationCenterPostNotification(uint64_t a1, const __CFString *a2, const void *a3, const __CFDictionary *a4, Boolean a5)
{
  __CFNotificationCenter *LocalCenter;

  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, a2, a3, a4, a5);
}

const __CFString *C3DCFTypeCopyModelInfoAtPath(float32x4_t *a1, CFStringRef theString, uint64_t a3)
{
  const __CFString *result;
  const __CFString *v6;
  uint64_t v7;

  result = C3DCreatePathComponentsFromString(theString);
  if (result)
  {
    v6 = result;
    v7 = C3DCFTypeCopyModelInfoAtSplittedPath(a1, (const __CFArray *)result, 0, a3);
    CFRelease(v6);
    return (const __CFString *)v7;
  }
  return result;
}

const __CFString *C3DCreatePathComponentsFromString(const __CFString *theString)
{
  if (theString)
    return (const __CFString *)CFStringCreateArrayBySeparatingStrings(0, theString, CFSTR("."));
  return theString;
}

uint64_t C3DCFTypeCopyModelInfoAtSplittedPath(float32x4_t *a1, const __CFArray *SubarrayWithRange, uint64_t a3, uint64_t a4)
{
  float32x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  CFIndex Count;
  uint64_t v11;
  void *v12;
  char v14;

  if (!a1)
    return 0;
  v7 = a1;
  v14 = 0;
  v8 = C3DModelTargetCreate(0, 0, 0, 0);
  v9 = C3DModelDescriptionResolveRootComponentInPath(SubarrayWithRange, v7, a3, &v14);
  if (v9)
    v7 = (float32x4_t *)v9;
  Count = CFArrayGetCount(SubarrayWithRange);
  v11 = Count;
  if (v14)
  {
    v11 = Count - 1;
    SubarrayWithRange = (const __CFArray *)C3DCFArrayGetSubarrayWithRange(SubarrayWithRange, (const char *)1, Count - 1);
  }
  v12 = (void *)CFGetTypeID(v7);
  _C3DModelPathResolverRegistryResolvePathWithClassName(v7, v12, SubarrayWithRange, 0, v11, v8, a4);
  if (*(_QWORD *)(v8 + 24))
    *(_BYTE *)(v8 + 36) = C3DSizeOfBaseType(*(__int16 *)(v8 + 32));
  return v8;
}

uint64_t _C3DModelPathResolverRegistryResolvePathWithClassName(float32x4_t *a1, void *a2, const __CFArray *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  void *ValueAtIndex;
  uint64_t v15;
  char *Gobo;
  uint64_t OverrideMaterial;
  const __CFDictionary *Type;
  const __CFDictionary *v19;
  const void *v20;
  _BYTE *Value;
  int v22;
  const void **v23;
  uint64_t v24;
  NSObject *v26;
  const void *v27;
  float32x4_t *v28;

  if ((void *)C3DEntityGetTypeID() == a2)
  {
    if ((_C3DModelPathResolveEntity(a1, a3, a4, a5, a6) & 1) != 0)
      return 1;
  }
  else if ((void *)C3DNodeGetTypeID() == a2)
  {
    if ((_C3DModelPathResolveNode(a1, a3, a4, a5, a6, a7) & 1) != 0)
      return 1;
  }
  else if ((void *)C3DMaterialGetTypeID() == a2)
  {
    if ((_C3DModelPathResolveMaterial((uint64_t)a1, a3, a4, a5, a6, a7) & 1) != 0)
      return 1;
  }
  else
  {
    if ((void *)C3DLightGetTypeID() == a2)
    {
      if (a1)
      {
        if ((_C3DModelPathResolveEntity(a1, a3, a4, a5, a6) & 1) == 0)
        {
          C3DModelTargetSetTarget(a6, a1);
          if ((int)a4 < (int)a5)
          {
            ValueAtIndex = (void *)CFArrayGetValueAtIndex(a3, (int)a4);
            switch(_pathComponentForString(ValueAtIndex))
            {
              case 'N':
                v15 = 1;
                Gobo = (char *)C3DLightGetGobo((uint64_t)a1, 1);
                goto LABEL_54;
              case 'O':
                v15 = 1;
                Gobo = (char *)C3DLightGetProbeEnvironment((uint64_t)a1, 1);
LABEL_54:
                C3DModelPathResolveCommonProfileProperty(Gobo, a3, a4 + 1, a5, a6, a7);
                return v15;
              case 'Q':
                v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                v28 = (float32x4_t *)((char *)a1 + 84);
                goto LABEL_61;
              case 'R':
                v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                v28 = (float32x4_t *)((char *)a1 + 88);
                goto LABEL_61;
              case 'S':
                v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                v28 = (float32x4_t *)((char *)a1 + 92);
                goto LABEL_61;
              case 'T':
                v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                v28 = (float32x4_t *)((char *)a1 + 244);
                goto LABEL_61;
              case 'U':
                v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                v28 = a1 + 15;
                goto LABEL_61;
              case 'V':
                v15 = 1;
                *(_WORD *)(a6 + 32) = 1;
                v28 = (float32x4_t *)((char *)a1 + 248);
LABEL_61:
                *(_QWORD *)(a6 + 24) = v28;
                break;
              default:
                goto LABEL_21;
            }
            return v15;
          }
          *(_QWORD *)(a6 + 24) = 0;
          *(_WORD *)(a6 + 32) = 0;
        }
        return 1;
      }
      goto LABEL_21;
    }
    if ((void *)C3DMorpherGetTypeID() == a2)
    {
      OverrideMaterial = C3DGeometryGetOverrideMaterial((uint64_t)a1);
    }
    else
    {
      if ((void *)C3DMorphGetTypeID() != a2)
      {
        if ((void *)C3DGeometryGetTypeID() == a2)
        {
          if ((_C3DModelPathResolveGeometry(a1, a3, a4, a5, a6, a7) & 1) != 0)
            return 1;
        }
        else if ((void *)C3DGenericSourceGetTypeID() == a2)
        {
          if ((_C3DModelPathResolveGenericSource(a1, a3, a4, a5, a6) & 1) != 0)
            return 1;
        }
        else if ((void *)C3DSceneGetTypeID() == a2)
        {
          if ((_C3DModelPathResolveScene(a1, a3, a4, a5, a6, a7) & 1) != 0)
            return 1;
        }
        else if ((void *)C3DFXTechniqueGetTypeID() == a2 && _C3DModelPathResolveTechnique(a1, a3, a4, a5, a6))
        {
          return 1;
        }
        goto LABEL_21;
      }
      OverrideMaterial = (uint64_t)a1;
    }
    if (_C3DModelPathResolveMorph(OverrideMaterial, a3, a4, a5, a6, a7))
      return 1;
  }
LABEL_21:
  os_unfair_lock_lock((os_unfair_lock_t)&_modelPathResolverRegistryLock);
  Type = (const __CFDictionary *)_C3DModelPathResolverRegistryGetType(a2);
  if ((int)a4 >= (int)a5 || (v19 = Type) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_modelPathResolverRegistryLock);
LABEL_29:
    v15 = 0;
    if (!(_DWORD)a7 || (_DWORD)a4 + 1 != (_DWORD)a5)
      return v15;
    v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      _C3DModelPathResolverRegistryResolvePathWithClassName_cold_1();
    return 0;
  }
  v20 = CFArrayGetValueAtIndex(a3, (int)a4);
  Value = CFDictionaryGetValue(v19, v20);
  os_unfair_lock_unlock((os_unfair_lock_t)&_modelPathResolverRegistryLock);
  if (!Value)
  {
    v27 = CFDictionaryGetValue(v19, CFSTR("superClass"));
    if (v27 && (_C3DModelPathResolverRegistryResolvePathWithClassName(a1, v27, a3, a4, a5, a6, a7) & 1) != 0)
      return 1;
    goto LABEL_29;
  }
  C3DModelTargetSetTarget(a6, a1);
  v22 = *((unsigned __int16 *)Value + 4);
  *(_WORD *)(a6 + 32) = v22;
  *(_BYTE *)(a6 + 34) = Value[10];
  v23 = (const void **)((char *)a1 + *(_QWORD *)Value);
  *(_QWORD *)(a6 + 24) = v23;
  *(_OWORD *)(a6 + 40) = *((_OWORD *)Value + 1);
  v24 = (a4 + 1);
  if ((int)v24 >= (int)a5)
    return 1;
  if (v22 != 5)
    return _C3DModelPathResolverRegistryResolveSubPath(a3, (int)a4 + 1, a5, a6);
  if (a1)
    return (uint64_t)_C3DModelPathResolverRegistryResolvePath(*v23, (uint64_t)a3, v24, a5, a6, a7);
  return 0;
}

uint64_t C3DEntityGetTypeID()
{
  if (C3DEntityGetTypeID_onceToken != -1)
    dispatch_once(&C3DEntityGetTypeID_onceToken, &__block_literal_global_96);
  return C3DEntityGetTypeID_typeID;
}

uint64_t C3DNodeGetTypeID()
{
  if (C3DNodeGetTypeID_onceToken != -1)
    dispatch_once(&C3DNodeGetTypeID_onceToken, &__block_literal_global_62);
  return C3DNodeGetTypeID_typeID;
}

uint64_t C3DModelTargetCreate(const void *a1, uint64_t a2, int a3, char a4)
{
  uint64_t Instance;
  uint64_t v9;

  if (C3DModelTargetGetTypeID_onceToken != -1)
    dispatch_once(&C3DModelTargetGetTypeID_onceToken, &__block_literal_global_128);
  Instance = C3DTypeCreateInstance_(C3DModelTargetGetTypeID_typeID, 0x28uLL);
  v9 = Instance;
  if (a1)
    C3DModelTargetSetTarget(Instance, a1);
  *(_QWORD *)(v9 + 24) = a2;
  *(_WORD *)(v9 + 32) = a3;
  *(_BYTE *)(v9 + 34) = a4;
  *(_BYTE *)(v9 + 36) = C3DSizeOfBaseType(a3);
  return v9;
}

uint64_t C3DMaterialCreate()
{
  uint64_t Instance;

  if (C3DMaterialGetTypeID_onceToken != -1)
    dispatch_once(&C3DMaterialGetTypeID_onceToken, &__block_literal_global_64);
  Instance = C3DTypeCreateInstance_(C3DMaterialGetTypeID_typeID, 0x58uLL);
  *(_QWORD *)(Instance + 64) = C3DEffectCommonProfileCreate(Instance);
  *(_BYTE *)(Instance + 100) = 0;
  *(_WORD *)(Instance + 92) = 3840;
  *(_DWORD *)(Instance + 88) = 257;
  __RasterizerStatesDidChange(Instance);
  return Instance;
}

uint64_t __RasterizerStatesDidChange(uint64_t a1)
{
  int v2;
  uint64_t result;
  _OWORD v4[2];
  _OWORD v5[2];

  C3DRasterizerStatesRelease(*(CFTypeRef *)(a1 + 80));
  memset(v5, 0, 28);
  C3DRasterizerStatesDescGetDefault(v5);
  if (*(_BYTE *)(a1 + 100))
    v2 = 2;
  else
    v2 = *(unsigned __int8 *)(a1 + 90);
  *(_QWORD *)&v5[0] = __PAIR64__(*(unsigned __int8 *)(a1 + 91), v2);
  BYTE8(v5[0]) = *(_BYTE *)(a1 + 89) != 0;
  BYTE9(v5[0]) = *(_BYTE *)(a1 + 88) != 0;
  v4[0] = v5[0];
  *(_OWORD *)((char *)v4 + 12) = *(_OWORD *)((char *)v5 + 12);
  result = C3DRasterizerStatesCreate((uint64_t)v4);
  *(_QWORD *)(a1 + 80) = result;
  return result;
}

void C3DRasterizerStatesRelease(CFTypeRef cf)
{
  if (cf)
  {
    if (*((_BYTE *)cf + 44))
    {
      os_unfair_lock_lock((os_unfair_lock_t)&s_RasterizerStatesRegistryLock);
      CFRelease(cf);
      os_unfair_lock_unlock((os_unfair_lock_t)&s_RasterizerStatesRegistryLock);
    }
    else
    {
      CFRelease(cf);
    }
  }
}

double C3DRasterizerStatesDescGetDefault@<D0>(_OWORD *a1@<X8>)
{
  double result;

  *a1 = kDefaultRasterizerStatesDesc;
  result = *(double *)((char *)&kDefaultRasterizerStatesDesc + 12);
  *(_OWORD *)((char *)a1 + 12) = *(__int128 *)((char *)&kDefaultRasterizerStatesDesc + 12);
  return result;
}

uint64_t C3DRasterizerStatesCreate(uint64_t a1)
{
  uint64_t Instance;
  __int128 v3;
  const void *Value;
  uint64_t v5;

  if (C3DRasterizerStatesCreate_once != -1)
    dispatch_once(&C3DRasterizerStatesCreate_once, &__block_literal_global_3_5);
  if (!*(_BYTE *)(a1 + 8))
    *(_BYTE *)(a1 + 10) = 1;
  if (*(_BYTE *)(a1 + 11))
  {
    if (*(_BYTE *)(a1 + 12))
      goto LABEL_10;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 13) = 16776961;
    *(_BYTE *)(a1 + 12) = 0;
  }
  *(_DWORD *)(a1 + 23) = 0;
  *(_DWORD *)(a1 + 20) = 16776961;
LABEL_10:
  os_unfair_lock_lock((os_unfair_lock_t)&s_RasterizerStatesRegistryLock);
  if (C3DRasterizerStatesGetTypeID_onceToken[0] != -1)
    dispatch_once(C3DRasterizerStatesGetTypeID_onceToken, &__block_literal_global_118);
  Instance = C3DTypeCreateInstance_(C3DRasterizerStatesGetTypeID_typeID, 0x20uLL);
  v3 = *(_OWORD *)(a1 + 12);
  *(_OWORD *)(Instance + 16) = *(_OWORD *)a1;
  *(_OWORD *)(Instance + 28) = v3;
  Value = CFSetGetValue((CFSetRef)s_RasterizerStatesRegistry, (const void *)Instance);
  if (Value)
  {
    v5 = (uint64_t)Value;
    CFRetain(Value);
    C3DRasterizerStatesRelease((CFTypeRef)Instance);
    Instance = v5;
  }
  else
  {
    CFSetSetValue((CFMutableSetRef)s_RasterizerStatesRegistry, (const void *)Instance);
    *(_BYTE *)(Instance + 44) = 1;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&s_RasterizerStatesRegistryLock);
  return Instance;
}

uint64_t C3DEffectCommonProfileCreate(uint64_t a1)
{
  uint64_t Instance;
  uint64_t v3;

  if (C3DEffectCommonProfileGetTypeID_onceToken != -1)
    dispatch_once(&C3DEffectCommonProfileGetTypeID_onceToken, &__block_literal_global_53);
  Instance = C3DTypeCreateInstance_(C3DEffectCommonProfileGetTypeID_typeID, 0xB8uLL);
  v3 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = a1;
    _C3DEffectCommonProfileSetDefaultValues(Instance);
  }
  return v3;
}

uint64_t _C3DEffectCommonProfileSetDefaultValues(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  uint64_t j;
  float v12;
  __int16 v13;
  uint64_t result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  C3DEffectCommonProfileSetLightingModel(a1, 3);
  for (i = 0; i != 16; ++i)
    _C3DEffectCommonProfileReleaseSlot((CFTypeRef *)a1, byte_1DD02A110[i]);
  for (j = 0; j != 5; ++j)
  {
    if (j == 4)
      v12 = 0.0;
    else
      v12 = 1.0;
    C3DEffectCommonProfileSetFloatProperty(a1, byte_1DD02A0B6[j], v12);
  }
  C3DEffectCommonProfileSetImageProxy(a1, 2, 0);
  *(_BYTE *)(a1 + 180) = 0;
  v13 = *(_WORD *)(a1 + 194);
  *(_QWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  *(_BYTE *)(a1 + 192) = 1;
  *(_WORD *)(a1 + 194) = v13 & 0xFE2C;
  result = C3DWasLinkedBeforeMajorOSYear2014();
  *(_BYTE *)(a1 + 193) = result ^ 1;
  return result;
}

void _C3DEffectCommonProfileReleaseSlot(CFTypeRef *a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef *v12;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      _C3DEffectCommonProfileReleaseSlot_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  switch(a2)
  {
    case 0:
      v12 = a1 + 4;
      goto LABEL_21;
    case 1:
      v12 = a1 + 5;
      goto LABEL_21;
    case 2:
      v12 = a1 + 6;
      goto LABEL_21;
    case 3:
      v12 = a1 + 7;
      goto LABEL_21;
    case 4:
      v12 = a1 + 8;
      goto LABEL_21;
    case 5:
      v12 = a1 + 9;
      goto LABEL_21;
    case 6:
      v12 = a1 + 10;
      goto LABEL_21;
    case 7:
      v12 = a1 + 11;
      goto LABEL_21;
    case 8:
      v12 = a1 + 13;
      goto LABEL_21;
    case 9:
      v12 = a1 + 12;
      goto LABEL_21;
    case 10:
      v12 = a1 + 14;
      goto LABEL_21;
    case 11:
      v12 = a1 + 15;
      goto LABEL_21;
    case 12:
      v12 = a1 + 17;
      goto LABEL_21;
    case 13:
      v12 = a1 + 18;
      goto LABEL_21;
    case 14:
      v12 = a1 + 19;
      goto LABEL_21;
    case 15:
      v12 = a1 + 16;
LABEL_21:
      if (*v12)
      {
        CFRelease(*v12);
        *v12 = 0;
      }
      break;
    default:
      return;
  }
}

void C3DEffectCommonProfileSetFloatProperty(uint64_t a1, int a2, float a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  BOOL v16;
  __int16 v17;
  float v18;
  float v19;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  switch(a2)
  {
    case 16:
      *(float *)(a1 + 160) = a3;
      goto LABEL_16;
    case 18:
      v14 = *(float *)(a1 + 164);
      if (v14 == a3)
        return;
      *(float *)(a1 + 164) = a3;
      v16 = v14 == 1.0 || v14 == 0.0 || a3 == 0.0;
      v17 = (a3 != 1.0) << 7;
      if (v16)
        v17 = 0;
      *(_WORD *)(a1 + 194) = *(_WORD *)(a1 + 194) & 0xFF7F | v17;
      goto LABEL_16;
    case 19:
      v18 = *(float *)(a1 + 168);
      if (v18 != a3)
      {
        *(float *)(a1 + 168) = a3;
        if (a3 == 0.0 || v18 == 0.0)
          goto LABEL_16;
      }
      return;
    case 20:
      v19 = *(float *)(a1 + 172);
      if (v19 == a3)
        return;
      *(float *)(a1 + 172) = a3;
      if (a3 == 0.0 || v19 == 0.0)
LABEL_16:
        __PostCommonProfileDidChangeNotification(a1);
      else
        C3DMaterialTouchValueStorageModificationCount(*(_QWORD *)(a1 + 16));
      return;
    default:
      return;
  }
}

void C3DEffectCommonProfileSetLightingModel(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (*(_DWORD *)(a1 + 24) != a2)
  {
    *(_DWORD *)(a1 + 24) = a2;
    __PostCommonProfileDidChangeNotification(a1);
  }
}

uint64_t C3DWasLinkedBeforeMajorOSYear2014()
{
  if (C3DWasLinkedBeforeMajorOSYear2014_onceToken != -1)
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2014_onceToken, &__block_literal_global_1);
  return C3DWasLinkedBeforeMajorOSYear2014_linkedBeforeMajorOSYear2014;
}

void C3DEffectCommonProfileSetImageProxy(uint64_t a1, int a2, const void *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t EffectSlot;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, a3 != 0);
  if (EffectSlot)
    C3DEffectSlotSetImageProxy(EffectSlot, a3);
  *(_WORD *)(a1 + 196) &= 0xE000u;
}

uint64_t C3DValueCreate(int a1, uint64_t a2)
{
  uint64_t Instance;
  uint64_t v5;
  size_t Length;

  if (!a2 || a1 && !C3DSizeOfBaseType(a1))
    return 0;
  if (C3DValueGetTypeID_onceToken != -1)
    dispatch_once(&C3DValueGetTypeID_onceToken, &__block_literal_global_93);
  Instance = C3DTypeCreateInstance_(C3DValueGetTypeID_typeID, 0x18uLL);
  v5 = Instance;
  *(_BYTE *)(Instance + 18) = 0;
  *(_WORD *)(Instance + 16) = a1;
  *(_QWORD *)(Instance + 32) = a2;
  if (a1)
  {
    Length = C3DValueGetLength(Instance);
    *(_QWORD *)(v5 + 24) = malloc_type_calloc(Length, 1uLL, 0xA137D7F8uLL);
  }
  return v5;
}

uint64_t C3DValueGetLength(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      __RemoveVRAMResourceFromDic_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 32) * C3DSizeOfBaseType(*(__int16 *)(a1 + 16));
}

uint64_t C3DSizeOfBaseType(int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 46)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSizeOfBaseType_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return __C3DSizeOfBaseTypeArray[a1];
}

uint64_t C3DModelDescriptionResolveRootComponentInPath(const __CFArray *a1, const void *a2, uint64_t a3, _BYTE *a4)
{
  const __CFString *ValueAtIndex;
  CFIndex Length;
  CFIndex v10;
  __CFString *v11;
  uint64_t EntryWithUniqueID;
  CFRange v14;

  if (a1
    && CFArrayGetCount(a1) >= 2
    && (ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, 0),
        Length = CFStringGetLength(ValueAtIndex),
        Length >= 2)
    && (v10 = Length, CFStringGetCharacterAtIndex(ValueAtIndex, 0) == 47))
  {
    if (a4)
      *a4 = 1;
    v14.length = v10 - 1;
    v14.location = 1;
    v11 = (__CFString *)CFStringCreateWithSubstring(0, ValueAtIndex, v14);
    if (!a3
      || (EntryWithUniqueID = (uint64_t)C3DLibraryGetEntryWithUniqueID(a3, v11)) == 0
      && (EntryWithUniqueID = (uint64_t)C3DLibraryGetEntryWithDocumentID(a3, v11)) == 0)
    {
      EntryWithUniqueID = C3DSearchByID(a2, (uint64_t)v11);
    }
    CFRelease(v11);
  }
  else
  {
    EntryWithUniqueID = 0;
    if (a4)
      *a4 = 0;
  }
  return EntryWithUniqueID;
}

void C3DGeometrySetMesh(uint64_t a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v4;
  void *v5;
  int v6;
  uint64_t *v7;
  const __CFSet *v8;

  v2 = a2;
  if (*(uint64_t **)(a1 + 64) != a2)
  {
    v4 = C3DGetSceneRef(a1);
    if (v4)
    {
      v5 = *(void **)(a1 + 64);
      if (!v5)
      {
        if (!v2)
          goto LABEL_20;
        LOBYTE(v6) = 1;
        goto LABEL_13;
      }
      C3DRemoveSceneRef(v5, v4);
      v6 = 1;
LABEL_9:
      v7 = *(uint64_t **)(a1 + 64);
      if (v7 == v2)
      {
        if (!v6)
        {
LABEL_22:
          *(_BYTE *)(a1 + 208) = 0;
          v8 = *(const __CFSet **)(a1 + 88);
          if (v8)
            CFSetApplyFunction(v8, (CFSetApplierFunction)__C3DNodeGeometryDidChange, 0);
          return;
        }
LABEL_20:
        if (v2)
          C3DAddSceneRef(v2, v4);
        goto LABEL_22;
      }
      if (v7)
      {
        CFRelease(v7);
        *(_QWORD *)(a1 + 64) = 0;
      }
      if (!v2)
      {
LABEL_14:
        *(_QWORD *)(a1 + 64) = v2;
        if ((v6 & 1) == 0)
          goto LABEL_22;
        goto LABEL_20;
      }
LABEL_13:
      v2 = (uint64_t *)CFRetain(v2);
      goto LABEL_14;
    }
LABEL_8:
    v6 = 0;
    goto LABEL_9;
  }
  if (!a2 && *(_QWORD *)(a1 + 120))
  {
    v4 = C3DGetSceneRef(a1);
    goto LABEL_8;
  }
}

void C3DGeometryInsertMaterialAtIndex(uint64_t a1, void *value, CFIndex idx)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), idx, value);
  v14 = C3DGetSceneRef(a1);
  C3DAddSceneRef((uint64_t *)value, v14);
  __PostGeometryMaterialDidChangeNotification((_QWORD *)a1);
}

void C3DGeometryRemoveAllMaterials(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  void *ValueAtIndex;
  uint64_t v14;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (C3DGetSceneRef(a1))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
    if (Count >= 1)
    {
      v11 = Count;
      for (i = 0; i != v11; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), i);
        v14 = C3DGetSceneRef(a1);
        C3DRemoveSceneRef(ValueAtIndex, v14);
      }
    }
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 80));
  __PostGeometryMaterialDidChangeNotification((_QWORD *)a1);
}

uint64_t C3DNodeInsertChildNodeAfterChild(uint64_t a1, float32x4_t *cf, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  if (cf[5].i64[0])
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DNodeInsertChildNodeAtIndex_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  if (!cf[4].i64[0] || (v14 = scn_default_log(), !os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)))
  {
    if (a3)
      goto LABEL_7;
LABEL_12:
    cf[5].i64[0] = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = cf;
    CFRetain(cf);
    return __FixupParent(a1, cf);
  }
  C3DNodeInsertChildNodeAtIndex_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
  if (!a3)
    goto LABEL_12;
LABEL_7:
  if (*(_QWORD *)(a3 + 64) != a1)
  {
    v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      C3DNodeInsertChildNodeAfterChild_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
  }
  v30 = *(_QWORD *)(a3 + 80);
  *(_QWORD *)(a3 + 80) = cf;
  CFRetain(cf);
  cf[5].i64[0] = v30;
  return __FixupParent(a1, cf);
}

uint64_t __FixupParent(uint64_t a1, float32x4_t *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;

  a2[4].i64[0] = a1;
  __C3DNodeTransformDidChange(a2);
  if (a1)
  {
    if ((a2[13].i32[3] & 3) != 0)
    {
      v4 = a1;
      do
      {
        *(_DWORD *)(v4 + 220) |= 2u;
        v4 = *(_QWORD *)(v4 + 64);
      }
      while (v4);
      if (!a2)
      {
        v5 = scn_default_log();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
          C3DGeometryTrackNode_cold_2(v5, v6, v7, v8, v9, v10, v11, v12);
      }
    }
  }
  v13 = a2[4].i64[0];
  if (v13)
  {
    v14 = a2[13].i32[3] & 0xFFFFFF7F | (((*(_DWORD *)(v13 + 220) >> 7) & 1) << 7);
    a2[13].i32[3] = v14;
    v15 = v14 & 0xFC7FFFFF | (((*(_DWORD *)(v13 + 220) >> 23) & 7) << 23);
    a2[13].i32[3] = v15;
  }
  else
  {
    v15 = a2[13].u32[3];
  }
  __PropagateFlagsToChildren((uint64_t)a2, (v15 >> 7) & 1, (v15 >> 23) & 7);
  __DirtyWorldAlpha((uint64_t)a2, 0);
  v16 = *(_QWORD *)(a1 + 48);
  v17 = a2[3].i64[0];
  if (v16)
  {
    if (v17 != v16)
    {
      C3DRemoveSceneRef(a2, v17);
      C3DAddSceneRef((uint64_t *)a2, *(_QWORD *)(a1 + 48));
    }
  }
  else
  {
    C3DRemoveSceneRef(a2, v17);
  }
  return __UpdateNodeVisibilityIfNeeded((uint64_t)a2, 1);
}

void __PropagateFlagsToChildren(uint64_t a1, int a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t i;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  v14 = *(_DWORD *)(a1 + 220);
  v15 = (v14 >> 7) & 0x80;
  if (a2)
    v15 = 128;
  *(_DWORD *)(a1 + 220) = v15 & 0xFC7FFFFF | ((a3 & 7) << 23) | v14 & 0xFC7FFF7F;
  for (i = *(_QWORD *)(a1 + 72); i; i = *(_QWORD *)(i + 80))
    __PropagateFlagsToChildren(i, (*(_DWORD *)(a1 + 220) >> 7) & 1, a3);
}

void __C3DNodeTransformDidChange(float32x4_t *a1)
{
  uint64_t v2;
  uint64_t TransformTree;
  __C3DTransformTree *v4;
  simd_float4x4 v5;

  v2 = a1[3].i64[0];
  if (v2)
  {
    TransformTree = C3DSceneGetTransformTree(v2);
    if (TransformTree)
    {
      if (a1[5].i32[2] != -1)
      {
        v4 = (__C3DTransformTree *)TransformTree;
        memset(&v5, 0, sizeof(v5));
        C3DNodeGetMatrix((uint64_t)a1, (uint64_t)&v5);
        C3DTransformTreeUpdateNodeTransform(v4, a1[5].i32[2], &v5);
      }
    }
  }
  __UpdateAudioTransform(a1);
}

void __UpdateAudioTransform(float32x4_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFArray *Attribute;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __n128 *WorldMatrix;
  CFIndex Count;
  CFIndex v21;
  CFIndex i;
  void *ValueAtIndex;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((a1[13].i8[14] & 8) != 0)
  {
    Attribute = C3DEntityGetAttribute((uint64_t)a1, CFSTR("kAudioPlayer"));
    if (!Attribute)
    {
      v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
        __UpdateAudioTransform_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
    }
    WorldMatrix = (__n128 *)C3DNodeGetWorldMatrix(a1);
    Count = CFArrayGetCount(Attribute);
    if (Count >= 1)
    {
      v21 = Count;
      for (i = 0; i != v21; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(Attribute, i);
        C3DAudioPlayerSetTransform(ValueAtIndex, WorldMatrix);
      }
    }
  }
}

void C3DRemoveSceneRef(void *cf, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *ClassWithTypeID;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(void *, uint64_t);
  void (*v19)(void *, uint64_t);
  void (*v20)(void *, _QWORD *);
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[5];

  if (!cf && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (!a2)
      return;
  }
  else if (!a2)
  {
    return;
  }
  if (_C3DEntityGetSceneLink_onceToken != -1)
    dispatch_once(&_C3DEntityGetSceneLink_onceToken, &__block_literal_global_11);
  v12 = _C3DEntityGetSceneLink_sceneLink;
  CFGetTypeID(cf);
  ClassWithTypeID = (_QWORD *)_CFRuntimeGetClassWithTypeID();
  v14 = *ClassWithTypeID;
  if (*ClassWithTypeID == 749405696)
    v15 = ClassWithTypeID;
  else
    v15 = 0;
  if (*((_QWORD *)cf + 6) == a2)
  {
    v16 = *((_QWORD *)cf + 7);
    if (v16)
    {
      v17 = v16 - 1;
      *((_QWORD *)cf + 7) = v17;
      if (!v17)
      {
        if (v14 == 749405696)
        {
          v18 = (void (*)(void *, uint64_t))v15[19];
          if (v18)
            v18(cf, a2);
        }
        v19 = *(void (**)(void *, uint64_t))(v12 + 16);
        if (v19)
          v19(cf, a2);
        if (v14 == 749405696)
        {
          v20 = (void (*)(void *, _QWORD *))v15[17];
          if (v20)
          {
            v28[0] = MEMORY[0x1E0C809B0];
            v28[1] = 0x40000000;
            v28[2] = __C3DRemoveSceneRef_block_invoke;
            v28[3] = &__block_descriptor_tmp_6;
            v28[4] = a2;
            v20(cf, v28);
          }
        }
        _removeFromScene(cf, a2);
        *((_QWORD *)cf + 6) = 0;
      }
    }
    else if ((C3DRemoveSceneRef_done & 1) == 0)
    {
      C3DRemoveSceneRef_done = 1;
      v21 = scn_default_log();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        C3DRemoveSceneRef_cold_1((uint64_t)cf, v21, v22, v23, v24, v25, v26, v27);
    }
  }
}

void __DirtyWorldAlpha(uint64_t a1, char a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD v14[5];
  char v15;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = *(_DWORD *)(a1 + 220);
  if (*(_QWORD *)(a1 + 72))
  {
    *(_DWORD *)(a1 + 220) = v12 & 0xFFFFFFDF;
    v13 = *(_QWORD *)(a1 + 48);
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 0x40000000;
    v14[2] = ____DirtyWorldAlpha_block_invoke;
    v14[3] = &__block_descriptor_tmp_124;
    v15 = a2;
    v14[4] = v13;
    C3DNodeApplyHierarchy(a1, (uint64_t)v14);
  }
  else
  {
    *(_DWORD *)(a1 + 220) = v12 | 0x20;
  }
}

uint64_t __UpdateNodeVisibilityIfNeeded(uint64_t result, char a2)
{
  uint64_t v2;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[6];
  char v14;

  v2 = *(_QWORD *)(result + 48);
  if (v2)
  {
    v4 = result;
    if (C3DNodeShouldBePutInCullingSystem(result) && *(_DWORD *)(v4 + 216) == -1)
    {
      v5 = scn_default_log();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
        __UpdateNodeVisibilityIfNeeded_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    __UpdateCullingSystemFlags(v4, 1);
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 0x40000000;
    v13[2] = ____UpdateNodeVisibilityIfNeeded_block_invoke;
    v13[3] = &__block_descriptor_tmp_129;
    v14 = a2;
    v13[4] = v4;
    v13[5] = v2;
    return C3DNodeApplyHierarchy(v4, (uint64_t)v13);
  }
  return result;
}

id C3DEntityCFFinalize(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  C3DEntityRemoveAllAnimations((void *)a1);
  v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 32) = 0;
  }
  return objc_storeWeak((id *)(a1 + 16), 0);
}

void C3DEntityRemoveAllAnimations(void *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t AnimationManager;
  const __CFDictionary *SubAttributeOrderedDictionary;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = C3DGetSceneRef((uint64_t)a1);
  v11 = v10;
  if (v10)
  {
    AnimationManager = C3DSceneGetAnimationManager(v10);
    if (AnimationManager)
      C3DAnimationManagerRemoveAllAnimationsForObject(AnimationManager, a1);
  }
  SubAttributeOrderedDictionary = _C3DEntityGetSubAttributeOrderedDictionary((uint64_t)a1, CFSTR("kAnimationsKey"), 0);
  if (SubAttributeOrderedDictionary)
  {
    C3DOrderedDictionaryApplyFunction(SubAttributeOrderedDictionary, (const char *)_removeAnimationPlayerSceneRef, v11);
    _C3DEntitySetAttribute((CFTypeRef *)a1, CFSTR("kAnimationsKey"), 0, 1);
  }
}

uint64_t C3DGetSceneRef(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DGeometryFillLibraryForSerialization_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 48);
}

void C3DNodeSetGeometry(uint64_t a1, __C3DGeometry *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Geometry;
  void *v13;
  __C3DGeometry *v14;
  CFTypeRef v15;
  uint64_t v16;
  uint64_t SharedInstance;
  uint64_t v18;
  CFTypeID v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  Geometry = C3DNodeGetGeometry(a1);
  if (Geometry)
  {
    v13 = (void *)Geometry;
    C3DGeometryUntrackNode(Geometry, (const void *)a1);
    C3DRemoveSceneRef(v13, *(_QWORD *)(a1 + 48));
  }
  v14 = *(__C3DGeometry **)(a1 + 240);
  if (v14 != a2)
  {
    if (v14)
    {
      CFRelease(v14);
      *(_QWORD *)(a1 + 240) = 0;
    }
    if (a2)
      v15 = CFRetain(a2);
    else
      v15 = 0;
    *(_QWORD *)(a1 + 240) = v15;
  }
  if (a2)
    C3DGeometryTrackNode((uint64_t)a2, (const void *)a1);
  v16 = *(_QWORD *)(a1 + 48);
  if (v16)
  {
    SharedInstance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, CFSTR("kC3DNotificationEntityAttributeDidChange"), (const void *)a1, (const __CFDictionary *)CFSTR("kMeshKey"), 1u);
  }
  if (!a2)
    goto LABEL_22;
  v18 = *(_QWORD *)(a1 + 48);
  if (v18)
    C3DAddSceneRef((uint64_t *)a2, v18);
  v19 = CFGetTypeID(a2);
  if (v19 == C3DFloorGetTypeID())
  {
    v20 = 4096;
  }
  else
  {
LABEL_22:
    v20 = 0;
    v21 = 0;
    v22 = *(_DWORD *)(a1 + 220);
    if ((v22 & 0x1000) == 0)
      goto LABEL_24;
  }
  v23 = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(v23, CFSTR("kC3DNotificationEngineContextInvalidatePasses"), *(const void **)(a1 + 48), 0, 1u);
  v22 = *(_DWORD *)(a1 + 220);
  v21 = v20;
LABEL_24:
  *(_DWORD *)(a1 + 220) = v22 & 0xFFFFEFFF | v21;
  v24 = *(_QWORD **)(a1 + 248);
  if (v24)
    C3DDeformerStackSetBaseGeometry(v24, a2);
  C3DNodeGeometryLODDidUpdate(a1);
  C3DNodeBoundingBoxDidUpdate(a1);
  __UpdateCullingSystemFlags(a1, 0);
  v25 = a1;
  do
  {
    *(_DWORD *)(v25 + 220) |= 2u;
    v25 = *(_QWORD *)(v25 + 64);
  }
  while (v25);
  if (v16)
    __UpdateCullingHandle(a1, v16);
}

__C3DCullingSystem *__UpdateCullingSystemFlags(uint64_t a1, int a2)
{
  __C3DCullingSystem *result;
  unsigned int v5;
  _QWORD v6[5];

  result = *(__C3DCullingSystem **)(a1 + 48);
  if (result)
  {
    result = (__C3DCullingSystem *)C3DSceneGetCullingSystem((uint64_t)result);
    if (result)
    {
      if (a2)
      {
        v6[0] = MEMORY[0x1E0C809B0];
        v6[1] = 0x40000000;
        v6[2] = ____UpdateCullingSystemFlags_block_invoke;
        v6[3] = &__block_descriptor_tmp_126;
        v6[4] = result;
        return (__C3DCullingSystem *)C3DNodeApplyHierarchy(a1, (uint64_t)v6);
      }
      else
      {
        v5 = *(_DWORD *)(a1 + 216);
        if (v5 != -1)
          return (__C3DCullingSystem *)C3DCullingSystemUpdateFlags(result, v5);
      }
    }
  }
  return result;
}

void C3DNodeGeometryLODDidUpdate(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t Geometry;
  const __CFArray *LOD;
  const __CFArray *v13;
  CFIndex Count;
  uint64_t v15;
  uint64_t v16;
  const void *ValueAtIndex;
  char v18;
  char *v19;
  CFIndex v20;
  float *v21;
  const void *v22;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(void **)(a1 + 232);
  if (v10)
    free(v10);
  *(_QWORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 220) &= ~0x8000u;
  Geometry = C3DNodeGetGeometry(a1);
  if (Geometry)
  {
    LOD = (const __CFArray *)C3DGeometryGetLOD(Geometry);
    if (LOD)
    {
      v13 = LOD;
      if (CFArrayGetCount(LOD) >= 1)
      {
        Count = CFArrayGetCount(v13);
        v15 = Count;
        if (Count >= 0)
          v16 = Count;
        else
          v16 = Count + 1;
        ValueAtIndex = CFArrayGetValueAtIndex(v13, v16 >> 1);
        v18 = C3DLODGetThresholdType((uint64_t)ValueAtIndex);
        v19 = (char *)malloc_type_malloc(12 * v15 + 8, 0x2D81DF56uLL);
        *(_QWORD *)(a1 + 232) = v19;
        *(_WORD *)v19 = v15;
        v19[2] = v18;
        *(_DWORD *)(*(_QWORD *)(a1 + 232) + 4) = 0;
        *(_DWORD *)(a1 + 220) |= 0x8000u;
        if (v15 >= 1)
        {
          v20 = 0;
          v21 = (float *)(v19 + 16);
          do
          {
            v22 = CFArrayGetValueAtIndex(v13, v20);
            *(v21 - 2) = C3DLODGetThreshold((uint64_t)v22);
            *(_QWORD *)(v21 - 1) = 0xFFFFFFFFLL;
            ++v20;
            v21 += 3;
          }
          while (v15 != v20);
        }
      }
    }
  }
  C3DScenePostPipelineEvent(*(_QWORD *)(a1 + 48), 2, (const void *)a1, CFSTR("kMeshKey"));
}

uint64_t C3DGeometryGetLOD(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 96);
}

CFIndex C3DGeometryTrackNode(uint64_t a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFSet *Mutable;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFIndex result;
  CFIndex v30;
  CFIndex i;
  const void *ValueAtIndex;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DGeometryTrackNode_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  Mutable = *(const __CFSet **)(a1 + 88);
  if (!Mutable)
  {
    Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
    *(_QWORD *)(a1 + 88) = Mutable;
  }
  if (CFSetContainsValue(Mutable, a2))
  {
    v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_1(v21, v22, v23, v24, v25, v26, v27, v28);
  }
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 88), a2);
  *(_BYTE *)(a1 + 112) = *(_BYTE *)(a1 + 112) & 0xFE | (CFSetGetCount(*(CFSetRef *)(a1 + 88)) > 4);
  result = *(_QWORD *)(a1 + 96);
  if (result)
  {
    result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      v30 = result;
      for (i = 0; i != v30; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), i);
        result = C3DLODGetEntity((uint64_t)ValueAtIndex);
        if (result)
          result = C3DGeometryTrackNode(result, a2);
      }
    }
  }
  return result;
}

uint64_t _C3DModelPathResolveMaterial(uint64_t result, const __CFArray *a2, int a3, int a4, uint64_t a5, int a6)
{
  const void *v11;
  void *ValueAtIndex;
  unsigned int v13;
  char *CommonProfile;

  if (result)
  {
    v11 = (const void *)result;
    if ((_C3DModelPathResolveEntity((_QWORD *)result, a2, a3, a4, a5) & 1) == 0)
    {
      C3DModelTargetSetTarget(a5, v11);
      if (a3 >= a4)
      {
        *(_QWORD *)(a5 + 24) = 0;
        *(_WORD *)(a5 + 32) = 0;
      }
      else
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, a3);
        v13 = _pathComponentForString(ValueAtIndex);
        CommonProfile = (char *)C3DMaterialGetCommonProfile((uint64_t)v11);
        if (v13 != 42)
          return _C3DModelPathResolveCommonProfile(CommonProfile, a2, a3, a4, a5, a6);
        _C3DModelPathResolveCommonProfile(CommonProfile, a2, a3 + 1, a4, a5, a6);
      }
    }
    return 1;
  }
  return result;
}

CFTypeRef C3DModelTargetSetTarget(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DKeyframeControllerSetKeyframeAtIndex_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(CFTypeRef *)(a1 + 16);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 16) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 16) = result;
  }
  return result;
}

uint64_t _C3DModelPathResolveEntity(_QWORD *a1, CFArrayRef theArray, int a3, int a4, uint64_t a5)
{
  void *ValueAtIndex;
  unsigned int v11;
  const void *v12;
  const __CFDictionary *ValueForKey;
  const __CFDictionary *v14;
  CFTypeID v15;
  uint64_t result;
  const void *v17;
  uint64_t AnimationManager;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  if (a3 >= a4)
    return 0;
  ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, a3);
  v11 = _pathComponentForString(ValueAtIndex);
  if (v11 == 90)
  {
    if (a3 + 1 < a4)
    {
      v17 = CFArrayGetValueAtIndex(theArray, a3 + 1);
      result = C3DGetScene(a1);
      if (result)
      {
        AnimationManager = C3DSceneGetAnimationManager(result);
        result = (uint64_t)C3DAnimationManagerGetAnimationNodeForKey(AnimationManager, a1, v17);
        if (result)
        {
          *(_QWORD *)(a5 + 24) = result + 52;
          C3DModelTargetSetTarget(a5, (CFTypeRef)result);
          result = 1;
          *(_WORD *)(a5 + 32) = 1;
          *(_BYTE *)(a5 + 34) = 0;
        }
      }
      return result;
    }
    return 0;
  }
  if (v11 != 89)
  {
    result = C3DEntityIsTypeSupportingShaderModifiers(a1);
    if ((_DWORD)result)
    {
      C3DEntityGetShaderModifiers((uint64_t)a1);
      return C3DEntityResolveKeypathInKeyValueStore((uint64_t)a1, theArray, a3, a5);
    }
    return result;
  }
  if (a3 + 1 >= a4)
    return 0;
  v12 = CFArrayGetValueAtIndex(theArray, a3 + 1);
  ValueForKey = C3DEntityGetValueForKey((uint64_t)a1, v12);
  if (ValueForKey)
  {
    v14 = ValueForKey;
    v15 = CFGetTypeID(ValueForKey);
    if (v15 == C3DValueGetTypeID())
    {
      C3DModelTargetSetTarget(a5, v14);
      *(_QWORD *)(a5 + 24) = C3DValueGetBytes((uint64_t)v14);
      *(_WORD *)(a5 + 32) = C3DValueGetType((uint64_t)v14);
      *(_BYTE *)(a5 + 34) = 0;
      return 1;
    }
  }
  v19 = scn_default_log();
  result = os_log_type_enabled(v19, OS_LOG_TYPE_FAULT);
  if ((_DWORD)result)
  {
    _C3DModelPathResolveEntity_cold_1(v19, v20, v21, v22, v23, v24, v25, v26);
    return 0;
  }
  return result;
}

const void *_pathComponentForString(void *key)
{
  if (_pathComponentForString_onceToken != -1)
    dispatch_once(&_pathComponentForString_onceToken, &__block_literal_global_7_3);
  return CFDictionaryGetValue((CFDictionaryRef)_pathComponentForString__pathComponents, key);
}

BOOL C3DEntityIsTypeSupportingShaderModifiers(CFTypeRef cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeID v10;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = CFGetTypeID(cf);
  return CFTypeIsC3DGeometry(v10) || v10 == C3DMaterialGetTypeID();
}

void __PostGeometryMaterialDidChangeNotification(_QWORD *cf)
{
  const __CFSet *v2;
  CFTypeID v3;

  v2 = (const __CFSet *)cf[11];
  if (v2)
    CFSetApplyFunction(v2, (CFSetApplierFunction)__C3DNodeGeometryDidChange, 0);
  v3 = CFGetTypeID(cf);
  if (v3 == C3DParametricGeometryGetTypeID())
    C3DParametricGeometryMaterialDidChange((uint64_t)cf);
}

void C3DEngineNotificationQueueEnqueueEvent(uint64_t a1, int a2, const void *a3, const void *a4)
{
  os_unfair_lock_s *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *TypeID;
  void *Value;
  unsigned int v27;
  unsigned int v28;
  NSObject *v29;
  const void *v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  const void *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v8 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  if (!a3 && (v9 = scn_default_log(), os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
    if (a1)
      goto LABEL_6;
  }
  else if (a1)
  {
    goto LABEL_6;
  }
  v17 = scn_default_log();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
    C3DEngineNotificationQueueEnqueueEvent_cold_2(v17, v18, v19, v20, v21, v22, v23, v24);
LABEL_6:
  TypeID = (const void *)CFGetTypeID(a3);
  if (CFTypeIsC3DGeometry((uint64_t)TypeID))
    TypeID = (const void *)C3DGeometryGetTypeID();
  Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), TypeID);
  if (!Value)
  {
    Value = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], 0);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), TypeID, Value);
    CFRelease(Value);
  }
  v27 = CFDictionaryGetValue((CFDictionaryRef)Value, a3);
  v28 = v27;
  switch(a2)
  {
    case 0:
      if ((v27 & 0x200) != 0)
      {
        v29 = scn_default_log();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          v41 = 134217984;
          v42 = a3;
          _os_log_impl(&dword_1DCCB8000, v29, OS_LOG_TYPE_DEFAULT, "Warning: adding a node that was just removed %p", (uint8_t *)&v41, 0xCu);
        }
      }
      v30 = (const void *)(v28 & 0xFFEFFF00 | 0x100001);
      goto LABEL_26;
    case 2:
      if (a4)
      {
        if (CFEqual(a4, CFSTR("kMeshKey")))
        {
          v31 = v28 & 0xFFFFEF00;
          v32 = 4097;
        }
        else if (CFEqual(a4, CFSTR("kCameraKey")))
        {
          v31 = v28 & 0xFFFFDF00;
          v32 = 8193;
        }
        else if (CFEqual(a4, CFSTR("kLightKey")))
        {
          v31 = v28 & 0xFFFFBF00;
          v32 = 16385;
        }
        else if (CFEqual(a4, CFSTR("kDeformerStackKey")))
        {
          v31 = v28 & 0xFFFDFF00;
          v32 = 131073;
        }
        else
        {
          if (!CFEqual(a4, CFSTR("rendererDelegate")))
            goto LABEL_27;
          v31 = v28 & 0xFFFF7F00;
          v32 = 32769;
        }
LABEL_25:
        v30 = (const void *)(v31 | v32);
LABEL_26:
        CFDictionarySetValue((CFMutableDictionaryRef)Value, a3, v30);
      }
      else
      {
        v33 = scn_default_log();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
          C3DEngineNotificationQueueEnqueueEvent_cold_1(v33, v34, v35, v36, v37, v38, v39, v40);
      }
LABEL_27:
      if (!*(_BYTE *)(a1 + 48))
      {
        *(_BYTE *)(a1 + 48) = 1;
        _dispatchAutoFlush(a1);
      }
      os_unfair_lock_unlock(v8);
      return;
    case 3:
      v31 = v27 & 0xFFFFFD00;
      v32 = 514;
      goto LABEL_25;
    case 4:
      v31 = v27 & 0xFFFFFB00;
      v32 = 1025;
      goto LABEL_25;
    case 5:
      v31 = v27 & 0xFFFFFF00;
      v32 = 2049;
      goto LABEL_25;
    case 6:
      v31 = v27 & 0xFFFFFB00;
      v32 = 1027;
      goto LABEL_25;
    case 7:
      v31 = v27 & 0xFFFFFF00;
      v32 = 2051;
      goto LABEL_25;
    case 8:
      v30 = (const void *)((v27 & 0xFFF7FF00) + 524289);
      goto LABEL_26;
    case 9:
      v31 = v27 & 0xFFFFFD00;
      v32 = 516;
      goto LABEL_25;
    default:
      goto LABEL_27;
  }
}

BOOL CFTypeIsC3DGeometry(uint64_t a1)
{
  if (C3DGeometryGetTypeID_onceToken != -1)
    dispatch_once(&C3DGeometryGetTypeID_onceToken, &__block_literal_global_5);
  return C3DGeometryGetTypeID_typeID == a1
      || C3DFloorGetTypeID() == a1
      || C3DParametricGeometryGetTypeID() == a1
      || C3DShapeGeometryGetTypeID() == a1
      || C3DTextGeometryGetTypeID() == a1
      || C3DBezierCurveGeometryGetTypeID() == a1;
}

uint64_t C3DParametricGeometryGetTypeID()
{
  if (C3DParametricGeometryGetTypeID_onceToken != -1)
    dispatch_once(&C3DParametricGeometryGetTypeID_onceToken, &__block_literal_global_92);
  return C3DParametricGeometryGetTypeID_typeID;
}

uint64_t C3DFloorGetTypeID()
{
  if (C3DFloorGetTypeID_onceToken != -1)
    dispatch_once(&C3DFloorGetTypeID_onceToken, &__block_literal_global_80);
  return C3DFloorGetTypeID_typeID;
}

uint64_t C3DTextGeometryGetTypeID()
{
  if (C3DTextGeometryGetTypeID_onceToken != -1)
    dispatch_once(&C3DTextGeometryGetTypeID_onceToken, &__block_literal_global_11_1);
  return C3DTextGeometryGetTypeID_typeID;
}

uint64_t C3DShapeGeometryGetTypeID()
{
  if (C3DShapeGeometryGetTypeID_onceToken != -1)
    dispatch_once(&C3DShapeGeometryGetTypeID_onceToken, &__block_literal_global_145);
  return C3DShapeGeometryGetTypeID_typeID;
}

uint64_t C3DMaterialGetTypeID()
{
  if (C3DMaterialGetTypeID_onceToken != -1)
    dispatch_once(&C3DMaterialGetTypeID_onceToken, &__block_literal_global_64);
  return C3DMaterialGetTypeID_typeID;
}

uint64_t C3DEntityResolveKeypathInKeyValueStore(uint64_t a1, const __CFArray *a2, int a3, uint64_t a4)
{
  const __CFDictionary *v4;
  CFDictionaryRef *Value;

  v4 = *(const __CFDictionary **)(a1 + 40);
  if (v4 && (Value = (CFDictionaryRef *)CFDictionaryGetValue(v4, CFSTR("_kvc"))) != 0)
    return C3DKeyValueStoreSetupModelTargetWithKey(Value, a2, a3, a4);
  else
    return 0;
}

float C3DEffectCommonProfileGetSelfIlluminationOcclusion(uint64_t a1)
{
  return *(float *)(a1 + 176);
}

uint64_t C3DEffectCommonProfileGetHashCode(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  __int16 v19;
  __int16 v20;
  int8x16_t v21;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(int *)(a1 + 24) >= 7)
  {
    v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      C3DEffectCommonProfileGetHashCode_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
  }
  v18 = *(_DWORD *)(a1 + 24);
  v19 = *(unsigned __int8 *)(a1 + 192);
  if (C3DMaterialIsDoubleSided(*(_QWORD *)(a1 + 16)))
    v20 = 32;
  else
    v20 = 0;
  v21 = (int8x16_t)vmovl_u16((uint16x4_t)vand_s8((int8x8_t)vdup_n_s16(32 * *(unsigned __int16 *)(a1 + 194)), (int8x8_t)0x400020001000080));
  *(int8x8_t *)v21.i8 = vorr_s8(*(int8x8_t *)v21.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
  return v21.i16[0] | ((*(_WORD *)(a1 + 194) & 1) << 6) | v21.i16[2] | ((*(_BYTE *)(a1 + 180) & 0xFu) << 11) | (unsigned __int16)(16 * v19) | (unsigned __int16)(v20 | (*(unsigned __int8 *)(a1 + 193) << 15) | v18);
}

uint64_t C3DMaterialIsDoubleSided(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 100);
}

uint64_t C3DMaterialGetFillMode(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 91);
}

BOOL C3DMaterialGetEnableReadsFromDepthBuffer(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_BYTE *)(a1 + 89) != 0;
}

uint64_t C3DMaterialGetCullMode(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 90);
}

uint64_t C3DMaterialGetBlendMode(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 92);
}

uint64_t C3DEffectCommonProfileIsPerPixelLit(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 192);
}

uint64_t C3DEffectCommonProfileGetEnableLockAmbientWithDiffuse(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 193);
}

uint64_t C3DEffectCommonProfileGetAvoidsOverLighting(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_WORD *)(a1 + 194) & 1;
}

uint64_t _C3DModelPathResolveCommonProfile(char *cf, const __CFArray *a2, int a3, int a4, uint64_t a5, int a6)
{
  void *ValueAtIndex;
  uint64_t v13;
  uint64_t v14;
  int v15;
  char *v16;
  char *EffectSlot;
  NSObject *v18;
  char *v20;

  C3DModelTargetSetTarget(a5, cf);
  if (a3 < a4)
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, a3);
    switch(_pathComponentForString(ValueAtIndex))
    {
      case '+':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 2;
        goto LABEL_22;
      case ',':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 1;
        goto LABEL_22;
      case '-':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 3;
        goto LABEL_22;
      case '.':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 0;
        goto LABEL_22;
      case '/':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 4;
        goto LABEL_22;
      case '0':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 7;
        goto LABEL_22;
      case '1':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 8;
        goto LABEL_22;
      case '2':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 9;
        goto LABEL_22;
      case '3':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 10;
        goto LABEL_22;
      case '4':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 11;
        goto LABEL_22;
      case '5':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 12;
        goto LABEL_22;
      case '6':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 13;
        goto LABEL_22;
      case '7':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 14;
        goto LABEL_22;
      case '8':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 15;
        goto LABEL_22;
      case '9':
        v13 = 1;
        *(_WORD *)(a5 + 32) = 1;
        v16 = cf + 176;
        goto LABEL_26;
      case ':':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 5;
        goto LABEL_22;
      case ';':
        v13 = 1;
        v14 = (uint64_t)cf;
        v15 = 6;
LABEL_22:
        EffectSlot = (char *)C3DEffectCommonProfileGetEffectSlot(v14, v15, 1);
        C3DModelPathResolveCommonProfileProperty(EffectSlot, a2, a3 + 1, a4, a5, a6);
        return v13;
      case '<':
        v13 = 1;
        *(_WORD *)(a5 + 32) = 1;
        v16 = cf + 160;
        goto LABEL_26;
      case '=':
        v13 = 1;
        *(_WORD *)(a5 + 32) = 1;
        v16 = cf + 164;
        goto LABEL_26;
      case '>':
        v13 = 1;
        *(_WORD *)(a5 + 32) = 1;
        v16 = cf + 172;
LABEL_26:
        *(_QWORD *)(a5 + 24) = v16;
        return v13;
      case '@':
        *(_WORD *)(a5 + 32) = 3;
        v20 = cf + 192;
        goto LABEL_34;
      case 'B':
        *(_WORD *)(a5 + 32) = 3;
        v20 = cf + 193;
LABEL_34:
        *(_QWORD *)(a5 + 24) = v20;
        return 1;
      default:
        if (a6)
        {
          v18 = scn_default_log();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            _C3DModelPathResolveCommonProfile_cold_1();
        }
        return 0;
    }
  }
  *(_QWORD *)(a5 + 24) = 0;
  *(_WORD *)(a5 + 32) = 0;
  return 1;
}

BOOL C3DModelPathResolveCommonProfileProperty(char *cf, const __CFArray *a2, int a3, int a4, uint64_t a5, int a6)
{
  void *ValueAtIndex;
  uint64_t Color;
  void *v14;
  NSObject *v15;
  NSObject *v16;
  _BOOL8 result;
  uint64_t ImageTransform;
  const void *TextureSampler;
  uint64_t v20;
  __int128 v21[4];

  C3DModelTargetSetTarget(a5, cf);
  if (a3 >= a4)
  {
    *(_QWORD *)(a5 + 24) = 0;
    *(_WORD *)(a5 + 32) = 0;
    return 1;
  }
  else
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, a3);
    switch(_pathComponentForString(ValueAtIndex))
    {
      case 'D':
      case 'E':
        Color = C3DEffectSlotGetColor((uint64_t)cf);
        goto LABEL_18;
      case 'F':
        C3DEffectSlotGetTexture((uint64_t)cf);
        if (a3 + 1 < a4)
        {
          v14 = (void *)CFArrayGetValueAtIndex(a2, a3 + 1);
          _pathComponentForString(v14);
          if (a6)
          {
            v15 = scn_default_log();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              C3DModelPathResolveCommonProfileProperty_cold_2();
          }
        }
        return 1;
      case 'H':
        ImageTransform = C3DEffectSlotGetImageTransform((uint64_t)cf);
        if (!ImageTransform)
        {
          memset(v21, 0, sizeof(v21));
          C3DMatrix4x4MakeIdentity((uint64_t)v21);
          C3DEffectSlotSetImageTransform((uint64_t)cf, v21);
          ImageTransform = C3DEffectSlotGetImageTransform((uint64_t)cf);
        }
        _C3DModelPathResolveMatrix(ImageTransform, a2, a3 + 1, a4, a5);
        return 1;
      case 'I':
        TextureSampler = (const void *)C3DEffectSlotGetTextureSampler((uint64_t)cf);
        if (!TextureSampler)
          return 1;
        v20 = (uint64_t)TextureSampler;
        C3DModelTargetSetTarget(a5, TextureSampler);
        Color = C3DTextureSamplerGetBorderColor(v20);
LABEL_18:
        _C3DModelPathResolveColor4(Color, a2, a3 + 1, a4, a5);
        return 1;
      case 'J':
        *(_QWORD *)(a5 + 24) = cf + 72;
        result = 1;
        *(_WORD *)(a5 + 32) = 1;
        return result;
      default:
        if (!a6)
          goto LABEL_12;
        v16 = scn_default_log();
        result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
        if (result)
        {
          C3DModelPathResolveCommonProfileProperty_cold_1();
LABEL_12:
          result = 0;
        }
        break;
    }
  }
  return result;
}

void _C3DModelPathResolveColor4(uint64_t a1, CFArrayRef theArray, int a3, int a4, uint64_t a5)
{
  void *ValueAtIndex;
  unsigned int v8;
  NSObject *v9;
  uint64_t v10;

  if (a3 >= a4)
  {
    *(_QWORD *)(a5 + 24) = a1;
    *(_WORD *)(a5 + 32) = 13;
  }
  else
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, a3);
    v8 = _pathComponentForString(ValueAtIndex);
    *(_WORD *)(a5 + 32) = 1;
    switch(v8)
    {
      case 0x12u:
        *(_QWORD *)(a5 + 24) = a1;
        return;
      case 0x13u:
        v10 = a1 + 4;
        goto LABEL_10;
      case 0x14u:
        v10 = a1 + 8;
        goto LABEL_10;
      case 0x15u:
        v10 = a1 + 12;
LABEL_10:
        *(_QWORD *)(a5 + 24) = v10;
        break;
      default:
        v9 = scn_default_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          _C3DModelPathResolveColor4_cold_1();
        break;
    }
  }
}

uint64_t C3DEffectSlotGetColor(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return a1 + 16;
}

uint64_t _C3DModelPathResolveNode(float32x4_t *a1, const __CFArray *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void *ValueAtIndex;
  int v13;
  char *v14;
  const __CFArray *v15;
  int v16;
  uint64_t v17;
  const void *Light;
  uint64_t v19;
  const __CFDictionary *FiltersParamController;
  unsigned int ChildNodesCount;
  uint64_t ChildNodeAtIndex;
  NSObject *v23;
  unsigned int v25;
  CFTypeRef cf[2];
  __int128 v27;
  __int128 v28;
  __int128 v29;

  if (!a1)
    return 0;
  if ((_C3DModelPathResolveEntity(a1, a2, a3, a4, a5) & 1) != 0)
    return 1;
  C3DModelTargetSetTarget(a5, a1);
  if (a3 >= (int)a4)
  {
    *(_QWORD *)(a5 + 24) = 0;
    *(_WORD *)(a5 + 32) = 0;
    return 1;
  }
  ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, a3);
  v13 = _pathComponentForString(ValueAtIndex);
  if (v13 <= 37)
  {
    switch(v13)
    {
      case 1:
        v16 = a3 + 1;
        v14 = (char *)a1;
        v15 = a2;
        goto LABEL_7;
      case 2:
        *(_QWORD *)(a5 + 24) = (char *)a1 + 204;
        v17 = 1;
        *(_WORD *)(a5 + 32) = 1;
        return v17;
      case 3:
        *(_QWORD *)(a5 + 24) = (char *)a1 + 200;
        *(_WORD *)(a5 + 32) = 3;
        return 1;
      case 5:
      case 6:
      case 7:
      case 8:
      case 12:
      case 13:
        v14 = (char *)a1;
        v15 = a2;
        v16 = a3;
LABEL_7:
        _C3DModelPathResolveNodeTransform(v14, v15, v16, a4, a5, a6);
        break;
      case 9:
        *(_BYTE *)(a5 + 34) = 8;
        v19 = a1[12].i64[0];
        if (!v19)
        {
          v28 = 0u;
          v29 = 0u;
          *(_OWORD *)cf = 0u;
          v27 = 0u;
          C3DMatrix4x4MakeIdentity((uint64_t)cf);
          C3DNodeSetPivotMatrix(a1, (__int128 *)cf);
          v19 = a1[12].i64[0];
        }
        _C3DModelPathResolveMatrix(v19, a2, a3 + 1, a4, a5);
        return 1;
      case 10:
        if (a3 + 1 >= (int)a4)
          goto LABEL_26;
        FiltersParamController = C3DNodeGetFiltersParamController((uint64_t)a1);
        if (!FiltersParamController)
          goto LABEL_26;
        _C3DModelPathResolveDynamicParameter(FiltersParamController, a2, a3 + 1, a4, a5, a6);
        break;
      default:
        goto LABEL_26;
    }
    return 1;
  }
  if (v13 > 74)
  {
    if (v13 == 75)
    {
      Light = C3DNodeGetLight((uint64_t)a1);
      goto LABEL_32;
    }
    if (v13 == 88)
    {
      Light = (const void *)C3DNodeGetMorpher((uint64_t)a1);
      goto LABEL_32;
    }
  }
  else
  {
    if (v13 == 38)
    {
      Light = C3DNodeGetCamera((uint64_t)a1);
      goto LABEL_32;
    }
    if (v13 == 39)
    {
      Light = (const void *)C3DNodeGetGeometry((uint64_t)a1);
LABEL_32:
      _C3DModelPathResolverRegistryResolvePath(Light, (uint64_t)a2, (a3 + 1), a4, a5, a6);
      return 1;
    }
  }
LABEL_26:
  cf[0] = 0;
  v25 = 0;
  if (!_C3DModelPathResolveArray(a2, a3, a4, (SInt32 *)&v25, (CFStringRef *)cf))
    goto LABEL_35;
  if (_pathComponentForString((void *)cf[0]) != 11)
  {
    if (cf[0])
      CFRelease(cf[0]);
LABEL_35:
    if ((_DWORD)a6)
    {
      v23 = scn_default_log();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        _C3DModelPathResolveNode_cold_1();
    }
    return 0;
  }
  ChildNodesCount = C3DNodeGetChildNodesCount((uint64_t)a1);
  if (ChildNodesCount <= v25)
  {
    v17 = 0;
  }
  else
  {
    ChildNodeAtIndex = C3DNodeGetChildNodeAtIndex((uint64_t)a1, v25);
    v17 = _C3DModelPathResolveNode(ChildNodeAtIndex, a2, (a3 + 1), a4, a5, a6);
  }
  if (cf[0])
    CFRelease(cf[0]);
  return v17;
}

void C3DGeometryUntrackNode(uint64_t a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFSet *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFArray *v29;
  CFIndex Count;
  CFIndex v31;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v34;
  __CFSet *v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DGeometryTrackNode_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  v20 = *(const __CFSet **)(a1 + 88);
  if (!v20 || !CFSetContainsValue(v20, a2))
  {
    v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
      C3DGeometryUntrackNode_cold_2(v21, v22, v23, v24, v25, v26, v27, v28);
  }
  v29 = *(const __CFArray **)(a1 + 96);
  if (v29)
  {
    Count = CFArrayGetCount(v29);
    if (Count >= 1)
    {
      v31 = Count;
      for (i = 0; i != v31; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), i);
        v34 = C3DLODGetEntity((uint64_t)ValueAtIndex);
        if (v34)
          C3DGeometryUntrackNode(v34, a2);
      }
    }
  }
  v35 = *(__CFSet **)(a1 + 88);
  if (v35)
    goto LABEL_20;
  v36 = scn_default_log();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
    C3DGeometryUntrackNode_cold_1(v36, v37, v38, v39, v40, v41, v42, v43);
  v35 = *(__CFSet **)(a1 + 88);
  if (v35)
LABEL_20:
    CFSetRemoveValue(v35, a2);
}

uint64_t _C3DModelPathResolveScene(CFTypeRef cf, const __CFArray *a2, int a3, int a4, uint64_t a5, int a6)
{
  void *ValueAtIndex;
  unsigned int v13;
  uint64_t v14;
  char *BackgroundEffectSlot;

  C3DModelTargetSetTarget(a5, cf);
  if (a3 >= a4)
  {
    *(_QWORD *)(a5 + 24) = 0;
    *(_WORD *)(a5 + 32) = 0;
    return 1;
  }
  else
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, a3);
    v13 = _pathComponentForString(ValueAtIndex);
    if (v13 == 91)
    {
      v14 = 1;
      BackgroundEffectSlot = (char *)C3DSceneGetBackgroundEffectSlot((uint64_t)cf, 1);
    }
    else
    {
      if (v13 != 92)
        return 0;
      v14 = 1;
      BackgroundEffectSlot = (char *)C3DSceneGetLightingEnvironmentEffectSlot((uint64_t)cf, 1);
    }
    C3DModelPathResolveCommonProfileProperty(BackgroundEffectSlot, a2, a3 + 1, a4, a5, a6);
  }
  return v14;
}

uint64_t C3DColorSpaceITUR_709()
{
  if (C3DColorSpaceITUR_709_onceToken != -1)
    dispatch_once(&C3DColorSpaceITUR_709_onceToken, &__block_literal_global_17);
  return C3DColorSpaceITUR_709_kC3DColorSpaceITUR_709;
}

CGColorRef C3DCGColorCreateExtendedSRGBWithCGColor(CGColorRef color)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  CGColorSpace *v5;

  if (!color)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DCGColorGetComponentsInColorSpace_cold_1(v2, v3, v4);
  }
  if (C3DColorSpaceExtendedSRGB_onceToken != -1)
    dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_9);
  v5 = (CGColorSpace *)C3DColorSpaceExtendedSRGB_kC3DColorSpaceExtendedSRGB;
  if (CGColorGetColorSpace(color) == v5)
    return CGColorRetain(color);
  if (C3DGetColorTransformToExtendedSRGB_onceToken != -1)
    dispatch_once(&C3DGetColorTransformToExtendedSRGB_onceToken, &__block_literal_global_32);
  return (CGColorRef)CGColorTransformConvertColor();
}

uint64_t __AddProperty(uint64_t a1, unsigned int a2, int a3, int a4)
{
  uint64_t DefineForPropertyAndSuffix;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  const __CFString *v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  const __CFString *v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  __int16 UVSetInfo;
  unsigned __int8 v23;
  unsigned int v24;
  void *v25;
  uint64_t v26;

  DefineForPropertyAndSuffix = __GetDefineForPropertyAndSuffix(a3, 0);
  v9 = __GetDefineForPropertyAndSuffix(a3, 1);
  result = __GetDefineForPropertyAndSuffix(a3, 5);
  v11 = result;
  *(_BYTE *)(a1 + 24) = 0;
  if (a4)
  {
    result = C3DProgramHashCodeGetEffectPropertyIsEnabled(*(_QWORD *)a1, a2);
    if ((_DWORD)result)
    {
      if (a3 == 7)
        v12 = (const __CFString *)&unk_1EA5FF180;
      else
        v12 = &stru_1EA5A6480;
      objc_msgSend(*(id *)(a1 + 8), "setObject:forKeyedSubscript:", v12, v9);
      if (!C3DProgramHashCodeGetEffectPropertyHasTexture(*(_QWORD *)a1, a2))
      {
        v19 = __GetDefineForPropertyAndSuffix(a3, 2);
        v18 = *(void **)(a1 + 8);
        v17 = &stru_1EA5A6480;
        goto LABEL_16;
      }
      if (C3DProgramHashCodeGetEffectPropertyTextureType(*(_QWORD *)a1, a2) == 4)
        v13 = 7;
      else
        v13 = 6;
      objc_msgSend(*(id *)(a1 + 8), "setObject:forKeyedSubscript:", &stru_1EA5A6480, __GetDefineForPropertyAndSuffix(a3, v13));
      *(_BYTE *)(a1 + 24) = 1;
      objc_msgSend(*(id *)(a1 + 8), "setObject:forKeyedSubscript:", &stru_1EA5A6480, v11);
      result = C3DProgramHashCodeGetEffectPropertyHashCode(*(_QWORD *)a1, a2);
      v14 = result;
      if ((result & 0x2000) != 0)
        result = objc_msgSend(*(id *)(a1 + 8), "setObject:forKeyedSubscript:", &stru_1EA5A6480, __GetDefineForPropertyAndSuffix(a3, 3));
      v15 = (v14 >> 14) & 0xF;
      if ((_DWORD)v15 && (_DWORD)v15 != 15)
      {
        v16 = __GetDefineForPropertyAndSuffix(a3, 4);
        v17 = (const __CFString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%d"), v15);
        v18 = *(void **)(a1 + 8);
        v19 = v16;
LABEL_16:
        result = objc_msgSend(v18, "setObject:forKeyedSubscript:", v17, v19);
      }
    }
  }
  v20 = *(void **)(a1 + 16);
  if (v20)
  {
    objc_msgSend(v20, "addObject:", __GetDefineForPropertyAndSuffix(a3, 1));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 2));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 3));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 4));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 5));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 6));
    result = objc_msgSend(*(id *)(a1 + 16), "addObject:", __GetDefineForPropertyAndSuffix(a3, 7));
  }
  if (a3 != 4)
  {
    result = objc_msgSend(*(id *)(a1 + 8), "objectForKeyedSubscript:", v11);
    if (result)
    {
      result = C3DProgramHashCodeGetEffectPropertyHashCode(*(_QWORD *)a1, a2);
      v21 = (result >> 18) & 0xF;
      if ((_DWORD)v21 != 15)
      {
        if (a3 == 15)
        {
          UVSetInfo = C3DProgramHashCodeGetUVSetInfo(*(_QWORD *)a1, v21);
          v23 = UVSetInfo;
          v24 = HIBYTE(UVSetInfo);
          v25 = *(void **)(a1 + 112);
          if (v24 <= 0xFE)
            return objc_msgSend(v25, "appendFormat:", CFSTR("float2 _%@Texcoord = (scn_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;\n"),
                     DefineForPropertyAndSuffix,
                     (*(_DWORD *)(a1 + 128) - 1),
                     v23);
          else
            return objc_msgSend(v25, "appendFormat:", CFSTR("float2 _%@Texcoord = _geometry.texcoords[%d].xy;\n"),
                     DefineForPropertyAndSuffix,
                     v23,
                     v26);
        }
        else
        {
          return objc_msgSend(*(id *)(a1 + 120), "appendFormat:", CFSTR("    _surface.%@Texcoord = in.texcoord%d;\n"),
                   DefineForPropertyAndSuffix,
                   v21,
                   v26);
        }
      }
    }
  }
  return result;
}

uint64_t __GetDefineForPropertyAndSuffix(int a1, int a2)
{
  if (__GetDefineForPropertyAndSuffix_predicate != -1)
    dispatch_once(&__GetDefineForPropertyAndSuffix_predicate, &__block_literal_global_104);
  return *((_QWORD *)&__GetDefineForPropertyAndSuffix_strings + 8 * (uint64_t)a1 + a2);
}

uint64_t C3DProgramHashCodeGetEffectPropertyIsEnabled(uint64_t a1, unsigned int a2)
{
  return (*(_DWORD *)(a1 + 4 * a2 + 36) >> 11) & 1;
}

uint64_t C3DProgramHashCodeGetEffectPropertyHasTexture(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 36) & 1;
}

uint64_t C3DProgramHashCodeGetEffectPropertyHashCode(uint64_t a1, unsigned int a2)
{
  return *(unsigned int *)(a1 + 4 * a2 + 36);
}

BOOL C3DShouldCollectGeneratedShaders()
{
    return 1;
  if (C3DShouldCollectGeneratedShaders::onceToken != -1)
    dispatch_once(&C3DShouldCollectGeneratedShaders::onceToken, &__block_literal_global_56);
  return C3DShouldCollectGeneratedShaders::traceResources != 0;
}

const void *C3DGetTextResourceWithNameAllowingHotReload(void *key)
{
  const __CFDictionary *v2;
  void *values[102];
  const void *__dst[103];

  __dst[102] = *(const void **)MEMORY[0x1E0C80C00];
  v2 = (const __CFDictionary *)C3DGetTextResourceWithNameAllowingHotReload_s_builtInTextResources;
  if (!C3DGetTextResourceWithNameAllowingHotReload_s_builtInTextResources)
  {
    memcpy(__dst, off_1EA5A4070, 0x330uLL);
    memcpy(values, off_1EA5A43A0, sizeof(values));
    v2 = CFDictionaryCreate(0, __dst, (const void **)values, 101, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    C3DGetTextResourceWithNameAllowingHotReload_s_builtInTextResources = (uint64_t)v2;
  }
  return CFDictionaryGetValue(v2, key);
}

uint64_t C3DProgramHashCodeGetReflectionProbesEnabled(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 202) >> 4) & 1;
}

uint64_t C3DProgramHashCodeGetEffectPropertyTextureType(uint64_t a1, unsigned int a2)
{
  return (*(_DWORD *)(a1 + 4 * a2 + 36) >> 6) & 0xF;
}

uint64_t SCNMetalLanguageVersion()
{
  if (SCNMetalLanguageVersion_onceToken != -1)
    dispatch_once(&SCNMetalLanguageVersion_onceToken, &__block_literal_global_27);
  return SCNMetalLanguageVersion_languageVersion;
}

uint64_t C3DProgramHashCodeGetUVSetInfo(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a2 >= 16)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DProgramHashCodeGetUVSetInfo_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return *(unsigned __int16 *)(a1 + 2 * a2 + 164);
}

CFIndex CFStringUpdateHash(uint64_t a1)
{
  CC_SHA256_CTX *v1;
  CC_SHA256_CTX *v2;
  const __CFString *v3;
  const __CFString *v4;
  const char *CStringPtr;
  CFIndex result;
  CFIndex v7;
  CFIndex v8;
  CFIndex usedBufLen;
  UInt8 buffer[32768];
  uint64_t v11;
  CFRange v12;

  MEMORY[0x1E0C80A78](a1);
  v2 = v1;
  v4 = v3;
  v11 = *MEMORY[0x1E0C80C00];
  CStringPtr = CFStringGetCStringPtr(v3, 0x600u);
  result = CFStringGetLength(v4);
  v7 = result;
  if (CStringPtr)
    return CC_SHA256_Update(v2, CStringPtr, result);
  do
  {
    if (!v7)
      break;
    usedBufLen = 0;
    v12.location = (CFIndex)CStringPtr;
    v12.length = v7;
    result = CFStringGetBytes(v4, v12, 0x8000100u, 0, 0, buffer, 0x8000, &usedBufLen);
    v8 = result;
    if (usedBufLen)
      result = CC_SHA256_Update(v2, buffer, usedBufLen);
    CStringPtr += v8;
    v7 -= v8;
  }
  while (v8);
  return result;
}

uint64_t C3DEngineContextGetCoordinatesSystemOptions(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(__int16 *)(a1 + 214);
}

uint64_t C3DWasLinkedBeforeMajorOSYear2023()
{
  if (C3DWasLinkedBeforeMajorOSYear2023_onceToken != -1)
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2023_onceToken, &__block_literal_global_10_0);
  return C3DWasLinkedBeforeMajorOSYear2023_linkedBeforeMajorOSYear2023;
}

const __CFDictionary *C3DEngineContextGetRenderingOptionForKey(uint64_t a1, void *key)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(const __CFDictionary **)(a1 + 376);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, key);
  return result;
}

const __CFString *__configureOpenSubdivSupport(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t NodeHashCode;
  int v7;
  int v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  const void *v12;
  const __CFString *result;

  NodeHashCode = C3DProgramHashCodeGetNodeHashCode(a3);
  v7 = C3DProgramHashCodeOpenSubdivPatchType(a3);
  if ((NodeHashCode & 0x20) != 0 && a2)
  {
    v8 = v7;
    v9 = 0x2000010000;
    if ((NodeHashCode & 0x80) == 0)
      v9 = 0x2000000000;
    *(_QWORD *)(a1 + 208) = C3DSubdivisionOsdGPUGetProgramGeneratorResources(v7 & 0xFFFFFEFF | (((NodeHashCode >> 6) & 1) << 8) | v9, (NodeHashCode >> 8) & 0x7FFFF, *(void **)(a1 + 8));
    *(_QWORD *)(a1 + 216) = C3DSubdivisionOsdGPUGetPerPatchTypeSources(v8);
    v10 = (void *)MEMORY[0x1E0CB3940];
    v11 = C3DSubdivisionOsdGPUGetSharedSources();
    v12 = C3DGetTextResourceWithNameAllowingHotReload(CFSTR("C3D-OpenSubdiv-Utils.h"));
    result = (const __CFString *)objc_msgSend(v10, "stringWithFormat:", CFSTR("%@%@%@"), v11, v12, C3DGetTextResourceWithNameAllowingHotReload(CFSTR("C3D-OpenSubdiv-Utils.metal")));
  }
  else
  {
    result = &stru_1EA5A6480;
    *(_QWORD *)(a1 + 208) = &stru_1EA5A6480;
    *(_QWORD *)(a1 + 216) = &stru_1EA5A6480;
  }
  *(_QWORD *)(a1 + 224) = result;
  return result;
}

uint64_t C3DProgramHashCodeGetNodeHashCode(uint64_t a1)
{
  return *(unsigned int *)(a1 + 124);
}

uint64_t __InjectAllModifiersIfNeeded(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  id v10;
  int ModifierFlag;
  int v12;
  int v13;
  unsigned int v14;
  void *v15;
  uint64_t v16;
  const __CFDictionary *StandardUniforms;
  _QWORD v19[5];
  _QWORD v20[5];
  _QWORD v21[5];
  uint64_t v22[32];
  uint64_t v23[32];
  uint64_t v24[36];

  v24[33] = *MEMORY[0x1E0C80C00];
  memset(v24, 0, 256);
  v2 = C3DProgramHashCodeCopyShaderModifiersForEntryPoint(*(_QWORD *)a1, 0, 0, (uint64_t)v24, 32);
  memset(v23, 0, sizeof(v23));
  v3 = C3DProgramHashCodeCopyShaderModifiersForEntryPoint(*(_QWORD *)a1, 1, 0, (uint64_t)v23, 32);
  memset(v22, 0, sizeof(v22));
  v4 = C3DProgramHashCodeCopyShaderModifiersForEntryPoint(*(_QWORD *)a1, 2, 0, (uint64_t)v22, 32);
  *(_QWORD *)(a1 + 152) = 0;
  v5 = C3DProgramHashCodeCopyShaderModifiersForEntryPoint(*(_QWORD *)a1, 3, 0, a1 + 152, 1);
  if (v5 >= 2)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      __InjectAllModifiersIfNeeded_cold_1();
    v5 = 1;
  }
  if (v2 >= 2)
  {
    v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      __InjectAllModifiersIfNeeded_cold_1();
    v2 = 1;
  }
  if (v3 >= 2)
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      __InjectAllModifiersIfNeeded_cold_1();
    v3 = 1;
  }
  if (v4 >= 2)
  {
    v9 = scn_default_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      __InjectAllModifiersIfNeeded_cold_1();
    v4 = 1;
  }
  __AppendModifierDefines(*(void **)(a1 + 8), v24, v2);
  __AppendModifierDefines(*(void **)(a1 + 8), v23, v3);
  __AppendModifierDefines(*(void **)(a1 + 8), v22, v4);
  __AppendModifierDefines(*(void **)(a1 + 8), (uint64_t *)(a1 + 152), v5);
  __AppendModifierArguments(a1, v24, v2);
  __AppendModifierArguments(a1, v23, v3);
  __AppendModifierArguments(a1, v22, v4);
  __AppendModifierArguments(a1, (uint64_t *)(a1 + 152), v5);
  v10 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  __UnifyModifierVaryings((uint64_t)v10, v24, v2);
  __UnifyModifierVaryings((uint64_t)v10, v23, v3);
  __UnifyModifierVaryings((uint64_t)v10, v22, v4);
  __UnifyModifierVaryings((uint64_t)v10, (uint64_t *)(a1 + 152), v5);
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v21[2] = ____InjectAllModifiersIfNeeded_block_invoke;
  v21[3] = &__block_descriptor_40_e35_v32__0__NSString_8__NSString_16_B24l;
  v21[4] = a1;
  objc_msgSend(v10, "enumerateKeysAndObjectsUsingBlock:", v21);

  ModifierFlag = __GetModifierFlag(v22, v4);
  v12 = __GetModifierFlag(v23, v3);
  v13 = __GetModifierFlag(v24, v2);
  v14 = __GetModifierFlag((uint64_t *)(a1 + 152), v5);
  if (v2)
  {
    objc_msgSend(*(id *)(a1 + 8), "setObject:forKeyedSubscript:", &stru_1EA5A6480, CFSTR("USE_GEOMETRY_MODIFIER"));
    __InjectModifiers(a1, 0, v24);
  }
  if (v3)
  {
    objc_msgSend(*(id *)(a1 + 8), "setObject:forKeyedSubscript:", &stru_1EA5A6480, CFSTR("USE_SURFACE_MODIFIER"));
    __InjectModifiers(a1, 1u, v23);
  }
  if (v4)
  {
    objc_msgSend(*(id *)(a1 + 8), "setObject:forKeyedSubscript:", &stru_1EA5A6480, CFSTR("USE_FRAGMENT_MODIFIER"));
    __InjectModifiers(a1, 2u, v22);
  }
  if (v5)
  {
    objc_msgSend(*(id *)(a1 + 8), "setObject:forKeyedSubscript:", &stru_1EA5A6480, CFSTR("USE_LIGHT_MODIFIER"));
    __InjectModifiers(a1, 3u, (uint64_t *)(a1 + 152));
  }
  v15 = *(void **)(a1 + 16);
  if (v15)
  {
    objc_msgSend(v15, "addObject:", CFSTR("USE_GEOMETRY_MODIFIER"));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", CFSTR("USE_SURFACE_MODIFIER"));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", CFSTR("USE_FRAGMENT_MODIFIER"));
    objc_msgSend(*(id *)(a1 + 16), "addObject:", CFSTR("USE_LIGHT_MODIFIER"));
    v16 = MEMORY[0x1E0C809B0];
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = ____InjectAllModifiersIfNeeded_block_invoke_2;
    v20[3] = &__block_descriptor_40_e21_v16__0____CFString__8l;
    v20[4] = a1;
    C3DShaderModifierEnumeratePossibleDefinesUsingBlock((uint64_t)v20);
    StandardUniforms = (const __CFDictionary *)C3DShaderGetStandardUniforms();
    v19[0] = v16;
    v19[1] = 3221225472;
    v19[2] = ____InjectAllModifiersIfNeeded_block_invoke_3;
    v19[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    v19[4] = a1;
    C3DCFDictionaryApplyBlock(StandardUniforms, (uint64_t)v19);
  }
  return v12 | ModifierFlag | v13 | v14;
}

uint64_t __UnifyModifierVaryings(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  void *v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t v8[4];
  _DWORD v9[7];

  *(_QWORD *)&v9[5] = *MEMORY[0x1E0C80C00];
  if (a3 >= 1)
  {
    v3 = a3;
    v5 = (void *)result;
    do
    {
      v6 = *a2;
      if (!*a2)
      {
        v7 = scn_default_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
          __UnifyModifierVaryings_cold_1(v8, v9, v7);
      }
      result = C3DShaderModifierGetVaryings(v6);
      if (result)
        result = objc_msgSend(v5, "addEntriesFromDictionary:", result);
      ++a2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t __GetModifierFlag(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  uint64_t v5;

  if (a2 < 1)
  {
    LOWORD(v4) = 0;
  }
  else
  {
    v2 = a2;
    v4 = 0;
    do
    {
      v5 = *a1++;
      v4 |= C3DShaderModifierGetFlags(v5);
      --v2;
    }
    while (v2);
  }
  return (__int16)v4;
}

void __AppendModifierDefines(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  const __CFDictionary *Defines;

  if (a3 >= 1)
  {
    v3 = a3;
    do
    {
      Defines = (const __CFDictionary *)C3DShaderModifierGetDefines(*a2);
      if (Defines)
        CFDictionaryApplyFunction(Defines, (CFDictionaryApplierFunction)__appendDictionary, a1);
      ++a2;
      --v3;
    }
    while (v3);
  }
}

uint64_t __AppendModifierArguments(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  int EntryPoint;
  BOOL v11;
  _QWORD v12[5];
  int v13;
  BOOL v14;
  uint8_t v15[4];
  _DWORD v16[7];

  *(_QWORD *)&v16[5] = *MEMORY[0x1E0C80C00];
  if (a3 >= 1)
  {
    v3 = a3;
    v5 = result;
    v6 = MEMORY[0x1E0C809B0];
    do
    {
      v7 = *a2;
      if (!*a2)
      {
        v8 = scn_default_log();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
          __UnifyModifierVaryings_cold_1(v15, v16, v8);
      }
      result = C3DShaderModifierGetArguments(v7);
      if (result)
      {
        v9 = (void *)result;
        EntryPoint = C3DShaderModifierGetEntryPoint(*a2);
        v11 = EntryPoint && (EntryPoint != 3 || *(_BYTE *)(v5 + 203));
        v12[0] = v6;
        v12[1] = 3221225472;
        v12[2] = ____AppendModifierArguments_block_invoke;
        v12[3] = &__block_descriptor_45_e35_v32__0__NSString_8__NSString_16_B24l;
        v12[4] = v5;
        v14 = v11;
        v13 = EntryPoint;
        result = objc_msgSend(v9, "enumerateKeysAndObjectsUsingBlock:", v12);
      }
      ++a2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t C3DProgramHashCodeCopyShaderModifiersForEntryPoint(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  const __CFArray *v9;
  _QWORD v11[2];
  uint64_t v12;
  int v13;
  int v14;
  CFRange v15;

  v5 = 0;
  v11[0] = a4;
  v11[1] = a5;
  v12 = 0;
  v6 = a1 + 16;
  v7 = 1;
  v13 = a2;
  v14 = a3;
  do
  {
    v8 = v7;
    v9 = *(const __CFArray **)(v6 + 8 * v5);
    if (v9)
    {
      v15.length = CFArrayGetCount(*(CFArrayRef *)(v6 + 8 * v5));
      v15.location = 0;
      CFArrayApplyFunction(v9, v15, (CFArrayApplierFunction)__dispatchShaderModifiers, v11);
    }
    v7 = 0;
    v5 = 1;
  }
  while ((v8 & 1) != 0);
  return v12;
}

uint64_t C3DProgramHashCodeUsePointRendering(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 9) & 1;
}

uint64_t C3DProgramHashCodeOpenSubdivPatchType(uint64_t a1)
{
  return *(_BYTE *)(a1 + 202) & 7;
}

uint64_t C3DProgramHashCodeHasNormals(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 3) & 1;
}

uint64_t C3DProgramHashCodeHasFog(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 7) & 1;
}

uint64_t C3DProgramHashCodeGlobalAlphaIsOne(uint64_t a1)
{
  return *(_WORD *)(a1 + 200) & 1;
}

uint64_t C3DProgramHashCodeGetUVSetsCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 163);
}

uint64_t C3DProgramHashCodeGetRenderMode(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 199) >> 3) & 3;
}

uint64_t C3DProgramHashCodeGetProbesLightingOrder(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 11) & 7;
}

uint64_t C3DSceneSourceGetStatus(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t C3DProgramHashCodeGetLocalLightingEnabled(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 202) >> 3) & 1;
}

uint64_t C3DProgramHashCodeGetLightsMask(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 161);
}

uint64_t C3DProgramHashCodeGetLightsCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 160);
}

uint64_t C3DProgramHashCodeGetLightingEnabled(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 5) & 1;
}

uint64_t C3DProgramHashCodeGetEyeCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 198);
}

uint64_t C3DProgramHashCodeGetCustomSlotCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 162);
}

uint64_t C3DProgramHashCodeGetConditioners(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 196);
}

uint64_t C3DProgramHashCodeGetCommonProfileHashCode(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 120);
}

uint64_t C3DProgramHashCodeGetAmbientLightingEnabled(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 6) & 1;
}

const __CFString *C3DLightingModelGetDescription(unsigned int a1)
{
  if (a1 > 6)
    return CFSTR("SCNLightingModelInvalid");
  else
    return off_1EA5A1158[a1];
}

CFHashCode C3DFXMetalProgramUpdateHashWithCommonProfileHashCode(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFHashCode result;
  unint64_t v13;

  if (!cf)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DFXMetalProgramUpdateHashWithCommonProfileHashCode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = CFHash(cf);
  v13 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * result) ^ ((0x9DDFEA08EB382D69 * result) >> 47));
  *(_QWORD *)(a1 + 168) = 0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47));
  return result;
}

uint64_t C3DFXMetalProgramCreateFromSource(const void *a1, const void *a2, int a3, const void *a4, const void *a5, const void *a6, const void *a7, int a8, char a9)
{
  uint64_t v17;
  const void *v18;
  CFTypeRef v19;
  const void *v20;
  CFTypeRef v21;
  const void *v22;
  CFTypeRef v23;
  const void *v24;
  CFTypeRef v25;
  const void *v26;
  CFTypeRef v27;
  const void *v28;
  CFTypeRef v29;
  const void *v30;
  const void *v31;

  v17 = C3DFXMetalProgramCreate();
  v18 = *(const void **)(v17 + 80);
  if (v18 != a1)
  {
    if (v18)
    {
      CFRelease(v18);
      *(_QWORD *)(v17 + 80) = 0;
    }
    if (a1)
      v19 = CFRetain(a1);
    else
      v19 = 0;
    *(_QWORD *)(v17 + 80) = v19;
  }
  v20 = *(const void **)(v17 + 88);
  if (v20 != a2)
  {
    if (v20)
    {
      CFRelease(v20);
      *(_QWORD *)(v17 + 88) = 0;
    }
    if (a2)
      v21 = CFRetain(a2);
    else
      v21 = 0;
    *(_QWORD *)(v17 + 88) = v21;
  }
  v22 = *(const void **)(v17 + 96);
  if (v22 != a4)
  {
    if (v22)
    {
      CFRelease(v22);
      *(_QWORD *)(v17 + 96) = 0;
    }
    if (a4)
      v23 = CFRetain(a4);
    else
      v23 = 0;
    *(_QWORD *)(v17 + 96) = v23;
  }
  v24 = *(const void **)(v17 + 104);
  if (v24 != a5)
  {
    if (v24)
    {
      CFRelease(v24);
      *(_QWORD *)(v17 + 104) = 0;
    }
    if (a5)
      v25 = CFRetain(a5);
    else
      v25 = 0;
    *(_QWORD *)(v17 + 104) = v25;
  }
  v26 = *(const void **)(v17 + 112);
  if (v26 != a6)
  {
    if (v26)
    {
      CFRelease(v26);
      *(_QWORD *)(v17 + 112) = 0;
    }
    if (a6)
      v27 = CFRetain(a6);
    else
      v27 = 0;
    *(_QWORD *)(v17 + 112) = v27;
  }
  v28 = *(const void **)(v17 + 120);
  if (v28 != a7)
  {
    if (v28)
    {
      CFRelease(v28);
      *(_QWORD *)(v17 + 120) = 0;
    }
    if (a7)
      v29 = CFRetain(a7);
    else
      v29 = 0;
    *(_QWORD *)(v17 + 120) = v29;
  }
  *(_DWORD *)(v17 + 144) = a3;
  v30 = *(const void **)(v17 + 152);
  if (v30)
  {
    CFRelease(v30);
    *(_QWORD *)(v17 + 152) = 0;
  }
  v31 = *(const void **)(v17 + 160);
  if (v31)
  {
    CFRelease(v31);
    *(_QWORD *)(v17 + 160) = 0;
  }
  *(_DWORD *)(v17 + 176) = a8;
  if (a9)
    _C3DFXMetalProgramUpdateHashWithSource((_QWORD *)v17);
  return v17;
}

uint64_t C3DFXMetalProgramCreateFromDefaultLibrary(const void *a1, const void *a2)
{
  uint64_t v4;
  const void *v5;
  CFTypeRef v6;
  const void *v7;
  CFTypeRef v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;

  v4 = C3DFXMetalProgramCreate();
  v5 = *(const void **)(v4 + 80);
  if (v5 != a1)
  {
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(v4 + 80) = 0;
    }
    if (a1)
      v6 = CFRetain(a1);
    else
      v6 = 0;
    *(_QWORD *)(v4 + 80) = v6;
  }
  v7 = *(const void **)(v4 + 88);
  if (v7 != a2)
  {
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(v4 + 88) = 0;
    }
    if (a2)
      v8 = CFRetain(a2);
    else
      v8 = 0;
    *(_QWORD *)(v4 + 88) = v8;
  }
  v9 = *(const void **)(v4 + 96);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(v4 + 96) = 0;
  }
  v10 = *(const void **)(v4 + 104);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(v4 + 104) = 0;
  }
  v11 = *(const void **)(v4 + 112);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(v4 + 112) = 0;
  }
  v12 = *(const void **)(v4 + 120);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(v4 + 120) = 0;
  }
  *(_DWORD *)(v4 + 144) = 0;
  v13 = *(const void **)(v4 + 152);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(v4 + 152) = 0;
  }
  v14 = *(const void **)(v4 + 160);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(v4 + 160) = 0;
  }
  _C3DFXMetalProgramUpdateHashWithLibrary((_QWORD *)v4);
  return v4;
}

uint64_t C3DFXMetalProgramCreate()
{
  uint64_t Instance;
  uint64_t v1;

  if (C3DFXMetalProgramGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  Instance = C3DTypeCreateInstance_(C3DFXMetalProgramGetTypeID_typeID, 0xA8uLL);
  v1 = Instance;
  if (Instance)
  {
    C3DFXProgramInitialize(Instance);
    *(_DWORD *)(v1 + 64) = 2;
    *(_QWORD *)(v1 + 80) = 0;
    *(_QWORD *)(v1 + 88) = 0;
  }
  return v1;
}

uint64_t C3DFXProgramInitialize(uint64_t result)
{
  *(_BYTE *)(result + 68) |= 1u;
  return result;
}

CFHashCode _C3DFXMetalProgramUpdateHashWithLibrary(_QWORD *a1)
{
  uint64_t v2;
  unint64_t v3;
  const void *v4;
  CFHashCode v5;
  CFHashCode result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  v2 = a1[19];
  if (v2)
    v3 = 0x9DDFEA08EB382D69 * (*(uint64_t (**)(void))(v2 + 16))();
  else
    v3 = 0;
  v4 = (const void *)a1[10];
  if (v4)
    v5 = CFHash(v4);
  else
    v5 = 0;
  result = a1[11];
  if (result)
    result = CFHash((CFTypeRef)result);
  v7 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47))) >> 47));
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ ((0x9DDFEA08EB382D69 * (v5 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v5 ^ v7)));
  v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  a1[21] = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v9 ^ ((0x9DDFEA08EB382D69 * (result ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (result ^ v9)))) ^ ((0x9DDFEA08EB382D69 * (v9 ^ ((0x9DDFEA08EB382D69 * (result ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (result ^ v9)))) >> 47));
  return result;
}

uint64_t C3DEngineContextGetVertexAmplificationEnabled(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

void sub_1DCCD94C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t C3DShaderModifierGetVaryings(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 72);
}

uint64_t C3DApplyBlendStatesToRenderPipelineDescriptor(uint64_t a1, void *a2)
{
  unint64_t Desc;
  unint64_t v4;
  void *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unsigned __int8 v12;
  unsigned __int8 v13;

  Desc = C3DBlendStatesGetDesc(a1, 0);
  v4 = HIDWORD(Desc);
  v5 = (void *)objc_msgSend((id)objc_msgSend(a2, "colorAttachments"), "objectAtIndexedSubscript:", 0);
  v6 = objc_msgSend(v5, "pixelFormat");
  if ((_BYTE)Desc)
    v7 = v6 == 0;
  else
    v7 = 1;
  v8 = !v7;
  objc_msgSend(v5, "setBlendingEnabled:", v8);
  objc_msgSend(v5, "setSourceRGBBlendFactor:", C3DBlendFactorToMTLBlendFactor(BYTE2(Desc)));
  objc_msgSend(v5, "setDestinationRGBBlendFactor:", C3DBlendFactorToMTLBlendFactor(BYTE3(Desc)));
  objc_msgSend(v5, "setRgbBlendOperation:", C3DBlendOpToMTLBlendOperation(BYTE4(Desc)));
  v9 = HIBYTE(Desc);
  v10 = Desc >> 40;
  v11 = (Desc & 0xFF00) == 0;
  if ((Desc & 0xFF00) != 0)
  {
    v12 = BYTE6(Desc);
  }
  else
  {
    LOBYTE(v10) = BYTE2(Desc);
    v12 = BYTE3(Desc);
  }
  if (v11)
    v13 = v4;
  else
    v13 = v9;
  objc_msgSend(v5, "setSourceAlphaBlendFactor:", C3DBlendFactorToMTLBlendFactor(v10));
  objc_msgSend(v5, "setDestinationAlphaBlendFactor:", C3DBlendFactorToMTLBlendFactor(v12));
  return objc_msgSend(v5, "setAlphaBlendOperation:", C3DBlendOpToMTLBlendOperation(v13));
}

uint64_t C3DBlendFactorToMTLBlendFactor(unsigned int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 0xF)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DBlendFactorToMTLBlendFactor_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return mtl_BlendModes[a1];
}

uint64_t C3DBlendOpToMTLBlendOperation(unsigned int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 5)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DBlendOpToMTLBlendOperation_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return mtl_BlendOps[a1];
}

unint64_t SCNMTLRenderPipelineApplyRenderPassDescriptor(uint64_t a1, void *a2)
{
  uint64_t i;
  unint64_t v5;
  unsigned __int8 v6;
  unint64_t v7;
  unint64_t result;
  char v9;

  for (i = 0; i != 8; ++i)
    *(_QWORD *)(a1 + 8 * i) = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "colorAttachments"), "objectAtIndexedSubscript:", i), "texture"), "pixelFormat");
  *(_QWORD *)(a1 + 64) = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "depthAttachment"), "texture"), "pixelFormat");
  *(_QWORD *)(a1 + 72) = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "stencilAttachment"), "texture"), "pixelFormat");
  *(_BYTE *)(a1 + 80) = 1;
  v5 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "colorAttachments"), "objectAtIndexedSubscript:", 0), "texture"), "sampleCount");
  if (v5 <= 1)
    v6 = 1;
  else
    v6 = v5;
  *(_BYTE *)(a1 + 80) = v6;
  v7 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "depthAttachment"), "texture"), "sampleCount");
  if (v6 <= v7)
    v6 = v7;
  *(_BYTE *)(a1 + 80) = v6;
  result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "stencilAttachment"), "texture"), "sampleCount");
  v9 = v6;
  if (v6 <= result)
    v9 = result;
  *(_BYTE *)(a1 + 80) = v9;
  return result;
}

void sub_1DCCD9D68(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x300], 8);
  _Block_object_dispose(&STACK[0x330], 8);
  _Unwind_Resume(a1);
}

uint64_t C3DFXMetalProgramGetFunctionName(CFTypeRef cf, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeID v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (!cf)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DResourceManagerMakeProgramResident_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  if (v12 != C3DFXMetalProgramGetTypeID_typeID)
  {
    v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      C3DFXMetalProgramGetHash_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
  }
  return *((_QWORD *)cf + a2 + 10);
}

uint64_t C3DMeshElementGetIndexCount(uint64_t a1)
{
  int Type;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  Type = C3DMeshElementGetType(a1);
  if (Type != 4)
    return C3DMeshElementGetIndexCountWithTypeAndPrimitiveCount(Type, *(unsigned int *)(a1 + 104));
  v4 = *(unsigned __int8 *)(a1 + 80);
  v3 = *(unsigned int *)(a1 + 104);
  v5 = CFDataGetLength(*(CFDataRef *)(a1 + 96)) / v4 - v3;
  v6 = *(unsigned __int8 *)(a1 + 130);
  v7 = v5 / v6;
  if (v5 % v6)
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      C3DMeshElementGetIndexCount_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
  }
  return v7;
}

uint64_t C3DMeshElementGetType(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(char *)(a1 + 88);
}

uint64_t C3DMeshElementGetIndexes(uint64_t a1, _DWORD *a2)
{
  if (a2)
    *a2 = *(unsigned __int8 *)(a1 + 80);
  return *(_QWORD *)(a1 + 96);
}

uint64_t C3DMeshElementGetSharedMeshElement(uint64_t result)
{
  if (*(_QWORD *)(result + 72))
    return *(_QWORD *)(result + 72);
  return result;
}

uint64_t C3DMeshElementGetInstanceCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 68);
}

BOOL C3DMeshElementIsVolatile(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_BYTE *)(a1 + 82) != 0;
}

BOOL C3DGeometryGetEffectiveDataKindForRendering(__C3DGeometry *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return !C3DGeometryOsdGetWantsGPUSubdivision(a1);
}

BOOL C3DGeometryOsdGetWantsGPUSubdivision(__C3DGeometry *a1)
{
  return a1->var10.var0 && a1->var11.var0 == 4 && C3DGeometryMeshElementsSupportsSubdivision(a1);
}

uint64_t C3DFXMetalProgramGetTypeID()
{
  if (C3DFXMetalProgramGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  return C3DFXMetalProgramGetTypeID_typeID;
}

uint64_t C3DNodeGetSkinner(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 248);
  if (result)
    return C3DDeformerStackGetSkinner(result);
  return result;
}

BOOL C3DGeometryGetWantsHardwareTessellation(__C3DGeometry *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (a1->var11.var0 - 1 < 3)
    return C3DGeometryMeshElementsSupportsTessellation((uint64_t)a1);
  if (a1->var11.var0)
    return C3DGeometryOpenSubdivGPUIsActive(a1);
  return 0;
}

uint64_t C3DGeometryGetOverrideMaterial(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t C3DMaterialGetColorBufferWriteMask(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 93);
}

uint64_t C3DMeshElementGetPrimitiveRange(uint64_t a1)
{
  if (*(_WORD *)(a1 + 128) == 1)
    return **(_QWORD **)(a1 + 120);
  else
    return -1;
}

void SCNMTLRenderCommandEncoder::setFragmentTexture(uint64_t a1, void *a2, unint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a2)
  {
    if ((objc_msgSend(a2, "conformsToProtocol:", &unk_1F040D6D0) & 1) == 0)
    {
      v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
        SCNMTLRenderCommandEncoder::setFragmentTexture(v6, v7, v8);
    }
  }
  v9 = a1 + 8 * a3;
  if (*(void **)(v9 + 2224) != a2)
  {
    *(_QWORD *)(v9 + 2224) = a2;
    *(_QWORD *)(a1 + 8 * (a3 >> 6) + 3424) |= 1 << a3;
  }
}

uint64_t C3DMaterialGetBlendStates(uint64_t a1, int a2, int a3, int a4, float *a5, float a6)
{
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float *v27;
  float v28;
  NSObject *v30;
  float FloatProperty;
  float *Color;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;

  switch(*(_BYTE *)(a1 + 92))
  {
    case 0:
      if (!*(_QWORD *)(a1 + 64) && (v11 = scn_default_log(), os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)))
      {
        C3DMaterialGetBlendStates_cold_3(v11, v12, v13, v14, v15, v16, v17, v18);
        if (a5)
          goto LABEL_7;
      }
      else if (a5)
      {
        goto LABEL_7;
      }
      v19 = scn_default_log();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        C3DMaterialGetBlendStates_cold_2(v19, v20, v21, v22, v23, v24, v25, v26);
LABEL_7:
      if (a2)
      {
        if (a6 >= 1.0)
          return C3DBlendStatesDefaultReplace();
        v27 = a5;
        v28 = a6;
        goto LABEL_10;
      }
      v40 = 1.0;
      if (!a3 || !C3DEffectCommonProfileHasConstantAlpha(*(float **)(a1 + 64), &v40))
        return C3DBlendStatesDefaultOver();
      if (C3DEffectCommonProfileGetTransparencyMode(*(_QWORD *)(a1 + 64)) != 1)
      {
        v28 = v40 * a6;
        v27 = a5;
LABEL_10:
        C3DColor4Make(v27, 0.0, 0.0, 0.0, v28);
        return C3DBlendStatesDefaultConstantAlpha();
      }
      FloatProperty = C3DEffectCommonProfileGetFloatProperty(*(float **)(a1 + 64), 18);
      Color = (float *)C3DEffectCommonProfileGetColor(*(_QWORD *)(a1 + 64), 5);
      v33 = Color[1];
      v34 = Color[2];
      v35 = v33 * 0.71516 + *Color * 0.212671 + v34 * 0.072169;
      v36 = (1.0 - (float)(FloatProperty * *Color)) * a6;
      v37 = (1.0 - (float)(FloatProperty * v33)) * a6;
      v38 = (1.0 - (float)(FloatProperty * v34)) * a6;
      v39 = (1.0 - (float)(FloatProperty * v35)) * a6;
      C3DColor4Make(a5, v36, v37, v38, v39);
      return C3DBlendStatesDefaultConstantColor();
    case 1:
      return C3DBlendStatesDefaultAdditive();
    case 2:
      return C3DBlendStatesDefaultSubtract();
    case 3:
      if (a4)
        return C3DBlendStatesDefaultMultiplicativeSeparate();
      else
        return C3DBlendStatesDefaultMultiplicative();
    case 4:
      return C3DBlendStatesDefaultScreen();
    case 5:
      return C3DBlendStatesDefaultReplace();
    case 6:
      return C3DBlendStatesDefaultMax();
    default:
      v30 = scn_default_log();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        C3DMaterialGetBlendStates_cold_1(v30);
      return C3DBlendStatesDefaultOver();
  }
}

uint64_t C3DBlendStatesNeedsConstantColor(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DBlendStatesGetDesc_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t C3DMeshElementTypeToMTLPrimitiveType(int a1)
{
  uint64_t result;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  result = 0;
  switch(a1)
  {
    case 0:
      result = 3;
      break;
    case 1:
      result = 4;
      break;
    case 2:
      result = 1;
      break;
    case 4:
      v3 = scn_default_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
        C3DMeshElementTypeToMTLPrimitiveType_cold_2(v3, v4, v5, v6, v7, v8, v9, v10);
      goto LABEL_9;
    case 5:
      v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
        C3DMeshElementTypeToMTLPrimitiveType_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
LABEL_9:
      result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t C3DMeshElementGetMTLBuffer(uint64_t a1)
{
  return *(_QWORD *)(a1 + 136);
}

uint64_t C3DBlendStatesDefaultReplace()
{
  if (C3DBlendStatesDefaultReplace_onceToken != -1)
    dispatch_once(&C3DBlendStatesDefaultReplace_onceToken, &__block_literal_global_21_1);
  return C3DBlendStatesDefaultReplace_states;
}

uint64_t C3DEngineContextIsWarmUp(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 461);
}

uint64_t C3DFXMetalProgramGetHash(_QWORD *a1)
{
  CFTypeID v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = CFGetTypeID(a1);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  if (v2 != C3DFXMetalProgramGetTypeID_typeID)
  {
    v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      C3DFXMetalProgramGetHash_cold_1(v3, v4, v5, v6, v7, v8, v9, v10);
  }
  return a1[21];
}

uint64_t C3DFXMetalProgramGetConstants(CFTypeRef cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeID v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DResourceManagerMakeProgramResident_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
  }
  return *((_QWORD *)cf + 16);
}

uint64_t C3DBlendStatesGetDesc(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DBlendStatesGetDesc_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (*(_QWORD *)(a1 + 48) <= a2)
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      C3DBlendStatesGetDesc_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  return *(_QWORD *)(a1 + 8 * a2 + 16);
}

uint64_t SCNMTLRenderCommandEncoder::setVertexBuffer(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;

  v4 = result + 16 * a4;
  if (*(_QWORD *)(v4 + 80) == a2)
  {
    v6 = *(_QWORD *)(v4 + 88);
    v5 = (uint64_t *)(v4 + 88);
    if (v6 != a3)
    {
      *v5 = a3;
      return objc_msgSend(*(id *)(result + 3392), "setVertexBufferOffset:atIndex:", a3, a4);
    }
  }
  else
  {
    *(_QWORD *)(v4 + 80) = a2;
    *(_QWORD *)(v4 + 88) = a3;
    return objc_msgSend(*(id *)(result + 3392), "setVertexBuffer:offset:atIndex:", a2);
  }
  return result;
}

uint64_t C3DDynamicBatchingSystemGetCurrentBatchNodes(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v3;

  v3 = a1 + 24;
  result = *(_QWORD *)(a1 + 24);
  *a2 = *(_QWORD *)(v3 + 8);
  return result;
}

uint64_t C3DBlendStatesDefaultOver()
{
  if (C3DBlendStatesDefaultOver_onceToken != -1)
    dispatch_once(&C3DBlendStatesDefaultOver_onceToken, &__block_literal_global_15_2);
  return C3DBlendStatesDefaultOver_states;
}

void _C3DRasterizerStatesCFFinalize(_BYTE *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t SharedInstance;

  if (a1[44])
  {
    if (os_unfair_lock_trylock((os_unfair_lock_t)&s_RasterizerStatesRegistryLock))
    {
      v2 = scn_default_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
        _C3DRasterizerStatesCFFinalize_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
    }
    if (!CFSetContainsValue((CFSetRef)s_RasterizerStatesRegistry, a1))
    {
      v10 = scn_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        _C3DRasterizerStatesCFFinalize_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
    CFSetRemoveValue((CFMutableSetRef)s_RasterizerStatesRegistry, a1);
    SharedInstance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterPostNotification(SharedInstance, CFSTR("kC3DNotificationRasterizerStatesDidDie"), a1, 0, 1u);
  }
}

void __appendDictionary(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

void __appendDictionary_0(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

uint64_t __appendDictionary_1(uint64_t a1, uint64_t a2, void *a3)
{
  return objc_msgSend(a3, "setObject:forKeyedSubscript:", a2, a1);
}

uint64_t C3DProgramHashCodeUseDynamicBatching(uint64_t a1)
{
  return HIBYTE(*(unsigned __int16 *)(a1 + 200)) & 1;
}

uint64_t C3DFXPassInstanceGetPass(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1)
    return *(_QWORD *)a1;
  v2 = scn_default_log();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
    C3DEngineContextRenderSubTechnique_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
  return 0;
}

void _processRendererElement(SCNMTLRenderContext *a1, __C3DRendererElement *a2, __C3DFXPassInstance *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t *Node;
  __C3DFXPass *pass;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const __CFDictionary *RendererDelegate;
  uint64_t v33;
  float32x4_t *WorldMatrix;
  SCNMTLRenderCommandEncoder *renderEncoder;
  unint64_t v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t Technique;
  uint64_t PassCount;
  uint64_t v47;
  uint64_t i;
  uint64_t PassAtIndex;
  int DrawInstruction;
  uint64_t v51;
  uint64_t RasterizerStates;
  uint64_t v53;
  NSObject *v54;
  uint64_t v55;
  uint64_t RaterizerStates;
  SCNMTLRenderContext *v57;
  __C3DEngineContext *engineContext;
  __int128 v59;
  uint8_t v60;
  _BYTE v61[7];
  uint64_t v62[10];
  uint64_t v63;

  if (!a2)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      _C3DRendererElementSync_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  Node = (float32x4_t *)C3DRendererElementGetNode((uint64_t)a2);
  v57 = a1;
  engineContext = a1->_engineContext;
  pass = a1->_processingContext.pass;
  if (C3DRendererElementIsHidden((uint64_t)a2))
  {
    v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
    {
      _processRendererElement(v16, v17, v18, v19, v20, v21, v22, v23);
      if (Node)
        goto LABEL_7;
LABEL_17:
      if (C3DRendererElementIsRendererDelegate((uint64_t)a2))
        return;
      goto LABEL_18;
    }
  }
  if (!Node)
    goto LABEL_17;
LABEL_7:
  if (C3DNodeGetOpacity((uint64_t)Node) <= 0.0 && (*((_WORD *)a2 + 36) & 7) != 2)
  {
    v24 = scn_default_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      _processRendererElement(v24, v25, v26, v27, v28, v29, v30, v31);
  }
  if (C3DRendererElementIsRendererDelegate((uint64_t)a2))
  {
    RendererDelegate = C3DNodeGetRendererDelegate((uint64_t)Node);
    if (RendererDelegate)
    {
      v33 = (uint64_t)RendererDelegate;
      WorldMatrix = C3DNodeGetWorldMatrix(Node);
      C3DEngineContextSetMatrix4x4((uint64_t)engineContext, 2, (uint64_t)WorldMatrix);
      C3DRendererDelegateFireWithNode(v33, (uint64_t)engineContext, (uint64_t)Node, (uint64_t)pass);
      renderEncoder = a1->_renderEncoder;
      v36 = renderEncoder->var25[0];
      v59 = *(_OWORD *)renderEncoder->var24;
      bzero(v57->_renderEncoder, 0xD70uLL);
      LODWORD(renderEncoder->var14[0].var1) = 1;
      LOBYTE(renderEncoder->var14[1].var0) = 1;
      *(_OWORD *)renderEncoder->var24 = v59;
      renderEncoder->var25[0] = v36;
      *(_WORD *)&renderEncoder->var5 = 257;
      renderEncoder->var7 = 1;
      *(_OWORD *)&renderEncoder->var1 = 0u;
      *(_OWORD *)&renderEncoder->var3 = 0u;
      return;
    }
    v37 = scn_default_log();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
      _processRendererElement(v37, v38, v39, v40, v41, v42, v43, v44);
  }
LABEL_18:
  Technique = *((_QWORD *)a2 + 5);
  if (!Technique && ((v55 = *((_QWORD *)a2 + 4)) == 0 || (Technique = C3DMaterialGetTechnique(v55)) == 0)
    || a3 && *(_QWORD *)a3 && (*(_BYTE *)(*(_QWORD *)a3 + 186) & 0x10) != 0)
  {
    -[SCNMTLRenderContext drawRenderElement:withPass:]((uint64_t)a1, (uint64_t)a2, (uint64_t)pass);
  }
  else if (Technique != C3DFXTechniqueGetNullTechnique())
  {
    RaterizerStates = C3DRendererElementGetRaterizerStates((uint64_t)a2);
    PassCount = C3DFXTechniqueGetPassCount(Technique);
    if (PassCount >= 1)
    {
      v47 = PassCount;
      for (i = 0; i != v47; ++i)
      {
        PassAtIndex = C3DFXTechniqueGetPassAtIndex(Technique, i);
        if ((C3DFXPassIsTopLevel(PassAtIndex) & 1) == 0)
        {
          DrawInstruction = C3DFXPassGetDrawInstruction(PassAtIndex);
          v62[0] = PassAtIndex;
          v62[1] = Technique;
          v62[2] = (uint64_t)Node;
          v62[3] = (uint64_t)engineContext;
          v62[5] = 0;
          v62[6] = 0;
          v51 = *(_QWORD *)(PassAtIndex + 280);
          v62[4] = (uint64_t)a3 + 80;
          v62[7] = v51;
          v62[8] = (uint64_t)a2;
          v62[9] = *((unsigned __int8 *)a3 + 25);
          v63 = 0;
          LOWORD(v63) = *(_WORD *)((char *)a3 + 27);
          C3DFXPassWillExecute(v62);
          switch(DrawInstruction)
          {
            case 1:
            case 7:
              C3DFXPassExecute((uint64_t)v62);
              break;
            case 2:
              RasterizerStates = C3DFXPassGetRasterizerStates(PassAtIndex);
              if (RasterizerStates)
                v53 = RasterizerStates;
              else
                v53 = RaterizerStates;
              if (v53)
                -[SCNMTLRenderContext setRasterizerStates:]((uint64_t)a1, v53);
              -[SCNMTLRenderContext drawRenderElement:withPass:]((uint64_t)a1, (uint64_t)a2, PassAtIndex);
              break;
            case 3:
            case 6:
            case 8:
              break;
            case 4:
              -[SCNMTLRenderContext drawFullScreenQuadForPass:]((uint64_t)a1, PassAtIndex);
              break;
            default:
              v54 = scn_default_log();
              if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                _processRendererElement(&v60, v61, v54);
              break;
          }
          C3DFXPassDidExecute((uint64_t)v62);
        }
      }
    }
  }
}

uint64_t C3DRendererElementIsHidden(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return C3DNodeIsHidden(result);
  return result;
}

uint64_t C3DRendererElementGetNode(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t C3DProgramHashCodeHasConstantAlpha(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 1) & 1;
}

uint64_t C3DProgramHashCodeIsOpaque(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 2) & 1;
}

void C3D::DrawNodesPass::_computeProgramHashCodeForRendererElement(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t RenderContext;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t ProgramHashCodeForRenderElement;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t Material;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  char v27;
  char v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const void *v36;
  uint64_t v37;
  unint64_t v38;
  _QWORD *v39;
  __C3DGeometry *v40;
  uint64_t v41;
  const void *v42;
  const void *v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t CommonProfile;
  uint64_t EffectSlot;
  BOOL HasImageOrTexture;
  uint64_t v49;
  uint64_t v50;
  const void *MeshElement;
  uint64_t Mesh;
  __C3DGeometry *Geometry;
  _QWORD *v54;
  uint64_t v55;
  _OWORD v56[6];
  uint64_t v57;

  if (*(_QWORD *)(a2 + 16) || *(_QWORD *)(a2 + 24))
  {
    RenderContext = C3DEngineContextGetRenderContext(*(_QWORD *)(a1 + 16));
    v11 = *(_QWORD **)(a2 + 8);
    v12 = *(_QWORD **)(a1 + 240);
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
    ProgramHashCodeForRenderElement = C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(a3, (unsigned __int16 *)a2, v12, v13);
    if (ProgramHashCodeForRenderElement)
    {
      if (!*(_BYTE *)(a1 + 296))
        return;
      if (a5)
      {
        v15 = *(_OWORD *)(a4 + 80);
        v56[4] = *(_OWORD *)(a4 + 64);
        v56[5] = v15;
        v57 = *(_QWORD *)(a4 + 96);
        v16 = *(_OWORD *)(a4 + 16);
        v56[0] = *(_OWORD *)a4;
        v56[1] = v16;
        v17 = *(_OWORD *)(a4 + 48);
        v56[2] = *(_OWORD *)(a4 + 32);
        v56[3] = v17;
        if (C3DProgramHashCodeMatchLightHashCodesAndLightingContext(ProgramHashCodeForRenderElement, (unsigned __int16 *)v56))
        {
          return;
        }
      }
LABEL_10:
      v19 = RenderContext;
      v54 = v11;
      Mesh = C3DRendererElementGetMesh(a2);
      MeshElement = C3DRendererElementGetMeshElement(a2);
      Geometry = (__C3DGeometry *)C3DRendererElementGetGeometry(a2);
      Material = C3DRendererElementGetMaterial(a2);
      v21 = *(_QWORD *)(a1 + 256);
      if (!v21)
        v21 = Material;
      v55 = v21;
      v22 = *(_QWORD *)(a2 + 8);
      if (v22)
      {
        if ((*(_BYTE *)(v22 + 221) & 0x10) != 0)
        {
          v23 = *(_QWORD *)(a2 + 40);
          if (v23)
            C3DFXTechniqueEnsureThatPassesShouldExecute(v23);
        }
      }
      v24 = *(unsigned __int16 *)(a1 + 298);
      v25 = *(unsigned __int8 *)(a1 + 4948);
      v26 = *(unsigned __int16 *)(a2 + 72);
      v27 = *(_BYTE *)(a1 + 117);
      v28 = *(_BYTE *)(a1 + 118);
      if (-[SCNMTLRenderContext reverseZ](v19))
        v29 = -128;
      else
        v29 = 0;
      v30 = (8 * (v27 & 3)) & 0x98 | (v26 >> 11) & 7 | v29 & 0xFFFFFF9F | (32 * (v28 & 3));
      if (!*(_QWORD *)(a1 + 256))
      {
        v43 = (const void *)C3DProgramHashCodeCreate(v54, Geometry, Mesh, (uint64_t)MeshElement, (_BYTE *)a4, v55, (v25 << 16) & 0xFFFFFFFF00FFFFFFLL | ((unint64_t)v30 << 24) | v24);
LABEL_28:
        v44 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
        C3DProgramHashCodeStoreRegisterProgramForRendererElementAndHashPass(a3, (unsigned int *)a2, v43, v44);
        if (v43)
          CFRelease(v43);
        return;
      }
      if (!C3DRendererElementIsOpaque(a2)
        || (v27 & 3) != 0
        || v55
        && (v31 = C3DRendererElementGetMaterial(a2), (C3DEntityHasShaderModifiers(v31, 0) & 1) != 0))
      {
        v32 = *(_WORD *)(a2 + 72);
        v33 = v24;
LABEL_25:
        *(_WORD *)(a2 + 72) = v32 | 0x400;
        v34 = C3DRendererElementGetGeometry(a2);
        v35 = C3DRendererElementGetMesh(a2);
        v36 = C3DRendererElementGetMeshElement(a2);
        v37 = C3DRendererElementGetMaterial(a2);
        v38 = (v25 << 16) & 0xFFFFFFFF00FFFFFFLL | ((unint64_t)v30 << 24) | v33;
        v39 = v54;
        v40 = (__C3DGeometry *)v34;
        v41 = v35;
        v42 = v36;
LABEL_26:
        v43 = (const void *)C3DProgramHashCodeCreate(v39, v40, v41, (uint64_t)v42, 0, v37, v38);
        goto LABEL_28;
      }
      if (Geometry)
        v45 = C3DEntityHasShaderModifiers((uint64_t)Geometry, 0) ^ 1;
      else
        v45 = 1;
      v33 = v24;
      if (v55
        && v45
        && (CommonProfile = C3DMaterialGetCommonProfile(v55),
            (EffectSlot = C3DEffectCommonProfileGetEffectSlot(CommonProfile, 15, 0)) != 0))
      {
        HasImageOrTexture = C3DEffectSlotHasImageOrTexture(EffectSlot);
        v32 = *(_WORD *)(a2 + 72);
        if (HasImageOrTexture)
          goto LABEL_25;
      }
      else
      {
        v32 = *(_WORD *)(a2 + 72);
        if (!v45)
          goto LABEL_25;
      }
      *(_WORD *)(a2 + 72) = v32 & 0xFBFF;
      v49 = C3DRendererElementGetGeometry(a2);
      v50 = C3DRendererElementGetMesh(a2);
      v42 = C3DRendererElementGetMeshElement(a2);
      v38 = (v25 << 16) & 0xFFFFFFFF00FFFFFFLL | ((unint64_t)v30 << 24) | v33;
      v39 = v54;
      v40 = (__C3DGeometry *)v49;
      v41 = v50;
      v37 = v55;
      goto LABEL_26;
    }
    v18 = *(_QWORD **)(a1 + 240);
    if (!v18 || !C3DFXPassGetOverridingProgramHashCode(0, v18, (unsigned __int16 *)a2))
      goto LABEL_10;
  }
}

unint64_t C3D::DrawNodesPass::programHashCodeStoreKey(C3D::DrawNodesPass *this)
{
  const char *v2;
  uint64_t RenderContext;
  unsigned __int16 v4;
  uint64_t v5;
  char v6;
  char v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  uint64_t v15;

  v2 = (const char *)(*(uint64_t (**)(C3D::DrawNodesPass *))(*(_QWORD *)this + 72))(this);
  RenderContext = C3DEngineContextGetRenderContext(*((_QWORD *)this + 2));
  v4 = *((_WORD *)this + 149);
  v5 = *((unsigned __int8 *)this + 4948);
  v6 = (8 * (*((_BYTE *)this + 117) & 3)) & 0x9F | (32 * (*((_BYTE *)this + 118) & 3));
  if (-[SCNMTLRenderContext reverseZ](RenderContext))
    v7 = 0x80;
  else
    v7 = 0;
  v8 = 0xC6A4A7935BD1E995
     * ((((unint64_t)((v6 | v7) & 0xF8) << 24) | (v5 << 16) | v4 & 0xFF00 | v4) ^ 0x1A929E4D6F47A654);
  v9 = 0xC6A4A7935BD1E995 * (v8 ^ (v8 >> 47));
  v10 = strlen(v2);
  v11 = (0xC6A4A7935BD1E995 * v10) ^ (v9 >> 47) ^ v9;
  if (v10 >= 8)
  {
    v12 = v10 >> 3;
    v13 = (unsigned __int8 *)&v2[8 * v12];
    v14 = 8 * v12;
    do
    {
      v15 = *(_QWORD *)v2;
      v2 += 8;
      v11 = 0xC6A4A7935BD1E995
          * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v15) ^ ((0xC6A4A7935BD1E995 * v15) >> 47))) ^ v11);
      v14 -= 8;
    }
    while (v14);
    v2 = (const char *)v13;
  }
  switch(v10 & 7)
  {
    case 1u:
      goto LABEL_15;
    case 2u:
      goto LABEL_14;
    case 3u:
      goto LABEL_13;
    case 4u:
      goto LABEL_12;
    case 5u:
      goto LABEL_11;
    case 6u:
      goto LABEL_10;
    case 7u:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 6) << 48;
LABEL_10:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 5) << 40;
LABEL_11:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 4) << 32;
LABEL_12:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 3) << 24;
LABEL_13:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 2) << 16;
LABEL_14:
      v11 ^= (unint64_t)*((unsigned __int8 *)v2 + 1) << 8;
LABEL_15:
      v11 = 0xC6A4A7935BD1E995 * (v11 ^ *(unsigned __int8 *)v2);
      break;
    default:
      return (0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) >> 47);
  }
  return (0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) >> 47);
}

uint64_t C3DEngineContextGetRenderContext(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 1704);
}

const char *C3D::DrawNodesPass::programHashCodeStoreName(C3D::DrawNodesPass *this, uint64_t a2, uint64_t a3, void *a4)
{
  const char **v4;

  v4 = (const char **)*((_QWORD *)this + 30);
  if (v4)
    return C3D::CachedFXPassName((void **)this + 669, v4, *(__C3DFXPass **)(*((_QWORD *)this + 3) + 16), a4);
  else
    return "DrawNodeDefault";
}

const void *C3DRendererElementGetMeshElement(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *result;
  CFTypeID v11;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DRendererElementSync_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = *(const void **)(a1 + 48);
  if (result)
  {
    v11 = CFGetTypeID(result);
    if (v11 == C3DMeshElementGetTypeID())
      return *(const void **)(a1 + 48);
    else
      return 0;
  }
  return result;
}

uint64_t C3DMeshElementGetTypeID()
{
  if (C3DMeshElementGetTypeID_onceToken != -1)
    dispatch_once(&C3DMeshElementGetTypeID_onceToken, &__block_literal_global_7);
  return C3DMeshElementGetTypeID_typeID;
}

uint64_t C3DRendererElementGetMesh(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DRendererElementSync_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 24);
}

uint64_t C3DRendererElementGetRaterizerStates(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DRendererElementSync_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = *(_QWORD *)(a1 + 32);
  if (result)
    return C3DMeshSourceGetMTLVertexFormat(result);
  return result;
}

void C3DProgramHashCodeStoreRegisterProgramForRendererElementAndHashPass(uint64_t a1, unsigned int *a2, const void *a3, uint64_t a4)
{
  uint64_t v7;
  _QWORD *v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  _DWORD *v12;
  void *ValuesPtr;
  int *v14;
  uint64_t *ValuePtrAtIndex;
  void *v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  CFTypeRef cf;

  v7 = *a2;
  v8 = (_QWORD *)(a1 + 16);
  v9 = (*(_DWORD *)(a1 + 44) - 1) & a4;
  v10 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 32) + 2 * v9);
  if (v10 < 2)
    goto LABEL_5;
  while ((v10 & 2) == 0 || *(_QWORD *)(*v8 + 8 * v9) != a4)
  {
    ++v9;
    v11 = v10 >= 4;
    v10 >>= 1;
    if (!v11)
      goto LABEL_5;
  }
  v18 = *(_QWORD *)(a1 + 24);
  if (!v18 || (v12 = *(_DWORD **)(v18 + 8 * v9)) == 0)
  {
LABEL_5:
    v12 = (_DWORD *)C3DArrayCreate(8, *(_DWORD *)(a1 + 56));
    cf = v12;
    C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::insert((uint64_t)v8, a4, &cf);
    if (cf)
      CFRelease(cf);
    C3DArraySetCount(v12, *(_DWORD *)(a1 + 56));
    ValuesPtr = (void *)C3DArrayGetValuesPtr((uint64_t)v12);
    bzero(ValuesPtr, 8 * *(unsigned int *)(a1 + 56));
  }
  v14 = (int *)(a1 + 56);
  if (v7 >= *(_DWORD *)(a1 + 56))
  {
    v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      C3DProgramHashCodeStoreRegisterProgramForRendererElementAndHashPass_cold_2(v14, v7, v17);
  }
  else
  {
    ValuePtrAtIndex = (uint64_t *)C3DArrayGetValuePtrAtIndex((uint64_t)v12, v7);
    if ((const void *)*ValuePtrAtIndex != a3)
    {
      C3DProgramHashCodeRelease(*ValuePtrAtIndex);
      if (a3)
        v16 = (void *)CFRetain(a3);
      else
        v16 = 0;
      *ValuePtrAtIndex = (uint64_t)v16;
      if (C3DIndexStoreAddIndexForKey(*(_QWORD *)(a1 + 48), v16) >= 0xFFFFFFFFLL)
      {
        v19 = scn_default_log();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          C3DProgramHashCodeStoreRegisterProgramForRendererElementAndHashPass_cold_1(v19, v20, v21, v22, v23, v24, v25, v26);
      }
    }
  }
}

unint64_t C3DRendererElementStoreAllocateSpanForNode(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  unsigned int v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFDictionary *Light;
  __C3DGeometry *Geometry;
  char v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  __C3DGeometry *v25;
  char v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t RendererElementStore;
  unint64_t Span;
  unint64_t v33;
  int v34;
  uint64_t v35;
  const void *RegisteredCIFilterTechniqueForNode;
  CFTypeID v37;
  BOOL v38;
  const void *Floor;
  uint64_t ElementInSpanAtIndex;
  const void *v41;
  CFTypeRef v42;
  unint64_t v43;
  int v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int16 v49;
  int v50;
  int v51;
  unsigned int v52;
  __C3DGeometry *AreaVisualisationGeometry;
  __C3DGeometry *cf;
  int v55;

  v8 = a4 & 4;
  if (!a3 && (a4 & 4) == 0)
  {
LABEL_45:
    v43 = 0;
    LOWORD(v33) = -1;
    v44 = -65536;
    return v44 & 0xFFFF0000 | v43 | (unsigned __int16)v33;
  }
  if (a3)
  {
    if ((a4 & 4) == 0)
    {
      if (*(_DWORD *)(a3 + 228))
      {
        v9 = scn_default_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
          C3DRendererElementStoreAllocateSpanForNode_cold_1(v9, v10, v11, v12, v13, v14, v15, v16);
      }
    }
    Light = C3DNodeGetLight(a3);
    Geometry = (__C3DGeometry *)C3DNodeGetGeometry(a3);
    if (Light)
    {
      AreaVisualisationGeometry = (__C3DGeometry *)C3DLightGetAreaVisualisationGeometry((uint64_t)Light);
      v19 = 1;
      goto LABEL_13;
    }
    v19 = 0;
  }
  else
  {
    v19 = 0;
    Geometry = 0;
  }
  AreaVisualisationGeometry = 0;
LABEL_13:
  v20 = a4 & 2;
  if ((a4 & 1) != 0)
    v21 = __SpanCountForGeometryAttribute(a2, a3, Geometry);
  else
    v21 = 0;
  v55 = v21 + (v20 >> 1) + (v8 >> 2);
  v51 = a4 & 2;
  v52 = v21;
  v48 = v21 + (v20 >> 1);
  v22 = v8;
  if ((a4 & 8) != 0)
  {
    v25 = (__C3DGeometry *)C3DNodeGetGeometry(a3);
    v23 = a2;
    v24 = __SpanCountForGeometryAttribute(a2, a3, v25) + 1;
  }
  else
  {
    v23 = a2;
    v24 = 0;
  }
  v26 = v19 ^ 1;
  if ((a4 & 0x10) == 0)
    v26 = 1;
  if ((v26 & 1) != 0)
    v27 = 0;
  else
    v27 = __SpanCountForGeometryAttribute(v23, a3, AreaVisualisationGeometry);
  v28 = (v27 + v24 + v55);
  v49 = v24 + v55;
  v50 = v27;
  if ((a4 & 0x21) == 0x21)
    v29 = __SpanCountForGeometryAttribute(v23, a3, Geometry);
  else
    v29 = 0;
  v30 = (v29 + v28);
  if (!(v29 + (_DWORD)v28))
    goto LABEL_45;
  cf = Geometry;
  RendererElementStore = C3DEnginePipelineGetRendererElementStore(a1);
  Span = C3DSpanAllocatorAllocateSpan(*(_QWORD *)(RendererElementStore + 16), v30);
  v33 = Span;
  v34 = a4 & 0x21;
  if ((a4 & 8) != 0)
  {
    if (cf)
    {
      __InitializeRendererElementsForGeometryAttribute(RendererElementStore, Span, (unsigned __int16)v55, cf, a3, 0);
      if (C3DNodeHasGeometryLOD(a3))
        __AllocateSpansAndInitializeRendererElementsForNodeGeometryLOD(v23, RendererElementStore, a3);
    }
    v35 = C3DGetScene((_QWORD *)a3);
    RegisteredCIFilterTechniqueForNode = C3DSceneGetRegisteredCIFilterTechniqueForNode(v35, (void *)a3);
    if (!RegisteredCIFilterTechniqueForNode)
      RegisteredCIFilterTechniqueForNode = (const void *)C3DFXTechniqueGetNullTechnique();
    __InitializeRendererElementWithNode(RendererElementStore, v33, (v55 + v24 - 1), a3, 3, 0, 0, RegisteredCIFilterTechniqueForNode, 0, 0);
  }
  if ((a4 & 1) != 0)
  {
    __InitializeRendererElementsForGeometryAttribute(RendererElementStore, v33, 0, cf, a3, 0);
    if (C3DNodeHasGeometryLOD(a3))
      __AllocateSpansAndInitializeRendererElementsForNodeGeometryLOD(v23, RendererElementStore, a3);
    v37 = CFGetTypeID(cf);
    v38 = v37 == C3DFloorGetTypeID();
    v34 = a4 & 0x21;
    if (v38)
    {
      Floor = (const void *)C3DFXTechniqueCreateFloor(v23, (__C3DNode *)a3);
      ElementInSpanAtIndex = C3DSpanAllocatorGetElementInSpanAtIndex(*(_QWORD *)(RendererElementStore + 16), v33, 0);
      v41 = *(const void **)(ElementInSpanAtIndex + 40);
      if (v41 != Floor)
      {
        if (v41)
        {
          CFRelease(v41);
          *(_QWORD *)(ElementInSpanAtIndex + 40) = 0;
        }
        if (Floor)
          v42 = CFRetain(Floor);
        else
          v42 = 0;
        *(_QWORD *)(ElementInSpanAtIndex + 40) = v42;
      }
      CFRelease(Floor);
      _C3DRendererElementSync(ElementInSpanAtIndex, 2);
      *(_WORD *)(ElementInSpanAtIndex + 72) |= 0x20u;
    }
  }
  if (v51)
    __InitializeRendererElementWithNode(RendererElementStore, v33, v52, a3, 1, 0, 0, 0, 0, 0);
  if (v22)
    __InitializeRendererElementWithNode(RendererElementStore, v33, v48, a3, 2, 0, 0, 0, 0, 0);
  v44 = v33 & 0xFFFF0000;
  v43 = v33 & 0xFFFFFFFF00000000;
  if (v50)
    __InitializeRendererElementsForGeometryAttribute(RendererElementStore, v33, v49, AreaVisualisationGeometry, a3, 0);
  if (v34 == 33)
  {
    __InitializeRendererElementsForGeometryAttribute(RendererElementStore, v33, (unsigned __int16)v28, cf, a3, 5);
    if (v52)
    {
      v46 = v52;
      do
      {
        v47 = C3DSpanAllocatorGetElementInSpanAtIndex(*(_QWORD *)(RendererElementStore + 16), v33, v28);
        *(_WORD *)(v47 + 72) = *(_WORD *)(v47 + 72) & 0xBFA7 | 0x4008;
        ++v28;
        --v46;
      }
      while (v46);
    }
  }
  return v44 & 0xFFFF0000 | v43 | (unsigned __int16)v33;
}

uint64_t C3DNodeHasGeometryLOD(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 221) >> 7;
}

uint64_t C3DEnginePipelineGetRendererElementStore(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextRenderScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 48);
}

void __InitializeRendererElementsForGeometryAttribute(uint64_t a1, unint64_t a2, unsigned int a3, __C3DGeometry *a4, uint64_t a5, char a6)
{
  unsigned int MeshElementCountForDeformerBasedDynamicMesh;
  uint64_t v11;
  uint64_t v12;
  __C3DMesh *MeshToRender;
  const __CFArray *ElementsCount;
  const __CFArray *v15;
  CFIndex v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *ElementAtIndex;
  uint64_t v21;
  unsigned __int8 v22;
  unsigned int v23;
  const __CFArray *v24;
  unint64_t v25;

  if (C3DGeometryUsesDeformerBasedDynamicMesh((uint64_t)a4))
  {
    MeshElementCountForDeformerBasedDynamicMesh = C3DGeometryGetMeshElementCountForDeformerBasedDynamicMesh((uint64_t)a4);
    if (MeshElementCountForDeformerBasedDynamicMesh)
    {
      v11 = MeshElementCountForDeformerBasedDynamicMesh;
      v12 = a3;
      do
      {
        __InitializeRendererElementWithNode(a1, a2, v12++, a5, a6, a4, 0, 0, 0, 0);
        --v11;
      }
      while (v11);
    }
  }
  else
  {
    MeshToRender = _C3DNodeGetMeshToRender(a5, a4);
    ElementsCount = C3DMeshGetElementsCount((uint64_t)MeshToRender);
    if ((uint64_t)ElementsCount >= 1)
    {
      v15 = ElementsCount;
      v16 = 0;
      v17 = 0;
      v18 = a2;
      v19 = a3;
      v24 = ElementsCount;
      do
      {
        ElementAtIndex = C3DMeshGetElementAtIndex((uint64_t)MeshToRender, v16, 0);
        if (C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex))
        {
          if (C3DGeometryOpenSubdivGPUIsActive(a4))
          {
            v21 = a5;
            v22 = 1;
            do
            {
              v23 = v22;
              if (C3DGeometryOpenSubdivGetGPUHasPatchOfType((uint64_t)a4, v22))
              {
                a2 = a2 & 0xFFFFFFFF00000000 | v18;
                __InitializeRendererElementWithNode(a1, a2, v17 + v19, v21, a6, a4, MeshToRender, 0, v16, v22);
                ++v17;
              }
              ++v22;
            }
            while (v23 < 6);
            a5 = v21;
            v15 = v24;
          }
          else
          {
            v25 = v25 & 0xFFFFFFFF00000000 | v18;
            __InitializeRendererElementWithNode(a1, v18, v17 + v19, a5, a6, a4, MeshToRender, 0, v16, 0);
            ++v17;
          }
        }
        ++v16;
      }
      while ((const __CFArray *)v16 != v15);
    }
  }
}

void C3DRendererElementStoreSyncRendererElement(uint64_t a1, uint64_t a2, int a3)
{
  char v3;

  if (a3)
  {
    v3 = a3;
    if ((*(_WORD *)(a2 + 72) & 0x20) != 0)
    {
      if ((a3 & 4) != 0)
        C3DIndexStoreRemoveIndexForKey(*(_QWORD *)(a1 + 24), (void *)*(int *)(a2 + 64));
      if ((v3 & 1) != 0)
        C3DIndexStoreRemoveIndexForKey(*(_QWORD *)(a1 + 32), *(void **)(a2 + 32));
    }
    _C3DRendererElementSync(a2, v3);
    if ((v3 & 4) != 0)
      C3DIndexStoreAddIndexForKey(*(_QWORD *)(a1 + 24), (void *)*(int *)(a2 + 64));
    if ((v3 & 1) != 0)
      C3DIndexStoreAddIndexForKey(*(_QWORD *)(a1 + 32), *(void **)(a2 + 32));
    *(_WORD *)(a2 + 72) |= 0x20u;
  }
}

uint64_t C3DIndexStoreAddIndexForKey(uint64_t a1, void *key)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *Value;
  char *v13;
  uint64_t result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DIndexStoreGetIndexForKey_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  Value = (uint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (Value)
  {
    v13 = (char *)Value;
    result = *Value;
  }
  else
  {
    v13 = C3DAllocatorNew(*(_QWORD *)(a1 + 48));
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 16), key, v13);
    *((_QWORD *)v13 + 1) = 0;
    result = _getNextFreeIndex(a1);
    *(_QWORD *)v13 = result;
    ++*(_QWORD *)(a1 + 72);
  }
  ++*((_QWORD *)v13 + 1);
  return result;
}

uint64_t _getNextFreeIndex(uint64_t a1)
{
  uint64_t FirstIndex;
  uint64_t v3;
  NSObject *v4;

  FirstIndex = C3DIndexSetGetFirstIndex(*(_QWORD *)(a1 + 24));
  if (FirstIndex == -1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      _getNextFreeIndex_cold_1(v4);
  }
  else
  {
    C3DIndexSetRemoveIndex(*(_QWORD *)(a1 + 24), FirstIndex);
    v3 = *(_QWORD *)(a1 + 32);
    if (v3 <= FirstIndex)
      v3 = FirstIndex;
    *(_QWORD *)(a1 + 32) = v3;
    *(_BYTE *)(a1 + 56) = 0;
  }
  return FirstIndex;
}

uint64_t __SpanCountForGeometryAttribute(uint64_t a1, uint64_t a2, __C3DGeometry *a3)
{
  __C3DMesh *MeshToRender;
  uint64_t v8;
  const __CFArray *ElementsCount;
  const __CFArray *v10;
  CFIndex v11;
  uint64_t v12;
  const void *ElementAtIndex;
  uint64_t v14;
  int v15;
  unsigned int v16;

  if (!a3)
    return 0;
  if (C3DGeometryUsesDeformerBasedDynamicMesh((uint64_t)a3))
    return C3DGeometryGetMeshElementCountForDeformerBasedDynamicMesh((uint64_t)a3);
  MeshToRender = _C3DNodeGetMeshToRender(a2, a3);
  if (!MeshToRender)
    return 0;
  v8 = (uint64_t)MeshToRender;
  ElementsCount = C3DMeshGetElementsCount((uint64_t)MeshToRender);
  if ((uint64_t)ElementsCount < 1)
    return 0;
  v10 = ElementsCount;
  v11 = 0;
  v12 = 0;
  do
  {
    ElementAtIndex = C3DMeshGetElementAtIndex(v8, v11, 0);
    if (C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex))
      ++v12;
    ++v11;
  }
  while (v10 != (const __CFArray *)v11);
  if (v12 && C3DGeometryOpenSubdivGPUIsActive(a3))
  {
    v14 = 0;
    v15 = 1;
    do
    {
      C3DGeometryOpenSubdivGetGPUContext((uint64_t)a3, 1, a1);
      v16 = v15;
      v14 += C3DGeometryOpenSubdivGetGPUHasPatchOfType((uint64_t)a3, v15++);
    }
    while (v16 < 6);
    v12 *= v14;
  }
  return v12;
}

const __CFArray *C3DMeshGetElementsCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFArray *result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = *(const __CFArray **)(a1 + 96);
  if (result)
    return (const __CFArray *)CFArrayGetCount(result);
  return result;
}

uint64_t C3DMeshElementGetPrimitiveCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 104);
}

__C3DMesh *C3DGeometryGetRenderingMesh(__C3DGeometry *a1)
{
  if (C3DGeometryOsdGetWantsCPUSubdivision(a1))
    return C3DGeometryOsdGetCPUSubdividedC3DMesh((uint64_t)a1);
  else
    return (__C3DMesh *)C3DGeometryGetMesh((uint64_t)a1);
}

BOOL C3DGeometryOsdGetWantsCPUSubdivision(__C3DGeometry *a1)
{
  return a1->var10.var0 && a1->var11.var0 != 4 && C3DGeometryMeshElementsSupportsSubdivision(a1);
}

void __InitializeRendererElementWithNode(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, char a5, __C3DGeometry *a6, const void *a7, const void *a8, CFIndex a9, char a10)
{
  __int16 v15;
  CFIndex v17;
  char v18;
  uint64_t ElementInSpanAtIndex;
  __int16 v20;
  __C3DGeometry *v21;
  CFTypeRef v22;
  const void *v23;
  CFTypeRef v24;
  const void *v25;
  const void *v26;
  CFTypeRef v27;
  _BOOL4 EffectiveDataKindForRendering;
  CFNumberRef v29;
  CFNumberRef v30;
  CFTypeRef v31;
  const void *ElementAtIndex;
  const void *v33;
  CFTypeRef v34;
  const __CFArray *MaterialsCount;
  const __CFArray *v36;
  uint64_t v37;
  uint64_t OverrideMaterial;
  const __CFArray *v39;
  const __CFArray *v40;
  const __CFArray *v41;
  const void *Default;
  const void *v43;
  CFTypeRef v44;
  const __CFArray *MaterialAtIndex;
  const __CFArray *v46;
  CFTypeRef v47;

  v15 = a3;
  v17 = a9;
  v18 = a10;
  ElementInSpanAtIndex = C3DSpanAllocatorGetElementInSpanAtIndex(*(_QWORD *)(a1 + 16), a2, a3);
  *(_OWORD *)ElementInSpanAtIndex = 0u;
  *(_OWORD *)(ElementInSpanAtIndex + 16) = 0u;
  *(_OWORD *)(ElementInSpanAtIndex + 32) = 0u;
  *(_OWORD *)(ElementInSpanAtIndex + 48) = 0u;
  *(_OWORD *)(ElementInSpanAtIndex + 64) = 0u;
  _C3DRendererElementInitialize(ElementInSpanAtIndex);
  *(_DWORD *)ElementInSpanAtIndex = ((unsigned __int16)a2 << 12) + (unsigned __int16)(v15 + HIWORD(a2));
  v20 = *(_WORD *)(ElementInSpanAtIndex + 72) & 0xC7F8 | ((v18 & 7) << 11);
  *(_QWORD *)(ElementInSpanAtIndex + 8) = a4;
  *(_WORD *)(ElementInSpanAtIndex + 72) = v20 & 0xFFF8 | a5 & 7;
  v21 = *(__C3DGeometry **)(ElementInSpanAtIndex + 16);
  if (v21 != a6)
  {
    if (v21)
    {
      CFRelease(v21);
      *(_QWORD *)(ElementInSpanAtIndex + 16) = 0;
    }
    if (a6)
      v22 = CFRetain(a6);
    else
      v22 = 0;
    *(_QWORD *)(ElementInSpanAtIndex + 16) = v22;
  }
  v23 = *(const void **)(ElementInSpanAtIndex + 24);
  if (v23 != a7)
  {
    if (v23)
    {
      CFRelease(v23);
      *(_QWORD *)(ElementInSpanAtIndex + 24) = 0;
    }
    if (a7)
      v24 = CFRetain(a7);
    else
      v24 = 0;
    *(_QWORD *)(ElementInSpanAtIndex + 24) = v24;
  }
  v25 = *(const void **)(ElementInSpanAtIndex + 32);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(ElementInSpanAtIndex + 32) = 0;
  }
  v26 = *(const void **)(ElementInSpanAtIndex + 40);
  if (v26 != a8)
  {
    if (v26)
    {
      CFRelease(v26);
      *(_QWORD *)(ElementInSpanAtIndex + 40) = 0;
    }
    if (a8)
      v27 = CFRetain(a8);
    else
      v27 = 0;
    *(_QWORD *)(ElementInSpanAtIndex + 40) = v27;
  }
  if (!a7)
  {
    if (!a6)
      goto LABEL_69;
    if (C3DGeometryUsesDeformerBasedDynamicMesh((uint64_t)a6))
    {
      v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, &a9);
      v30 = *(CFNumberRef *)(ElementInSpanAtIndex + 48);
      if (v30 != v29)
      {
        if (v30)
        {
          CFRelease(v30);
          *(_QWORD *)(ElementInSpanAtIndex + 48) = 0;
        }
        if (v29)
          v31 = CFRetain(v29);
        else
          v31 = 0;
        *(_QWORD *)(ElementInSpanAtIndex + 48) = v31;
      }
      CFRelease(v29);
    }
LABEL_47:
    MaterialsCount = C3DGeometryGetMaterialsCount((uint64_t)a6);
    if (!MaterialsCount)
    {
      Default = (const void *)C3DMaterialCreateDefault();
      v43 = *(const void **)(ElementInSpanAtIndex + 32);
      if (v43 != Default)
      {
        if (v43)
        {
          CFRelease(v43);
          *(_QWORD *)(ElementInSpanAtIndex + 32) = 0;
        }
        if (Default)
          v44 = CFRetain(Default);
        else
          v44 = 0;
        *(_QWORD *)(ElementInSpanAtIndex + 32) = v44;
      }
      if (Default)
        CFRelease(Default);
      goto LABEL_69;
    }
    v36 = MaterialsCount;
    v37 = a9;
    OverrideMaterial = C3DGeometryGetOverrideMaterial((uint64_t)a6);
    if (OverrideMaterial)
    {
      v39 = (const __CFArray *)OverrideMaterial;
      v40 = *(const __CFArray **)(ElementInSpanAtIndex + 32);
      if (v40 == v39)
        goto LABEL_69;
      if (v40)
      {
        CFRelease(v40);
        *(_QWORD *)(ElementInSpanAtIndex + 32) = 0;
      }
      v41 = v39;
    }
    else
    {
      MaterialAtIndex = C3DGeometryGetMaterialAtIndex((uint64_t)a6, v37 % (uint64_t)v36);
      v46 = *(const __CFArray **)(ElementInSpanAtIndex + 32);
      if (v46 == MaterialAtIndex)
        goto LABEL_69;
      if (v46)
      {
        CFRelease(v46);
        *(_QWORD *)(ElementInSpanAtIndex + 32) = 0;
      }
      if (!MaterialAtIndex)
      {
        v47 = 0;
        goto LABEL_64;
      }
      v41 = MaterialAtIndex;
    }
    v47 = CFRetain(v41);
LABEL_64:
    *(_QWORD *)(ElementInSpanAtIndex + 32) = v47;
    goto LABEL_69;
  }
  if (a6)
    EffectiveDataKindForRendering = C3DGeometryGetEffectiveDataKindForRendering(a6);
  else
    EffectiveDataKindForRendering = 1;
  ElementAtIndex = C3DMeshGetElementAtIndex((uint64_t)a7, v17, EffectiveDataKindForRendering);
  v33 = *(const void **)(ElementInSpanAtIndex + 48);
  if (v33 != ElementAtIndex)
  {
    if (v33)
    {
      CFRelease(v33);
      *(_QWORD *)(ElementInSpanAtIndex + 48) = 0;
    }
    if (ElementAtIndex)
      v34 = CFRetain(ElementAtIndex);
    else
      v34 = 0;
    *(_QWORD *)(ElementInSpanAtIndex + 48) = v34;
  }
  if (a6)
    goto LABEL_47;
LABEL_69:
  C3DRendererElementStoreSyncRendererElement(a1, ElementInSpanAtIndex, -1);
}

unint64_t __AllocateNewSpanInPage(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int16 *v9;
  unsigned int v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int v36;

  v2 = a2;
  if (*(_DWORD *)(a1 + 32) < a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      __AllocateNewSpanInPage_cold_3(v2, v4);
  }
  v5 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = *(_QWORD *)(a1 + 16);
    v8 = 2;
    while (1)
    {
      v9 = (unsigned __int16 *)(v7 + v8);
      v10 = *(_DWORD *)(v7 + v8 + 2);
      if (v10 >= v2)
        break;
      ++v6;
      v8 += 8;
      if (v5 == v6)
        goto LABEL_8;
    }
    v20 = *(v9 - 1);
    v19 = *v9;
    if (v19 + v2 > *(_DWORD *)(a1 + 8))
    {
      v22 = scn_default_log();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
        __AllocateNewSpanInPage_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
    }
    v30 = *(_QWORD *)(a1 + 16);
    v31 = *(_DWORD *)(v30 + v8 + 2) - v2;
    if (v31)
    {
      *(_WORD *)(v30 + v8) += v2;
      *(_DWORD *)(v30 + v8 + 2) = v31;
    }
    else
    {
      __RemoveFromFreeList((_DWORD *)a1, v6);
    }
    if (*(_DWORD *)(a1 + 32) == v10)
    {
      v32 = *(unsigned int *)(a1 + 24);
      if ((_DWORD)v32)
      {
        v33 = 0;
        v34 = (unsigned int *)(*(_QWORD *)(a1 + 16) + 4);
        do
        {
          v36 = *v34;
          v34 += 2;
          v35 = v36;
          if (v36 > v33)
            v33 = v35;
          --v32;
        }
        while (v32);
        *(_DWORD *)(a1 + 32) = v33;
      }
      else
      {
        *(_DWORD *)(a1 + 32) = 0;
      }
    }
  }
  else
  {
LABEL_8:
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      C3DFXPassInitialize_cold_2(v11, v12, v13, v14, v15, v16, v17, v18);
    v2 = 0;
    v19 = 0xFFFF;
    v20 = 0xFFFF;
  }
  return (v2 << 32) | ((unint64_t)v19 << 16) | v20;
}

unint64_t __AllocateNewSpan(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t NewPage;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unsigned int v13;
  unsigned int v14;
  NSObject *v16;

  v6 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v6)
  {
    NewPage = *(_QWORD *)(a1 + 16);
    v8 = v6;
    while (!*(_QWORD *)NewPage || *(_DWORD *)(NewPage + 32) < a2)
    {
      NewPage += 40;
      if (!--v8)
      {
        v9 = 0;
        NewPage = 0;
        v10 = 40 * v6;
        do
        {
          v11 = *(_QWORD *)(a1 + 16);
          v12 = (_QWORD *)(v11 + v9);
          v13 = *(_DWORD *)(v11 + v9 + 32);
          if (v13 >= a2)
          {
            if (!*v12)
              __AllocatePage(a1, (uint64_t)v12, *(_DWORD *)(v11 + v9 + 12), v13);
            NewPage = (uint64_t)v12;
          }
          v9 += 40;
        }
        while (v10 != v9);
        if (NewPage)
          goto LABEL_18;
        goto LABEL_13;
      }
    }
    goto LABEL_18;
  }
LABEL_13:
  if (*(_QWORD *)(a1 + 48) >= (uint64_t)a2)
    v14 = *(_QWORD *)(a1 + 48);
  else
    v14 = a2;
  if (v14 <= 0x10000)
  {
    NewPage = __CreateNewPage(a1, v14);
LABEL_18:
    if (a3)
      *a3 = NewPage;
    *(_DWORD *)(a1 + 36) += a2;
    return __AllocateNewSpanInPage(NewPage, a2);
  }
  v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    __AllocateNewSpan_cold_1(v16);
  return 0xFFFFFFFFLL;
}

uint64_t _C3DRendererElementInitialize(uint64_t result)
{
  *(_WORD *)(result + 72) &= ~0x400u;
  return result;
}

unint64_t C3DSpanAllocatorAllocateSpan(uint64_t a1, uint64_t a2)
{
  return __AllocateNewSpan(a1, a2, 0);
}

uint64_t C3DProgramHashCodeNeedTangents(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 200) >> 4) & 1;
}

uint64_t C3DGeometryIsAlwaysRendered(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const __CFArray *MaterialsCount;
  const __CFArray *v5;
  uint64_t v6;
  const __CFArray *MaterialAtIndex;
  uint64_t Technique;
  uint64_t CommonProfile;
  uint64_t EffectSlot;
  uint64_t v11;
  _BOOL4 v12;

  v2 = *(_QWORD *)(a1 + 72);
  if (v2)
    v3 = C3DMaterialGetTechnique(v2) != 0;
  else
    v3 = 0;
  MaterialsCount = C3DGeometryGetMaterialsCount(a1);
  if ((uint64_t)MaterialsCount >= 1 && (v3 & 1) == 0)
  {
    v5 = MaterialsCount;
    v6 = 1;
    do
    {
      MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1, v6 - 1);
      Technique = C3DMaterialGetTechnique((uint64_t)MaterialAtIndex);
      v3 = Technique != 0;
      CommonProfile = C3DMaterialGetCommonProfile((uint64_t)MaterialAtIndex);
      if (CommonProfile)
      {
        EffectSlot = C3DEffectCommonProfileGetEffectSlot(CommonProfile, 15, 0);
        if (EffectSlot)
        {
          v11 = EffectSlot;
          v12 = C3DEffectSlotHasImageOrTexture(EffectSlot) && C3DEffectSlotGetIntensity(v11) != 0.0;
          if (Technique)
            v3 = 1;
          else
            v3 = v12;
        }
      }
      if (v6 >= (uint64_t)v5)
        break;
      ++v6;
    }
    while ((v3 & 1) == 0);
  }
  return v3;
}

const __CFArray *C3DGeometryGetMaterialAtIndex(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFArray *result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = C3DGeometryGetMaterialsCount(a1);
  if (result)
    return (const __CFArray *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), a2 % (uint64_t)result);
  return result;
}

const __CFArray *C3DGeometryGetMaterialsCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFArray *result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = *(const __CFArray **)(a1 + 80);
  if (result)
    return (const __CFArray *)CFArrayGetCount(result);
  return result;
}

void C3DEnginePipelineGetRenderComponentsForRenderPass(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t RenderContext;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t OverridingProgramHashCode;
  uint64_t MaterialForRenderPass;
  uint64_t Program;
  uint64_t Technique;
  NSObject *v23;
  uint64_t ProgramHashCodeStore;
  unsigned int PreferredRenderMode;
  uint64_t CommonProfile;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t ProgramHashCodeForRenderElement;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;

  RenderContext = C3DEngineContextGetRenderContext(a3);
  if (!RenderContext)
  {
    if (a2 && C3DFXPassIsOverridingPrograms((uint64_t)a2))
      OverridingProgramHashCode = (uint64_t)C3DFXPassGetOverridingProgramHashCode(a3, a2, (unsigned __int16 *)a1);
    else
      OverridingProgramHashCode = 0;
    MaterialForRenderPass = C3DRendererElementGetMaterialForRenderPass(a1, (uint64_t)a2);
    v18 = MaterialForRenderPass;
    if (!MaterialForRenderPass || C3DMaterialGetTechnique(MaterialForRenderPass))
    {
      if (!a2 || (Program = C3DFXPassGetProgram((uint64_t)a2)) == 0)
      {
        Technique = *(_QWORD *)(a1 + 40);
        if (v18 && !Technique)
          Technique = C3DMaterialGetTechnique(v18);
        if (Technique)
          goto LABEL_38;
        v23 = scn_default_log();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          C3DEnginePipelineGetRenderComponentsForRenderPass_cold_1(v23);
        return;
      }
LABEL_39:
      OverridingProgramHashCode = 0;
      if (!a4)
      {
LABEL_41:
        if (a6)
          *a6 = Program;
        if (a5)
          *a5 = OverridingProgramHashCode;
        return;
      }
LABEL_40:
      *a4 = v18;
      goto LABEL_41;
    }
    if (!OverridingProgramHashCode)
    {
      ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(a3);
      PreferredRenderMode = C3DEngineContextGetPreferredRenderMode(a3);
      OverridingProgramHashCode = C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(ProgramHashCodeStore, (unsigned __int16 *)a1, a2, PreferredRenderMode);
    }
    CommonProfile = C3DMaterialGetCommonProfile(v18);
    if (!CommonProfile)
    {
      v27 = scn_default_log();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
        goto LABEL_48;
    }
    goto LABEL_49;
  }
  v15 = RenderContext;
  v16 = C3DEngineContextGetProgramHashCodeStore(a3);
  if (a2)
  {
    v17 = C3DRendererElementGetMaterialForRenderPass(a1, (uint64_t)a2);
  }
  else
  {
    if (C3DRendererElementIsRendererDelegate(a1))
    {
      v18 = 0;
      goto LABEL_30;
    }
    if ((*(_WORD *)(a1 + 72) & 0x400) != 0 || !-[SCNMTLRenderContext getCurrentPassMaterial](v15))
    {
      v18 = *(_QWORD *)(a1 + 32);
      goto LABEL_30;
    }
    v17 = -[SCNMTLRenderContext getCurrentPassMaterial](v15);
  }
  v18 = v17;
LABEL_30:
  v35 = -[SCNMTLRenderContext getCurrentPassHash](v15);
  ProgramHashCodeForRenderElement = C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(v16, (unsigned __int16 *)a1, a2, v35);
  if (v18)
  {
    OverridingProgramHashCode = ProgramHashCodeForRenderElement;
    if (!C3DMaterialGetTechnique(v18))
    {
      CommonProfile = C3DMaterialGetCommonProfile(v18);
      if (!CommonProfile)
      {
        v27 = scn_default_log();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
LABEL_48:
          C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v27, v28, v29, v30, v31, v32, v33, v34);
      }
LABEL_49:
      Program = (uint64_t)C3DEngineContextEvaluateProgramWithHashCode(a3, OverridingProgramHashCode, CommonProfile, a7);
      if (!a4)
        goto LABEL_41;
      goto LABEL_40;
    }
  }
  if (a2)
  {
    Program = C3DFXPassGetProgram((uint64_t)a2);
    if (Program)
      goto LABEL_39;
  }
  Technique = *(_QWORD *)(a1 + 40);
  if (v18 && !Technique)
    Technique = C3DMaterialGetTechnique(v18);
  if (Technique)
  {
LABEL_38:
    Program = C3DFXTechniqueGetSingleProgram(Technique);
    goto LABEL_39;
  }
  v37 = scn_default_log();
  if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    C3DFXTechniqueAppendPass_cold_3(v37, v38, v39, v40, v41, v42, v43, v44);
}

uint64_t C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(uint64_t a1, unsigned __int16 *a2, _QWORD *a3, uint64_t a4)
{
  uint64_t result;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;

  if (!a3
    || !C3DFXPassIsOverridingPrograms((uint64_t)a3)
    || (result = (uint64_t)C3DFXPassGetOverridingProgramHashCode(0, a3, a2)) == 0)
  {
    result = C3DRendererElementGetMaterialForRenderPass((uint64_t)a2, (uint64_t)a3);
    if (result)
    {
      if (C3DMaterialGetTechnique(result))
        return 0;
      v9 = (*(_DWORD *)(a1 + 44) - 1) & a4;
      v10 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 32) + 2 * v9);
      if (v10 < 2)
        return 0;
      v11 = *(unsigned int *)a2;
      while ((v10 & 2) == 0 || *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v9) != a4)
      {
        ++v9;
        v12 = v10 >= 4;
        v10 >>= 1;
        if (!v12)
          return 0;
      }
      v13 = *(_QWORD *)(a1 + 24);
      if (!v13)
        return 0;
      v14 = (uint64_t *)(v13 + 8 * v9);
      v15 = C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>::operator __C3DArray *((uint64_t)v14);
      if (C3DArrayGetCount(v15) <= v11)
        return 0;
      else
        return *(_QWORD *)C3DArrayGetValuePtrAtIndex(*v14, v11);
    }
  }
  return result;
}

uint64_t C3DMaterialGetTechnique(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 72);
}

uint64_t C3DArrayGetValuePtrAtIndex(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DArrayGetCount_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (C3DArrayGetCount(a1) <= a2)
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      C3DArrayGetValuePtrAtIndex_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  return *(_QWORD *)(a1 + 16) + *(unsigned int *)(a1 + 32) * a2;
}

uint64_t C3DArrayGetCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DArrayGetCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 24);
}

uint64_t C3DRendererElementGetMaterialForRenderPass(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t Material;
  __int16 v14;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      _C3DRendererElementSync_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if ((*(_WORD *)(a1 + 72) & 7) == 1)
    return 0;
  if (!a2)
    return *(_QWORD *)(a1 + 32);
  Material = C3DFXPassGetMaterial(a2);
  v14 = *(_WORD *)(a1 + 72);
  if ((v14 & 0x400) != 0)
    return *(_QWORD *)(a1 + 32);
  v12 = Material;
  if (!Material || (v14 & 8) == 0 && C3DFXPassGetDrawOnlyShadowCaster(a2))
    return *(_QWORD *)(a1 + 32);
  return v12;
}

uint64_t C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>::operator __C3DArray *(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!*(_QWORD *)a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>::operator __C3DArray *(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)a1;
}

BOOL C3DRendererElementIsRendererDelegate(uint64_t a1)
{
  return (*(_WORD *)(a1 + 72) & 7) == 1;
}

uint64_t C3DEngineContextGetProgramHashCodeStore(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 176);
}

__C3DFXProgram *C3DEngineContextEvaluateProgramWithHashCode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2)
    return -[SCNCommonProfileProgramGenerator programWithHashCode:engineContext:trackedResource:introspectionDataPtr:](C3DEngineContextGetCommonProfileProgramGenerator(a1), "programWithHashCode:engineContext:trackedResource:introspectionDataPtr:", a2, a1, a3, a4);
  else
    return 0;
}

SCNCommonProfileProgramGenerator *C3DEngineContextGetCommonProfileProgramGenerator(uint64_t a1)
{
  SCNCommonProfileProgramGenerator *result;

  result = *(SCNCommonProfileProgramGenerator **)(a1 + 216);
  if (!result)
  {
    result = +[SCNCommonProfileProgramGenerator generatorWithProfile:allowingHotReload:](SCNCommonProfileProgramGenerator, "generatorWithProfile:allowingHotReload:", C3DEngineContextGetRendererContextProfile(a1), 0);
    *(_QWORD *)(a1 + 216) = result;
  }
  return result;
}

uint64_t C3DProgramHashCodeGetHashCode(uint64_t a1)
{
  return *(_QWORD *)(a1 + 280);
}

void C3DIndexStoreRemoveIndexForKey(uint64_t a1, void *key)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *Value;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t LastRange;
  uint64_t v17;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DIndexStoreGetIndexForKey_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  Value = (uint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (Value)
  {
    v13 = (unint64_t)Value;
    v14 = Value[1] - 1;
    Value[1] = v14;
    if (!v14)
    {
      v15 = *Value;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), key);
      C3DAllocatorDelete(*(_QWORD *)(a1 + 48), v13);
      *(_BYTE *)(a1 + 56) = 0;
      C3DIndexSetAddIndex(*(_QWORD *)(a1 + 24), v15);
      if (*(_QWORD *)(a1 + 32) == v15)
      {
        LastRange = C3DIndexSetGetLastRange(*(_QWORD *)(a1 + 24));
        if (LastRange <= 1)
          v17 = 1;
        else
          v17 = LastRange;
        *(_QWORD *)(a1 + 32) = v17 - 1;
      }
      ++*(_QWORD *)(a1 + 72);
    }
  }
}

void _insertRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  NSObject *v9;
  _QWORD *v10;
  _OWORD *v11;
  _QWORD *v12;
  char v13;

  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    v8 = 0;
  }
  else if ((*(_BYTE *)(a1 + 16) & 2) != 0)
  {
    v8 = 1;
  }
  else
  {
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8);
  }
  if (v8 >= a4)
  {
    _ensureRangeCapacity(a1, v8 + 1);
    v10 = (_QWORD *)(a1 + 24);
    if ((*(_BYTE *)(a1 + 16) & 2) == 0)
      v10 = (_QWORD *)(*v10 + 56);
    if (v8 > a4)
    {
      v11 = &v10[2 * v8];
      do
      {
        --v8;
        *v11 = *(v11 - 1);
        --v11;
      }
      while (v8 > a4);
    }
    v12 = &v10[2 * a4];
    *v12 = a2;
    v12[1] = a3;
    v13 = *(_BYTE *)(a1 + 16);
    if ((v13 & 2) == 0)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48) = 0;
      ++*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8);
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) += a3;
      v13 = *(_BYTE *)(a1 + 16);
    }
    *(_BYTE *)(a1 + 16) = v13 & 0xFE;
  }
  else
  {
    v9 = scn_default_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      _insertRange_cold_1();
  }
}

__n128 _ensureRangeCapacity(uint64_t a1, uint64_t a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __n128 result;
  _BOOL8 v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  __n128 v12;

  v3 = *(_BYTE *)(a1 + 16);
  if ((v3 & 2) != 0)
    v4 = 1;
  else
    v4 = **(_QWORD **)(a1 + 24);
  if (v4 < a2)
  {
    if (a2 == 1)
    {
      *(_BYTE *)(a1 + 16) = v3 | 2;
    }
    else
    {
      v5 = 2 * v4;
      if (v5 <= a2)
        v5 = a2;
      if (a2 >= 4)
        v6 = v5;
      else
        v6 = 4;
      if ((*(_BYTE *)(a1 + 16) & 2) != 0)
      {
        v8 = (v3 & 1) == 0;
        if ((*(_BYTE *)(a1 + 16) & 1) != 0)
          v9 = 0;
        else
          v9 = *(_QWORD *)(a1 + 32);
        v10 = (_QWORD *)(a1 + 24);
        v12 = *(__n128 *)(a1 + 24);
        *(_BYTE *)(a1 + 16) = v3 & 0xFD;
        v11 = malloc_type_calloc(16 * v6 + 56, 1uLL, 0xCAE6BB9uLL);
        *(_QWORD *)(a1 + 24) = v11;
        v11[6] = 0;
        **(_QWORD **)(a1 + 24) = v6;
        *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8) = v8;
        *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) = v9;
        if ((*(_BYTE *)(a1 + 16) & 2) == 0)
          v10 = (_QWORD *)(*v10 + 56);
        result = v12;
        *(__n128 *)v10 = v12;
      }
      else
      {
        *(_QWORD *)(a1 + 24) = malloc_type_realloc(*(void **)(a1 + 24), 16 * v6 + 56, 0xA6EDD4FCuLL);
      }
    }
  }
  return result;
}

BOOL C3DProgramHashCodeHasShaderModifiers(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) || *(_QWORD *)(a1 + 24) != 0;
}

float C3DEffectCommonProfileGetConstantAlpha(float *a1)
{
  float FloatProperty;
  char v3;
  float *Color;
  char v5;
  float *v6;

  FloatProperty = C3DEffectCommonProfileGetFloatProperty(a1, 18);
  v3 = C3DEffectCommonProfileContainsContentForEffectProperty((uint64_t)a1, 5);
  Color = (float *)C3DEffectCommonProfileGetColor((uint64_t)a1, 5);
  if ((v3 & 1) == 0)
    FloatProperty = FloatProperty * Color[3];
  v5 = C3DEffectCommonProfileContainsContentForEffectProperty((uint64_t)a1, 2);
  v6 = (float *)C3DEffectCommonProfileGetColor((uint64_t)a1, 2);
  if ((v5 & 1) == 0)
    return FloatProperty * v6[3];
  return FloatProperty;
}

uint64_t __CreateNewPage(uint64_t a1, unsigned int a2)
{
  unsigned int v4;
  void *v5;
  uint64_t v6;

  v4 = *(_DWORD *)(a1 + 24);
  if (v4)
  {
    *(_DWORD *)(a1 + 24) = v4 + 1;
    v5 = malloc_type_realloc(*(void **)(a1 + 16), 40 * (v4 + 1), 0x10A00408EF24B1CuLL);
    *(_QWORD *)(a1 + 16) = v5;
  }
  else
  {
    v5 = malloc_type_malloc(0x28uLL, 0x10A00408EF24B1CuLL);
    *(_QWORD *)(a1 + 16) = v5;
    *(_DWORD *)(a1 + 24) = 1;
  }
  ++*(_DWORD *)(a1 + 28);
  v6 = (uint64_t)v5 + 40 * v4;
  __AllocatePage(a1, v6, v4, a2);
  return v6;
}

void __AllocatePage(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v7;
  size_t v8;
  void *v9;

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v7 = a4;
  v8 = *(_QWORD *)(a1 + 40) * a4;
  v9 = malloc_type_malloc(v8, 0xE6913EE2uLL);
  *(_QWORD *)a2 = v9;
  bzero(v9, v8);
  *(_DWORD *)(a2 + 8) = a4;
  *(_DWORD *)(a2 + 12) = a3;
  __AddToFreeList(a2, (unsigned __int16)a3 | (unint64_t)(v7 << 32));
}

void __AddToFreeList(uint64_t a1, unint64_t a2)
{
  unsigned __int16 v2;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t *v16;
  BOOL v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  unsigned int *v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  unint64_t v39;
  unint64_t v40;
  uint8_t buf[4];
  _DWORD v42[7];

  v2 = WORD1(a2);
  *(_QWORD *)&v42[5] = *MEMORY[0x1E0C80C00];
  v40 = a2;
  if (!HIDWORD(a2))
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      __AddToFreeList_cold_3(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v39 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v39)
  {
    v17 = 0;
    v13 = 0;
LABEL_22:
    v28 = *(_DWORD *)(a1 + 28);
    if (v28 < *(_DWORD *)(a1 + 24) + 1)
    {
      if (*(_QWORD *)(a1 + 16))
      {
        v29 = 2 * v28;
        *(_DWORD *)(a1 + 28) = v29;
        if (!v29)
        {
          v30 = scn_default_log();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
            __AddToFreeList_cold_1(v30, v31, v32, v33, v34, v35, v36, v37);
        }
        v38 = malloc_type_realloc(*(void **)(a1 + 16), 8 * *(unsigned int *)(a1 + 28), 0x100004000313F17uLL);
      }
      else
      {
        *(_DWORD *)(a1 + 28) = 8;
        v38 = malloc_type_malloc(0x40uLL, 0x100004000313F17uLL);
      }
      *(_QWORD *)(a1 + 16) = v38;
    }
    if (HIDWORD(v40) > *(_DWORD *)(a1 + 32))
      *(_DWORD *)(a1 + 32) = HIDWORD(v40);
    if (v17)
      memmove((void *)(*(_QWORD *)(a1 + 16) + 8 * v13 + 8), (const void *)(*(_QWORD *)(a1 + 16) + 8 * v13), 8 * (v39 - v13));
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v13) = v40;
    ++*(_DWORD *)(a1 + 24);
    return;
  }
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = v2;
  v16 = (uint64_t *)&v40;
  v17 = 1;
  while (1)
  {
    v18 = (unsigned int *)(*(_QWORD *)(a1 + 16) + v12);
    v19 = *((unsigned __int16 *)v18 + 1);
    v20 = v18[1];
    v21 = *((unsigned __int16 *)v16 + 1);
    v22 = *((_DWORD *)v16 + 1);
    v23 = v18;
    if (v20 + v19 == v21 || (v23 = (unsigned int *)v16, v22 + v21 == v19))
    {
      v24 = *v23;
      if (v14 == 1)
      {
        __RemoveFromFreeList((_DWORD *)a1, v13);
        v18 = (unsigned int *)v16;
      }
      v25 = v22 + v20;
      *(_QWORD *)v18 = v24 | (v25 << 32);
      if (v25 + WORD1(v24) > *(_DWORD *)(a1 + 8))
      {
        v26 = scn_default_log();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
          __AddToFreeList_cold_2(buf, v42, v26);
      }
      v27 = v18[1];
      if (v27 > *(_DWORD *)(a1 + 32))
        *(_DWORD *)(a1 + 32) = v27;
      if (++v14 == 2)
        return;
      v19 = *((unsigned __int16 *)v18 + 1);
      v15 = WORD1(v40);
      v16 = (uint64_t *)v18;
    }
    if (v19 > v15)
      break;
    v17 = ++v13 < v39;
    v12 += 8;
    if (v39 == v13)
    {
      v13 = v39;
      break;
    }
  }
  if (!v14)
    goto LABEL_22;
}

uint64_t C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::insert(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;
  unsigned int v13;
  __int16 *v14;
  unsigned int v15;
  __int16 v16;
  __int16 v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  char v21;
  uint64_t v22;
  int v23;
  char v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t result;
  uint64_t v33;

  while (1)
  {
    v6 = *(_DWORD *)(a1 + 28);
    v7 = (v6 - 1) & a2;
    v8 = *(_QWORD *)(a1 + 16);
    v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2)
      break;
LABEL_6:
    v12 = v7 + 496;
    v13 = v6 + 15;
    if (v13 < (int)v7 + 496)
      v12 = v13;
    if (v7 >= v12)
    {
      v15 = v7;
    }
    else
    {
      v14 = (__int16 *)(v8 + 2 * v7);
      v15 = v7;
      while (1)
      {
        v16 = *v14++;
        if ((v16 & 1) == 0)
          break;
        if (v12 == ++v15)
          goto LABEL_33;
      }
    }
    if (v15 != v12)
    {
      v17 = *(_WORD *)(v8 + 2 * v15) | 1;
      *(_WORD *)(v8 + 2 * v15) = v17;
      if (v15 <= (int)v7 + 14)
      {
        v33 = v15;
        v28 = *(_QWORD *)a1;
        v29 = *(_QWORD *)(a1 + 8);
        LOBYTE(v22) = v15;
      }
      else
      {
        while (2)
        {
          if (v15 >= 0xF)
            v18 = v15 - 14;
          else
            v18 = 0;
          v19 = v18 - 1;
          if (v18 <= v15)
            v20 = v15;
          else
            v20 = v18;
          v21 = 1;
          while (1)
          {
            v22 = v19 + 1;
            if (v18 <= v22)
              break;
LABEL_27:
            ++v21;
            v19 = v22;
            if ((_DWORD)v22 == v20)
              goto LABEL_32;
          }
          v23 = 1 << (v19 - v18 + 2);
          v24 = v21;
          v25 = v18;
          while (1)
          {
            v26 = v25;
            v27 = *(unsigned __int16 *)(v8 + 2 * v25);
            if ((v23 & v27) != 0)
              break;
            v25 = v26 + 1;
            v23 = (unsigned __int16)v23 >> 1;
            --v24;
            if ((int)v26 + 1 > v22)
              goto LABEL_27;
          }
          if (v22 >= v15)
          {
LABEL_32:
            *(_WORD *)(v8 + 2 * v15) ^= 1u;
            goto LABEL_33;
          }
          v28 = *(_QWORD *)a1;
          v29 = *(_QWORD *)(a1 + 8);
          *(_QWORD *)(*(_QWORD *)a1 + 8 * v15) = *(_QWORD *)(*(_QWORD *)a1 + 8 * v22);
          *(_QWORD *)(v29 + 8 * v15) = *(_QWORD *)(v29 + 8 * v22);
          *(_QWORD *)(v29 + 8 * v22) = 0;
          *(_WORD *)(v8 + 2 * v26) = (v27 | (1 << (v15 - v26 + 1))) ^ (1 << v24);
          v15 = v22;
          if (v22 > (int)v7 + 14)
            continue;
          break;
        }
        v17 = *(_WORD *)(v8 + 2 * v22) | 1;
        v33 = v22;
      }
      *(_QWORD *)(v29 + 8 * v33) = *a3;
      *a3 = 0;
      *(_QWORD *)(v28 + 8 * v33) = a2;
      *(_WORD *)(v8 + 2 * v33) = v17;
      result = 1;
      *(_WORD *)(v8 + 2 * v7) |= 1 << (v22 - v7 + 1);
      ++*(_DWORD *)(a1 + 24);
      return result;
    }
LABEL_33:
    C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::_grow(a1);
  }
  v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(_QWORD *)(*(_QWORD *)a1 + 8 * v10) != a2)
  {
    ++v10;
    v11 = v9 > 3;
    v9 >>= 1;
    if (!v11)
      goto LABEL_6;
  }
  v30 = *(_QWORD *)(a1 + 8);
  v31 = *a3;
  *a3 = 0;
  result = *(_QWORD *)(v30 + 8 * v10);
  *(_QWORD *)(v30 + 8 * v10) = v31;
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 0;
  }
  return result;
}

void C3DSortSystemSetCapacity(uint64_t a1, int a2)
{
  int64_t v2;
  uint64_t Capacity;
  unint64_t v5;
  uint64_t v6;
  BOOL v7;
  int64_t v8;
  void *v9;

  LODWORD(v2) = a2;
  Capacity = C3DArrayGetCapacity(*(_QWORD *)(a1 + 16));
  if (Capacity <= v2)
    v5 = v2;
  else
    v5 = Capacity;
  if (v2 >= v5 >> 1)
    v2 = v5;
  else
    v2 = v2;
  if (v2 != Capacity)
  {
    v6 = Capacity;
    C3DArraySetCapacity(*(_QWORD *)(a1 + 16), v2);
    C3DArraySetCount(*(_DWORD **)(a1 + 16), v2);
    v7 = v2 <= v6;
    v8 = v2 - v6;
    if (!v7)
    {
      v9 = (void *)(C3DArrayGetValuesPtr(*(_QWORD *)(a1 + 16)) + 8 * v6);
      memset(v9, 255, 8 * v8);
    }
  }
}

uint64_t _compareRendererElements(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  uint64_t ValuesPtr;
  int v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  unsigned int v10;

  ValuesPtr = C3DArrayGetValuesPtr(*(_QWORD *)(a1 + 16));
  LODWORD(a2) = C3DRendererElementFlattenedIndexForSpanHandle(*a2, a2[1]);
  v6 = C3DRendererElementFlattenedIndexForSpanHandle(*a3, a3[1]);
  v7 = *(_QWORD *)(ValuesPtr + 8 * (int)a2);
  v8 = *(_QWORD *)(ValuesPtr + 8 * v6);
  v9 = v7 > v8;
  if (v7 == v8)
    v10 = 0;
  else
    v10 = -1;
  if (v9)
    return 1;
  else
    return v10;
}

uint64_t C3DRendererElementFlattenedIndexForSpanHandle(int a1, int a2)
{
  return (a2 + (a1 << 12));
}

uint64_t C3DArrayGetValuesPtr(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DArrayGetCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 16);
}

void C3DArraySetCount(_DWORD *a1, unsigned int a2)
{
  unsigned int v4;

  if (a1[6] != a2)
  {
    v4 = a1[7];
    if (v4 < a2)
    {
      __allocate((uint64_t)a1, a1[8] * v4, a1[8] * a2);
      a1[7] = a2;
    }
    a1[6] = a2;
  }
}

uint64_t C3DIndexSetGetLastRange(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    return 0;
  v1 = (uint64_t *)(a1 + 24);
  if ((*(_BYTE *)(a1 + 16) & 2) != 0)
  {
    v4 = 0;
    return v1[2 * v4];
  }
  v2 = *v1;
  v3 = *(_QWORD *)(v2 + 8);
  if (!v3)
    return 0;
  v1 = (uint64_t *)(v2 + 56);
  v4 = v3 - 1;
  return v1[2 * v4];
}

uint64_t C3DFillModeToMTLFillMode(unsigned int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 2)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DFillModeToMTLFillMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return mtl_FillMode[a1];
}

uint64_t C3DEngineContextGetWarmUpAbortHandler(uint64_t a1)
{
  return *(_QWORD *)(a1 + 464);
}

uint64_t C3DEngineContextGetRendererContextProfile(uint64_t a1)
{
  uint64_t RendererContextGL;

  if (*(_QWORD *)(a1 + 1704))
    return -[SCNMTLRenderContext profile](*(_QWORD *)(a1 + 1704));
  RendererContextGL = C3DEngineContextGetRendererContextGL(a1);
  if (RendererContextGL)
    return C3DRendererContextGetProfile(RendererContextGL);
  else
    return 1;
}

uint64_t C3DCullModeToMTLCullMode(int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 3)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCullModeToMTLCullMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return mtl_CullMode[a1];
}

void C3DArraySetCapacity(uint64_t a1, int a2)
{
  int v3;

  v3 = *(_DWORD *)(a1 + 28);
  if (v3 != a2)
  {
    __allocate(a1, *(_DWORD *)(a1 + 32) * v3, (*(_DWORD *)(a1 + 32) * a2));
    *(_DWORD *)(a1 + 28) = a2;
  }
}

unint64_t __hashCodeFromDesc(int *a1)
{
  uint64x2_t v1;
  int8x16_t v2;

  v1 = (uint64x2_t)vdupq_n_s64(a1[5] | ((unint64_t)(*((unsigned __int16 *)a1 + 12) | (*((unsigned __int8 *)a1 + 26) << 16)) << 32));
  v2 = vorrq_s8(vandq_s8((int8x16_t)vshlq_u64(v1, (uint64x2_t)xmmword_1DD02C450), (int8x16_t)xmmword_1DD02C480), vandq_s8((int8x16_t)vshlq_u64(v1, (uint64x2_t)xmmword_1DD02C460), (int8x16_t)xmmword_1DD02C470));
  return *((unsigned __int8 *)a1 + 8) | (2 * *((unsigned __int8 *)a1 + 9)) | (4 * *((unsigned __int8 *)a1 + 10)) | (32 * *((unsigned __int8 *)a1 + 11)) | ((unint64_t)*((unsigned __int8 *)a1 + 12) << 6) | *a1 | ((((unint64_t)*(unsigned int *)((char *)a1 + 13) >> 5) & 0x7FFF8 | *(int *)((char *)a1 + 13) | ((unint64_t)*(_WORD *)((char *)a1 + 17) << 19) | (*(unsigned __int16 *)((char *)a1 + 17) << 14) & 0x3FC00000 | (*((unsigned __int8 *)a1 + 19) << 25) & 0x7FFFFFFE000000) << 9) | ((unint64_t)(vorr_s8(*(int8x8_t *)v2.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL)).u32[0] | a1[5]) << 37);
}

void sub_1DCCE1780(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void ____arrayOfC3DModifiersFromDictionary_block_invoke(uint64_t a1, void *a2, __CFString *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  const void *v12;
  const __CFString *v13;
  const void *v14;
  uint64_t ArgumentsDefaultValues;
  const __CFDictionary *v16;
  void *v17;
  NSObject *v18;

  if ((objc_msgSend(a2, "isEqualToString:", CFSTR("SCNShaderModifierEntryPointGeometry")) & 1) != 0)
  {
    v6 = 0;
    goto LABEL_9;
  }
  if ((objc_msgSend(a2, "isEqualToString:", CFSTR("SCNShaderModifierEntryPointSurface")) & 1) != 0)
  {
    v6 = 1;
    goto LABEL_9;
  }
  if ((objc_msgSend(a2, "isEqualToString:", CFSTR("SCNShaderModifierEntryPointFragment")) & 1) != 0)
  {
    v6 = 2;
    goto LABEL_9;
  }
  if ((objc_msgSend(a2, "isEqualToString:", CFSTR("SCNShaderModifierEntryPointLightingModel")) & 1) != 0)
  {
    v6 = 3;
LABEL_9:
    -[__CFString rangeOfString:](a3, "rangeOfString:", CFSTR(";"));
    if (v7 != 1)
    {
      v8 = objc_msgSend((id)SCNGetResourceBundle(), "pathForResource:ofType:inDirectory:", objc_msgSend((id)-[__CFString lastPathComponent](a3, "lastPathComponent"), "stringByDeletingPathExtension"), -[__CFString pathExtension](a3, "pathExtension"), -[__CFString stringByDeletingLastPathComponent](a3, "stringByDeletingLastPathComponent"));
      if (v8)
      {
        v9 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithContentsOfFile:encoding:error:", v8, 4, 0);
        if (v9)
          a3 = (__CFString *)v9;
      }
    }
    v10 = C3DGetShadingLanguageFromSource(&a3->isa);
    if (v10 == -1)
      v11 = 1;
    else
      v11 = v10;
    v12 = (const void *)C3DShaderModifiersCreate(a3, v6, 0, v11, 1, 0);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v12);
    CFRelease(v12);
    if (v11)
    {
      v13 = (id)C3DConvertGLSLShaderToMetal(&a3->isa, 0);
      v14 = (const void *)C3DShaderModifiersCreate(v13, v6, 0, 0, 1, 0);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v14);
      CFRelease(v14);
      ArgumentsDefaultValues = C3DShaderModifierGetArgumentsDefaultValues((uint64_t)v14);
      if (ArgumentsDefaultValues)
      {
        v16 = (const __CFDictionary *)ArgumentsDefaultValues;
        v17 = *(void **)(a1 + 40);
        if (v17)
          CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)__setupDefaultArguments, (void *)objc_msgSend(v17, "__CFObject"));
      }
    }
    return;
  }
  v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    ____arrayOfC3DModifiersFromDictionary_block_invoke_cold_1();
}

uint64_t C3DShaderModifiersCreate(CFStringRef theString, int a2, CFDictionaryRef theDict, int a4, int a5, int a6)
{
  CFIndex Count;
  unint64_t v13;
  uint64_t *v14;
  size_t v15;
  uint64_t v16;
  uint64_t *v17;
  CFMutableStringRef Mutable;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v24[2];
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (theDict && CFDictionaryGetCount(theDict) >= 1)
  {
    v25 = a6;
    Count = CFDictionaryGetCount(theDict);
    v24[1] = v24;
    MEMORY[0x1E0C80A78](Count);
    v13 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
    v14 = (_QWORD *)((char *)v24 - v13);
    if ((unint64_t)(8 * Count) >= 0x200)
      v15 = 512;
    else
      v15 = 8 * Count;
    bzero((char *)v24 - v13, v15);
    MEMORY[0x1E0C80A78](v16);
    v17 = (_QWORD *)((char *)v24 - v13);
    bzero((char *)v24 - v13, v15);
    CFDictionaryGetKeysAndValues(theDict, (const void **)((char *)v24 - v13), (const void **)((char *)v24 - v13));
    Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (Count >= 1)
    {
      do
      {
        v20 = *v14++;
        v19 = v20;
        v21 = *v17++;
        CFStringAppendFormat(Mutable, 0, CFSTR("#define %@ %@\n"), v19, v21);
        --Count;
      }
      while (Count);
    }
    CFStringAppend(Mutable, theString);
    LOWORD(a6) = v25;
  }
  else
  {
    Mutable = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theString);
  }
  v22 = __C3DShaderModifierCreate(Mutable, a2, a4, a5, a6);
  CFRelease(Mutable);
  return v22;
}

uint64_t __C3DShaderModifierCreate(const __CFString *a1, int a2, int a3, int a4, __int16 a5)
{
  __int128 v7;
  const void *v8;
  const void *v9;
  __int128 v10;
  const void *v11;
  const void *v12;
  __int16 v13;
  uint64_t Instance;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  NSObject *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  __int16 v24;
  CFAllocatorRef *v25;
  const __CFDictionary *v26;
  const __CFAllocator *v27;
  const __CFDictionary *MutableCopy;
  CFIndex Count;
  CFDictionaryRef Copy;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  CFDictionaryRef v39;
  CFTypeRef v40;
  const __CFDictionary *v41;
  const __CFDictionary *v42;
  const __CFString *v43;
  int i;
  uint64_t v45;
  uint64_t v46;
  const __CFDictionary *v47;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  _QWORD v57[6];
  CC_SHA256_CTX cStr;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v52 = 0u;
  C3DShaderSourceParserContextCreate(0, a3, (uint64_t)&v52);
  C3DShaderSourceParserParseSource(a1, (uint64_t)&v52, 0);
  v7 = v52;
  v8 = (const void *)v53;
  if (a4)
    v9 = (const void *)*((_QWORD *)&v53 + 1);
  else
    v9 = 0;
  v10 = v54;
  v11 = (const void *)v55;
  v12 = (const void *)v56;
  v13 = WORD4(v56);
  if (C3DShaderModifierGetTypeID_onceToken != -1)
    dispatch_once(&C3DShaderModifierGetTypeID_onceToken, &__block_literal_global_123);
  Instance = C3DTypeCreateInstance_(C3DShaderModifierGetTypeID_typeID, 0x78uLL);
  if ((_QWORD)v7)
  {
    if (CFStringGetLength((CFStringRef)v7))
    {
      v15 = *(const void **)(Instance + 16);
      if (v15 != (const void *)v7)
      {
        if (v15)
        {
          CFRelease(v15);
          *(_QWORD *)(Instance + 16) = 0;
        }
        *(_QWORD *)(Instance + 16) = CFRetain((CFTypeRef)v7);
      }
    }
  }
  if ((_QWORD)v10)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v10))
    {
      v16 = *(const void **)(Instance + 56);
      if (v16 != (const void *)v10)
      {
        if (v16)
        {
          CFRelease(v16);
          *(_QWORD *)(Instance + 56) = 0;
        }
        *(_QWORD *)(Instance + 56) = CFRetain((CFTypeRef)v10);
      }
    }
  }
  if (*((_QWORD *)&v10 + 1))
  {
    if (CFDictionaryGetCount(*((CFDictionaryRef *)&v10 + 1)))
    {
      v17 = *(const void **)(Instance + 64);
      if (v17 != *((const void **)&v10 + 1))
      {
        if (v17)
        {
          CFRelease(v17);
          *(_QWORD *)(Instance + 64) = 0;
        }
        *(_QWORD *)(Instance + 64) = CFRetain(*((CFTypeRef *)&v10 + 1));
      }
    }
  }
  if (v11)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v11))
    {
      v18 = *(const void **)(Instance + 72);
      if (v18 != v11)
      {
        if (v18)
        {
          CFRelease(v18);
          *(_QWORD *)(Instance + 72) = 0;
        }
        *(_QWORD *)(Instance + 72) = CFRetain(v11);
      }
    }
  }
  if (!*((_QWORD *)&v7 + 1) || !CFStringGetLength(*((CFStringRef *)&v7 + 1)))
  {
    v20 = scn_default_log();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      __C3DShaderModifierCreate_cold_2(v20);
      if (!v8)
        goto LABEL_44;
      goto LABEL_39;
    }
LABEL_38:
    if (!v8)
      goto LABEL_44;
    goto LABEL_39;
  }
  v19 = *(const void **)(Instance + 24);
  if (v19 == *((const void **)&v7 + 1))
    goto LABEL_38;
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(Instance + 24) = 0;
  }
  *(_QWORD *)(Instance + 24) = CFRetain(*((CFTypeRef *)&v7 + 1));
  if (v8)
  {
LABEL_39:
    if (CFDictionaryGetCount((CFDictionaryRef)v8))
    {
      v21 = *(const void **)(Instance + 32);
      if (v21 != v8)
      {
        if (v21)
        {
          CFRelease(v21);
          *(_QWORD *)(Instance + 32) = 0;
        }
        *(_QWORD *)(Instance + 32) = CFRetain(v8);
      }
    }
  }
LABEL_44:
  if (v9)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v9))
    {
      v22 = *(const void **)(Instance + 48);
      if (v22 != v9)
      {
        if (v22)
        {
          CFRelease(v22);
          *(_QWORD *)(Instance + 48) = 0;
        }
        *(_QWORD *)(Instance + 48) = CFRetain(v9);
      }
    }
  }
  if (v12)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v12))
    {
      v23 = *(const void **)(Instance + 40);
      if (v23 != v12)
      {
        if (v23)
        {
          CFRelease(v23);
          *(_QWORD *)(Instance + 40) = 0;
        }
        *(_QWORD *)(Instance + 40) = CFRetain(v12);
      }
    }
  }
  v24 = v13 | a5;
  *(_DWORD *)(Instance + 88) = a2;
  *(_DWORD *)(Instance + 94) = 0;
  v25 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (*(_QWORD *)(Instance + 24))
  {
    v26 = *(const __CFDictionary **)(Instance + 32);
    v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v26)
    {
      MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v26);
      Count = CFDictionaryGetCount(*(CFDictionaryRef *)(Instance + 32));
    }
    else
    {
      MutableCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      Count = 0;
    }
    v57[0] = MEMORY[0x1E0C809B0];
    v57[1] = 0x40000000;
    v57[2] = ___C3DShaderModifierCreateWithComponents_block_invoke;
    v57[3] = &__block_descriptor_tmp_142;
    v57[4] = Instance;
    v57[5] = MutableCopy;
    if (C3DGetSurfacePropertiesToDefines_onceToken != -1)
      dispatch_once(&C3DGetSurfacePropertiesToDefines_onceToken, &__block_literal_global_3_7);
    C3DCFDictionaryApplyBlock((const __CFDictionary *)C3DGetSurfacePropertiesToDefines_s_dic, (uint64_t)v57);
    if (C3DGetTexturePropertiesToDefines_onceToken != -1)
      dispatch_once(&C3DGetTexturePropertiesToDefines_onceToken, &__block_literal_global_70_0);
    C3DCFDictionaryApplyBlock((const __CFDictionary *)C3DGetTexturePropertiesToDefines_s_dic, (uint64_t)v57);
    if (C3DGetGeometryPropertiesToDefines_onceToken != -1)
      dispatch_once(&C3DGetGeometryPropertiesToDefines_onceToken, &__block_literal_global_77);
    C3DCFDictionaryApplyBlock((const __CFDictionary *)C3DGetGeometryPropertiesToDefines_s_dic, (uint64_t)v57);
    if (C3DGetFramebufferPropertiesToDefines_onceToken != -1)
      dispatch_once(&C3DGetFramebufferPropertiesToDefines_onceToken, &__block_literal_global_107);
    C3DCFDictionaryApplyBlock((const __CFDictionary *)C3DGetFramebufferPropertiesToDefines_s_dic, (uint64_t)v57);
    if (CFDictionaryGetCount(MutableCopy) != Count)
    {
      Copy = CFDictionaryCreateCopy(v27, MutableCopy);
      if (!Copy)
      {
        v31 = scn_default_log();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
          __C3DShaderModifierCreate_cold_1(v31, v32, v33, v34, v35, v36, v37, v38);
      }
      v39 = *(CFDictionaryRef *)(Instance + 32);
      if (v39 != Copy)
      {
        if (v39)
        {
          CFRelease(v39);
          *(_QWORD *)(Instance + 32) = 0;
        }
        if (Copy)
          v40 = CFRetain(Copy);
        else
          v40 = 0;
        *(_QWORD *)(Instance + 32) = v40;
      }
      CFRelease(Copy);
    }
    CFRelease(MutableCopy);
  }
  v41 = *(const __CFDictionary **)(Instance + 32);
  if (v41)
  {
    if (CFDictionaryGetCountOfKey(v41, CFSTR("USE_TANGENT"))
      || CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_TANGENT")))
    {
      v24 |= 4u;
    }
    v42 = *(const __CFDictionary **)(Instance + 32);
    *(_WORD *)(Instance + 92) = v24;
    if (v42)
    {
      if (CFDictionaryGetCountOfKey(v42, CFSTR("USE_EMISSIVETEXCOORD")))
        *(_WORD *)(Instance + 94) |= 1u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_AMBIENTTEXCOORD")))
        *(_WORD *)(Instance + 94) |= 2u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_DIFFUSETEXCOORD")))
        *(_WORD *)(Instance + 94) |= 4u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_SPECULARTEXCOORD")))
        *(_WORD *)(Instance + 94) |= 8u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_REFLECTIVETEXCOORD")))
        *(_WORD *)(Instance + 94) |= 0x10u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_TRANSPARENTTEXCOORD")))
        *(_WORD *)(Instance + 94) |= 0x20u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_FILTERTEXCOORD")))
        *(_WORD *)(Instance + 94) |= 0x40u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_NORMALTEXCOORD")))
        *(_WORD *)(Instance + 94) |= 0x80u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_METALNESSTEXCOORD")))
        *(_WORD *)(Instance + 94) |= 0x400u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_ROUGHNESSTEXCOORD")))
        *(_WORD *)(Instance + 94) |= 0x800u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_CLEARCOATTEXCOORD")))
        *(_WORD *)(Instance + 94) |= 0x1000u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_CLEARCOATROUGHNESSTEXCOORD")))
        *(_WORD *)(Instance + 94) |= 0x2000u;
      if (CFDictionaryGetCountOfKey(*(CFDictionaryRef *)(Instance + 32), CFSTR("USE_CLEARCOATNORMALTEXCOORD")))
        *(_WORD *)(Instance + 94) |= 0x4000u;
    }
  }
  else
  {
    *(_WORD *)(Instance + 92) = v24;
  }
  if (*(_QWORD *)(Instance + 24))
  {
    strcpy((char *)&cStr, "_geometry.texcoords[x]");
    v43 = CFStringCreateWithCStringNoCopy(*v25, (const char *)&cStr, 0x600u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    for (i = 0; i != 8; ++i)
    {
      LOBYTE(cStr.hash[3]) = i + 48;
      if (CFStringFind((CFStringRef)*(_QWORD *)(Instance + 24), v43, 0).location != -1)
        *(_WORD *)(Instance + 96) |= 1 << i;
    }
    CFRelease(v43);
  }
  memset(&cStr, 0, sizeof(cStr));
  CC_SHA256_Init(&cStr);
  CC_SHA256_Update(&cStr, (const void *)(Instance + 88), 4u);
  v45 = *(_QWORD *)(Instance + 24);
  if (v45)
    CFStringUpdateHash(v45);
  v46 = *(_QWORD *)(Instance + 16);
  if (v46)
    CFStringUpdateHash(v46);
  v47 = *(const __CFDictionary **)(Instance + 32);
  if (v47)
    CFDictionaryApplyFunction(v47, (CFDictionaryApplierFunction)CFStringToStringDictionaryHash, &cStr);
  CC_SHA256_Final((unsigned __int8 *)(Instance + 104), &cStr);
  *(_DWORD *)(Instance + 100) = a3;
  C3DShaderSourceParserContextDestroy((uint64_t)&v52);
  return Instance;
}

void C3DShaderSourceParserParseSource(CFStringRef theString, uint64_t a2, int a3)
{
  const __CFAllocator *v5;
  const __CFArray *ArrayBySeparatingStrings;
  CFIndex Count;
  CFMutableStringRef Mutable;
  CFIndex v9;
  int v10;
  const __CFString *ValueAtIndex;
  const __CFString *v12;
  uint64_t v13;
  char v14;
  __int16 v15;

  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theString, CFSTR("\n"));
  Count = CFArrayGetCount(ArrayBySeparatingStrings);
  Mutable = CFStringCreateMutable(v5, 0);
  *(_WORD *)(a2 + 72) = 0;
  if (Count < 1)
    goto LABEL_41;
  v9 = 0;
  v10 = 4;
  do
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v9);
    if (C3DSourceCodeHasPrefix(ValueAtIndex, CFSTR("//")))
      goto LABEL_15;
    if (a3)
    {
      if (!C3DSourceCodeHasPrefix(ValueAtIndex, CFSTR("uniform")))
        goto LABEL_15;
      v12 = ValueAtIndex;
      v13 = a2;
      v14 = 1;
      goto LABEL_14;
    }
    if (C3DSourceCodeHasPrefix(ValueAtIndex, CFSTR("#pragma opaque")))
    {
      v15 = *(_WORD *)(a2 + 72) | 1;
LABEL_11:
      *(_WORD *)(a2 + 72) = v15;
      goto LABEL_15;
    }
    if (C3DSourceCodeHasPrefix(ValueAtIndex, CFSTR("#pragma transparent")))
    {
      v15 = *(_WORD *)(a2 + 72) | 2;
      goto LABEL_11;
    }
    if (C3DSourceCodeHasPrefix(ValueAtIndex, CFSTR("uniform")))
    {
      v12 = ValueAtIndex;
      v13 = a2;
      v14 = 0;
LABEL_14:
      __analyseUniformDeclaration(v12, v13, v14);
      goto LABEL_15;
    }
    if (C3DSourceCodeHasPrefix(ValueAtIndex, CFSTR("#pragma declaration")))
    {
LABEL_18:
      v10 = 0;
    }
    else if (C3DSourceCodeHasPrefix(ValueAtIndex, CFSTR("#pragma arguments")))
    {
      if (v10 == 4 && CFStringGetLength(Mutable))
      {
        CFStringAppend(*(CFMutableStringRef *)a2, Mutable);
        CFStringReplaceAll(Mutable, &stru_1EA5A6480);
      }
LABEL_23:
      v10 = 1;
    }
    else if (C3DSourceCodeHasPrefix(ValueAtIndex, CFSTR("#pragma varyings")))
    {
      if (v10 == 4 && CFStringGetLength(Mutable))
      {
        CFStringAppend(*(CFMutableStringRef *)a2, Mutable);
        CFStringReplaceAll(Mutable, &stru_1EA5A6480);
      }
LABEL_35:
      v10 = 2;
    }
    else if (C3DSourceCodeHasPrefix(ValueAtIndex, CFSTR("#pragma body")))
    {
      if (v10 == 4 && CFStringGetLength(Mutable))
      {
        CFStringAppend(*(CFMutableStringRef *)a2, Mutable);
        CFStringReplaceAll(Mutable, &stru_1EA5A6480);
      }
LABEL_37:
      v10 = 3;
    }
    else
    {
      switch(v10)
      {
        case 0:
          __analyseStandardUniformUsage(ValueAtIndex, a2);
          CFStringAppend(*(CFMutableStringRef *)a2, ValueAtIndex);
          CFStringAppend(*(CFMutableStringRef *)a2, CFSTR("\n"));
          goto LABEL_18;
        case 1:
          __analyseArgumentDeclaration(ValueAtIndex, a2);
          goto LABEL_23;
        case 2:
          __analyseVaryingDeclaration(ValueAtIndex, a2);
          goto LABEL_35;
        case 3:
          __analyseStandardUniformUsage(ValueAtIndex, a2);
          CFStringAppend(*(CFMutableStringRef *)(a2 + 8), ValueAtIndex);
          CFStringAppend(*(CFMutableStringRef *)(a2 + 8), CFSTR("\n"));
          goto LABEL_37;
        case 4:
          __analyseStandardUniformUsage(ValueAtIndex, a2);
          CFStringAppend(Mutable, ValueAtIndex);
          CFStringAppend(Mutable, CFSTR("\n"));
          v10 = 4;
          break;
        default:
          break;
      }
    }
LABEL_15:
    ++v9;
  }
  while (Count != v9);
  if (v10 == 4)
  {
LABEL_41:
    if (CFStringGetLength(Mutable))
    {
      CFStringAppend(*(CFMutableStringRef *)(a2 + 8), Mutable);
      CFStringReplaceAll(Mutable, &stru_1EA5A6480);
    }
  }
  CFRelease(Mutable);
  CFRelease(ArrayBySeparatingStrings);
}

BOOL C3DSourceCodeHasPrefix(const __CFString *a1, const __CFString *a2)
{
  CFIndex Length;
  CFIndex v5;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  const __CFString *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  UniChar v13;
  uint64_t v14;
  UniChar v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  UniChar v23[8];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  CFStringRef v31[2];
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  UniChar buffer[8];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  CFStringRef theString;
  const UniChar *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  CFRange v50;
  CFRange v51;

  Length = CFStringGetLength(a1);
  v5 = CFStringGetLength(a2);
  theString = a1;
  v46 = 0;
  v47 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v44 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  *(_OWORD *)v23 = 0u;
  v24 = 0u;
  v48 = 0;
  v49 = 0;
  v45 = CStringPtr;
  v31[0] = a2;
  v33 = (unint64_t)v5;
  v34 = 0;
  v8 = (const __CFString *)CFStringGetCharactersPtr(a2);
  v9 = 0;
  v31[1] = v8;
  if (!v8)
    v9 = CFStringGetCStringPtr(a2, 0x600u);
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  *(_OWORD *)buffer = 0u;
  v36 = 0u;
  *((_QWORD *)&v33 + 1) = 0;
  v34 = 0;
  *(_QWORD *)&v32 = v9;
  v21 = 0;
  v22 = 0;
  C3DInlineBufferConsumeWhitespaces(buffer, &v22, Length);
LABEL_6:
  C3DInlineBufferConsumeWhitespaces(v23, &v21, v5);
  v10 = v21;
  while (1)
  {
    if (v10 == v5)
      return 1;
    v11 = v22;
    if (v22 == Length)
      goto LABEL_51;
    if (v22 < 0 || (v12 = v47, v47 <= v22))
    {
      v13 = 0;
    }
    else if (v44)
    {
      v13 = v44[v46 + v22];
    }
    else if (v45)
    {
      v13 = v45[v46 + v22];
    }
    else
    {
      if (v49 <= v22 || (v16 = v48, v48 > v22))
      {
        v17 = v22 - 4;
        if ((unint64_t)v22 < 4)
          v17 = 0;
        if (v17 + 64 < v47)
          v12 = v17 + 64;
        v48 = v17;
        v49 = v12;
        v50.location = v46 + v17;
        v50.length = v12 - v17;
        CFStringGetCharacters(theString, v50, buffer);
        v16 = v48;
      }
      v13 = buffer[v11 - v16];
    }
    if (v10 < 0 || (v14 = v33, (uint64_t)v33 <= v10))
    {
      v15 = 0;
    }
    else if (v31[1])
    {
      v15 = *((_WORD *)&v31[1]->isa + *((_QWORD *)&v32 + 1) + v10);
    }
    else if ((_QWORD)v32)
    {
      v15 = *(char *)(v32 + *((_QWORD *)&v32 + 1) + v10);
    }
    else
    {
      if (v34 <= v10 || (v18 = *((_QWORD *)&v33 + 1), *((uint64_t *)&v33 + 1) > v10))
      {
        v19 = v10 - 4;
        if ((unint64_t)v10 < 4)
          v19 = 0;
        if (v19 + 64 < (uint64_t)v33)
          v14 = v19 + 64;
        *((_QWORD *)&v33 + 1) = v19;
        v34 = v14;
        v51.location = *((_QWORD *)&v32 + 1) + v19;
        v51.length = v14 - v19;
        CFStringGetCharacters(v31[0], v51, v23);
        v18 = *((_QWORD *)&v33 + 1);
      }
      v15 = v23[v10 - v18];
    }
    if (v15 == 12288
      || (unsigned __int16)(v15 - 0x2000) < 0xCu
      || v15 < 0x21u
      || (unsigned __int16)(v15 - 127) <= 0x21u)
    {
      if (v13 == 12288
        || (unsigned __int16)(v13 - 0x2000) < 0xCu
        || v13 < 0x21u
        || (unsigned __int16)(v13 - 127) <= 0x21u)
      {
        C3DInlineBufferConsumeWhitespaces(buffer, &v22, Length);
        goto LABEL_6;
      }
LABEL_51:
      C3DInlineBufferConsumeWhitespaces(v23, &v21, v5);
      return v21 == v5;
    }
    if (v13 != v15)
      return 0;
    v21 = ++v10;
    v22 = v11 + 1;
  }
}

void C3DInlineBufferConsumeWhitespaces(UniChar *buffer, uint64_t *a2, uint64_t a3)
{
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  UniChar v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFRange v13;

  for (i = *a2; i < a3; *a2 = i)
  {
    if (i < 0 || (v7 = *((_QWORD *)buffer + 20), v7 <= i))
    {
      v9 = 0;
    }
    else
    {
      v8 = *((_QWORD *)buffer + 17);
      if (v8)
      {
        v9 = *(_WORD *)(v8 + 2 * (*((_QWORD *)buffer + 19) + i));
      }
      else
      {
        v10 = *((_QWORD *)buffer + 18);
        if (v10)
        {
          v9 = *(char *)(v10 + *((_QWORD *)buffer + 19) + i);
        }
        else
        {
          if (*((_QWORD *)buffer + 22) <= i || (v11 = *((_QWORD *)buffer + 21), v11 > i))
          {
            v12 = i - 4;
            if ((unint64_t)i < 4)
              v12 = 0;
            if (v12 + 64 < v7)
              v7 = v12 + 64;
            *((_QWORD *)buffer + 21) = v12;
            *((_QWORD *)buffer + 22) = v7;
            v13.location = *((_QWORD *)buffer + 19) + v12;
            v13.length = v7 - v12;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v13, buffer);
            v11 = *((_QWORD *)buffer + 21);
          }
          v9 = buffer[i - v11];
        }
      }
    }
    if (v9 != 12288 && (unsigned __int16)(v9 - 0x2000) >= 0xCu && v9 >= 0x21u && (unsigned __int16)(v9 - 127) > 0x21u)
      break;
    i = *a2 + 1;
  }
}

uint64_t __analyseStandardUniformUsage(const __CFString *a1, uint64_t a2)
{
  CFIndex Length;
  const __CFDictionary *StandardUniforms;
  uint64_t result;
  BOOL v7;
  const __CFAllocator *v8;
  CFIndex CurrentTokenRange;
  CFIndex v10;
  CFIndex v11;
  BOOL v12;
  CFIndex v13;
  CFIndex v14;
  uint64_t v15;
  CFStringRef v16;
  const void **Value;
  _OWORD v18[16];
  CFRange v19;
  CFRange v20;
  CFRange v21;
  CFRange v22;
  CFRange v23;

  memset(v18, 0, 240);
  Length = CFStringGetLength(a1);
  C3DStringTokenizerInit((uint64_t)v18, a1, 0, Length, 1);
  StandardUniforms = (const __CFDictionary *)C3DShaderGetStandardUniforms();
  result = C3DStringTokenizerAdvanceToNextToken((uint64_t)v18);
  if ((_DWORD)result)
  {
    v7 = 0;
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    while (1)
    {
      if (C3DStringTokenizerIsCurrentIsTokenWhiteSpaceOnly((uint64_t)v18))
        C3DStringTokenizerAdvanceToNextToken((uint64_t)v18);
      CurrentTokenRange = C3DStringTokenizerGetCurrentTokenRange((uint64_t)v18);
      v11 = v10;
      v19.location = CurrentTokenRange;
      v19.length = v10;
      result = CFStringCompareWithOptions(a1, CFSTR("/"), v19, 0);
      v12 = result == 0;
      if (!result)
      {
        if (v7)
          return result;
        goto LABEL_14;
      }
      v20.location = CurrentTokenRange;
      v20.length = v11;
      if (CFStringCompareWithOptions(a1, CFSTR("scn_node"), v20, 0))
      {
        v21.location = CurrentTokenRange;
        v21.length = v11;
        if (CFStringCompareWithOptions(a1, CFSTR("scn_frame"), v21, 0))
          goto LABEL_10;
      }
      C3DStringTokenizerAdvanceToNextToken((uint64_t)v18);
      v22.location = C3DStringTokenizerGetCurrentTokenRange((uint64_t)v18);
      v14 = v13;
      v22.length = v13;
      if (CFStringCompareWithOptions(a1, CFSTR("."), v22, 0) == kCFCompareEqualTo)
        break;
LABEL_14:
      result = C3DStringTokenizerAdvanceToNextToken((uint64_t)v18);
      v7 = v12;
      if ((result & 1) == 0)
        return result;
    }
    C3DStringTokenizerAdvanceToNextToken((uint64_t)v18);
    C3DStringTokenizerGetCurrentTokenRange((uint64_t)v18);
    v11 += v14 + v15;
LABEL_10:
    v23.location = CurrentTokenRange;
    v23.length = v11;
    v16 = CFStringCreateWithSubstring(v8, a1, v23);
    Value = (const void **)CFDictionaryGetValue(StandardUniforms, v16);
    if (Value)
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 64), v16, *Value);
    CFRelease(v16);
    goto LABEL_14;
  }
  return result;
}

uint64_t _C3DStringTokenizerAdvanceToNextToken(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  UniChar v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  UniChar v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  UniChar v32;
  int IsCharacterMember;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  CFRange v39;
  CFRange v40;
  CFRange v41;

  result = 0;
  v4 = *(_QWORD *)(a1 + 208) + *(_QWORD *)(a1 + 200);
  v5 = *(_QWORD *)(a1 + 8) + *(_QWORD *)a1;
  *(_BYTE *)(a1 + 217) = 0;
  if (v4 >= v5)
    return result;
  v7 = a1 + 16;
  while (1)
  {
    v8 = v4 - *(_QWORD *)a1;
    if (v8 < 0 || (v9 = *(_QWORD *)(a1 + 176), v9 <= v8))
    {
      v11 = 0;
    }
    else
    {
      v10 = *(_QWORD *)(a1 + 152);
      if (v10)
      {
        v11 = *(_WORD *)(v10 + 2 * (*(_QWORD *)(a1 + 168) + v8));
      }
      else
      {
        v22 = *(_QWORD *)(a1 + 160);
        if (v22)
        {
          v11 = *(char *)(v22 + *(_QWORD *)(a1 + 168) + v8);
        }
        else
        {
          if (*(_QWORD *)(a1 + 192) <= v8 || (v23 = *(_QWORD *)(a1 + 184), v23 > v8))
          {
            v24 = v8 - 4;
            if ((unint64_t)v8 < 4)
              v24 = 0;
            if (v24 + 64 < v9)
              v9 = v24 + 64;
            *(_QWORD *)(a1 + 184) = v24;
            *(_QWORD *)(a1 + 192) = v9;
            v40.location = *(_QWORD *)(a1 + 168) + v24;
            v40.length = v9 - v24;
            CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v40, (UniChar *)(a1 + 16));
            v23 = *(_QWORD *)(a1 + 184);
          }
          v11 = *(_WORD *)(v7 + 2 * (v8 - v23));
        }
      }
    }
    ++v4;
    if (CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), v11))
    {
      v12 = v4;
      do
      {
        v4 = v12;
        v13 = v12 - *(_QWORD *)a1;
        if (v13 < 0 || (v14 = *(_QWORD *)(a1 + 176), v14 <= v13))
        {
          v16 = 0;
        }
        else
        {
          v15 = *(_QWORD *)(a1 + 152);
          if (v15)
          {
            v16 = *(_WORD *)(v15 + 2 * (*(_QWORD *)(a1 + 168) + v13));
          }
          else
          {
            v17 = *(_QWORD *)(a1 + 160);
            if (v17)
            {
              v16 = *(char *)(v17 + *(_QWORD *)(a1 + 168) + v13);
            }
            else
            {
              if (*(_QWORD *)(a1 + 192) <= v13 || (v18 = *(_QWORD *)(a1 + 184), v18 > v13))
              {
                v19 = v13 - 4;
                if ((unint64_t)v13 < 4)
                  v19 = 0;
                if (v19 + 64 < v14)
                  v14 = v19 + 64;
                *(_QWORD *)(a1 + 184) = v19;
                *(_QWORD *)(a1 + 192) = v14;
                v39.location = *(_QWORD *)(a1 + 168) + v19;
                v39.length = v14 - v19;
                CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v39, (UniChar *)(a1 + 16));
                v18 = *(_QWORD *)(a1 + 184);
              }
              v16 = *(_WORD *)(v7 + 2 * (v13 - v18));
            }
          }
        }
        v12 = v4 + 1;
      }
      while (CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), v16));
      v20 = *(_QWORD *)(a1 + 200) + *(_QWORD *)(a1 + 208);
      *(_QWORD *)(a1 + 200) = v20;
      *(_QWORD *)(a1 + 208) = v4 - v20;
      if (*(_BYTE *)(a1 + 216))
      {
        result = 1;
        *(_BYTE *)(a1 + 217) = 1;
        return result;
      }
      goto LABEL_32;
    }
    if (v11 == 95 || CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 232), v11))
      break;
    v21 = *(_QWORD *)(a1 + 200) + *(_QWORD *)(a1 + 208);
    *(_QWORD *)(a1 + 200) = v21;
    *(_QWORD *)(a1 + 208) = v4 - v21;
    if (*(_BYTE *)(a1 + 216))
      return 1;
LABEL_32:
    if (v4 >= v5)
      return 0;
  }
  v25 = 0;
  v26 = v4;
  do
  {
LABEL_45:
    v27 = v26;
    while (1)
    {
      v26 = v27;
      v28 = v4++;
      v29 = v28 - *(_QWORD *)a1;
      if (v29 < 0 || (v30 = *(_QWORD *)(a1 + 176), v30 <= v29))
      {
        v32 = 0;
      }
      else
      {
        v31 = *(_QWORD *)(a1 + 152);
        if (v31)
        {
          v32 = *(_WORD *)(v31 + 2 * (*(_QWORD *)(a1 + 168) + v29));
        }
        else
        {
          v35 = *(_QWORD *)(a1 + 160);
          if (v35)
          {
            v32 = *(char *)(v35 + *(_QWORD *)(a1 + 168) + v29);
          }
          else
          {
            if (*(_QWORD *)(a1 + 192) <= v29 || (v36 = *(_QWORD *)(a1 + 184), v36 > v29))
            {
              v37 = v29 - 4;
              if ((unint64_t)v29 < 4)
                v37 = 0;
              if (v37 + 64 < v30)
                v30 = v37 + 64;
              *(_QWORD *)(a1 + 184) = v37;
              *(_QWORD *)(a1 + 192) = v30;
              v41.location = *(_QWORD *)(a1 + 168) + v37;
              v41.length = v30 - v37;
              CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v41, (UniChar *)(a1 + 16));
              v36 = *(_QWORD *)(a1 + 184);
            }
            v32 = *(_WORD *)(v7 + 2 * (v29 - v36));
          }
        }
        if (v32 == 95)
        {
          CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), 0x5Fu);
          goto LABEL_52;
        }
      }
      IsCharacterMember = CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 232), v32);
      v34 = CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), v32);
      if (!IsCharacterMember)
        break;
LABEL_52:
      v27 = v4;
      if ((v25 & 1) != 0)
        goto LABEL_70;
    }
    if (!a2)
      break;
    v25 = 1;
    if (v32 == 42)
    {
      v26 = v4;
      goto LABEL_45;
    }
  }
  while (v34);
LABEL_70:
  v38 = *(_QWORD *)(a1 + 200) + *(_QWORD *)(a1 + 208);
  *(_QWORD *)(a1 + 200) = v38;
  *(_QWORD *)(a1 + 208) = v26 - v38;
  return 1;
}

uint64_t C3DStringTokenizerAdvanceToNextToken(uint64_t a1)
{
  return _C3DStringTokenizerAdvanceToNextToken(a1, 0);
}

uint64_t C3DStringTokenizerGetCurrentTokenRange(uint64_t a1)
{
  return *(_QWORD *)(a1 + 200);
}

uint64_t C3DStringTokenizerIsCurrentIsTokenWhiteSpaceOnly(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 217);
}

CFCharacterSetRef C3DStringTokenizerInit(uint64_t a1, CFStringRef theString, uint64_t a3, uint64_t a4, char a5)
{
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  CFCharacterSetRef result;

  *(_QWORD *)a1 = a3;
  *(_QWORD *)(a1 + 8) = a4;
  if (theString)
  {
    *(_QWORD *)(a1 + 144) = theString;
    *(_QWORD *)(a1 + 168) = a3;
    *(_QWORD *)(a1 + 176) = a4;
    CharactersPtr = CFStringGetCharactersPtr(theString);
    *(_QWORD *)(a1 + 152) = CharactersPtr;
    if (CharactersPtr)
      CStringPtr = 0;
    else
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    *(_QWORD *)(a1 + 160) = CStringPtr;
    *(_QWORD *)(a1 + 184) = 0;
    *(_QWORD *)(a1 + 192) = 0;
  }
  *(_QWORD *)(a1 + 200) = a3;
  *(_QWORD *)(a1 + 208) = 0;
  *(_BYTE *)(a1 + 216) = a5;
  *(_QWORD *)(a1 + 224) = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  result = CFCharacterSetGetPredefined(kCFCharacterSetAlphaNumeric);
  *(_QWORD *)(a1 + 232) = result;
  return result;
}

uint64_t C3DShaderGetStandardUniforms()
{
  if (C3DShaderGetStandardUniforms_onceToken != -1)
    dispatch_once(&C3DShaderGetStandardUniforms_onceToken, &__block_literal_global_146);
  return C3DShaderGetStandardUniforms_s_standardUniforms;
}

void __analyseArgumentDeclaration(const __CFString *a1, uint64_t a2)
{
  CFIndex Length;
  CFIndex v5;
  const __CFAllocator *v6;
  const __CFString *v7;
  CFIndex v8;
  CFMutableStringRef MutableCopy;
  CFIndex CurrentTokenRange;
  CFIndex v11;
  CFIndex v12;
  const __CFString *v13;
  CFComparisonResult v14;
  char Token;
  CFIndex v16;
  CFIndex v17;
  CFIndex v18;
  CFStringRef v19;
  int v20;
  int v21;
  CFIndex v22;
  CFIndex v23;
  __CFString *v24;
  uint64_t v25;
  uint64_t v26;
  const __CFString *v27;
  const void *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  CFRange v44;
  CFRange v45;
  CFRange v46;
  CFRange v47;
  CFRange v48;
  CFRange v49;

  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v29 = 0u;
  Length = CFStringGetLength(a1);
  C3DStringTokenizerInit((uint64_t)&v29, a1, 0, Length, 1);
  _C3DStringTokenizerAdvanceToNextToken((uint64_t)&v29, 1);
  if (C3DStringTokenizerIsCurrentIsTokenWhiteSpaceOnly((uint64_t)&v29))
    _C3DStringTokenizerAdvanceToNextToken((uint64_t)&v29, 1);
  v44.location = C3DStringTokenizerGetCurrentTokenRange((uint64_t)&v29);
  v44.length = v5;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v44);
  _C3DStringTokenizerAdvanceToNextToken((uint64_t)&v29, 1);
  v45.location = C3DStringTokenizerGetCurrentTokenRange((uint64_t)&v29);
  v45.length = v8;
  if (CFStringCompareWithOptions(a1, CFSTR("<"), v45, 0))
  {
    MutableCopy = (CFMutableStringRef)v7;
  }
  else
  {
    MutableCopy = CFStringCreateMutableCopy(v6, 0, v7);
    do
    {
      CurrentTokenRange = C3DStringTokenizerGetCurrentTokenRange((uint64_t)&v29);
      v12 = v11;
      v46.location = CurrentTokenRange;
      v46.length = v11;
      v13 = CFStringCreateWithSubstring(v6, a1, v46);
      CFStringAppend(MutableCopy, v13);
      CFRelease(v13);
      v47.location = CurrentTokenRange;
      v47.length = v12;
      v14 = CFStringCompareWithOptions(a1, CFSTR(">"), v47, 0);
      Token = _C3DStringTokenizerAdvanceToNextToken((uint64_t)&v29, 1);
    }
    while (v14 && (Token & 1) != 0);
    CFRelease(v7);
  }
  if (C3DStringTokenizerIsCurrentIsTokenWhiteSpaceOnly((uint64_t)&v29))
    _C3DStringTokenizerAdvanceToNextToken((uint64_t)&v29, 1);
  v16 = C3DStringTokenizerGetCurrentTokenRange((uint64_t)&v29);
  v18 = v17;
  v48.location = v16;
  v48.length = v17;
  v19 = CFStringCreateWithSubstring(v6, a1, v48);
  if (CFStringGetLength(MutableCopy) >= 1)
  {
    v20 = *(_DWORD *)(a2 + 76) == 1 ? C3DBaseTypeFromGLSLString(MutableCopy) : C3DBaseTypeFromMetalString(MutableCopy);
    v21 = v20;
    if (v20)
    {
      v22 = v16 + v18;
      v23 = CFStringGetLength(a1);
      if (v23 > v22)
      {
        v49.location = v22;
        v49.length = v23 - v22;
        v24 = (__CFString *)CFStringCreateWithSubstring(v6, a1, v49);
        v25 = -[__CFString rangeOfString:](v24, "rangeOfString:", CFSTR("="), v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43);
        if (v26)
        {
          v27 = (const __CFString *)-[__CFString substringFromIndex:](v24, "substringFromIndex:", v25 + 1);
          v28 = (const void *)C3DValueCreate(v21, 1);
          C3DValueSetValueFromString((uint64_t)v28, v27);
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 40), v19, v28);
          CFRelease(v28);
        }
        CFRelease(v24);
      }
    }
  }
  if (CFStringGetLength(v19) >= 1 && CFStringGetLength(MutableCopy) >= 1)
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 32), v19, MutableCopy);
  if (v19)
    CFRelease(v19);
  if (MutableCopy)
    CFRelease(MutableCopy);
}

CFComparisonResult __C3DBaseTypeFromMetalString(const __CFString *a1)
{
  CFComparisonResult result;
  NSObject *v3;
  _BOOL4 v4;
  int v5;
  const __CFString *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (CFStringCompare(a1, CFSTR("int"), 0) == kCFCompareEqualTo)
    return 2;
  if (CFStringCompare(a1, CFSTR("BOOL"), 0) == kCFCompareEqualTo)
    return 3;
  if (CFStringCompare(a1, CFSTR("texture1d"), 0) == kCFCompareEqualTo
    || CFStringCompare(a1, CFSTR("texture2d"), 0) == kCFCompareEqualTo
    || CFStringCompare(a1, CFSTR("texture3d"), 0) == kCFCompareEqualTo
    || CFStringCompare(a1, CFSTR("texturecube"), 0) == kCFCompareEqualTo)
  {
    return 5;
  }
  if (CFStringCompare(a1, CFSTR("float"), 0) == kCFCompareEqualTo)
    return 1;
  if (CFStringCompare(a1, CFSTR("float2"), 0) == kCFCompareEqualTo)
    return 8;
  if (CFStringCompare(a1, CFSTR("float3"), 0) == kCFCompareEqualTo)
    return 9;
  if (CFStringCompare(a1, CFSTR("float4"), 0) == kCFCompareEqualTo)
    return 10;
  if (CFStringCompare(a1, CFSTR("int2"), 0) == kCFCompareEqualTo)
    return 18;
  if (CFStringCompare(a1, CFSTR("int3"), 0) == kCFCompareEqualTo)
    return 19;
  if (CFStringCompare(a1, CFSTR("int4"), 0) == kCFCompareEqualTo)
    return 20;
  if (CFStringCompare(a1, CFSTR("float4x4"), 0) == kCFCompareEqualTo)
    return 11;
  result = CFStringCompare(a1, CFSTR("none"), 0);
  if (result)
  {
    v3 = scn_default_log();
    v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    result = kCFCompareEqualTo;
    if (v4)
    {
      v5 = 138412290;
      v6 = a1;
      _os_log_impl(&dword_1DCCB8000, v3, OS_LOG_TYPE_DEFAULT, "Warning: C3DBaseTypeFromMetalString: unknown type name '%@'", (uint8_t *)&v5, 0xCu);
      return 0;
    }
  }
  return result;
}

CFComparisonResult C3DBaseTypeFromMetalString(const __CFString *a1)
{
  CFRange v2;
  const __CFString *v3;
  CFComparisonResult v4;
  CFRange v6;

  v2 = CFStringFind(a1, CFSTR("["), 4uLL);
  if (!v2.length)
    return __C3DBaseTypeFromMetalString(a1);
  v6.length = v2.location;
  v6.location = 0;
  v3 = CFStringCreateWithSubstring(0, a1, v6);
  v4 = __C3DBaseTypeFromMetalString(v3);
  CFRelease(v3);
  return v4;
}

void C3DShaderSourceParserContextDestroy(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  v2 = *(const void **)a1;
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)a1 = 0;
  }
  v3 = *(const void **)(a1 + 8);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v6 = *(const void **)(a1 + 56);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v7 = *(const void **)(a1 + 40);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v8 = *(const void **)(a1 + 32);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v9 = *(const void **)(a1 + 48);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v10 = *(const void **)(a1 + 64);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 64) = 0;
  }
}

CFMutableDictionaryRef C3DShaderSourceParserContextCreate@<X0>(char a1@<W0>, int a2@<W1>, uint64_t a3@<X8>)
{
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v6;
  const CFDictionaryKeyCallBacks *v7;
  const CFDictionaryValueCallBacks *v8;
  CFMutableDictionaryRef result;

  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  if ((a1 & 1) != 0)
  {
    Mutable = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  }
  else
  {
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *(_QWORD *)a3 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    *(_QWORD *)(a3 + 8) = CFStringCreateMutable(v6, 0);
    Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  *(_QWORD *)(a3 + 16) = Mutable;
  v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  *(_QWORD *)(a3 + 24) = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], 0);
  v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  *(_QWORD *)(a3 + 56) = CFDictionaryCreateMutable(v6, 0, v7, MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(a3 + 32) = CFDictionaryCreateMutable(v6, 0, v7, v8);
  *(_QWORD *)(a3 + 40) = CFDictionaryCreateMutable(v6, 0, v7, v8);
  *(_QWORD *)(a3 + 48) = CFDictionaryCreateMutable(v6, 0, v7, v8);
  result = CFDictionaryCreateMutable(v6, 0, v7, v8);
  *(_QWORD *)(a3 + 64) = result;
  *(_DWORD *)(a3 + 76) = a2;
  return result;
}

uint64_t C3DStandardShadersUseFunctionConstants()
{
  if (C3DStandardShadersUseFunctionConstants_onceToken != -1)
    dispatch_once(&C3DStandardShadersUseFunctionConstants_onceToken, &__block_literal_global_178);
  return C3DStandardShadersUseFunctionConstants_enableFunctionConstants;
}

void _C3DArrayCFFinalize(uint64_t a1)
{
  free(*(void **)(a1 + 16));
}

uint64_t C3DGetShadingLanguageFromSource(NSString *a1)
{
  unsigned int v1;
  uint64_t v2;
  char *v4[4];
  int v5;

  ShaderConverter::ShaderConverter((ShaderConverter *)v4, a1);
  ShaderConverter::Parse(v4, 1);
  if (v5 == 1)
    v1 = 1;
  else
    v1 = -1;
  if (v5 == 2)
    v2 = 0;
  else
    v2 = v1;
  ShaderConverter::~ShaderConverter((ShaderConverter *)v4);
  return v2;
}

void sub_1DCCE46BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ShaderConverter::~ShaderConverter((ShaderConverter *)&a9);
  _Unwind_Resume(a1);
}

void ShaderConverter::ShaderConverter(ShaderConverter *this, NSString *a2)
{
  *(_QWORD *)this = &off_1EA595E28;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_BYTE *)this + 96) = 0;
  *(_OWORD *)((char *)this + 100) = 0u;
  *(_OWORD *)((char *)this + 116) = 0u;
  *(_OWORD *)((char *)this + 132) = 0u;
  *(_OWORD *)((char *)this + 148) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_QWORD *)this + 22) = (char *)this + 184;
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 25) = (char *)this + 208;
  *((_QWORD *)this + 27) = 0;
  MEMORY[0x1DF0D40B8]((char *)this + 8, -[NSString UTF8String](a2, "UTF8String"));
  if (ShaderConverter::StaticInit(void)::onceToken != -1)
    dispatch_once(&ShaderConverter::StaticInit(void)::onceToken, &__block_literal_global_2);
}

void sub_1DCCE47BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  void **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v8;
  va_list va;

  va_start(va, a2);
  v6 = v4;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(v6, *(_QWORD **)(v2 + 208));
  std::__tree<std::string>::destroy(v5, *(char **)(v2 + 184));
  v8 = *(void **)(v2 + 152);
  if (v8)
  {
    *(_QWORD *)(v2 + 160) = v8;
    operator delete(v8);
  }
  std::vector<Variable>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  std::vector<Variable>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  if (*(char *)(v2 + 31) < 0)
    operator delete(*v3);
  _Unwind_Resume(a1);
}

uint64_t ShaderConverter::Parse(char **this, int a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  int v8;
  Statement *v10;
  _BOOL4 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  Statement *v16;
  Statement *v17;
  Statement *v18;
  int v19;
  std::string *p_p;
  std::string *v21;
  int data;
  int v23;
  _BOOL4 v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  Statement *v32;
  int v33;
  int v34;
  int v35;
  char *v36;
  uint64_t i;
  char *v38;
  char *v39;
  std::string v41;
  std::string v42;
  std::string __p;

  v4 = (char *)(this + 23);
  std::__tree<std::string>::destroy((uint64_t)(this + 22), this[23]);
  this[22] = v4;
  *(_QWORD *)v4 = 0;
  v5 = this[26];
  this[24] = 0;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)(this + 25), v5);
  this[25] = (char *)(this + 26);
  this[26] = 0;
  this[27] = 0;
  this[10] = 0;
  if (this[9])
    ShaderConverter::Parse();
  v6 = operator new();
  Tokenizer::Tokenizer(v6, this + 1);
  this[9] = (char *)v6;
  v7 = (char *)operator new();
  *(_QWORD *)v7 = &off_1EA598440;
  *((_QWORD *)v7 + 1) = 0;
  *((_QWORD *)v7 + 2) = 0;
  *((_QWORD *)v7 + 3) = 0;
  this[11] = v7;
  ShaderConverter::NextToken((ShaderConverter *)this);
  do
  {
    v8 = *((_DWORD *)this + 16);
    if (v8 == 1)
    {
      Token::str((Token *)(this + 5), &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        if (__p.__r_.__value_.__l.__size_ == 7)
        {
          v12 = *(_DWORD *)__p.__r_.__value_.__l.__data_ != 1718185589
             || *(_DWORD *)(__p.__r_.__value_.__r.__words[0] + 3) != 1836216166;
          operator delete(__p.__r_.__value_.__l.__data_);
          if (!v12)
          {
LABEL_26:
            ++*((_DWORD *)this + 21);
            ShaderConverter::ParseUniform((ShaderConverter *)this);
            if (!a2)
              continue;
            goto LABEL_34;
          }
        }
        else
        {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      else if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) == 7
             && LODWORD(__p.__r_.__value_.__l.__data_) == 1718185589
             && *(_DWORD *)((char *)__p.__r_.__value_.__r.__words + 3) == 1836216166)
      {
        goto LABEL_26;
      }
      v13 = ShaderConverter::mpStatics + 48;
      Token::str((Token *)(this + 5), &__p);
      v14 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v13, (const void **)&__p.__r_.__value_.__l.__data_);
      v15 = ShaderConverter::mpStatics;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (v15 + 56 != v14)
      {
        *((_DWORD *)this + 25) = 4;
        v16 = (Statement *)this[11];
        v17 = (Statement *)ShaderConverter::ParseTextureLookup((ShaderConverter *)this);
        v18 = v16;
        goto LABEL_33;
      }
      v19 = *((_DWORD *)this + 25);
      if (v19 != 3 && v19)
        goto LABEL_73;
      Token::str((Token *)(this + 5), &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        if (__p.__r_.__value_.__l.__size_ != 2)
          goto LABEL_46;
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      else
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 2)
          goto LABEL_46;
        p_p = &__p;
      }
      if (LOWORD(p_p->__r_.__value_.__l.__data_) == 26217)
      {
        v26 = 0;
        if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) == 0)
          goto LABEL_85;
        goto LABEL_72;
      }
LABEL_46:
      Token::str((Token *)(this + 5), &v42);
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
      {
        if (v42.__r_.__value_.__l.__size_ != 5)
          goto LABEL_55;
        v21 = (std::string *)v42.__r_.__value_.__r.__words[0];
      }
      else
      {
        if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) != 5)
          goto LABEL_55;
        v21 = &v42;
      }
      data = (int)v21->__r_.__value_.__l.__data_;
      v23 = v21->__r_.__value_.__s.__data_[4];
      if (data == 1818847351 && v23 == 101)
      {
        v26 = 0;
        if ((*((_BYTE *)&v42.__r_.__value_.__s + 23) & 0x80) == 0)
          goto LABEL_84;
        goto LABEL_83;
      }
LABEL_55:
      Token::str((Token *)(this + 5), &v41);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
      {
        v26 = v41.__r_.__value_.__l.__size_ != 3
           || *(_WORD *)v41.__r_.__value_.__l.__data_ != 28518
           || *(_BYTE *)(v41.__r_.__value_.__r.__words[0] + 2) != 114;
        operator delete(v41.__r_.__value_.__l.__data_);
      }
      else
      {
        v26 = SHIBYTE(v41.__r_.__value_.__r.__words[2]) != 3
           || LOWORD(v41.__r_.__value_.__l.__data_) != 28518
           || v41.__r_.__value_.__s.__data_[2] != 114;
      }
      if ((*((_BYTE *)&v42.__r_.__value_.__s + 23) & 0x80) == 0)
      {
LABEL_84:
        if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) == 0)
        {
LABEL_85:
          if (v26)
          {
LABEL_86:
            *((_DWORD *)this + 25) = 4;
            ShaderConverter::ParseDeclaration((ShaderConverter *)this);
            if (!a2)
              continue;
            goto LABEL_34;
          }
          goto LABEL_73;
        }
LABEL_72:
        operator delete(__p.__r_.__value_.__l.__data_);
        if (v26)
          goto LABEL_86;
LABEL_73:
        v28 = ShaderConverter::mpStatics + 72;
        Token::str((Token *)(this + 5), &__p);
        v29 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v28, (const void **)&__p.__r_.__value_.__l.__data_);
        v30 = ShaderConverter::mpStatics;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        v31 = v30 + 80;
        *((_DWORD *)this + 25) = 4;
        v32 = (Statement *)this[11];
        if (v31 != v29)
        {
          v17 = (Statement *)ShaderConverter::ParseMatrixCTOR((uint64_t **)this);
          v18 = v32;
LABEL_33:
          Statement::AddStatement(v18, v17);
          if (!a2)
            continue;
          goto LABEL_34;
        }
        v10 = (Statement *)this[11];
        goto LABEL_16;
      }
LABEL_83:
      operator delete(v42.__r_.__value_.__l.__data_);
      goto LABEL_84;
    }
    if (v8 != 16)
    {
      v10 = (Statement *)this[11];
LABEL_16:
      Statement::AddToken(v10, (const Token *)(this + 5));
      ShaderConverter::NextToken((ShaderConverter *)this);
      if (!a2)
        continue;
      goto LABEL_34;
    }
    ShaderConverter::ParseMacro((ShaderConverter *)this);
    if (!a2)
      continue;
LABEL_34:
    if (*((_DWORD *)this + 21))
    {
      *((_DWORD *)this + 8) = 1;
      if (*((_DWORD *)this + 20))
LABEL_91:
        *((_DWORD *)this + 8) = 2;
      v36 = this[11];
      if (v36)
        (*(void (**)(char *))(*(_QWORD *)v36 + 8))(v36);
      this[11] = 0;
      v38 = this[13];
      for (i = (uint64_t)this[14];
            (char *)i != v38;
            std::allocator<Variable>::destroy[abi:nn180100]((uint64_t)(this + 15), i))
      {
        i -= 96;
      }
      this[14] = v38;
      this[20] = this[19];
      v39 = this[9];
      if (v39)
      {
        std::__tree<char>::destroy((uint64_t)(v39 + 80), *((_QWORD **)v39 + 11));
        MEMORY[0x1DF0D41C0](v39, 0x1060C4014D1E9E2);
      }
      this[9] = 0;
      return 1;
    }
    if (*((_DWORD *)this + 20))
      goto LABEL_91;
  }
  while (v8);
  v34 = *((_DWORD *)this + 20);
  v33 = *((_DWORD *)this + 21);
  if (v33 <= v34)
  {
    if (v33 >= v34)
    {
      *((_DWORD *)this + 8) = 0;
      return 1;
    }
    v35 = 2;
  }
  else
  {
    v35 = 1;
  }
  *((_DWORD *)this + 8) = v35;
  return 1;
}

void sub_1DCCE4CFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0)
    operator delete(__p);
  if (a24 < 0)
    operator delete(a19);
  _Unwind_Resume(exception_object);
}

void ShaderConverter::NextToken(ShaderConverter *this)
{
  __int128 *Token;
  __int128 v3;
  std::string *v4;
  std::string *p_p;
  char v6;
  BOOL v7;
  int data_low;
  int v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  std::string __p;
  std::string v18;

  Token = (__int128 *)Tokenizer::NextToken(*((Tokenizer **)this + 9));
  v3 = *Token;
  *(_OWORD *)((char *)this + 52) = *(__int128 *)((char *)Token + 12);
  *(_OWORD *)((char *)this + 40) = v3;
  if (*((_DWORD *)this + 16) != 1)
    return;
  Token::str((ShaderConverter *)((char *)this + 40), &v18);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    if (v18.__r_.__value_.__l.__size_ != 2)
      goto LABEL_8;
    v4 = (std::string *)v18.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) != 2)
      goto LABEL_8;
    v4 = &v18;
  }
  if (LOWORD(v4->__r_.__value_.__l.__data_) == 28265)
  {
    v6 = 1;
    goto LABEL_21;
  }
LABEL_8:
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ != 3)
    {
      v7 = 0;
LABEL_25:
      operator delete(__p.__r_.__value_.__l.__data_);
      goto LABEL_26;
    }
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 3)
    {
      v7 = 0;
      goto LABEL_26;
    }
    p_p = &__p;
  }
  v6 = 0;
  v7 = 0;
  data_low = LOWORD(p_p->__r_.__value_.__l.__data_);
  v9 = p_p->__r_.__value_.__s.__data_[2];
  if (data_low == 30063 && v9 == 116)
  {
LABEL_21:
    v7 = Tokenizer::GetNextChar(*((Tokenizer **)this + 9)) == 46;
    if ((v6 & 1) != 0 || (*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) == 0)
      goto LABEL_26;
    goto LABEL_25;
  }
  if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
    goto LABEL_25;
LABEL_26:
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v18.__r_.__value_.__l.__data_);
    if (v7)
    {
LABEL_37:
      ++*((_DWORD *)this + 20);
      return;
    }
  }
  else if (v7)
  {
    goto LABEL_37;
  }
  v11 = ShaderConverter::mpStatics + 24;
  Token::str((ShaderConverter *)((char *)this + 40), &v18);
  v12 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v11, (const void **)&v18.__r_.__value_.__l.__data_);
  v13 = ShaderConverter::mpStatics + 32;
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
  if (v13 != v12)
    ++*((_DWORD *)this + 21);
  v14 = ShaderConverter::mpStatics;
  Token::str((ShaderConverter *)((char *)this + 40), &v18);
  v15 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v14, (const void **)&v18.__r_.__value_.__l.__data_);
  v16 = ShaderConverter::mpStatics + 8;
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
  if (v16 != v15)
    goto LABEL_37;
}

void sub_1DCCE4F4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  char v20;

  if ((v20 & 1) == 0 && a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

uint64_t Tokenizer::NextToken(Tokenizer *this)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  unint64_t v5;
  _QWORD *v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unsigned int v29;
  int v30;
  unsigned int v31;
  _QWORD *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t *v37;
  char **v38;
  char **v39;
  int v40;
  BOOL v41;
  char **v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;

  *((_DWORD *)this + 14) = 0;
  v3 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  if (v2 >= v3)
  {
    v8 = *((_QWORD *)this + 3);
    *((_QWORD *)this + 4) = *(_QWORD *)this;
    *((_QWORD *)this + 5) = v2;
    *((_QWORD *)this + 6) = v8 + ~v2;
    v9 = v8 - 1;
LABEL_113:
    *((_QWORD *)this + 2) = v9;
    return (uint64_t)this + 32;
  }
  v4 = *((char *)this + 65);
  if (v4 == 10)
  {
    v5 = *((_QWORD *)this + 3);
    *((_BYTE *)this + 64) = 10;
    if (v5 >= v3)
    {
      v7 = 0;
    }
    else
    {
      v6 = *(_QWORD **)this;
      if (*(char *)(*(_QWORD *)this + 23) < 0)
        v6 = (_QWORD *)*v6;
      v7 = *((unsigned __int8 *)v6 + v5);
    }
    *((_BYTE *)this + 65) = v7;
    *((_QWORD *)this + 3) = v5 + 1;
    ++*((_DWORD *)this + 18);
    if (v7 == 10)
      *(_QWORD *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
    *((_QWORD *)this + 4) = *(_QWORD *)this;
    *((_QWORD *)this + 5) = v2;
    *((_QWORD *)this + 6) = v5 - v2;
    *((_DWORD *)this + 14) = 17;
    *((_QWORD *)this + 2) = v5;
    return (uint64_t)this + 32;
  }
  if (v4 <= 32)
  {
    v10 = *((_QWORD *)this + 3);
    do
    {
      if ((char)v4 > 32 || v4 == 10)
        break;
      *((_BYTE *)this + 64) = v4;
      if (v10 >= v3)
      {
        v4 = 0;
      }
      else
      {
        v12 = *(_QWORD **)this;
        if (*(char *)(*(_QWORD *)this + 23) < 0)
          v12 = (_QWORD *)*v12;
        v4 = *((unsigned __int8 *)v12 + v10);
      }
      *((_BYTE *)this + 65) = v4;
      *((_QWORD *)this + 3) = ++v10;
      ++*((_DWORD *)this + 18);
      if (v4 == 10)
        *(_QWORD *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
    }
    while (v10 < v3);
    if (v2 + 1 < v10)
    {
      *((_QWORD *)this + 4) = *(_QWORD *)this;
      *((_QWORD *)this + 5) = v2;
      *((_QWORD *)this + 6) = v10 + ~v2;
      *((_DWORD *)this + 14) = 13;
      v9 = v10 - 1;
      goto LABEL_113;
    }
  }
  if (v4 <= 0x3Au)
  {
    switch((char)v4)
    {
      case '#':
        Tokenizer::NextChar(this);
        v14 = *((_QWORD *)this + 2);
        v13 = *((_QWORD *)this + 3);
        *((_QWORD *)this + 4) = *(_QWORD *)this;
        *((_QWORD *)this + 5) = v14;
        *((_QWORD *)this + 6) = v13 + ~v14;
        v15 = 16;
        goto LABEL_111;
      case '(':
        Tokenizer::NextChar(this);
        v18 = *((_QWORD *)this + 2);
        v13 = *((_QWORD *)this + 3);
        *((_QWORD *)this + 4) = *(_QWORD *)this;
        *((_QWORD *)this + 5) = v18;
        *((_QWORD *)this + 6) = v13 + ~v18;
        v15 = 6;
        goto LABEL_111;
      case ')':
        Tokenizer::NextChar(this);
        v19 = *((_QWORD *)this + 2);
        v13 = *((_QWORD *)this + 3);
        *((_QWORD *)this + 4) = *(_QWORD *)this;
        *((_QWORD *)this + 5) = v19;
        *((_QWORD *)this + 6) = v13 + ~v19;
        v15 = 7;
        goto LABEL_111;
      case ',':
        Tokenizer::NextChar(this);
        v20 = *((_QWORD *)this + 2);
        v13 = *((_QWORD *)this + 3);
        *((_QWORD *)this + 4) = *(_QWORD *)this;
        *((_QWORD *)this + 5) = v20;
        *((_QWORD *)this + 6) = v13 + ~v20;
        v15 = 14;
        goto LABEL_111;
      case '.':
        v21 = *(_QWORD **)this;
        if (*(char *)(*(_QWORD *)this + 23) < 0)
          v21 = (_QWORD *)*v21;
        v22 = *((char *)v21 + *((_QWORD *)this + 3));
        if ((v22 & 0x80000000) != 0)
          v23 = __maskrune(v22, 0x400uLL);
        else
          v23 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v22 + 60) & 0x400;
        if (v23)
          return Tokenizer::ParseNumber(this);
        goto LABEL_110;
      default:
        goto LABEL_49;
    }
  }
  if (v4 <= 0x5Cu)
  {
    if (v4 == 59)
    {
      Tokenizer::NextChar(this);
      v26 = *((_QWORD *)this + 2);
      v13 = *((_QWORD *)this + 3);
      *((_QWORD *)this + 4) = *(_QWORD *)this;
      *((_QWORD *)this + 5) = v26;
      *((_QWORD *)this + 6) = v13 + ~v26;
      v15 = 15;
      goto LABEL_111;
    }
    if (v4 == 91)
    {
      Tokenizer::NextChar(this);
      v17 = *((_QWORD *)this + 2);
      v13 = *((_QWORD *)this + 3);
      *((_QWORD *)this + 4) = *(_QWORD *)this;
      *((_QWORD *)this + 5) = v17;
      *((_QWORD *)this + 6) = v13 + ~v17;
      v15 = 10;
      goto LABEL_111;
    }
  }
  else
  {
    switch(v4)
    {
      case ']':
        Tokenizer::NextChar(this);
        v24 = *((_QWORD *)this + 2);
        v13 = *((_QWORD *)this + 3);
        *((_QWORD *)this + 4) = *(_QWORD *)this;
        *((_QWORD *)this + 5) = v24;
        *((_QWORD *)this + 6) = v13 + ~v24;
        v15 = 11;
        goto LABEL_111;
      case '{':
        Tokenizer::NextChar(this);
        v25 = *((_QWORD *)this + 2);
        v13 = *((_QWORD *)this + 3);
        *((_QWORD *)this + 4) = *(_QWORD *)this;
        *((_QWORD *)this + 5) = v25;
        *((_QWORD *)this + 6) = v13 + ~v25;
        v15 = 8;
        goto LABEL_111;
      case '}':
        Tokenizer::NextChar(this);
        v16 = *((_QWORD *)this + 2);
        v13 = *((_QWORD *)this + 3);
        *((_QWORD *)this + 4) = *(_QWORD *)this;
        *((_QWORD *)this + 5) = v16;
        *((_QWORD *)this + 6) = v13 + ~v16;
        v15 = 9;
LABEL_111:
        *((_DWORD *)this + 14) = v15;
        goto LABEL_112;
    }
  }
LABEL_49:
  if ((char)v4 < 0)
    v27 = __maskrune((char)v4, 0x100uLL);
  else
    v27 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v4 + 60) & 0x100;
  if (v27)
    return Tokenizer::ParseSymbol(this);
  v29 = *((char *)this + 65);
  if (v29 == 95)
    return Tokenizer::ParseSymbol(this);
  if ((v29 & 0x80000000) != 0)
    v30 = __maskrune(v29, 0x400uLL);
  else
    v30 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v29 + 60) & 0x400;
  if (v30)
    return Tokenizer::ParseNumber(this);
  v31 = *((unsigned __int8 *)this + 65);
  if (v31 <= 0x2E)
  {
    if (*((unsigned __int8 *)this + 65) <= 0x29u)
    {
      if (v31 - 37 >= 2)
      {
        if (v31 == 34)
        {
          Tokenizer::ParseString(this);
LABEL_109:
          v43 = *((_QWORD *)this + 2);
          v13 = *((_QWORD *)this + 3);
          *((_QWORD *)this + 4) = *(_QWORD *)this;
          *((_QWORD *)this + 5) = v43;
          *((_QWORD *)this + 6) = v13 + ~v43;
          *((_DWORD *)this + 14) = 0;
LABEL_112:
          v9 = v13 - 1;
          goto LABEL_113;
        }
        goto LABEL_99;
      }
      goto LABEL_82;
    }
    if (v31 - 42 >= 2 && v31 != 45)
    {
LABEL_99:
      v38 = (char **)*((_QWORD *)this + 11);
      if (!v38)
        goto LABEL_109;
      v39 = (char **)((char *)this + 88);
      do
      {
        v40 = *((char *)v38 + 25);
        v41 = v40 < (char)v31;
        if (v40 >= (char)v31)
          v42 = v38;
        else
          v42 = v38 + 1;
        if (!v41)
          v39 = v38;
        v38 = (char **)*v42;
      }
      while (*v42);
      if (v39 == (char **)((char *)this + 88) || (char)v31 < *((char *)v39 + 25))
        goto LABEL_109;
LABEL_110:
      Tokenizer::NextChar(this);
      v44 = *((_QWORD *)this + 2);
      v13 = *((_QWORD *)this + 3);
      *((_QWORD *)this + 4) = *(_QWORD *)this;
      *((_QWORD *)this + 5) = v44;
      *((_QWORD *)this + 6) = v13 + ~v44;
      v15 = 4;
      goto LABEL_111;
    }
LABEL_82:
    if (*((_QWORD *)this + 2) >= *((_QWORD *)this + 1))
      goto LABEL_110;
    v33 = *(uint64_t **)this;
    v34 = *((_QWORD *)this + 3);
    goto LABEL_84;
  }
  if (*((unsigned __int8 *)this + 65) > 0x3Du)
  {
    if (v31 != 62)
    {
      if (v31 != 94 && v31 != 124)
        goto LABEL_99;
      goto LABEL_82;
    }
LABEL_89:
    if (*((_QWORD *)this + 2) < *((_QWORD *)this + 1))
    {
      v36 = *(_QWORD **)this;
      if (*(char *)(*(_QWORD *)this + 23) < 0)
        v36 = (_QWORD *)*v36;
      if (*((_BYTE *)v36 + *((_QWORD *)this + 3)) == 61)
        Tokenizer::NextChar(this);
    }
    goto LABEL_110;
  }
  if (v31 != 47)
  {
    if (v31 != 60)
    {
      if (v31 == 61)
      {
        if (*((_QWORD *)this + 2) < *((_QWORD *)this + 1))
        {
          v32 = *(_QWORD **)this;
          if (*(char *)(*(_QWORD *)this + 23) < 0)
            v32 = (_QWORD *)*v32;
          if (*((_BYTE *)v32 + *((_QWORD *)this + 3)) == 61)
            goto LABEL_110;
        }
        goto LABEL_88;
      }
      goto LABEL_99;
    }
    goto LABEL_89;
  }
  if (*((_QWORD *)this + 2) >= *((_QWORD *)this + 1))
    goto LABEL_110;
  v33 = *(uint64_t **)this;
  v34 = *((_QWORD *)this + 3);
  v37 = *(uint64_t **)this;
  if (*(char *)(*(_QWORD *)this + 23) < 0)
    v37 = (uint64_t *)*v33;
  if (*((_BYTE *)v37 + v34) == 47)
    return Tokenizer::ParseLineComment(this);
  v45 = *(uint64_t **)this;
  if (*((char *)v33 + 23) < 0)
    v45 = (uint64_t *)*v33;
  if (*((_BYTE *)v45 + v34) != 42)
  {
LABEL_84:
    if (*((char *)v33 + 23) < 0)
      v33 = (uint64_t *)*v33;
    if (*((_BYTE *)v33 + v34) != 61)
      goto LABEL_110;
    Tokenizer::NextChar(this);
LABEL_88:
    Tokenizer::NextChar(this);
    v35 = *((_QWORD *)this + 2);
    v13 = *((_QWORD *)this + 3);
    *((_QWORD *)this + 4) = *(_QWORD *)this;
    *((_QWORD *)this + 5) = v35;
    *((_QWORD *)this + 6) = v13 + ~v35;
    v15 = 5;
    goto LABEL_111;
  }
  return Tokenizer::ParseMultiLineComment(this);
}

void Statement::AddToken(Statement *this, const Token *a2)
{
  Statement *v4;
  std::string __p;

  v4 = (Statement *)operator new();
  Token::str(a2, &__p);
  TokenStatement::TokenStatement((uint64_t)v4, (__int128 *)&__p, *((_DWORD *)a2 + 6));
  Statement::AddStatement(this, v4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1DCCE566C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  MEMORY[0x1DF0D41C0](v15, 0x1093C40A9CC4442);
  _Unwind_Resume(a1);
}

std::string *Token::str@<X0>(Token *this@<X0>, std::string *a2@<X8>)
{
  char v3;

  if (!*(_QWORD *)this)
    Token::str();
  return std::string::basic_string(a2, *(const std::string **)this, *((_QWORD *)this + 1), *((_QWORD *)this + 2), (std::allocator<char> *)&v3);
}

void Statement::AddStatement(Statement *this, Statement *a2)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  if (a2)
  {
    v6 = *((_QWORD *)this + 3);
    v4 = (char *)this + 24;
    v5 = v6;
    v7 = (_QWORD *)*((_QWORD *)v4 - 1);
    if ((unint64_t)v7 >= v6)
    {
      v9 = *((_QWORD *)this + 1);
      v10 = ((uint64_t)v7 - v9) >> 3;
      if ((unint64_t)(v10 + 1) >> 61)
        abort();
      v11 = v5 - v9;
      v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1))
        v12 = v10 + 1;
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
        v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)v4, v13);
      else
        v14 = 0;
      v15 = &v14[8 * v10];
      v16 = &v14[8 * v13];
      *(_QWORD *)v15 = a2;
      v8 = v15 + 8;
      v18 = (char *)*((_QWORD *)this + 1);
      v17 = (char *)*((_QWORD *)this + 2);
      if (v17 != v18)
      {
        do
        {
          v19 = *((_QWORD *)v17 - 1);
          v17 -= 8;
          *((_QWORD *)v15 - 1) = v19;
          v15 -= 8;
        }
        while (v17 != v18);
        v17 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v15;
      *((_QWORD *)this + 2) = v8;
      *((_QWORD *)this + 3) = v16;
      if (v17)
        operator delete(v17);
    }
    else
    {
      *v7 = a2;
      v8 = v7 + 1;
    }
    *((_QWORD *)this + 2) = v8;
  }
}

uint64_t TokenStatement::TokenStatement(uint64_t a1, __int128 *a2, int a3)
{
  std::string *v5;
  __int128 v6;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = off_1EA595A10;
  *(_QWORD *)(a1 + 8) = 0;
  v5 = (std::string *)(a1 + 32);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v6 = *a2;
    v5->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  *(_DWORD *)(a1 + 56) = a3;
  return a1;
}

void sub_1DCCE581C(_Unwind_Exception *a1)
{
  Statement *v1;

  Statement::~Statement(v1);
  _Unwind_Resume(a1);
}

uint64_t Tokenizer::ParseLineComment(Tokenizer *this)
{
  int v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t result;

  v1 = *((unsigned __int8 *)this + 65);
  while (v1 != 10)
  {
    v3 = *((_QWORD *)this + 1);
    v2 = *((_QWORD *)this + 2);
    v4 = *((_QWORD *)this + 3);
    if (v2 < v3)
    {
      *((_BYTE *)this + 64) = v1;
      if (v4 >= v3)
      {
        v1 = 0;
      }
      else
      {
        v5 = *(_QWORD **)this;
        if (*(char *)(*(_QWORD *)this + 23) < 0)
          v5 = (_QWORD *)*v5;
        v1 = *((unsigned __int8 *)v5 + v4);
      }
      *((_BYTE *)this + 65) = v1;
      *((_QWORD *)this + 3) = ++v4;
      ++*((_DWORD *)this + 18);
      if (v1 == 10)
        *(_QWORD *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
      if (v4 < v3)
        continue;
    }
    goto LABEL_14;
  }
  v2 = *((_QWORD *)this + 2);
  v4 = *((_QWORD *)this + 3);
LABEL_14:
  *((_QWORD *)this + 4) = *(_QWORD *)this;
  *((_QWORD *)this + 5) = v2;
  result = (uint64_t)this + 32;
  *(_QWORD *)(result + 16) = v4 + ~v2;
  *(_DWORD *)(result + 24) = 12;
  *(_QWORD *)(result - 16) = v4 - 1;
  return result;
}

uint64_t std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t *v8;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = a1 + 8;
  do
  {
    v7 = std::less<std::string>::operator()[abi:nn180100](v5, (const void **)(v3 + 32), a2);
    v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      v8 = (uint64_t *)v3;
      v6 = v3;
    }
    v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || std::less<std::string>::operator()[abi:nn180100](v5, a2, (const void **)(v6 + 32)))
    return v2;
  return v6;
}

uint64_t Tokenizer::Tokenizer(uint64_t a1, uint64_t a2)
{
  uint64_t **v3;
  uint64_t v4;
  char *v5;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  int v10;
  char v12[24];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 80) = a1 + 88;
  v3 = (uint64_t **)(a1 + 80);
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) != 0)
    v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 8) = v4;
  strcpy(v12, ".<>?:/|&^*/+-=%!~");
  v5 = v12;
  do
    std::__tree<char>::__emplace_unique_key_args<char,char const&>(v3, v5, v5);
  while (*++v5);
  v7 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)(a1 + 16) < v7)
  {
    v8 = *(_QWORD *)(a1 + 24);
    *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 65);
    if (v8 >= v7)
    {
      v10 = 0;
    }
    else
    {
      v9 = *(_QWORD **)a1;
      if (*(char *)(*(_QWORD *)a1 + 23) < 0)
        v9 = (_QWORD *)*v9;
      v10 = *((unsigned __int8 *)v9 + v8);
    }
    *(_BYTE *)(a1 + 65) = v10;
    *(_QWORD *)(a1 + 24) = v8 + 1;
    ++*(_DWORD *)(a1 + 72);
    if (v10 == 10)
      *(_QWORD *)(a1 + 68) = (*(_DWORD *)(a1 + 68) + 1);
  }
  return a1;
}

uint64_t **std::__tree<char>::__emplace_unique_key_args<char,char const&>(uint64_t **a1, char *a2, _BYTE *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  int v7;
  uint64_t **v8;
  int v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((char *)v5 + 25);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x20uLL);
    *((_BYTE *)v10 + 25) = *a3;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void ___ZN15ShaderConverter10StaticInitEv_block_invoke()
{
  _QWORD *v0;
  char *v1;
  uint64_t *v2;
  unint64_t v3;
  char *v4;
  uint64_t **v5;
  _OWORD *v6;
  uint64_t v7;
  uint64_t **v8;
  uint64_t **v9;
  _OWORD *v10;
  uint64_t i;
  uint64_t **v12;
  char *v13;
  _OWORD *v14;
  const __CFDictionary *StandardUniforms;
  CFIndex Count;
  const void **v17;
  const void **v18;
  id *v19;
  void ***v20;
  void *v21;
  uint64_t *v22;
  std::string v23;
  void *__p[2];
  char v25;
  void **v26;

  if (!ShaderConverter::mpStatics)
  {
    v0 = (_QWORD *)operator new();
    v0[1] = 0;
    *v0 = v0 + 1;
    v0[4] = 0;
    v0[2] = 0;
    v0[3] = v0 + 4;
    v0[7] = 0;
    v0[10] = 0;
    v0[5] = 0;
    v0[6] = v0 + 7;
    v0[8] = 0;
    v0[9] = v0 + 10;
    v0[13] = 0;
    v1 = "vec2";
    v0[11] = 0;
    v0[12] = v0 + 13;
    v2 = &qword_1EA59D628;
    v3 = -18;
    v0[14] = 0;
    ShaderConverter::mpStatics = (uint64_t)v0;
    do
    {
      v4 = (char *)*(v2 - 1);
      v5 = (uint64_t **)(ShaderConverter::mpStatics + 24);
      std::string::basic_string[abi:nn180100]<0>(__p, v1);
      v23.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
      v6 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v5, (const void **)__p, (uint64_t)&std::piecewise_construct, &v23);
      MEMORY[0x1DF0D40B8]((char *)v6 + 56, v4);
      if (v25 < 0)
        operator delete(__p[0]);
      if (v3 >= 0xFFFFFFFFFFFFFFF7)
      {
        v7 = *v2;
        v8 = (uint64_t **)(ShaderConverter::mpStatics + 72);
        std::string::basic_string[abi:nn180100]<0>(__p, v1);
        v23.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
        *((_QWORD *)std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v8, (const void **)__p, (uint64_t)&std::piecewise_construct, &v23)+ 7) = v7;
        if (v25 < 0)
          operator delete(__p[0]);
      }
      v9 = (uint64_t **)ShaderConverter::mpStatics;
      std::string::basic_string[abi:nn180100]<0>(__p, v4);
      v23.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
      v10 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v9, (const void **)__p, (uint64_t)&std::piecewise_construct, &v23);
      MEMORY[0x1DF0D40B8]((char *)v10 + 56, v1);
      if (v25 < 0)
        operator delete(__p[0]);
      v1 = (char *)v2[1];
      ++v3;
      v2 += 3;
    }
    while (v3 != 26);
    for (i = 0; i != 52; i += 2)
    {
      v12 = (uint64_t **)(ShaderConverter::mpStatics + 48);
      v13 = off_1EA59DA50[i + 1];
      std::string::basic_string[abi:nn180100]<0>(__p, off_1EA59DA50[i]);
      v23.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
      v14 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v12, (const void **)__p, (uint64_t)&std::piecewise_construct, &v23);
      MEMORY[0x1DF0D40B8]((char *)v14 + 56, v13);
      if (v25 < 0)
        operator delete(__p[0]);
    }
  }
  StandardUniforms = (const __CFDictionary *)C3DShaderGetStandardUniforms();
  Count = CFDictionaryGetCount(StandardUniforms);
  v17 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  v18 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  CFDictionaryGetKeysAndValues(StandardUniforms, v17, v18);
  if (Count >= 1)
  {
    v19 = (id *)v17;
    v20 = (void ***)v18;
    do
    {
      v21 = **v20;
      std::string::basic_string[abi:nn180100]<0>(__p, (char *)objc_msgSend(*v19, "UTF8String"));
      std::string::basic_string[abi:nn180100]<0>(&v23, (char *)objc_msgSend(v21, "UTF8String"));
      v26 = __p;
      v22 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)(ShaderConverter::mpStatics + 96), (const void **)__p, (uint64_t)&std::piecewise_construct, (__int128 **)&v26);
      std::string::operator=((std::string *)(v22 + 7), &v23);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v23.__r_.__value_.__l.__data_);
      if (v25 < 0)
        operator delete(__p[0]);
      ++v20;
      ++v19;
      --Count;
    }
    while (Count);
  }
  free(v17);
  free(v18);
}

void sub_1DCCE5EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_OWORD *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD v12[2];
  char v13;
  uint64_t v14;

  v6 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v14, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x50uLL);
    v12[1] = a1 + 1;
    v9 = *a4;
    v10 = *((_QWORD *)*a4 + 2);
    v7[2] = **a4;
    *((_QWORD *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    *v9 = 0;
    *((_QWORD *)v7 + 8) = 0;
    *((_QWORD *)v7 + 9) = 0;
    *((_QWORD *)v7 + 7) = 0;
    v13 = 1;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v12, 0);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!std::less<std::string>::operator()[abi:nn180100](v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::string>::operator()[abi:nn180100](v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)v10);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v10, 0);
  }
  return v7;
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  std::string *v7;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = operator new(0x50uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 4);
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    v6[6] = *((_QWORD *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  v6[9] = 0;
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_1DCCE61C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

_OWORD *std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v12;

  v6 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v12, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x40uLL);
    v9 = *a4;
    v10 = *((_QWORD *)*a4 + 2);
    v7[2] = **a4;
    *((_QWORD *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    *v9 = 0;
    *((_QWORD *)v7 + 7) = 0;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v12, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t Tokenizer::ParseSymbol(Tokenizer *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t i;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  uint64_t result;

  v3 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  for (i = *((_QWORD *)this + 3); ; i = *((_QWORD *)this + 3))
  {
    if (v2 >= v3)
    {
      v7 = i + ~v2;
      *((_QWORD *)this + 4) = *(_QWORD *)this;
      result = (uint64_t)this + 32;
      goto LABEL_17;
    }
    *((_BYTE *)this + 64) = *((_BYTE *)this + 65);
    if (i >= v3)
    {
      v6 = 0;
    }
    else
    {
      v5 = *(_QWORD **)this;
      if (*(char *)(*(_QWORD *)this + 23) < 0)
        v5 = (_QWORD *)*v5;
      v6 = *((unsigned __int8 *)v5 + i);
    }
    *((_BYTE *)this + 65) = v6;
    *((_QWORD *)this + 3) = i + 1;
    ++*((_DWORD *)this + 18);
    if (v6 == 10)
      *(_QWORD *)((char *)this + 68) = (*((_DWORD *)this + 17) + 1);
    if ((v6 & 0x80) != 0)
    {
      if (__maskrune((char)v6, 0x500uLL))
      {
LABEL_12:
        v2 = *((_QWORD *)this + 2);
        goto LABEL_15;
      }
    }
    else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v6 + 60) & 0x500) != 0)
    {
      goto LABEL_12;
    }
    v2 = *((_QWORD *)this + 2);
    if (*((_BYTE *)this + 65) != 95)
      break;
LABEL_15:
    v3 = *((_QWORD *)this + 1);
  }
  *((_QWORD *)this + 4) = *(_QWORD *)this;
  result = (uint64_t)this + 32;
  i = *((_QWORD *)this + 3);
  v7 = i + ~v2;
LABEL_17:
  *((_QWORD *)this + 5) = v2;
  *((_QWORD *)this + 6) = v7;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 2) = i - 1;
  return result;
}

void Statement::~Statement(Statement *this)
{
  Statement::~Statement(this);
  JUMPOUT(0x1DF0D41C0);
}

{
  _QWORD *v2;
  _QWORD *v3;

  *(_QWORD *)this = &off_1EA598440;
  v2 = (_QWORD *)*((_QWORD *)this + 1);
  v3 = (_QWORD *)*((_QWORD *)this + 2);
  if (v2 != v3)
  {
    do
    {
      if (*v2)
        (*(void (**)(_QWORD))(*(_QWORD *)*v2 + 8))(*v2);
      ++v2;
    }
    while (v2 != v3);
    v2 = (_QWORD *)*((_QWORD *)this + 1);
  }
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
}

void TokenStatement::~TokenStatement(void **this)
{
  *this = off_1EA595A10;
  if (*((char *)this + 55) < 0)
    operator delete(this[4]);
  Statement::~Statement((Statement *)this);
  JUMPOUT(0x1DF0D41C0);
}

{
  *this = off_1EA595A10;
  if (*((char *)this + 55) < 0)
    operator delete(this[4]);
  Statement::~Statement((Statement *)this);
}

void ShaderConverter::~ShaderConverter(ShaderConverter *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void **v5;

  *(_QWORD *)this = &off_1EA595E28;
  v2 = *((_QWORD *)this + 11);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 9);
  if (v3)
  {
    std::__tree<char>::destroy(v3 + 80, *(_QWORD **)(v3 + 88));
    MEMORY[0x1DF0D41C0](v3, 0x1060C4014D1E9E2);
  }
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)this + 200, *((_QWORD **)this + 26));
  std::__tree<std::string>::destroy((uint64_t)this + 176, *((char **)this + 23));
  v4 = (void *)*((_QWORD *)this + 19);
  if (v4)
  {
    *((_QWORD *)this + 20) = v4;
    operator delete(v4);
  }
  v5 = (void **)((char *)this + 128);
  std::vector<Variable>::__destroy_vector::operator()[abi:nn180100](&v5);
  v5 = (void **)((char *)this + 104);
  std::vector<Variable>::__destroy_vector::operator()[abi:nn180100](&v5);
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  ShaderConverter::~ShaderConverter(this);
  JUMPOUT(0x1DF0D41C0);
}

void std::__tree<std::string>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::string>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::string>::destroy(a1, *((_QWORD *)a2 + 1));
    if (a2[55] < 0)
      operator delete(*((void **)a2 + 4));
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

BOOL SCNMatrix4IsIdentity(SCNMatrix4 *m)
{
  __int128 v1;
  __int128 v2;
  _OWORD v4[4];

  v1 = *(_OWORD *)&m->m21;
  v4[0] = *(_OWORD *)&m->m11;
  v4[1] = v1;
  v2 = *(_OWORD *)&m->m41;
  v4[2] = *(_OWORD *)&m->m31;
  v4[3] = v2;
  return memcmp(v4, &SCNMatrix4Identity, 0x40uLL) == 0;
}

void C3DImageCacheImageWithSource(const void *a1, void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t SharedInstance;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DImageGetURL_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DKeyframedAnimationCopy_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  SharedInstance = C3DResourceCacheGetSharedInstance();
  C3DResourceCacheAddResource(SharedInstance, a2, a1);
}

uint64_t C3DImageGetTypeID()
{
  if (C3DImageGetTypeID_onceToken != -1)
    dispatch_once(&C3DImageGetTypeID_onceToken, &__block_literal_global_28);
  return C3DImageGetTypeID_typeID;
}

const void *C3DImageCopyCachedImageForSource(void *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t SharedInstance;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DKeyframedAnimationCopy_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  SharedInstance = C3DResourceCacheGetSharedInstance();
  return C3DResourceCacheCopyResourceForSource(SharedInstance, a1);
}

uint64_t C3DResourceCacheGetSharedInstance()
{
  if (C3DResourceCacheGetSharedInstance_onceToken != -1)
    dispatch_once(&C3DResourceCacheGetSharedInstance_onceToken, &__block_literal_global_3_3);
  return _sharedInstance;
}

const void *C3DResourceCacheCopyResourceForSource(uint64_t a1, void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const void *v21;
  CFTypeID v22;
  CFTypeID v23;
  _BOOL4 v24;
  double v25;
  uint64_t v26;
  void *v27;
  const __CFNumber *Value;
  double v29;
  double valuePtr;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DResourceCacheCopyResourceForSource_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DKeyframedAnimationCopy_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  v20 = (void *)_C3DResourceCacheStandardizeSource(a2);
  v21 = (const void *)objc_msgSend((id)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v20), "copyWeakRef");
  if (v21)
  {
    v22 = CFGetTypeID(v20);
    if (v22 == CFURLGetTypeID() || (v23 = CFGetTypeID(v20), v23 == CFStringGetTypeID()))
    {
      v24 = SCNHasSpecialResourceBundle();
      v25 = SCNGetFileTimestampAtURL(v20);
      if (v25 == 0.0 && SCNHasSpecialResourceBundle())
      {
        objc_opt_class();
        v26 = (uint64_t)v20;
        if ((objc_opt_isKindOfClass() & 1) != 0)
          v26 = objc_msgSend(v20, "path");
        v27 = (void *)objc_msgSend((id)objc_msgSend((id)SCNGetResourceBundle(), "bundlePath"), "stringByAppendingPathComponent:", v26);
        v25 = SCNGetFileTimestampAtURL(v27);
      }
      if (v25 == 0.0)
      {
        if (!v24)
          goto LABEL_22;
        goto LABEL_21;
      }
      valuePtr = 0.0;
      Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v20);
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
        v29 = valuePtr;
      }
      else
      {
        v29 = 0.0;
      }
      if (v29 != v25)
      {
LABEL_21:
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), v20);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), v21);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v20);
        CFRelease(v21);
        v21 = 0;
      }
    }
  }
LABEL_22:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
  return v21;
}

uint64_t _C3DResourceCacheStandardizeSource(void *a1)
{
  CFTypeID v2;
  uint64_t v3;

  v2 = CFGetTypeID(a1);
  v3 = (uint64_t)a1;
  if (v2 == CFURLGetTypeID())
  {
    v3 = (uint64_t)a1;
    if (objc_msgSend(a1, "isFileURL"))
    {
      v3 = (uint64_t)a1;
      if (!objc_msgSend(a1, "query"))
        v3 = objc_msgSend(a1, "relativePath");
    }
  }
  if (v2 == CFStringGetTypeID())
    return objc_msgSend(a1, "stringByStandardizingPath");
  else
    return v3;
}

uint64_t C3DEffectSlotGetDefaultTextureOptions(int a1, int a2)
{
  int v2;
  int v3;
  int v4;

  if (a1 == 4)
    v2 = 2;
  else
    v2 = 0;
  if (a1 == 26)
    v3 = 8;
  else
    v3 = v2;
  if ((a1 - 24) >= 2)
    v4 = v3;
  else
    v4 = 6;
  return v4 | a2 ^ 1u;
}

void C3DResourceCacheAddResource(uint64_t a1, void *cf, const void *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  CFTypeID v30;
  CFTypeID v31;
  double v32;
  void *v33;
  CFTypeID v34;
  void *Value;
  uint64_t v36;
  const void *v37;
  const __CFDictionary *v38;
  SCNWeakPointer *v39;
  CFNumberRef v40;
  _QWORD v41[6];
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  double valuePtr;

  if (!a1 && (v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DResourceCacheCopyResourceForSource_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
    if (cf)
      goto LABEL_6;
  }
  else if (cf)
  {
    goto LABEL_6;
  }
  v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    C3DKeyframedAnimationCopy_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
LABEL_6:
  if (!a3)
  {
    v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      C3DResourceCacheGetSourceForResource_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
  }
  valuePtr = 0.0;
  v30 = CFGetTypeID(cf);
  if (v30 == CFURLGetTypeID() || (v31 = CFGetTypeID(cf), v32 = 0.0, v31 == CFStringGetTypeID()))
  {
    v32 = SCNGetFileTimestampAtURL(cf);
    valuePtr = v32;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  v33 = (void *)_C3DResourceCacheStandardizeSource(cf);
  v34 = CFGetTypeID(v33);
  if (v34 == CFStringGetTypeID())
    v33 = (void *)objc_msgSend(v33, "copy");
  else
    CFRetain(v33);
  Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v33);
  if (Value)
  {
    v36 = objc_msgSend(Value, "copyWeakRef");
    if (v36)
    {
      v37 = (const void *)v36;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), v33);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), v37);
      CFRelease(v37);
    }
    else
    {
      v42 = 0;
      v43 = &v42;
      v44 = 0x2020000000;
      v45 = 0;
      v38 = *(const __CFDictionary **)(a1 + 24);
      v41[0] = MEMORY[0x1E0C809B0];
      v41[1] = 3221225472;
      v41[2] = __C3DResourceCacheAddResource_block_invoke;
      v41[3] = &unk_1EA5A30D8;
      v41[4] = &v42;
      v41[5] = v33;
      C3DCFDictionaryApplyBlock(v38, (uint64_t)v41);
      if (v43[3])
      {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), v33);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), (const void *)v43[3]);
      }
      _Block_object_dispose(&v42, 8);
    }
  }
  v39 = objc_alloc_init(SCNWeakPointer);
  -[SCNWeakPointer setWeakRef:](v39, "setWeakRef:", a3);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v33, v39);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a3, v33);

  CFRelease(v33);
  if (v32 != 0.0)
  {
    v40 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v33, v40);
    CFRelease(v40);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
}

void sub_1DCCE77C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t C3DImageCreateWithMDLTexture(void *a1)
{
  uint64_t v2;
  NSObject *v3;
  uint8_t v5[16];

  v2 = C3DImageCreateWithCGImage((CGImage *)objc_msgSend(a1, "imageFromTexture"));
  if (objc_msgSend(a1, "isCube"))
  {
    C3DImageChangeImageTypeToCubeMapIfSuitable(v2);
    if (!C3DImageIsCubeMap(v2))
    {
      v3 = scn_default_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v5 = 0;
        _os_log_impl(&dword_1DCCB8000, v3, OS_LOG_TYPE_DEFAULT, "Warning: Failed to create cubemap from Model I/O texture", v5, 2u);
      }
    }
  }
  return v2;
}

uint64_t C3DImageCreateWithCGImage(CGImage *a1)
{
  uint64_t v2;

  v2 = C3DImageCreate();
  if (v2)
  {
    *(_QWORD *)(v2 + 88) = CGImageRetain(a1);
    *(_DWORD *)(v2 + 96) = 3;
  }
  return v2;
}

uint64_t C3DImageCreate()
{
  uint64_t result;

  if (C3DImageGetTypeID_onceToken != -1)
    dispatch_once(&C3DImageGetTypeID_onceToken, &__block_literal_global_28);
  result = C3DTypeCreateInstance_(C3DImageGetTypeID_typeID, 0x70uLL);
  *(_BYTE *)(result + 116) &= 0xFCu;
  *(_DWORD *)(result + 120) = 1;
  return result;
}

uint64_t C3DMaterialCreateCopy(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryCopy_cold_4(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = C3DMaterialCreate();
  C3DMaterialCopy(a1, v10);
  return v10;
}

uint64_t C3DMaterialCopy(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFString *Name;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DGeometryCopy_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  *(_BYTE *)(a2 + 100) = *(_BYTE *)(a1 + 100);
  *(_DWORD *)(a2 + 88) = *(_DWORD *)(a1 + 88);
  *(_BYTE *)(a2 + 93) = *(_BYTE *)(a1 + 93);
  v20 = *(_QWORD *)(a1 + 64);
  v21 = *(_QWORD *)(a2 + 64);
  if (v20)
  {
    C3DEffectCommonProfileCopy(v20, v21);
  }
  else if (v21)
  {
    CFRelease(*(CFTypeRef *)(a2 + 64));
    *(_QWORD *)(a2 + 64) = 0;
  }
  C3DEntityCopyTo(a1, (CFTypeRef *)a2);
  Name = (const __CFString *)C3DMaterialGetName(a1);
  C3DMaterialSetName(a2, Name);
  return __RasterizerStatesDidChange(a2);
}

CFStringRef C3DMaterialSetName(uint64_t a1, CFStringRef theString)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return C3DEntitySetName(a1, theString);
}

uint64_t C3DMaterialGetName(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return C3DEntityGetName(a1);
}

uint64_t C3DEngineContextSetMainClearColor(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 224) = a2;
  *(_QWORD *)(result + 232) = a3;
  return result;
}

void C3DEffectCommonProfileCopy(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int LightingModel;
  uint64_t i;
  int v22;
  float FloatProperty;
  unsigned __int8 v24;
  uint64_t EffectSlot;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DGeometryCopy_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  LightingModel = C3DEffectCommonProfileGetLightingModel(a1);
  C3DEffectCommonProfileSetLightingModel(a2, LightingModel);
  for (i = 0; i != 5; ++i)
  {
    v22 = byte_1DD02A0B6[i];
    FloatProperty = C3DEffectCommonProfileGetFloatProperty((float *)a1, v22);
    C3DEffectCommonProfileSetFloatProperty(a2, v22, FloatProperty);
  }
  v24 = 0;
  do
  {
    EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, (char)v24, 0);
    if (EffectSlot)
    {
      v26 = EffectSlot;
      v27 = C3DEffectCommonProfileGetEffectSlot(a2, (char)v24, 1);
      C3DEffectSlotCopy(v26, v27);
    }
    v28 = v24++;
  }
  while (v28 < 0x10);
  *(_WORD *)(a2 + 194) = *(_WORD *)(a2 + 194) & 0xFFFE | *(_WORD *)(a1 + 194) & 1;
  *(_BYTE *)(a2 + 193) = *(_BYTE *)(a1 + 193);
  C3DEffectCommonProfileSetTransparencyMode(a2, *(unsigned __int8 *)(a1 + 180));
  *(_WORD *)(a2 + 194) = *(_WORD *)(a2 + 194) & 0xFFEF | *(_WORD *)(a1 + 194) & 0x10;
}

void C3DEffectSlotCopy(uint64_t a1, uint64_t a2)
{
  const void *Image;
  const void *ImageProxy;
  _OWORD *v6;
  _OWORD *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  const void *Texture;
  const void *MTLTexture;
  uint64_t UVSet;
  int TextureComponents;
  float Intensity;

  C3DEffectSlotSetColor(a2, (float *)(a1 + 16));
  Image = (const void *)C3DEffectSlotGetImage(a1);
  C3DEffectSlotSetImage(a2, Image);
  ImageProxy = (const void *)C3DEffectSlotGetImageProxy(a1);
  C3DEffectSlotSetImageProxy(a2, ImageProxy);
  C3DEffectSlotSetTextureSampler(a2, *(CFTypeRef *)(a1 + 56));
  if (*(_QWORD *)(a1 + 64))
  {
    v6 = C3DMalloc(0x40uLL);
    *(_QWORD *)(a2 + 64) = v6;
    v7 = *(_OWORD **)(a1 + 64);
    v9 = v7[2];
    v8 = v7[3];
    v10 = v7[1];
    *v6 = *v7;
    v6[1] = v10;
    v6[2] = v9;
    v6[3] = v8;
  }
  Texture = (const void *)C3DEffectSlotGetTexture(a1);
  C3DEffectSlotSetTexture(a2, Texture);
  MTLTexture = (const void *)C3DEffectSlotGetMTLTexture(a1);
  C3DEffectSlotSetMTLTexture(a2, MTLTexture);
  UVSet = C3DEffectSlotGetUVSet(a1);
  C3DEffectSlotSetUVSet(a2, UVSet);
  TextureComponents = C3DEffectSlotGetTextureComponents(a1);
  C3DEffectSlotSetTextureComponents(a2, TextureComponents);
  Intensity = C3DEffectSlotGetIntensity(a1);
  C3DEffectSlotSetIntensity(a2, Intensity);
  *(_WORD *)(a2 + 48) = *(_WORD *)(a2 + 48) & 0xFDFF | *(_WORD *)(a1 + 48) & 0x200;
}

void C3DEffectSlotSetTexture(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef v12;
  CFTypeRef v13;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (cf || *(_WORD *)(a1 + 48) == 1)
  {
    *(_WORD *)(a1 + 48) = *(_WORD *)(a1 + 48) & 0xFF00 | 1;
    v12 = *(CFTypeRef *)(a1 + 40);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(_QWORD *)(a1 + 40) = 0;
      }
      if (cf)
        v13 = CFRetain(cf);
      else
        v13 = 0;
      *(_QWORD *)(a1 + 40) = v13;
      __PostParentDidChangeNotification(a1, 1, 1);
    }
  }
}

void C3DEffectSlotSetImageProxy(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef v12;
  CFTypeRef v13;
  uint64_t CommonProfile;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (cf || *(_WORD *)(a1 + 48) == 2)
  {
    *(_WORD *)(a1 + 48) = *(_WORD *)(a1 + 48) & 0xFF00 | 2;
    v12 = *(CFTypeRef *)(a1 + 40);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(_QWORD *)(a1 + 40) = 0;
      }
      if (cf)
        v13 = CFRetain(cf);
      else
        v13 = 0;
      *(_QWORD *)(a1 + 40) = v13;
      CommonProfile = _C3DEffectSlotGetCommonProfile(a1);
      if (CommonProfile)
        *(_WORD *)(CommonProfile + 196) &= 0xE000u;
      __PostParentDidChangeNotification(a1, 1, 1);
    }
  }
}

void C3DEffectSlotSetImage(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef v12;
  CFTypeRef v13;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (cf || !*(_WORD *)(a1 + 48))
  {
    *(_WORD *)(a1 + 48) &= 0xFF00u;
    v12 = *(CFTypeRef *)(a1 + 40);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(_QWORD *)(a1 + 40) = 0;
      }
      if (cf)
        v13 = CFRetain(cf);
      else
        v13 = 0;
      *(_QWORD *)(a1 + 40) = v13;
      __PostParentDidChangeNotification(a1, 1, 1);
    }
  }
}

uint64_t C3DEffectSlotGetEffectProperty(uint64_t a1)
{
  return *(char *)(a1 + 50);
}

unint64_t C3DColor4WithCGColor(CGColor *a1, char a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  CGColorSpace *v8;
  CGColor *v9;
  CGColor *v10;
  size_t NumberOfComponents;
  const CGFloat *Components;
  float v13;
  unsigned __int32 v14;
  double v15;
  float v17;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      _C3DCGColorGetComponentsInColorSpace_cold_1(v4, v5, v6);
  }
  if (!C3DLinearRenderingIsEnabled() || (a2 & 1) != 0)
    goto LABEL_20;
  if (C3DWideGamutIsUsed())
  {
    if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1)
      dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_11);
    v7 = &C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB;
  }
  else
  {
    if (C3DColorSpaceLinearSRGB_onceToken != -1)
      dispatch_once(&C3DColorSpaceLinearSRGB_onceToken, &__block_literal_global_3);
    v7 = &C3DColorSpaceLinearSRGB_kC3DColorSpaceLinearSRGB;
  }
  v8 = (CGColorSpace *)*v7;
  if (C3DWideGamutIsUsed())
  {
    if (C3DGetColorTransformToExtendedLinearSRGB_onceToken != -1)
      dispatch_once(&C3DGetColorTransformToExtendedLinearSRGB_onceToken, &__block_literal_global_28);
  }
  else if (C3DGetColorTransformToLinearSRGB_onceToken != -1)
  {
    dispatch_once(&C3DGetColorTransformToLinearSRGB_onceToken, &__block_literal_global_30);
  }
  if (CGColorGetColorSpace(a1) == v8)
LABEL_20:
    v9 = CGColorRetain(a1);
  else
    v9 = (CGColor *)CGColorTransformConvertColor();
  v10 = v9;
  NumberOfComponents = CGColorGetNumberOfComponents(v9);
  Components = CGColorGetComponents(v10);
  if (NumberOfComponents >= 4)
    goto LABEL_24;
  if (NumberOfComponents == 2)
  {
LABEL_26:
    v15 = *Components;
    *(float *)&v15 = *Components;
    v17 = *(float *)&v15;
    v14 = vdup_lane_s32(*(int32x2_t *)&v15, 0).u32[0];
    goto LABEL_27;
  }
  if (NumberOfComponents < 3)
  {
    if (!NumberOfComponents)
    {
      v14 = 0;
      v17 = 0.0;
      goto LABEL_27;
    }
    goto LABEL_26;
  }
LABEL_24:
  v13 = *Components;
  v17 = v13;
  v14 = vcvt_f32_f64(*(float64x2_t *)(Components + 1)).u32[0];
LABEL_27:
  CGColorRelease(v10);
  return LODWORD(v17) | ((unint64_t)v14 << 32);
}

uint64_t C3DColor4FromRGBCFColor(const void *a1, uint64_t a2)
{
  return objc_msgSend((id)scn_NSColorFromCGColorIfApplicable(a1), "scn_C3DColorIgnoringColorSpace:success:", a2, 0);
}

uint64_t C3DEffectPropertyGetSemanticForColorIsRawFloatValue(unsigned int a1)
{
  return (a1 < 0x10) & (0x8DA0u >> a1);
}

void C3DEffectSlotSetMTLTexture(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef v12;
  CFTypeRef v13;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (cf || *(_WORD *)(a1 + 48) == 3)
  {
    *(_WORD *)(a1 + 48) = *(_WORD *)(a1 + 48) & 0xFE00 | 3;
    v12 = *(CFTypeRef *)(a1 + 40);
    if (v12 != cf)
    {
      if (v12)
      {
        CFRelease(v12);
        *(_QWORD *)(a1 + 40) = 0;
      }
      if (cf)
        v13 = CFRetain(cf);
      else
        v13 = 0;
      *(_QWORD *)(a1 + 40) = v13;
    }
    __PostParentDidChangeNotification(a1, 1, 1);
  }
}

void C3DEffectSlotSetIntensity(uint64_t a1, float a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (*(float *)(a1 + 72) != a2)
  {
    *(float *)(a1 + 72) = a2;
    __PostParentDidChangeNotification(a1, 0, 0);
  }
}

void C3DEffectSlotSetUVSet(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (*(_DWORD *)(a1 + 76) != a2)
  {
    *(_DWORD *)(a1 + 76) = a2;
    __PostParentDidChangeNotification(a1, 0, 0);
  }
}

float C3DEffectSlotGetIntensity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 72);
}

uint64_t C3DEffectSlotGetUVSet(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(_DWORD *)(a1 + 76);
  if (v10 == -2)
  {
    if (*(_BYTE *)(a1 + 50) == 4)
      return -1;
    else
      return 0;
  }
  return v10;
}

uint64_t C3DEffectSlotGetTextureComponents(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(unsigned __int16 *)(a1 + 48) >> 11) & 0xF;
}

void C3DEffectCommonProfileSetTransparencyMode(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (*(unsigned __int8 *)(a1 + 180) != a2)
  {
    *(_WORD *)(a1 + 194) &= ~0x80u;
    *(_BYTE *)(a1 + 180) = a2;
    __PostCommonProfileDidChangeNotification(a1);
  }
}

void C3DAnimationManagerExecRemoveAnimation(uint64_t a1, void *key, void *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if (!a1 && (v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key)
      goto LABEL_6;
  }
  else if (key)
  {
    goto LABEL_6;
  }
  v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
LABEL_6:
  _C3DAnimationManagerRemoveAnimationForKey(a1, key, a3);
}

void _C3DAnimationManagerRemoveAnimationForKey(uint64_t a1, void *key, void *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const __CFDictionary *AnimationPerKeyDictionaryForObject;
  const __CFDictionary *v31;
  const void *Value;
  const void *v33;

  if (!a1 && (v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key)
      goto LABEL_6;
  }
  else if (key)
  {
    goto LABEL_6;
  }
  v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
LABEL_6:
  if (!a3)
  {
    v22 = scn_default_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      C3DAnimationManagerAddAnimationPlayerForKey_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
  }
  AnimationPerKeyDictionaryForObject = (const __CFDictionary *)_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(a1, key, 0);
  if (AnimationPerKeyDictionaryForObject)
  {
    v31 = AnimationPerKeyDictionaryForObject;
    CFRetain(AnimationPerKeyDictionaryForObject);
    Value = CFDictionaryGetValue(v31, a3);
    if (Value)
    {
      v33 = Value;
      CFRetain(Value);
      C3DAnimationNodeSetOwner((uint64_t)v33, 0);
      _C3DAnimationManagerRemoveAnimationsForKey(a1, key, a3, v31);
      CFRelease(v33);
    }
    CFRelease(v31);
  }
}

const void *_C3DAnimationManagerGetAnimationPerKeyDictionaryForObject(uint64_t a1, void *key, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const void *Value;
  BOOL v23;

  if (!a1 && (v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (key)
      goto LABEL_6;
  }
  else if (key)
  {
    goto LABEL_6;
  }
  v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
LABEL_6:
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), key);
  if (Value)
    v23 = 1;
  else
    v23 = a3 == 0;
  if (!v23)
  {
    Value = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 48), key, Value);
    CFRelease(Value);
  }
  return Value;
}

void _commitImplicitTransaction(uint64_t a1)
{
  uint64_t v2;
  uint64_t Stack;
  uint64_t v4;
  int v5;
  uint64_t v6;

  os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
  Stack = C3DTransactionGetStack(v2);
  if (Stack && (v4 = Stack, *(_QWORD *)(Stack + 24) == a1))
  {
    v5 = pthread_main_np();
    v6 = *(_QWORD *)(v4 + 32);
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    if (v5 != 1 || v6)
    {
      C3DTransactionFlush();
    }
    else
    {
      if (_commitImplicitTransaction_onceToken != -1)
        dispatch_once(&_commitImplicitTransaction_onceToken, &__block_literal_global_14);
      dispatch_async((dispatch_queue_t)_commitImplicitTransaction_queue, &__block_literal_global_17_0);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
  }
}

uint64_t _C3DCFArrayApplyBlock(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = a2[1];
  ++*a2;
  return (*(uint64_t (**)(void))(v2 + 16))();
}

uint64_t SCNMTLRenderCommandEncoder::setVertexBuffers(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *i;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;

  if (a5)
  {
    v9 = result;
    v10 = 0;
    v11 = 0;
    for (i = (_QWORD *)(result + 16 * a4 + 88); ; i += 2)
    {
      v13 = a4 + v11;
      v14 = *(_QWORD *)(a2 + 8 * v11);
      if (*(i - 1) != v14)
        break;
      v15 = *(_QWORD *)(a3 + 8 * v11);
      if (*i != v15)
      {
        *i = v15;
        result = objc_msgSend(*(id *)(v9 + 3392), "setVertexBufferOffset:atIndex:", *(_QWORD *)(a3 + 8 * v11), a4 + v11);
      }
      ++v11;
      v10 -= 8;
      if (a5 == v11)
        return result;
    }
    v16 = a5 - v11;
    if (a5 != v11)
    {
      if (a5 - 1 == v11)
      {
        *(i - 1) = v14;
        *i = *(_QWORD *)(a3 + 8 * v11);
        return objc_msgSend(*(id *)(v9 + 3392), "setVertexBuffer:offset:atIndex:", *(_QWORD *)(a2 + 8 * v11), *(_QWORD *)(a3 + 8 * v11), v13);
      }
      else
      {
        v17 = (uint64_t *)(a2 - v10);
        v18 = (uint64_t *)(a3 - v10);
        result = objc_msgSend(*(id *)(v9 + 3392), "setVertexBuffers:offsets:withRange:", v17, v18, v13, a5 - v11);
        if (a5 > v11)
        {
          do
          {
            v19 = *v17++;
            *(i - 1) = v19;
            v20 = *v18++;
            *i = v20;
            i += 2;
            --v16;
          }
          while (v16);
        }
      }
    }
  }
  return result;
}

void sub_1DCCEBF0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  _Block_object_dispose(&a61, 8);
  _Unwind_Resume(a1);
}

float C3DEffectCommonProfileGetIntensity(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t EffectSlot;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineGetRenderComponentsForRenderPass_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (EffectSlot)
    return *(float *)(EffectSlot + 72);
  else
    return 1.0;
}

uint64_t C3DEffectCommonProfileGetColorModulatedByIntensity(uint64_t a1, int a2)
{
  uint64_t EffectSlot;
  float Intensity;
  int32x2_t v6;
  float v7;
  float32x4_t v9;

  v9 = *(float32x4_t *)C3DEffectCommonProfileGetColor(a1, a2);
  EffectSlot = C3DEffectCommonProfileGetEffectSlot(a1, a2, 0);
  if (EffectSlot && C3DEffectSlotHasImageOrTexture(EffectSlot))
    C3DColor4Make(v9.f32, 1.0, 1.0, 1.0, 1.0);
  Intensity = C3DEffectCommonProfileGetIntensity(a1, a2);
  if (Intensity != 1.0)
  {
    if (a2 == 6)
    {
      *(float *)v6.i32 = 1.0 - Intensity;
      *(float32x2_t *)v9.f32 = vmla_n_f32((float32x2_t)vdup_lane_s32(v6, 0), *(float32x2_t *)v9.f32, Intensity);
      v7 = (float)(1.0 - Intensity) + (float)(Intensity * v9.f32[2]);
    }
    else
    {
      if (a2 == 5)
      {
        v9 = vmulq_n_f32(v9, Intensity);
        return v9.i64[0];
      }
      *(float32x2_t *)v9.f32 = vmul_n_f32(*(float32x2_t *)v9.f32, Intensity);
      v7 = Intensity * v9.f32[2];
    }
    v9.f32[2] = v7;
  }
  return v9.i64[0];
}

float C3DEffectCommonProfileGetColorLuminanceModulatedByIntensity(uint64_t a1, int a2)
{
  float result;

  LODWORD(result) = C3DEffectCommonProfileGetColorModulatedByIntensity(a1, a2);
  return result;
}

uint64_t C3DEffectCommonProfileIsUsingAmbientOcclusion(uint64_t a1)
{
  return C3DEffectCommonProfileContainsContentForEffectProperty(a1, 8);
}

uint64_t C3DEntityGetValueStorageModificationCount(_QWORD *a1)
{
  const __CFDictionary *v2;
  const void *Value;
  uint64_t Timestamp;
  CFTypeID v5;

  v2 = (const __CFDictionary *)a1[5];
  if (v2 && (Value = CFDictionaryGetValue(v2, CFSTR("_kvc"))) != 0)
    Timestamp = C3DKeyValueStoreGetTimestamp((uint64_t)Value);
  else
    Timestamp = 0;
  v5 = CFGetTypeID(a1);
  if (v5 == C3DMaterialGetTypeID())
    return C3DMaterialGetValueStorageModificationCount((uint64_t)a1) + Timestamp;
  return Timestamp;
}

uint64_t C3DMaterialGetValueStorageModificationCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 96);
}

const __CFDictionary *C3DEntityEnumerateKeyValuesWithBlock(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(const __CFDictionary **)(a1 + 40);
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("_kvc"));
    if (result)
      return (const __CFDictionary *)C3DKeyValueStoreEnumerate((uint64_t)result, a2);
  }
  return result;
}

uint64_t SCNMTLRenderCommandEncoder::drawIndexedPrimitives(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  void *v19;

  SCNMTLRenderCommandEncoder::_bindPendingTextures((SCNMTLRenderCommandEncoder *)a1);
  SCNMTLRenderCommandEncoder::applyChangedStates((SCNMTLRenderCommandEncoder *)a1);
  v16 = *(unsigned int *)(a1 + 64);
  v17 = v16 * a7;
  v18 = v16 * a8;
  v19 = *(void **)(a1 + 3392);
  if (v17 <= 1 && v18 == 0)
    return objc_msgSend(v19, "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:", a2, a3, a4, a5, a6);
  if (v18)
    return objc_msgSend(v19, "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:", a2, a3, a4, a5, a6, 0, v18);
  return objc_msgSend(v19, "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:", a2, a3, a4, a5, a6);
}

void SCNMTLRenderCommandEncoder::_bindPendingTextures(SCNMTLRenderCommandEncoder *this)
{
  uint64_t v2;
  id *v3;
  BOOL *v4;
  unint64_t v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  BOOL v13;
  uint64_t v14;
  id *v15;
  BOOL *v16;
  unint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  uint8_t v25[4];
  uint64_t v26;
  uint8_t v27[4];
  _DWORD v28[7];

  v2 = 0;
  *(_QWORD *)&v28[5] = *MEMORY[0x1E0C80C00];
  v3 = &this->var15[3];
  do
  {
    v4 = &this->var0 + 8 * v2;
    v5 = *((_QWORD *)v4 + 426);
    if (v5)
    {
      v6 = 0;
      v7 = 0xFFFFFFFFLL;
      v8 = 1;
      do
      {
        if ((v5 & 1) != 0)
        {
          if (v7 >= v8 - 1)
            v10 = (v8 - 1);
          else
            v10 = v7;
          if ((v5 & 2) != 0)
            goto LABEL_21;
          if (v7 >= v6)
            v11 = v6;
          else
            v11 = v7;
          v12 = v8 - v11;
          if ((v8 - v11) < 2)
            objc_msgSend((id)this->var24[1], "setVertexTexture:atIndex:", this->var15[v10 + 3], v10);
          else
            objc_msgSend((id)this->var24[1], "setVertexTextures:withRange:", &v3[v10], v10, (v8 - v11));
          SCNMTLEnsureIOSurfaceBackingBufferValidity((__IOSurface *)this->var24[0], &v3[v10], v12);
        }
        else if ((_DWORD)v7 != -1)
        {
          v9 = scn_default_log();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
            SCNMTLComputeCommandEncoder::_bindPendingTextures(v27, v28, v9);
          v10 = v7;
          goto LABEL_21;
        }
        v10 = 0xFFFFFFFFLL;
LABEL_21:
        ++v6;
        ++v8;
        v7 = v10;
        v13 = v5 >= 2;
        v5 >>= 1;
      }
      while (v13);
    }
    *((_QWORD *)v4 + 426) = 0;
    ++v2;
  }
  while (v2 != 2);
  v14 = 0;
  v15 = &this->var18[3];
  do
  {
    v16 = &this->var0 + 8 * v14;
    v17 = *((_QWORD *)v16 + 428);
    if (v17)
    {
      v18 = 0;
      v19 = 0xFFFFFFFFLL;
      v20 = 1;
      do
      {
        if ((v17 & 1) != 0)
        {
          if (v19 >= v20 - 1)
            v22 = (v20 - 1);
          else
            v22 = v19;
          if ((v17 & 2) != 0)
            goto LABEL_43;
          if (v19 >= v18)
            v23 = v18;
          else
            v23 = v19;
          v24 = v20 - v23;
          if ((v20 - v23) < 2)
            objc_msgSend((id)this->var24[1], "setFragmentTexture:atIndex:", this->var18[v22 + 3], v22);
          else
            objc_msgSend((id)this->var24[1], "setFragmentTextures:withRange:", &v15[v22], v22, (v20 - v23));
          SCNMTLEnsureIOSurfaceBackingBufferValidity((__IOSurface *)this->var24[0], &v15[v22], v24);
        }
        else if ((_DWORD)v19 != -1)
        {
          v21 = scn_default_log();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
            SCNMTLComputeCommandEncoder::_bindPendingTextures(v25, &v26, v21);
          v22 = v19;
          goto LABEL_43;
        }
        v22 = 0xFFFFFFFFLL;
LABEL_43:
        ++v18;
        ++v20;
        v19 = v22;
        v13 = v17 >= 2;
        v17 >>= 1;
      }
      while (v13);
    }
    *((_QWORD *)v16 + 428) = 0;
    ++v14;
  }
  while (v14 != 2);
}

SCNMTLRenderCommandEncoder *SCNMTLRenderCommandEncoder::applyChangedStates(SCNMTLRenderCommandEncoder *this)
{
  SCNMTLRenderCommandEncoder *v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;

  v1 = this;
  if (this->var5)
  {
    this->var5 = 0;
    this = (SCNMTLRenderCommandEncoder *)objc_msgSend((id)this->var24[1], "setFrontFacingWinding:", this->var1);
  }
  if (v1->var7)
  {
    v1->var7 = 0;
    this = (SCNMTLRenderCommandEncoder *)objc_msgSend((id)v1->var24[1], "setTriangleFillMode:", v1->var3);
  }
  if (v1->var6)
  {
    v1->var6 = 0;
    this = (SCNMTLRenderCommandEncoder *)objc_msgSend((id)v1->var24[1], "setCullMode:", v1->var2);
  }
  if (v1->var8)
  {
    v1->var8 = 0;
    if ((SCNMTLDeviceSupportsDepthClipMode((void *)objc_msgSend((id)v1->var24[1], "device")) & 1) == 0)
    {
      v2 = scn_default_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
        SCNMTLRenderCommandEncoder::applyChangedStates(v2, v3, v4);
    }
    return (SCNMTLRenderCommandEncoder *)objc_msgSend((id)v1->var24[1], "setDepthClipMode:", v1->var4);
  }
  return this;
}

uint64_t SCNMTLRenderCommandEncoder::setFragmentBuffer(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = result + 16 * a4;
  if (*(_QWORD *)(v4 + 1728) == a2)
  {
    if (*(_QWORD *)(v4 + 1736) != a3)
    {
      *(_QWORD *)(v4 + 1736) = a3;
      return objc_msgSend(*(id *)(result + 3392), "setFragmentBufferOffset:atIndex:", a3, a4);
    }
  }
  else
  {
    *(_QWORD *)(v4 + 1728) = a2;
    *(_QWORD *)(v4 + 1736) = a3;
    return objc_msgSend(*(id *)(result + 3392), "setFragmentBuffer:offset:atIndex:", a2);
  }
  return result;
}

__IOSurface *SCNMTLEnsureIOSurfaceBackingBufferValidity(__IOSurface *result, id *a2, unsigned int a3)
{
  __IOSurface *v4;
  uint64_t v5;
  uint64_t v6;
  __IOSurface *v7;
  _QWORD v8[5];

  if (a3)
  {
    v4 = result;
    v5 = a3;
    v6 = MEMORY[0x1E0C809B0];
    do
    {
      result = (__IOSurface *)objc_msgSend(*a2, "iosurface");
      if (result)
      {
        v7 = result;
        IOSurfaceIncrementUseCount(result);
        v8[0] = v6;
        v8[1] = 3221225472;
        v8[2] = __SCNMTLEnsureIOSurfaceBackingBufferValidity_block_invoke;
        v8[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
        v8[4] = v7;
        result = (__IOSurface *)-[__IOSurface addCompletedHandler:](v4, "addCompletedHandler:", v8);
      }
      ++a2;
      --v5;
    }
    while (v5);
  }
  return result;
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

__n128 __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

__n128 __Block_byref_object_copy__4(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

__n128 __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

uint64_t _transposeSkinnerToClone(void *a1, void *a2, void *a3)
{
  void *v6;
  uint64_t Clone;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[128];
  _BYTE v30[128];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(a1, "skinner"))
  {
    v6 = (void *)objc_msgSend((id)objc_msgSend(a1, "skinner"), "skeleton");
    if (v6 && (Clone = _findClone(v6, a2, a3)) != 0)
    {
      objc_msgSend((id)objc_msgSend(a1, "skinner"), "setSkeleton:", Clone);
    }
    else
    {
      v8 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
      v25 = 0u;
      v26 = 0u;
      v27 = 0u;
      v28 = 0u;
      v9 = (void *)objc_msgSend((id)objc_msgSend(a1, "skinner"), "bones");
      v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v25, v30, 16);
      if (v10)
      {
        v11 = v10;
        v12 = *(_QWORD *)v26;
LABEL_7:
        v13 = 0;
        while (1)
        {
          if (*(_QWORD *)v26 != v12)
            objc_enumerationMutation(v9);
          v14 = *(void **)(*((_QWORD *)&v25 + 1) + 8 * v13);
          if (!objc_msgSend(v14, "name"))
            break;
          v15 = objc_msgSend(a3, "childNodeWithName:", objc_msgSend(v14, "name"));
          if (!v15)
            break;
          objc_msgSend(v8, "addObject:", v15);
          if (v11 == ++v13)
          {
            v11 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v25, v30, 16);
            if (v11)
              goto LABEL_7;
            goto LABEL_14;
          }
        }
      }
      else
      {
LABEL_14:
        objc_msgSend((id)objc_msgSend(a1, "skinner"), "setBones:", v8);
      }
    }
  }
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v16 = (void *)objc_msgSend(a1, "childNodes", 0);
  result = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v21, v29, 16);
  if (result)
  {
    v18 = result;
    v19 = *(_QWORD *)v22;
    do
    {
      v20 = 0;
      do
      {
        if (*(_QWORD *)v22 != v19)
          objc_enumerationMutation(v16);
        _transposeSkinnerToClone(*(_QWORD *)(*((_QWORD *)&v21 + 1) + 8 * v20++), a2, a3);
      }
      while (v18 != v20);
      result = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v21, v29, 16);
      v18 = result;
    }
    while (result);
  }
  return result;
}

void _copyAnimations(void *a1, void *a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  NSObject *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a2, "_copyAnimationsFrom:", a1);
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v4 = (void *)objc_msgSend(a1, "actionKeys", 0);
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v13;
    do
    {
      v8 = 0;
      do
      {
        if (*(_QWORD *)v13 != v7)
          objc_enumerationMutation(v4);
        objc_msgSend(a2, "runAction:forKey:", objc_msgSend(a1, "actionForKey:", *(_QWORD *)(*((_QWORD *)&v12 + 1) + 8 * v8)), *(_QWORD *)(*((_QWORD *)&v12 + 1) + 8 * v8));
        ++v8;
      }
      while (v6 != v8);
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
    }
    while (v6);
  }
  v9 = objc_msgSend((id)objc_msgSend(a1, "childNodes"), "count");
  if (objc_msgSend((id)objc_msgSend(a2, "childNodes"), "count") == v9)
  {
    if (v9)
    {
      for (i = 0; i != v9; ++i)
        _copyAnimations(objc_msgSend((id)objc_msgSend(a1, "childNodes"), "objectAtIndex:", i), objc_msgSend((id)objc_msgSend(a2, "childNodes"), "objectAtIndex:", i));
    }
  }
  else
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      _copyAnimations_cold_1();
  }
}

void C3DEntityCopyTo(uint64_t a1, CFTypeRef *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *ID;
  const __CFString *Name;
  const __CFDictionary *Attributes;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DGeometryCopy_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  ID = (const void *)C3DEntityGetID(a1);
  C3DEntitySetID((uint64_t)a2, ID);
  Name = (const __CFString *)C3DEntityGetName(a1);
  C3DEntitySetName((uint64_t)a2, Name);
  Attributes = (const __CFDictionary *)C3DEntityGetAttributes(a1);
  _C3DEntitySetAttributes((uint64_t)a2, Attributes);
  _C3DEntitySetAttribute(a2, CFSTR("_kvc"), 0, 1);
  _C3DEntitySetAttribute(a2, CFSTR("kAnimationsKey"), 0, 1);
}

void _C3DEntitySetAttribute(CFTypeRef *a1, void *key, const __CFDictionary *a3, int a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __CFDictionary *Mutable;
  uint64_t SharedInstance;

  if (!a1 && (v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    C3DEntityRemoveAllAnimations_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (key)
      goto LABEL_6;
  }
  else if (key)
  {
    goto LABEL_6;
  }
  v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
    C3DEntityGetAttribute_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
LABEL_6:
  if (C3DEntityGetAttribute((uint64_t)a1, key) != a3)
  {
    Mutable = (__CFDictionary *)a1[5];
    if (!Mutable)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      a1[5] = Mutable;
    }
    if (a3)
    {
      CFDictionarySetValue(Mutable, key, a3);
    }
    else
    {
      CFDictionaryRemoveValue(Mutable, key);
      if (!CFDictionaryGetCount((CFDictionaryRef)a1[5]))
      {
        CFRelease(a1[5]);
        a1[5] = 0;
      }
    }
    if (a4)
    {
      SharedInstance = C3DNotificationCenterGetSharedInstance();
      C3DNotificationCenterPostNotification(SharedInstance, CFSTR("kC3DNotificationEntityAttributeDidChange"), a1, (const __CFDictionary *)key, 1u);
    }
  }
}

CFTypeRef C3DEntitySetID(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(CFTypeRef *)(a1 + 24);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 24) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 24) = result;
  }
  return result;
}

uint64_t C3DEntityGetID(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 24);
}

void _C3DEntitySetAttributes(uint64_t a1, CFDictionaryRef theDict)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = *(const void **)(a1 + 40);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a1 + 40) = 0;
  }
  if (theDict)
  {
    if (CFDictionaryGetCount(theDict))
      *(_QWORD *)(a1 + 40) = CFDictionaryCreateMutableCopy(0, 0, theDict);
  }
}

uint64_t C3DNodeSetIsGizmo(uint64_t result, int a2)
{
  int v2;

  if (a2)
    v2 = 0x20000;
  else
    v2 = 0;
  *(_DWORD *)(result + 220) = *(_DWORD *)(result + 220) & 0xFFFDFFFF | v2;
  return result;
}

uint64_t C3DNodeIsGizmo(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 222) >> 1) & 1;
}

void _C3DTransactionBegin(uint64_t a1, float a2)
{
  int v2;
  uint64_t Stack;
  const __CFArray *v5;
  CFIndex Count;
  __CFArray **ValueAtIndex;
  uint64_t Instance;
  uint64_t v9;
  char v10;
  __CFArray *Mutable;
  __CFArray *v12;
  __CFArray *v13;

  v2 = a1;
  Stack = C3DTransactionGetStack(a1);
  if (CFArrayGetCount(*(CFArrayRef *)(Stack + 16)) < 1)
  {
    ValueAtIndex = 0;
  }
  else
  {
    v5 = *(const __CFArray **)(Stack + 16);
    Count = CFArrayGetCount(v5);
    ValueAtIndex = (__CFArray **)CFArrayGetValueAtIndex(v5, Count - 1);
  }
  if (C3DTransactionGetTypeID_onceToken != -1)
    dispatch_once(&C3DTransactionGetTypeID_onceToken, &__block_literal_global_112);
  Instance = C3DTypeCreateInstance_(C3DTransactionGetTypeID_typeID, 0x48uLL);
  v9 = Instance;
  *(double *)(Instance + 32) = a2;
  if (v2)
    v10 = 2;
  else
    v10 = 0;
  *(_BYTE *)(Instance + 60) = *(_BYTE *)(Instance + 60) & 0xFD | v10;
  if (ValueAtIndex)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
    *(_QWORD *)(v9 + 72) = CFRetain(ValueAtIndex);
    Mutable = ValueAtIndex[8];
    if (!Mutable)
    {
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      ValueAtIndex[8] = Mutable;
    }
    CFArrayAppendValue(Mutable, (const void *)v9);
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    if ((*((_BYTE *)ValueAtIndex + 60) & 2) == 0)
    {
      *(_QWORD *)(v9 + 32) = ValueAtIndex[4];
      *(_BYTE *)(v9 + 60) = *(_BYTE *)(v9 + 60) & 0xFB | *((_BYTE *)ValueAtIndex + 60) & 4;
      v12 = *(__CFArray **)(v9 + 24);
      v13 = ValueAtIndex[3];
      if (v12 != v13)
      {
        if (v12)
        {
          CFRelease(*(CFTypeRef *)(v9 + 24));
          *(_QWORD *)(v9 + 24) = 0;
          v13 = ValueAtIndex[3];
        }
        if (v13)
          v13 = (__CFArray *)CFRetain(v13);
        *(_QWORD *)(v9 + 24) = v13;
      }
    }
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(Stack + 16), (const void *)v9);
  CFRelease((CFTypeRef)v9);
}

void C3DTransactionCommit(char a1)
{
  void *Stack;
  const __CFArray *v3;
  CFIndex Count;
  double *ValueAtIndex;
  NSObject *v6;
  uint64_t v7;
  CFTimeInterval v8;
  char *appended;
  CFArrayRef *v10;
  CFIndex v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;

  Stack = C3DTransactionGetStack();
  v3 = (const __CFArray *)*((_QWORD *)Stack + 2);
  Count = CFArrayGetCount(v3);
  ValueAtIndex = (double *)CFArrayGetValueAtIndex(v3, Count - 1);
  if (ValueAtIndex[5] == 0.0)
  {
    v7 = (uint64_t)ValueAtIndex;
    v8 = CACurrentMediaTime();
    os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
    *(CFTimeInterval *)(v7 + 40) = v8;
    if ((a1 & 1) != 0)
    {
      *(_BYTE *)(v7 + 60) |= 1u;
      C3DTransactionTestForDidComplete(v7);
    }
    else
    {
      appended = C3DCommandQueueAppendNewCommand((char **)Stack + 4);
      *((_QWORD *)appended + 4) = CFRetain((CFTypeRef)v7);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    os_unfair_lock_lock((os_unfair_lock_t)&gCommandQueueLock);
    v10 = (CFArrayRef *)C3DTransactionGetStack();
    v11 = CFArrayGetCount(v10[2]);
    if (v11 <= 1)
    {
      v12 = scn_default_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
        C3DTransactionCommit_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
      v20 = scn_default_log();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        C3DTransactionCommit_cold_2();
    }
    else
    {
      CFArrayRemoveValueAtIndex(v10[2], v11 - 1);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&gCommandQueueLock);
    if (CFArrayGetCount(*((CFArrayRef *)Stack + 2)) <= 1 && (a1 & 1) == 0)
      C3DTransactionFlush();
  }
  else
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      C3DTransactionCommit_cold_1();
  }
}

void C3DTransactionTestForDidComplete(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFArray *v10;
  CFArrayRef *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CFIndex FirstIndexOfValue;
  CFIndex v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  CFRange v31;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DTextureCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 60) & 1) != 0 && !*(_DWORD *)(a1 + 56))
  {
    v10 = *(const __CFArray **)(a1 + 64);
    if (!v10 || !CFArrayGetCount(v10))
    {
      CFRetain((CFTypeRef)a1);
      v11 = *(CFArrayRef **)(a1 + 72);
      if (v11)
      {
        CFRetain(*(CFTypeRef *)(a1 + 72));
        if (!v11[8])
        {
          v12 = scn_default_log();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
            C3DTransactionTestForDidComplete_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
        }
        v31.length = CFArrayGetCount(v11[8]);
        v31.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v11[8], v31, (const void *)a1);
        if (FirstIndexOfValue == -1)
        {
          v30 = scn_default_log();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            C3DTransactionTestForDidComplete_cold_1();
        }
        else
        {
          v21 = FirstIndexOfValue;
          CFRetain((CFTypeRef)a1);
          CFArrayRemoveValueAtIndex(v11[8], v21);
          if (*(CFArrayRef **)(a1 + 72) != v11)
          {
            v22 = scn_default_log();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
              C3DTransactionTestForDidComplete_cold_2(v22, v23, v24, v25, v26, v27, v28, v29);
          }
          CFRelease(*(CFTypeRef *)(a1 + 72));
          *(_QWORD *)(a1 + 72) = 0;
          CFRelease((CFTypeRef)a1);
        }
        C3DTransactionDidComplete(a1);
        if (!CFArrayGetCount(v11[8]))
          C3DTransactionTestForDidComplete(v11);
        CFRelease(v11);
      }
      else
      {
        C3DTransactionDidComplete(a1);
      }
      CFRelease((CFTypeRef)a1);
    }
  }
}

void C3DTransactionDidComplete(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DTextureCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(void **)(a1 + 80);
  if (v10)
    dispatch_async(MEMORY[0x1E0C80D38], v10);
}

void C3DTransactionBegin()
{
  _C3DTransactionBegin(0, 0.25);
}

double C3D::ScenePass::execute(uint64_t a1, void **a2)
{
  void (**RenderCallbacks)(_QWORD);
  void (**v5)(_QWORD);
  BOOL v6;
  char *v7;
  int v8;
  __int128 *v9;
  uint64_t v10;
  uint64_t RenderContext;
  uint64_t v12;
  double result;
  BOOL v14;
  void (*v15)(_QWORD);
  char *v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;

  RenderCallbacks = (void (**)(_QWORD))C3DEngineContextGetRenderCallbacks(*(_QWORD *)(a1 + 16));
  v5 = RenderCallbacks;
  if (*(_BYTE *)(a1 + 5365))
    v6 = RenderCallbacks == 0;
  else
    v6 = 1;
  if (!v6 && *RenderCallbacks)
  {
    (*RenderCallbacks)(*(_QWORD *)(a1 + 16));
    v7 = (char *)*a2;
    v8 = *((_DWORD *)*a2 + 16);
    v9 = (__int128 *)((char *)*a2 + 3384);
    v10 = *((_QWORD *)*a2 + 425);
    v18 = *v9;
    bzero(*a2, 0xD70uLL);
    *((_DWORD *)v7 + 16) = 1;
    v7[72] = 1;
    *v9 = v18;
    *((_QWORD *)v7 + 425) = v10;
    *((_WORD *)v7 + 20) = 257;
    v7[42] = 1;
    *(_OWORD *)(v7 + 8) = 0u;
    *(_OWORD *)(v7 + 24) = 0u;
    *((_DWORD *)*a2 + 16) = v8;
    C3D::RenderPass::setStates((unsigned __int8 *)a1, a2);
  }
  if (*(_QWORD *)(a1 + 5384))
  {
    RenderContext = C3DEngineContextGetRenderContext(*(_QWORD *)(a1 + 16));
    v12 = C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*(_QWORD *)(a1 + 5384) + 48);
    -[SCNMTLRenderContext _setReflectionProbeArrayTexture:](RenderContext, v12);
  }
  C3D::DrawNodesPass::execute((uint64_t *)a1, (uint64_t)a2);
  if (*(_BYTE *)(a1 + 5365))
    v14 = v5 == 0;
  else
    v14 = 1;
  if (!v14)
  {
    v15 = v5[1];
    if (v15)
    {
      v15(*(_QWORD *)(a1 + 16));
      v16 = (char *)*a2;
      v17 = *((_QWORD *)v16 + 425);
      v19 = *(_OWORD *)(v16 + 3384);
      bzero(v16, 0xD70uLL);
      *((_DWORD *)v16 + 16) = 1;
      v16[72] = 1;
      *(_OWORD *)(v16 + 3384) = v19;
      *((_QWORD *)v16 + 425) = v17;
      *((_WORD *)v16 + 20) = 257;
      v16[42] = 1;
      result = 0.0;
      *(_OWORD *)(v16 + 8) = 0u;
      *(_OWORD *)(v16 + 24) = 0u;
    }
  }
  return result;
}

void C3DTransactionSetImmediateMode(int a1)
{
  _BYTE *Current;
  char v3;

  Current = C3DTransactionGetCurrent();
  if (a1)
    v3 = 8;
  else
    v3 = 0;
  Current[60] = Current[60] & 0xF7 | v3;
  if (a1)
    gAtomicTime = CACurrentMediaTime();
}

uint64_t C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;

  if (!*(_QWORD *)a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(v2, v3, v4);
  }
  return *(_QWORD *)a1;
}

unsigned __int8 *C3D::RenderPass::setStates(unsigned __int8 *result, _QWORD *a2)
{
  _BYTE *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = (_BYTE *)*a2;
  v3 = result[112];
  *(_BYTE *)*a2 = result[112] != 0;
  if (v3)
  {
    v4 = *((_QWORD *)v2 + 1);
    v5 = *((_QWORD *)&xmmword_1DD009B50 + v4);
    if (v4 != v5)
    {
      *((_QWORD *)v2 + 1) = v5;
      v2[40] = 1;
      v4 = v5;
    }
    v6 = *((_QWORD *)&xmmword_1DD009B50 + result[113]);
  }
  else
  {
    v6 = result[113];
    v4 = *((_QWORD *)v2 + 1);
  }
  if (v4 != v6)
  {
    *((_QWORD *)v2 + 1) = v6;
    v2[40] = 1;
  }
  if (!v2[74])
  {
    v7 = result[114];
    if (*((_QWORD *)v2 + 3) != v7)
    {
      *((_QWORD *)v2 + 3) = v7;
      v2[42] = 1;
    }
  }
  v8 = result[115];
  if (*((_QWORD *)v2 + 4) != v8)
  {
    *((_QWORD *)v2 + 4) = v8;
    v2[43] = 1;
  }
  if (!v2[73])
  {
    v9 = result[116];
    if (*((_QWORD *)v2 + 2) != v9)
    {
      *((_QWORD *)v2 + 2) = v9;
      v2[41] = 1;
    }
  }
  return result;
}

uint64_t _willRenderSceneEngineContextCallback(uint64_t a1)
{
  uint64_t result;
  void *v3;
  id *Scene;

  result = C3DEngineContextGetUserInfo(a1);
  if (result)
  {
    v3 = (void *)result;
    Scene = (id *)C3DEngineContextGetScene(a1);
    return objc_msgSend(v3, "_willRenderScene:", C3DEntityGetObjCWrapper(Scene));
  }
  return result;
}

uint64_t _didRenderSceneEngineContextCallback(uint64_t a1)
{
  uint64_t result;
  void *v3;
  id *Scene;

  result = C3DEngineContextGetUserInfo(a1);
  if (result)
  {
    v3 = (void *)result;
    Scene = (id *)C3DEngineContextGetScene(a1);
    return objc_msgSend(v3, "_didRenderScene:", C3DEntityGetObjCWrapper(Scene));
  }
  return result;
}

_QWORD *CreateProbeArrayResourceIfNeeded(C3D::Pass *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t RenderContext;
  uint64_t LightingSystem;
  C3D::RenderGraphResourceManager *v7;
  int v8;
  int IsWritable;
  uint64_t v10;
  uint64_t v11;
  int ReflectionProbesCount;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL4 v17;
  _BOOL4 v18;
  _QWORD *v19;
  unsigned int v20;
  void **v21;
  void *v22;
  id v23;
  uint64_t v24;
  void *v25;
  uint64_t LightingEnvironmentEffectSlot;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  C3D::RefCountedResource *PersistentResource;
  int LightingEnvironmentTimeStamp;
  _DWORD *v39;
  _BOOL4 HasImageOrTexture;
  C3D::Pass *v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  _BOOL4 HasPrecomputedLightingEnvironment;
  _BOOL4 AllowsDefaultLightingEnvironmentFallback;
  id v48;
  C3D::RefCountedResource *v49;
  C3D::Pass *v50;
  C3D::PassDescriptor *v51;
  uint64_t v52;
  C3D::PassResource *v53;
  C3D::PassDescriptor *v54;
  uint64_t v55;
  C3D::PassDescriptor *v56;
  uint64_t v57;
  C3D::PassResource *v58;
  C3D::PassDescriptor *v59;
  uint64_t v60;
  BOOL v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v67;
  uint64_t v68;
  uint64_t Scene;
  uint64_t v70;
  uint64_t v71;
  _QWORD v72[4];
  int v73;
  uint64_t v74;
  _BOOL4 v75;
  uint64_t v76;
  C3D::Pass *v77;
  uint64_t v78;
  _QWORD *v79;
  C3D::RefCountedResource *v80;
  BOOL v81;
  __int128 v82;
  int v83;
  __int128 v84;
  uint64_t v85;
  __int128 v86;
  int v87;
  C3D::Pass *v88;

  v88 = a1;
  v3 = *((_QWORD *)a1 + 3);
  v4 = *(_QWORD *)(v3 + 8);
  RenderContext = C3DEngineContextGetRenderContext(v4);
  Scene = C3DEngineContextGetScene(v4);
  LightingSystem = C3DSceneGetLightingSystem(Scene);
  v7 = *(C3D::RenderGraphResourceManager **)(v3 + 128);
  -[SCNMTLRenderContext device](RenderContext);
  v8 = SCNMTLDeviceSupportsColorRenderingInPixelFormat();
  -[SCNMTLRenderContext device](RenderContext);
  IsWritable = SCNMTLPixelFormatIsWritable();
  v10 = 115;
  if ((IsWritable & v8) != 0)
    v10 = 93;
  v70 = v10;
  if ((-[SCNMTLRenderContext features](RenderContext) & 0x100) != 0)
    v11 = 256;
  else
    v11 = 128;
  v71 = v11;
  ReflectionProbesCount = C3DLightingSystemGetReflectionProbesCount(LightingSystem);
  if (!ReflectionProbesCount)
  {
    LightingEnvironmentEffectSlot = C3DSceneGetLightingEnvironmentEffectSlot(Scene, 0);
    if (!LightingEnvironmentEffectSlot
      || (v27 = LightingEnvironmentEffectSlot, !C3DEffectSlotHasImageOrTexture(LightingEnvironmentEffectSlot))
      && !C3DEffectSlotHasPrecomputedLightingEnvironment(v27))
    {
      if (!C3DEngineContextGetAllowsDefaultLightingEnvironmentFallback(v4))
        return 0;
    }
  }
  v67 = a2;
  v13 = (ReflectionProbesCount + 1);
  v14 = C3D::RenderGraphResourceManager::get(v7, LightingSystem);
  v15 = v14;
  v68 = LightingSystem;
  v64 = v4;
  v65 = (uint64_t)v7;
  v63 = RenderContext;
  if (v14
    && (v16 = v14 + 48, *(_QWORD *)(v15 + 48))
    && objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(v16), "arrayLength") == v13)
  {
    v17 = 0;
    v18 = 1;
    v19 = (_QWORD *)v15;
    v20 = v13;
  }
  else
  {
    v19 = (_QWORD *)operator new();
    v19[2] = 0;
    v19[4] = 0;
    *v19 = &off_1EA599AB8;
    v19[1] = 0;
    v19[3] = v19 + 4;
    v19[6] = 0;
    v21 = (void **)(v19 + 6);
    v19[5] = v19 + 6;
    v22 = (void *)-[SCNMTLRenderContext resourceManager](RenderContext);
    v23 = objc_alloc_init(MEMORY[0x1E0CC6BB0]);
    v24 = RenderContext;
    v25 = v23;
    if (v13 < 2)
    {
      objc_msgSend(v23, "setTextureType:", 5);
    }
    else
    {
      objc_msgSend(v23, "setTextureType:", -[SCNMTLRenderContext cubeArrayTypeIfSupported](v24));
      objc_msgSend(v25, "setArrayLength:", v13);
    }
    objc_msgSend(v25, "setPixelFormat:", v70);
    v28 = v15;
    v29 = v3;
    if (SCNMTLTextureTypeIsCube(objc_msgSend(v25, "textureType")))
    {
      v30 = v25;
      v31 = v71;
      v32 = v71;
    }
    else
    {
      v31 = v71;
      v32 = (2 * v71);
      v30 = v25;
    }
    objc_msgSend(v30, "setWidth:", v32);
    LODWORD(v71) = v31;
    objc_msgSend(v25, "setHeight:", v31);
    objc_msgSend(v25, "setUsage:", 1);
    objc_msgSend(v25, "setUsage:", objc_msgSend(v25, "usage") | 4);
    objc_msgSend(v25, "setUsage:", objc_msgSend(v25, "usage") | 2);
    objc_msgSend(v25, "setStorageMode:", 2);
    objc_msgSend(v25, "setMipmapLevelCount:", 5);
    v33 = objc_msgSend(v22, "newTextureWithDescriptor:", v25);
    v34 = *v21;
    v3 = v29;
    v15 = v28;
    v20 = v13;
    if (*v21 != (void *)v33)
    {
      v35 = (void *)v33;
      if (v34)

      *v21 = v35;
    }
    C3D::Array<unsigned int,0u,C3D::MallocAllocator>::resize((uint64_t)(v19 + 2), v13);
    C3D::Array<void const*,0u,C3D::MallocAllocator>::resize((uint64_t)(v19 + 4), v13);
    v17 = 0;
    v18 = v15 == (_QWORD)v19;
    if (v15 && (_QWORD *)v15 != v19)
    {
      v18 = 0;
      v17 = *(_QWORD *)(v15 + 48) != 0;
    }
  }
  v36 = C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *((uint64_t)(v19 + 6));
  PersistentResource = (C3D::RefCountedResource *)C3D::RenderGraph::createPersistentResource(v3, v36);
  LightingEnvironmentTimeStamp = C3DSceneGetLightingEnvironmentTimeStamp(Scene);
  v39 = (_DWORD *)C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[]((uint64_t)(v19 + 2), 0);
  if (v18 && *v39 == LightingEnvironmentTimeStamp)
  {
    HasImageOrTexture = 0;
    v41 = a1;
    v42 = v67;
    v43 = v71;
    goto LABEL_48;
  }
  if (!v17
    || *(_DWORD *)C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[](v15 + 16, 0) != LightingEnvironmentTimeStamp)
  {
    v62 = v17;
    v44 = C3DSceneGetLightingEnvironmentEffectSlot(Scene, 0);
    v45 = v44;
    if (v44
      && ((HasImageOrTexture = C3DEffectSlotHasImageOrTexture(v44),
           HasPrecomputedLightingEnvironment = C3DEffectSlotHasPrecomputedLightingEnvironment(v45),
           HasImageOrTexture)
       || HasPrecomputedLightingEnvironment))
    {
      if (!HasImageOrTexture)
      {
        v42 = v67;
        goto LABEL_45;
      }
      v43 = v71;
      LODWORD(v86) = v71;
      *((_QWORD *)&v86 + 1) = v70;
      HasImageOrTexture = 1;
      v87 = 1;
      v42 = v67;
      C3D::ComputeProbeFromEnvironmentTexture(a1, v67, PersistentResource, 0, v45, &v86);
    }
    else
    {
      AllowsDefaultLightingEnvironmentFallback = C3DEngineContextGetAllowsDefaultLightingEnvironmentFallback(v64);
      if (v20 <= 1 && AllowsDefaultLightingEnvironmentFallback)
      {
        v48 = (id)objc_msgSend((id)-[SCNMTLRenderContext resourceManager](v63), "defaultLightingEnvironmentRadianceTexture");
        v49 = (C3D::RefCountedResource *)C3D::RenderGraph::createPersistentResource(v3, (uint64_t)v48);
        v84 = 0uLL;
        v85 = 0;
        v50 = C3D::RenderGraph::createPass<C3D::CopyTextureComputePass,C3D::Pass *&,C3D::CopyTextureComputePass::Parameters>(v3, &v88, (const Parameters *)&v84);
        v51 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v50);
        v52 = C3D::PassDescriptor::inputAtIndex(v51, 0);
        *(_WORD *)(v52 + 66) |= 0x100u;
        v53 = (C3D::PassResource *)C3D::Pass::resource(v50);
        C3D::PassResource::setInputAtIndex(v53, v49, 0);
        v54 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v50);
        v55 = C3D::PassDescriptor::outputAtIndex(v54, 0);
        *(_WORD *)(v55 + 66) |= 0x100u;
        SCNMTLTextureDescFromMTLTexture(*(void **)PersistentResource, (uint64_t)&v84);
        v56 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v50);
        v57 = C3D::PassDescriptor::outputAtIndex(v56, 0);
        *(_OWORD *)(v57 + 16) = v84;
        *(_DWORD *)(v57 + 32) = v85;
        v58 = (C3D::PassResource *)C3D::Pass::resource(v50);
        C3D::PassResource::setOutputAtIndex(v58, PersistentResource, 0);
        v59 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v50);
        v60 = C3D::PassDescriptor::outputAtIndex(v59, 0);
        v42 = v67;
        C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>(v67, v60);
        C3D::Pass::addDependency(v88, v50);
        HasImageOrTexture = 0;
LABEL_45:
        v43 = v71;
        goto LABEL_46;
      }
      v43 = v71;
      LODWORD(v82) = v71;
      *((_QWORD *)&v82 + 1) = v70;
      v83 = 0;
      v42 = v67;
      C3D::ComputeProbeFromEnvironmentTexture(a1, v67, PersistentResource, 0, v45, &v82);
      HasImageOrTexture = 0;
    }
LABEL_46:
    LOBYTE(v17) = v62;
    goto LABEL_47;
  }
  v42 = a2;
  C3D::CopyProbeFromOldTextureToNewTexture(a1, a2, v15, 0, (uint64_t)v19, PersistentResource, 0);
  HasImageOrTexture = 0;
  v43 = v71;
LABEL_47:
  *(_DWORD *)C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[]((uint64_t)(v19 + 2), 0) = LightingEnvironmentTimeStamp;
  *(_QWORD *)C3D::Array<void const*,0u,C3D::MallocAllocator>::operator[]((uint64_t)(v19 + 4), 0) = 0;
  v41 = v88;
LABEL_48:
  v72[0] = MEMORY[0x1E0C809B0];
  v72[1] = 3221225472;
  v72[2] = __CreateProbeArrayResourceIfNeeded_block_invoke;
  v72[3] = &__block_descriptor_97_e53_v36__0I8_____C3DNode_12_____C3DLight_20________3___28l;
  v73 = v43;
  v74 = v70;
  v75 = HasImageOrTexture;
  v81 = v17;
  v76 = v15;
  v77 = v41;
  v78 = v42;
  v79 = v19;
  v80 = PersistentResource;
  C3DLightingSystemEnumerateRadianceProbes(v68, (uint64_t)v72);
  if (!v18)
    C3D::RenderGraphResourceManager::set(v65, v68, (uint64_t)v19);
  return v19;
}

uint64_t C3DSceneGetLightingSystem(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 128);
}

uint64_t C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  NSObject *v4;

  if (*(_DWORD *)a1 <= a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[]();
  }
  return *(_QWORD *)(a1 + 8) + 4 * a2;
}

void *SCNMTLTextureDescToMTLTextureDescriptor(unsigned __int16 *a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = objc_alloc_init(MEMORY[0x1E0CC6BB0]);
  v3 = v2;
  if (*a1 <= 1u)
    v4 = 1;
  else
    v4 = *a1;
  objc_msgSend(v2, "setWidth:", v4);
  if (a1[1] <= 1u)
    v5 = 1;
  else
    v5 = a1[1];
  objc_msgSend(v3, "setHeight:", v5);
  if (a1[2] <= 1u)
    v6 = 1;
  else
    v6 = a1[2];
  objc_msgSend(v3, "setDepth:", v6);
  if (a1[3] <= 1u)
    v7 = 1;
  else
    v7 = a1[3];
  objc_msgSend(v3, "setArrayLength:", v7);
  if (*((unsigned __int8 *)a1 + 15) <= 1u)
    v8 = 1;
  else
    v8 = *((unsigned __int8 *)a1 + 15);
  objc_msgSend(v3, "setSampleCount:", v8);
  objc_msgSend(v3, "setTextureType:", *((unsigned __int8 *)a1 + 8));
  objc_msgSend(v3, "setStorageMode:", *((unsigned __int8 *)a1 + 9));
  objc_msgSend(v3, "setUsage:", *((unsigned __int8 *)a1 + 10));
  objc_msgSend(v3, "setCpuCacheMode:", *((unsigned __int8 *)a1 + 11));
  objc_msgSend(v3, "setPixelFormat:", a1[6]);
  if (*((unsigned __int8 *)a1 + 14) <= 1u)
    v9 = 1;
  else
    v9 = *((unsigned __int8 *)a1 + 14);
  objc_msgSend(v3, "setMipmapLevelCount:", v9);
  return v3;
}

uint64_t C3DTextureSamplerGetMipFilter(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 36);
}

void sub_1DCCF1984(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t C3DEnumIterator<C3DEffectProperty,(signed char)0,(signed char)15>::end()
{
  unsigned __int8 v0;
  unsigned __int8 *v1;
  int v3;

  v1 = (unsigned __int8 *)&unk_1F03BE000;
  if ((v0 & 1) == 0)
  {
    v1 = (unsigned __int8 *)&unk_1F03BE000;
    if (v3)
    {
      C3DEnumIterator<C3DEffectProperty,(signed char)0,(signed char)15>::end(void)::end = 16;
      v1 = (_BYTE *)&unk_1F03BE000;
    }
  }
  return v1[1816];
}

uint64_t SCNMTLPixelFormatGetBitSize()
{
  MTLPixelFormatGetInfo();
  return 0;
}

BOOL C3DImageIsCatalogTexture(uint64_t a1)
{
  return *(_DWORD *)(a1 + 96) == 5;
}

unint64_t SCNMTLBlitCommandEncoder::generateMipmapsForTexture(id *a1, void *a2)
{
  unint64_t result;

  result = objc_msgSend(a2, "mipmapLevelCount");
  if (result >= 2)
  {
    if ((unint64_t)objc_msgSend(a2, "width") > 1)
      return objc_msgSend(*a1, "generateMipmapsForTexture:", a2);
    if ((unint64_t)objc_msgSend(a2, "height") > 1)
      return objc_msgSend(*a1, "generateMipmapsForTexture:", a2);
    result = objc_msgSend(a2, "depth");
    if (result >= 2)
      return objc_msgSend(*a1, "generateMipmapsForTexture:", a2);
  }
  return result;
}

unint64_t SCNMTLPixelFormatSupportsMipmapGeneration(uint64_t a1)
{
  return ((unint64_t)(a1 - 160) > 0x3A) | (0x20E008302AB00uLL >> (a1 + 96)) & 1;
}

void C3DImageReleaseBitmapCache(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(_DWORD *)(a1 + 96))
  {
    pthread_mutex_lock(&bitmapAccessSharedMutex);
    v10 = *(const void **)(a1 + 64);
    if (v10)
    {
      CFRelease(v10);
      *(_QWORD *)(a1 + 64) = 0;
      *(_BYTE *)(a1 + 80) |= 1u;
    }
    pthread_mutex_unlock(&bitmapAccessSharedMutex);
    pthread_mutex_lock(&bitmapAccessSharedMutex);
    if (*(_QWORD *)(a1 + 72))
    {
      _C3DImageDeleteTextureRawDataIfNeeded(a1);
      *(_BYTE *)(a1 + 80) |= 2u;
    }
    pthread_mutex_unlock(&bitmapAccessSharedMutex);
  }
}

uint64_t C3DImageGetTextureRawDataMipmapLevelCount(uint64_t a1, _BYTE *a2)
{
  uint64_t result;
  uint64_t v5;
  _BOOL4 IsCubeMap;
  _BOOL4 HasCubeMapComplexLayout;
  const __CFArray *v8;
  const void *ValueAtIndex;
  CFTypeID v10;

  result = C3DImageGetTextureRawData(a1);
  if (result)
  {
    v5 = result;
    IsCubeMap = C3DImageIsCubeMap(a1);
    HasCubeMapComplexLayout = C3DImageHasCubeMapComplexLayout(a1);
    v8 = *(const __CFArray **)(v5 + 40);
    if (IsCubeMap && !HasCubeMapComplexLayout)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v8, 0);
      v10 = CFGetTypeID(ValueAtIndex);
      if (v10 != CFArrayGetTypeID())
      {
        result = CFArrayGetCount(*(CFArrayRef *)(v5 + 40)) / 6;
        if (!a2)
          return result;
LABEL_7:
        *a2 = 1;
        return result;
      }
      v8 = (const __CFArray *)ValueAtIndex;
    }
    result = CFArrayGetCount(v8);
    if (!a2)
      return result;
    goto LABEL_7;
  }
  return result;
}

uint64_t C3DImageGetName(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 96);
  if (v1 == 5)
    return *(_QWORD *)(a1 + 88);
  if (v1 == 1)
    return objc_msgSend(*(id *)(a1 + 88), "lastPathComponent");
  return 0;
}

uint64_t SCNMTLPixelFormatFromBitmapContextDescription(uint64_t a1, uint64_t a2, CGContextRef context, char a4)
{
  CGBitmapInfo BitmapInfo;
  CGColorSpaceRef ColorSpace;
  int v10;
  _BOOL4 v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v16;
  unsigned int v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  int v22;
  CGContextRef v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  CGBitmapInfo v29;
  __int16 v30;
  const __CFString *v31;
  __int16 v32;
  const __CFString *v33;
  __int16 v34;
  const __CFString *v35;
  __int16 v36;
  CGColorSpaceRef v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  BitmapInfo = CGBitmapContextGetBitmapInfo(context);
  ColorSpace = CGBitmapContextGetColorSpace(context);
  v10 = BitmapInfo & 0x7000;
  if ((BitmapInfo & 0x1B) == 2)
  {
    v12 = 0;
    v11 = v10 == 4096 || v10 == 0x2000;
    if ((BitmapInfo & 0x100) == 0)
      goto LABEL_8;
LABEL_25:
    if (a2 == 32)
    {
      switch(a1)
      {
        case 1:
          return 55;
        case 4:
          return 125;
        case 2:
          return 105;
      }
    }
    else if (a2 == 16)
    {
      switch(a1)
      {
        case 1:
          return 25;
        case 4:
          return 115;
        case 2:
          return 65;
      }
    }
    goto LABEL_70;
  }
  if ((BitmapInfo & 0x1B) != 1 || (v11 = 0, v12 = 1, (BitmapInfo & 0x7000) != 0) && v10 != 12288 && v10 != 0x4000)
  {
    v12 = 0;
    v11 = 0;
  }
  if ((BitmapInfo & 0x100) != 0)
    goto LABEL_25;
LABEL_8:
  if (C3DLinearRenderingIsEnabled())
  {
    if (ColorSpace != (CGColorSpaceRef)C3DColorSpaceExtendedLinearSRGB()
      && ColorSpace != (CGColorSpaceRef)C3DColorSpaceLinearSRGB()
      && ColorSpace != (CGColorSpaceRef)C3DColorSpaceLinearGray())
    {
      v13 = C3DColorSpaceLinearDisplayP3();
      if ((a4 & 1) == 0 && ColorSpace != (CGColorSpaceRef)v13)
      {
        if (a2 == 8)
        {
          if (a1 == 1)
            return 11;
          if (a1 == 2)
            return 31;
          if (a1 == 4 && v12 == 1)
            return 71;
          if (a1 == 4 && v11)
            return 81;
        }
        goto LABEL_70;
      }
    }
    if (a2 == 16)
    {
      if (a1 == 1)
        return 20;
      if (a1 == 4 && (v12 & 1) != 0)
        return 110;
      goto LABEL_70;
    }
    if (a2 != 8)
      goto LABEL_70;
    if (a1 != 1)
    {
      if (a1 == 2)
        return 30;
      if (a1 == 4 && v12 == 1)
        return 70;
      if (a1 != 4 || !v11)
        goto LABEL_70;
      return 80;
    }
    return 10;
  }
  if (a2 != 8)
    goto LABEL_70;
  if (a1 == 1)
    return 10;
  if (a1 == 2)
    return 30;
  if (a1 == 4 && v12 == 1)
    return 70;
  if (a1 == 4 && v11)
    return 80;
LABEL_70:
  v16 = scn_default_log();
  if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    return 70;
  v18 = (BitmapInfo >> 12) & 7;
  if (v18 > 4)
    v19 = CFSTR("byteOrderUnknown");
  else
    v19 = off_1EA59F910[v18];
  if ((BitmapInfo & 0x1F) > 7)
    v20 = CFSTR("alphaUnknown");
  else
    v20 = off_1EA59F938[BitmapInfo & 0x1F];
  v21 = CFSTR("yes");
  v22 = 138414082;
  v23 = context;
  v24 = 1024;
  if ((BitmapInfo & 0x100) == 0)
    v21 = CFSTR("no");
  v25 = a1;
  v26 = 1024;
  v27 = a2;
  v28 = 1024;
  v29 = BitmapInfo;
  v30 = 2112;
  v31 = v19;
  v32 = 2112;
  v33 = v20;
  v34 = 2112;
  v35 = v21;
  v36 = 2112;
  v37 = ColorSpace;
  v14 = 70;
  _os_log_error_impl(&dword_1DCCB8000, v16, OS_LOG_TYPE_ERROR, "Error: Failed to create Metal pixel format for %@ [%d components, %d bits per component, bitmap info: %u (%@|%@), float components: %@, color space: %@]", (uint8_t *)&v22, 0x46u);
  return v14;
}

uint64_t C3DImageCacheBitmap(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CGImage *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CGContext *v19;
  CGContext *v20;
  CGImageAlphaInfo AlphaInfo;
  unsigned int v22;
  BOOL v24;
  unsigned __int8 *Data;
  unsigned __int8 *v26;
  unsigned int Width;
  unsigned int Height;
  size_t BitsPerComponent;
  size_t v30;
  size_t BytesPerRow;
  int v32;
  int v33;
  unsigned int v34;
  BOOL v35;
  int v36;
  unsigned int v37;
  NSObject *v38;
  uint64_t v39;
  float *v40;
  float *v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int16 *v44;
  unsigned __int16 *v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  int v50;
  BOOL v51;
  int v52;
  int HasAlpha;
  CGColorSpaceRef ColorSpace;
  int v55;
  double v56;
  NSObject *v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  int v62;
  uint64_t v63;
  __int16 v64;
  unsigned int v65;
  __int16 v66;
  unsigned int v67;
  __int16 v68;
  double v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  pthread_mutex_lock(&bitmapAccessSharedMutex);
  if (!*(_QWORD *)(a1 + 64)
    && *(_DWORD *)(a1 + 96) != 5
    && (*(_BYTE *)(a1 + 80) & 2) == 0
    && !C3DImageGetTextureRawData(a1))
  {
    kdebug_trace();
    v10 = C3DImageCopyCGImage(a1);
    if (*(_QWORD *)(a1 + 64) && (v11 = scn_default_log(), os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)))
    {
      C3DImageCacheBitmap_cold_2(v11, v12, v13, v14, v15, v16, v17, v18);
      if (!v10)
        goto LABEL_84;
    }
    else if (!v10)
    {
LABEL_84:
      kdebug_trace();
      return pthread_mutex_unlock(&bitmapAccessSharedMutex);
    }
    v19 = C3DCreateCGBitmapContextRefFromCGImageRef(v10);
    *(_QWORD *)(a1 + 64) = v19;
    if (!v19)
    {
      v38 = scn_default_log();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        C3DImageCacheBitmap_cold_1();
      goto LABEL_83;
    }
    if ((*(_BYTE *)(a1 + 116) & 4) != 0)
    {
LABEL_66:
      HasAlpha = C3DImageHasAlpha(a1);
      ColorSpace = CGBitmapContextGetColorSpace(*(CGContextRef *)(a1 + 64));
      if (ColorSpace != (CGColorSpaceRef)C3DColorSpaceExtendedLinearSRGB()
        && ColorSpace != (CGColorSpaceRef)C3DColorSpaceLinearGray()
        && ColorSpace != (CGColorSpaceRef)C3DColorSpaceLinearSRGB())
      {
        v55 = ColorSpace == (CGColorSpaceRef)C3DColorSpaceLinearDisplayP3() ? 0 : HasAlpha;
        if (v55 == 1 && (C3DImageNeedsUnpremultiply(a1) & 1) == 0)
        {
          if (C3DLinearRenderingIsEnabled())
          {
            v56 = CACurrentMediaTime();
            C3DBitmapFixIncorrectPremultiply(*(CGContext **)(a1 + 64));
            v57 = scn_default_log();
            if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
            {
              v58 = *(_DWORD *)(a1 + 96);
              if (v58 == 5)
              {
                v59 = *(_QWORD *)(a1 + 88);
              }
              else if (v58 == 1)
              {
                v59 = objc_msgSend(*(id *)(a1 + 88), "lastPathComponent");
              }
              else
              {
                v59 = 0;
              }
              v60 = *(_QWORD *)(a1 + 104);
              v62 = 138413058;
              v63 = v59;
              v64 = 1024;
              v65 = *(float *)&v60;
              v66 = 1024;
              v67 = *((float *)&v60 + 1);
              v68 = 2048;
              v69 = (CACurrentMediaTime() - v56) * 1000.0;
              _os_log_impl(&dword_1DCCB8000, v57, OS_LOG_TYPE_INFO, "Info: FixIncorrectPremultiply %@ time %u x %u : %fms", (uint8_t *)&v62, 0x22u);
            }
          }
        }
      }
LABEL_83:
      CGImageRelease(v10);
      goto LABEL_84;
    }
    v20 = v19;
    AlphaInfo = CGImageGetAlphaInfo(v10);
    v22 = AlphaInfo - 1;
    v24 = AlphaInfo == kCGImageAlphaOnly || v22 < 4;
    if (v22 > 3)
    {
LABEL_65:
      *(_BYTE *)(a1 + 116) = *(_BYTE *)(a1 + 116) & 0xFE | v24 | 4;
      goto LABEL_66;
    }
    Data = (unsigned __int8 *)CGBitmapContextGetData(v20);
    if (Data)
    {
      v26 = Data;
      Width = CGBitmapContextGetWidth(v20);
      Height = CGBitmapContextGetHeight(v20);
      BitsPerComponent = CGBitmapContextGetBitsPerComponent(v20);
      v30 = (CGBitmapContextGetBitsPerPixel(v20) / BitsPerComponent * BitsPerComponent) >> 3;
      BytesPerRow = CGBitmapContextGetBytesPerRow(v20);
      if (v30 == 4)
      {
        if (CGImageGetBitmapInfo(v10) == 0x2000)
          v32 = 0;
        else
          v32 = 3;
        if (Height)
        {
          v33 = 0;
          v34 = 0;
          v35 = 1;
          while (!Width)
          {
LABEL_31:
            v24 = 0;
            ++v34;
            v33 += BytesPerRow;
            v35 = v34 < Height;
            if (v34 == Height)
              goto LABEL_65;
          }
          v36 = v33 + v32;
          v37 = Width;
          while (v26[v36] >= 0xFEu)
          {
            v36 += 4;
            if (!--v37)
              goto LABEL_31;
          }
          v24 = v35;
          goto LABEL_65;
        }
        goto LABEL_64;
      }
      if ((CGBitmapContextGetBitmapInfo(v20) & 0x100) != 0)
      {
        if (v30 == 8)
        {
          if (Height)
          {
            v43 = 0;
            v44 = (unsigned __int16 *)(v26 + 6);
            while (1)
            {
              v45 = v44;
              v46 = Width;
              if (Width)
                break;
LABEL_62:
              v24 = 0;
              ++v43;
              v44 = (unsigned __int16 *)((char *)v44 + BytesPerRow);
              if (v43 == Height)
                goto LABEL_65;
            }
            while (1)
            {
              v48 = *v45;
              v45 += 4;
              v47 = v48;
              v49 = (v48 >> 10) & 0x1F;
              v50 = v49 == 31 ? 2139095040 : v49;
              v51 = !v49 || v49 == 31;
              v52 = v51 ? v50 : (v49 << 23) + 939524096;
              if (COERCE_FLOAT(v52 | (v47 << 16) & 0x80000000 | (v47 >> 7) & 7 | (8 * (v47 & 0x3FF)) & 0x1FFF | ((v47 & 0x3FF) << 13)) < 0.999)
                goto LABEL_79;
              if (!--v46)
                goto LABEL_62;
            }
          }
        }
        else if (v30 == 16 && Height)
        {
          v39 = 0;
          v40 = (float *)(v26 + 12);
          while (1)
          {
            v41 = v40;
            v42 = Width;
            if (Width)
              break;
LABEL_45:
            v24 = 0;
            ++v39;
            v40 = (float *)((char *)v40 + BytesPerRow);
            if (v39 == Height)
              goto LABEL_65;
          }
          while (*v41 >= 0.999)
          {
            v41 += 4;
            if (!--v42)
              goto LABEL_45;
          }
LABEL_79:
          v24 = 1;
          goto LABEL_65;
        }
      }
    }
LABEL_64:
    v24 = 0;
    goto LABEL_65;
  }
  return pthread_mutex_unlock(&bitmapAccessSharedMutex);
}

uint64_t C3DImageGetTextureRawData(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  pthread_mutex_lock(&bitmapAccessSharedMutex);
  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 80) & 2) != 0)
    *(_BYTE *)(a1 + 116) &= ~8u;
  C3DImageGetSize(a1);
  v10 = *(_QWORD *)(a1 + 72);
  pthread_mutex_unlock(&bitmapAccessSharedMutex);
  return v10;
}

double C3DImageGetSize(uint64_t a1)
{
  void *v2;
  const void *v3;
  const void *v4;
  CFTypeRef v5;
  CGContext *v6;
  size_t Height;
  uint64_t v8;
  int v9;
  const __CFData *v10;
  CGImageSourceRef v11;
  const __CFURL *v12;
  CGImageSource *v13;
  __CFDictionary *Mutable;
  const __CFDictionary *v15;
  uint64_t v16;
  const __CFNumber *Value;
  const __CFNumber *v18;
  const __CFNumber *v19;
  const __CFNumber *v20;
  _BOOL4 v21;
  const __CFNumber *v22;
  const __CFNumber *v23;
  const __CFNumber *v24;
  const __CFNumber *v25;
  float v26;
  float v27;
  float v28;
  float v29;
  uint64_t v30;
  CGImage *v31;
  CGImage *v32;
  char v33;
  char v34;
  NSObject *v36;
  float Width;
  uint64_t v38;
  uint64_t v39;
  uint64_t valuePtr;

  if ((*(_BYTE *)(a1 + 116) & 8) == 0)
  {
    *(_QWORD *)(a1 + 104) = 0;
    if (_mayBeASTC(a1))
    {
      if (C3DASTCIsSupported() && (_loadASTC(a1) & 1) != 0)
        goto LABEL_62;
      if ((_mayBeKTX(a1) & 1) == 0)
      {
LABEL_9:
        if ((C3DASTCIsSupported() & 1) == 0 && *(_DWORD *)(a1 + 96) == 1)
        {
          v2 = *(void **)(a1 + 88);
          if (v2)
          {
            v3 = (const void *)objc_msgSend((id)objc_msgSend(v2, "URLByDeletingPathExtension"), "URLByAppendingPathExtension:", CFSTR("pvrtc"));
            if (C3DFileMayExistAtURL((const __CFURL *)v3))
            {
              v4 = *(const void **)(a1 + 88);
              if (v4 != v3)
              {
                if (v4)
                {
                  CFRelease(v4);
                  *(_QWORD *)(a1 + 88) = 0;
                }
                if (v3)
                  v5 = CFRetain(v3);
                else
                  v5 = 0;
                *(_QWORD *)(a1 + 88) = v5;
              }
            }
          }
        }
LABEL_20:
        if (_mayBePVRTC(a1) && (_loadPVRTC(a1) & 1) != 0)
          goto LABEL_62;
        pthread_mutex_lock(&bitmapAccessSharedMutex);
        v6 = *(CGContext **)(a1 + 64);
        if (v6)
        {
          Width = (float)CGBitmapContextGetWidth(v6);
          Height = CGBitmapContextGetHeight(*(CGContextRef *)(a1 + 64));
          *(float *)&v8 = Width;
          *((float *)&v8 + 1) = (float)Height;
          *(_QWORD *)(a1 + 104) = v8;
          pthread_mutex_unlock(&bitmapAccessSharedMutex);
          goto LABEL_62;
        }
        pthread_mutex_unlock(&bitmapAccessSharedMutex);
        v9 = *(_DWORD *)(a1 + 96);
        if (v9 == 1)
        {
          v12 = *(const __CFURL **)(a1 + 88);
          if (v12)
          {
            v11 = C3DCreateImageSourceWithURL(v12);
            goto LABEL_30;
          }
        }
        else if (v9 == 2)
        {
          v10 = *(const __CFData **)(a1 + 88);
          if (v10)
          {
            v11 = CGImageSourceCreateWithData(v10, 0);
LABEL_30:
            v13 = v11;
            if (v11)
            {
              Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CBD240], (const void *)*MEMORY[0x1E0C9AE40]);
              v15 = CGImageSourceCopyPropertiesAtIndex(v13, 0, Mutable);
              CFRelease(Mutable);
              v16 = 0;
              if (v15)
              {
                Value = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x1E0CBD048]);
                v18 = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x1E0CBD040]);
                v19 = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x1E0CBCFF0]);
                if (Value && v18)
                {
                  v20 = v19;
                  valuePtr = 0;
                  CFNumberGetValue(Value, kCFNumberFloatType, (char *)&valuePtr + 4);
                  CFNumberGetValue(v18, kCFNumberFloatType, &valuePtr);
                  if (v20)
                  {
                    HIDWORD(v39) = 0;
                    CFNumberGetValue(v20, kCFNumberIntType, (char *)&v39 + 4);
                    v21 = SHIDWORD(v39) > 4;
                  }
                  else
                  {
                    v21 = 0;
                  }
                  v22 = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x1E0CBC9F8]);
                  if (v22)
                  {
                    v23 = v22;
                    v24 = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x1E0CBCA00]);
                    if (v24)
                    {
                      v25 = v24;
                      v39 = 0;
                      CFNumberGetValue(v23, kCFNumberFloatType, (char *)&v39 + 4);
                      CFNumberGetValue(v25, kCFNumberFloatType, &v39);
                      if (*((float *)&v39 + 1) != *(float *)&v39 && *(float *)&v39 > 0.01)
                      {
                        v26 = *(float *)&v39 / *((float *)&v39 + 1);
                        if (*(float *)&v39 <= *((float *)&v39 + 1))
                          v26 = 1.0;
                        if (*((float *)&v39 + 1) <= *(float *)&v39)
                          v27 = 1.0;
                        else
                          v27 = *((float *)&v39 + 1) / *(float *)&v39;
                        if (v21)
                          v28 = v26;
                        else
                          v28 = v27;
                        if (!v21)
                          v27 = v26;
                        *(float *)&valuePtr = v27 * *(float *)&valuePtr;
                        *((float *)&valuePtr + 1) = v28 * *((float *)&valuePtr + 1);
                      }
                    }
                  }
                  v29 = *(float *)&valuePtr;
                  if (v21)
                    *(float *)&v30 = *(float *)&valuePtr;
                  else
                    *(float *)&v30 = *((float *)&valuePtr + 1);
                  if (v21)
                    v29 = *((float *)&valuePtr + 1);
                  *((float *)&v30 + 1) = v29;
                  v38 = v30;
                  CFRelease(v15);
                  v16 = v38;
                }
                else
                {
                  CFRelease(v15);
                  v16 = 0;
                }
              }
              *(_QWORD *)(a1 + 104) = v16;
              CFRelease(v13);
              if (COERCE_FLOAT(*(_QWORD *)(a1 + 104)) > 0.0)
                goto LABEL_62;
            }
          }
        }
        v31 = C3DImageCopyCGImage(a1);
        if (!v31)
        {
          if ((C3DIsRunningInSCNTool() & 1) == 0)
          {
            v36 = scn_default_log();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
              C3DImageGetSize_cold_1();
          }
          *(_BYTE *)(a1 + 116) |= 0x28u;
          if (C3DImageIsCubeMap(a1))
            v34 = 16;
          else
            v34 = 0;
          v33 = *(_BYTE *)(a1 + 116);
          goto LABEL_63;
        }
        v32 = v31;
        *(float *)(a1 + 104) = (float)CGImageGetWidth(v31);
        *(float *)(a1 + 108) = (float)CGImageGetHeight(v32);
        CFRelease(v32);
LABEL_62:
        v33 = *(_BYTE *)(a1 + 116) | 0x28;
        v34 = 16;
LABEL_63:
        *(_BYTE *)(a1 + 116) = v33 & 0xEF | v34;
        return *(double *)(a1 + 104);
      }
    }
    else if (!_mayBeKTX(a1))
    {
      goto LABEL_20;
    }
    if ((_loadKTX(a1) & 1) != 0)
      goto LABEL_62;
    goto LABEL_9;
  }
  return *(double *)(a1 + 104);
}

CGImageRef C3DImageCopyCGImage(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *Image;
  CGContext *v11;
  uint64_t URL;
  const __CFURL *v14;
  const __CFData *v15;
  const __CFData *v16;
  CGImageSource *v17;
  CGImageSourceRef v18;
  CGImageSource *v19;
  const __CFData *Data;
  NSObject *v21;
  NSObject *v22;
  CGImage *v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[2];

  v28[1] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(_DWORD *)(a1 + 96) != 3)
  {
    pthread_mutex_lock(&bitmapAccessSharedMutex);
    v11 = *(CGContext **)(a1 + 64);
    if (v11)
    {
LABEL_7:
      Image = CGBitmapContextCreateImage(v11);
LABEL_8:
      pthread_mutex_unlock(&bitmapAccessSharedMutex);
      return (CGImageRef)Image;
    }
    URL = C3DImageGetURL(a1);
    if (URL)
    {
      v14 = (const __CFURL *)URL;
      v24 = 0;
      v15 = (const __CFData *)C3DImageCopyUSDZEmbeddedData(a1, &v24);
      if (v15)
      {
        v16 = v15;
        v17 = CGImageSourceCreateWithData(v15, 0);
        CFRelease(v16);
        if (v17)
        {
          v27 = *MEMORY[0x1E0CBD238];
          v28[0] = MEMORY[0x1E0C9AAB0];
          Image = CGImageSourceCreateImageAtIndex(v17, 0, (CFDictionaryRef)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v28, &v27, 1));
          CFRelease(v17);
          goto LABEL_8;
        }
      }
      if (v24)
        goto LABEL_29;
      v18 = C3DCreateImageSourceWithURL(v14);
      if (v18)
      {
        v19 = v18;
LABEL_19:
        v25 = *MEMORY[0x1E0CBD238];
        v26 = MEMORY[0x1E0C9AAB0];
        Image = CGImageSourceCreateImageAtIndex(v19, 0, (CFDictionaryRef)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
        if (!Image)
        {
          v21 = scn_default_log();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            C3DImageCopyCGImage_cold_2(v19, v21);
        }
        CFRelease(v19);
        if (Image)
          goto LABEL_8;
        goto LABEL_28;
      }
      v23 = (CGImage *)SCNFindImageNamedInAppBundle(v14);
      if (v23)
      {
        Image = v23;
        CGImageRetain(v23);
        goto LABEL_8;
      }
    }
    else
    {
      Data = (const __CFData *)C3DImageGetData(a1);
      if (Data)
      {
        v19 = CGImageSourceCreateWithData(Data, 0);
        if (v19)
          goto LABEL_19;
        v22 = scn_default_log();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          C3DImageCopyCGImage_cold_1();
      }
    }
    if (*(_DWORD *)(a1 + 96) == 4)
    {
      Image = (void *)SCNCopyCGImageFromImage(*(void **)(a1 + 88));
      if (Image)
        goto LABEL_8;
    }
LABEL_28:
    v11 = *(CGContext **)(a1 + 64);
    if (v11)
      goto LABEL_7;
LABEL_29:
    Image = 0;
    goto LABEL_8;
  }
  return CGImageRetain(*(CGImageRef *)(a1 + 88));
}

uint64_t C3DColorSpaceLinearSRGB()
{
  if (C3DColorSpaceLinearSRGB_onceToken != -1)
    dispatch_once(&C3DColorSpaceLinearSRGB_onceToken, &__block_literal_global_3);
  return C3DColorSpaceLinearSRGB_kC3DColorSpaceLinearSRGB;
}

uint64_t C3DColorSpaceLinearGray()
{
  if (C3DColorSpaceLinearGray_onceToken != -1)
    dispatch_once(&C3DColorSpaceLinearGray_onceToken, &__block_literal_global_7);
  return C3DColorSpaceLinearGray_kC3DColorSpaceLinearGray;
}

uint64_t C3DColorSpaceLinearDisplayP3()
{
  if (C3DColorSpaceLinearDisplayP3_onceToken != -1)
    dispatch_once(&C3DColorSpaceLinearDisplayP3_onceToken, &__block_literal_global_15);
  return C3DColorSpaceLinearDisplayP3_kC3DColorSpaceLinearDisplayP3;
}

uint64_t C3DColorSpaceExtendedLinearSRGB()
{
  if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1)
    dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_11);
  return C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB;
}

uint64_t _mayBePVRTC(uint64_t a1)
{
  _BOOL8 v2;
  __CFString *v3;
  __CFString *v4;

  if (C3DImageGetData(a1))
    return 1;
  v3 = copyPathExtension(a1);
  if (!v3)
    return 0;
  v4 = v3;
  v2 = CFEqual(v3, CFSTR("pvr")) || CFEqual(v4, CFSTR("pvrtc"));
  CFRelease(v4);
  return v2;
}

uint64_t _mayBeKTX(uint64_t a1)
{
  _BOOL8 v2;
  __CFString *v3;
  __CFString *v4;

  if (C3DImageGetData(a1))
    return 1;
  v3 = copyPathExtension(a1);
  if (!v3)
    return 0;
  v4 = v3;
  v2 = CFEqual(v3, CFSTR("ktx")) != 0;
  CFRelease(v4);
  return v2;
}

__CFString *copyPathExtension(uint64_t a1)
{
  const __CFURL *URL;
  const __CFString *v2;
  const __CFString *v3;
  __CFString *MutableCopy;

  URL = (const __CFURL *)C3DImageGetURL(a1);
  if (!URL)
    return 0;
  v2 = CFURLCopyPathExtension(URL);
  if (!v2)
    return 0;
  v3 = v2;
  MutableCopy = CFStringCreateMutableCopy(0, 0, v2);
  CFStringLowercase(MutableCopy, 0);
  CFRelease(v3);
  return MutableCopy;
}

uint64_t C3DImageGetURL(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(_DWORD *)(a1 + 96) == 1)
    return *(_QWORD *)(a1 + 88);
  else
    return 0;
}

uint64_t C3DImageGetData(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(_DWORD *)(a1 + 96) == 2)
    return *(_QWORD *)(a1 + 88);
  else
    return 0;
}

uint64_t _mayBeASTC(uint64_t a1)
{
  _BOOL8 v2;
  __CFString *v3;
  __CFString *v4;

  if (C3DImageGetData(a1))
    return 1;
  v3 = copyPathExtension(a1);
  if (!v3)
    return 0;
  v4 = v3;
  v2 = CFEqual(v3, CFSTR("ast")) || CFEqual(v4, CFSTR("astc"));
  CFRelease(v4);
  return v2;
}

CGContext *C3DCreateCGBitmapContextRefFromCGImageRef(CGImage *a1)
{
  unint64_t Width;
  unint64_t Height;
  __int16 BitmapInfo;
  CGColorSpace *ColorSpace;
  CGColorSpace *v6;
  CGColorSpaceRef BaseColorSpace;
  _BOOL4 IsWideGamutRGB;
  _BOOL4 v9;
  int v10;
  size_t v11;
  uint32_t v12;
  size_t v13;
  uint64_t v14;
  CGColorSpace *v15;
  CGContext *v16;
  CGContext *v17;
  NSObject *v18;
  int v20;
  CGImage *v21;
  uint64_t v22;
  CGRect v23;

  v22 = *MEMORY[0x1E0C80C00];
  Width = CGImageGetWidth(a1);
  Height = CGImageGetHeight(a1);
  BitmapInfo = CGImageGetBitmapInfo(a1);
  ColorSpace = CGImageGetColorSpace(a1);
  if (!ColorSpace)
  {
    if ((BitmapInfo & 0x100) == 0)
    {
      C3DWideGamutIsUsed();
      v9 = 1;
      goto LABEL_9;
    }
LABEL_16:
    v11 = 8 * Width;
    v12 = 4353;
    v13 = 16;
    v14 = C3DColorSpaceExtendedLinearSRGB();
LABEL_17:
    v15 = (CGColorSpace *)v14;
    goto LABEL_18;
  }
  v6 = ColorSpace;
  BaseColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
  if (BaseColorSpace)
    v6 = BaseColorSpace;
  IsWideGamutRGB = CGColorSpaceIsWideGamutRGB(v6);
  if ((BitmapInfo & 0x100) != 0 || (C3DWideGamutIsUsed() & IsWideGamutRGB) == 1)
    goto LABEL_16;
  v9 = CGColorSpaceGetNumberOfComponents(v6) == 1;
LABEL_9:
  v10 = BitmapInfo & 0x1F;
  if ((BitmapInfo & 0x1F) != 0 || !v9 || (C3DWasLinkedBeforeMajorOSYear2016() & 1) != 0)
  {
    v11 = 4 * Width;
    if (v10)
      v12 = 16385;
    else
      v12 = 16389;
    v13 = 8;
    v14 = C3DColorSpaceSRGB();
    goto LABEL_17;
  }
  v13 = 8;
  v15 = (CGColorSpace *)C3DColorSpaceGray();
  v12 = 0;
  v11 = Width;
LABEL_18:
  v16 = CGBitmapContextCreate(0, Width, Height, v13, v11, v15, v12);
  v17 = v16;
  if (v16)
  {
    v23.size.width = (double)Width;
    v23.size.height = (double)Height;
    v23.origin.x = 0.0;
    v23.origin.y = 0.0;
    CGContextDrawImage(v16, v23, a1);
  }
  else
  {
    v18 = scn_default_log();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      v20 = 138412290;
      v21 = a1;
      _os_log_impl(&dword_1DCCB8000, v18, OS_LOG_TYPE_DEFAULT, "Warning: Failed to create bitmap context for CG image %@", (uint8_t *)&v20, 0xCu);
    }
  }
  return v17;
}

uint64_t C3DColorSpaceSRGB()
{
  if (C3DColorSpaceSRGB_onceToken != -1)
    dispatch_once(&C3DColorSpaceSRGB_onceToken, &__block_literal_global_4);
  return C3DColorSpaceSRGB_kC3DColorSpaceSRGB;
}

uint64_t C3DImageTypeToMTLTextureType(int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 8)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageTypeToMTLTextureType_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return mtl_TextureType[a1];
}

int32x2_t C3DImageGetTextureSize(uint64_t a1)
{
  int32x2_t result;
  float v3;

  *(double *)&result = C3DImageGetSize(a1);
  switch(*(_DWORD *)(a1 + 120))
  {
    case 2:
    case 4:
      return vdup_lane_s32(result, 1);
    case 5:
      goto LABEL_6;
    case 6:
      v3 = *(float *)&result.i32[1] / 3.0;
      goto LABEL_5;
    case 7:
      v3 = *(float *)&result.i32[1] * 0.25;
LABEL_5:
      *(float *)result.i32 = ceilf(v3);
LABEL_6:
      result = vdup_lane_s32(result, 0);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t C3DImageGetDepth(uint64_t a1)
{
  uint32x2_t v1;

  if (*(_DWORD *)(a1 + 120) != 2)
    return 1;
  v1 = vcvt_u32_f32(vrnda_f32(COERCE_FLOAT32X2_T(C3DImageGetSize(a1))));
  if (v1.i32[0] <= (unsigned __int32)v1.i32[1])
    return v1.i32[1] / (unsigned __int32)v1.i32[0];
  else
    return v1.i32[0] / (unsigned __int32)v1.i32[1];
}

CFTypeRef C3DImageCopyBitmap(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  BOOL v13;
  CFTypeRef v14;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  pthread_mutex_lock(&bitmapAccessSharedMutex);
  v12 = *(const void **)(a1 + 64);
  if (v12)
    v13 = 1;
  else
    v13 = a2 == 0;
  if (!v13)
  {
    C3DImageCacheBitmap(a1);
    v12 = *(const void **)(a1 + 64);
  }
  if (v12)
    v14 = CFRetain(v12);
  else
    v14 = 0;
  pthread_mutex_unlock(&bitmapAccessSharedMutex);
  return v14;
}

uint64_t C3DImageNeedsUnpremultiply(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DImageGetURL_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(unsigned __int8 *)(a1 + 116) >> 1) & 1;
}

uint64_t C3DTextureSamplerGetWrapModeT(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 20);
}

uint64_t C3DTextureSamplerGetWrapModeS(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 16);
}

uint64_t C3DTextureSamplerGetMinFilter(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 28);
}

uint64_t C3DTextureSamplerGetMagFilter(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 32);
}

float C3DTextureSamplerGetAnisotropy(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DTextureSamplerSetAnisotropy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 64);
}

size_t C3DBitmapFixIncorrectPremultiply(CGContext *a1)
{
  unsigned int Width;
  int Height;
  size_t result;
  int *v5;
  size_t BitsPerComponent;
  uint64_t v7;
  uint32x4_t v8;
  int8x16_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  uint64_t v33;
  int *v34;
  const float *v35;
  const float *v36;
  uint32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int8x16_t v56;
  int32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  int8x16_t v61;
  float32x4_t v62;
  int32x4_t v63;
  float32x4_t v64;
  int8x16_t v65;
  int8x16_t v66;
  __int32 v67;
  __int32 v68;
  __int32 v69;
  __int32 v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;

  Width = CGBitmapContextGetWidth(a1);
  Height = CGBitmapContextGetHeight(a1);
  result = (size_t)CGBitmapContextGetData(a1);
  if (result)
  {
    v5 = (int *)result;
    BitsPerComponent = CGBitmapContextGetBitsPerComponent(a1);
    result = CGBitmapContextGetBitsPerPixel(a1);
    if (((result / BitsPerComponent * BitsPerComponent) & 0xFFFFFFFFFFFFFFF8) == 0x20)
    {
      result = CGBitmapContextGetBytesPerRow(a1);
      if (Height)
      {
        v7 = 0;
        v8 = (uint32x4_t)xmmword_1DD008EA0;
        v9.i64[0] = 0xFF000000FFLL;
        v9.i64[1] = 0xFF000000FFLL;
        v10 = (float32x4_t)vdupq_n_s32(0x3E1C096Eu);
        v11 = (float32x4_t)vdupq_n_s32(0xBF12862E);
        v12 = (float32x4_t)vdupq_n_s32(0x3F6BC556u);
        v13 = (float32x4_t)vdupq_n_s32(0xBF66EEDE);
        v14 = (float32x4_t)vdupq_n_s32(0x3F622C5Fu);
        v15 = (float32x4_t)vdupq_n_s32(0x3EF653C9u);
        v16 = (float32x4_t)vdupq_n_s32(0x3D11FA77u);
        v17 = (float32x4_t)vdupq_n_s32(0x3A5DBC4Du);
        v18 = (float32x4_t)vdupq_n_s32(0x3D9E8391u);
        v19 = (float32x4_t)vdupq_n_s32(0x3D25AEE6u);
        v20 = (float32x4_t)vdupq_n_s32(0xC5D0CBF7);
        v21 = (float32x4_t)vdupq_n_s32(0x44991F14u);
        v22 = (float32x4_t)vdupq_n_s32(0xC2C877E1);
        v23 = (float32x4_t)vdupq_n_s32(0x40D350C9u);
        v24 = (float32x4_t)vdupq_n_s32(0x3D7A766Bu);
        v25 = (float32x4_t)vdupq_n_s32(0xB9693F28);
        v26 = (float32x4_t)vdupq_n_s32(0x34DD5C9Cu);
        v27 = (float32x4_t)vdupq_n_s32(0xAFC12644);
        v28 = (float32x4_t)vdupq_n_s32(0xBE3FCBA9);
        v29 = (float32x4_t)vdupq_n_s32(0x3F259300u);
        v30 = (float32x4_t)vdupq_n_s32(0xBF7D862E);
        v31 = (float32x4_t)vdupq_n_s32(0x3F9ACD51u);
        v75 = (float32x4_t)vdupq_n_s32(0xBC5C6168);
        v76 = (float32x4_t)vdupq_n_s32(0x3EAB2DE7u);
        v73 = (float32x4_t)vdupq_n_s32(0xB6DEE3CF);
        v74 = (float32x4_t)vdupq_n_s32(0x39E887D3u);
        v32 = (float32x4_t)vdupq_n_s32(0x3D563886u);
        v71 = (float32x4_t)vdupq_n_s32(0x3B808081u);
        v72 = v10;
        do
        {
          v33 = Width;
          v34 = v5;
          if (Width)
          {
            do
            {
              v35 = (const float *)v34;
              v37 = (uint32x4_t)vld1q_dup_f32(v35);
              v36 = v35 + 1;
              v39 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, v8), v9));
              v38 = vmulq_f32(v39, v71);
              v39.i32[0] = v38.i32[3];
              if (v38.f32[3] <= 0.0)
                v39.f32[0] = 0.0001;
              v40 = vdivq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 0));
              v41 = vmulq_f32(v40, v40);
              v42 = vmlaq_f32(v15, v14, v40);
              v43 = v14;
              v44 = v13;
              v45 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(v17, v16, v40), v41, v42), vmulq_f32(v41, v41), vmlaq_f32(vmlaq_f32(v13, v12, v40), v41, vmlaq_f32(v11, v10, v40)));
              v46 = (int8x16_t)vmulq_f32(v40, v18);
              v47 = vcgeq_f32(v40, v19);
              v47.i32[3] = 0;
              v48 = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v47), v45, v46), v39.f32[0]);
              v49 = vmulq_f32(v48, v48);
              v50 = vmulq_f32(v48, v49);
              v50.i32[3] = 0;
              v51 = vmlaq_f32(vmlaq_f32(v23, v22, v48), v49, vmlaq_f32(v21, v20, v48));
              v52 = vmlaq_f32(vmlaq_f32(v27, v26, v48), v49, vmlaq_f32(v25, v24, v48));
              v53 = vmlaq_f32(vmlaq_f32(v31, v30, v48), v49, vmlaq_f32(v29, v28, v48));
              v54 = vmlaq_f32(vmlaq_f32(v73, v74, v48), v49, vmlaq_f32(v75, v76, v48));
              v55 = vmulq_f32(v49, v49);
              v56 = (int8x16_t)vmlaq_f32(v52, v55, v51);
              v57 = vcgeq_f32(v48, v32);
              v57.i32[3] = 0;
              v58 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v57), (int8x16_t)vmlaq_f32(v54, v55, v53), v56);
              v13 = v44;
              v14 = v43;
              v59 = vrecpeq_f32(v50);
              v60 = vmulq_f32(v59, vrecpsq_f32(v50, v59));
              v10 = v72;
              v61 = (int8x16_t)vmulq_f32(vmulq_f32(v60, vrecpsq_f32(v50, v60)), v58);
              v62 = vmulq_f32(v48, (float32x4_t)vdupq_n_s32(0x414EB852u));
              v63 = vcgeq_f32(v48, (float32x4_t)vdupq_n_s32(0x3B4D2E1Cu));
              v63.i32[3] = 0;
              v64 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v63), v61, (int8x16_t)v62);
              v64.i32[3] = v39.i32[0];
              v62.i64[0] = 0x3F0000003F000000;
              v62.i64[1] = 0x3F0000003F000000;
              v65 = (int8x16_t)vcvtq_s32_f32(vmlaq_f32(v62, (float32x4_t)vdupq_n_s32(0x437F0000u), v64));
              v9.i64[0] = 0xFF000000FFLL;
              v9.i64[1] = 0xFF000000FFLL;
              v66 = vandq_s8(v65, v9);
              v67 = v66.i32[1];
              v68 = v66.i32[0];
              *(uint32x2_t *)v66.i8 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v66, v66, 8uLL), (uint32x2_t)0x1800000010);
              v69 = v66.i32[1];
              v70 = v66.i32[0];
              v8 = (uint32x4_t)xmmword_1DD008EA0;
              *v34 = v68 | (v67 << 8) | v70 | v69;
              v34 = (int *)v36;
              --v33;
            }
            while (v33);
          }
          ++v7;
          v5 = (int *)((char *)v5 + result);
        }
        while (v7 != Height);
      }
    }
  }
  return result;
}

uint64_t C3DWrapModeToMTLAddressMode(int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 5)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DWrapModeToMTLAddressMode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return mtl_AddressMode[a1];
}

uint64_t scn_default_log()
{
  if (scn_default_log_once != -1)
    dispatch_once(&scn_default_log_once, &__block_literal_global_10);
  return scn_default_log_logger;
}

uint64_t C3DFilterModeToMTLFilter(int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 3)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DFilterModeToMTLFilter_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return mtl_FilterMode[a1];
}

uint64_t C3D::RenderGraphResourceManager::get(C3D::RenderGraphResourceManager *this, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  uint64_t result;
  uint64_t v6;

  v2 = (*((_DWORD *)this + 7) - 1) & a2;
  v3 = *(unsigned __int16 *)(*((_QWORD *)this + 2) + 2 * v2);
  if (v3 < 2)
    return 0;
  while ((v3 & 2) == 0 || *(_QWORD *)(*(_QWORD *)this + 8 * v2) != a2)
  {
    ++v2;
    v4 = v3 >= 4;
    v3 >>= 1;
    if (!v4)
      return 0;
  }
  v6 = *((_QWORD *)this + 1);
  if (!v6)
    return 0;
  result = *(_QWORD *)(v6 + 8 * v2);
  *(_BYTE *)(result + 8) = 0;
  return result;
}

uint64_t C3DLightingSystemEnumerateRadianceProbes(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(unsigned int *)(result + 84);
  if ((_DWORD)v2)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(a2 + 16))(a2, v2, *(_QWORD *)(result + 176), *(_QWORD *)(result + 240), *(_QWORD *)(result + 480));
  return result;
}

void C3D::Array<unsigned int,0u,C3D::MallocAllocator>::resize(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v5;
  int v6;

  v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != a2)
  {
    if (v2 <= a2)
    {
      v5 = *(_DWORD *)(a1 + 4);
      v6 = a2 - v5;
      if (a2 > v5)
      {
        C3D::Array<unsigned int,0u,C3D::MallocAllocator>::GrowCapacityBy((unsigned int *)a1, v6, 0);
        v2 = *(_DWORD *)a1;
      }
      bzero((void *)(*(_QWORD *)(a1 + 8) + 4 * v2), 4 * (a2 - v2));
    }
    *(_DWORD *)a1 = a2;
  }
}

void C3D::Array<unsigned int,0u,C3D::MallocAllocator>::GrowCapacityBy(unsigned int *a1, int a2, int a3)
{
  unsigned int *v4;
  double v5;
  unsigned int v6;
  void *v7;

  v4 = (unsigned int *)*((_QWORD *)a1 + 1);
  v5 = 1.5;
  if (a3)
    v5 = 1.0;
  v6 = (v5 * (double)(a1[1] + a2));
  v7 = malloc_type_malloc(4 * v6, 0x74F3E194uLL);
  memcpy(v7, v4, 4 * *a1);
  *((_QWORD *)a1 + 1) = v7;
  a1[1] = v6;
  if (v4 != a1 + 4)
    free(v4);
}

uint64_t C3D::Array<void const*,0u,C3D::MallocAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  NSObject *v4;

  if (*(_DWORD *)a1 <= a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3D::Array<unsigned int,0u,C3D::MallocAllocator>::operator[]();
  }
  return *(_QWORD *)(a1 + 8) + 8 * a2;
}

void C3D::Array<void const*,0u,C3D::MallocAllocator>::resize(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v5;
  int v6;

  v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != a2)
  {
    if (v2 <= a2)
    {
      v5 = *(_DWORD *)(a1 + 4);
      v6 = a2 - v5;
      if (a2 > v5)
      {
        C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::GrowCapacityBy((unsigned int *)a1, v6, 0);
        v2 = *(_DWORD *)a1;
      }
      bzero((void *)(*(_QWORD *)(a1 + 8) + 8 * v2), 8 * (a2 - v2));
    }
    *(_DWORD *)a1 = a2;
  }
}

void C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::GrowCapacityBy(unsigned int *a1, int a2, int a3)
{
  unsigned int *v4;
  double v5;
  unsigned int v6;
  void *v7;

  v4 = (unsigned int *)*((_QWORD *)a1 + 1);
  v5 = 1.5;
  if (a3)
    v5 = 1.0;
  v6 = (v5 * (double)(a1[1] + a2));
  v7 = malloc_type_malloc(8 * v6, 0x74F3E194uLL);
  memcpy(v7, v4, 8 * *a1);
  *((_QWORD *)a1 + 1) = v7;
  a1[1] = v6;
  if (v4 != a1 + 4)
    free(v4);
}

uint64_t C3D::RenderGraph::createPersistentResource(uint64_t a1, uint64_t a2)
{
  uint64_t Aligned;
  uint64_t result;

  Aligned = C3DScratchAllocatorAllocateAligned(*(_QWORD *)(a1 + 16), 40, 8, 0);
  result = C3D::RefCountedResource::RefCountedResource(Aligned);
  *(_QWORD *)result = a2;
  *(_WORD *)(result + 32) = 1;
  *(_BYTE *)(result + 34) |= 1u;
  return result;
}

uint64_t SCNMTLComputeCommandEncoder::endEncoding(SCNMTLComputeCommandEncoder *this)
{
  MTLComputeCommandEncoder **p_encoder;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  p_encoder = &this->_encoder;
  if (!this->_encoder)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      SCNMTLComputeCommandEncoder::endEncoding(v2, v3, v4);
  }
  result = -[MTLComputeCommandEncoder endEncoding](*p_encoder, "endEncoding");
  *p_encoder = 0;
  p_encoder[1] = 0;
  return result;
}

uint64_t SCNMTLPixelFormatIsWritable()
{
  MTLPixelFormatGetInfoForDevice();
  return 0;
}

uint64_t SCNMTLDeviceSupportsColorRenderingInPixelFormat()
{
  MTLPixelFormatGetInfoForDevice();
  return 0;
}

uint64_t C3DSceneGetLightingEnvironmentTimeStamp(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 320);
}

uint64_t C3DFilterModeToMTLMipFilter(int a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 >= 3)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DFilterModeToMTLFilter_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return mtl_MipFilterMode[a1];
}

uint64_t C3DFXMetalProgramGetSourceCode(CFTypeRef cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeID v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DResourceManagerMakeProgramResident_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
  }
  return *((_QWORD *)cf + 12);
}

uint64_t C3DFXMetalProgramGetPreprocessorsMacros(CFTypeRef cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeID v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DResourceManagerMakeProgramResident_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
  }
  return *((_QWORD *)cf + 14);
}

uint64_t C3DFXMetalProgramGetLanguageVersion(unsigned int *cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeID v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DResourceManagerMakeProgramResident_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = CFGetTypeID(cf);
  if (C3DFXMetalProgramGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXMetalProgramGetTypeID_onceToken, &__block_literal_global_139);
  if (v10 != C3DFXMetalProgramGetTypeID_typeID)
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      C3DFXMetalProgramGetHash_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
  }
  return cf[44];
}

void _C3DIndexSetCFFinalize(uint64_t a1)
{
  void *v1;

  if ((*(_BYTE *)(a1 + 16) & 2) == 0)
  {
    v1 = *(void **)(a1 + 24);
    if (v1)
      free(v1);
  }
}

CFIndex C3DEnginePipelineApplyNotificationQueue(uint64_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t NotificationQueue;
  uint64_t v12;
  int v13;
  uint64_t PointOfViewIfAny;
  const __CFDictionary *Camera;
  int v16;
  int v17;
  _BOOL4 v18;
  int v19;
  const __CFDictionary *LightingSystem;
  const void *TypeID;
  const void *v22;
  const void *v23;
  const void *v24;
  uint64_t RendererElementStore;
  unsigned int Capacity;
  uint64_t ProgramHashCodeStore;
  uint64_t SortSystem;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      __ApplyMaterialDidChange_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *a1;
  NotificationQueue = C3DEnginePipelineGetNotificationQueue(*a1);
  v12 = NotificationQueue;
  if (NotificationQueue)
    v13 = C3DEngineNotificationQueueNeedsFullReset(NotificationQueue);
  else
    v13 = 0;
  PointOfViewIfAny = C3DEngineContextGetPointOfViewIfAny(a1[1]);
  v16 = PointOfViewIfAny
     && (Camera = C3DNodeGetCamera(PointOfViewIfAny)) != 0
     && C3DCameraGetScreenSpaceAmbientOcclusionIntensity((uint64_t)Camera) > 0.0;
  v17 = *(unsigned __int8 *)(v10 + 58);
  v18 = v17 != v16;
  if (v17 != v16)
    *(_BYTE *)(v10 + 58) = v16;
  v19 = C3DSceneGetFogEndDistance(*(_QWORD *)(v10 + 16)) > 0.0;
  if (*(unsigned __int8 *)(v10 + 56) != v19)
  {
    *(_BYTE *)(v10 + 56) = v19;
    v18 = 1;
  }
  if (!C3DEngineContextIsClusteredShadingEnabled(a1[1])
    || (LightingSystem = (const __CFDictionary *)C3DSceneGetLightingSystem(*(_QWORD *)(v10 + 16))) == 0)
  {
    if (!v18)
      goto LABEL_21;
    goto LABEL_20;
  }
  if (((v18 | C3DLightingSystemGetGlobalLightHashCodeForCaching(LightingSystem, a1[1], v10 + 60)) & 1) != 0)
LABEL_20:
    C3DRendererElementStoreApplyForAllRendererElements(*(_QWORD *)(v10 + 48), (uint64_t)__ResyncRendererElements, v10);
LABEL_21:
  if (v12)
  {
    C3DEngineNotificationQueueSwapForApplying(v12);
    if (v13)
    {
      __ResyncAllNodes(a1);
    }
    else
    {
      TypeID = (const void *)C3DNodeGetTypeID();
      C3DEngineNotificationQueueApplyForEntityType(v12, TypeID, (void (__cdecl *)(const void *, const void *, void *))__HandleNodeNotification, a1);
      v22 = (const void *)C3DGeometryGetTypeID();
      C3DEngineNotificationQueueApplyForEntityType(v12, v22, (void (__cdecl *)(const void *, const void *, void *))__HandleGeometryDidChangeNotifications, a1);
      v23 = (const void *)C3DMaterialGetTypeID();
      C3DEngineNotificationQueueApplyForEntityType(v12, v23, (void (__cdecl *)(const void *, const void *, void *))__HandleMaterialDidChangeNotifications, a1);
      v24 = (const void *)C3DLightGetTypeID();
      C3DEngineNotificationQueueApplyForEntityType(v12, v24, (void (__cdecl *)(const void *, const void *, void *))__HandleLightDidChangeNotifications, a1);
    }
  }
  RendererElementStore = C3DEnginePipelineGetRendererElementStore(v10);
  Capacity = C3DRendererElementStoreGetCapacity(RendererElementStore);
  ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(a1[1]);
  C3DProgramHashCodeStoreSetCapacity(ProgramHashCodeStore, Capacity);
  SortSystem = C3DEngineContextGetSortSystem(a1[1]);
  C3DSortSystemSetCapacity(SortSystem, Capacity);
  return C3DSortSystemPrepare(SortSystem, v10);
}

void C3DEngineNotificationQueueApplyForEntityType(uint64_t a1, const void *a2, void (__cdecl *a3)(const void *, const void *, void *), void *a4)
{
  const __CFDictionary *Value;

  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
    CFDictionaryApplyFunction(Value, a3, a4);
}

uint64_t C3DLightGetTypeID()
{
  if (C3DLightGetTypeID_onceToken != -1)
    dispatch_once(&C3DLightGetTypeID_onceToken, &__block_literal_global_60);
  return C3DLightGetTypeID_typeID;
}

uint64_t C3DSceneGetTypeID()
{
  if (C3DSceneGetTypeID_onceToken != -1)
    dispatch_once(&C3DSceneGetTypeID_onceToken, &__block_literal_global_66);
  return C3DSceneGetTypeID_typeID;
}

uint64_t C3DMorpherGetTypeID()
{
  if (C3DMorpherGetTypeID_onceToken != -1)
    dispatch_once(&C3DMorpherGetTypeID_onceToken, &__block_literal_global_102);
  return C3DMorpherGetTypeID_typeID;
}

uint64_t C3DMorphGetTypeID()
{
  if (C3DMorphGetTypeID_onceToken != -1)
    dispatch_once(&C3DMorphGetTypeID_onceToken, &__block_literal_global_101);
  return C3DMorphGetTypeID_typeID;
}

uint64_t C3DGenericSourceGetTypeID()
{
  if (C3DGenericSourceGetTypeID_onceToken != -1)
    dispatch_once(&C3DGenericSourceGetTypeID_onceToken, &__block_literal_global_89);
  return C3DGenericSourceGetTypeID_typeID;
}

void C3DSortSystemSyncKeys(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5;
  float32x4_t *PointOfView;
  uint64_t Scene;
  uint64_t EnginePipeline;
  uint64_t RendererElementStore;
  uint64_t v13;
  float32x4_t *WorldMatrix;
  __n128 v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  unsigned int v21;
  unsigned int *Element;
  _QWORD *ValuePtrAtIndex;
  char IsOpaque;
  char v25;
  uint64_t PriorityIndex;
  int v27;
  void *ProgramHashCodeForRenderElement;
  uint64_t ProgramIndexForRenderElement;
  uint64_t v30;
  uint64_t v31;
  uint64_t MaterialIndex;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  int v37;
  int v38;
  char v39;
  int v40;
  int v41;
  char v42;
  unint64_t v43;
  char v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  float32x4_t *Node;
  uint64_t Mesh;
  uint64_t v50;
  float32x4_t *MeshElement;
  float32x4_t *v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t *v55;
  __n128 v56;
  float32x4_t v57;
  float32x4_t v58;
  __n128 WorldBoundingBox;
  uint64_t v60;
  int8x16_t v61;
  uint64_t ProgramHashCodeStore;
  float32x4_t v64;
  uint64_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v69;
  __n128 v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;

  PointOfView = C3DEngineContextGetPointOfView(a2);
  Scene = C3DEngineContextGetScene(a2);
  EnginePipeline = C3DSceneGetEnginePipeline(Scene);
  ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(a2);
  RendererElementStore = C3DEnginePipelineGetRendererElementStore(EnginePipeline);
  if (PointOfView)
  {
    v13 = RendererElementStore;
    v69.i32[2] = 0;
    v69.i64[0] = 0;
    WorldMatrix = C3DNodeGetWorldMatrix(PointOfView);
    v15 = *(__n128 *)WorldMatrix;
    v16 = WorldMatrix[1];
    v17 = WorldMatrix[3];
    v72 = WorldMatrix[2];
    v73 = v17;
    v70 = v15;
    v71 = v16;
    *(double *)v18.i64 = C3DVector3Rotate((float32x2_t *)&v70, (float32x4_t)xmmword_1DD007600);
    v66 = v18;
    C3DMatrix4x4GetTranslation((__n128 *)WorldMatrix, (__n128 *)&v69);
    if (a4 >= 1)
    {
      v19 = v66;
      v20 = vmulq_f32(v66, v69);
      v19.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0];
      v67 = v19;
      v65 = v13;
      while (1)
      {
        v21 = *a3++;
        v5 = v5 & 0xFFFFFFFF00000000 | v21;
        Element = (unsigned int *)C3DRendererElementStoreGetElement(v13, v5);
        ValuePtrAtIndex = (_QWORD *)C3DArrayGetValuePtrAtIndex(*(_QWORD *)(a1 + 16), *Element);
        IsOpaque = C3DRendererElementIsOpaque((uint64_t)Element);
        v25 = IsOpaque;
        if (*ValuePtrAtIndex == -1)
          break;
        if ((IsOpaque & 1) == 0)
        {
          *ValuePtrAtIndex &= 0xFFFFFFFF00000000;
          goto LABEL_27;
        }
LABEL_40:
        if (!--a4)
          return;
      }
      PriorityIndex = C3DRendererElementStoreGetPriorityIndex(v13, (uint64_t)Element);
      v27 = C3DRendererElementIsOpaque((uint64_t)Element);
      if (v27 && C3DRendererElementGetMaterial((uint64_t)Element))
      {
        ProgramHashCodeForRenderElement = (void *)C3DProgramHashCodeStoreGetProgramHashCodeForRenderElement(ProgramHashCodeStore, (unsigned __int16 *)Element, 0, a5);
        ProgramIndexForRenderElement = C3DProgramHashCodeStoreGetProgramIndexForRenderElement(ProgramHashCodeStore, ProgramHashCodeForRenderElement);
        v30 = v13;
        v31 = ProgramIndexForRenderElement;
        MaterialIndex = C3DRendererElementStoreGetMaterialIndex(v30, (uint64_t)Element);
      }
      else
      {
        v31 = 0;
        MaterialIndex = 0;
      }
      v33 = *((_QWORD *)Element + 1);
      if (v33)
        v34 = C3DNodeGetLayerIndex(v33) << 61;
      else
        v34 = 0;
      v35 = *(unsigned __int16 *)(a1 + 24);
      v36 = (v35 >> 5) & 0x1F;
      v37 = v35 & 0x1F;
      v38 = (60 - (v36 + v37)) & ~((60 - (v36 + v37)) >> 31);
      v39 = v37;
      if ((v27 & 1) != 0)
        v40 = v36;
      else
        v40 = 0;
      if ((v27 & 1) != 0)
        v41 = v38;
      else
        v41 = 0;
      v42 = 60 - v39;
      v43 = (PriorityIndex << (61 - v39)) | v34 | ((unint64_t)(v27 ^ 1u) << (60 - v39));
      v44 = 60 - v39 - v41;
      if (v41)
      {
        v43 |= (v31 & ~(-1 << v41)) << (v42 - v41);
        v45 = v44;
      }
      else
      {
        v45 = v42;
      }
      v46 = MaterialIndex << (v45 - v40);
      if (v40)
        v47 = v46;
      else
        v47 = 0;
      *ValuePtrAtIndex = v47 | v43;
      v13 = v65;
      if ((v25 & 1) != 0)
        goto LABEL_40;
LABEL_27:
      Node = (float32x4_t *)C3DRendererElementGetNode((uint64_t)Element);
      Mesh = C3DRendererElementGetMesh((uint64_t)Element);
      if (Mesh)
      {
        v50 = Mesh;
        MeshElement = (float32x4_t *)C3DRendererElementGetMeshElement((uint64_t)Element);
        if (!MeshElement)
        {
          v60 = 3212836864;
LABEL_39:
          *ValuePtrAtIndex |= v60;
          goto LABEL_40;
        }
        v52 = MeshElement;
        _C3DUpdateMeshElementsBBoxIfNeeded(v50);
        *(double *)v53.i64 = C3DVector3MidVector(v52[11], v52[12]);
        v54 = v53;
        if (!Node)
          goto LABEL_37;
        v64 = v53;
        v55 = C3DNodeGetWorldMatrix(Node);
        v56 = *(__n128 *)v55;
        v57 = v55[1];
        v58 = v55[3];
        v72 = v55[2];
        v73 = v58;
        v70 = v56;
        v71 = v57;
        WorldBoundingBox.n128_f64[0] = C3DVector3MultMatrix4x4((float32x4_t *)&v70, v64);
      }
      else
      {
        if ((Element[18] & 7) != 2)
        {
          v54 = (float32x4_t)xmmword_1DD007610;
          if (!Node)
          {
LABEL_38:
            v61 = (int8x16_t)vmulq_f32(v67, v54);
            *(float32x2_t *)v61.i8 = vadd_f32(*(float32x2_t *)v61.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v61, v61, 8uLL));
            v61.i32[0] = vadd_f32(*(float32x2_t *)v61.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v61.i8, 1)).u32[0];
            v60 = ((v61.i32[0] >> 31) | 0x80000000) ^ v61.i32[0];
            goto LABEL_39;
          }
          v70.n128_u32[2] = 0;
          v70.n128_u64[0] = 0;
          C3DNodeGetWorldPosition(Node, &v70);
          v54 = (float32x4_t)v70;
LABEL_37:
          v54.i32[3] = 1.0;
          goto LABEL_38;
        }
        WorldBoundingBox = C3DParticleSystemInstanceGetWorldBoundingBox(*((_QWORD *)Element + 6));
      }
      v54 = (float32x4_t)WorldBoundingBox;
      goto LABEL_37;
    }
  }
}

uint64_t C3DRendererElementIsOpaque(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 72) >> 3) & 1;
}

uint64_t C3DIndexStoreGetIndexForKey(uint64_t a1, void *key)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *Value;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DIndexStoreGetIndexForKey_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (Value)
    return *(_QWORD *)Value;
  else
    return -1;
}

uint64_t C3DRendererElementStoreGetPriorityIndex(uint64_t a1, uint64_t a2)
{
  return C3DIndexStoreGetOrderedIndexForKey(*(_QWORD *)(a1 + 24), (void *)*(int *)(a2 + 64));
}

uint64_t C3DIndexStoreGetOrderedIndexForKey(uint64_t a1, void *key)
{
  CFIndex Count;
  void *v5;
  uint64_t v6;
  const void **v7;
  uint64_t v8;
  uint64_t *Value;
  uint64_t v10;
  NSObject *v11;
  uint64_t result;
  uint64_t v13;
  uint8_t v14[4];
  _DWORD v15[7];

  *(_QWORD *)&v15[5] = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 56))
  {
    Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
    v5 = *(void **)(a1 + 64);
    if (v5)
    {
      free(v5);
      *(_QWORD *)(a1 + 64) = 0;
    }
    if (Count >= 1)
    {
      v6 = *(_QWORD *)(a1 + 32);
      *(_QWORD *)(a1 + 64) = malloc_type_malloc(8 * v6 + 8, 0x100004000313F17uLL);
      v7 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 16), v7, 0);
      qsort(v7, Count, 8uLL, (int (__cdecl *)(const void *, const void *))_sortKeys);
      v8 = 0;
      while (1)
      {
        Value = (uint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v7[v8]);
        if (!Value)
          break;
        v10 = *Value;
        if (*Value < 0 || v10 > v6)
          goto LABEL_11;
LABEL_13:
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v10) = v8++;
        if (Count == v8)
        {
          free(v7);
          goto LABEL_15;
        }
      }
      v10 = -1;
LABEL_11:
      v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
        C3DIndexStoreGetOrderedIndexForKey_cold_1(v14, v15, v11);
      goto LABEL_13;
    }
LABEL_15:
    *(_BYTE *)(a1 + 56) = 1;
  }
  result = C3DIndexStoreGetIndexForKey(a1, key);
  if (result != -1)
  {
    v13 = *(_QWORD *)(a1 + 64);
    if (v13)
      return *(_QWORD *)(v13 + 8 * result);
  }
  return result;
}

uint64_t C3DRendererElementStoreGetMaterialIndex(uint64_t a1, uint64_t a2)
{
  return C3DIndexStoreGetIndexForKey(*(_QWORD *)(a1 + 32), *(void **)(a2 + 32));
}

uint64_t C3DProgramHashCodeStoreGetProgramIndexForRenderElement(uint64_t a1, void *a2)
{
  if (a2)
    return C3DIndexStoreGetIndexForKey(*(_QWORD *)(a1 + 48), a2);
  else
    return 0;
}

uint64_t _C3DUpdateMeshElementsBBoxIfNeeded(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  CFIndex v3;
  float32x4_t *ElementAtIndex;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t IndexCount;
  float32x4_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  unsigned __int8 *v13;
  unint64_t v14;
  float32x4_t v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  float32x4_t v20;
  unsigned __int16 *v21;
  unint64_t v22;
  float32x4_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  if ((*(_BYTE *)(result + 200) & 2) == 0)
  {
    v1 = result;
    result = (uint64_t)C3DMeshGetElementsCount(result);
    if (result >= 1)
    {
      v2 = result;
      v3 = 0;
      v28 = vdupq_n_s32(0x7F7FFFFFu);
      do
      {
        ElementAtIndex = (float32x4_t *)C3DMeshGetElementAtIndex(v1, v3, 0);
        v40 = 0;
        v38 = 0u;
        v39 = 0u;
        v37 = 0u;
        C3DMeshElementGetContent((uint64_t)ElementAtIndex, 0, (uint64_t)&v37);
        if ((_QWORD)v37 && (float32x4_t *)C3DMeshElementGetSharedMeshElement((uint64_t)ElementAtIndex) == ElementAtIndex)
        {
          result = (uint64_t)C3DMeshGetSourceWithSemanticAtIndex(v1, 0, 0, 0);
          if (result)
          {
            result = C3DMeshSourceGetContent(result);
            if (result)
            {
              v6 = result;
              v7 = v5;
              IndexCount = C3DMeshElementGetIndexCount((uint64_t)ElementAtIndex);
              v10 = IndexCount;
              v11.i64[0] = 0x80000000800000;
              v11.i64[1] = 0x80000000800000;
              if ((v7 & 0xFF000000000000) == 0x1000000000000)
              {
                switch(BYTE11(v38))
                {
                  case 4u:
                    v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      v18 = (_DWORD *)(v37 + 4 * *((_QWORD *)&v39 + 1));
                      v12 = (float32x4_t)v28;
                      do
                      {
                        v19 = v6 + *v18 * BYTE5(v7);
                        v20.i64[0] = *(_QWORD *)v19;
                        v20.i64[1] = *(unsigned int *)(v19 + 8);
                        v12 = vminq_f32(v12, v20);
                        v11 = vmaxq_f32(v11, v20);
                        v18 += v40;
                        --v10;
                      }
                      while (v10);
                    }
                    goto LABEL_43;
                  case 2u:
                    v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      v21 = (unsigned __int16 *)(v37 + 2 * *((_QWORD *)&v39 + 1));
                      v12 = (float32x4_t)v28;
                      do
                      {
                        v22 = v6 + BYTE5(v7) * (unint64_t)*v21;
                        v23.i64[0] = *(_QWORD *)v22;
                        v23.i64[1] = *(unsigned int *)(v22 + 8);
                        v12 = vminq_f32(v12, v23);
                        v11 = vmaxq_f32(v11, v23);
                        v21 += v40;
                        --v10;
                      }
                      while (v10);
                    }
                    goto LABEL_43;
                  case 1u:
                    v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      v13 = (unsigned __int8 *)(v37 + *((_QWORD *)&v39 + 1));
                      v12 = (float32x4_t)v28;
                      do
                      {
                        v14 = v6 + BYTE5(v7) * (unint64_t)*v13;
                        v15.i64[0] = *(_QWORD *)v14;
                        v15.i64[1] = *(unsigned int *)(v14 + 8);
                        v12 = vminq_f32(v12, v15);
                        v11 = vmaxq_f32(v11, v15);
                        v13 += v40;
                        --v10;
                      }
                      while (v10);
                    }
                    goto LABEL_43;
                }
              }
              else
              {
                switch(BYTE11(v38))
                {
                  case 4u:
                    v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      v24 = 0;
                      v25 = v37;
                      v12 = (float32x4_t)v28;
                      do
                      {
                        v30 = v12;
                        v34 = v11;
                        *(double *)v9.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v7), (float *)(v6+ *(_DWORD *)(v25 + 4 * (*((_QWORD *)&v39 + 1) + v40 * v24))* BYTE5(v7)), v9, v11.f32[0], v12.f32[0]);
                        v12 = vminq_f32(v30, v9);
                        v11 = vmaxq_f32(v34, v9);
                        ++v24;
                      }
                      while (v10 != v24);
                    }
                    goto LABEL_43;
                  case 2u:
                    v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      v26 = 0;
                      v27 = v37;
                      v12 = (float32x4_t)v28;
                      do
                      {
                        v31 = v12;
                        v35 = v11;
                        *(double *)v9.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v7), (float *)(v6+ BYTE5(v7)* (unint64_t)*(unsigned __int16 *)(v27+ 2* (*((_QWORD *)&v39 + 1)+ v40 * v26))), v9, v11.f32[0], v12.f32[0]);
                        v12 = vminq_f32(v31, v9);
                        v11 = vmaxq_f32(v35, v9);
                        ++v26;
                      }
                      while (v10 != v26);
                    }
                    goto LABEL_43;
                  case 1u:
                    v12 = (float32x4_t)v28;
                    if (IndexCount >= 1)
                    {
                      v16 = 0;
                      v17 = v37;
                      v12 = (float32x4_t)v28;
                      do
                      {
                        v29 = v12;
                        v33 = v11;
                        *(double *)v9.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v7), (float *)(v6+ BYTE5(v7)* (unint64_t)*(unsigned __int8 *)(v17+ *((_QWORD *)&v39 + 1)+ v40 * v16)), v9, v11.f32[0], v12.f32[0]);
                        v12 = vminq_f32(v29, v9);
                        v11 = vmaxq_f32(v33, v9);
                        ++v16;
                      }
                      while (v10 != v16);
                    }
                    goto LABEL_43;
                }
              }
              v12 = (float32x4_t)v28;
LABEL_43:
              v32 = v12;
              v36 = v11;
              ElementAtIndex[11] = v12;
              ElementAtIndex[12] = v11;
              result = (uint64_t)C3DMeshGetRenderableElementAtIndexIfNeeded(v1, v3);
              if (result)
              {
                *(float32x4_t *)(result + 176) = v32;
                *(float32x4_t *)(result + 192) = v36;
              }
            }
          }
        }
        else
        {
          ElementAtIndex[11] = 0u;
          ElementAtIndex[12] = 0u;
          result = (uint64_t)C3DMeshGetRenderableElementAtIndexIfNeeded(v1, v3);
          if (result)
          {
            *(_OWORD *)(result + 176) = 0u;
            *(_OWORD *)(result + 192) = 0u;
          }
        }
        ++v3;
      }
      while (v3 != v2);
    }
    *(_BYTE *)(v1 + 200) |= 2u;
  }
  return result;
}

double C3DVector3MultMatrix4x4(float32x4_t *a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(a1[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[1], *(float32x2_t *)a2.f32, 1), *a1, a2.f32[0]), a1[2], a2, 2)).u64[0];
  return result;
}

double C3DVector3MidVector(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  double result;

  v2 = vaddq_f32(a1, a2);
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  *(_QWORD *)&result = vmulq_f32(v2, v3).u64[0];
  return result;
}

const void *C3DMeshGetRenderableElementAtIndexIfNeeded(uint64_t a1, CFIndex idx)
{
  const __CFArray *Count;

  Count = *(const __CFArray **)(a1 + 144);
  if (Count)
    Count = (const __CFArray *)CFArrayGetCount(Count);
  if ((uint64_t)Count <= idx)
    return 0;
  else
    return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), idx);
}

const UInt8 *C3DMeshElementGetContent@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v6;
  NSObject *v7;
  int v8;
  int Type;
  const UInt8 *result;
  const UInt8 *v11;
  uint64_t v12;
  const UInt8 *v13;

  v3 = a2;
  v6 = *(unsigned __int8 *)(a1 + 130);
  if (a2 < 0 || v6 <= a2)
  {
    v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      C3DMeshElementGetContent_cold_1(v6, v3, v7);
  }
  v8 = *(unsigned __int8 *)(a1 + 131);
  if (!*(_BYTE *)(a1 + 131))
    v3 *= C3DMeshElementGetIndexCount(a1);
  Type = C3DMeshElementGetType(a1);
  result = *(const UInt8 **)(a1 + 96);
  if (result)
  {
    result = CFDataGetBytePtr((CFDataRef)result);
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    if (Type == 4 && result)
      v11 = &result[*(_DWORD *)(a1 + 104) * *(unsigned __int8 *)(a1 + 80)];
    else
      v11 = result;
  }
  else
  {
    v11 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
  }
  *(_QWORD *)a3 = v11;
  if (v8)
    v12 = v6;
  else
    v12 = 1;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 104);
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(a1 + 120);
  *(_WORD *)(a3 + 24) = *(_WORD *)(a1 + 128);
  *(_BYTE *)(a3 + 26) = *(_BYTE *)(a1 + 88);
  *(_BYTE *)(a3 + 27) = *(_BYTE *)(a1 + 80);
  if (Type == 4)
    v13 = result;
  else
    v13 = 0;
  *(_QWORD *)(a3 + 32) = v13;
  *(_QWORD *)(a3 + 40) = v3;
  *(_QWORD *)(a3 + 48) = v12;
  return result;
}

void C3D::DrawNodesPass::compile(C3D::DrawNodesPass *this)
{
  unint64_t v1;
  uint64_t Scene;
  uint64_t EnginePipeline;
  uint64_t RendererElementStore;
  uint64_t LightingSystem;
  uint64_t ProgramHashCodeStore;
  unsigned int Capacity;
  uint64_t RenderContext;
  _BOOL4 IsClusteredShadingEnabled;
  int v11;
  unint64_t v12;
  unsigned __int8 LightingSetProgramHashCodes;
  char *v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  uint64_t Element;
  __int16 v19;
  int v20;
  _OWORD v21[6];
  uint64_t v22;
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  Scene = C3DEngineContextGetScene(*((_QWORD *)this + 2));
  EnginePipeline = C3DSceneGetEnginePipeline(Scene);
  RendererElementStore = C3DEnginePipelineGetRendererElementStore(EnginePipeline);
  LightingSystem = C3DSceneGetLightingSystem(Scene);
  ProgramHashCodeStore = C3DEngineContextGetProgramHashCodeStore(*((_QWORD *)this + 2));
  Capacity = C3DRendererElementStoreGetCapacity(RendererElementStore);
  C3DProgramHashCodeStoreSetCapacity(ProgramHashCodeStore, Capacity);
  RenderContext = C3DEngineContextGetRenderContext(*((_QWORD *)this + 2));
  if (RenderContext)
    -[SCNMTLRenderContext disableLinearRendering](RenderContext);
  IsClusteredShadingEnabled = C3DEngineContextIsClusteredShadingEnabled(*((_QWORD *)this + 2));
  if (*((_DWORD *)this + 1236))
  {
    v11 = IsClusteredShadingEnabled;
    v12 = 0;
    do
    {
      C3DLightingSystemBeginQueries(LightingSystem, (uint64_t)this + 64 * v12 + 3408, *((_QWORD *)this + 2));
      v22 = 0;
      memset(v21, 0, sizeof(v21));
      C3DLightingSystemGetLightingContext(LightingSystem, *((_QWORD *)this + 2), (uint64_t)v21);
      v20 = 0;
      if (C3DLightingSystemGetInfiniteLightSet(LightingSystem, v23, &v20))
      {
        C3DLightingSystemCheckLightingSetTextureUsage(LightingSystem, (uint64_t)v23);
        LightingSetProgramHashCodes = C3DLightingSystemGetLightingSetProgramHashCodes(LightingSystem, (uint64_t)v23, (_OWORD *)((char *)v21 + 4));
        LOWORD(v21[0]) = (LightingSetProgramHashCodes << 7) | v21[0] & 0x807F;
      }
      v14 = (char *)this + 16 * v12;
      v15 = *((unsigned int *)v14 + 1310);
      if ((_DWORD)v15)
      {
        v16 = (unsigned int *)*((_QWORD *)v14 + 654);
        do
        {
          v17 = *v16++;
          v1 = v1 & 0xFFFFFFFF00000000 | v17;
          Element = C3DRendererElementStoreGetElement(RendererElementStore, v1);
          v19 = *(_WORD *)(Element + 72);
          if ((v19 & 0x40) != 0)
            *(_WORD *)(Element + 72) = (8 * LOWORD(v21[0])) & 0x380 | v19 & 0xFC7F;
          C3D::DrawNodesPass::_computeProgramHashCodeForRendererElement((uint64_t)this, Element, ProgramHashCodeStore, (uint64_t)v21, v11);
          --v15;
        }
        while (v15);
      }
      if (*((_BYTE *)this + 296))
        C3DLightingSystemEndQueries(LightingSystem);
      ++v12;
    }
    while (v12 < *((unsigned int *)this + 1236));
  }
}

uint64_t C3DRendererElementStoreGetElement(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DRendererElementStoreDeallocateSpanForNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return C3DSpanAllocatorGetElementInSpanAtIndex(*(_QWORD *)(a1 + 16), a2, 0);
}

uint64_t C3DSpanAllocatorGetElementInSpanAtIndex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DAllocatorNew_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  if ((unsigned __int16)a2 >= *(_DWORD *)(a1 + 24))
  {
    v14 = scn_default_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      C3DSpanAllocatorGetElementInSpanAtIndex_cold_2(v14, v15, v16, v17, v18, v19, v20, v21);
  }
  v22 = a2 >> 16;
  v23 = *(_QWORD *)(a1 + 16);
  v24 = (unsigned __int16)a2;
  if (*(_DWORD *)(v23 + 40 * (unsigned __int16)a2 + 12) != (unsigned __int16)a2
    || *(_DWORD *)(v23 + 40 * (unsigned __int16)a2 + 8) <= WORD1(a2))
  {
    v25 = scn_default_log();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
      C3DSpanAllocatorGetElementInSpanAtIndex_cold_1(v25, v26, v27, v28, v29, v30, v31, v32);
  }
  return *(_QWORD *)(v23 + 40 * v24) + *(_QWORD *)(a1 + 40) * (a3 + (unsigned __int16)v22);
}

uint64_t C3DRendererElementStoreGetCapacity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererElementStoreDeallocateSpanForNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return C3DSpanAllocatorGetCapacity(*(_QWORD *)(a1 + 16));
}

uint64_t C3DSpanAllocatorGetCapacity(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 24) * *(_DWORD *)(a1 + 48));
}

void C3DProgramHashCodeStoreSetCapacity(uint64_t a1, unsigned int a2)
{
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t ValuesPtr;

  if (*(_DWORD *)(a1 + 56) < a2)
  {
    v4 = *(_DWORD *)(a1 + 44);
    if (v4 != -15)
    {
      v5 = 0;
      do
      {
        if ((*(_WORD *)(*(_QWORD *)(a1 + 32) + 2 * v5) & 1) != 0)
        {
          v6 = *(_QWORD *)(a1 + 24);
          C3DArraySetCount(*(_DWORD **)(v6 + 8 * v5), a2);
          ValuesPtr = C3DArrayGetValuesPtr(*(_QWORD *)(v6 + 8 * v5));
          bzero((void *)(ValuesPtr + 8 * *(unsigned int *)(a1 + 56)), 8 * (a2 - *(_DWORD *)(a1 + 56)));
          v4 = *(_DWORD *)(a1 + 44);
        }
        ++v5;
      }
      while (v5 < (v4 + 15));
    }
    *(_DWORD *)(a1 + 56) = a2;
  }
}

double C3DVector3Rotate(float32x2_t *a1, float32x4_t a2)
{
  float32x4_t v9;
  float v10;
  float32x4_t v11;
  float v12;
  float v13;

  _Q1 = a2;
  *(float32x2_t *)a2.f32 = vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(a1[2], *(float32x2_t *)a2.f32, 1), *a1, a2.f32[0]), a1[4], a2, 2);
  _S2 = a1[5].i32[0];
  __asm { FMLA            S3, S2, V1.S[2] }
  a2.i32[2] = _S3;
  v9 = vmulq_f32(a2, a2);
  v10 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0];
  if (v10 != 0.0)
  {
    v11 = vmulq_f32(_Q1, _Q1);
    v12 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
    v13 = sqrtf(v10);
    if (v13 != v12)
      a2.i64[0] = vmulq_n_f32(a2, v12 / v13).u64[0];
  }
  return *(double *)a2.i64;
}

CFIndex C3DSortSystemPrepare(uint64_t a1, uint64_t a2)
{
  uint64_t Count;
  uint64_t RendererElementStore;
  uint64_t PriorityStamp;
  unsigned int PriorityCount;
  __int16 v8;
  char v9;
  BOOL v10;
  CFIndex result;
  unsigned int v12;
  __int16 v13;
  __int16 v14;
  void *ValuesPtr;

  Count = C3DArrayGetCount(*(_QWORD *)(a1 + 16));
  RendererElementStore = C3DEnginePipelineGetRendererElementStore(a2);
  PriorityStamp = C3DRendererElementStoreGetPriorityStamp(RendererElementStore);
  if (PriorityStamp != *(_QWORD *)(a1 + 32))
  {
    *(_QWORD *)(a1 + 32) = PriorityStamp;
    PriorityCount = C3DRendererElementStoreGetPriorityCount(RendererElementStore);
    v8 = 1;
    if (PriorityCount >= 2)
    {
      v9 = 0;
      do
      {
        ++v9;
        v10 = PriorityCount > 3;
        PriorityCount >>= 1;
      }
      while (v10);
      v8 = (v9 + 1) & 0x1F;
    }
    *(_WORD *)(a1 + 24) = *(_WORD *)(a1 + 24) & 0xFFE0 | v8;
    *(_BYTE *)(a1 + 40) = 1;
  }
  result = C3DRendererElementStoreGetMaterialCount(RendererElementStore);
  v12 = *(unsigned __int16 *)(a1 + 24);
  if (result >= (uint64_t)(2 << (v12 >> 5)))
  {
    if (result >= 2)
    {
      v14 = 0;
      do
      {
        ++v14;
        v10 = result > 3;
        LODWORD(result) = result >> 1;
      }
      while (v10);
      v13 = (32 * v14 + 32) & 0x3E0;
    }
    else
    {
      v13 = 32;
    }
    *(_WORD *)(a1 + 24) = v13 | v12 & 0xFC1F;
    *(_BYTE *)(a1 + 40) = 1;
    goto LABEL_16;
  }
  if (*(_BYTE *)(a1 + 40))
  {
LABEL_16:
    ValuesPtr = (void *)C3DArrayGetValuesPtr(*(_QWORD *)(a1 + 16));
    result = (CFIndex)memset(ValuesPtr, 255, 8 * Count);
    *(_BYTE *)(a1 + 40) = 0;
  }
  return result;
}

uint64_t C3DSkinnerGetTypeID()
{
  if (C3DSkinnerGetTypeID_onceToken != -1)
    dispatch_once(&C3DSkinnerGetTypeID_onceToken, &__block_literal_global_86);
  return C3DSkinnerGetTypeID_typeID;
}

uint64_t C3DSkinGetTypeID()
{
  if (C3DSkinGetTypeID_onceToken != -1)
    dispatch_once(&C3DSkinGetTypeID_onceToken, &__block_literal_global_87);
  return C3DSkinGetTypeID_typeID;
}

uint64_t C3DRendererElementStoreGetPriorityStamp(uint64_t a1)
{
  return C3DGeometryGetOverrideMaterial(*(_QWORD *)(a1 + 24));
}

CFIndex C3DRendererElementStoreGetPriorityCount(uint64_t a1)
{
  return C3DIndexStoreGetCount(*(_QWORD *)(a1 + 24));
}

CFIndex C3DRendererElementStoreGetMaterialCount(uint64_t a1)
{
  return C3DIndexStoreGetCount(*(_QWORD *)(a1 + 32));
}

CFIndex C3DIndexStoreGetCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DIndexStoreGetIndexForKey_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
}

uint64_t C3DParticleSystemGetTypeID()
{
  if (C3DParticleSystemGetTypeID_onceToken != -1)
    dispatch_once(&C3DParticleSystemGetTypeID_onceToken, &__block_literal_global_78);
  return C3DParticleSystemGetTypeID_typeID;
}

uint64_t C3DMeshSourceGetTypeID()
{
  if (C3DMeshSourceGetTypeID_onceToken != -1)
    dispatch_once(&C3DMeshSourceGetTypeID_onceToken, &__block_literal_global_17);
  return C3DMeshSourceGetTypeID_typeID;
}

uint64_t C3DMeshGetTypeID()
{
  if (C3DMeshGetTypeID_onceToken != -1)
    dispatch_once(&C3DMeshGetTypeID_onceToken, &__block_literal_global_63);
  return C3DMeshGetTypeID_typeID;
}

__n128 C3DMatrix4x4GetTranslation(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a1[3];
  *a2 = result;
  return result;
}

__n128 C3DLightingSystemGetLightingContext@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v6;
  __int16 v7;
  __int16 v8;
  int v9;
  int v10;
  int v11;
  int v12;
  __int16 v13;
  uint64_t *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __n128 result;
  _QWORD v19[6];
  __int128 v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v21 = 0;
  v22 = &v21;
  v23 = 0x8000000000;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v30 = 0;
  __ComputeAmbientLighting(a1);
  v20 = *(_OWORD *)(a1 + 48);
  if (C3DColor4IsBlack((float *)&v20))
    v6 = 0;
  else
    v6 = 2;
  *((_WORD *)v22 + 12) = v22[3] & 0xFFFD | v6;
  if (C3DLightingSystemGetIrradianceProbesCount(a1))
    v7 = 16 * (C3DLightProbesSystemGetSphericalHarmonicsOrder(*(_QWORD *)(a1 + 24)) & 7);
  else
    v7 = 0;
  *((_WORD *)v22 + 12) = v22[3] & 0xFF8F | v7;
  if (C3DEngineContextIsClusteredShadingEnabled(a2))
  {
    *((_WORD *)v22 + 12) = v22[3] & 0xFFFB | (4 * (*(_DWORD *)(a1 + 572) != 0));
    v8 = C3DLightingSystemGetReflectionProbesCount(a1) != 0;
    *((_WORD *)v22 + 12) = v22[3] & 0xFFF7 | (8 * v8);
  }
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 0x40000000;
  v19[2] = __C3DLightingSystemGetLightingContext_block_invoke;
  v19[3] = &unk_1EA5A20A8;
  v19[4] = &v21;
  v19[5] = a1;
  C3DLightingSystemEnumerateGlobalLights((const __CFDictionary *)a1, a2, (uint64_t)v19);
  v9 = *(_DWORD *)(a1 + 68);
  v10 = *(_DWORD *)(a1 + 72);
  v11 = *(_DWORD *)(a1 + 76);
  v12 = *(_DWORD *)(a1 + 88);
  if (!C3DEngineContextIsClusteredShadingEnabled(a2))
  {
    __ComputeInfiniteLightSet(a1);
    if (!(v10 + v9 + v11 + v12))
    {
      v13 = *(_DWORD *)(a1 + 584) == 0;
      goto LABEL_16;
    }
LABEL_15:
    v13 = 0;
    goto LABEL_16;
  }
  if (v10 + v9 + v11 + v12 || *(_DWORD *)(a1 + 584))
    goto LABEL_15;
  v13 = (unsigned __int16)__ShouldForceLighting(a2) ^ 1;
LABEL_16:
  v14 = v22;
  *((_WORD *)v22 + 12) = v22[3] & 0xFFFE | v13;
  v15 = *(_OWORD *)(v14 + 9);
  v16 = *(_OWORD *)(v14 + 13);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v14 + 11);
  *(_OWORD *)(a3 + 80) = v16;
  *(_QWORD *)(a3 + 96) = v14[15];
  v17 = *(_OWORD *)(v14 + 5);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v14 + 7);
  *(_OWORD *)(a3 + 48) = v15;
  *(_OWORD *)a3 = *(_OWORD *)(v14 + 3);
  *(_OWORD *)(a3 + 16) = v17;
  _Block_object_dispose(&v21, 8);
  return result;
}

BOOL C3DEngineContextIsClusteredShadingEnabled(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1704) != 0;
}

const __CFDictionary *C3DLightingSystemEnumerateGlobalLights(const __CFDictionary *result, uint64_t a2, uint64_t a3)
{
  const __CFDictionary *v5;
  uint64_t v6;
  uint64_t i;
  unint64_t v8;
  unsigned int v9;
  char *v10;
  const __CFDictionary *Light;
  float32x4_t *PointOfView;
  uint64_t DefaultPointOfView;
  float32x4_t *v14;
  float32x4_t *DefaultLightNode;
  _OWORD v16[4];
  _OWORD v17[4];
  uint64_t v18;

  v5 = result;
  v18 = *MEMORY[0x1E0C80C00];
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  v6 = *((unsigned int *)result + 142);
  if ((_DWORD)v6)
  {
    for (i = 0; i != v6; ++i)
    {
      v8 = *((unsigned int *)result + i + 126);
      v9 = (v8 & 0xFFFFFFF) - 1;
      v10 = (char *)result + ((v8 >> 25) & 0x78);
      *((_QWORD *)v17 + i) = *(_QWORD *)(*((_QWORD *)v10 + 17) + 8 * v9);
      *((_QWORD *)v16 + i) = *(_QWORD *)(*((_QWORD *)v10 + 25) + 8 * v9);
    }
    return (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  }
  else if (!(*((_DWORD *)result + 19) | *((_DWORD *)result + 18) | *((_DWORD *)result + 22) | *((_DWORD *)result + 23)))
  {
    result = __ShouldForceLighting(a2);
    if ((_DWORD)result)
    {
      DefaultLightNode = C3DEngineContextGetDefaultLightNode(a2);
      Light = C3DNodeGetLight((uint64_t)DefaultLightNode);
      if (C3DEngineContextGetPointOfViewIfAny(a2))
      {
        PointOfView = C3DEngineContextGetPointOfView(a2);
        C3DEngineContextSynchronizeDefaultLight(a2, PointOfView);
      }
      else
      {
        DefaultPointOfView = C3DEngineContextGetDefaultPointOfView(a2);
        v14 = C3DEngineContextGetPointOfView(a2);
        C3DEngineContextSynchronizeDefaultLight(a2, v14);
        if (!DefaultPointOfView)
          C3DEngineContextSetDefaultPointOfView(a2, 0);
      }
      *((_DWORD *)v5 + 134) = C3DLightGetProgramHashCode((uint64_t)Light);
      return (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
    }
  }
  return result;
}

const __CFDictionary *__ShouldForceLighting(uint64_t a1)
{
  uint64_t Scene;
  uint64_t LightingEnvironmentEffectSlot;
  uint64_t v4;
  const __CFDictionary *result;
  CFTypeRef *v6;
  const void *Attribute;
  CFTypeRef v8;
  int v9;
  const void *v10;

  Scene = C3DEngineContextGetScene(a1);
  LightingEnvironmentEffectSlot = C3DSceneGetLightingEnvironmentEffectSlot(Scene, 0);
  if (LightingEnvironmentEffectSlot)
  {
    v4 = LightingEnvironmentEffectSlot;
    if (C3DEffectSlotHasImageOrTexture(LightingEnvironmentEffectSlot)
      || C3DEffectSlotHasPrecomputedLightingEnvironment(v4))
    {
      return 0;
    }
  }
  if ((C3DSceneGetAllowsDefaultLightingEnvironmentFallback(Scene) & 1) != 0)
    return 0;
  v6 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
  if (Scene)
  {
    Attribute = (const void *)C3DSceneGetAttribute(Scene, CFSTR("triggerOptionsForRealtimeViewer"));
    if (!Attribute)
      Attribute = (const void *)*MEMORY[0x1E0C9AE40];
    v8 = *v6;
    v9 = CFEqual(Attribute, *v6);
    v10 = v8;
    if (v9)
    {
      if (!v8)
        goto LABEL_16;
    }
    else
    {
      v10 = (const void *)C3DSceneGetAttribute(Scene, CFSTR("defaultLight"));
      if (!v10)
        goto LABEL_16;
    }
    if (CFEqual(v10, v8))
      return (const __CFDictionary *)1;
  }
LABEL_16:
  result = C3DEngineContextGetRenderingOptionForKey(a1, CFSTR("defaultLight"));
  if (result)
    return (const __CFDictionary *)(CFEqual(result, *v6) != 0);
  return result;
}

double __ComputeAmbientLighting(uint64_t a1)
{
  float32x4_t v2;
  float32x4_t v3;
  double v4;
  double v5;
  double v6;
  double v7;
  __n128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  float32x2_t v14;
  double result;
  __int128 v16;

  v16 = 0uLL;
  C3DColor4Make((float *)&v16, 0.0, 0.0, 0.0, 1.0);
  v9 = *(unsigned int *)(a1 + 64);
  if ((_DWORD)v9)
  {
    v10 = 0;
    v11 = 8 * v9;
    do
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 200) + v10);
      if (v12)
      {
        C3DLightGetColorModulatedByIntensity(v12, v2, v3, v4, v5, v6, v7, v8);
        v3.f32[0] = v13;
        v4 = *(double *)&v16;
        *(float32x2_t *)v2.f32 = vadd_f32(*(float32x2_t *)&v16, v14);
        *(_QWORD *)&v16 = v2.i64[0];
        v2.f32[0] = *((float *)&v16 + 2) + v13;
        *((float *)&v16 + 2) = *((float *)&v16 + 2) + v13;
      }
      v10 += 8;
    }
    while (v11 != v10);
  }
  result = *(double *)&v16;
  *(_OWORD *)(a1 + 48) = v16;
  return result;
}

uint64_t C3DLightingSystemGetReflectionProbesCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DLightingSystemGetIrradianceProbesCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 84);
}

uint64_t C3DLightingSystemGetIrradianceProbesCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DLightingSystemGetIrradianceProbesCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 80);
}

uint64_t C3DLightingSystemGetInfiniteLightSet(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  *a2 = *(_QWORD *)(a1 + 576);
  *a3 = *(_DWORD *)(a1 + 584);
  return *(unsigned __int8 *)(a1 + 588);
}

uint64_t C3DLightingSystemGetGlobalLightHashCodeForCaching(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __C3DLightingSystemGetGlobalLightHashCodeForCaching_block_invoke;
  v5[3] = &unk_1EA5A2060;
  v5[5] = a3;
  v5[6] = a1;
  v5[4] = &v6;
  C3DLightingSystemEnumerateGlobalLights(a1, a2, (uint64_t)v5);
  v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void C3DLightingSystemEndQueries(uint64_t a1)
{
  uint64_t v2;
  char *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  float32x4_t *WorldMatrix;
  uint64_t v9;
  int v10;
  uint64_t v11;
  _BOOL4 v12;
  unsigned int ShadowCascadeCount;
  uint64_t v14;
  uint64_t v15;
  float *v16;
  char AutomaticallyAdjustsShadowProjection;
  uint64_t *v18;
  float32x4_t v19;
  int v20;
  int Type;
  uint64_t v22;
  __int128 *v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 *v30;
  unsigned int v31;
  uint64_t v32;
  _QWORD v33[4];
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(uint64_t, unsigned int, uint64_t, uint64_t, uint64_t);
  void *v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  _QWORD v44[4];
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  float32x4_t v48[2];
  __int128 v49;
  __int128 v50;
  _OWORD v51[4];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 116416;
  v3 = *(char **)(a1 + 116440);
  if (v3)
  {
    if (*(_BYTE *)(a1 + 588))
    {
      v4 = *(_DWORD *)(a1 + 584);
      if (v4 >= 8)
        v4 = 8;
      *(_DWORD *)(a1 + 4 * v4 + 116448) = 666;
    }
    C3DAuthoringEnvironmentUpdateLightingStats(v3, (const void *)(a1 + 116448), 9u);
    if (C3DAuthoringEnvironmentShouldDisplayLightInfluences(*(_QWORD *)(v2 + 24)))
    {
      v49 = xmmword_1DD0078A0;
      v50 = xmmword_1DD007880;
      v32 = *(unsigned int *)(a1 + 68);
      if ((_DWORD)v32)
      {
        for (i = 0; i != v32; ++i)
        {
          WorldMatrix = C3DNodeGetWorldMatrix(*(float32x4_t **)(*(_QWORD *)(a1 + 144) + 8 * i));
          v9 = *(_QWORD *)(a1 + 400);
          v10 = *(unsigned __int8 *)(v9 + i);
          if (*(_BYTE *)(v9 + i))
          {
            v51[0] = *(_OWORD *)"fff?";
            v51[1] = unk_1DD02A800;
            v51[2] = xmmword_1DD02A810;
            v51[3] = unk_1DD02A820;
            v11 = *(_QWORD *)(*(_QWORD *)(a1 + 208) + 8 * i);
            v12 = C3DLightSupportsShadowCascades(v11);
            if (!v12)
            {
              v14 = 1;
LABEL_14:
              v15 = a1 + 1568 * (v10 - 1) + 116768;
              v16 = (float *)v51;
              do
              {
                if (v12)
                {
                  v48[0] = *(float32x4_t *)v16;
                  v48[0].i32[2] = 1056964608;
                  AutomaticallyAdjustsShadowProjection = C3DLightGetAutomaticallyAdjustsShadowProjection(v11);
                  v18 = *(uint64_t **)(v2 + 24);
                  if ((AutomaticallyAdjustsShadowProjection & 1) != 0)
                    C3DAuthoringEnvironmentAppendDebugPolyhedron(v18, *(_QWORD *)(v15 + 240), 0, v48[0].f32);
                  else
                    C3DAuthoringEnvironmentAppendDebugBoundingSphere((uint64_t)v18, *(_QWORD *)(v15 + 224), *(_QWORD *)(v15 + 232), 0, (__int128 *)v48);
                }
                C3DAuthoringEnvironmentAppendDebugFrustum(*(uint64_t **)(v2 + 24), (float32x4_t *)(v15 + 256), 0, v16);
                v19 = *(float32x4_t *)(v15 + 368);
                v48[0] = *(float32x4_t *)(v15 + 352);
                v48[1] = v19;
                C3DAuthoringEnvironmentAppendDebugBoundingBox(*(_QWORD *)(v2 + 24), v48, (float32x4_t *)v15, v16);
                v15 += 384;
                v16 += 4;
                --v14;
              }
              while (v14);
              goto LABEL_20;
            }
            ShadowCascadeCount = C3DLightGetShadowCascadeCount(v11);
            if (ShadowCascadeCount)
            {
              v14 = ShadowCascadeCount;
              goto LABEL_14;
            }
          }
LABEL_20:
          v20 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 336) + i);
          Type = C3DLightGetType(*(_QWORD *)(*(_QWORD *)(a1 + 208) + 8 * i));
          v22 = *(_QWORD *)(v2 + 24);
          if (v20)
            v23 = &v49;
          else
            v23 = &v50;
          if (Type == 1)
          {
            C3DAuthoringEnvironmentAppendDebugRay(v22, (uint64_t)WorldMatrix, (float *)v23, (float32x4_t)0, (float32x4_t)xmmword_1DD02A840);
          }
          else
          {
            C3DAuthoringEnvironmentAppendDebugSegment(v22, (uint64_t)WorldMatrix, (float *)v23, 0, (float32x4_t)xmmword_1DD007970, (float32x4_t)xmmword_1DD007A30);
            C3DAuthoringEnvironmentAppendDebugSegment(*(_QWORD *)(v2 + 24), (uint64_t)WorldMatrix, (float *)v23, 0, (float32x4_t)xmmword_1DD007920, (float32x4_t)xmmword_1DD007A00);
            C3DAuthoringEnvironmentAppendDebugSegment(*(_QWORD *)(v2 + 24), (uint64_t)WorldMatrix, (float *)v23, 0, (float32x4_t)xmmword_1DD007600, (float32x4_t)xmmword_1DD007960);
          }
        }
      }
      v24 = MEMORY[0x1E0C809B0];
      v44[0] = MEMORY[0x1E0C809B0];
      v44[1] = 0x40000000;
      v44[2] = __C3DLightingSystemEndQueries_block_invoke;
      v44[3] = &__block_descriptor_tmp_16_1;
      v47 = a1;
      v45 = v49;
      v46 = v50;
      v25 = *(_DWORD *)(a1 + 72);
      if (v25)
        __C3DLightingSystemEndQueries_block_invoke((uint64_t)v44, v25, v5, v6, *(_QWORD *)(a1 + 456));
      v37 = v24;
      v38 = 0x40000000;
      v39 = __C3DLightingSystemEndQueries_block_invoke_2;
      v40 = &__block_descriptor_tmp_18_0;
      v43 = a1;
      v41 = v49;
      v42 = v50;
      v26 = *(unsigned int *)(a1 + 88);
      if ((_DWORD)v26)
      {
        v27 = 0;
        v28 = *(_QWORD *)(a1 + 464);
        do
        {
          v29 = *(_OWORD *)(v28 + 16 * v27);
          HIDWORD(v29) = sqrtf(*((float *)&v29 + 3));
          if (*(_BYTE *)(*(_QWORD *)(v43 + 376) + v27))
            v30 = &v41;
          else
            v30 = &v42;
          C3DAuthoringEnvironmentAppendDebugBoundingSphere(*(_QWORD *)(v43 + 116440), *(_QWORD *)(v28 + 16 * v27++), *((uint64_t *)&v29 + 1), 0, v30);
        }
        while (v26 != v27);
      }
      v33[0] = v24;
      v33[1] = 0x40000000;
      v33[2] = __C3DLightingSystemEndQueries_block_invoke_3;
      v33[3] = &__block_descriptor_tmp_20_3;
      v36 = a1;
      v34 = v49;
      v35 = v50;
      v31 = *(_DWORD *)(a1 + 76);
      if (v31)
        __C3DLightingSystemEndQueries_block_invoke_3((uint64_t)v33, v31, v5, v6, *(_QWORD *)(a1 + 472));
    }
  }
  if (*(_DWORD *)(a1 + 80))
    C3DLightProbesEndQueries(*(_QWORD *)(a1 + 24));
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)v2 = 0;
}

void C3DLightingSystemBeginQueries(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t Scene;
  __int128 v16;
  __int128 v17;
  float32x4_t v18;
  float32x4_t v19;
  uint64_t i;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t j;
  id AuthoringEnvironment;
  char ShouldDisplayLightInfluences;
  uint64_t v29;
  float32x4_t v30;

  v6 = a1 + 116400;
  if (!a2)
  {
    v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      C3DLightingSystemBeginQueries_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
  }
  *(_QWORD *)(v6 + 16) = a3;
  Scene = C3DEngineContextGetScene(a3);
  *(_QWORD *)(v6 + 24) = C3DSceneGetEnginePipeline(Scene);
  *(_BYTE *)(v6 + 32) = C3DEngineContextGetBooleanOptionForKey(a3, CFSTR("probeRendering"));
  v16 = *(_OWORD *)(a2 + 48);
  v18 = *(float32x4_t *)a2;
  v17 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 116368) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 116384) = v16;
  *(float32x4_t *)(a1 + 116336) = v18;
  *(_OWORD *)(a1 + 116352) = v17;
  v30.i32[2] = 0;
  v30.i64[0] = 0;
  C3DMatrix4x4GetScale((float32x4_t *)a2, &v30);
  v19 = vabsq_f32(v30);
  *(float *)v6 = fmaxf(fmaxf(v19.f32[0], v19.f32[2]), v19.f32[1]);
  __CommitLightsUpdate(a1);
  for (i = 1; i != 8; ++i)
  {
    v21 = *(unsigned int *)(a1 + 4 * i + 64);
    if ((_DWORD)v21)
    {
      v22 = 0;
      v23 = a1 + 8 * i;
      v24 = (_QWORD *)(v23 + 136);
      v25 = (_QWORD *)(v23 + 200);
      do
      {
        __updateWorldData((uint64_t *)a1, i, v22, *(float32x4_t **)(*v24 + 8 * v22), *(__n128 **)(*v25 + 8 * v22));
        ++v22;
      }
      while (v21 != v22);
    }
  }
  for (j = 0; j != 7; ++j)
    bzero(*(void **)(a1 + 8 * j + 336), *(unsigned int *)(a1 + 4 * j + 68));
  bzero((void *)(a1 + 2664), 0x800uLL);
  bzero((void *)(a1 + 616), 0x800uLL);
  *(_DWORD *)(a1 + 608) = 0;
  AuthoringEnvironment = C3DEngineContextGetAuthoringEnvironment(a3, 0);
  *(_QWORD *)(v6 + 40) = AuthoringEnvironment;
  if (AuthoringEnvironment)
  {
    ShouldDisplayLightInfluences = C3DAuthoringEnvironmentShouldDisplayLightInfluences((uint64_t)AuthoringEnvironment);
    v29 = *(_QWORD *)(v6 + 40);
    *(_BYTE *)(v6 + 84) = ShouldDisplayLightInfluences;
    if (v29)
    {
      *(_DWORD *)(a1 + 116480) = 0;
      *(_OWORD *)(a1 + 116448) = 0u;
      *(_OWORD *)(a1 + 116464) = 0u;
    }
  }
  else
  {
    *(_BYTE *)(v6 + 84) = 0;
  }
  __ComputeAmbientLighting(a1);
  if (C3DLightingSystemGetIrradianceProbesCount(a1))
    C3DLightProbesBeginQueries(*(_QWORD *)(a1 + 24), a3);
}

uint64_t C3DSceneGetEnginePipeline(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 120);
}

id C3DEngineContextGetAuthoringEnvironment(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  id result;
  BOOL v13;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(id *)(a1 + 144);
  if (result)
    v13 = 1;
  else
    v13 = a2 == 0;
  if (!v13)
  {
    result = C3DAuthoringEnvironmentCreate(a1);
    *(_QWORD *)(a1 + 144) = result;
  }
  return result;
}

void __CommitLightsUpdate(uint64_t a1)
{
  int HaveChanged;
  _BOOL4 IsBlack;
  uint64_t v4;

  if (CFSetGetCount(*(CFSetRef *)(a1 + 488)))
  {
    HaveChanged = __LightsHaveChanged(a1);
    CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 488));
    if (HaveChanged)
    {
      IsBlack = C3DColor4IsBlack((float *)(a1 + 48));
      __ComputeAmbientLighting(a1);
      if (IsBlack != C3DColor4IsBlack((float *)(a1 + 48)))
      {
        v4 = *(_QWORD *)(a1 + 116424);
        if (v4)
          C3DEnginePipelineInvalidateAllProgramHashCode(v4);
      }
    }
  }
}

uint64_t C3DLODGetTypeID()
{
  if (C3DLODGetTypeID_onceToken != -1)
    dispatch_once(&C3DLODGetTypeID_onceToken, &__block_literal_global_54);
  return C3DLODGetTypeID_typeID;
}

uint64_t C3DKeyframedAnimationGetTypeID()
{
  if (C3DKeyframedAnimationGetTypeID_onceToken != -1)
    dispatch_once(&C3DKeyframedAnimationGetTypeID_onceToken, &__block_literal_global_24);
  return C3DKeyframedAnimationGetTypeID_typeID;
}

uint64_t C3DKeyValueStoreGetTypeID()
{
  if (C3DKeyValueStoreGetTypeID_onceToken != -1)
    dispatch_once(&C3DKeyValueStoreGetTypeID_onceToken, &__block_literal_global);
  return C3DKeyValueStoreGetTypeID_typeID;
}

uint64_t C3DFXTechniqueGetTypeID()
{
  if (C3DFXTechniqueGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXTechniqueGetTypeID_onceToken, &__block_literal_global_23);
  return C3DFXTechniqueGetTypeID_typeID;
}

uint64_t C3DFXGLSLProgramGetTypeID()
{
  if (C3DFXGLSLProgramGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXGLSLProgramGetTypeID_onceToken, &__block_literal_global_105);
  return C3DFXGLSLProgramGetTypeID_typeID;
}

void C3DEngineNotificationQueueSwapForApplying(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineNotificationQueueEnqueueEvent_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 24));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  *(int8x16_t *)(a1 + 16) = vextq_s8(*(int8x16_t *)(a1 + 16), *(int8x16_t *)(a1 + 16), 8uLL);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
  *(_BYTE *)(a1 + 50) = 0;
  *(CFTimeInterval *)(a1 + 40) = CACurrentMediaTime();
}

uint64_t C3DEngineNotificationQueueNeedsFullReset(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 50);
}

const __CFDictionary *C3DEngineContextGetBooleanOptionForKey(uint64_t a1, void *key)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(const __CFDictionary **)(a1 + 376);
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, key);
    if (result)
      return (const __CFDictionary *)(CFEqual(result, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0);
  }
  return result;
}

uint64_t C3DConstraintSliderGetTypeID()
{
  if (C3DConstraintSliderGetTypeID::onceToken != -1)
    dispatch_once(&C3DConstraintSliderGetTypeID::onceToken, &__block_literal_global_41);
  return C3DConstraintSliderGetTypeID::typeID;
}

uint64_t C3DConstraintReplicatorGetTypeID()
{
  if (C3DConstraintReplicatorGetTypeID_onceToken != -1)
    dispatch_once(&C3DConstraintReplicatorGetTypeID_onceToken, &__block_literal_global_27_0);
  return C3DConstraintReplicatorGetTypeID_typeID;
}

uint64_t C3DConstraintProceduralGetTypeID()
{
  if (C3DConstraintProceduralGetTypeID_onceToken != -1)
    dispatch_once(&C3DConstraintProceduralGetTypeID_onceToken, &__block_literal_global_18);
  return C3DConstraintProceduralGetTypeID_typeID;
}

uint64_t C3DConstraintLookAtGetTypeID()
{
  if (C3DConstraintLookAtGetTypeID_onceToken != -1)
    dispatch_once(&C3DConstraintLookAtGetTypeID_onceToken, &__block_literal_global_8_2);
  return C3DConstraintLookAtGetTypeID_typeID;
}

uint64_t C3DConstraintIKGetTypeID()
{
  if (C3DConstraintIKGetTypeID_onceToken != -1)
    dispatch_once(&C3DConstraintIKGetTypeID_onceToken, &__block_literal_global_20_1);
  return C3DConstraintIKGetTypeID_typeID;
}

uint64_t C3DConstraintDistanceGetTypeID()
{
  if (C3DConstraintDistanceGetTypeID_onceToken != -1)
    dispatch_once(&C3DConstraintDistanceGetTypeID_onceToken, &__block_literal_global_23_0);
  return C3DConstraintDistanceGetTypeID_typeID;
}

uint64_t C3DConstraintConstantScaleGetTypeID()
{
  if (C3DConstraintConstantScaleGetTypeID_onceToken != -1)
    dispatch_once(&C3DConstraintConstantScaleGetTypeID_onceToken, &__block_literal_global_15_1);
  return C3DConstraintConstantScaleGetTypeID_typeID;
}

uint64_t C3DConstraintBillboardGetTypeID()
{
  if (C3DConstraintBillboardGetTypeID_onceToken != -1)
    dispatch_once(&C3DConstraintBillboardGetTypeID_onceToken, &__block_literal_global_11_0);
  return C3DConstraintBillboardGetTypeID_typeID;
}

uint64_t C3DConstraintAvoidOccluderGetTypeID()
{
  if (C3DConstraintAvoidOccluderGetTypeID::onceToken != -1)
    dispatch_once(&C3DConstraintAvoidOccluderGetTypeID::onceToken, &__block_literal_global_21_0);
  return C3DConstraintAvoidOccluderGetTypeID::typeID;
}

uint64_t C3DConstraintAccelerationGetTypeID()
{
  if (C3DConstraintAccelerationGetTypeID_onceToken != -1)
    dispatch_once(&C3DConstraintAccelerationGetTypeID_onceToken, &__block_literal_global_25_1);
  return C3DConstraintAccelerationGetTypeID_typeID;
}

uint64_t C3DCameraGetTypeID()
{
  if (C3DCameraGetTypeID_onceToken != -1)
    dispatch_once(&C3DCameraGetTypeID_onceToken, &__block_literal_global_61);
  return C3DCameraGetTypeID_typeID;
}

uint64_t C3DAnimationPlayerGetTypeID()
{
  if (C3DAnimationPlayerGetTypeID_onceToken != -1)
    dispatch_once(&C3DAnimationPlayerGetTypeID_onceToken, &__block_literal_global_25);
  return C3DAnimationPlayerGetTypeID_typeID;
}

uint64_t C3DAnimationGroupGetTypeID()
{
  if (C3DAnimationGroupGetTypeID_onceToken != -1)
    dispatch_once(&C3DAnimationGroupGetTypeID_onceToken, &__block_literal_global_91);
  return C3DAnimationGroupGetTypeID_typeID;
}

uint64_t C3DAnimationClusterGetTypeID()
{
  if (C3DAnimationClusterGetTypeID_onceToken != -1)
    dispatch_once(&C3DAnimationClusterGetTypeID_onceToken, &__block_literal_global_2);
  return C3DAnimationClusterGetTypeID_typeID;
}

uint64_t __ApplyMaterialDidChange(uint64_t a1, uint64_t **a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t Node;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      __RemoveVRAMResourceFromDic_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = *a2;
  if (!*a2)
  {
    v13 = scn_default_log();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      __ApplyMaterialDidChange_cold_1(v13, v14, v15, v16, v17, v18, v19, v20);
  }
  Node = C3DRendererElementGetNode(a1);
  if (Node)
    C3DNodeBoundingBoxDidUpdate(Node);
  return C3DEnginePipelineSyncRendererElement(*v12, a1, 27);
}

uint64_t C3DEnginePipelineSyncRendererElement(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;
  _QWORD v7[5];
  int v8;

  C3DRendererElementStoreSyncRendererElement(*(_QWORD *)(a1 + 48), a2, a3);
  result = *(_QWORD *)(a1 + 16);
  if (result)
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = __C3DEnginePipelineSyncRendererElement_block_invoke;
    v7[3] = &__block_descriptor_44_e29_v16__0____C3DEngineContext__8l;
    v7[4] = a2;
    v8 = a3;
    return C3DSceneEnumerateEngineContexts(result, (uint64_t)v7);
  }
  return result;
}

uint64_t C3DSceneUnlock(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 232));
}

uint64_t C3DSceneEnumerateEngineContexts(uint64_t a1, uint64_t a2)
{
  unint64_t v4;

  C3DSceneLock(a1);
  if (*(_WORD *)(a1 + 168))
  {
    if (*(_WORD *)(a1 + 168) == 1)
    {
      (*(void (**)(uint64_t, _QWORD))(a2 + 16))(a2, *(_QWORD *)(a1 + 160));
    }
    else
    {
      v4 = 0;
      do
        (*(void (**)(uint64_t, _QWORD))(a2 + 16))(a2, *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * v4++));
      while (v4 < *(unsigned __int16 *)(a1 + 168));
    }
  }
  return C3DSceneUnlock(a1);
}

uint64_t C3DEngineContextGetSortSystem(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 184);
}

_QWORD *C3DSortSystemInvalidateKeyForRendererElement(uint64_t a1, unsigned int *a2)
{
  uint64_t v3;
  _QWORD *result;

  v3 = *a2;
  result = (_QWORD *)C3DArrayGetCapacity(*(_QWORD *)(a1 + 16));
  if ((uint64_t)result > v3)
  {
    result = (_QWORD *)C3DArrayGetValuePtrAtIndex(*(_QWORD *)(a1 + 16), v3);
    *result = -1;
  }
  return result;
}

uint64_t C3DArrayGetCapacity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DArrayGetCount_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 28);
}

void C3DProgramHashCodeStoreInvalidateRendererElement(uint64_t a1, unsigned int *a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void **ValuePtrAtIndex;
  void **v7;

  if (*(_DWORD *)(a1 + 44) != -15)
  {
    v3 = 0;
    v4 = *a2;
    do
    {
      if ((*(_WORD *)(*(_QWORD *)(a1 + 32) + 2 * v3) & 1) != 0)
      {
        v5 = *(_QWORD *)(a1 + 24);
        if (C3DArrayGetCount(*(_QWORD *)(v5 + 8 * v3)) > v4)
        {
          ValuePtrAtIndex = (void **)C3DArrayGetValuePtrAtIndex(*(_QWORD *)(v5 + 8 * v3), v4);
          if (*ValuePtrAtIndex)
          {
            v7 = ValuePtrAtIndex;
            C3DIndexStoreRemoveIndexForKey(*(_QWORD *)(a1 + 48), *ValuePtrAtIndex);
            *v7 = 0;
          }
        }
      }
      ++v3;
    }
    while (v3 < (*(_DWORD *)(a1 + 44) + 15));
  }
}

uint64_t C3DSceneLock(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return pthread_mutex_lock((pthread_mutex_t *)(a1 + 232));
}

id C3DFXProgramCFFinalize(uint64_t a1)
{
  CFNumberRef v1;
  __CFNotificationCenter *LocalCenter;
  uint64_t v3;
  uint64_t valuePtr;

  valuePtr = a1;
  v1 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, CFSTR("kC3DNotificationProgramWillDie"), v1, 0, 1u);
  CFRelease(v1);
  v3 = valuePtr;
  if (*(_QWORD *)(valuePtr + 72))
  {
    CFRelease(*(CFTypeRef *)(valuePtr + 72));
    v3 = valuePtr;
    *(_QWORD *)(valuePtr + 72) = 0;
  }
  return C3DEntityCFFinalize(v3);
}

void _C3DProgramHashCodeCFFinalize(uint64_t a1)
{
  uint64_t SharedInstance;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  char v23;
  const void *v24;
  unsigned int v25;
  unint64_t v26;
  uint64_t v27;
  const void *v28;

  SharedInstance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, CFSTR("kC3DNotificationProgramHashCodeWillDie"), (const void *)a1, 0, 0);
  if (!CFDictionaryContainsKey((CFDictionaryRef)s_ProgramHashCodeDictionary, *(const void **)(a1 + 280)))
  {
    v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      _C3DProgramHashCodeCFFinalize_cold_2(v3, v4, v5, v6, v7, v8, v9, v10);
  }
  if (!*(_QWORD *)(a1 + 280))
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      _C3DProgramHashCodeCFFinalize_cold_1(v11, v12, v13, v14, v15, v16, v17, v18);
  }
  CFDictionaryRemoveValue((CFMutableDictionaryRef)s_ProgramHashCodeDictionary, *(const void **)(a1 + 280));
  v19 = *(const void **)(a1 + 280);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(a1 + 280) = 0;
  }
  v20 = 0;
  v21 = a1 + 16;
  v22 = 1;
  do
  {
    v23 = v22;
    v24 = *(const void **)(v21 + 8 * v20);
    if (v24)
    {
      CFRelease(v24);
      *(_QWORD *)(v21 + 8 * v20) = 0;
    }
    v22 = 0;
    v20 = 1;
  }
  while ((v23 & 1) != 0);
  v25 = *(unsigned __int8 *)(a1 + 162);
  if (*(_BYTE *)(a1 + 162))
  {
    v26 = 0;
    v27 = a1 + 216;
    do
    {
      v28 = *(const void **)(v27 + 8 * v26);
      if (v28)
      {
        CFRelease(v28);
        *(_QWORD *)(v27 + 8 * v26) = 0;
        v25 = *(unsigned __int8 *)(a1 + 162);
      }
      ++v26;
    }
    while (v26 < v25);
  }
}

void __HandleMaterialDidChangeNotifications(void *key, __int16 a2, uint64_t a3)
{
  const __CFSet *Value;
  const __CFSet *Copy;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD context[3];

  context[2] = *MEMORY[0x1E0C80C00];
  if (a2 == 2)
  {
    if ((a2 & 0x200) != 0)
    {
      Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)a3 + 40), key);
      if (Value)
      {
        Copy = CFSetCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Value);
        context[0] = a3;
        context[1] = key;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)__ApplyMaterialDidChange, context);
        CFRelease(Copy);
      }
    }
  }
  else
  {
    v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      __HandleMaterialDidChangeNotifications_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
  }
}

void C3DNodeSetPosition(uint64_t a1, __n128 a2)
{
  C3DTransformSetPosition((__n128 *)(a1 + 96), a2);
  __C3DNodeTransformDidChange((float32x4_t *)a1);
}

__n128 C3DTransformSetPosition(__n128 *a1, __n128 result)
{
  result.n128_u32[3] = 1.0;
  a1[3] = result;
  return result;
}

void _C3DTransactionCFFinalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  v2 = (const void *)a1[2];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[3];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[8];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[9];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)a1[10];
  if (v6)
    _Block_release(v6);
}

void __HandleNodeNotification(_DWORD *a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;

  v6 = *a3;
  v7 = a3[1];
  if (a2 != 1)
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      __HandleNodeNotification_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
      if ((a2 & 0x80000) == 0)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  if ((a2 & 0x80000) != 0)
  {
LABEL_4:
    C3DEnginePipelineRemoveNodeFromRendering(v6, (uint64_t)a1);
    C3DEnginePipelineAddNodeToRendering(v6, v7, a1);
  }
LABEL_5:
  if ((a2 & 0x100000) != 0)
  {
    v16 = C3DGetScene(a1);
    if (C3DNodeHasCamera((uint64_t)a1))
      C3DEngineContextSetDefaultPointOfView(a3[1], 0);
    if (v16 == C3DEngineContextGetScene(a3[1]))
    {
      C3DEnginePipelineAddNodeToRendering(v6, v7, a1);
      return;
    }
  }
  if ((a2 & 0x3F000) == 0)
    goto LABEL_16;
  if ((a2 & 0x1000) != 0)
  {
    C3DEnginePipelineSyncNodeAttribute(v6, a1, CFSTR("kMeshKey"), (uint64_t)a3);
    if ((a2 & 0x2000) == 0)
    {
LABEL_12:
      if ((a2 & 0x4000) == 0)
        goto LABEL_13;
LABEL_20:
      C3DEnginePipelineSyncNodeAttribute(v6, a1, CFSTR("kLightKey"), (uint64_t)a3);
      if ((a2 & 0x20000) == 0)
      {
LABEL_14:
        if ((a2 & 0x8000) == 0)
          goto LABEL_16;
        goto LABEL_15;
      }
      goto LABEL_21;
    }
  }
  else if ((a2 & 0x2000) == 0)
  {
    goto LABEL_12;
  }
  C3DEnginePipelineSyncNodeAttribute(v6, a1, CFSTR("kCameraKey"), (uint64_t)a3);
  C3DEngineContextSetDefaultPointOfView(a3[1], 0);
  if ((a2 & 0x4000) != 0)
    goto LABEL_20;
LABEL_13:
  if ((a2 & 0x20000) == 0)
    goto LABEL_14;
LABEL_21:
  C3DEnginePipelineSyncNodeAttribute(v6, a1, CFSTR("kDeformerStackKey"), (uint64_t)a3);
  if ((a2 & 0x8000) != 0)
LABEL_15:
    C3DEnginePipelineSyncNodeAttribute(v6, a1, CFSTR("rendererDelegate"), (uint64_t)a3);
LABEL_16:
  v17 = (a2 >> 9) & 4 | (a2 >> 7) & 8;
  if (v17)
    C3DEnginePipelineUpdateNodeRendererElements(v6, (uint64_t)a1, v17);
}

uint64_t C3DEngineContextGetScene(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 16);
}

uint64_t C3DNodeHasCamera(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 221) >> 2) & 1;
}

uint64_t __TrackRenderNodeDependencies(uint64_t a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;

  if (!a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (C3DNodeGetLight((uint64_t)a2))
    C3DEnginePipelineAddNodeForKeyIfAbsent(a1, a2, CFSTR("kLightKey"));
  if (C3DNodeGetCamera((uint64_t)a2))
    C3DEnginePipelineAddNodeForKeyIfAbsent(a1, a2, CFSTR("kCameraKey"));
  result = C3DNodeGetDeformerStack((uint64_t)a2);
  if (result)
    return C3DEnginePipelineAddNodeForKeyIfAbsent(a1, a2, CFSTR("kDeformerStackKey"));
  return result;
}

const __CFDictionary *C3DNodeGetCamera(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((*(_BYTE *)(a1 + 221) & 4) != 0)
    return C3DEntityGetAttribute(a1, CFSTR("kCameraKey"));
  else
    return 0;
}

uint64_t C3DSceneGetLightingEnvironmentEffectSlot(uint64_t a1, int a2)
{
  uint64_t v3;
  const void *v4;

  if (a2 && !*(_QWORD *)(a1 + 312))
  {
    v3 = C3DEffectSlotCreate(a1, 25);
    *(_QWORD *)(a1 + 312) = v3;
    v4 = (const void *)C3DTextureSamplerBilinearMipMapClampNoAnisotropy();
    C3DEffectSlotSetTextureSampler(v3, v4);
  }
  return *(_QWORD *)(a1 + 312);
}

BOOL C3DEffectSlotHasPrecomputedLightingEnvironment(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return C3DEffectSlotGetPrecomputedLightingEnvironment(a1) != 0;
}

uint64_t C3DEffectSlotGetPrecomputedLightingEnvironment(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererContextExecuteSlotTextureProxy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(_BYTE *)(a1 + 48) == 4)
    return *(_QWORD *)(a1 + 40);
  else
    return 0;
}

uint64_t C3DTextureSamplerBilinearMipMapClampNoAnisotropy()
{
  if (C3DTextureSamplerBilinearMipMapClampNoAnisotropy_onceToken != -1)
    dispatch_once(&C3DTextureSamplerBilinearMipMapClampNoAnisotropy_onceToken, &__block_literal_global_27);
  return C3DTextureSamplerBilinearMipMapClampNoAnisotropy_states;
}

void C3DNotificationCenterAddObserver(uint64_t a1, const void *a2, void (__cdecl *a3)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef), const __CFString *a4, const void *a5, CFNotificationSuspensionBehavior a6)
{
  __CFNotificationCenter *LocalCenter;

  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(LocalCenter, a2, a3, a4, a5, a6);
}

void *SCNMTLBufferPool::allocateAndCopy@<X0>(SCNMTLBufferPool *this@<X0>, const void *a2@<X1>, size_t a3@<X2>, void **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  SCNMTLBufferPool::allocate(this, a3, a4);
  return memcpy(*a4, a2, a3);
}

unint64_t SCNMTLBufferPool::allocate@<X0>(SCNMTLBufferPool *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t result;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  result = -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](*(_QWORD *)this);
  v7 = (a2 + 15) & 0xFFFFFFFFFFFFFFF0;
  v8 = *((_QWORD *)this + 11);
  v9 = v8 + v7;
  if (v8 + v7 > *((_QWORD *)this + 10))
  {
    do
    {
      v10 = *((_QWORD *)this + 4);
      v11 = *((unsigned int *)this + 14);
      if (v11 >= ((unint64_t)(*((_QWORD *)this + 5) - v10) >> 4))
      {
        v14 = 0;
        do
          v14 += *((_QWORD *)this + 1);
        while (v7 > v14);
        v15 = -[SCNMTLResourceManager newConstantBufferWithLength:options:](*(_QWORD *)this, v14, 16 * *((_QWORD *)this + 3));
        v16 = v15;
        *((_QWORD *)this + 8) = v15;
        v18 = *((_QWORD *)this + 5);
        v17 = *((_QWORD *)this + 6);
        if (v18 >= v17)
        {
          v20 = *((_QWORD *)this + 4);
          v21 = (uint64_t)(v18 - v20) >> 4;
          v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 60)
            abort();
          v23 = v17 - v20;
          if (v23 >> 3 > v22)
            v22 = v23 >> 3;
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0)
            v24 = 0xFFFFFFFFFFFFFFFLL;
          else
            v24 = v22;
          if (v24)
            v25 = (char *)_ZNSt3__119__allocate_at_leastB8nn180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)this + 48, v24);
          else
            v25 = 0;
          v26 = &v25[16 * v21];
          *(_QWORD *)v26 = v16;
          *((_DWORD *)v26 + 2) = 1;
          v28 = (char *)*((_QWORD *)this + 4);
          v27 = (char *)*((_QWORD *)this + 5);
          v29 = v26;
          if (v27 != v28)
          {
            do
            {
              *((_OWORD *)v29 - 1) = *((_OWORD *)v27 - 1);
              v29 -= 16;
              v27 -= 16;
            }
            while (v27 != v28);
            v27 = (char *)*((_QWORD *)this + 4);
          }
          v19 = v26 + 16;
          *((_QWORD *)this + 4) = v29;
          *((_QWORD *)this + 5) = v26 + 16;
          *((_QWORD *)this + 6) = &v25[16 * v24];
          if (v27)
            operator delete(v27);
        }
        else
        {
          *(_QWORD *)v18 = v15;
          *(_DWORD *)(v18 + 8) = 1;
          v19 = (char *)(v18 + 16);
        }
        *((_QWORD *)this + 5) = v19;
        LODWORD(v11) = *((_DWORD *)this + 14);
        v13 = (void *)*((_QWORD *)this + 8);
      }
      else
      {
        v12 = v10 + 16 * v11;
        v13 = *(void **)v12;
        *((_QWORD *)this + 8) = *(_QWORD *)v12;
        ++*(_DWORD *)(v12 + 8);
      }
      *((_DWORD *)this + 14) = v11 + 1;
      *((_QWORD *)this + 11) = 0;
      *((_QWORD *)this + 9) = objc_msgSend(v13, "contents");
      result = objc_msgSend(*((id *)this + 8), "length");
      *((_QWORD *)this + 10) = result;
      v8 = *((_QWORD *)this + 11);
      v9 = v8 + v7;
    }
    while (v8 + v7 > result);
  }
  a3[2] = v8;
  v30 = *((_QWORD *)this + 8);
  *a3 = *((_QWORD *)this + 9) + v8;
  a3[1] = v30;
  *((_QWORD *)this + 11) = v9;
  return result;
}

_QWORD *C3DEngineContextCleanup(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  *(_QWORD *)(a1 + 216) = 0;
  C3DEngineContextSetPointOfView(a1, 0);
  result = (_QWORD *)C3DEngineContextGetRendererContextGL(a1);
  if (result)
  {
    result = (_QWORD *)C3DEngineContextGetFXContext(a1);
    if (result)
    {
      C3DFXContextCleanup(result, a1);
      return C3DEngineContextSetFXContext(a1, 0);
    }
  }
  return result;
}

uint64_t C3DTransactionIsImmediate(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 60) >> 3) & 1;
}

double C3DTransactionGetDuration()
{
  return *((double *)C3DTransactionGetCurrent() + 4);
}

uint64_t C3DTransactionGetDisableActions()
{
  return (*((unsigned __int8 *)C3DTransactionGetCurrent() + 60) >> 2) & 1;
}

id *C3DEntityGetObjCWrapper(id *result)
{
  if (result)
    return (id *)objc_loadWeak(result + 2);
  return result;
}

void *SCNMTLComputeCommandEncoder::beginEncoding(_QWORD *a1, void *a2, int a3, uint64_t a4, uint64_t a5)
{
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  void *result;

  if (a1[207])
  {
    v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      SCNMTLComputeCommandEncoder::beginEncoding(v10, v11, v12);
  }
  bzero(a1, 0x6B0uLL);
  *((_DWORD *)a1 + 420) = a3;
  a1[208] = a2;
  result = (void *)objc_msgSend(a2, "computeCommandEncoder");
  a1[207] = result;
  a1[209] = a5;
  if (a4)
    return (void *)objc_msgSend(result, "setLabel:", a4);
  return result;
}

uint64_t SCNMTLBlitCommandEncoder::endEncoding(SCNMTLBlitCommandEncoder *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  if (!this->_encoder)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      SCNMTLBlitCommandEncoder::endEncoding(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = -[MTLBlitCommandEncoder endEncoding](this->_encoder, "endEncoding");
  this->_encoder = 0;
  this->_commandBuffer = 0;
  return result;
}

__n128 C3DSceneGetUpAxis(__n128 *a1, __n128 *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = a1[13];
  *a2 = result;
  return result;
}

id _C3DFXMetalProgramCFFinalize(_QWORD *a1)
{
  uint64_t v2;
  char v3;
  char v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;

  v2 = 0;
  v3 = 1;
  do
  {
    v4 = v3;
    v5 = (const void *)a1[v2 + 10];
    if (v5)
      CFRelease(v5);
    v3 = 0;
    v2 = 1;
  }
  while ((v4 & 1) != 0);
  v6 = (const void *)a1[17];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[12];
  if (v7)
  {
    CFRelease(v7);
    a1[12] = 0;
  }
  v8 = (const void *)a1[13];
  if (v8)
  {
    CFRelease(v8);
    a1[13] = 0;
  }
  v9 = (const void *)a1[14];
  if (v9)
  {
    CFRelease(v9);
    a1[14] = 0;
  }
  v10 = (const void *)a1[15];
  if (v10)
  {
    CFRelease(v10);
    a1[15] = 0;
  }
  v11 = (const void *)a1[16];
  if (v11)
  {
    CFRelease(v11);
    a1[16] = 0;
  }
  v12 = (const void *)a1[19];
  if (v12)
  {
    CFRelease(v12);
    a1[19] = 0;
  }
  v13 = (const void *)a1[20];
  if (v13)
  {
    CFRelease(v13);
    a1[20] = 0;
  }
  return C3DFXProgramCFFinalize((uint64_t)a1);
}

void C3DNodeGeometryDidUpdate(uint64_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  C3DNodeBoundingBoxDidUpdate((uint64_t)a1);
  C3DScenePostPipelineEvent(a1[6], 2, a1, CFSTR("kMeshKey"));
}

uint64_t _C3DStackAllocatorCFFinalize(uint64_t a1)
{
  return __destroyChuncks(a1, 0);
}

void __C3DMeshDeindex(CFArrayRef *a1, __CFArray **a2, __CFArray **a3, unsigned int **a4, unsigned int *a5, unsigned int **a6)
{
  __CFArray **v10;
  CFIndex Count;
  BOOL v13;
  uint64_t v14;
  const __CFAllocator *v15;
  uint64_t ChannelForSourceAtIndex;
  uint64_t v17;
  uint64_t ElementAtIndex;
  __int128 v19;
  __CFArray **v20;
  uint64_t v21;
  CFIndex v22;
  unsigned int IndicesChannelCount;
  unsigned int v24;
  NSObject *v25;
  int AllChannelsDefineSameTopology;
  const __CFAllocator *v27;
  const CFArrayCallBacks *v28;
  CFAllocatorRef v29;
  uint64_t *v30;
  unsigned __int8 v31;
  const __CFAllocator *v32;
  __C3DMesh *v33;
  const void *ValueAtIndex;
  uint64_t Accessor;
  unsigned __int8 v36;
  unsigned int v37;
  int ComponentsValueType;
  uint64_t ComponentsCountPerValue;
  uint64_t v40;
  uint64_t v42;
  int Semantic;
  size_t v44;
  __int128 v45;
  const __CFAllocator *v46;
  CFIndex v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  unint64_t v51;
  unsigned int v52;
  unsigned __int8 *v53;
  const UInt8 *v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  _OWORD *v58;
  unsigned __int8 v59;
  uint64_t v60;
  uint64_t v61;
  CFAllocatorRef v62;
  char **v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  size_t v67;
  char *v68;
  char *v69;
  uint64_t v70;
  unsigned int Index;
  const UInt8 *ValuePtrAtIndex;
  NSObject *v73;
  NSObject *v74;
  uint64_t v75;
  int v76;
  const __CFString *v77;
  uint64_t v78;
  int v79;
  int v80;
  char *v81;
  _DWORD *v82;
  char *v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  char *v88;
  char *v89;
  int v90;
  NSObject *v91;
  CFDataRef v92;
  const void *v93;
  __int128 v94;
  unsigned int ElementsCount;
  uint64_t v96;
  CFIndex v97;
  uint64_t v98;
  uint64_t v99;
  unsigned int v100;
  const __CFArray *v101;
  __CFArray *MutableCopy;
  NSObject *v103;
  CFMutableArrayRef Mutable;
  CFIndex v105;
  CFDataRef *v106;
  int Type;
  unsigned int PrimitiveCount;
  uint64_t BytesPerIndex;
  unsigned int IndexCount;
  unint64_t v111;
  void *v112;
  int v113;
  const UInt8 *BytePtr;
  CFDataRef v115;
  const void *v116;
  NSObject *v117;
  _DWORD *v118;
  size_t v119;
  uint64_t v120;
  char v121;
  int v122;
  char **v123;
  int v124;
  int v125;
  NSObject *v126;
  CFAllocatorRef v127;
  char **v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  size_t v132;
  char *v133;
  char *v134;
  const UInt8 *v135;
  NSObject *v136;
  uint64_t v137;
  int v138;
  const __CFString *v139;
  char *v140;
  _DWORD *v141;
  char *v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  unint64_t v146;
  char *v147;
  char *v148;
  int v149;
  uint64_t v150;
  size_t v151;
  void *v152;
  __int16 *v153;
  CFAllocatorRef v154;
  __CFArray *v155;
  uint64_t v156;
  __int16 v157;
  uint64_t v158;
  CFDataRef v159;
  const void *v160;
  CFDataRef v161;
  void **v162;
  CFAllocatorRef v163;
  unsigned int **v164;
  void *v165;
  const __CFAllocator *v166;
  __CFArray **v167;
  __CFArray **v168;
  unsigned int *v169;
  NSObject *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  CFIndex v178;
  NSObject *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  int *v188;
  CFMutableArrayRef v189;
  uint64_t *v190;
  unsigned int **v191;
  unsigned int *v192;
  unsigned int **v193;
  uint64_t *v194;
  __CFArray **v195;
  __CFArray **v196;
  CFAllocatorRef v197;
  CFArrayRef v198;
  uint64_t v199;
  int v200;
  CFIndex v201;
  CFIndex v202;
  CFAllocatorRef v203;
  size_t v204;
  uint64_t v205;
  __C3DMesh *v206;
  uint64_t v207;
  uint64_t v208;
  __int128 *v209;
  int v210;
  __int128 v211;
  _QWORD *v212;
  uint64_t v213;
  _DWORD *v214;
  char **v215;
  unint64_t v216;
  unsigned __int8 *v217;
  uint64_t v218;
  CFAllocatorRef v219;
  uint64_t v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;
  __n128 v225;
  uint64_t v226;
  __int128 v227;
  __int128 v228;
  __n128 v229;
  uint64_t v230;
  uint8_t v231[4];
  int v232;
  _BYTE buf[24];
  void *v234;
  _QWORD *v235;
  void *v236;
  uint64_t v237;
  unint64_t v238;
  unsigned int v239;
  _QWORD v240[3];
  int v241;
  uint64_t v242;

  v10 = a2;
  v242 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  Count = CFArrayGetCount(a1[8]);
  v206 = (__C3DMesh *)a1;
  v202 = CFArrayGetCount(a1[12]);
  v219 = (CFAllocatorRef)Count;
  if (Count < 1)
  {
    LOBYTE(v17) = 0;
    goto LABEL_83;
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  while (1)
  {
    ChannelForSourceAtIndex = C3DMeshGetChannelForSourceAtIndex((uint64_t)v206, (uint64_t)v15);
    v17 = ChannelForSourceAtIndex;
    if (v15)
      break;
LABEL_6:
    v15 = (const __CFAllocator *)((char *)v15 + 1);
    v13 = (uint64_t)v15 >= (uint64_t)v219;
    v14 = v17;
    if (v219 == v15)
      goto LABEL_83;
  }
  if (v14 == ChannelForSourceAtIndex)
  {
    v17 = v14;
    goto LABEL_6;
  }
  if (v13 || v202 < 1)
  {
    LOBYTE(v17) = v14;
    goto LABEL_83;
  }
  ElementAtIndex = C3DMeshGetElementAtIndex((int)v206, 0);
  v192 = a5;
  v193 = a6;
  v191 = a4;
  if (!C3DMeshElementGetAllChannelsDefineSameTopology(ElementAtIndex))
    goto LABEL_20;
  v20 = a3;
  *(_QWORD *)&v19 = 134218496;
  v222 = v19;
  v21 = 1;
  do
  {
    v22 = v21;
    IndicesChannelCount = C3DMeshElementGetIndicesChannelCount(ElementAtIndex);
    if (IndicesChannelCount >= 2
      && (__C3DMeshDeindex(__C3DMesh *,__CFArray **,__CFArray **,unsigned int **,unsigned int *,unsigned int **)::done & 1) == 0)
    {
      v24 = IndicesChannelCount;
      __C3DMeshDeindex(__C3DMesh *,__CFArray **,__CFArray **,unsigned int **,unsigned int *,unsigned int **)::done = 1;
      v25 = scn_default_log();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = v222;
        *(_QWORD *)&buf[4] = ElementAtIndex;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v206;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v234) = v24;
        _os_log_error_impl(&dword_1DCCB8000, v25, OS_LOG_TYPE_ERROR, "Warning: Mesh element %p of mesh %p has %d channels but they all define the same topology", buf, 0x1Cu);
      }
    }
    if (v202 == v22)
      break;
    ElementAtIndex = C3DMeshGetElementAtIndex((int)v206, v22);
    AllChannelsDefineSameTopology = C3DMeshElementGetAllChannelsDefineSameTopology(ElementAtIndex);
    v21 = v22 + 1;
  }
  while (AllChannelsDefineSameTopology);
  LOBYTE(v17) = v14;
  a3 = v20;
  if (v22 >= v202)
  {
LABEL_83:
    ElementsCount = C3DMeshGetElementsCount((uint64_t)v206);
    LODWORD(v96) = ElementsCount;
    if (ElementsCount)
    {
      v97 = 0;
      v98 = ElementsCount;
      while (1)
      {
        v99 = C3DMeshGetElementAtIndex((int)v206, v97);
        v100 = C3DMeshElementGetIndicesChannelCount(v99);
        if (v100 <= v17)
        {
          v103 = scn_default_log();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
            __C3DMeshDeindex(v17, v99, v103);
          return;
        }
        if (v100 >= 2)
          break;
        if (v98 == ++v97)
          goto LABEL_88;
      }
      v195 = v10;
      v196 = a3;
      *(_QWORD *)&v222 = *MEMORY[0x1E0C9AE00];
      Mutable = CFArrayCreateMutable((CFAllocatorRef)v222, v96, MEMORY[0x1E0C9B378]);
      MutableCopy = Mutable;
      v105 = 0;
      v220 = v17;
      v219 = (CFAllocatorRef)*MEMORY[0x1E0C9AE10];
      if (v96 <= 1)
        v96 = 1;
      else
        v96 = v96;
      *(_QWORD *)&v221 = Mutable;
      v218 = v96;
      do
      {
        v106 = (CFDataRef *)C3DMeshGetElementAtIndex((int)v206, v105);
        if (C3DMeshElementGetIndicesChannelCount((uint64_t)v106) == 1)
        {
          CFArrayAppendValue(MutableCopy, v106);
        }
        else
        {
          Type = C3DMeshElementGetType((uint64_t)v106);
          PrimitiveCount = C3DMeshElementGetPrimitiveCount((uint64_t)v106);
          BytesPerIndex = C3DMeshElementGetBytesPerIndex((uint64_t)v106);
          IndexCount = C3DMeshElementGetIndexCount((uint64_t)v106);
          if (Type == 4)
          {
            v111 = BytesPerIndex * (unint64_t)(IndexCount + PrimitiveCount);
            v112 = malloc_type_malloc(v111, 0x88C313D8uLL);
            v113 = PrimitiveCount;
            BytePtr = CFDataGetBytePtr(v106[12]);
            memcpy(v112, BytePtr, PrimitiveCount * (unint64_t)BytesPerIndex);
          }
          else
          {
            v111 = IndexCount * (unint64_t)BytesPerIndex;
            v112 = malloc_type_malloc(v111, 0xE8BBA66CuLL);
            v113 = PrimitiveCount;
            PrimitiveCount = 0;
          }
          v240[0] = 0;
          v240[1] = v240;
          v240[2] = 0x2000000000;
          v241 = 0;
          v230 = 0;
          v228 = 0u;
          v229 = 0u;
          v227 = 0u;
          C3DMeshElementGetContent((uint64_t)v106, v220, (uint64_t)&v227);
          v223 = v227;
          v224 = v228;
          v225 = v229;
          v226 = v230;
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZL40__C3DMeshCopyDeindexedElementsForChannelP9__C3DMeshh_block_invoke;
          v234 = &unk_1EA5A52F0;
          v239 = PrimitiveCount;
          v235 = v240;
          v236 = v112;
          v237 = BytesPerIndex;
          v238 = v111;
          C3DIndicesContentEnumeratePrimitives((uint64_t *)&v223, (uint64_t)buf, v229);
          v115 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)v222, (const UInt8 *)v112, v111, v219);
          v116 = (const void *)C3DMeshElementCreate();
          C3DMeshElementInit((uint64_t)v116, Type, v113, v115, BytesPerIndex);
          MutableCopy = (__CFArray *)v221;
          CFArrayAppendValue((CFMutableArrayRef)v221, v116);
          CFRelease(v115);
          CFRelease(v116);
          _Block_object_dispose(v240, 8);
          v96 = v218;
        }
        ++v105;
      }
      while (v96 != v105);
      v10 = v195;
      a3 = v196;
      if (!MutableCopy)
        return;
    }
    else
    {
LABEL_88:
      v101 = (const __CFArray *)*((_QWORD *)v206 + 12);
      *(_QWORD *)&v222 = *MEMORY[0x1E0C9AE00];
      MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)v222, 0, v101);
      if (!MutableCopy)
        return;
    }
    *v10 = CFArrayCreateMutableCopy((CFAllocatorRef)v222, 0, *((CFArrayRef *)v206 + 8));
    *a3 = MutableCopy;
  }
  else
  {
LABEL_20:
    v195 = v10;
    v196 = a3;
    v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v28 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    v29 = v219;
    v189 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFIndex)v219, MEMORY[0x1E0C9B378]);
    v203 = v27;
    v198 = CFArrayCreateMutable(v27, v202, v28);
    v190 = &v187;
    MEMORY[0x1E0C80A78](v198);
    v30 = &v187 - 8 * (_QWORD)v29;
    v31 = 0;
    v204 = 0;
    v32 = 0;
    v194 = v30;
    do
    {
      v33 = v206;
      ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)v206 + 8), (CFIndex)v32);
      Accessor = C3DMeshSourceGetAccessor();
      v36 = C3DMeshGetChannelForSourceAtIndex((uint64_t)v33, (uint64_t)v32);
      v37 = C3DSourceAccessorGetCount(Accessor);
      ComponentsValueType = C3DSourceAccessorGetComponentsValueType(Accessor);
      ComponentsCountPerValue = C3DSourceAccessorGetComponentsCountPerValue(Accessor);
      v40 = C3DSizeOfBaseType(ComponentsValueType);
      if (ComponentsValueType == 15 && ComponentsCountPerValue == 3)
      {
        v42 = 4 * C3DSizeOfBaseType(15);
        ComponentsCountPerValue = 4;
      }
      else
      {
        v42 = v40 * ComponentsCountPerValue;
      }
      *v30 = (uint64_t)ValueAtIndex;
      v30[1] = Accessor;
      *((_BYTE *)v30 + 16) = v36;
      v30[3] = v42;
      *((_WORD *)v30 + 16) = ComponentsValueType;
      v30[5] = ComponentsCountPerValue;
      *((_DWORD *)v30 + 14) = 0;
      *((_DWORD *)v30 + 15) = v37;
      v30[6] = (uint64_t)malloc_type_malloc(v42 * v37, 0x7483DA0FuLL);
      Semantic = C3DMeshSourceGetSemantic((uint64_t)ValueAtIndex);
      if (Semantic)
        v44 = v204;
      else
        v44 = v37;
      v204 = v44;
      if (!Semantic)
        v31 = v36;
      v32 = (const __CFAllocator *)((char *)v32 + 1);
      v30 += 8;
    }
    while (v219 != v32);
    v227 = 0uLL;
    *(_QWORD *)&v228 = 0;
    v214 = malloc_type_calloc(v204, 4uLL, 0x100004052888210uLL);
    *((_QWORD *)&v223 + 1) = 0;
    *(_QWORD *)&v224 = 0;
    *(_QWORD *)&v223 = (char *)&v223 + 8;
    v46 = v203;
    if (v202 < 1)
      goto LABEL_107;
    v47 = 0;
    v210 = 0;
    v212 = (_QWORD *)((char *)v240 + 4);
    v213 = v31;
    v209 = &v228;
    v188 = &v232;
    v197 = (CFAllocatorRef)*MEMORY[0x1E0C9AE10];
    v215 = (char **)(v194 + 6);
    *(_QWORD *)&v45 = 134218498;
    v211 = v45;
    do
    {
      v48 = C3DMeshGetElementAtIndex((int)v206, v47);
      v49 = C3DMeshElementGetType(v48);
      v50 = C3DMeshElementGetPrimitiveCount(v48);
      v51 = C3DMeshElementGetBytesPerIndex(v48);
      v52 = C3DMeshElementGetIndexCount(v48);
      v200 = v49;
      v201 = v47;
      v199 = v52;
      if (v49 == 4)
      {
        v218 = (v52 + v50) * v51;
        v53 = (unsigned __int8 *)malloc_type_malloc(v218, 0xB7678F60uLL);
        v54 = CFDataGetBytePtr(*(CFDataRef *)(v48 + 96));
        v217 = v53;
        memcpy(v53, v54, v50 * v51);
        v205 = v50;
      }
      else
      {
        v218 = v52 * (unint64_t)v51;
        v217 = (unsigned __int8 *)malloc_type_malloc(v218, 0x12FE990EuLL);
        v205 = 0;
      }
      if (v50 < 1)
      {
        v208 = 0;
      }
      else
      {
        v55 = 0;
        v207 = v50;
        v208 = 0;
        v216 = v51;
        do
        {
          *(_QWORD *)&v221 = C3DMeshElementGetVertexCountForPrimitiveAtIndex(v48, v55);
          if ((uint64_t)v221 >= 1)
          {
            v56 = 0;
            v220 = v208 + v205;
            *(_QWORD *)&v222 = v55;
            do
            {
              v57 = v224;
              *(_QWORD *)buf = v48;
              *(_QWORD *)&buf[8] = v55;
              *(_QWORD *)&buf[16] = v56;
              LODWORD(v234) = v224;
              v58 = std::__tree<std::__value_type<__C3DMeshDeindexerKey,unsigned int>,std::__map_value_compare<__C3DMeshDeindexerKey,std::__value_type<__C3DMeshDeindexerKey,unsigned int>,__C3DMeshDeindexerKeyComparator,true>,std::allocator<std::__value_type<__C3DMeshDeindexerKey,unsigned int>>>::__emplace_unique_key_args<__C3DMeshDeindexerKey,std::pair<__C3DMeshDeindexerKey,unsigned int>>((uint64_t **)&v223, (uint64_t *)buf, (uint64_t)buf);
              v60 = v59;
              v61 = v56;
              __writeIndexInBuffer(v217, v220 + v56, *((_DWORD *)v58 + 14), v51, v218);
              v62 = v219;
              v63 = v215;
              if (v60)
              {
                do
                {
                  v65 = *((unsigned int *)v63 + 2);
                  v64 = *((_DWORD *)v63 + 3);
                  if (v64 == (_DWORD)v65)
                  {
                    v66 = (2 * v64);
                    *((_DWORD *)v63 + 3) = v66;
                    v67 = (size_t)*(v63 - 3);
                    v68 = (char *)malloc_type_realloc(*v63, v67 * v66, 0x24965B07uLL);
                    *v63 = v68;
                  }
                  else
                  {
                    v68 = *v63;
                    v67 = (size_t)*(v63 - 3);
                  }
                  v69 = &v68[v67 * v65];
                  v70 = v48;
                  Index = C3DMeshElementGetIndex(v48, v222, v61, *((unsigned __int8 *)v63 - 32));
                  ValuePtrAtIndex = C3DSourceAccessorGetValuePtrAtIndex(*(v63 - 5), Index);
                  if (ValuePtrAtIndex)
                  {
                    memcpy(v69, ValuePtrAtIndex, v67);
                  }
                  else
                  {
                    bzero(v69, v67);
                    v73 = scn_default_log();
                    if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
                    {
                      v75 = (uint64_t)*(v63 - 6);
                      v76 = C3DMeshSourceGetSemantic(v75);
                      v77 = C3DMeshSourceSemanticToSemanticString(v76);
                      *(_DWORD *)buf = v211;
                      *(_QWORD *)&buf[4] = v75;
                      *(_WORD *)&buf[12] = 2112;
                      *(_QWORD *)&buf[14] = v77;
                      *(_WORD *)&buf[22] = 1024;
                      LODWORD(v234) = Index;
                      _os_log_error_impl(&dword_1DCCB8000, v73, OS_LOG_TYPE_ERROR, "Error: Deindexer failed - Source %p (%@) has no original data at index %u", buf, 0x1Cu);
                    }
                  }
                  if ((_DWORD)v65 != v57)
                  {
                    v74 = scn_default_log();
                    if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
                      __C3DMeshDeindex((uint8_t *)v240, v212, v74);
                  }
                  *((_DWORD *)v63 + 2) = v65 + 1;
                  v63 += 8;
                  v62 = (CFAllocatorRef)((char *)v62 - 1);
                  v48 = v70;
                }
                while (v62);
                v78 = v70;
                v55 = v222;
                v56 = v61;
                v79 = C3DMeshElementGetIndex(v78, v222, v61, v213);
                v80 = v79;
                v81 = (char *)*((_QWORD *)&v227 + 1);
                if (*((_QWORD *)&v227 + 1) >= (unint64_t)v228)
                {
                  v83 = (char *)v227;
                  v84 = (uint64_t)(*((_QWORD *)&v227 + 1) - v227) >> 2;
                  v85 = v84 + 1;
                  if ((unint64_t)(v84 + 1) >> 62)
LABEL_156:
                    abort();
                  v86 = v228 - v227;
                  if ((uint64_t)(v228 - v227) >> 1 > v85)
                    v85 = v86 >> 1;
                  if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFFCLL)
                    v87 = 0x3FFFFFFFFFFFFFFFLL;
                  else
                    v87 = v85;
                  if (v87)
                  {
                    v88 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v209, v87);
                    v81 = (char *)*((_QWORD *)&v227 + 1);
                    v83 = (char *)v227;
                  }
                  else
                  {
                    v88 = 0;
                  }
                  v89 = &v88[4 * v84];
                  *(_DWORD *)v89 = v80;
                  v82 = v89 + 4;
                  while (v81 != v83)
                  {
                    v90 = *((_DWORD *)v81 - 1);
                    v81 -= 4;
                    *((_DWORD *)v89 - 1) = v90;
                    v89 -= 4;
                  }
                  *(_QWORD *)&v227 = v89;
                  *((_QWORD *)&v227 + 1) = v82;
                  *(_QWORD *)&v228 = &v88[4 * v87];
                  if (v83)
                    operator delete(v83);
                }
                else
                {
                  **((_DWORD **)&v227 + 1) = v79;
                  v82 = v81 + 4;
                }
                *((_QWORD *)&v227 + 1) = v82;
                if (!v214[v80])
                  v214[v80] = (unint64_t)((unint64_t)v82 - v227) >> 2;
                v51 = v216;
              }
              else
              {
                v210 = 1;
                v51 = v216;
                v55 = v222;
              }
              ++v56;
            }
            while (v56 != (_QWORD)v221);
          }
          LODWORD(v50) = v207;
          v208 += v221;
          ++v55;
        }
        while (v55 != v207);
      }
      if (v208 != v199)
      {
        v91 = scn_default_log();
        if (os_log_type_enabled(v91, OS_LOG_TYPE_FAULT))
          __C3DMeshDeindex(v231, v188, v91);
      }
      v46 = v203;
      v92 = CFDataCreateWithBytesNoCopy(v203, v217, v218, v197);
      v93 = (const void *)C3DMeshElementCreate();
      C3DMeshElementInit((uint64_t)v93, v200, v50, v92, v51);
      CFArrayAppendValue(v198, v93);
      CFRelease(v93);
      CFRelease(v92);
      v47 = v201 + 1;
    }
    while (v201 + 1 != v202);
    if ((v210 & 1) == 0)
    {
LABEL_107:
      v117 = scn_default_log();
      if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v206;
        _os_log_impl(&dword_1DCCB8000, v117, OS_LOG_TYPE_DEFAULT, "Warning: Mesh %p has multiple channels but deindexing didn't have any effect", buf, 0xCu);
      }
    }
    v118 = v214;
    v119 = v204;
    if ((_DWORD)v204)
    {
      v120 = 0;
      v121 = 0;
      v122 = 0;
      v220 = (uint64_t)&v228;
      v123 = (char **)(v194 + 6);
      *(_QWORD *)&v94 = 67109376;
      v222 = v94;
      *(_QWORD *)&v94 = 134218498;
      v221 = v94;
      do
      {
        v124 = v118[v120];
        if (v124)
        {
          v125 = v124 - 1;
        }
        else
        {
          v126 = scn_default_log();
          if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = v222;
            *(_DWORD *)&buf[4] = v120;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = v119;
            _os_log_impl(&dword_1DCCB8000, v126, OS_LOG_TYPE_DEFAULT, "Warning: Deindexing - Vertex at index %u of %u is not used by any geometry element", buf, 0xEu);
          }
          v127 = v219;
          v128 = v123;
          if ((v121 & 1) != 0)
          {
            v121 = 1;
            v125 = v122;
            v46 = v203;
            v119 = v204;
            v118 = v214;
          }
          else
          {
            do
            {
              v130 = *((unsigned int *)v128 + 2);
              v129 = *((_DWORD *)v128 + 3);
              if (v129 == (_DWORD)v130)
              {
                v131 = (2 * v129);
                *((_DWORD *)v128 + 3) = v131;
                v132 = (size_t)*(v128 - 3);
                v133 = (char *)malloc_type_realloc(*v128, v132 * v131, 0x675A9096uLL);
                *v128 = v133;
              }
              else
              {
                v133 = *v128;
                v132 = (size_t)*(v128 - 3);
              }
              v134 = &v133[v132 * v130];
              v135 = C3DSourceAccessorGetValuePtrAtIndex(*(v128 - 5), 0);
              if (v135)
              {
                memcpy(v134, v135, v132);
              }
              else
              {
                bzero(v134, v132);
                v136 = scn_default_log();
                if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
                {
                  v137 = (uint64_t)*(v128 - 6);
                  v138 = C3DMeshSourceGetSemantic(v137);
                  v139 = C3DMeshSourceSemanticToSemanticString(v138);
                  *(_DWORD *)buf = v221;
                  *(_QWORD *)&buf[4] = v137;
                  *(_WORD *)&buf[12] = 2112;
                  *(_QWORD *)&buf[14] = v139;
                  *(_WORD *)&buf[22] = 1024;
                  LODWORD(v234) = 0;
                  _os_log_error_impl(&dword_1DCCB8000, v136, OS_LOG_TYPE_ERROR, "Error: Deindexer failed - Source %p (%@) has no original data at index %u", buf, 0x1Cu);
                }
              }
              *((_DWORD *)v128 + 2) = v130 + 1;
              v128 += 8;
              v127 = (CFAllocatorRef)((char *)v127 - 1);
            }
            while (v127);
            v140 = (char *)*((_QWORD *)&v227 + 1);
            if (*((_QWORD *)&v227 + 1) >= (unint64_t)v228)
            {
              v142 = (char *)v227;
              v143 = (uint64_t)(*((_QWORD *)&v227 + 1) - v227) >> 2;
              v144 = v143 + 1;
              v46 = v203;
              v119 = v204;
              if ((unint64_t)(v143 + 1) >> 62)
                goto LABEL_156;
              v145 = v228 - v227;
              if ((uint64_t)(v228 - v227) >> 1 > v144)
                v144 = v145 >> 1;
              if ((unint64_t)v145 >= 0x7FFFFFFFFFFFFFFCLL)
                v146 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v146 = v144;
              if (v146)
              {
                v147 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v220, v146);
                v140 = (char *)*((_QWORD *)&v227 + 1);
                v142 = (char *)v227;
              }
              else
              {
                v147 = 0;
              }
              v148 = &v147[4 * v143];
              *(_DWORD *)v148 = v120;
              v141 = v148 + 4;
              while (v140 != v142)
              {
                v149 = *((_DWORD *)v140 - 1);
                v140 -= 4;
                *((_DWORD *)v148 - 1) = v149;
                v148 -= 4;
              }
              *(_QWORD *)&v227 = v148;
              *((_QWORD *)&v227 + 1) = v141;
              *(_QWORD *)&v228 = &v147[4 * v146];
              if (v142)
                operator delete(v142);
            }
            else
            {
              **((_DWORD **)&v227 + 1) = v120;
              v141 = v140 + 4;
              v46 = v203;
              v119 = v204;
            }
            v118 = v214;
            *((_QWORD *)&v227 + 1) = v141;
            v125 = ((unint64_t)((unint64_t)v141 - v227) >> 2) - 1;
            v121 = 1;
            v122 = v125;
          }
        }
        v118[v120++] = v125;
      }
      while (v120 != v119);
    }
    v150 = (*((_QWORD *)&v227 + 1) - (_QWORD)v227) >> 2;
    v151 = (*((_QWORD *)&v227 + 1) - v227) & 0x3FFFFFFFCLL;
    v152 = malloc_type_malloc(v151, 0xE4931FB5uLL);
    memcpy(v152, (const void *)v227, v151);
    v153 = (__int16 *)(v194 + 4);
    v154 = v219;
    v155 = v189;
    do
    {
      v156 = *((unsigned int *)v153 + 6);
      v157 = C3DMeshSourceGetSemantic(*((_QWORD *)v153 - 4));
      v158 = *((_QWORD *)v153 - 1);
      v159 = CFDataCreate(v46, *((const UInt8 **)v153 + 2), v158 * v156);
      v160 = (const void *)C3DMeshSourceCreateWithData(v157, v159, *v153, *((_QWORD *)v153 + 1), v156, v158, 0);
      CFArrayAppendValue(v155, v160);
      CFRelease(v160);
      v161 = v159;
      v46 = v203;
      CFRelease(v161);
      v153 += 32;
      v154 = (CFAllocatorRef)((char *)v154 - 1);
    }
    while (v154);
    v162 = (void **)(v194 + 6);
    v163 = v219;
    v164 = v191;
    do
    {
      v165 = *v162;
      v162 += 8;
      free(v165);
      v163 = (CFAllocatorRef)((char *)v163 - 1);
    }
    while (v163);
    v166 = (const __CFAllocator *)CFArrayGetCount(v155);
    v168 = v195;
    v167 = v196;
    v169 = v192;
    if (v219 != v166)
    {
      v170 = scn_default_log();
      if (os_log_type_enabled(v170, OS_LOG_TYPE_FAULT))
        __C3DMeshDeindex(v170, v171, v172, v173, v174, v175, v176, v177);
    }
    v178 = CFArrayGetCount(v198);
    if (v202 != v178)
    {
      v179 = scn_default_log();
      if (os_log_type_enabled(v179, OS_LOG_TYPE_FAULT))
        __C3DMeshDeindex(v179, v180, v181, v182, v183, v184, v185, v186);
    }
    *v168 = v155;
    *v167 = v198;
    *v164 = (unsigned int *)v152;
    *v169 = v150;
    *v193 = v214;
    std::__tree<char>::destroy((uint64_t)&v223, *((_QWORD **)&v223 + 1));
    if ((_QWORD)v227)
    {
      *((_QWORD *)&v227 + 1) = v227;
      operator delete((void *)v227);
    }
  }
}

uint64_t C3DMeshGetChannelForSourceAtIndex(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!*(_QWORD *)(a1 + 104))
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DMeshGetChannelForSourceAtIndex_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 104) + a2);
}

uint64_t C3DMeshElementGetIndicesChannelCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 130);
}

uint64_t C3DShaderModifierGetFlags(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(__int16 *)(a1 + 92);
}

uint64_t C3DSceneCreate()
{
  uint64_t Instance;
  uint64_t v1;
  __C3DTransformTree *v2;
  uint64_t v3;
  pthread_mutexattr_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (C3DSceneGetTypeID_onceToken != -1)
    dispatch_once(&C3DSceneGetTypeID_onceToken, &__block_literal_global_66);
  Instance = C3DTypeCreateInstance_(C3DSceneGetTypeID_typeID, 0x1A0uLL);
  v1 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 48) = Instance;
    *(_QWORD *)(Instance + 72) = C3DAnimationManagerCreate();
    *(_QWORD *)(v1 + 80) = C3DConstraintManagerCreate(v1);
    *(_QWORD *)(v1 + 96) = C3DModelValueStorageCreate();
    *(_QWORD *)(v1 + 128) = C3DLightingSystemCreate(v1);
    *(_QWORD *)(v1 + 136) = C3DDynamicBatchingSystemCreate();
    *(_QWORD *)(v1 + 192) = 0x3F80000042700000;
    *(_DWORD *)(v1 + 212) = 1065353216;
    if ((C3DWasLinkedBeforeMajorOSYear2017() & 1) == 0)
      *(_DWORD *)(v1 + 224) = 1065353216;
    *(_QWORD *)(v1 + 328) = 0;
    *(_DWORD *)(v1 + 336) = 1065353216;
    C3DColor4Make((float *)(v1 + 352), 1.0, 1.0, 1.0, 1.0);
    *(_BYTE *)(v1 + 368) = 0;
    *(_WORD *)(v1 + 370) = 64;
    *(_QWORD *)(v1 + 372) = 0x41000000447A0000;
    *(_QWORD *)(v1 + 120) = C3DEnginePipelineCreate(v1);
    v2 = (__C3DTransformTree *)C3DTransformTreeCreate(v1);
    *(_QWORD *)(v1 + 152) = v2;
    C3DCullingSystemCreate(v2);
    *(_QWORD *)(v1 + 144) = v3;
    C3DAnimationManagerSetModelValueStorage(*(_QWORD *)(v1 + 72), *(CFTypeRef *)(v1 + 96));
    v5.__sig = 0;
    *(_QWORD *)v5.__opaque = 0;
    pthread_mutexattr_init(&v5);
    pthread_mutexattr_settype(&v5, 2);
    pthread_mutex_init((pthread_mutex_t *)(v1 + 232), &v5);
    pthread_mutexattr_destroy(&v5);
  }
  return v1;
}

void __C3DCullingSystem::__C3DCullingSystem(__C3DCullingSystem *this, __C3DTransformTree *a2)
{
  int v4;
  int v5;
  __C3DTransformTree *v6;
  CFTypeRef v7;
  void *v8;
  int v9;
  void *v10;
  uint64_t (*v11)(uint64_t, unsigned int, unsigned int);
  uint64_t (*v12)(uint64_t);
  uint64_t (*v13)(uint64_t, unsigned int, unsigned int);
  uint64_t (*v14)(int32x2_t *, unsigned int, unsigned int);
  uint64_t (*v15)(uint64_t);
  uint64_t (*v16)(int32x2_t *, unsigned int, unsigned int);
  void *v17;
  void *v18;

  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 14) = -1;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 12) = 0;
  v4 = C3DGetCPUCaps();
  if ((v4 & 0x20) != 0)
    v5 = 8;
  else
    v5 = 4;
  *((_DWORD *)this + 6) = v5;
  *((_DWORD *)this + 7) = v4;
  __C3DCullingSystem::_allocateData(this, 0x80u);
  v6 = (__C3DTransformTree *)*((_QWORD *)this + 17);
  if (v6 != a2)
  {
    if (v6)
    {
      CFRelease(v6);
      *((_QWORD *)this + 17) = 0;
    }
    if (a2)
      v7 = CFRetain(a2);
    else
      v7 = 0;
    *((_QWORD *)this + 17) = v7;
  }
  if ((*((_DWORD *)this + 7) & 0x20) != 0)
  {
    *((_QWORD *)this + 19) = C3DParticleManagerGetUpdateQueue();
    *((_QWORD *)this + 18) = C3DParticleManagerGetUpdateQueue();
    *((_QWORD *)this + 22) = C3DParticleManagerGetUpdateQueue();
    *((_QWORD *)this + 23) = C3DParticleManagerGetUpdateQueue();
    *((_QWORD *)this + 24) = C3DParticleManagerGetUpdateQueue();
    *((_QWORD *)this + 20) = C3DParticleManagerGetUpdateQueue();
    *((_QWORD *)this + 21) = C3DParticleManagerGetUpdateQueue();
  }
  else
  {
    v8 = C3DCullingSystem_AABBRange_x1;
    v9 = *((_DWORD *)this + 6);
    if (v9 == 4)
    {
      v8 = C3DCullingSystem_AABBRange_x4;
      v10 = C3DCullingSystem_MergeAABBRange_x4;
    }
    else
    {
      v10 = C3DCullingSystem_MergeAABBRange_x1;
    }
    v11 = C3DCullingSystem_CullRange_x1<false,false>;
    if (v9 == 4)
      v11 = C3DCullingSystem_CullRange_x4<false,false>;
    v12 = (uint64_t (*)(uint64_t))C3DCullingSystem_CullRange_x1<false,true>;
    if (v9 == 4)
      v12 = C3DCullingSystem_CullRange_x4<false,true>;
    v13 = C3DCullingSystem_CullRange_x1<true,false>;
    if (v9 == 4)
      v13 = C3DCullingSystem_CullRange_x4<true,false>;
    if (v9 == 8)
    {
      v8 = C3DCullingSystem_AABBRange_x8;
      v10 = C3DCullingSystem_MergeAABBRange_x8;
    }
    *((_QWORD *)this + 18) = v10;
    *((_QWORD *)this + 19) = v8;
    v14 = C3DCullingSystem_CullRange_x8<false,false>;
    if (v9 != 8)
      v14 = (uint64_t (*)(int32x2_t *, unsigned int, unsigned int))v11;
    v15 = C3DCullingSystem_CullRange_x8<false,true>;
    if (v9 != 8)
      v15 = v12;
    *((_QWORD *)this + 22) = v14;
    *((_QWORD *)this + 23) = v15;
    v16 = C3DCullingSystem_CullRange_x8<true,false>;
    if (v9 != 8)
      v16 = (uint64_t (*)(int32x2_t *, unsigned int, unsigned int))v13;
    *((_QWORD *)this + 24) = v16;
    if (v9 == 8)
    {
      v17 = C3DCullingSystem_RayRange_x8<true>;
      v18 = C3DCullingSystem_RayRange_x8<false>;
    }
    else if (v9 == 4)
    {
      v17 = C3DCullingSystem_RayRange_x4<true>;
      v18 = C3DCullingSystem_RayRange_x4<false>;
    }
    else
    {
      v17 = C3DCullingSystem_RayRange_x1<true>;
      v18 = C3DCullingSystem_RayRange_x1<false>;
    }
    *((_QWORD *)this + 20) = v18;
    *((_QWORD *)this + 21) = v17;
  }
}

void __C3DCullingSystem::_allocateData(__C3DCullingSystem *this, unsigned int a2)
{
  int v4;
  int v5;
  unint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  size_t v11;
  uint64_t v12;
  unsigned int v13;
  size_t v14;
  int v15;
  void *v16;
  int v17;
  void *v18;
  int v19;
  void *v20;
  int v21;
  void *v22;
  int v23;
  void *v24;
  int v25;
  void *v26;
  size_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  __n128 *v32;
  __n128 v33;
  void *memptr;

  v4 = *((_DWORD *)this + 5);
  v5 = *((_DWORD *)this + 6);
  if (v5 == 8)
    v6 = 32;
  else
    v6 = 16;
  if (v5 == 8)
    v7 = 192;
  else
    v7 = 0;
  if (v5 == 4)
    v7 = 96;
  v8 = v5 - 1;
  if (v5 == 1)
    v9 = 32;
  else
    v9 = v7;
  v10 = C3DLog2OfPowerOf2::deBruijnPosition[(125613361 * v5) >> 27];
  v11 = (v9 * (v8 + a2)) >> v10;
  v12 = (v4 + 7) >> 3;
  v13 = (a2 + 7) >> 3;
  if (*((_QWORD *)this + 8))
  {
    v14 = ((v4 + v8) * v9) >> v10;
    *((_QWORD *)this + 14) = malloc_type_realloc(*((void **)this + 14), (a2 + 7) >> 3, 0xC64850EDuLL);
    *((_QWORD *)this + 12) = _mm_realloc(*((void **)this + 12), v14, v11, v6);
    *((_QWORD *)this + 8) = _mm_realloc(*((void **)this + 8), 32 * *((unsigned int *)this + 5), 32 * a2, v6);
    *((_QWORD *)this + 13) = _mm_realloc(*((void **)this + 13), 8 * *((unsigned int *)this + 5), 8 * a2, v6);
    *((_QWORD *)this + 9) = _mm_realloc(*((void **)this + 9), 4 * *((unsigned int *)this + 5), 4 * a2, v6);
    *((_QWORD *)this + 10) = _mm_realloc(*((void **)this + 10), 4 * *((unsigned int *)this + 5), 4 * a2, v6);
    *((_QWORD *)this + 11) = _mm_realloc(*((void **)this + 11), 2 * *((unsigned int *)this + 5), 2 * a2, v6);
  }
  else
  {
    *((_QWORD *)this + 14) = malloc_type_malloc((a2 + 7) >> 3, 0xDCA4A6E3uLL);
    memptr = 0;
    v15 = malloc_type_posix_memalign(&memptr, v6, v11, 0xBA8A1232uLL);
    v16 = memptr;
    if (v15)
      v16 = 0;
    *((_QWORD *)this + 12) = v16;
    memptr = 0;
    v17 = malloc_type_posix_memalign(&memptr, v6, 32 * a2, 0xBA8A1232uLL);
    v18 = memptr;
    if (v17)
      v18 = 0;
    *((_QWORD *)this + 8) = v18;
    memptr = 0;
    v19 = malloc_type_posix_memalign(&memptr, v6, 8 * a2, 0xBA8A1232uLL);
    v20 = memptr;
    if (v19)
      v20 = 0;
    *((_QWORD *)this + 13) = v20;
    memptr = 0;
    v21 = malloc_type_posix_memalign(&memptr, v6, 4 * a2, 0xBA8A1232uLL);
    v22 = memptr;
    if (v21)
      v22 = 0;
    *((_QWORD *)this + 9) = v22;
    memptr = 0;
    v23 = malloc_type_posix_memalign(&memptr, v6, 4 * a2, 0xBA8A1232uLL);
    v24 = memptr;
    if (v23)
      v24 = 0;
    *((_QWORD *)this + 10) = v24;
    memptr = 0;
    v25 = malloc_type_posix_memalign(&memptr, v6, 2 * a2, 0xBA8A1232uLL);
    v26 = memptr;
    if (v25)
      v26 = 0;
    *((_QWORD *)this + 11) = v26;
  }
  v27 = v13 - v12;
  if ((int)v27 >= 1)
    bzero((void *)(*((_QWORD *)this + 14) + v12), v27);
  v28 = *((unsigned int *)this + 5);
  v29 = a2 - v28;
  if ((int)(a2 - v28) >= 1)
  {
    bzero((void *)(*((_QWORD *)this + 13) + 8 * v28), 8 * (a2 - v28));
    bzero((void *)(*((_QWORD *)this + 9) + 4 * *((unsigned int *)this + 5)), 4 * v29);
    bzero((void *)(*((_QWORD *)this + 10) + 4 * *((unsigned int *)this + 5)), 4 * v29);
    bzero((void *)(*((_QWORD *)this + 11) + 2 * *((unsigned int *)this + 5)), 2 * v29);
    v30 = *((unsigned int *)this + 5);
    if (v30 < a2)
    {
      v33 = *(__n128 *)(MEMORY[0x1E0C83FF0] + 48);
      v31 = 32 * v30;
      do
      {
        v32 = (__n128 *)(*((_QWORD *)this + 8) + v31);
        *v32 = v33;
        v32[1] = (__n128)xmmword_1DD0076D0;
        __C3DCullingSystem::_setWorldAABBAtIndex((uint64_t)this, v30, v33, (__n128)xmmword_1DD0076D0);
        LODWORD(v30) = v30 + 1;
        v31 += 32;
      }
      while (a2 != (_DWORD)v30);
    }
  }
  *((_DWORD *)this + 5) = a2;
}

uint64_t __C3DCullingSystem::_setWorldAABBAtIndex(uint64_t result, unsigned int a2, __n128 a3, __n128 a4)
{
  int v4;
  uint64_t v5;
  unsigned int v6;
  __n128 *v7;

  v4 = *(_DWORD *)(result + 24);
  if (v4 == 4)
  {
    v5 = *(_QWORD *)(result + 96) + 96 * (a2 >> 2);
    *(_DWORD *)(v5 + 4 * (a2 & 3)) = a3.n128_u32[0];
    *(_DWORD *)(v5 + 4 * (a2 & 3 | 4)) = a3.n128_u32[1];
    *(_DWORD *)(v5 + 4 * (a2 & 3 | 8)) = a3.n128_u32[2];
    *(_DWORD *)(v5 + 4 * (a2 & 3 | 0xC)) = a4.n128_u32[0];
    *(_DWORD *)(v5 + 4 * (a2 & 3 | 0x10)) = a4.n128_u32[1];
    v6 = a2 & 3 | 0x14;
    goto LABEL_5;
  }
  if (v4 == 8)
  {
    v5 = *(_QWORD *)(result + 96) + 192 * (a2 >> 3);
    *(_DWORD *)(v5 + 4 * (a2 & 7)) = a3.n128_u32[0];
    *(_DWORD *)(v5 + 4 * (a2 & 7 | 8)) = a3.n128_u32[1];
    *(_DWORD *)(v5 + 4 * (a2 & 7 | 0x10)) = a3.n128_u32[2];
    *(_DWORD *)(v5 + 4 * (a2 & 7 | 0x18)) = a4.n128_u32[0];
    *(_DWORD *)(v5 + 4 * (a2 & 7 | 0x20)) = a4.n128_u32[1];
    v6 = a2 & 7 | 0x28;
LABEL_5:
    *(_DWORD *)(v5 + 4 * v6) = a4.n128_u32[2];
    return result;
  }
  v7 = (__n128 *)(*(_QWORD *)(result + 96) + 32 * a2);
  *v7 = a3;
  v7[1] = a4;
  return result;
}

uint64_t C3DTransformTreeCreate(uint64_t a1)
{
  uint64_t Instance;

  if (C3DTransformTreeGetTypeID(void)::onceToken != -1)
    dispatch_once(&C3DTransformTreeGetTypeID(void)::onceToken, &__block_literal_global_132);
  Instance = C3DTypeCreateInstance_(C3DTransformTreeGetTypeID(void)::typeID, 0x40uLL);
  *(_QWORD *)(Instance + 16) = a1;
  *(_QWORD *)(Instance + 24) = 0;
  *(_QWORD *)(Instance + 32) = 0;
  *(_QWORD *)(Instance + 40) = 0;
  *(_DWORD *)(Instance + 48) = -1;
  *(_QWORD *)(Instance + 56) = 0;
  *(_DWORD *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 72) = 0;
  __C3DTransformTree::_setLevelCount((__C3DTransformTree *)Instance, 1);
  return Instance;
}

uint64_t C3DModelValueStorageCreate()
{
  uint64_t Instance;

  if (C3DModelValueStorageGetTypeID_onceToken != -1)
    dispatch_once(&C3DModelValueStorageGetTypeID_onceToken, &__block_literal_global_5_3);
  Instance = C3DTypeCreateInstance_(C3DModelValueStorageGetTypeID_typeID, 0x20uLL);
  if (Instance)
    *(_QWORD *)(Instance + 16) = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E0C9B3A0]);
  return Instance;
}

uint64_t C3DLightingSystemCreate(uint64_t a1)
{
  uint64_t Instance;
  const __CFAllocator *v3;
  const CFSetCallBacks *v4;
  CFMutableSetRef Mutable;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;

  if (C3DLightingSystemGetTypeID_onceToken != -1)
    dispatch_once(&C3DLightingSystemGetTypeID_onceToken, &__block_literal_global_70);
  Instance = C3DTypeCreateInstance_(C3DLightingSystemGetTypeID_typeID, 0x1F910uLL);
  *(_QWORD *)(Instance + 16) = a1;
  *(_QWORD *)(Instance + 24) = C3DLightProbesSystemCreate();
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(_QWORD *)(Instance + 32) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
  *(_QWORD *)(Instance + 40) = CFDictionaryCreateMutable(v3, 0, 0, MEMORY[0x1E0C9B3A0]);
  v4 = (const CFSetCallBacks *)MEMORY[0x1E0C9B3B0];
  *(_QWORD *)(Instance + 496) = CFSetCreateMutable(v3, 0, MEMORY[0x1E0C9B3B0]);
  Mutable = CFSetCreateMutable(v3, 0, v4);
  v6 = 0;
  *(_QWORD *)(Instance + 488) = Mutable;
  *(_DWORD *)(Instance + 116504) = -1;
  v7 = Instance + 117008;
  do
  {
    for (i = 0; i != 1536; i += 384)
      *(_QWORD *)(v7 + i) = C3DConvexPolyhedronCreate();
    ++v6;
    v7 += 1568;
  }
  while (v6 != 8);
  return Instance;
}

uint64_t C3DConvexPolyhedronCreate()
{
  if (C3DConvexPolyhedronGetTypeID::onceToken != -1)
    dispatch_once(&C3DConvexPolyhedronGetTypeID::onceToken, &__block_literal_global_18);
  return C3DTypeCreateInstance_(C3DConvexPolyhedronGetTypeID::typeID, 0x90uLL);
}

uint64_t C3DLightProbesSystemCreate()
{
  uint64_t result;

  if (C3DLightProbesSystemGetTypeID_onceToken != -1)
    dispatch_once(&C3DLightProbesSystemGetTypeID_onceToken, &__block_literal_global_52);
  result = C3DTypeCreateInstance_(C3DLightProbesSystemGetTypeID_typeID, 0xF0uLL);
  *(_DWORD *)(result + 232) = 3;
  return result;
}

uint64_t C3DGetCPUCaps()
{
  uint64_t result;
  int v1;
  size_t v2;
  int v3;

  result = C3DGetCPUCaps_cpuCaps;
  if (C3DGetCPUCaps_cpuCaps == -1)
  {
    C3DGetCPUCaps_cpuCaps = 0;
    v3 = 0;
    v2 = 4;
    if (!sysctlbyname("hw.optional.sse2", &v3, &v2, 0, 0) && v3)
      C3DGetCPUCaps_cpuCaps |= 1u;
    v3 = 0;
    v2 = 4;
    if (!sysctlbyname("hw.optional.sse3", &v3, &v2, 0, 0) && v3)
      C3DGetCPUCaps_cpuCaps |= 2u;
    v3 = 0;
    v2 = 4;
    if (!sysctlbyname("hw.optional.supplementalsse3", &v3, &v2, 0, 0) && v3)
      C3DGetCPUCaps_cpuCaps |= 2u;
    v3 = 0;
    v2 = 4;
    if (!sysctlbyname("hw.optional.sse4_1", &v3, &v2, 0, 0) && v3)
      C3DGetCPUCaps_cpuCaps |= 8u;
    v3 = 0;
    v2 = 4;
    if (!sysctlbyname("hw.optional.sse4_2", &v3, &v2, 0, 0) && v3)
      C3DGetCPUCaps_cpuCaps |= 0x10u;
    v3 = 0;
    v2 = 4;
    if (!sysctlbyname("hw.optional.avx1_0", &v3, &v2, 0, 0) && v3)
      C3DGetCPUCaps_cpuCaps |= 0x20u;
    v3 = 0;
    v2 = 4;
    v1 = sysctlbyname("hw.optional.fma", &v3, &v2, 0, 0);
    result = C3DGetCPUCaps_cpuCaps;
    if (!v1)
    {
      if (v3)
      {
        result = C3DGetCPUCaps_cpuCaps | 0x40u;
        C3DGetCPUCaps_cpuCaps |= 0x40u;
      }
    }
  }
  return result;
}

uint64_t *C3DEnginePipelineCreate(uint64_t a1)
{
  uint64_t *Instance;
  NSObject *v3;
  const void *v4;
  uint64_t SharedInstance;
  _BYTE *v6;
  uint8_t v8[16];

  if (C3DEnginePipelineGetTypeID_onceToken != -1)
    dispatch_once(&C3DEnginePipelineGetTypeID_onceToken, &__block_literal_global_46);
  Instance = (uint64_t *)C3DTypeCreateInstance_(C3DEnginePipelineGetTypeID_typeID, 0x50uLL);
  Instance[5] = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  Instance[6] = (uint64_t)C3DRendererElementStoreCreate();
  Instance[2] = a1;
  if (Instance[3])
  {
    v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v8 = 0;
      _os_log_impl(&dword_1DCCB8000, v3, OS_LOG_TYPE_DEFAULT, "Warning: Warning _lightNodes not NULL in C3DEnginePipelineSetup", v8, 2u);
    }
    v4 = (const void *)Instance[3];
    if (v4)
    {
      CFRelease(v4);
      Instance[3] = 0;
    }
  }
  SharedInstance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterAddObserver(SharedInstance, Instance, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))__HandleNodeWillDieNotification, CFSTR("kC3DNotificationNodeWillDie"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  if (!Instance[4])
  {
    v6 = (_BYTE *)C3DEngineNotificationQueueCreate(Instance[2]);
    Instance[4] = (uint64_t)v6;
    C3DEngineNotificationQueueStartObserving(v6);
  }
  return Instance;
}

void C3DEngineNotificationQueueStartObserving(_BYTE *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t SharedInstance;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineNotificationQueueStartObserving_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  SharedInstance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterAddObserver(SharedInstance, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))__EnqueueNotification, CFSTR("kC3DNotificationEntityAttributeDidChange"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  a1[49] = 1;
}

uint64_t C3DEngineNotificationQueueCreate(uint64_t a1)
{
  uint64_t Instance;
  const __CFAllocator *v3;
  const CFDictionaryValueCallBacks *v4;

  if (C3DEngineNotificationQueueGetTypeID_onceToken != -1)
    dispatch_once(&C3DEngineNotificationQueueGetTypeID_onceToken, &__block_literal_global_97);
  Instance = C3DTypeCreateInstance_(C3DEngineNotificationQueueGetTypeID_typeID, 0x30uLL);
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  *(_QWORD *)(Instance + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(Instance + 24) = CFDictionaryCreateMutable(v3, 0, 0, v4);
  *(_QWORD *)(Instance + 56) = a1;
  *(_DWORD *)(Instance + 32) = 0;
  return Instance;
}

uint64_t C3DDynamicBatchingSystemCreate()
{
  uint64_t Instance;
  uint64_t Integer;
  uint64_t v2;

  if (C3DDynamicBatchingSystemGetTypeID_onceToken != -1)
    dispatch_once(&C3DDynamicBatchingSystemGetTypeID_onceToken, &__block_literal_global_98);
  Instance = C3DTypeCreateInstance_(C3DDynamicBatchingSystemGetTypeID_typeID, 0x20uLL);
  *(_QWORD *)(Instance + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  Integer = C3DPreferencesGetInteger(4);
  if (Integer)
    v2 = Integer;
  else
    v2 = 1000;
  C3DDynamicBatchingSystemSetMaxBatchSize(Instance, v2);
  return Instance;
}

uint64_t C3DPreferencesGetInteger(int a1)
{
  if (C3DPreferencesGetInteger_onceToken != -1)
    dispatch_once(&C3DPreferencesGetInteger_onceToken, &__block_literal_global_129);
  return C3DPreferencesGetInteger_prefs[a1];
}

void *C3DDynamicBatchingSystemSetMaxBatchSize(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  void *result;

  if (*(_QWORD *)(a1 + 32))
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DDynamicBatchingSystemSetMaxBatchSize_cold_1(v4);
  }
  if (a2 <= 1)
    a2 = 1;
  free(*(void **)(a1 + 24));
  result = malloc_type_malloc(8 * a2, 0x2004093837F09uLL);
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = a2;
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

void C3DCullingSystemCreate(__C3DTransformTree *a1)
{
  __C3DCullingSystem *Instance;

  if (C3DCullingSystemGetTypeID(void)::onceToken != -1)
    dispatch_once(&C3DCullingSystemGetTypeID(void)::onceToken, &__block_literal_global_16);
  Instance = (__C3DCullingSystem *)C3DTypeCreateInstance_(C3DCullingSystemGetTypeID(void)::typeID, 0xB8uLL);
  __C3DCullingSystem::__C3DCullingSystem(Instance, a1);
}

uint64_t C3DConstraintManagerCreate(uint64_t a1)
{
  uint64_t result;

  if (C3DConstraintManagerGetTypeID_onceToken != -1)
    dispatch_once(&C3DConstraintManagerGetTypeID_onceToken, &__block_literal_global_126);
  result = C3DTypeCreateInstance_(C3DConstraintManagerGetTypeID_typeID, 0x18uLL);
  *(_QWORD *)(result + 24) = a1;
  return result;
}

CFTypeRef C3DAnimationManagerSetModelValueStorage(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CFTypeRef result;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerAddAnimationNode_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (cf)
      goto LABEL_6;
  }
  else if (cf)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DAnimationManagerSetModelValueStorage_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  result = *(CFTypeRef *)(a1 + 16);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 16) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 16) = result;
  }
  return result;
}

uint64_t C3DAnimationManagerCreate()
{
  uint64_t Instance;

  if (C3DAnimationManagerGetTypeID_onceToken != -1)
    dispatch_once(&C3DAnimationManagerGetTypeID_onceToken, &__block_literal_global_19);
  Instance = C3DTypeCreateInstance_(C3DAnimationManagerGetTypeID_typeID, 0xA0uLL);
  if (Instance)
  {
    *(_QWORD *)(Instance + 24) = C3DArrayCreate(256, 64);
    *(_QWORD *)(Instance + 32) = CFDictionaryCreateMutable(0, 0, 0, 0);
    *(_QWORD *)(Instance + 48) = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)(Instance + 56) = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
    *(_QWORD *)(Instance + 80) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    *(_QWORD *)(Instance + 112) = C3DAllocatorCreate(40, 64);
    *(_DWORD *)(Instance + 64) = 0;
  }
  return Instance;
}

uint64_t C3DSortSystemCreate()
{
  uint64_t Instance;

  if (C3DSortSystemGetTypeID_onceToken != -1)
    dispatch_once(&C3DSortSystemGetTypeID_onceToken, &__block_literal_global_1);
  Instance = C3DTypeCreateInstance_(C3DSortSystemGetTypeID_typeID, 0x20uLL);
  *(_QWORD *)(Instance + 16) = C3DArrayCreate(8, 0);
  return Instance;
}

uint64_t C3DArrayCreate(int a1, int a2)
{
  uint64_t Instance;
  uint64_t v5;
  int v6;

  if (C3DArrayGetTypeID_onceToken != -1)
    dispatch_once(&C3DArrayGetTypeID_onceToken, &__block_literal_global_142);
  Instance = C3DTypeCreateInstance_(C3DArrayGetTypeID_typeID, 0x18uLL);
  v5 = Instance;
  *(_DWORD *)(Instance + 32) = a1;
  v6 = *(_DWORD *)(Instance + 28);
  if (v6 != a2)
  {
    __allocate(Instance, v6 * a1, (a2 * a1));
    *(_DWORD *)(v5 + 28) = a2;
  }
  return v5;
}

void __allocate(uint64_t a1, unsigned int a2, size_t size)
{
  void *v4;
  unsigned int v5;
  size_t v6;
  char *v8;
  size_t v9;
  char *v10;

  v4 = *(void **)(a1 + 16);
  if ((_DWORD)size)
  {
    v5 = size;
    v6 = size;
    if (!v4)
    {
      v10 = (char *)C3DMallocWithName(size);
      *(_QWORD *)(a1 + 16) = v10;
      v9 = v6;
      goto LABEL_8;
    }
    v8 = (char *)malloc_type_realloc(v4, size, 0xA9E1E891uLL);
    *(_QWORD *)(a1 + 16) = v8;
    v9 = v5 - a2;
    if (v5 > a2)
    {
      v10 = &v8[a2];
LABEL_8:
      bzero(v10, v9);
    }
  }
  else
  {
    free(v4);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

void *C3DMallocWithName(size_t a1)
{
  return malloc_type_malloc(a1, 0xA9292AECuLL);
}

float C3DSceneGetSSRStride(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 376);
}

uint64_t C3DSceneGetSSRSampleCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int16 *)(a1 + 370);
}

float C3DSceneGetSSRMaxRayDistance(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 372);
}

float C3DSceneGetFogStartDistance(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 328);
}

float C3DSceneGetFogDensityExponent(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 336);
}

uint64_t C3DNodeGetParent(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 64);
}

uint64_t C3DEngineContextGetPointOfViewIfAny(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 24);
}

uint64_t C3DCameraGetTechnique(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 536);
}

void C3DSceneSetRootNode(uint64_t a1, uint64_t *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  NSObject *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  CFTypeRef v17;
  __int16 v18[8];

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (*(uint64_t **)(a1 + 64) != a2)
  {
    C3DEnginePipelineReset(*(_QWORD *)(a1 + 120));
    v12 = *(_QWORD **)(a1 + 64);
    if (v12)
    {
      if (C3DGetScene(v12) == a1)
      {
        C3DRemoveSceneRef(*(void **)(a1 + 64), a1);
      }
      else
      {
        v13 = scn_default_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v18[0] = 0;
          _os_log_impl(&dword_1DCCB8000, v13, OS_LOG_TYPE_DEFAULT, "Warning: C3DSceneSetRootNode - old root node seems to be already connected to another scene", (uint8_t *)v18, 2u);
        }
      }
      v15 = *(uint64_t **)(a1 + 64);
      v14 = a2;
      if (v15 == a2)
        goto LABEL_19;
      if (v15)
      {
        CFRelease(*(CFTypeRef *)(a1 + 64));
        *(_QWORD *)(a1 + 64) = 0;
      }
      if (!a2)
      {
        v14 = 0;
        goto LABEL_18;
      }
    }
    else
    {
      v14 = a2;
      if (!a2)
        goto LABEL_19;
    }
    v14 = (uint64_t *)CFRetain(a2);
LABEL_18:
    *(_QWORD *)(a1 + 64) = v14;
LABEL_19:
    v16 = *(uint64_t **)(a1 + 384);
    if (v16 != a2)
    {
      if (v16)
      {
        CFRelease(*(CFTypeRef *)(a1 + 384));
        *(_QWORD *)(a1 + 384) = 0;
      }
      if (a2)
        v17 = CFRetain(a2);
      else
        v17 = 0;
      *(_QWORD *)(a1 + 384) = v17;
      v14 = *(uint64_t **)(a1 + 64);
    }
    if (v14)
      C3DAddSceneRef(v14, a1);
  }
}

void C3DEnginePipelineReset(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFDictionary *v10;
  const void *v11;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEnginePipelineReset_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(__CFDictionary **)(a1 + 40);
  if (v10)
    CFDictionaryRemoveAllValues(v10);
  C3DRendererElementStoreClear(*(uint64_t **)(a1 + 48));
  v11 = *(const void **)(a1 + 24);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void C3DRendererElementStoreClear(uint64_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererElementStoreDeallocateSpanForNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  C3DSpanAllocatorFree(a1[2]);
  C3DIndexStoreRemoveAllIndexes(a1[3]);
  C3DIndexStoreRemoveAllIndexes(a1[4]);
}

void C3DSpanAllocatorFree(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;

  if (*(_DWORD *)(a1 + 24))
  {
    v2 = 0;
    v3 = 0;
    do
    {
      __DestructPage(*(_QWORD *)(a1 + 16) + v2);
      ++v3;
      v2 += 40;
    }
    while (v3 < *(unsigned int *)(a1 + 24));
  }
  free(*(void **)(a1 + 16));
  *(_DWORD *)(a1 + 36) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
}

BOOL C3DCameraHasDepthOfField(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return C3DCameraGetDepthOfFieldIntensity(a1) > 0.0;
}

float C3DCameraGetDepthOfFieldIntensity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 448);
}

void C3DEngineContextSetViewport(__n128 a1, __n128 *a2)
{
  a2[15] = a1;
  if (a2[8].n128_u64[1])
    C3DRendererContextSetViewport(a1);
}

uint64_t C3DEngineContextSetDrawableSize(uint64_t result, double a2)
{
  *(double *)(result + 352) = a2;
  return result;
}

uint64_t C3DEngineContextGetPreferredRenderMode(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 213);
}

void sub_1DCCFFE98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

double C3DEngineContextGetSystemTime(uint64_t a1)
{
  return *(double *)(a1 + 440);
}

uint64_t C3DSceneGetFogColor(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return a1 + 352;
}

uint64_t C3DSceneGetDynamicBatchingSystem(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 136);
}

uint64_t SCNMTLClusterSystem::compute(uint64_t a1)
{
  double v1;
  SCNMTLBufferPool *v2;
  SCNMTLBufferPool *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double *v7;
  double *v8;
  float v9;
  float v10;
  uint32x4_t *v11;
  uint32x4_t *v12;
  float *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t result;
  float32x4_t v30;
  float32x4_t v31;
  uint64_t v32;
  float v33;
  float *v34;
  float32x4_t v35;
  uint32x2_t v36;
  float v37;
  float32x4_t v38;
  float32x4_t v39;
  double v45;
  __int128 v46;
  int v47;
  char v48;
  size_t v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  unsigned int v53;
  double v54;
  double v55;
  double v56;
  __n128 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  size_t v62;
  int v63;
  float32x4_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v68;
  int v69;
  int *v70;
  int *v71;
  int *v72;
  int v73;
  int v74;
  int v75;
  int v76;
  unsigned int v77;
  int v78;
  uint64_t v79;
  int v80;
  _DWORD *v81;
  int *v82;
  int *v83;
  int *v84;
  int v85;
  int v86;
  int v87;
  int v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  uint64_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int32x4_t v98;
  unsigned int v99;
  _BYTE *v100;
  _DWORD *v101;
  unsigned int v102;
  unsigned int v103;
  uint64_t v104;
  unsigned int v105;
  int v106;
  unsigned int v107;
  int v108;
  NSObject *v109;
  float32x4_t *v110;
  float32x4_t v111;
  float32x4_t v112;
  int32x4_t v113;
  int32x4_t v114;
  int32x4_t v115;
  int32x4_t v116;
  int32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  int32x2_t v123;
  uint64_t v124;
  uint32x4_t v125;
  uint64_t v126;
  unsigned int v127;
  int v128;
  unsigned int v129;
  int v130;
  NSObject *v131;
  float v132;
  float32x4_t v133;
  float32x4_t v134;
  uint64_t v135;
  unsigned int v136;
  unsigned int v137;
  uint64_t v138;
  _BYTE *v139;
  unsigned int v140;
  int v141;
  unsigned int v142;
  int v143;
  NSObject *v144;
  float32x4_t *v145;
  float v146;
  float32x4_t v147;
  float32x4_t v148;
  float v149;
  float32x4_t v150;
  float v153;
  float v154;
  float v155;
  float v156;
  float v157;
  uint64_t v158;
  unsigned int v159;
  __int16 appended;
  _WORD *v161;
  uint64_t v162;
  int v163;
  unsigned int v164;
  unsigned int v165;
  void *v166;
  __int16 v167;
  int v168;
  uint64_t v169;
  uint64_t StackAllocator;
  float *v171;
  __int8 v172;
  unsigned int v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  __int8 v177;
  __int32 v178;
  unsigned __int32 v179;
  uint64_t v180;
  int v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  unsigned int v194;
  __int32 v195;
  unsigned int v196;
  float32x4_t v197;
  unsigned int v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  float32x4_t v202;
  float32x4_t v203;
  char v204;
  uint64_t v205;
  _DWORD *v206;
  uint64_t v207;
  _DWORD *v208;
  uint64_t v209;
  float32x4_t v210;
  char *v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  char v217;
  uint64_t v218;
  uint64_t v219;
  float v220;
  uint64_t v221;
  float32x4_t v222;
  float32x4_t v223;
  __int128 v224;
  uint64_t v225;
  unsigned __int16 v226[4];
  char v227;
  char v228;
  __int16 v229;
  __int16 v230;
  __int16 v231;
  int v232;
  _QWORD v233[4];
  int64x2_t v234;
  __int128 v235;
  int v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  double *v249;
  uint64_t v250;
  uint64_t v251;
  SCNMTLBufferPool *v252;
  _OWORD *v253;
  int32x4_t *v254;
  _OWORD *v255;
  _OWORD v256[8];
  float32x4_t v257;
  float32x4_t v258;
  float32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float32x4_t v265;
  float32x4_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  int32x4_t *v279;
  int32x4_t *v280;
  _OWORD *v281;
  void *Aligned;
  unsigned int v283;
  void *v284;
  unsigned int v285;
  void *v286;
  unsigned int v287;
  void *v288;
  unsigned int v289;
  _BYTE v290[256];
  unsigned int v291;
  unsigned int v292;
  unsigned int v293;
  unsigned int v294;
  char *v295[3];
  unsigned int v296;
  float32x4_t v297;
  float32x4_t v298;
  float32x4_t v299;
  float32x4_t v300;
  float32x4_t v301;
  float32x4_t v302;
  float32x4_t v303;
  float32x4_t v304[129];
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  _QWORD v308[2];
  uint64_t v309;
  _DWORD *v310;
  int *v311;
  unsigned int v312;
  int v313[2];
  _OWORD v314[1280];
  int32x4_t v315[768];
  _OWORD v316[256];
  uint8_t v317[4];
  uint64_t v318;
  uint8_t v319[4];
  uint64_t v320;
  uint8_t v321[4];
  _QWORD v322[5];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v169 = v4;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  *(double *)v202.i64 = v1;
  v12 = v11;
  *(_QWORD *)((char *)&v322[2] + 4) = *MEMORY[0x1E0C80C00];
  *((_OWORD *)v13 + 24) = 0u;
  *((_OWORD *)v13 + 25) = 0u;
  *((_OWORD *)v13 + 22) = 0u;
  *((_OWORD *)v13 + 23) = 0u;
  *((_OWORD *)v13 + 20) = 0u;
  *((_OWORD *)v13 + 21) = 0u;
  *((_OWORD *)v13 + 18) = 0u;
  *((_OWORD *)v13 + 19) = 0u;
  *((_OWORD *)v13 + 16) = 0u;
  *((_OWORD *)v13 + 17) = 0u;
  *((_OWORD *)v13 + 14) = 0u;
  *((_OWORD *)v13 + 15) = 0u;
  *((_OWORD *)v13 + 12) = 0u;
  *((_OWORD *)v13 + 13) = 0u;
  *((_OWORD *)v13 + 10) = 0u;
  *((_OWORD *)v13 + 11) = 0u;
  *((_OWORD *)v13 + 8) = 0u;
  *((_OWORD *)v13 + 9) = 0u;
  *((_OWORD *)v13 + 6) = 0u;
  *((_OWORD *)v13 + 7) = 0u;
  *((_OWORD *)v13 + 4) = 0u;
  *((_OWORD *)v13 + 5) = 0u;
  *((_OWORD *)v13 + 2) = 0u;
  *((_OWORD *)v13 + 3) = 0u;
  *(_OWORD *)v13 = 0u;
  *((_OWORD *)v13 + 1) = 0u;
  v14 = *((_QWORD *)v7 + 592);
  v15 = *((_QWORD *)v7 + 266);
  v16 = *((_QWORD *)v7 + 267);
  v17 = *((_QWORD *)v7 + 268);
  v18 = *((_QWORD *)v7 + 269);
  v19 = *((_QWORD *)v7 + 270);
  v20 = *((_QWORD *)v7 + 271);
  v21 = *((_QWORD *)v8 + 272);
  v22 = *((_QWORD *)v8 + 273);
  v23 = *((_QWORD *)v8 + 274);
  v24 = *((_QWORD *)v8 + 275);
  v25 = *((_QWORD *)v8 + 276);
  v26 = *((_QWORD *)v8 + 277);
  v249 = v8;
  v250 = v14;
  v251 = v5;
  v252 = v2;
  v253 = v316;
  v254 = v315;
  v255 = v314;
  v218 = v21;
  v219 = v16;
  v238 = v16;
  v221 = v15;
  v237 = v15;
  v205 = v18;
  v209 = v17;
  v240 = v18;
  v239 = v17;
  v27 = v20;
  v242 = v20;
  v28 = v19;
  v241 = v19;
  v215 = v23;
  v216 = v22;
  v244 = v22;
  v243 = v21;
  v213 = v24;
  v246 = v24;
  v245 = v23;
  v248 = v26;
  v247 = v25;
  v171 = v13;
  _addLightsInFrustum(v19);
  result = C3DLightingSystemHasLocalLights(v6);
  if ((_DWORD)result)
  {
    StackAllocator = C3DEngineContextGetStackAllocator(v14);
    C3DStackAllocatorPushFrame(StackAllocator);
    v31 = vcvtq_f32_u32(*v12);
    v32 = v12[1].i64[0];
    if ((_DWORD)v32)
    {
      v33 = (float)v32 * v10;
      v34 = v171;
      v171[20] = v33;
      v36.i32[1] = v202.i32[1];
      v35.f32[0] = (float)v202.u32[0] / v33;
      v35.i32[1] = v31.i32[1];
      v35.i64[1] = v31.i64[1];
      v36.i32[0] = (float)(v33 * ceilf(v35.f32[0]));
      v31 = v35;
    }
    else
    {
      v34 = v171;
      v36 = *(uint32x2_t *)v202.f32;
    }
    if (HIDWORD(v32))
    {
      v37 = (float)HIDWORD(v32) * v10;
      v38.i32[0] = v31.i32[0];
      v38.f32[1] = (float)v36.u32[1] / v37;
      v34[21] = v37;
      v38.i64[1] = v31.i64[1];
      v36.i32[1] = (float)(v37 * ceilf(v38.f32[1]));
      v31 = v38;
    }
    *(uint32x2_t *)v30.f32 = vcvt_u32_f32(vrndp_f32(*(float32x2_t *)v31.f32));
    v39 = v30;
    v39.i32[2] = v31.f32[2];
    v174 = v39;
    __asm { FMOV            V1.4S, #1.0 }
    v203 = vdivq_f32(_Q1, v31);
    _Q1.f32[0] = v8[593];
    v45 = v8[594];
    *(float *)&v45 = v45;
    *(float32x2_t *)&v46 = vdiv_f32(vcvt_f32_u32(*(uint32x2_t *)v30.f32), vcvt_f32_u32(v36));
    *(float *)&v45 = _Q1.f32[0] - *(float *)&v45;
    _Q1.f32[0] = vmuls_lane_f32(_Q1.f32[0], v31, 2);
    v31.i32[0] = vextq_s8((int8x16_t)v31, (int8x16_t)v31, 8uLL).u32[0];
    v31.i32[1] = _Q1.i32[0];
    *((float32x2_t *)&v46 + 1) = vdiv_f32(*(float32x2_t *)v31.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v45, 0));
    *((float32x4_t *)v34 + 3) = v203;
    *((_OWORD *)v34 + 4) = v46;
    v173 = v31.f32[2];
    v178 = v30.i32[1];
    v197 = v30;
    v195 = v30.i32[0];
    v181 = *((_DWORD *)v34 + 27);
    if (v181)
      v47 = 8;
    else
      v47 = 4;
    v168 = v47;
    if (v181)
      v48 = 3;
    else
      v48 = 2;
    v49 = (v30.i32[1] * v31.f32[2] * v30.i32[0]) << v48;
    SCNMTLBufferPool::allocate(v3, v49, &v265);
    *(float32x4_t *)v34 = v265;
    *((_QWORD *)v34 + 2) = v266.i64[0];
    v180 = *(_QWORD *)v34;
    bzero(*(void **)v34, v49);
    bzero(&v281, 0xA60uLL);
    v265 = v174;
    v266 = v203;
    v268 = v219;
    v267 = v221;
    v270 = v205;
    v269 = v209;
    v272 = v27;
    v271 = v28;
    v274 = v216;
    v273 = v218;
    v276 = v213;
    v275 = v215;
    v278 = v26;
    v277 = v25;
    v279 = (int32x4_t *)v316;
    v280 = v315;
    v281 = v314;
    *(_QWORD *)v313 = StackAllocator;
    v50 = *((_QWORD *)v34 + 11);
    v201 = v50;
    v51 = HIDWORD(v50);
    v283 = (HIDWORD(v50) + 3) >> 2;
    if ((HIDWORD(v50) + 3) >= 4)
    {
      Aligned = C3DStackAllocatorAllocateAligned(StackAllocator, (unint64_t)((HIDWORD(v50) + 3) >> 2) << 6, 16, 0);
      scn_sphere_x4_fill((uint64_t)Aligned, v279, v51);
      v285 = (v283 + 1) >> 1;
      v284 = C3DStackAllocatorAllocateAligned(StackAllocator, v285, 16, 0);
    }
    v52 = *((_QWORD *)v34 + 12);
    v199 = v52;
    v53 = HIDWORD(v52);
    v287 = (HIDWORD(v52) + 3) >> 2;
    if ((HIDWORD(v52) + 3) >= 4)
    {
      v286 = C3DStackAllocatorAllocateAligned(StackAllocator, (unint64_t)((HIDWORD(v52) + 3) >> 2) << 7, 16, 0);
      scn_cone_x4_fill((uint64_t)v286, v315, v53, v54, v55, v56, v57);
      v289 = (v287 + 1) >> 1;
      v288 = C3DStackAllocatorAllocateAligned(StackAllocator, v289, 16, 0);
    }
    v58 = 0;
    HIDWORD(v60) = HIDWORD(v199);
    HIDWORD(v59) = HIDWORD(v201);
    LODWORD(v59) = 0;
    LODWORD(v60) = (v51 + 31) >> 5;
    v305 = v59;
    v306 = v60;
    v61 = *((_QWORD *)v34 + 13);
    v204 = v61;
    LODWORD(v61) = ((v53 + 31) >> 5) + v60;
    v307 = v61;
    v312 = v61 + ((HIDWORD(v61) + 31) >> 5);
    v62 = 4 * v312;
    do
    {
      v223 = v174;
      v308[v58] = C3DStackAllocatorAllocateZero(StackAllocator, (*(_DWORD *)((unint64_t)&v223 & 0xFFFFFFFFFFFFFFF3 | (4 * (v58 & 3))) * v62));
      v310 = C3DStackAllocatorAllocate(StackAllocator, v62);
      v311 = (int *)C3DStackAllocatorAllocate(StackAllocator, v62);
      __computeLightsFlagsForAxis(&v265, v58++);
    }
    while (v58 != 3);
    scn_plane_intersect_3_planes(v25, v26, v28, v27, v209, v205, &v297);
    scn_plane_intersect_3_planes(v25, v26, v221, v219, v28, v27, &v298);
    scn_plane_intersect_3_planes(v25, v26, v209, v205, v218, v216, &v299);
    scn_plane_intersect_3_planes(v25, v26, v218, v216, v221, v219, &v300);
    scn_plane_intersect_3_planes(v215, v213, v28, v27, v209, v205, &v301);
    scn_plane_intersect_3_planes(v215, v213, v221, v219, v28, v27, &v302);
    scn_plane_intersect_3_planes(v215, v213, v209, v205, v218, v216, &v303);
    scn_plane_intersect_3_planes(v215, v213, v218, v216, v221, v219, v304);
    v63 = v195;
    if (v173)
    {
      v179 = 0;
      v64.i64[1] = v197.i64[1];
      *(int32x2_t *)v64.f32 = vceqz_s32(*(int32x2_t *)v197.f32);
      v214 = *((_QWORD *)v171 + 14);
      v217 = v199;
      v172 = v64.i8[4];
      v177 = v64.i8[0];
      do
      {
        if (v312)
        {
          if (*(_DWORD *)(v309 + 4 * v312 * v179))
            goto LABEL_27;
          v65 = 1;
          do
          {
            v66 = v65;
            if (v312 == v65)
              break;
          }
          while (!*(_DWORD *)(v309 + 4 * v312 * v179 + 4 * v65++));
          if (v66 < v312)
          {
LABEL_27:
            v64 = __computeFrustumExtrema(&v265, 0, 0, v179, &v257, (uint32x4_t)v64);
            if ((v172 & 1) == 0)
            {
              v194 = 0;
              v190 = v257;
              v191 = v258;
              v188 = v262;
              v189 = vsubq_f32(v258, v257);
              v185 = v259;
              v186 = vsubq_f32(v262, v261);
              v182 = v264;
              v187 = v261;
              v183 = v263;
              v184 = v260;
              v64 = vsubq_f32(v263, v261);
              v175 = v64;
              v176 = vsubq_f32(v259, v257);
              do
              {
                v68 = v312;
                if (v312)
                {
                  v69 = 0;
                  v70 = v311;
                  v71 = (int *)(v309 + 4 * v179 * v312);
                  v72 = (int *)(v308[1] + 4 * v312 * v194);
                  do
                  {
                    v74 = *v72++;
                    v73 = v74;
                    v75 = *v71++;
                    v76 = v75 & v73;
                    *v70++ = v76;
                    v69 |= v76;
                    --v68;
                  }
                  while (v68);
                  if (v69 && (v177 & 1) == 0)
                  {
                    v77 = 0;
                    v64 = vmulq_n_f32(v175, (float)v194);
                    v192 = v64;
                    v193 = vmulq_n_f32(v176, (float)v194);
                    v78 = (v194 + v179 * v178) * v63;
                    do
                    {
                      v79 = v312;
                      if (v312)
                      {
                        v80 = 0;
                        v81 = v310;
                        v82 = v311;
                        v83 = (int *)(v308[0] + 4 * v312 * v77);
                        v84 = v310;
                        do
                        {
                          v86 = *v82++;
                          v85 = v86;
                          v87 = *v83++;
                          v88 = v87 & v85;
                          *v84++ = v88;
                          v80 |= v88;
                          --v79;
                        }
                        while (v79);
                        if (v80)
                        {
                          v196 = v78;
                          v198 = v77;
                          v89 = vmlaq_n_f32(v193, v189, (float)v77);
                          v90 = vmlaq_n_f32(v192, v186, (float)v77);
                          v91 = vaddq_f32(v190, v89);
                          v256[0] = v91;
                          v256[1] = vaddq_f32(v191, v89);
                          v256[2] = vaddq_f32(v185, v89);
                          v256[3] = vaddq_f32(v89, v184);
                          v256[4] = vaddq_f32(v187, v90);
                          v256[5] = vaddq_f32(v188, v90);
                          v256[6] = vaddq_f32(v183, v90);
                          v256[7] = vaddq_f32(v90, v182);
                          v91.i32[3] = 0;
                          v92 = 1;
                          v93 = v91;
                          do
                          {
                            v94 = (float32x4_t)v256[v92];
                            v94.i32[3] = 0;
                            v91 = vminq_f32(v91, v94);
                            v93 = vmaxq_f32(v93, v94);
                            ++v92;
                          }
                          while (v92 != 8);
                          v95.i64[0] = 0x3F0000003F000000;
                          v95.i64[1] = 0x3F0000003F000000;
                          v98 = (int32x4_t)vmulq_f32(vaddq_f32(v93, v91), v95);
                          v96 = vmulq_f32(vsubq_f32(v93, v91), v95);
                          v97 = vmulq_f32(v96, v96);
                          v98.i32[3] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v97, 2), vaddq_f32(v97, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v97.f32, 1))).f32[0]);
                          v220 = *(float *)&v98.i32[3];
                          v222 = (float32x4_t)v98;
                          v294 = 0;
                          v99 = HIDWORD(v307);
                          if ((HIDWORD(v307) + 31) >= 0x20)
                          {
                            v104 = 0;
                            v206 = &v81[v307];
                            v200 = (HIDWORD(v307) + 31) >> 5;
                            v210 = (float32x4_t)vdupq_laneq_s32(v98, 3);
                            while (1)
                            {
                              v105 = v206[v104];
                              if (v105)
                                break;
LABEL_54:
                              if (++v104 == v200)
                                goto LABEL_42;
                            }
                            v106 = 32 * v104;
                            while (1)
                            {
                              v107 = __clz(__rbit32(v105));
                              v108 = v107 | v106;
                              if ((v107 | v106) >= v99)
                              {
                                v109 = scn_default_log();
                                if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT))
                                  SCNMTLClusterSystem::compute(v317, &v318, v109);
                              }
                              v110 = (float32x4_t *)&v314[5 * v108];
                              v111 = v110[4];
                              v112 = vsubq_f32(v222, *v110);
                              v113 = (int32x4_t)vmulq_f32(v110[1], v112);
                              v114 = (int32x4_t)vmulq_f32(v112, v110[2]);
                              v115 = (int32x4_t)vmulq_f32(v112, v110[3]);
                              v116 = vzip1q_s32(v113, v115);
                              v117 = vzip2q_s32(v113, v115);
                              v118 = (float32x4_t)vtrn2q_s32(v113, v114);
                              v118.i32[2] = v115.i32[1];
                              v119 = vabsq_f32(vaddq_f32((float32x4_t)vzip1q_s32(v117, vdupq_laneq_s32(v114, 2)), vaddq_f32((float32x4_t)vzip1q_s32(v116, v114), v118)));
                              v120 = vsubq_f32(v119, v111);
                              v120.i32[3] = 0;
                              v121 = vmaxnmq_f32(v120, (float32x4_t)0);
                              v122 = vmulq_f32(v121, v121);
                              v123 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v122, 2), vaddq_f32(v122, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v122.f32, 1))).u64[0];
                              if (*(float *)v123.i32 <= (float)(v220 * v220))
                              {
                                v124 = v294++;
                                v290[v124] = v108 + v204;
                                if (*(float *)(v214 + ((unint64_t)(v108 + v204) << 8)) >= 1.0)
                                {
                                  *(float *)v123.i32 = fmaxf(fmaxf(v111.f32[0], v111.f32[2]), v111.f32[1]) * 0.090909;
                                  v125 = (uint32x4_t)vcgeq_f32(vsubq_f32(vsubq_f32(v111, (float32x4_t)vdupq_lane_s32(v123, 0)), v119), v210);
                                  v125.i32[3] = v125.i32[2];
                                  if ((vminvq_u32(v125) & 0x80000000) != 0)
                                    break;
                                }
                              }
                              v105 &= ~(1 << v107);
                              if (!v105)
                                goto LABEL_54;
                            }
                          }
LABEL_42:
                          v100 = &v290[v294];
                          v292 = 0;
                          v101 = v310;
                          v102 = HIDWORD(v305);
                          if ((HIDWORD(v305) + 31) >= 0x20)
                          {
                            v126 = 0;
                            v207 = (HIDWORD(v305) + 31) >> 5;
                            v211 = (char *)&v310[v305];
                            do
                            {
                              v127 = *(_DWORD *)&v211[4 * v126];
                              if (v127)
                              {
                                v128 = 32 * v126;
                                do
                                {
                                  v129 = __clz(__rbit32(v127));
                                  v130 = v129 | v128;
                                  if ((v129 | v128) >= v102)
                                  {
                                    v131 = scn_default_log();
                                    if (os_log_type_enabled(v131, OS_LOG_TYPE_FAULT))
                                      SCNMTLClusterSystem::compute(v319, &v320, v131);
                                  }
                                  v132 = v220 + COERCE_FLOAT(HIDWORD(v316[v130]));
                                  v133 = vsubq_f32((float32x4_t)v316[v130], v222);
                                  v134 = vmulq_f32(v133, v133);
                                  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v134, 2), vaddq_f32(v134, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v134.f32, 1))).f32[0] <= (float)(v132 * v132))
                                  {
                                    v135 = v292++;
                                    v100[v135] = v201 + v130;
                                  }
                                  v127 &= ~(1 << v129);
                                }
                                while (v127);
                              }
                              ++v126;
                            }
                            while (v126 != v207);
                            v103 = v292;
                            v101 = v310;
                            v63 = v195;
                          }
                          else
                          {
                            v103 = 0;
                            v63 = v195;
                          }
                          v293 = 0;
                          v136 = HIDWORD(v306);
                          if ((HIDWORD(v306) + 31) >= 0x20)
                          {
                            v138 = 0;
                            v139 = &v100[v103];
                            v208 = &v101[v306];
                            v212 = (HIDWORD(v306) + 31) >> 5;
                            do
                            {
                              v140 = v208[v138];
                              if (v140)
                              {
                                v141 = 32 * v138;
                                do
                                {
                                  v142 = __clz(__rbit32(v140));
                                  v143 = v142 | v141;
                                  if ((v142 | v141) >= v136)
                                  {
                                    v144 = scn_default_log();
                                    if (os_log_type_enabled(v144, OS_LOG_TYPE_FAULT))
                                      SCNMTLClusterSystem::compute(v321, v322, v144);
                                  }
                                  v145 = (float32x4_t *)&v315[3 * v143];
                                  v146 = v145[2].f32[0];
                                  v147 = vsubq_f32(v222, *v145);
                                  v148 = vmulq_f32(v147, v147);
                                  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v148, 2), vaddq_f32(v148, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v148.f32, 1))).f32[0] <= (float)((float)(v220 + v146) * (float)(v220 + v146)))
                                  {
                                    v149 = v145[2].f32[2];
                                    v150 = vmulq_f32(v147, v145[1]);
                                    LODWORD(_S3) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v150, 2), vaddq_f32(v150, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v150.f32, 1))).u32[0];
                                    __asm { FMLS            S1, S3, V3.S[0] }
                                    v153 = sqrtf(_S1);
                                    v154 = v145[2].f32[3] * v149;
                                    v155 = vmlas_n_f32(-(float)(v149 * v153), v154, _S3);
                                    if (v155 >= 0.0
                                      || (v156 = (float)(v149 * _S3) + (float)(v154 * v153),
                                          v157 = fminf(fmaxf(v156, 0.0), v146),
                                          (float)((float)(v155 * v155)
                                                + (float)((float)(v156 - v157) * (float)(v156 - v157))) <= (float)(v220 * v220)))
                                    {
                                      v158 = v293++;
                                      v139[v158] = v143 + v217;
                                    }
                                  }
                                  v140 &= ~(1 << v142);
                                }
                                while (v140);
                              }
                              ++v138;
                            }
                            while (v138 != v212);
                            v137 = v293;
                            v103 = v292;
                            v63 = v195;
                          }
                          else
                          {
                            v137 = 0;
                          }
                          v77 = v198;
                          v78 = v196;
                          v159 = v137 + v103;
                          v291 = v294 + v159;
                          if (v294 + v159)
                          {
                            appended = __appendUnoptimized(*(uint64_t *)v313, v295, v290, v294 + v159);
                            v64.i32[3] = 0;
                            v64.i16[0] = appended;
                            v64.i16[1] = v292 | (unsigned __int16)((_WORD)v293 << 8);
                            *(uint64_t *)((char *)v64.i64 + 4) = v294;
                          }
                          else
                          {
                            v64 = 0uLL;
                          }
                          if (v181)
                          {
                            *(_QWORD *)(v180 + 8 * v196) = v64.i64[0];
                          }
                          else
                          {
                            v64 = (float32x4_t)vmovl_u16(*(uint16x4_t *)v64.f32);
                            v161 = (_WORD *)(v180 + 4 * v196);
                            v161[1] = v64.i16[2];
                            *v161 = v64.i16[0];
                          }
                        }
                      }
                      ++v77;
                      ++v78;
                    }
                    while (v77 != v63);
                  }
                }
                ++v194;
              }
              while (v194 != v178);
            }
          }
        }
        ++v179;
      }
      while (v179 != v173);
    }
    __compactLightIndices((uint64_t)&v265, v180, v168);
    v162 = v296;
    if (v296 <= 1)
      v163 = 1;
    else
      v163 = v296;
    v164 = (v163 - 1) | ((v163 - 1) >> 1) | (((v163 - 1) | ((v163 - 1) >> 1)) >> 2);
    v165 = v164 | (v164 >> 4) | ((v164 | (v164 >> 4)) >> 8);
    LOWORD(v235) = (v165 | HIWORD(v165)) + 1;
    *(_DWORD *)((char *)&v235 + 2) = 0;
    *(_DWORD *)((char *)&v235 + 5) = 0;
    BYTE9(v235) = 0;
    *(_DWORD *)((char *)&v235 + 10) = 851969;
    HIWORD(v235) = 0;
    v236 = 0;
    v166 = (void *)SCNMTLTexturePool::allocate(v169, &v235, 0, 1);
    *((_QWORD *)v171 + 4) = v166;
    if ((_DWORD)v162)
    {
      memset(v233, 0, 24);
      v233[3] = v162;
      v234 = vdupq_n_s64(1uLL);
      objc_msgSend(v166, "replaceRegion:mipmapLevel:withBytes:bytesPerRow:", v233, 0, v295[2], v296);
    }
    v226[1] = v174.u16[2];
    v226[0] = v174.i16[0];
    v226[2] = v174.u16[4];
    if (v181)
      v167 = 113;
    else
      v167 = 63;
    v226[3] = 0;
    v227 = 7;
    v228 = 2;
    v229 = 1;
    v230 = v167;
    v231 = 0;
    v232 = 0;
    v224 = *(_OWORD *)v171;
    v225 = *((_QWORD *)v171 + 2);
    *((_QWORD *)v171 + 3) = SCNMTLTexturePool::allocateWithStagingBuffer(v169, v226, &v224, 1);
    return C3DStackAllocatorPopFrame(StackAllocator);
  }
  return result;
}

__n128 C3DSceneComputeViewToCubemapMatrix(__n128 *a1, uint64_t a2)
{
  double v4;
  simd_float4 v5;
  __n128 result;
  __int128 v7;
  float32x4_t v8[4];
  __n128 v9;
  simd_float4x4 v10;

  memset(&v10, 0, sizeof(v10));
  C3DMatrix4x4Invert((simd_float4x4 *)a2, &v10);
  v9.n128_u32[2] = 0;
  v9.n128_u64[0] = 0;
  C3DSceneGetUpAxis(a1, &v9);
  memset(v8, 0, sizeof(v8));
  if (v9.n128_f32[2] == 1.0)
  {
    v7 = xmmword_1DD007970;
    v4 = 1.57079633;
LABEL_7:
    C3DMatrix4x4MakeAxisAngleRotation(v8, (float32x4_t *)&v7, v4);
    C3DMatrix4x4Mult((uint64_t)&v10, v8, &v10);
    goto LABEL_8;
  }
  if (v9.n128_f32[2] == -1.0)
  {
    v7 = xmmword_1DD007970;
    v4 = -1.57079633;
    goto LABEL_7;
  }
  if (v9.n128_f32[1] == -1.0)
  {
    v7 = xmmword_1DD007970;
    v4 = -3.14159265;
    goto LABEL_7;
  }
LABEL_8:
  v10.columns[0].f32[2] = -v10.columns[0].f32[2];
  v10.columns[1].f32[2] = -v10.columns[1].f32[2];
  v10.columns[2].f32[2] = -v10.columns[2].f32[2];
  v5 = v10.columns[1];
  *(simd_float4 *)a2 = v10.columns[0];
  *(simd_float4 *)(a2 + 16) = v5;
  result = (__n128)v10.columns[3];
  *(simd_float4 *)(a2 + 32) = v10.columns[2];
  *(__n128 *)(a2 + 48) = result;
  return result;
}

__n64 C3DSceneComputeFogParameters(uint64_t a1, float a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  float v13;
  double v14;
  float v15;
  float v16;
  __n64 result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = fmaxf(*(float *)(a1 + 328) * a2, 0.0);
  v13 = fmaxf(*(float *)(a1 + 332) * a2, 0.0);
  v14 = v13 + -0.001;
  if (v14 <= v12)
  {
    v15 = v14;
    v16 = v15;
  }
  else
  {
    v16 = v12;
  }
  result.n64_f32[0] = 1.0 / (float)(v13 - v16);
  result.n64_f32[1] = -(float)(result.n64_f32[0] * v16);
  return result;
}

uint64_t C3DMatrix4x4Invert(simd_float4x4 *a1, simd_float4x4 *a2)
{
  *a2 = __invert_f4(*a1);
  return 1;
}

BOOL C3DLightingSystemHasLocalLights(uint64_t a1)
{
  return *(_DWORD *)(a1 + 572) != 0;
}

uint64_t C3DLightingSystemGetAmbientLighting(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

__n128 C3DEngineContextGetViewportAtIndex(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a2 >= 6)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetViewportAtIndex_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return *(__n128 *)(a1 + 16 * a2 + 240);
}

float C3DEngineContextGetPointOfViewScale(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 200);
}

unint64_t C3DEngineContextGetEyeMatrix4x4(uint64_t a1, int a2, unsigned int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a3 >= 6)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetEyeMatrix4x4_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  return a1 + 384 * a2 + ((unint64_t)a3 << 6) + 480;
}

uint64_t C3DCreateTangentsWithGeometryOptimized(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *PositionSource;
  const void *NormalSource;
  const void *SourceWithSemanticAtIndex;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t Content;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  unsigned __int8 v45;
  unsigned __int8 v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  unsigned __int8 v50;
  float32x4_t *v51;
  float32x4_t *v52;
  float32x4_t v53;
  unsigned __int8 v54;
  CFIndex v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const void *ElementAtIndex;
  const __CFData *Indexes;
  const UInt8 *BytePtr;
  const UInt8 *v63;
  NSObject *v64;
  uint64_t PrimitiveCount;
  CFIndex v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int16 *v73;
  unsigned __int8 *v74;
  __int32 v75;
  unsigned int *v76;
  float32x2_t v77;
  float32x2_t v78;
  float32x2_t v79;
  float v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  float v84;
  float32x2_t v85;
  float32x2_t v86;
  float32x4_t v87;
  NSObject *v88;
  NSObject *v89;
  NSObject *v90;
  unint64_t v91;
  unsigned int v92;
  unsigned int v93;
  uint64_t v94;
  uint64_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int32x4_t v100;
  float32x2_t v101;
  int32x4_t v102;
  float32x4_t v103;
  float v104;
  CFDataRef v105;
  uint64_t v106;
  NSObject *v107;
  CFIndex length;
  uint64_t v110;
  unsigned __int8 v111;
  unsigned int v112;
  uint64_t v113;
  const UInt8 *v114;
  const UInt8 *v115;
  int v116[2];
  const __CFData *theData;
  const __CFArray *ElementsCount;
  unsigned int v119;
  uint8_t buf[4];
  uint64_t v121;
  uint64_t v122;

  v122 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  PositionSource = C3DMeshGetPositionSource(a1, a2);
  NormalSource = C3DMeshGetNormalSource(a1, a2);
  SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex(a1, 3, 0, a2);
  if (!PositionSource && (v15 = scn_default_log(), os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)))
  {
    C3DCreateTangentsWithGeometryOptimized_cold_7(v15, v16, v17, v18, v19, v20, v21, v22);
    if (NormalSource)
      goto LABEL_9;
  }
  else if (NormalSource)
  {
    goto LABEL_9;
  }
  v23 = scn_default_log();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
    C3DCreateTangentsWithGeometryOptimized_cold_6(v23, v24, v25, v26, v27, v28, v29, v30);
LABEL_9:
  if (!SourceWithSemanticAtIndex)
  {
    v31 = scn_default_log();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_5(v31, v32, v33, v34, v35, v36, v37, v38);
  }
  Content = C3DMeshSourceGetContent((uint64_t)PositionSource);
  if (!Content || (v41 = v40, !(_DWORD)v40))
  {
    v88 = scn_default_log();
    if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
      C3DCreateTangentsWithGeometryOptimized_cold_4();
    return 0;
  }
  v42 = Content;
  *(_QWORD *)v116 = a1;
  v43 = C3DMeshSourceGetContent((uint64_t)SourceWithSemanticAtIndex);
  if (!v43 || (v46 = v45, v44 != (_DWORD)v41))
  {
    v89 = scn_default_log();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
      C3DCreateTangentsWithGeometryOptimized_cold_3();
    return 0;
  }
  v47 = v43;
  v48 = C3DMeshSourceGetContent((uint64_t)NormalSource);
  if (!v48 || v49 != (_DWORD)v41)
  {
    v90 = scn_default_log();
    if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
      C3DCreateTangentsWithGeometryOptimized_cold_2();
    return 0;
  }
  v113 = v48;
  v110 = v41;
  v111 = v50;
  v51 = (float32x4_t *)malloc_type_calloc(16 * v41, 1uLL, 0xDFDF37B6uLL);
  length = 16 * v41;
  v52 = (float32x4_t *)malloc_type_calloc(length, 1uLL, 0xAD0CE6BDuLL);
  ElementsCount = C3DMeshGetElementsCount(a1);
  v112 = v41;
  if ((uint64_t)ElementsCount >= 1)
  {
    v54 = BYTE5(v41);
    v55 = 0;
    v56 = 0;
    v57 = v54;
    v58 = v46;
    v59 = *(_QWORD *)v116;
    while (1)
    {
      ElementAtIndex = C3DMeshGetElementAtIndex(v59, v55, 1);
      if (C3DMeshElementGetType((uint64_t)ElementAtIndex)
        && C3DMeshElementGetType((uint64_t)ElementAtIndex) != 1)
      {
        goto LABEL_48;
      }
      v119 = 0;
      Indexes = (const __CFData *)C3DMeshElementGetIndexes((uint64_t)ElementAtIndex, &v119);
      if (!Indexes)
        goto LABEL_48;
      theData = Indexes;
      BytePtr = CFDataGetBytePtr(Indexes);
      if (!BytePtr)
        goto LABEL_48;
      if (v119 == 1)
        break;
      if (v119 != 4)
      {
        if (v119 == 2)
        {
          v114 = 0;
          v63 = BytePtr;
        }
        else
        {
          v64 = scn_default_log();
          if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134217984;
            v121 = v119;
            _os_log_error_impl(&dword_1DCCB8000, v64, OS_LOG_TYPE_ERROR, "Unreachable code: Unsupported index size (%zu)", buf, 0xCu);
          }
          v114 = 0;
          v63 = 0;
        }
        goto LABEL_33;
      }
      v114 = 0;
      v115 = BytePtr;
      v63 = 0;
LABEL_34:
      PrimitiveCount = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
      v66 = 3 * PrimitiveCount * v119;
      if (v66 > CFDataGetLength(theData))
      {
        free(v51);
        free(v52);
        v107 = scn_default_log();
        if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
          C3DCreateTangentsWithGeometryOptimized_cold_1();
        return 0;
      }
      if (PrimitiveCount < 1)
      {
        v56 = 0;
        v59 = *(_QWORD *)v116;
      }
      else
      {
        v70 = 0;
        v71 = 0;
        v72 = 0;
        v73 = (unsigned __int16 *)(v63 + 4);
        v74 = (unsigned __int8 *)(v114 + 2);
        v75 = 0;
        v76 = (unsigned int *)(v115 + 4);
        v59 = *(_QWORD *)v116;
        do
        {
          if (v63)
          {
            v72 = *(v73 - 2);
            v71 = *(v73 - 1);
            v70 = *v73;
          }
          else if (v115)
          {
            v72 = *(v76 - 1);
            v71 = *v76;
            v70 = v76[1];
          }
          else if (v114)
          {
            v72 = *(v74 - 2);
            v71 = *(v74 - 1);
            v70 = *v74;
          }
          v77 = *(float32x2_t *)(v47 + v72 * v58);
          v78 = vsub_f32(*(float32x2_t *)(v47 + v71 * v58), v77);
          v79 = vsub_f32(*(float32x2_t *)(v47 + v70 * v58), v77);
          v80 = vmlas_n_f32((float)-v78.f32[1] * v79.f32[0], v79.f32[1], v78.f32[0]);
          if (v80 == 0.0)
          {
            v79 = vadd_f32(v79, (float32x2_t)0xB400000034000000);
            v78 = vadd_f32(v78, (float32x2_t)0xB4000000B4000000);
            v80 = vmlas_n_f32((float)-v78.f32[1] * v79.f32[0], v79.f32[1], v78.f32[0]);
          }
          v81 = v42 + v72 * v57;
          v67.i64[0] = *(_QWORD *)v81;
          v67.i32[2] = *(_DWORD *)(v81 + 8);
          v82 = v42 + v71 * v57;
          v68.i64[0] = *(_QWORD *)v82;
          v68.i32[2] = *(_DWORD *)(v82 + 8);
          v83 = v42 + v70 * v57;
          v69.i64[0] = *(_QWORD *)v83;
          v69.i32[2] = *(_DWORD *)(v83 + 8);
          v68 = vsubq_f32(v68, v67);
          v67 = vsubq_f32(v69, v67);
          v84 = v80;
          v85 = vrecpe_f32((float32x2_t)LODWORD(v80));
          v86 = vmul_f32(v85, vrecps_f32((float32x2_t)LODWORD(v84), v85));
          v86.i32[0] = vmul_f32(v86, vrecps_f32((float32x2_t)LODWORD(v84), v86)).u32[0];
          v69 = vmulq_n_f32(vmlaq_lane_f32(vmulq_lane_f32(vnegq_f32(v67), v78, 1), v68, v79, 1), v86.f32[0]);
          v69.i32[3] = v75;
          v51[v72] = vaddq_f32(v51[v72], v69);
          v51[v71] = vaddq_f32(v51[v71], v69);
          v51[v70] = vaddq_f32(v51[v70], v69);
          v87 = vmulq_n_f32(vmlaq_n_f32(vmulq_f32(v68, vnegq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v79, 0))), v67, v78.f32[0]), v86.f32[0]);
          v87.i32[3] = 0;
          v52[v72] = vaddq_f32(v87, v52[v72]);
          v52[v71] = vaddq_f32(v87, v52[v71]);
          v52[v70] = vaddq_f32(v87, v52[v70]);
          v73 += 3;
          v74 += 3;
          v76 += 3;
          v75 = v69.i32[3];
          --PrimitiveCount;
        }
        while (PrimitiveCount);
        v56 = 1;
      }
LABEL_48:
      if ((const __CFArray *)++v55 == ElementsCount)
        goto LABEL_57;
    }
    v63 = 0;
    v114 = BytePtr;
LABEL_33:
    v115 = 0;
    goto LABEL_34;
  }
  v56 = 0;
LABEL_57:
  v91 = 0;
  v92 = 0;
  if (v112 <= 1)
    v93 = 1;
  else
    v93 = v112;
  v94 = 16 * v93;
  do
  {
    v95 = v113 + v92;
    v53.i64[0] = *(_QWORD *)v95;
    v96 = v53;
    v96.i32[2] = *(_DWORD *)(v95 + 8);
    v53.i32[2] = v96.i32[2];
    v97 = v51[v91 / 0x10];
    v98 = vmulq_f32(v97, v53);
    v99 = vmlsq_lane_f32(v97, v96, (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 2), vaddq_f32(v98, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v98.f32, 1))), 0);
    v100 = (int32x4_t)vmulq_f32(v99, v99);
    v100.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v100, 2), vadd_f32(*(float32x2_t *)v100.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v100.i8, 1))).u32[0];
    v101 = vrsqrte_f32((float32x2_t)v100.u32[0]);
    v53 = vmulq_n_f32(v99, vmul_f32(v101, vrsqrts_f32((float32x2_t)v100.u32[0], vmul_f32(v101, v101))).f32[0]);
    v102 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL), vnegq_f32(v96)), v53, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v96, (int32x4_t)v96), (int8x16_t)v96, 0xCuLL));
    v103 = vmulq_f32(v52[v91 / 0x10], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v102, v102), (int8x16_t)v102, 0xCuLL));
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v103, 2), vaddq_f32(v103, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v103.f32, 1))).f32[0] < 0.0)v104 = -1.0;
    else
      v104 = 1.0;
    v53.f32[3] = v104;
    v51[v91 / 0x10] = v53;
    v92 += v111;
    v91 += 16;
  }
  while (v94 != v91);
  free(v52);
  if ((v56 & 1) == 0)
  {
    free(v51);
    return 0;
  }
  v105 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v51, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  v106 = C3DMeshSourceCreate(v105, 4, v110, 4, 1);
  CFRelease(v105);
  return v106;
}

uint64_t C3DMeshCreateTangentsIfNeeded(uint64_t a1, int a2)
{
  uint64_t result;
  const void *PositionSource;
  uint64_t v6;
  unsigned __int8 ChannelForSourceWithSemanticAtIndex;
  const void *NormalSource;
  NSObject *v9;
  const void *SourceWithSemanticAtIndex;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t Count;
  uint64_t v20;
  UInt8 *v21;
  const UInt8 *v22;
  CFDataRef v23;
  const void *v24;
  NSObject *v25;

  if (C3DMeshGetSourceWithSemanticAtIndex(a1, 4, 0, a2))
    return 1;
  PositionSource = C3DMeshGetPositionSource(a1, a2);
  if (PositionSource)
  {
    v6 = (uint64_t)PositionSource;
    ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 0, 0);
    NormalSource = C3DMeshGetNormalSource(a1, a2);
    if (!NormalSource)
    {
      result = C3DCreateNormalsWithMesh(a1, a2, 0);
      if (!result)
        return result;
      NormalSource = (const void *)result;
      if (a2 == 1)
      {
        __C3DMeshSetRenderableSourceWithInputSetAndPositionChannel(a1, (const void *)result, 0);
      }
      else if (!a2)
      {
        C3DMeshSetSourceWithInputSet(a1, (const void *)result, 0, ChannelForSourceWithSemanticAtIndex);
      }
      CFRelease(NormalSource);
    }
    SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex(a1, 3, 0, a2);
    if (SourceWithSemanticAtIndex)
    {
      v11 = (uint64_t)SourceWithSemanticAtIndex;
      C3DMeshSourceGetContent(v6);
      v13 = v12;
      C3DMeshSourceGetContent((uint64_t)NormalSource);
      v15 = v14;
      C3DMeshSourceGetContent(v11);
      if ((v13 & 0xFF000000000000) == 0x1000000000000
        && HIBYTE(v13) >= 3
        && (v15 & 0xFF000000000000) == 0x1000000000000
        && HIBYTE(v15) >= 3
        && (v16 & 0xFF000000000000) == 0x1000000000000
        && v16 >> 57)
      {
        v17 = C3DCreateTangentsWithGeometryOptimized(a1, a2);
      }
      else
      {
        v17 = C3DCreateTangentsWithGeometry(a1, a2);
      }
      v24 = (const void *)v17;
      if (v17)
      {
LABEL_32:
        if (a2 == 1)
        {
          __C3DMeshSetRenderableSourceWithInputSetAndPositionChannel(a1, v24, 0);
        }
        else if (!a2)
        {
          C3DMeshSetSourceWithInputSet(a1, v24, 0, ChannelForSourceWithSemanticAtIndex);
        }
        CFRelease(v24);
        return 1;
      }
    }
    else
    {
      v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        C3DMeshCreateTangentsIfNeeded_cold_3();
      Count = C3DMeshSourceGetCount(v6);
      v20 = 16 * Count;
      v21 = (UInt8 *)malloc_type_calloc(16 * Count, 1uLL, 0x9344E74uLL);
      v22 = v21;
      if (Count >= 1)
        memset_pattern16(v21, &xmmword_1DD007610, v20);
      v23 = CFDataCreateWithBytesNoCopy(0, v22, v20, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
      v24 = (const void *)C3DMeshSourceCreate(v23, 4, Count, 4, 1);
      CFRelease(v23);
      if (v24)
        goto LABEL_32;
    }
    v25 = scn_default_log();
    result = os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      C3DMeshCreateTangentsIfNeeded_cold_2();
      return 0;
    }
  }
  else
  {
    v9 = scn_default_log();
    result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      C3DMeshCreateTangentsIfNeeded_cold_1();
      return 0;
    }
  }
  return result;
}

const void *C3DMeshGetPositionSource(uint64_t a1, int a2)
{
  return C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, a2);
}

const void *C3DMeshGetNormalSource(uint64_t a1, int a2)
{
  return C3DMeshGetSourceWithSemanticAtIndex(a1, 1, 0, a2);
}

uint64_t __C3DMeshSetSourceWithInputSetAndDataKind(uint64_t a1, const void *a2, uint64_t a3, int a4, int a5)
{
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int Semantic;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  CFIndex v48;
  NSObject *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unsigned __int8 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  CFIndex v63;
  CFIndex Count;
  uint64_t v65;
  void *v67;
  _BYTE *v68;
  uint64_t v69;
  _QWORD v70[5];

  if (!a1 && (v10 = scn_default_log(), os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)))
  {
    C3DCreateTangentsWithGeometryOptimized_cold_8(v10, v11, v12, v13, v14, v15, v16, v17);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v18 = scn_default_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
    C3DMeshSourceCreateWithAccessor_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
LABEL_6:
  if (a4 && a5 == 1)
  {
    v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
      __C3DMeshSetSourceWithInputSetAndDataKind_cold_3(v26, v27, v28, v29, v30, v31, v32, v33);
    goto LABEL_13;
  }
  if (a5 == 1)
  {
LABEL_13:
    C3DMeshBuildRenderableData(a1, 1);
    v34 = a1 + 112;
    goto LABEL_17;
  }
  if (a5)
  {
    v35 = scn_default_log();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      C3DMeshApplySources_cold_1(v35, v36, v37, v38, v39, v40, v41, v42);
    v34 = 0;
  }
  else
  {
    v34 = a1 + 64;
  }
LABEL_17:
  Semantic = C3DMeshSourceGetSemantic((uint64_t)a2);
  v44 = v34 + 2 * Semantic;
  v47 = *(char *)(v44 + 8);
  v46 = v44 + 8;
  v45 = v47;
  if (v47 != -1 && *(unsigned __int8 *)(v46 + 1) > a3)
  {
    v48 = v45 + a3;
    CFArraySetValueAtIndex(*(CFMutableArrayRef *)v34, v48, a2);
    if (a4 != 255)
      *(_BYTE *)(*(_QWORD *)(v34 + 40) + v48) = a4;
    if (a5)
      goto LABEL_43;
    goto LABEL_40;
  }
  if (a4 != 255 || (v49 = scn_default_log(), !os_log_type_enabled(v49, OS_LOG_TYPE_FAULT)))
  {
    if ((Semantic & 0x80000000) == 0)
      goto LABEL_26;
LABEL_29:
    v63 = 0;
    goto LABEL_30;
  }
  __C3DMeshSetSourceWithInputSetAndDataKind_cold_1(v49, v50, v51, v52, v53, v54, v55, v56);
  if (Semantic < 0)
    goto LABEL_29;
LABEL_26:
  v57 = Semantic;
  while (1)
  {
    v58 = v34 + 2 * v57;
    v61 = *(char *)(v58 + 8);
    v60 = v58 + 8;
    v59 = v61;
    if (v61 != -1)
      break;
    v62 = (char)v57--;
    if (v62 < 1)
      goto LABEL_29;
  }
  v65 = *(unsigned __int8 *)(v60 + 1);
  if (v65 < a3)
    return 0;
  v63 = v65 + v59;
LABEL_30:
  Count = CFArrayGetCount(*(CFArrayRef *)v34);
  CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)v34, v63, a2);
  if (!a5)
  {
    v67 = *(void **)(a1 + 152);
    if (v67)
    {
      free(v67);
      *(_QWORD *)(a1 + 152) = 0;
    }
    v68 = malloc_type_realloc(*(void **)(a1 + 104), Count + 1, 0x28E62344uLL);
    *(_QWORD *)(a1 + 104) = v68;
    if (Count > v63)
    {
      do
      {
        *(_BYTE *)(*(_QWORD *)(a1 + 104) + Count) = *(_BYTE *)(*(_QWORD *)(a1 + 104) + Count - 1);
        --Count;
      }
      while (Count > v63);
      v68 = *(_BYTE **)(a1 + 104);
    }
    v68[v63] = a4;
    __BuildSemanticInfosForData(a1, v34);
LABEL_40:
    v69 = MEMORY[0x1E0C809B0];
    *(_BYTE *)(a1 + 200) &= ~4u;
    v70[0] = v69;
    v70[1] = 0x40000000;
    v70[2] = ____UpdateSourcesMutability_block_invoke;
    v70[3] = &__block_descriptor_tmp_35;
    v70[4] = a1;
    C3DMeshApplySources(a1, 0, (uint64_t)v70);
    if (!Semantic)
      C3DMeshResetBoundingVolumes(a1);
    __C3DMeshInvalidateRenderableData(a1);
    goto LABEL_43;
  }
  __BuildRenderableSourceChannelsAndSemanticInfos(a1);
LABEL_43:
  __MeshWillDieNotification(a1);
  return 1;
}

void __MeshWillDieNotification(uint64_t a1)
{
  CFNumberRef v1;
  __CFNotificationCenter *LocalCenter;
  uint64_t valuePtr;

  valuePtr = a1;
  v1 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, CFSTR("kC3DNotificationMeshWillDie"), v1, 0, 1u);
  CFRelease(v1);
  ++*(_QWORD *)(valuePtr + 208);
}

uint64_t __C3DMeshSetRenderableSourceWithInputSetAndPositionChannel(uint64_t a1, const void *a2, uint64_t a3)
{
  return __C3DMeshSetSourceWithInputSetAndDataKind(a1, a2, a3, 0, 1);
}

uint64_t C3DMeshSourceCreate(const void *a1, __int16 a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v10;

  v10 = C3DSizeOfBaseType(a5) * a4;
  return C3DMeshSourceCreateWithData(a2, a1, a5, a4, a3, v10, 0);
}

uint64_t C3DMeshGetChannelForSourceWithSemanticAtIndex(uint64_t a1, int a2, uint64_t a3)
{
  int v3;
  char v4;
  uint64_t v6;
  NSObject *v7;

  v3 = a3;
  v4 = a2;
  v6 = __indexOfSourceWithSemanticAtIndex(a1, a2, a3, 0);
  if (v6 == -1)
  {
    v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      C3DMeshGetChannelForSourceWithSemanticAtIndex_cold_1(v4, v3, v7);
  }
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 104) + v6);
}

const void *SCNCopyValueFromObjCValue(void *a1)
{
  int v2;
  int v3;
  const void *v4;
  uint64_t Bytes;
  NSObject *v6;

  v2 = SCNObjCEncodedTypeToC3DBaseType((const char *)objc_msgSend(a1, "objCType"));
  if (!v2)
    return 0;
  v3 = v2;
  v4 = (const void *)C3DValueCreate(v2, 1);
  Bytes = C3DValueGetBytes((uint64_t)v4);
  if ((SCNWriteValueToTypedBytes(a1, Bytes, v3) & 1) == 0)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      SCNCopyValueFromObjCValue_cold_1((uint64_t)a1, v6);
    CFRelease(v4);
    return 0;
  }
  return v4;
}

uint64_t SCNWriteValueToTypedBytes(void *a1, uint64_t a2, int a3)
{
  uint64_t result;
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  double v14;
  int v15;
  int v16;
  int v17;
  char v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;

  result = 0;
  switch(a3)
  {
    case 1:
    case 7:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
          return 0;
      }
      objc_msgSend(a1, "floatValue");
      *(_DWORD *)a2 = v6;
      return 1;
    case 2:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
          return 0;
      }
      *(_DWORD *)a2 = objc_msgSend(a1, "intValue");
      return 1;
    case 3:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
          return 0;
      }
      v18 = objc_msgSend(a1, "BOOLValue");
      goto LABEL_35;
    case 4:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        return 0;
      v18 = objc_msgSend(a1, "charValue");
      goto LABEL_35;
    case 5:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        return 0;
      v11 = objc_msgSend(a1, "pointerValue");
      goto LABEL_39;
    case 6:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
          return 0;
      }
      objc_msgSend(a1, "doubleValue");
      *(_QWORD *)a2 = v12;
      return 1;
    case 8:
    case 18:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v20 = 0uLL;
        CFStringScanCGFloats((char *)a1, (uint64_t)&v20, 2);
        goto LABEL_31;
      }
      objc_msgSend(a1, "CGPointValue");
      *(float *)&v13 = v13;
      *(float *)&v14 = v14;
      *(_DWORD *)a2 = LODWORD(v13);
      *(_DWORD *)(a2 + 4) = LODWORD(v14);
      return 1;
    case 9:
    case 19:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v20 = 0uLL;
        CFStringScanFloats((const char *)a1, (int *)&v20, 3);
        *(_QWORD *)a2 = v20;
        *(_DWORD *)(a2 + 8) = DWORD2(v20);
      }
      else
      {
        objc_msgSend(a1, "SCNVector3Value");
        *(_DWORD *)a2 = v15;
        *(_DWORD *)(a2 + 4) = v16;
        *(_DWORD *)(a2 + 8) = v17;
      }
      return 1;
    case 10:
    case 20:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        goto LABEL_30;
      objc_msgSend(a1, "SCNVector4Value");
      DWORD1(v10) = v7;
      *((_QWORD *)&v10 + 1) = __PAIR64__(v9, v8);
      goto LABEL_32;
    case 11:
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      if (a1)
        objc_msgSend(a1, "SCNMatrix4Value", v20, v21, v22, v23);
      C3DMatrix4x4FromSCNMatrix4((_OWORD *)a2, (uint64_t)&v20);
      return 1;
    case 13:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
LABEL_30:
        v20 = 0uLL;
        CFStringScanFloats((const char *)a1, (int *)&v20, 4);
LABEL_31:
        v10 = v20;
LABEL_32:
        *(_OWORD *)a2 = v10;
      }
      else
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v11 = objc_msgSend(a1, "scn_C3DColorIgnoringColorSpace:success:", 0, 0);
          *(_QWORD *)(a2 + 8) = v19;
LABEL_39:
          *(_QWORD *)a2 = v11;
        }
      }
      return 1;
    case 16:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        return 0;
      v18 = objc_msgSend(a1, "unsignedCharValue");
LABEL_35:
      *(_BYTE *)a2 = v18;
      return 1;
    default:
      return result;
  }
}

uint64_t SCNObjCEncodedTypeToC3DBaseType(const char *a1)
{
  if (!strcmp(a1, "f"))
    return 1;
  if (!strcmp(a1, "i") || !strcmp(a1, "I") || !strcmp(a1, "q") || !strcmp(a1, "Q"))
    return 2;
  if (!strcmp(a1, "s") || !strcmp(a1, "S"))
    return 14;
  if (!strcmp(a1, "B"))
    return 3;
  if (!strcmp(a1, "c") || !strcmp(a1, "C"))
    return 4;
  if (!strcmp(a1, "d"))
    return 6;
  if (!strcmp(a1, "{SCNMatrix4=ffffffffffffffff}") || !strcmp(a1, "{CATransform3D=dddddddddddddddd}"))
    return 11;
  if (!strcmp(a1, "{CGPoint=dd}"))
    return 8;
  if (!strcmp(a1, "{SCNVector4=ffff}") || !strcmp(a1, "{CGRect={CGPoint=dd}{CGSize=dd}}"))
    return 10;
  if (!strcmp(a1, "{SCNVector3=fff}"))
    return 9;
  if (!strcmp(a1, "{_SCNVector4=dddd}"))
    return 10;
  if (!strcmp(a1, "{_SCNVector3=ddd}"))
    return 9;
  if (*a1 == 64)
    return 5;
  else
    return 0;
}

uint64_t SCNCopyValueFromObjCProperty(void *a1, void *a2)
{
  objc_class *v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  void *v8;
  const void *v9;
  uint64_t Bytes;
  NSObject *v11;

  v4 = (objc_class *)objc_opt_class();
  v5 = SCNBaseTypeOfObjCProperty(v4, a2);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = objc_msgSend(a1, "valueForKey:", a2);
  if (v7)
  {
    v8 = (void *)v7;
    v9 = (const void *)C3DValueCreate(v6, 1);
    Bytes = C3DValueGetBytes((uint64_t)v9);
    if ((SCNWriteValueToTypedBytes(v8, Bytes, v6) & 1) != 0)
      return (uint64_t)v9;
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      SCNCopyValueFromObjCProperty_cold_1((uint64_t)a2, (uint64_t)a1, v11);
    CFRelease(v9);
    return 0;
  }
  return C3DValueCreateDefault(v6);
}

uint64_t C3DValueCreateDefault(int a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t Bytes;

  v2 = C3DValueCreate(a1, 1);
  v3 = v2;
  if (a1 == 11)
  {
    Bytes = C3DValueGetBytes(v2);
    C3DMatrix4x4MakeIdentity(Bytes);
  }
  return v3;
}

uint64_t C3DKeyValueStoreEnumerateBySortingKeys(uint64_t a1, uint64_t a2)
{
  void *v3;
  uint64_t result;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _QWORD v13[5];
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v3 = *(void **)(a1 + 64);
  if ((unint64_t)objc_msgSend(v3, "count") > 1)
  {
    v5 = (void *)objc_msgSend((id)objc_msgSend(v3, "allKeys"), "sortedArrayUsingSelector:", sel_compare_);
    v9 = 0u;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    result = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v9, v14, 16);
    if (result)
    {
      v6 = result;
      v7 = *(_QWORD *)v10;
      do
      {
        v8 = 0;
        do
        {
          if (*(_QWORD *)v10 != v7)
            objc_enumerationMutation(v5);
          (*(void (**)(uint64_t, _QWORD, uint64_t))(a2 + 16))(a2, *(_QWORD *)(*((_QWORD *)&v9 + 1) + 8 * v8), objc_msgSend(v3, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v9 + 1) + 8 * v8)));
          ++v8;
        }
        while (v6 != v8);
        result = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v9, v14, 16);
        v6 = result;
      }
      while (result);
    }
  }
  else
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __C3DKeyValueStoreEnumerateBySortingKeys_block_invoke;
    v13[3] = &unk_1EA59D4A8;
    v13[4] = a2;
    return objc_msgSend(v3, "enumerateKeysAndObjectsUsingBlock:", v13);
  }
  return result;
}

void C3DEntitySetValueForKey(uint64_t a1, void *a2, __int16 *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFDictionary *KeyValueStore;

  if (!a1 && (v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DEntityRemoveAllAnimations_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    C3DEntitySetValueForKey_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
LABEL_6:
  KeyValueStore = _C3DEntityGetKeyValueStore(a1, 1);
  C3DKeyValueStoreSetValueForKey((uint64_t)KeyValueStore, a2, a3);
}

const __CFDictionary *_C3DEntityGetKeyValueStore(uint64_t a1, int a2)
{
  const __CFDictionary *v4;
  const __CFDictionary *Value;

  v4 = *(const __CFDictionary **)(a1 + 40);
  if (v4)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v4, CFSTR("_kvc"));
    if (Value)
      return Value;
  }
  else
  {
    Value = 0;
  }
  if (a2)
  {
    Value = (const __CFDictionary *)C3DKeyValueStoreCreate();
    _C3DEntitySetAttribute((CFTypeRef *)a1, CFSTR("_kvc"), Value, 1);
    CFRelease(Value);
  }
  return Value;
}

uint64_t C3DKeyValueStoreSetupModelTargetWithKey(CFDictionaryRef *a1, CFArrayRef theArray, int a3, uint64_t a4)
{
  int Count;
  CFIndex v9;
  const void *ValueAtIndex;
  char *Value;
  char *v12;
  CFTypeID v13;
  int v14;
  CFIndex v15;
  __CFArray *Mutable;
  __CFString *v17;
  __CFString *v18;
  char *v19;
  CFTypeID v20;
  CFRange v22;

  Count = CFArrayGetCount(theArray);
  v9 = a3;
  ValueAtIndex = CFArrayGetValueAtIndex(theArray, a3);
  Value = (char *)CFDictionaryGetValue(a1[8], ValueAtIndex);
  v12 = Value;
  if (Value)
  {
    v13 = CFGetTypeID(Value);
    if (v13 == C3DEffectSlotGetTypeID()
      && C3DModelPathResolveCommonProfileProperty(v12, theArray, a3 + 1, Count, a4, 0))
    {
      C3DModelTargetSetTarget(a4, a1);
      return 1;
    }
  }
  if (a3 + 1 < Count)
  {
    v14 = Count - a3;
    v15 = Count - a3;
    Mutable = CFArrayCreateMutable(0, v14, MEMORY[0x1E0C9B378]);
    v22.location = v9;
    v22.length = v15;
    CFArrayAppendArray(Mutable, theArray, v22);
    v17 = (__CFString *)CFStringCreateByCombiningStrings(0, Mutable, CFSTR("."));
    v18 = v17;
    CFRelease(Mutable);
    v19 = (char *)CFDictionaryGetValue(a1[8], v17);
    if (v19)
      v12 = v19;
  }
  if (v12)
  {
    v20 = CFGetTypeID(v12);
    if (v20 == C3DValueGetTypeID())
    {
      C3DModelTargetSetTarget(a4, a1);
      *(_WORD *)(a4 + 32) = C3DValueGetType((uint64_t)v12);
      *(_BYTE *)(a4 + 34) = C3DValueGetTypeSemantic((uint64_t)v12);
      *(_QWORD *)(a4 + 24) = C3DValueGetBytes((uint64_t)v12);
      return 1;
    }
  }
  return 0;
}

void C3DKeyValueStoreSetValueForKey(uint64_t a1, void *key, __int16 *a3)
{
  _WORD *Value;
  CFTypeID v7;
  CFTypeID v8;
  _WORD *v9;
  NSObject *v10;
  const __CFString *v11;
  const __CFString *v12;
  void *Bytes;
  int v14;
  void *v15;
  __int16 v16;
  const __CFString *v17;
  __int16 v18;
  const __CFString *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 64), key);
    ++*(_DWORD *)(a1 + 72);
    return;
  }
  ++*(_DWORD *)(a1 + 72);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), key);
  v7 = CFGetTypeID(a3);
  if (!Value)
  {
    if (v7 == C3DValueGetTypeID())
      goto LABEL_13;
LABEL_16:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 64), key, a3);
    return;
  }
  v8 = CFGetTypeID(Value);
  if (v8 == C3DValueGetTypeID())
    v9 = Value;
  else
    v9 = 0;
  if (v7 != C3DValueGetTypeID())
    goto LABEL_16;
  if (v9)
  {
    if (v9[8] != a3[8])
    {
      v10 = scn_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        v11 = C3DBaseTypeStringDescription((__int16)v9[8]);
        v12 = C3DBaseTypeStringDescription(a3[8]);
        v14 = 138412802;
        v15 = key;
        v16 = 2112;
        v17 = v11;
        v18 = 2112;
        v19 = v12;
        _os_log_error_impl(&dword_1DCCB8000, v10, OS_LOG_TYPE_ERROR, "Error: type for key %@ is switching from %@ to %@, this will lead to improper animation", (uint8_t *)&v14, 0x20u);
      }
    }
    goto LABEL_14;
  }
LABEL_13:
  Value = (_WORD *)C3DValueCreate(11, 1);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 64), key, Value);
  CFRelease(Value);
LABEL_14:
  Bytes = (void *)C3DValueGetBytes((uint64_t)Value);
  C3DValueCopyTo((uint64_t)a3, Bytes);
  Value[8] = C3DValueGetType((uint64_t)a3);
}

uint64_t C3DValueGetTypeID()
{
  if (C3DValueGetTypeID_onceToken != -1)
    dispatch_once(&C3DValueGetTypeID_onceToken, &__block_literal_global_93);
  return C3DValueGetTypeID_typeID;
}

uint64_t C3DValueGetType(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      __RemoveVRAMResourceFromDic_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(__int16 *)(a1 + 16);
}

size_t C3DValueCopyTo(uint64_t a1, void *a2)
{
  size_t Length;
  const void *Bytes;

  Length = C3DValueGetLength(a1);
  Bytes = (const void *)C3DValueGetBytes(a1);
  memcpy(a2, Bytes, Length);
  return Length;
}

uint64_t C3DValueGetBytes(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      __RemoveVRAMResourceFromDic_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 24);
}

uint64_t C3DValueGetTypeSemantic(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      __RemoveVRAMResourceFromDic_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(char *)(a1 + 18);
}

uint64_t C3DEffectSlotGetTypeID()
{
  if (C3DEffectSlotGetTypeID_onceToken != -1)
    dispatch_once(&C3DEffectSlotGetTypeID_onceToken, &__block_literal_global_25_0);
  return C3DEffectSlotGetTypeID_typeID;
}

uint64_t C3DKeyValueStoreCreate()
{
  uint64_t Instance;

  if (C3DKeyValueStoreGetTypeID_onceToken != -1)
    dispatch_once(&C3DKeyValueStoreGetTypeID_onceToken, &__block_literal_global);
  Instance = C3DTypeCreateInstance_(C3DKeyValueStoreGetTypeID_typeID, 0x40uLL);
  *(_QWORD *)(Instance + 64) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  return Instance;
}

unint64_t _setupMetalBackingLayer(void *a1, int a2)
{
  char v3;
  unint64_t result;

  if (a2)
    v3 = 32;
  else
    v3 = 0;
  objc_msgSend(a1, "setPixelFormat:", C3DMetalFramebufferPixelFormat(v3));
  objc_msgSend(a1, "setFramebufferOnly:", 1);
  result = objc_msgSend(a1, "maximumDrawableCount");
  if (result >= 3)
    return objc_msgSend(a1, "setFenceEnabled:", 1);
  return result;
}

id SCNUIKitSourceSetCurrentViewEvent(id result)
{
  void *v1;

  if ((id)gCurrentSCNViewEvent != result)
  {
    v1 = result;

    result = v1;
    gCurrentSCNViewEvent = (uint64_t)result;
  }
  return result;
}

uint64_t SCNGetPerformanceStatisticsEnabled()
{
  if (SCNGetPerformanceStatisticsEnabled::onceToken != -1)
    dispatch_once(&SCNGetPerformanceStatisticsEnabled::onceToken, &__block_literal_global_49);
}

uint64_t C3DWarmupSceneVRAMResourcesForEngineContext(const void *a1, __n128 *a2, uint64_t a3)
{
  uint64_t Scene;
  uint64_t EnginePipeline;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t RenderContext;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20[2];
  __int128 v21;
  __int128 v22;

  Scene = C3DEngineContextGetScene((uint64_t)a2);
  if ((const void *)Scene != a1)
    C3DEngineContextSetScene((uint64_t)a2, a1);
  C3DEngineContextSetupForWarmUp((uint64_t)a2, a3);
  EnginePipeline = C3DSceneGetEnginePipeline((uint64_t)a1);
  if (!EnginePipeline)
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      C3DWarmupSceneVRAMResourcesForEngineContext_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
  }
  v20[0] = EnginePipeline;
  v20[1] = (uint64_t)a2;
  v21 = 0u;
  v22 = 0u;
  C3DEnginePipelineApplyNotificationQueue(v20);
  C3DEngineContextApplyModifiers((uint64_t)a2, EnginePipeline);
  RenderContext = C3DEngineContextGetRenderContext((uint64_t)a2);
  if (RenderContext)
  {
    v17 = RenderContext;
    C3DEngineContextRenderWithRenderGraph((uint64_t)a2);
    v18 = -[SCNMTLRenderContext resourceManager](v17);
    objc_msgSend((id)-[SCNMTLResourceManager libraryManager](v18), "waitForShadersCompilation");
  }
  else
  {
    C3DEngineContextRenderMainTechnique(a2);
  }
  if ((const void *)Scene != a1)
    C3DEngineContextSetScene((uint64_t)a2, 0);
  C3DEngineContextUnSetupForWarmUp((uint64_t)a2);
  return 1;
}

void C3DEngineContextSetScene(uint64_t a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t FXContext;
  const void *v13;
  CFTypeRef v14;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (*(const void **)(a1 + 16) != a2)
  {
    FXContext = C3DEngineContextGetFXContext(a1);
    if (*(_QWORD *)(a1 + 16))
    {
      C3DEngineContextSetPointOfView(a1, 0);
      if (FXContext)
        C3DFXContextSceneWillChange(FXContext);
      C3DAudioManagerRemoveEngineContext((__C3DEngineContext *)a1);
      C3DSceneUnregisterEngineContext(*(_QWORD *)(a1 + 16), a1);
    }
    C3DProgramHashCodeStoreClear(*(_QWORD *)(a1 + 176));
    C3DSortSystemInvalidate(*(_QWORD *)(a1 + 184));
    v13 = *(const void **)(a1 + 16);
    if (v13 != a2)
    {
      if (v13)
      {
        CFRelease(v13);
        *(_QWORD *)(a1 + 16) = 0;
      }
      if (a2)
        v14 = CFRetain(a2);
      else
        v14 = 0;
      *(_QWORD *)(a1 + 16) = v14;
    }
    if (a2)
    {
      C3DSceneRegisterEngineContext((uint64_t)a2, a1);
      if (FXContext)
        C3DFXContextSceneDidChange(FXContext, a1);
      C3DAudioManagerRemoveEngineContext((__C3DEngineContext *)a1);
    }
    C3DEngineContextSetDefaultPointOfView(a1, 0);
    C3DAudioManagerUpdateEngineContext((__C3DEngineContext *)a1);
  }
}

uint64_t C3DEngineContextGetFXContext(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 160);
}

uint64_t CPP3DAudioEngine::RemoveContext(CPP3DAudioEngine *this, __C3DEngineContext *a2)
{
  unint64_t Scene;
  _QWORD *v5;
  char *v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t *v11;
  unint64_t v12;
  BOOL v13;
  _QWORD *v14;
  id *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t *v18;
  unint64_t v19;
  BOOL v20;
  _QWORD *v21;
  id *v22;
  CPP3DAudioEngine *v23;
  CPP3DAudioEngine *v24;
  BOOL v25;

  Scene = C3DEngineContextGetScene((uint64_t)a2);
  objc_msgSend(*((id *)this + 1), "lock");
  if (Scene)
  {
    v5 = (_QWORD *)*((_QWORD *)this + 3);
    if (v5)
    {
      v6 = (char *)this + 24;
      do
      {
        v7 = v5[4];
        v8 = v7 >= Scene;
        if (v7 >= Scene)
          v9 = v5;
        else
          v9 = v5 + 1;
        if (v8)
          v6 = (char *)v5;
        v5 = (_QWORD *)*v9;
      }
      while (*v9);
      if (v6 != (char *)this + 24 && Scene >= *((_QWORD *)v6 + 4))
      {
        v10 = (_QWORD *)*((_QWORD *)v6 + 6);
        if (v10)
        {
          v11 = (uint64_t *)(v6 + 48);
          do
          {
            v12 = v10[4];
            v13 = v12 >= (unint64_t)a2;
            if (v12 >= (unint64_t)a2)
              v14 = v10;
            else
              v14 = v10 + 1;
            if (v13)
              v11 = v10;
            v10 = (_QWORD *)*v14;
          }
          while (*v14);
          if (v11 != (uint64_t *)(v6 + 48) && v11[4] <= (unint64_t)a2)
          {
            v15 = (id *)v11[5];
            if (v15)
            {
              CPP3DAudioContext::~CPP3DAudioContext(v15);
              MEMORY[0x1DF0D41C0]();
            }
            std::__tree<std::__value_type<__C3DMesh *,WireframeMesh *>,std::__map_value_compare<__C3DMesh *,std::__value_type<__C3DMesh *,WireframeMesh *>,std::less<__C3DMesh *>,true>,std::allocator<std::__value_type<__C3DMesh *,WireframeMesh *>>>::__remove_node_pointer((uint64_t **)v6 + 5, v11);
            operator delete(v11);
          }
        }
        if (!*((_QWORD *)v6 + 7))
          std::__tree<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::__map_value_compare<__C3DScene *,std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::less<__C3DScene *>,true>,std::allocator<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>>>::erase((uint64_t **)this + 2, (uint64_t)v6);
      }
    }
  }
  else
  {
    v16 = *((_QWORD *)this + 2);
    if ((CPP3DAudioEngine *)v16 != (CPP3DAudioEngine *)((char *)this + 24))
    {
      do
      {
        v17 = *(_QWORD **)(v16 + 48);
        if (v17)
        {
          v18 = (uint64_t *)(v16 + 48);
          do
          {
            v19 = v17[4];
            v20 = v19 >= (unint64_t)a2;
            if (v19 >= (unint64_t)a2)
              v21 = v17;
            else
              v21 = v17 + 1;
            if (v20)
              v18 = v17;
            v17 = (_QWORD *)*v21;
          }
          while (*v21);
          if (v18 != (uint64_t *)(v16 + 48) && v18[4] <= (unint64_t)a2)
          {
            v22 = (id *)v18[5];
            if (v22)
            {
              CPP3DAudioContext::~CPP3DAudioContext(v22);
              MEMORY[0x1DF0D41C0]();
            }
            std::__tree<std::__value_type<__C3DMesh *,WireframeMesh *>,std::__map_value_compare<__C3DMesh *,std::__value_type<__C3DMesh *,WireframeMesh *>,std::less<__C3DMesh *>,true>,std::allocator<std::__value_type<__C3DMesh *,WireframeMesh *>>>::__remove_node_pointer((uint64_t **)(v16 + 40), v18);
            operator delete(v18);
          }
        }
        if (*(_QWORD *)(v16 + 56))
        {
          v23 = *(CPP3DAudioEngine **)(v16 + 8);
          if (v23)
          {
            do
            {
              v24 = v23;
              v23 = *(CPP3DAudioEngine **)v23;
            }
            while (v23);
          }
          else
          {
            do
            {
              v24 = *(CPP3DAudioEngine **)(v16 + 16);
              v25 = *(_QWORD *)v24 == v16;
              v16 = (uint64_t)v24;
            }
            while (!v25);
          }
        }
        else
        {
          v24 = (CPP3DAudioEngine *)std::__tree<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::__map_value_compare<__C3DScene *,std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::less<__C3DScene *>,true>,std::allocator<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>>>::erase((uint64_t **)this + 2, v16);
        }
        v16 = (uint64_t)v24;
      }
      while (v24 != (CPP3DAudioEngine *)((char *)this + 24));
    }
  }
  return objc_msgSend(*((id *)this + 1), "unlock");
}

void C3DProgramHashCodeStoreClear(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 16;
  C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::enumerate(a1 + 16, (uint64_t)&__block_literal_global_4_2);
  C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::clear(v2);
  C3DIndexStoreRemoveAllIndexes(*(_QWORD *)(a1 + 48));
  *(_DWORD *)(a1 + 56) = 0;
}

void C3DIndexStoreRemoveAllIndexes(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DIndexStoreGetIndexForKey_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  C3DIndexSetRemoveAllIndexes(*(_QWORD *)(a1 + 24));
  C3DIndexSetAddIndexesInRange(*(_QWORD *)(a1 + 24), 0, *(_QWORD *)(a1 + 40));
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 16));
}

void C3DIndexSetRemoveAllIndexes(uint64_t a1)
{
  char v2;
  void *v3;

  v2 = *(_BYTE *)(a1 + 16);
  if ((v2 & 2) == 0)
  {
    v3 = *(void **)(a1 + 24);
    if (v3)
    {
      free(v3);
      v2 = *(_BYTE *)(a1 + 16);
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
  *(_BYTE *)(a1 + 16) = v2 | 3;
}

uint64_t C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::enumerate(uint64_t result, uint64_t a2)
{
  int v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;

  v2 = *(_DWORD *)(result + 28);
  if (v2 != -15)
  {
    v4 = result;
    v5 = 0;
    v6 = 0;
    do
    {
      if ((*(_WORD *)(*(_QWORD *)(v4 + 16) + 2 * v6) & 1) != 0)
      {
        result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a2 + 16))(a2, *(_QWORD *)(*(_QWORD *)v4 + 8 * v6), *(_QWORD *)(v4 + 8) + v5);
        v2 = *(_DWORD *)(v4 + 28);
      }
      ++v6;
      v5 += 8;
    }
    while (v6 < (v2 + 15));
  }
  return result;
}

void C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::clear(uint64_t a1)
{
  C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::_destroy_values(*(CFTypeRef **)(a1 + 8), *(__int16 **)(a1 + 16), *(_DWORD *)(a1 + 28) + 15);
  memset(*(void **)a1, 255, 8 * (*(_DWORD *)(a1 + 28) + 15));
  bzero(*(void **)(a1 + 16), 2 * (*(_DWORD *)(a1 + 28) + 15));
  *(_DWORD *)(a1 + 24) = 0;
}

void C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::_destroy_values(CFTypeRef *a1, __int16 *a2, unsigned int a3)
{
  uint64_t v5;
  __int16 v6;

  if (a3)
  {
    v5 = a3;
    do
    {
      v6 = *a2++;
      if ((v6 & 1) != 0)
      {
        if (*a1)
          CFRelease(*a1);
      }
      ++a1;
      --v5;
    }
    while (v5);
  }
}

uint64_t C3DAudioManagerRemoveEngineContext(__C3DEngineContext *a1)
{
  if (CPP3DAudioEngine::GetEngine(void)::onceToken != -1)
    dispatch_once(&CPP3DAudioEngine::GetEngine(void)::onceToken, &__block_literal_global_113);
  return CPP3DAudioEngine::RemoveContext((CPP3DAudioEngine *)gCPP3DAudioEngineInstance, a1);
}

_QWORD *CPP3DAudioEngine::GetContext(CPP3DAudioEngine *this, __C3DEngineContext *a2)
{
  _QWORD *Scene;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  BOOL v15;
  _QWORD *v16;
  uint64_t *v17;
  _QWORD *v19;
  __C3DEngineContext *v20;
  __C3DEngineContext **v21;

  v20 = a2;
  Scene = (_QWORD *)C3DEngineContextGetScene((uint64_t)a2);
  v19 = Scene;
  if (Scene)
  {
    objc_msgSend(*((id *)this + 1), "lock", v19, v20);
    v5 = (_QWORD *)*((_QWORD *)this + 3);
    if (!v5)
      goto LABEL_24;
    v6 = (_QWORD *)((char *)this + 24);
    do
    {
      v7 = v5[4];
      v8 = v7 >= (unint64_t)Scene;
      if (v7 >= (unint64_t)Scene)
        v9 = v5;
      else
        v9 = v5 + 1;
      if (v8)
        v6 = v5;
      v5 = (_QWORD *)*v9;
    }
    while (*v9);
    if (v6 == (_QWORD *)((char *)this + 24))
      goto LABEL_24;
    if ((unint64_t)Scene < v6[4])
      goto LABEL_24;
    v12 = (_QWORD *)v6[6];
    v10 = v6 + 6;
    v11 = v12;
    if (!v12)
      goto LABEL_24;
    v13 = v10;
    do
    {
      v14 = v11[4];
      v15 = v14 >= (unint64_t)a2;
      if (v14 >= (unint64_t)a2)
        v16 = v11;
      else
        v16 = v11 + 1;
      if (v15)
        v13 = v11;
      v11 = (_QWORD *)*v16;
    }
    while (*v16);
    if (v13 != v10 && v13[4] <= (unint64_t)a2)
    {
      Scene = (_QWORD *)v13[5];
    }
    else
    {
LABEL_24:
      Scene = (_QWORD *)operator new();
      *Scene = this;
      Scene[1] = a2;
      Scene[5] = 0;
      Scene[6] = 0;
      Scene[2] = 0;
      Scene[3] = 0;
      Scene[4] = Scene + 5;
      v21 = (__C3DEngineContext **)&v19;
      v17 = std::__tree<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::__map_value_compare<__C3DScene *,std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::less<__C3DScene *>,true>,std::allocator<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>>>::__emplace_unique_key_args<__C3DScene *,std::piecewise_construct_t const&,std::tuple<__C3DScene * const&>,std::tuple<>>((uint64_t **)this + 2, (unint64_t *)&v19, (uint64_t)&std::piecewise_construct, (uint64_t **)&v21);
      v21 = &v20;
      std::__tree<std::__value_type<__C3DMesh *,WireframeMesh *>,std::__map_value_compare<__C3DMesh *,std::__value_type<__C3DMesh *,WireframeMesh *>,std::less<__C3DMesh *>,true>,std::allocator<std::__value_type<__C3DMesh *,WireframeMesh *>>>::__emplace_unique_key_args<__C3DMesh *,std::piecewise_construct_t const&,std::tuple<__C3DMesh * const&>,std::tuple<>>((uint64_t **)v17 + 5, (unint64_t *)&v20, (uint64_t)&std::piecewise_construct, (uint64_t **)&v21)[5] = (uint64_t)Scene;
    }
    objc_msgSend(*((id *)this + 1), "unlock");
  }
  return Scene;
}

uint64_t C3DSortSystemInvalidate(uint64_t result)
{
  *(_BYTE *)(result + 40) = 1;
  return result;
}

_QWORD *C3DAudioManagerUpdateEngineContext(__C3DEngineContext *a1)
{
  if (CPP3DAudioEngine::GetEngine(void)::onceToken != -1)
    dispatch_once(&CPP3DAudioEngine::GetEngine(void)::onceToken, &__block_literal_global_113);
  return CPP3DAudioEngine::GetContext((CPP3DAudioEngine *)gCPP3DAudioEngineInstance, a1);
}

uint64_t *std::__tree<std::__value_type<__C3DMesh *,WireframeMesh *>,std::__map_value_compare<__C3DMesh *,std::__value_type<__C3DMesh *,WireframeMesh *>,std::less<__C3DMesh *>,true>,std::allocator<std::__value_type<__C3DMesh *,WireframeMesh *>>>::__emplace_unique_key_args<__C3DMesh *,std::piecewise_construct_t const&,std::tuple<__C3DMesh * const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  uint64_t *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t *std::__tree<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::__map_value_compare<__C3DScene *,std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::less<__C3DScene *>,true>,std::allocator<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>>>::__emplace_unique_key_args<__C3DScene *,std::piecewise_construct_t const&,std::tuple<__C3DScene * const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t v12;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x40uLL);
    v12 = **a4;
    v11[7] = 0;
    v11[6] = 0;
    v11[4] = v12;
    v11[5] = (uint64_t)(v11 + 6);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t C3DSceneRegisterEngineContext(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  _QWORD *v6;
  unsigned __int16 v7;
  _QWORD *v8;

  C3DSceneLock(a1);
  v4 = *(unsigned __int16 *)(a1 + 168);
  if (v4 == 1)
  {
    v5 = *(_QWORD *)(a1 + 160);
    v6 = malloc_type_malloc(0x10uLL, 0x2004093837F09uLL);
    *(_QWORD *)(a1 + 160) = v6;
    *v6 = v5;
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8) = a2;
    *(_WORD *)(a1 + 168) = 2;
  }
  else if (*(_WORD *)(a1 + 168))
  {
    v7 = v4 + 1;
    *(_WORD *)(a1 + 168) = v7;
    v8 = malloc_type_realloc(*(void **)(a1 + 160), 8 * v7, 0x2004093837F09uLL);
    *(_QWORD *)(a1 + 160) = v8;
    v8[*(unsigned __int16 *)(a1 + 168) - 1] = a2;
  }
  else
  {
    *(_WORD *)(a1 + 168) = 1;
    *(_QWORD *)(a1 + 160) = a2;
  }
  return C3DSceneUnlock(a1);
}

void C3DFXContextSceneDidChange(uint64_t a1, uint64_t a2)
{
  uint64_t Scene;

  if (*(_QWORD *)(a1 + 24))
  {
    Scene = C3DEngineContextGetScene(a2);
    if (Scene)
      C3DAddSceneRef(*(uint64_t **)(a1 + 24), Scene);
  }
}

uint64_t C3DMetalFramebufferPixelFormat(char a1)
{
  int IsEnabled;
  int v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;

  IsEnabled = C3DLinearRenderingIsEnabled();
  if ((a1 & 0x20) != 0)
    v3 = 0;
  else
    v3 = IsEnabled;
  v4 = 80;
  if (v3)
    v4 = 81;
  v5 = 554;
  if (v3)
    v5 = 555;
  v6 = v3 == 0;
  v7 = 80;
  if (!v6)
    v7 = 81;
  v8 = 550;
  if (!v6)
    v8 = 551;
  if ((a1 & 8) == 0)
    v7 = v8;
  if ((a1 & 0x10) == 0)
    v7 = v5;
  if ((a1 & 1) != 0)
    return v7;
  else
    return v4;
}

float C3DEngineContextSetPointOfView(uint64_t a1, float32x4_t *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float result;
  const __CFDictionary *Camera;
  float32x4_t *v14;
  CFTypeRef v15;
  float32x4_t *WorldMatrix;
  float32x4_t v17;
  float32x4_t v18;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = C3DEngineContextSetDefaultPointOfView(a1, 0);
  if (a2)
  {
    Camera = C3DNodeGetCamera((uint64_t)a2);
    if (Camera)
      *((_BYTE *)Camera + 312) &= ~1u;
  }
  v14 = *(float32x4_t **)(a1 + 24);
  if (v14 != a2)
  {
    if (v14)
    {
      CFRelease(v14);
      *(_QWORD *)(a1 + 24) = 0;
    }
    if (a2)
      v15 = CFRetain(a2);
    else
      v15 = 0;
    *(_QWORD *)(a1 + 24) = v15;
  }
  if (a2)
  {
    v18.i32[2] = 0;
    v18.i64[0] = 0;
    WorldMatrix = C3DNodeGetWorldMatrix(a2);
    C3DMatrix4x4GetScale(WorldMatrix, &v18);
    v17 = vabsq_f32(v18);
    result = 1.0 / fmaxf(fmaxf(v17.f32[0], v17.f32[2]), v17.f32[1]);
    *(float *)(a1 + 200) = result;
  }
  return result;
}

float C3DEngineContextSetDefaultPointOfView(uint64_t a1, float32x4_t *cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float result;
  float32x4_t *v13;
  CFTypeRef v14;
  float32x4_t *WorldMatrix;
  float32x4_t v16;
  float32x4_t v17;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v13 = *(float32x4_t **)(a1 + 40);
  if (v13 != cf)
  {
    if (v13)
    {
      CFRelease(v13);
      *(_QWORD *)(a1 + 40) = 0;
    }
    if (cf)
      v14 = CFRetain(cf);
    else
      v14 = 0;
    *(_QWORD *)(a1 + 40) = v14;
  }
  if (cf)
  {
    v17.i32[2] = 0;
    v17.i64[0] = 0;
    WorldMatrix = C3DNodeGetWorldMatrix(cf);
    C3DMatrix4x4GetScale(WorldMatrix, &v17);
    v16 = vabsq_f32(v17);
    result = 1.0 / fmaxf(fmaxf(v16.f32[0], v16.f32[2]), v16.f32[1]);
    *(float *)(a1 + 200) = result;
  }
  return result;
}

float32x4_t C3DMatrix4x4GetScale(float32x4_t *a1, float32x4_t *a2)
{
  float32x4_t v2;
  float32x4_t v3;
  int32x4_t v4;
  float32x4_t v5;
  BOOL v6;
  float v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t result;

  v2 = a1[1];
  v3 = a1[2];
  v4 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL), vnegq_f32(v2)), v3, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL));
  v5 = vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v4, v4), (int8x16_t)v4, 0xCuLL), *a1);
  v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0] < 0.0;
  v7 = 1.0;
  if (v6)
    v7 = -1.0;
  v8 = vmulq_f32(*a1, *a1);
  v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1)));
  v9.f32[0] = sqrtf(v9.f32[0]);
  v10 = vmulq_f32(v2, v2);
  v11 = vmulq_f32(v3, v3);
  v9.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]);
  v9.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
  result = vmulq_n_f32(v9, v7);
  *a2 = result;
  return result;
}

uint64_t SCNMTLDeviceSupportedSampleCountForSampleCount(void *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a2 < 2)
    return 1;
  v13 = v3;
  v14 = v2;
  v15 = v4;
  v16 = v5;
  v7 = (a2 - 1) | ((a2 - 1) >> 1) | ((((_DWORD)a2 - 1) | ((a2 - 1) >> 1)) >> 2);
  v8 = v7 | (v7 >> 4) | ((v7 | (v7 >> 4)) >> 8);
  v9 = (v8 | HIWORD(v8)) + 1;
  if (v9 >= 2)
  {
    while ((objc_msgSend(a1, "supportsTextureSampleCount:", v9, v13, v14, v15, v16) & 1) == 0)
    {
      v11 = v9 >> 1;
      v12 = v9 > 3;
      v9 >>= 1;
      if (!v12)
        return v11;
    }
  }
  return v9;
}

void C3DNotifyMetalIsUsed()
{
  gMetalIsUsed = 1;
}

void C3DEngineContextSetRenderingOptionForKey(uint64_t a1, const __CFString *key, void *value)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __CFDictionary *v14;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  if (!*(_QWORD *)(a1 + 376))
    *(_QWORD *)(a1 + 376) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (CFSTR("debugRendering") == key)
  {
    *(_BYTE *)(a1 + 208) = 1;
    C3DFXInvalidatePasses(a1);
  }
  v14 = *(__CFDictionary **)(a1 + 376);
  if (value)
    CFDictionarySetValue(v14, key, value);
  else
    CFDictionaryRemoveValue(v14, key);
}

uint64_t C3DEngineContextGetRenderCallbacks(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return a1 + 56;
}

void C3DEngineContextSetUserInfo(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_QWORD *)(a1 + 128) = a2;
}

void C3DEngineContextSetRenderContext(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef v12;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    if (cf)
      goto LABEL_4;
  }
  else if (cf)
  {
LABEL_4:
    v12 = CFRetain(cf);
    goto LABEL_7;
  }
  v12 = 0;
LABEL_7:
  *(_QWORD *)(a1 + 1704) = v12;
  *(_DWORD *)(a1 + 1712) = -[SCNMTLRenderContext features]((uint64_t)cf);
  *(_WORD *)(a1 + 214) = 3;
  if (-[SCNMTLRenderContext reverseZ]((uint64_t)cf))
    *(_WORD *)(a1 + 214) |= 8u;
  *(_QWORD *)(a1 + 1696) = -[SCNMTLResourceManager commandQueue]((uint64_t)cf);
  __InstallFXContext(a1);
}

void __InstallFXContext(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = *(_QWORD **)(a1 + 160);
  if (v2)
  {
    C3DFXContextCleanup(v2, a1);
    C3DEngineContextSetFXContext(a1, 0);
  }
  v3 = C3DFXContextCreate();
  C3DEngineContextSetFXContext(a1, v3);
  if (C3DEngineContextGetScene(a1))
    C3DFXContextSceneDidChange((uint64_t)v3, a1);
  CFRelease(v3);
}

_QWORD *C3DFXContextCreate()
{
  _QWORD *Instance;
  const CFArrayCallBacks *v1;
  _QWORD *v2;

  if (C3DFXContextGetTypeID_onceToken != -1)
    dispatch_once(&C3DFXContextGetTypeID_onceToken, &__block_literal_global_103);
  Instance = (_QWORD *)C3DTypeCreateInstance_(C3DFXContextGetTypeID_typeID, 0x130uLL);
  Instance[30] = C3DFramebufferRegistryCreate();
  v1 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  Instance[35] = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  Instance[37] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v1);
  v2 = C3DAllocatorCreate(5136, 16);
  Instance[26] = v2;
  C3DAllocatorSetKeepLastPageAllocated((uint64_t)v2, 1);
  return Instance;
}

_QWORD *C3DFramebufferRegistryCreate()
{
  _QWORD *Instance;
  const CFDictionaryValueCallBacks *v1;
  const CFDictionaryKeyCallBacks *v2;

  if (C3DFramebufferRegistryGetTypeID_onceToken != -1)
    dispatch_once(&C3DFramebufferRegistryGetTypeID_onceToken, &__block_literal_global_69);
  Instance = (_QWORD *)C3DTypeCreateInstance_(C3DFramebufferRegistryGetTypeID_typeID, 0x48uLL);
  if (Instance)
  {
    v1 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    Instance[6] = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E0C9B3A0]);
    Instance[2] = CFDictionaryCreateMutable(0, 0, 0, v1);
    Instance[3] = CFDictionaryCreateMutable(0, 0, 0, v1);
    v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    Instance[9] = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], v1);
    Instance[4] = CFDictionaryCreateMutable(0, 0, v2, 0);
  }
  return Instance;
}

CFTypeRef C3DEngineContextSetFXContext(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(CFTypeRef *)(a1 + 160);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 160) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 160) = result;
  }
  return result;
}

void C3DEngineContextSetClearsOnDraw(uint64_t a1, char a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_BYTE *)(a1 + 210) = a2;
}

uint64_t C3DAllocatorSetKeepLastPageAllocated(uint64_t result, char a2)
{
  *(_BYTE *)(result + 64) = a2;
  return result;
}

void sub_1DCD063B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1DF0D41C0](v1, 0x10A0C400A278675);
  _Unwind_Resume(a1);
}

void SCNMTLBufferPool::SCNMTLBufferPool(SCNMTLBufferPool *this, SCNMTLResourceManager *a2, NSString *a3, uint64_t a4, MTLStorageMode a5)
{
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a4;
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = a5;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 2) = a3;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 11) = 0;
}

void sub_1DCD06440(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 40) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t C3DUseOneCommandQueuePerDevice()
{
  if (C3DUseOneCommandQueuePerDevice_onceToken != -1)
    dispatch_once(&C3DUseOneCommandQueuePerDevice_onceToken, &__block_literal_global_179);
  return C3DUseOneCommandQueuePerDevice_useOneCommandQueuePerDevice;
}

void SCNMTLTexturePool::SCNMTLTexturePool(SCNMTLTexturePool *this, SCNMTLRenderContext *a2)
{
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = -[SCNMTLRenderContext resourceManager]((uint64_t)a2);
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
}

uint64_t SCNMTLDeviceSupportsVertexAmplification(void *a1)
{
  uint64_t result;

  result = C3DSceneSourceGetSceneCount();
  if ((_DWORD)result)
    return objc_msgSend(a1, "supportsVertexAmplificationCount:", 2);
  return result;
}

uint64_t SCNMTLDeviceSupportsTextureSwizzle(void *a1)
{
  uint64_t result;

  result = C3DSceneSourceGetSceneCount();
  if ((_DWORD)result)
    return objc_msgSend(a1, "supportsTextureSwizzle");
  return result;
}

uint64_t SCNMTLDeviceSupportsTessellation(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsTessellation");
  else
    return objc_msgSend(a1, "supportsFeatureSet:", 7);
}

uint64_t SCNMTLDeviceSupportsStencilResolve(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsMSAAStencilResolve");
  else
    return objc_msgSend(a1, "supportsFeatureSet:", 16);
}

uint64_t SCNMTLDeviceSupportsProgrammableBlending(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsProgrammableBlending");
  else
    return 1;
}

uint64_t SCNMTLDeviceSupportsNonUniformThreadgroupSize(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsNonUniformThreadgroupSize");
  else
    return objc_msgSend(a1, "supportsFeatureSet:", 11);
}

uint64_t SCNMTLDeviceSupportsMultipleViewports(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return (unint64_t)objc_msgSend(a1, "maxViewportCount") > 1;
  else
    return objc_msgSend(a1, "supportsFeatureSet:", 16);
}

uint64_t SCNMTLDeviceSupportsLayeredRendering(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsLayeredRendering");
  else
    return objc_msgSend(a1, "supportsFeatureSet:", 16);
}

uint64_t C3DSceneSourceGetSceneCount()
{
  return 1;
}

uint64_t SCNMTLDeviceSupportsDepthResolve(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsMSAADepthResolve");
  else
    return objc_msgSend(a1, "supportsFeatureSet:", 4);
}

uint64_t SCNMTLDeviceSupportsDepthClipMode(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsDepthClipMode");
  else
    return 1;
}

uint64_t SCNMTLDeviceSupportsDepth24UnormStencil8()
{
  return 0;
}

uint64_t SCNMTLDeviceSupportsCubeMapWrite(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsReadWriteTextureCubeArguments");
  else
    return objc_msgSend(a1, "supportsFeatureSet:", 11);
}

uint64_t SCNMTLDeviceSupportsCubeMapTextureArrays(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsTextureCubeArray");
  else
    return objc_msgSend(a1, "supportsFeatureSet:", 11);
}

uint64_t SCNMTLDeviceSupportsBaseInstance(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsBaseVertexInstanceDrawing");
  if ((objc_msgSend(a1, "supportsFeatureSet:", 10) & 1) != 0)
    return 1;
  return objc_msgSend(a1, "supportsFeatureSet:", 11);
}

uint64_t C3DReverseZIsSupported()
{
  if (C3DReverseZIsSupported_onceToken != -1)
    dispatch_once(&C3DReverseZIsSupported_onceToken, &__block_literal_global_170);
  return C3DReverseZIsSupported_useReverseZ;
}

uint64_t SCNSampleCountForAntialiasingMode(unint64_t a1)
{
  int v1;
  NSObject *v3;

  v1 = a1;
  if (a1 < 3)
    return qword_1DD008E60[a1];
  v3 = scn_default_log();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    SCNSampleCountForAntialiasingMode_cold_1(v1, v3);
  return 1;
}

uint64_t C3DEngineContextGetRendererContextGL(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 136);
}

BOOL C3DPreferencesGetBool(int a1)
{
  if (C3DPreferencesGetInteger_onceToken != -1)
    dispatch_once(&C3DPreferencesGetInteger_onceToken, &__block_literal_global_129);
  return C3DPreferencesGetInteger_prefs[a1] != 0;
}

uint64_t *std::__tree<std::__value_type<__C3DMesh *,WireframeMesh *>,std::__map_value_compare<__C3DMesh *,std::__value_type<__C3DMesh *,WireframeMesh *>,std::less<__C3DMesh *>,true>,std::allocator<std::__value_type<__C3DMesh *,WireframeMesh *>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

void CPP3DAudioContext::~CPP3DAudioContext(id *this)
{
  CPP3DAudioContext *v2;
  const void *v3;
  CPP3DAudioContext *v4;
  CPP3DAudioContext *v5;
  BOOL v6;

  objc_msgSend(this[2], "reset");
  objc_msgSend((id)objc_msgSend(this[2], "engine"), "disconnectNodeInput:", this[2]);
  objc_msgSend((id)objc_msgSend(this[2], "engine"), "disconnectNodeOutput:", this[2]);
  objc_msgSend((id)objc_msgSend(this[2], "engine"), "detachNode:", this[2]);

  v2 = (CPP3DAudioContext *)this[4];
  if (v2 != (CPP3DAudioContext *)(this + 5))
  {
    do
    {
      v3 = (const void *)*((_QWORD *)v2 + 4);
      if (v3)
        CFRelease(v3);
      v4 = (CPP3DAudioContext *)*((_QWORD *)v2 + 1);
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = *(CPP3DAudioContext **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v5 = (CPP3DAudioContext *)*((_QWORD *)v2 + 2);
          v6 = *(_QWORD *)v5 == (_QWORD)v2;
          v2 = v5;
        }
        while (!v6);
      }
      v2 = v5;
    }
    while (v5 != (CPP3DAudioContext *)(this + 5));
  }
  std::__tree<char>::destroy((uint64_t)(this + 4), this[5]);
}

void sub_1DCD06C80(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<char>::destroy(v1 + 32, *(_QWORD **)(v1 + 40));
  _Unwind_Resume(a1);
}

uint64_t C3DSceneUnregisterEngineContext(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  int v4;
  unint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;

  if (*(_WORD *)(result + 168))
  {
    v3 = result;
    C3DSceneLock(result);
    v4 = *(unsigned __int16 *)(v3 + 168);
    if (*(_WORD *)(v3 + 168))
    {
      if (v4 == 1)
      {
        if (*(_QWORD *)(v3 + 160) == a2)
        {
          *(_WORD *)(v3 + 168) = 0;
          *(_QWORD *)(v3 + 160) = 0;
        }
      }
      else
      {
        v5 = 0;
        v6 = 8;
        do
        {
          v7 = *(char **)(v3 + 160);
          if (*(_QWORD *)&v7[8 * v5] == a2)
          {
            if ((unsigned __int16)v4 == 2)
            {
              v8 = *(_QWORD *)&v7[v6];
              free(v7);
              *(_QWORD *)(v3 + 160) = v8;
              LOWORD(v4) = 1;
              *(_WORD *)(v3 + 168) = 1;
            }
            else
            {
              LOWORD(v4) = v4 - 1;
              *(_WORD *)(v3 + 168) = v4;
              *(_QWORD *)&v7[8 * v5] = *(_QWORD *)&v7[8 * (unsigned __int16)v4];
            }
          }
          ++v5;
          v6 -= 8;
        }
        while (v5 < (unsigned __int16)v4);
      }
    }
    return C3DSceneUnlock(v3);
  }
  return result;
}

_QWORD *C3DRendererElementStoreCreate()
{
  _QWORD *Instance;

  if (C3DRendererElementStoreGetTypeID_onceToken != -1)
    dispatch_once(&C3DRendererElementStoreGetTypeID_onceToken, &__block_literal_global_134);
  Instance = (_QWORD *)C3DTypeCreateInstance_(C3DRendererElementStoreGetTypeID_typeID, 0x18uLL);
  Instance[3] = C3DIndexStoreCreateWithCapacity(0x7FFFFFFFLL);
  Instance[4] = C3DIndexStoreCreateWithCapacity(0x7FFFFFFFLL);
  Instance[2] = C3DSpanAllocatorCreate(80, 4096);
  return Instance;
}

uint64_t C3DProgramHashCodeStoreCreate()
{
  uint64_t Instance;

  if (C3DProgramHashCodeStoreGetTypeID(void)::onceToken != -1)
    dispatch_once(&C3DProgramHashCodeStoreGetTypeID(void)::onceToken, &__block_literal_global_81);
  Instance = C3DTypeCreateInstance_(C3DProgramHashCodeStoreGetTypeID(void)::typeID, 0x30uLL);
  C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_allocate(Instance + 16, 32);
  *(_QWORD *)(Instance + 48) = C3DIndexStoreCreateWithCapacity(0x7FFFFFFFLL);
  return Instance;
}

_QWORD *C3DIndexStoreCreateWithCapacity(uint64_t a1)
{
  _QWORD *Instance;

  if (C3DIndexStoreGetTypeID_onceToken != -1)
    dispatch_once(&C3DIndexStoreGetTypeID_onceToken, &__block_literal_global_135);
  Instance = (_QWORD *)C3DTypeCreateInstance_(C3DIndexStoreGetTypeID_typeID, 0x40uLL);
  Instance[2] = CFDictionaryCreateMutable(0, 0, 0, 0);
  Instance[3] = C3DIndexSetCreateMutable();
  Instance[4] = 0;
  Instance[5] = a1;
  Instance[6] = C3DAllocatorCreate(16, 4096);
  C3DIndexSetAddIndexesInRange(Instance[3], 0, a1);
  return Instance;
}

_QWORD *C3DAllocatorCreate(uint64_t a1, uint64_t a2)
{
  _QWORD *Instance;

  if (C3DAllocatorGetTypeID_onceToken != -1)
    dispatch_once(&C3DAllocatorGetTypeID_onceToken, &__block_literal_global_136);
  Instance = (_QWORD *)C3DTypeCreateInstance_(C3DAllocatorGetTypeID_typeID, 0x38uLL);
  Instance[5] = C3DIndexSetCreateMutable();
  Instance[2] = a1;
  Instance[3] = a2;
  return Instance;
}

uint64_t C3DIndexSetCreateMutable()
{
  uint64_t result;

  result = C3DIndexSetCreate();
  *(_BYTE *)(result + 16) |= 0xBu;
  return result;
}

void C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_allocate(uint64_t a1, int a2)
{
  unsigned int v3;
  size_t v4;
  size_t v5;

  if ((a2 & (a2 - 1)) != 0)
    C3D::Hash<C3D::FinalPass::RenderTarget,C3D::StackAllocator>::_allocate();
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = a2;
  v3 = a2 + 15;
  v4 = 2 * (a2 + 15);
  *(_QWORD *)(a1 + 16) = malloc_type_malloc((2 * (a2 + 15)), 0x74F3E194uLL);
  v5 = 8 * v3;
  *(_QWORD *)a1 = malloc_type_malloc(v5 & 0xFFFFFFF8, 0x74F3E194uLL);
  *(_QWORD *)(a1 + 8) = malloc_type_malloc(v5 & 0xFFFFFFF8, 0x74F3E194uLL);
  memset(*(void **)a1, 255, v5);
  bzero(*(void **)(a1 + 16), v4);
}

uint64_t C3DSpanAllocatorCreate(uint64_t a1, uint64_t a2)
{
  uint64_t Instance;
  size_t v6;
  int v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (C3DSpanAllocatorGetTypeID_onceToken != -1)
    dispatch_once(&C3DSpanAllocatorGetTypeID_onceToken, &__block_literal_global_143);
  Instance = C3DTypeCreateInstance_(C3DSpanAllocatorGetTypeID_typeID, 0x28uLL);
  *(_QWORD *)(Instance + 40) = a1;
  *(_QWORD *)(Instance + 48) = a2;
  *(_QWORD *)v7 = 0x1000000006;
  v6 = 4;
  if (sysctl(v7, 2u, (void *)(Instance + 32), &v6, 0, 0) < 0)
    *(_DWORD *)(Instance + 32) = 64;
  return Instance;
}

void C3DFXContextSceneWillChange(uint64_t a1)
{
  void *v1;
  uint64_t v2;

  v1 = *(void **)(a1 + 24);
  if (v1)
  {
    v2 = C3DGetScene(*(_QWORD **)(a1 + 24));
    C3DRemoveSceneRef(v1, v2);
  }
}

void C3DEngineContextUnSetupForWarmUp(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  *(_BYTE *)(a1 + 461) = 0;
  *(_QWORD *)(a1 + 464) = 0;
}

void C3DEngineContextSetupForWarmUp(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_BYTE *)(a1 + 461) = 1;
  *(_QWORD *)(a1 + 464) = a2;
}

uint64_t C3DEngineContextSetInterfaceOrientation(uint64_t result, int a2)
{
  *(_DWORD *)(result + 368) = a2;
  return result;
}

CFIndex CFStringToStringDictionaryHash(uint64_t a1, uint64_t a2)
{
  CFIndex result;

  result = CFStringUpdateHash(a1);
  if (a2)
    return CFStringUpdateHash(a2);
  return result;
}

void C3DModelPathResolverRegisterClassEnd()
{
  _currentClassRegistry = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&_modelPathResolverRegistryLock);
}

void C3DModelPathResolverRegisterClassBegin(void *a1, const void *a2)
{
  __CFDictionary *Type;

  os_unfair_lock_lock((os_unfair_lock_t)&_modelPathResolverRegistryLock);
  Type = (__CFDictionary *)_C3DModelPathResolverRegistryGetType(a1);
  _currentClassRegistry = (uint64_t)Type;
  if (a2)
    CFDictionaryAddValue(Type, CFSTR("superClass"), a2);
}

const void *_C3DModelPathResolverRegistryGetType(void *key)
{
  const __CFDictionary *Mutable;
  const void *Value;

  Mutable = (const __CFDictionary *)_modelPathResolverRegistry;
  if (!_modelPathResolverRegistry)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
    _modelPathResolverRegistry = (uint64_t)Mutable;
  }
  Value = CFDictionaryGetValue(Mutable, key);
  if (!Value)
  {
    Value = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], 0);
    CFDictionarySetValue((CFMutableDictionaryRef)_modelPathResolverRegistry, key, Value);
  }
  return Value;
}

uint64_t C3DGeometryGetTypeID()
{
  if (C3DGeometryGetTypeID_onceToken != -1)
    dispatch_once(&C3DGeometryGetTypeID_onceToken, &__block_literal_global_5);
  return C3DGeometryGetTypeID_typeID;
}

void C3DModelPathResolverRegisterProperty(const void *a1, unsigned int a2, __int16 a3, char a4, uint64_t a5, uint64_t a6)
{
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _WORD *v20;
  NSObject *v21;

  if (!_currentClassRegistry)
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      C3DModelPathResolverRegisterProperty_cold_2(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  v20 = malloc_type_malloc(0x20uLL, 0x1080040FF9D436EuLL);
  v20[4] = a3;
  *(_QWORD *)v20 = a2;
  *((_BYTE *)v20 + 10) = a4;
  *((_QWORD *)v20 + 2) = a5;
  *((_QWORD *)v20 + 3) = a6;
  if (CFDictionaryGetCountOfKey((CFDictionaryRef)_currentClassRegistry, a1))
  {
    v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
      C3DModelPathResolverRegisterProperty_cold_1((uint64_t)a1, v21);
  }
  CFDictionarySetValue((CFMutableDictionaryRef)_currentClassRegistry, a1, v20);
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void C3DShaderAddStandardUniform(const __CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  NSObject *v12;
  _QWORD *v13;

  if (CFDictionaryGetValue(a1, a2))
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      C3DShaderAddStandardUniform_cold_1((uint64_t)a2, v12);
  }
  v13 = C3DMalloc(0x20uLL);
  v13[1] = a4;
  v13[2] = a5;
  *v13 = a3;
  *((_DWORD *)v13 + 6) = a6;
  CFDictionarySetValue(a1, a2, v13);
}

const __CFSet *C3DEngineContextApplyModifiers(uint64_t a1, uint64_t a2)
{
  uint64_t Stats;
  const __CFSet *result;
  const __CFSet *v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  uint64_t v13;
  _QWORD v14[5];
  _QWORD v15[5];

  Stats = C3DEngineContextGetStats(a1);
  result = (const __CFSet *)C3DEnginePipelineGetNodesForKey(a2, CFSTR("kDeformerStackKey"), 0);
  if (result)
  {
    v6 = result;
    v7 = *(_QWORD *)(a1 + 1704);
    if (v7)
      -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v7);
    kdebug_trace();
    v8 = CACurrentMediaTime();
    v9 = MEMORY[0x1E0C809B0];
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = __C3DEngineContextApplyModifiers_block_invoke;
    v15[3] = &__block_descriptor_40_e10_v16__0r_v8l;
    v15[4] = a1;
    C3DCFSetApplyBlock(v6, (uint64_t)v15);
    *(double *)(Stats + 144) = *(double *)(Stats + 144) + CACurrentMediaTime() - v8;
    v10 = *(_QWORD *)(a1 + 1704);
    if (v10)
      -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v10);
    kdebug_trace();
    v11 = *(_QWORD *)(a1 + 1704);
    if (v11)
      -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v11);
    kdebug_trace();
    v12 = CACurrentMediaTime();
    v14[0] = v9;
    v14[1] = 3221225472;
    v14[2] = __C3DEngineContextApplyModifiers_block_invoke_2;
    v14[3] = &__block_descriptor_40_e10_v16__0r_v8l;
    v14[4] = a1;
    C3DCFSetApplyBlock(v6, (uint64_t)v14);
    *(double *)(Stats + 136) = *(double *)(Stats + 136) + CACurrentMediaTime() - v12;
    v13 = *(_QWORD *)(a1 + 1704);
    if (v13)
      -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v13);
    return (const __CFSet *)kdebug_trace();
  }
  return result;
}

const void *__C3DEnginePipelineGetNodesForKey(uint64_t a1, void *key, int a3, int a4)
{
  const __CFDictionary *Mutable;
  const void *Value;
  BOOL v10;
  BOOL v11;
  _QWORD v13[6];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  Mutable = *(const __CFDictionary **)(a1 + 24);
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)(a1 + 24) = Mutable;
  }
  Value = CFDictionaryGetValue(Mutable, key);
  if (Value)
    v10 = 1;
  else
    v10 = a3 == 0;
  if (!v10)
  {
    Value = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), key, Value);
    CFRelease(Value);
  }
  if (Value)
    v11 = a4 == 0;
  else
    v11 = 1;
  if (!v11 && CFEqual(key, CFSTR("kDeformerStackKey")))
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v17 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = ____C3DEnginePipelineGetNodesForKey_block_invoke;
    v13[3] = &unk_1EA5A0B90;
    v13[4] = &v14;
    v13[5] = Value;
    C3DCFSetApplyBlock((const __CFSet *)Value, (uint64_t)v13);
    if (v15[3])
      Value = (const void *)v15[3];
    _Block_object_dispose(&v14, 8);
  }
  return Value;
}

void sub_1DCD0A0B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const void *C3DEnginePipelineGetNodesForKey(uint64_t a1, void *a2, int a3)
{
  return __C3DEnginePipelineGetNodesForKey(a1, a2, a3, 1);
}

void sub_1DCD0A294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double SCNMTLBufferPool::reset(SCNMTLBufferPool *this)
{
  double result;

  *((_DWORD *)this + 14) = 0;
  result = 0.0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  return result;
}

void SCNMTLTexturePool::reset(SCNMTLTexturePool *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 3);
  if (v3 == v2)
  {
    v3 = *((_QWORD *)this + 3);
  }
  else
  {
    do
    {
      v4 = *(_DWORD *)(v3 + 28);
      *(_DWORD *)(v3 + 28) = v4 + 1;
      if (v4 < 0x65)
      {
        v3 += 32;
      }
      else
      {

        v5 = *((_QWORD *)this + 3);
        v6 = v5 - (v3 + 32);
        if (v5 != v3 + 32)
          memmove((void *)v3, (const void *)(v3 + 32), v5 - (v3 + 32));
        v2 = v3 + v6;
        *((_QWORD *)this + 3) = v3 + v6;
      }
    }
    while (v3 != v2);
    v2 = *((_QWORD *)this + 2);
  }
  *((_DWORD *)this + 10) = (unint64_t)(v3 - v2) >> 5;
}

_QWORD *C3DTransactionSetImmediateModeRestrictedContext(uint64_t a1)
{
  _QWORD *result;

  result = C3DTransactionGetCurrent();
  result[6] = a1;
  return result;
}

void _addLightsInFrustum(uint64_t a1)
{
  simd_float4 *v1;
  simd_float4 *v2;
  unsigned int v3;
  __int128 *v4;
  __int128 *v5;
  uint64_t *v6;
  uint64_t v7;
  const __CFDictionary *v8;
  __n128 *v9;
  float32x4_t *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *ParticleManager;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  unsigned int v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t RenderContext;
  float32x4_t *v40;
  _BYTE *v41;
  float32x4_t *v42;
  float *v43;
  uint64_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float v53;
  float32x4_t v54;
  float v55;
  float32x4_t v56;
  unsigned int v57;
  uint64_t *v58;
  unsigned int v59;
  uint64_t v63;
  uint64_t *v64;
  __n128 *v65;
  uint64_t v66;
  uint64_t v67;
  int Type;
  float32x4_t v70;
  float32x4_t v71;
  double v72;
  double v73;
  double v74;
  double v75;
  __n128 v76;
  uint64_t v77;
  __int128 v78;
  int v79;
  unint64_t v80;
  __int128 v81;
  float32x4_t *WorldMatrix;
  uint64_t v83;
  simd_float4 v84;
  simd_float4 v85;
  simd_float4 v86;
  float32x4_t *v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  unint64_t v92;
  uint64_t v93;
  int32x4_t v94;
  float32x2_t v95;
  float32x2_t v96;
  float32x4_t v97;
  __int128 v98;
  float32x4_t *v99;
  uint64_t v100;
  NSObject *v101;
  uint64_t ProbeEnvironment;
  float Intensity;
  uint64_t v104;
  float32x4_t v105;
  __int128 v106;
  int RadianceProbeIndex;
  uint64_t v108;
  NSObject *v109;
  __n128 ProbeExtents;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t *v115;
  float32x4_t *v116;
  __n128 v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  uint64_t v121;
  uint64_t v122;
  _OWORD *v123;
  float v124;
  float v125;
  _BYTE *v126;
  int v127;
  __CFString *ShadowMapNameForNode;
  unsigned int ActiveShadowCasterIndex;
  uint64_t ActiveShadowCasterData;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  __n128 v139;
  __n128 v140;
  __n128 v141;
  __n128 v142;
  uint64_t v143;
  simd_float4 *v144;
  simd_float4 v145;
  simd_float4 v146;
  simd_float4 v147;
  uint64_t v148;
  simd_float4 v149;
  simd_float4 v150;
  simd_float4 v151;
  simd_float4 v152;
  simd_float4 *v153;
  simd_float4 *v154;
  simd_float4 v155;
  simd_float4 v156;
  simd_float4 v157;
  __int128 v158;
  _OWORD *v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  unsigned int ShadowCascadeCount;
  uint64_t v164;
  __int128 *v165;
  __int128 v166;
  __int128 v167;
  float ShadowRadius;
  __int32 v169;
  float ShadowCascadeDebugFactor;
  int32x2_t v171;
  float32x2_t v172;
  float32x2_t v173;
  float32x4_t v174;
  float32x2_t v175;
  float32x2_t v176;
  float32x4_t v177;
  int32x4_t v178;
  float32x2_t v179;
  float32x2_t v180;
  float32x4_t v181;
  float v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  char *Matrix;
  uint64_t v187;
  float32x4_t *ImageTransform;
  uint64_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  simd_float4 v194;
  simd_float4 v195;
  simd_float4 v196;
  simd_float4 v197;
  float32x4_t v199;
  float32x4_t v200;
  int32x4_t v201;
  float32_t v202;
  float32x4_t v203;
  uint64_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  simd_float4 v209;
  simd_float4 v210;
  simd_float4 v211;
  simd_float4 *v212;
  float32x4_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t *v216;
  uint64_t v217;
  uint64_t v218;
  simd_float4 *v219;
  uint64_t *v220;
  uint64_t v221;
  uint64_t v222;
  SCNMTLBufferPool *v223;
  uint64_t v224;
  unsigned int v225;
  NSObject *v226;
  unsigned int v227;
  char CoordinatesSystemOptions;
  uint64_t v229;
  const void **v230;
  void *v231;
  uint64_t v232;
  void **v233;
  float32x2_t **v234;
  int v235;
  __n128 *v236;
  uint64_t v237;
  int HasValidGobo;
  float32x4_t v239;
  __n128 *Scene;
  float32x4_t v241;
  _BOOL4 HasValidIES;
  float32x4_t v243;
  float32x4_t v244;
  unsigned __int8 *v245;
  float32x4_t v246;
  simd_float4x4 v247;
  float32x4_t v248;
  float32x4_t v249;
  simd_float4 v250;
  simd_float4 v251;
  simd_float4 v252;
  simd_float4 v253;
  simd_float4 v254;
  simd_float4x4 v255;
  simd_float4 v256;
  simd_float4 v257;
  float32x4_t v258;
  float32x4_t v259;
  simd_float4 *v260;
  uint64_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  unint64_t v265;
  float32x4_t *v266;
  float32x4_t v267;
  float32x4_t *v268;
  float32x4_t v269;
  int8x8_t RealShadowMapSize;
  float32x4_t v271;
  simd_float4 v272;
  _OWORD *v273;
  float32x4_t v274;
  uint64_t v275;
  simd_float4x4 v276[3];
  uint64_t v277;
  _QWORD v278[4];
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  __int128 v284;
  uint64_t *v285;
  _OWORD *v286;
  _OWORD *v287;
  _OWORD *v288;
  int v289;
  _OWORD v290[6];
  _QWORD v291[4];
  __int128 v292;
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  uint64_t *v298;
  float32x4_t *v299;
  _OWORD *v300;
  _OWORD *v301;
  int v302;
  _OWORD v303[6];
  _QWORD v304[4];
  __int128 v305;
  __int128 v306;
  __int128 v307;
  __int128 v308;
  __int128 v309;
  __int128 v310;
  uint64_t *v311;
  __n128 *v312;
  _OWORD *v313;
  _OWORD *v314;
  _OWORD *v315;
  int v316;
  _QWORD v317[4];
  __int128 v318;
  __int128 v319;
  __int128 v320;
  __int128 v321;
  __int128 v322;
  __int128 v323;
  uint64_t *v324;
  __n128 *v325;
  _OWORD *v326;
  _OWORD *v327;
  int v328;
  _QWORD v329[7];
  uint64_t v330;
  uint64_t *v331;
  uint64_t v332;
  int v333;
  simd_float4x4 v334;
  simd_float4x4 v335;
  uint8_t v336[4];
  uint64_t v337;
  uint8_t v338[4];
  uint64_t v339;
  uint8_t v340[4];
  uint64_t v341;
  _DWORD v342[14];
  _BYTE v343[352];
  float32x4_t v344[24];
  __n128 v345[256];
  _OWORD v346[128];
  _OWORD v347[128];
  uint64_t v348;
  simd_float4x4 v349;
  simd_float4x4 v350;
  simd_float4x4 v351;
  simd_float4x4 v352;
  simd_float4x4 v353;

  MEMORY[0x1E0C80A78](a1);
  v2 = v1;
  v225 = v3;
  v5 = v4;
  v348 = *MEMORY[0x1E0C80C00];
  v7 = v6[1];
  v266 = *v6;
  v8 = (const __CFDictionary *)v6[2];
  v223 = (SCNMTLBufferPool *)v6[3];
  v9 = (__n128 *)v6[4];
  v10 = (float32x4_t *)v6[5];
  v273 = (_OWORD *)v6[6];
  Scene = (__n128 *)C3DEngineContextGetScene(v7);
  memset(v347, 0, 512);
  memset(v346, 0, 512);
  v330 = 0;
  v331 = &v330;
  v332 = 0x2020000000;
  v333 = 0;
  v11 = MEMORY[0x1E0C809B0];
  v329[0] = MEMORY[0x1E0C809B0];
  v329[1] = 3221225472;
  v329[2] = ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke;
  v329[3] = &unk_1EA5A1488;
  v329[4] = &v330;
  v329[5] = v346;
  v329[6] = v347;
  v232 = v7;
  C3DLightingSystemEnumerateGlobalLights(v8, v7, (uint64_t)v329);
  v12 = *((unsigned int *)v331 + 6);
  v317[0] = v11;
  v317[1] = 3221225472;
  v317[2] = ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_2;
  v317[3] = &unk_1EA5A14B0;
  v13 = v5[3];
  v320 = v5[2];
  v321 = v13;
  v14 = v5[5];
  v322 = v5[4];
  v323 = v14;
  v15 = v5[1];
  v318 = *v5;
  v319 = v15;
  v324 = &v330;
  v16 = v12;
  v236 = v9;
  v237 = (uint64_t)v8;
  v325 = v9;
  v328 = v12;
  v326 = v346;
  v327 = v347;
  C3DLightingSystemEnumerateLocalOmnis((uint64_t)v8, (uint64_t)v317);
  if (Scene)
  {
    ParticleManager = C3DSceneGetParticleManager((uint64_t)Scene, 0);
    if (ParticleManager)
    {
      v304[0] = v11;
      v304[1] = 3221225472;
      v304[2] = ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_3;
      v304[3] = &unk_1EA5A14D8;
      v18 = v5[3];
      v307 = v5[2];
      v308 = v18;
      v19 = v5[5];
      v309 = v5[4];
      v310 = v19;
      v20 = v5[1];
      v305 = *v5;
      v306 = v20;
      v311 = &v330;
      v312 = v9;
      v316 = v16;
      v313 = (_OWORD *)v345;
      v314 = v346;
      v315 = v347;
      C3DParticleManagerEnumerateInstancesWithLightEmission((uint64_t)ParticleManager, (uint64_t)v304);
    }
  }
  LODWORD(v21) = v16;
  HIDWORD(v21) = *((_DWORD *)v331 + 6) - v16;
  v2[5].i64[1] = v21;
  C3DEngineContextGetAuthoringEnvironment(v7, 0);
  v22 = v5[3];
  v303[2] = v5[2];
  v303[3] = v22;
  v23 = v5[5];
  v303[4] = v5[4];
  v303[5] = v23;
  v24 = v5[1];
  v303[0] = *v5;
  v303[1] = v24;
  __sortOmniLightsOnZAxis((uint64_t)v303, v9, (_QWORD *)v347 + v16, (_QWORD *)v346 + v16, &v345[v16], v2[5].i16[6], *(double *)v303);
  v224 = v16;
  v25 = *((unsigned int *)v331 + 6);
  v291[0] = v11;
  v291[1] = 3221225472;
  v291[2] = ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_4;
  v291[3] = &unk_1EA5A1500;
  v26 = v5[3];
  v294 = v5[2];
  v295 = v26;
  v27 = v5[5];
  v296 = v5[4];
  v297 = v27;
  v28 = v5[1];
  v292 = *v5;
  v293 = v28;
  v298 = &v330;
  v299 = v10;
  v302 = v25;
  v300 = v346;
  v301 = v347;
  C3DLightingSystemEnumerateSpots((uint64_t)v8, (uint64_t)v291);
  v29 = *((_DWORD *)v331 + 6) - v25;
  v2[6].i64[0] = __PAIR64__(v29, v25);
  v30 = v5[3];
  v290[2] = v5[2];
  v290[3] = v30;
  v31 = v5[5];
  v290[4] = v5[4];
  v290[5] = v31;
  v32 = v5[1];
  v290[0] = *v5;
  v290[1] = v32;
  __sortSpotLightsOnZAxis((uint64_t)v290, v10, (_QWORD *)v347 + v25, (_QWORD *)v346 + v25, (__int16)v29, *(double *)v290);
  v33 = *((unsigned int *)v331 + 6);
  v278[0] = v11;
  v278[1] = 3221225472;
  v278[2] = ___Z19_addLightsInFrustumP19SCNMTLClusterSystem11scn_frustumhRKN13SCNMTLCluster7ContextEPNS_4InfoE_block_invoke_5;
  v278[3] = &unk_1EA5A1528;
  v34 = v5[3];
  v281 = v5[2];
  v282 = v34;
  v35 = v5[5];
  v283 = v5[4];
  v284 = v35;
  v36 = v5[1];
  v279 = *v5;
  v280 = v36;
  v286 = v273;
  v285 = &v330;
  v289 = v33;
  v287 = v346;
  v288 = v347;
  C3DLightingSystemEnumerateRadianceProbes((uint64_t)v8, (uint64_t)v278);
  v37 = *((_DWORD *)v331 + 6) - v33;
  v2[6].i64[1] = __PAIR64__(v37, v33);
  __sortProbesByVolume(v273, (_QWORD *)v347 + v33, (_QWORD *)v346 + v33, (__int16)v37);
  v38 = v225;
  RenderContext = C3DEngineContextGetRenderContext(v7);
  v231 = (void *)-[SCNMTLRenderContext resourceManager](RenderContext);
  v229 = RenderContext;
  CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(v7);
  if (v225)
  {
    v40 = (float32x4_t *)(v266 + 3088);
    v41 = v343;
    v42 = v344;
    v43 = (float *)v342;
    v44 = v225;
    do
    {
      v45 = v40[1];
      *v42 = *v40;
      v42[1] = v45;
      v46 = v40[3];
      v42[2] = v40[2];
      v42[3] = v46;
      v349 = *(simd_float4x4 *)v42->i8;
      v264 = (float32x4_t)v349.columns[1];
      v267 = (float32x4_t)v349.columns[2];
      v274 = *v42;
      v350 = __invert_f4(*(simd_float4x4 *)v42->f32);
      v47 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v267, (int32x4_t)v267), (int8x16_t)v267, 0xCuLL), vnegq_f32(v264)), v267, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v264, (int32x4_t)v264), (int8x16_t)v264, 0xCuLL));
      v48 = vmulq_f32(v274, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v47, v47), (int8x16_t)v47, 0xCuLL));
      v49 = vmulq_f32(v274, v274);
      v50 = vmulq_f32(v264, v264);
      v51 = vmulq_f32(v267, v267);
      v54 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1)));
      _NF = v54.f32[0] < 0.0;
      v54.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2), vaddq_f32(v49, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v49.f32, 1))).f32[0]);
      v49.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).f32[0]);
      v53 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).f32[0]);
      v54.i32[1] = v49.i32[0];
      if (_NF)
        v55 = -1.0;
      else
        v55 = 1.0;
      v54.f32[2] = v53;
      v56 = vabsq_f32(vmulq_n_f32(v54, v55));
      *v43++ = fmaxf(fmaxf(v56.f32[0], v56.f32[2]), v56.f32[1]);
      *(simd_float4x4 *)(v41 - 32) = v350;
      v41 += 64;
      v42 += 4;
      v40 += 4;
      --v44;
    }
    while (v44);
  }
  v57 = *((_DWORD *)v331 + 6);
  if (v57 <= 1)
    v57 = 1;
  v2[8].i32[2] = v57;
  SCNMTLBufferPool::allocate(v223, (v225 * (unint64_t)v57) << 8, v276);
  v2[7] = v276[0].columns[0];
  v2[8].i64[0] = v276[0].columns[1].i64[0];
  v58 = v331;
  if (*((_DWORD *)v331 + 6))
  {
    v59 = 0;
    v265 = 0;
    v275 = v2[7].i64[0];
    __asm { FMOV            V0.4S, #1.0 }
    v235 = DWORD2(_Q0);
    v260 = v2;
    do
    {
      if (v38)
      {
        v63 = 0;
        v64 = (uint64_t *)v2 + v265;
        v230 = (const void **)(v64 + 18);
        v233 = (void **)(v64 + 34);
        v234 = (float32x2_t **)(v64 + 26);
        v227 = v59;
        do
        {
          v65 = (__n128 *)*((_QWORD *)v346 + v265);
          v268 = (float32x4_t *)*((_QWORD *)v347 + v265);
          v66 = v265 * v225 + v63;
          v67 = v260[6].i64[1];
          if (v265 < v67 || v265 >= (v67 + HIDWORD(v260[6].i64[1])))
          {
            v261 = v275 + (v66 << 8);
            if (v65)
            {
              Type = C3DLightGetType((uint64_t)v65);
              C3DLightGetColorModulatedByIntensity((uint64_t)v65, v70, v71, v72, v73, v74, v75, v76);
              *(_QWORD *)&v78 = v77;
              DWORD2(v78) = v79;
              HIDWORD(v78) = *(_DWORD *)(v261 + 12);
              *(_OWORD *)v261 = v78;
              C3DLightGetShadowColor((uint64_t)v65);
              v81 = *(_OWORD *)v261;
              HIDWORD(v81) = vdupq_n_s64(v80).i32[3];
              *(_OWORD *)v261 = v81;
              WorldMatrix = C3DNodeGetWorldMatrix(v268);
              v83 = 0;
              v84 = (simd_float4)WorldMatrix[1];
              v85 = (simd_float4)WorldMatrix[2];
              v86 = (simd_float4)WorldMatrix[3];
              v87 = &v344[4 * v63];
              v88 = *v87;
              v89 = v87[1];
              v90 = v87[2];
              v91 = v87[3];
              v92 = v275 + 128 + ((unint64_t)v59 << 8);
              v335.columns[0] = (simd_float4)*WorldMatrix;
              v335.columns[1] = v84;
              v335.columns[2] = v85;
              v335.columns[3] = v86;
              do
              {
                v276[0].columns[v83] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v88, COERCE_FLOAT(*(_OWORD *)&v335.columns[v83])), v89, *(float32x2_t *)v335.columns[v83].f32, 1), v90, (float32x4_t)v335.columns[v83], 2), v91, (float32x4_t)v335.columns[v83], 3);
                ++v83;
              }
              while (v83 != 4);
              v247 = v276[0];
              v93 = v275 + (v66 << 8);
              v94 = (int32x4_t)vmulq_f32((float32x4_t)v276[0].columns[2], (float32x4_t)v276[0].columns[2]);
              v94.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v94, 2), vadd_f32(*(float32x2_t *)v94.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v94.i8, 1))).u32[0];
              v95 = vrsqrte_f32((float32x2_t)v94.u32[0]);
              v96 = vmul_f32(v95, vrsqrts_f32((float32x2_t)v94.u32[0], vmul_f32(v95, v95)));
              v97 = vmulq_n_f32((float32x4_t)v276[0].columns[2], vmul_f32(v96, vrsqrts_f32((float32x2_t)v94.u32[0], vmul_f32(v96, v96))).f32[0]);
              *(simd_float4 *)(v93 + 16) = v276[0].columns[3];
              *(float32x4_t *)(v93 + 32) = v97;
              *(float *)&v98 = C3DLightComputeDistanceAttenuations((float *)v65, 1, *(float *)&v342[v63]);
              *(_OWORD *)(v93 + 64) = v98;
              v99 = (float32x4_t *)(v93 + 64);
              if (Type == 6)
              {
                switch(v65[16].n128_u8[0])
                {
                  case 0u:
                    v99->i32[0] = v65[17].n128_i32[0];
                    break;
                  case 1u:
                  case 2u:
                    v124 = 1.0;
                    if ((v65[15].n128_u8[0] & 1) == 0)
                      v124 = 0.0;
                    v99->f32[2] = v124;
                    v99->i64[0] = v65[17].n128_i64[0];
                    break;
                  case 3u:
                    *v99 = (float32x4_t)v65[17];
                    break;
                  case 4u:
                    v125 = 1.0;
                    if ((v65[15].n128_u8[0] & 1) == 0)
                      v125 = 0.0;
                    v99->f32[1] = v125;
                    v99->i32[0] = v65[17].n128_u8[0];
                    break;
                  default:
                    break;
                }
                *(simd_float4x4 *)(v275 + (v66 << 8) + 192) = v247;
              }
              else if (Type == 3)
              {
                C3DLightComputeSpotAttenuations((uint64_t)v65);
                v99[1].i64[0] = v100;
              }
              v126 = (_BYTE *)(v275 + (v66 << 8));
              v126[52] = Type;
              v126[53] = C3DLightGetDistanceAttenuationType((uint64_t)v65);
              v126[54] = C3DLightGetEffectiveShadowSampleCount((uint64_t)v65);
              v245 = v126 + 54;
              if (v265 <= 7)
              {
                if (C3DLightGetCastsShadow((uint64_t)v65)
                  && C3DLightTypeSupportsShadow((uint64_t)v65))
                {
                  v127 = C3DLightGetUsesDeferredShadows((uint64_t)v65) ^ 1;
                }
                else
                {
                  v127 = 0;
                }
                HasValidGobo = C3DLightHasValidGobo((uint64_t)v65);
                HasValidIES = C3DLightHasValidIES((uint64_t)v65);
                if (v127)
                {
                  ShadowMapNameForNode = (__CFString *)C3DLightingSystemGetShadowMapNameForNode(v237, v268);
                  if (!ShadowMapNameForNode)
                  {
                    v226 = scn_default_log();
                    if (os_log_type_enabled(v226, OS_LOG_TYPE_FAULT))
                      _addLightsInFrustum(v336, &v337, v226);
                  }
                  *v230 = C3DEngineContextGetTextureWithName(v232, ShadowMapNameForNode);
                  ActiveShadowCasterIndex = C3DLightingSystemGetActiveShadowCasterIndex(v237, v268);
                  if (ActiveShadowCasterIndex)
                  {
                    ActiveShadowCasterData = C3DLightingSystemGetActiveShadowCasterData(v237, ActiveShadowCasterIndex);
                    v138 = ActiveShadowCasterData;
                    v139 = *(__n128 *)(ActiveShadowCasterData + 64);
                    v140 = *(__n128 *)(ActiveShadowCasterData + 80);
                    v141 = *(__n128 *)(ActiveShadowCasterData + 96);
                    v142 = *(__n128 *)(ActiveShadowCasterData + 112);
                    if (Type == 2)
                    {
                      v143 = 0;
                      v144 = (simd_float4 *)&v342[16 * v63 + 6];
                      v145 = v144[1];
                      v146 = v144[2];
                      v147 = v144[3];
                      v335.columns[0] = *v144;
                      v335.columns[1] = v145;
                      v335.columns[2] = v146;
                      v335.columns[3] = v147;
                      do
                      {
                        v276[0].columns[v143] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v139, COERCE_FLOAT(*(_OWORD *)&v335.columns[v143])), (float32x4_t)v140, *(float32x2_t *)v335.columns[v143].f32, 1), (float32x4_t)v141, (float32x4_t)v335.columns[v143], 2), (float32x4_t)v142, (float32x4_t)v335.columns[v143], 3);
                        ++v143;
                      }
                      while (v143 != 4);
                      v148 = 0;
                      v149 = v276[0].columns[0];
                      v150 = v276[0].columns[1];
                      v151 = v276[0].columns[2];
                      v152 = v276[0].columns[3];
                      v153 = (simd_float4 *)(v275 + (v66 << 8));
                      v153[12] = v276[0].columns[0];
                      v153[13] = v150;
                      v154 = v153 + 12;
                      v154[2] = v151;
                      v154[3] = v152;
                      v335.columns[0] = v149;
                      v335.columns[1] = v150;
                      v335.columns[2] = v151;
                      v335.columns[3] = v152;
                      do
                      {
                        v276[0].columns[v148] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1DD007970, COERCE_FLOAT(*(_OWORD *)&v335.columns[v148])), (float32x4_t)xmmword_1DD007920, *(float32x2_t *)v335.columns[v148].f32, 1), (float32x4_t)xmmword_1DD007960, (float32x4_t)v335.columns[v148], 2), (float32x4_t)xmmword_1DD007610, (float32x4_t)v335.columns[v148], 3);
                        ++v148;
                      }
                      while (v148 != 4);
                      v155 = v276[0].columns[1];
                      v156 = v276[0].columns[2];
                      v157 = v276[0].columns[3];
                      *v154 = v276[0].columns[0];
                      v154[1] = v155;
                      v154[2] = v156;
                      v154[3] = v157;
                      v99[1] = *(float32x4_t *)(ActiveShadowCasterData + 192);
                    }
                    else
                    {
                      *(double *)&v158 = _computeShadowMatrix(CoordinatesSystemOptions, v139, v140, v141, v142, *(__n128 *)(ActiveShadowCasterData + 128), *(__n128 *)(ActiveShadowCasterData + 144), *(__n128 *)(ActiveShadowCasterData + 160), *(__n128 *)(ActiveShadowCasterData + 176), v131, v132, v133, v134, v135, v136, v137, *(__n128 *)&v342[16 * v63 + 6], *(__n128 *)&v342[16 * v63 + 10], *(__n128 *)&v342[16 * v63 + 14],
                                           *(__n128 *)&v343[64 * v63 + 16]);
                      v159 = (_OWORD *)(v275 + (v66 << 8));
                      v159[12] = v158;
                      v159[13] = v160;
                      v159[14] = v161;
                      v159[15] = v162;
                      if (Type == 1)
                      {
                        ShadowCascadeCount = C3DLightGetShadowCascadeCount((uint64_t)v65);
                        if (ShadowCascadeCount)
                        {
                          v164 = ShadowCascadeCount;
                          v165 = (__int128 *)(v138 + 208);
                          do
                          {
                            v166 = *(v165 - 1);
                            HIDWORD(v166) = *(_DWORD *)(v92 - 52);
                            *(_OWORD *)(v92 - 64) = v166;
                            v167 = *v165;
                            HIDWORD(v167) = *(_DWORD *)(v92 + 12);
                            *(_OWORD *)v92 = v167;
                            v92 += 16;
                            v165 += 24;
                            --v164;
                          }
                          while (v164);
                        }
                      }
                    }
                  }
                  if (*v245 >= 2u)
                  {
                    RealShadowMapSize = C3DLightGetRealShadowMapSize((uint64_t)v65);
                    ShadowRadius = C3DLightGetShadowRadius((uint64_t)v65);
                    v169 = RealShadowMapSize.i32[1];
                    if (*(float *)RealShadowMapSize.i32 >= *(float *)&RealShadowMapSize.i32[1])
                      v169 = RealShadowMapSize.i32[0];
                    *(float *)(v275 + (v66 << 8) + 48) = ShadowRadius / fmaxf(*(float *)&v169, 1.0);
                  }
                  ShadowCascadeDebugFactor = C3DLightGetShadowCascadeDebugFactor((uint64_t)v65);
                  if (ShadowCascadeDebugFactor != 0.0)
                    *(float *)(v261 + 12) = ShadowCascadeDebugFactor;
                }
                if (HasValidIES)
                {
                  *(float *)v171.i32 = (float)(180.0 / C3DLightGetIESSpotAngle((uint64_t)v65)) * 0.5;
                  *(int32x2_t *)v99[1].f32 = vdup_lane_s32(v171, 0);
                  v352 = __invert_f4(v247);
                  v352.columns[3] = (simd_float4)vmulq_f32((float32x4_t)v352.columns[0], (float32x4_t)v352.columns[0]);
                  v352.columns[3].i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v352.columns[3], 2), vadd_f32(*(float32x2_t *)v352.columns[3].f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v352.columns[3].f32, 1))).u32[0];
                  v172 = vrsqrte_f32((float32x2_t)v352.columns[3].u32[0]);
                  v173 = vmul_f32(v172, vrsqrts_f32((float32x2_t)v352.columns[3].u32[0], vmul_f32(v172, v172)));
                  v174 = vmulq_n_f32((float32x4_t)v352.columns[0], vmul_f32(v173, vrsqrts_f32((float32x2_t)v352.columns[3].u32[0], vmul_f32(v173, v173))).f32[0]);
                  v352.columns[3] = (simd_float4)vmulq_f32((float32x4_t)v352.columns[1], (float32x4_t)v352.columns[1]);
                  v352.columns[3].i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v352.columns[3], 2), vadd_f32(*(float32x2_t *)v352.columns[3].f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v352.columns[3].f32, 1))).u32[0];
                  v175 = vrsqrte_f32((float32x2_t)v352.columns[3].u32[0]);
                  v176 = vmul_f32(v175, vrsqrts_f32((float32x2_t)v352.columns[3].u32[0], vmul_f32(v175, v175)));
                  v177 = vmulq_n_f32((float32x4_t)v352.columns[1], vmul_f32(v176, vrsqrts_f32((float32x2_t)v352.columns[3].u32[0], vmul_f32(v176, v176))).f32[0]);
                  v178 = (int32x4_t)vmulq_f32((float32x4_t)v352.columns[2], (float32x4_t)v352.columns[2]);
                  v178.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v178, 2), vadd_f32(*(float32x2_t *)v178.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v178.i8, 1))).u32[0];
                  v179 = vrsqrte_f32((float32x2_t)v178.u32[0]);
                  v180 = vmul_f32(v179, vrsqrts_f32((float32x2_t)v178.u32[0], vmul_f32(v179, v179)));
                  v181 = vmulq_n_f32((float32x4_t)v352.columns[2], vmul_f32(v180, vrsqrts_f32((float32x2_t)v178.u32[0], vmul_f32(v180, v180))).f32[0]);
                  v182 = (float)(v174.f32[0] + v177.f32[1]) + v181.f32[2];
                  if (v182 <= 0.0)
                  {
                    if (v174.f32[0] <= v177.f32[1] || v174.f32[0] <= v181.f32[2])
                    {
                      if (v177.f32[1] <= v181.f32[2])
                      {
                        v213.i64[0] = v181.i64[0];
                        v213.f32[2] = (float)(v181.f32[2] + 1.0) - v174.f32[0];
                        v213.i32[3] = v174.i32[1];
                        v185 = (float32x4_t)vrev64q_s32((int32x4_t)vextq_s8((int8x16_t)vtrn1q_s32((int32x4_t)v177, (int32x4_t)v174), (int8x16_t)v177, 8uLL));
                        v184.i64[0] = vaddq_f32(v181, v185).u64[0];
                        v184.i64[1] = vsubq_f32(v213, v185).i64[1];
                        v185.i32[0] = v184.i32[2];
                      }
                      else
                      {
                        v199 = v177;
                        v199.f32[1] = (float)(v177.f32[1] + 1.0) - v174.f32[0];
                        v199.i32[3] = v181.i32[0];
                        v200 = (float32x4_t)vzip2q_s32(vzip1q_s32((int32x4_t)v174, (int32x4_t)v181), vtrn1q_s32((int32x4_t)v181, (int32x4_t)v174));
                        v201 = (int32x4_t)vaddq_f32(v177, v200);
                        v185 = vsubq_f32(v199, v200);
                        v184 = (float32x4_t)vtrn2q_s32(vrev64q_s32(v201), (int32x4_t)v185);
                        v185.i32[0] = v185.i32[1];
                      }
                    }
                    else
                    {
                      v202 = (float)(v174.f32[0] + 1.0) - v177.f32[1];
                      v203 = (float32x4_t)vextq_s8((int8x16_t)v177, (int8x16_t)vtrn1q_s32((int32x4_t)v177, (int32x4_t)v181), 0xCuLL);
                      v184 = vaddq_f32(v203, v174);
                      v203.f32[0] = v202;
                      v174.i32[0] = v181.i32[2];
                      v174.i32[3] = v181.i32[1];
                      v185 = vsubq_f32(v203, v174);
                      v184.i32[0] = v185.i32[0];
                      v184.i32[3] = v185.i32[3];
                    }
                  }
                  else
                  {
                    v183 = (float32x4_t)vzip2q_s32((int32x4_t)v177, vuzp1q_s32((int32x4_t)v177, (int32x4_t)v181));
                    v183.i32[2] = v174.i32[1];
                    v185 = (float32x4_t)vtrn2q_s32((int32x4_t)v181, vzip2q_s32((int32x4_t)v181, (int32x4_t)v174));
                    v185.i32[2] = v177.i32[0];
                    v184 = vsubq_f32(v183, v185);
                    v185.i32[3] = 1.0;
                    v183.f32[3] = v182;
                    v184.i32[3] = vaddq_f32(v183, v185).i32[3];
                    v185.i32[0] = v184.i32[3];
                  }
                  v99[2] = vmulq_n_f32(v184, 0.5 / sqrtf(v185.f32[0]));
                  *v234 = (float32x2_t *)objc_msgSend(v231, "iesTextureForProfile:renderContext:", C3DLightGetIESProfileURL((uint64_t)v65), v229);
                  *v233 = 0;
                }
                else if (HasValidGobo)
                {
                  v277 = 0;
                  *v234 = C3DEngineContextGetTextureForEffectSlot(v232, v65[12].n128_i64[1], (const void **)&v277);
                  *v233 = -[SCNMTLResourceManager renderResourceForSampler:]((uint64_t)v231, v277);
                  C3DLightGetProjectionInfo((uint64_t)v65, (uint64_t)v276);
                  Matrix = C3DProjectionInfosGetMatrix((char *)v276, 0, CoordinatesSystemOptions);
                  v271 = *((float32x4_t *)Matrix + 1);
                  v243 = *((float32x4_t *)Matrix + 2);
                  v246 = *(float32x4_t *)Matrix;
                  v239 = *((float32x4_t *)Matrix + 3);
                  v353 = __invert_f4(v247);
                  v187 = 0;
                  v334 = v353;
                  do
                  {
                    v335.columns[v187] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v246, COERCE_FLOAT(*(_OWORD *)&v334.columns[v187])), v271, *(float32x2_t *)v334.columns[v187].f32, 1), v243, (float32x4_t)v334.columns[v187], 2), v239, (float32x4_t)v334.columns[v187], 3);
                    ++v187;
                  }
                  while (v187 != 4);
                  v272 = v335.columns[0];
                  v252 = v335.columns[2];
                  v254 = v335.columns[1];
                  v250 = v335.columns[3];
                  if (C3DKeyframeControllerHasInterpolationModesPerKey(v65[12].n128_i64[1]))
                  {
                    ImageTransform = (float32x4_t *)C3DEffectSlotGetImageTransform(v65[12].n128_i64[1]);
                    v189 = 0;
                    v190 = *ImageTransform;
                    v191 = ImageTransform[1];
                    v192 = ImageTransform[2];
                    v193 = ImageTransform[3];
                    v334.columns[0] = v272;
                    v334.columns[1] = v254;
                    v334.columns[2] = v252;
                    v334.columns[3] = v250;
                    do
                    {
                      v335.columns[v189] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v190, COERCE_FLOAT(*(_OWORD *)&v334.columns[v189])), v191, *(float32x2_t *)v334.columns[v189].f32, 1), v192, (float32x4_t)v334.columns[v189], 2), v193, (float32x4_t)v334.columns[v189], 3);
                      ++v189;
                    }
                    while (v189 != 4);
                    v194 = v335.columns[0];
                    v195 = v335.columns[1];
                    v196 = v335.columns[2];
                    v197 = v335.columns[3];
                  }
                  else
                  {
                    v194 = v272;
                    v196 = v252;
                    v195 = v254;
                    v197 = v250;
                  }
                  v204 = 0;
                  v205 = *(float32x4_t *)MEMORY[0x1E0C83FF0];
                  v206 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 16);
                  v205.i32[0] = 0.5;
                  v207 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 32);
                  v206.i32[1] = -0.5;
                  v207.i32[2] = 1.0;
                  v208.i64[0] = 0x3F0000003F000000;
                  v208.i64[1] = *(_QWORD *)(MEMORY[0x1E0C83FF0] + 56);
                  v334.columns[0] = v194;
                  v334.columns[1] = v195;
                  v334.columns[2] = v196;
                  v334.columns[3] = v197;
                  do
                  {
                    v335.columns[v204] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v205, COERCE_FLOAT(*(_OWORD *)&v334.columns[v204])), v206, *(float32x2_t *)v334.columns[v204].f32, 1), v207, (float32x4_t)v334.columns[v204], 2), v208, (float32x4_t)v334.columns[v204], 3);
                    ++v204;
                  }
                  while (v204 != 4);
                  v209 = v335.columns[1];
                  v210 = v335.columns[2];
                  v211 = v335.columns[3];
                  v212 = (simd_float4 *)(v275 + (v66 << 8));
                  v212[12] = v335.columns[0];
                  v212[13] = v209;
                  v212[14] = v210;
                  v212[15] = v211;
                  *(float *)(v261 + 12) = C3DEffectSlotGetIntensity(v65[12].n128_i64[1]);
                }
              }
            }
            else
            {
              *(__n128 *)v261 = v345[v265];
              v105 = (float32x4_t)v236[(v265 - v224)];
              v104 = v275 + (v66 << 8);
              *(float32x4_t *)(v104 + 16) = vaddq_f32(v344[4 * v63 + 3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v344[4 * v63], v105.f32[0]), v344[4 * v63 + 1], *(float32x2_t *)v105.f32, 1), v344[4 * v63 + 2], v105, 2));
              v105.i32[0] = v105.i32[3];
              if (v105.f32[3] <= 0.01)
                v105.f32[0] = INFINITY;
              DWORD2(v106) = v235;
              *(float *)&v106 = -1.0 / v105.f32[3];
              *((float *)&v106 + 1) = (float)((float)(-1.0 / v105.f32[3]) * -0.0) + 1.0;
              *((float *)&v106 + 3) = 1.0 / (float)(v105.f32[0] * v105.f32[0]);
              *(_OWORD *)(v104 + 64) = v106;
            }
          }
          else
          {
            *(_BYTE *)(v275 + (v66 << 8) + 52) = 4;
            if (v65)
            {
              if (C3DLightGetType((uint64_t)v65) != 4)
              {
                v101 = scn_default_log();
                if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT))
                  _addLightsInFrustum(v340, &v341, v101);
              }
              ProbeEnvironment = C3DLightGetProbeEnvironment((uint64_t)v65, 0);
              if (ProbeEnvironment)
                Intensity = C3DEffectSlotGetIntensity(ProbeEnvironment);
              else
                Intensity = 1.0;
              *(float *)(v275 + (v66 << 8)) = (float)(Intensity * C3DLightGetIntensity((uint64_t)v65)) / 1000.0;
              RadianceProbeIndex = C3DLightGetRadianceProbeIndex((uint64_t)v65);
              v108 = v275 + (v66 << 8);
              *(_DWORD *)(v108 + 128) = RadianceProbeIndex;
              if (RadianceProbeIndex < 0)
              {
                v109 = scn_default_log();
                if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT))
                  _addLightsInFrustum(v338, &v339, v109);
              }
              *(__n128 *)(v108 + 64) = C3DLightGetProbeOffset(v65);
              ProbeExtents = C3DLightGetProbeExtents(v65);
              v111.i64[0] = 0x3F0000003F000000;
              v111.i64[1] = 0x3F0000003F000000;
              v262 = vmulq_f32((float32x4_t)ProbeExtents, v111);
              v112 = v262;
              v112.f32[3] = fmaxf(fmaxf(v262.f32[0], v262.f32[2]), v262.f32[1]) * 0.1;
              *(float32x4_t *)(v108 + 80) = v112;
              *(_DWORD *)(v108 + 132) = C3DLightGetParallaxCorrectionEnabled((uint64_t)v65);
              v113 = vmulq_f32(v262, (float32x4_t)C3DLightGetParallaxCenterOffset(v65));
              *(_DWORD *)(v108 + 104) = v113.i32[2];
              *(_QWORD *)(v108 + 96) = v113.i64[0];
              v114 = vmulq_f32(v262, (float32x4_t)C3DLightGetParallaxExtentsFactor(v65));
              *(_DWORD *)(v108 + 120) = v114.i32[2];
              *(_QWORD *)(v108 + 112) = v114.i64[0];
              v115 = C3DNodeGetWorldMatrix(v268);
              v256 = (simd_float4)v115[1];
              v257 = *(simd_float4 *)v115;
              v251 = (simd_float4)v115[3];
              v253 = (simd_float4)v115[2];
              *(simd_float4 *)(v275 + (v66 << 8) + 16) = v251;
              v116 = &v344[4 * v63];
              v269 = *v116;
              v263 = v116[1];
              v258 = v116[3];
              v259 = v116[2];
              v117 = C3DSceneComputeWorldToCubemapMatrix(Scene);
              v241 = v119;
              v244 = v118;
              v248 = v120;
              v249 = (float32x4_t)v117;
              v121 = 0;
              v335.columns[0] = v257;
              v335.columns[1] = v256;
              v335.columns[2] = v253;
              v335.columns[3] = v251;
              do
              {
                v276[0].columns[v121] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v269, COERCE_FLOAT(*(_OWORD *)&v335.columns[v121])), v263, *(float32x2_t *)v335.columns[v121].f32, 1), v259, (float32x4_t)v335.columns[v121], 2), v258, (float32x4_t)v335.columns[v121], 3);
                ++v121;
              }
              while (v121 != 4);
              v351 = __invert_f4(v276[0]);
              v122 = 0;
              v335 = v351;
              do
              {
                v276[0].columns[v122] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v249, COERCE_FLOAT(*(_OWORD *)&v335.columns[v122])), v248, *(float32x2_t *)v335.columns[v122].f32, 1), v244, (float32x4_t)v335.columns[v122], 2), v241, (float32x4_t)v335.columns[v122], 3);
                ++v122;
              }
              while (v122 != 4);
              v255 = v276[0];
            }
            v123 = (_OWORD *)(v275 + (v66 << 8));
            v123[12] = v255.columns[0];
            v123[13] = v255.columns[1];
            v123[14] = v255.columns[2];
            v123[15] = v255.columns[3];
          }
          ++v63;
          ++v59;
        }
        while (v63 != v225);
        v58 = v331;
        v2 = v260;
        v38 = v225;
        v59 = v227;
      }
      v59 += v38;
      ++v265;
    }
    while (v265 < *((unsigned int *)v58 + 6));
  }
  v214 = v224;
  if (!(_DWORD)v224)
    goto LABEL_121;
  v215 = 0;
  v216 = (uint64_t *)v346;
  v217 = v224;
  do
  {
    v218 = *v216;
    if (C3DLightGetType(*v216) == 6 && *(_BYTE *)(v218 + 256) == 4)
      v215 += 8 * *(unsigned __int8 *)(v218 + 272);
    ++v216;
    --v217;
  }
  while (v217);
  if (v215)
  {
    memset(v276, 0, 24);
    SCNMTLBufferPool::allocate(v223, v215, v276);
    v219 = v2 + 22;
    v220 = (uint64_t *)v346;
    do
    {
      v221 = *v220;
      if (C3DLightGetType(*v220) == 6 && *(_BYTE *)(v221 + 256) == 4)
        memcpy((void *)(v276[0].columns[0].i64[0] + v219->i64[0]), *(const void **)(v221 + 280), 8 * *(unsigned __int8 *)(v221 + 272));
      ++v220;
      v219 = (simd_float4 *)((char *)v219 + 8);
      --v214;
    }
    while (v214);
    v222 = v276[0].columns[1].i64[0];
    v2[21].i64[0] = v276[0].columns[0].i64[1];
    v2[21].i64[1] = v222;
  }
  else
  {
LABEL_121:
    v2[21].i64[0] = 0;
  }
  _Block_object_dispose(&v330, 8);
}

void sub_1DCD0BAC0(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x6A0], 8);
  _Unwind_Resume(a1);
}

void C3D::DrawNodesPass::setup(C3D::DrawNodesPass *this)
{
  uint64_t RenderContext;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  C3D::RenderGraphResourceManager *v6;
  uint64_t v7;
  _OWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  char PreferredMultiVertexOutputStreamGenerator;
  uint64_t Scene;
  __n128 v23;
  unint64_t v24;
  uint64_t v25;
  float32x4_t **v26;
  float32x4_t **v27;
  unint64_t v28;
  float32x4_t *v29;
  _QWORD *ParticleManager;
  uint64_t Stats;
  double v32;
  uint64_t LightingSystem;
  unsigned int v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  __int128 v38;
  int v39;

  RenderContext = C3DEngineContextGetRenderContext(*((_QWORD *)this + 2));
  if (-[SCNMTLRenderContext disableLinearRendering](RenderContext))
    *((_WORD *)this + 149) |= 1u;
  v3 = (*(uint64_t (**)(C3D::DrawNodesPass *))(*(_QWORD *)this + 64))(this);
  v4 = 0xC6A4A7935BD1E995
     * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * (v3 ^ 0xD2066E14D2E75C53)) ^ 0x73)) ^ ((0xC6A4A7935BD1E995
                                                                                                 * ((0xC6A4A7935BD1E995 * (v3 ^ 0xD2066E14D2E75C53)) ^ 0x73)) >> 47));
  v5 = v4 ^ (v4 >> 47);
  v6 = *(C3D::RenderGraphResourceManager **)(*((_QWORD *)this + 3) + 128);
  v7 = C3D::RenderGraphResourceManager::get(v6, v5);
  *((_QWORD *)this + 668) = v7;
  if (!v7)
  {
    v8 = (_OWORD *)operator new();
    *v8 = 0u;
    v8[1] = 0u;
    v8[2] = 0u;
    v8[3] = 0u;
    v8[4] = 0u;
    v8[5] = 0u;
    v8[6] = 0u;
    v8[7] = 0u;
    v8[8] = 0u;
    v8[9] = 0u;
    v8[10] = 0u;
    v8[11] = 0u;
    v8[12] = 0u;
    v8[13] = 0u;
    v8[14] = 0u;
    v8[15] = 0u;
    v8[16] = 0u;
    v8[17] = 0u;
    v8[18] = 0u;
    v8[19] = 0u;
    v8[20] = 0u;
    v8[21] = 0u;
    v8[22] = 0u;
    v8[23] = 0u;
    v8[24] = 0u;
    *(_QWORD *)v8 = &off_1EA599F48;
    *((_QWORD *)this + 668) = v8;
    C3D::RenderGraphResourceManager::set((uint64_t)v6, v5, (uint64_t)v8);
  }
  if (!C3D::PassDescriptor::outputCount((C3D::DrawNodesPass *)((char *)this + 32)))
  {
    C3D::Pass::setOutputCount(this, 2u);
    v9 = C3D::PassDescriptor::outputAtIndex((C3D::DrawNodesPass *)((char *)this + 32), 0);
    *(_QWORD *)(v9 + 8) = "COLOR";
    C3D::Pass::parentColorDesc(this, (uint64_t)&v38);
    *(_OWORD *)(v9 + 16) = v38;
    *(_DWORD *)(v9 + 32) = v39;
    *(_BYTE *)(v9 + 65) = 0;
    *(_WORD *)(v9 + 66) = *(_WORD *)(v9 + 66) & 0xFFFC | 2;
    v10 = C3D::PassDescriptor::outputAtIndex((C3D::DrawNodesPass *)((char *)this + 32), 1u);
    *(_BYTE *)(v10 + 64) = 2;
    *(_QWORD *)(v10 + 8) = "DEPTH";
    C3D::Pass::parentDepthDesc(this, (uint64_t)&v38);
    *(_OWORD *)(v10 + 16) = v38;
    *(_DWORD *)(v10 + 32) = v39;
    *(_WORD *)(v10 + 66) = *(_WORD *)(v10 + 66) & 0xFFF4 | 0xA;
  }
  v11 = C3D::PassDescriptor::outputAtIndex((C3D::DrawNodesPass *)((char *)this + 32), 0);
  if (*(unsigned __int8 *)(v11 + 64) - 1 >= 2)
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      C3D::DrawNodesPass::setup(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  if (SCNMTLTextureTypeIsCube(*(unsigned __int8 *)(v11 + 24)))
  {
    *((_BYTE *)this + 302) = 1;
    v20 = -[SCNMTLRenderContext features](RenderContext);
    *((_BYTE *)this + 117) = (v20 & 0x20) != 0;
    if ((v20 & 0x20) != 0)
      PreferredMultiVertexOutputStreamGenerator = C3DEngineContextGetPreferredMultiVertexOutputStreamGenerator(*((_QWORD *)this + 2));
    else
      PreferredMultiVertexOutputStreamGenerator = 0;
    *((_BYTE *)this + 118) = PreferredMultiVertexOutputStreamGenerator;
    *((_WORD *)this + 19) = 6;
  }
  Scene = C3DEngineContextGetScene(*((_QWORD *)this + 2));
  v23 = C3D::DrawNodesPass::_setupCullingContext((__n128 *)this);
  v24 = *((_QWORD *)this + 34);
  if (v24)
  {
    v25 = *(unsigned int *)(v24 + 8);
    if ((_DWORD)v25)
    {
      v26 = *(float32x4_t ***)(v24 + 16);
      v27 = &v26[v25];
      LODWORD(v24) = *((unsigned __int16 *)this + 19);
      do
      {
        if ((_DWORD)v24)
        {
          v28 = 0;
          v29 = *v26;
          do
          {
            if ((*(unsigned int (**)(C3D::DrawNodesPass *, float32x4_t *, unint64_t, __n128))(*(_QWORD *)this + 120))(this, v29, v28, v23))
            {
              C3DCullingContextForcePushGeometryRenderableElementsToVisible((float32x4_t *)this + 20, v28, v29);
            }
            ++v28;
            v24 = *((unsigned __int16 *)this + 19);
          }
          while (v28 < v24);
        }
        ++v26;
      }
      while (v26 != v27);
    }
  }
  else
  {
    C3DCullingContextCull((uint64_t)this + 320);
    ParticleManager = C3DSceneGetParticleManager(Scene, 0);
    if ((*(_BYTE *)(C3D::Pass::descriptor(this) + 12) & 1) != 0)
    {
      Stats = C3DEngineContextGetStats(*((_QWORD *)this + 2));
      v32 = CACurrentMediaTime();
      LightingSystem = C3DSceneGetLightingSystem(Scene);
      v34 = *((unsigned __int16 *)this + 19);
      if (*((_WORD *)this + 19))
      {
        v35 = LightingSystem;
        v36 = 0;
        v37 = (char *)this + 3408;
        do
        {
          if (ParticleManager)
          {
            C3DLightingSystemBeginQueries(v35, (uint64_t)v37, *((_QWORD *)this + 2));
            C3DParticleManagerCull((uint64_t)ParticleManager, (uint64_t)this + 320, *((_QWORD *)this + 2), v36, *((unsigned __int8 *)this + 117), *((unsigned __int8 *)this + 118));
            C3DLightingSystemEndQueries(v35);
            v34 = *((unsigned __int16 *)this + 19);
          }
          ++v36;
          v37 += 64;
        }
        while (v36 < v34);
      }
      *(double *)(Stats + 120) = *(double *)(Stats + 120) + CACurrentMediaTime() - v32;
    }
  }
}

uint64_t C3D::RenderGraphResourceManager::set(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v4;

  v4 = a3;
  C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::insert(a1, a2, &v4);
  result = v4;
  v4 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1DCD0BF9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

uint64_t C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::insert(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;
  __int16 *v13;
  uint64_t v14;
  __int16 v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  char v20;
  int v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t result;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  while (1)
  {
    v6 = *(_DWORD *)(a1 + 28);
    v7 = (v6 - 1) & a2;
    v8 = *(_QWORD *)(a1 + 16);
    v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2)
      break;
LABEL_6:
    v12 = v6 + 15;
    if (v12 >= (int)v7 + 496)
      v12 = v7 + 496;
    if (v7 >= v12)
    {
      LODWORD(v14) = v7;
    }
    else
    {
      v13 = (__int16 *)(v8 + 2 * v7);
      LODWORD(v14) = v7;
      while (1)
      {
        v15 = *v13++;
        if ((v15 & 1) == 0)
          break;
        LODWORD(v14) = v14 + 1;
        if (v12 == (_DWORD)v14)
          goto LABEL_34;
      }
    }
    if ((_DWORD)v14 != v12)
    {
      *(_WORD *)(v8 + 2 * v14) |= 1u;
      if (v14 <= (int)v7 + 14)
      {
        v32 = v14;
LABEL_37:
        v33 = *(_QWORD *)(a1 + 8);
        v34 = *a3;
        *a3 = 0;
        *(_QWORD *)(v33 + 8 * v32) = v34;
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v32) = a2;
        v35 = *(_QWORD *)(a1 + 16);
        *(_WORD *)(v35 + 2 * v32) |= 1u;
        result = 1;
        *(_WORD *)(v35 + 2 * v7) |= 1 << (v14 - v7 + 1);
        ++*(_DWORD *)(a1 + 24);
        return result;
      }
      while (1)
      {
        v16 = v14;
        v17 = v14 - 14;
        if (v14 < 0xF)
          v17 = 0;
        v18 = v17 - 1;
        v19 = v17 <= v14 ? v14 : v17;
        v20 = 1;
        while (1)
        {
          v14 = v18 + 1;
          if (v17 <= v14)
            break;
LABEL_26:
          ++v20;
          v18 = v14;
          if ((_DWORD)v14 == v19)
            goto LABEL_33;
        }
        v21 = 1 << (v18 - v17 + 2);
        v22 = v20;
        v23 = v17;
        while (1)
        {
          v24 = v23;
          if (((unsigned __int16)v21 & *(_WORD *)(v8 + 2 * v23)) != 0)
            break;
          ++v23;
          LOWORD(v21) = (unsigned __int16)v21 >> 1;
          --v22;
          if ((int)v24 + 1 > v14)
            goto LABEL_26;
        }
        if (v14 >= v16)
          break;
        v25 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v16) = *(_QWORD *)(*(_QWORD *)a1 + 8 * v14);
        v26 = *(_QWORD *)(v25 + 8 * v14);
        *(_QWORD *)(v25 + 8 * v14) = 0;
        *(_QWORD *)(v25 + 8 * v16) = v26;
        v27 = *(_QWORD *)(a1 + 8);
        v28 = *(_QWORD *)(v27 + 8 * v14);
        *(_QWORD *)(v27 + 8 * v14) = 0;
        if (v28)
          (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
        v8 = *(_QWORD *)(a1 + 16);
        *(_WORD *)(v8 + 2 * v24) = (*(_WORD *)(v8 + 2 * v24) | (1 << (v16 - v24 + 1))) ^ (1 << v22);
        if (v14 <= (int)v7 + 14)
        {
          v32 = v14;
          goto LABEL_37;
        }
      }
LABEL_33:
      *(_WORD *)(v8 + 2 * v16) ^= 1u;
    }
LABEL_34:
    C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_grow(a1);
  }
  v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(_QWORD *)(*(_QWORD *)a1 + 8 * v10) != a2)
  {
    ++v10;
    v11 = v9 > 3;
    v9 >>= 1;
    if (!v11)
      goto LABEL_6;
  }
  v29 = *(_QWORD *)(a1 + 8);
  v30 = *a3;
  *a3 = 0;
  result = *(_QWORD *)(v29 + 8 * v10);
  *(_QWORD *)(v29 + 8 * v10) = v30;
  if (result)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    return 0;
  }
  return result;
}

_QWORD *C3DSceneGetParticleManager(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *result;
  BOOL v13;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(_QWORD **)(a1 + 88);
  if (result)
    v13 = 1;
  else
    v13 = a2 == 0;
  if (!v13)
  {
    result = C3DParticleManagerCreate(a1);
    *(_QWORD *)(a1 + 88) = result;
  }
  return result;
}

void C3D::DrawNodesPass::execute(uint64_t *a1, uint64_t a2)
{
  uint64_t Scene;
  const void *RootNode;
  uint64_t RenderContext;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  _OWORD *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  float32x2_t TAAJitter;
  float32x2_t v24;
  int8x16_t *v25;
  int8x16_t v26;
  int8x16_t v27;

  Scene = C3DEngineContextGetScene(a1[2]);
  RootNode = (const void *)C3DSceneGetRootNode(Scene);
  CFRetain(RootNode);
  RenderContext = C3DEngineContextGetRenderContext(a1[2]);
  v7 = (*(uint64_t (**)(uint64_t *))(*a1 + 80))(a1);
  -[SCNMTLRenderContext setCurrentPassHash:](RenderContext, v7);
  -[SCNMTLRenderContext setCurrentPassMaterial:](RenderContext, a1[32]);
  if (!C3DSceneGetEnginePipeline(Scene))
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      C3DEngineContextRenderScene_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
  }
  C3DEngineContextSetMatrix4x4(a1[2], 0, (uint64_t)&a1[8 * (unint64_t)*(unsigned __int16 *)(a2 + 16) + 474]);
  C3DEngineContextSetMatrix4x4(a1[2], 1, (uint64_t)&a1[8 * (unint64_t)*(unsigned __int16 *)(a2 + 16) + 426]);
  C3D::DrawNodesPass::_renderEye((C3D::DrawNodesPass *)a1);
  if (*((_BYTE *)a1 + 4948))
  {
    v16 = 0;
    v17 = 0;
    v18 = a1 + 522;
    do
    {
      v19 = (_OWORD *)(a1[668] + v16 * 8);
      v20 = *(_OWORD *)&v18[v16];
      v21 = *(_OWORD *)&v18[v16 + 2];
      v22 = *(_OWORD *)&v18[v16 + 6];
      v19[3] = *(_OWORD *)&v18[v16 + 4];
      v19[4] = v22;
      v19[1] = v20;
      v19[2] = v21;
      if (C3DEngineContextIsTemporalAntialiasingEnabled(a1[2]))
      {
        TAAJitter = C3DEngineContextGetTAAJitter((float32x2_t *)a1[2], 0);
        v24 = C3DEngineContextGetTAAJitter((float32x2_t *)a1[2], 1);
        v25 = (int8x16_t *)(a1[668] + v16 * 8);
        v26 = v25[4];
        *(float32x2_t *)v27.i8 = vadd_f32(vsub_f32(v24, TAAJitter), *(float32x2_t *)v26.i8);
        v27.i64[1] = vextq_s8(v26, v26, 8uLL).u64[0];
        v25[4] = v27;
      }
      ++v17;
      v16 += 8;
    }
    while (v17 < *((unsigned __int8 *)a1 + 4948));
  }
  CFRelease(RootNode);
}

__n128 C3DEngineContextSetMatrix4x4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  __n128 result;
  __int128 v5;
  __int128 v6;

  v3 = a1 + 384 * a2;
  result = *(__n128 *)a3;
  v5 = *(_OWORD *)(a3 + 16);
  v6 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(v3 + 512) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v3 + 528) = v6;
  *(__n128 *)(v3 + 480) = result;
  *(_OWORD *)(v3 + 496) = v5;
  return result;
}

double C3D::DrawNodesPass::_renderEye(C3D::DrawNodesPass *this)
{
  unsigned __int8 v1;
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t Scene;
  uint64_t EnginePipeline;
  uint64_t RenderContext;
  C3D::PassDescriptor *v9;
  uint64_t BackgroundEffectSlot;
  uint64_t Stats;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  unsigned int *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  void *SortSystem;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  double v30;
  uint64_t v31;
  double result;
  _QWORD v33[5];
  char v34;
  char v35;
  _QWORD v36[3];
  char v37;
  unsigned __int8 v38;
  char v39;
  __int16 v40;
  _BYTE v41[5024];

  MEMORY[0x1E0C80A78](this);
  v2 = v1;
  v4 = v3;
  v5 = (char *)(v3 + 4948);
  Scene = C3DEngineContextGetScene(*(_QWORD *)(v3 + 16));
  EnginePipeline = C3DSceneGetEnginePipeline(Scene);
  RenderContext = C3DEngineContextGetRenderContext(*(_QWORD *)(v4 + 16));
  bzero(v36, 0x1410uLL);
  v36[0] = *(_QWORD *)(v4 + 240);
  v37 = *v5;
  v38 = v2;
  v39 = *(_BYTE *)(v4 + 302);
  v40 = *(_WORD *)(v4 + 117);
  memcpy(v41, (const void *)(v4 + 320), sizeof(v41));
  if (*(_BYTE *)(v4 + 303))
  {
    v9 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v4);
    if ((*(_WORD *)(C3D::PassDescriptor::outputAtIndex(v9, 0) + 66) & 0x40) == 0)
    {
      BackgroundEffectSlot = C3DSceneGetBackgroundEffectSlot(Scene, 0);
      if (BackgroundEffectSlot)
        C3DEngineContextRenderBackgroundMap(*(_QWORD *)(v4 + 16), BackgroundEffectSlot, (uint64_t)v36);
    }
  }
  Stats = C3DEngineContextGetStats(*(_QWORD *)(v4 + 16));
  if (v5[68])
    v12 = 0;
  else
    v12 = v2;
  v13 = v4 + 16 * v12;
  v14 = *(unsigned int *)(v13 + 5240);
  v15 = *(unsigned int **)(v13 + 5232);
  if (!v15)
  {
    v16 = scn_default_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
      C3D::DrawNodesPass::_renderEye(v16, v17, v18, v19, v20, v21, v22, v23);
  }
  v24 = CACurrentMediaTime();
  SortSystem = (void *)C3DEngineContextGetSortSystem(*(_QWORD *)(v4 + 16));
  v26 = *(_QWORD *)(v4 + 16);
  v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 80))(v4);
  C3DSortSystemSyncKeys((uint64_t)SortSystem, v26, v15, v14, v27);
  C3DSortSystemSort(SortSystem, *(_QWORD *)(v4 + 16), v15, v14);
  *(double *)(Stats + 152) = *(double *)(Stats + 152) + CACurrentMediaTime() - v24;
  if (C3DEngineContextGetMaxDrawingCommand(*(_QWORD *)(v4 + 16)))
  {
    v28 = C3DEngineContextGetStats(*(_QWORD *)(v4 + 16));
    v29 = C3DEngineContextGetMaxDrawingCommand(*(_QWORD *)(v4 + 16)) + ~*(_DWORD *)(v28 + 12);
    if (v14 >= v29)
      LODWORD(v14) = v29;
  }
  v30 = CACurrentMediaTime();
  v31 = *(_QWORD *)(v4 + 16);
  v33[0] = EnginePipeline;
  v33[1] = v31;
  v34 = *(_BYTE *)(v4 + 296);
  v35 = *(_BYTE *)(v4 + 301);
  v33[3] = v4;
  v33[4] = 0;
  v33[2] = v36;
  -[SCNMTLRenderContext processRendererElements:count:engineIterationContext:](RenderContext, (unint64_t)v15, v14, (uint64_t)v33);
  result = *(double *)(Stats + 152) + CACurrentMediaTime() - v30;
  *(double *)(Stats + 152) = result;
  return result;
}

uint64_t C3DEngineContextGetStats(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 1696);
}

uint64_t C3DSceneGetBackgroundEffectSlot(uint64_t a1, int a2)
{
  uint64_t v3;
  const void *v4;

  if (a2 && !*(_QWORD *)(a1 + 304))
  {
    v3 = C3DEffectSlotCreate(a1, 24);
    *(_QWORD *)(a1 + 304) = v3;
    v4 = (const void *)C3DTextureSamplerBilinearMipMapClampNoAnisotropy();
    C3DEffectSlotSetTextureSampler(v3, v4);
  }
  return *(_QWORD *)(a1 + 304);
}

uint64_t C3DEngineContextGetMaxDrawingCommand(uint64_t a1)
{
  return *(unsigned int *)(a1 + 456);
}

double __sortSpotLightsOnZAxis(uint64_t a1, float32x4_t *a2, _QWORD *a3, _QWORD *a4, int a5, double result)
{
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  float32x2_t v13;
  uint64_t v14;
  float *v15;
  int v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t *v19;
  uint64_t v25;
  float *v26;
  float32x4_t v27;
  float32x4_t v28;
  float v29;
  float32x4_t v30;
  float32x4_t v31;
  int32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  unsigned int v42;
  int32x4_t v43;
  float32x4_t v44;
  float v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  __int16 *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52[2];

  v52[1] = *MEMORY[0x1E0C80C00];
  if (a5)
  {
    *(double *)v12.i64 = MEMORY[0x1E0C80A78](a1);
    v15 = (float *)((char *)v52 - v14);
    if (v16 >= 1)
    {
      v17 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL);
      v18 = vnegq_f32(v12);
      v19 = a2 + 2;
      __asm { FMOV            V4.4S, #1.0 }
      v25 = v11;
      v26 = v15;
      do
      {
        v27 = v19[-2];
        v28 = v19[-1];
        v29 = v19->f32[0];
        v13.i32[0] = v19->i32[1];
        v19 += 3;
        v30 = vmulq_f32(v12, v27);
        v31 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), (int8x16_t)v28, 0xCuLL);
        v32 = (int32x4_t)vmlaq_f32(vmulq_f32(v31, v18), v28, v17);
        v33 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v32, v32), (int8x16_t)v32, 0xCuLL);
        v34 = vmlaq_f32(vmulq_f32(v31, vnegq_f32(v33)), v28, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL));
        v35 = v12.f32[3]
            + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0];
        v36 = vmulq_f32(v34, v34);
        v36.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), v36)).u64[0];
        v37 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 0);
        v38 = vrsqrteq_f32(v37);
        v39 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34), (int8x16_t)v34, 0xCuLL);
        v40 = vmulq_f32(v38, vrsqrtsq_f32(v37, vmulq_f32(v38, v38)));
        _ZF = v36.f32[0] == 0.0;
        v41 = vrsqrtsq_f32(v37, vmulq_f32(v40, v40));
        v42 = !_ZF;
        v43 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v42)), 0x1FuLL));
        v43.i32[3] = 0;
        v44 = vmulq_f32(v12, vmlsq_lane_f32(vmlaq_n_f32(v27, v28, v29), vmulq_f32(v39, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v43), (int8x16_t)vmulq_f32(v40, v41), _Q4)), v13, 0));
        v44.f32[0] = v12.f32[3]
                   + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).f32[0];
        v45 = v35 * v44.f32[0];
        v46 = fminf(v35, v44.f32[0]);
        if (v45 < 0.0)
          v46 = 0.0;
        *v26++ = v46;
        --v25;
      }
      while (v25);
    }
    MEMORY[0x1E0C80A78](v10);
    v49 = (__int16 *)((char *)v52 - v48);
    v50 = 0;
    v51 = 2 * a5;
    do
    {
      v49[v50] = v50;
      ++v50;
      v51 -= 2;
    }
    while (v51);
    v52[0] = v47;
    std::__introsort<std::_ClassicAlgPolicy,__SphereZComp &,short *,false>((uint64_t)v52 - v48, (__int16 *)((char *)v52 + 2 * a5 - v48), v52, 126 - 2 * __clz(a5), 1);
    reorder<__C3DNode *>(a3, v49, a5);
    reorder<__C3DNode *>(a4, v49, a5);
    *(_QWORD *)&result = reorder<scn_cone>(a2, v49, a5).n128_u64[0];
  }
  return result;
}

double __sortOmniLightsOnZAxis(uint64_t a1, __n128 *a2, _QWORD *a3, _QWORD *a4, __n128 *a5, int a6, double result)
{
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  uint64_t v15;
  char *v16;
  int v17;
  float32x4_t v18;
  int8x16_t v19;
  uint64_t v20;
  float32x4_t *v21;
  _DWORD *v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  int8x16_t v26;
  uint64_t v27;
  uint64_t v28;
  __int16 *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32[2];

  v32[1] = *MEMORY[0x1E0C80C00];
  if (a6)
  {
    *(double *)v14.i64 = MEMORY[0x1E0C80A78](a1);
    v16 = (char *)v32 - v15;
    if (v17 >= 1)
    {
      v18 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 3);
      v19.i64[0] = 0x8000000080000000;
      v19.i64[1] = 0x8000000080000000;
      v20 = v13;
      v21 = (float32x4_t *)a2;
      v22 = v16;
      do
      {
        v23 = *v21++;
        v24 = (int8x16_t)v23;
        v25 = vmulq_f32(v14, v23);
        v26 = (int8x16_t)vaddq_f32(v18, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))));
        *(float *)v24.i32 = fmaxf(fabsf(*(float *)v26.i32) - v23.f32[3], 0.0);
        *v22++ = vbslq_s8(v19, v24, v26).u32[0];
        --v20;
      }
      while (v20);
    }
    MEMORY[0x1E0C80A78](v12);
    v29 = (__int16 *)((char *)v32 - v28);
    v30 = 0;
    v31 = 2 * a6;
    do
    {
      v29[v30] = v30;
      ++v30;
      v31 -= 2;
    }
    while (v31);
    v32[0] = v27;
    std::__introsort<std::_ClassicAlgPolicy,__SphereZComp &,short *,false>((uint64_t)v32 - v28, (__int16 *)((char *)v32 + 2 * a6 - v28), v32, 126 - 2 * __clz(a6), 1);
    reorder<__C3DNode *>(a3, v29, a6);
    reorder<__C3DNode *>(a4, v29, a6);
    reorder<scn_sphere>(a2, v29, a6);
    *(_QWORD *)&result = reorder<scn_sphere>(a5, v29, a6).n128_u64[0];
  }
  return result;
}

double __sortProbesByVolume(_OWORD *a1, _QWORD *a2, _QWORD *a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  int v12;
  float *v13;
  uint64_t v14;
  float *v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  __int16 *v20;
  uint64_t v21;
  uint64_t v22;
  double result;
  uint64_t v24[2];

  v24[1] = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    MEMORY[0x1E0C80A78](a1);
    v11 = (float *)((char *)v24 - v10);
    if (v12 >= 1)
    {
      v13 = (float *)a1 + 18;
      v14 = v9;
      v15 = v11;
      do
      {
        v16 = *(v13 - 2) * *(v13 - 1);
        v17 = *v13;
        v13 += 20;
        *v15++ = (float)(v17 * v16) * 8.0;
        --v14;
      }
      while (v14);
    }
    MEMORY[0x1E0C80A78](v8);
    v20 = (__int16 *)((char *)v24 - v19);
    v21 = 0;
    v22 = 2 * a4;
    do
    {
      v20[v21] = v21;
      ++v21;
      v22 -= 2;
    }
    while (v22);
    v24[0] = v18;
    std::__introsort<std::_ClassicAlgPolicy,__VolumeComp &,short *,false>((uint64_t)v24 - v19, (__int16 *)((char *)v24 + 2 * a4 - v19), v24, 126 - 2 * __clz(a4), 1);
    reorder<__C3DNode *>(a2, v20, a4);
    reorder<__C3DNode *>(a3, v20, a4);
    *(_QWORD *)&result = reorder<scn_obb>(a1, v20, a4).n128_u64[0];
  }
  return result;
}

void C3DSortSystemSort(void *a1, int a2, void *__base, size_t __nel)
{
  qsort_r(__base, __nel, 4uLL, a1, (int (__cdecl *)(void *, const void *, const void *))_compareRendererElements);
}

uint64_t C3DLightingSystemEnumerateSpots(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(unsigned int *)(result + 76);
  if ((_DWORD)v2)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(a2 + 16))(a2, v2, *(_QWORD *)(result + 160), *(_QWORD *)(result + 224), *(_QWORD *)(result + 472));
  return result;
}

uint64_t C3DLightingSystemEnumerateLocalOmnis(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(unsigned int *)(result + 72);
  if ((_DWORD)v2)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(a2 + 16))(a2, v2, *(_QWORD *)(result + 152), *(_QWORD *)(result + 216), *(_QWORD *)(result + 456));
  return result;
}

uint64_t C3DCullingContextCull(uint64_t a1)
{
  uint64_t Stats;
  double v3;
  uint64_t v4;
  uint64_t RootNode;
  uint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  int i;
  float32x4_t *LayerRootNode;
  uint64_t CullingSystem;
  int v12;
  _QWORD v14[6];
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  C3DEngineContextGetFrameIndex(*(_QWORD *)(a1 + 4736));
  kdebug_trace();
  Stats = C3DEngineContextGetStats(*(_QWORD *)(a1 + 4736));
  v3 = CACurrentMediaTime();
  v4 = *(_QWORD *)(a1 + 4672);
  RootNode = C3DSceneGetRootNode(*(_QWORD *)(a1 + 4728));
  if (*(_DWORD *)(a1 + 4624))
  {
    v6 = RootNode;
    v7 = 0;
    v8 = (unsigned __int8 *)(a1 + 4630);
    do
    {
      if (*(_BYTE *)(a1 + 4692))
      {
        if (v4 == v6)
        {
          for (i = 0; i != 4; ++i)
          {
            if (((*v8 >> i) & 1) != 0)
            {
              LayerRootNode = (float32x4_t *)C3DSceneGetLayerRootNode(*(_QWORD *)(a1 + 4728), i);
              if (LayerRootNode)
                __CullInside((float32x4_t *)a1, v7, LayerRootNode);
            }
          }
        }
        else
        {
          __CullInside((float32x4_t *)a1, 0, *(float32x4_t **)(a1 + 4672));
        }
      }
      else if (v4 == v6)
      {
        CullingSystem = C3DSceneGetCullingSystem(*(_QWORD *)(a1 + 4728));
        v17 = 0;
        v15 = 0u;
        v16 = 0u;
        v14[0] = MEMORY[0x1E0C809B0];
        v14[1] = 0x40000000;
        v14[2] = __C3DCullingContextCull_block_invoke;
        v14[3] = &__block_descriptor_tmp_6_8;
        v14[4] = a1;
        v14[5] = v7;
        C3DCullingSystemQueryMake((uint64_t)v14, (uint64_t)&v15);
        v15 = *(_OWORD *)(a1 + 4704);
        if (*(_BYTE *)(a1 + 4690))
          v12 = 3;
        else
          v12 = 1;
        DWORD1(v16) = v12;
        if (*(_BYTE *)(a1 + 4691))
          DWORD1(v16) = v12 | 4;
        if (*(_BYTE *)(a1 + 4689))
          LODWORD(v16) = 8;
        DWORD2(v16) = *v8;
        C3DCullingSystemCull(CullingSystem);
      }
      else
      {
        __Cull((float32x4_t *)a1, 0, *(float32x4_t **)(a1 + 4672));
      }
      ++v7;
    }
    while (v7 < *(unsigned int *)(a1 + 4624));
  }
  *(double *)(Stats + 104) = *(double *)(Stats + 104) + CACurrentMediaTime() - v3;
  C3DEngineContextGetFrameIndex(*(_QWORD *)(a1 + 4736));
  return kdebug_trace();
}

uint64_t C3DNodeApplyChildren(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *(_QWORD *)(result + 72);
  if (v2)
  {
    v4 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 16))(a2, v2, v4++);
      v2 = *(_QWORD *)(v2 + 80);
    }
    while (v2);
  }
  return result;
}

uint64_t __CullInside(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  uint64_t result;
  _QWORD v7[6];

  result = C3DCullingContextPushRenderableElementsToVisible(a1, a2, a3);
  if (!result)
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = ____CullInside_block_invoke;
    v7[3] = &__block_descriptor_tmp_85;
    v7[4] = a1;
    v7[5] = a2;
    return C3DNodeApplyChildren((uint64_t)a3, (uint64_t)v7);
  }
  return result;
}

uint64_t C3DCullingContextPushRenderableElementsToVisible(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  uint64_t v3;
  float32x4_t *v8;
  __int32 v9;
  __int16 v10;
  __int16 v11;
  __int32 v12;
  uint64_t v13;
  const __CFDictionary *RegisteredCIFilterTechniqueForNode;
  uint64_t ParentTechnique;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (a1[294].i64[1] & a3[13].i64[0] | ((a1[294].i64[0] & a3[13].i64[0]) == 0))
    return 0;
  v8 = a1 + 293;
  if (a1[293].i8[2])
  {
    if ((a3[13].i8[14] & 0x40) == 0)
      return 0;
  }
  if (a1[293].i8[3] && (a3[13].i8[14] & 0x40) != 0)
    return 0;
  v9 = a3[14].i32[1];
  if (!v9)
    return 0;
  v10 = a3[14].i16[0];
  v11 = a3[14].i16[1];
  if (C3DNodeIsHiddenOrTransparent((uint64_t)a3))
    return 1;
  v12 = a3[13].i32[3];
  if ((v12 & 0x1000) == 0)
  {
    if ((v12 & 0x4000) != 0)
      goto LABEL_13;
LABEL_22:
    C3DCullingContextForcePushGeometryRenderableElementsToVisible(a1, a2, a3);
    return 0;
  }
  v8[20].i8[0] = 1;
  if (v8->i8[0] || a1[292].i64[1])
    return 0;
  if ((a3[13].i32[3] & 0x4000) == 0)
    goto LABEL_22;
LABEL_13:
  v8[20].i8[0] = 1;
  if ((float32x4_t *)a1[292].i64[0] == a3 || C3DFXPassGetMaterial(a1[291].i64[0]))
    goto LABEL_22;
  v13 = C3DGetScene(a3);
  RegisteredCIFilterTechniqueForNode = C3DSceneGetRegisteredCIFilterTechniqueForNode(v13, a3);
  if (RegisteredCIFilterTechniqueForNode)
  {
    ParentTechnique = C3DFXTechniqueGetParentTechnique((uint64_t)RegisteredCIFilterTechniqueForNode);
    if (!ParentTechnique || C3DFXTechniqueIsBeingRendered(ParentTechnique))
    {
      v16 = (uint64_t)&a1[a2 + 307];
      v3 = 1;
      C3DHandlesSequenceAppend(v16, v10, v11 + v9 - 1, 1);
      return v3;
    }
    return 1;
  }
  v3 = 1;
  if ((C3DCullingContextPushRenderableElementsToVisible_done & 1) == 0)
  {
    C3DCullingContextPushRenderableElementsToVisible_done = 1;
    v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      __shouldPushRenderableElementsToVisible_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
      return 1;
    }
  }
  return v3;
}

void C3DCullingContextForcePushGeometryRenderableElementsToVisible(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  float32x4_t *v3;
  __int16 v4;
  __int16 v5;
  __int32 v6;
  int v7;
  float32x4_t *v11;
  __int32 *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  __int16 *v23;
  int v24;
  _WORD *v25;
  uint64_t v26;
  uint64_t v27;
  __int32 *v28;
  uint64_t v29;
  __int16 v30;
  __int16 v31;
  int v32;
  NSObject *v33;
  uint64_t v34;
  int v35;
  _WORD *v36;
  float *v37;
  uint64_t v38;
  float32x4_t *WorldMatrix;
  float32x4_t v40;
  float32x4_t v41;
  float v42;
  uint64_t v43;
  __n128 Viewport;
  float v45;
  float *v46;
  float32x4_t v47;
  float32x4_t v48;
  float v49;
  float *v50;
  uint64_t v51;
  uint64_t v52;
  __int32 *v53;
  NSObject *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  __int16 *v64;
  float32x4_t *v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v3 = &a1[a2];
  v65 = v3 + 307;
  v4 = a3[14].i16[0];
  v5 = a3[14].i16[1];
  v6 = a3[13].i32[3];
  v7 = a3[14].i32[1] + (v6 << 17 >> 31);
  if ((v6 & 0x8000) != 0)
  {
    if (C3DEngineContextIsWarmUp(a1[296].i64[0]))
    {
      v11 = &a1[a2];
      v12 = &v11[307].i32[2];
      if ((v11[307].i32[2] + v7) > v11[307].i32[3])
      {
        v13 = scn_default_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
          C3D::ScenePass::_shouldPushNodeToVisible(v13, v14, v15, v16, v17, v18, v19, v20);
      }
      v21 = *v12;
      if (v7)
      {
        v22 = 0;
        v23 = (__int16 *)(v65->i64[0] + 4 * v21);
        do
        {
          *v23 = v4;
          v23[1] = v5 + v22++;
          v23 += 2;
        }
        while (v7 != v22);
      }
      v24 = v21 + v7;
      *v12 = v24;
      v25 = (_WORD *)a3[14].i64[1];
      v26 = (unsigned __int16)*v25;
      if (*v25)
      {
        v27 = 0;
        v28 = &v11[307].i32[3];
        do
        {
          v29 = a3[14].i64[1] + 12 * v27;
          v30 = *(_WORD *)(v29 + 12);
          v31 = *(_WORD *)(v29 + 14);
          v32 = *(_DWORD *)(v29 + 16);
          if (v24 + v32 > *v28)
          {
            v33 = scn_default_log();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
              C3DCullingContextForcePushGeometryRenderableElementsToVisible_cold_2((uint8_t *)&v71, (uint64_t *)((char *)v71.i64 + 4), v33);
          }
          v34 = *v12;
          if (v32)
          {
            v35 = 0;
            v36 = (_WORD *)(v65->i64[0] + 4 * v34);
            do
            {
              *v36 = v30;
              v36[1] = v31 + v35++;
              v36 += 2;
            }
            while (v32 != v35);
          }
          v24 = v34 + v32;
          *v12 = v24;
          ++v27;
        }
        while (v27 != v26);
      }
      return;
    }
    v37 = (float *)a3[14].i64[1];
    v38 = *(unsigned __int16 *)v37;
    if (*((_BYTE *)v37 + 2))
    {
      v71 = 0uLL;
      C3DGetBoundingSphere(a3, 0, (uint64_t)&v71);
      v70 = 0uLL;
      WorldMatrix = C3DNodeGetWorldMatrix(a3);
      C3DSphereXFormMatrix4x4(&v71, WorldMatrix, (uint64_t)&v70);
      v69 = vaddq_f32(vaddq_f32(v70, vmulq_laneq_f32(a1[299], v70, 3)), vmulq_laneq_f32(a1[300], v70, 3));
      v68.i32[2] = 0;
      v68.i64[0] = 0;
      v67.i32[2] = 0;
      v67.i64[0] = 0;
      v66 = v70;
      C3DMatrix4x4Project(a1 + 303, (float32x2_t *)&v66, &v68);
      C3DMatrix4x4Project(a1 + 303, (float32x2_t *)&v69, &v67);
      v40 = vsubq_f32(v68, v67);
      v41 = vmulq_f32(v40, v40);
      v42 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), vaddq_f32(v41, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1))).f32[0])* 0.5;
      Viewport = C3DEngineContextGetViewport((__n128 *)a1[296].i64[0]);
      LODWORD(v43) = 0;
      Viewport.n128_u32[0] = Viewport.n128_u32[3];
      if (Viewport.n128_f32[2] > Viewport.n128_f32[3])
        Viewport.n128_f32[0] = Viewport.n128_f32[2];
      v45 = Viewport.n128_f32[0] * v42;
      if (v37[2] < v45)
        goto LABEL_37;
      if (v38 >= 2)
      {
        v46 = v37 + 5;
        v43 = 1;
        while (*v46 >= v45)
        {
          ++v43;
          v46 += 3;
          if (v38 == v43)
          {
            LODWORD(v43) = v38;
            goto LABEL_37;
          }
        }
        goto LABEL_37;
      }
    }
    else
    {
      v71.i32[2] = 0;
      v71.i64[0] = 0;
      C3DNodeGetWorldPosition(a3, (__n128 *)&v71);
      LODWORD(v43) = 0;
      v47 = a1[298];
      v48 = vmulq_f32(v71, v47);
      v49 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1)))).f32[0];
      if (v49 < 0.0)
        v49 = 0.0;
      if (v37[2] > v49)
        goto LABEL_37;
      if (v38 >= 2)
      {
        LODWORD(v43) = v38;
        v50 = v37 + 5;
        v51 = 1;
        while (*v50 <= v49)
        {
          ++v51;
          v50 += 3;
          if (v38 == v51)
            goto LABEL_37;
        }
        LODWORD(v43) = v51;
        goto LABEL_37;
      }
    }
    LODWORD(v43) = 1;
LABEL_37:
    if ((int)v43 >= 1)
    {
      v52 = a3[14].i64[1] + 12 * v43;
      v4 = *(_WORD *)v52;
      v5 = *(_WORD *)(v52 + 2);
      v7 = *(_DWORD *)(v52 + 4);
    }
  }
  v53 = &v3[307].i32[2];
  if ((v3[307].i32[2] + v7) > v3[307].i32[3])
  {
    v54 = scn_default_log();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
      C3D::ScenePass::_shouldPushNodeToVisible(v54, v55, v56, v57, v58, v59, v60, v61);
  }
  v62 = *v53;
  if (v7)
  {
    v63 = 0;
    v64 = (__int16 *)(v65->i64[0] + 4 * v62);
    do
    {
      *v64 = v4;
      v64[1] = v5 + v63++;
      v64 += 2;
    }
    while (v7 != v63);
  }
  *v53 = v62 + v7;
}

uint64_t C3DEngineContextGetFrameIndex(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 1704);
  if (result)
    return -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](result);
  return result;
}

uint64_t C3DSceneGetLayerRootNode(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (a2 >= 4)
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      C3DSceneSetLayerRootNode_cold_1();
  }
  return *(_QWORD *)(a1 + 8 * a2 + 384);
}

uint64_t C3DGeometryCreateCopy(CFTypeRef cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return C3DCreateCopy(cf);
}

uint64_t C3DCreateCopy(CFTypeRef cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *ClassWithTypeID;
  uint64_t (*v11)(CFTypeRef);
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _C3DGeometryFillLibraryForSerialization_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (_QWORD *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696)
  {
    v11 = (uint64_t (*)(CFTypeRef))ClassWithTypeID[27];
    if (v11)
      return v11(cf);
  }
  v13 = scn_default_log();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    C3DCreateCopy_cold_1((uint64_t)cf, v13, v14, v15, v16, v17, v18, v19);
  return 0;
}

uint64_t _C3DGeometryCreateCopy(uint64_t a1)
{
  uint64_t v2;

  v2 = C3DGeometryCreate();
  C3DGeometryCopy(a1, v2);
  return v2;
}

void C3DGeometryCopy(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *Mesh_NoValidation;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFArray *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const __CFArray *v38;
  const __CFArray *LOD;
  const __CFString *Name;
  _OWORD *v41;
  _OWORD *v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DGeometryCopy_cold_3(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  Mesh_NoValidation = (uint64_t *)C3DGeometryGetMesh_NoValidation(a1);
  C3DGeometrySetMesh(a2, Mesh_NoValidation);
  if (!a1)
  {
    v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v21, v22, v23, v24, v25, v26, v27, v28);
  }
  v29 = *(const __CFArray **)(a1 + 80);
  if (!a2)
  {
    v30 = scn_default_log();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v30, v31, v32, v33, v34, v35, v36, v37);
  }
  v38 = *(const __CFArray **)(a2 + 80);
  if (v38 != v29)
  {
    if (v38)
    {
      CFRelease(v38);
      *(_QWORD *)(a2 + 80) = 0;
    }
    if (v29)
      *(_QWORD *)(a2 + 80) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v29);
  }
  LOD = (const __CFArray *)C3DGeometryGetLOD(a1);
  C3DGeometrySetLOD(a2, LOD);
  Name = (const __CFString *)C3DGeometryGetName(a1);
  if (Name)
    C3DGeometrySetName(a2, Name);
  *(_OWORD *)(a2 + 120) = *(_OWORD *)(a1 + 120);
  if (*(_QWORD *)(a1 + 104))
  {
    v41 = C3DMalloc(0x20uLL);
    *(_QWORD *)(a2 + 104) = v41;
    v42 = *(_OWORD **)(a1 + 104);
    v43 = v42[1];
    *v41 = *v42;
    v41[1] = v43;
  }
  C3DEntityCopyTo(a1, (CFTypeRef *)a2);
  C3DGeometryCopySubdivision(a1, (__C3DGeometry *)a2);
  v44 = *(_OWORD *)(a1 + 184);
  v45 = *(_QWORD *)(a1 + 200);
  C3DGeometrySetTessellator(a2, (unsigned __int8 *)&v44);
}

void C3DGeometrySetTessellator(uint64_t a1, unsigned __int8 *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  __int128 v14;
  uint64_t v15;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = *(unsigned __int8 *)(a1 + 184);
  v13 = *(unsigned __int8 *)(a1 + 196);
  v14 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 200) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(a1 + 184) = v14;
  if (v13 != a2[12])
  {
    v15 = C3DGetScene((_QWORD *)a1);
    C3DScenePostPipelineEvent(v15, 6, (const void *)a1, 0);
  }
  C3DGeometryOpenSubdivGPUParameterDidChange((__C3DGeometry *)a1, v12, *a2, *(unsigned __int8 *)(a1 + 136), *(unsigned __int8 *)(a1 + 136));
}

void C3DGeometrySetLOD(uint64_t a1, const __CFArray *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFArray *v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex i;
  const void *ValueAtIndex;
  void *v18;
  const __CFArray *v19;
  CFIndex v20;
  CFIndex v21;
  CFIndex j;
  void *v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex k;
  uint64_t *v27;
  CFIndex v28;
  CFIndex v29;
  CFIndex m;
  const void *v31;
  void *v32;
  const __CFSet *v33;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v12 = C3DGetSceneRef(a1);
  v13 = *(const __CFArray **)(a1 + 96);
  if (v13)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      Count = CFArrayGetCount(v13);
      if (Count >= 1)
      {
        v15 = Count;
        for (i = 0; i != v15; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), i);
          v18 = (void *)C3DLODGetEntity((uint64_t)ValueAtIndex);
          if (v18)
            CFSetApplyFunction(*(CFSetRef *)(a1 + 88), (CFSetApplierFunction)__propagateUnTrackingOfNodesToLODs, v18);
        }
      }
    }
  }
  v19 = *(const __CFArray **)(a1 + 96);
  if (v19 && v12)
  {
    v20 = CFArrayGetCount(v19);
    if (v20 >= 1)
    {
      v21 = v20;
      for (j = 0; j != v21; ++j)
      {
        v23 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), j);
        C3DRemoveSceneRef(v23, v12);
      }
    }
    v19 = *(const __CFArray **)(a1 + 96);
  }
  if (v19 != a2)
  {
    if (v19)
    {
      CFRelease(v19);
      *(_QWORD *)(a1 + 96) = 0;
    }
    if (a2)
      a2 = (const __CFArray *)CFRetain(a2);
    *(_QWORD *)(a1 + 96) = a2;
  }
  if (a2 && v12)
  {
    v24 = CFArrayGetCount(a2);
    if (v24 >= 1)
    {
      v25 = v24;
      for (k = 0; k != v25; ++k)
      {
        v27 = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), k);
        C3DAddSceneRef(v27, v12);
      }
    }
    a2 = *(const __CFArray **)(a1 + 96);
  }
  if (a2)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      v28 = CFArrayGetCount(a2);
      if (v28 >= 1)
      {
        v29 = v28;
        for (m = 0; m != v29; ++m)
        {
          v31 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), m);
          v32 = (void *)C3DLODGetEntity((uint64_t)v31);
          if (v32)
            CFSetApplyFunction(*(CFSetRef *)(a1 + 88), (CFSetApplierFunction)__propagateTrackingOfNodesToLODs, v32);
        }
      }
    }
  }
  v33 = *(const __CFSet **)(a1 + 88);
  if (v33)
    CFSetApplyFunction(v33, (CFSetApplierFunction)_GeometryLODDidChange, 0);
}

void C3DGeometryOpenSubdivGPUParameterDidChange(__C3DGeometry *a1, int a2, int a3, int a4, int a5)
{
  BOOL v10;
  int v11;
  BOOL v12;
  int v13;
  int v14;
  uint64_t v15;

  if ((C3DSubdivisionOsdGPUContextInvalidateIfNeeded(a1) & 1) != 0
    || (a3 == 4 ? (v10 = a5 == 0) : (v10 = 1),
        v10 ? (v11 = 0) : (v11 = 1),
        a2 == 4 ? (v12 = a4 == 0) : (v12 = 1),
        v12 ? (v13 = 0) : (v13 = 1),
        v13 != v11))
  {
    v14 = 7;
LABEL_16:
    v15 = C3DGetScene(a1);
    C3DScenePostPipelineEvent(v15, v14, a1, 0);
    return;
  }
  if ((a2 == 0) == (a3 != 0))
  {
    v14 = 6;
    goto LABEL_16;
  }
}

uint64_t C3DSubdivisionOsdGPUContextInvalidateIfNeeded(__C3DGeometry *a1)
{
  unsigned __int8 *var6;
  __C3DMeshElement *var3;
  __n128 v5;
  uint64_t v6;

  var6 = (unsigned __int8 *)a1->var10.var6;
  if (!var6)
    return 0;
  v5 = 0uLL;
  v6 = 0;
  C3DGeometryGetTessellator((uint64_t)a1, &v5);
  if ((v6 & 0x100) != 0)
  {
    var3 = a1->var10.var3;
    if (var3)
      LODWORD(var3) = a1->var10.var4 != 0;
  }
  else
  {
    LODWORD(var3) = 0;
  }
  if (*((_QWORD *)var6 + 3)
    && var6[4] == ((BYTE1(v6) >> 1) & 1)
    && var6[2] == a1->var10.var1
    && (_DWORD)var3 == var6[3]
    && *var6 == a1->var10.var0
    && var6[7] == a1->var10.var2.var1
    && var6[8] == a1->var10.var2.var2
    && *((_QWORD *)var6 + 2) == ((uint64_t)a1->var10.var4 ^ (uint64_t)a1->var10.var3))
  {
    return 0;
  }
  C3DSubdivisionOsdGPUContextDestroy(a1);
  return 1;
}

uint64_t C3DGeometryGetName(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return C3DEntityGetName(a1);
}

uint64_t C3DGeometryGetMesh_NoValidation(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 64);
}

__C3DMeshElement *C3DGeometryCopySubdivision(uint64_t a1, __C3DGeometry *a2)
{
  __C3DMesh *var5;
  __C3DMeshSource *var4;
  __C3DMeshSource *v6;
  __C3DMeshElement *var3;
  __C3DMeshElement *result;

  a2->var10.var2.var3 = *(_BYTE *)(a1 + 141);
  *(_DWORD *)&a2->var10.var0 = *(_DWORD *)(a1 + 136);
  a2->var10.var2.var2 = *(_BYTE *)(a1 + 140);
  C3DSubdivisionOsdGPUContextDestroy(a2);
  C3DGeometryDestroySubdivTopologyInfo(a2);
  var5 = a2->var10.var5;
  if (var5)
  {
    CFRelease(var5);
    a2->var10.var5 = 0;
  }
  var4 = a2->var10.var4;
  v6 = *(__C3DMeshSource **)(a1 + 152);
  if (var4 != v6)
  {
    if (var4)
    {
      CFRelease(a2->var10.var4);
      a2->var10.var4 = 0;
      v6 = *(__C3DMeshSource **)(a1 + 152);
    }
    if (v6)
      v6 = (__C3DMeshSource *)CFRetain(v6);
    a2->var10.var4 = v6;
  }
  var3 = a2->var10.var3;
  result = *(__C3DMeshElement **)(a1 + 144);
  if (var3 != result)
  {
    if (var3)
    {
      CFRelease(a2->var10.var3);
      a2->var10.var3 = 0;
      result = *(__C3DMeshElement **)(a1 + 144);
    }
    if (result)
      result = (__C3DMeshElement *)CFRetain(result);
    a2->var10.var3 = result;
  }
  return result;
}

void C3DGeometryDestroySubdivTopologyInfo(__C3DGeometry *a1)
{
  void *var7;
  int v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  var7 = a1->var10.var7;
  if (var7)
  {
    if (*((int *)var7 + 49) >= 1)
    {
      v3 = 0;
      do
        free(*(void **)(*((_QWORD *)var7 + 25) + 16 * v3++ + 8));
      while (*((_DWORD *)var7 + 49) > (int)v3);
    }
    free(*((void **)var7 + 25));
    free(*((void **)var7 + 14));
    free(*((void **)var7 + 15));
    free(*((void **)var7 + 17));
    free(*((void **)var7 + 18));
    free(*((void **)var7 + 20));
    free(*((void **)var7 + 21));
    free(*((void **)var7 + 23));
    v4 = (void *)*((_QWORD *)var7 + 10);
    if (v4)
    {
      *((_QWORD *)var7 + 11) = v4;
      operator delete(v4);
    }
    v5 = (void *)*((_QWORD *)var7 + 7);
    if (v5)
      operator delete(v5);
    v6 = (void *)*((_QWORD *)var7 + 4);
    if (v6)
    {
      *((_QWORD *)var7 + 5) = v6;
      operator delete(v6);
    }
    v7 = (void *)*((_QWORD *)var7 + 1);
    if (v7)
    {
      *((_QWORD *)var7 + 2) = v7;
      operator delete(v7);
    }
    free(a1->var10.var7);
    a1->var10.var7 = 0;
  }
}

void C3DSubdivisionOsdGPUContextDestroy(__C3DGeometry *a1)
{
  _QWORD *var6;
  const void *v3;

  var6 = a1->var10.var6;
  if (var6)
  {
    v3 = (const void *)var6[3];
    if (v3)
      CFRelease(v3);
    free(var6);
    a1->var10.var6 = 0;
  }
}

void *__InjectModifiers(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t Declaration;
  uint64_t Code;
  NSObject *v11;
  const __CFDictionary *Defines;
  void *result;
  _QWORD v14[5];

  v5 = *a3;
  if (C3DShaderModifierGetEntryPoint(*a3) != a2)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      __InjectModifiers_cold_2(v6, v7, v8);
  }
  Declaration = C3DShaderModifierGetDeclaration(v5);
  if (Declaration)
    objc_msgSend(*(id *)(a1 + 32), "appendString:", Declaration);
  Code = C3DShaderModifierGetCode(v5);
  if (Code)
  {
    *(_QWORD *)(a1 + 8 * a2 + 48) = Code;
  }
  else
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      __InjectModifiers_cold_1();
  }
  Defines = (const __CFDictionary *)C3DShaderModifierGetDefines(v5);
  if (Defines)
    CFDictionaryApplyFunction(Defines, (CFDictionaryApplierFunction)__appendDictionary_1, *(void **)(a1 + 8));
  result = (void *)C3DShaderModifierGetStandardUniformsUsed(v5);
  if (result)
  {
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = ____InjectModifiers_block_invoke;
    v14[3] = &__block_descriptor_40_e25_v32__0__NSString_8_16_B24l;
    v14[4] = a1;
    return (void *)objc_msgSend(result, "enumerateKeysAndObjectsUsingBlock:", v14);
  }
  return result;
}

uint64_t ____createHashCode_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = C3DShaderModifierGetEntryPoint(a3);
  if ((_DWORD)result == *(_DWORD *)(a1 + 40))
    return C3DShaderModifierUpdateHashCode(a3, *(CC_SHA256_CTX **)(a1 + 32));
  return result;
}

uint64_t __dispatchShaderModifiers(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  result = C3DShaderModifierGetEntryPoint(a1);
  if ((_DWORD)result == *(_DWORD *)(a2 + 24))
  {
    result = C3DShaderModifierGetLanguage(a1);
    if ((_DWORD)result == *(_DWORD *)(a2 + 28))
    {
      if (*(_QWORD *)a2)
      {
        v5 = *(_QWORD *)(a2 + 16);
        if (v5 < *(_QWORD *)(a2 + 8))
        {
          *(_QWORD *)(*(_QWORD *)a2 + 8 * v5) = a1;
          *(_QWORD *)(a2 + 16) = v5 + 1;
        }
      }
    }
  }
  return result;
}

uint64_t C3DShaderModifierGetEntryPoint(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 88);
}

uint64_t C3DShaderModifierGetDefines(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 32);
}

uint64_t C3DShaderModifierGetStandardUniformsUsed(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 40);
}

uint64_t C3DShaderModifierGetLanguage(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 100);
}

uint64_t C3DShaderModifierGetDeclaration(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 16);
}

uint64_t C3DShaderModifierGetCode(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 24);
}

void _transactionsDidFlush(uint64_t a1)
{
  *(_BYTE *)(a1 + 60) |= 1u;
  C3DTransactionTestForDidComplete(a1);
}

void _C3DAllocatorCFFinalize(uint64_t a1)
{
  const void *v2;

  C3DAllocatorFree(a1);
  v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 40) = 0;
  }
}

void C3DAllocatorFree(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DAllocatorNew_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (*(uint64_t *)(a1 + 48) >= 1)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(_QWORD *)(a1 + 32);
      free(*(void **)(v12 + v10));
      *(_QWORD *)(v12 + v10) = 0;
      ++v11;
      v10 += 16;
    }
    while (v11 < *(_QWORD *)(a1 + 48));
  }
  free(*(void **)(a1 + 32));
  *(_QWORD *)(a1 + 32) = 0;
  C3DIndexSetRemoveAllIndexes(*(_QWORD *)(a1 + 40));
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
}

uint64_t C3DStackAllocatorCreate(uint64_t a1)
{
  uint64_t Instance;

  if (C3DStackAllocatorGetTypeID(void)::onceToken != -1)
    dispatch_once(&C3DStackAllocatorGetTypeID(void)::onceToken, &__block_literal_global_138);
  Instance = C3DTypeCreateInstance_(C3DStackAllocatorGetTypeID(void)::typeID, 0x238uLL);
  __allocateChunk((vm_address_t *)(Instance + 24), a1);
  *(_QWORD *)(Instance + 16) = Instance + 24;
  *(_DWORD *)(Instance + 56) = *(_DWORD *)(Instance + 32);
  return Instance;
}

uint64_t __allocateChunk(vm_address_t *address, uint64_t a2)
{
  vm_size_t v3;
  uint64_t result;

  if (!address)
    __allocateChunk();
  if (!a2)
    __allocateChunk();
  v3 = ((*MEMORY[0x1E0C85AD8] - 1) | (a2 - 1)) + 1;
  *((_DWORD *)address + 2) = v3;
  result = vm_allocate(*MEMORY[0x1E0C83DA0], address, v3, 1);
  if (!*address)
    __allocateChunk();
  return result;
}

uint64_t C3DShaderModifierUpdateHashCode(uint64_t a1, CC_SHA256_CTX *c)
{
  return CC_SHA256_Update(c, (const void *)(a1 + 104), 0x20u);
}

uint64_t C3D::RenderGraph::isMainPass(C3D::RenderGraph *this, uint64_t a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 14);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 64))(result) == a2;
  return result;
}

void C3D::RenderGraph::addDependency(C3D::RenderGraph *this, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  unsigned int v7;
  __int16 v11;
  _QWORD *v12;
  _QWORD *v13;
  C3D::PassDescriptor *v14;
  C3D::PassDescriptor *v15;
  C3D::PassDescriptor *v16;
  C3D::PassIODescriptor *v17;
  C3D::PassDescriptor *v18;
  C3D::PassIODescriptor *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _DWORD *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  uint64_t v32;
  std::string *v33;
  uint64_t v34;
  std::string *v35;
  std::string __p;
  uint8_t buf[4];
  uint64_t v38;
  __int16 v39;
  int v40;
  __int16 v41;
  std::string *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v6 = *((_QWORD *)this + 3);
  v7 = *(_DWORD *)(v6 + 8);
  if (v7 <= a2)
    C3D::RenderGraph::addDependency();
  if (v7 <= a3)
    C3D::RenderGraph::addDependency();
  v11 = a2;
  v12 = (_QWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v6, a2);
  v13 = (_QWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), a3);
  if ((_DWORD)a4 != 255)
  {
    v14 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)*v12);
    if (C3D::PassDescriptor::inputCount(v14) <= a4)
      C3D::RenderGraph::addDependency();
  }
  if ((_DWORD)a5 == 255)
    goto LABEL_9;
  v15 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)*v13);
  if (C3D::PassDescriptor::outputCount(v15) <= a5)
    C3D::RenderGraph::addDependency();
  if ((_DWORD)a4 == 255
    || (v16 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)*v12),
        v17 = (C3D::PassIODescriptor *)C3D::PassDescriptor::inputAtIndex(v16, a4),
        v18 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)*v13),
        v19 = (C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex(v18, a5),
        C3D::PassIODescriptor::isPartiallyCompatible(v19, (const PassIODescriptor *)v17)))
  {
LABEL_9:
    *(_DWORD *)buf = a3 & 0x7FFF | ((_DWORD)a4 << 16) | ((_DWORD)a5 << 24);
    v20 = v12[3];
    v21 = *((unsigned int *)v12 + 4);
    if ((_DWORD)v21)
    {
      v22 = 4 * v21;
      v23 = (_DWORD *)v12[3];
      while ((*v23 & 0xFFFF7FFF) != (a3 & 0x7FFF | ((_DWORD)a4 << 16) | ((_DWORD)a5 << 24)))
      {
        ++v23;
        v22 -= 4;
        if (!v22)
        {
          v23 = (_DWORD *)(v20 + 4 * v21);
          break;
        }
      }
    }
    else
    {
      v23 = (_DWORD *)v12[3];
    }
    if (v21 == ((uint64_t)v23 - v20) >> 2)
      C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::Link const&>((_DWORD *)v12 + 2, buf);
    *(_DWORD *)buf = v11 & 0x7FFF | ((_DWORD)a5 << 16) | ((_DWORD)a4 << 24);
    v24 = v13[6];
    v25 = *((unsigned int *)v13 + 10);
    if ((_DWORD)v25)
    {
      v26 = 4 * v25;
      v27 = (_DWORD *)v13[6];
      while ((*v27 & 0xFFFF7FFF) != (v11 & 0x7FFF | ((_DWORD)a5 << 16) | ((_DWORD)a4 << 24)))
      {
        ++v27;
        v26 -= 4;
        if (!v26)
        {
          v27 = (_DWORD *)(v24 + 4 * v25);
          break;
        }
      }
    }
    else
    {
      v27 = (_DWORD *)v13[6];
    }
    if (v25 == ((uint64_t)v27 - v24) >> 2)
      C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::Link const&>((_DWORD *)v13 + 8, buf);
  }
  else
  {
    v28 = scn_default_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      C3D::RenderGraph::addDependency((uint64_t (****)(_QWORD))v13, (uint64_t (****)(_QWORD))v12);
    v29 = scn_default_log();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      C3D::RenderGraph::addDependency(a4, a5, v29);
    v30 = scn_default_log();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v32 = (**(uint64_t (***)(_QWORD))*v13)(*v13);
      C3D::PassIODescriptor::description(v19, &__p);
      v33 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315650;
      v38 = v32;
      v39 = 1024;
      v40 = a5;
      v41 = 2080;
      v42 = v33;
      _os_log_error_impl(&dword_1DCCB8000, v30, OS_LOG_TYPE_ERROR, "Error: Output descriptor of pass %s at port %d: %s", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    v31 = scn_default_log();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v34 = (**(uint64_t (***)(_QWORD))*v12)(*v12);
      C3D::PassIODescriptor::description(v17, &__p);
      v35 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315650;
      v38 = v34;
      v39 = 1024;
      v40 = a4;
      v41 = 2080;
      v42 = v35;
      _os_log_error_impl(&dword_1DCCB8000, v31, OS_LOG_TYPE_ERROR, "Error: Input descriptor of pass %s at port %d: %s", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

_DWORD *C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::Link const&>(_DWORD *result, _DWORD *a2)
{
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  const void *v6;
  unsigned int v7;
  void *Aligned;

  v3 = result;
  v4 = result[2];
  v5 = result[3];
  v6 = (const void *)*((_QWORD *)result + 2);
  if (v4 + 1 > v5)
  {
    v7 = ((double)(v5 + 1) * 1.5);
    Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)result, 4 * v7, 4, 0);
    result = memcpy(Aligned, v6, 4 * v3[2]);
    *((_QWORD *)v3 + 2) = Aligned;
    v3[3] = v7;
    v6 = Aligned;
    v4 = v3[2];
  }
  *((_DWORD *)v6 + v4) = *a2;
  ++v3[2];
  return result;
}

BOOL C3D::PassIODescriptor::isPartiallyCompatible(C3D::PassIODescriptor *this, const PassIODescriptor *a2)
{
  int v4;
  int v5;
  uint64_t v6;
  int v8;

  if (*((_WORD *)this + 8))
  {
    if (*((_WORD *)a2 + 8) && *((unsigned __int16 *)this + 8) != *((unsigned __int16 *)a2 + 8))
      return 0;
  }
  if (*((_WORD *)this + 9))
  {
    if (*((_WORD *)a2 + 9) && *((unsigned __int16 *)this + 9) != *((unsigned __int16 *)a2 + 9))
      return 0;
  }
  if (*((_WORD *)this + 10)
    && *((_WORD *)a2 + 10)
    && *((unsigned __int16 *)this + 10) != *((unsigned __int16 *)a2 + 10))
  {
    return 0;
  }
  v4 = *((unsigned __int8 *)this + 24);
  if (!*((_BYTE *)this + 24)
    || (v5 = *((unsigned __int8 *)a2 + 24), !*((_BYTE *)a2 + 24))
    || v4 == v5
    || v4 == 4 && v5 == 2
    || (v6 = 0, v4 == 8) && v5 == 3)
  {
    if (*((_BYTE *)this + 25)
      && *((_BYTE *)a2 + 25)
      && *((unsigned __int8 *)this + 25) != *((unsigned __int8 *)a2 + 25)
      || *((_BYTE *)this + 27)
      && *((_BYTE *)a2 + 27)
      && *((unsigned __int8 *)this + 27) != *((unsigned __int8 *)a2 + 27)
      || *((_WORD *)this + 14)
      && *((_WORD *)a2 + 14)
      && *((unsigned __int16 *)this + 14) != *((unsigned __int16 *)a2 + 14))
    {
      return 0;
    }
    v6 = *((unsigned __int8 *)this + 30);
    if ((_DWORD)v6 != 1)
    {
      v8 = *((unsigned __int8 *)a2 + 30);
      return v8 == 1 || (_DWORD)v6 == v8;
    }
  }
  return v6;
}

void C3D::RenderGraph::execute(C3D::RenderGraph *this)
{
  uint64_t v1;
  __n128 v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  __int128 v6;
  uint64_t v7;
  _DWORD *v8;
  unsigned int v9;
  unsigned __int16 v10;
  unsigned __int16 *v11;
  _DWORD *v12;
  C3D::Pass *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  NSObject *v17;
  void *v18;
  uint64_t v19;
  int v20;
  uint64_t i;
  uint64_t v22;
  int v23;
  unsigned int v24;
  C3D::Pass *PassInStage;
  unsigned int v26;
  C3D::Pass *v27;
  uint64_t v28;
  C3D::PassDescriptor *v29;
  int v30;
  C3D::PassDescriptor *v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  C3D::PassDescriptor *v36;
  int v37;
  NSObject *v38;
  void *v39;
  void *v40;
  NSObject *v41;
  C3D::PassResource *v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  void *v46;
  C3D::PassResource *v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  void *v51;
  uint64_t v52;
  char CoordinatesSystemOptions;
  uint64_t v54;
  void *v55;
  int v56;
  void *v57;
  C3D::PassResource *v58;
  uint64_t v59;
  C3D::RefCountedResource *v60;
  NSObject *v61;
  void *v62;
  BOOL v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  BOOL v67;
  char v68;
  C3D::PassDescriptor *v69;
  unsigned int v70;
  __int16 v71;
  unsigned int v72;
  __int16 v73;
  uint64_t v74;
  __int16 v75;
  unsigned __int16 v76;
  unsigned __int16 v77;
  void *RenderPassDescriptorForEye;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  C3D::PassResource *v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  C3D::PassResource *v86;
  uint64_t v87;
  unsigned int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unsigned __int16 *v92;
  uint64_t v93;
  uint64_t *v94;
  int PrimitiveCount;
  uint64_t v96;
  NSObject *v97;
  uint64_t v98;
  MTLTexture *v99;
  MTLTexture *v100;
  void *v101;
  MTLTexture *SharedTexture;
  const char *v103;
  char *v104;
  unsigned int v105;
  unint64_t v106;
  unsigned int *v107;
  unsigned int v108;
  char *v109;
  char *v110;
  uint64_t v111;
  unint64_t j;
  char *v113;
  uint64_t v114;
  char *v115;
  char *v116;
  C3D::PassResource *v117;
  __int128 v118;
  uint64_t StackAllocator;
  int v120;
  char v121;
  char *__s1[2];
  unsigned int __s1a;
  char *__s1b;
  __int16 v125;
  unsigned __int16 v126;
  uint64_t v127;
  unsigned int *v128;
  void *v129;
  SCNMTLRenderContext *RenderContext;
  _QWORD v131[5];
  _QWORD v132[2];
  unsigned __int16 v133;
  __int16 v134;
  int v135;
  unsigned __int16 v136;
  uint64_t v137;
  SCNMTLBlitCommandEncoder v138;
  SCNMTLComputeCommandEncoder v139;
  char v140;
  _BYTE buf[24];
  uint8_t v142[4];
  uint64_t v143;
  uint8_t v144[4];
  int v145[3];
  uint8_t v146[4];
  uint64_t v147;
  uint8_t v148[4];
  uint64_t v149;
  uint8_t v150[4];
  _QWORD v151[5];

  v2.n128_f64[0] = MEMORY[0x1E0C80A78](this);
  v3 = v1;
  *(_QWORD *)((char *)&v151[2] + 4) = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(v1 + 210) || !*(_BYTE *)(v1 + 211))
  {
    v4 = *(_QWORD *)(v1 + 168);
    if (v4)
    {
      v5 = *(id *)(v3 + 184);
      if (v5
        || (v5 = C3D::RenderGraph::graphDescription((C3D::RenderGraph *)v3),
            *(_QWORD *)(v3 + 184) = v5,
            (v4 = *(_QWORD *)(v3 + 168)) != 0))
      {
        (*(void (**)(uint64_t, id, __n128))(v4 + 16))(v4, v5, v2);

        *(_QWORD *)(v3 + 168) = 0;
        *(_QWORD *)(v3 + 184) = 0;
      }
    }
  }
  else
  {
    if (*(_BYTE *)(v1 + 212))
      C3D::RenderGraph::logFrame((C3D::RenderGraph *)v1);
    RenderContext = (SCNMTLRenderContext *)C3DEngineContextGetRenderContext(*(_QWORD *)(v3 + 8));
    v129 = (void *)-[SCNMTLRenderContext currentCommandBuffer]((uint64_t)RenderContext);
    StackAllocator = C3DEngineContextGetStackAllocator(*(_QWORD *)(v3 + 8));
    C3DStackAllocatorPushFrame(StackAllocator);
    v139._encoder = 0;
    v139._bufferPool = 0;
    v138._encoder = 0;
    v138._commandBuffer = 0;
    if (*(_QWORD *)(v3 + 168))
    {
      v128 = (unsigned int *)operator new();
      *(_QWORD *)v128 = 0;
      *((_QWORD *)v128 + 1) = v128 + 4;
    }
    else
    {
      v128 = 0;
    }
    v7 = *(_QWORD *)(v3 + 96);
    v137 = v7;
    if (v7)
    {
      *(_QWORD *)&v6 = 136315394;
      v118 = v6;
      while (1)
      {
        v136 = 0;
        v8 = (_DWORD *)(v7 + 8);
        if (*(_DWORD *)(v7 + 8))
          break;
LABEL_208:
        v7 = *(_QWORD *)(v7 + 24);
        v137 = v7;
        if (!v7)
          goto LABEL_209;
      }
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = (unsigned __int16 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](v7, v9);
        v12 = (_DWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(v3 + 24), *v11);
        v13 = *(C3D::Pass **)v12;
        *(_QWORD *)(v3 + 120) = *(_QWORD *)v12;
        switch(*(_DWORD *)C3D::Pass::descriptor(v13))
        {
          case 1:
            v14 = C3D::Pass::descriptor(v13);
            v15 = *(unsigned __int16 *)(v14 + 6);
            if (*(_WORD *)(v14 + 6))
            {
              v16 = 0;
              do
              {
                *(_QWORD *)buf = v129;
                *(_WORD *)&buf[8] = v16;
                (*(void (**)(C3D::Pass *, _BYTE *))(*(_QWORD *)v13 + 56))(v13, buf);
                ++v16;
              }
              while (v16 < v15);
            }
            goto LABEL_167;
          case 2:
            v120 = *(unsigned __int8 *)C3D::RenderPass::getRenderMode(v13);
            v18 = *(void **)(v3 + 152);
            v19 = *(_QWORD *)(v7 + 24);
            v20 = v19
               && !*(_QWORD *)(v19 + 24)
               && -[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext)
               && *v8 - 1 == v9;
            for (i = 0; i != 8; ++i)
            {
              objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments", v118), "objectAtIndexedSubscript:", i), "setTexture:", 0);
              objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", i), "setResolveTexture:", 0);
            }
            objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setTexture:", 0);
            objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setResolveTexture:", 0);
            objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setTexture:", 0);
            if (v120 == 1)
              v22 = *(unsigned __int16 *)(C3D::Pass::descriptor(v13) + 6);
            else
              v22 = 0;
            objc_msgSend(v18, "setRenderTargetArrayLength:", v22);
            if (v13 == *(C3D::Pass **)(v3 + 112))
              v28 = objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "rasterizationRateMap");
            else
              v28 = 0;
            objc_msgSend(v18, "setRasterizationRateMap:", v28);
            v29 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v13);
            if (C3D::PassDescriptor::outputCount(v29))
            {
              v121 = 0;
              v30 = 0;
              while (1)
              {
                v31 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v13);
                v32 = C3D::PassDescriptor::outputAtIndex(v31, (unsigned __int16)v30);
                if (*(_BYTE *)v32 == 1)
                {
                  v33 = *(_QWORD *)(v32 + 8);
                  v34 = *(unsigned __int8 *)(v32 + 31);
                  *(_OWORD *)__s1 = *(_OWORD *)(v32 + 48);
                  v35 = *(unsigned __int8 *)(v32 + 65);
                  v125 = *(_WORD *)(v32 + 66);
                  v36 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v13);
                  v37 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex(v36, (unsigned __int16)v30) + 64);
                  switch(v37)
                  {
                    case 3:
                      if (v20
                        && objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "stencilAttachment"), "texture"))
                      {
                        v39 = (void *)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "stencilAttachment");
                        objc_msgSend(v18, "setStencilAttachment:", v39);
                        if (v34 <= 1 && objc_msgSend(v39, "resolveTexture"))
                        {
                          objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setTexture:", objc_msgSend(v39, "resolveTexture"));
                          objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setResolveTexture:", 0);
                          objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setStoreAction:", 1);
                        }
LABEL_88:
                        if (C3DEngineContextHasFeatures(*(_QWORD *)(v3 + 8), 0x4000))
                        {
                          v46 = (void *)-[SCNMTLRenderContext device]((uint64_t)RenderContext);
                          if (SCNMTLDeviceSupportsStencilResolve(v46))
                          {
                            if (-[SCNMTLRenderContext shouldDelegateARCompositing]((uint64_t)RenderContext))
                              objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setStencilResolveFilter:", 1);
                          }
                        }
                        break;
                      }
                      v42 = (C3D::PassResource *)C3D::Pass::resource(v13);
                      v43 = C3D::PassResource::outputAtIndex(v42, (unsigned __int16)v30);
                      if (v43)
                      {
                        if ((v125 & 8) != 0 && !*(_QWORD *)(v3 + 168))
                          v44 = 0;
                        else
                          v44 = C3D::__deduceStoreAction(v3, (void *)objc_msgSend(v18, "stencilAttachment"), 3, (unint64_t)v12, StackAllocator, v30);
                        objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setStoreAction:", v44);
                        if (objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "storeAction") == 2
                          || objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "storeAction") == 3)
                        {
                          objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setResolveTexture:", *(_QWORD *)(v43 + 24));
                        }
                        if (*(_BYTE *)(v43 + 32) != 1)
                        {
                          v45 = scn_default_log();
                          if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
                            C3D::RenderGraph::execute(v146, &v147, v45);
                        }
                        objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setLoadAction:", v125 & 3);
                        objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setTexture:", *(_QWORD *)v43);
                        goto LABEL_88;
                      }
                      break;
                    case 2:
                      if (v20
                        && objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "depthAttachment"), "texture"))
                      {
                        v40 = (void *)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "depthAttachment");
                        objc_msgSend(v18, "setDepthAttachment:", v40);
                        if (v34 <= 1 && objc_msgSend(v40, "resolveTexture"))
                        {
                          objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setTexture:", objc_msgSend(v40, "resolveTexture"));
                          objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setResolveTexture:", 0);
                          objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setStoreAction:", 1);
                        }
LABEL_102:
                        CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(*(_QWORD *)(v3 + 8));
                        if (C3DEngineContextHasFeatures(*(_QWORD *)(v3 + 8), 4)
                          && -[SCNMTLRenderContext shouldDelegateARCompositing]((uint64_t)RenderContext))
                        {
                          if ((CoordinatesSystemOptions & 8) != 0)
                            v54 = 2;
                          else
                            v54 = 1;
                          objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setDepthResolveFilter:", v54);
                        }
                        v55 = (void *)objc_msgSend(v18, "depthAttachment");
                        if ((CoordinatesSystemOptions & 8) != 0)
                          objc_msgSend(v55, "setClearDepth:", 0.0);
                        else
                          objc_msgSend(v55, "setClearDepth:", 1.0);
                        break;
                      }
                      v47 = (C3D::PassResource *)C3D::Pass::resource(v13);
                      v48 = C3D::PassResource::outputAtIndex(v47, (unsigned __int16)v30);
                      v49 = v48;
                      if (v48)
                      {
                        if (*(_BYTE *)(v48 + 32) != 1)
                        {
                          v50 = scn_default_log();
                          if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
                            C3D::RenderGraph::execute(v148, &v149, v50);
                        }
                        v51 = (void *)objc_msgSend(v18, "depthAttachment");
                        objc_msgSend(v51, "setTexture:", C3D::Pass::outputTextureAtIndex(v13, (unsigned __int16)v30));
                        objc_msgSend(v51, "setLoadAction:", v125 & 3);
                        if ((v125 & 8) != 0 && !*(_QWORD *)(v3 + 168))
                          v52 = 0;
                        else
                          v52 = C3D::__deduceStoreAction(v3, v51, 2, (unint64_t)v12, StackAllocator, v30);
                        objc_msgSend(v51, "setStoreAction:", v52);
                        if (objc_msgSend(v51, "storeAction") == 2 || objc_msgSend(v51, "storeAction") == 3)
                          objc_msgSend(v51, "setResolveTexture:", *(_QWORD *)(v49 + 24));
                        goto LABEL_102;
                      }
                      break;
                    case 1:
                      if ((_DWORD)v35 == 255)
                      {
                        v38 = scn_default_log();
                        if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)buf = v118;
                          *(_QWORD *)&buf[4] = "attachmentID < 255";
                          *(_WORD *)&buf[12] = 2080;
                          *(_QWORD *)&buf[14] = v33;
                          _os_log_fault_impl(&dword_1DCCB8000, v38, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Attachment ID not set for %s", buf, 0x16u);
                        }
                      }
                      else
                      {
                        if ((_DWORD)v35)
                          v56 = 0;
                        else
                          v56 = v20;
                        if (v56 == 1)
                        {
                          v57 = (void *)objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "colorAttachments"), "objectAtIndexedSubscript:", 0);
                          objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "setObject:atIndexedSubscript:", v57, 0);
                          if (v34 <= 1 && objc_msgSend(v57, "resolveTexture"))
                          {
                            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setTexture:", objc_msgSend(v57, "resolveTexture"));
                            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setResolveTexture:", 0);
                            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setStoreAction:", 1);
                          }
                          break;
                        }
                      }
                      v58 = (C3D::PassResource *)C3D::Pass::resource(v13);
                      v59 = C3D::PassResource::outputAtIndex(v58, (unsigned __int16)v30);
                      v60 = (C3D::RefCountedResource *)v59;
                      if (v59)
                      {
                        if (*(_BYTE *)(v59 + 32) != 1)
                        {
                          v61 = scn_default_log();
                          if (os_log_type_enabled(v61, OS_LOG_TYPE_FAULT))
                            C3D::RenderGraph::execute(v150, v151, v61);
                        }
                        v62 = (void *)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", v35);
                        objc_msgSend(v62, "setTexture:", C3D::Pass::outputTextureAtIndex(v13, (unsigned __int16)v30));
                        v63 = objc_msgSend(v62, "texture") == 0;
                        objc_msgSend(v62, "setStoreAction:", C3D::__deduceStoreAction(v3, v62, 1, (unint64_t)v12, StackAllocator, v30));
                        if (objc_msgSend(v62, "storeAction") == 2 || objc_msgSend(v62, "storeAction") == 3)
                        {
                          objc_msgSend(v62, "setResolveTexture:", C3D::RefCountedResource::resolveTextureOrFinal(v60, RenderContext));
                          v64 = objc_msgSend((id)objc_msgSend(v62, "resolveTexture"), "width");
                          LODWORD(v64) = v64 == objc_msgSend((id)objc_msgSend(v62, "texture"), "width");
                          v65 = (void *)objc_msgSend(v62, "resolveTexture");
                          if (!(_DWORD)v64
                            || ((v66 = objc_msgSend(v65, "height"),
                                 v67 = v66 != objc_msgSend((id)objc_msgSend(v62, "texture"), "height"),
                                 !objc_msgSend(v62, "resolveTexture"))
                              ? (v68 = 1)
                              : (v68 = v67),
                                (v68 & 1) != 0))
                          {
                            *(_QWORD *)(v3 + 120) = 0;
                            C3DStackAllocatorPopFrame(StackAllocator);
                            return;
                          }
                        }
                        objc_msgSend(v62, "setLoadAction:", v125 & 3);
                        v121 |= v63;
                        if (objc_msgSend(v62, "loadAction") == 2)
                        {
                          if ((v125 & 0x40) == 0)
                            *(__n128 *)__s1 = C3DEngineContextGetViewBackgroundColor(*(_QWORD *)(v3 + 8));
                          objc_msgSend(v62, "setClearColor:", *(float *)__s1, *((float *)__s1 + 1), *(float *)&__s1[1], *((float *)&__s1[1] + 1));
                        }
                      }
                      break;
                    default:
                      v41 = scn_default_log();
                      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                        C3D::__renderSlice(v144, v145, v41);
                      break;
                  }
                }
                v69 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v13);
                if (++v30 >= C3D::PassDescriptor::outputCount(v69))
                  goto LABEL_138;
              }
            }
            v121 = 0;
LABEL_138:
            if (v20
              && objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "stencilAttachment"), "texture"))
            {
              objc_msgSend(v18, "setStencilAttachment:", objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor]((uint64_t)RenderContext), "stencilAttachment"));
            }
            v70 = *(unsigned __int16 *)(C3D::Pass::descriptor(v13) + 10);
            if (v70 <= 1)
              v71 = 1;
            else
              v71 = v70;
            v72 = *(unsigned __int16 *)(C3D::Pass::descriptor(v13) + 8);
            v73 = *(_WORD *)(C3D::Pass::descriptor(v13) + 6);
            v74 = C3D::Pass::descriptor(v13);
            if (v120)
              v75 = 1;
            else
              v75 = v73;
            v126 = v72 + v71;
            if (!(v121 & 1 | (v72 >= (unsigned __int16)(v72 + v71))))
            {
              __s1a = *(unsigned __int16 *)(v74 + 4);
              v76 = __s1a + v75;
              do
              {
                v77 = __s1a;
                if (__s1a < v76)
                {
                  do
                  {
                    if (v20
                      && ((-[SCNMTLRenderContext shouldDelegateARCompositing]((uint64_t)RenderContext) & 1) != 0
                       || -[SCNMTLRenderContext enableARMode]((uint64_t)RenderContext)))
                    {
                      RenderPassDescriptorForEye = (void *)C3DEngineContextGetRenderPassDescriptorForEye(*(_QWORD *)(v3 + 8), v77);
                      v79 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "colorAttachments"), "objectAtIndexedSubscript:", 0), "resolveTexture");
                      if (!v79)
                        v79 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "colorAttachments"), "objectAtIndexedSubscript:", 0), "texture");
                      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setTexture:", v79);
                      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setLoadAction:", 0);
                      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v18, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setStoreAction:", 1);
                      if (objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "texture")
                        || objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "resolveTexture"))
                      {
                        v80 = objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "depthAttachment"), "resolveTexture");
                        if (!v80)
                          v80 = objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "depthAttachment"), "texture");
                        objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setTexture:", v80);
                        objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setLoadAction:", 0);
                        objc_msgSend((id)objc_msgSend(v18, "depthAttachment"), "setStoreAction:", 1);
                      }
                      if (objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "texture")
                        || objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "resolveTexture"))
                      {
                        v81 = objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "stencilAttachment"), "resolveTexture");
                        if (!v81)
                          v81 = objc_msgSend((id)objc_msgSend(RenderPassDescriptorForEye, "stencilAttachment"), "texture");
                        objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setTexture:", v81);
                        objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setLoadAction:", 0);
                        objc_msgSend((id)objc_msgSend(v18, "stencilAttachment"), "setStoreAction:", 1);
                      }
                    }
                    v132[0] = &v140;
                    v132[1] = v18;
                    v133 = v77;
                    v134 = v72;
                    v135 = 0;
                    C3D::__renderSlice((_QWORD *)v3, v13, &v136, v12, &v137, (uint64_t)v132, v20, (uint64_t *)(v3 + 160));
                    ++v77;
                  }
                  while (v77 < v76);
                }
                LOWORD(v72) = v72 + 1;
              }
              while ((unsigned __int16)v72 < v126);
            }
LABEL_167:
            if (*(_QWORD *)(v3 + 168))
            {
              v82 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v12);
              v83 = C3D::PassResource::outputCount(v82);
              v84 = v136;
              if (v83)
              {
                v85 = 0;
                v127 = v136;
                while (2)
                {
                  v86 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v12);
                  v87 = C3D::PassResource::outputAtIndex(v86, (unsigned __int16)v85);
                  if (!v87)
                    goto LABEL_201;
                  if (!*(_QWORD *)(v3 + 184))
                    *(_QWORD *)(v3 + 184) = C3D::RenderGraph::graphDescription((C3D::RenderGraph *)v3);
                  v88 = 0;
                  v89 = v3 + 96;
                  while (1)
                  {
                    v90 = *(_QWORD *)v89;
                    v91 = *(unsigned int *)(*(_QWORD *)v89 + 8);
                    if ((_DWORD)v91)
                      break;
LABEL_178:
                    v89 = v90 + 24;
                    ++v88;
                  }
                  v92 = *(unsigned __int16 **)(v90 + 16);
                  v93 = 2 * v91;
                  while (1)
                  {
                    v94 = (uint64_t *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(v3 + 24), *v92);
                    PrimitiveCount = C3DMeshElementGetPrimitiveCount(*v94);
                    if (PrimitiveCount != C3DMeshElementGetPrimitiveCount(*(_QWORD *)v12))
                      break;
                    ++v92;
                    v93 -= 2;
                    if (!v93)
                      goto LABEL_178;
                  }
                  v96 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(v3 + 184), "objectForKeyedSubscript:", CFSTR("stages")), "objectAtIndex:", v88), "objectAtIndex:", v84), "objectForKey:", CFSTR("outputs")), "objectAtIndex:", v85);
                  if (!v96)
                  {
                    v97 = scn_default_log();
                    if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136315650;
                      *(_QWORD *)&buf[4] = "outputDesc";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v85;
                      *(_WORD *)&buf[18] = 1024;
                      *(_DWORD *)&buf[20] = v88;
                      _os_log_fault_impl(&dword_1DCCB8000, v97, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Missing output at index %d for stage %d", buf, 0x18u);
                    }
                  }
                  if (*(_BYTE *)(v87 + 32) != 1)
                    goto LABEL_201;
                  v98 = C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v12, v85);
                  *(_OWORD *)buf = *(_OWORD *)(v98 + 16);
                  *(_DWORD *)&buf[16] = *(_DWORD *)(v98 + 32);
                  v99 = (MTLTexture *)(objc_msgSend(*(id *)v87, "sampleCount") == 1
                                     ? C3D::RefCountedResource::textureOrFinal((C3D::RefCountedResource *)v87, RenderContext): C3D::RefCountedResource::resolveTextureOrFinal((C3D::RefCountedResource *)v87, RenderContext));
                  v100 = v99;
                  v101 = (void *)-[SCNMTLRenderContext resourceManager]((uint64_t)RenderContext);
                  SharedTexture = C3D::CreateSharedTexture(v100, (__int128 *)buf, v129, v101);
                  if (!SharedTexture)
                    goto LABEL_201;
                  v103 = (const char *)(***(uint64_t (****)(_QWORD))v12)(*(_QWORD *)v12);
                  if (v103)
                    v104 = strdup(v103);
                  else
                    v104 = 0;
                  LODWORD(v106) = *v128;
                  v105 = v128[1];
                  v107 = (unsigned int *)*((_QWORD *)v128 + 1);
                  if (*v128 + 1 <= v105)
                  {
                    v110 = (char *)*((_QWORD *)v128 + 1);
                    if (!v104)
                      goto LABEL_197;
                  }
                  else
                  {
                    __s1b = v104;
                    v108 = ((double)(v105 + 1) * 1.5);
                    v109 = (char *)malloc_type_malloc(32 * v108, 0x74F3E194uLL);
                    v110 = v109;
                    v106 = *v128;
                    if ((_DWORD)v106)
                    {
                      v111 = 0;
                      for (j = 0; j < v106; ++j)
                      {
                        v113 = &v109[v111];
                        v114 = *((_QWORD *)v128 + 1) + v111;
                        *(_OWORD *)v113 = *(_OWORD *)v114;
                        *((_QWORD *)v113 + 2) = *(_QWORD *)(v114 + 16);
                        *((_DWORD *)v113 + 6) = *(_DWORD *)(v114 + 24);
                        *(_QWORD *)v114 = 0;
                        *(_QWORD *)(v114 + 8) = 0;
                        *(_QWORD *)(v114 + 16) = 0;
                        *(_DWORD *)(v114 + 24) = -1;
                        v111 += 32;
                      }
                    }
                    *((_QWORD *)v128 + 1) = v109;
                    v128[1] = v108;
                    if (v107 != v128 + 4)
                    {
                      free(v107);
                      LODWORD(v106) = *v128;
                      v110 = (char *)*((_QWORD *)v128 + 1);
                    }
                    v104 = __s1b;
                    if (!__s1b)
                    {
LABEL_197:
                      v115 = 0;
                      goto LABEL_200;
                    }
                  }
                  v115 = strdup(v104);
LABEL_200:
                  v116 = &v110[32 * v106];
                  *(_QWORD *)v116 = v115;
                  *((_QWORD *)v116 + 1) = v96;
                  *((_QWORD *)v116 + 2) = SharedTexture;
                  *((_DWORD *)v116 + 6) = v85;
                  *v128 = v106 + 1;
                  free(v104);
                  v84 = v127;
LABEL_201:
                  v117 = (C3D::PassResource *)C3D::Pass::resource(*(C3D::Pass **)v12);
                  if (++v85 >= (unint64_t)C3D::PassResource::outputCount(v117))
                    break;
                  continue;
                }
              }
            }
            else
            {
              LOWORD(v84) = v136;
            }
            v10 = v84 + 1;
            v136 = v84 + 1;
            v9 = (unsigned __int16)(v84 + 1);
            v7 = v137;
            v8 = (_DWORD *)(v137 + 8);
            if (*(_DWORD *)(v137 + 8) <= v9)
              goto LABEL_208;
            break;
          case 3:
            if (v129 && !v139._encoder)
            {
              v23 = -[SCNMTLRenderContext features]((uint64_t)RenderContext);
              SCNMTLComputeCommandEncoder::beginEncoding(&v139, v129, v23, 0, 0);
            }
            if (*(_WORD *)(C3D::Pass::descriptor(v13) + 6))
            {
              v24 = 0;
              do
              {
                *(_QWORD *)buf = &v139;
                *(_WORD *)&buf[8] = v24;
                (*(void (**)(C3D::Pass *, _BYTE *))(*(_QWORD *)v13 + 40))(v13, buf);
                ++v24;
              }
              while (v24 < *(unsigned __int16 *)(C3D::Pass::descriptor(v13) + 6));
            }
            PassInStage = (C3D::Pass *)C3D::__nextPassInStage(*(_QWORD *)(v3 + 24), v7, v10);
            if (v129 && (*(_QWORD *)(v3 + 168) || !PassInStage || *(_DWORD *)C3D::Pass::descriptor(PassInStage) != 3))
              SCNMTLComputeCommandEncoder::endEncoding(&v139);
            goto LABEL_167;
          case 4:
            if (v129 && !v138._encoder)
              SCNMTLBlitCommandEncoder::beginEncoding(&v138, v129, 0);
            if (*(_WORD *)(C3D::Pass::descriptor(v13) + 6))
            {
              v26 = 0;
              do
              {
                *(_QWORD *)buf = &v138;
                *(_WORD *)&buf[8] = v26;
                (*(void (**)(C3D::Pass *, _BYTE *))(*(_QWORD *)v13 + 48))(v13, buf);
                ++v26;
              }
              while (v26 < *(unsigned __int16 *)(C3D::Pass::descriptor(v13) + 6));
            }
            v27 = (C3D::Pass *)C3D::__nextPassInStage(*(_QWORD *)(v3 + 24), v7, v10);
            if (v129 && (!v27 || *(_DWORD *)C3D::Pass::descriptor(v27) != 4))
              SCNMTLBlitCommandEncoder::endEncoding(&v138);
            goto LABEL_167;
          case 5:
            (*(void (**)(C3D::Pass *))(*(_QWORD *)v13 + 24))(v13);
            goto LABEL_167;
          default:
            v17 = scn_default_log();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
              C3D::RenderGraph::execute(v142, &v143, v17);
            goto LABEL_167;
        }
      }
    }
LABEL_209:
    if (v128)
    {
      v131[0] = MEMORY[0x1E0C809B0];
      v131[1] = 3221225472;
      v131[2] = ___ZN3C3D11RenderGraph7executeEv_block_invoke;
      v131[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
      v131[4] = v128;
      objc_msgSend(v129, "addCompletedHandler:", v131);
    }
    *(_QWORD *)(v3 + 120) = 0;
    C3DStackAllocatorPopFrame(StackAllocator);
  }
}

void sub_1DCD10088(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  free(a21);
  _Unwind_Resume(a1);
}

uint64_t C3D::Pass::descriptor(C3D::Pass *this)
{
  return (uint64_t)this + 32;
}

uint64_t C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  int v6;
  int v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  unsigned int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) <= a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      v6 = *(_DWORD *)(a1 + 8);
      v7 = 136315906;
      v8 = "i < size()";
      v9 = 2048;
      v10 = a1;
      v11 = 1024;
      v12 = a2;
      v13 = 1024;
      v14 = v6;
      _os_log_fault_impl(&dword_1DCCB8000, v4, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Out of bound Array:%p access %d size %d", (uint8_t *)&v7, 0x22u);
    }
  }
  return *(_QWORD *)(a1 + 16) + 2 * a2;
}

_QWORD *C3D::Pass::outputTextureAtIndex(C3D::Pass *this, unsigned int a2)
{
  _QWORD *RenderContext;
  void **v5;
  void **v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  RenderContext = (_QWORD *)C3DEngineContextGetRenderContext(*((_QWORD *)this + 2));
  v5 = (void **)C3D::PassResource::outputAtIndex((C3D::Pass *)((char *)this + 80), a2);
  if (v5)
  {
    v6 = v5;
    v7 = *v5;
    v8 = C3D::PassDescriptor::outputAtIndex((C3D::Pass *)((char *)this + 32), a2);
    if (v7
      && (*(unsigned __int8 *)(v8 + 31) <= 1u ? (v9 = 1) : (v9 = *(unsigned __int8 *)(v8 + 31)),
          objc_msgSend(v7, "sampleCount") != v9))
    {
      if ((*((_BYTE *)v6 + 34) & 4) == 0)
        return v6[3];
    }
    else if ((*((_BYTE *)v6 + 34) & 2) == 0)
    {
      return *v6;
    }
    return -[SCNMTLRenderContext _finalRenderTexture](RenderContext);
  }
  else
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      C3D::Pass::outputTextureAtIndex(v11, v12, v13, v14, v15, v16, v17, v18);
    return 0;
  }
}

uint64_t C3D::PassResource::outputAtIndex(C3D::PassResource *this, unsigned int a2)
{
  NSObject *v4;

  if (*((unsigned __int16 *)this + 9) <= a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3D::PassResource::outputAtIndex();
  }
  return *(_QWORD *)(*((_QWORD *)this + 1) + 8 * a2);
}

_QWORD *C3D::RefCountedResource::resolveTextureOrFinal(C3D::RefCountedResource *this, SCNMTLRenderContext *a2)
{
  if ((*((_BYTE *)this + 34) & 4) != 0)
    return -[SCNMTLRenderContext _finalRenderTexture](a2);
  else
    return (_QWORD *)*((_QWORD *)this + 3);
}

uint64_t C3D::RenderGraph::matchingPortForNodes(uint64_t a1, uint64_t a2, C3D::Pass **a3, uint64_t a4)
{
  uint64_t StackAllocator;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  C3D::PassDescriptor *v10;
  uint64_t result;
  unsigned __int16 v12;
  unsigned __int8 v13;
  C3D::PassDescriptor *v14;
  C3D::PassIODescriptor *v15;
  C3D::PassDescriptor *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 v19;
  C3D::PassDescriptor *v20;
  PassIODescriptor *v21;
  _BYTE *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  _BOOL4 v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 v35;
  C3D::Pass *v36;
  char v37;
  int v38;
  C3D::Pass *v39;
  __int16 v40;
  uint64_t v41;
  size_t __n;
  void *__s;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v38 = *(_DWORD *)(a4 + 8);
  v39 = *(C3D::Pass **)a2;
  v36 = *a3;
  StackAllocator = C3DEngineContextGetStackAllocator(*(_QWORD *)(a1 + 8));
  C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(&v41, StackAllocator);
  v7 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v7)
  {
    v8 = *(_DWORD **)(a2 + 24);
    v9 = 4 * v7;
    do
    {
      if ((~*v8 & 0xFF0000) != 0)
      {
        LOBYTE(v40) = BYTE2(*v8);
        C3D::Array<unsigned char,16u,C3D::StackAllocator>::push_back<unsigned char>(&v41, &v40);
      }
      ++v8;
      v9 -= 4;
    }
    while (v9);
  }
  v10 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v36);
  result = C3D::PassDescriptor::outputCount(v10);
  v35 = result;
  if (!(_BYTE)result)
    return result;
  v12 = 0;
  v37 = 0;
  v13 = 0;
  do
  {
    v14 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v36);
    v15 = (C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex(v14, v12);
    v16 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v39);
    result = C3D::PassDescriptor::inputCount(v16);
    v17 = result;
    if (!(_BYTE)result)
      goto LABEL_42;
    v18 = 0;
    v19 = 0;
    while (1)
    {
      v20 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v39);
      v21 = (PassIODescriptor *)C3D::PassDescriptor::inputAtIndex(v20, v18);
      v22 = __s;
      v23 = __n;
      v24 = (char *)__s + __n;
      v25 = (char *)memchr(__s, (char)v19, __n);
      v26 = v25 ? v25 : v24;
      v27 = v26 - v22 == v23;
      result = C3D::PassIODescriptor::isMatching(v15, v21);
      if ((v27 & result) == 1)
        break;
LABEL_39:
      ++v19;
      if (++v18 == v17)
        goto LABEL_42;
    }
    if (v38)
    {
      if (!*(_DWORD *)(a4 + 8))
        goto LABEL_34;
      v28 = 0;
      do
      {
        if (*(unsigned __int8 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v28) == v19
          || (result = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v28),
              *(unsigned __int8 *)(result + 1) == v13))
        {
          result = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v28);
          *(_BYTE *)result = v19;
          *(_BYTE *)(result + 1) = v13;
          goto LABEL_39;
        }
        ++v28;
        v29 = *(unsigned int *)(a4 + 8);
      }
      while (v28 < v29);
      if (!(_DWORD)v29)
        goto LABEL_34;
      v30 = 0;
      v31 = 0;
      do
      {
        result = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v30);
        if (*(unsigned __int8 *)result == 255)
        {
          result = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v30);
          if (*(unsigned __int8 *)(result + 1) == 255)
          {
            result = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](a4, v30);
            *(_BYTE *)result = v19;
            *(_BYTE *)(result + 1) = v13;
            v31 = 1;
            v37 = 1;
          }
        }
        ++v30;
      }
      while (v30 < *(unsigned int *)(a4 + 8));
      if ((v31 & 1) == 0)
      {
LABEL_34:
        if ((v37 & 1) != 0)
        {
          LOBYTE(v40) = v19;
          HIBYTE(v40) = v13;
          result = (uint64_t)C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::push_back<C3D::RenderGraph::PortsPair&>((_DWORD *)a4, &v40);
        }
      }
      goto LABEL_39;
    }
    v32 = *(unsigned int *)(a4 + 8);
    if ((_DWORD)v32)
    {
      v33 = 2 * v32;
      v34 = *(unsigned __int8 **)(a4 + 16);
      while (*v34 != v19 && v34[1] != v13)
      {
        v34 += 2;
        v33 -= 2;
        if (!v33)
          goto LABEL_41;
      }
    }
    else
    {
      v34 = *(unsigned __int8 **)(a4 + 16);
    }
    if (v34 != (unsigned __int8 *)(*(_QWORD *)(a4 + 16) + 2 * v32))
      goto LABEL_39;
LABEL_41:
    LOBYTE(v40) = v19;
    HIBYTE(v40) = v13;
    result = (uint64_t)C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::push_back<C3D::RenderGraph::PortsPair&>((_DWORD *)a4, &v40);
LABEL_42:
    v12 = ++v13;
  }
  while (v13 < v35);
  return result;
}

BOOL C3D::PassIODescriptor::isMatching(C3D::PassIODescriptor *this, PassIODescriptor *a2)
{
  const char *v4;
  const char *v5;

  return *(unsigned __int8 *)this == *(_BYTE *)a2
      && *((unsigned __int8 *)this + 64) == *((unsigned __int8 *)a2 + 64)
      && ((v4 = (const char *)*((_QWORD *)this + 1)) == 0
       || (v5 = (const char *)*((_QWORD *)a2 + 1)) == 0
       || !strcmp(v4, v5))
      && C3D::PassIODescriptor::isPartiallyCompatible(this, a2);
}

_QWORD *C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(_QWORD *a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = a2;
  a1[1] = 0x1000000000;
  a1[2] = a1 + 3;
  if (!a2)
  {
    v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      C3D::__deduceMemoryLess(v3, v4, v5);
  }
  return a1;
}

_DWORD *C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::push_back<C3D::RenderGraph::PortsPair&>(_DWORD *result, _WORD *a2)
{
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  const void *v6;
  unsigned int v7;
  void *Aligned;

  v3 = result;
  v4 = result[2];
  v5 = result[3];
  v6 = (const void *)*((_QWORD *)result + 2);
  if (v4 + 1 > v5)
  {
    v7 = ((double)(v5 + 1) * 1.5);
    Aligned = C3DStackAllocatorAllocateAligned(*(_QWORD *)result, 2 * v7, 1, 0);
    result = memcpy(Aligned, v6, 2 * v3[2]);
    *((_QWORD *)v3 + 2) = Aligned;
    v3[3] = v7;
    v6 = Aligned;
    v4 = v3[2];
  }
  *((_WORD *)v6 + v4) = *a2;
  ++v3[2];
  return result;
}

uint64_t C3D::__deduceStoreAction(uint64_t a1, void *a2, int a3, unint64_t a4, uint64_t a5, unsigned __int8 a6)
{
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  char *Aligned;
  uint64_t v16;
  char v17;
  char v18;
  char *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v28;
  uint64_t v29;
  __n128 v30;
  __n128 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;

  if (!SCNMTLTextureTypeIsMultisampled(objc_msgSend((id)objc_msgSend(a2, "texture"), "textureType")))
    return 1;
  if (a3 == 2 && !C3DEngineContextHasFeatures(*(_QWORD *)(a1 + 8), 4))
    return 0;
  v33 = a5;
  v34 = 0;
  v35 = (char *)&v36;
  if (!a5)
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      C3D::__deduceMemoryLess(v12, v13, v14);
  }
  Aligned = (char *)C3DStackAllocatorAllocateAligned(v33, (16 * (HIDWORD(v34) + 10)), 8, 0);
  memcpy(Aligned, v35, 16 * v34);
  v35 = Aligned;
  HIDWORD(v34) += 10;
  v31.n128_u64[0] = a4;
  v31.n128_u8[8] = a6;
  C3D::Array<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair,0u,C3D::StackAllocator>::push_back<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair>((uint64_t)&v33, &v31);
  v16 = v34;
  if ((_DWORD)v34)
  {
    v17 = 0;
    v18 = 0;
    do
    {
      v19 = &v35[16 * v16];
      v20 = *((_QWORD *)v19 - 2);
      v21 = *(v19 - 8);
      LODWORD(v34) = v34 - 1;
      C3D::RenderGraph::GraphNode::successorsAtIndex(v20, v21, a5, &v31);
      if (v31.n128_u32[2])
      {
        v22 = v32;
        v23 = 4 * v31.n128_u32[2];
        while (1)
        {
          v24 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(a1 + 24), *(_DWORD *)v22 & 0x7FFF);
          v25 = C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*(_QWORD *)v24 + 32), *(unsigned __int8 *)(v22 + 3));
          v26 = *(unsigned __int8 *)(v25 + 31);
          v18 |= v26 > 1;
          v17 |= v26 < 2;
          if ((v18 & 1) != 0 && (v17 & 1) != 0)
            break;
          if ((*(_WORD *)(v25 + 66) & 0x80) != 0)
          {
            v30.n128_u64[0] = v24;
            v30.n128_u8[8] = *(_BYTE *)(v22 + 3);
            C3D::Array<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair,0u,C3D::StackAllocator>::push_back<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair>((uint64_t)&v33, &v30);
          }
          v22 += 4;
          v23 -= 4;
          if (!v23)
            goto LABEL_18;
        }
        v18 = 1;
        v17 = 1;
      }
LABEL_18:
      v16 = v34;
    }
    while ((_DWORD)v34);
  }
  else
  {
    v18 = 0;
    v17 = 0;
  }
  v28 = v18 & (objc_msgSend((id)objc_msgSend(a2, "texture"), "storageMode") != 3);
  v29 = 2;
  if ((v17 & 1 & v28) != 0)
    v29 = 3;
  if ((v17 & 1) != 0)
    return v29;
  else
    return v28;
}

BOOL SCNMTLTextureTypeIsMultisampled(uint64_t a1)
{
  return a1 == 4 || a1 == 8;
}

__n128 C3D::Array<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair,0u,C3D::StackAllocator>::push_back<C3D::__deduceStoreAction(C3D::RenderGraph *,MTLRenderPassAttachmentDescriptor *,C3D::TextureAttachmentType,C3D::RenderGraph::GraphNode const&,__C3DStackAllocator *,unsigned char)::NodeOutputPair>(uint64_t a1, __n128 *a2)
{
  int v4;
  unsigned int v5;
  __n128 *v6;
  unsigned int v7;
  __n128 *Aligned;
  __n128 result;

  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_DWORD *)(a1 + 12);
  v6 = *(__n128 **)(a1 + 16);
  if (v4 + 1 > v5)
  {
    v7 = ((double)(v5 + 1) * 1.5);
    Aligned = (__n128 *)C3DStackAllocatorAllocateAligned(*(_QWORD *)a1, 16 * v7, 8, 0);
    memcpy(Aligned, v6, 16 * *(unsigned int *)(a1 + 8));
    *(_QWORD *)(a1 + 16) = Aligned;
    *(_DWORD *)(a1 + 12) = v7;
    v6 = Aligned;
    v4 = *(_DWORD *)(a1 + 8);
  }
  result = *a2;
  v6[v4] = *a2;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void C3D::__renderSlice(_QWORD *a1, C3D::Pass *a2, _WORD *a3, _DWORD *a4, uint64_t *a5, uint64_t a6, int a7, uint64_t *a8)
{
  uint64_t v10;
  void *v11;
  uint64_t v12;
  C3D::PassDescriptor *v13;
  unsigned int v14;
  C3D::PassDescriptor *v15;
  C3D::PassDescriptor *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _BOOL4 v20;
  C3D::PassDescriptor *v21;
  int v22;
  C3D::PassDescriptor *v23;
  uint64_t v24;
  _BOOL4 v25;
  _BOOL4 v26;
  NSObject *v27;
  C3D::PassDescriptor *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  __int16 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  uint64_t v43;
  double v44;
  unsigned __int8 **v45;
  uint64_t v46;
  uint64_t v47;
  unsigned __int16 *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned __int8 v51;
  _DWORD *v52;
  uint64_t v53;
  unsigned __int8 *v54;
  int v55;
  int v56;
  int v57;
  unsigned __int16 v58;
  int v59;
  int v60;
  __int16 v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  unsigned int *v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  __int16 v70;
  int v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  C3D::PassIODescriptor *v76;
  NSObject *v77;
  NSObject *v78;
  int v79;
  int v80;
  unsigned int v81;
  char v82;
  C3D::Pass *v83;
  unsigned int v84;
  __int16 v85;
  unsigned int v86;
  __int16 v87;
  uint64_t v88;
  unsigned __int16 v89;
  unsigned int v90;
  unsigned __int16 v91;
  unsigned int v92;
  uint64_t v94;
  unsigned __int8 v98;
  uint64_t StackAllocator;
  unsigned __int8 *v102;
  id *RenderContext;
  uint64_t v104;
  unsigned int v105;
  _DWORD *v106;
  uint8_t v107[4];
  uint64_t v108;
  uint8_t v109[4];
  uint64_t v110;
  uint8_t v111[4];
  _DWORD v112[3];
  uint64_t v113;

  v113 = *MEMORY[0x1E0C80C00];
  v10 = a1[1];
  RenderContext = (id *)C3DEngineContextGetRenderContext(v10);
  v12 = *(_QWORD *)a6;
  v11 = *(void **)(a6 + 8);
  StackAllocator = C3DEngineContextGetStackAllocator(v10);
  v13 = (C3D::PassDescriptor *)C3D::Pass::descriptor(a2);
  v102 = (unsigned __int8 *)a2;
  if (C3D::PassDescriptor::outputCount(v13))
  {
    v14 = 0;
    do
    {
      v15 = (C3D::PassDescriptor *)C3D::Pass::descriptor(a2);
      if (*(_BYTE *)C3D::PassDescriptor::outputAtIndex(v15, (unsigned __int16)v14) == 1)
      {
        v16 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v102);
        v17 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex(v16, (unsigned __int16)v14) + 24);
        if (SCNMTLTextureTypeIsArray(v17) || SCNMTLTextureTypeIsCube(v17))
        {
          v18 = *(unsigned __int16 *)(a6 + 16);
          LODWORD(v19) = v18;
        }
        else
        {
          LODWORD(v19) = 0;
          v18 = *(unsigned __int16 *)(a6 + 16);
        }
        if (v18)
          v20 = v102[120] != 0;
        else
          v20 = 0;
        v21 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v102);
        v22 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex(v21, (unsigned __int16)v14) + 64);
        switch(v22)
        {
          case 3:
            v25 = objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "resolveTexture") == 0;
            objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "setSlice:", v19);
            objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "setLevel:", *(unsigned __int16 *)(a6 + 18));
            if (v25)
              v19 = 0;
            else
              v19 = v19;
            objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "setResolveSlice:", v19);
            if (v20 && objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "loadAction") == 2)
              objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "setLoadAction:", 0);
            break;
          case 2:
            v26 = objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "resolveTexture") == 0;
            objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "setSlice:", v19);
            objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "setLevel:", *(unsigned __int16 *)(a6 + 18));
            if (v26)
              v19 = 0;
            else
              v19 = v19;
            objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "setResolveSlice:", v19);
            if (v20 && objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "loadAction") == 2)
              objc_msgSend((id)objc_msgSend(v11, "depthAttachment"), "setLoadAction:", 0);
            break;
          case 1:
            v23 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v102);
            v24 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex(v23, (unsigned __int16)v14) + 65);
            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "setSlice:", v19);
            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "setLevel:", *(unsigned __int16 *)(a6 + 18));
            if (objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "resolveTexture"))
            {
              v19 = v19;
            }
            else
            {
              v19 = 0;
            }
            objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "setResolveSlice:", v19);
            if (v20
              && objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "loadAction") == 2)
            {
              objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "colorAttachments"), "objectAtIndexedSubscript:", v24), "setLoadAction:", 0);
            }
            break;
          default:
            v27 = scn_default_log();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              C3D::__renderSlice(v111, v112, v27);
            break;
        }
      }
      v28 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v102);
      ++v14;
      a2 = (C3D::Pass *)v102;
    }
    while (v14 < C3D::PassDescriptor::outputCount(v28));
  }
  v94 = objc_msgSend((id)objc_msgSend(v11, "stencilAttachment"), "texture");
  v29 = -[SCNMTLRenderContext frameConstantBufferPool]((uint64_t)RenderContext);
  v30 = (void *)-[SCNMTLRenderContext currentCommandBuffer]((uint64_t)RenderContext);
  if (-[SCNMTLRenderContext clientRenderCommandEncoder]((uint64_t)RenderContext))
  {
    if (a7)
    {
      v31 = -[SCNMTLRenderContext clientCommandBuffer]((uint64_t)RenderContext);
      if (v31)
        v30 = (void *)v31;
      v32 = -[SCNMTLRenderContext clientRenderCommandEncoder]((uint64_t)RenderContext);
      SCNMTLRenderCommandEncoder::useCommandEncoder((char *)v12, (uint64_t)v30, v32, v29);
    }
    else
    {
      v34 = (void *)*a8;
      if (!*a8)
      {
        v34 = (void *)objc_msgSend((id)-[SCNMTLRenderContext commandQueue]((uint64_t)RenderContext), "commandBuffer");
        *a8 = (uint64_t)v34;
      }
      SCNMTLRenderCommandEncoder::useCommandEncoder((char *)v12, *a8, objc_msgSend(v34, "renderCommandEncoderWithDescriptor:", v11), v29);
    }
  }
  else
  {
    if (-[SCNMTLRenderContext commandBufferStatusMonitor](RenderContext))
      v33 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", (**(uint64_t (***)(unsigned __int8 *))v102)(v102));
    else
      v33 = 0;
    bzero((void *)v12, 0xD70uLL);
    *(_DWORD *)(v12 + 64) = 1;
    *(_BYTE *)(v12 + 72) = 1;
    *(_QWORD *)(v12 + 3384) = v30;
    v35 = (void *)objc_msgSend(v30, "renderCommandEncoderWithDescriptor:", v11);
    *(_QWORD *)(v12 + 3392) = v35;
    *(_QWORD *)(v12 + 3400) = v29;
    if (v33)
      objc_msgSend(v35, "setLabel:", v33);
    *(_OWORD *)(v12 + 24) = 0u;
    *(_OWORD *)(v12 + 8) = 0u;
  }
  v36 = *(unsigned __int8 *)(a6 + 16);
  v37 = *(_WORD *)(C3D::Pass::descriptor((C3D::Pass *)v102) + 6);
  v38 = v102[117];
  v39 = v102[118];
  v40 = (*(uint64_t (**)(unsigned __int8 *))(*(_QWORD *)v102 + 64))(v102);
  v41 = a1[14];
  if (v41)
  {
    v42 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v41 + 64))(v41) != v40;
    v43 = 0x100000000;
    if (v42)
      v43 = 0;
  }
  else
  {
    v43 = 0;
  }
  -[SCNMTLRenderContext beginRenderPass:renderEncoder:parameters:]((uint64_t)RenderContext, v11, v12, v43 | (v39 << 24) | (v38 << 16) | ((unint64_t)v37 << 8) | v36);
  C3D::__setupRenderEncoder((uint64_t)RenderContext, (C3D::RenderPass *)v102, a6, v12);
  C3D::RenderPass::setStates(v102, (_QWORD *)a6);
  (*(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)v102 + 32))(v102, a6);
  v45 = 0;
  v46 = *a5;
  while (1)
  {
    v47 = *(_QWORD *)(v46 + 24);
    if (!v47)
      goto LABEL_120;
    v48 = (unsigned __int16 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](v47, 0);
    v49 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](a1[3], *v48);
    if (v94)
      goto LABEL_121;
    v45 = (unsigned __int8 **)v49;
    v50 = (uint64_t)a4;
    if (a4[10])
      break;
LABEL_64:
    if (*(_DWORD *)(*a5 + 8) - 1 != (unsigned __int16)*a3)
      goto LABEL_121;
    if (*((_DWORD *)*v45 + 8) != 2)
      goto LABEL_121;
    v55 = *(unsigned __int16 *)(a6 + 16);
    if (*(unsigned __int16 *)(C3D::Pass::descriptor((C3D::Pass *)v102) + 6) - 1 != v55
      && !*(_BYTE *)C3D::RenderPass::getRenderMode((C3D::RenderPass *)v102))
    {
      goto LABEL_121;
    }
    v56 = *(unsigned __int16 *)(a6 + 18);
    v57 = *(unsigned __int16 *)(C3D::Pass::descriptor((C3D::Pass *)v102) + 8);
    if (v57 + *(unsigned __int16 *)(C3D::Pass::descriptor((C3D::Pass *)v102) + 10) - 1 != v56)
      goto LABEL_121;
    if (!C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*v45 + 32)))
      goto LABEL_121;
    v58 = 0;
    v59 = 0;
    v60 = 0;
    do
    {
      v61 = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*v45 + 32), v58) + 66);
      v62 = C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*v45 + 32));
      v60 += (v61 & 0x80) >> 7;
      v58 = ++v59;
    }
    while (v62 > v59);
    if (!(_BYTE)v60)
      goto LABEL_121;
    if (C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(_QWORD *)a4 + 32)) < v60)
      goto LABEL_121;
    v63 = C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*v45 + 32));
    if (v63 > C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(_QWORD *)a4 + 32)))
      goto LABEL_121;
    if (a4[10])
    {
      v64 = 0;
      v65 = 0;
      do
      {
        v66 = (unsigned int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)(a4 + 8), v64);
        v67 = *v66;
        if ((unsigned __int8 **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](a1[3], *v66 & 0x7FFF) == v45&& (*(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(_QWORD *)a4 + 32), BYTE2(v67))+ 66) & 0x80) != 0&& (*(_WORD *)(C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*v45 + 32), HIBYTE(v67)) + 66) & 0x80) == 0)
        {
          goto LABEL_121;
        }
        v64 = ++v65;
      }
      while (a4[10] > v65);
    }
    if (C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*v45 + 32)))
    {
      v68 = 0;
      v98 = 0;
      while (1)
      {
        v69 = C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*v45 + 32), (unsigned __int16)v68);
        v70 = *(_WORD *)(v69 + 66);
        if ((v70 & 0x80) != 0)
        {
          v73 = C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*v45 + 32), (unsigned __int16)v68);
          v74 = *(_QWORD *)a4;
          C3D::RenderGraph::GraphNode::predecessorsAtIndex((uint64_t)v45, v68, StackAllocator, &v104);
          v75 = C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v104, 0);
          v76 = (C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(v74 + 32), *(unsigned __int8 *)(v75 + 3));
          if (*((_BYTE *)v76 + 31) == 1)
          {
            v77 = scn_default_log();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
              C3D::__renderSlice(v109, &v110, v77);
          }
          if (*(_BYTE *)(v73 + 31) == 1)
          {
            v78 = scn_default_log();
            if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
              C3D::__renderSlice(v107, &v108, v78);
          }
          v79 = *((unsigned __int8 *)v76 + 31);
          v80 = *(unsigned __int8 *)(v73 + 31);
          if (!C3D::PassIODescriptor::isPartiallyCompatible(v76, (const PassIODescriptor *)v73)
            || *(unsigned __int8 *)(v73 + 65) != *((unsigned __int8 *)v76 + 65))
          {
            goto LABEL_108;
          }
          v72 = 0;
          if ((*(_WORD *)(v73 + 66) & 3) != 1 || v79 != v80)
            goto LABEL_109;
          ++v98;
        }
        else if ((v70 & 3) == 2
               && C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(_QWORD *)a4 + 32)))
        {
          v71 = 0;
          while (*(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(_QWORD *)a4 + 32), v71)+ 64) != *(unsigned __int8 *)(v69 + 64)|| *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(_QWORD *)a4 + 32), v71)+ 65) != *(unsigned __int8 *)(v69 + 65))
          {
            if (++v71 >= C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*(_QWORD *)a4 + 32)))
              goto LABEL_90;
          }
          v72 = 1;
        }
        else
        {
LABEL_90:
          v72 = 0;
        }
        v81 = C3D::PassDescriptor::outputCount((C3D::PassDescriptor *)(*v45 + 32));
        ++v68;
        v82 = v72 ^ 1;
        if (v68 >= v81)
          v82 = 0;
        if ((v82 & 1) == 0)
          goto LABEL_109;
      }
    }
    v98 = 0;
LABEL_108:
    v72 = 0;
LABEL_109:
    if ((v72 & 1) != 0 || v98 != v60)
      goto LABEL_121;
    v83 = (C3D::Pass *)*v45;
    a1[15] = *v45;
    v84 = *(unsigned __int16 *)(C3D::Pass::descriptor(v83) + 10);
    if (v84 <= 1)
      v85 = 1;
    else
      v85 = v84;
    v86 = *(unsigned __int16 *)(C3D::Pass::descriptor(v83) + 8);
    v87 = *(_WORD *)(C3D::Pass::descriptor(v83) + 6);
    v88 = C3D::Pass::descriptor(v83);
    v89 = v86 + v85;
    if (v86 < v89)
    {
      v90 = *(unsigned __int16 *)(v88 + 4);
      v91 = v90 + v87;
      do
      {
        v92 = v90;
        if (v90 < v91)
        {
          do
          {
            *(_WORD *)(a6 + 16) = v92;
            *(_WORD *)(a6 + 18) = v86;
            C3D::__setupRenderEncoder((uint64_t)RenderContext, v83, a6, v12);
            C3D::RenderPass::setStates(*v45, (_QWORD *)a6);
            (*(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)*v45 + 32))(*v45, a6);
            ++v92;
          }
          while ((unsigned __int16)v92 < v91);
        }
        ++v86;
      }
      while ((unsigned __int16)v86 < v89);
    }
    v46 = *(_QWORD *)(*a5 + 24);
    *a5 = v46;
    *a3 = 0;
LABEL_120:
    if (!v45)
      goto LABEL_121;
  }
  v51 = 0;
  while (1)
  {
    C3D::RenderGraph::GraphNode::successorsAtIndex(v50, v51, StackAllocator, &v104);
    if (v105)
      break;
LABEL_63:
    ++v51;
    v50 = (uint64_t)a4;
    if (a4[10] <= v51)
      goto LABEL_64;
  }
  v52 = v106;
  v53 = 4 * v105;
  while (1)
  {
    v54 = *v45;
    if (v54 != *(unsigned __int8 **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](a1[3], *v52 & 0x7FFF))break;
    ++v52;
    v53 -= 4;
    if (!v53)
      goto LABEL_63;
  }
LABEL_121:
  if (*(_QWORD *)(v12 + 3392)
    && (!-[SCNMTLRenderContext clientRenderCommandEncoder]((uint64_t)RenderContext) || (a7 & 1) == 0))
  {
    v44 = SCNMTLRenderCommandEncoder::endEncoding((SCNMTLRenderCommandEncoder *)v12);
  }
  if (a7 && *a8)
  {
    objc_msgSend((id)*a8, "commit", v44);
    *a8 = 0;
  }
  -[SCNMTLRenderContext endRenderPass]((uint64_t)RenderContext);
}

unint64_t C3D::RenderPass::hashName(C3D::RenderPass *this)
{
  unint64_t v2;
  C3D::PassDescriptor *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = C3D::Pass::hashName(this);
  v3 = (C3D::RenderPass *)((char *)this + 32);
  if (C3D::PassDescriptor::outputCount(v3))
  {
    v4 = 0;
    do
    {
      v5 = C3D::PassDescriptor::outputAtIndex(v3, v4);
      if (*(_BYTE *)v5 == 1 && *(unsigned __int8 *)(v5 + 65) != 255)
      {
        v6 = *(unsigned __int8 *)(v5 + 31);
        v7 = 0xC6A4A7935BD1E995 * (v2 ^ 0x8D494F26B7A3D32ALL ^ *(unsigned __int16 *)(v5 + 28));
        v2 = (0xC6A4A7935BD1E995 * (v7 ^ (v7 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v7 ^ (v7 >> 47))) >> 47);
        if (v6 >= 2)
        {
          v8 = 0xC6A4A7935BD1E995
             * ((0xC6A4A7935BD1E995 * (v2 ^ v6 ^ 0xC6A4A7935BD1E995)) ^ ((0xC6A4A7935BD1E995
                                                                            * (v2 ^ v6 ^ 0xC6A4A7935BD1E995)) >> 47));
          v2 = v8 ^ (v8 >> 47);
        }
      }
      ++v4;
    }
    while (v4 < C3D::PassDescriptor::outputCount(v3));
  }
  return v2;
}

uint64_t C3D::PassDescriptor::outputAtIndex(C3D::PassDescriptor *this, unsigned int a2)
{
  NSObject *v4;

  if (*((unsigned __int16 *)this + 21) <= a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3D::PassDescriptor::outputAtIndex();
  }
  return *((_QWORD *)this + 4) + 80 * a2;
}

uint64_t C3D::PassDescriptor::outputCount(C3D::PassDescriptor *this)
{
  return *((unsigned __int16 *)this + 21);
}

unint64_t C3D::Pass::hashName(C3D::Pass *this)
{
  unsigned __int8 *v2;
  const char *v3;
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = (unsigned __int8 *)(**(uint64_t (***)(C3D::Pass *))this)(this);
  v3 = (const char *)(**(uint64_t (***)(C3D::Pass *))this)(this);
  v4 = strlen(v3);
  v5 = 0xC6A4A7935BD1E995 * v4;
  if (v4 >= 8)
  {
    v6 = v4 >> 3;
    v7 = &v2[8 * v6];
    v8 = 8 * v6;
    do
    {
      v9 = *(_QWORD *)v2;
      v2 += 8;
      v5 = 0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v9) ^ ((0xC6A4A7935BD1E995 * v9) >> 47))) ^ v5);
      v8 -= 8;
    }
    while (v8);
    v2 = v7;
  }
  switch(v4 & 7)
  {
    case 1u:
      goto LABEL_12;
    case 2u:
      goto LABEL_11;
    case 3u:
      goto LABEL_10;
    case 4u:
      goto LABEL_9;
    case 5u:
      goto LABEL_8;
    case 6u:
      goto LABEL_7;
    case 7u:
      v5 ^= (unint64_t)v2[6] << 48;
LABEL_7:
      v5 ^= (unint64_t)v2[5] << 40;
LABEL_8:
      v5 ^= (unint64_t)v2[4] << 32;
LABEL_9:
      v5 ^= (unint64_t)v2[3] << 24;
LABEL_10:
      v5 ^= (unint64_t)v2[2] << 16;
LABEL_11:
      v5 ^= (unint64_t)v2[1] << 8;
LABEL_12:
      v5 = 0xC6A4A7935BD1E995 * (v5 ^ *v2);
      break;
    default:
      return (0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) >> 47);
  }
  return (0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) >> 47);
}

const char *C3D::MainPass::name(C3D::MainPass *this)
{
  return "MainPass";
}

BOOL SCNMTLTextureTypeIsCube(uint64_t a1)
{
  return (unint64_t)(a1 - 5) < 2;
}

BOOL SCNMTLTextureTypeIsArray(uint64_t a1)
{
  return a1 == 6 || (a1 & 0xFFFFFFFFFFFFFFFDLL) == 1;
}

void C3D::__setupRenderEncoder(uint64_t a1, C3D::RenderPass *this, uint64_t a3, uint64_t a4)
{
  int v8;
  NSObject *v14;
  int32x2_t v15;
  void *v16;
  void *v17;
  uint32x2_t v18;
  __int128 v19;
  __int128 v20;
  uint32x2_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  float32x2_t v31;
  void *v32;
  uint32x2_t v33;
  __int128 v34;
  NSObject *v35;
  uint64_t v36;
  _OWORD *v37;
  float32x4_t v38;
  uint64_t v39;
  _OWORD *v40;
  float32x4_t v42;
  NSObject *v43;
  _BOOL4 v44;
  uint64_t v45;
  uint64x2_t v46;
  uint64x2_t *v47;
  float64x2_t *v48;
  uint64_t v49;
  uint64x2_t v50;
  float64x2_t v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  _OWORD *v55;
  float v56;
  uint64_t v57;
  float32x4_t v58;
  uint64_t v59;
  uint64_t v60;
  float32x4_t *v61;
  __n128 ViewportAtIndex;
  float32x4_t v63;
  uint64x2_t v64;
  uint64x2_t *v65;
  float64x2_t *v66;
  uint64_t v67;
  uint64x2_t v68;
  float64x2_t v69;
  void *v70;
  NSObject *v71;
  uint64_t v72;
  _OWORD *v73;
  float32x4_t v74;
  uint64_t v75;
  uint64_t v76;
  _OWORD *v77;
  float32x4_t v79;
  NSObject *v80;
  _BOOL4 v81;
  float32x4_t v82;
  uint64_t v83;
  uint64x2_t *v84;
  float64x2_t *v85;
  uint64x2_t v86;
  float64x2_t v87;
  uint64_t v88;
  _OWORD *v89;
  float v90;
  uint64_t v91;
  float32x4_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  float32x4_t *v96;
  __n128 v97;
  float32x4_t v98;
  uint64x2_t *v99;
  float64x2_t *v100;
  uint64x2_t v101;
  float64x2_t v102;
  int v103;
  float32x4_t v104;
  float32x4_t v105;
  __int128 v106;
  float32x4_t v107;
  __n128 v108;
  _BYTE buf[32];
  __int128 v110;
  uint64_t v111;

  v111 = *MEMORY[0x1E0C80C00];
  v8 = *(unsigned __int8 *)C3D::RenderPass::getRenderMode(this);
  switch(v8)
  {
    case 2:
      v23 = C3D::Pass::descriptor(this);
      v24 = *(unsigned __int8 *)(v23 + 6);
      v25 = *((unsigned __int8 *)this + 118);
      if (v25 == 1)
      {
        *(_DWORD *)(a4 + 64) = v24;
      }
      else if (v25 == 2)
      {
        v23 = SCNMTLRenderCommandEncoder::setVertexAmplificationCount(a4, v24, 2);
      }
      else
      {
        v35 = scn_default_log();
        v23 = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
        if ((_DWORD)v23)
          C3D::__setupRenderEncoder();
      }
      if (*((_BYTE *)this + 121))
      {
        MEMORY[0x1E0C80A78](v23);
        v37 = (_OWORD *)&v104.f32[-4 * v36];
        v38.f32[0] = ldexpf(1.0, *(unsigned __int16 *)(a3 + 18));
        if ((_DWORD)v24)
        {
          v39 = 0;
          v40 = v37 + 1;
          __asm { FMOV            V1.4S, #-1.0 }
          v107 = _Q1;
          _Q1.i64[1] = 0x3FF0000000000000;
          v106 = xmmword_1DD008310;
          _Q1.i64[0] = 136315650;
          v38.f32[0] = 1.0 / v38.f32[0];
          v104 = _Q1;
          v105 = v38;
          do
          {
            v42 = *((float32x4_t *)this + v39 + 8);
            if ((vminvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v42, v107))) & 0x80000000) == 0)
            {
              v108 = *((__n128 *)this + v39 + 8);
              v43 = scn_default_log();
              v44 = os_log_type_enabled(v43, OS_LOG_TYPE_FAULT);
              v42 = (float32x4_t)v108;
              if (v44)
              {
                v45 = (**(uint64_t (***)(C3D::RenderPass *))this)(this);
                *(_DWORD *)buf = v104.i32[0];
                *(_QWORD *)&buf[4] = "simd_all(viewport != -1)";
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = v45;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = v39;
                _os_log_fault_impl(&dword_1DCCB8000, v43, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Pass %s has specific viewport but it's not specified for index : %d", buf, 0x1Cu);
                v42 = (float32x4_t)v108;
              }
            }
            v38 = vmulq_n_f32(v42, v105.f32[0]);
            *(v40 - 1) = vcvtq_f64_f32(*(float32x2_t *)v38.f32);
            *v40 = vcvt_hight_f64_f32(v38);
            v38.i64[0] = v106;
            v40[1] = v106;
            ++v39;
            v40 += 3;
          }
          while (v24 != v39);
        }
        objc_msgSend(*(id *)(a4 + 3392), "setViewports:count:", v37, v24, *(double *)v38.i64, *(_OWORD *)&v104);
        if (-[SCNMTLRenderContext clientRenderPassDescriptor](a1))
          break;
        *(double *)v46.i64 = MEMORY[0x1E0C80A78](0);
        if ((_DWORD)v24)
        {
          v47 = (uint64x2_t *)(&v104 - 2 * v24 + 1);
          v48 = (float64x2_t *)(v37 + 1);
          v49 = v24;
          do
          {
            v50 = vcvtq_u64_f64(v48[-1]);
            v51 = *v48;
            v48 += 3;
            v46 = vcvtq_u64_f64(v51);
            v47[-1] = v50;
            *v47 = v46;
            v47 += 2;
            --v49;
          }
          while (v49);
        }
        v52 = *(void **)(a4 + 3392);
LABEL_60:
        objc_msgSend(v52, "setScissorRects:count:", *(double *)v46.i64);
        break;
      }
      if (!*((_BYTE *)this + 120))
        break;
      v53 = v24;
      MEMORY[0x1E0C80A78](v23);
      v55 = (_OWORD *)&v104.f32[-4 * v54];
      v56 = ldexpf(1.0, *(unsigned __int16 *)(a3 + 18));
      v57 = -[SCNMTLRenderContext engineContext](a1);
      if ((_DWORD)v24)
      {
        v59 = v57;
        v60 = 0;
        v61 = (float32x4_t *)(v55 + 2);
        v58.f32[0] = 1.0 / v56;
        v107 = v58;
        v108 = (__n128)xmmword_1DD008310;
        do
        {
          ViewportAtIndex = C3DEngineContextGetViewportAtIndex(v59, v60);
          v63 = vmulq_n_f32((float32x4_t)ViewportAtIndex, v107.f32[0]);
          v61[-2] = (float32x4_t)vcvtq_f64_f32(*(float32x2_t *)v63.f32);
          v61[-1] = (float32x4_t)vcvt_hight_f64_f32(v63);
          *v61 = (float32x4_t)v108;
          v61 += 3;
          ++v60;
        }
        while (v53 != v60);
      }
      objc_msgSend(*(id *)(a4 + 3392), "setViewports:count:", v55, v53);
      if (-[SCNMTLRenderContext clientRenderPassDescriptor](a1))
        break;
      *(double *)v64.i64 = MEMORY[0x1E0C80A78](0);
      if ((_DWORD)v53)
      {
        v65 = (uint64x2_t *)(&v104 - 2 * v53 + 1);
        v66 = (float64x2_t *)(v55 + 1);
        v67 = v53;
        do
        {
          v68 = vcvtq_u64_f64(v66[-1]);
          v69 = *v66;
          v66 += 3;
          v64 = vcvtq_u64_f64(v69);
          v65[-1] = v68;
          *v65 = v64;
          v65 += 2;
          --v67;
        }
        while (v67);
      }
      v70 = *(void **)(a4 + 3392);
LABEL_71:
      objc_msgSend(v70, "setScissorRects:count:", *(double *)v64.i64);
      break;
    case 1:
      v26 = objc_msgSend(*(id *)(a3 + 8), "renderTargetArrayLength");
      v27 = v26;
      v28 = *((unsigned __int8 *)this + 118);
      if (v28 == 1)
      {
        *(_DWORD *)(a4 + 64) = v26;
      }
      else if (v28 == 2)
      {
        v26 = SCNMTLRenderCommandEncoder::setVertexAmplificationCount(a4, v26, 1);
      }
      else
      {
        v71 = scn_default_log();
        v26 = os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
        if ((_DWORD)v26)
          C3D::__setupRenderEncoder();
      }
      if (*((_BYTE *)this + 121))
      {
        MEMORY[0x1E0C80A78](v26);
        v73 = (_OWORD *)&v104.f32[-4 * v72];
        v74.f32[0] = ldexpf(1.0, *(unsigned __int16 *)(a3 + 18));
        v75 = v27;
        if ((_BYTE)v27)
        {
          v76 = 0;
          v77 = v73 + 1;
          __asm { FMOV            V1.4S, #-1.0 }
          v107 = _Q1;
          _Q1.i64[1] = 0x3FF0000000000000;
          v106 = xmmword_1DD008310;
          _Q1.i64[0] = 136315650;
          v74.f32[0] = 1.0 / v74.f32[0];
          v104 = _Q1;
          v105 = v74;
          do
          {
            v79 = *((float32x4_t *)this + v76 + 8);
            if ((vminvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v79, v107))) & 0x80000000) == 0)
            {
              v108 = *((__n128 *)this + v76 + 8);
              v80 = scn_default_log();
              v81 = os_log_type_enabled(v80, OS_LOG_TYPE_FAULT);
              v79 = (float32x4_t)v108;
              if (v81)
              {
                v83 = (**(uint64_t (***)(C3D::RenderPass *))this)(this);
                *(_DWORD *)buf = v104.i32[0];
                *(_QWORD *)&buf[4] = "simd_all(viewport != -1)";
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = v83;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = v76;
                _os_log_fault_impl(&dword_1DCCB8000, v80, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Pass %s has specific viewport but it's not specified for index : %d", buf, 0x1Cu);
                v79 = (float32x4_t)v108;
              }
            }
            v82 = vmulq_n_f32(v79, v105.f32[0]);
            *(v77 - 1) = vcvtq_f64_f32(*(float32x2_t *)v82.f32);
            *v77 = vcvt_hight_f64_f32(v82);
            v77[1] = v106;
            ++v76;
            v77 += 3;
          }
          while (v27 != v76);
        }
        objc_msgSend(*(id *)(a4 + 3392), "setViewports:count:", v73, v27, *(_OWORD *)&v104);
        if (-[SCNMTLRenderContext clientRenderPassDescriptor](a1))
          break;
        *(double *)v46.i64 = MEMORY[0x1E0C80A78](0);
        if ((_BYTE)v27)
        {
          v84 = (uint64x2_t *)(&v104 - 2 * v27 + 1);
          v85 = (float64x2_t *)(v73 + 1);
          do
          {
            v86 = vcvtq_u64_f64(v85[-1]);
            v87 = *v85;
            v85 += 3;
            v46 = vcvtq_u64_f64(v87);
            v84[-1] = v86;
            *v84 = v46;
            v84 += 2;
            --v75;
          }
          while (v75);
        }
        v52 = *(void **)(a4 + 3392);
        goto LABEL_60;
      }
      if (!*((_BYTE *)this + 120))
        break;
      MEMORY[0x1E0C80A78](v26);
      v89 = (_OWORD *)&v104.f32[-4 * v88];
      v90 = ldexpf(1.0, *(unsigned __int16 *)(a3 + 18));
      v91 = -[SCNMTLRenderContext engineContext](a1);
      v93 = v27;
      if ((_BYTE)v27)
      {
        v94 = v91;
        v95 = 0;
        v96 = (float32x4_t *)(v89 + 2);
        v92.f32[0] = 1.0 / v90;
        v107 = v92;
        v108 = (__n128)xmmword_1DD008310;
        do
        {
          v97 = C3DEngineContextGetViewportAtIndex(v94, v95);
          v98 = vmulq_n_f32((float32x4_t)v97, v107.f32[0]);
          v96[-2] = (float32x4_t)vcvtq_f64_f32(*(float32x2_t *)v98.f32);
          v96[-1] = (float32x4_t)vcvt_hight_f64_f32(v98);
          *v96 = (float32x4_t)v108;
          v96 += 3;
          ++v95;
        }
        while (v27 != v95);
      }
      objc_msgSend(*(id *)(a4 + 3392), "setViewports:count:", v89, v27);
      if (-[SCNMTLRenderContext clientRenderPassDescriptor](a1))
        break;
      *(double *)v64.i64 = MEMORY[0x1E0C80A78](0);
      if ((_BYTE)v27)
      {
        v99 = (uint64x2_t *)(&v104 - 2 * v27 + 1);
        v100 = (float64x2_t *)(v89 + 1);
        do
        {
          v101 = vcvtq_u64_f64(v100[-1]);
          v102 = *v100;
          v100 += 3;
          v64 = vcvtq_u64_f64(v102);
          v99[-1] = v101;
          *v99 = v64;
          v99 += 2;
          --v93;
        }
        while (v93);
      }
      v70 = *(void **)(a4 + 3392);
      goto LABEL_71;
    case 0:
      if (*(_BYTE *)(a4 + 72) != 1)
      {
        *(_BYTE *)(a4 + 72) = 1;
        objc_msgSend(*(id *)(a4 + 3392), "setVertexAmplificationCount:viewMappings:", 1, 0);
      }
      if (*((_BYTE *)this + 121))
      {
        __asm { FMOV            V0.4S, #-1.0 }
        v108 = *((__n128 *)this + *(unsigned __int16 *)(a3 + 16) + 8);
        if ((vminvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32((float32x4_t)v108, _Q0))) & 0x80000000) == 0)
        {
          v14 = scn_default_log();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
            C3D::__setupRenderEncoder((uint64_t (***)(_QWORD))this, (unsigned __int16 *)(a3 + 16), v14);
        }
        *(float *)v15.i32 = ldexpf(1.0, *(unsigned __int16 *)(a3 + 18));
        v16 = *(void **)(a4 + 3392);
        v107 = vdivq_f32((float32x4_t)v108, (float32x4_t)vdupq_lane_s32(v15, 0));
        v108 = (__n128)vextq_s8((int8x16_t)v107, (int8x16_t)v107, 8uLL);
        *(float64x2_t *)buf = vcvtq_f64_f32(*(float32x2_t *)v107.f32);
        *(float64x2_t *)&buf[16] = vcvt_hight_f64_f32(v107);
        v110 = xmmword_1DD008310;
        objc_msgSend(v16, "setViewport:", buf);
        *(_DWORD *)(a4 + 64) = 1;
        v17 = *(void **)(a4 + 3392);
        v18 = vcvt_u32_f32(*(float32x2_t *)v107.f32);
        *(_QWORD *)&v19 = v18.u32[0];
        *((_QWORD *)&v19 + 1) = v18.u32[1];
        v20 = v19;
        v21 = vcvt_u32_f32((float32x2_t)v108.n128_u64[0]);
      }
      else
      {
        if (!*((_BYTE *)this + 120))
          break;
        v29 = -[SCNMTLRenderContext engineContext](a1);
        v108 = C3DEngineContextGetViewportAtIndex(v29, *(unsigned __int16 *)(a3 + 16));
        v30 = -[SCNMTLRenderContext engineContext](a1);
        v31 = vmul_n_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v108, (int8x16_t)v108, 8uLL), C3DEngineContextGetSuperSamplingFactor(v30));
        v32 = *(void **)(a4 + 3392);
        *(float64x2_t *)buf = vcvtq_f64_f32((float32x2_t)v108.n128_u64[0]);
        *(float64x2_t *)&buf[16] = vcvtq_f64_f32(v31);
        v110 = xmmword_1DD008310;
        objc_msgSend(v32, "setViewport:", buf);
        *(_DWORD *)(a4 + 64) = 1;
        if (-[SCNMTLRenderContext clientRenderPassDescriptor](a1))
          break;
        v33 = vcvt_u32_f32((float32x2_t)v108.n128_u64[0]);
        v21 = vcvt_u32_f32(v31);
        v17 = *(void **)(a4 + 3392);
        *(_QWORD *)&v34 = v33.u32[0];
        *((_QWORD *)&v34 + 1) = v33.u32[1];
        v20 = v34;
      }
      *(_QWORD *)&v22 = v21.u32[0];
      *((_QWORD *)&v22 + 1) = v21.u32[1];
      *(_OWORD *)buf = v20;
      *(_OWORD *)&buf[16] = v22;
      objc_msgSend(v17, "setScissorRect:", buf);
      break;
  }
  v103 = *((_DWORD *)this + 56);
  if (*(_DWORD *)(a4 + 68) != v103)
  {
    *(_DWORD *)(a4 + 68) = v103;
    objc_msgSend(*(id *)(a4 + 3392), "setStencilReferenceValue:");
  }
}

double SCNMTLRenderCommandEncoder::endEncoding(SCNMTLRenderCommandEncoder *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  double result;

  if (!this->var24[1])
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      SCNMTLRenderCommandEncoder::endEncoding(v2, v3, v4);
  }
  objc_msgSend((id)this->var24[1], "endEncoding");
  result = 0.0;
  *(_OWORD *)this->var24 = 0u;
  return result;
}

BOOL C3DEngineContextHasFeatures(uint64_t a1, int a2)
{
  return (a2 & ~*(_DWORD *)(a1 + 1712)) == 0;
}

__n128 C3DEngineContextGetViewBackgroundColor(uint64_t a1)
{
  uint64_t Scene;
  uint64_t BackgroundEffectSlot;
  float32x4_t *ColorIfApplicable;
  __n128 result;
  float32x4_t v5;
  float32x4_t v6;

  v6 = *(float32x4_t *)(a1 + 224);
  Scene = C3DEngineContextGetScene(a1);
  if (Scene
    && (BackgroundEffectSlot = C3DSceneGetBackgroundEffectSlot(Scene, 0)) != 0
    && (ColorIfApplicable = (float32x4_t *)C3DEffectSlotGetColorIfApplicable(BackgroundEffectSlot)) != 0)
  {
    v5 = vmulq_laneq_f32(*ColorIfApplicable, *ColorIfApplicable, 3);
    v5.i32[3] = HIDWORD(*(unsigned __int128 *)ColorIfApplicable);
    result.n128_u64[0] = vaddq_f32(v5, vmulq_n_f32(v6, 1.0 - v5.f32[3])).u64[0];
  }
  else
  {
    return (__n128)v6;
  }
  return result;
}

C3D::RenderGraph *C3DRenderGraphCreate(__C3DEngineContext *a1)
{
  C3D::RenderGraph *v2;
  void *v3;

  v2 = (C3D::RenderGraph *)operator new();
  C3D::RenderGraph::RenderGraph(v2, a1, v3);
  return v2;
}

void sub_1DCD12490(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1DF0D41C0](v1, 0x10F0C405F2E17D2);
  _Unwind_Resume(a1);
}

C3D::RenderGraph *C3D::RenderGraph::RenderGraph(C3D::RenderGraph *this, __C3DEngineContext *a2, void *a3)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = a2;
  v4 = (void *)C3DScratchAllocatorCreate(4096);
  *((_QWORD *)this + 2) = v4;
  C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array((C3D::RenderGraph *)((char *)this + 32), v4);
  C3D::ScratchAllocator::ScratchAllocator((C3D::ScratchAllocator *)&v8, *((void **)this + 2));
  *((_QWORD *)this + 7) = v8;
  C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate((_QWORD *)this + 7, 32, v5);
  *((_QWORD *)this + 18) = 0;
  *((_BYTE *)this + 210) = 0;
  *((_BYTE *)this + 212) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_BYTE *)this + 208) = 0;
  *((_QWORD *)this + 19) = objc_alloc_init(MEMORY[0x1E0CC6B50]);
  *((_BYTE *)this + 209) = 0;
  v6 = operator new();
  C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::_allocate(v6, 32);
  *((_QWORD *)this + 16) = v6;
  return this;
}

void sub_1DCD12580(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1DF0D41C0](v1, 0x1030C408C11463FLL);
  _Unwind_Resume(a1);
}

C3D::ScratchAllocator *C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array(C3D::ScratchAllocator *a1, void *a2)
{
  C3D::ScratchAllocator *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = C3D::ScratchAllocator::ScratchAllocator(a1, a2);
  *((_QWORD *)v4 + 1) = 0;
  *((_QWORD *)v4 + 2) = (char *)v4 + 24;
  if (!a2)
  {
    v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      C3D::__deduceMemoryLess(v5, v6, v7);
  }
  return a1;
}

uint64_t C3DScratchAllocatorCreate(uint64_t a1)
{
  uint64_t v2;

  v2 = operator new();
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_QWORD *)(v2 + 32) = v2;
  VMAllocateChunk((vm_address_t *)v2, a1);
  return v2;
}

void VMAllocateChunk(vm_address_t *address, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;

  if (!address)
    VMAllocateChunk();
  if (address[3])
    VMAllocateChunk();
  if (!a2)
    VMAllocateChunk();
  v3 = ((*MEMORY[0x1E0C85AD8] - 1) | (a2 - 1)) + 1;
  if (vm_allocate(*MEMORY[0x1E0C83DA0], address, v3, 1))
  {
    *__error() = 12;
    *address = 0;
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      VMAllocateChunk(v3, v4);
  }
  else
  {
    address[1] = v3;
    if (!*address)
      VMAllocateChunk();
  }
}

void sub_1DCD12940(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void SCNMTLClusterSystem::SCNMTLClusterSystem(SCNMTLClusterSystem *this)
{
  *(_OWORD *)this = xmmword_1DD02A310;
  *((_QWORD *)this + 2) = 0x4000000040;
  *((_OWORD *)this + 2) = xmmword_1DD02A320;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
}

void __EnqueueNotification(int a1, uint64_t a2, CFTypeRef cf1, _QWORD *a4, const void *a5)
{
  uint64_t v8;
  uint64_t v9;
  NSObject *v11;

  if (CFEqual(cf1, CFSTR("kC3DNotificationEntityAttributeDidChange")))
  {
    v8 = C3DGetScene(a4);
    v9 = *(_QWORD *)(a2 + 56);
    if (v8 == v9 && v9 != 0)
      C3DEngineNotificationQueueEnqueueEvent(a2, 2, a4, a5);
  }
  else
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      __EnqueueNotification_cold_1(v11);
  }
}

void __SCNRenderThread_start__(void *a1)
{
  void (**v1)(_QWORD);
  uint64_t v2;
  void *v3;

  v1 = a1;
  if (__SCNRenderThread_start___once != -1)
    dispatch_once(&__SCNRenderThread_start___once, &__block_literal_global_47);
  v2 = pthread_setspecific(__SCNRenderThread_start___block_key, v1);
  v3 = (void *)MEMORY[0x1DF0D4CF4](v2);
  v1[2](v1);
  objc_autoreleasePoolPop(v3);
  pthread_exit(0);
}

void sub_1DCD13004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1DCD13330(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t C3DEngineContextGetRenderGraph(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1728);
}

void C3D::RenderGraph::addDependency(C3D::RenderGraph *this, unsigned int a2, unsigned int a3)
{
  uint64_t v4;
  unsigned int v5;
  C3D::Pass **v8;
  C3D::Pass **v9;
  uint64_t StackAllocator;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  C3D::PassDescriptor *v13;
  int v14;
  C3D::PassDescriptor *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned __int8 *v21;

  v4 = *((_QWORD *)this + 3);
  v5 = *(_DWORD *)(v4 + 8);
  if (v5 <= a2)
    C3D::RenderGraph::addDependency();
  if (v5 <= a3)
    C3D::RenderGraph::addDependency();
  v8 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v4, a2);
  v9 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), a3);
  StackAllocator = C3DEngineContextGetStackAllocator(*((_QWORD *)this + 1));
  C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(&v19, StackAllocator);
  C3D::RenderGraph::matchingPortForNodes((uint64_t)this, (uint64_t)v8, v9, (uint64_t)&v19);
  if (v20)
  {
    v11 = v21;
    v12 = &v21[2 * v20];
    do
    {
      C3D::RenderGraph::addDependency(this, a2, a3, *v11, v11[1]);
      v11 += 2;
    }
    while (v11 != v12);
  }
  else
  {
    v13 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v8);
    v14 = C3D::PassDescriptor::inputCount(v13);
    v15 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v9);
    v16 = C3D::PassDescriptor::outputCount(v15);
    if (v14 == 1)
      v17 = 0;
    else
      v17 = 255;
    if (v16 == 1)
      v18 = 0;
    else
      v18 = 255;
    C3D::RenderGraph::addDependency(this, a2, a3, v17, v18);
  }
}

void C3D::RenderGraph::allocateResources(C3D::RenderGraph *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned __int16 *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  C3D::PassResource *v9;
  int v10;
  NSObject *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  C3D::PassResource *v15;
  NSObject *v16;
  C3D::PassResource *v17;
  NSObject *v18;
  C3D::PassResource *v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  C3D::Pass *v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  C3D::Pass **v34;
  unsigned __int8 *v35;
  uint64_t v36;
  int v37;
  char v38;
  char v39;
  char v40;
  BOOL v41;
  unsigned int v42;
  unsigned int v43;
  _BOOL4 v45;
  C3D::PassResource *v46;
  uint64_t v47;
  C3D::PassResource *v48;
  uint64_t v49;
  NSObject *v50;
  C3D::Pass *v51;
  _BYTE *RenderMode;
  C3D::PassIODescriptor *v53;
  __int16 v54;
  C3D::PassResource *v55;
  C3D::PassResource *v56;
  C3D::RefCountedResource *v57;
  NSObject *v58;
  C3D::PassResource *v59;
  C3D::PassResource *v60;
  _BOOL4 v61;
  int v62;
  C3D::RefCountedResource *Resource;
  C3D::PassResource *v64;
  C3D::PassResource *v65;
  NSObject *v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  char v73;
  char v74;
  char v75;
  BOOL v76;
  C3D::Pass *v77;
  __int16 v78;
  C3D::PassResource *v79;
  int v80;
  C3D::PassResource *v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  char v85;
  NSObject *v86;
  int v87;
  NSObject *v88;
  char v89;
  uint64_t v90;
  NSObject *v91;
  uint64_t v92;
  NSObject *v93;
  NSObject *v94;
  uint64_t RenderContext;
  unsigned int v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t StackAllocator;
  int v101;
  BOOL v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t *v105;
  C3D::Pass **v106;
  C3D::PassIODescriptor *v107;
  BOOL v108[2];
  __int128 v109;
  int v110;
  C3D::RefCountedResource *v111;
  uint64_t v112;
  unsigned int v113;
  uint64_t *v114;
  uint8_t v115[4];
  uint64_t v116;
  uint8_t v117[4];
  uint64_t v118;
  uint8_t v119[4];
  uint64_t v120;
  uint8_t v121[4];
  uint64_t v122;
  uint8_t v123[4];
  uint64_t v124;
  _BYTE buf[12];
  __int16 v126;
  uint64_t v127;
  __int16 v128;
  unsigned int v129;
  __int16 v130;
  uint64_t v131;
  uint8_t v132[4];
  _QWORD v133[5];

  *(_QWORD *)((char *)&v133[2] + 4) = *MEMORY[0x1E0C80C00];
  RenderContext = C3DEngineContextGetRenderContext(*((_QWORD *)this + 1));
  v99 = -[SCNMTLRenderContext frameTexturePool](RenderContext);
  v105 = (uint64_t *)this;
  v2 = *((_QWORD *)this + 12);
  if (!v2)
    return;
  while (1)
  {
    v98 = v2;
    v96 = *(_DWORD *)(v2 + 8);
    if (v96)
      break;
LABEL_141:
    v2 = *(_QWORD *)(v98 + 24);
    if (!v2)
      return;
  }
  v3 = 0;
  v97 = 0;
  while (1)
  {
    v4 = (unsigned __int16 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[](v98, v3);
    v106 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v105[3], *v4);
    v5 = *(_DWORD *)C3D::Pass::descriptor(*v106);
    v6 = *(_QWORD *)(v98 + 24);
    v101 = v5;
    if (v6 && ((v7 = *(_QWORD *)(v6 + 24), v5 == 2) ? (v8 = v7 == 0) : (v8 = 0), v8))
    {
      v92 = -[SCNMTLRenderContext clientRenderPassDescriptor](RenderContext);
      LOBYTE(v103) = 0;
      if (v96 - 1 == v3)
      {
        BYTE4(v103) = 0;
        v102 = 0;
        if (v92)
        {
          BYTE4(v103) = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor](RenderContext), "colorAttachments"), "objectAtIndexedSubscript:", 0), "texture") != 0;
          LOBYTE(v103) = objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor](RenderContext), "depthAttachment"), "texture") != 0;
          v102 = objc_msgSend((id)objc_msgSend((id)-[SCNMTLRenderContext clientRenderPassDescriptor](RenderContext), "stencilAttachment"), "texture") != 0;
        }
      }
      else
      {
        BYTE4(v103) = 0;
        v102 = 0;
      }
    }
    else
    {
      v103 = 0;
      v102 = 0;
    }
    v9 = (C3D::PassResource *)C3D::Pass::resource(*v106);
    v10 = C3D::PassResource::outputCount(v9);
    if (v10 != C3D::PassDescriptor::outputCount((C3D::Pass *)((char *)*v106 + 32)))
    {
      v11 = scn_default_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
        C3D::RenderGraph::allocateResources(v132, v133, v11);
    }
    StackAllocator = C3DEngineContextGetStackAllocator(v105[1]);
    C3DStackAllocatorPushFrame(StackAllocator);
    C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::Array(&v112, StackAllocator);
    if (C3D::PassDescriptor::inputCount((C3D::Pass *)((char *)*v106 + 32)))
    {
      v12 = 0;
      do
      {
        v13 = C3D::Pass::inputBufferParameterAtIndex(*v106, v12);
        if ((*(_WORD *)(v13 + 66) & 0x80) != 0)
        {
          v14 = C3D::Pass::outputBufferParameterAtIndex(*v106, v12);
          if ((*(_WORD *)(v14 + 66) & 8) != 0)
          {
            v15 = (C3D::PassResource *)C3D::Pass::resource(*v106);
            if (C3D::PassResource::outputAtIndex(v15, (unsigned __int16)v12))
            {
              v16 = scn_default_log();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
              {
                v24 = (**(uint64_t (***)(C3D::Pass *))*v106)(*v106);
                v25 = *(_QWORD *)(v14 + 8);
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = "resOutput == nullptr";
                v126 = 2080;
                v127 = v24;
                v128 = 1024;
                v129 = v12;
                v130 = 2080;
                v131 = v25;
                _os_log_fault_impl(&dword_1DCCB8000, v16, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Readwrite pass %s has an initialised output at index %d:%s should be null", buf, 0x26u);
              }
            }
            v111 = 0;
            v17 = (C3D::PassResource *)C3D::Pass::resource(*v106);
            v111 = (C3D::RefCountedResource *)C3D::PassResource::inputAtIndex(v17, (unsigned __int16)v12);
            if (!v111)
            {
              v18 = scn_default_log();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
              {
                v26 = (**(uint64_t (***)(C3D::Pass *))*v106)(*v106);
                v27 = *(_QWORD *)(v13 + 8);
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = "resInput";
                v126 = 2080;
                v127 = v26;
                v128 = 1024;
                v129 = v12;
                v130 = 2080;
                v131 = v27;
                _os_log_fault_impl(&dword_1DCCB8000, v18, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Readwrite pass %s has an uninitialised input at index %d:%s should be null", buf, 0x26u);
              }
            }
            v19 = (C3D::PassResource *)C3D::Pass::resource(*v106);
            C3D::PassResource::setOutputAtIndex(v19, v111, (unsigned __int16)v12);
            ++*((_BYTE *)v111 + 33);
            v20 = (_OWORD *)C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)*v106 + 32), (unsigned __int16)v12);
            *(_OWORD *)v14 = *v20;
            v21 = v20[1];
            v22 = v20[2];
            v23 = v20[4];
            *(_OWORD *)(v14 + 48) = v20[3];
            *(_OWORD *)(v14 + 64) = v23;
            *(_OWORD *)(v14 + 16) = v21;
            *(_OWORD *)(v14 + 32) = v22;
            C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v112, &v111);
          }
        }
        ++v12;
      }
      while (v12 < C3D::PassDescriptor::inputCount((C3D::Pass *)((char *)*v106 + 32)));
    }
    v28 = *((unsigned int *)v106 + 10);
    if ((_DWORD)v28)
    {
      v29 = v106[6];
      v30 = 4 * v28;
      do
      {
        v104 = v30;
        v31 = *(_DWORD *)v29;
        v32 = BYTE2(*(_DWORD *)v29);
        v33 = C3D::PassDescriptor::outputAtIndex((C3D::Pass *)((char *)*v106 + 32), v32);
        v34 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v105[3], v31 & 0x7FFF);
        v35 = (unsigned __int8 *)C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)*v34 + 32), HIBYTE(v31));
        v36 = (uint64_t)v35;
        v37 = v35[64];
        v38 = BYTE4(v103);
        if (v37 != 1)
          v38 = 0;
        if (v35[65])
          v39 = 0;
        else
          v39 = v38;
        v40 = v103;
        if (v37 != 2)
          v40 = 0;
        v8 = v37 == 3;
        v41 = v102;
        if (!v8)
          v41 = 0;
        if ((v39 & 1) == 0 && (v40 & 1) == 0 && !v41)
        {
          v42 = *(unsigned __int8 *)(v33 + 31);
          if (v42 <= 1)
            v42 = 1;
          v43 = v35[31];
          if (v43 <= 1)
            v43 = 1;
          v45 = *(_BYTE *)v33 == 1 && v42 != v43;
          v46 = (C3D::PassResource *)C3D::Pass::resource(*v106);
          v47 = C3D::PassResource::outputAtIndex(v46, BYTE2(v31));
          if (v47)
          {
            v48 = (C3D::PassResource *)C3D::Pass::resource(*v34);
            v49 = C3D::PassResource::inputAtIndex(v48, HIBYTE(v31));
            if (v49)
            {
              if (v49 != v47)
              {
                v50 = scn_default_log();
                if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
                  C3D::RenderGraph::allocateResources(v123, &v124, v50);
              }
            }
            else
            {
              v55 = (C3D::PassResource *)C3D::Pass::resource(*v34);
              C3D::PassResource::setInputAtIndex(v55, (C3D::RefCountedResource *)v47, HIBYTE(v31));
            }
            if ((*(_WORD *)(v33 + 66) & 0x100) == 0)
              ++*(_BYTE *)(v47 + 33);
            if (v45 && !*(_QWORD *)(v47 + 24))
            {
              *(_DWORD *)(v36 + 32) = 1;
              v109 = *(_OWORD *)(v36 + 16);
              v110 = *(_DWORD *)(v36 + 32);
              *(_QWORD *)(v47 + 24) = SCNMTLTexturePool::allocate(v99, &v109, 0, 0);
            }
            LOBYTE(v107) = 0;
            *(_QWORD *)buf = 0;
            C3D::RenderGraph::lastNodeUsingResourceAtIndex((uint64_t)v105, (_BYTE *)v33, v31 & 0x7FFF, HIBYTE(v31), (C3D::Pass ***)buf, (uint64_t *)&v111, (BOOL *)&v107, &v108[1]);
            if (*(_QWORD *)buf && *(C3D::Pass ***)buf != v34)
              C3D::RenderGraph::propagateReadWriteResources((uint64_t)v105, *(C3D::Pass ***)buf, v31 & 0x7FFF, HIBYTE(v31), (C3D::RefCountedResource *)v47);
          }
          else if ((*(_WORD *)(v33 + 66) & 0x80) != 0)
          {
            v56 = (C3D::PassResource *)C3D::Pass::resource(*v106);
            v57 = (C3D::RefCountedResource *)C3D::PassResource::inputAtIndex(v56, BYTE2(v31));
            if (!v57)
            {
              v58 = scn_default_log();
              if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::allocateResources(v121, &v122, v58);
            }
            v59 = (C3D::PassResource *)C3D::Pass::resource(*v106);
            C3D::PassResource::setOutputAtIndex(v59, v57, BYTE2(v31));
            v60 = (C3D::PassResource *)C3D::Pass::resource(*v34);
            C3D::PassResource::setInputAtIndex(v60, v57, HIBYTE(v31));
          }
          else
          {
            *(_WORD *)v108 = 0;
            v111 = 0;
            v107 = 0;
            C3D::RenderGraph::lastNodeUsingResourceAtIndex((uint64_t)v105, (_BYTE *)v33, v31 & 0x7FFF, HIBYTE(v31), (C3D::Pass ***)&v111, (uint64_t *)&v107, &v108[1], v108);
            if (v101 == 2)
            {
              v51 = *v106;
              RenderMode = (_BYTE *)C3D::RenderPass::getRenderMode(*v106);
              v53 = v107;
              if (*RenderMode == 1 && SCNMTLTextureTypeIsArray(*((unsigned __int8 *)v107 + 24)))
                v54 = *(_WORD *)(C3D::Pass::descriptor(v51) + 6);
              else
                v54 = 0;
              *((_WORD *)v53 + 11) = v54;
            }
            v61 = v108[0];
            C3D::RenderGraph::computeResourceUsageForOutputDescriptor((uint64_t)v105, v106, (C3D::PassIODescriptor *)v33, v36, v108[0]);
            buf[0] = BYTE2(v31);
            if (*(unsigned __int16 *)(C3D::Pass::descriptor(*v106) + 6) > 1u)
              v62 = 0;
            else
              v62 = C3D::__deduceMemoryLess((uint64_t)v105, (uint64_t)v106, StackAllocator, buf, 1);
            Resource = (C3D::RefCountedResource *)C3D::RenderGraph::createResource((C3D::RenderGraph *)v105, (C3D::PassIODescriptor *)v33, v107, v108[1], v61, v62);
            v64 = (C3D::PassResource *)C3D::Pass::resource(*v106);
            C3D::PassResource::setOutputAtIndex(v64, Resource, BYTE2(v31));
            v65 = (C3D::PassResource *)C3D::Pass::resource(*v34);
            C3D::PassResource::setInputAtIndex(v65, Resource, HIBYTE(v31));
            if (v111 && v111 != (C3D::RefCountedResource *)v34)
              C3D::RenderGraph::propagateReadWriteResources((uint64_t)v105, (C3D::Pass **)v111, v31 & 0x7FFF, HIBYTE(v31), Resource);
            if ((*(_WORD *)(v33 + 66) & 8) != 0)
            {
              v66 = scn_default_log();
              if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
              {
                v67 = (**(uint64_t (***)(C3D::Pass *))*v106)(*v106);
                v68 = *(_QWORD *)(v33 + 8);
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = "!outputResDesc.usedInternally";
                v126 = 2080;
                v127 = v67;
                v128 = 1024;
                v129 = v32;
                v130 = 2080;
                v131 = v68;
                _os_log_fault_impl(&dword_1DCCB8000, v66, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Pass %s resource at index %d:%s should not be tagged as \"usedInternally\"", buf, 0x26u);
              }
            }
          }
        }
        v29 = (C3D::Pass *)((char *)v29 + 4);
        v30 = v104 - 4;
      }
      while (v104 != 4);
    }
    if (C3D::PassDescriptor::outputCount((C3D::Pass *)((char *)*v106 + 32)))
      break;
LABEL_112:
    (*(void (**)(C3D::Pass *))(*(_QWORD *)*v106 + 16))(*v106);
    if (v113)
    {
      v82 = v114;
      v83 = 8 * v113;
      do
      {
        v84 = *v82;
        v85 = *(_BYTE *)(*v82 + 33) - 1;
        *(_BYTE *)(*v82 + 33) = v85;
        if (v85 < 0)
        {
          v86 = scn_default_log();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
            C3D::RenderGraph::allocateResources(v119, &v120, v86);
          v85 = *(_BYTE *)(v84 + 33);
        }
        if (!v85 && (*(_BYTE *)(v84 + 34) & 1) == 0)
        {
          v87 = *(unsigned __int8 *)(v84 + 32);
          if (v87 == 2)
          {
            if (!*(_QWORD *)(v84 + 8))
            {
              v91 = scn_default_log();
              if (os_log_type_enabled(v91, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::allocateResources(v115, &v116, v91);
            }
            *(_QWORD *)v84 = 0;
            *(_QWORD *)(v84 + 8) = 0;
            *(_QWORD *)(v84 + 16) = 0;
          }
          else if (v87 == 1)
          {
            if (!*(_QWORD *)v84)
            {
              v88 = scn_default_log();
              if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::allocateResources(v117, &v118, v88);
            }
            v89 = *(_BYTE *)(v84 + 34);
            if ((v89 & 2) == 0)
            {
              SCNMTLTexturePool::free(v99, *(_QWORD *)v84);
              v89 = *(_BYTE *)(v84 + 34);
            }
            if ((v89 & 4) == 0)
            {
              v90 = *(_QWORD *)(v84 + 24);
              if (v90)
                SCNMTLTexturePool::free(v99, v90);
            }
          }
        }
        ++v82;
        v83 -= 8;
      }
      while (v83);
    }
    C3DStackAllocatorPopFrame(StackAllocator);
    C3D::RenderGraph::freeConsumedResources((uint64_t)v105, (uint64_t)v106, v99);
    v3 = (unsigned __int16)++v97;
    if (v96 <= (unsigned __int16)v97)
      goto LABEL_141;
  }
  v69 = 0;
  while (1)
  {
    v70 = C3D::PassDescriptor::outputAtIndex((C3D::Pass *)((char *)*v106 + 32), (unsigned __int16)v69);
    v71 = v70;
    v72 = *(unsigned __int8 *)(v70 + 64);
    v73 = BYTE4(v103);
    if (v72 != 1)
      v73 = 0;
    if (*(_BYTE *)(v70 + 65))
      v74 = 0;
    else
      v74 = v73;
    v75 = v103;
    if (v72 != 2)
      v75 = 0;
    v8 = v72 == 3;
    v76 = v102;
    if (!v8)
      v76 = 0;
    if ((v74 & 1) != 0 || (v75 & 1) != 0 || v76)
      goto LABEL_111;
    if (v101 == 2)
    {
      v77 = *v106;
      if (*(_BYTE *)C3D::RenderPass::getRenderMode(*v106) == 1
        && SCNMTLTextureTypeIsArray(*(unsigned __int8 *)(v71 + 24)))
      {
        v78 = *(_WORD *)(C3D::Pass::descriptor(v77) + 6);
      }
      else
      {
        v78 = 0;
      }
      *(_WORD *)(v71 + 22) = v78;
    }
    if ((*(_WORD *)(v71 + 66) & 0x108) != 8)
      goto LABEL_111;
    v79 = (C3D::PassResource *)C3D::Pass::resource(*v106);
    if (C3D::PassResource::outputAtIndex(v79, (unsigned __int16)v69))
    {
      if ((*(_WORD *)(v71 + 66) & 0x80) == 0)
        break;
    }
    *(_QWORD *)buf = 0;
    C3D::RenderGraph::computeResourceUsageForOutputDescriptor((uint64_t)v105, v106, (C3D::PassIODescriptor *)v71, 0, 0);
    LOBYTE(v111) = v69;
    if (*(unsigned __int16 *)(C3D::Pass::descriptor(*v106) + 6) > 1u)
      v80 = 0;
    else
      v80 = C3D::__deduceMemoryLess((uint64_t)v105, (uint64_t)v106, StackAllocator, (char *)&v111, 1);
    *(_QWORD *)buf = C3D::RenderGraph::createResource((C3D::RenderGraph *)v105, (C3D::PassIODescriptor *)v71, 0, 0, 0, v80);
    v81 = (C3D::PassResource *)C3D::Pass::resource(*v106);
    C3D::PassResource::setOutputAtIndex(v81, *(C3D::RefCountedResource **)buf, (unsigned __int16)v69);
    C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v112, buf);
LABEL_111:
    if (++v69 >= C3D::PassDescriptor::outputCount((C3D::Pass *)((char *)*v106 + 32)))
      goto LABEL_112;
  }
  v93 = scn_default_log();
  if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
    C3D::RenderGraph::allocateResources(v71, v69, v93);
  v94 = scn_default_log();
  if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    C3D::RenderGraph::allocateResources();
}

uint64_t C3D::Pass::resource(C3D::Pass *this)
{
  return (uint64_t)this + 80;
}

uint64_t C3DEngineContextGetStackAllocator(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetStats_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 168);
}

uint64_t C3D::RenderPass::getRenderMode(C3D::RenderPass *this)
{
  return (uint64_t)this + 117;
}

void C3DStackAllocatorPushFrame(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  v1 = *(unsigned int *)(a1 + 576);
  if ((_DWORD)v1 == 31)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      C3DStackAllocatorPushFrame_cold_1(v2);
  }
  else
  {
    *(_DWORD *)(a1 + 576) = v1 + 1;
    v3 = *(_QWORD *)(a1 + 16);
    v4 = *(_DWORD *)(v3 + 12);
    v5 = a1 + 16 * v1;
    *(_QWORD *)(v5 + 64) = v3;
    *(_DWORD *)(v5 + 72) = v4;
  }
}

uint64_t C3DStackAllocatorPopFrame(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  BOOL v17;
  vm_address_t *v18;
  uint64_t result;

  if (!*(_DWORD *)(a1 + 576))
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DStackAllocatorPopFrame_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(_DWORD *)(a1 + 576) - 1;
  *(_DWORD *)(a1 + 576) = v10;
  v11 = a1 + 16 * v10;
  v14 = *(_QWORD *)(v11 + 64);
  v12 = v11 + 64;
  v13 = v14;
  v15 = *(_DWORD *)(v12 + 8);
  *(_DWORD *)(v14 + 12) = v15;
  v16 = a1 + 24;
  if (v15)
    v17 = 1;
  else
    v17 = v13 == v16;
  if (v17)
    v18 = (vm_address_t *)v13;
  else
    v18 = *(vm_address_t **)(v13 + 16);
  result = __destroyChuncks(a1, (uint64_t)v18);
  if (v13 == v16 && *(unsigned int *)(a1 + 56) > v18[1])
  {
    MEMORY[0x1DF0D52F4](*MEMORY[0x1E0C83DA0], *v18);
    result = __allocateChunk(v18, *(unsigned int *)(a1 + 56));
  }
  *(_QWORD *)v12 = 0;
  *(_DWORD *)(v12 + 8) = 0;
  return result;
}

uint64_t __destroyChuncks(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;

  v3 = result;
  v4 = *(_QWORD *)(result + 16);
  if (v4 != a2)
  {
    v5 = result + 24;
    v6 = (unsigned int *)MEMORY[0x1E0C83DA0];
    do
    {
      v7 = *(_QWORD *)(v4 + 16);
      result = MEMORY[0x1DF0D52F4](*v6, *(_QWORD *)v4, *(unsigned int *)(v4 + 8));
      if (v4 != v5)
        result = MEMORY[0x1DF0D41C0](v4, 0x1030C40D5FA72FALL);
      v4 = v7;
    }
    while (v7 != a2);
  }
  *(_QWORD *)(v3 + 16) = a2;
  return result;
}

uint64_t C3D::PassResource::outputCount(C3D::PassResource *this)
{
  return *((unsigned __int16 *)this + 9);
}

_QWORD *C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::Array(_QWORD *a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = a2;
  a1[1] = 0;
  a1[2] = a1 + 3;
  if (!a2)
  {
    v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      C3D::__deduceMemoryLess(v3, v4, v5);
  }
  return a1;
}

void C3D::PassResource::setOutputAtIndex(C3D::PassResource *this, C3D::RefCountedResource *a2, unsigned int a3)
{
  NSObject *v6;

  if (*((unsigned __int16 *)this + 9) <= a3)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3D::PassResource::outputAtIndex();
  }
  *(_QWORD *)(*((_QWORD *)this + 1) + 8 * a3) = a2;
}

uint64_t C3D::RenderGraph::computeResourceUsageForOutputDescriptor(uint64_t this, const C3D::Pass **a2, C3D::PassIODescriptor *a3, uint64_t a4, int a5)
{
  uint64_t v7;
  C3D::Pass **v8;
  uint64_t *v9;
  const C3D::Pass *v10;
  C3D::PassDescriptor *v11;
  unsigned __int16 v12;
  unsigned int v13;
  C3D::PassDescriptor *v14;
  C3D::PassDescriptor *v15;
  uint64_t StackAllocator;
  C3D::PassDescriptor *v17;
  const C3D::PassIODescriptor *v18;
  uint64_t v19;
  _DWORD *v20;
  _DWORD *v21;
  C3D::PassDescriptor *v22;
  uint64_t v23;
  C3D::Pass *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  _DWORD *v28;

  if (a5)
  {
    LOBYTE(v7) = 0;
    *((_BYTE *)a3 + 26) = 0;
    goto LABEL_10;
  }
  v8 = a2;
  v9 = (uint64_t *)this;
  v10 = *a2;
  if ((*((_WORD *)a3 + 33) & 8) != 0)
  {
    this = C3D::RenderGraph::outputTextureUsageForPass((C3D::RenderGraph *)this, v10, a3);
    *((_BYTE *)a3 + 26) = this;
    LOBYTE(v7) = this;
    if (!a4)
      return this;
    goto LABEL_10;
  }
  v11 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v10);
  if (C3D::PassDescriptor::outputCount(v11))
  {
    v12 = 0;
    LOBYTE(v13) = 0;
    do
    {
      v14 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v8);
      if ((C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex(v14, v12) == a3)
        break;
      LOBYTE(v13) = v13 + 1;
      v15 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v8);
      v12 = v13;
    }
    while (C3D::PassDescriptor::outputCount(v15) > v13);
  }
  else
  {
    LOBYTE(v13) = 0;
  }
  StackAllocator = C3DEngineContextGetStackAllocator(v9[1]);
  v7 = 0;
LABEL_14:
  v17 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v8);
  v18 = (const C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex(v17, v13);
  v19 = C3D::RenderGraph::outputTextureUsageForPass((C3D::RenderGraph *)v9, *v8, v18);
  this = (uint64_t)C3D::RenderGraph::GraphNode::successorsAtIndex((uint64_t)v8, v13, StackAllocator, &v26);
  v7 |= v19;
  if (v27)
  {
    v20 = v28;
    v21 = &v28[v27];
    do
    {
      while (1)
      {
        v13 = HIBYTE(*v20);
        v8 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v9[3], *v20 & 0x7FFF);
        v22 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v8);
        this = C3D::PassDescriptor::inputAtIndex(v22, v13);
        if ((*(_WORD *)(this + 66) & 0x80) == 0)
          break;
        if (++v20 == v21)
          goto LABEL_14;
      }
      if (v9[21])
      {
        v23 = 7;
      }
      else
      {
        v24 = *v8;
        v25 = *(unsigned __int8 *)(this + 26);
        this = C3D::Pass::descriptor(v24);
        v23 = v25 | ((*(_DWORD *)this - 1) < 4);
      }
      v7 |= v23;
      ++v20;
    }
    while (v20 != v21);
  }
  *((_BYTE *)a3 + 26) = v7;
  if (a4)
LABEL_10:
    *(_BYTE *)(a4 + 26) = v7;
  return this;
}

void C3D::RenderGraph::freeConsumedResources(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int *v6;
  uint64_t v7;
  unsigned int v8;
  C3D::Pass **v9;
  unsigned int v10;
  uint64_t v11;
  unsigned __int8 *v12;
  C3D::PassResource *v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  NSObject *v17;
  int v18;
  char v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  uint8_t v23[4];
  uint64_t v24;
  uint8_t v25[4];
  uint64_t v26;
  uint8_t v27[4];
  _DWORD v28[7];

  *(_QWORD *)&v28[5] = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v3)
  {
    v6 = *(unsigned int **)(a2 + 24);
    v7 = 4 * v3;
    do
    {
      v8 = *v6;
      v9 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(a1 + 24), *v6 & 0x7FFF);
      v10 = HIBYTE(v8);
      v11 = C3D::PassDescriptor::outputAtIndex((C3D::Pass *)((char *)*v9 + 32), v10);
      if ((*(_WORD *)(v11 + 66) & 0x100) == 0)
      {
        v12 = (unsigned __int8 *)v11;
        v13 = (C3D::PassResource *)C3D::Pass::resource(*v9);
        v14 = C3D::PassResource::outputAtIndex(v13, v10);
        if (v14)
        {
          v15 = v14;
          if ((*(_BYTE *)(v14 + 34) & 1) == 0)
          {
            v16 = *(_BYTE *)(v14 + 33) - 1;
            *(_BYTE *)(v14 + 33) = v16;
            if (v16 < 0)
            {
              v17 = scn_default_log();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::allocateResources(v27, v28, v17);
              v16 = *(_BYTE *)(v15 + 33);
            }
            if (!v16)
            {
              v18 = *v12;
              if (v18 == 2)
              {
                if (!*(_QWORD *)(v15 + 8))
                {
                  v22 = scn_default_log();
                  if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
                    C3D::RenderGraph::freeConsumedResources(v23, &v24, v22);
                }
                *(_QWORD *)v15 = 0;
                *(_QWORD *)(v15 + 8) = 0;
                *(_QWORD *)(v15 + 16) = 0;
              }
              else if (v18 == 1)
              {
                v19 = *(_BYTE *)(v15 + 34);
                if ((v19 & 1) == 0)
                {
                  if ((*(_BYTE *)(v15 + 34) & 2) == 0)
                  {
                    if (!*(_QWORD *)v15)
                    {
                      v20 = scn_default_log();
                      if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
                        C3D::RenderGraph::freeConsumedResources(v25, &v26, v20);
                    }
                    SCNMTLTexturePool::free(a3, *(_QWORD *)v15);
                    v19 = *(_BYTE *)(v15 + 34);
                  }
                  if ((v19 & 4) == 0)
                  {
                    v21 = *(_QWORD *)(v15 + 24);
                    if (v21)
                      SCNMTLTexturePool::free(a3, v21);
                  }
                }
              }
            }
          }
        }
      }
      ++v6;
      v7 -= 4;
    }
    while (v7);
  }
}

uint64_t C3D::RenderGraph::createResource(C3D::RenderGraph *this, C3D::PassIODescriptor *a2, C3D::PassIODescriptor *a3, char a4, int a5, int a6)
{
  SCNMTLRenderContext *RenderContext;
  SCNMTLBufferPool *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  void *v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  const char *v35;
  unsigned int v36;
  unint64_t v37;
  uint64_t v38;
  unsigned __int8 *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  const char *v44;
  unsigned int v45;
  unint64_t v46;
  uint64_t v47;
  unsigned __int8 *v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v53;
  NSObject *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  NSObject *v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t v63;
  NSObject *v64;
  uint64_t v65;
  uint64_t v66;
  __int128 v67;
  int v68;
  __int128 v69;
  int v70;
  __int128 v71;
  int v72;
  __int128 v73;
  int v74;
  __int128 v75;
  int v76;
  __int128 v77;
  uint64_t v78;

  RenderContext = (SCNMTLRenderContext *)C3DEngineContextGetRenderContext(*((_QWORD *)this + 1));
  v13 = (SCNMTLBufferPool *)-[SCNMTLRenderContext frameConstantBufferPool]((uint64_t)RenderContext);
  v14 = -[SCNMTLRenderContext frameTexturePool]((uint64_t)RenderContext);
  C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::emplace_back(*((_QWORD *)this + 18));
  v15 = C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::back(*((_QWORD *)this + 18));
  v16 = *(unsigned __int8 *)a2;
  *(_BYTE *)(v15 + 32) = v16;
  if (a6)
  {
    v17 = (void *)-[SCNMTLRenderContext device]((uint64_t)RenderContext);
    if (SCNMTLDeviceSupportsMemorylessStorage(v17))
      *((_BYTE *)a2 + 25) = 3;
    v16 = *(unsigned __int8 *)a2;
  }
  if (v16 == 2)
  {
    SCNMTLBufferPool::allocate(v13, *((_QWORD *)a2 + 2), &v77);
    *(_OWORD *)v15 = v77;
    *(_QWORD *)(v15 + 16) = v78;
    if (!*(_QWORD *)(v15 + 8))
    {
      v18 = scn_default_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
        C3D::RenderGraph::createResource(v18, v19, v20);
    }
    goto LABEL_28;
  }
  if ((a4 & 1) == 0 && (a5 & 1) == 0)
  {
    *((_DWORD *)a2 + 8) = 0;
    v76 = 0;
    v75 = *((_OWORD *)a2 + 1);
    v21 = SCNMTLTexturePool::allocate(v14, &v75, 0, 0);
    *(_QWORD *)v15 = v21;
    if (!v21)
    {
      v22 = scn_default_log();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
        C3D::RenderGraph::createResource(v22, v23, v24);
    }
    goto LABEL_28;
  }
  if ((a4 & 1) == 0)
  {
    if (*((_BYTE *)a2 + 64) != 1)
    {
      v30 = scn_default_log();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
        C3D::RenderGraph::createResource(v30, v31, v32);
    }
    *(_QWORD *)v15 = 0;
    v29 = *(_BYTE *)(v15 + 34) | 2;
    goto LABEL_27;
  }
  if (a5)
  {
    if (!*((_QWORD *)this + 21))
      *((_BYTE *)a2 + 26) = 4;
    *((_DWORD *)a2 + 8) = 0;
    v74 = 0;
    v73 = *((_OWORD *)a2 + 1);
    v25 = SCNMTLTexturePool::allocate(v14, &v73, 0, 0);
    *(_QWORD *)v15 = v25;
    if (!v25)
    {
      v26 = scn_default_log();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
        C3D::RenderGraph::createResource(v26, v27, v28);
    }
    if (*((_BYTE *)a2 + 64) == 1)
    {
      *(_QWORD *)(v15 + 24) = 0;
      v29 = *(_BYTE *)(v15 + 34) | 4;
LABEL_27:
      *(_BYTE *)(v15 + 34) = v29;
      goto LABEL_28;
    }
    if (*((unsigned __int8 *)a3 + 31) >= 2u)
    {
      v61 = scn_default_log();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_FAULT))
        C3D::RenderGraph::createResource(v61, v62, v63);
    }
    if (SCNMTLTextureTypeIsMultisampled(*((unsigned __int8 *)a3 + 24)))
    {
      v64 = scn_default_log();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT))
        C3D::RenderGraph::createResource(v64, v65, v66);
    }
    *((_DWORD *)a3 + 8) = 1;
    v71 = *((_OWORD *)a3 + 1);
    v72 = *((_DWORD *)a3 + 8);
    *(_QWORD *)(v15 + 24) = SCNMTLTexturePool::allocate(v14, &v71, 0, 0);
  }
  else
  {
    *((_DWORD *)a2 + 8) = 0;
    v70 = 0;
    v69 = *((_OWORD *)a2 + 1);
    v53 = SCNMTLTexturePool::allocate(v14, &v69, 0, 0);
    *(_QWORD *)v15 = v53;
    if (!v53)
    {
      v54 = scn_default_log();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
        C3D::RenderGraph::createResource(v54, v55, v56);
    }
    *((_DWORD *)a3 + 8) = 1;
    v68 = 1;
    v67 = *((_OWORD *)a3 + 1);
    v57 = SCNMTLTexturePool::allocate(v14, &v67, 0, 0);
    *(_QWORD *)(v15 + 24) = v57;
    if (!v57)
    {
      v58 = scn_default_log();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT))
        C3D::RenderGraph::createResource(v58, v59, v60);
    }
  }
LABEL_28:
  v33 = *((_WORD *)a2 + 33);
  if ((v33 & 0x10) != 0)
  {
    v34 = *((_QWORD *)this + 17);
    v35 = (const char *)*((_QWORD *)a2 + 1);
    v36 = strlen(v35);
    v37 = 0xC6A4A7935BD1E995 * v36;
    if (v36 >= 8)
    {
      v38 = v36 >> 3;
      v39 = (unsigned __int8 *)&v35[8 * v38];
      v40 = 8 * v38;
      do
      {
        v41 = *(_QWORD *)v35;
        v35 += 8;
        v37 = 0xC6A4A7935BD1E995
            * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v41) ^ ((0xC6A4A7935BD1E995 * v41) >> 47))) ^ v37);
        v40 -= 8;
      }
      while (v40);
      v35 = (const char *)v39;
    }
    switch(v36 & 7)
    {
      case 1u:
        goto LABEL_40;
      case 2u:
        goto LABEL_39;
      case 3u:
        goto LABEL_38;
      case 4u:
        goto LABEL_37;
      case 5u:
        goto LABEL_36;
      case 6u:
        goto LABEL_35;
      case 7u:
        v37 ^= (unint64_t)*((unsigned __int8 *)v35 + 6) << 48;
LABEL_35:
        v37 ^= (unint64_t)*((unsigned __int8 *)v35 + 5) << 40;
LABEL_36:
        v37 ^= (unint64_t)*((unsigned __int8 *)v35 + 4) << 32;
LABEL_37:
        v37 ^= (unint64_t)*((unsigned __int8 *)v35 + 3) << 24;
LABEL_38:
        v37 ^= (unint64_t)*((unsigned __int8 *)v35 + 2) << 16;
LABEL_39:
        v37 ^= (unint64_t)*((unsigned __int8 *)v35 + 1) << 8;
LABEL_40:
        v37 = 0xC6A4A7935BD1E995 * (v37 ^ *(unsigned __int8 *)v35);
        break;
      default:
        break;
    }
    v42 = (0xC6A4A7935BD1E995 * (v37 ^ (v37 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v37 ^ (v37 >> 47))) >> 47);
    *(_QWORD *)&v77 = C3D::RefCountedResource::textureOrFinal((C3D::RefCountedResource *)v15, RenderContext);
    C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>::insert(v34, v42, &v77);
    v33 = *((_WORD *)a2 + 33);
  }
  if ((v33 & 0x20) != 0)
  {
    v43 = *((_QWORD *)this + 17);
    v44 = (const char *)*((_QWORD *)a2 + 1);
    v45 = strlen(v44);
    v46 = 0xC6A4A7935BD1E995 * v45;
    if (v45 >= 8)
    {
      v47 = v45 >> 3;
      v48 = (unsigned __int8 *)&v44[8 * v47];
      v49 = 8 * v47;
      do
      {
        v50 = *(_QWORD *)v44;
        v44 += 8;
        v46 = 0xC6A4A7935BD1E995
            * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v50) ^ ((0xC6A4A7935BD1E995 * v50) >> 47))) ^ v46);
        v49 -= 8;
      }
      while (v49);
      v44 = (const char *)v48;
    }
    switch(v45 & 7)
    {
      case 1u:
        goto LABEL_54;
      case 2u:
        goto LABEL_53;
      case 3u:
        goto LABEL_52;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_50;
      case 6u:
        goto LABEL_49;
      case 7u:
        v46 ^= (unint64_t)*((unsigned __int8 *)v44 + 6) << 48;
LABEL_49:
        v46 ^= (unint64_t)*((unsigned __int8 *)v44 + 5) << 40;
LABEL_50:
        v46 ^= (unint64_t)*((unsigned __int8 *)v44 + 4) << 32;
LABEL_51:
        v46 ^= (unint64_t)*((unsigned __int8 *)v44 + 3) << 24;
LABEL_52:
        v46 ^= (unint64_t)*((unsigned __int8 *)v44 + 2) << 16;
LABEL_53:
        v46 ^= (unint64_t)*((unsigned __int8 *)v44 + 1) << 8;
LABEL_54:
        v46 = 0xC6A4A7935BD1E995 * (v46 ^ *(unsigned __int8 *)v44);
        break;
      default:
        break;
    }
    v51 = (0xC6A4A7935BD1E995 * (v46 ^ (v46 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v46 ^ (v46 >> 47))) >> 47);
    *(_QWORD *)&v77 = C3D::RefCountedResource::resolveTextureOrFinal((C3D::RefCountedResource *)v15, RenderContext);
    C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>::insert(v43, v51, &v77);
  }
  return v15;
}

uint64_t C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::back(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;

  if (!*(_DWORD *)(a1 + 8))
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::back(v2, v3, v4);
  }
  return *(_QWORD *)(a1 + 16) + 40 * *(unsigned int *)(a1 + 8) - 40;
}

uint64_t C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::emplace_back(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  const void *v4;
  unsigned int v5;
  void *Aligned;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 12);
  v4 = *(const void **)(a1 + 16);
  if (v2 + 1 > v3)
  {
    v5 = ((double)(v3 + 1) * 1.5);
    Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)a1, 40 * v5, 8, 0);
    memcpy(Aligned, v4, 40 * *(unsigned int *)(a1 + 8));
    *(_QWORD *)(a1 + 16) = Aligned;
    *(_DWORD *)(a1 + 12) = v5;
    v4 = Aligned;
    v2 = *(_DWORD *)(a1 + 8);
  }
  result = C3D::RefCountedResource::RefCountedResource((uint64_t)v4 + 40 * v2);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t C3D::RefCountedResource::RefCountedResource(uint64_t this)
{
  *(_BYTE *)(this + 34) &= 0xF8u;
  *(_WORD *)(this + 32) = 256;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  return this;
}

uint64_t SCNMTLTexturePool::allocate(uint64_t a1, __int128 *a2, void *a3, int a4)
{
  void *v4;
  unint64_t v7;
  __int128 *v8;
  __int128 *v9;
  uint64_t v10;
  BOOL v11;
  BOOL v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  __int128 v37;
  __int128 v39;
  unsigned int v40;
  __int128 v41;
  int v42;

  v4 = a3;
  v7 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v7)
  {
    v8 = *(__int128 **)(a1 + 16);
    v9 = &v8[2 * v7];
    v10 = 32 * v7;
    while (1)
    {
      v11 = *(_QWORD *)a2 == *((_QWORD *)v8 + 1) && *((_QWORD *)a2 + 1) == *((_QWORD *)v8 + 2);
      v12 = v11 && *((_DWORD *)a2 + 4) == (unint64_t)*((unsigned int *)v8 + 6);
      if (v12 && (!a4 || *((_DWORD *)v8 + 7) >= 3u))
        break;
      v8 += 2;
      v10 -= 32;
      if (!v10)
        goto LABEL_14;
    }
    v13 = *(_QWORD *)v8;
    *((_DWORD *)v8 + 7) = 0;
    if (v10 != 32)
    {
      v7 = (unint64_t)(v9 - 2);
      v31 = *v8;
      v30 = v8[1];
      v32 = *(v9 - 1);
      *v8 = *(v9 - 2);
      v8[1] = v32;
      *(_OWORD *)v7 = v31;
      *(_OWORD *)(v7 + 16) = v30;
      LODWORD(v7) = *(_DWORD *)(a1 + 40);
    }
    *(_DWORD *)(a1 + 40) = v7 - 1;
  }
  else
  {
LABEL_14:
    if (!a3)
    {
      v41 = *a2;
      v42 = *((_DWORD *)a2 + 4);
      v4 = SCNMTLTextureDescToMTLTextureDescriptor((unsigned __int16 *)&v41);
    }
    v13 = objc_msgSend(*(id *)(a1 + 8), "newTextureWithDescriptor:", v4);
    v39 = *a2;
    v40 = *((_DWORD *)a2 + 4);
    if (v13)
    {
      v14 = *(_QWORD *)(a1 + 32);
      v15 = *(_QWORD *)(a1 + 24);
      if (v15 >= v14)
      {
        v24 = *(_QWORD *)(a1 + 16);
        v25 = (uint64_t)(v15 - v24) >> 5;
        v26 = v25 + 1;
        if ((unint64_t)(v25 + 1) >> 59)
          abort();
        v27 = v14 - v24;
        if (v27 >> 4 > v26)
          v26 = v27 >> 4;
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFE0)
          v28 = 0x7FFFFFFFFFFFFFFLL;
        else
          v28 = v26;
        if (v28)
          v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>(a1 + 32, v28);
        else
          v29 = 0;
        v33 = &v29[32 * v25];
        v34 = &v29[32 * v28];
        *(_QWORD *)v33 = v13;
        *(_OWORD *)(v33 + 8) = v39;
        *((_DWORD *)v33 + 6) = v40;
        *((_DWORD *)v33 + 7) = 0;
        v16 = v33 + 32;
        v36 = *(char **)(a1 + 16);
        v35 = *(char **)(a1 + 24);
        if (v35 != v36)
        {
          do
          {
            v37 = *((_OWORD *)v35 - 1);
            *((_OWORD *)v33 - 2) = *((_OWORD *)v35 - 2);
            *((_OWORD *)v33 - 1) = v37;
            v33 -= 32;
            v35 -= 32;
          }
          while (v35 != v36);
          v35 = *(char **)(a1 + 16);
        }
        *(_QWORD *)(a1 + 16) = v33;
        *(_QWORD *)(a1 + 24) = v16;
        *(_QWORD *)(a1 + 32) = v34;
        if (v35)
          operator delete(v35);
      }
      else
      {
        *(_QWORD *)v15 = v13;
        *(_OWORD *)(v15 + 8) = v39;
        *(_QWORD *)(v15 + 24) = v40;
        v16 = (char *)(v15 + 32);
      }
      *(_QWORD *)(a1 + 24) = v16;
    }
    else
    {
      v17 = scn_default_log();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        SCNMTLTexturePool::allocate((uint64_t)v4, v17, v18, v19, v20, v21, v22, v23);
    }
  }
  return v13;
}

uint64_t SCNMTLDeviceSupportsMemorylessStorage(void *a1)
{
  if (C3DSceneSourceGetSceneCount())
    return objc_msgSend(a1, "supportsMemorylessRenderTargets");
  else
    return objc_msgSend(a1, "supportsFeatureSet:", 5);
}

void SCNMTLTexturePool::free(uint64_t a1, uint64_t a2)
{
  _OWORD *v3;
  unint64_t v4;
  _OWORD *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  v3 = *(_OWORD **)(a1 + 24);
  v4 = *(unsigned int *)(a1 + 40);
  v5 = (_OWORD *)(*(_QWORD *)(a1 + 16) + 32 * v4);
  if (v5 == v3)
  {
LABEL_5:
    v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      SCNMTLTexturePool::free(a2, v7, v8, v9, v10, v11, v12, v13);
  }
  else
  {
    v6 = 0;
    while (*(_QWORD *)&v5[v6] != a2)
    {
      v6 += 2;
      if (&v5[v6] == v3)
        goto LABEL_5;
    }
    if (v6 * 16)
    {
      v4 = (unint64_t)&v5[v6];
      v15 = v5[v6];
      v14 = v5[v6 + 1];
      v16 = v5[1];
      *(_OWORD *)v4 = *v5;
      *(_OWORD *)(v4 + 16) = v16;
      *v5 = v15;
      v5[1] = v14;
      LODWORD(v4) = *(_DWORD *)(a1 + 40);
    }
    *(_DWORD *)(a1 + 40) = v4 + 1;
  }
}

void C3D::MainPass::compile(C3D::MainPass *this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,__int128 a28,uint64_t a29,float a30,float a31,float a32,float a33,float a34,float a35,int8x8_t a36,float a37,int a38,float a39,int a40,float a41,float a42,float a43,float a44,float a45,float a46,float a47,float a48,float a49,uint64_t a50,float32x2_t a51,float a52,int a53,int a54,unsigned int a55,unsigned int a56,unint64_t a57,float a58,int a59,float a60,float a61,float a62,__int128 a63)
{
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  uint64_t v69;

  C3D::ScenePass::compile(this);
  v69 = *((_QWORD *)this + 681);
  if (v69)
    C3D::PostProcessPassesComputeUniforms(*((_QWORD *)this + 2), v69, this, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, a17, a18, a19,
      a20,
      a21,
      a22,
      a23,
      a24,
      a25,
      a26,
      a27,
      a28,
      a29,
      a30,
      a31,
      a32,
      a33,
      a34,
      a35,
      a36,
      a37,
      a38,
      a39,
      a40,
      a41,
      a42,
      a43,
      a44,
      a45,
      a46,
      a47,
      a48,
      a49,
      a50,
      a51,
      a52,
      a53,
      a54,
      a55,
      a56,
      a57,
      a58,
      a59,
      a60,
      a61,
      a62,
      a63);
}

_DWORD *C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(_DWORD *result, _QWORD *a2)
{
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  const void *v7;
  unsigned int v8;
  void *Aligned;

  v3 = result;
  v4 = result[2];
  v5 = result[3];
  v6 = v4 + 1;
  v7 = (const void *)*((_QWORD *)result + 2);
  if (v4 + 1 > v5)
  {
    v8 = ((double)(v5 + 1) * 1.5);
    Aligned = C3DStackAllocatorAllocateAligned(*(_QWORD *)result, 8 * v8, 8, 0);
    result = memcpy(Aligned, v7, 8 * v3[2]);
    *((_QWORD *)v3 + 2) = Aligned;
    v3[3] = v8;
    v4 = v3[2];
    v6 = v4 + 1;
    v7 = Aligned;
  }
  *((_QWORD *)v7 + v4) = *a2;
  v3[2] = v6;
  return result;
}

void C3D::Hash<C3D::Pass *,C3D::StackAllocator>::_allocate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4;
  size_t v5;
  size_t v6;

  if ((a2 & ((_DWORD)a2 - 1)) != 0)
    C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate(a1, a2, a3);
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = a2;
  v4 = a2 + 15;
  v5 = 2 * (a2 + 15);
  *(_QWORD *)(a1 + 24) = C3DStackAllocatorAllocateAligned(*(_QWORD *)a1, (2 * (a2 + 15)), 4, 0);
  v6 = 8 * v4;
  *(_QWORD *)(a1 + 8) = C3DStackAllocatorAllocateAligned(*(_QWORD *)a1, v6 & 0xFFFFFFF8, 8, 0);
  *(_QWORD *)(a1 + 16) = C3DStackAllocatorAllocateAligned(*(_QWORD *)a1, v6 & 0xFFFFFFF8, 8, 0);
  memset(*(void **)(a1 + 8), 255, v6);
  bzero(*(void **)(a1 + 24), v5);
}

uint64_t C3D::__deduceMemoryLess(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  char *Aligned;
  int v14;
  uint64_t v15;
  char v16;
  char v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;

  v33 = a3;
  v34 = 0;
  v35 = (char *)&v36;
  if (!a3)
  {
    v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      C3D::__deduceMemoryLess(v10, v11, v12);
  }
  Aligned = (char *)C3DStackAllocatorAllocateAligned(v33, (16 * (HIDWORD(v34) + a5)), 8, 0);
  memcpy(Aligned, v35, 16 * v34);
  v35 = Aligned;
  HIDWORD(v34) += a5;
  v14 = v34;
  if (a5 >= 1)
  {
    v15 = a5;
    do
    {
      v17 = *a4++;
      v16 = v17;
      v18 = v35;
      if ((v14 + 1) > HIDWORD(v34))
      {
        v19 = (char *)C3DStackAllocatorAllocateAligned(v33, 16 * ((double)(HIDWORD(v34) + 1) * 1.5), 8, 0);
        memcpy(v19, v35, 16 * v34);
        v35 = v19;
        HIDWORD(v34) = ((double)(HIDWORD(v34) + 1) * 1.5);
        v18 = v19;
        v14 = v34;
      }
      v20 = &v18[16 * v14];
      *(_QWORD *)v20 = a2;
      v20[8] = v16;
      v14 = v34 + 1;
      LODWORD(v34) = v34 + 1;
      --v15;
    }
    while (v15);
  }
  if (!v14)
    return 1;
  while (1)
  {
    v21 = &v35[16 * v14];
    v22 = *((_QWORD *)v21 - 2);
    v23 = *(v21 - 8);
    LODWORD(v34) = v34 - 1;
    v24 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)(*(_QWORD *)v22 + 32), v23)
                             + 31);
    C3D::RenderGraph::GraphNode::successorsAtIndex(v22, v23, a3, &v30);
    if (v31)
      break;
LABEL_15:
    v14 = v34;
    if (!(_DWORD)v34)
      return 1;
  }
  v25 = v32;
  v26 = 4 * v31;
  while (1)
  {
    v27 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(a1 + 24), *(_DWORD *)v25 & 0x7FFF);
    v28 = C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*(_QWORD *)v27 + 32), *(unsigned __int8 *)(v25 + 3));
    if (v24 < 2 || *(unsigned __int8 *)(v28 + 31) >= 2u)
      return 0;
    v25 += 4;
    v26 -= 4;
    if (!v26)
      goto LABEL_15;
  }
}

void *C3D::RenderGraph::GraphNode::successorsAtIndex@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  void *result;
  uint64_t v8;
  int *v9;
  uint64_t v10;
  int v11;

  result = C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::Array(a4, a3);
  v8 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v8)
  {
    v9 = *(int **)(a1 + 48);
    v10 = 4 * v8;
    do
    {
      v11 = *v9;
      if (a2 == BYTE2(v11))
        result = C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::push_back<C3D::RenderGraph::Link&>(a4, &v11);
      ++v9;
      v10 -= 4;
    }
    while (v10);
  }
  return result;
}

_DWORD *C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::push_back<C3D::RenderGraph::Link&>(_DWORD *result, _DWORD *a2)
{
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  const void *v6;
  unsigned int v7;
  void *Aligned;

  v3 = result;
  v4 = result[2];
  v5 = result[3];
  v6 = (const void *)*((_QWORD *)result + 2);
  if (v4 + 1 > v5)
  {
    v7 = ((double)(v5 + 1) * 1.5);
    Aligned = C3DStackAllocatorAllocateAligned(*(_QWORD *)result, 4 * v7, 4, 0);
    result = memcpy(Aligned, v6, 4 * v3[2]);
    *((_QWORD *)v3 + 2) = Aligned;
    v3[3] = v7;
    v6 = Aligned;
    v4 = v3[2];
  }
  *((_DWORD *)v6 + v4) = *a2;
  ++v3[2];
  return result;
}

void *C3DStackAllocatorAllocateAligned(uint64_t a1, size_t a2, uint64_t a3, int a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  vm_address_t *v22;
  vm_address_t *v23;
  size_t v24;
  uint64_t v25;

  if (!*(_DWORD *)(a1 + 576))
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      C3DStackAllocatorAllocateAligned_cold_2(v8, v9, v10, v11, v12, v13, v14, v15);
  }
  v16 = a3 - 1;
  v17 = -a3;
  v18 = *(_QWORD *)(a1 + 16);
  do
  {
    v19 = *(unsigned int *)(v18 + 12);
    v20 = *(_QWORD *)v18 + v19;
    v21 = (void *)((v16 + v20) & v17);
    if ((unint64_t)v21 + a2 - v20 <= (*(_DWORD *)(v18 + 8) - v19))
    {
      *(_DWORD *)(v18 + 12) = a2 + (_DWORD)v21 - *(_DWORD *)v18;
      goto LABEL_13;
    }
    v18 = *(_QWORD *)(v18 + 16);
  }
  while (v18);
  if (!*(_QWORD *)(a1 + 16))
    C3DStackAllocatorAllocateAligned_cold_1();
  v22 = (vm_address_t *)operator new();
  v23 = v22;
  *v22 = 0;
  v22[1] = 0;
  v22[2] = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v22;
  v24 = *(unsigned int *)(a1 + 32);
  if (a3 + a2 >= v24)
    v25 = (a3 + a2);
  else
    v25 = v24;
  __allocateChunk(v22, v25);
  *(_DWORD *)(a1 + 56) += v25;
  v21 = (void *)((v16 + *v23 + *((unsigned int *)v23 + 3)) & v17);
  *((_DWORD *)v23 + 3) = a2 + (_DWORD)v21 - *(_DWORD *)v23;
LABEL_13:
  if (a4 == 2)
  {
    memset(v21, 255, a2);
  }
  else if (a4 == 1)
  {
    bzero(v21, a2);
  }
  return v21;
}

void C3D::PassResource::setInputAtIndex(C3D::PassResource *this, C3D::RefCountedResource *a2, unsigned int a3)
{
  NSObject *v6;

  if (*((unsigned __int16 *)this + 8) <= a3)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3D::PassResource::inputAtIndex();
  }
  *(_QWORD *)(*(_QWORD *)this + 8 * a3) = a2;
}

uint64_t C3D::RenderGraph::lastNodeUsingResourceAtIndex(uint64_t result, _BYTE *a2, unsigned int a3, unsigned int a4, C3D::Pass ***a5, uint64_t *a6, BOOL *a7, BOOL *a8)
{
  uint64_t v12;
  uint64_t StackAllocator;
  C3D::Pass **v14;
  uint64_t v15;
  unsigned int v16;
  _DWORD *v17;
  unsigned int v18;
  int v19;
  BOOL v21;
  uint64_t v22;
  uint64_t v26;
  int v27;

  if (*a2 == 1)
  {
    v12 = result;
    StackAllocator = C3DEngineContextGetStackAllocator(*(_QWORD *)(result + 8));
    v14 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(v12 + 24), a3);
    if (C3D::PassDescriptor::outputCount((C3D::Pass *)((char *)*v14 + 32)) <= a4)
    {
      v15 = 0;
      LOBYTE(v16) = a4;
    }
    else
    {
      v15 = 0;
      LOBYTE(v16) = a4;
      do
      {
        if ((*(_WORD *)(C3D::Pass::outputBufferParameterAtIndex(*v14, v16) + 66) & 0x80) == 0)
          break;
        C3D::RenderGraph::GraphNode::successorsAtIndex((uint64_t)v14, v16, StackAllocator, &v26);
        if (!v27)
          break;
        v16 = HIBYTE(*(_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v26, 0));
        v17 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v26, 0);
        v14 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(v12 + 24), *v17 & 0x7FFF);
        v15 = C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)*v14 + 32), v16);
      }
      while (C3D::PassDescriptor::outputCount((C3D::Pass *)((char *)*v14 + 32)) > v16);
    }
    result = C3D::PassDescriptor::inputCount((C3D::Pass *)((char *)*v14 + 32));
    if (result > v16)
    {
      v18 = v16;
      v19 = a2[31];
      result = C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)*v14 + 32), v18);
      *a7 = v19 != *(unsigned __int8 *)(result + 31);
    }
    v21 = *((_DWORD *)*v14 + 8) == 5 && a2[64] == 1;
    *a8 = v21;
    *a5 = v14;
    if (!v15)
    {
      v22 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(v12 + 24), a3);
      result = C3D::PassDescriptor::inputAtIndex((C3D::PassDescriptor *)(*(_QWORD *)v22 + 32), a4);
      v15 = result;
    }
    *a6 = v15;
  }
  return result;
}

void C3D::RenderGraph::resolvePartialCompatibility(C3D::RenderGraph *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned __int16 *v4;
  uint64_t v5;
  C3D::PassDescriptor *v6;
  unsigned int v7;
  C3D::PassDescriptor *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t j;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  BOOL v27;
  BOOL v28;
  __int16 v29;
  _WORD *v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t i;
  uint64_t v37;
  __int16 *v38;
  __int16 *v39;
  unsigned __int8 v40;
  uint64_t v41;
  unsigned __int8 *v42;
  C3D::PassDescriptor *v43;
  C3D::PassDescriptor *v44;
  __int16 *v45;
  NSObject *v46;
  NSObject *v47;
  uint64_t v48;
  unsigned int *v49;
  uint64_t v50;
  unsigned int v51;
  C3D::PassIODescriptor *v52;
  C3D::Pass **v53;
  const C3D::PassIODescriptor *v54;
  __int16 *v55;
  __int16 *v56;
  uint64_t k;
  uint64_t v58;
  unsigned __int16 *v59;
  unsigned __int16 *v60;
  uint64_t v61;
  C3D::PassDescriptor *v62;
  unsigned __int8 v63;
  unsigned __int8 v64;
  unsigned __int8 v65;
  uint64_t v66;
  unsigned __int8 *v67;
  C3D::PassDescriptor *v68;
  C3D::PassDescriptor *v69;
  __int16 *v70;
  NSObject *v71;
  NSObject *v72;
  uint64_t v73;
  unsigned int *v74;
  uint64_t v75;
  unsigned int v76;
  __int16 *v77;
  C3D::Pass **v78;
  __int16 *v79;
  unsigned __int16 *v80;
  uint8_t v81[4];
  uint64_t v82;
  uint8_t v83[4];
  uint64_t v84;
  uint8_t v85[4];
  uint64_t v86;
  uint8_t v87[4];
  uint64_t v88;
  uint8_t v89[4];
  uint64_t v90;
  _BYTE v91[16];
  uint8_t v92[4];
  uint64_t v93;
  _BYTE v94[16];
  uint64_t v95;

  v95 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 12);
  if (v2)
  {
    while (1)
    {
      v3 = *(unsigned int *)(v2 + 8);
      if ((_DWORD)v3)
        break;
LABEL_74:
      v2 = *(_QWORD *)(v2 + 24);
      if (!v2)
        goto LABEL_75;
    }
    v4 = *(unsigned __int16 **)(v2 + 16);
    v80 = &v4[v3];
    while (1)
    {
      v5 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v4);
      v6 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
      v7 = C3D::PassDescriptor::inputCount(v6);
      v8 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
      v9 = C3D::PassDescriptor::outputCount(v8);
      v10 = v7;
      if (v7)
      {
        v11 = 0;
        do
        {
          if ((*(_WORD *)(C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v5, v11) + 66) & 0x80) != 0)
          {
            v12 = C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v5, v11);
            v13 = v12;
            if (v2 == *((_QWORD *)this + 12) && (*(_WORD *)(v12 + 66) & 0x100) == 0)
            {
              v14 = scn_default_log();
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
                C3D::RenderGraph::resolvePartialCompatibility((uint64_t)v94, (_QWORD *)v5);
              v15 = scn_default_log();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::resolvePartialCompatibility(v92, &v93, v15);
            }
            *(_WORD *)(v13 + 66) |= 0x80u;
          }
          ++v11;
        }
        while (v10 != v11);
      }
      if (v9)
        break;
LABEL_50:
      if ((_DWORD)v10)
      {
        for (i = 0; i != v10; ++i)
        {
          v37 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v5, i);
          if ((*(_WORD *)(v37 + 66) & 0x80) != 0)
          {
            v38 = (__int16 *)(v37 + 16);
            v39 = (__int16 *)(C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v5, i) + 16);
            C3D::PropagateMissingTextureParameters(v38, v39);
            C3D::PropagateMissingTextureParameters(v39, v38);
          }
        }
        v40 = 0;
        do
        {
          v41 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v5, v40);
          if ((*(_WORD *)(v41 + 66) & 4) != 0)
          {
            v42 = (unsigned __int8 *)v41;
            v43 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
            if (C3D::PassDescriptor::outputCount(v43) == 1)
            {
              v44 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v5);
              v45 = (__int16 *)C3D::PassDescriptor::outputAtIndex(v44, 0);
            }
            else
            {
              if (!**((_BYTE **)v42 + 1))
              {
                v46 = scn_default_log();
                if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
                  C3D::RenderGraph::resolvePartialCompatibility(v87, &v88, v46);
              }
              v45 = (__int16 *)C3D::Pass::outputBufferParameterNamed(*(C3D::Pass **)v5, *((const char **)v42 + 1));
              if (!v45)
                C3D::RenderGraph::resolvePartialCompatibility();
            }
            if (*v42 != *(unsigned __int8 *)v45)
            {
              v47 = scn_default_log();
              if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::resolvePartialCompatibility(v85, &v86, v47);
            }
            C3D::PropagateMissingTextureParameters((__int16 *)v42 + 8, v45 + 8);
          }
          ++v40;
        }
        while (v10 > v40);
      }
      v48 = *(unsigned int *)(v5 + 40);
      if ((_DWORD)v48)
      {
        v49 = *(unsigned int **)(v5 + 48);
        v50 = 4 * v48;
        do
        {
          v51 = *v49;
          v52 = (C3D::PassIODescriptor *)C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v5, BYTE2(*v49));
          v53 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), v51 & 0x7FFF);
          v54 = (const C3D::PassIODescriptor *)C3D::Pass::inputBufferParameterAtIndex(*v53, HIBYTE(v51));
          if (!C3D::PassIODescriptor::isCompatible(v52, v54))
          {
            v55 = (__int16 *)((char *)v52 + 16);
            v56 = (__int16 *)((char *)v54 + 16);
            C3D::PropagateMissingTextureParameters(v55, v56);
            C3D::PropagateMissingTextureParameters(v56, v55);
          }
          ++v49;
          v50 -= 4;
        }
        while (v50);
      }
      if (++v4 == v80)
        goto LABEL_74;
    }
    for (j = 0; j != v9; ++j)
    {
      if ((*(_WORD *)(C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v5, j) + 66) & 0x80) != 0)
      {
        v17 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v5, j);
        v18 = v17;
        if (v2 == *((_QWORD *)this + 12) && (*(_WORD *)(v17 + 66) & 0x100) == 0)
        {
          v19 = scn_default_log();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            C3D::RenderGraph::resolvePartialCompatibility((uint64_t)v91, (_QWORD *)v5);
          v20 = scn_default_log();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
            C3D::RenderGraph::resolvePartialCompatibility(v89, &v90, v20);
        }
        *(_WORD *)(v18 + 66) |= 0x80u;
      }
    }
    v21 = 0;
    while (1)
    {
      v22 = C3D::Pass::outputBufferParameterAtIndex(*(C3D::Pass **)v5, v21);
      v23 = *(unsigned int *)(v5 + 40);
      if ((_DWORD)v23)
      {
        v24 = *(_QWORD *)(v5 + 48);
        v25 = 4 * v23 - 4;
        do
        {
          v26 = *(unsigned __int8 *)(v24 + 2);
          v27 = v26 == v21;
          v28 = v26 == v21 || v25 == 0;
          v25 -= 4;
          v24 += 4;
        }
        while (!v28);
        v30 = (_WORD *)(v22 + 66);
        v29 = *(_WORD *)(v22 + 66);
        if ((v29 & 8) == 0)
          goto LABEL_39;
        if (v26 == v21)
        {
          v31 = v29 & 0xFFF7;
          goto LABEL_48;
        }
      }
      else
      {
        v30 = (_WORD *)(v22 + 66);
        v29 = *(_WORD *)(v22 + 66);
        if ((v29 & 8) == 0)
        {
          v27 = 0;
LABEL_39:
          if (v27 || (v29 & 0x80) == 0)
            goto LABEL_49;
          v31 = v29 | 8;
LABEL_48:
          *v30 = v31;
          goto LABEL_49;
        }
      }
      if ((v29 & 0x80) != 0)
      {
        v32 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v5, v21);
        v33 = *(unsigned int *)(v5 + 16);
        if ((_DWORD)v33)
        {
          v34 = *(_QWORD *)(v5 + 24);
          v35 = 4 * v33;
          while (*(unsigned __int8 *)(v34 + 2) != v21)
          {
            v34 += 4;
            v35 -= 4;
            if (!v35)
              goto LABEL_47;
          }
          goto LABEL_49;
        }
LABEL_47:
        *(_WORD *)(v32 + 66) &= ~0x80u;
        v31 = *v30 & 0xFF7C | 2;
        goto LABEL_48;
      }
LABEL_49:
      if (++v21 == v9)
        goto LABEL_50;
    }
  }
LABEL_75:
  for (k = *((_QWORD *)this + 13); k; k = *(_QWORD *)(k + 32))
  {
    v58 = *(unsigned int *)(k + 8);
    if ((_DWORD)v58)
    {
      v59 = *(unsigned __int16 **)(k + 16);
      v60 = &v59[v58];
      do
      {
        v61 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v59);
        v62 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v61);
        v63 = C3D::PassDescriptor::inputCount(v62);
        if (v63)
        {
          v64 = v63;
          v65 = 0;
          do
          {
            v66 = C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v61, v65);
            if ((*(_WORD *)(v66 + 66) & 4) != 0)
            {
              v67 = (unsigned __int8 *)v66;
              v68 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v61);
              if (C3D::PassDescriptor::outputCount(v68) == 1)
              {
                v69 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*(C3D::Pass **)v61);
                v70 = (__int16 *)C3D::PassDescriptor::outputAtIndex(v69, 0);
              }
              else
              {
                if (!**((_BYTE **)v67 + 1))
                {
                  v71 = scn_default_log();
                  if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
                    C3D::RenderGraph::resolvePartialCompatibility(v83, &v84, v71);
                }
                v70 = (__int16 *)C3D::Pass::outputBufferParameterNamed(*(C3D::Pass **)v61, *((const char **)v67 + 1));
                if (!v70)
                  C3D::RenderGraph::resolvePartialCompatibility();
              }
              if (*v67 != *(unsigned __int8 *)v70)
              {
                v72 = scn_default_log();
                if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
                  C3D::RenderGraph::resolvePartialCompatibility(v81, &v82, v72);
              }
              C3D::PropagateMissingTextureParameters(v70 + 8, (__int16 *)v67 + 8);
            }
            ++v65;
          }
          while (v65 < v64);
        }
        v73 = *(unsigned int *)(v61 + 16);
        if ((_DWORD)v73)
        {
          v74 = *(unsigned int **)(v61 + 24);
          v75 = 4 * v73;
          do
          {
            v76 = *v74;
            v77 = (__int16 *)C3D::Pass::inputBufferParameterAtIndex(*(C3D::Pass **)v61, BYTE2(*v74));
            v78 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), v76 & 0x7FFF);
            v79 = (__int16 *)C3D::Pass::outputBufferParameterAtIndex(*v78, HIBYTE(v76));
            if (!C3D::PassIODescriptor::isCompatible((C3D::PassIODescriptor *)v77, (const C3D::PassIODescriptor *)v79))
              C3D::PropagateMissingTextureParameters(v77 + 8, v79 + 8);
            ++v74;
            v75 -= 4;
          }
          while (v75);
        }
        ++v59;
      }
      while (v59 != v60);
    }
  }
}

uint64_t C3D::PassDescriptor::inputCount(C3D::PassDescriptor *this)
{
  return *((unsigned __int16 *)this + 20);
}

uint64_t C3D::Pass::inputBufferParameterAtIndex(C3D::Pass *this, unsigned int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*((unsigned __int16 *)this + 36) <= a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3D::Pass::inputBufferParameterAtIndex(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return C3D::PassDescriptor::inputAtIndex((C3D::Pass *)((char *)this + 32), a2);
}

uint64_t C3D::PassDescriptor::inputAtIndex(C3D::PassDescriptor *this, unsigned int a2)
{
  NSObject *v4;

  if (*((unsigned __int16 *)this + 20) <= a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3D::PassDescriptor::inputAtIndex();
  }
  return *((_QWORD *)this + 3) + 80 * a2;
}

uint64_t C3D::Pass::outputBufferParameterAtIndex(C3D::Pass *this, unsigned int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*((unsigned __int16 *)this + 37) <= a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3D::Pass::outputBufferParameterAtIndex(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return C3D::PassDescriptor::outputAtIndex((C3D::Pass *)((char *)this + 32), a2);
}

BOOL C3D::PassIODescriptor::isCompatible(C3D::PassIODescriptor *this, const C3D::PassIODescriptor *a2)
{
  int v2;
  int v3;
  uint64_t v4;

  if (*((unsigned __int16 *)this + 8) != *((unsigned __int16 *)a2 + 8)
    || *((unsigned __int16 *)this + 9) != *((unsigned __int16 *)a2 + 9)
    || *((unsigned __int16 *)this + 10) != *((unsigned __int16 *)a2 + 10)
    || *((unsigned __int16 *)this + 11) != *((unsigned __int16 *)a2 + 11))
  {
    return 0;
  }
  v2 = *((unsigned __int8 *)this + 24);
  v3 = *((unsigned __int8 *)a2 + 24);
  if (v2 == v3 || v2 == 4 && v3 == 2 || (v4 = 0, v2 == 8) && v3 == 3)
  {
    if (*((unsigned __int8 *)this + 25) == *((unsigned __int8 *)a2 + 25)
      && *((unsigned __int8 *)this + 27) == *((unsigned __int8 *)a2 + 27)
      && *((unsigned __int16 *)this + 14) == *((unsigned __int16 *)a2 + 14))
    {
      return *((unsigned __int8 *)this + 30) == *((unsigned __int8 *)a2 + 30);
    }
    return 0;
  }
  return v4;
}

__int16 *C3D::PropagateMissingTextureParameters(__int16 *result, __int16 *a2)
{
  __int16 v2;
  __int16 v3;
  __int16 v4;
  unsigned int v5;
  char v6;
  char v7;
  char v8;
  char v9;
  __int16 v10;
  unsigned int v11;

  v2 = *a2;
  if (!*a2)
    v2 = *result;
  *a2 = v2;
  v3 = a2[1];
  if (!v3)
    v3 = result[1];
  a2[1] = v3;
  v4 = a2[2];
  if (!v4)
    v4 = result[2];
  a2[2] = v4;
  v5 = (unsigned __int16)a2[3];
  if (v5 <= (unsigned __int16)result[3])
    LOWORD(v5) = result[3];
  a2[3] = v5;
  v6 = *((_BYTE *)a2 + 8);
  if (!v6)
    v6 = *((_BYTE *)result + 8);
  *((_BYTE *)a2 + 8) = v6;
  v7 = *((_BYTE *)a2 + 9);
  if (!v7)
    v7 = *((_BYTE *)result + 9);
  *((_BYTE *)a2 + 9) = v7;
  v8 = *((_BYTE *)a2 + 10);
  if (!v8)
    v8 = *((_BYTE *)result + 10);
  *((_BYTE *)a2 + 10) = v8;
  v9 = *((_BYTE *)a2 + 11);
  if (!v9)
    v9 = *((_BYTE *)result + 11);
  *((_BYTE *)a2 + 11) = v9;
  v10 = a2[6];
  if (!v10)
    v10 = result[6];
  a2[6] = v10;
  v11 = *((unsigned __int8 *)a2 + 14);
  if (v11 <= *((unsigned __int8 *)result + 14))
    LOBYTE(v11) = *((_BYTE *)result + 14);
  *((_BYTE *)a2 + 14) = v11;
  return result;
}

uint64_t C3D::RenderGraph::outputTextureUsageForPass(C3D::RenderGraph *this, const C3D::Pass *a2, const C3D::PassIODescriptor *a3)
{
  uint64_t v4;
  int v5;
  uint64_t v6;

  if (*((_QWORD *)this + 21))
    return 7;
  v4 = *((unsigned __int8 *)a3 + 26);
  v5 = *(_DWORD *)C3D::Pass::descriptor(a2);
  v6 = v4 | 4;
  if (v5 != 2)
    v6 = v4;
  if (v5 == 3)
    return v4 | 2;
  else
    return v6;
}

_QWORD *C3DRenderGraphSetWarmupPixelFormat(_QWORD *result, unsigned int a2)
{
  *result = a2;
  return result;
}

uint64_t C3DEngineContextRenderWithRenderGraph(uint64_t a1)
{
  C3D::RenderGraph *v1;

  v1 = *(C3D::RenderGraph **)(a1 + 1728);
  C3DRenderGraphReset(v1);
  C3DLoadBuiltInPasses((uint64_t)v1);
  C3DRenderGraphSetup(v1);
  C3DRenderGraphCompile(v1);
  return C3DRenderGraphExecute(v1);
}

uint64_t C3D::RenderGraph::setup(C3D::RenderGraph *this)
{
  uint64_t StackAllocator;
  uint64_t RenderContext;
  uint64_t v4;
  uint64_t i;
  _QWORD *v6;
  BOOL v7;

  StackAllocator = C3DEngineContextGetStackAllocator(*((_QWORD *)this + 1));
  C3DStackAllocatorPushFrame(StackAllocator);
  *((_BYTE *)this + 209) = 1;
  RenderContext = C3DEngineContextGetRenderContext(*((_QWORD *)this + 1));
  if (*((_QWORD *)this + 21))
    objc_msgSend((id)-[SCNMTLRenderContext layerTarget](RenderContext), "setFramebufferOnly:", 0);
  v4 = *(unsigned int *)(*((_QWORD *)this + 3) + 8);
  if ((_DWORD)v4)
  {
    for (i = 0; i != v4; ++i)
    {
      v6 = (_QWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), i);
      (*(void (**)(_QWORD))(*(_QWORD *)*v6 + 8))(*v6);
    }
  }
  C3D::RenderGraph::resolvePartialDependencies(this);
  C3D::RenderGraph::removeInvalidPasses(this);
  v7 = C3D::RenderGraph::sort(this);
  *((_BYTE *)this + 211) = v7;
  if (v7)
  {
    C3D::RenderGraph::resolvePartialCompatibility(this);
    C3D::RenderGraph::validate(this);
  }
  *((_BYTE *)this + 209) = 0;
  return C3DStackAllocatorPopFrame(StackAllocator);
}

void C3D::RenderGraph::validate(C3D::RenderGraph *this)
{
  uint64_t i;
  uint64_t v3;
  unsigned __int16 *v4;
  _QWORD *v5;
  C3D::PassDescriptor *v6;
  unint64_t v7;
  C3D::PassDescriptor *v8;
  uint64_t v9;
  C3D::PassDescriptor *v10;
  C3D::PassIODescriptor *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  C3D::PassDescriptor *v16;
  int v17;
  _BYTE *v18;
  _BYTE *v19;
  std::string *p_p;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int *v24;
  uint64_t v25;
  C3D::Pass **v26;
  NSObject *v27;
  NSObject *v28;
  C3D::PassDescriptor *v29;
  uint64_t v30;
  C3D::PassDescriptor *v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  NSObject *v44;
  NSObject *v45;
  NSObject *v46;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  _BYTE *v51;
  int v52;
  _BYTE *v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  int v59;
  std::string *v60;
  uint64_t v61;
  int v62;
  std::string *v63;
  int v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t StackAllocator;
  uint64_t v73;
  int *v74;
  uint64_t v75;
  _QWORD *v76;
  int v77;
  NSObject *v78;
  NSObject *v79;
  std::string::size_type v80;
  std::string::size_type v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  std::string::size_type v85;
  int v86;
  NSObject *v87;
  uint64_t v88;
  uint64_t v89;
  unsigned __int16 *v90;
  unsigned __int16 *v91;
  std::string __p;
  uint64_t v93;
  uint8_t v94[4];
  uint64_t v95;
  _BYTE v96[34];
  uint8_t v97[4];
  uint64_t v98;
  uint8_t v99[4];
  uint64_t v100;
  _BYTE v101[16];
  uint8_t v102[4];
  uint64_t v103;
  _BYTE v104[16];
  uint8_t v105[4];
  uint64_t v106;
  uint8_t v107[4];
  uint64_t v108;
  uint8_t v109[4];
  uint64_t v110;
  uint8_t v111[4];
  uint64_t v112;
  uint8_t buf[4];
  _BYTE *v114;
  __int16 v115;
  std::string *v116;
  _BYTE v117[24];
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  for (i = *((_QWORD *)this + 12); i; i = *(_QWORD *)(v89 + 24))
  {
    v89 = i;
    v3 = *(unsigned int *)(i + 8);
    if ((_DWORD)v3)
    {
      v4 = *(unsigned __int16 **)(i + 16);
      v90 = &v4[v3];
      do
      {
        v91 = v4;
        v5 = (_QWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v4);
        v6 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)*v5);
        if (C3D::PassDescriptor::inputCount(v6))
        {
          v7 = 0;
          do
          {
            v8 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)*v5);
            v9 = C3D::PassDescriptor::inputAtIndex(v8, (unsigned __int16)v7);
            if ((*(_WORD *)(v9 + 66) & 0x80) != 0)
            {
              v10 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)*v5);
              v11 = (C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex(v10, (unsigned __int16)v7);
              if (*(_DWORD *)C3D::Pass::descriptor((C3D::Pass *)*v5) == 2 && (*(_WORD *)(v9 + 66) & 3) != 1)
              {
                if ((C3D::RenderGraph::validate(void)::done & 1) == 0)
                {
                  C3D::RenderGraph::validate(void)::done = 1;
                  v12 = scn_default_log();
                  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
                  {
                    v21 = (**(uint64_t (***)(_QWORD))*v5)(*v5);
                    v22 = *(_QWORD *)(v9 + 8);
                    *(_DWORD *)v96 = 136315650;
                    *(_QWORD *)&v96[4] = v21;
                    *(_WORD *)&v96[12] = 2048;
                    *(_QWORD *)&v96[14] = v7;
                    *(_WORD *)&v96[22] = 2080;
                    *(_QWORD *)&v96[24] = v22;
                    _os_log_error_impl(&dword_1DCCB8000, v12, OS_LOG_TYPE_ERROR, "Error: ReadWrite pass %s require input %zu:%s with load mode set to \"Load\", forcing it.", v96, 0x20u);
                  }
                }
                *(_WORD *)(v9 + 66) = *(_WORD *)(v9 + 66) & 0xFFFC | 1;
              }
              if (!C3D::PassIODescriptor::isCompatible((C3D::PassIODescriptor *)v9, v11))
              {
                v13 = scn_default_log();
                if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
                  C3D::RenderGraph::validate((uint64_t)v117, v5);
                v14 = scn_default_log();
                if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
                {
                  C3D::PassIODescriptor::description((C3D::PassIODescriptor *)v9, (std::string *)v96);
                  v17 = v96[23];
                  v18 = *(_BYTE **)v96;
                  C3D::PassIODescriptor::description(v11, &__p);
                  v19 = v96;
                  if (v17 < 0)
                    v19 = v18;
                  p_p = &__p;
                  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                  *(_DWORD *)buf = 136315394;
                  v114 = v19;
                  v115 = 2080;
                  v116 = p_p;
                  _os_log_error_impl(&dword_1DCCB8000, v14, OS_LOG_TYPE_ERROR, "Error: Input %s doesn't match output %s.", buf, 0x16u);
                  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(__p.__r_.__value_.__l.__data_);
                  if ((v96[23] & 0x80000000) != 0)
                    operator delete(*(void **)v96);
                }
                v15 = scn_default_log();
                if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
                  C3D::RenderGraph::resolvePartialCompatibility(v111, &v112, v15);
              }
            }
            v16 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)*v5);
            ++v7;
          }
          while (v7 < C3D::PassDescriptor::inputCount(v16));
        }
        v23 = *((unsigned int *)v5 + 10);
        if ((_DWORD)v23)
        {
          v24 = (unsigned int *)v5[6];
          v25 = 4 * v23;
          do
          {
            v26 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v24 & 0x7FFF);
            if (HIBYTE(*v24) == 255 || (*v24 & 0xFF0000) == 0xFF0000)
            {
              v27 = scn_default_log();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              {
                v48 = (**(uint64_t (***)(C3D::Pass *))*v26)(*v26);
                v49 = (**(uint64_t (***)(_QWORD))*v5)(*v5);
                *(_DWORD *)v96 = 136315394;
                *(_QWORD *)&v96[4] = v48;
                *(_WORD *)&v96[12] = 2080;
                *(_QWORD *)&v96[14] = v49;
                _os_log_error_impl(&dword_1DCCB8000, v27, OS_LOG_TYPE_ERROR, "Error: Unresolved dependency between %s and %s\n", v96, 0x16u);
              }
              v28 = scn_default_log();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::validate(v109, &v110, v28);
            }
            v29 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)*v5);
            v30 = C3D::PassDescriptor::outputAtIndex(v29, *((unsigned __int8 *)v24 + 2));
            v31 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v26);
            v32 = C3D::PassDescriptor::inputAtIndex(v31, *((unsigned __int8 *)v24 + 3));
            if (*(_BYTE *)v30 == 1 && *(_BYTE *)(v30 + 31) == 1)
            {
              v33 = scn_default_log();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
              {
                v64 = *(unsigned __int8 *)(v30 + 31);
                v65 = (**(uint64_t (***)(_QWORD))*v5)(*v5);
                v66 = *((unsigned __int8 *)v24 + 2);
                v67 = *(_QWORD *)(v30 + 8);
                *(_DWORD *)v96 = 67109890;
                *(_DWORD *)&v96[4] = v64;
                *(_WORD *)&v96[8] = 2080;
                *(_QWORD *)&v96[10] = v65;
                *(_WORD *)&v96[18] = 1024;
                *(_DWORD *)&v96[20] = v66;
                *(_WORD *)&v96[24] = 2080;
                *(_QWORD *)&v96[26] = v67;
                _os_log_error_impl(&dword_1DCCB8000, v33, OS_LOG_TYPE_ERROR, "Error: Invalid output texture sampleCount %d for pass %s %d:%s, if no multisample needed, set it to 0", v96, 0x22u);
              }
              v34 = scn_default_log();
              if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::validate(v107, &v108, v34);
            }
            if (*(_BYTE *)v32 == 1 && *(_BYTE *)(v32 + 31) == 1)
            {
              v35 = scn_default_log();
              if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
              {
                v68 = *(unsigned __int8 *)(v32 + 31);
                v69 = (**(uint64_t (***)(C3D::Pass *))*v26)(*v26);
                v70 = *((unsigned __int8 *)v24 + 3);
                v71 = *(_QWORD *)(v32 + 8);
                *(_DWORD *)v96 = 67109890;
                *(_DWORD *)&v96[4] = v68;
                *(_WORD *)&v96[8] = 2080;
                *(_QWORD *)&v96[10] = v69;
                *(_WORD *)&v96[18] = 1024;
                *(_DWORD *)&v96[20] = v70;
                *(_WORD *)&v96[24] = 2080;
                *(_QWORD *)&v96[26] = v71;
                _os_log_error_impl(&dword_1DCCB8000, v35, OS_LOG_TYPE_ERROR, "Error: Invalid input texture sampleCount %d for pass %s %d:%s, if no multisample needed, set it to 0", v96, 0x22u);
              }
              v36 = scn_default_log();
              if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::validate(v105, &v106, v36);
            }
            if (!C3D::PassIODescriptor::isValid((C3D::PassIODescriptor *)v30))
            {
              v37 = scn_default_log();
              if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
                C3D::RenderGraph::validate((uint64_t)v104, v5);
              v38 = scn_default_log();
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              {
                v50 = *((unsigned __int8 *)v24 + 3);
                C3D::PassIODescriptor::description((C3D::PassIODescriptor *)v30, (std::string *)v96);
                v51 = v96;
                if (v96[23] < 0)
                  v51 = *(_BYTE **)v96;
                LODWORD(__p.__r_.__value_.__l.__data_) = 67109378;
                HIDWORD(__p.__r_.__value_.__r.__words[0]) = v50;
                LOWORD(__p.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v51;
                _os_log_error_impl(&dword_1DCCB8000, v38, OS_LOG_TYPE_ERROR, "Error: Invalid output parameters for port %d: %s", (uint8_t *)&__p, 0x12u);
                if ((v96[23] & 0x80000000) != 0)
                  operator delete(*(void **)v96);
              }
              v39 = scn_default_log();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::validate(v102, &v103, v39);
            }
            if (!C3D::PassIODescriptor::isValid((C3D::PassIODescriptor *)v32))
            {
              v40 = scn_default_log();
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                C3D::RenderGraph::validate((uint64_t)v101, v26);
              v41 = scn_default_log();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                v52 = *((unsigned __int8 *)v24 + 2);
                C3D::PassIODescriptor::description((C3D::PassIODescriptor *)v32, (std::string *)v96);
                v53 = v96;
                if (v96[23] < 0)
                  v53 = *(_BYTE **)v96;
                LODWORD(__p.__r_.__value_.__l.__data_) = 67109378;
                HIDWORD(__p.__r_.__value_.__r.__words[0]) = v52;
                LOWORD(__p.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v53;
                _os_log_error_impl(&dword_1DCCB8000, v41, OS_LOG_TYPE_ERROR, "Error: Buffer input parameters for port %d: %s", (uint8_t *)&__p, 0x12u);
                if ((v96[23] & 0x80000000) != 0)
                  operator delete(*(void **)v96);
              }
              v42 = scn_default_log();
              if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::validate(v99, &v100, v42);
            }
            if (!C3D::PassIODescriptor::isCompatible((C3D::PassIODescriptor *)v30, (const C3D::PassIODescriptor *)v32))
            {
              v43 = scn_default_log();
              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
              {
                v54 = (**(uint64_t (***)(_QWORD))*v5)(*v5);
                v55 = (**(uint64_t (***)(C3D::Pass *))*v26)(*v26);
                *(_DWORD *)v96 = 136315394;
                *(_QWORD *)&v96[4] = v54;
                *(_WORD *)&v96[12] = 2080;
                *(_QWORD *)&v96[14] = v55;
                _os_log_error_impl(&dword_1DCCB8000, v43, OS_LOG_TYPE_ERROR, "Error: Compatibility mismatch between %s and %s\n", v96, 0x16u);
              }
              v44 = scn_default_log();
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
              {
                v56 = *v24;
                v57 = BYTE2(*v24);
                *(_DWORD *)v96 = 67109376;
                *(_DWORD *)&v96[4] = v57;
                *(_WORD *)&v96[8] = 1024;
                *(_DWORD *)&v96[10] = HIBYTE(v56);
                _os_log_error_impl(&dword_1DCCB8000, v44, OS_LOG_TYPE_ERROR, "Error: Output buffer parameters for port %d isn't compatible with input port %d\n", v96, 0xEu);
              }
              v45 = scn_default_log();
              if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
              {
                v58 = (**(uint64_t (***)(_QWORD))*v5)(*v5);
                v59 = *((unsigned __int8 *)v24 + 3);
                C3D::PassIODescriptor::description((C3D::PassIODescriptor *)v30, &__p);
                v60 = &__p;
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                  v60 = (std::string *)__p.__r_.__value_.__r.__words[0];
                *(_DWORD *)v96 = 136315650;
                *(_QWORD *)&v96[4] = v58;
                *(_WORD *)&v96[12] = 1024;
                *(_DWORD *)&v96[14] = v59;
                *(_WORD *)&v96[18] = 2080;
                *(_QWORD *)&v96[20] = v60;
                _os_log_error_impl(&dword_1DCCB8000, v45, OS_LOG_TYPE_ERROR, "Error: Output descriptor of pass %s at port %d: %s", v96, 0x1Cu);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p.__r_.__value_.__l.__data_);
              }
              v46 = scn_default_log();
              if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
              {
                v61 = (**(uint64_t (***)(C3D::Pass *))*v26)(*v26);
                v62 = *((unsigned __int8 *)v24 + 2);
                C3D::PassIODescriptor::description((C3D::PassIODescriptor *)v32, &__p);
                v63 = &__p;
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                  v63 = (std::string *)__p.__r_.__value_.__r.__words[0];
                *(_DWORD *)v96 = 136315650;
                *(_QWORD *)&v96[4] = v61;
                *(_WORD *)&v96[12] = 1024;
                *(_DWORD *)&v96[14] = v62;
                *(_WORD *)&v96[18] = 2080;
                *(_QWORD *)&v96[20] = v63;
                _os_log_error_impl(&dword_1DCCB8000, v46, OS_LOG_TYPE_ERROR, "Error: Input descriptor of pass %s at port %d: %s", v96, 0x1Cu);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p.__r_.__value_.__l.__data_);
              }
              v47 = scn_default_log();
              if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::validate(v97, &v98, v47);
            }
            ++v24;
            v25 -= 4;
          }
          while (v25);
        }
        StackAllocator = C3DEngineContextGetStackAllocator(*((_QWORD *)this + 1));
        C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(v96, StackAllocator);
        v73 = *((unsigned int *)v5 + 4);
        if ((_DWORD)v73)
        {
          v74 = (int *)v5[3];
          v75 = 4 * v73;
          do
          {
            v76 = (_QWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v74 & 0x7FFF);
            v77 = *v74;
            buf[0] = BYTE2(*v74);
            buf[1] = HIBYTE(v77);
            C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::push_back<C3D::RenderGraph::PortsPair&>(v96, buf);
            if (HIBYTE(*v74) == 255 || (*v74 & 0xFF0000) == 0xFF0000)
            {
              v78 = scn_default_log();
              if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
              {
                v80 = (**(uint64_t (***)(_QWORD))*v5)(*v5);
                v81 = (**(uint64_t (***)(_QWORD))*v76)(*v76);
                LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
                *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v80;
                WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v81;
                _os_log_error_impl(&dword_1DCCB8000, v78, OS_LOG_TYPE_ERROR, "Error: Unresolved dependency between %s and %s\n", (uint8_t *)&__p, 0x16u);
              }
              v79 = scn_default_log();
              if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT))
                C3D::RenderGraph::validate(v94, &v95, v79);
            }
            ++v74;
            v75 -= 4;
          }
          while (v75);
        }
        v82 = 126 - 2 * __clz(*(unsigned int *)&v96[8]);
        if (*(_DWORD *)&v96[8])
          v83 = v82;
        else
          v83 = 0;
        std::__introsort<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *,false>(*(unsigned __int8 **)&v96[16], (unsigned __int8 *)(*(_QWORD *)&v96[16] + 2 * *(unsigned int *)&v96[8]), v83, 1);
        v84 = *(unsigned int *)&v96[8];
        if (*(_DWORD *)&v96[8])
        {
          v85 = 0;
          do
          {
            if (v85)
            {
              v86 = *(unsigned __int8 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[]((uint64_t)v96, v85);
              if (v86 == *(unsigned __int8 *)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::operator[]((uint64_t)v96, (int)v85 - 1))
              {
                v87 = scn_default_log();
                if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT))
                {
                  v88 = (**(uint64_t (***)(_QWORD))*v5)(*v5);
                  LODWORD(__p.__r_.__value_.__l.__data_) = 136315650;
                  *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)"index == 0 || inputPorts[index].a != inputPorts[index - 1].a";
                  WORD2(__p.__r_.__value_.__r.__words[1]) = 2048;
                  *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v85;
                  HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
                  v93 = v88;
                  _os_log_fault_impl(&dword_1DCCB8000, v87, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Multiple dependencies on the same input %zu on %s", (uint8_t *)&__p, 0x20u);
                }
              }
            }
            ++v85;
          }
          while (v84 != v85);
        }
        v4 = v91 + 1;
      }
      while (v91 + 1 != v90);
    }
  }
}

void sub_1DCD176D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a48 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unsigned __int8 *std::__introsort<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *,false>(unsigned __int8 *result, unsigned __int8 *a2, uint64_t a3, char a4)
{
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  unsigned int v16;
  unsigned int v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  __int16 v24;
  unsigned int v25;
  unsigned int v26;
  unsigned __int8 *v27;
  BOOL v28;
  __int16 v29;
  unsigned int v30;
  unsigned int v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  unsigned int v34;
  __int16 v35;
  unsigned int v36;
  unsigned int v37;
  unsigned __int8 *v38;
  __int16 v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  __int16 v42;
  __int16 v43;
  __int16 v44;
  __int16 v45;
  __int16 v46;
  unsigned __int8 *v47;
  BOOL v49;
  uint64_t v50;
  unsigned __int8 *v51;
  unsigned int v52;
  unsigned int v53;
  __int16 v54;
  uint64_t v55;
  unsigned int v56;
  unsigned __int8 *v57;
  int64_t v58;
  int64_t v59;
  int64_t v60;
  uint64_t v61;
  unsigned __int8 *v62;
  unsigned int v63;
  unsigned int v64;
  BOOL v65;
  unsigned __int8 *v66;
  __int16 v67;
  unsigned __int8 *v68;
  uint64_t v69;
  unsigned int v70;
  unsigned int v71;
  BOOL v72;
  uint64_t v73;
  uint64_t v74;
  __int16 v75;
  unsigned __int8 *v76;
  uint64_t v77;
  unsigned __int8 *v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unsigned __int8 *v82;
  __int16 v83;
  unsigned __int8 *v84;
  unsigned int v86;
  unsigned int v87;
  __int16 v88;
  _WORD *v89;
  __int16 v90;

  v7 = result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = a2 - v8;
    v10 = (a2 - v8) >> 1;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        if (*(a2 - 2) < *v8)
        {
          v39 = *(_WORD *)v8;
          *(_WORD *)v8 = *((_WORD *)a2 - 1);
          *((_WORD *)a2 - 1) = v39;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v8, v8 + 2, (_WORD *)a2 - 1);
      case 4uLL:
        return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v8, v8 + 2, (__int16 *)v8 + 2, (__int16 *)a2 - 1);
      case 5uLL:
        v40 = v8 + 4;
        v41 = v8 + 6;
        result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v8, v8 + 2, (__int16 *)v8 + 2, (__int16 *)v8 + 3);
        if (*(a2 - 2) < v8[6])
        {
          v42 = *(_WORD *)v41;
          *(_WORD *)v41 = *((_WORD *)a2 - 1);
          *((_WORD *)a2 - 1) = v42;
          if (*v41 < *v40)
          {
            v43 = *(_WORD *)v40;
            v44 = *(_WORD *)v41;
            *(_WORD *)v40 = *(_WORD *)v41;
            *(_WORD *)v41 = v43;
            if (v8[2] > v44)
            {
              v45 = *((_WORD *)v8 + 1);
              *((_WORD *)v8 + 1) = v44;
              *((_WORD *)v8 + 2) = v45;
              if (*v8 > v44)
              {
                v46 = *(_WORD *)v8;
                *(_WORD *)v8 = v44;
                *((_WORD *)v8 + 1) = v46;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 47)
        {
          v47 = v8 + 2;
          v49 = v8 == a2 || v47 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v49)
            {
              v50 = 0;
              v51 = v8;
              do
              {
                v52 = v51[2];
                v53 = *v51;
                v51 = v47;
                if (v52 < v53)
                {
                  v54 = *(_WORD *)v47;
                  v55 = v50;
                  while (1)
                  {
                    *(_WORD *)&v8[v55 + 2] = *(_WORD *)&v8[v55];
                    if (!v55)
                      break;
                    v56 = v8[v55 - 2];
                    v55 -= 2;
                    if (v56 <= v54)
                    {
                      v57 = &v8[v55 + 2];
                      goto LABEL_78;
                    }
                  }
                  v57 = v8;
LABEL_78:
                  *(_WORD *)v57 = v54;
                }
                v47 = v51 + 2;
                v50 += 2;
              }
              while (v51 + 2 != a2);
            }
          }
          else if (!v49)
          {
            do
            {
              v86 = v7[2];
              v87 = *v7;
              v7 = v47;
              if (v86 < v87)
              {
                v88 = *(_WORD *)v47;
                do
                {
                  v89 = v47;
                  v90 = *((_WORD *)v47 - 1);
                  v47 -= 2;
                  *v89 = v90;
                }
                while (*((unsigned __int8 *)v89 - 4) > v88);
                *(_WORD *)v47 = v88;
              }
              v47 = v7 + 2;
            }
            while (v7 + 2 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v58 = (v10 - 2) >> 1;
            v59 = v58;
            do
            {
              v60 = v59;
              if (v58 >= v59)
              {
                v61 = (2 * v59) | 1;
                v62 = &v8[2 * v61];
                if (2 * v60 + 2 >= (uint64_t)v10)
                {
                  v63 = *v62;
                }
                else
                {
                  v63 = *v62;
                  v64 = v62[2];
                  v65 = v63 >= v64;
                  if (v63 <= v64)
                    v63 = v62[2];
                  if (!v65)
                  {
                    v62 += 2;
                    v61 = 2 * v60 + 2;
                  }
                }
                v66 = &v8[2 * v60];
                if (v63 >= *v66)
                {
                  v67 = *(_WORD *)v66;
                  do
                  {
                    v68 = v66;
                    v66 = v62;
                    *(_WORD *)v68 = *(_WORD *)v62;
                    if (v58 < v61)
                      break;
                    v69 = (2 * v61) | 1;
                    v62 = &v8[2 * v69];
                    v61 = 2 * v61 + 2;
                    if (v61 >= (uint64_t)v10)
                    {
                      v70 = *v62;
                      v61 = v69;
                    }
                    else
                    {
                      v70 = *v62;
                      result = v62 + 2;
                      v71 = v62[2];
                      v72 = v70 >= v71;
                      if (v70 <= v71)
                        v70 = v62[2];
                      if (v72)
                        v61 = v69;
                      else
                        v62 += 2;
                    }
                  }
                  while (v70 >= v67);
                  *(_WORD *)v66 = v67;
                }
              }
              v59 = v60 - 1;
            }
            while (v60);
            v73 = (unint64_t)v9 >> 1;
            do
            {
              v74 = 0;
              v75 = *(_WORD *)v8;
              v76 = v8;
              do
              {
                v77 = 2 * v74 + 2;
                v78 = &v76[v77];
                v79 = (2 * v74) | 1;
                if (v77 < v73 && *v78 < v78[2])
                {
                  v78 += 2;
                  v79 = 2 * v74 + 2;
                }
                *(_WORD *)v76 = *(_WORD *)v78;
                v76 = v78;
                v74 = v79;
              }
              while (v79 <= (uint64_t)((unint64_t)(v73 - 2) >> 1));
              a2 -= 2;
              if (v78 == a2)
              {
                *(_WORD *)v78 = v75;
              }
              else
              {
                *(_WORD *)v78 = *(_WORD *)a2;
                *(_WORD *)a2 = v75;
                v80 = v78 - v8 + 2;
                if (v80 >= 3)
                {
                  v81 = (((unint64_t)v80 >> 1) - 2) >> 1;
                  v82 = &v8[2 * v81];
                  if (*v82 < *v78)
                  {
                    v83 = *(_WORD *)v78;
                    do
                    {
                      v84 = v78;
                      v78 = v82;
                      *(_WORD *)v84 = *(_WORD *)v82;
                      if (!v81)
                        break;
                      v81 = (v81 - 1) >> 1;
                      v82 = &v8[2 * v81];
                    }
                    while (*v82 < v83);
                    *(_WORD *)v78 = v83;
                  }
                }
              }
            }
            while (v73-- > 2);
          }
          return result;
        }
        v11 = v10 >> 1;
        v12 = &v8[2 * (v10 >> 1)];
        if ((unint64_t)v9 < 0x101)
        {
          result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(&v7[2 * (v10 >> 1)], v7, (_WORD *)a2 - 1);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v7, &v7[2 * (v10 >> 1)], (_WORD *)a2 - 1);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v7 + 2, v12 - 2, (_WORD *)a2 - 2);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v7 + 4, &v7[2 * v11 + 2], (_WORD *)a2 - 3);
          result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v12 - 2, v12, &v7[2 * v11 + 2]);
          v13 = *(_WORD *)v7;
          *(_WORD *)v7 = *(_WORD *)v12;
          *(_WORD *)v12 = v13;
        }
        --a3;
        if ((a4 & 1) == 0 && *(v7 - 2) >= *v7)
        {
          v29 = *(_WORD *)v7;
          v30 = *(_WORD *)v7;
          if (*(a2 - 2) <= v30)
          {
            v32 = v7 + 2;
            do
            {
              v8 = v32;
              if (v32 >= a2)
                break;
              v32 += 2;
            }
            while (*v8 <= v30);
          }
          else
          {
            v8 = v7;
            do
            {
              v31 = v8[2];
              v8 += 2;
            }
            while (v31 <= v30);
          }
          v33 = a2;
          if (v8 < a2)
          {
            v33 = a2;
            do
            {
              v34 = *(v33 - 2);
              v33 -= 2;
            }
            while (v34 > v30);
          }
          while (v8 < v33)
          {
            v35 = *(_WORD *)v8;
            *(_WORD *)v8 = *(_WORD *)v33;
            *(_WORD *)v33 = v35;
            do
            {
              v36 = v8[2];
              v8 += 2;
            }
            while (v36 <= v30);
            do
            {
              v37 = *(v33 - 2);
              v33 -= 2;
            }
            while (v37 > v30);
          }
          v38 = v8 - 2;
          if (v8 - 2 != v7)
            *(_WORD *)v7 = *(_WORD *)v38;
          a4 = 0;
          *(_WORD *)v38 = v29;
          continue;
        }
        v14 = 0;
        v15 = *(_WORD *)v7;
        v16 = *(_WORD *)v7;
        do
        {
          v17 = v7[v14 + 2];
          v14 += 2;
        }
        while (v17 < v16);
        v18 = &v7[v14];
        v19 = a2;
        if (v14 == 2)
        {
          v19 = a2;
          do
          {
            if (v18 >= v19)
              break;
            v21 = *(v19 - 2);
            v19 -= 2;
          }
          while (v21 >= v16);
        }
        else
        {
          do
          {
            v20 = *(v19 - 2);
            v19 -= 2;
          }
          while (v20 >= v16);
        }
        if (v18 >= v19)
        {
          v27 = v18 - 2;
        }
        else
        {
          v22 = &v7[v14];
          v23 = v19;
          do
          {
            v24 = *(_WORD *)v22;
            *(_WORD *)v22 = *(_WORD *)v23;
            *(_WORD *)v23 = v24;
            do
            {
              v25 = v22[2];
              v22 += 2;
            }
            while (v25 < v16);
            do
            {
              v26 = *(v23 - 2);
              v23 -= 2;
            }
            while (v26 >= v16);
          }
          while (v22 < v23);
          v27 = v22 - 2;
        }
        if (v27 != v7)
          *(_WORD *)v7 = *(_WORD *)v27;
        *(_WORD *)v27 = v15;
        if (v18 < v19)
        {
LABEL_32:
          result = (unsigned __int8 *)std::__introsort<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *,false>(v7, v27, a3, a4 & 1);
          a4 = 0;
          v8 = v27 + 2;
          continue;
        }
        v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v7, v27);
        v8 = v27 + 2;
        result = (unsigned __int8 *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,C3D::RenderGraph::validate(void)::$_0 &,C3D::RenderGraph::PortsPair *>(v27 + 2, a2);
        if (!(_DWORD)result)
        {
          if (v28)
            continue;
          goto LABEL_32;
        }
        a2 = v27;
        if (!v28)
          goto LABEL_2;
        return result;
    }
  }
}

BOOL C3D::PassIODescriptor::isValid(C3D::PassIODescriptor *this)
{
  _BOOL8 result;

  if (!*((_WORD *)this + 14))
    return 0;
  if (*((unsigned __int16 *)this + 11) < 2u || (result = SCNMTLTextureTypeIsArray(*((unsigned __int8 *)this + 24))))
    return *((unsigned __int8 *)this + 31) < 2u || SCNMTLTextureTypeIsMultisampled(*((unsigned __int8 *)this + 24));
  return result;
}

void C3D::RenderGraph::reset(C3D::RenderGraph *this)
{
  uint64_t *v2;
  uint64_t v3;
  C3D::ScratchAllocator *Aligned;
  C3D::ScratchAllocator *v5;
  uint64_t v6;

  if (!*((_BYTE *)this + 210))
    C3D::RenderGraph::checkResources((uint64_t)this);
  C3D::RenderGraphResourceManager::purgeIfNeeded(*((C3D::RenderGraphResourceManager **)this + 16));
  v3 = *((_QWORD *)this + 2);
  v2 = (uint64_t *)((char *)this + 16);
  C3DScratchAllocatorReset(v3);
  Aligned = (C3D::ScratchAllocator *)C3DScratchAllocatorAllocateAligned(*v2, 24, 8, 0);
  v2[1] = (uint64_t)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array(Aligned, (void *)*v2);
  v2[15] = (uint64_t)C3D::ScratchAllocate<C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>,void *&>(*v2, (void **)v2);
  v5 = (C3D::ScratchAllocator *)C3DScratchAllocatorAllocateAligned(*v2, 24, 8, 0);
  v2[16] = (uint64_t)C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array(v5, (void *)*v2);
  C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate(v2 + 5, 32, v6);
}

void C3D::RenderGraphResourceManager::purgeIfNeeded(C3D::RenderGraphResourceManager *this)
{
  int v1;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  _BYTE v20[256];

  v18 = 0x2000000000;
  v19 = v20;
  v1 = *((_DWORD *)this + 7);
  if (v1 != -15)
  {
    v3 = 0;
    do
    {
      if ((*(_WORD *)(*((_QWORD *)this + 2) + 2 * v3) & 1) != 0)
      {
        v4 = *(_QWORD *)this;
        v5 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v3);
        v6 = *(unsigned __int8 *)(v5 + 8);
        *(_BYTE *)(v5 + 8) = v6 + 1;
        if (v6 >= 0xA)
        {
          C3D::Array<unsigned long long,32u,C3D::MallocAllocator>::push_back<unsigned long long const&>((uint64_t)&v18, (_QWORD *)(v4 + 8 * v3));
          v1 = *((_DWORD *)this + 7);
        }
      }
      ++v3;
    }
    while (v3 < (v1 + 15));
    v7 = (char *)v19;
    if ((_DWORD)v18)
    {
      v8 = (char *)v19 + 8 * v18;
      do
      {
        v9 = (*((_DWORD *)this + 7) - 1) & *(_QWORD *)v7;
        v10 = *((_QWORD *)this + 2);
        v11 = *(unsigned __int16 *)(v10 + 2 * v9);
        if (v11 >= 2)
        {
          v12 = 1;
          v13 = *(unsigned __int16 *)(v10 + 2 * v9);
          while (1)
          {
            if ((v13 & 2) != 0)
            {
              v14 = (v9 + v12 - 1);
              if (*(_QWORD *)v7 == *(_QWORD *)(*(_QWORD *)this + 8 * v14))
                break;
            }
            ++v12;
            v15 = v13 > 3;
            v13 >>= 1;
            if (!v15)
              goto LABEL_18;
          }
          *(_WORD *)(v10 + 2 * v9) = v11 ^ (1 << v12);
          *(_WORD *)(v10 + 2 * v14) ^= 1u;
          v16 = *((_QWORD *)this + 1);
          v17 = *(_QWORD *)(v16 + 8 * v14);
          *(_QWORD *)(v16 + 8 * v14) = 0;
          if (v17)
            (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
          --*((_DWORD *)this + 6);
        }
LABEL_18:
        v7 += 8;
      }
      while (v7 != v8);
      v7 = (char *)v19;
    }
    if (v7 != v20)
      free(v7);
  }
}

void sub_1DCD18048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  void *v10;

  if (a10 != v10)
    free(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *C3D::ScratchAllocate<C3D::Hash<objc_object  {objcproto10MTLTexture}*,C3D::ScratchAllocator>,void *&>(uint64_t a1, void **a2)
{
  _QWORD *Aligned;
  uint64_t v4;
  uint64_t v6;

  Aligned = (_QWORD *)C3DScratchAllocatorAllocateAligned(a1, 40, 8, 0);
  C3D::ScratchAllocator::ScratchAllocator((C3D::ScratchAllocator *)&v6, *a2);
  *Aligned = v6;
  C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate(Aligned, 32, v4);
  return Aligned;
}

void C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4;
  size_t v5;
  size_t v6;

  if ((a2 & ((_DWORD)a2 - 1)) != 0)
    C3D::Hash<C3D::Pass *,C3D::ScratchAllocator>::_allocate((uint64_t)a1, a2, a3);
  *((_DWORD *)a1 + 8) = 0;
  *((_DWORD *)a1 + 9) = a2;
  v4 = a2 + 15;
  v5 = 2 * (a2 + 15);
  a1[3] = C3DScratchAllocatorAllocateAligned(*a1, (2 * (a2 + 15)), 4, 0);
  v6 = 8 * v4;
  a1[1] = C3DScratchAllocatorAllocateAligned(*a1, v6 & 0xFFFFFFF8, 8, 0);
  a1[2] = C3DScratchAllocatorAllocateAligned(*a1, v6 & 0xFFFFFFF8, 8, 0);
  memset((void *)a1[1], 255, v6);
  bzero((void *)a1[3], v5);
}

void C3D::RenderGraph::resolvePartialDependencies(C3D::RenderGraph *this)
{
  uint64_t StackAllocator;
  unsigned int v3;
  _QWORD *v4;
  unint64_t v5;
  _DWORD *v6;
  int *v7;
  int *v8;
  int v9;
  uint64_t v10;
  int *v11;
  int *v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  int *v17;
  int *v18;
  int v19;
  unint64_t i;
  uint64_t v21;
  _DWORD *v22;
  const C3D::Pass **v23;
  unint64_t v24;
  int *v25;
  int *v26;
  int v27;
  int v28;
  uint64_t v29;
  NSObject *v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  unsigned __int8 *v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  int *v44;
  uint64_t v45;
  uint8_t buf[4];
  const char *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  uint64_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  StackAllocator = C3DEngineContextGetStackAllocator(*((_QWORD *)this + 1));
  C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(&v41, StackAllocator);
  v37 = *(unsigned __int16 *)(*((_QWORD *)this + 3) + 8);
  if (*(_WORD *)(*((_QWORD *)this + 3) + 8))
  {
    v3 = 0;
    while (1)
    {
      v4 = (_QWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), v3);
      C3D::Array<C3D::RenderGraph::Link,16u,C3D::StackAllocator>::resize((uint64_t)&v41, 0);
      v43 = 16;
      v44 = (int *)&v45;
      if (*((_DWORD *)v4 + 10))
      {
        v5 = 0;
        do
        {
          v6 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)(v4 + 4), v5);
          if (HIBYTE(*v6) == 255 || (*v6 & 0xFF0000) == 0xFF0000)
          {
            C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::push_back<C3D::RenderGraph::Link&>(&v41, v6);
            v7 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)(v4 + 4), v5);
            v8 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)(v4 + 4), *((_DWORD *)v4 + 10) - 1);
            v9 = *v7;
            *v7 = *v8;
            *v8 = v9;
            C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::resize((uint64_t)(v4 + 4), *((_DWORD *)v4 + 10) - 1);
          }
          else
          {
            ++v5;
          }
        }
        while (v5 < *((unsigned int *)v4 + 10));
      }
      if (v42)
      {
        std::__introsort<std::_ClassicAlgPolicy,C3D::RenderGraph::resolvePartialDependencies(void)::$_0 &,C3D::RenderGraph::Link *,false>(v44, &v44[v42], 126 - 2 * __clz(v42), 1);
        if (v42)
          break;
      }
LABEL_41:
      if (++v3 == v37)
        return;
    }
    v10 = 0;
    while (1)
    {
      v11 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v41, v10);
      v12 = v11;
      if (!v10)
        break;
      v13 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v41, (int)v10 - 1);
      v14 = *v12;
      if (((*v12 ^ *v13) & 0x7FFF) != 0)
        goto LABEL_17;
LABEL_23:
      if (++v10 >= (unint64_t)v42)
      {
        if (v42)
        {
          for (i = 0; i < v42; ++i)
          {
            v21 = *((_QWORD *)this + 3);
            v22 = (_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v41, i);
            v23 = (const C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](v21, *v22 & 0x7FFF);
            C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::Array(&v38, StackAllocator);
            if (i < v42)
            {
              v24 = i;
              do
              {
                v25 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v41, v24);
                v26 = v25;
                if (v24)
                {
                  v27 = *v25;
                  if (((*(_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[]((uint64_t)&v41, (int)v24 - 1) ^ v27) & 0x7FFF) != 0)break;
                }
                v28 = *v26;
                buf[0] = HIBYTE(*v26);
                buf[1] = BYTE2(v28);
                C3D::Array<C3D::RenderGraph::PortsPair,16u,C3D::StackAllocator>::push_back<C3D::RenderGraph::PortsPair&>(&v38, buf);
                ++v24;
              }
              while (v24 < v42);
            }
            C3D::RenderGraph::matchingPortForNodes((uint64_t)this, (uint64_t)v23, (C3D::Pass **)v4, (uint64_t)&v38);
            v29 = v39;
            if (v39)
              goto LABEL_35;
            v30 = scn_default_log();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
            {
              v35 = (**(uint64_t (***)(_QWORD))*v4)(*v4);
              v36 = (**(uint64_t (***)(const C3D::Pass *))*v23)(*v23);
              *(_DWORD *)buf = 136315650;
              v47 = "!portsPairs.empty()";
              v48 = 2080;
              v49 = v35;
              v50 = 2080;
              v51 = v36;
              _os_log_fault_impl(&dword_1DCCB8000, v30, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Unable to resolve dependency between %s and %s", buf, 0x20u);
            }
            v29 = v39;
            if (v39)
            {
LABEL_35:
              v31 = v40;
              v32 = &v40[2 * v29];
              do
              {
                v33 = *v31;
                if ((_DWORD)v33 != 255)
                {
                  v34 = v31[1];
                  if ((_DWORD)v34 != 255)
                    C3D::RenderGraph::addDependency(this, *v23, (const C3D::Pass *)*v4, v33, v34);
                }
                v31 += 2;
              }
              while (v31 != v32);
            }
          }
        }
        goto LABEL_41;
      }
    }
    v14 = *v11;
LABEL_17:
    v15 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), v14 & 0x7FFF);
    if (*(_DWORD *)(v15 + 16))
    {
      v16 = 0;
      do
      {
        while ((*(_DWORD *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v15 + 8, v16) & 0x7FFF) == v3)
        {
          v17 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v15 + 8, v16);
          v18 = (int *)C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](v15 + 8, *(_DWORD *)(v15 + 16) - 1);
          v19 = *v17;
          *v17 = *v18;
          *v18 = v19;
          C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::resize(v15 + 8, *(_DWORD *)(v15 + 16) - 1);
          if (*(_DWORD *)(v15 + 16) <= v16)
            goto LABEL_23;
        }
        ++v16;
      }
      while (v16 < *(unsigned int *)(v15 + 16));
    }
    goto LABEL_23;
  }
}

void C3D::Array<C3D::RenderGraph::Link,16u,C3D::StackAllocator>::resize(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  char *v5;
  unsigned int v6;
  char *Aligned;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      v5 = *(char **)(a1 + 16);
      if (*(_DWORD *)(a1 + 12) < a2)
      {
        v6 = ((double)a2 * 1.5);
        Aligned = (char *)C3DStackAllocatorAllocateAligned(*(_QWORD *)a1, 4 * v6, 4, 0);
        memcpy(Aligned, v5, 4 * *(unsigned int *)(a1 + 8));
        *(_QWORD *)(a1 + 16) = Aligned;
        *(_DWORD *)(a1 + 12) = v6;
        v5 = Aligned;
        v2 = *(_DWORD *)(a1 + 8);
      }
      bzero(&v5[4 * v2], 4 * (a2 - v2));
    }
    *(_DWORD *)(a1 + 8) = a2;
  }
}

uint64_t C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  int v6;
  int v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  unsigned int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) <= a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      v6 = *(_DWORD *)(a1 + 8);
      v7 = 136315906;
      v8 = "i < size()";
      v9 = 2048;
      v10 = a1;
      v11 = 1024;
      v12 = a2;
      v13 = 1024;
      v14 = v6;
      _os_log_fault_impl(&dword_1DCCB8000, v4, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Out of bound Array:%p access %d size %d", (uint8_t *)&v7, 0x22u);
    }
  }
  return *(_QWORD *)(a1 + 16) + 4 * a2;
}

void C3D::RenderGraph::removeInvalidPasses(C3D::RenderGraph *this)
{
  uint64_t StackAllocator;
  uint64_t v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  char v9;
  unsigned int *v10;
  int *v11;
  _QWORD *v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  BOOL v16;
  BOOL v17;
  NSObject *v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  _QWORD *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int i;
  _QWORD *v34;
  unsigned int v35;
  unsigned int v36;
  NSObject *v37;
  _DWORD *v38;
  _QWORD *v39;
  _DWORD v40[6];
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  _BYTE buf[12];
  __int16 v49;
  _BYTE v50[24];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v38 = (_DWORD *)((char *)this + 32);
  C3D::Array<C3D::Pass *,0u,C3D::ScratchAllocator>::resize((uint64_t)this + 32, 0);
  *((_DWORD *)this + 11) = 0;
  *((_QWORD *)this + 6) = (char *)this + 56;
  StackAllocator = C3DEngineContextGetStackAllocator(*((_QWORD *)this + 1));
  v43 = StackAllocator;
  C3D::Hash<C3D::Pass *,C3D::StackAllocator>::_allocate((uint64_t)&v43, 32, v3);
  C3D::Array<C3D::RenderGraph::Link,0u,C3D::StackAllocator>::Array(&v41, StackAllocator);
  v4 = *((_QWORD *)this + 3);
  v5 = *(unsigned __int16 *)(v4 + 8);
  if (*(_WORD *)(v4 + 8))
  {
    v6 = 0;
    do
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)buf = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), v6);
      if (*(_DWORD *)C3D::Pass::descriptor(**(C3D::Pass ***)buf) == 5)
        C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v41, buf);
      ++v6;
    }
    while (v5 != v6);
  }
  if (!v42)
    goto LABEL_34;
  do
  {
    v7 = *(_QWORD **)C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::back((uint64_t)&v41);
    C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::pop_back((uint64_t)&v41);
    *(_QWORD *)buf = *v7;
    C3D::Hash<C3D::Pass *,C3D::StackAllocator>::insert((uint64_t)&v43, *(uint64_t *)buf, buf);
    C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::Array((C3D::ScratchAllocator *)v40, *((void **)this + 2), *((_DWORD *)v7 + 4));
    v8 = *((unsigned int *)v7 + 4);
    if (!(_DWORD)v8)
      continue;
    v9 = 0;
    v10 = (unsigned int *)v7[3];
    v11 = (int *)&v10[v8];
    do
    {
      v39 = 0;
      v12 = (_QWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v10 & 0x7FFF);
      v39 = v12;
      v13 = *v10 & 0xFF0000;
      if (HIBYTE(*v10) == 255 || v13 == 16711680)
      {
        v17 = HIBYTE(*v10) == 255;
        v18 = scn_default_log();
        v19 = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
        if (v17)
        {
          if (v13 == 16711680)
          {
            if (v19)
            {
              v20 = (**(uint64_t (***)(_QWORD))*v7)(*v7);
              v21 = (**(uint64_t (***)(_QWORD))*v39)(*v39);
              v22 = (**(uint64_t (***)(_QWORD))*v39)(*v39);
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = v20;
              v49 = 2080;
              *(_QWORD *)v50 = v21;
              *(_WORD *)&v50[8] = 2080;
              *(_QWORD *)&v50[10] = v22;
              _os_log_error_impl(&dword_1DCCB8000, v18, OS_LOG_TYPE_ERROR, "Error: Pass %s has an unresolved dependency with pass %s. Pass %s will be ignored", buf, 0x20u);
            }
            goto LABEL_26;
          }
          if (v19)
          {
            v29 = (**(uint64_t (***)(_QWORD))*v7)(*v7);
            v30 = *((unsigned __int8 *)v10 + 2);
            v31 = (**(uint64_t (***)(_QWORD))*v39)(*v39);
            v32 = (**(uint64_t (***)(_QWORD))*v39)(*v39);
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v29;
            v49 = 1024;
            *(_DWORD *)v50 = v30;
            *(_WORD *)&v50[4] = 2080;
            *(_QWORD *)&v50[6] = v31;
            *(_WORD *)&v50[14] = 2080;
            *(_QWORD *)&v50[16] = v32;
            _os_log_error_impl(&dword_1DCCB8000, v18, OS_LOG_TYPE_ERROR, "Error: Pass %s has an unresolved dependency from output port %d of pass %s. Pass %s will be ignored", buf, 0x26u);
          }
        }
        else if (v19)
        {
          v25 = (**(uint64_t (***)(_QWORD))*v7)(*v7);
          v26 = *((unsigned __int8 *)v10 + 3);
          v27 = (**(uint64_t (***)(_QWORD))*v39)(*v39);
          v28 = (**(uint64_t (***)(_QWORD))*v39)(*v39);
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v25;
          v49 = 1024;
          *(_DWORD *)v50 = v26;
          *(_WORD *)&v50[4] = 2080;
          *(_QWORD *)&v50[6] = v27;
          *(_WORD *)&v50[14] = 2080;
          *(_QWORD *)&v50[16] = v28;
          _os_log_error_impl(&dword_1DCCB8000, v18, OS_LOG_TYPE_ERROR, "Error: Pass %s has an unresolved dependency on input port %d with pass %s. Pass %s will be ignored", buf, 0x26u);
        }
        v23 = *v10;
        v24 = (_QWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v10 & 0x7FFF);
        C3D::RenderGraph::logDependencyInputMismatch((uint64_t)this, v7, v24, BYTE2(v23), HIBYTE(v23));
LABEL_26:
        v9 = 1;
        goto LABEL_27;
      }
      v14 = (v47 - 1) & *v12;
      v15 = *(unsigned __int16 *)(v46 + 2 * v14);
      if (v15 < 2)
        goto LABEL_15;
      while ((v15 & 2) == 0 || *(_QWORD *)(v44 + 8 * v14) != *v12)
      {
        ++v14;
        v16 = v15 >= 4;
        v15 >>= 1;
        if (!v16)
          goto LABEL_15;
      }
      if (!v45)
      {
LABEL_15:
        C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::Link const&>(v40, v10);
        C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>(&v41, &v39);
      }
LABEL_27:
      ++v10;
    }
    while (v10 != (unsigned int *)v11);
    if ((v9 & 1) != 0)
      C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=((uint64_t)(v7 + 1), (uint64_t)v40);
  }
  while (v42);
LABEL_34:
  if (v5)
  {
    for (i = 0; i != v5; ++i)
    {
      v34 = (_QWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), i);
      v35 = (v47 - 1) & *v34;
      v36 = *(unsigned __int16 *)(v46 + 2 * v35);
      if (v36 < 2)
        goto LABEL_40;
      while ((v36 & 2) == 0 || *(_QWORD *)(v44 + 8 * v35) != *v34)
      {
        ++v35;
        v16 = v36 >= 4;
        v36 >>= 1;
        if (!v16)
          goto LABEL_40;
      }
      if (!v45)
      {
LABEL_40:
        v37 = scn_default_log();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          C3D::RenderGraph::removeInvalidPasses((uint64_t)buf, v34);
        C3D::Array<C3D::Pass *,0u,C3D::ScratchAllocator>::push_back<C3D::Pass *&>(v38, v34);
      }
    }
  }
}

C3D::ScratchAllocator *C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::Array(C3D::ScratchAllocator *a1, void *a2, int a3)
{
  C3D::ScratchAllocator *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  int v11;
  void *Aligned;

  v6 = C3D::ScratchAllocator::ScratchAllocator(a1, a2);
  *((_QWORD *)v6 + 1) = 0;
  *((_QWORD *)v6 + 2) = (char *)v6 + 24;
  if (!a2)
  {
    v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      C3D::__deduceMemoryLess(v7, v8, v9);
  }
  v10 = (const void *)*((_QWORD *)a1 + 2);
  v11 = *((_DWORD *)a1 + 3) + a3;
  Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)a1, (4 * v11), 4, 0);
  memcpy(Aligned, v10, 4 * *((unsigned int *)a1 + 2));
  *((_QWORD *)a1 + 2) = Aligned;
  *((_DWORD *)a1 + 3) = v11;
  return a1;
}

char *C3DScratchAllocator::Allocate(_QWORD *a1, size_t a2, uint64_t a3, int a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  _QWORD *v17;
  float v18;
  uint64_t v19;
  char *v20;

  v8 = 0;
  v9 = a3 - 1;
  v10 = -a3;
  v11 = a1;
  do
  {
    v12 = v11[1];
    v13 = v11[2];
    v14 = *v11 + v13;
    v15 = ((v9 + v14) & v10) - v14 + a2;
    if (v15 <= v12 - v13)
    {
      v20 = (char *)((v9 + v14) & v10);
      v11[2] = v15 + v13;
      return v20;
    }
    v8 += v12;
    v11 = (_QWORD *)v11[3];
  }
  while (v11);
  if (!a1[4])
    C3DScratchAllocator::Allocate();
  v16 = operator new();
  v17 = (_QWORD *)v16;
  *(_OWORD *)v16 = 0u;
  *(_OWORD *)(v16 + 16) = 0u;
  *(_QWORD *)(a1[4] + 24) = v16;
  a1[4] = v16;
  v18 = (float)v8 * 0.5;
  if (a3 + a2 <= (unint64_t)v18)
    v19 = (unint64_t)v18;
  else
    v19 = a3 + a2;
  VMAllocateChunk((vm_address_t *)v16, v19);
  v20 = (char *)((v9 + *v17 + v17[2]) & v10);
  v17[2] = &v20[a2 - *v17];
  if (a4 == 2)
  {
    memset(v20, 255, a2);
  }
  else if (a4 == 1)
  {
    bzero(v20, a2);
  }
  return v20;
}

void C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::pop_back(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;

  if (!*(_DWORD *)(a1 + 8))
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::pop_back(v2, v3, v4);
  }
  --*(_DWORD *)(a1 + 8);
}

uint64_t C3D::Array<C3D::RenderGraph::GraphNode *,0u,C3D::StackAllocator>::back(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;

  if (!*(_DWORD *)(a1 + 8))
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3D::Array<C3D::RefCountedResource,0u,C3D::ScratchAllocator>::back(v2, v3, v4);
  }
  return *(_QWORD *)(a1 + 16) + 8 * *(unsigned int *)(a1 + 8) - 8;
}

uint64_t C3D::Hash<C3D::Pass *,C3D::StackAllocator>::insert(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;
  unsigned int v13;
  __int16 *v14;
  unsigned int v15;
  __int16 v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  char v20;
  uint64_t v21;
  int v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  uint64_t v27;

  v4 = a2;
  while (1)
  {
    v6 = *(_DWORD *)(a1 + 36);
    v7 = (v6 - 1) & v4;
    v8 = *(_QWORD *)(a1 + 24);
    v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2)
      break;
LABEL_7:
    v12 = v7 + 496;
    v13 = v6 + 15;
    if (v13 < (int)v7 + 496)
      v12 = v13;
    if (v7 >= v12)
    {
      v15 = v7;
    }
    else
    {
      v14 = (__int16 *)(v8 + 2 * v7);
      v15 = v7;
      while (1)
      {
        v16 = *v14++;
        if ((v16 & 1) == 0)
          break;
        if (v12 == ++v15)
          goto LABEL_34;
      }
    }
    if (v15 != v12)
    {
      *(_WORD *)(v8 + 2 * v15) |= 1u;
      if (v15 <= (int)v7 + 14)
      {
        v21 = v15;
      }
      else
      {
        while (2)
        {
          if (v15 >= 0xF)
            v17 = v15 - 14;
          else
            v17 = 0;
          v18 = v17 - 1;
          if (v17 <= v15)
            v19 = v15;
          else
            v19 = v17;
          v20 = 1;
          while (1)
          {
            v21 = v18 + 1;
            if (v17 <= v21)
              break;
LABEL_28:
            ++v20;
            v18 = v21;
            if ((_DWORD)v21 == v19)
              goto LABEL_33;
          }
          v22 = 1 << (v18 - v17 + 2);
          v23 = v20;
          LODWORD(a2) = v17;
          while (1)
          {
            v24 = a2;
            a2 = *(unsigned __int16 *)(v8 + 2 * a2);
            if ((v22 & a2) != 0)
              break;
            a2 = (v24 + 1);
            v22 = (unsigned __int16)v22 >> 1;
            --v23;
            if (a2 > v21)
              goto LABEL_28;
          }
          if (v21 >= v15)
          {
LABEL_33:
            *(_WORD *)(v8 + 2 * v15) ^= 1u;
            goto LABEL_34;
          }
          v25 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v15) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v21);
          *(_QWORD *)(v25 + 8 * v15) = *(_QWORD *)(v25 + 8 * v21);
          v8 = *(_QWORD *)(a1 + 24);
          *(_WORD *)(v8 + 2 * v24) = (*(_WORD *)(v8 + 2 * v24) | (1 << (v15 - v24 + 1))) ^ (1 << v23);
          v15 = v21;
          if (v21 > (int)v7 + 14)
            continue;
          break;
        }
        LOBYTE(v15) = v21;
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v21) = *a3;
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v21) = v4;
      v27 = *(_QWORD *)(a1 + 24);
      *(_WORD *)(v27 + 2 * v21) |= 1u;
      result = 1;
      *(_WORD *)(v27 + 2 * v7) |= 1 << (v15 - v7 + 1);
      ++*(_DWORD *)(a1 + 32);
      return result;
    }
LABEL_34:
    C3D::Hash<C3D::Pass *,C3D::StackAllocator>::_grow(a1, a2, (uint64_t)a3);
  }
  v10 = (v6 - 1) & v4;
  while ((v9 & 2) == 0 || *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v10) != v4)
  {
    ++v10;
    v11 = v9 > 3;
    v9 >>= 1;
    if (!v11)
      goto LABEL_7;
  }
  result = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v10) = *a3;
  return result;
}

void C3D::Array<C3D::Pass *,0u,C3D::ScratchAllocator>::resize(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  char *v5;
  unsigned int v6;
  char *Aligned;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      v5 = *(char **)(a1 + 16);
      if (*(_DWORD *)(a1 + 12) < a2)
      {
        v6 = ((double)a2 * 1.5);
        Aligned = (char *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)a1, 8 * v6, 8, 0);
        memcpy(Aligned, v5, 8 * *(unsigned int *)(a1 + 8));
        *(_QWORD *)(a1 + 16) = Aligned;
        *(_DWORD *)(a1 + 12) = v6;
        v5 = Aligned;
        v2 = *(_DWORD *)(a1 + 8);
      }
      bzero(&v5[8 * v2], 8 * (a2 - v2));
    }
    *(_DWORD *)(a1 + 8) = a2;
  }
}

BOOL C3D::RenderGraph::sort(C3D::RenderGraph *this)
{
  C3D::ScratchAllocator *Aligned;
  C3D::ScratchAllocator *v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int16 *v18;
  unsigned __int16 *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  _DWORD *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  _DWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  C3D::ScratchAllocator *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int16 *v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int16 *v42;
  unsigned __int16 *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _DWORD *v47;
  uint64_t v48;
  uint64_t v49;
  _DWORD *v50;
  _DWORD *v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  _BOOL8 result;
  NSObject *v58;
  _DWORD v59[6];

  Aligned = (C3D::ScratchAllocator *)C3DScratchAllocatorAllocateAligned(*((_QWORD *)this + 2), 40, 8, 0);
  v3 = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array(Aligned, *((void **)this + 2));
  *((_QWORD *)v3 + 3) = 0;
  *((_QWORD *)v3 + 4) = 0;
  *((_QWORD *)this + 12) = v3;
  if (*(_DWORD *)(*((_QWORD *)this + 3) + 8) >= 0x7FFFu)
    C3D::RenderGraph::sort();
  C3D::RenderGraph::clearAllDirtyBits((uint64_t)this, 1);
  v4 = *(unsigned __int16 *)(*((_QWORD *)this + 3) + 8);
  LOWORD(v59[0]) = 0;
  if (v4)
  {
    v5 = 0;
    do
    {
      v6 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), v5);
      if (!*(_DWORD *)(v6 + 16))
      {
        v7 = *((_QWORD *)this + 6);
        v8 = *((unsigned int *)this + 10);
        if ((_DWORD)v8)
        {
          v9 = 8 * v8;
          v10 = (_QWORD *)*((_QWORD *)this + 6);
          while (*v10 != *(_QWORD *)v6)
          {
            ++v10;
            v9 -= 8;
            if (!v9)
            {
              v10 = (_QWORD *)(v7 + 8 * v8);
              break;
            }
          }
        }
        else
        {
          v10 = (_QWORD *)*((_QWORD *)this + 6);
        }
        if (v8 == ((uint64_t)v10 - v7) >> 3)
          C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::push_back<unsigned short &>(*((_DWORD **)this + 12), v59);
      }
      ++LOWORD(v59[0]);
      v5 = LOWORD(v59[0]);
    }
    while (v4 > LOWORD(v59[0]));
  }
  v11 = *((_QWORD *)this + 12);
  if (!*(_DWORD *)(v11 + 8))
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      C3D::RenderGraph::sort(v12, v13, v14);
    v11 = *((_QWORD *)this + 12);
    if (!v11)
    {
      *((_QWORD *)this + 13) = 0;
      return 1;
    }
  }
  v15 = v11;
  do
  {
    v16 = v15;
    if (v11 != v15)
    {
      *(_QWORD *)(v11 + 24) = v15;
      *(_QWORD *)(v15 + 32) = v11;
    }
    v17 = *(unsigned int *)(v15 + 8);
    if (!(_DWORD)v17)
      break;
    v15 = 0;
    v18 = *(unsigned __int16 **)(v16 + 16);
    v19 = &v18[v17];
    do
    {
      v20 = *v18;
      v21 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), v20);
      v22 = *(unsigned int *)(v21 + 40);
      if ((_DWORD)v22)
      {
        v23 = *(_DWORD **)(v21 + 48);
        v24 = &v23[v22];
        do
        {
          v25 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v23 & 0x7FFF);
          v26 = *(unsigned int *)(v25 + 16);
          if ((_DWORD)v26)
          {
            v27 = 0;
            v28 = *(_DWORD **)(v25 + 24);
            v29 = 4 * v26;
            do
            {
              if ((*v28 & 0x8000) != 0)
              {
                ++v27;
              }
              else if ((*v28 & 0x7FFF) == v20)
              {
                ++v27;
                *v28 |= 0x8000u;
              }
              ++v28;
              v29 -= 4;
            }
            while (v29);
          }
          else
          {
            v27 = 0;
          }
          v30 = *((_QWORD *)this + 6);
          v31 = *((unsigned int *)this + 10);
          if ((_DWORD)v31)
          {
            v32 = 8 * v31;
            v33 = (_QWORD *)*((_QWORD *)this + 6);
            while (*v33 != *(_QWORD *)v25)
            {
              ++v33;
              v32 -= 8;
              if (!v32)
              {
                v33 = (_QWORD *)(v30 + 8 * v31);
                break;
              }
            }
          }
          else
          {
            v33 = (_QWORD *)*((_QWORD *)this + 6);
          }
          if (v31 == ((uint64_t)v33 - v30) >> 3 && v27 == (_DWORD)v26)
          {
            if (!v15)
            {
              v15 = C3DScratchAllocatorAllocateAligned(*((_QWORD *)this + 2), 40, 8, 0);
              v34 = C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array((C3D::ScratchAllocator *)v15, *((void **)this + 2));
              *((_QWORD *)v34 + 3) = 0;
              *((_QWORD *)v34 + 4) = 0;
            }
            v35 = *v23 & 0x7FFF;
            LOWORD(v59[0]) = *v23 & 0x7FFF;
            v36 = *(_QWORD *)(v15 + 16);
            v37 = *(unsigned int *)(v15 + 8);
            if ((_DWORD)v37)
            {
              v38 = 2 * v37;
              v39 = *(unsigned __int16 **)(v15 + 16);
              while (*v39 != v35)
              {
                ++v39;
                v38 -= 2;
                if (!v38)
                {
                  v39 = (unsigned __int16 *)(v36 + 2 * v37);
                  break;
                }
              }
            }
            else
            {
              v39 = *(unsigned __int16 **)(v15 + 16);
            }
            if (v37 == ((uint64_t)v39 - v36) >> 1)
              C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::push_back<unsigned short &>((_DWORD *)v15, v59);
          }
          ++v23;
        }
        while (v23 != v24);
      }
      ++v18;
    }
    while (v18 != v19);
    v11 = v16;
  }
  while (v15);
  v40 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 13) = v16;
  if (!v40)
    return 1;
  while (1)
  {
    v41 = *(unsigned int *)(v40 + 8);
    if ((_DWORD)v41)
      break;
LABEL_74:
    v40 = *(_QWORD *)(v40 + 24);
    result = 1;
    if (!v40)
      return result;
  }
  v42 = *(unsigned __int16 **)(v40 + 16);
  v43 = &v42[v41];
  while (1)
  {
    v44 = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v42);
    v45 = v44;
    v46 = *(unsigned int *)(v44 + 16);
    if ((_DWORD)v46)
      break;
LABEL_62:
    C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::Array((C3D::ScratchAllocator *)v59, *((void **)this + 2), *(_DWORD *)(v44 + 40));
    v49 = *(unsigned int *)(v45 + 40);
    if ((_DWORD)v49)
    {
      v50 = *(_DWORD **)(v45 + 48);
      v51 = &v50[v49];
      do
      {
        v52 = (_QWORD *)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v50 & 0x7FFF);
        v53 = *((_QWORD *)this + 6);
        v54 = *((unsigned int *)this + 10);
        if ((_DWORD)v54)
        {
          v55 = 8 * v54;
          v56 = (_QWORD *)*((_QWORD *)this + 6);
          while (*v56 != *v52)
          {
            ++v56;
            v55 -= 8;
            if (!v55)
            {
              v56 = (_QWORD *)(v53 + 8 * v54);
              break;
            }
          }
        }
        else
        {
          v56 = (_QWORD *)*((_QWORD *)this + 6);
        }
        if (v54 == ((uint64_t)v56 - v53) >> 3)
          C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::Link const&>(v59, v50);
        ++v50;
      }
      while (v50 != v51);
    }
    C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(v45 + 32, (uint64_t)v59);
    if (++v42 == v43)
      goto LABEL_74;
  }
  v47 = *(_DWORD **)(v44 + 24);
  v48 = 4 * v46;
  while ((*v47 & 0x8000) != 0)
  {
    ++v47;
    v48 -= 4;
    if (!v48)
      goto LABEL_62;
  }
  C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*((_QWORD *)this + 3), *v47 & 0x7FFF);
  if ((C3D::RenderGraph::sort(void)::done & 1) != 0)
    return 0;
  C3D::RenderGraph::sort(void)::done = 1;
  v58 = scn_default_log();
  result = os_log_type_enabled(v58, OS_LOG_TYPE_ERROR);
  if (result)
  {
    C3D::RenderGraph::sort();
    return 0;
  }
  return result;
}

uint64_t C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  int v6;
  int v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  unsigned int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) <= a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      v6 = *(_DWORD *)(a1 + 8);
      v7 = 136315906;
      v8 = "i < size()";
      v9 = 2048;
      v10 = a1;
      v11 = 1024;
      v12 = a2;
      v13 = 1024;
      v14 = v6;
      _os_log_fault_impl(&dword_1DCCB8000, v4, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Out of bound Array:%p access %d size %d", (uint8_t *)&v7, 0x22u);
    }
  }
  return *(_QWORD *)(a1 + 16) + 56 * a2;
}

uint64_t C3D::RenderGraph::addPass(C3D::RenderGraph *this, C3D::Pass *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  C3D::Pass *v11;
  uint64_t v12;
  uint64_t v13;

  if (!a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3D::RenderGraph::addPass(v4, v5, v6);
  }
  v7 = *((_QWORD *)this + 3);
  v8 = *(unsigned int *)(v7 + 8);
  *((_DWORD *)a2 + 26) = v8;
  *((_QWORD *)a2 + 3) = this;
  v9 = (void *)*((_QWORD *)this + 2);
  v11 = a2;
  C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array((C3D::ScratchAllocator *)&v12, v9);
  C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::Array((C3D::ScratchAllocator *)&v13, v9);
  C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::GraphNode>(v7, &v11);
  if (v8 >= 0x7FFF)
    C3D::RenderGraph::addPass();
  return v8;
}

C3D::ScratchAllocator *C3D::ScratchAllocator::ScratchAllocator(C3D::ScratchAllocator *this, void *a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = a2;
  if (!a2)
  {
    v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      C3D::ScratchAllocator::ScratchAllocator(v3, v4, v5);
  }
  return this;
}

_QWORD *C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::push_back<C3D::RenderGraph::GraphNode>(uint64_t a1, _QWORD *a2)
{
  unsigned int v4;
  _QWORD *result;

  v4 = *(_DWORD *)(a1 + 8);
  if (v4 + 1 > *(_DWORD *)(a1 + 12))
  {
    C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::GrowCapacityBy(a1, 1, 0);
    v4 = *(_DWORD *)(a1 + 8);
  }
  result = C3D::RenderGraph::GraphNode::GraphNode((_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v4), a2);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

_QWORD *C3D::RenderGraph::GraphNode::GraphNode(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[3] = a1 + 4;
  C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=((uint64_t)(a1 + 1), (uint64_t)(a2 + 1));
  a1[4] = a2[4];
  a1[6] = a1 + 7;
  C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=((uint64_t)(a1 + 4), (uint64_t)(a2 + 4));
  return a1;
}

uint64_t C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  const void *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;

  if (a2 != a1)
  {
    if (!*(_QWORD *)a1)
    {
      v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
        C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(v4, v5, v6);
    }
    v7 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 12) = v7;
    if (*(_QWORD *)(a1 + 16) != a1 + 24)
      *(_QWORD *)(a1 + 16) = a1 + 24;
    v8 = *(const void **)(a2 + 16);
    if (v8 == (const void *)(a2 + 24))
    {
      if (v7)
      {
        v9 = scn_default_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
          C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(v9, v10, v11);
      }
      if (*(_DWORD *)(a2 + 12))
      {
        v12 = scn_default_log();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
          C3D::Array<C3D::RenderGraph::Link,0u,C3D::ScratchAllocator>::operator=(v12, v13, v14);
      }
      memcpy((void *)(a1 + 24), v8, 4 * *(unsigned int *)(a2 + 8));
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v8;
    }
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = a2 + 24;
  }
  return a1;
}

_QWORD *C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::GrowCapacityBy(uint64_t a1, int a2, int a3)
{
  double v4;
  unsigned int v5;
  _QWORD *result;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;

  v4 = 1.5;
  if (a3)
    v4 = 1.0;
  v5 = (v4 * (double)(*(_DWORD *)(a1 + 12) + a2));
  result = (_QWORD *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)a1, 56 * v5, 8, 0);
  v7 = result;
  if (*(_DWORD *)(a1 + 8))
  {
    v8 = 0;
    v9 = 0;
    do
    {
      result = C3D::RenderGraph::GraphNode::GraphNode(&v7[v8], (_QWORD *)(*(_QWORD *)(a1 + 16) + v8 * 8));
      ++v9;
      v8 += 7;
    }
    while (v9 < *(unsigned int *)(a1 + 8));
  }
  *(_QWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 12) = v5;
  return result;
}

_DWORD *C3D::Array<unsigned short,0u,C3D::ScratchAllocator>::push_back<unsigned short &>(_DWORD *result, _WORD *a2)
{
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  const void *v7;
  unsigned int v8;
  void *Aligned;

  v3 = result;
  v4 = result[2];
  v5 = result[3];
  v6 = v4 + 1;
  v7 = (const void *)*((_QWORD *)result + 2);
  if (v4 + 1 > v5)
  {
    v8 = ((double)(v5 + 1) * 1.5);
    Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)result, 2 * v8, 2, 0);
    result = memcpy(Aligned, v7, 2 * v3[2]);
    *((_QWORD *)v3 + 2) = Aligned;
    v3[3] = v8;
    v4 = v3[2];
    v6 = v4 + 1;
    v7 = Aligned;
  }
  *((_WORD *)v7 + v4) = *a2;
  v3[2] = v6;
  return result;
}

uint64_t C3D::RenderGraph::clearAllDirtyBits(uint64_t result, int a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;

  v2 = *(_QWORD *)(result + 24);
  v3 = *(_DWORD *)(v2 + 8);
  if (v3)
  {
    v4 = *(_QWORD *)(v2 + 16);
    v5 = v4 + 56 * v3;
    do
    {
      v6 = 1;
      do
      {
        if ((v6 & a2) != 0)
        {
          if (v6 == 1)
            v7 = v4 + 8;
          else
            v7 = v4 + 32;
          v8 = *(unsigned int *)(v7 + 8);
          if ((_DWORD)v8)
          {
            v9 = *(_DWORD **)(v7 + 16);
            v10 = 4 * v8;
            do
            {
              *v9++ &= ~0x8000u;
              v10 -= 4;
            }
            while (v10);
          }
        }
      }
      while (v6++ < 2);
      v4 += 56;
    }
    while (v4 != v5);
  }
  return result;
}

uint64_t C3D::RenderGraph::checkResources(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  C3D::Pass **v6;
  C3D::PassResource *v7;
  unsigned int v8;
  C3D::PassResource *v9;
  C3D::PassResource *v10;

  v1 = *(_QWORD *)(this + 96);
  if (v1)
  {
    v2 = this;
    do
    {
      v3 = *(unsigned int *)(v1 + 8);
      if ((_DWORD)v3)
      {
        v4 = *(unsigned __int16 **)(v1 + 16);
        v5 = &v4[v3];
        do
        {
          v6 = (C3D::Pass **)C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(v2 + 24), *v4);
          v7 = (C3D::PassResource *)C3D::Pass::resource(*v6);
          this = C3D::PassResource::outputCount(v7);
          if ((_DWORD)this)
          {
            v8 = 0;
            do
            {
              v9 = (C3D::PassResource *)C3D::Pass::resource(*v6);
              C3D::PassResource::outputAtIndex(v9, (unsigned __int16)v8++);
              v10 = (C3D::PassResource *)C3D::Pass::resource(*v6);
              this = C3D::PassResource::outputCount(v10);
            }
            while (v8 < this);
          }
          ++v4;
        }
        while (v4 != v5);
      }
      v1 = *(_QWORD *)(v1 + 24);
    }
    while (v1);
  }
  return this;
}

void C3DScratchAllocator::Reset(C3DScratchAllocator *this)
{
  uint64_t v1;
  uint64_t i;

  LODWORD(v1) = *((_DWORD *)this + 2);
  for (i = *((_QWORD *)this + 3); i; i = *(_QWORD *)(i + 24))
    v1 = *(_QWORD *)(i + 8) + v1;
  C3DScratchAllocator::ClearToCapacity(this, v1);
}

void C3DRenderGraphCompile(C3D::RenderGraph *this)
{
  if (*((_BYTE *)this + 211))
    C3D::RenderGraph::allocateResources(this);
}

C3D::Pass *C3DLoadBuiltInPasses(uint64_t a1)
{
  return C3D::RenderGraph::createPass<C3D::FinalPass,decltype(nullptr)>(a1);
}

C3D::Pass *C3D::RenderGraph::createPass<C3D::FinalPass,decltype(nullptr)>(uint64_t a1)
{
  C3D::Pass *Aligned;
  _QWORD *v3;

  Aligned = (C3D::Pass *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)(a1 + 16), 176, 16, 0);
  C3D::Pass::Pass(Aligned, (C3D::RenderGraph *)a1, 0);
  *v3 = &unk_1EA59A788;
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(_BYTE *)(a1 + 209))
    (*(void (**)(C3D::Pass *))(*(_QWORD *)Aligned + 8))(Aligned);
  return Aligned;
}

void C3DNodeSetScale(float32x4_t *a1, __n128 a2)
{
  C3DTransformSetScale((uint64_t)&a1[6], a2);
  __C3DNodeTransformDidChange(a1);
}

void C3DTransformSetScale(uint64_t a1, __n128 a2)
{
  unsigned int v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float32x4_t v20;
  float32x4_t v21;
  __int128 v22;
  __n128 v23;
  float32x4_t v24[4];

  v3 = *(_DWORD *)(a1 + 92);
  if ((v3 & 4) == 0)
  {
    v23 = a2;
    if ((v3 & 8) == 0)
    {
      v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
        C3DTransformSetScale_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    }
    if ((*(_BYTE *)(a1 + 92) & 4) != 0)
    {
      v12 = scn_default_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
        C3DTransformSetScale_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
    v20 = *(float32x4_t *)(a1 + 16);
    v24[0] = *(float32x4_t *)a1;
    v24[1] = v20;
    v21 = *(float32x4_t *)(a1 + 48);
    v24[2] = *(float32x4_t *)(a1 + 32);
    v24[3] = v21;
    *(double *)&v22 = C3DMatrix4x4GetRotation(v24);
    *(_OWORD *)(a1 + 64) = v22;
    v3 = *(_DWORD *)(a1 + 92) & 0xFFFFFFF8 | 4;
    a2 = v23;
  }
  *(_DWORD *)(a1 + 92) = v3 & 0xFFFFFFF7;
  *(_DWORD *)(a1 + 88) = a2.n128_u32[2];
  *(_QWORD *)(a1 + 80) = a2.n128_u64[0];
}

double C3DMatrix4x4GetRotation(float32x4_t *a1)
{
  float32x4_t v1;
  int32x4_t v2;
  float32x4_t v3;
  float32x2_t v4;
  float32x2_t v5;
  float32x4_t v6;
  int32x4_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x4_t v10;
  int32x4_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x4_t v14;
  float v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v20;
  float32x4_t v21;
  int32x4_t v22;
  float32_t v23;
  float32x4_t v24;
  float32x4_t v25;
  __n128 v26;
  __n128 v28;

  v1 = a1[1];
  v2 = (int32x4_t)vmulq_f32(*a1, *a1);
  v2.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v2, 2), vadd_f32(*(float32x2_t *)v2.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v2.i8, 1))).u32[0];
  v3 = a1[2];
  v4 = vrsqrte_f32((float32x2_t)v2.u32[0]);
  v5 = vmul_f32(v4, vrsqrts_f32((float32x2_t)v2.u32[0], vmul_f32(v4, v4)));
  v6 = vmulq_n_f32(*a1, vmul_f32(v5, vrsqrts_f32((float32x2_t)v2.u32[0], vmul_f32(v5, v5))).f32[0]);
  v7 = (int32x4_t)vmulq_f32(v1, v1);
  v7.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v7, 2), vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1))).u32[0];
  v8 = vrsqrte_f32((float32x2_t)v7.u32[0]);
  v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v8, v8)));
  v10 = vmulq_n_f32(v1, vmul_f32(v9, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v9, v9))).f32[0]);
  v11 = (int32x4_t)vmulq_f32(v3, v3);
  v11.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2), vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1))).u32[0];
  v12 = vrsqrte_f32((float32x2_t)v11.u32[0]);
  v13 = vmul_f32(v12, vrsqrts_f32((float32x2_t)v11.u32[0], vmul_f32(v12, v12)));
  v14 = vmulq_n_f32(v3, vmul_f32(v13, vrsqrts_f32((float32x2_t)v11.u32[0], vmul_f32(v13, v13))).f32[0]);
  v15 = (float)(v6.f32[0] + v10.f32[1]) + v14.f32[2];
  if (v15 <= 0.0)
  {
    if (v6.f32[0] <= v10.f32[1] || v6.f32[0] <= v14.f32[2])
    {
      if (v10.f32[1] <= v14.f32[2])
      {
        v25.i64[0] = v14.i64[0];
        v25.f32[2] = (float)(v14.f32[2] + 1.0) - v6.f32[0];
        v25.i32[3] = v6.i32[1];
        v18 = (float32x4_t)vrev64q_s32((int32x4_t)vextq_s8((int8x16_t)vtrn1q_s32((int32x4_t)v10, (int32x4_t)v6), (int8x16_t)v10, 8uLL));
        v17.i64[0] = vaddq_f32(v14, v18).u64[0];
        v17.i64[1] = vsubq_f32(v25, v18).i64[1];
        v18.i32[0] = v17.i32[2];
      }
      else
      {
        v20 = v10;
        v20.f32[1] = (float)(v10.f32[1] + 1.0) - v6.f32[0];
        v20.i32[3] = v14.i32[0];
        v21 = (float32x4_t)vzip2q_s32(vzip1q_s32((int32x4_t)v6, (int32x4_t)v14), vtrn1q_s32((int32x4_t)v14, (int32x4_t)v6));
        v22 = (int32x4_t)vaddq_f32(v10, v21);
        v18 = vsubq_f32(v20, v21);
        v17 = (float32x4_t)vtrn2q_s32(vrev64q_s32(v22), (int32x4_t)v18);
        v18.i32[0] = v18.i32[1];
      }
    }
    else
    {
      v23 = (float)(v6.f32[0] + 1.0) - v10.f32[1];
      v24 = (float32x4_t)vextq_s8((int8x16_t)v10, (int8x16_t)vtrn1q_s32((int32x4_t)v10, (int32x4_t)v14), 0xCuLL);
      v17 = vaddq_f32(v24, v6);
      v24.f32[0] = v23;
      v6.i32[0] = v14.i32[2];
      v6.i32[3] = v14.i32[1];
      v18 = vsubq_f32(v24, v6);
      v17.i32[0] = v18.i32[0];
      v17.i32[3] = v18.i32[3];
    }
  }
  else
  {
    v16 = (float32x4_t)vzip2q_s32((int32x4_t)v10, vuzp1q_s32((int32x4_t)v10, (int32x4_t)v14));
    v16.i32[2] = v6.i32[1];
    v18 = (float32x4_t)vtrn2q_s32((int32x4_t)v14, vzip2q_s32((int32x4_t)v14, (int32x4_t)v6));
    v18.i32[2] = v10.i32[0];
    v17 = vsubq_f32(v16, v18);
    v18.i32[3] = 1.0;
    v16.f32[3] = v15;
    v17.i32[3] = vaddq_f32(v16, v18).i32[3];
    v18.i32[0] = v17.i32[3];
  }
  v26 = (__n128)vmulq_n_f32(v17, 0.5 / sqrtf(v18.f32[0]));
  v28 = 0uLL;
  C3DQuaternionMake(&v28, v26, v26.n128_f32[1], v26.n128_f32[2], v26.n128_f32[3]);
  return v28.n128_f64[0];
}

__n128 C3DQuaternionMake(__n128 *a1, __n128 result, float a3, float a4, float a5)
{
  result.n128_f32[1] = a3;
  result.n128_u64[1] = __PAIR64__(LODWORD(a5), LODWORD(a4));
  *a1 = result;
  return result;
}

void _C3DEngineContextCFFinalize(uint64_t a1)
{
  uint64_t SharedInstance;
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;

  if (a1)
  {
    C3DRenderGraphDelete(*(C3D::RenderGraph **)(a1 + 1728));
    C3DAudioManagerRemoveEngineContext((__C3DEngineContext *)a1);
    SharedInstance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterRemoveObserver(SharedInstance, (const void *)a1, CFSTR("kC3DNotificationEngineContextInvalidatePasses"), 0);
    v3 = *(_QWORD *)(a1 + 152);
    if (v3)
    {
      v4 = *(const void **)(a1 + 136);
      if (v4)
        _C3DResourceManagerUninstallRendererContext(v3, v4);
    }
    v5 = *(_QWORD *)(a1 + 16);
    if (v5)
      C3DSceneUnregisterEngineContext(v5, a1);
    v6 = *(const void **)(a1 + 144);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a1 + 144) = 0;
    }
    v7 = *(const void **)(a1 + 160);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(a1 + 160) = 0;
    }
    v8 = *(const void **)(a1 + 136);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(a1 + 136) = 0;
    }
    v9 = *(const void **)(a1 + 152);
    if (v9)
    {
      CFRelease(v9);
      *(_QWORD *)(a1 + 152) = 0;
    }
    v10 = *(const void **)(a1 + 16);
    if (v10)
    {
      CFRelease(v10);
      *(_QWORD *)(a1 + 16) = 0;
    }
    v11 = *(const void **)(a1 + 24);
    if (v11)
    {
      CFRelease(v11);
      *(_QWORD *)(a1 + 24) = 0;
    }
    v12 = *(const void **)(a1 + 32);
    if (v12)
    {
      CFRelease(v12);
      *(_QWORD *)(a1 + 32) = 0;
    }
    v13 = *(const void **)(a1 + 40);
    if (v13)
    {
      CFRelease(v13);
      *(_QWORD *)(a1 + 40) = 0;
    }
    v14 = *(const void **)(a1 + 376);
    if (v14)
    {
      CFRelease(v14);
      *(_QWORD *)(a1 + 376) = 0;
    }
    v15 = *(const void **)(a1 + 48);
    if (v15)
    {
      CFRelease(v15);
      *(_QWORD *)(a1 + 48) = 0;
    }
    v16 = *(const void **)(a1 + 392);
    if (v16)
    {
      CFRelease(v16);
      *(_QWORD *)(a1 + 392) = 0;
    }
    v17 = *(const void **)(a1 + 1640);
    if (v17)
    {
      CFRelease(v17);
      *(_QWORD *)(a1 + 1640) = 0;
    }
    v18 = *(const void **)(a1 + 1704);
    if (v18)
    {
      CFRelease(v18);
      *(_QWORD *)(a1 + 1704) = 0;
    }
    v19 = *(const void **)(a1 + 192);
    if (v19)
    {
      CFRelease(v19);
      *(_QWORD *)(a1 + 192) = 0;
    }
    v20 = *(const void **)(a1 + 176);
    if (v20)
    {
      CFRelease(v20);
      *(_QWORD *)(a1 + 176) = 0;
    }
    v21 = *(const void **)(a1 + 184);
    if (v21)
    {
      CFRelease(v21);
      *(_QWORD *)(a1 + 184) = 0;
    }
    v22 = *(const void **)(a1 + 168);
    if (v22)
    {
      CFRelease(v22);
      *(_QWORD *)(a1 + 168) = 0;
    }
    v23 = 0;
    v24 = a1 + 1648;
    do
    {
      v25 = *(const void **)(v24 + v23);
      if (v25)
      {
        CFRelease(v25);
        *(_QWORD *)(v24 + v23) = 0;
      }
      v23 += 8;
    }
    while (v23 != 48);
    *(_QWORD *)(a1 + 1696) = 0;
  }
}

C3D::RenderGraph *C3DRenderGraphDelete(C3D::RenderGraph *result)
{
  if (result)
  {
    C3D::RenderGraph::~RenderGraph(result);
    JUMPOUT(0x1DF0D41C0);
  }
  return result;
}

void C3D::RenderGraph::~RenderGraph(C3D::RenderGraph *this)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  const void *v5;

  v2 = *((_QWORD *)this + 16);
  if (v2)
  {
    v3 = C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::~Hash(v2);
    MEMORY[0x1DF0D41C0](v3, 0x1030C408C11463FLL);
  }

  C3DScratchAllocatorDelete(*((C3DScratchAllocator **)this + 2));
  v4 = (const void *)*((_QWORD *)this + 24);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 24) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 25);
  if (v5)
  {
    CFRelease(v5);
    *((_QWORD *)this + 25) = 0;
  }

}

uint64_t C3D::Hash<std::unique_ptr<C3D::RenderGraphResource>,C3D::MallocAllocator>::~Hash(uint64_t a1)
{
  uint64_t *v2;
  int v3;
  uint64_t v4;
  __int16 *v5;
  __int16 v6;
  uint64_t v7;

  v2 = *(uint64_t **)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 28);
  v4 = (v3 + 15);
  if (v3 != -15)
  {
    v5 = *(__int16 **)(a1 + 16);
    do
    {
      v6 = *v5++;
      if ((v6 & 1) != 0)
      {
        v7 = *v2;
        *v2 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      }
      ++v2;
      --v4;
    }
    while (v4);
    v2 = *(uint64_t **)(a1 + 8);
  }
  free(v2);
  free(*(void **)a1);
  free(*(void **)(a1 + 16));
  return a1;
}

void C3D::DrawNodesPassResource::~DrawNodesPassResource(C3D::DrawNodesPassResource *this)
{
  JUMPOUT(0x1DF0D41C0);
}

void C3D::ProbeArrayResource::~ProbeArrayResource(C3D::ProbeArrayResource *this)
{
  void *v2;
  char *v3;
  char *v4;
  char *v5;

  *(_QWORD *)this = &off_1EA599AB8;
  v3 = (char *)this + 48;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)

  v4 = (char *)*((_QWORD *)this + 5);
  if (v4 != v3)
    free(v4);
  v5 = (char *)*((_QWORD *)this + 3);
  if (v5 != (char *)this + 32)
    free(v5);
  JUMPOUT(0x1DF0D41C0);
}

{
  void *v2;
  char *v3;
  char *v4;
  char *v5;

  *(_QWORD *)this = &off_1EA599AB8;
  v3 = (char *)this + 48;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)

  v4 = (char *)*((_QWORD *)this + 5);
  if (v4 != v3)
    free(v4);
  v5 = (char *)*((_QWORD *)this + 3);
  if (v5 != (char *)this + 32)
    free(v5);
}

C3DScratchAllocator *C3DScratchAllocatorDelete(C3DScratchAllocator *result)
{
  C3DScratchAllocator *v1;

  if (result)
  {
    v1 = result;
    C3DScratchAllocator::ClearToCapacity(result, 0);
    MEMORY[0x1DF0D52F4](*MEMORY[0x1E0C83DA0], *(_QWORD *)v1, *((_QWORD *)v1 + 1));
    JUMPOUT(0x1DF0D41C0);
  }
  return result;
}

void C3DScratchAllocator::ClearToCapacity(C3DScratchAllocator *this, unint64_t a2)
{
  _QWORD *v4;
  unsigned int *v5;
  _QWORD *v6;

  *((_QWORD *)this + 2) = 0;
  v4 = (_QWORD *)*((_QWORD *)this + 3);
  v5 = (unsigned int *)MEMORY[0x1E0C83DA0];
  if (v4)
  {
    do
    {
      v6 = (_QWORD *)v4[3];
      MEMORY[0x1DF0D52F4](*v5, *v4, v4[1]);
      MEMORY[0x1DF0D41C0](v4, 0x10A0C4064A2AE3FLL);
      v4 = v6;
    }
    while (v6);
  }
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = this;
  if (*((_QWORD *)this + 1) < a2)
  {
    MEMORY[0x1DF0D52F4](*v5, *(_QWORD *)this);
    VMAllocateChunk((vm_address_t *)this, a2);
  }
}

void C3DNotificationCenterRemoveObserver(uint64_t a1, const void *a2, const __CFString *a3, const void *a4)
{
  __CFNotificationCenter *LocalCenter;

  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(LocalCenter, a2, a3, a4);
}

void SCNMTLBufferPool::~SCNMTLBufferPool(SCNMTLBufferPool *this)
{
  id *v2;

  v2 = (id *)*((_QWORD *)this + 4);
  if (v2 != *((id **)this + 5))
  {
    do
    {

      v2 += 2;
    }
    while (v2 != *((id **)this + 5));
    v2 = (id *)*((_QWORD *)this + 4);
  }
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
}

void sub_1DCD1A9A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 32);
  if (v3)
  {
    *(_QWORD *)(v1 + 40) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void SCNMTLTexturePool::~SCNMTLTexturePool(SCNMTLTexturePool *this)
{
  id *v2;
  id *v3;

  v2 = (id *)*((_QWORD *)this + 2);
  v3 = (id *)*((_QWORD *)this + 3);
  if (v2 != v3)
  {
    do
    {
      if (*v2)

      v2 += 4;
    }
    while (v2 != v3);
    v2 = (id *)*((_QWORD *)this + 2);
  }
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
}

void sub_1DCD1AA24(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 16);
  if (v3)
  {
    *(_QWORD *)(v1 + 24) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t C3DMetalIsSupported()
{
  if (C3DMetalIsSupported_onceToken != -1)
    dispatch_once(&C3DMetalIsSupported_onceToken, &__block_literal_global_50);
  return C3DMetalIsSupported_supported;
}

uint64_t C3DWasLinkedBeforeMajorOSYear2015()
{
  if (C3DWasLinkedBeforeMajorOSYear2015_onceToken != -1)
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2015_onceToken, &__block_literal_global_2_0);
  return C3DWasLinkedBeforeMajorOSYear2015_linkedBeforeMajorOSYear2015;
}

uint64_t C3DWasLinkedBeforeMajorOSYear2019()
{
  if (C3DWasLinkedBeforeMajorOSYear2019_onceToken != -1)
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2019_onceToken, &__block_literal_global_6);
  return C3DWasLinkedBeforeMajorOSYear2019_linkedBeforeMajorOSYear2019;
}

uint64_t C3DWasLinkedBeforeMajorOSYear2021()
{
  if (C3DWasLinkedBeforeMajorOSYear2021_onceToken != -1)
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2021_onceToken, &__block_literal_global_8_0);
  return C3DWasLinkedBeforeMajorOSYear2021_linkedBeforeMajorOSYear2021;
}

uint64_t C3DWasLinkedBeforeMajorOSYear2020()
{
  if (C3DWasLinkedBeforeMajorOSYear2020_onceToken != -1)
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2020_onceToken, &__block_literal_global_7_1);
  return C3DWasLinkedBeforeMajorOSYear2020_linkedBeforeMajorOSYear2020;
}

uint64_t C3DGetInfoPlistFlagIsSet(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;

  v3 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle"), "infoDictionary"), "objectForKeyedSubscript:", a1);
  if (v3 && (v4 = (void *)v3, objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    return objc_msgSend(v4, "BOOLValue");
  else
    return a2;
}

uint64_t C3DGetShaderCacheLibraryURL()
{
  return kShaderCacheLibraryURL;
}

void _C3DPostSceneDidChangeNotifications(void *object, CFNotificationCenterRef center)
{
  if (center)
    CFNotificationCenterPostNotificationWithOptions(center, CFSTR("kC3DSceneDidUpdateNotification"), object, 0, 4uLL);
}

void _C3DSortSystemCFFinalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

void _C3DRendererElementStateCFFinalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 328);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 328) = 0;
  }
  *(_QWORD *)(a1 + 336) = 0;
}

void sub_1DCD1BB1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1DCD1BD20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  id *v19;

  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t C3DWasLinkedBeforeMajorOSYear2022()
{
  if (C3DWasLinkedBeforeMajorOSYear2022_onceToken != -1)
    dispatch_once(&C3DWasLinkedBeforeMajorOSYear2022_onceToken, &__block_literal_global_9_0);
  return C3DWasLinkedBeforeMajorOSYear2022_linkedBeforeMajorOSYear2022;
}

void _dispatchAutoFlush(uint64_t a1)
{
  C3DEngineNotificationQueueTransientWrapper *v2;
  dispatch_time_t v3;
  _QWORD v4[6];

  if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16)))
  {
    v2 = objc_alloc_init(C3DEngineNotificationQueueTransientWrapper);
    -[C3DEngineNotificationQueueTransientWrapper setEngineNotificationQueue:](v2, "setEngineNotificationQueue:", a1);
    v3 = dispatch_time(0, 1000000000);
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 3221225472;
    v4[2] = ___dispatchAutoFlush_block_invoke;
    v4[3] = &unk_1EA5A3010;
    v4[4] = v2;
    v4[5] = a1;
    dispatch_after(v3, MEMORY[0x1E0C80D38], v4);

  }
}

uint64_t _C3DUnlockScenesAndBumpStateStamps(uint64_t a1)
{
  C3DSceneBumpStateStamp(a1);
  return C3DSceneUnlock(a1);
}

void C3DSceneBumpStateStamp(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  ++*(_DWORD *)(a1 + 300);
}

void __AppendArgument(uint64_t a1, int a2, uint64_t a3, void *a4, int a5)
{
  uint64_t v10;
  void *v11;
  int v12;
  void *v13;
  char v14;
  uint64_t v15;
  void *v16;
  int v17;

  if ((objc_msgSend(a4, "hasPrefix:", CFSTR("texture")) & 1) != 0
    || (objc_msgSend(a4, "hasPrefix:", CFSTR("depth")) & 1) != 0)
  {
    v10 = 176;
    if (a2)
      v10 = 184;
    v11 = *(void **)(a1 + v10);
    if (objc_msgSend(a4, "hasSuffix:", CFSTR(">")))
      objc_msgSend(v11, "appendFormat:", CFSTR(", %@ %@\n"), a4, a3);
    else
      objc_msgSend(v11, "appendFormat:", CFSTR(", %@<float> %@\n"), a4, a3);
    v12 = 1;
  }
  else
  {
    v14 = objc_msgSend(a4, "hasPrefix:", CFSTR("sampler"));
    v15 = 176;
    if (a2)
      v15 = 184;
    v16 = *(void **)(a1 + v15);
    if ((v14 & 1) != 0)
    {
      objc_msgSend(v16, "appendFormat:", CFSTR(", %@ %@\n"), a4, a3);
      v12 = 2;
    }
    else
    {
      if (objc_msgSend(a4, "hasSuffix:", CFSTR("*")))
        objc_msgSend(v16, "appendFormat:", CFSTR(", device %@ %@\n"), a4, a3);
      else
        objc_msgSend(v16, "appendFormat:", CFSTR(", constant %@& %@\n"), a4, a3);
      v12 = 0;
    }
  }
  if (a5 == 3)
  {
    objc_msgSend(*(id *)(a1 + 168), "appendFormat:", CFSTR("_lightingContribution.%@=%@;\n"), a3, a3);
    if (v12 != 1)
    {
      v13 = *(void **)(a1 + 160);
LABEL_17:
      objc_msgSend(v13, "appendFormat:", CFSTR("%@ %@;\n"), a4, a3);
      return;
    }
    v17 = objc_msgSend(a4, "hasSuffix:", CFSTR(">"));
    v13 = *(void **)(a1 + 160);
    if (v17)
      goto LABEL_17;
    objc_msgSend(v13, "appendFormat:", CFSTR("%@<float> %@;\n"), a4, a3);
  }
}

dispatch_queue_t ___commitImplicitTransaction_block_invoke()
{
  NSObject *v0;
  NSObject *v1;
  dispatch_queue_t result;

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v1 = dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_USER_INTERACTIVE, 0);
  result = dispatch_queue_create("com.apple.scenekit.main-thread-implicit-transaction-flush", v1);
  _commitImplicitTransaction_queue = (uint64_t)result;
  return result;
}

void _C3DProgramHashCodeStoreCFFinalize(_QWORD *a1)
{
  const void *v2;

  C3DProgramHashCodeStoreClear((uint64_t)a1);
  C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::~Hash((uint64_t)(a1 + 2));
  v2 = (const void *)a1[6];
  if (v2)
  {
    CFRelease(v2);
    a1[6] = 0;
  }
}

uint64_t C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::~Hash(uint64_t a1)
{
  C3D::Hash<C3D::SmartPtr<__C3DArray *,C3D::detail::CFRetainFct,C3D::detail::CFReleaseFct>,C3D::MallocAllocator>::_destroy_values(*(CFTypeRef **)(a1 + 8), *(__int16 **)(a1 + 16), *(_DWORD *)(a1 + 28) + 15);
  free(*(void **)(a1 + 8));
  free(*(void **)a1);
  free(*(void **)(a1 + 16));
  return a1;
}

void SCNMTLClusterSystem::~SCNMTLClusterSystem(SCNMTLClusterSystem *this)
{
  uint64_t i;
  char *v3;
  const void *v4;
  const void *v5;

  for (i = 0; i != 56; i += 8)
  {
    v3 = (char *)this + i;
    v4 = *(const void **)((char *)this + i + 72);
    if (v4)
    {
      CFRelease(v4);
      *((_QWORD *)v3 + 9) = 0;
    }
    v5 = (const void *)*((_QWORD *)v3 + 16);
    if (v5)
    {
      CFRelease(v5);
      *((_QWORD *)v3 + 16) = 0;
    }
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,SCNMTLLightSetData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,SCNMTLLightSetData>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void *SCNMTLBlitCommandEncoder::beginEncoding(_QWORD *a1, void *a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *result;

  if (*a1 && (v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    SCNMTLBlitCommandEncoder::beginEncoding(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    SCNMTLBlitCommandEncoder::beginEncoding(v14, v15, v16, v17, v18, v19, v20, v21);
LABEL_6:
  *a1 = 0;
  a1[1] = 0;
  result = (void *)objc_msgSend(a2, "blitCommandEncoder");
  *a1 = result;
  a1[1] = a2;
  if (a3)
    return (void *)objc_msgSend(result, "setLabel:", a3);
  return result;
}

const void *C3DResourceCacheGetSourceForResource(uint64_t a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *Value;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    C3DResourceCacheCopyResourceForSource_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    C3DResourceCacheGetSourceForResource_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
  return Value;
}

BOOL C3DImageHasTextureRawData(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 80) & 2) != 0 || C3DImageGetTextureRawData(a1) != 0;
}

C3D::MainPass *C3D::RenderGraph::createPass<C3D::MainPass,C3D::Pass *&>(uint64_t a1, C3D::Pass **a2)
{
  C3D::MainPass *Aligned;

  Aligned = (C3D::MainPass *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)(a1 + 16), 5456, 16, 0);
  C3D::MainPass::MainPass(Aligned, (C3D::RenderGraph *)a1, *a2);
  C3D::RenderGraph::addPass((C3D::RenderGraph *)a1, Aligned);
  if (*(_BYTE *)(a1 + 209))
    (*(void (**)(C3D::MainPass *))(*(_QWORD *)Aligned + 8))(Aligned);
  return Aligned;
}

C3D::DrawNodesPass *C3D::MainPass::MainPass(C3D::MainPass *this, C3D::RenderGraph *a2, C3D::Pass *a3)
{
  C3D::DrawNodesPass *result;
  _OWORD v4[2];
  uint64_t v5;
  __int128 v6;
  char v7;
  uint64_t v8;
  char v9;
  Parameters v10;

  *(_DWORD *)&v10.var0 = 16843009;
  *(_WORD *)&v10.var4 = 1;
  v5 = 0;
  memset(v4, 0, sizeof(v4));
  v6 = xmmword_1DD007D30;
  v7 = 1;
  v8 = 0;
  v9 = 2;
  result = C3D::ScenePass::ScenePass(this, a2, a3, &v10, (const Parameters *)v4);
  *(_QWORD *)result = off_1EA59A6F8;
  *((_QWORD *)result + 681) = 0;
  *((_BYTE *)result + 5365) = 1;
  return result;
}

C3D::DrawNodesPass *C3D::ScenePass::ScenePass(C3D::ScenePass *this, C3D::RenderGraph *a2, C3D::Pass *a3, const Parameters *a4, const Parameters *a5)
{
  C3D::DrawNodesPass *result;
  int v7;

  result = C3D::DrawNodesPass::DrawNodesPass(this, a2, a3, a5);
  *(_QWORD *)result = off_1EA59A888;
  v7 = *(_DWORD *)&a4->var0;
  *((_WORD *)result + 2682) = *(_WORD *)&a4->var4;
  *((_DWORD *)result + 1340) = v7;
  *((_QWORD *)result + 671) = 0;
  *((_QWORD *)result + 673) = 0;
  *((_QWORD *)result + 672) = 0;
  *((_QWORD *)result + 680) = result;
  return result;
}

C3D::DrawNodesPass *C3D::DrawNodesPass::DrawNodesPass(C3D::DrawNodesPass *this, C3D::RenderGraph *a2, C3D::Pass *a3, const Parameters *a4)
{
  C3D::RenderPass *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  v6 = C3D::RenderPass::RenderPass(this, a2, a3);
  *(_QWORD *)v6 = off_1EA598E38;
  *((_OWORD *)v6 + 15) = *(_OWORD *)&a4->var0;
  v7 = *(_OWORD *)&a4[1].var6;
  v8 = *(_OWORD *)&a4[3].var2;
  v9 = *(_OWORD *)&a4[4].var8;
  *((_QWORD *)v6 + 38) = *(_QWORD *)&a4[6].var4;
  *((_OWORD *)v6 + 17) = v8;
  *((_OWORD *)v6 + 18) = v9;
  *((_OWORD *)v6 + 16) = v7;
  bzero((char *)v6 + 320, 0x13B0uLL);
  return this;
}

C3D::RenderPass *C3D::RenderPass::RenderPass(C3D::RenderPass *this, C3D::RenderGraph *a2, C3D::Pass *a3)
{
  uint64_t v4;

  C3D::Pass::Pass(this, a2, a3);
  *(_QWORD *)v4 = &unk_1EA598898;
  *(_WORD *)(v4 + 112) = 256;
  *(_DWORD *)(v4 + 224) = 0;
  *(_QWORD *)(v4 + 114) = 0;
  *(_DWORD *)(v4 + 32) = 2;
  memset_pattern16((void *)(v4 + 128), &unk_1DD02C770, 0x60uLL);
  return this;
}

double C3D::Pass::Pass(C3D::Pass *this, C3D::RenderGraph *a2, C3D::Pass *a3)
{
  double result;

  *(_QWORD *)this = &unk_1EA59A5A8;
  *((_QWORD *)this + 1) = a3;
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 1);
  *((_QWORD *)this + 3) = a2;
  *(_QWORD *)&result = 0x1000000010000;
  *(_QWORD *)((char *)this + 36) = 0x1000000010000;
  *((_DWORD *)this + 11) = 1;
  *((_BYTE *)this + 48) = 1;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 26) = -1;
  return result;
}

const void *_C3DNodeEnumerateAttributeEntities(uint64_t a1, const void *a2, uint64_t a3)
{
  const void *result;

  result = CFTypeIsC3DEntity(a2);
  if ((_DWORD)result)
    return (const void *)(*(uint64_t (**)(uint64_t, const void *))(a3 + 16))(a3, a2);
  return result;
}

void C3DNodeSetQuaternion(float32x4_t *a1, __n128 a2)
{
  C3DTransformSetQuaternion((uint64_t)&a1[6], a2);
  __C3DNodeTransformDidChange(a1);
}

void C3DTransformSetQuaternion(uint64_t a1, __n128 a2)
{
  int v3;
  __n128 v4;

  v3 = *(_DWORD *)(a1 + 92);
  if ((v3 & 4) == 0)
  {
    v4 = a2;
    _updateAffineScale((float32x4_t *)a1);
    a2 = v4;
    v3 = *(_DWORD *)(a1 + 92);
  }
  *(_DWORD *)(a1 + 92) = v3 & 0xFFFFFFF4;
  *(__n128 *)(a1 + 64) = a2;
}

void _updateAffineScale(float32x4_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if ((a1[5].i8[12] & 8) == 0)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      _updateAffineScale_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((a1[5].i8[12] & 4) != 0)
  {
    v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      _updateAffineScale_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
  }
  C3DMatrix4x4GetScale(a1, a1 + 5);
  a1[5].i32[3] |= 4u;
}

uint64_t C3DCameraGetProjectionInfosPtr(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return a1 + 64;
}

uint64_t C3DCameraUsesLegacyFov(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 64) >> 4) & 1;
}

float C3DCameraGetScreenSpaceAmbientOcclusionIntensity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 492);
}

uint64_t C3DCameraGetARGrainTexture(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 544);
}

void *C3D::PostProcessPassesCreateIfNeeded(C3D *this, C3D::RenderGraph *a2, C3D::MainPass *a3, C3D::Pass **a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t RenderContext;
  void *result;
  uint64_t v11;
  uint64_t Aligned;
  float32x2_t *v13;
  BOOL v14;
  float v15;
  uint64_t ColorGradingEffectSlot;
  char WantsHDR;
  _BYTE *v18;
  char v19;
  char v20;
  BOOL v21;
  BOOL v22;
  BOOL v23;
  int BloomIteration;
  float v25;
  int v26;
  float v27;
  float v28;
  float v30;
  BOOL v31;
  int v32;
  C3D::Pass *Pass;
  uint64_t StackAllocator;
  C3D::Pass *v35;
  _BYTE *v36;
  C3D::Pass *v37;
  C3D::Pass *v38;
  C3D::Pass *v39;
  C3D::Pass *v40;
  C3D::Pass *v41;
  C3D::Pass *v42;
  float BloomBlurRadius;
  float v44;
  C3D::Pass *v45;
  const float *v46;
  float32x2_t v47;
  float32x2_t v48;
  C3D::PassDescriptor *v53;
  uint64_t v54;
  C3D::PassDescriptor *v55;
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  C3D::Pass *v60;
  C3D::PassDescriptor *v61;
  _OWORD *v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  C3D::PassDescriptor *v66;
  _OWORD *v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  C3D::Pass *v71;
  int DofSampleCount;
  int v73;
  float v74;
  int v75;
  C3D::Pass *v76;
  C3D::Pass *v77;
  C3D::Pass *v78;
  C3D::Pass *v79;
  C3D::Pass *v80;
  C3D::Pass *v81;
  C3D::Pass *v82;
  C3D::Pass *v83;
  C3D::Pass *v84;
  const C3D::Pass **v85;
  uint64_t v86;
  const C3D::Pass *v87;
  C3D::MainPass *v88;
  uint32x2_t v89;
  _BYTE v90[14];
  C3D::Pass *v91;
  _BYTE v92[8];
  unsigned int v93;
  const C3D::Pass **v94;
  uint64_t v95;
  C3D::DrawNodesPass *v96;

  v96 = a2;
  v8 = *((_QWORD *)this + 1);
  v7 = *((_QWORD *)this + 2);
  RenderContext = C3DEngineContextGetRenderContext(v8);
  result = C3DEngineContextGetPointOfView(v8);
  if (result)
  {
    result = C3DNodeGetCamera((uint64_t)result);
    if (result)
    {
      v11 = (uint64_t)result;
      Aligned = C3DScratchAllocatorAllocateAligned(v7, 72, 8, 0);
      *(_OWORD *)Aligned = 0u;
      *(_OWORD *)(Aligned + 16) = 0u;
      *(_OWORD *)(Aligned + 32) = 0u;
      *(_OWORD *)(Aligned + 48) = 0u;
      *(_QWORD *)(Aligned + 64) = 0;
      v95 = Aligned;
      v13 = (float32x2_t *)(*(uint64_t (**)(C3D::RenderGraph *))(*(_QWORD *)a2 + 88))(a2);
      v14 = -[SCNMTLRenderContext contentScaleFactor](RenderContext) <= 1.0;
      v15 = 0.0;
      if (!v14)
        v15 = 1.0;
      *(float *)Aligned = v15 + 1.0;
      ColorGradingEffectSlot = C3DCameraGetColorGradingEffectSlot(v11, 0);
      WantsHDR = C3DCameraGetWantsHDR(v11);
      *(_BYTE *)(Aligned + 8) = WantsHDR;
      if ((WantsHDR & 1) != 0)
      {
        *(_BYTE *)(Aligned + 9) = C3DCameraGetWantsExposureAdaptation(v11);
        v18 = (_BYTE *)(Aligned + 9);
        v19 = *(_BYTE *)(Aligned + 8);
        if (v19)
          v19 = C3DCameraGetBloomIntensity(v11) > 0.0;
      }
      else
      {
        v19 = 0;
        *(_BYTE *)(Aligned + 9) = 0;
        v18 = (_BYTE *)(Aligned + 9);
      }
      *(_BYTE *)(Aligned + 10) = v19;
      *(_BYTE *)(Aligned + 11) = C3DCameraGetMotionBlurIntensity(v11) > 0.0;
      if (C3DCameraGetDepthOfFieldIntensity(v11) <= 0.0)
        v20 = 0;
      else
        v20 = C3DWasLinkedBeforeMajorOSYear2017() ^ 1;
      *(_BYTE *)(Aligned + 12) = v20;
      v21 = C3DCameraGetColorFringeStrength(v11) > 0.0 && C3DCameraGetColorFringeIntensity(v11) != 0.0;
      *(_BYTE *)(Aligned + 13) = v21;
      *(_BYTE *)(Aligned + 14) = C3DCameraGetSaturation(v11) != 1.0;
      *(_BYTE *)(Aligned + 15) = C3DCameraGetContrast(v11) != 0.0;
      v22 = C3DCameraGetVignettingPower(v11) > 0.0 && C3DCameraGetVignettingIntensity(v11) > 0.0;
      *(_BYTE *)(Aligned + 16) = v22;
      v23 = ColorGradingEffectSlot
         && C3DEffectSlotHasImageOrTexture(ColorGradingEffectSlot)
         && C3DEffectSlotGetIntensity(ColorGradingEffectSlot) > 0.0;
      *(_BYTE *)(Aligned + 17) = v23;
      BloomIteration = C3DCameraGetBloomIteration(v11);
      v25 = fmax((double)(float)((float)(v13[1].f32[0] * 0.5) / *(float *)Aligned), (double)(float)((float)(v13[1].f32[1] * 0.5) / *(float *)Aligned));
      v26 = (int)(float)(floorf(log2f(v25)) + 1.0);
      if (BloomIteration < v26)
        v26 = BloomIteration;
      *(_DWORD *)(Aligned + 24) = v26;
      v27 = fmaxf(C3DCameraGetBloomIterationSpread(v11), 0.0);
      v28 = v27 + 1.0;
      _NF = v27 < 10.0;
      v30 = 11.0;
      if (_NF)
        v30 = v28;
      *(float *)(Aligned + 28) = v30;
      *(_BYTE *)(Aligned + 18) = C3DCameraGetGrainIntensity(v11) > 0.0;
      *(_BYTE *)(Aligned + 19) = C3DCameraGetGrainIsColored(v11);
      *(_BYTE *)(Aligned + 21) = -[SCNMTLRenderContext enableARMode](RenderContext);
      v31 = C3DCameraGetWhiteBalanceTemperature(v11) != 0.0 || C3DCameraGetWhiteBalanceTint(v11) != 0.0;
      *(_BYTE *)(Aligned + 22) = v31;
      if ((C3DEngineContextIsTemporalAntialiasingEnabled(v8) & 1) != 0
        || *(_BYTE *)(Aligned + 8)
        || *v18
        || *(_BYTE *)(Aligned + 10)
        || *(_BYTE *)(Aligned + 12)
        || *(_BYTE *)(Aligned + 13)
        || *(_BYTE *)(Aligned + 14)
        || *(_BYTE *)(Aligned + 15)
        || *(_BYTE *)(Aligned + 16)
        || *(_BYTE *)(Aligned + 17)
        || *(_BYTE *)(Aligned + 18)
        || *(_BYTE *)(Aligned + 22))
      {
        v32 = 1;
      }
      else
      {
        if (!*(_BYTE *)(Aligned + 11) && !*(_BYTE *)(Aligned + 21))
          return 0;
        v32 = 0;
      }
      Pass = (C3D::Pass *)C3D::ScenePass::lastPass(a2);
      StackAllocator = C3DEngineContextGetStackAllocator(v8);
      C3D::RenderGraph::getSuccessors((uint64_t)this, (uint64_t)Pass, StackAllocator, (uint64_t)v92);
      if (v32)
      {
        v35 = C3D::RenderGraph::createPass<C3D::CompositePass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
        C3D::Pass::addDependency(v35, Pass);
        v36 = (_BYTE *)v95;
        if (*(_BYTE *)(v95 + 8))
        {
          v37 = C3D::RenderGraph::createPass<C3D::HDRAverageLuminancePass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          C3D::Pass::addDependency(v35, v37);
          v36 = (_BYTE *)v95;
        }
        else
        {
          v37 = 0;
        }
        if (v36[9])
        {
          v38 = C3D::RenderGraph::createPass<C3D::HDRFrameLuminancePass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          v39 = C3D::RenderGraph::createPass<C3D::GenerateMipmapPass,C3D::DrawNodesPass *&>((uint64_t)this, &v96);
          C3D::Pass::addDependency(v38, Pass);
          C3D::Pass::addDependency(v39, v38);
          C3D::Pass::addDependency(v37, v39);
          v36 = (_BYTE *)v95;
        }
        v91 = 0;
        if (v36[10] || v36[12])
        {
          v40 = C3D::RenderGraph::createPass<C3D::DownSampleBloomCoCPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          v41 = v40;
          v91 = v40;
          v42 = Pass;
          if (v96 != Pass)
          {
            C3D::Pass::addDependency(v40, Pass);
            v42 = v96;
          }
          C3D::Pass::addDependency(v41, v42);
          v36 = (_BYTE *)v95;
          if (*(_BYTE *)(v95 + 10))
          {
            C3D::Pass::addDependency(v41, v37);
            v36 = (_BYTE *)v95;
            if (*(_BYTE *)(v95 + 10))
            {
              v88 = a3;
              BloomBlurRadius = C3DCameraGetBloomBlurRadius(v11);
              *(float *)v90 = BloomBlurRadius / (float)(*(float *)v95 + *(float *)v95);
              v44 = *(float *)v90;
              v90[4] = 0;
              *(_QWORD *)&v90[6] = 0;
              v45 = C3D::RenderGraph::createPass<C3D::GaussianBlurPass,C3D::MainPass *&,C3D::GaussianBlurPass::Parameters>((uint64_t)this, &v96, (const Parameters *)v90);
              v46 = (const float *)v95;
              v47 = vld1_dup_f32(v46);
              v48 = vdiv_f32(vmul_f32(v13[1], (float32x2_t)0x3F0000003F000000), v47);
              __asm { FMOV            V1.2S, #1.0 }
              v89 = vcvt_u32_f32(vmaxnm_f32(v48, _D1));
              v53 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v45);
              v54 = C3D::PassDescriptor::inputAtIndex(v53, 0);
              *(_QWORD *)(v54 + 8) = "Bloom";
              *(_WORD *)(v54 + 18) = v89.i16[2];
              *(_WORD *)(v54 + 16) = v89.i16[0];
              *(_DWORD *)(v54 + 20) = 0;
              *(_DWORD *)(v54 + 24) = 514;
              *(_QWORD *)(v54 + 28) = 115;
              *(_BYTE *)(v54 + 30) = *(_DWORD *)(v95 + 24);
              v55 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v45);
              v56 = C3D::PassDescriptor::outputAtIndex(v55, 0);
              v58 = *(_OWORD *)(v54 + 16);
              v57 = *(_OWORD *)(v54 + 32);
              v59 = *(_OWORD *)(v54 + 48);
              *(_OWORD *)(v56 + 64) = *(_OWORD *)(v54 + 64);
              *(_OWORD *)v56 = *(_OWORD *)v54;
              *(_OWORD *)(v56 + 16) = v58;
              *(_OWORD *)(v56 + 32) = v57;
              *(_OWORD *)(v56 + 48) = v59;
              *(_BYTE *)(v56 + 65) = 0;
              *(float *)v90 = v44;
              v90[4] = 1;
              *(_QWORD *)&v90[6] = 0;
              v60 = C3D::RenderGraph::createPass<C3D::GaussianBlurPass,C3D::MainPass *&,C3D::GaussianBlurPass::Parameters>((uint64_t)this, &v96, (const Parameters *)v90);
              *(_QWORD *)v90 = v60;
              v61 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v60);
              v62 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v61, 0);
              *v62 = *(_OWORD *)v54;
              v63 = *(_OWORD *)(v54 + 64);
              v65 = *(_OWORD *)(v54 + 16);
              v64 = *(_OWORD *)(v54 + 32);
              v62[3] = *(_OWORD *)(v54 + 48);
              v62[4] = v63;
              v62[1] = v65;
              v62[2] = v64;
              v66 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v60);
              v67 = (_OWORD *)C3D::PassDescriptor::outputAtIndex(v66, 0);
              *v67 = *(_OWORD *)v56;
              v68 = *(_OWORD *)(v56 + 64);
              v70 = *(_OWORD *)(v56 + 16);
              v69 = *(_OWORD *)(v56 + 32);
              v67[3] = *(_OWORD *)(v56 + 48);
              v67[4] = v68;
              v67[1] = v70;
              v67[2] = v69;
              C3D::Pass::addDependency(v45, v41);
              C3D::Pass::addDependency(v60, v45);
              if (*(int *)(v95 + 24) >= 2)
              {
                v71 = C3D::RenderGraph::createPass<C3D::BloomDownSamplePass,C3D::Pass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v91, &v95);
                C3D::Pass::addDependency(v71, v60);
                v60 = C3D::RenderGraph::createPass<C3D::BloomUpSamplePass,C3D::Pass *&,C3D::PostProcessPassData *&>((uint64_t)this, (C3D::Pass **)v90, &v95);
                C3D::Pass::addDependency(v60, v71);
              }
              a3 = v88;
              C3D::Pass::addDependency(v35, v60);
              v36 = (_BYTE *)v95;
            }
          }
        }
        if (v36[12])
        {
          DofSampleCount = C3DCameraGetDofSampleCount(v11);
          if (DofSampleCount <= 4)
            v73 = 4;
          else
            v73 = DofSampleCount;
          v74 = sqrtf((float)v73);
          v75 = (int)v74 * (int)v74;
          if (v75 >= 256)
            v75 = 256;
          *(_DWORD *)(v95 + 4) = v75 - 1;
          v76 = C3D::RenderGraph::createPass<C3D::DOFDownsampleCoCPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          v77 = C3D::RenderGraph::createPass<C3D::DOFBlurCoCXPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          v78 = C3D::RenderGraph::createPass<C3D::DOFBlurCoCYPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          v79 = C3D::RenderGraph::createPass<C3D::DOFFinalBlurPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
          C3D::Pass::addDependency(v76, v91);
          C3D::Pass::addDependency(v77, v76);
          C3D::Pass::addDependency(v78, v77);
          C3D::Pass::addDependency(v79, v78);
          C3D::Pass::addDependency(v79, v91);
          C3D::Pass::addDependency(v35, v79);
        }
      }
      else
      {
        v35 = 0;
      }
      if (*(_BYTE *)(v95 + 11) && *(_DWORD *)(C3D::DrawNodesPass::getCullingContext(v96) + 4920))
      {
        v80 = C3D::RenderGraph::createPass<C3D::MBTileMaxPass,C3D::MainPass *&>((uint64_t)this, &v96);
        v90[0] = 0;
        v81 = C3D::RenderGraph::createPass<C3D::MBNeighborMaxPass,C3D::MainPass *&,BOOL>((uint64_t)this, &v96, v90);
        v90[0] = 1;
        v82 = C3D::RenderGraph::createPass<C3D::MBNeighborMaxPass,C3D::MainPass *&,BOOL>((uint64_t)this, &v96, v90);
        v83 = C3D::RenderGraph::createPass<C3D::MBFinalBlurPass,C3D::MainPass *&,C3D::PostProcessPassData *&>((uint64_t)this, &v96, &v95);
        C3D::Pass::addDependency(v80, v96);
        C3D::Pass::addDependency(v81, v80);
        C3D::Pass::addDependency(v82, v81);
        C3D::Pass::addDependency(v83, v82);
        if (v32)
          C3D::Pass::addDependency(v83, v35);
        v84 = Pass;
        if (v96 != Pass)
        {
          C3D::Pass::addDependency(v83, Pass);
          v84 = v96;
        }
        C3D::Pass::addDependency(v83, v84);
      }
      else
      {
        v83 = v35;
      }
      if (v93)
      {
        v85 = v94;
        v86 = 8 * v93;
        do
        {
          v87 = *v85++;
          C3D::RenderGraph::removeDependency(this, v87, Pass);
          C3D::RenderGraph::addDependency(this, v87, v83);
          v86 -= 8;
        }
        while (v86);
      }
      if (a3)
        *(_QWORD *)a3 = v83;
      return (void *)v95;
    }
  }
  return result;
}

float C3DCameraGetMotionBlurIntensity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 472);
}

uint64_t C3DCameraGetWantsHDR(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(unsigned __int8 *)(a1 + 312) >> 1) & 1;
}

float C3DCameraGetWhiteBalanceTint(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 488);
}

float C3DCameraGetWhiteBalanceTemperature(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 484);
}

float C3DCameraGetVignettingPower(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 476);
}

float C3DCameraGetSaturation(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 456);
}

uint64_t C3DCameraGetGrainIsColored(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(unsigned __int8 *)(a1 + 312) >> 4) & 1;
}

float C3DCameraGetGrainIntensity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 464);
}

float C3DCameraGetContrast(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 460);
}

float C3DCameraGetColorFringeStrength(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 452);
}

float C3DCameraGetBloomIterationSpread(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 436);
}

uint64_t C3DCameraGetBloomIteration(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(_DWORD *)(a1 + 432);
  if (v10 <= 1)
    return 1;
  else
    return v10;
}

uint64_t C3D::MainPass::setup(C3D::MainPass *this)
{
  uint64_t Scene;
  float32x4_t *PointOfView;
  const __CFDictionary *Camera;
  int v5;
  _BOOL4 v6;
  int v7;
  uint64_t RenderCallbacks;
  unsigned int (*v9)(_QWORD);
  uint64_t v10;
  C3D::Pass *v11;
  C3D::Pass *v12;
  C3D::Pass *v13;
  C3D::MainPass *v14;
  C3D::Pass **v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _BOOL4 v24;
  __int128 v25;
  uint64_t v26;
  C3D::Pass *v27;
  C3D::Pass *v28;
  C3D::Pass *v29;
  _BYTE *IfNeeded;
  C3D::Pass *v31;
  __int16 v32;
  uint64_t result;
  __int16 v34;
  _BOOL4 v35;
  _BYTE v36[20];
  C3D::Pass *v37;
  char v38;

  Scene = C3DEngineContextGetScene(*((_QWORD *)this + 2));
  PointOfView = C3DEngineContextGetPointOfView(*((_QWORD *)this + 2));
  if (!PointOfView)
  {
    if ((C3DEngineContextIsTemporalAntialiasingEnabled(*((_QWORD *)this + 2)) & 1) == 0)
      goto LABEL_9;
LABEL_7:
    v5 = 1;
    goto LABEL_8;
  }
  Camera = C3DNodeGetCamera((uint64_t)PointOfView);
  if ((C3DEngineContextIsTemporalAntialiasingEnabled(*((_QWORD *)this + 2)) & 1) != 0)
    goto LABEL_7;
  if (!Camera)
  {
LABEL_9:
    v5 = 0;
    goto LABEL_10;
  }
  v5 = 0;
  if (C3DCameraGetMotionBlurIntensity((uint64_t)Camera) > 0.0)
LABEL_8:
    *((_WORD *)this + 149) |= 8u;
LABEL_10:
  C3D::Pass::parentColorDesc(*((C3D::Pass **)this + 1), (uint64_t)&v37);
  if (v38 == 2)
  {
    v6 = 1;
  }
  else
  {
    C3D::Pass::parentColorDesc(*((C3D::Pass **)this + 1), (uint64_t)v36);
    v6 = v36[8] == 4;
  }
  v7 = C3DSceneGetWantsSSR(Scene) & v6;
  if (v7 == 1)
    *((_WORD *)this + 149) |= 0x106u;
  if (v6
    && (RenderCallbacks = C3DEngineContextGetRenderCallbacks(*((_QWORD *)this + 2))) != 0
    && (v9 = *(unsigned int (**)(_QWORD))(RenderCallbacks + 40)) != 0
    && v9(*((_QWORD *)this + 2)))
  {
    v10 = *((_QWORD *)this + 3);
    v37 = this;
    v11 = C3D::RenderGraph::createPass<C3D::MainPassCustomPostProcessPass,C3D::MainPass *>(v10, &v37);
    v12 = v11;
    v13 = (C3D::Pass *)*((_QWORD *)this + 680);
    if (v13 != this)
      C3D::Pass::addDependency(v11, v13);
    C3D::Pass::addDependency(v12, this);
    *((_QWORD *)this + 680) = v12;
    if (*((_BYTE *)v12 + 240))
      *((_WORD *)this + 149) |= 0x80u;
  }
  else
  {
    v12 = 0;
  }
  *((_BYTE *)this + 119) = 1;
  *((_BYTE *)this + 306) = C3DEngineContextGetViewpointCoordinateSpace(*((_QWORD *)this + 2));
  C3D::ScenePass::setup(this);
  if (v12)
  {
    v35 = v6;
    v16 = v7;
    v17 = v5;
    v18 = *((_QWORD *)v12 + 31);
    v19 = *((unsigned __int8 *)v12 + 240);
    v20 = C3D::Pass::outputBufferParameterNamed(this, "COLOR");
    if (v19)
    {
      v21 = C3D::Pass::outputBufferParameterNamed(this, "COLOR1");
      v22 = C3D::Pass::inputBufferParameterNamed(v12, "COLOR");
      v23 = C3D::Pass::inputBufferParameterNamed(v12, "COLOR1");
      v24 = v21 != 0;
      if (v21 && v18)
      {
        *(_WORD *)(v21 + 28) = v18;
        v24 = 1;
      }
    }
    else
    {
      v22 = C3D::Pass::inputBufferParameterNamed(v12, "COLOR");
      v24 = 0;
      v23 = 0;
      v21 = 0;
    }
    v5 = v17;
    v7 = v16;
    v6 = v35;
    *(_BYTE *)(v22 + 31) = 0;
    *(_BYTE *)(v22 + 24) = SCNMTLTextureTypeNonMultisampledEquivalent(*(unsigned __int8 *)(v20 + 24));
    if (v23)
    {
      *(_BYTE *)(v23 + 31) = 0;
      *(_BYTE *)(v23 + 24) = SCNMTLTextureTypeNonMultisampledEquivalent(*(unsigned __int8 *)(v21 + 24));
    }
    if (*((_BYTE *)v12 + 272))
    {
      v25 = *((_OWORD *)v12 + 16);
      *(_WORD *)(v20 + 66) |= 0x40u;
      *(_OWORD *)(v20 + 48) = v25;
      if (v24)
      {
        *(_WORD *)(v21 + 66) |= 0x40u;
        *(_OWORD *)(v21 + 48) = v25;
      }
      *((_BYTE *)this + 303) = 0;
    }
  }
  if (v7)
    *((_QWORD *)this + 680) = C3D::SSRPassesCreateIfNeeded(*((C3D **)this + 3), this, v14);
  if (v5)
  {
    *((_WORD *)this + 149) |= 8u;
    v26 = *((_QWORD *)this + 3);
    v37 = this;
    v27 = C3D::RenderGraph::createPass<C3D::TemporalAAPass,C3D::MainPass *>(v26, &v37);
    v28 = v27;
    v29 = (C3D::Pass *)*((_QWORD *)this + 680);
    if (v29 != this)
      C3D::Pass::addDependency(v27, v29);
    C3D::Pass::addDependency(v28, this);
    *((_QWORD *)this + 680) = v28;
  }
  *((_QWORD *)this + 681) = 0;
  if (v6)
  {
    v37 = 0;
    IfNeeded = C3D::PostProcessPassesCreateIfNeeded(*((C3D **)this + 3), this, (C3D::MainPass *)&v37, v15);
    *((_QWORD *)this + 681) = IfNeeded;
    v31 = v37;
    if (!v37)
      v31 = (C3D::Pass *)*((_QWORD *)this + 680);
    *((_QWORD *)this + 680) = v31;
    if (IfNeeded)
    {
      if (IfNeeded[12])
        v32 = 0;
      else
        v32 = 8 * (IfNeeded[10] == 0);
    }
    else
    {
      v32 = 8;
    }
    result = C3D::PassDescriptor::outputAtIndex((C3D::MainPass *)((char *)this + 32), 1u);
    v34 = *(_WORD *)(result + 66) & 0xFFF7 | v32;
  }
  else
  {
    result = C3D::PassDescriptor::outputAtIndex((C3D::MainPass *)((char *)this + 32), 1u);
    v34 = *(_WORD *)(result + 66) | 8;
  }
  *(_WORD *)(result + 66) = v34;
  return result;
}

uint64_t C3DEngineContextIsTemporalAntialiasingEnabled(uint64_t a1)
{
  return *(_BYTE *)(a1 + 1864) & 1;
}

uint64_t C3DSceneGetWantsSSR(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 368);
}

void C3D::ScenePass::setup(C3D::ScenePass *this)
{
  uint64_t RenderContext;
  float32x4_t *PointOfView;
  const __CFDictionary *Camera;
  _OWORD *v5;
  __int128 v6;
  __int128 v7;
  BOOL v8;
  int WantsHDR;
  unsigned __int16 v10;
  C3D::PassDescriptor *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  unsigned int v27;
  char v28;
  uint64_t StackAllocator;
  char v30;
  char PreferredMultiVertexOutputStreamGenerator;
  int PreferredRenderMode;
  uint64_t Scene;
  const __CFDictionary *LightingSystem;
  float v35;
  float v36;
  uint64_t v37;
  C3D::DrawNodesPass *v38;
  uint64_t v39;
  const C3D::Pass **v40;
  uint64_t v41;
  const C3D::Pass *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  C3D::FloorPass **v46;
  uint64_t v47;
  C3D::FloorPass *v48;
  uint64_t v49;
  uint64_t Floor;
  C3D::PassDescriptor *v51;
  uint64_t v52;
  C3D::PassDescriptor *v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  uint64_t *v60;
  uint64_t *v61;
  uint64_t v62;
  C3D::Pass **v63;
  C3D *v64;
  C3D **v65;
  uint64_t v66;
  C3D *v67;
  C3D::Pass **v68;
  NSObject *v69;
  C3D::PassDescriptor *v70;
  uint64_t v71;
  C3D::PassDescriptor *v72;
  uint64_t v73;
  uint64_t EnginePipeline;
  uint64_t RendererElementStore;
  unint64_t RendererElementSpan;
  __C3DEngineContext *v77;
  uint64_t ElementInSpanAtIndex;
  uint64_t v79;
  const void *CIFilterQuadBlendTechnique;
  const void *v81;
  CFTypeRef v82;
  C3D::PassDescriptor *v83;
  uint64_t v84;
  C3D::PassDescriptor *v85;
  uint64_t v86;
  int v87;
  unsigned int i;
  _OWORD *v89;
  _OWORD *v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  C3D::ScenePass *v94;
  C3D *v95;
  _QWORD v96[8];
  _BYTE v97[8];
  unsigned int v98;
  const C3D::Pass **v99;
  uint64_t v100;
  uint64_t *v101;
  uint64_t v102;
  uint64_t v103;
  _QWORD v104[4];
  _QWORD v105[3];
  uint64_t v106;
  uint64_t *v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t v110;
  unsigned int v111;
  _QWORD v112[3];
  _QWORD v113[3];
  uint8_t buf[16];
  int v115;
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  RenderContext = C3DEngineContextGetRenderContext(*((_QWORD *)this + 2));
  PointOfView = C3DEngineContextGetPointOfView(*((_QWORD *)this + 2));
  if (PointOfView)
    Camera = C3DNodeGetCamera((uint64_t)PointOfView);
  else
    Camera = 0;
  v5 = (_OWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 88))(*((_QWORD *)this + 1));
  v7 = v5[1];
  v6 = v5[2];
  *((_OWORD *)this + 337) = *v5;
  *((_OWORD *)this + 338) = v7;
  *((_OWORD *)this + 339) = v6;
  *((_BYTE *)this + 296) = 1;
  *((_BYTE *)this + 303) = 1;
  if (Camera)
  {
    if (C3DCameraGetScreenSpaceAmbientOcclusionIntensity((uint64_t)Camera) > 0.0)
      *((_WORD *)this + 149) |= 0x10u;
    v8 = C3DCameraGetARGrainTexture((uint64_t)Camera) != 0;
    WantsHDR = C3DCameraGetWantsHDR((uint64_t)Camera);
  }
  else
  {
    v8 = 0;
    WantsHDR = 0;
  }
  v10 = vaddv_s16((int16x4_t)vand_s8((int8x8_t)vshl_u16((uint16x4_t)vdup_n_s16(*((unsigned __int16 *)this + 149)), (uint16x4_t)0xFFF9FFF8FFFDFFFELL), (int8x8_t)0x1000100010001))+ ((*((_WORD *)this + 149) >> 1) & 1)+ 2;
  C3D::Pass::setOutputCount(this, v10);
  v11 = (C3D::ScenePass *)((char *)this + 32);
  v12 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0);
  *(_QWORD *)(v12 + 8) = "COLOR";
  C3D::Pass::parentColorDesc(this, (uint64_t)buf);
  *(_OWORD *)(v12 + 16) = *(_OWORD *)buf;
  *(_DWORD *)(v12 + 32) = v115;
  *(_BYTE *)(v12 + 65) = 0;
  *(_WORD *)(v12 + 66) = *(_WORD *)(v12 + 66) & 0xFFFC | 2;
  if (WantsHDR)
  {
    *((_QWORD *)this + 677) = 115;
    *(_WORD *)(v12 + 28) = 115;
  }
  if (v8 || -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext))
  {
    if (-[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext))
    {
      *(_WORD *)(v12 + 66) |= 0x40u;
      *(_QWORD *)(v12 + 48) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      *((_BYTE *)this + 303) = 0;
    }
    v13 = -[SCNMTLRenderContext sampleCount](RenderContext);
    v14 = *(unsigned __int16 *)(v12 + 28);
    if (v14 == 554)
    {
      v15 = v13 <= 1;
      v14 = 550;
      v16 = 115;
    }
    else
    {
      if (v14 != 555)
      {
LABEL_22:
        *((_QWORD *)this + 677) = v14;
        goto LABEL_23;
      }
      v15 = v13 <= 1;
      v14 = 551;
      v16 = 553;
    }
    if (!v15)
      v14 = v16;
    *(_WORD *)(v12 + 28) = v14;
    goto LABEL_22;
  }
LABEL_23:
  v17 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 1u);
  *(_BYTE *)(v17 + 64) = 2;
  *(_QWORD *)(v17 + 8) = "DEPTH";
  C3D::Pass::parentDepthDesc(this, (uint64_t)buf);
  *(_OWORD *)(v17 + 16) = *(_OWORD *)buf;
  *(_DWORD *)(v17 + 32) = v115;
  *(_WORD *)(v17 + 66) = *(_WORD *)(v17 + 66) & 0xFFF4 | 0xA;
  v18 = *((_WORD *)this + 149);
  if ((v18 & 2) != 0)
  {
    v20 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 2u);
    *(_QWORD *)(v20 + 8) = "Normals";
    *(_WORD *)(v20 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 16);
    *(_WORD *)(v20 + 18) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 18);
    *(_WORD *)(v20 + 28) = 115;
    *(_BYTE *)(v20 + 65) = 2;
    *(_WORD *)(v20 + 66) = *(_WORD *)(v20 + 66) & 0xFFFC | 2;
    v18 = *((_WORD *)this + 149);
    v19 = 3;
    if ((v18 & 8) == 0)
    {
LABEL_25:
      if ((v18 & 4) == 0)
        goto LABEL_26;
      goto LABEL_31;
    }
  }
  else
  {
    v19 = 2;
    if ((v18 & 8) == 0)
      goto LABEL_25;
  }
  v21 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), v19);
  *(_QWORD *)(v21 + 8) = "VELOCITY";
  *(_BYTE *)(v21 + 65) = 3;
  *(_WORD *)(v21 + 28) = 115;
  *(_WORD *)(v21 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 16);
  ++v19;
  *(_WORD *)(v21 + 18) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 18);
  *(_WORD *)(v21 + 66) = *(_WORD *)(v21 + 66) & 0xFFBC | 0x42;
  *(_OWORD *)(v21 + 48) = xmmword_1DD02AE20;
  v18 = *((_WORD *)this + 149);
  if ((v18 & 4) == 0)
  {
LABEL_26:
    if ((v18 & 0x100) == 0)
      goto LABEL_27;
    goto LABEL_32;
  }
LABEL_31:
  v22 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), v19);
  *(_QWORD *)(v22 + 8) = "ReflectanceRoughness";
  *(_WORD *)(v22 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 16);
  ++v19;
  *(_WORD *)(v22 + 18) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 18);
  *(_WORD *)(v22 + 28) = 115;
  *(_BYTE *)(v22 + 65) = 4;
  *(_WORD *)(v22 + 66) = *(_WORD *)(v22 + 66) & 0xFFFC | 2;
  v18 = *((_WORD *)this + 149);
  if ((v18 & 0x100) == 0)
  {
LABEL_27:
    if ((v18 & 0x80) == 0)
      goto LABEL_34;
    goto LABEL_33;
  }
LABEL_32:
  v23 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), v19);
  *(_QWORD *)(v23 + 8) = "Radiance";
  *(_WORD *)(v23 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 16);
  ++v19;
  *(_WORD *)(v23 + 18) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 18);
  *(_WORD *)(v23 + 28) = 115;
  *(_BYTE *)(v23 + 65) = 5;
  *(_WORD *)(v23 + 66) = *(_WORD *)(v23 + 66) & 0xFFFC | 2;
  if ((*((_WORD *)this + 149) & 0x80) != 0)
  {
LABEL_33:
    v24 = C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), v19);
    *(_QWORD *)(v24 + 8) = "COLOR1";
    *(_WORD *)(v24 + 16) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 16);
    *(_WORD *)(v24 + 18) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 18);
    *(_WORD *)(v24 + 28) = *(_WORD *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 28);
    *(_BYTE *)(v24 + 65) = 1;
    *(_WORD *)(v24 + 66) = *(_WORD *)(v24 + 66) & 0xFFFC | 2;
  }
LABEL_34:
  if (-[SCNMTLRenderContext sampleCount](RenderContext) >= 2)
  {
    v25 = *(unsigned __int8 *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), 0) + 24);
    if (!SCNMTLTextureTypeIsMultisampled(v25))
    {
      v26 = SCNMTLTextureTypeMultisampledEquivalent(v25);
      LOWORD(v27) = 0;
      do
      {
        *(_BYTE *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), (unsigned __int16)v27) + 24) = v26;
        v28 = -[SCNMTLRenderContext sampleCount](RenderContext);
        *(_BYTE *)(C3D::PassDescriptor::outputAtIndex((C3D::ScenePass *)((char *)this + 32), (unsigned __int16)v27) + 31) = v28;
        v27 = (v27 + 1);
      }
      while (v27 < v10);
    }
  }
  StackAllocator = C3DEngineContextGetStackAllocator(*((_QWORD *)this + 2));
  C3DStackAllocatorPushFrame(StackAllocator);
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v113, StackAllocator);
  *((_QWORD *)this + 671) = v113;
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v112, StackAllocator);
  *((_QWORD *)this + 672) = v112;
  C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::Array(&v110, StackAllocator);
  v106 = 0;
  v107 = &v106;
  v108 = 0x2020000000;
  v109 = &v110;
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v105, StackAllocator);
  v104[0] = 0;
  v104[1] = v104;
  v104[2] = 0x2020000000;
  v104[3] = v105;
  if (*(_BYTE *)(v12 + 24) == 5)
  {
    v30 = -[SCNMTLRenderContext features](RenderContext);
    *((_BYTE *)this + 117) = (v30 & 0x20) != 0;
    if ((v30 & 0x20) != 0)
      PreferredMultiVertexOutputStreamGenerator = C3DEngineContextGetPreferredMultiVertexOutputStreamGenerator(*((_QWORD *)this + 2));
    else
      PreferredMultiVertexOutputStreamGenerator = 0;
    *((_BYTE *)this + 118) = PreferredMultiVertexOutputStreamGenerator;
    *((_WORD *)this + 19) = 6;
  }
  else if (C3DEngineContextGetEyeCount(*((_QWORD *)this + 2)) > 1
         || -[SCNMTLRenderContext clientRenderPassDescriptor](RenderContext))
  {
    *((_WORD *)this + 19) = C3DEngineContextGetEyeCount(*((_QWORD *)this + 2));
    PreferredRenderMode = C3DEngineContextGetPreferredRenderMode(*((_QWORD *)this + 2));
    *((_BYTE *)this + 117) = PreferredRenderMode;
    if (PreferredRenderMode)
      LOBYTE(PreferredRenderMode) = C3DEngineContextGetPreferredMultiVertexOutputStreamGenerator(*((_QWORD *)this + 2));
    *((_BYTE *)this + 118) = PreferredRenderMode;
    *((_BYTE *)this + 120) = 1;
  }
  C3D::DrawNodesPass::setup(this);
  Scene = C3DEngineContextGetScene(*((_QWORD *)this + 2));
  LightingSystem = (const __CFDictionary *)C3DSceneGetLightingSystem(Scene);
  v35 = *((double *)this + 633);
  v36 = *((double *)this + 634);
  C3DLightingSystemSetMainRenderingFrustums((uint64_t)LightingSystem, (_OWORD *)this + 21, v35, v36, *((unsigned __int8 *)this + 4948), (__int128 *)this + 57, (__int128 *)this + 189);
  v100 = 0;
  v101 = &v100;
  v102 = 0x2020000000;
  v103 = 0;
  C3D::RenderGraph::getSuccessors(*((_QWORD *)this + 3), (uint64_t)this, StackAllocator, (uint64_t)v97);
  v37 = *((_QWORD *)this + 2);
  v96[0] = MEMORY[0x1E0C809B0];
  v96[1] = 3221225472;
  v96[2] = ___ZN3C3D9ScenePass5setupEv_block_invoke;
  v96[3] = &unk_1EA5A32C8;
  v96[4] = &v100;
  v96[5] = &v106;
  v96[6] = v104;
  v96[7] = this;
  C3DLightingSystemEnumerateGlobalLights(LightingSystem, v37, (uint64_t)v96);
  *((_QWORD *)this + 673) = CreateProbeArrayResourceIfNeeded(this, v107[3]);
  v39 = v101[3];
  if (v39)
  {
    *((_QWORD *)this + 680) = v39;
    if (v98)
    {
      v40 = v99;
      v41 = 8 * v98;
      do
      {
        v42 = *v40;
        C3D::RenderGraph::removeDependency(*((C3D::RenderGraph **)this + 3), *v40, this);
        C3D::RenderGraph::addDependency(*((C3D::RenderGraph **)this + 3), v42, (const C3D::Pass *)v101[3]);
        ++v40;
        v41 -= 8;
      }
      while (v41);
    }
  }
  if (C3D::SSAOPassesCreateIfNeeded(*((C3D **)this + 3), this, v38))
  {
    v43 = (*(uint64_t (**)(C3D::ScenePass *))(*(_QWORD *)this + 88))(this);
    C3D::PassIODescriptor::PassIODescriptor((uint64_t)buf, *(_QWORD *)(v43 + 32));
    *(_QWORD *)&buf[8] = "SSAO-Final";
    C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, (uint64_t)buf);
  }
  v44 = *((_QWORD *)this + 671);
  v45 = *(unsigned int *)(v44 + 8);
  if ((_DWORD)v45)
  {
    v46 = *(C3D::FloorPass ***)(v44 + 16);
    v47 = 8 * v45;
    do
    {
      v48 = *v46;
      v49 = C3D::FloorPass::mirrorNode(*v46);
      Floor = C3DNodeGetFloor(v49);
      if (C3DFloorGetReflectivity(Floor) > 0.0)
      {
        C3D::Pass::addDependency(this, *((C3D::Pass **)v48 + 680));
        v51 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*((C3D::Pass **)v48 + 680));
        v52 = C3D::PassDescriptor::outputAtIndex(v51, 0);
        C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v52);
        *(_BYTE *)(C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::back((uint64_t)&v110) + 24) = 2;
        *(_BYTE *)(C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::back((uint64_t)&v110) + 31) = 0;
        if (C3DFloorGetReflectionFalloffEnd(Floor) != 0.0)
        {
          v53 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v48);
          v54 = C3D::PassDescriptor::outputAtIndex(v53, 1u);
          C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v54);
          *(_BYTE *)(C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::back((uint64_t)&v110) + 24) = 2;
          *(_BYTE *)(C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::back((uint64_t)&v110) + 31) = 0;
        }
      }
      ++v46;
      v47 -= 8;
    }
    while (v47);
  }
  v55 = *((_QWORD *)this + 672);
  v56 = *(_DWORD *)(v55 + 8);
  if (v56 >= 2)
  {
    v57 = 0;
    v58 = v56 >> 1;
    v59 = v56 - 1;
    do
    {
      v60 = (uint64_t *)C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::operator[](*((_QWORD *)this + 672), v57);
      v61 = (uint64_t *)C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::operator[](*((_QWORD *)this + 672), v59);
      v62 = *v60;
      *v60 = *v61;
      *v61 = v62;
      ++v57;
      --v59;
    }
    while (v58 != v57);
    v55 = *((_QWORD *)this + 672);
    v56 = *(_DWORD *)(v55 + 8);
  }
  if (v56)
  {
    v63 = 0;
    v64 = 0;
    v65 = *(C3D ***)(v55 + 16);
    v66 = 8 * v56;
    do
    {
      v67 = *v65;
      v94 = this;
      v95 = v67;
      v68 = (C3D::Pass **)C3D::RenderGraph::createPass<C3D::CIFilterPass,C3D::ScenePass *,__C3DNode *&>(*((_QWORD *)this + 3), &v94, (__C3DNode **)&v95);
      if (v64)
      {
        if (C3DNodeIsAncestor((uint64_t)v64, (uint64_t)v95))
        {
          if (!v63)
          {
            v69 = scn_default_log();
            if (os_log_type_enabled(v69, OS_LOG_TYPE_FAULT))
              C3D::ScenePass::setup(buf, &buf[4], v69);
          }
          C3D::Pass::addDependency(v68[16], (C3D::Pass *)v63);
          C3D::Pass::addDependency(v68[16], v63[16]);
        }
        else
        {
          C3D::Pass::addDependency(this, (C3D::Pass *)v63);
          C3D::Pass::addDependency(this, v63[16]);
          v70 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v63);
          v71 = C3D::PassDescriptor::outputAtIndex(v70, 0);
          C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v71);
          v72 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v63[16]);
          v73 = C3D::PassDescriptor::outputAtIndex(v72, 1u);
          C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v73);
        }
      }
      EnginePipeline = C3DSceneGetEnginePipeline(Scene);
      RendererElementStore = C3DEnginePipelineGetRendererElementStore(EnginePipeline);
      RendererElementSpan = C3DNodeGetRendererElementSpan((uint64_t)v95);
      ElementInSpanAtIndex = C3DRendererElementStoreGetElementInSpanAtIndex(RendererElementStore, RendererElementSpan, (HIDWORD(RendererElementSpan) - 1));
      v79 = *(_QWORD *)(ElementInSpanAtIndex + 40);
      if (!v79 || C3DFXTechniqueGetPassCount(v79) != 1)
      {
        CIFilterQuadBlendTechnique = (const void *)C3D::CreateCIFilterQuadBlendTechnique(v95, *((__C3DNode **)this + 2), v77);
        v81 = *(const void **)(ElementInSpanAtIndex + 40);
        if (v81 != CIFilterQuadBlendTechnique)
        {
          if (v81)
          {
            CFRelease(v81);
            *(_QWORD *)(ElementInSpanAtIndex + 40) = 0;
          }
          if (CIFilterQuadBlendTechnique)
            v82 = CFRetain(CIFilterQuadBlendTechnique);
          else
            v82 = 0;
          *(_QWORD *)(ElementInSpanAtIndex + 40) = v82;
        }
        CFRelease(CIFilterQuadBlendTechnique);
      }
      v64 = v95;
      ++v65;
      v63 = v68;
      v66 -= 8;
    }
    while (v66);
    if (v95)
    {
      C3D::Pass::addDependency(this, (C3D::Pass *)v68);
      C3D::Pass::addDependency(this, v68[16]);
      v83 = (C3D::PassDescriptor *)C3D::Pass::descriptor((C3D::Pass *)v68);
      v84 = C3D::PassDescriptor::outputAtIndex(v83, 0);
      C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v84);
      v85 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v68[16]);
      v86 = C3D::PassDescriptor::outputAtIndex(v85, 1u);
      C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::push_back<C3D::PassIODescriptor&>((uint64_t)&v110, v86);
    }
  }
  v87 = (unsigned __int16)v111;
  C3D::Pass::setInputCount(this, (unsigned __int16)v111);
  if (v87)
  {
    for (i = 0; i != v87; ++i)
    {
      v89 = (_OWORD *)C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::operator[]((uint64_t)&v110, i);
      v90 = (_OWORD *)C3D::PassDescriptor::inputAtIndex(v11, (unsigned __int16)i);
      *v90 = *v89;
      v91 = v89[1];
      v92 = v89[2];
      v93 = v89[4];
      v90[3] = v89[3];
      v90[4] = v93;
      v90[1] = v91;
      v90[2] = v92;
    }
  }
  C3DStackAllocatorPopFrame(StackAllocator);
  _Block_object_dispose(&v100, 8);
  _Block_object_dispose(v104, 8);
  _Block_object_dispose(&v106, 8);
}

void sub_1DCD1F750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

float C3D::Pass::parentColorDesc@<S0>(C3D::Pass *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  float result;
  uint64_t v5;

  v3 = (*(uint64_t (**)(C3D::Pass *))(*(_QWORD *)this + 88))(this);
  LODWORD(result) = HIDWORD(*(_OWORD *)v3);
  *(_WORD *)a2 = (int)COERCE_FLOAT(*(_QWORD *)(v3 + 8));
  *(_WORD *)(a2 + 2) = (int)result;
  *(_DWORD *)(a2 + 4) = 0;
  v5 = *(_QWORD *)(v3 + 24);
  *(_BYTE *)(a2 + 8) = *(_QWORD *)(v3 + 32);
  *(_WORD *)(a2 + 9) = 2;
  *(_BYTE *)(a2 + 11) = 0;
  *(_DWORD *)(a2 + 12) = (unsigned __int16)v5;
  *(_DWORD *)(a2 + 16) = 0;
  return result;
}

uint64_t C3D::FinalPass::drawableInfo(C3D::FinalPass *this)
{
  return (uint64_t)this + 128;
}

uint64_t C3D::ScenePass::drawableInfo(C3D::ScenePass *this)
{
  return (uint64_t)this + 5392;
}

float C3D::Pass::parentDepthDesc@<S0>(C3D::Pass *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  __int128 v4;
  float result;

  v3 = (*(uint64_t (**)(C3D::Pass *))(*(_QWORD *)this + 88))(this);
  v4 = *(_OWORD *)v3;
  *(_WORD *)a2 = (int)COERCE_FLOAT(*(_QWORD *)(v3 + 8));
  result = *((float *)&v4 + 3);
  *(_WORD *)(a2 + 2) = (int)*((float *)&v4 + 3);
  *(_DWORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 8) = *(_QWORD *)(v3 + 32);
  *(_WORD *)(a2 + 9) = 2;
  *(_BYTE *)(a2 + 11) = 0;
  *(_QWORD *)(a2 + 12) = 252;
  return result;
}

_QWORD *C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(_QWORD *a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *a1 = a2;
  a1[1] = 0;
  a1[2] = a1 + 3;
  if (!a2)
  {
    v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v3, v4, v5, v6, v7, v8, v9, v10);
  }
  return a1;
}

_QWORD *C3D::Array<C3D::PassIODescriptor,0u,C3D::StackAllocator>::Array(_QWORD *a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *a1 = a2;
  a1[1] = 0;
  a1[2] = a1 + 4;
  if (!a2)
  {
    v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(v3, v4, v5, v6, v7, v8, v9, v10);
  }
  return a1;
}

void C3D::Pass::setOutputCount(C3D::Pass *this, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  void *Aligned;

  *((_WORD *)this + 37) = a2;
  *((_WORD *)this + 49) = a2;
  if (a2)
  {
    v4 = *(_QWORD *)(*((_QWORD *)this + 3) + 16);
    v5 = a2;
    v6 = (*(uint64_t (**)(C3D::Pass *))(*(_QWORD *)this + 88))(this);
    *((_QWORD *)this + 8) = C3D::ScratchAllocateArray<C3D::PassIODescriptor,MTLTextureType const&>(v4, v5, (uint64_t *)(v6 + 32));
    v7 = 8 * a2;
    Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)(*((_QWORD *)this + 3) + 16), v7, 8, 0);
    bzero(Aligned, v7);
    *((_QWORD *)this + 11) = Aligned;
    bzero(Aligned, 8 * *((unsigned __int16 *)this + 49));
  }
}

uint64_t C3D::SSAOPassesCreateIfNeeded(C3D *this, C3D::RenderGraph *a2, C3D::DrawNodesPass *a3)
{
  uint64_t Aligned;
  uint64_t v6;
  float32x4_t *PointOfView;
  const __CFDictionary *Camera;
  uint64_t v9;
  C3D::Pass *v10;
  C3D::Pass *v11;
  C3D::Pass *v12;
  C3D::Pass *v13;
  C3D::Pass *v14;
  uint64_t v15;
  C3D::Pass *v16;
  C3D::Pass *v17;
  char v19;
  uint64_t v20;
  C3D::Pass *v21;

  v21 = a2;
  Aligned = C3DScratchAllocatorAllocateAligned(*((_QWORD *)this + 2), 32, 8, 0);
  *(_OWORD *)Aligned = 0u;
  *(_OWORD *)(Aligned + 16) = 0u;
  v20 = Aligned;
  v6 = *((_QWORD *)this + 1);
  PointOfView = C3DEngineContextGetPointOfView(v6);
  if (!PointOfView)
    return 0;
  Camera = C3DNodeGetCamera((uint64_t)PointOfView);
  if (!Camera)
    return 0;
  v9 = (uint64_t)Camera;
  if (C3DCameraGetScreenSpaceAmbientOcclusionIntensity((uint64_t)Camera) <= 0.0)
    return 0;
  *(_QWORD *)(Aligned + 8) = (int)C3DCameraGetScreenSpaceAmbientOcclusionSampleCount(v9);
  *(_QWORD *)(Aligned + 16) = (int)C3DCameraGetScreenSpaceAmbientOcclusionDownSample(v9);
  *(_BYTE *)(Aligned + 24) = C3DCameraGetUsesOrthographicProjection(v9);
  *(_QWORD *)Aligned = a2;
  *(_BYTE *)(Aligned + 25) = C3DEngineContextGetPreferredRenderMode(v6) != 0;
  v10 = C3D::RenderGraph::createPass<C3D::SSAODepthNormalPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>((uint64_t)this, &v21, &v20);
  v11 = C3D::RenderGraph::createPass<C3D::GenerateMipmapPass,C3D::DrawNodesPass *&>((uint64_t)this, &v21);
  v12 = C3D::RenderGraph::createPass<C3D::SSAOMinMaxOffsetPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>((uint64_t)this, &v21, &v20);
  v13 = C3D::RenderGraph::createPass<C3D::SSAORaytracePass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>((uint64_t)this, &v21, &v20);
  v19 = 0;
  v14 = C3D::RenderGraph::createPass<C3D::SSAOBlurPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&,BOOL>((uint64_t)this, &v21, &v20, &v19);
  v15 = 1;
  v19 = 1;
  v16 = C3D::RenderGraph::createPass<C3D::SSAOBlurPass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&,BOOL>((uint64_t)this, &v21, &v20, &v19);
  v17 = C3D::RenderGraph::createPass<C3D::SSAOUpSamplePass,C3D::DrawNodesPass *&,C3D::SSAOPassData *&>((uint64_t)this, &v21, &v20);
  C3D::Pass::addDependency(v11, v10);
  C3D::Pass::addDependency(v12, v10);
  C3D::Pass::addDependency(v13, v11);
  C3D::Pass::addDependency(v13, v12);
  C3D::Pass::addDependency(v14, v13);
  C3D::Pass::addDependency(v16, v14);
  C3D::Pass::addDependency(v17, v16);
  C3D::Pass::addDependency(v17, v10);
  C3D::Pass::addDependency(v21, v17);
  return v15;
}

__n128 C3D::DrawNodesPass::_setupCullingContext(__n128 *this)
{
  unsigned __int8 *v2;
  uint64_t RenderContext;
  uint64_t Scene;
  uint64_t EnginePipeline;
  uint64_t v6;
  BOOL v7;
  uint64_t RendererElementStore;
  unsigned int ElementCount;
  unsigned __int32 v10;
  unint64_t v11;
  size_t v12;
  unsigned __int32 *v13;
  void *Aligned;
  unint64_t v15;
  BOOL v16;
  BOOL v17;
  unint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __n128 ViewportAtIndex;
  uint64_t v29;
  float32x4_t *PointOfViewForCulling;
  uint64_t v31;
  const __CFDictionary *Light;
  __n128 result;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  __n128 *v37;
  __n128 v38;
  __n128 v39;
  float32x4_t *PointOfView;
  uint32x2_t v41;
  float32x2_t v42;

  v2 = &this[309].n128_u8[4];
  RenderContext = C3DEngineContextGetRenderContext(this[1].n128_i64[0]);
  Scene = C3DEngineContextGetScene(this[1].n128_i64[0]);
  EnginePipeline = C3DSceneGetEnginePipeline(Scene);
  if (!this[18].n128_u8[12] && -[SCNMTLRenderContext textureTarget](RenderContext))
    this[18].n128_u8[14] = (unint64_t)(objc_msgSend((id)-[SCNMTLRenderContext textureTarget](RenderContext), "textureType")- 5) < 2;
  v2[66] = 0;
  v6 = this[1].n128_i64[0];
  this[316].n128_u64[0] = v6;
  v7 = (C3DEngineContextIsWarmUp(v6) & 1) != 0 || this[17].n128_u64[0] || this[19].n128_u8[0] != 0;
  v2[64] = v7;
  this[20].n128_u64[0] = EnginePipeline;
  this[315].n128_u64[1] = Scene;
  *v2 = this[2].n128_u8[6];
  v2[3] = this[7].n128_u8[5];
  RendererElementStore = C3DEnginePipelineGetRendererElementStore(EnginePipeline);
  ElementCount = C3DRendererElementStoreGetElementCount(RendererElementStore);
  if (this[2].n128_u16[3])
  {
    v10 = ElementCount;
    v11 = 0;
    v12 = 4 * ElementCount;
    v13 = &this[327].n128_u32[3];
    do
    {
      Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)(this[1].n128_u64[1] + 16), v12, 2, 0);
      bzero(Aligned, v12);
      *(_QWORD *)(v13 - 3) = Aligned;
      *(v13 - 1) = 0;
      *v13 = v10;
      ++v11;
      v15 = this[2].n128_u16[3];
      v13 += 4;
    }
    while (v11 < v15);
    v16 = (_DWORD)v15 == 2;
  }
  else
  {
    v16 = 0;
  }
  v17 = 0;
  v2[4] = this[18].n128_u8[14];
  this[311].n128_u64[0] = this[15].n128_u64[0];
  this[311].n128_u64[1] = (unint64_t)this;
  this[333].n128_u64[1] = (unint64_t)C3D::drawNodesPassShouldPushRenderableElementsToVisible;
  v2[65] = this[18].n128_u8[8];
  v2[380] = 0;
  v2[2] = this[2].n128_u32[3];
  if (v16)
    v17 = this[7].n128_u8[5] == 2;
  v2[68] = v17;
  v2[69] = this[19].n128_u8[2];
  v18 = this[16].n128_u64[1];
  this[312].n128_u64[0] = v18;
  if (!v18)
  {
    if (!Scene)
    {
      v19 = scn_default_log();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        C3DSceneCreateHitTestResultsWithSegment_cold_2(v19, v20, v21, v22, v23, v24, v25, v26);
    }
    this[312].n128_u64[0] = C3DSceneGetRootNode(Scene);
  }
  v2[60] = this[18].n128_u8[13];
  v27 = C3D::PassDescriptor::outputAtIndex((C3D::PassDescriptor *)&this[2], 0);
  if (this[7].n128_u8[9])
  {
    ViewportAtIndex = this[8];
  }
  else if (this[7].n128_u8[8] || this[19].n128_u8[1])
  {
    ViewportAtIndex = C3DEngineContextGetViewportAtIndex(this[1].n128_i64[0], 0);
  }
  else
  {
    v41.i32[0] = *(unsigned __int16 *)(v27 + 16);
    v41.i32[1] = *(unsigned __int16 *)(v27 + 18);
    v42 = vcvt_f32_u32(v41);
    ViewportAtIndex.n128_u64[0] = 0;
    *(float32x2_t *)&ViewportAtIndex.n128_i8[8] = v42;
  }
  this[310] = ViewportAtIndex;
  v29 = this[15].n128_i64[1];
  PointOfViewForCulling = (float32x4_t *)v29;
  if (v29
    || (PointOfViewForCulling = C3DEngineContextGetPointOfViewForCulling(this[1].n128_i64[0]),
        (v29 = this[15].n128_i64[1]) != 0))
  {
    v2[61] = this[18].n128_u8[12];
  }
  else
  {
    PointOfView = C3DEngineContextGetPointOfView(this[1].n128_i64[0]);
    this[15].n128_u64[1] = (unint64_t)PointOfView;
    v2[61] = this[18].n128_u8[12];
    if (!PointOfView)
    {
      C3DCullingContextSetupMatricesToIdentity((uint64_t)&this[20]);
      goto LABEL_28;
    }
    v29 = (uint64_t)PointOfView;
  }
  C3D::DrawNodesPass::_setupPointOfView(this, v29, (uint64_t)PointOfViewForCulling, (uint64_t)&this[310]);
LABEL_28:
  this[315].n128_u64[0] = (unint64_t)C3DEngineContextGetAuthoringEnvironment(this[1].n128_i64[0], 0);
  this[314].n128_u64[0] = this[17].n128_u64[1];
  this[314].n128_u64[0] &= C3DGetPovCategoryMask((uint64_t)PointOfViewForCulling);
  this[314].n128_u64[1] = this[18].n128_u64[0];
  *((_WORD *)v2 + 31) = 0;
  v31 = this[15].n128_i64[1];
  if (v31)
  {
    Light = C3DNodeGetLight(v31);
    if (Light)
    {
      if (C3DLightGetType((uint64_t)Light) == 4)
        *((_WORD *)v2 + 31) = 256;
    }
  }
  result.n128_f64[0] = C3DCullingContextSetupLOD((uint64_t)&this[20], (__n128 *)this[1].n128_u64[0]);
  if (*v2)
  {
    v34 = 0;
    v35 = 0;
    do
    {
      v36 = this[334].n128_u64[0] + v34 * 16;
      v37 = &this[v34 + 285];
      result = *(__n128 *)(v36 + 16);
      v38 = *(__n128 *)(v36 + 32);
      v39 = *(__n128 *)(v36 + 64);
      v37[2] = *(__n128 *)(v36 + 48);
      v37[3] = v39;
      *v37 = result;
      v37[1] = v38;
      ++v35;
      v34 += 4;
    }
    while (v35 < *v2);
  }
  return result;
}

uint64_t C3DSceneGetRootNode(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DSceneCreateHitTestResultsWithSegment_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 64);
}

float32x4_t *C3DEngineContextGetPointOfViewForCulling(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t *result;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  result = *(float32x4_t **)(a1 + 32);
  if (!result)
    return C3DEngineContextGetPointOfView(a1);
  return result;
}

float32x4_t *C3DEngineContextGetPointOfView(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t *DefaultPointOfView;
  uint64_t Scene;
  __n128 *v12;
  uint64_t RootNode;
  const __CFArray *v14;
  const __CFArray *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const __CFDictionary *RenderingOptionForKey;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  DefaultPointOfView = *(float32x4_t **)(a1 + 24);
  if (!DefaultPointOfView)
  {
    DefaultPointOfView = (float32x4_t *)C3DEngineContextGetDefaultPointOfView(a1);
    if (!DefaultPointOfView)
    {
      Scene = C3DEngineContextGetScene(a1);
      if (Scene && (v12 = (__n128 *)Scene, (RootNode = C3DSceneGetRootNode(Scene)) != 0))
      {
        v14 = C3DNodeCopyNodesWithAttribute(RootNode, CFSTR("kCameraKey"), 1);
        v15 = v14;
        if (v14 && CFArrayGetCount(v14) >= 1)
        {
          DefaultPointOfView = (float32x4_t *)CFArrayGetValueAtIndex(v15, 0);
          C3DEngineContextSetPointOfView(a1, DefaultPointOfView);
          if (!*(_QWORD *)(a1 + 24))
          {
            v16 = scn_default_log();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
              C3DEngineContextGetPointOfView_cold_1(v16, v17, v18, v19, v20, v21, v22, v23);
          }
LABEL_21:
          CFRelease(v15);
          return DefaultPointOfView;
        }
        RenderingOptionForKey = C3DEngineContextGetRenderingOptionForKey(a1, CFSTR("defaultCamera"));
        if (RenderingOptionForKey && !CFEqual(RenderingOptionForKey, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
        {
          DefaultPointOfView = 0;
        }
        else
        {
          DefaultPointOfView = (float32x4_t *)C3DEngineContextGetDefaultPointOfView(a1);
          if (!DefaultPointOfView)
          {
            DefaultPointOfView = C3DCreateDefaultCameraNode(v12, 0);
            if (DefaultPointOfView)
            {
              C3DEngineContextSetDefaultPointOfView(a1, DefaultPointOfView);
              CFRelease(DefaultPointOfView);
            }
          }
        }
        if (v15)
          goto LABEL_21;
      }
      else
      {
        return 0;
      }
    }
  }
  return DefaultPointOfView;
}

uint64_t C3DCameraGetCategoryBitMask(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 528);
}

void C3D::FinalPass::setup(C3D::FinalPass *this)
{
  C3D::PassDescriptor *v2;
  uint64_t v3;
  uint64_t RenderContext;
  void *v5;
  double v6;
  double v7;
  float v8;
  float SuperSamplingFactor;
  int8x16_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t StackAllocator;
  C3D::Pass *v14;
  uint64_t v15;
  uint64_t v16;
  C3D::Pass *v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  C3D::Pass *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  C3D::Pass **v45;
  C3D::Pass **v46;
  C3D::Pass *v47;
  C3D::PassDescriptor *v48;
  unsigned __int8 v49;
  uint64_t v50;
  C3D::Pass *v51;
  C3D::PassDescriptor *v52;
  C3D::Pass **v53;
  C3D::Pass **v54;
  C3D::Pass *v55;
  C3D::PassDescriptor *v56;
  unsigned __int8 v57;
  uint64_t v58;
  C3D::PassDescriptor *v59;
  uint64_t v60;
  C3D::Pass *v61;
  uint64_t v62;
  uint64_t v63;
  C3D::Pass *v64;
  void *UserInfo;
  void *v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  C3D::Pass *v70;
  uint64_t v71;
  C3D::Pass *v72;
  __int16 v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  id AuthoringEnvironment;
  uint64_t v78;
  C3D::Pass *v79;
  C3D::AuthoringPass *v80;
  C3D::Pass *v81;
  uint64_t v82;
  uint64_t v83;
  C3D::ScenePass *v84;
  int v85;
  C3D::Pass *v86;
  uint64_t v87;
  C3D::Pass *v88;
  C3D::Pass *v89;
  C3D::Pass *v90;
  uint64_t v91;
  uint64_t v92;
  C3D::Pass *v93;
  const C3D::PassIODescriptor *v94;
  C3D::Pass *v95;
  const C3D::PassIODescriptor *v96;
  uint64_t v97;
  C3D::Pass *v98;
  C3D::Pass *v99;
  C3D::Pass *v100;
  C3D::Pass *v101;
  NSObject *v102;
  C3D::Pass *v103;
  uint64_t v104;
  uint64_t v105;
  __int128 v106;
  int8x16_t v107;
  __int128 v108;
  const char *v109;
  __int16 v110;
  uint64_t Pass;
  int v112;
  char v113;
  uint64_t v114;
  int v115;
  C3D::Pass **v116;
  C3D::Pass *v117;
  C3D::Pass *v118;

  *((_DWORD *)this + 8) = 5;
  v2 = (C3D::FinalPass *)((char *)this + 32);
  *((_OWORD *)this + 8) = xmmword_1DD007E00;
  *((_QWORD *)this + 20) = 2;
  v3 = *((_QWORD *)this + 2);
  *((_QWORD *)v2 + 15) = **((_QWORD **)v2 - 1);
  RenderContext = C3DEngineContextGetRenderContext(v3);
  if (-[SCNMTLRenderContext textureTarget](RenderContext))
  {
    v5 = (void *)-[SCNMTLRenderContext textureTarget](RenderContext);
    *((float *)this + 36) = (float)(unint64_t)objc_msgSend(v5, "width");
    *((float *)this + 37) = (float)(unint64_t)objc_msgSend(v5, "height");
    *((_QWORD *)this + 20) = objc_msgSend(v5, "textureType");
    *((float *)this + 34) = (float)(unint64_t)objc_msgSend(v5, "width");
    *((float *)this + 35) = (float)(unint64_t)objc_msgSend(v5, "height");
  }
  else
  {
    if (!-[SCNMTLRenderContext layerTarget](RenderContext))
      goto LABEL_6;
    objc_msgSend((id)-[SCNMTLRenderContext layerTarget](RenderContext), "drawableSize");
    *(float *)&v6 = v6;
    *((float *)this + 36) = floorf(*(float *)&v6);
    objc_msgSend((id)-[SCNMTLRenderContext layerTarget](RenderContext), "drawableSize");
    v8 = v7;
    *((float *)this + 37) = floorf(v8);
    *((float32x4_t *)this + 8) = vrndmq_f32((float32x4_t)C3DEngineContextGetViewport((__n128 *)*((_QWORD *)this + 2)));
    v5 = (void *)-[SCNMTLRenderContext layerTarget](RenderContext);
  }
  *((_QWORD *)this + 19) = objc_msgSend(v5, "pixelFormat");
LABEL_6:
  v106 = *((_OWORD *)this + 8);
  SuperSamplingFactor = C3DEngineContextGetSuperSamplingFactor(*((_QWORD *)this + 2));
  v10 = *((int8x16_t *)this + 8);
  v10.u64[1] = (unint64_t)vmul_n_f32((float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL), SuperSamplingFactor);
  v107 = v10;
  *((int8x16_t *)this + 8) = v10;
  C3D::Pass::setInputCount(this, 1u);
  *(_QWORD *)(C3D::PassDescriptor::inputAtIndex(v2, 0) + 8) = "COLOR";
  v117 = 0;
  v118 = 0;
  v11 = C3D::RenderGraph::finalTechnique(*((C3D::RenderGraph **)this + 3));
  if (!v11)
  {
    v60 = *((_QWORD *)this + 3);
    *(_QWORD *)&v108 = this;
    v61 = C3D::RenderGraph::createPass<C3D::MainPass,C3D::Pass *&>(v60, (C3D::Pass **)&v108);
    v117 = v61;
    goto LABEL_45;
  }
  v12 = v11;
  StackAllocator = C3DEngineContextGetStackAllocator(*((_QWORD *)this + 2));
  C3DStackAllocatorPushFrame(StackAllocator);
  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array(&v114, StackAllocator);
  v14 = C3D::FinalPass::_createCustomTechniquePassesIfNeeded((uint64_t *)this, v12, &v114, &v118);
  v105 = StackAllocator;
  if (v118)
  {
    if ((*(_BYTE *)(v12 + 88) & 8) == 0)
    {
      v15 = *((_QWORD *)this + 3);
      *(_QWORD *)&v108 = this;
      v117 = C3D::RenderGraph::createPass<C3D::MainPass,C3D::Pass *&>(v15, (C3D::Pass **)&v108);
      v16 = *((_QWORD *)this + 3);
      v108 = 0uLL;
      v109 = "DEPTH";
      v110 = 512;
      Pass = C3D::ScenePass::lastPass(v117);
      v112 = 1;
      v113 = 0;
      v17 = C3D::RenderGraph::search(v16, (uint64_t)&v108);
      if (!v17)
      {
        v18 = scn_default_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
          C3D::FinalPass::setup(v18, v19, v20, v21, v22, v23, v24, v25);
      }
      v26 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
      v27 = C3D::Pass::outputBufferParameterNamed(v26, "COLOR");
      if (!v27)
      {
        v28 = scn_default_log();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
          C3D::FinalPass::setup(v28, v29, v30, v31, v32, v33, v34, v35);
      }
      v36 = C3D::Pass::outputBufferParameterNamed(v17, "DEPTH");
      if (!v36)
      {
        v37 = scn_default_log();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
          C3D::FinalPass::setup(v37, v38, v39, v40, v41, v42, v43, v44);
      }
      if (v115)
      {
        v104 = RenderContext;
        v45 = v116;
        v46 = &v116[v115];
        do
        {
          v47 = *v45;
          v48 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v45);
          if (C3D::PassDescriptor::inputCount(v48))
          {
            v49 = 0;
            do
            {
              if (*(_BYTE *)(C3D::Pass::inputBufferParameterAtIndex(v47, v49) + 64) == 1)
              {
                v50 = C3D::Pass::inputBufferParameterNamed(v47, "COLOR");
                if (v27 && v50)
                  *(_WORD *)(v50 + 28) = *(_WORD *)(v27 + 28);
                v51 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
                C3D::Pass::addDependency(v47, v51);
              }
              ++v49;
              v52 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v47);
            }
            while (C3D::PassDescriptor::inputCount(v52) > v49);
          }
          ++v45;
        }
        while (v45 != v46);
        RenderContext = v104;
        if (v115)
        {
          v53 = v116;
          v54 = &v116[v115];
          do
          {
            v55 = *v53;
            v56 = (C3D::PassDescriptor *)C3D::Pass::descriptor(*v53);
            if (C3D::PassDescriptor::inputCount(v56))
            {
              v57 = 0;
              do
              {
                if (*(_BYTE *)(C3D::Pass::inputBufferParameterAtIndex(v55, v57) + 64) == 2)
                {
                  v58 = C3D::Pass::inputBufferParameterNamed(v55, "DEPTH");
                  if (v36 && v58)
                    *(_WORD *)(v58 + 28) = *(_WORD *)(v36 + 28);
                  C3D::Pass::addDependency(v55, v17);
                }
                ++v57;
                v59 = (C3D::PassDescriptor *)C3D::Pass::descriptor(v55);
              }
              while (C3D::PassDescriptor::inputCount(v59) > v57);
            }
            ++v53;
          }
          while (v53 != v54);
        }
      }
      goto LABEL_44;
    }
  }
  else
  {
    v62 = *((_QWORD *)this + 3);
    *(_QWORD *)&v108 = this;
    v14 = C3D::RenderGraph::createPass<C3D::MainPass,C3D::Pass *&>(v62, (C3D::Pass **)&v108);
  }
  v117 = v14;
LABEL_44:
  C3DStackAllocatorPopFrame(v105);
  v61 = v117;
LABEL_45:
  *(_QWORD *)(*((_QWORD *)this + 3) + 112) = v61;
  *((_OWORD *)this + 8) = v106;
  C3D::Pass::parentColorDesc(this, (uint64_t)&v108);
  v63 = C3D::PassDescriptor::inputAtIndex(v2, 0);
  *(_OWORD *)(v63 + 16) = v108;
  *(_DWORD *)(v63 + 32) = (_DWORD)v109;
  C3D::PassDescriptor::inputAtIndex(v2, 0);
  v64 = this;
  if (C3DEngineContextGetUpdateMainFramebuffer(*((_QWORD *)this + 2)))
  {
    UserInfo = (void *)C3DEngineContextGetUserInfo(*((_QWORD *)this + 2));
    if (UserInfo
      && (v66 = UserInfo,
          v67 = objc_msgSend(UserInfo, "overlaySKScene") != 0,
          LODWORD(UserInfo) = objc_msgSend(v66, "showsStatistics"),
          v67)
      || (v64 = this, (_DWORD)UserInfo))
    {
      v68 = *((_QWORD *)this + 3);
      *(_QWORD *)&v108 = this;
      v64 = C3D::RenderGraph::createPass<C3D::OverlayPass,C3D::FinalPass *>(v68, (C3D::Pass **)&v108);
      C3D::Pass::addDependency(this, v64);
    }
    if (C3DEngineContextGetSuperSamplingFactor(*((_QWORD *)this + 2)) > 1.0)
    {
      v69 = *((_QWORD *)this + 3);
      *(_QWORD *)&v108 = this;
      v70 = C3D::RenderGraph::createPass<C3D::DownsamplePass,C3D::FinalPass *>(v69, (C3D::Pass **)&v108);
      C3D::Pass::addDependency(v64, v70);
      v64 = v70;
    }
  }
  *((int8x16_t *)this + 8) = v107;
  if (C3DEngineContextIsJitteringEnabled(*((_QWORD *)this + 2)))
  {
    v71 = *((_QWORD *)this + 3);
    *(_QWORD *)&v108 = this;
    v72 = C3D::RenderGraph::createPass<C3D::JitteringPass,C3D::FinalPass *>(v71, (C3D::Pass **)&v108);
    if (C3DEngineContextGetUpdateMainFramebuffer(*((_QWORD *)this + 2)))
    {
      v73 = *(_WORD *)(C3D::Pass::outputBufferParameterAtIndex(v72, 1u) + 28);
      *(_WORD *)(C3D::Pass::inputBufferParameterAtIndex(this, 0) + 28) = v73;
    }
    else
    {
      v74 = C3D::Pass::outputBufferParameterAtIndex(v72, 0);
      v75 = C3D::Pass::inputBufferParameterAtIndex(this, 0);
      v76 = *(_DWORD *)(v74 + 32);
      *(_OWORD *)(v75 + 16) = *(_OWORD *)(v74 + 16);
      *(_DWORD *)(v75 + 32) = v76;
    }
    C3D::Pass::addDependency(v64, v72);
  }
  else
  {
    v72 = v64;
  }
  if (!-[SCNMTLRenderContext showsAuthoringEnvironment](RenderContext))
  {
    v80 = 0;
    v79 = 0;
    v81 = 0;
    goto LABEL_68;
  }
  AuthoringEnvironment = C3DEngineContextGetAuthoringEnvironment(*((_QWORD *)this + 2), 0);
  if (C3DAuthoringEnvironmentHasSelectedNodes(AuthoringEnvironment))
  {
    v78 = *((_QWORD *)this + 3);
    *(_QWORD *)&v108 = this;
    v79 = C3D::RenderGraph::createPass<C3D::ManipulatorPass,C3D::FinalPass *>(v78, (C3D::Pass **)&v108);
    C3D::Pass::addDependency(v72, v79);
    v72 = v79;
    if (!AuthoringEnvironment)
      goto LABEL_65;
  }
  else
  {
    v79 = 0;
    if (!AuthoringEnvironment)
      goto LABEL_65;
  }
  if ((objc_msgSend(AuthoringEnvironment, "authoringDisplayMask", v104) & 0x100) != 0)
  {
    v82 = *((_QWORD *)this + 3);
    *(_QWORD *)&v108 = this;
    v81 = C3D::RenderGraph::createPass<C3D::GridPass,C3D::FinalPass *>(v82, (C3D::Pass **)&v108);
    C3D::Pass::addDependency(v72, v81);
    v72 = v81;
    goto LABEL_67;
  }
LABEL_65:
  v81 = 0;
LABEL_67:
  v83 = *((_QWORD *)this + 3);
  *(_QWORD *)&v108 = this;
  v80 = C3D::RenderGraph::createPass<C3D::AuthoringPass,C3D::FinalPass *>(v83, (C3D::Pass **)&v108);
  C3D::Pass::addDependency(v72, v80);
  v72 = v80;
LABEL_68:
  if ((-[SCNMTLRenderContext enableARMode](RenderContext) & 1) != 0)
  {
    if (!v117)
    {
      v84 = 0;
      goto LABEL_82;
    }
  }
  else
  {
    v85 = -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext);
    v84 = v117;
    if (!v85 || !v117)
    {
LABEL_82:
      if (v80)
      {
        v86 = 0;
LABEL_84:
        C3D::AuthoringPass::setMainScenePass((uint64_t)v80, v84);
        v91 = C3DEngineContextGetStackAllocator(*((_QWORD *)this + 2));
        C3DStackAllocatorPushFrame(v91);
        if (v86)
          goto LABEL_88;
        v92 = *((_QWORD *)this + 3);
        v108 = 0uLL;
        v109 = "COLOR";
        v110 = 256;
        v93 = v118;
        if (!v118)
          v93 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
        Pass = (uint64_t)v93;
        v112 = 1;
        v113 = 0;
        v86 = C3D::RenderGraph::search(v92, (uint64_t)&v108);
        if (v86)
        {
LABEL_88:
          v94 = (const C3D::PassIODescriptor *)C3D::Pass::outputBufferParameterNamed(v86, "COLOR");
          if (v117)
          {
            if (v94)
            {
              C3D::AuthoringPass::setColorInput(v80, v94);
              C3D::Pass::addDependency(v80, v86);
              if (v79)
              {
                if (v81)
                  v95 = v81;
                else
                  v95 = v80;
                v96 = (const C3D::PassIODescriptor *)C3D::PassDescriptor::outputAtIndex((C3D::Pass *)((char *)v95 + 32), 0);
                C3D::ManipulatorPass::setColorInput(v79, v96);
              }
            }
          }
        }
        v97 = *((_QWORD *)this + 3);
        v108 = 0uLL;
        v109 = "DEPTH";
        v110 = 512;
        v98 = v118;
        if (!v118)
          v98 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
        Pass = (uint64_t)v98;
        v112 = 1;
        v113 = 0;
        v99 = C3D::RenderGraph::search(v97, (uint64_t)&v108);
        if (v99)
        {
          v100 = v99;
          if (v81)
            C3D::Pass::addDependency(v81, v99);
          v101 = (C3D::Pass *)*((_QWORD *)v80 + 671);
          if (v101)
          {
            if (v100 != v86)
            {
              C3D::Pass::addDependency(v101, v86);
              v101 = (C3D::Pass *)*((_QWORD *)v80 + 671);
            }
            C3D::Pass::addDependency(v101, v100);
          }
          if (v100 != v86)
            C3D::Pass::addDependency(v80, v100);
        }
        else if ((C3D::FinalPass::setup(void)::done & 1) == 0)
        {
          C3D::FinalPass::setup(void)::done = 1;
          v102 = scn_default_log();
          if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
            C3D::FinalPass::setup(v102);
        }
        C3DStackAllocatorPopFrame(v91);
        return;
      }
      goto LABEL_111;
    }
  }
  v86 = C3D::RenderGraph::createPass<C3D::CompositeARPass,C3D::ScenePass *&>(*((_QWORD *)this + 3), &v117);
  v87 = *((_QWORD *)this + 3);
  v108 = 0uLL;
  v109 = "COLOR";
  v110 = 256;
  v88 = v118;
  if (!v118)
    v88 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
  Pass = (uint64_t)v88;
  v112 = 1;
  v113 = 0;
  v89 = C3D::RenderGraph::search(v87, (uint64_t)&v108);
  C3D::Pass::addDependency(v86, v89);
  if (-[SCNMTLRenderContext enableARMode](RenderContext))
  {
    v90 = C3D::RenderGraph::createPass<C3D::DrawBackgroundPass,C3D::ScenePass *&>(*((_QWORD *)this + 3), &v117);
    C3D::Pass::addDependency(v86, v90);
  }
  if (v89 != v117 && -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext))
    C3D::Pass::addDependency(v86, v117);
  if (v80)
  {
    v84 = v117;
    goto LABEL_84;
  }
  C3D::Pass::addDependency(v72, v86);
  v72 = v86;
LABEL_111:
  v103 = v118;
  if (!v118)
    v103 = (C3D::Pass *)C3D::ScenePass::lastPass(v117);
  C3D::Pass::addDependency(v72, v103);
}

float C3DEngineContextGetSuperSamplingFactor(uint64_t a1)
{
  return *(float *)(a1 + 204);
}

uint64_t C3DEngineContextGetUserInfo(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 128);
}

void C3D::Pass::setInputCount(C3D::Pass *this, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  void *Aligned;

  *((_WORD *)this + 36) = a2;
  *((_WORD *)this + 48) = a2;
  if (a2)
  {
    v4 = *(_QWORD *)(*((_QWORD *)this + 3) + 16);
    v5 = a2;
    v6 = (*(uint64_t (**)(C3D::Pass *))(*(_QWORD *)this + 88))(this);
    *((_QWORD *)this + 7) = C3D::ScratchAllocateArray<C3D::PassIODescriptor,MTLTextureType const&>(v4, v5, (uint64_t *)(v6 + 32));
    v7 = 8 * a2;
    Aligned = (void *)C3DScratchAllocatorAllocateAligned(*(_QWORD *)(*((_QWORD *)this + 3) + 16), v7, 8, 0);
    bzero(Aligned, v7);
    *((_QWORD *)this + 10) = Aligned;
    bzero(Aligned, 8 * *((unsigned __int16 *)this + 48));
  }
}

uint64_t C3D::ScratchAllocateArray<C3D::PassIODescriptor,MTLTextureType const&>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t result;
  _WORD *v6;
  uint64_t v7;

  v4 = a2;
  result = C3DScratchAllocatorAllocateAligned(a1, 80 * a2, 16, 0);
  if (v4)
  {
    v6 = (_WORD *)(result + 66);
    do
    {
      v7 = *a3;
      *((_BYTE *)v6 - 66) = 1;
      *(_QWORD *)(v6 - 29) = 0;
      *(_QWORD *)(v6 - 5) = 0;
      *(_QWORD *)(v6 - 9) = 0;
      *(v6 - 1) = 1;
      *v6 &= 0xFE00u;
      *(_QWORD *)(v6 - 25) = 0x1000100000000;
      *((_BYTE *)v6 - 42) = v7;
      *(_WORD *)((char *)v6 - 41) = 2;
      *((_BYTE *)v6 - 39) = 0;
      *(_QWORD *)(v6 - 19) = 0x10000;
      v6 += 40;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t C3DEngineContextIsJitteringEnabled(uint64_t a1)
{
  return *(_BYTE *)(a1 + 1716) & 1;
}

uint64_t C3D::ScenePass::lastPass(C3D::ScenePass *this)
{
  return *((_QWORD *)this + 680);
}

void C3D::Pass::addDependency(C3D::Pass *this, C3D::Pass *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (this == a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3D::Pass::addDependency(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (!*((_QWORD *)this + 3))
  {
    v12 = scn_default_log();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      C3D::Pass::addDependency(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  C3D::RenderGraph::addDependency(*((C3D::RenderGraph **)this + 3), this, a2);
}

uint64_t C3D::DrawNodesPass::_setupPointOfView(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!a1[631])
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      C3D::DrawNodesPass::_setupPointOfView(v8, v9, v10, v11, v12, v13, v14, v15);
  }
  (*(void (**)(_QWORD *))(*a1 + 104))(a1);
  (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*a1 + 96))(a1, a2, a3, a4);
  C3DCullingContextSetupCullingMatricesAndPlanes((uint64_t)(a1 + 40), (float32x2_t *)a1[2], a2, a3, *((unsigned __int8 *)a1 + 119));
  return (*(uint64_t (**)(_QWORD *))(*a1 + 112))(a1);
}

void C3D::DrawNodesPass::_setupPointOfViewMatrices(uint64_t a1, float32x4_t *a2, float32x4_t *a3)
{
  char CoordinatesSystemOptions;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  unsigned int v19;
  float32x4_t v20;
  float32x4_t v21;
  unsigned int v22;
  float32x4_t v23;
  unsigned int v24;
  __int128 v25;
  double v26;
  double v27;
  double v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unint64_t v32;
  float32x4_t *WorldMatrix;
  unint64_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  unint64_t v40;
  float32x4_t v41;
  float32x4_t v42;
  __int128 v43;
  float32x4_t v44;
  unint64_t v45;
  float32x4_t v46;
  float32x4_t v47;
  __int128 v48;
  unint64_t v49;
  float32x4_t v50;
  float32x4_t v51;
  __int128 v52;
  unint64_t v53;
  float32x4_t v54;
  float32x4_t v55;
  __int128 v56;
  unint64_t v57;
  float32x4_t v58;
  float32x4_t v59;
  __int128 v60;
  float32x4_t v61;
  float32x4_t v62;
  __int128 v63;
  __int128 v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  char v68[8];
  double v69;
  double v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  __int128 v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  __int128 v78;

  if (*(_BYTE *)(a1 + 302))
  {
    CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(*(_QWORD *)(a1 + 16));
    if ((C3DNodeGetProjectionInfos((uint64_t)a2, (uint64_t)v68) & 1) == 0)
    {
      v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
        C3D::DrawNodesPass::_setupPointOfViewMatrices(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    v15 = v69;
    v14 = v70;
    *(double *)(a1 + 5064) = v69;
    *(double *)(a1 + 5072) = v14;
    *(_BYTE *)(a1 + 5015) = (v68[0] & 0x20) != 0;
    if ((CoordinatesSystemOptions & 1) != 0)
    {
      if (v14 > v15)
        v26 = v14;
      else
        v26 = v15 + 1.0;
      v27 = __tanpi(0.25);
      if (v27 == 0.0)
        v28 = 1.0;
      else
        v28 = 1.0 / v27;
      *(float *)&v29 = v28;
      v20 = (float32x4_t)v29;
      v21.i32[0] = 0;
      v21.i64[1] = 0;
      v21.i32[1] = v29;
      v23.i64[0] = 0;
      *(float *)&v30 = v26 / (v15 - v26);
      v23.i64[1] = __PAIR64__(-1.0, v30);
      *(_QWORD *)&v25 = 0;
      *(float *)&v31 = v15 * v26 / (v15 - v26);
      *((_QWORD *)&v25 + 1) = v31;
      if ((CoordinatesSystemOptions & 8) != 0)
      {
        v32 = 0;
        v71 = v20;
        v72 = v21;
        v73 = v23;
        v74 = v25;
        do
        {
          *(float32x4_t *)((char *)&v75 + v32) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1DD007970, COERCE_FLOAT(*(_OWORD *)((char *)&v71 + v32))), (float32x4_t)xmmword_1DD007920, *(float32x2_t *)&v71.f32[v32 / 4], 1), (float32x4_t)xmmword_1DD007960, *(float32x4_t *)((char *)&v71 + v32), 2), (float32x4_t)xmmword_1DD007E00, *(float32x4_t *)((char *)&v71 + v32), 3);
          v32 += 16;
        }
        while (v32 != 64);
        v20 = v75;
        v21 = v76;
        v23 = v77;
        v25 = v78;
      }
    }
    else
    {
      if (v14 > v15)
        v16 = v14;
      else
        v16 = v15 + 1.0;
      v17 = __tanpi(0.25);
      if (v17 == 0.0)
        v18 = 1.0;
      else
        v18 = 1.0 / v17;
      *(float *)&v19 = v18;
      *(_QWORD *)&v25 = 0;
      v20 = (float32x4_t)v19;
      v21.i32[0] = 0;
      v21.i64[1] = 0;
      v21.i32[1] = v19;
      v23.i64[0] = 0;
      *(float *)&v22 = (v15 + v16) / (v15 - v16);
      v23.i64[1] = __PAIR64__(-1.0, v22);
      *(float *)&v24 = (v15 + v15) * v16 / (v15 - v16);
      *((_QWORD *)&v25 + 1) = v24;
    }
    *(float32x4_t *)(a1 + 3792) = v20;
    *(float32x4_t *)(a1 + 3808) = v21;
    *(float32x4_t *)(a1 + 3824) = v23;
    *(_OWORD *)(a1 + 3840) = v25;
    v66 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 16);
    v67 = *(float32x4_t *)MEMORY[0x1E0C83FF0];
    v64 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 48);
    v65 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 32);
    WorldMatrix = C3DNodeGetWorldMatrix(a2);
    v34 = 0;
    v35 = *WorldMatrix;
    v36 = WorldMatrix[1];
    v37 = WorldMatrix[2];
    v38 = WorldMatrix[3];
    v39 = vnegq_f32(v67);
    v71 = v65;
    v72 = v66;
    v73 = v39;
    v74 = v64;
    do
    {
      *(float32x4_t *)((char *)&v75 + v34) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(*(_OWORD *)((char *)&v71 + v34))), v36, *(float32x2_t *)&v71.f32[v34 / 4], 1), v37, *(float32x4_t *)((char *)&v71 + v34), 2), v38, *(float32x4_t *)((char *)&v71 + v34), 3);
      v34 += 16;
    }
    while (v34 != 64);
    v40 = 0;
    v41 = v76;
    v42 = v77;
    v43 = v78;
    *(float32x4_t *)(a1 + 3024) = v75;
    *(float32x4_t *)(a1 + 3040) = v41;
    *(float32x4_t *)(a1 + 3056) = v42;
    *(_OWORD *)(a1 + 3072) = v43;
    v44 = vnegq_f32(v65);
    v71 = v44;
    v72 = v66;
    v73 = v67;
    v74 = v64;
    do
    {
      *(float32x4_t *)((char *)&v75 + v40) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(*(_OWORD *)((char *)&v71 + v40))), v36, *(float32x2_t *)&v71.f32[v40 / 4], 1), v37, *(float32x4_t *)((char *)&v71 + v40), 2), v38, *(float32x4_t *)((char *)&v71 + v40), 3);
      v40 += 16;
    }
    while (v40 != 64);
    v45 = 0;
    v46 = v76;
    v47 = v77;
    v48 = v78;
    *(float32x4_t *)(a1 + 3088) = v75;
    *(float32x4_t *)(a1 + 3104) = v46;
    *(float32x4_t *)(a1 + 3120) = v47;
    *(_OWORD *)(a1 + 3136) = v48;
    v71 = v67;
    v72 = v65;
    v73 = vnegq_f32(v66);
    v74 = v64;
    do
    {
      *(float32x4_t *)((char *)&v75 + v45) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(*(_OWORD *)((char *)&v71 + v45))), v36, *(float32x2_t *)&v71.f32[v45 / 4], 1), v37, *(float32x4_t *)((char *)&v71 + v45), 2), v38, *(float32x4_t *)((char *)&v71 + v45), 3);
      v45 += 16;
    }
    while (v45 != 64);
    v49 = 0;
    v50 = v76;
    v51 = v77;
    v52 = v78;
    *(float32x4_t *)(a1 + 3152) = v75;
    *(float32x4_t *)(a1 + 3168) = v50;
    *(float32x4_t *)(a1 + 3184) = v51;
    *(_OWORD *)(a1 + 3200) = v52;
    v71 = v67;
    v72 = v44;
    v73 = v66;
    v74 = v64;
    do
    {
      *(float32x4_t *)((char *)&v75 + v49) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(*(_OWORD *)((char *)&v71 + v49))), v36, *(float32x2_t *)&v71.f32[v49 / 4], 1), v37, *(float32x4_t *)((char *)&v71 + v49), 2), v38, *(float32x4_t *)((char *)&v71 + v49), 3);
      v49 += 16;
    }
    while (v49 != 64);
    v53 = 0;
    v54 = v76;
    v55 = v77;
    v56 = v78;
    *(float32x4_t *)(a1 + 3216) = v75;
    *(float32x4_t *)(a1 + 3232) = v54;
    *(float32x4_t *)(a1 + 3248) = v55;
    *(_OWORD *)(a1 + 3264) = v56;
    v71 = v67;
    v72 = v66;
    v73 = v65;
    v74 = v64;
    do
    {
      *(float32x4_t *)((char *)&v75 + v53) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(*(_OWORD *)((char *)&v71 + v53))), v36, *(float32x2_t *)&v71.f32[v53 / 4], 1), v37, *(float32x4_t *)((char *)&v71 + v53), 2), v38, *(float32x4_t *)((char *)&v71 + v53), 3);
      v53 += 16;
    }
    while (v53 != 64);
    v57 = 0;
    v58 = v76;
    v59 = v77;
    v60 = v78;
    *(float32x4_t *)(a1 + 3280) = v75;
    *(float32x4_t *)(a1 + 3296) = v58;
    *(float32x4_t *)(a1 + 3312) = v59;
    *(_OWORD *)(a1 + 3328) = v60;
    v71 = v39;
    v72 = v66;
    v73 = v44;
    v74 = v64;
    do
    {
      *(float32x4_t *)((char *)&v75 + v57) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(*(_OWORD *)((char *)&v71 + v57))), v36, *(float32x2_t *)&v71.f32[v57 / 4], 1), v37, *(float32x4_t *)((char *)&v71 + v57), 2), v38, *(float32x4_t *)((char *)&v71 + v57), 3);
      v57 += 16;
    }
    while (v57 != 64);
    v61 = v76;
    v62 = v77;
    v63 = v78;
    *(float32x4_t *)(a1 + 3344) = v75;
    *(float32x4_t *)(a1 + 3360) = v61;
    *(float32x4_t *)(a1 + 3376) = v62;
    *(_OWORD *)(a1 + 3392) = v63;
    C3DCullingContextSetupViewAndViewProjMatricesForCubemapRendering(a1 + 320);
  }
  else
  {
    C3DCullingContextSetupPointOfViewMatrices(a1 + 320, *(_QWORD *)(a1 + 16), a2, a3);
  }
}

uint64_t C3D::RenderGraph::finalTechnique(C3D::RenderGraph *this)
{
  const void *v2;
  float32x4_t *PointOfView;
  const __CFDictionary *Camera;
  const void *Technique;
  __CFArray *Mutable;
  uint64_t Scene;
  uint64_t LightingSystem;
  const void *v9;
  CFTypeRef v10;
  CFTypeRef v11;
  CFTypeRef v12;
  const void *v13;
  _QWORD v15[5];

  if (!*((_BYTE *)this + 208))
  {
    v2 = (const void *)*((_QWORD *)this + 25);
    if (v2)
    {
      CFRelease(v2);
      *((_QWORD *)this + 25) = 0;
    }
    PointOfView = C3DEngineContextGetPointOfView(*((_QWORD *)this + 1));
    if (PointOfView && (Camera = C3DNodeGetCamera((uint64_t)PointOfView)) != 0)
      Technique = (const void *)C3DCameraGetTechnique((uint64_t)Camera);
    else
      Technique = 0;
    Mutable = CFArrayCreateMutable(0, 10, MEMORY[0x1E0C9B378]);
    Scene = C3DEngineContextGetScene(*((_QWORD *)this + 1));
    LightingSystem = C3DSceneGetLightingSystem(Scene);
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = ___ZN3C3D11RenderGraph14finalTechniqueEv_block_invoke;
    v15[3] = &__block_descriptor_40_e21_v16__0____C3DLight__8l;
    v15[4] = Mutable;
    C3DLightingSystemEnumerateLightsWithTechnique(LightingSystem, (uint64_t)v15);
    if (Technique)
      CFArrayAppendValue(Mutable, Technique);
    v9 = (const void *)*((_QWORD *)this + 24);
    if (v9)
      CFArrayAppendValue(Mutable, v9);
    if (CFArrayGetCount(Mutable))
    {
      v10 = C3DFXTechniqueCreateBySequencingTechniques(Mutable, 0);
      v11 = (CFTypeRef)*((_QWORD *)this + 25);
      if (v11 != v10)
      {
        if (v11)
        {
          CFRelease(v11);
          *((_QWORD *)this + 25) = 0;
        }
        if (v10)
          v12 = CFRetain(v10);
        else
          v12 = 0;
        *((_QWORD *)this + 25) = v12;
      }
      if (v10)
        CFRelease(v10);
    }
    else
    {
      v13 = (const void *)*((_QWORD *)this + 25);
      if (v13)
      {
        CFRelease(v13);
        *((_QWORD *)this + 25) = 0;
      }
    }
    CFRelease(Mutable);
    *((_BYTE *)this + 208) = 1;
  }
  return *((_QWORD *)this + 25);
}

uint64_t C3D::RenderGraph::getSuccessors@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned __int16 PrimitiveCount;
  uint64_t result;
  uint64_t v9;
  _DWORD *v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;

  C3D::Array<C3D::Pass *,0u,C3D::StackAllocator>::Array((_QWORD *)a4, a3);
  PrimitiveCount = C3DMeshElementGetPrimitiveCount(a2);
  result = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(a1 + 24), PrimitiveCount);
  v9 = *(unsigned int *)(result + 40);
  if ((_DWORD)v9)
  {
    v10 = *(_DWORD **)(result + 48);
    v11 = &v10[v9];
    do
    {
      result = C3D::Array<C3D::RenderGraph::GraphNode,0u,C3D::ScratchAllocator>::operator[](*(_QWORD *)(a1 + 24), *v10 & 0x7FFF);
      v12 = *(_QWORD *)(a4 + 16);
      v13 = *(unsigned int *)(a4 + 8);
      if ((_DWORD)v13)
      {
        v14 = 8 * v13;
        v15 = *(_QWORD **)(a4 + 16);
        while (*v15 != *(_QWORD *)result)
        {
          ++v15;
          v14 -= 8;
          if (!v14)
          {
            v15 = (_QWORD *)(v12 + 8 * v13);
            break;
          }
        }
      }
      else
      {
        v15 = *(_QWORD **)(a4 + 16);
      }
      if (v13 == ((uint64_t)v15 - v12) >> 3)
        result = (uint64_t)C3D::Array<char const*,0u,C3D::StackAllocator>::push_back<char const*&>((_DWORD *)a4, (_QWORD *)result);
      ++v10;
    }
    while (v10 != v11);
  }
  return result;
}

void C3D::RenderGraph::addDependency(C3D::RenderGraph *this, const C3D::Pass *a2, const C3D::Pass *a3)
{
  unsigned int PrimitiveCount;
  unsigned int v7;

  if (C3DMeshElementGetPrimitiveCount((uint64_t)a2) == -1)
    C3D::RenderGraph::addDependency();
  if (C3DMeshElementGetPrimitiveCount((uint64_t)a3) == -1)
    C3D::RenderGraph::addDependency();
  PrimitiveCount = C3DMeshElementGetPrimitiveCount((uint64_t)a2);
  v7 = C3DMeshElementGetPrimitiveCount((uint64_t)a3);
  C3D::RenderGraph::addDependency(this, PrimitiveCount, v7);
}

uint64_t SCNMTLTextureTypeMultisampledEquivalent(uint64_t a1)
{
  uint64_t v1;

  v1 = 4;
  if (a1 != 2)
    v1 = a1;
  if (a1 == 3)
    return 8;
  else
    return v1;
}

uint64_t C3DRendererElementStoreGetElementCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DRendererElementStoreDeallocateSpanForNode_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return C3DSpanAllocatorGetCount(*(_QWORD *)(a1 + 16));
}

uint64_t C3DSpanAllocatorGetCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

double C3DProjectionInfosGetZNear(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(double *)(a1 + 8);
}

double C3DProjectionInfosGetZFar(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(double *)(a1 + 16);
}

double C3DProjectionInfosGetOrthographicScale(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(double *)(a1 + 48);
}

uint64_t C3DProjectionInfosGetOrtho(_BYTE *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DProjectionInfosSetZFar_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *a1 & 1;
}

CFMutableArrayRef C3DNodeCopyNodesWithAttribute(uint64_t a1, __CFString *a2, char a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v23;
  _QWORD *v24;
  uint64_t *v25;
  _QWORD v27[6];
  uint64_t v28;
  _QWORD v29[6];
  _QWORD v30[6];

  if (!a1 && (v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    C3DNodeCopyNodesWithAttribute_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
LABEL_6:
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v23 = Mutable;
  if (CFSTR("kMeshKey") == a2)
  {
    v30[0] = MEMORY[0x1E0C809B0];
    v30[1] = 0x40000000;
    v30[2] = __C3DNodeCopyNodesWithAttribute_block_invoke;
    v30[3] = &__block_descriptor_tmp_29_0;
    v30[4] = Mutable;
    v24 = v30;
LABEL_11:
    v25 = v24 + 5;
    goto LABEL_12;
  }
  if (CFSTR("kDeformerStackKey") == a2)
  {
    v29[0] = MEMORY[0x1E0C809B0];
    v29[1] = 0x40000000;
    v29[2] = __C3DNodeCopyNodesWithAttribute_block_invoke_2;
    v29[3] = &__block_descriptor_tmp_30_1;
    v29[4] = Mutable;
    v24 = v29;
    goto LABEL_11;
  }
  v27[0] = MEMORY[0x1E0C809B0];
  v27[1] = 0x40000000;
  v27[2] = __C3DNodeCopyNodesWithAttribute_block_invoke_3;
  v27[3] = &__block_descriptor_tmp_31_1;
  v27[4] = a2;
  v27[5] = Mutable;
  v24 = v27;
  v25 = &v28;
LABEL_12:
  *(_BYTE *)v25 = a3;
  C3DNodeApplyHierarchy(a1, (uint64_t)v24);
  return v23;
}

uint64_t C3DLightingSystemSetMainRenderingFrustums(uint64_t result, _OWORD *a2, float a3, float a4, uint64_t a5, __int128 *a6, __int128 *a7)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  v7 = a2[1];
  *(_OWORD *)(result + 116512) = *a2;
  *(_OWORD *)(result + 116528) = v7;
  v8 = a2[2];
  v9 = a2[3];
  v10 = a2[5];
  *(_OWORD *)(result + 116576) = a2[4];
  *(_OWORD *)(result + 116592) = v10;
  *(_OWORD *)(result + 116544) = v8;
  *(_OWORD *)(result + 116560) = v9;
  v11 = *a7;
  v12 = a7[1];
  v13 = a7[3];
  *(_OWORD *)(result + 116720) = a7[2];
  *(_OWORD *)(result + 116736) = v13;
  *(_OWORD *)(result + 116688) = v11;
  *(_OWORD *)(result + 116704) = v12;
  v14 = *a6;
  v15 = a6[1];
  v16 = a6[3];
  *(_OWORD *)(result + 116640) = a6[2];
  *(_OWORD *)(result + 116656) = v16;
  *(_OWORD *)(result + 116608) = v14;
  *(_OWORD *)(result + 116624) = v15;
  *(float *)(result + 116672) = a3;
  *(float *)(result + 116676) = a4;
  return result;
}

void C3DLightingSystemEnumerateLightsWithTechnique(uint64_t a1, uint64_t a2)
{
  const __CFSet *v2;
  uint64_t context;

  v2 = *(const __CFSet **)(a1 + 116496);
  if (v2)
  {
    context = a2;
    CFSetApplyFunction(v2, (CFSetApplierFunction)__lightsWithTechniqueEnumerator, &context);
  }
}

uint64_t C3DGetPovCategoryMask(uint64_t a1)
{
  const __CFDictionary *Camera;

  if (a1 && (Camera = C3DNodeGetCamera(a1)) != 0)
    return C3DCameraGetCategoryBitMask((uint64_t)Camera);
  else
    return -1;
}

uint64_t C3DEngineContextGetViewpointCoordinateSpace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1632);
}

uint64_t C3DEngineContextGetUpdateMainFramebuffer(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1724);
}

uint64_t C3DEngineContextGetEyeCount(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 212);
}

uint64_t C3DEngineContextGetDefaultPointOfView(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 40);
}

void C3DCullingContextSetupCullingMatricesAndPlanes(uint64_t a1, float32x2_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  unsigned __int8 *v9;
  unsigned int CoordinatesSystemOptions;
  unint64_t v11;
  uint64_t v12;
  simd_float4x4 *v13;
  simd_float4x4 *v14;
  uint64_t v15;
  int JitteringStep;
  uint64_t v17;
  simd_float4 *v18;
  simd_float4 v19;
  simd_float4 v20;
  simd_float4 v21;
  simd_float4 v22;
  int32x4_t *v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  float32x2_t TAAJitter;
  int8x16_t *v32;
  int8x16_t v33;
  int8x16_t v34;
  uint64_t v35;
  _OWORD *v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  simd_float4 v41;
  simd_float4 v42;
  simd_float4 v43;
  _OWORD *v44;
  int32x4_t v45;
  int32x4_t v46;
  int32x4_t v47;
  int32x4_t v48;
  uint64_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x2_t v52;
  float32x2_t v53;
  float32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  float32x2_t v57;
  float32x2_t v58;
  int32x4_t v59;
  float32x4_t v60;
  int32x4_t v61;
  float32x2_t v62;
  float32x2_t v63;
  float32x4_t v64;
  _OWORD *v65;
  int32x4_t v66;
  _OWORD *v67;
  unsigned __int32 v68;
  float32x2_t v69;
  float32x2_t v70;
  unsigned __int32 v71;
  unsigned __int32 v72;
  float32x2_t v73;
  float32x2_t v74;
  unint64_t v75;
  _BYTE *v76;
  int v77;
  uint64_t v78;
  int v79;
  NSObject *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  unint64_t v89;
  uint64_t v95;
  uint64_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  uint64_t v101;
  simd_float4 v102;
  simd_float4 v103;
  simd_float4 v104;
  simd_float4 *v105;
  simd_float4 v106;
  simd_float4 v107;
  simd_float4 v108;
  float v109;
  double v110;
  double v111;
  double v112;
  unsigned int v113;
  float32x4_t v114;
  float32x4_t v115;
  double v116;
  unsigned int v117;
  float32x4_t v118;
  float32_t v119;
  double v120;
  unsigned int v121;
  float32x4_t v122;
  simd_float4 v123;
  simd_float4 v124;
  simd_float4 v125;
  _OWORD *v126;
  int32x4_t v127;
  int32x4_t v128;
  int32x4_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  float32x4_t *v135;
  int32x4_t v136;
  int32x4_t v137;
  __int128 v138;
  __int128 v139;
  float32x4_t v140;
  int32x4_t v141;
  float32x2_t v142;
  float32x2_t v143;
  float v144;
  float v145;
  float32x4_t v146;
  float v147;
  float v148;
  float v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x2_t v152;
  float32x2_t v153;
  _OWORD *f32;
  int32x4_t v155;
  float32x4_t v156;
  int32x4_t v157;
  float32x2_t v158;
  float32x2_t v159;
  int32x4_t v160;
  float32x4_t v161;
  _OWORD *v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  _OWORD *v168;
  int32x4_t v169;
  float32x2_t v170;
  float32x2_t v171;
  unsigned __int32 v172;
  int32x4_t v173;
  float32x2_t v174;
  float32x2_t v175;
  unsigned int v176;
  int v177;
  _BOOL4 v178;
  uint64_t v179;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  simd_float4x4 v185;
  int32x4_t v186;
  int32x4_t v187;
  int32x4_t v188;
  int32x4_t v189;
  simd_float4x4 v190;

  v9 = (unsigned __int8 *)(a1 + 4628);
  CoordinatesSystemOptions = (unsigned __int16)C3DEngineContextGetCoordinatesSystemOptions((uint64_t)a2);
  v178 = v9[3] == 1 && v9[4] != 0;
  v179 = a4;
  if (*v9)
  {
    v11 = 0;
    do
    {
      if (v9[3] && !v9[4])
      {
        v15 = a1 + (v11 << 6);
        v13 = (simd_float4x4 *)(v15 + 2704);
        v14 = (simd_float4x4 *)(v15 + 3088);
      }
      else
      {
        v12 = a1 + (v11 << 6);
        v13 = (simd_float4x4 *)(v12 + 3088);
        v14 = (simd_float4x4 *)(v12 + 2704);
      }
      *v13 = __invert_f4(*v14);
      if (a5)
      {
        if (C3DEngineContextIsJitteringEnabled((uint64_t)a2))
        {
          JitteringStep = C3DEngineContextGetJitteringStep((uint64_t)a2);
          v183 = 0u;
          v184 = 0u;
          v181 = 0u;
          v182 = 0u;
          C3DEngineContextComputeJitterMatrix((uint64_t)a2, JitteringStep, &v181);
          v17 = 0;
          v18 = (simd_float4 *)(a1 + (v11 << 6));
          v19 = v18[217];
          v20 = v18[218];
          v21 = v18[219];
          v22 = v18[220];
          v23 = (int32x4_t *)&v18[217];
          v24 = v181;
          v25 = v182;
          v26 = v183;
          v27 = v184;
          v185.columns[0] = v19;
          v185.columns[1] = v20;
          v185.columns[2] = v21;
          v185.columns[3] = v22;
          v186 = 0u;
          v187 = 0u;
          v188 = 0u;
          v189 = 0u;
          do
          {
            *(float32x4_t *)((char *)&v186 + v17 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v24, COERCE_FLOAT(*(_OWORD *)&v185.columns[v17])), v25, *(float32x2_t *)v185.columns[v17].f32, 1), v26, (float32x4_t)v185.columns[v17], 2), v27, (float32x4_t)v185.columns[v17], 3);
            ++v17;
          }
          while (v17 != 4);
          v28 = v187;
          v29 = v188;
          v30 = v189;
          *v23 = v186;
          v23[1] = v28;
          v23[2] = v29;
          v23[3] = v30;
        }
        if (C3DEngineContextIsTemporalAntialiasingEnabled((uint64_t)a2))
        {
          TAAJitter = C3DEngineContextGetTAAJitter(a2, 0);
          v32 = (int8x16_t *)(a1 + (v11 << 6));
          v33 = v32[220];
          *(float32x2_t *)v34.i8 = vadd_f32(TAAJitter, *(float32x2_t *)v33.i8);
          v34.i64[1] = vextq_s8(v33, v33, 8uLL).u64[0];
          v32[220] = v34;
        }
      }
      v35 = 0;
      v36 = (_OWORD *)(a1 + (v11 << 6));
      v37 = *((float32x4_t *)v36 + 217);
      v38 = *((float32x4_t *)v36 + 218);
      v39 = *((float32x4_t *)v36 + 219);
      v40 = *((float32x4_t *)v36 + 220);
      v41 = *((simd_float4 *)v36 + 194);
      v42 = *((simd_float4 *)v36 + 195);
      v43 = *((simd_float4 *)v36 + 196);
      v185.columns[0] = (simd_float4)v36[193];
      v185.columns[1] = v41;
      v185.columns[2] = v42;
      v185.columns[3] = v43;
      v186 = 0u;
      v187 = 0u;
      v188 = 0u;
      v189 = 0u;
      do
      {
        *(float32x4_t *)((char *)&v186 + v35 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)&v185.columns[v35])), v38, *(float32x2_t *)v185.columns[v35].f32, 1), v39, (float32x4_t)v185.columns[v35], 2), v40, (float32x4_t)v185.columns[v35], 3);
        ++v35;
      }
      while (v35 != 4);
      v44 = (_OWORD *)(a1 + (v11 << 6));
      v45 = v186;
      v46 = v187;
      v48 = v188;
      v47 = v189;
      v44[241] = v186;
      v44[242] = v46;
      v44[243] = v48;
      v44[244] = v47;
      v49 = a1 + 96 * v11;
      v50.f32[0] = *(float *)&v45.i32[3] - *(float *)v45.i32;
      v50.f32[1] = *(float *)&v46.i32[3] - *(float *)v46.i32;
      v50.f32[2] = *(float *)&v48.i32[3] - *(float *)v48.i32;
      v50.f32[3] = *(float *)&v47.i32[3] - *(float *)v47.i32;
      v51 = vmulq_f32(v50, v50);
      v51.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v51, 2), vadd_f32(*(float32x2_t *)v51.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v51.f32, 1))).u32[0];
      v52 = vrsqrte_f32((float32x2_t)v51.u32[0]);
      v53 = vmul_f32(v52, vrsqrts_f32((float32x2_t)v51.u32[0], vmul_f32(v52, v52)));
      v54 = vmulq_n_f32(v50, vmul_f32(v53, vrsqrts_f32((float32x2_t)v51.u32[0], vmul_f32(v53, v53))).f32[0]);
      v51.f32[0] = *(float *)&v45.i32[3] + *(float *)v45.i32;
      v51.f32[1] = *(float *)&v46.i32[3] + *(float *)v46.i32;
      v51.f32[2] = *(float *)&v48.i32[3] + *(float *)v48.i32;
      v51.f32[3] = *(float *)&v47.i32[3] + *(float *)v47.i32;
      v55 = (int32x4_t)vmulq_f32(v51, v51);
      v55.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v55, 2), vadd_f32(*(float32x2_t *)v55.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v55.i8, 1))).u32[0];
      *(float32x4_t *)(v49 + 2128) = v54;
      *(float32x2_t *)v54.f32 = vrsqrte_f32((float32x2_t)v55.u32[0]);
      *(float32x2_t *)v54.f32 = vmul_f32(*(float32x2_t *)v54.f32, vrsqrts_f32((float32x2_t)v55.u32[0], vmul_f32(*(float32x2_t *)v54.f32, *(float32x2_t *)v54.f32)));
      *(float32x4_t *)(v49 + 2144) = vmulq_n_f32(v51, vmul_f32(*(float32x2_t *)v54.f32, vrsqrts_f32((float32x2_t)v55.u32[0], vmul_f32(*(float32x2_t *)v54.f32, *(float32x2_t *)v54.f32))).f32[0]);
      v51.f32[0] = *(float *)&v45.i32[3] + *(float *)&v45.i32[1];
      v51.f32[1] = *(float *)&v46.i32[3] + *(float *)&v46.i32[1];
      v51.f32[2] = *(float *)&v48.i32[3] + *(float *)&v48.i32[1];
      v51.f32[3] = *(float *)&v47.i32[3] + *(float *)&v47.i32[1];
      v56 = (int32x4_t)vmulq_f32(v51, v51);
      v56.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v56, 2), vadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v56.i8, 1))).u32[0];
      v57 = vrsqrte_f32((float32x2_t)v56.u32[0]);
      v58 = vmul_f32(v57, vrsqrts_f32((float32x2_t)v56.u32[0], vmul_f32(v57, v57)));
      v54.f32[0] = *(float *)&v45.i32[3] - *(float *)&v45.i32[1];
      v54.f32[1] = *(float *)&v46.i32[3] - *(float *)&v46.i32[1];
      v54.f32[2] = *(float *)&v48.i32[3] - *(float *)&v48.i32[1];
      v54.f32[3] = *(float *)&v47.i32[3] - *(float *)&v47.i32[1];
      v59 = (int32x4_t)vmulq_f32(v54, v54);
      v59.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v59, 2), vadd_f32(*(float32x2_t *)v59.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v59.i8, 1))).u32[0];
      *(float32x4_t *)(v49 + 2160) = vmulq_n_f32(v51, vmul_f32(v58, vrsqrts_f32((float32x2_t)v56.u32[0], vmul_f32(v58, v58))).f32[0]);
      *(float32x2_t *)v51.f32 = vrsqrte_f32((float32x2_t)v59.u32[0]);
      *(float32x2_t *)v51.f32 = vmul_f32(*(float32x2_t *)v51.f32, vrsqrts_f32((float32x2_t)v59.u32[0], vmul_f32(*(float32x2_t *)v51.f32, *(float32x2_t *)v51.f32)));
      *(float32x4_t *)(v49 + 2176) = vmulq_n_f32(v54, vmul_f32(*(float32x2_t *)v51.f32, vrsqrts_f32((float32x2_t)v59.u32[0], vmul_f32(*(float32x2_t *)v51.f32, *(float32x2_t *)v51.f32))).f32[0]);
      v60.f32[0] = *(float *)&v45.i32[3] - *(float *)&v45.i32[2];
      v60.f32[1] = *(float *)&v46.i32[3] - *(float *)&v46.i32[2];
      v60.f32[2] = *(float *)&v48.i32[3] - *(float *)&v48.i32[2];
      v60.f32[3] = *(float *)&v47.i32[3] - *(float *)&v47.i32[2];
      v61 = (int32x4_t)vmulq_f32(v60, v60);
      v61.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v61, 2), vadd_f32(*(float32x2_t *)v61.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v61.i8, 1))).u32[0];
      v62 = vrsqrte_f32((float32x2_t)v61.u32[0]);
      v63 = vmul_f32(v62, vrsqrts_f32((float32x2_t)v61.u32[0], vmul_f32(v62, v62)));
      *(float32x4_t *)(v49 + 2192) = vmulq_n_f32(v60, vmul_f32(v63, vrsqrts_f32((float32x2_t)v61.u32[0], vmul_f32(v63, v63))).f32[0]);
      if ((CoordinatesSystemOptions & 1) != 0)
      {
        v64.i64[0] = vzip2q_s32(v45, v46).u64[0];
        v64.i64[1] = __PAIR64__(v47.u32[2], v48.u32[2]);
      }
      else
      {
        v64.f32[0] = *(float *)&v45.i32[3] + *(float *)&v45.i32[2];
        v64.f32[1] = *(float *)&v46.i32[3] + *(float *)&v46.i32[2];
        v64.f32[2] = *(float *)&v48.i32[3] + *(float *)&v48.i32[2];
        v64.f32[3] = *(float *)&v47.i32[3] + *(float *)&v47.i32[2];
      }
      v65 = (_OWORD *)(v49 + 2208);
      v66 = (int32x4_t)vmulq_f32(v64, v64);
      if ((CoordinatesSystemOptions & 8) != 0)
      {
        v67 = (_OWORD *)(v49 + 2192);
        *v65 = *v67;
        v68 = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v66, 2), vadd_f32(*(float32x2_t *)v66.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v66.i8, 1))).u32[0];
        v69 = vrsqrte_f32((float32x2_t)v68);
        v70 = vmul_f32(v69, vrsqrts_f32((float32x2_t)v68, vmul_f32(v69, v69)));
        v71 = vmul_f32(v70, vrsqrts_f32((float32x2_t)v68, vmul_f32(v70, v70))).u32[0];
        v65 = v67;
      }
      else
      {
        v72 = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v66, 2), vadd_f32(*(float32x2_t *)v66.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v66.i8, 1))).u32[0];
        v73 = vrsqrte_f32((float32x2_t)v72);
        v74 = vmul_f32(v73, vrsqrts_f32((float32x2_t)v72, vmul_f32(v73, v73)));
        v71 = vmul_f32(v74, vrsqrts_f32((float32x2_t)v72, vmul_f32(v74, v74))).u32[0];
      }
      *v65 = vmulq_n_f32(v64, *(float *)&v71);
      ++v11;
      v75 = *v9;
    }
    while (v11 < v75);
    v77 = v9[68];
    v76 = v9 + 68;
    v78 = a3;
    if (v77)
    {
      if ((_DWORD)v75 == 2)
      {
LABEL_33:
        LODWORD(v75) = 1;
        *(_DWORD *)(a1 + 4624) = 1;
        v88 = *v76;
        goto LABEL_39;
      }
LABEL_30:
      v80 = scn_default_log();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
        C3DCullingContextSetupCullingMatricesAndPlanes_cold_1(v80, v81, v82, v83, v84, v85, v86, v87);
      v78 = a3;
      goto LABEL_33;
    }
  }
  else
  {
    v79 = v9[68];
    v76 = v9 + 68;
    LODWORD(v75) = v79;
    if (v79)
      goto LABEL_30;
    v78 = a3;
  }
  v88 = v178;
  if (v178)
  {
    v88 = 0;
    LODWORD(v75) = 1;
  }
  *(_DWORD *)(a1 + 4624) = v75;
LABEL_39:
  if ((_DWORD)v75 + v88)
  {
    v89 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    v176 = HIDWORD(_Q0);
    v177 = (CoordinatesSystemOptions >> 3) & 1;
    do
    {
      if (v78 == a4)
      {
        if (!v178)
        {
          v162 = (_OWORD *)(a1 + (v89 << 6));
          v163 = v162[194];
          v162[61] = v162[193];
          v162[62] = v163;
          v164 = v162[196];
          v162[63] = v162[195];
          v162[64] = v164;
          v162[85] = v162[217];
          v162[86] = v162[218];
          v162[87] = v162[219];
          v162[88] = v162[220];
          v165 = v162[241];
          v166 = v162[242];
          v167 = v162[243];
          v162[112] = v162[244];
          v162[111] = v167;
          v162[110] = v166;
          v162[109] = v165;
          goto LABEL_52;
        }
        v101 = 0;
        v102 = *(simd_float4 *)(a1 + 3024);
        v103 = *(simd_float4 *)(a1 + 3040);
        v104 = *(simd_float4 *)(a1 + 3072);
        v105 = (simd_float4 *)(a1 + (v89 << 6));
        v105[39] = *(simd_float4 *)(a1 + 3056);
        v105[40] = v104;
        v105[37] = v102;
        v105[38] = v103;
        v106 = *(simd_float4 *)(a1 + 3456);
        v108 = *(simd_float4 *)(a1 + 3408);
        v107 = *(simd_float4 *)(a1 + 3424);
        v105[63] = *(simd_float4 *)(a1 + 3440);
        v105[64] = v106;
        v105[61] = v108;
        v105[62] = v107;
        v109 = *(double *)(a1 + 4752);
        v110 = (float)-v109;
        v111 = v109;
        if (v109 > 0.0)
          v112 = v109;
        else
          v112 = v110 + 1.0;
        *(float *)&v113 = 2.0 / (v111 - v110);
        v114 = (float32x4_t)v113;
        v115.i32[0] = 0;
        v115.i64[1] = 0;
        v115.i32[1] = v113;
        v116 = v110 - v112;
        *(float *)&v117 = 1.0 / (v110 - v112);
        v118.i64[0] = 0;
        v118.i64[1] = v117;
        v119 = -(v110 + v111) / (v111 - v110);
        v120 = v110 / v116;
        v122.f32[0] = v119;
        v122.f32[1] = v119;
        *(float *)&v121 = v120;
        v122.i64[1] = __PAIR64__(v176, v121);
        v105[85] = (simd_float4)v114.u32[0];
        v105[86] = (simd_float4)v115.u64[0];
        v105[87] = (simd_float4)v118;
        v105[88] = (simd_float4)v122;
        v123 = v105[62];
        v124 = v105[63];
        v125 = v105[64];
        v185.columns[0] = v105[61];
        v185.columns[1] = v123;
        v185.columns[2] = v124;
        v185.columns[3] = v125;
        v186 = 0u;
        v187 = 0u;
        v188 = 0u;
        v189 = 0u;
        do
        {
          *(float32x4_t *)((char *)&v186 + v101 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v114, COERCE_FLOAT(*(_OWORD *)&v185.columns[v101])), v115, *(float32x2_t *)v185.columns[v101].f32, 1), v118, (float32x4_t)v185.columns[v101], 2), v122, (float32x4_t)v185.columns[v101], 3);
          ++v101;
        }
        while (v101 != 4);
      }
      else
      {
        v95 = a1 + (v89 << 6);
        v190 = __invert_f4(*(simd_float4x4 *)(v95 + 592));
        v96 = 0;
        *(simd_float4x4 *)(v95 + 976) = v190;
        v97 = *(float32x4_t *)(v95 + 1360);
        v98 = *(float32x4_t *)(v95 + 1376);
        v99 = *(float32x4_t *)(v95 + 1392);
        v100 = *(float32x4_t *)(v95 + 1408);
        v185 = v190;
        v186 = 0u;
        v187 = 0u;
        v188 = 0u;
        v189 = 0u;
        do
        {
          *(float32x4_t *)((char *)&v186 + v96 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v97, COERCE_FLOAT(*(_OWORD *)&v185.columns[v96])), v98, *(float32x2_t *)v185.columns[v96].f32, 1), v99, (float32x4_t)v185.columns[v96], 2), v100, (float32x4_t)v185.columns[v96], 3);
          ++v96;
        }
        while (v96 != 4);
      }
      v126 = (_OWORD *)(a1 + (v89 << 6));
      v127 = v187;
      v128 = v188;
      v129 = v189;
      v126[109] = v186;
      v126[110] = v127;
      v126[111] = v128;
      v126[112] = v129;
LABEL_52:
      if (*v76)
      {
        if (v89)
        {
          v130 = a1 + 3856 + ((v89 - 1) << 6);
          v131 = a1 + 96 * (v89 - 1);
          scn_frustum_extract_from_twos_viewProjs(v131 + 2128, CoordinatesSystemOptions & 1, v177, *(float32x4_t *)v130, *(__n128 *)(v130 + 16), *(__n128 *)(v130 + 32), *(__n128 *)(v130 + 48), *(__n128 *)(a1 + 3856 + (v89 << 6)), *(__n128 *)(a1 + 3856 + (v89 << 6) + 16), *(__n128 *)(a1 + 3856 + (v89 << 6) + 32), *(__n128 *)(a1 + 3856 + (v89 << 6) + 48));
          v132 = a1 + 1744 + ((v89 - 1) << 6);
          v133 = v131 + 16;
          a4 = v179;
          v78 = a3;
          scn_frustum_extract_from_twos_viewProjs(v133, CoordinatesSystemOptions & 1, v177, *(float32x4_t *)v132, *(__n128 *)(v132 + 16), *(__n128 *)(v132 + 32), *(__n128 *)(v132 + 48), *(__n128 *)(a1 + 1744 + (v89 << 6)), *(__n128 *)(a1 + 1744 + (v89 << 6) + 16), *(__n128 *)(a1 + 1744 + (v89 << 6) + 32), *(__n128 *)(a1 + 1744 + (v89 << 6) + 48));
        }
      }
      else
      {
        v134 = a1 + (v89 << 6);
        v135 = (float32x4_t *)(a1 + 96 * v89);
        v136 = *(int32x4_t *)(v134 + 1744);
        v137 = *(int32x4_t *)(v134 + 1760);
        v138 = *(_OWORD *)(v134 + 1776);
        v139 = *(_OWORD *)(v134 + 1792);
        v140.f32[0] = *(float *)&v136.i32[3] - *(float *)v136.i32;
        v140.f32[1] = *(float *)&v137.i32[3] - *(float *)v137.i32;
        v140.f32[2] = *((float *)&v138 + 3) - *(float *)&v138;
        v140.f32[3] = *((float *)&v139 + 3) - *(float *)&v139;
        v141 = (int32x4_t)vmulq_f32(v140, v140);
        v141.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v141, 2), vadd_f32(*(float32x2_t *)v141.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v141.i8, 1))).u32[0];
        v142 = vrsqrte_f32((float32x2_t)v141.u32[0]);
        v143 = vmul_f32(v142, vrsqrts_f32((float32x2_t)v141.u32[0], vmul_f32(v142, v142)));
        LODWORD(v144) = vmul_f32(v143, vrsqrts_f32((float32x2_t)v141.u32[0], vmul_f32(v143, v143))).u32[0];
        v145 = COERCE_FLOAT(*(_QWORD *)(v134 + 1752));
        v146.f32[0] = *(float *)&v136.i32[3] - v145;
        v147 = COERCE_FLOAT(*(_QWORD *)(v134 + 1768));
        v148 = COERCE_FLOAT(*(_QWORD *)(v134 + 1784));
        v149 = COERCE_FLOAT(*(_QWORD *)(v134 + 1800));
        v146.f32[1] = *(float *)&v137.i32[3] - v147;
        v146.f32[2] = *((float *)&v138 + 3) - v148;
        v146.f32[3] = *((float *)&v139 + 3) - v149;
        v150 = vmulq_f32(v146, v146);
        v150.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v150, 2), vadd_f32(*(float32x2_t *)v150.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v150.f32, 1))).u32[0];
        v151 = vmulq_n_f32(v140, v144);
        v152 = vrsqrte_f32((float32x2_t)v150.u32[0]);
        v153 = vmul_f32(v152, vrsqrts_f32((float32x2_t)v150.u32[0], vmul_f32(v152, v152)));
        v135[5] = vmulq_n_f32(v146, vmul_f32(v153, vrsqrts_f32((float32x2_t)v150.u32[0], vmul_f32(v153, v153))).f32[0]);
        f32 = (_OWORD *)v135[5].f32;
        *(f32 - 4) = v151;
        v151.f32[0] = *(float *)&v136.i32[3] + *(float *)v136.i32;
        v151.f32[1] = *(float *)&v137.i32[3] + *(float *)v137.i32;
        v151.f32[2] = *((float *)&v138 + 3) + *(float *)&v138;
        v151.f32[3] = *((float *)&v139 + 3) + *(float *)&v139;
        v155 = (int32x4_t)vmulq_f32(v151, v151);
        v155.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v155, 2), vadd_f32(*(float32x2_t *)v155.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v155.i8, 1))).u32[0];
        *(float32x2_t *)v146.f32 = vrsqrte_f32((float32x2_t)v155.u32[0]);
        *(float32x2_t *)v146.f32 = vmul_f32(*(float32x2_t *)v146.f32, vrsqrts_f32((float32x2_t)v155.u32[0], vmul_f32(*(float32x2_t *)v146.f32, *(float32x2_t *)v146.f32)));
        v150.f32[0] = *(float *)&v136.i32[3] + *(float *)&v136.i32[1];
        v150.f32[1] = *(float *)&v137.i32[3] + *(float *)&v137.i32[1];
        v150.f32[2] = *((float *)&v138 + 3) + *((float *)&v138 + 1);
        v150.f32[3] = *((float *)&v139 + 3) + *((float *)&v139 + 1);
        v156 = vmulq_n_f32(v151, vmul_f32(*(float32x2_t *)v146.f32, vrsqrts_f32((float32x2_t)v155.u32[0], vmul_f32(*(float32x2_t *)v146.f32, *(float32x2_t *)v146.f32))).f32[0]);
        v157 = (int32x4_t)vmulq_f32(v150, v150);
        v157.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v157, 2), vadd_f32(*(float32x2_t *)v157.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v157.i8, 1))).u32[0];
        v158 = vrsqrte_f32((float32x2_t)v157.u32[0]);
        v159 = vmul_f32(v158, vrsqrts_f32((float32x2_t)v157.u32[0], vmul_f32(v158, v158)));
        *(f32 - 3) = v156;
        *(f32 - 2) = vmulq_n_f32(v150, vmul_f32(v159, vrsqrts_f32((float32x2_t)v157.u32[0], vmul_f32(v159, v159))).f32[0]);
        v156.f32[0] = *(float *)&v136.i32[3] - *(float *)&v136.i32[1];
        v156.f32[1] = *(float *)&v137.i32[3] - *(float *)&v137.i32[1];
        v156.f32[2] = *((float *)&v138 + 3) - *((float *)&v138 + 1);
        v156.f32[3] = *((float *)&v139 + 3) - *((float *)&v139 + 1);
        v160 = (int32x4_t)vmulq_f32(v156, v156);
        v160.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v160, 2), vadd_f32(*(float32x2_t *)v160.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v160.i8, 1))).u32[0];
        *(float32x2_t *)v146.f32 = vrsqrte_f32((float32x2_t)v160.u32[0]);
        *(float32x2_t *)v146.f32 = vmul_f32(*(float32x2_t *)v146.f32, vrsqrts_f32((float32x2_t)v160.u32[0], vmul_f32(*(float32x2_t *)v146.f32, *(float32x2_t *)v146.f32)));
        *(f32 - 1) = vmulq_n_f32(v156, vmul_f32(*(float32x2_t *)v146.f32, vrsqrts_f32((float32x2_t)v160.u32[0], vmul_f32(*(float32x2_t *)v146.f32, *(float32x2_t *)v146.f32))).f32[0]);
        if ((CoordinatesSystemOptions & 1) != 0)
        {
          v161.i64[0] = vzip2q_s32(v136, v137).u64[0];
          v161.i64[1] = __PAIR64__(DWORD2(v139), DWORD2(v138));
        }
        else
        {
          v161.f32[0] = *(float *)&v136.i32[3] + v145;
          v161.f32[1] = *(float *)&v137.i32[3] + v147;
          v161.f32[2] = *((float *)&v138 + 3) + v148;
          v161.f32[3] = *((float *)&v139 + 3) + v149;
        }
        v168 = f32 + 1;
        if ((CoordinatesSystemOptions & 8) != 0)
        {
          *v168 = *f32;
          v169 = (int32x4_t)vmulq_f32(v161, v161);
          v169.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v169, 2), vadd_f32(*(float32x2_t *)v169.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v169.i8, 1))).u32[0];
          v170 = vrsqrte_f32((float32x2_t)v169.u32[0]);
          v171 = vmul_f32(v170, vrsqrts_f32((float32x2_t)v169.u32[0], vmul_f32(v170, v170)));
          v172 = vmul_f32(v171, vrsqrts_f32((float32x2_t)v169.u32[0], vmul_f32(v171, v171))).u32[0];
          v168 = f32;
        }
        else
        {
          v173 = (int32x4_t)vmulq_f32(v161, v161);
          v173.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v173, 2), vadd_f32(*(float32x2_t *)v173.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v173.i8, 1))).u32[0];
          v174 = vrsqrte_f32((float32x2_t)v173.u32[0]);
          v175 = vmul_f32(v174, vrsqrts_f32((float32x2_t)v173.u32[0], vmul_f32(v174, v174)));
          v172 = vmul_f32(v175, vrsqrts_f32((float32x2_t)v173.u32[0], vmul_f32(v175, v175))).u32[0];
        }
        *v168 = vmulq_n_f32(v161, *(float *)&v172);
      }
      ++v89;
    }
    while (v89 < *(_DWORD *)(a1 + 4624) + *v76);
  }
}

float C3DCameraGetWhitePoint(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 384);
}

uint64_t C3DCameraGetWantsExposureAdaptation(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(unsigned __int8 *)(a1 + 312) >> 2) & 1;
}

float C3DCameraGetVignettingIntensity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 480);
}

float C3DCameraGetSensorSize(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 300);
}

uint64_t C3DCameraGetScreenSpaceAmbientOcclusionSampleCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 512);
}

float C3DCameraGetScreenSpaceAmbientOcclusionRadius(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 496);
}

float C3DCameraGetScreenSpaceAmbientOcclusionNormalThreshold(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 508);
}

uint64_t C3DCameraGetScreenSpaceAmbientOcclusionDownSample(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 516);
}

float C3DCameraGetScreenSpaceAmbientOcclusionDepthThreshold(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 504);
}

float C3DCameraGetScreenSpaceAmbientOcclusionBias(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 500);
}

double C3DCameraGetPostProjectionTransformTranslation(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(double *)(a1 + 96);
}

double C3DCameraGetPostProjectionTransformScale(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(double *)(a1 + 104);
}

float C3DCameraGetMinimumExposure(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 416);
}

float C3DCameraGetMaximumExposure(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 420);
}

double C3DCameraGetLensShift(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(double *)(a1 + 88);
}

float C3DCameraGetGrainScale(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 468);
}

uint64_t C3DCameraGetFovIsHorizontal(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return (*(unsigned __int8 *)(a1 + 64) >> 5) & 1;
}

float C3DCameraGetFov(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 120);
}

float C3DCameraGetFocusDistance(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 288);
}

float C3DCameraGetFocalLength(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 292);
}

float C3DCameraGetFStop(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 296);
}

float C3DCameraGetExposureOffset(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 392);
}

uint64_t C3DCameraGetExposureAdaptationMode(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 313);
}

float C3DCameraGetExposureAdaptationHistogramRangeLowProbability(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 412);
}

float C3DCameraGetExposureAdaptationHistogramRangeHighProbability(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 408);
}

float C3DCameraGetExposureAdaptationDuration(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 396);
}

float C3DCameraGetExposureAdaptationDarkeningSpeedFactor(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 404);
}

float C3DCameraGetExposureAdaptationBrighteningSpeedFactor(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 400);
}

uint64_t C3DCameraGetDofSampleCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 308);
}

uint64_t C3DCameraGetColorGradingEffectSlot(uint64_t a1, int a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 520);
  if (a2)
  {
    if (!result)
    {
      result = C3DEffectSlotCreate(a1, 26);
      *(_QWORD *)(a1 + 520) = result;
    }
  }
  return result;
}

float C3DCameraGetColorFringeIntensity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 444);
}

float C3DCameraGetBloomThreshold(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 428);
}

float C3DCameraGetBloomIntensity(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 424);
}

float C3DCameraGetBloomBlurRadius(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 440);
}

uint64_t C3DCameraGetBladeCount(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 304);
}

float C3DCameraGetAverageGray(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 388);
}

float C3DCameraGetAspectRatio(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(double *)(a1 + 128);
}

float C3DCameraGetARGrainSlice(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DCameraNeedsPostProcess_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(float *)(a1 + 552);
}

void __scn_default_log_block_invoke()
{
  NSObject *v0;

  scn_default_log_logger = (uint64_t)os_log_create("com.apple.scenekit", "SceneKit");
  if (C3DPreferencesGetBool(17))
  {
    v0 = scn_default_log_logger;
    if (os_log_type_enabled((os_log_t)scn_default_log_logger, OS_LOG_TYPE_DEBUG))
      __scn_default_log_block_invoke_cold_1(v0);
  }
}

void _C3DIndexStoreCFFinalize(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v4 = *(const void **)(a1 + 48);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 48) = 0;
  }
  free(*(void **)(a1 + 64));
}

uint64_t C3DBlendStatesCreate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int8x16_t v5;
  int v6;
  __int8 *v7;
  _QWORD *v8;
  int8x16_t v9;
  int8x16_t v10;

  if (C3DBlendStatesGetTypeID_onceToken != -1)
    dispatch_once(&C3DBlendStatesGetTypeID_onceToken, &__block_literal_global_141);
  result = C3DTypeCreateInstance_(C3DBlendStatesGetTypeID_typeID, 0x30uLL);
  if (a2 > 3)
    return 0;
  *(_QWORD *)(result + 48) = a2;
  if (a2 < 1)
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    v6 = 0;
    v7 = (__int8 *)(a1 + 2);
    v8 = (_QWORD *)(result + 16);
    do
    {
      *v8 = *(_QWORD *)(v7 - 2);
      if (*(v7 - 2))
      {
        v5.i8[0] = *v7;
        v5.i8[4] = v7[1];
        v9 = v5;
        v9.i8[1] = v5.i8[4];
        v9.i8[8] = *v7;
        v9.i8[9] = v5.i8[4];
        *(int8x8_t *)v5.i8 = vceq_s8(vqtbl1_s8(v9, (int8x8_t)0x101000000000101), (int8x8_t)0xB0D0A0C0B0D0A0CLL);
        v5.i8[0] = vmaxv_u8(*(uint8x8_t *)v5.i8);
        v6 |= v5.i32[0];
        if (*(v7 - 1))
        {
          v5.i8[0] = v7[3];
          v5.i8[4] = v7[4];
          v10 = v5;
          v10.i8[1] = v5.i8[4];
          v10.i8[8] = v5.i8[0];
          v10.i8[9] = v5.i8[4];
          *(int8x8_t *)v5.i8 = vceq_s8(vqtbl1_s8(v10, (int8x8_t)0x101000000000101), (int8x8_t)0xB0D0A0C0B0D0A0CLL);
          v5.i8[0] = vmaxv_u8(*(uint8x8_t *)v5.i8);
          v6 |= v5.i32[0];
        }
      }
      v7 += 8;
      ++v8;
      --a2;
    }
    while (a2);
  }
  *(_BYTE *)(result + 56) = v6 & 1;
  return result;
}

uint64_t C3DShaderModifierGetArguments(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DShaderModifierGetDeclaration_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 56);
}

SCNMatrix4 *__cdecl SCNMatrix4Mult(SCNMatrix4 *__return_ptr retstr, SCNMatrix4 *a, SCNMatrix4 *b)
{
  __int128 v4;
  __int128 v5;
  float32x4_t v6;
  float32x4_t v7;
  SCNMatrix4 *result;
  __int128 v9;
  __int128 v10;
  float32x4_t v11[4];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  *(_OWORD *)&retstr->m31 = 0u;
  *(_OWORD *)&retstr->m41 = 0u;
  *(_OWORD *)&retstr->m11 = 0u;
  *(_OWORD *)&retstr->m21 = 0u;
  v4 = *(_OWORD *)&a->m21;
  v12 = *(_OWORD *)&a->m11;
  v13 = v4;
  v5 = *(_OWORD *)&a->m41;
  v14 = *(_OWORD *)&a->m31;
  v15 = v5;
  v6 = *(float32x4_t *)&b->m21;
  v11[0] = *(float32x4_t *)&b->m11;
  v11[1] = v6;
  v7 = *(float32x4_t *)&b->m41;
  v11[2] = *(float32x4_t *)&b->m31;
  v11[3] = v7;
  C3DMatrix4x4Mult((uint64_t)&v12, v11, &v12);
  v9 = v13;
  *(_OWORD *)&retstr->m11 = v12;
  *(_OWORD *)&retstr->m21 = v9;
  v10 = v15;
  *(_OWORD *)&retstr->m31 = v14;
  *(_OWORD *)&retstr->m41 = v10;
  return result;
}

double C3DMatrix4x4Mult(uint64_t a1, float32x4_t *a2, _OWORD *a3)
{
  uint64_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  __int128 v8;
  double result;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _OWORD v13[4];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;

  v3 = 0;
  v4 = *a2;
  v5 = a2[1];
  v6 = a2[2];
  v7 = a2[3];
  v8 = *(_OWORD *)(a1 + 48);
  v13[2] = *(_OWORD *)(a1 + 32);
  v13[3] = v8;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  do
  {
    *(__int128 *)((char *)&v14 + v3 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v4, COERCE_FLOAT(v13[v3])), v5, *(float32x2_t *)&v13[v3], 1), v6, (float32x4_t)v13[v3], 2), v7, (float32x4_t)v13[v3], 3);
    ++v3;
  }
  while (v3 != 4);
  result = *(double *)&v14;
  v10 = v15;
  v11 = v16;
  v12 = v17;
  *a3 = v14;
  a3[1] = v10;
  a3[2] = v11;
  a3[3] = v12;
  return result;
}

uint64_t C3DNotificationCenterCreate()
{
  uint64_t Instance;
  pthread_mutexattr_t v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (C3DNotificationCenterGetTypeID_onceToken != -1)
    dispatch_once(&C3DNotificationCenterGetTypeID_onceToken, &__block_literal_global_107);
  Instance = C3DTypeCreateInstance_(C3DNotificationCenterGetTypeID_typeID, 0x48uLL);
  *(_QWORD *)(Instance + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v2.__sig = 0;
  *(_QWORD *)v2.__opaque = 0;
  pthread_mutexattr_init(&v2);
  pthread_mutexattr_settype(&v2, 2);
  pthread_mutex_init((pthread_mutex_t *)(Instance + 24), &v2);
  pthread_mutexattr_destroy(&v2);
  return Instance;
}

void C3DEntitySetShaderModifiers(CFTypeRef *a1, const __CFDictionary *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeID v12;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEntityRemoveAllAnimations_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  _C3DEntitySetAttribute(a1, CFSTR("kShaderModifiers"), a2, 1);
  v12 = CFGetTypeID(a1);
  if (CFTypeIsC3DGeometry(v12))
  {
    _C3DGeometryShadingDidUpdate(a1);
  }
  else if (v12 == C3DMaterialGetTypeID())
  {
    _C3DMaterialShadingDidUpdate(a1);
  }
}

void _C3DMaterialShadingDidUpdate(_QWORD *a1)
{
  uint64_t v2;

  v2 = C3DGetScene(a1);
  C3DScenePostPipelineEvent(v2, 3, a1, 0);
  C3DMaterialTouchValueStorageModificationCount((uint64_t)a1);
}

void ___ZN16CPP3DAudioEngine9GetEngineEv_block_invoke()
{
  CPP3DAudioEngine *v0;

  v0 = (CPP3DAudioEngine *)operator new();
  CPP3DAudioEngine::CPP3DAudioEngine(v0);
  gCPP3DAudioEngineInstance = (uint64_t)v0;
}

void sub_1DCD23BE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1DF0D41C0](v1, 0x10A0C40AC8DBCBCLL);
  _Unwind_Resume(a1);
}

void CPP3DAudioEngine::CPP3DAudioEngine(CPP3DAudioEngine *this)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 2) = (char *)this + 24;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 5) = (char *)this + 48;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 1) = objc_alloc_init(MEMORY[0x1E0CB38E0]);
}

void sub_1DCD23C70(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD **v3;
  _QWORD **v4;

  std::__tree<char>::destroy(v2, *v4);
  std::__tree<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::__map_value_compare<__C3DScene *,std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>,std::less<__C3DScene *>,true>,std::allocator<std::__value_type<__C3DScene *,std::map<__C3DEngineContext *,CPP3DAudioContext *>>>>::destroy(v1, *v3);
  _Unwind_Resume(a1);
}

void _C3DFramebufferRegistryCFFinalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;

  v2 = (const void *)a1[6];
  if (v2)
  {
    CFRelease(v2);
    a1[6] = 0;
  }
  v3 = (const void *)a1[2];
  if (v3)
  {
    CFRelease(v3);
    a1[2] = 0;
  }
  v4 = (const void *)a1[3];
  if (v4)
  {
    CFRelease(v4);
    a1[3] = 0;
  }
  v5 = (const void *)a1[7];
  if (v5)
  {
    CFRelease(v5);
    a1[7] = 0;
  }
  v6 = (const void *)a1[9];
  if (v6)
  {
    CFRelease(v6);
    a1[9] = 0;
  }
  v7 = (const void *)a1[4];
  if (v7)
  {
    CFRelease(v7);
    a1[4] = 0;
  }
}

void C3DEngineContextSetupWithScene(const void *a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t SharedInstance;
  uint64_t v21;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  C3DEngineContextSetScene((uint64_t)a1, a2);
  if (a2)
  {
    if (!C3DSceneGetRootNode((uint64_t)a2))
    {
      v12 = scn_default_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
        _C3DAnimationManagerGetAnimationPerKeyDictionaryForObject_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
    }
    C3DFXInvalidatePasses((uint64_t)a1);
    SharedInstance = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterAddObserver(SharedInstance, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))_C3DEngineContextInvalidatePasses, CFSTR("kC3DNotificationEngineContextInvalidatePasses"), a2, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  else
  {
    v21 = C3DNotificationCenterGetSharedInstance();
    C3DNotificationCenterRemoveObserver(v21, a1, CFSTR("kC3DNotificationEngineContextInvalidatePasses"), 0);
  }
  _setupRendererContextWithSceneOptions((uint64_t)a1);
}

void _setupRendererContextWithSceneOptions(uint64_t a1)
{
  uint64_t Scene;
  uint64_t RendererContextGL;
  uint64_t v4;
  const void *Attribute;

  Scene = C3DEngineContextGetScene(a1);
  RendererContextGL = C3DEngineContextGetRendererContextGL(a1);
  if (Scene)
  {
    v4 = RendererContextGL;
    if (RendererContextGL)
    {
      Attribute = (const void *)C3DSceneGetAttribute(Scene, CFSTR("triggerOptionsForRealtimeViewer"));
      if (!Attribute)
        Attribute = (const void *)*MEMORY[0x1E0C9AE40];
      if (CFEqual(Attribute, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
        C3DRendererContextSetMaxTextureSize(v4, COERCE_DOUBLE(vdup_n_s32(0x44800000u)));
    }
  }
}

uint64_t C3DFXInvalidatePasses(uint64_t a1)
{
  uint64_t result;

  result = C3DEngineContextGetFXContext(a1);
  if (result)
    *(_BYTE *)(result + 121) &= ~1u;
  return result;
}

uint64_t C3DCameraCreate()
{
  uint64_t Instance;
  char v1;
  int v7;
  float v8;
  __int128 *Identity;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  char v13;

  if (C3DCameraGetTypeID_onceToken != -1)
    dispatch_once(&C3DCameraGetTypeID_onceToken, &__block_literal_global_61);
  Instance = C3DTypeCreateInstance_(C3DCameraGetTypeID_typeID, 0x220uLL);
  if (C3DWasLinkedBeforeMajorOSYear2017())
    v1 = 16;
  else
    v1 = 0;
  *(_BYTE *)(Instance + 64) = *(_BYTE *)(Instance + 64) & 0xEF | v1;
  *(_QWORD *)(Instance + 272) = 0;
  *(_QWORD *)(Instance + 280) = 0;
  *(_DWORD *)(Instance + 120) = 1114636288;
  *(_QWORD *)(Instance + 128) = 0x3FF8000000000000;
  *(_OWORD *)(Instance + 72) = xmmword_1DD02A430;
  *(_QWORD *)(Instance + 112) = 0x3FF0000000000000;
  *(_QWORD *)(Instance + 96) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(Instance + 104) = _D0;
  *(_DWORD *)(Instance + 448) = 0;
  *(_DWORD *)(Instance + 292) = 1112014848;
  *(_QWORD *)(Instance + 296) = 0x41C0000040B33333;
  *(_QWORD *)(Instance + 304) = 0x1900000006;
  v7 = C3DWasLinkedBeforeMajorOSYear2017();
  v8 = 2.5;
  if (v7)
    v8 = 10.0;
  *(float *)(Instance + 288) = v8;
  *(_QWORD *)(Instance + 528) = -1;
  *(_BYTE *)(Instance + 312) &= ~1u;
  Identity = (__int128 *)C3DMatrix4x4GetIdentity();
  v10 = *Identity;
  v11 = Identity[1];
  v12 = Identity[3];
  *(_OWORD *)(Instance + 352) = Identity[2];
  *(_OWORD *)(Instance + 368) = v12;
  *(_OWORD *)(Instance + 320) = v10;
  *(_OWORD *)(Instance + 336) = v11;
  v13 = *(_BYTE *)(Instance + 312);
  *(_OWORD *)(Instance + 384) = xmmword_1DD02A680;
  *(_OWORD *)(Instance + 400) = xmmword_1DD02A690;
  *(_BYTE *)(Instance + 313) = 0;
  *(_OWORD *)(Instance + 416) = xmmword_1DD02A6A0;
  *(_QWORD *)(Instance + 432) = 1;
  *(_QWORD *)(Instance + 440) = 0x3F80000040800000;
  *(_BYTE *)(Instance + 312) = v13 & 0xE9 | 4;
  *(_QWORD *)(Instance + 544) = 0;
  *(_DWORD *)(Instance + 552) = 0;
  *(_OWORD *)(Instance + 452) = xmmword_1DD007920;
  *(_OWORD *)(Instance + 468) = xmmword_1DD007880;
  *(_OWORD *)(Instance + 484) = xmmword_1DD02A6B0;
  *(_DWORD *)(Instance + 500) = 1022739087;
  *(_QWORD *)(Instance + 504) = 0x3E99999A3E4CCCCDLL;
  *(_QWORD *)(Instance + 512) = 0x200000009;
  return Instance;
}

uint64_t C3DMatrix4x4GetIdentity()
{
  return MEMORY[0x1E0C83FF0];
}

uint64_t C3DResourceCacheCreate()
{
  uint64_t Instance;
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const CFDictionaryKeyCallBacks *v9;
  const CFDictionaryValueCallBacks *v10;
  __CFNotificationCenter *LocalCenter;
  __CFNotificationCenter *v12;

  if (C3DResourceCacheGetTypeID_onceToken != -1)
    dispatch_once(&C3DResourceCacheGetTypeID_onceToken, &__block_literal_global_90);
  Instance = C3DTypeCreateInstance_(C3DResourceCacheGetTypeID_typeID, 0x20uLL);
  if (!Instance)
  {
    v1 = scn_default_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_FAULT))
      C3DResourceCacheCreate_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
  }
  v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  *(_QWORD *)(Instance + 16) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(Instance + 24) = CFDictionaryCreateMutable(0, 0, 0, 0);
  *(_QWORD *)(Instance + 32) = CFDictionaryCreateMutable(0, 0, v9, v10);
  *(_DWORD *)(Instance + 40) = 0;
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(LocalCenter, (const void *)Instance, (CFNotificationCallback)_C3DResourceCacheResourceWillDie, CFSTR("kC3DNotificationImageWillDie"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  v12 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(v12, (const void *)Instance, (CFNotificationCallback)_C3DResourceCacheResourceWillDie, CFSTR("kC3DNotificationImageProxyWillDie"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  return Instance;
}

_QWORD *___setupTransactionIfNeeded_block_invoke()
{
  _QWORD *result;
  pthread_rwlockattr_t v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  pthread_key_create((pthread_key_t *)&gTransactionKey, (void (__cdecl *)(void *))C3DTransactionThreadDied);
  memset(&v1, 0, sizeof(v1));
  pthread_rwlockattr_init(&v1);
  pthread_rwlock_init(&gCommandQueueFlushLock, &v1);
  pthread_rwlockattr_destroy(&v1);
  result = C3DAllocatorCreate(48, 2048);
  gCommandAllocator = (uint64_t)result;
  return result;
}

id C3DAudioManagerGetAudioEngine(char a1)
{
  if ((a1 & 1) != 0)
  {
    if (CPP3DAudioEngine::GetEngine(void)::onceToken != -1)
      dispatch_once(&CPP3DAudioEngine::GetEngine(void)::onceToken, &__block_literal_global_113);
    return CPP3DAudioEngine::GetAVEngine((id *)gCPP3DAudioEngineInstance);
  }
  else if (gCPP3DAudioEngineInstance)
  {
    if (CPP3DAudioEngine::GetEngine(void)::onceToken != -1)
      dispatch_once(&CPP3DAudioEngine::GetEngine(void)::onceToken, &__block_literal_global_113);
    return *(id *)gCPP3DAudioEngineInstance;
  }
  else
  {
    return 0;
  }
}

void _C3DFXContextCFFinalize(uint64_t a1)
{
  const void *v2;
  void *v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  uint64_t v11;
  void *v12;

  C3DFXContextRemoveAllPassInstances((_QWORD *)a1);
  __releaseBuiltinTechniques((_QWORD *)a1);
  v2 = *(const void **)(a1 + 240);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 240) = 0;
  }
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    v4 = C3DGetScene(*(_QWORD **)(a1 + 24));
    C3DRemoveSceneRef(v3, v4);
    v5 = *(const void **)(a1 + 24);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
  v6 = *(const void **)(a1 + 280);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 280) = 0;
  }
  v7 = *(const void **)(a1 + 296);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 296) = 0;
  }
  v8 = *(const void **)(a1 + 72);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v9 = *(const void **)(a1 + 40);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v10 = *(const void **)(a1 + 208);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 208) = 0;
  }
  free(*(void **)(a1 + 200));
  if (*(uint64_t *)(a1 + 96) >= 1)
  {
    v11 = 0;
    do
      CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 80) + 8 * v11++));
    while (v11 < *(_QWORD *)(a1 + 96));
  }
  v12 = *(void **)(a1 + 80);
  if (v12)
    free(v12);
}

void __releaseBuiltinTechniques(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  if (C3DWasLinkedBeforeMajorOSYear2017())
  {
    v4 = (const void *)a1[6];
    if (v4)
    {
      CFRelease(v4);
      a1[6] = 0;
    }
  }
  v5 = (const void *)a1[7];
  if (v5)
  {
    CFRelease(v5);
    a1[7] = 0;
  }
  v6 = (const void *)a1[11];
  if (v6)
  {
    CFRelease(v6);
    a1[11] = 0;
  }
}

void C3DFXContextRemoveAllPassInstances(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  const void *v12;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DFXContextSetPostProcessTechnique_cold_2(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if ((uint64_t)a1[27] >= 1)
  {
    v10 = 0;
    do
    {
      for (i = 32; i != 80; i += 8)
      {
        v12 = *(const void **)(*(_QWORD *)(a1[25] + 8 * v10) + i);
        if (v12)
        {
          C3DFXContextReleaseCullingData((uint64_t)a1, v12);
          *(_QWORD *)(*(_QWORD *)(a1[25] + 8 * v10) + i) = 0;
        }
      }
      C3DAllocatorDelete(a1[26], *(_QWORD *)(a1[25] + 8 * v10++));
    }
    while (v10 < a1[27]);
  }
  a1[27] = 0;
}

SCNMatrix4 *__cdecl SCNMatrix4MakeRotation(SCNMatrix4 *__return_ptr retstr, float angle, float x, float y, float z)
{
  SCNMatrix4 *result;
  __int128 v9;
  __int128 v10;
  float32x4_t v11;
  float32x4_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  *(_OWORD *)&retstr->m31 = 0u;
  *(_OWORD *)&retstr->m41 = 0u;
  *(_OWORD *)&retstr->m11 = 0u;
  *(_OWORD *)&retstr->m21 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v11 = *(float32x4_t *)&x;
  C3DMatrix4x4MakeAxisAngleRotation(&v12, &v11, (float)-angle);
  v9 = v13;
  *(float32x4_t *)&retstr->m11 = v12;
  *(_OWORD *)&retstr->m21 = v9;
  v10 = v15;
  *(_OWORD *)&retstr->m31 = v14;
  *(_OWORD *)&retstr->m41 = v10;
  return result;
}

void C3DMatrix4x4MakeAxisAngleRotation(float32x4_t *a1, float32x4_t *a2, double a3)
{
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float v10;
  float v11;
  float v12;
  float32x2_t v13;
  float32x2_t v14;
  int32x2_t v15;
  __float2 v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  float32x4_t v28;

  v4 = *a2;
  v6 = *(float32x4_t *)MEMORY[0x1E0C83FF0];
  v5 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 16);
  v7 = vmulq_f32(v4, v4);
  v9 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 32);
  v8 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 48);
  v10 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0];
  if (v10 != 0.0)
  {
    v11 = a3;
    v12 = v10;
    v13 = vrsqrte_f32((float32x2_t)LODWORD(v10));
    v25 = *MEMORY[0x1E0C83FF0];
    v26 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 16);
    v14 = vmul_f32(v13, vrsqrts_f32((float32x2_t)LODWORD(v12), vmul_f32(v13, v13)));
    v24 = vmulq_n_f32(v4, vmul_f32(v14, vrsqrts_f32((float32x2_t)LODWORD(v12), vmul_f32(v14, v14))).f32[0]);
    v28 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 48);
    v27 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 32);
    v16 = __sincosf_stret(v11);
    *(float *)v15.i32 = v16.__cosval;
    v8 = v28;
    v17 = vmulq_n_f32(v24, 1.0 - v16.__cosval);
    v18 = vmulq_f32((float32x4_t)vzip1q_s32((int32x4_t)v24, (int32x4_t)v24), (float32x4_t)vzip2q_s32((int32x4_t)vextq_s8((int8x16_t)v17, (int8x16_t)v17, 0xCuLL), (int32x4_t)v17));
    v19 = vmlaq_f32((float32x4_t)vdupq_lane_s32(v15, 0), v17, v24);
    v20 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_n_f32(v24, v16.__sinval));
    v21 = (float32x4_t)vextq_s8(v20, v20, 0xCuLL);
    v22 = vsubq_f32(v18, v21);
    v23 = vaddq_f32(v21, v18);
    v18.i64[0] = __PAIR64__(v19.u32[1], v23.u32[0]);
    v9.i64[0] = __PAIR64__(v23.u32[2], v22.u32[1]);
    v9.i64[1] = __PAIR64__(HIDWORD(v27), v19.u32[2]);
    v19.i32[1] = v22.i32[0];
    v19.i64[1] = __PAIR64__(HIDWORD(v25), v23.u32[1]);
    v18.i64[1] = __PAIR64__(HIDWORD(v26), v22.u32[2]);
    v6 = v19;
    v5 = v18;
  }
  *a1 = v6;
  a1[1] = v5;
  a1[2] = v9;
  a1[3] = v8;
}

__n128 C3DCullingContextSetupPointOfViewMatrices(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4)
{
  unsigned __int8 *v8;
  int v9;
  char CoordinatesSystemOptions;
  BOOL v11;
  int EyeCount;
  unint64_t v13;
  simd_float4 *EyeMatrix4x4;
  simd_float4 v15;
  simd_float4 v16;
  simd_float4 v17;
  simd_float4 v18;
  simd_float4 *v19;
  unint64_t v20;
  _OWORD *v21;
  float32x4_t *v22;
  unint64_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t *v43;
  _OWORD *v44;
  char *Matrix;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _OWORD *v49;
  NSObject *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __n128 result;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  unint64_t v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  unint64_t v74;
  _OWORD *v75;
  uint64_t v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  simd_float4 *v80;
  simd_float4 v81;
  simd_float4 v82;
  simd_float4 v83;
  unint64_t v84;
  uint64_t v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  NSObject *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  double v99;
  double v100;
  float v101;
  double v102;
  double v103;
  double v104;
  double v105;
  double v106;
  BOOL v107;
  double v108;
  simd_float4 v109;
  simd_float4 v110;
  simd_float4 v111;
  simd_float4 v112;
  simd_float4x4 v113;
  simd_float4x4 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  simd_float4 v125;
  simd_float4 v126;
  simd_float4 v127;
  simd_float4 v128;
  simd_float4x4 v129;
  simd_float4x4 v130;

  v8 = (unsigned __int8 *)(a1 + 4628);
  v9 = *(unsigned __int8 *)(a1 + 4697);
  CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(a2);
  if (v8[68])
    v11 = 0;
  else
    v11 = v9 == 2;
  if (!v11)
  {
    EyeCount = C3DEngineContextGetEyeCount(a2);
    *v8 = EyeCount;
    if (v9)
    {
      if (v9 == 1)
      {
        memset(&v113, 0, sizeof(v113));
        C3DNodeComputeWorldMatrix(a3, (uint64_t)&v113);
        v129 = __invert_f4(v113);
        v111 = v129.columns[1];
        v112 = v129.columns[0];
        v109 = v129.columns[3];
        v110 = v129.columns[2];
        if (*v8)
        {
          v13 = 0;
          do
          {
            EyeMatrix4x4 = (simd_float4 *)C3DEngineContextGetEyeMatrix4x4(a2, 0, v13);
            v16 = *EyeMatrix4x4;
            v15 = EyeMatrix4x4[1];
            v17 = EyeMatrix4x4[2];
            v18 = EyeMatrix4x4[3];
            if ((CoordinatesSystemOptions & 8) != 0)
            {
              v20 = 0;
              v125 = *EyeMatrix4x4;
              v126 = v15;
              v127 = v17;
              v128 = v18;
              memset(&v114, 0, sizeof(v114));
              do
              {
                v114.columns[v20 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1DD007970, COERCE_FLOAT(*(_OWORD *)((char *)&v125 + v20 * 4))), (float32x4_t)xmmword_1DD007920, *(float32x2_t *)&v125.f32[v20], 1), (float32x4_t)xmmword_1DD007960, *(float32x4_t *)((char *)&v125 + v20 * 4), 2), (float32x4_t)xmmword_1DD007E00, *(float32x4_t *)((char *)&v125 + v20 * 4), 3);
                v20 += 4;
              }
              while (v20 != 16);
              v19 = (simd_float4 *)(a1 + (v13 << 6));
              v16 = v114.columns[0];
              v15 = v114.columns[1];
              v17 = v114.columns[2];
              v18 = v114.columns[3];
            }
            else
            {
              v19 = (simd_float4 *)(a1 + (v13 << 6));
            }
            v19[217] = v16;
            v21 = (_OWORD *)(a1 + (v13 << 6));
            v21[218] = v15;
            v21[219] = v17;
            v21[220] = v18;
            v22 = (float32x4_t *)C3DEngineContextGetEyeMatrix4x4(a2, 1, v13);
            v23 = 0;
            v24 = *v22;
            v25 = v22[1];
            v26 = v22[2];
            v27 = v22[3];
            v125 = v112;
            v126 = v111;
            v127 = v110;
            v128 = v109;
            memset(&v114, 0, sizeof(v114));
            do
            {
              v114.columns[v23 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v24, COERCE_FLOAT(*(_OWORD *)((char *)&v125 + v23 * 4))), v25, *(float32x2_t *)&v125.f32[v23], 1), v26, *(float32x4_t *)((char *)&v125 + v23 * 4), 2), v27, *(float32x4_t *)((char *)&v125 + v23 * 4), 3);
              v23 += 4;
            }
            while (v23 != 16);
            v130 = v114;
            v28 = a1 + (v13 << 6);
            *(simd_float4 *)(v28 + 3088) = v114.columns[0];
            *(simd_float4 *)(v28 + 3104) = v130.columns[1];
            *(simd_float4 *)(v28 + 3120) = v130.columns[2];
            *(simd_float4 *)(v28 + 3136) = v130.columns[3];
            *(simd_float4x4 *)(v28 + 2704) = __invert_f4(v130);
            v29 = *(_OWORD *)(v28 + 2720);
            *(_OWORD *)(v28 + 592) = *(_OWORD *)(v28 + 2704);
            *(_OWORD *)(v28 + 608) = v29;
            v30 = *(_OWORD *)(v28 + 2752);
            *(_OWORD *)(v28 + 624) = *(_OWORD *)(v28 + 2736);
            *(_OWORD *)(v28 + 640) = v30;
            v31 = *(_OWORD *)(v28 + 3472);
            v32 = *(_OWORD *)(v28 + 3488);
            v33 = *(_OWORD *)(v28 + 3504);
            *(_OWORD *)(v28 + 1408) = *(_OWORD *)(v28 + 3520);
            *(_OWORD *)(v28 + 1392) = v33;
            *(_OWORD *)(v28 + 1376) = v32;
            *(_OWORD *)(v28 + 1360) = v31;
            ++v13;
          }
          while (v13 < *v8);
        }
LABEL_54:
        *(__n128 *)(a1 + 4640) = C3DEngineContextGetViewportAtIndex(a2, 0);
        LODWORD(v99) = *(_DWORD *)(a1 + 3512);
        v100 = *(float *)&v99;
        v101 = *(float *)(a1 + 3528);
        v102 = v101;
        if (*(float *)(a1 + 3516) == 0.0)
        {
          v103 = (v102 + -1.0) / v100;
          v104 = (v102 + 1.0) / v100;
          *(float *)&v104 = v104;
          v105 = -(1.0 - v102) / v100;
          if (v101 < -1.0)
            v106 = v105;
          else
            v106 = v103;
          *(float *)&v105 = v101 / *(float *)&v99;
          if (v101 < -1.0)
            v105 = v104;
        }
        else
        {
          v107 = v101 < -2.0;
          *(float *)&v99 = v101 / *(float *)&v99;
          v108 = v102 / (v100 + 1.0);
          v105 = v102 / (v100 + -1.0);
          *(float *)&v105 = v105;
          v106 = v108;
          if (!v107)
            v105 = v99;
        }
        *(float *)&v106 = v106;
        result = (__n128)vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(*(float32x2_t *)&v105, *(float32x2_t *)&v106), 0), (int8x8_t)vrev64_s32((int32x2_t)__PAIR64__(LODWORD(v106), LODWORD(v105))), (int8x8_t)__PAIR64__(LODWORD(v106), LODWORD(v105))));
        *(__n128 *)(v8 + 116) = result;
        return result;
      }
      if (!v8[68])
      {
        v91 = scn_default_log();
        if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
          C3DCullingContextSetupPointOfViewMatrices_cold_3(v91, v92, v93, v94, v95, v96, v97, v98);
        goto LABEL_54;
      }
    }
    if (EyeCount)
    {
      v74 = 0;
      do
      {
        v75 = (_OWORD *)C3DEngineContextGetEyeMatrix4x4(a2, 1, v74);
        v76 = a1 + (v74 << 6);
        v77 = v75[2];
        v78 = v75[3];
        v79 = v75[1];
        *(_OWORD *)(v76 + 3088) = *v75;
        *(_OWORD *)(v76 + 3136) = v78;
        *(_OWORD *)(v76 + 3120) = v77;
        *(_OWORD *)(v76 + 3104) = v79;
        v80 = (simd_float4 *)C3DEngineContextGetEyeMatrix4x4(a2, 0, v74);
        v81 = v80[1];
        v82 = v80[2];
        v83 = v80[3];
        if ((CoordinatesSystemOptions & 8) != 0)
        {
          v84 = 0;
          v125 = *v80;
          v126 = v81;
          v127 = v82;
          v128 = v83;
          memset(&v114, 0, sizeof(v114));
          do
          {
            v114.columns[v84 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1DD007970, COERCE_FLOAT(*(_OWORD *)((char *)&v125 + v84 * 4))), (float32x4_t)xmmword_1DD007920, *(float32x2_t *)&v125.f32[v84], 1), (float32x4_t)xmmword_1DD007960, *(float32x4_t *)((char *)&v125 + v84 * 4), 2), (float32x4_t)xmmword_1DD007E00, *(float32x4_t *)((char *)&v125 + v84 * 4), 3);
            v84 += 4;
          }
          while (v84 != 16);
          v81 = v114.columns[1];
          v82 = v114.columns[2];
          v83 = v114.columns[3];
          *(simd_float4 *)(a1 + (v74 << 6) + 3472) = v114.columns[0];
        }
        else
        {
          *(simd_float4 *)(v76 + 3472) = *v80;
        }
        v85 = a1 + (v74 << 6);
        *(simd_float4 *)(v85 + 3488) = v81;
        *(simd_float4 *)(v85 + 3504) = v82;
        *(simd_float4 *)(v85 + 3520) = v83;
        *(simd_float4x4 *)(v85 + 2704) = __invert_f4(*(simd_float4x4 *)(v76 + 3088));
        v86 = *(_OWORD *)(v85 + 2720);
        *(_OWORD *)(v85 + 592) = *(_OWORD *)(v85 + 2704);
        *(_OWORD *)(v85 + 608) = v86;
        v87 = *(_OWORD *)(v85 + 2752);
        *(_OWORD *)(v85 + 624) = *(_OWORD *)(v85 + 2736);
        *(_OWORD *)(v85 + 640) = v87;
        v88 = *(_OWORD *)(v85 + 3472);
        v89 = *(_OWORD *)(v85 + 3488);
        v90 = *(_OWORD *)(v85 + 3504);
        *(_OWORD *)(v85 + 1408) = *(_OWORD *)(v85 + 3520);
        *(_OWORD *)(v85 + 1392) = v90;
        *(_OWORD *)(v85 + 1376) = v89;
        *(_OWORD *)(v85 + 1360) = v88;
        ++v74;
      }
      while (v74 < *v8);
    }
    goto LABEL_54;
  }
  v123 = 0u;
  v124 = 0u;
  v121 = 0u;
  v122 = 0u;
  v119 = 0u;
  v120 = 0u;
  v117 = 0u;
  v118 = 0u;
  v115 = 0u;
  v116 = 0u;
  memset(&v114, 0, sizeof(v114));
  if ((C3DNodeGetProjectionInfos((uint64_t)a3, (uint64_t)&v114) & 1) == 0)
  {
    v34 = scn_default_log();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
      C3DCullingContextSetupLOD_cold_1(v34, v35, v36, v37, v38, v39, v40, v41);
  }
  if ((v114.columns[0].i8[0] & 2) != 0 || C3DEngineContextGetAutoAdjustZRange(a2))
    C3DAdjustZRangeOfProjectionInfos((uint64_t)&v114, a3, a1 + 4640, *(_QWORD *)(a1 + 4728));
  v42 = &v114.columns[0].i64[1];
  if (v8[66])
    v43 = (uint64_t *)(v8 + 116);
  else
    v43 = &v114.columns[0].i64[1];
  if (!v8[66])
    v42 = (uint64_t *)(v8 + 116);
  *(_OWORD *)v42 = *(_OWORD *)v43;
  v8[67] = (v114.columns[0].i8[0] & 0x20) != 0;
  v44 = (_OWORD *)(a1 + 3472);
  Matrix = C3DProjectionInfosGetMatrix((char *)&v114, a1 + 4640, CoordinatesSystemOptions);
  v46 = *((_OWORD *)Matrix + 2);
  v47 = *((_OWORD *)Matrix + 3);
  v48 = *((_OWORD *)Matrix + 1);
  *(_OWORD *)(a1 + 3472) = *(_OWORD *)Matrix;
  *(_OWORD *)(a1 + 3520) = v47;
  *(_OWORD *)(a1 + 3504) = v46;
  *(_OWORD *)(a1 + 3488) = v48;
  v49 = (_OWORD *)(a1 + 2704);
  C3DNodeComputeWorldMatrix(a3, a1 + 2704);
  if (a3 == a4)
  {
    v63 = *(_OWORD *)(a1 + 2720);
    *(_OWORD *)(a1 + 592) = *v49;
    *(_OWORD *)(a1 + 608) = v63;
    v64 = *(_OWORD *)(a1 + 2752);
    *(_OWORD *)(a1 + 624) = *(_OWORD *)(a1 + 2736);
    *(_OWORD *)(a1 + 640) = v64;
    v65 = *(_OWORD *)(a1 + 3488);
    *(_OWORD *)(a1 + 1360) = *v44;
    *(_OWORD *)(a1 + 1376) = v65;
    result = *(__n128 *)(a1 + 3504);
    v66 = *(_OWORD *)(a1 + 3520);
    *(__n128 *)(a1 + 1392) = result;
    *(_OWORD *)(a1 + 1408) = v66;
  }
  else
  {
    if ((C3DNodeGetProjectionInfos((uint64_t)a4, (uint64_t)&v114) & 1) == 0)
    {
      v50 = scn_default_log();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
        C3DCullingContextSetupLOD_cold_1(v50, v51, v52, v53, v54, v55, v56, v57);
    }
    if ((v114.columns[0].i8[0] & 2) != 0 || C3DEngineContextGetAutoAdjustZRange(a2))
      C3DAdjustZRangeOfProjectionInfos((uint64_t)&v114, a3, a1 + 4640, *(_QWORD *)(a1 + 4728));
    *(simd_float4 *)(v8 + 116) = *(simd_float4 *)((char *)v114.columns + 8);
    v58 = C3DProjectionInfosGetMatrix((char *)&v114, a1 + 4640, CoordinatesSystemOptions);
    v59 = *((_OWORD *)v58 + 2);
    v60 = *((_OWORD *)v58 + 3);
    v61 = *((_OWORD *)v58 + 1);
    *(_OWORD *)(a1 + 1360) = *(_OWORD *)v58;
    *(_OWORD *)(a1 + 1408) = v60;
    *(_OWORD *)(a1 + 1392) = v59;
    *(_OWORD *)(a1 + 1376) = v61;
    result.n128_u64[0] = C3DNodeComputeWorldMatrix(a4, a1 + 592).n128_u64[0];
  }
  if (*v8 >= 2u)
  {
    v67 = a1 + 2768;
    v68 = 1;
    do
    {
      v69 = *v44;
      v70 = *(_OWORD *)(a1 + 3488);
      v71 = *(_OWORD *)(a1 + 3520);
      *(_OWORD *)(v67 + 800) = *(_OWORD *)(a1 + 3504);
      *(_OWORD *)(v67 + 816) = v71;
      *(_OWORD *)(v67 + 768) = v69;
      *(_OWORD *)(v67 + 784) = v70;
      result = *(__n128 *)v49;
      v72 = *(_OWORD *)(a1 + 2720);
      v73 = *(_OWORD *)(a1 + 2752);
      *(_OWORD *)(v67 + 32) = *(_OWORD *)(a1 + 2736);
      *(_OWORD *)(v67 + 48) = v73;
      *(__n128 *)v67 = result;
      *(_OWORD *)(v67 + 16) = v72;
      v67 += 64;
      ++v68;
    }
    while (v68 < *v8);
  }
  return result;
}

__n128 C3DNodeComputeWorldMatrix(float32x4_t *a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *WorldMatrix;
  __n128 result;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;

  if (!a2)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DNodeComputeWorldMatrix_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  WorldMatrix = C3DNodeGetWorldMatrix(a1);
  result = (__n128)WorldMatrix[2];
  v14 = WorldMatrix[3];
  v16 = *WorldMatrix;
  v15 = WorldMatrix[1];
  *(__n128 *)(a2 + 32) = result;
  *(float32x4_t *)(a2 + 48) = v14;
  *(float32x4_t *)a2 = v16;
  *(float32x4_t *)(a2 + 16) = v15;
  return result;
}

double C3DCullingContextSetupLOD(uint64_t a1, __n128 *a2)
{
  float32x4_t *PointOfViewForCulling;
  double result;
  float32x4_t *v6;
  float32x4_t *WorldMatrix;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char CoordinatesSystemOptions;
  char *Matrix;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  _OWORD v32[14];
  __n128 Viewport;
  simd_float4x4 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  simd_float4x4 v39;

  PointOfViewForCulling = C3DEngineContextGetPointOfViewForCulling((uint64_t)a2);
  if (PointOfViewForCulling)
  {
    v6 = PointOfViewForCulling;
    WorldMatrix = C3DNodeGetWorldMatrix(PointOfViewForCulling);
    v8 = WorldMatrix[2];
    v9 = WorldMatrix[3];
    v10 = vnegq_f32(v8);
    v11 = vmulq_f32(v9, v10);
    v10.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0];
    v12 = *WorldMatrix;
    v13 = WorldMatrix[1];
    *(float32x4_t *)(a1 + 4768) = v10;
    *(float32x4_t *)(a1 + 4784) = v12;
    *(float32x4_t *)(a1 + 4800) = v13;
    *(float32x4_t *)(a1 + 4816) = v8;
    *(float32x4_t *)(a1 + 4832) = v9;
    Viewport = C3DEngineContextGetViewport(a2);
    memset(v32, 0, sizeof(v32));
    if ((C3DNodeGetProjectionInfos((uint64_t)v6, (uint64_t)v32) & 1) == 0)
    {
      v14 = scn_default_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
        C3DCullingContextSetupLOD_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
    }
    if ((v32[0] & 2) != 0 || C3DEngineContextGetAutoAdjustZRange((uint64_t)a2))
      C3DAdjustZRangeOfProjectionInfos((uint64_t)v32, v6, (uint64_t)&Viewport, *(_QWORD *)(a1 + 4728));
    if (*(_BYTE *)(a1 + 4694))
      *(_OWORD *)((char *)v32 + 8) = *(_OWORD *)(a1 + 4744);
    CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions((uint64_t)a2);
    Matrix = C3DProjectionInfosGetMatrix((char *)v32, (uint64_t)&Viewport, CoordinatesSystemOptions);
    v30 = *((float32x4_t *)Matrix + 1);
    v31 = *(float32x4_t *)Matrix;
    v28 = *((float32x4_t *)Matrix + 3);
    v29 = *((float32x4_t *)Matrix + 2);
    v39 = __invert_f4(*(simd_float4x4 *)(a1 + 4784));
    v24 = 0;
    v34 = v39;
    v35 = 0u;
    v36 = 0u;
    v37 = 0u;
    v38 = 0u;
    do
    {
      *(__int128 *)((char *)&v35 + v24 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v31, COERCE_FLOAT(*(_OWORD *)&v34.columns[v24])), v30, *(float32x2_t *)v34.columns[v24].f32, 1), v29, (float32x4_t)v34.columns[v24], 2), v28, (float32x4_t)v34.columns[v24], 3);
      ++v24;
    }
    while (v24 != 4);
    result = *(double *)&v35;
    v25 = v36;
    v26 = v37;
    v27 = v38;
    *(_OWORD *)(a1 + 4848) = v35;
    *(_OWORD *)(a1 + 4864) = v25;
    *(_OWORD *)(a1 + 4880) = v26;
    *(_OWORD *)(a1 + 4896) = v27;
  }
  return result;
}

char *C3DProjectionInfosGetMatrix(char *a1, uint64_t a2, char a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  float32x2_t v15;
  uint32x2_t v16;
  float v17;
  double v18;
  float v19;
  float32x2_t v20;
  double v21;
  float64x2_t v26;
  float64x2_t v27;
  float v28;
  float v29;
  __int128 v30;
  float64x2_t v31;
  double v32;
  double v33;
  double v34;
  __int128 v35;
  __int128 v36;
  double v37;
  float v38;
  float v39;
  uint64_t v40;
  __int128 v41;
  float64x2_t v42;
  __int128 v43;
  double v44;
  double v45;
  float v46;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  float v58;
  float v59;
  __int128 v60;
  double v61;
  unsigned int v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  __int128 v68;
  double v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  double v74;
  double v75;
  double v76;
  double v77;
  unsigned int v78;
  __int128 v79;
  float v80;
  __int128 v81;
  double v82;
  unsigned int v83;
  float v84;
  float v85;
  double v86;
  float v87;
  float v88;
  double v89;
  unsigned int v90;
  unsigned int v91;
  double v92;
  unsigned int v93;
  unsigned int v94;
  float v95;
  float v96;
  float v97;
  uint64_t v98;
  __int128 v99;
  __int128 v100;
  float32x4_t v101;
  float32x2_t v102;
  uint32x2_t v103;
  uint32x2_t v105;
  uint64_t v106;
  float32x4_t v107;
  __int128 v108;
  __int128 v109;
  float64x2_t v110;
  __int128 v111;
  __int128 v113;
  __int128 v114;
  float64x2_t v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  float64x2_t v119;
  __int128 v120;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DProjectionInfosSetZFar_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  v14 = *a1;
  if ((*a1 & 8) == 0)
  {
    if ((*a1 & 1) == 0)
    {
      if ((*a1 & 0x10) != 0)
      {
        v44 = *((double *)a1 + 26);
        v45 = 1.0;
        if (a2)
        {
          LODWORD(v46) = HIDWORD(*(_OWORD *)a2);
          if (v46 != 0.0)
            v45 = (float)(COERCE_FLOAT(*(_QWORD *)(a2 + 8)) / v46);
        }
        if (v44 == 0.0 && *((double *)a1 + 27) == 0.0)
          v48 = 60.0;
        else
          v48 = *((double *)a1 + 27);
        if (v44 != 0.0 && v48 != 0.0)
        {
          v49 = tan(v44 / 180.0 * 3.14159265);
          if (v49 / tan(v48 / 180.0 * 3.14159265) > v45)
            v48 = 0.0;
          else
            v44 = 0.0;
        }
        v50 = *((double *)a1 + 1);
        if (*((double *)a1 + 2) > v50)
          v51 = *((double *)a1 + 2);
        else
          v51 = v50 + 1.0;
        if (v48 == 0.0)
          v52 = v44;
        else
          v52 = v48;
        v53 = __tanpi(v52 / 360.0);
        if (v53 == 0.0)
          v54 = 1.0;
        else
          v54 = 1.0 / v53;
        if (v44 == 0.0)
          v55 = v48;
        else
          v55 = v44;
        v56 = __tanpi(v55 / 360.0);
        if (v56 == 0.0)
          v57 = 1.0;
        else
          v57 = 1.0 / v56;
        v58 = v57;
        LODWORD(v60) = 0;
        *((_QWORD *)&v60 + 1) = 0;
        v59 = v54;
        *((float *)&v60 + 1) = v59;
        v61 = v50 - v51;
        if ((a3 & 1) != 0)
        {
          v31.f64[0] = 0.0;
          *(float *)&v71 = v51 / (v50 - v51);
          *(_QWORD *)&v31.f64[1] = __PAIR64__(-1.0, v71);
        }
        else
        {
          *(float *)&v62 = (v50 + v51) / (v50 - v51);
          v31.f64[0] = 0.0;
          *(_QWORD *)&v31.f64[1] = __PAIR64__(-1.0, v62);
          v51 = v51 + v51;
        }
        *(float *)&v72 = v50 * v51 / v61;
        *(_QWORD *)&_Q1 = 0;
        *((_QWORD *)&_Q1 + 1) = v72;
        *((_OWORD *)a1 + 5) = LODWORD(v58);
        *((_OWORD *)a1 + 6) = v60;
        *((float64x2_t *)a1 + 7) = v31;
        *((_OWORD *)a1 + 8) = _Q1;
        if (v44 == 0.0)
        {
          v74 = v58 / v45;
          goto LABEL_89;
        }
        v89 = v45 * v59;
LABEL_92:
        v97 = v89;
        *((float *)a1 + 25) = v97;
        if ((a3 & 8) == 0)
          goto LABEL_96;
        goto LABEL_93;
      }
      if (a2
        && (v15 = *(float32x2_t *)(a1 + 24),
            v16 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v15)),
            (vpmax_u32(v16, v16).u32[0] & 0x80000000) != 0))
      {
        v17 = *((float *)a1 + 14) / 180.0 * 3.14159265 * 0.5;
        v18 = *((double *)a1 + 1);
        v19 = v18 * tanf(v17);
        v20 = vdiv_f32(vadd_f32(v15, v15), *(float32x2_t *)(a2 + 8));
        v21 = *((double *)a1 + 2);
        if (v21 <= v18)
          v21 = v18 + 1.0;
        __asm { FMOV            V4.2S, #1.0 }
        v26 = vcvtq_f64_f32(vmul_n_f32(vadd_f32(v20, _D4), -v19));
        v31 = vcvtq_f64_f32(vmul_n_f32(vsub_f32(_D4, v20), v19));
        v27 = vsubq_f64(v31, v26);
        v28 = (v18 + v18) / v27.f64[0];
        LODWORD(v30) = 0;
        *((_QWORD *)&v30 + 1) = 0;
        v29 = (v18 + v18) / v27.f64[1];
        *((float *)&v30 + 1) = v29;
        *(float32x2_t *)&v31.f64[0] = vcvt_f32_f64(vdivq_f64(vaddq_f64(v31, v26), v27));
        if ((a3 & 1) != 0)
        {
          v33 = v18 - v21;
          v34 = v21 / (v18 - v21);
        }
        else
        {
          v32 = v18 + v21;
          v33 = v18 - v21;
          v18 = v18 + v18;
          v34 = v32 / v33;
        }
        *(float *)&v90 = v34;
        *(_QWORD *)&v31.f64[1] = __PAIR64__(-1.0, v90);
        *(float *)&v91 = v18 * v21 / v33;
        *(_QWORD *)&_Q1 = 0;
        *((_QWORD *)&_Q1 + 1) = v91;
        *((_OWORD *)a1 + 5) = LODWORD(v28);
        *((_OWORD *)a1 + 6) = v30;
        *((float64x2_t *)a1 + 7) = v31;
        *((_OWORD *)a1 + 8) = _Q1;
        v92 = *((double *)a1 + 8);
      }
      else
      {
        v64 = *((double *)a1 + 1);
        if (*((double *)a1 + 2) > v64)
          v65 = *((double *)a1 + 2);
        else
          v65 = v64 + 1.0;
        v66 = __tanpi(*((float *)a1 + 14) / 360.0);
        if (v66 == 0.0)
          v67 = 1.0;
        else
          v67 = 1.0 / v66;
        v28 = v67;
        LODWORD(v68) = 0;
        *((_QWORD *)&v68 + 1) = 0;
        *((float *)&v68 + 1) = v28;
        v69 = v64 - v65;
        if ((a3 & 1) != 0)
        {
          v31.f64[0] = 0.0;
          *(float *)&v93 = v65 / (v64 - v65);
          *(_QWORD *)&v31.f64[1] = __PAIR64__(-1.0, v93);
        }
        else
        {
          *(float *)&v70 = (v64 + v65) / (v64 - v65);
          v31.f64[0] = 0.0;
          *(_QWORD *)&v31.f64[1] = __PAIR64__(-1.0, v70);
          v64 = v64 + v64;
        }
        *(float *)&v94 = v64 * v65 / v69;
        *(_QWORD *)&_Q1 = 0;
        *((_QWORD *)&_Q1 + 1) = v94;
        *((_OWORD *)a1 + 5) = LODWORD(v28);
        *((_OWORD *)a1 + 6) = v68;
        *((float64x2_t *)a1 + 7) = v31;
        *((_OWORD *)a1 + 8) = _Q1;
        v92 = *((double *)a1 + 8);
        v29 = v28;
        if (!a2)
          goto LABEL_87;
      }
      LODWORD(v95) = HIDWORD(*(_OWORD *)a2);
      if (v95 != 0.0)
        v92 = (float)(COERCE_FLOAT(*(_QWORD *)(a2 + 8)) / v95);
LABEL_87:
      if ((v14 & 0x20) == 0)
      {
        v74 = v28 / v92;
LABEL_89:
        v96 = v74;
        *((float *)a1 + 20) = v96;
        if ((a3 & 8) == 0)
          goto LABEL_96;
        goto LABEL_93;
      }
      v89 = v92 * v29;
      goto LABEL_92;
    }
    v37 = *((double *)a1 + 6);
    if (!a2)
    {
      v63 = *((double *)a1 + 6);
      goto LABEL_72;
    }
    LODWORD(v38) = HIDWORD(*(_OWORD *)a2);
    if (v38 == 0.0)
    {
      v39 = 1.0;
      if ((C3DWasLinkedBeforeMajorOSYear2017() & 1) != 0)
        goto LABEL_70;
    }
    else
    {
      v39 = COERCE_FLOAT(*(_QWORD *)(a2 + 8)) / v38;
      if ((C3DWasLinkedBeforeMajorOSYear2017() & 1) != 0)
      {
        if (v39 <= 1.0)
        {
LABEL_70:
          v75 = v39;
          goto LABEL_71;
        }
        v75 = v39;
LABEL_69:
        v63 = v37;
        v37 = v37 * v75;
        goto LABEL_72;
      }
    }
    v75 = v39;
    if ((*a1 & 0x20) != 0)
    {
LABEL_71:
      v63 = v37 / v75;
LABEL_72:
      v76 = *((double *)a1 + 1);
      if (*((double *)a1 + 2) > v76)
        v77 = *((double *)a1 + 2);
      else
        v77 = v76 + 1.0;
      *(float *)&v78 = 2.0 / (v37 + v37);
      v31.f64[0] = 0.0;
      HIDWORD(v31.f64[1]) = 0;
      v79 = v78;
      v80 = 2.0 / (v63 + v63);
      LODWORD(v81) = 0;
      *((_QWORD *)&v81 + 1) = 0;
      *((float *)&v81 + 1) = v80;
      v82 = v76 - v77;
      v84 = -(v63 - v63) / (v63 + v63);
      if ((a3 & 1) != 0)
      {
        v87 = 1.0 / v82;
        *(float *)&v31.f64[1] = v87;
        v86 = v76 / v82;
      }
      else
      {
        v85 = 2.0 / v82;
        *(float *)&v31.f64[1] = v85;
        v86 = (v76 + v77) / v82;
      }
      v88 = v86;
      __asm { FMOV            V1.4S, #1.0 }
      *(float *)&v83 = -(v37 - v37) / (v37 + v37);
      *(_QWORD *)&_Q1 = __PAIR64__(LODWORD(v84), v83);
      *((float *)&_Q1 + 2) = v88;
      *((_OWORD *)a1 + 5) = v79;
      *((_OWORD *)a1 + 6) = v81;
      *((float64x2_t *)a1 + 7) = v31;
      *((_OWORD *)a1 + 8) = _Q1;
      if ((a3 & 8) == 0)
      {
LABEL_96:
        v101.i64[0] = *((_QWORD *)a1 + 4);
        v102 = *(float32x2_t *)(a1 + 40);
        v103 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*(float32x2_t *)v101.f32));
        if ((vpmax_u32(v103, v103).u32[0] & 0x80000000) != 0)
          goto LABEL_98;
        __asm { FMOV            V3.2S, #1.0 }
        v105 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v102, _D3));
        if ((vpmax_u32(v105, v105).u32[0] & 0x80000000) != 0)
        {
LABEL_98:
          v106 = 0;
          v107.i32[0] = 0;
          v107.i32[3] = 0;
          *(uint64_t *)((char *)v107.i64 + 4) = HIDWORD(*((_QWORD *)a1 + 5));
          v101.i32[2] = 0;
          v101.i32[3] = 1.0;
          v108 = *((_OWORD *)a1 + 6);
          v113 = *((_OWORD *)a1 + 5);
          v114 = v108;
          v115 = v31;
          v116 = _Q1;
          v117 = 0u;
          v118 = 0u;
          v119 = 0u;
          v120 = 0u;
          do
          {
            *(__int128 *)((char *)&v117 + v106) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v102.u32[0], COERCE_FLOAT(*(__int128 *)((char *)&v113 + v106))), v107, *(float32x2_t *)((char *)&v113 + v106), 1), (float32x4_t)xmmword_1DD007600, *(float32x4_t *)((char *)&v113 + v106), 2), v101, *(float32x4_t *)((char *)&v113 + v106), 3);
            v106 += 16;
          }
          while (v106 != 64);
LABEL_100:
          v109 = v118;
          v110 = v119;
          v111 = v120;
          *((_OWORD *)a1 + 5) = v117;
          *((_OWORD *)a1 + 6) = v109;
          *((float64x2_t *)a1 + 7) = v110;
          *((_OWORD *)a1 + 8) = v111;
          return a1 + 80;
        }
        return a1 + 80;
      }
LABEL_93:
      v98 = 0;
      v99 = *((_OWORD *)a1 + 6);
      v113 = *((_OWORD *)a1 + 5);
      v114 = v99;
      v115 = v31;
      v116 = _Q1;
      v117 = 0u;
      v118 = 0u;
      v119 = 0u;
      v120 = 0u;
      do
      {
        *(__int128 *)((char *)&v117 + v98) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1DD007970, COERCE_FLOAT(*(__int128 *)((char *)&v113 + v98))), (float32x4_t)xmmword_1DD007920, *(float32x2_t *)((char *)&v113 + v98), 1), (float32x4_t)xmmword_1DD007960, *(float32x4_t *)((char *)&v113 + v98), 2), (float32x4_t)xmmword_1DD007E00, *(float32x4_t *)((char *)&v113 + v98), 3);
        v98 += 16;
      }
      while (v98 != 64);
      v100 = v118;
      v31 = v119;
      _Q1 = v120;
      *((_OWORD *)a1 + 5) = v117;
      *((_OWORD *)a1 + 6) = v100;
      *((float64x2_t *)a1 + 7) = v31;
      *((_OWORD *)a1 + 8) = _Q1;
      goto LABEL_96;
    }
    goto LABEL_69;
  }
  if ((a3 & 8) != 0)
  {
    v40 = 0;
    v41 = *((_OWORD *)a1 + 10);
    v42 = *((float64x2_t *)a1 + 11);
    v43 = *((_OWORD *)a1 + 12);
    v113 = *((_OWORD *)a1 + 9);
    v114 = v41;
    v115 = v42;
    v116 = v43;
    v117 = 0u;
    v118 = 0u;
    v119 = 0u;
    v120 = 0u;
    do
    {
      *(__int128 *)((char *)&v117 + v40) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1DD007970, COERCE_FLOAT(*(__int128 *)((char *)&v113 + v40))), (float32x4_t)xmmword_1DD007920, *(float32x2_t *)((char *)&v113 + v40), 1), (float32x4_t)xmmword_1DD007960, *(float32x4_t *)((char *)&v113 + v40), 2), (float32x4_t)xmmword_1DD007E00, *(float32x4_t *)((char *)&v113 + v40), 3);
      v40 += 16;
    }
    while (v40 != 64);
    goto LABEL_100;
  }
  v35 = *((_OWORD *)a1 + 10);
  *((_OWORD *)a1 + 5) = *((_OWORD *)a1 + 9);
  *((_OWORD *)a1 + 6) = v35;
  v36 = *((_OWORD *)a1 + 12);
  *((_OWORD *)a1 + 7) = *((_OWORD *)a1 + 11);
  *((_OWORD *)a1 + 8) = v36;
  return a1 + 80;
}

uint64_t C3DNodeGetProjectionInfos(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *Camera;
  _OWORD *ProjectionInfosPtr;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  float v24;
  double v25;
  float v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  uint64_t result;
  BOOL v33;
  double v34;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DNodeGetProjectionInfos_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  Camera = C3DNodeGetCamera(a1);
  if (Camera)
  {
    ProjectionInfosPtr = (_OWORD *)C3DCameraGetProjectionInfosPtr((uint64_t)Camera);
    v14 = ProjectionInfosPtr[1];
    *(_OWORD *)a2 = *ProjectionInfosPtr;
    *(_OWORD *)(a2 + 16) = v14;
    v15 = ProjectionInfosPtr[5];
    v17 = ProjectionInfosPtr[2];
    v16 = ProjectionInfosPtr[3];
    *(_OWORD *)(a2 + 64) = ProjectionInfosPtr[4];
    *(_OWORD *)(a2 + 80) = v15;
    *(_OWORD *)(a2 + 32) = v17;
    *(_OWORD *)(a2 + 48) = v16;
    v18 = ProjectionInfosPtr[9];
    v20 = ProjectionInfosPtr[6];
    v19 = ProjectionInfosPtr[7];
    *(_OWORD *)(a2 + 128) = ProjectionInfosPtr[8];
    *(_OWORD *)(a2 + 144) = v18;
    *(_OWORD *)(a2 + 96) = v20;
    *(_OWORD *)(a2 + 112) = v19;
    v21 = ProjectionInfosPtr[13];
    v23 = ProjectionInfosPtr[10];
    v22 = ProjectionInfosPtr[11];
    *(_OWORD *)(a2 + 192) = ProjectionInfosPtr[12];
    *(_OWORD *)(a2 + 208) = v21;
    *(_OWORD *)(a2 + 160) = v23;
    *(_OWORD *)(a2 + 176) = v22;
    if ((*(_BYTE *)a2 & 8) != 0)
    {
      v24 = *(float *)(a2 + 184);
      v25 = v24;
      v26 = *(float *)(a2 + 200);
      v27 = v26;
      if (*(float *)(a2 + 188) == 0.0)
      {
        v28 = (v27 + -1.0) / v25;
        v29 = (v27 + 1.0) / v25;
        *(float *)&v29 = v29;
        v30 = -(1.0 - v27) / v25;
        if (v26 < -1.0)
          v31 = v30;
        else
          v31 = v28;
        *(float *)&v30 = v26 / v24;
        if (v26 < -1.0)
          v30 = v29;
      }
      else
      {
        v33 = v26 < -2.0;
        *(float *)&v21 = v26 / v24;
        v34 = v27 / (v25 + 1.0);
        v30 = v27 / (v25 + -1.0);
        *(float *)&v30 = v30;
        v31 = v34;
        if (!v33)
          v30 = *(double *)&v21;
      }
      *(float *)&v21 = v31;
      *(float64x2_t *)(a2 + 8) = vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(*(float32x2_t *)&v30, *(float32x2_t *)&v21), 0), (int8x8_t)vrev64_s32((int32x2_t)__PAIR64__(v21, LODWORD(v30))), (int8x8_t)__PAIR64__(v21, LODWORD(v30))));
    }
    return 1;
  }
  else
  {
    result = (uint64_t)C3DNodeGetLight(a1);
    if (result)
      return C3DLightGetProjectionInfo(result, a2);
  }
  return result;
}

uint64_t C3DEngineContextGetAutoAdjustZRange(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DEngineContextGetScene_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 209);
}

__n128 C3DEngineContextGetViewport(__n128 *a1)
{
  return a1[15];
}

void ___pathComponentForString_block_invoke()
{
  _pathComponentForString__pathComponents = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 110, MEMORY[0x1E0C9B390], 0);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("transform"), (const void *)1);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("opacity"), (const void *)2);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("hidden"), (const void *)3);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("attributes"), (const void *)4);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("matrix"), (const void *)5);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("translation"), (const void *)6);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("position"), (const void *)6);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("rotation"), (const void *)7);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("orientation"), (const void *)0xD);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("scale"), (const void *)8);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("eulerAngles"), (const void *)0xC);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("quaternion"), (const void *)0xD);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("pivot"), (const void *)9);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("filters"), (const void *)0xA);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("nodes"), (const void *)0xB);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("childNodes"), (const void *)0xB);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("x"), (const void *)0xE);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("y"), (const void *)0xF);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("z"), (const void *)0x10);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("w"), (const void *)0x11);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("(0)"), (const void *)0xE);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("(1)"), (const void *)0xF);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("(2)"), (const void *)0x10);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("(3)"), (const void *)0x11);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("r"), (const void *)0x12);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("g"), (const void *)0x13);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("b"), (const void *)0x14);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("a"), (const void *)0x15);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m11"), (const void *)0x16);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m12"), (const void *)0x1A);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m13"), (const void *)0x1E);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m14"), (const void *)0x22);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m21"), (const void *)0x17);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m22"), (const void *)0x1B);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m23"), (const void *)0x1F);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m24"), (const void *)0x23);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m31"), (const void *)0x18);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m32"), (const void *)0x1C);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m33"), (const void *)0x20);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m34"), (const void *)0x24);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m41"), (const void *)0x19);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m42"), (const void *)0x1D);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m43"), (const void *)0x21);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("m44"), (const void *)0x25);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("camera"), (const void *)0x26);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("geometry"), (const void *)0x27);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("firstMaterial"), (const void *)0x28);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("materials"), (const void *)0x29);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("commonProfile"), (const void *)0x2A);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("diffuse"), (const void *)0x2B);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("ambient"), (const void *)0x2C);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("specular"), (const void *)0x2D);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("emission"), (const void *)0x2E);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("reflective"), (const void *)0x2F);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("normal"), (const void *)0x30);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("ambientOcclusion"), (const void *)0x31);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("selfIllumination"), (const void *)0x32);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("metalness"), (const void *)0x33);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("roughness"), (const void *)0x34);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("selfIlluminationOcclusion"), (const void *)0x39);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("clearCoat"), (const void *)0x35);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("clearCoatRoughness"), (const void *)0x36);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("clearCoatNormal"), (const void *)0x37);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("displacement"), (const void *)0x38);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("transparent"), (const void *)0x3A);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("multiply"), (const void *)0x3B);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("shininess"), (const void *)0x3C);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("transparency"), (const void *)0x3D);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("fresnelExponent"), (const void *)0x3E);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("shaderModifiers"), (const void *)0x43);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("doubleSided"), (const void *)0x3F);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("litPerPixel"), (const void *)0x40);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("cullMode"), (const void *)0x41);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("lockAmbientWithDiffuse"), (const void *)0x42);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("color"), (const void *)0x44);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("contents"), (const void *)0x45);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("texture"), (const void *)0x46);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("image"), (const void *)0x47);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("contentsTransform"), (const void *)0x48);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("borderColor"), (const void *)0x49);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("intensity"), (const void *)0x4A);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("light"), (const void *)0x4B);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("shadowColor"), (const void *)0x4C);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("shadowRadius"), (const void *)0x4D);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("attenuationStart"), (const void *)0x51);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("attenuationEnd"), (const void *)0x52);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("attenuationFalloffExponent"), (const void *)0x53);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("spotInnerAngle"), (const void *)0x54);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("spotOuterAngle"), (const void *)0x55);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("spotFalloffExponent"), (const void *)0x56);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("weights"), (const void *)0x57);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("morpher"), (const void *)0x58);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("background"), (const void *)0x5B);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("environment"), (const void *)0x5C);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("gobo"), (const void *)0x4E);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("probeEnvironment"), (const void *)0x4F);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("ies"), (const void *)0x50);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("customProperty"), (const void *)0x59);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("animations"), (const void *)0x5A);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("euler"), (const void *)0xC);
  CFDictionaryAddValue((CFMutableDictionaryRef)_pathComponentForString__pathComponents, CFSTR("axisAngle"), (const void *)7);
}

__n128 C3DShapeMeshCreationInitProfile(uint64_t a1, __n128 *a2)
{
  CGPath *v4;
  CGPath *Mutable;
  __n128 *v6;
  __n128 *v7;
  unsigned int v8;
  unint64_t v9;
  unsigned __int32 v10;
  NSObject *v11;
  unint64_t v12;
  _BYTE *v13;
  int v14;
  __n128 result;
  __n128 v16;
  __n128 v17;
  unint64_t v18;
  unsigned __int32 v19;

  v4 = *(CGPath **)(a1 + 40);
  Mutable = v4;
  if (!v4)
  {
    Mutable = CGPathCreateMutable();
    CGPathMoveToPoint(Mutable, 0, 0.0, 1.0);
    CGPathAddArcToPoint(Mutable, 0, 1.0, 1.0, 1.0, 0.0, 1.0);
  }
  v19 = 0;
  v18 = 0;
  v16 = 0u;
  v17 = 0u;
  v6 = (__n128 *)C3DShapeBoundaryMakeWithCGPath(Mutable, &v19, *(float *)(a1 + 4) * 0.1, 1.79769313e308);
  v7 = v6;
  if (v6 && (v8 = v6->n128_u32[2], v8 >= 2))
  {
    v9 = v6->n128_u64[0];
    v10 = v6->n128_u32[3];
    v16 = v6[1];
    v17 = v6[2];
    v18 = v6[3].n128_u64[0];
    if (v6->n128_u64[0])
      goto LABEL_11;
  }
  else
  {
    v10 = 0;
    v8 = 0;
  }
  v11 = scn_default_log();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
    C3DShapeMeshCreationInitProfile_cold_1(v11);
  v9 = 0;
LABEL_11:
  if (*(_BYTE *)(v9 + 72))
  {
    *(_BYTE *)(v9 + 72) = 0;
    *(_OWORD *)(v9 + 16) = *(_OWORD *)(v9 + 32);
    --v10;
  }
  v12 = v9 + 80 * (v8 - 1);
  v14 = *(unsigned __int8 *)(v12 + 72);
  v13 = (_BYTE *)(v12 + 72);
  if (v14)
  {
    *v13 = 0;
    --v10;
  }
  if (!v4)
    CGPathRelease(Mutable);
  a2[2].n128_u64[0] = v9;
  a2[2].n128_u32[2] = v8;
  a2[2].n128_u32[3] = v10;
  result = v16;
  a2[3] = v16;
  a2[4] = v17;
  a2[5].n128_u64[0] = v18;
  a2[5].n128_u64[1] = (unint64_t)v7;
  a2[1].n128_u32[3] = v19;
  return result;
}

int32x2_t C3DShapeMeshCreationInitMisc(unsigned int a1, unsigned int a2, uint64_t a3, char a4)
{
  size_t v8;
  void *v9;
  void *v10;
  int32x2_t result;

  if (a1)
  {
    v8 = 12 * a1;
    *(_QWORD *)(a3 + 112) = malloc_type_malloc(v8, 0x10000403E1C8BA9uLL);
    *(_QWORD *)(a3 + 120) = malloc_type_malloc(v8, 0x10000403E1C8BA9uLL);
    v9 = malloc_type_malloc(8 * a1, 0x100004000313F17uLL);
  }
  else
  {
    v9 = 0;
    *(_QWORD *)(a3 + 112) = 0;
    *(_QWORD *)(a3 + 120) = 0;
  }
  *(_QWORD *)(a3 + 104) = v9;
  *(_WORD *)(a3 + 96) = 0;
  if (a2)
    v10 = malloc_type_malloc(8 * a2, 0x2004093837F09uLL);
  else
    v10 = 0;
  *(_QWORD *)(a3 + 128) = v10;
  *(_WORD *)(a3 + 98) = 0;
  *(_DWORD *)(a3 + 136) = 0;
  *(_QWORD *)(a3 + 168) = 0;
  *(_DWORD *)(a3 + 176) = 0;
  *(_QWORD *)(a3 + 144) = 0;
  *(_QWORD *)(a3 + 152) = 0;
  *(_DWORD *)(a3 + 160) = 0;
  *(_QWORD *)(a3 + 184) = 0;
  *(_QWORD *)(a3 + 192) = 0;
  *(_BYTE *)(a3 + 24) = a4;
  if (C3DWasLinkedBeforeMajorOSYear2013())
    *(_BYTE *)(a3 + 24) = 1;
  *(_OWORD *)a3 = xmmword_1DD0075D0;
  result = vdup_n_s32(0xC9742400);
  *(int32x2_t *)(a3 + 16) = result;
  return result;
}

void C3DShapeMeshCreationAppendShape(uint64_t a1, uint64_t a2, uint64_t a3, char a4, double a5, double a6)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  double v11;
  unsigned int v12;
  size_t v13;
  void *v14;
  int v15;
  unsigned int v16;
  double v17;
  int v18;
  float v19;
  uint64_t v20;
  uint64_t v21;
  UInt8 *v22;
  uint64_t v23;
  unsigned __int16 v24;
  float64x2_t v25;
  int v26;
  float64x2_t **v27;
  uint64_t v28;
  float32x2_t *v29;
  float64x2_t *v30;
  float32x2_t v31;
  float32x2_t v32;
  float v33;
  int v34;
  float v35;
  float v36;
  uint64_t v37;
  uint64_t v38;
  UInt8 *v39;
  uint64_t v40;
  unsigned __int16 v41;
  float64x2_t v42;
  float64x2_t **v43;
  uint64_t v44;
  float32x2_t *v45;
  float64x2_t *v46;
  float32x2_t v47;
  float32x2_t v48;
  float v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  int *v55;
  int v56;
  UInt8 *v57;
  UInt8 *v58;
  unint64_t v59;
  unint64_t i;
  float v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  __int16 v68;
  uint64_t v69;
  uint64_t v70;
  unsigned __int16 v71;
  uint64_t v72;
  float64x2_t v73;
  double v74;
  float v75;
  float v76;
  float v77;
  int v78;
  float v79;
  unsigned __int16 v80;
  unsigned __int16 v81;
  float *v82;
  float *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  __int16 v87;
  unsigned __int16 v88;
  float *v89;
  float *v90;
  uint64_t v91;
  uint64_t v92;
  float v93;
  float v94;
  float32x2_t v95;
  float32x2_t v96;
  int8x8_t v97;
  int8x8_t v98;
  int v99;
  __int16 v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  uint64_t v105;
  int *v106;
  int v107;
  unsigned int v108;
  void *v109;
  int v110;
  unsigned int v111;
  unint64_t v112;
  unint64_t v113;
  unsigned __int16 v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  unint64_t v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  uint64_t v123;
  double v124;
  double v125;
  double v126;
  double v127;
  __int128 *v128;
  double v129;
  double v130;
  double v131;
  double v132;
  char v133;
  uint64_t v134;
  unsigned __int16 v135;
  uint64_t v136;
  float v137;
  float v138;
  uint64_t v139;
  int v140;
  uint64_t v141;
  __int128 *v142;
  double v143;
  double v144;
  double v145;
  double v146;
  char v147;
  float (*v148)(uint64_t, float64x2_t *, double, double, float, double, double, double, double);
  unint64_t v149;
  unint64_t v150;
  unsigned __int16 v151;
  uint64_t v152;
  uint64_t v153;
  unint64_t v154;
  unint64_t v155;
  uint64_t *v156;
  uint64_t v157;
  int v158;
  uint64_t v159;
  uint64_t v160;
  double v161;
  double v162;
  double v163;
  double v164;
  __int128 *v165;
  double v166;
  double v167;
  double v168;
  double v169;
  char v170;
  uint64_t v171;
  unsigned __int16 v172;
  uint64_t v173;
  float v174;
  float v175;
  uint64_t v176;
  int v177;
  uint64_t v178;
  __int128 *v179;
  double v180;
  double v181;
  double v182;
  double v183;
  char v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  unint64_t v188;
  unint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  __int16 v194;
  __int16 v195;
  char v196;
  char v197;
  double v198;
  double v199;
  double v201;
  double v202;
  uint64_t v204;
  uint64_t v205;
  __int128 v206;
  double v207;
  double v208;
  double v209;
  double v210;
  __int128 v211;
  uint64_t v212;
  char v213;
  _DWORD v214[3];
  _DWORD v215[2];
  __int128 v216;
  uint64_t v217;
  __int128 v218;
  _QWORD v219[2];
  float (*v220)(uint64_t, float64x2_t *, double, double, float, double, double, double, double);
  void *v221;
  uint64_t v222;
  double v223;
  double v224;
  double v225;
  _QWORD v226[2];
  void (*v227)(uint64_t, char, int, UInt8 *, unsigned int);
  void *v228;
  uint64_t v229;
  char v230;

  v8 = a1;
  v9 = MEMORY[0x1E0C809B0];
  v10 = *(_DWORD *)(a1 + 24);
  v226[0] = MEMORY[0x1E0C809B0];
  v226[1] = 0x40000000;
  v227 = __C3DShapeMeshCreationAppendShape_block_invoke;
  v228 = &__block_descriptor_tmp;
  v229 = a3;
  v230 = a4;
  v11 = *(float *)(a2 + 8);
  if (*(_BYTE *)(a3 + 24) == 1)
  {
    v12 = (unsigned __int16)v10;
    *(_DWORD *)(a3 + 136) = (unsigned __int16)v10;
    v13 = 2 * (unsigned __int16)v10;
    *(_QWORD *)(a3 + 144) = malloc_type_malloc(v13, 0x1000040BDFB0063uLL);
    if (*(float *)(a2 + 8) == 0.0)
      v14 = 0;
    else
      v14 = malloc_type_malloc(v13, 0x1000040BDFB0063uLL);
    v15 = 0;
  }
  else
  {
    v15 = *(_DWORD *)(a3 + 136);
    v12 = (unsigned __int16)v10;
    v16 = v15 + (unsigned __int16)v10;
    *(_DWORD *)(a3 + 136) = v16;
    *(_QWORD *)(a3 + 144) = malloc_type_realloc(*(void **)(a3 + 144), 2 * v16, 0x1000040BDFB0063uLL);
    if (*(float *)(a2 + 8) == 0.0)
      v14 = 0;
    else
      v14 = malloc_type_realloc(*(void **)(a3 + 152), 2 * *(unsigned int *)(a3 + 136), 0x1000040BDFB0063uLL);
  }
  v17 = v11 * 0.5;
  *(_QWORD *)(a3 + 152) = v14;
  if (v12)
  {
    v18 = *(_DWORD *)(a2 + 16);
    v19 = v17;
    v21 = *(_QWORD *)(a3 + 112);
    v20 = *(_QWORD *)(a3 + 120);
    v22 = *(UInt8 **)(a3 + 144);
    v23 = v12;
    v24 = *(_WORD *)(a3 + 96);
    v25.f64[0] = a5;
    v25.f64[1] = a6;
    v26 = v15;
    v27 = *(float64x2_t ***)(v8 + 32);
    do
    {
      v28 = v20 + 12 * v24;
      *(_QWORD *)v28 = 0;
      *(_DWORD *)(v28 + 8) = 1065353216;
      v29 = (float32x2_t *)(v21 + 12 * v24);
      v30 = *v27;
      if (v18 == 2)
      {
        v31.f32[0] = a5 + v30->f64[0];
        v32.f32[0] = a6 + v30->f64[1];
        v29->i32[0] = v31.i32[0];
        v29->i32[1] = v32.i32[0];
        v29[1].f32[0] = v19;
        v32.f32[1] = v17;
      }
      else
      {
        v31 = vcvt_f32_f64(vaddq_f64(v25, v30[3]));
        *v29 = v31;
        v29[1].f32[0] = v19;
        v32 = *(float32x2_t *)((char *)v29 + 4);
      }
      if (v31.f32[0] >= *(float *)a3)
        v31.i32[0] = *(_DWORD *)a3;
      *(_DWORD *)a3 = v31.i32[0];
      *(int8x8_t *)(a3 + 4) = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(a3 + 4), v32), (int8x8_t)v32, *(int8x8_t *)(a3 + 4));
      v33 = v29[1].f32[0];
      if (v33 <= *(float *)(a3 + 20))
        v33 = *(float *)(a3 + 20);
      *(int8x8_t *)(a3 + 12) = vbsl_s8((int8x8_t)vcgt_f32(*v29, *(float32x2_t *)(a3 + 12)), (int8x8_t)*v29, *(int8x8_t *)(a3 + 12));
      *(float *)(a3 + 20) = v33;
      *(_WORD *)&v22[2 * v26] = v24;
      v24 = *(_WORD *)(a3 + 96) + 1;
      *(_WORD *)(a3 + 96) = v24;
      ++v27;
      ++v26;
      --v23;
    }
    while (v23);
    v227((uint64_t)v226, 0, *(unsigned int *)(a3 + 136) / 3uLL, v22, *(_DWORD *)(a3 + 136));
  }
  else
  {
    __C3DShapeMeshCreationAppendShape_block_invoke((uint64_t)v226, 0, *(unsigned int *)(a3 + 136) / 3uLL, *(UInt8 **)(a3 + 144), *(_DWORD *)(a3 + 136));
  }
  if (*(float *)(a2 + 8) > 0.0)
  {
    if (v12)
    {
      v34 = *(_DWORD *)(a2 + 16);
      v35 = v17;
      v36 = -v35;
      v38 = *(_QWORD *)(a3 + 112);
      v37 = *(_QWORD *)(a3 + 120);
      v39 = *(UInt8 **)(a3 + 152);
      v40 = v12;
      v41 = *(_WORD *)(a3 + 96);
      v42.f64[0] = a5;
      v42.f64[1] = a6;
      v43 = *(float64x2_t ***)(v8 + 32);
      do
      {
        v44 = v37 + 12 * v41;
        *(_QWORD *)v44 = 0;
        *(_DWORD *)(v44 + 8) = -1082130432;
        v45 = (float32x2_t *)(v38 + 12 * v41);
        v46 = *v43;
        if (v34 == 1)
        {
          v47.f32[0] = a5 + v46->f64[0];
          v48.f32[0] = a6 + v46->f64[1];
          v45->i32[0] = v47.i32[0];
          v45->i32[1] = v48.i32[0];
          v45[1].f32[0] = v36;
          v48.f32[1] = v36;
        }
        else
        {
          v47 = vcvt_f32_f64(vaddq_f64(v42, v46[3]));
          *v45 = v47;
          v45[1].f32[0] = v36;
          v48 = *(float32x2_t *)((char *)v45 + 4);
        }
        if (v47.f32[0] >= *(float *)a3)
          v47.i32[0] = *(_DWORD *)a3;
        *(_DWORD *)a3 = v47.i32[0];
        *(int8x8_t *)(a3 + 4) = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(a3 + 4), v48), (int8x8_t)v48, *(int8x8_t *)(a3 + 4));
        v49 = v45[1].f32[0];
        if (v49 <= *(float *)(a3 + 20))
          v49 = *(float *)(a3 + 20);
        *(int8x8_t *)(a3 + 12) = vbsl_s8((int8x8_t)vcgt_f32(*v45, *(float32x2_t *)(a3 + 12)), (int8x8_t)*v45, *(int8x8_t *)(a3 + 12));
        *(float *)(a3 + 20) = v49;
        *(_WORD *)&v39[2 * (v15 - 1 + v40)] = v41;
        v41 = *(_WORD *)(a3 + 96) + 1;
        *(_WORD *)(a3 + 96) = v41;
        ++v43;
        --v40;
      }
      while (v40);
    }
    else
    {
      v39 = *(UInt8 **)(a3 + 152);
    }
    v227((uint64_t)v226, 0, *(unsigned int *)(a3 + 136) / 3uLL, v39, *(_DWORD *)(a3 + 136));
  }
  if (v17 > 0.0)
  {
    v50 = *(unsigned int *)(v8 + 48);
    if ((_DWORD)v50)
    {
      v51 = 0;
      v52 = 0;
      v53 = *(_QWORD *)(v8 + 40);
      do
      {
        v54 = *(unsigned int *)(v53 + 32 * v51 + 8);
        if ((_DWORD)v54)
        {
          v55 = (int *)(*(_QWORD *)(v53 + 32 * v51) + 8);
          do
          {
            v56 = *v55;
            v55 += 14;
            v52 += v56;
            --v54;
          }
          while (v54);
        }
        ++v51;
      }
      while (v51 != v50);
    }
    else
    {
      v52 = 0;
    }
    if (*(_BYTE *)(a3 + 24) == 1)
    {
      *(_DWORD *)(a3 + 160) = 0;
      v57 = (UInt8 *)malloc_type_malloc(2 * (6 * v52), 0x1000040BDFB0063uLL);
    }
    else
    {
      v57 = (UInt8 *)malloc_type_realloc(*(void **)(a3 + 168), 2 * (*(_DWORD *)(a3 + 160) + 6 * v52), 0x1000040BDFB0063uLL);
    }
    v58 = v57;
    *(_QWORD *)(a3 + 168) = v57;
    v59 = *(unsigned int *)(v8 + 48);
    if ((_DWORD)v59)
    {
      for (i = 0; i < v59; ++i)
      {
        v62 = *(_QWORD *)(v8 + 40) + 32 * i;
        v63 = *(unsigned int *)(v62 + 8);
        if ((_DWORD)v63)
        {
          v64 = 0;
          v65 = *(_QWORD *)v62;
          do
          {
            v66 = (uint64_t *)(v65 + 56 * v64);
            v67 = *((unsigned int *)v66 + 2);
            v68 = *(_WORD *)(a3 + 96);
            if ((_DWORD)v67)
            {
              v69 = *v66;
              v70 = *(_QWORD *)(a3 + 112);
              v71 = *(_WORD *)(a3 + 96);
              do
              {
                v72 = v69 + 80 * (v67 - 1);
                v73 = *(float64x2_t *)(v72 + 16);
                v74 = *(double *)(v72 + 64);
                v75 = a5 + *(double *)v72;
                v76 = a6 + *(double *)(v72 + 8);
                v77 = v17 - v74;
                v78 = *(_DWORD *)(a2 + 16);
                if (v78 == 2)
                  v77 = v17;
                v79 = v74 - v17;
                if (v78 == 1)
                {
                  v61 = v17;
                  v79 = -v61;
                }
                if ((*(_BYTE *)(v72 + 72) & 1) != 0)
                {
                  v80 = v71 + 1;
                  v81 = v71 + 2;
                  v82 = (float *)(v70 + 12 * v71);
                  *v82 = v75;
                  v82[1] = v76;
                  v82[2] = v77;
                  *(_WORD *)(a3 + 96) = v81;
                  v83 = (float *)(v70 + 12 * v80);
                  *v83 = v75;
                  v83[1] = v76;
                  v83[2] = v79;
                  v84 = *(_QWORD *)(a3 + 120) + 12 * v81;
                  *(float32x2_t *)(v84 - 12) = vcvt_f32_f64(*(float64x2_t *)(v72 + 32));
                  *(_DWORD *)(v84 - 4) = 0;
                  *(_DWORD *)(v84 - 16) = 0;
                  *(_QWORD *)(v84 - 24) = *(_QWORD *)(v84 - 12);
                  v71 = *(_WORD *)(a3 + 96);
                  v70 = *(_QWORD *)(a3 + 112);
                }
                v85 = *(_QWORD *)(a3 + 168);
                v86 = *(unsigned int *)(a3 + 160);
                *(_WORD *)(v85 + 2 * v86) = v71;
                *(_WORD *)(v85 + 2 * (v86 + 1)) = *(_WORD *)(a3 + 96) + 1;
                *(_WORD *)(v85 + 2 * (v86 + 2)) = *(_WORD *)(a3 + 96) + 3;
                *(_WORD *)(v85 + 2 * (v86 + 3)) = *(_WORD *)(a3 + 96);
                *(_WORD *)(v85 + 2 * (v86 + 4)) = *(_WORD *)(a3 + 96) + 3;
                v87 = *(_WORD *)(a3 + 96) + 2;
                *(_DWORD *)(a3 + 160) = v86 + 6;
                *(_WORD *)(v85 + 2 * (v86 + 5)) = v87;
                v88 = *(_WORD *)(a3 + 96);
                LOWORD(v85) = v88 + 1;
                v89 = (float *)(v70 + 12 * v88);
                *v89 = v75;
                v89[1] = v76;
                v89[2] = v77;
                v88 += 2;
                *(_WORD *)(a3 + 96) = v88;
                v90 = (float *)(v70 + 12 * (unsigned __int16)v85);
                *v90 = v75;
                v90[1] = v76;
                v90[2] = v79;
                v91 = *(_QWORD *)(a3 + 120) + 12 * v88;
                *(float32x2_t *)(v91 - 12) = vcvt_f32_f64(v73);
                *(_DWORD *)(v91 - 4) = 0;
                *(_DWORD *)(v91 - 16) = 0;
                *(_QWORD *)(v91 - 24) = *(_QWORD *)(v91 - 12);
                v70 = *(_QWORD *)(a3 + 112);
                v71 = *(_WORD *)(a3 + 96);
                v92 = v70 + 12 * v71;
                v93 = *(float *)(v92 - 16);
                if (v93 >= *(float *)(a3 + 8))
                  v93 = *(float *)(a3 + 8);
                v94 = *(float *)(a3 + 20);
                v95 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)a3, *(float32x2_t *)(v92 - 24)), *(int8x8_t *)(v92 - 24), *(int8x8_t *)a3);
                *(float32x2_t *)a3 = v95;
                *(float *)(a3 + 8) = v93;
                if (*(float *)(v92 - 16) > v94)
                  v94 = *(float *)(v92 - 16);
                v96 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(v92 - 24), *(float32x2_t *)(a3 + 12)), *(int8x8_t *)(v92 - 24), *(int8x8_t *)(a3 + 12));
                *(float32x2_t *)(a3 + 12) = v96;
                *(float *)(a3 + 20) = v94;
                v97 = vbsl_s8((int8x8_t)vcgt_f32(v95, *(float32x2_t *)(v92 - 12)), *(int8x8_t *)(v92 - 12), (int8x8_t)v95);
                if (*(float *)(v92 - 4) < v93)
                  v93 = *(float *)(v92 - 4);
                *(int8x8_t *)a3 = v97;
                *(float *)(a3 + 8) = v93;
                v98 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(v92 - 12), v96), *(int8x8_t *)(v92 - 12), (int8x8_t)v96);
                if (*(float *)(v92 - 4) > v94)
                  v94 = *(float *)(v92 - 4);
                *(int8x8_t *)(a3 + 12) = v98;
                *(float *)(a3 + 20) = v94;
                --v67;
              }
              while (v67);
              v58 = *(UInt8 **)(a3 + 168);
            }
            v99 = *(_DWORD *)(a3 + 160);
            *(_WORD *)&v58[2 * (v99 - 1)] = v68;
            v100 = v68 + 1;
            *(_WORD *)&v58[2 * (v99 - 4)] = v100;
            *(_WORD *)&v58[2 * (v99 - 2)] = v100;
            ++v64;
          }
          while (v64 != v63);
          v59 = *(unsigned int *)(v8 + 48);
        }
      }
    }
    v227((uint64_t)v226, 0, *(unsigned int *)(a3 + 160) / 3uLL, v58, *(_DWORD *)(a3 + 160));
  }
  if (*(float *)(a2 + 12) > 0.0)
  {
    v101 = *(unsigned int *)(v8 + 48);
    if ((_DWORD)v101)
    {
      v102 = 0;
      v103 = 0;
      v104 = *(_QWORD *)(v8 + 40);
      do
      {
        v105 = *(unsigned int *)(v104 + 32 * v102 + 8);
        if ((_DWORD)v105)
        {
          v106 = (int *)(*(_QWORD *)(v104 + 32 * v102) + 8);
          do
          {
            v107 = *v106;
            v106 += 14;
            v103 += v107;
            --v105;
          }
          while (v105);
        }
        ++v102;
      }
      while (v102 != v101);
    }
    else
    {
      v103 = 0;
    }
    if (*(_BYTE *)(a3 + 24) == 1)
    {
      v108 = (6 * *(_DWORD *)(a3 + 40) - 6) * v103;
      *(_DWORD *)(a3 + 176) = v108;
      *(_QWORD *)(a3 + 184) = malloc_type_malloc(2 * v108, 0x1000040BDFB0063uLL);
      v109 = malloc_type_malloc(2 * *(unsigned int *)(a3 + 176), 0x1000040BDFB0063uLL);
      v110 = 0;
    }
    else
    {
      v110 = *(_DWORD *)(a3 + 176);
      v111 = v110 + (6 * *(_DWORD *)(a3 + 40) - 6) * v103;
      *(_DWORD *)(a3 + 176) = v111;
      *(_QWORD *)(a3 + 184) = malloc_type_realloc(*(void **)(a3 + 184), 2 * v111, 0x1000040BDFB0063uLL);
      v109 = malloc_type_realloc(*(void **)(a3 + 192), 2 * *(unsigned int *)(a3 + 176), 0x1000040BDFB0063uLL);
    }
    *(_QWORD *)(a3 + 192) = v109;
    v219[0] = v9;
    v219[1] = 0x40000000;
    v220 = __C3DShapeMeshCreationAppendShape_block_invoke_2;
    v221 = &__block_descriptor_tmp_3;
    v222 = a3;
    v223 = a5;
    v224 = a6;
    v225 = v17;
    v185 = v8;
    if (*(_DWORD *)(a2 + 16) == 2)
    {
      free(*(void **)(a3 + 184));
    }
    else
    {
      v112 = *(unsigned int *)(v8 + 48);
      if ((_DWORD)v112)
      {
        v113 = 0;
        v114 = 0;
        do
        {
          v115 = *(_QWORD *)(v185 + 40) + 32 * v113;
          v190 = *(unsigned int *)(v115 + 8);
          if ((_DWORD)v190)
          {
            v116 = 0;
            v186 = *(_QWORD *)v115;
            v188 = v113;
            LODWORD(v117) = *(_DWORD *)(a3 + 40);
            do
            {
              if ((_DWORD)v117)
              {
                v118 = 0;
                v192 = v116;
                v119 = (uint64_t *)(v186 + 56 * v116);
                v120 = *v119;
                v121 = *((unsigned int *)v119 + 2);
                v122 = *((_DWORD *)v119 + 3);
                v204 = v121;
                do
                {
                  v123 = *(_QWORD *)(a3 + 32) + 80 * v118;
                  v124 = *(double *)v123;
                  v125 = *(double *)(v123 + 8);
                  v198 = *(double *)(v123 + 40);
                  v201 = *(double *)(v123 + 32);
                  v194 = *(_WORD *)(a3 + 96);
                  v196 = *(_BYTE *)(v123 + 72);
                  if ((_DWORD)v121)
                  {
                    v127 = *(double *)(v123 + 16);
                    v126 = *(double *)(v123 + 24);
                    do
                    {
                      v128 = (__int128 *)(v120 + 80 * (v121 - 1));
                      v218 = *v128;
                      v129 = *((double *)v128 + 2);
                      v130 = *((double *)v128 + 3);
                      v131 = *((double *)v128 + 4);
                      v132 = *((double *)v128 + 5);
                      v216 = v128[3];
                      v217 = *((_QWORD *)v128 + 8);
                      v133 = *((_BYTE *)v128 + 72);
                      v215[0] = *(_DWORD *)((char *)v128 + 73);
                      *(_DWORD *)((char *)v215 + 3) = *((_DWORD *)v128 + 19);
                      if ((v133 & 1) != 0)
                      {
                        v206 = v218;
                        v207 = v129;
                        v208 = v130;
                        v209 = v131;
                        v210 = v132;
                        v211 = v216;
                        v212 = v217;
                        v213 = v133;
                        v214[0] = v215[0];
                        *(_DWORD *)((char *)v214 + 3) = *(_DWORD *)((char *)v215 + 3);
                        v220((uint64_t)v219, (float64x2_t *)&v206, v131, v132, 1.0, v124, v125, v127, v126);
                      }
                      if (v118)
                      {
                        v134 = *(_QWORD *)(a3 + 184);
                        *(_WORD *)(v134 + 2 * (v110 + v114)) = *(_WORD *)(a3 + 96);
                        *(_WORD *)(v134 + 2 * (v110 + (unsigned __int16)(v114 + 1))) = *(_WORD *)(a3 + 96) - v122;
                        *(_WORD *)(v134 + 2 * (v110 + (unsigned __int16)(v114 + 2))) = *(_WORD *)(a3 + 96) - v122 + 1;
                        *(_WORD *)(v134 + 2 * (v110 + (unsigned __int16)(v114 + 3))) = *(_WORD *)(a3 + 96);
                        v135 = v114 + 5;
                        *(_WORD *)(v134 + 2 * (v110 + (unsigned __int16)(v114 + 4))) = *(_WORD *)(a3 + 96) - v122 + 1;
                        v114 += 6;
                        *(_WORD *)(v134 + 2 * (v110 + v135)) = *(_WORD *)(a3 + 96) + 1;
                      }
                      v206 = v218;
                      v207 = v129;
                      v208 = v130;
                      v209 = v131;
                      v210 = v132;
                      v211 = v216;
                      v212 = v217;
                      v213 = v133;
                      v214[0] = v215[0];
                      *(_DWORD *)((char *)v214 + 3) = *(_DWORD *)((char *)v215 + 3);
                      v220((uint64_t)v219, (float64x2_t *)&v206, v129, v130, 1.0, v124, v125, v127, v126);
                      v136 = *(_QWORD *)(a3 + 112) + 12 * *(unsigned __int16 *)(a3 + 96);
                      v137 = *(float *)(v136 - 4);
                      if (v137 >= *(float *)(a3 + 8))
                        v137 = *(float *)(a3 + 8);
                      *(int8x8_t *)a3 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)a3, *(float32x2_t *)(v136 - 12)), *(int8x8_t *)(v136 - 12), *(int8x8_t *)a3);
                      *(float *)(a3 + 8) = v137;
                      v138 = *(float *)(v136 - 4);
                      if (v138 <= *(float *)(a3 + 20))
                        v138 = *(float *)(a3 + 20);
                      *(int8x8_t *)(a3 + 12) = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(v136 - 12), *(float32x2_t *)(a3 + 12)), *(int8x8_t *)(v136 - 12), *(int8x8_t *)(a3 + 12));
                      *(float *)(a3 + 20) = v138;
                      --v121;
                    }
                    while (v121);
                  }
                  if (v118)
                  {
                    v139 = *(_QWORD *)(a3 + 184);
                    v140 = v110 + v114;
                    *(_WORD *)(v139 + 2 * (v140 - 1)) = v194;
                    *(_WORD *)(v139 + 2 * (v140 - 4)) = v194 - v122;
                    *(_WORD *)(v139 + 2 * (v140 - 2)) = v194 - v122;
                  }
                  if ((v196 & 1) != 0 && (_DWORD)v204)
                  {
                    v141 = v204;
                    do
                    {
                      v142 = (__int128 *)(v120 + 80 * (v141 - 1));
                      v218 = *v142;
                      v143 = *((double *)v142 + 2);
                      v144 = *((double *)v142 + 3);
                      v145 = *((double *)v142 + 4);
                      v146 = *((double *)v142 + 5);
                      v216 = v142[3];
                      v217 = *((_QWORD *)v142 + 8);
                      v147 = *((_BYTE *)v142 + 72);
                      v215[0] = *(_DWORD *)((char *)v142 + 73);
                      *(_DWORD *)((char *)v215 + 3) = *((_DWORD *)v142 + 19);
                      v148 = v220;
                      if ((v147 & 1) != 0)
                      {
                        v206 = v218;
                        v207 = v143;
                        v208 = v144;
                        v209 = v145;
                        v210 = v146;
                        v211 = v216;
                        v212 = v217;
                        v213 = v147;
                        v214[0] = v215[0];
                        *(_DWORD *)((char *)v214 + 3) = *(_DWORD *)((char *)v215 + 3);
                        v220((uint64_t)v219, (float64x2_t *)&v206, v145, v146, 1.0, v124, v125, v201, v198);
                        v148 = v220;
                      }
                      v206 = v218;
                      v207 = v143;
                      v208 = v144;
                      v209 = v145;
                      v210 = v146;
                      v211 = v216;
                      v212 = v217;
                      v213 = v147;
                      v214[0] = v215[0];
                      *(_DWORD *)((char *)v214 + 3) = *(_DWORD *)((char *)v215 + 3);
                      v148((uint64_t)v219, (float64x2_t *)&v206, v143, v144, 1.0, v124, v125, v201, v198);
                      --v141;
                    }
                    while (v141);
                  }
                  ++v118;
                  v117 = *(unsigned int *)(a3 + 40);
                  v121 = v204;
                }
                while (v118 < v117);
                v113 = v188;
                v116 = v192;
              }
              ++v116;
            }
            while (v116 != v190);
            v112 = *(unsigned int *)(v185 + 48);
          }
          ++v113;
        }
        while (v113 < v112);
      }
      v227((uint64_t)v226, 0, *(unsigned int *)(a3 + 176) / 3uLL, *(UInt8 **)(a3 + 184), *(_DWORD *)(a3 + 176));
      v8 = v185;
    }
    if (*(_DWORD *)(a2 + 16) == 1)
    {
      free(*(void **)(a3 + 192));
    }
    else
    {
      v149 = *(unsigned int *)(v8 + 48);
      if ((_DWORD)v149)
      {
        v150 = 0;
        v151 = 0;
        do
        {
          v152 = *(_QWORD *)(v185 + 40) + 32 * v150;
          v191 = *(unsigned int *)(v152 + 8);
          if ((_DWORD)v191)
          {
            v153 = 0;
            v187 = *(_QWORD *)v152;
            v189 = v150;
            LODWORD(v154) = *(_DWORD *)(a3 + 40);
            do
            {
              if ((_DWORD)v154)
              {
                v155 = 0;
                v193 = v153;
                v156 = (uint64_t *)(v187 + 56 * v153);
                v157 = *v156;
                v159 = *((unsigned int *)v156 + 2);
                v158 = *((_DWORD *)v156 + 3);
                v205 = v159;
                do
                {
                  v160 = *(_QWORD *)(a3 + 32) + 80 * v155;
                  v161 = *(double *)v160;
                  v162 = *(double *)(v160 + 8);
                  v199 = *(double *)(v160 + 40);
                  v202 = *(double *)(v160 + 32);
                  v195 = *(_WORD *)(a3 + 96);
                  v197 = *(_BYTE *)(v160 + 72);
                  if ((_DWORD)v159)
                  {
                    v164 = *(double *)(v160 + 16);
                    v163 = *(double *)(v160 + 24);
                    do
                    {
                      v165 = (__int128 *)(v157 + 80 * (v159 - 1));
                      v218 = *v165;
                      v166 = *((double *)v165 + 2);
                      v167 = *((double *)v165 + 3);
                      v168 = *((double *)v165 + 4);
                      v169 = *((double *)v165 + 5);
                      v216 = v165[3];
                      v217 = *((_QWORD *)v165 + 8);
                      v170 = *((_BYTE *)v165 + 72);
                      v215[0] = *(_DWORD *)((char *)v165 + 73);
                      *(_DWORD *)((char *)v215 + 3) = *((_DWORD *)v165 + 19);
                      if ((v170 & 1) != 0)
                      {
                        v206 = v218;
                        v207 = v166;
                        v208 = v167;
                        v209 = v168;
                        v210 = v169;
                        v211 = v216;
                        v212 = v217;
                        v213 = v170;
                        v214[0] = v215[0];
                        *(_DWORD *)((char *)v214 + 3) = *(_DWORD *)((char *)v215 + 3);
                        v220((uint64_t)v219, (float64x2_t *)&v206, v168, v169, -1.0, v161, v162, v164, v163);
                      }
                      if (v155)
                      {
                        v171 = *(_QWORD *)(a3 + 192);
                        *(_WORD *)(v171 + 2 * (v110 + v151)) = *(_WORD *)(a3 + 96);
                        *(_WORD *)(v171 + 2 * (v110 + (unsigned __int16)(v151 + 1))) = *(_WORD *)(a3 + 96) - v158 + 1;
                        *(_WORD *)(v171 + 2 * (v110 + (unsigned __int16)(v151 + 2))) = *(_WORD *)(a3 + 96) - v158;
                        *(_WORD *)(v171 + 2 * (v110 + (unsigned __int16)(v151 + 3))) = *(_WORD *)(a3 + 96);
                        v172 = v151 + 5;
                        *(_WORD *)(v171 + 2 * (v110 + (unsigned __int16)(v151 + 4))) = *(_WORD *)(a3 + 96) + 1;
                        v151 += 6;
                        *(_WORD *)(v171 + 2 * (v110 + v172)) = *(_WORD *)(a3 + 96) - v158 + 1;
                      }
                      v206 = v218;
                      v207 = v166;
                      v208 = v167;
                      v209 = v168;
                      v210 = v169;
                      v211 = v216;
                      v212 = v217;
                      v213 = v170;
                      v214[0] = v215[0];
                      *(_DWORD *)((char *)v214 + 3) = *(_DWORD *)((char *)v215 + 3);
                      v220((uint64_t)v219, (float64x2_t *)&v206, v166, v167, -1.0, v161, v162, v164, v163);
                      v173 = *(_QWORD *)(a3 + 112) + 12 * *(unsigned __int16 *)(a3 + 96);
                      v174 = *(float *)(v173 - 4);
                      if (v174 >= *(float *)(a3 + 8))
                        v174 = *(float *)(a3 + 8);
                      *(int8x8_t *)a3 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)a3, *(float32x2_t *)(v173 - 12)), *(int8x8_t *)(v173 - 12), *(int8x8_t *)a3);
                      *(float *)(a3 + 8) = v174;
                      v175 = *(float *)(v173 - 4);
                      if (v175 <= *(float *)(a3 + 20))
                        v175 = *(float *)(a3 + 20);
                      *(int8x8_t *)(a3 + 12) = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(v173 - 12), *(float32x2_t *)(a3 + 12)), *(int8x8_t *)(v173 - 12), *(int8x8_t *)(a3 + 12));
                      *(float *)(a3 + 20) = v175;
                      --v159;
                    }
                    while (v159);
                  }
                  if (v155)
                  {
                    v176 = *(_QWORD *)(a3 + 192);
                    v177 = v110 + v151;
                    *(_WORD *)(v176 + 2 * (v177 - 2)) = v195;
                    *(_WORD *)(v176 + 2 * (v177 - 1)) = v195 - v158;
                    *(_WORD *)(v176 + 2 * (v177 - 5)) = v195 - v158;
                  }
                  if ((v197 & 1) != 0 && (_DWORD)v205)
                  {
                    v178 = v205;
                    do
                    {
                      v179 = (__int128 *)(v157 + 80 * (v178 - 1));
                      v218 = *v179;
                      v180 = *((double *)v179 + 2);
                      v181 = *((double *)v179 + 3);
                      v182 = *((double *)v179 + 4);
                      v183 = *((double *)v179 + 5);
                      v216 = v179[3];
                      v217 = *((_QWORD *)v179 + 8);
                      v184 = *((_BYTE *)v179 + 72);
                      v215[0] = *(_DWORD *)((char *)v179 + 73);
                      *(_DWORD *)((char *)v215 + 3) = *((_DWORD *)v179 + 19);
                      if ((v184 & 1) != 0)
                      {
                        v206 = v218;
                        v207 = v180;
                        v208 = v181;
                        v209 = v182;
                        v210 = v183;
                        v211 = v216;
                        v212 = v217;
                        v213 = v184;
                        v214[0] = v215[0];
                        *(_DWORD *)((char *)v214 + 3) = *(_DWORD *)((char *)v215 + 3);
                        v220((uint64_t)v219, (float64x2_t *)&v206, v182, v183, -1.0, v161, v162, v202, v199);
                      }
                      v206 = v218;
                      v207 = v180;
                      v208 = v181;
                      v209 = v182;
                      v210 = v183;
                      v211 = v216;
                      v212 = v217;
                      v213 = v184;
                      v214[0] = v215[0];
                      *(_DWORD *)((char *)v214 + 3) = *(_DWORD *)((char *)v215 + 3);
                      v220((uint64_t)v219, (float64x2_t *)&v206, v180, v181, -1.0, v161, v162, v202, v199);
                      --v178;
                    }
                    while (v178);
                  }
                  ++v155;
                  v154 = *(unsigned int *)(a3 + 40);
                  v159 = v205;
                }
                while (v155 < v154);
                v150 = v189;
                v153 = v193;
              }
              ++v153;
            }
            while (v153 != v191);
            v149 = *(unsigned int *)(v185 + 48);
          }
          ++v150;
        }
        while (v150 < v149);
      }
      v227((uint64_t)v226, 0, *(unsigned int *)(a3 + 176) / 3uLL, *(UInt8 **)(a3 + 192), *(_DWORD *)(a3 + 176));
    }
  }
}

uint64_t C3DShapeMeshCreationCreateMesh(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  __int128 *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  void *v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float *v16;
  float *v17;
  float *v18;
  uint64_t v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  BOOL v34;
  CFIndex v35;
  const __CFAllocator *v36;
  __CFData *Mutable;
  __CFData *v38;
  __CFData *v39;
  const CFArrayCallBacks *v40;
  const __CFArray *v41;
  const __CFArray *v42;
  unsigned int v43;
  unint64_t v44;
  const void *v45;
  uint64_t v46;
  __int16 v48;
  char v49;
  void *values[2];
  CFTypeRef cf[2];
  __int128 v52;
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 28))
  {
    v2 = 0;
    v3 = 0;
    do
    {
      v4 = (__int128 *)(*(_QWORD *)(a1 + 88) + v2);
      v5 = *v4;
      v6 = v4[1];
      v7 = v4[2];
      v53 = *((_QWORD *)v4 + 6);
      *(_OWORD *)cf = v6;
      v52 = v7;
      *(_OWORD *)values = v5;
      C3DShapeBoundaryDestroy(values);
      ++v3;
      v2 += 56;
    }
    while (v3 < *(unsigned int *)(a1 + 28));
  }
  v8 = *(void **)(a1 + 88);
  if (v8)
    free(v8);
  v9 = *(unsigned __int16 *)(a1 + 96);
  if (*(_WORD *)(a1 + 96))
  {
    v10 = *(float *)a1;
    v11 = *(float *)(a1 + 4);
    v12 = *(float *)(a1 + 8);
    v13 = *(float *)(a1 + 12) - *(float *)a1;
    v14 = *(float *)(a1 + 16) - v11;
    v15 = *(float *)(a1 + 20) - v12;
    v16 = (float *)(*(_QWORD *)(a1 + 112) + 8);
    v17 = (float *)(*(_QWORD *)(a1 + 104) + 4);
    v18 = (float *)(*(_QWORD *)(a1 + 120) + 4);
    v19 = *(unsigned __int16 *)(a1 + 96);
    do
    {
      v20 = *(v16 - 2);
      v21 = *(v16 - 1);
      v22 = *v16;
      v23 = *(v18 - 1);
      v24 = v18[1];
      v25 = fabsf(v23);
      v26 = fabsf(*v18);
      v27 = fabsf(v24);
      if (v25 <= v26)
      {
        v32 = (float)(v20 - v10) / v13;
        if (v24 > 0.0)
          v33 = (float)(v20 - v10) / v13;
        else
          v33 = 1.0 - v32;
        v31 = (float)(v22 - v12) / v15;
        if (*v18 <= 0.0)
          v32 = 1.0 - v32;
        v34 = v26 <= v27;
        if (v26 > v27)
          v30 = v32;
        else
          v30 = v33;
        if (v34)
          v31 = 1.0 - (float)((float)(v21 - v11) / v14);
      }
      else
      {
        v28 = (float)(v20 - v10) / v13;
        if (v24 <= 0.0)
          v28 = 1.0 - v28;
        v29 = (float)(v22 - v12) / v15;
        if (v23 <= 0.0)
          v29 = 1.0 - v29;
        if (v25 > v27)
          v30 = v29;
        else
          v30 = v28;
        v31 = 1.0 - (float)((float)(v21 - v11) / v14);
      }
      *(v17 - 1) = v30;
      *v17 = v31;
      v16 += 3;
      v17 += 2;
      v18 += 3;
      --v19;
    }
    while (v19);
    v35 = 12 * v9;
  }
  else
  {
    v35 = 0;
  }
  v36 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v35);
  CFDataAppendBytes(Mutable, *(const UInt8 **)(a1 + 112), 12 * *(unsigned __int16 *)(a1 + 96));
  values[0] = (void *)C3DMeshSourceCreate(Mutable, 0, *(unsigned __int16 *)(a1 + 96), 3, 1);
  if (Mutable)
    CFRelease(Mutable);
  v38 = CFDataCreateMutable(v36, 12 * *(unsigned __int16 *)(a1 + 96));
  CFDataAppendBytes(v38, *(const UInt8 **)(a1 + 120), 12 * *(unsigned __int16 *)(a1 + 96));
  values[1] = (void *)C3DMeshSourceCreate(v38, 1, *(unsigned __int16 *)(a1 + 96), 3, 1);
  if (v38)
    CFRelease(v38);
  v39 = CFDataCreateMutable(v36, 8 * *(unsigned __int16 *)(a1 + 96));
  CFDataAppendBytes(v39, *(const UInt8 **)(a1 + 104), 8 * *(unsigned __int16 *)(a1 + 96));
  cf[0] = (CFTypeRef)C3DMeshSourceCreate(v39, 3, *(unsigned __int16 *)(a1 + 96), 2, 1);
  if (v39)
    CFRelease(v39);
  free(*(void **)(a1 + 120));
  free(*(void **)(a1 + 112));
  free(*(void **)(a1 + 104));
  v49 = 0;
  v48 = 0;
  v40 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  v41 = CFArrayCreate(v36, (const void **)values, 3, MEMORY[0x1E0C9B378]);
  v42 = CFArrayCreate(v36, *(const void ***)(a1 + 128), *(unsigned __int16 *)(a1 + 98), v40);
  v43 = *(unsigned __int16 *)(a1 + 98);
  if (*(_WORD *)(a1 + 98))
  {
    v44 = 0;
    do
    {
      v45 = *(const void **)(*(_QWORD *)(a1 + 128) + 8 * v44);
      if (v45)
      {
        CFRelease(v45);
        *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * v44) = 0;
        v43 = *(unsigned __int16 *)(a1 + 98);
      }
      ++v44;
    }
    while (v44 < v43);
  }
  free(*(void **)(a1 + 128));
  v46 = C3DMeshCreateWithMeshSourcesAndMeshElements(v41, v42, (uint64_t)&v48);
  if (v42)
    CFRelease(v42);
  if (v41)
    CFRelease(v41);
  if (values[0])
  {
    CFRelease(values[0]);
    values[0] = 0;
  }
  if (values[1])
  {
    CFRelease(values[1]);
    values[1] = 0;
  }
  if (cf[0])
    CFRelease(cf[0]);
  return v46;
}

uint64_t C3DMeshCreateShape(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  int v5;
  int v6;
  float v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  int v16;
  __int128 v17;
  uint64_t result;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  __n128 v23[2];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = 0;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  memset(v23, 0, sizeof(v23));
  v4 = a2[1];
  v19 = *a2;
  v20 = v4;
  v21 = a2[2];
  v22 = *((_QWORD *)a2 + 6);
  C3DShapeMeshCreationInitProfile((uint64_t)&v19, v23);
  if (*((float *)a2 + 3) <= 0.0)
  {
    v6 = 0;
  }
  else
  {
    v5 = *((_DWORD *)a2 + 4);
    if (v5 == 2)
      v6 = 1;
    else
      v6 = (v5 != 1) + 1;
  }
  v7 = *((float *)a2 + 2);
  v8 = *(_DWORD *)(a1 + 24) << (v7 > 0.0);
  if (v7 <= 0.0)
    v9 = v6 + 1;
  else
    v9 = v6 + 3;
  v10 = *(unsigned int *)(a1 + 48);
  if ((_DWORD)v10)
  {
    v11 = 0;
    v12 = HIDWORD(v24) * v6 + 2 * (v7 > 0.0);
    do
    {
      v13 = *(_QWORD *)(a1 + 40) + 32 * v11;
      v14 = *(unsigned int *)(v13 + 8);
      if ((_DWORD)v14)
      {
        v15 = (int *)(*(_QWORD *)v13 + 12);
        do
        {
          v16 = *v15;
          v15 += 14;
          v8 += v12 * v16;
          --v14;
        }
        while (v14);
      }
      ++v11;
    }
    while (v11 != v10);
  }
  C3DShapeMeshCreationInitMisc(v8, v9, (uint64_t)v23, 0);
  v17 = a2[1];
  v19 = *a2;
  v20 = v17;
  v21 = a2[2];
  v22 = *((_QWORD *)a2 + 6);
  C3DShapeMeshCreationAppendShape(a1, (uint64_t)&v19, (uint64_t)v23, 1, *MEMORY[0x1E0C9D538], *(double *)(MEMORY[0x1E0C9D538] + 8));
  result = C3DShapeMeshCreationCreateMesh((uint64_t)v23);
  if (!result)
    return C3DMeshCreate();
  return result;
}

uint64_t C3DMeshCreateText(uint64_t a1, __int128 *a2, uint64_t a3, float64_t a4, float64_t a5)
{
  __int128 v7;
  float v8;
  float v9;
  unsigned int v10;
  unsigned int v11;
  CFIndex v12;
  int v13;
  int v14;
  int v15;
  int v16;
  CFArrayRef *ValueAtIndex;
  CFIndex v18;
  CFArrayRef *GlyphAtIndex;
  uint64_t v20;
  uint64_t i;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  NSObject *v26;
  uint64_t result;
  CFIndex Count;
  CGPoint *v29;
  CFIndex v30;
  float64x2_t v31;
  CFArrayRef *v32;
  unsigned int GlyphCount;
  float64x2_t *v34;
  double v35;
  CFIndex j;
  CFArrayRef *v37;
  char v39;
  float64x2_t v40;
  __int128 v41;
  CFIndex v44;
  float64x2_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  __n128 v51[2];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;
  CFRange v63;

  if (a1)
  {
    v62 = 0;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    memset(v51, 0, sizeof(v51));
    v7 = a2[1];
    v47 = *a2;
    v48 = v7;
    v49 = a2[2];
    v50 = *((_QWORD *)a2 + 6);
    C3DShapeMeshCreationInitProfile((uint64_t)&v47, v51);
    v8 = *((float *)a2 + 2);
    v9 = *((float *)a2 + 3);
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 24)) < 1)
    {
      v11 = 0;
      v10 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = v8 > 0.0;
      v14 = 2 * (v9 > 0.0);
      if (v8 > 0.0)
        v15 = v14 + 3;
      else
        v15 = v14 + 1;
      v16 = HIDWORD(v52) * v14 + 2 * v13;
      do
      {
        ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v12);
        if (C3DTextLineGetGlyphCount((CFIndex)ValueAtIndex))
        {
          v18 = 0;
          do
          {
            GlyphAtIndex = C3DTextLineGetGlyphAtIndex(ValueAtIndex, v18);
            v10 += *((_DWORD *)GlyphAtIndex + 6) << v13;
            v20 = *((unsigned int *)GlyphAtIndex + 12);
            if ((_DWORD)v20)
            {
              for (i = 0; i != v20; ++i)
              {
                v22 = (uint64_t)GlyphAtIndex[5] + 32 * i;
                v23 = *(unsigned int *)(v22 + 8);
                if ((_DWORD)v23)
                {
                  v24 = (int *)(*(_QWORD *)v22 + 12);
                  do
                  {
                    v25 = *v24;
                    v24 += 14;
                    v10 += v16 * v25;
                    --v23;
                  }
                  while (v23);
                }
              }
            }
            v11 += v15;
            v18 = (v18 + 1);
          }
          while (v18 < C3DTextLineGetGlyphCount((CFIndex)ValueAtIndex));
        }
        ++v12;
      }
      while (v12 < CFArrayGetCount(*(CFArrayRef *)(a1 + 24)));
    }
    C3DShapeMeshCreationInitMisc(v10, v11, (uint64_t)v51, *(_BYTE *)(a3 + 34));
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
    v29 = (CGPoint *)malloc_type_malloc(16 * Count, 0x1000040451B5BE8uLL);
    v63.location = 0;
    v63.length = 0;
    CTFrameGetLineOrigins(*(CTFrameRef *)(a1 + 16), v63, v29);
    v44 = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
    if (v44 >= 1)
    {
      v30 = 0;
      v31.f64[0] = a4;
      v31.f64[1] = a5;
      v46 = v31;
      do
      {
        v32 = (CFArrayRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v30);
        GlyphCount = C3DTextLineGetGlyphCount((CFIndex)v32);
        v34 = (float64x2_t *)malloc_type_malloc(16 * GlyphCount, 0x1000040451B5BE8uLL);
        C3DTextLineGetAdvances((uint64_t)v32, (uint64_t)v34, GlyphCount, v35);
        if (GlyphCount)
        {
          for (j = 0; j != GlyphCount; ++j)
          {
            v37 = C3DTextLineGetGlyphAtIndex(v32, j);
            v39 = v30 == v44 - 1 && GlyphCount - 1 == j;
            v40 = vaddq_f64(vaddq_f64(v46, (float64x2_t)v29[v30]), v34[j]);
            v41 = a2[1];
            v47 = *a2;
            v48 = v41;
            v49 = a2[2];
            v50 = *((_QWORD *)a2 + 6);
            C3DShapeMeshCreationAppendShape((uint64_t)v37, (uint64_t)&v47, (uint64_t)v51, v39, v40.f64[0], v40.f64[1]);
          }
        }
        free(v34);
        ++v30;
      }
      while (v30 != v44);
    }
    free(v29);
    result = C3DShapeMeshCreationCreateMesh((uint64_t)v51);
    if (!result)
      return C3DMeshCreate();
  }
  else
  {
    v26 = scn_default_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      C3DMeshCreateText_cold_1(v26);
    return 0;
  }
  return result;
}

const void *C3DKeyValueStoreGetValueForKey(uint64_t a1, const void *a2)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), a2);
}

void C3DKeyValueStoreResetValueForKey(uint64_t a1, const void *a2)
{
  _QWORD *Value;
  _QWORD *v5;
  CFTypeID v6;
  int v7;
  void *v8;
  uint64_t v9;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), a2);
  if (Value)
  {
    v5 = Value;
    v6 = CFGetTypeID(Value);
    if (v6 == C3DValueGetTypeID())
    {
      v7 = *((unsigned __int16 *)v5 + 8);
      v8 = (void *)v5[3];
      if (v7 == 11)
      {
        C3DMatrix4x4MakeIdentity(v5[3]);
      }
      else
      {
        v9 = C3DSizeOfBaseType((__int16)v7);
        bzero(v8, v5[4] * v9);
      }
    }
    else
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 64), a2);
    }
    ++*(_DWORD *)(a1 + 72);
  }
}

uint64_t C3DKeyValueStoreGetTimestamp(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t C3DKeyValueStoreEnumerate(uint64_t a1, uint64_t a2)
{
  void *v2;
  _QWORD v4[5];

  v2 = *(void **)(a1 + 64);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __C3DKeyValueStoreEnumerate_block_invoke;
  v4[3] = &unk_1EA59D4A8;
  v4[4] = a2;
  return objc_msgSend(v2, "enumerateKeysAndObjectsUsingBlock:", v4);
}

id _C3DKeyValueStoreCFFinalize(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 64));
  return C3DEntityCFFinalize(a1);
}

CFStringRef _C3DKeyValueStoreCFCopyFormatDescription(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<C3DKeyValueStore>"));
}

CFStringRef _C3DKeyValueStoreCFCopyDebugDescription(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<C3DKeyValueStore>"));
}

void *_C3DKeyValueStoreSetValue(uint64_t a1, void *__dst, void *__src, size_t __n)
{
  void *result;

  result = memcpy(__dst, __src, __n);
  ++*(_DWORD *)(a1 + 72);
  return result;
}

BOOL std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s);
  if (*((char *)a1 + 23) < 0)
  {
    if (v4 == a1[1])
    {
      if (v4 == -1)
        goto LABEL_10;
      a1 = (_QWORD *)*a1;
      return memcmp(a1, __s, v4) == 0;
    }
  }
  else if (v4 == *((unsigned __int8 *)a1 + 23))
  {
    if (v4 == -1)
LABEL_10:
      abort();
    return memcmp(a1, __s, v4) == 0;
  }
  return 0;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
  abort();
}

BOOL std::less<std::string>::operator()[abi:nn180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

_QWORD *std::string::basic_string[abi:nn180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

void _C3DSceneSourceCFFinalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  if (a1)
  {
    v2 = (const void *)a1[2];
    if (v2)
      CFRelease(v2);
    v3 = (const void *)a1[3];
    if (v3)
      CFRelease(v3);
    v4 = (const void *)a1[6];
    if (v4)
      CFRelease(v4);
    v5 = (const void *)a1[5];
    if (v5)
      CFRelease(v5);
  }
}

CFStringRef _C3DSceneSourceCFCopyFormatDescription(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<C3DSceneSource >"));
}

CFStringRef _C3DSceneSourceCFCopyDebugDescription(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<C3DSceneSource >"));
}

uint64_t C3DSceneSourceCreate()
{
  uint64_t Instance;

  if (C3DSceneSourceGetTypeID_onceToken != -1)
    dispatch_once(&C3DSceneSourceGetTypeID_onceToken, &__block_literal_global_0);
  Instance = C3DTypeCreateInstance_(C3DSceneSourceGetTypeID_typeID, 0x28uLL);
  *(_QWORD *)(Instance + 48) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  return Instance;
}

uint64_t C3DSceneSourceCreateWithURL(const void *a1)
{
  uint64_t v2;

  v2 = C3DSceneSourceCreate();
  *(_QWORD *)(v2 + 16) = CFRetain(a1);
  return v2;
}

uint64_t C3DSceneSourceCreateWithData(const void *a1)
{
  uint64_t v2;
  CFTypeRef v3;

  v2 = C3DSceneSourceCreate();
  if (a1)
    v3 = CFRetain(a1);
  else
    v3 = 0;
  *(_QWORD *)(v2 + 24) = v3;
  return v2;
}

uint64_t C3DSceneSourceGetURL(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t C3DSceneSourceGetData(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

void C3DSceneSourceSetLibrary(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
  *(_QWORD *)(a1 + 40) = cf;
  if (cf)
    CFRetain(cf);
}

void C3DSceneSourceSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), a2, a3);
}

CFDictionaryRef C3DSceneSourceCopyPropertiesAtIndex(uint64_t a1, uint64_t a2)
{
  if (a2)
    return 0;
  else
    return CFDictionaryCreateCopy(0, *(CFDictionaryRef *)(a1 + 48));
}

__CFDictionary *__CreateViewerOptionsWithOptions(CFDictionaryRef theDict)
{
  const __CFAllocator *v2;
  __CFDictionary *MutableCopy;
  __CFDictionary *v4;
  const void *v5;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (theDict)
    MutableCopy = CFDictionaryCreateMutableCopy(v2, 0, theDict);
  else
    MutableCopy = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v4 = MutableCopy;
  v5 = (const void *)*MEMORY[0x1E0C9AE50];
  CFDictionaryAddValue(MutableCopy, CFSTR("kSceneSourceCreateCameraIfAbsent"), (const void *)*MEMORY[0x1E0C9AE50]);
  CFDictionaryAddValue(v4, CFSTR("kSceneSourceCreateNormalsIfAbsent"), v5);
  CFDictionaryAddValue(v4, CFSTR("kSceneSourceCreateLightIfAbsent"), v5);
  CFDictionaryAddValue(v4, CFSTR("kSceneSourceAdjustInvalidClippingPlanes"), v5);
  CFDictionaryAddValue(v4, CFSTR("kSceneSourceFlattenScene"), (const void *)*MEMORY[0x1E0C9AE40]);
  CFDictionaryAddValue(v4, CFSTR("kSceneSourceSplitMeshesForGLES"), v5);
  CFDictionaryAddValue(v4, CFSTR("kSceneSourceAutoLimitMemoryForImages"), v5);
  CFDictionaryAddValue(v4, CFSTR("triggerOptionsForRealtimeViewer"), v5);
  CFDictionaryAddValue(v4, CFSTR("kSceneSourceAnimationLoadingMode"), CFSTR("playUsingSceneTime"));
  return v4;
}

__CFDictionary *C3DIOCreateImportContextFromOptions(CFDictionaryRef theDict, const __CFURL *a2)
{
  const __CFAllocator *v3;
  const __CFDictionary *MutableCopy;
  __CFDictionary *v5;
  const __CFArray *Value;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v8;
  CFStringRef v9;
  CFURLRef PathComponent;
  CFURLRef v11;
  const __CFURL *v13;
  CFURLRef v14;
  CFRange v15;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (theDict)
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theDict);
  else
    MutableCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = MutableCopy;
  Value = (const __CFArray *)CFDictionaryGetValue(MutableCopy, CFSTR("kSceneSourceAssetDirectoryURLs"));
  if (Value)
    Mutable = CFArrayCreateMutableCopy(v3, 0, Value);
  else
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v8 = Mutable;
  CFDictionarySetValue(v5, CFSTR("kSceneSourceAssetDirectoryURLs"), Mutable);
  CFRelease(v8);
  v9 = CFURLCopyScheme(a2);
  PathComponent = CFURLCreateCopyDeletingLastPathComponent(0, a2);
  if (PathComponent)
  {
    v11 = PathComponent;
    CFDictionarySetValue(v5, CFSTR("kEnclosingDirectoryURL"), PathComponent);
    v15.length = CFArrayGetCount(v8);
    v15.location = 0;
    if (!CFArrayContainsValue(v8, v15, v11))
      CFArrayAppendValue(v8, v11);
    CFRelease(v11);
  }
  if (!CFDictionaryGetValue(v5, CFSTR("kEnclosingFolderURL")))
  {
    v13 = CFURLCreateCopyDeletingLastPathComponent(v3, a2);
    v14 = C3DCopyResolvedURLFromFileURL(v13);
    CFDictionarySetValue(v5, CFSTR("kEnclosingFolderURL"), v14);
    CFRelease(v13);
    CFRelease(v14);
    if (!v9)
      return v5;
    goto LABEL_13;
  }
  if (v9)
LABEL_13:
    CFRelease(v9);
  return v5;
}

uint64_t C3DSceneSourceGetFileFormat(uint64_t a1)
{
  const __CFData *v2;
  const UInt8 *BytePtr;
  uint64_t v5;
  const __CFURL *v6;
  const __CFURL *v7;
  const __CFAllocator *v8;
  __CFReadStream *v9;
  __CFReadStream *v10;
  CFIndex v11;
  _BOOL4 v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFString *v20;
  const __CFString *v21;
  _BOOL4 v22;
  const __CFString *v23;
  const __CFString *v24;
  __CFString *MutableCopy;
  const __CFString *v26;
  CFComparisonResult v27;
  _BOOL4 v29;
  UInt8 buffer[4];
  __int16 v32;

  v2 = *(const __CFData **)(a1 + 24);
  if (!v2)
  {
    v6 = *(const __CFURL **)(a1 + 16);
    if (!v6)
      return -1;
    v7 = CFURLCopyAbsoluteURL(v6);
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v9 = CFReadStreamCreateWithFile((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7);
    if (v9)
    {
      v10 = v9;
      if (CFReadStreamOpen(v9))
      {
        v11 = CFReadStreamRead(v10, buffer, 6);
        v12 = v11 != 6;
        if (v11 == 6)
        {
          v29 = *(_DWORD *)buffer != 1768714338 || v32 != 29811;
          CFReadStreamClose(v10);
          CFRelease(v10);
          if (!v29)
            goto LABEL_24;
        }
        else
        {
          CFReadStreamClose(v10);
          CFRelease(v10);
        }
LABEL_20:
        v20 = CFURLCopyPathExtension(v7);
        if (v20)
        {
          v21 = v20;
          v22 = CFStringCompare(v20, CFSTR("c3d"), 1uLL) == kCFCompareEqualTo;
          CFRelease(v21);
        }
        else
        {
          v22 = 0;
        }
        if (!v12 && !v22)
        {
          v23 = CFURLCopyPathExtension(v7);
          if (v23)
          {
            v24 = v23;
            MutableCopy = CFStringCreateMutableCopy(v8, 0, v23);
            if (MutableCopy)
            {
              v26 = MutableCopy;
              CFStringLowercase(MutableCopy, 0);
              v27 = CFStringCompare(v26, CFSTR("dae"), 0);
              CFRelease(v26);
              CFRelease(v24);
              if (v27 == kCFCompareEqualTo)
              {
                v5 = 0;
                goto LABEL_39;
              }
            }
            else
            {
              CFRelease(v24);
            }
          }
          v5 = -1;
          goto LABEL_39;
        }
LABEL_24:
        v5 = 1;
LABEL_39:
        CFRelease(v7);
        return v5;
      }
      CFRelease(v10);
    }
    else
    {
      v13 = scn_default_log();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        C3DSceneSourceGetFileFormat_cold_1((uint64_t)v7, v13, v14, v15, v16, v17, v18, v19);
    }
    v12 = 1;
    goto LABEL_20;
  }
  BytePtr = CFDataGetBytePtr(v2);
  if ((unint64_t)CFDataGetLength(*(CFDataRef *)(a1 + 24)) < 6)
    return 0;
  return *(_DWORD *)BytePtr == 1768714338 && *((_WORD *)BytePtr + 2) == 29811;
}

__n128 *C3DSceneSourceCreateSceneAtIndex(_QWORD *a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4)
{
  CFURLRef *v7;
  const void *Value;
  __CFDictionary *ViewerOptionsWithOptions;
  const void *v10;
  uint64_t FileFormat;
  const __CFData *v12;
  __n128 *v13;
  const __CFURL *v14;
  const __CFURL *v15;
  __n128 *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFErrorRef Error;

  os_unfair_lock_lock((os_unfair_lock_t)&scene_source_mutex);
  v7 = (CFURLRef *)(a1 + 2);
  if (!a1[2] && !a1[3])
  {
    v16 = 0;
    goto LABEL_27;
  }
  if (a3
    && (Value = CFDictionaryGetValue(a3, CFSTR("triggerOptionsForRealtimeViewer"))) != 0
    && CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
  {
    ViewerOptionsWithOptions = __CreateViewerOptionsWithOptions(a3);
    a3 = ViewerOptionsWithOptions;
  }
  else
  {
    ViewerOptionsWithOptions = 0;
  }
  v10 = (const void *)C3DLibraryCreate();
  C3DSceneSourceSetLibrary((uint64_t)a1, v10);
  FileFormat = C3DSceneSourceGetFileFormat((uint64_t)a1);
  v12 = (const __CFData *)a1[3];
  if (!v12)
  {
    v14 = CFURLCopyAbsoluteURL(*v7);
    v15 = v14;
    if (FileFormat == -1)
    {
      Error = C3DSceneSourceCreateError(-6, CFSTR("Unknown or missing file"));
      (*(void (**)(uint64_t, uint64_t, CFErrorRef, _QWORD, float))(a4 + 16))(a4, 0xFFFFFFFFLL, Error, 0, 1.0);
      CFRelease(Error);
    }
    else if (FileFormat == 1)
    {
      v16 = C3DIOCreateSceneAtURL(v14, (uint64_t)a1, v10, a3, a4);
      goto LABEL_21;
    }
    v16 = 0;
LABEL_21:
    CFRelease(v15);
    if (!v16)
      goto LABEL_23;
LABEL_22:
    C3DIOFinalizeLoadScene((uint64_t)v16, v10, a3, a1[6], FileFormat);
    goto LABEL_23;
  }
  if (FileFormat != 1)
  {
    v17 = scn_default_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      C3DSceneSourceCreateSceneAtIndex_cold_1((uint64_t)v7, v17, v18, v19, v20, v21, v22, v23);
    v16 = 0;
    goto LABEL_23;
  }
  if (*v7)
    v13 = C3DIOCreateSceneAtURL(*v7, (uint64_t)a1, v10, a3, a4);
  else
    v13 = C3DIOCreateSceneWithData(v12, (uint64_t)a1, v10, a3, a4);
  v16 = v13;
  if (v13)
    goto LABEL_22;
LABEL_23:
  if (v10)
    CFRelease(v10);
  if (ViewerOptionsWithOptions)
    CFRelease(ViewerOptionsWithOptions);
LABEL_27:
  os_unfair_lock_unlock((os_unfair_lock_t)&scene_source_mutex);
  return v16;
}

CFErrorRef C3DSceneSourceCreateError(CFIndex a1, void *a2)
{
  __CFBundle *MainBundle;
  __CFString *v5;
  CFErrorRef v6;

  MainBundle = CFBundleGetMainBundle();
  v5 = (__CFString *)CFBundleCopyLocalizedString(MainBundle, CFSTR("Could not load the scene"), CFSTR("Could not load the scene"), 0);
  v6 = C3DErrorCreate(a1, v5, a2);
  CFRelease(v5);
  return v6;
}

CFErrorRef C3DSceneSourceCreateMalformedDocumentError(int a1)
{
  __CFBundle *MainBundle;
  const __CFString *v3;
  __CFString *v4;
  __CFBundle *v5;
  __CFString *v6;
  CFErrorRef v7;

  MainBundle = CFBundleGetMainBundle();
  if (a1)
    v3 = CFSTR("The document does not appear to be a valid COLLADA file. Please check that is has not been corrupted.");
  else
    v3 = CFSTR("The document does not appear to be valid. Please re-create it from your original COLLADA assets.");
  v4 = (__CFString *)CFBundleCopyLocalizedString(MainBundle, v3, v3, 0);
  v5 = CFBundleGetMainBundle();
  v6 = (__CFString *)CFBundleCopyLocalizedString(v5, CFSTR("Could not load the scene"), CFSTR("Could not load the scene"), 0);
  v7 = C3DErrorCreate(-5, v6, v4);
  CFRelease(v4);
  CFRelease(v6);
  return v7;
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

BOOL C3DEqual(CFTypeRef cf1, const void *a2)
{
  _BOOL8 result;

  result = 0;
  if (cf1)
  {
    if (a2)
      return CFEqual(cf1, a2) != 0;
  }
  return result;
}

__n128 C3D::CopyTextureComputePass::CopyTextureComputePass(C3D::CopyTextureComputePass *this, C3D::RenderGraph *a2, C3D::Pass *a3, const Parameters *a4)
{
  uint64_t v5;
  __n128 result;

  C3D::ComputePass::ComputePass(this, a2, a3);
  *(_QWORD *)v5 = off_1EA59A0E8;
  result = *(__n128 *)&a4->var0;
  *(_QWORD *)(v5 + 124) = *(_QWORD *)&a4[1].var6;
  *(__n128 *)(v5 + 108) = result;
  return result;
}

const char *C3D::CopyTextureComputePass::name(C3D::CopyTextureComputePass *this)
{
  return "CopyTextureComputePass";
}

void C3D::CopyTextureComputePass::setup(C3D::CopyTextureComputePass *this)
{
  C3D::Pass::setInputCount(this, 1u);
  C3D::Pass::setOutputCount(this, 1u);
}

void C3D::CopyTextureComputePass::compile(C3D::CopyTextureComputePass *this)
{
  uint64_t RenderContext;
  void *v3;
  uint64_t v4;
  C3D::RenderGraphResourceManager *v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL4 HasFeatures;
  const __CFString *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const __CFString *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;

  RenderContext = C3DEngineContextGetRenderContext(*((_QWORD *)this + 2));
  v3 = (void *)-[SCNMTLRenderContext resourceManager](RenderContext);
  v4 = (*(uint64_t (**)(C3D::CopyTextureComputePass *))(*(_QWORD *)this + 64))(this);
  v5 = *(C3D::RenderGraphResourceManager **)(*((_QWORD *)this + 3) + 128);
  v6 = C3D::RenderGraphResourceManager::get(v5, v4);
  *((_QWORD *)this + 17) = v6;
  if (!v6)
  {
    v7 = operator new();
    *(_QWORD *)v7 = &off_1EA59A0C8;
    *(_QWORD *)(v7 + 8) = 0;
    *(_OWORD *)(v7 + 16) = 0u;
    *(_OWORD *)(v7 + 32) = 0u;
    *((_QWORD *)this + 17) = v7;
    C3D::RenderGraphResourceManager::set((uint64_t)v5, v4, v7);
    HasFeatures = C3DEngineContextHasFeatures(*((_QWORD *)this + 2), 512);
    if (HasFeatures)
      v9 = CFSTR("texturecube_copy_kernel");
    else
      v9 = CFSTR("texturecube_slices_copy_kernel");
    v10 = objc_msgSend(v3, "newComputePipelineStateWithFunctionName:", v9);
    v11 = *((_QWORD *)this + 17);
    v12 = *(void **)(v11 + 24);
    *(_QWORD *)(v11 + 24) = v10;
    if (v12)

    if (HasFeatures)
      v13 = CFSTR("texturecube_copy_resample_kernel");
    else
      v13 = CFSTR("texturecube_slices_copy_kernel");
    v14 = objc_msgSend(v3, "newComputePipelineStateWithFunctionName:", v13);
    v15 = *((_QWORD *)this + 17);
    v16 = *(void **)(v15 + 40);
    *(_QWORD *)(v15 + 40) = v14;
    if (v16)

    v17 = objc_msgSend(v3, "newComputePipelineStateWithFunctionName:", CFSTR("texture2d_copy_kernel"));
    v18 = *((_QWORD *)this + 17);
    v19 = *(void **)(v18 + 16);
    *(_QWORD *)(v18 + 16) = v17;
    if (v19)

    v20 = objc_msgSend(v3, "newComputePipelineStateWithFunctionName:", CFSTR("texture2d_copy_resample_kernel"));
    v21 = *((_QWORD *)this + 17);
    v22 = *(void **)(v21 + 32);
    *(_QWORD *)(v21 + 32) = v20;
    if (v22)

  }
}

void C3D::CopyTextureComputePass::execute(uint64_t a1, SCNMTLComputeCommandEncoder **a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  SCNMTLComputeCommandEncoder *v7;
  void **v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BOOL4 v21;
  uint64_t ArrayElementType;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  MTLTexture *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  MTLTexture *v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  MTLTexture *v41;
  uint64_t v42;
  MTLBuffer *v43;
  unint64_t v44;
  MTLBuffer **v45;
  void *v46;
  SCNMTLComputeCommandEncoder *v47;
  uint64_t v48;
  _BOOL4 v49;
  _BOOL4 IsArray;
  _BOOL4 v51;
  unsigned int v52;
  _QWORD v53[7];

  v53[6] = *MEMORY[0x1E0C80C00];
  if (*(_WORD *)(C3D::Pass::descriptor((C3D::Pass *)a1) + 4))
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3D::CopyTextureComputePass::execute(v4, v5, v6);
  }
  v7 = *a2;
  v8 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  v9 = C3D::Pass::outputTextureAtIndex((C3D::Pass *)a1, 0);
  v10 = objc_msgSend(v8, "mipmapLevelCount");
  v11 = objc_msgSend(v9, "mipmapLevelCount");
  if (v10 >= v11)
    v12 = v11;
  else
    v12 = v10;
  v13 = *(_DWORD *)(a1 + 112);
  v14 = v12 - *(_DWORD *)(a1 + 116);
  v15 = *(_DWORD *)(a1 + 120);
  if (v15 >= v14)
    v16 = v14;
  else
    v16 = *(_DWORD *)(a1 + 120);
  if (v15)
    v14 = v16;
  v52 = v14;
  if (!v13)
  {
    v17 = objc_msgSend(v8, "arrayLength");
    if ((unint64_t)(objc_msgSend(v8, "textureType") - 5) >= 2)
      v13 = v17;
    else
      v13 = 6 * v17;
  }
  v18 = objc_msgSend(v8, "width");
  if (v18 == objc_msgSend(v9, "width") && (v19 = objc_msgSend(v8, "height"), v19 == objc_msgSend(v9, "height")))
  {
    v20 = objc_msgSend(v8, "depth");
    v21 = v20 != objc_msgSend(v9, "depth");
  }
  else
  {
    v21 = 1;
  }
  v51 = v21;
  IsArray = SCNMTLTextureTypeIsArray(objc_msgSend(v8, "textureType"));
  v49 = SCNMTLTextureTypeIsArray(objc_msgSend(v9, "textureType"));
  ArrayElementType = SCNMTLTextureTypeGetArrayElementType(objc_msgSend(v8, "textureType"));
  v48 = SCNMTLTextureTypeGetArrayElementType(objc_msgSend(v9, "textureType"));
  if (ArrayElementType != v48)
  {
    v23 = scn_default_log();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
      C3D::CopyTextureComputePass::execute(v23, v24, v25);
  }
  if (v52)
  {
    v26 = 0;
    while (1)
    {
      v27 = (*(_DWORD *)(a1 + 116) + v26);
      v28 = *(unsigned int *)(a1 + 108);
      v29 = v27 | v28 || IsArray;
      if (v29 != 1)
        break;
      v30 = (MTLTexture *)(id)objc_msgSend(v8, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v8, "pixelFormat"), ArrayElementType, v27, 1, v28, v13);
      if (v7->_textures[0] != v30)
        goto LABEL_32;
LABEL_33:
      v31 = (*(_DWORD *)(a1 + 128) + v26);
      v32 = *(_QWORD **)(a1 + 136);
      if (ArrayElementType == 5)
      {
        if (v51)
          v33 = v32[5];
        else
          v33 = v32[3];
        v35 = -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v33);
        if (v7->_computePipelineState != (MTLComputePipelineState *)v35)
        {
          v7->_computePipelineState = (MTLComputePipelineState *)v35;
          -[MTLComputeCommandEncoder setComputePipelineState:](v7->_encoder, "setComputePipelineState:");
        }
        if (C3DEngineContextHasFeatures(*(_QWORD *)(a1 + 16), 512))
        {
          if ((_DWORD)v31)
            v36 = 1;
          else
            v36 = v49;
          if (v36 == 1)
          {
            v37 = (MTLTexture *)(id)objc_msgSend(v9, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v9, "pixelFormat"), v48, v31, 1, *(unsigned int *)(a1 + 124), 6);
            if (v7->_textures[1] == v37)
            {
LABEL_67:
              v47 = v7;
              v46 = v9;
LABEL_68:
              SCNMTLComputeCommandEncoder::dispatchOnTextureCube(v47, v46);
              goto LABEL_69;
            }
          }
          else
          {
            v37 = (MTLTexture *)v9;
            if ((_QWORD *)v7->_textures[1] == v9)
              goto LABEL_67;
          }
          v7->_textures[1] = v37;
          v7->_texturesToBind[0] |= 2uLL;
          goto LABEL_67;
        }
        v42 = 0;
        do
        {
          v43 = (MTLBuffer *)(id)objc_msgSend(v9, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v9, "pixelFormat"), 2, v31, 1, (v42 + *(_DWORD *)(a1 + 124)), 1);
          v53[v42] = v43;
          v44 = v42 + 1;
          v45 = &v7->_buffers[v42];
          if (v45[63] != v43)
          {
            v45[63] = v43;
            v7->_texturesToBind[v44 >> 6] |= (2 << v42);
          }
          ++v42;
        }
        while (v44 != 6);
        v46 = (void *)v53[0];
        v47 = v7;
        goto LABEL_68;
      }
      if (v51)
        v34 = v32[4];
      else
        v34 = v32[2];
      v38 = -[SCNMTLOpenSubdivComputeEvaluator computeEvaluator](v34);
      v39 = v38;
      if (v7->_computePipelineState != (MTLComputePipelineState *)v38)
      {
        v7->_computePipelineState = (MTLComputePipelineState *)v38;
        -[MTLComputeCommandEncoder setComputePipelineState:](v7->_encoder, "setComputePipelineState:");
      }
      if ((_DWORD)v31)
        v40 = 1;
      else
        v40 = v49;
      if (v40 == 1)
      {
        v41 = (MTLTexture *)(id)objc_msgSend(v9, "newTextureViewWithPixelFormat:textureType:levels:slices:", objc_msgSend(v9, "pixelFormat", v39), v48, v31, 1, *(unsigned int *)(a1 + 124), 1);
        if (v7->_textures[1] == v41)
          goto LABEL_64;
LABEL_63:
        v7->_textures[1] = v41;
        v7->_texturesToBind[0] |= 2uLL;
        goto LABEL_64;
      }
      v41 = (MTLTexture *)v9;
      if ((_QWORD *)v7->_textures[1] != v9)
        goto LABEL_63;
LABEL_64:
      SCNMTLComputeCommandEncoder::dispatchOnGrid2D(v7, objc_msgSend(v9, "width"), objc_msgSend(v9, "height"));
LABEL_69:
      if (++v26 == v52)
        return;
    }
    v30 = (MTLTexture *)v8;
    if ((void **)v7->_textures[0] == v8)
      goto LABEL_33;
LABEL_32:
    v7->_textures[0] = v30;
    v7->_texturesToBind[0] |= 1uLL;
    goto LABEL_33;
  }
}

uint64_t SCNMTLComputeCommandEncoder::dispatchOnTextureCube(SCNMTLComputeCommandEncoder *this, void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int features;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  MTLComputeCommandEncoder *v16;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  MTLComputeCommandEncoder *encoder;
  _QWORD v22[3];
  _QWORD v23[3];
  _QWORD v24[3];
  _QWORD v25[3];

  if (!this->_computePipelineState)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      SCNMTLComputeCommandEncoder::dispatchOnTextureCube(v4, v5, v6);
  }
  SCNMTLComputeCommandEncoder::_bindPendingTextures(this);
  SCNMTLComputeCommandEncoder::_bindPendingBuffers(this);
  features = this->_features;
  v8 = -[MTLComputePipelineState threadExecutionWidth](this->_computePipelineState, "threadExecutionWidth");
  if ((features & 0x40) != 0)
  {
    v18 = -[MTLComputePipelineState maxTotalThreadsPerThreadgroup](this->_computePipelineState, "maxTotalThreadsPerThreadgroup")/ v8;
    v19 = objc_msgSend(a2, "width");
    v20 = objc_msgSend(a2, "height");
    encoder = this->_encoder;
    v25[0] = v19;
    v25[1] = v20;
    v25[2] = 6;
    v24[0] = v8;
    v24[1] = v18;
    v24[2] = 1;
    return -[MTLComputeCommandEncoder dispatchThreads:threadsPerThreadgroup:](encoder, "dispatchThreads:threadsPerThreadgroup:", v25, v24);
  }
  else
  {
    v9 = objc_msgSend(a2, "width");
    if (v8 >= v9)
      v8 = v9;
    v10 = -[MTLComputePipelineState maxTotalThreadsPerThreadgroup](this->_computePipelineState, "maxTotalThreadsPerThreadgroup");
    v11 = v8;
    do
    {
      v12 = v11;
      v13 = 6 * v8 * v11;
      v11 >>= 1;
    }
    while (v13 > v10);
    v14 = (v8 + objc_msgSend(a2, "width") - 1) / v8;
    v15 = v12 + objc_msgSend(a2, "height") - 1;
    v16 = this->_encoder;
    v23[0] = v14;
    v23[1] = v15 / v12;
    v23[2] = 6;
    v22[0] = v8;
    v22[1] = v12;
    v22[2] = 1;
    return -[MTLComputeCommandEncoder dispatchThreadgroups:threadsPerThreadgroup:](v16, "dispatchThreadgroups:threadsPerThreadgroup:", v23, v22);
  }
}

uint64_t SCNMTLRenderCommandEncoder::drawFullScreenTriangle(SCNMTLRenderCommandEncoder *this)
{
  void *v2;

  SCNMTLRenderCommandEncoder::_bindPendingTextures(this);
  SCNMTLRenderCommandEncoder::applyChangedStates(this);
  v2 = (void *)this->var24[1];
  if (LODWORD(this->var14[0].var1) < 2)
    return objc_msgSend(v2, "drawPrimitives:vertexStart:vertexCount:", 3, 0, 3);
  else
    return objc_msgSend(v2, "drawPrimitives:vertexStart:vertexCount:instanceCount:", 3, 0, 3);
}

void C3D::CopyTextureComputePass::Resource::~Resource(C3D::CopyTextureComputePass::Resource *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  *(_QWORD *)this = &off_1EA59A0C8;
  v2 = (void *)*((_QWORD *)this + 5);
  if (v2)

  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)

  v4 = (void *)*((_QWORD *)this + 3);
  if (v4)

  v5 = (void *)*((_QWORD *)this + 2);
  if (v5)

}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  *(_QWORD *)this = &off_1EA59A0C8;
  v2 = (void *)*((_QWORD *)this + 5);
  if (v2)

  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)

  v4 = (void *)*((_QWORD *)this + 3);
  if (v4)

  v5 = (void *)*((_QWORD *)this + 2);
  if (v5)

  JUMPOUT(0x1DF0D41C0);
}

void SCNMTLComputeCommandEncoder::_bindPendingTextures(SCNMTLComputeCommandEncoder *this)
{
  uint64_t v2;
  MTLTexture **textures;
  MTLBuffer **v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  unint64_t v11;
  MTLComputeCommandEncoder *encoder;
  BOOL v13;
  uint8_t v14[4];
  _DWORD v15[7];

  v2 = 0;
  *(_QWORD *)&v15[5] = *MEMORY[0x1E0C80C00];
  textures = this->_textures;
  do
  {
    v4 = &this->_buffers[v2];
    v5 = (unint64_t)v4[211];
    if (v5)
    {
      v6 = 0;
      v7 = 1;
      v8 = 0xFFFFFFFFLL;
      do
      {
        if ((v5 & 1) != 0)
        {
          if (v8 >= v7 - 1)
            v9 = v7 - 1;
          else
            v9 = v8;
          if ((v5 & 2) == 0)
          {
            if (v8 >= v6)
              v11 = v6;
            else
              v11 = v8;
            encoder = this->_encoder;
            if (v7 - v11 < 2)
              -[MTLComputeCommandEncoder setTexture:atIndex:](encoder, "setTexture:atIndex:", this->_textures[v9]);
            else
              -[MTLComputeCommandEncoder setTextures:withRange:](encoder, "setTextures:withRange:", &textures[v9]);
            v9 = 0xFFFFFFFFLL;
          }
        }
        else
        {
          v9 = 0xFFFFFFFFLL;
          if (v8 != 0xFFFFFFFF)
          {
            v10 = scn_default_log();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
              SCNMTLComputeCommandEncoder::_bindPendingTextures(v14, v15, v10);
            v9 = v8;
          }
        }
        ++v6;
        ++v7;
        v8 = v9;
        v13 = v5 >= 2;
        v5 >>= 1;
      }
      while (v13);
    }
    v4[211] = 0;
    ++v2;
  }
  while (v2 != 2);
}

void SCNMTLComputeCommandEncoder::_bindPendingBuffers(SCNMTLComputeCommandEncoder *this)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  NSObject *v7;
  unint64_t v8;
  MTLComputeCommandEncoder *encoder;
  BOOL v10;
  uint8_t v11[4];
  _DWORD v12[7];

  *(_QWORD *)&v12[5] = *MEMORY[0x1E0C80C00];
  v2 = this->_buffersToBind[0];
  if (v2)
  {
    v3 = 0;
    v4 = 1;
    v5 = 0xFFFFFFFFLL;
    do
    {
      if ((v2 & 1) != 0)
      {
        if (v5 >= v4 - 1)
          v6 = v4 - 1;
        else
          v6 = v5;
        if ((v2 & 2) == 0)
        {
          if (v5 >= v3)
            v8 = v3;
          else
            v8 = v5;
          encoder = this->_encoder;
          if (v4 - v8 < 2)
            -[MTLComputeCommandEncoder setBuffer:offset:atIndex:](encoder, "setBuffer:offset:atIndex:", this->_buffers[v6], this->_offsets[v6]);
          else
            -[MTLComputeCommandEncoder setBuffers:offsets:withRange:](encoder, "setBuffers:offsets:withRange:", &this->_buffers[v6], &this->_offsets[v6]);
          v6 = 0xFFFFFFFFLL;
        }
      }
      else
      {
        v6 = 0xFFFFFFFFLL;
        if (v5 != 0xFFFFFFFF)
        {
          v7 = scn_default_log();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
            SCNMTLComputeCommandEncoder::_bindPendingTextures(v11, v12, v7);
          v6 = v5;
        }
      }
      ++v3;
      ++v4;
      v5 = v6;
      v10 = v2 >= 2;
      v2 >>= 1;
    }
    while (v10);
  }
  this->_buffersToBind[0] = 0;
}

uint64_t SCNMTLComputeCommandEncoder::dispatchOnGrid2D(SCNMTLComputeCommandEncoder *this, unint64_t a2, unint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int features;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  MTLComputeCommandEncoder *v16;
  unint64_t v18;
  MTLComputeCommandEncoder *encoder;
  _QWORD v20[3];
  _QWORD v21[3];
  _QWORD v22[3];
  _QWORD v23[3];

  if (!this->_computePipelineState)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      SCNMTLComputeCommandEncoder::dispatchOnTextureCube(v6, v7, v8);
  }
  SCNMTLComputeCommandEncoder::_bindPendingTextures(this);
  SCNMTLComputeCommandEncoder::_bindPendingBuffers(this);
  features = this->_features;
  v10 = -[MTLComputePipelineState threadExecutionWidth](this->_computePipelineState, "threadExecutionWidth");
  v11 = v10;
  if ((features & 0x40) != 0)
  {
    v18 = -[MTLComputePipelineState maxTotalThreadsPerThreadgroup](this->_computePipelineState, "maxTotalThreadsPerThreadgroup");
    encoder = this->_encoder;
    v23[0] = a2;
    v23[1] = a3;
    v23[2] = 1;
    v22[0] = v11;
    v22[1] = v18 / v11;
    v22[2] = 1;
    return -[MTLComputeCommandEncoder dispatchThreads:threadsPerThreadgroup:](encoder, "dispatchThreads:threadsPerThreadgroup:", v23, v22);
  }
  else
  {
    if (v10 >= a2)
      v12 = a2;
    else
      v12 = v10;
    if (v10 >= a3)
      v11 = a3;
    v13 = -[MTLComputePipelineState maxTotalThreadsPerThreadgroup](this->_computePipelineState, "maxTotalThreadsPerThreadgroup");
    do
    {
      v14 = v11;
      v15 = v11 * v12;
      v11 >>= 1;
    }
    while (v15 > v13);
    v16 = this->_encoder;
    v21[0] = (a2 + v12 - 1) / v12;
    v21[1] = (a3 + v14 - 1) / v14;
    v21[2] = 1;
    v20[0] = v12;
    v20[1] = v14;
    v20[2] = 1;
    return -[MTLComputeCommandEncoder dispatchThreadgroups:threadsPerThreadgroup:](v16, "dispatchThreadgroups:threadsPerThreadgroup:", v21, v20);
  }
}

void OUTLINED_FUNCTION_0_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0xCu);
}

CFStringRef _C3DSortSystemCFCopyFormatDescription(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<C3DSortSystem %p>"), a1);
}

CFStringRef _C3DSortSystemCFCopyDebugDescription(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<C3DSortSystem %p>"), a1);
}

uint64_t C3DSortSystemInvalidateKeyForRendererElementSpan(uint64_t a1, unint64_t a2)
{
  uint64_t Count;
  uint64_t result;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;

  Count = C3DArrayGetCount(*(_QWORD *)(a1 + 16));
  result = C3DRendererElementFlattenedIndexForSpanHandle((unsigned __int16)a2, WORD1(a2));
  if (Count > result)
  {
    v6 = HIDWORD(a2);
    result = C3DArrayGetValuesPtr(*(_QWORD *)(a1 + 16));
    if (HIDWORD(a2))
    {
      v7 = result;
      v8 = a2 >> 16;
      do
      {
        result = C3DRendererElementFlattenedIndexForSpanHandle((unsigned __int16)a2, (unsigned __int16)v8);
        *(_QWORD *)(v7 + 8 * result) = -1;
        LODWORD(v8) = v8 + 1;
        LODWORD(v6) = v6 - 1;
      }
      while ((_DWORD)v6);
    }
  }
  return result;
}

void Variable::Variable(std::string *this, __int128 *a2, __int128 *a3, __int128 *a4, __int128 *a5)
{
  __int128 v9;
  __int128 v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v9 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v9;
  }
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this + 1, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v10 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v10;
  }
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this + 2, *(const std::string::value_type **)a4, *((_QWORD *)a4 + 1));
  }
  else
  {
    v11 = *a4;
    this[2].__r_.__value_.__r.__words[2] = *((_QWORD *)a4 + 2);
    *(_OWORD *)&this[2].__r_.__value_.__l.__data_ = v11;
  }
  v12 = this + 3;
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v12, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v13 = *a5;
    this[3].__r_.__value_.__r.__words[2] = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v12->__r_.__value_.__l.__data_ = v13;
  }
}

void sub_1DCD2B3D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;

  if (*(char *)(v1 + 71) < 0)
    operator delete(*v3);
  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

std::string *Variable::Output(std::string *result, uint64_t a2, int a3, std::string *this)
{
  uint64_t v5;
  std::string *v6;
  const void **v7;
  int v8;
  const std::string::value_type *v9;
  std::string::size_type v10;
  int v11;
  const std::string::value_type *v12;
  std::string::size_type v13;
  char v14;
  const std::string::value_type *v15;
  std::string::size_type v16;
  const void **v17;
  int v18;
  const std::string::value_type *v19;
  std::string::size_type v20;
  int v21;
  const std::string::value_type *v22;
  std::string::size_type v23;
  char v24;
  const std::string::value_type *v25;
  std::string::size_type v26;
  const std::string::value_type *v27;
  const std::string::value_type *v28;
  int v29;
  const std::string::value_type *v30;
  std::string::size_type v31;

  v5 = (uint64_t)result;
  if (a3 == 2)
  {
    v17 = ShaderConverter::GLSLToMetalSymbol(a2, (const void **)&result[1].__r_.__value_.__l.__data_);
    v18 = *((char *)v17 + 23);
    if (v18 >= 0)
      v19 = (const std::string::value_type *)v17;
    else
      v19 = (const std::string::value_type *)*v17;
    if (v18 >= 0)
      v20 = *((unsigned __int8 *)v17 + 23);
    else
      v20 = (std::string::size_type)v17[1];
    std::string::append(this, v19, v20);
    std::string::append(this, " ");
    v21 = *(char *)(v5 + 23);
    if (v21 >= 0)
      v22 = (const std::string::value_type *)v5;
    else
      v22 = *(const std::string::value_type **)v5;
    if (v21 >= 0)
      v23 = *(unsigned __int8 *)(v5 + 23);
    else
      v23 = *(_QWORD *)(v5 + 8);
    std::string::append(this, v22, v23);
    v24 = *(_BYTE *)(v5 + 95);
    if (v24 < 0)
    {
      if (!*(_QWORD *)(v5 + 80))
        goto LABEL_48;
    }
    else if (!*(_BYTE *)(v5 + 95))
    {
      goto LABEL_48;
    }
    if (v24 >= 0)
      v25 = (const std::string::value_type *)(v5 + 72);
    else
      v25 = *(const std::string::value_type **)(v5 + 72);
    if (v24 >= 0)
      v26 = *(unsigned __int8 *)(v5 + 95);
    else
      v26 = *(_QWORD *)(v5 + 80);
    std::string::append(this, v25, v26);
LABEL_48:
    if (*(char *)(v5 + 71) < 0)
    {
      if (!*(_QWORD *)(v5 + 56))
        return std::string::append(this, ";\n");
    }
    else if (!*(_BYTE *)(v5 + 71))
    {
      return std::string::append(this, ";\n");
    }
    v27 = (const std::string::value_type *)(v5 + 48);
    v28 = " =";
    goto LABEL_60;
  }
  if (a3 == 1)
  {
    v6 = std::string::append(this, "uniform ");
    v7 = ShaderConverter::MetalToGLSLSymbol((uint64_t)v6, (const void **)(v5 + 24));
    v8 = *((char *)v7 + 23);
    if (v8 >= 0)
      v9 = (const std::string::value_type *)v7;
    else
      v9 = (const std::string::value_type *)*v7;
    if (v8 >= 0)
      v10 = *((unsigned __int8 *)v7 + 23);
    else
      v10 = (std::string::size_type)v7[1];
    std::string::append(this, v9, v10);
    std::string::append(this, " ");
    v11 = *(char *)(v5 + 23);
    if (v11 >= 0)
      v12 = (const std::string::value_type *)v5;
    else
      v12 = *(const std::string::value_type **)v5;
    if (v11 >= 0)
      v13 = *(unsigned __int8 *)(v5 + 23);
    else
      v13 = *(_QWORD *)(v5 + 8);
    std::string::append(this, v12, v13);
    v14 = *(_BYTE *)(v5 + 95);
    if (v14 < 0)
    {
      if (*(_QWORD *)(v5 + 80))
        goto LABEL_17;
    }
    else if (*(_BYTE *)(v5 + 95))
    {
LABEL_17:
      if (v14 >= 0)
        v15 = (const std::string::value_type *)(v5 + 72);
      else
        v15 = *(const std::string::value_type **)(v5 + 72);
      if (v14 >= 0)
        v16 = *(unsigned __int8 *)(v5 + 95);
      else
        v16 = *(_QWORD *)(v5 + 80);
      std::string::append(this, v15, v16);
    }
    if ((*(char *)(v5 + 71) & 0x80000000) == 0)
    {
      if (!*(_BYTE *)(v5 + 71))
        return std::string::append(this, ";\n");
      goto LABEL_55;
    }
    if (*(_QWORD *)(v5 + 56))
    {
LABEL_55:
      v27 = (const std::string::value_type *)(v5 + 48);
      v28 = " = ";
LABEL_60:
      std::string::append(this, v28);
      v29 = *(char *)(v5 + 71);
      if (v29 >= 0)
        v30 = v27;
      else
        v30 = *(const std::string::value_type **)(v5 + 48);
      if (v29 >= 0)
        v31 = *(unsigned __int8 *)(v5 + 71);
      else
        v31 = *(_QWORD *)(v5 + 56);
      std::string::append(this, v30, v31);
    }
    return std::string::append(this, ";\n");
  }
  return result;
}

const void **ShaderConverter::MetalToGLSLSymbol(uint64_t a1, const void **a2)
{
  uint64_t v3;

  if (ShaderConverter::StaticInit(void)::onceToken != -1)
    dispatch_once(&ShaderConverter::StaticInit(void)::onceToken, &__block_literal_global_2);
  v3 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(ShaderConverter::mpStatics, a2);
  if (ShaderConverter::mpStatics + 8 == v3)
    return a2;
  else
    return (const void **)(v3 + 56);
}

const void **ShaderConverter::GLSLToMetalSymbol(uint64_t a1, const void **a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const std::string *v7;
  uint64_t *v8;
  __int128 *v10;

  if (ShaderConverter::StaticInit(void)::onceToken != -1)
    dispatch_once(&ShaderConverter::StaticInit(void)::onceToken, &__block_literal_global_2);
  v4 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(ShaderConverter::mpStatics + 24, a2);
  if (ShaderConverter::mpStatics + 32 != v4)
  {
    v5 = v4;
    v6 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(ShaderConverter::mpStatics + 96, a2);
    if (ShaderConverter::mpStatics + 104 != v6)
    {
      v7 = (const std::string *)ShaderConverter::GLSLToMetalSymbol(a1, v6 + 56);
      v10 = (__int128 *)(v5 + 56);
      v8 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)(a1 + 200), (const void **)(v5 + 56), (uint64_t)&std::piecewise_construct, &v10);
      std::string::operator=((std::string *)(v8 + 7), v7);
    }
    return (const void **)(v5 + 56);
  }
  return a2;
}

void Statement::AddToken(Statement *a1, __int128 *a2, int a3)
{
  Statement *v6;

  v6 = (Statement *)operator new();
  TokenStatement::TokenStatement((uint64_t)v6, a2, a3);
  Statement::AddStatement(a1, v6);
}

void sub_1DCD2B7D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1DF0D41C0](v1, 0x1093C40A9CC4442);
  _Unwind_Resume(a1);
}

void Statement::AddTokens(Statement *a1, int **a2)
{
  int *v2;
  int *v3;
  Statement *v5;
  std::string __p;

  v2 = *a2;
  v3 = a2[1];
  if (*a2 != v3)
  {
    do
    {
      v5 = (Statement *)operator new();
      Token::str((Token *)v2, &__p);
      TokenStatement::TokenStatement((uint64_t)v5, (__int128 *)&__p, v2[6]);
      Statement::AddStatement(a1, v5);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v2 += 8;
    }
    while (v2 != v3);
  }
}

void sub_1DCD2B8A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  MEMORY[0x1DF0D41C0](v15, 0x1093C40A9CC4442);
  _Unwind_Resume(a1);
}

uint64_t ShaderConverter::ParseUniform(ShaderConverter *this)
{
  Token *v2;
  BOOL v4;
  int v5;
  std::string *p_p;
  std::string::size_type size;
  uint64_t v8;
  std::string *v10;
  std::string::size_type v11;
  void *v12;
  int v13;
  int v14;
  std::string *v15;
  std::string::size_type v16;
  int v17;
  unint64_t v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  int v24;
  std::string __p;
  void *v26[2];
  uint64_t v27;
  void *v28[2];
  uint64_t v29;
  void *v30[2];
  uint64_t v31;
  std::string v32;
  std::string v33;
  std::string v34;
  std::string v35;

  v2 = (ShaderConverter *)((char *)this + 40);
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ != 7
      || (*(_DWORD *)__p.__r_.__value_.__l.__data_ == 1718185589
        ? (v4 = *(_DWORD *)(__p.__r_.__value_.__r.__words[0] + 3) == 1836216166)
        : (v4 = 0),
          !v4))
    {
LABEL_108:
      __assert_rtn("ParseUniform", "C3DShaderConverter.mm", 626, "mToken.str() == \"uniform\"");
    }
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 7)
      goto LABEL_108;
    if (LODWORD(__p.__r_.__value_.__l.__data_) != 1718185589
      || *(_DWORD *)((char *)__p.__r_.__value_.__r.__words + 3) != 1836216166)
    {
      goto LABEL_108;
    }
  }
  ShaderConverter::NextToken(this);
  if (*((_DWORD *)this + 16) == 13)
  {
    ShaderConverter::NextToken(this);
    if (*((_DWORD *)this + 16) == 1)
    {
      Token::str(v2, &v35);
      ShaderConverter::NextToken(this);
      if (*((_DWORD *)this + 16) != 13 || (ShaderConverter::NextToken(this), *((_DWORD *)this + 16) != 1))
      {
        Token::str(v2, &__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        v8 = 0;
        goto LABEL_40;
      }
      Token::str(v2, &v34);
      ShaderConverter::NextToken(this);
      v5 = *((_DWORD *)this + 16);
      if (v5 == 13)
      {
        ShaderConverter::NextToken(this);
        v5 = *((_DWORD *)this + 16);
      }
      memset(&v33, 0, sizeof(v33));
      memset(&v32, 0, sizeof(v32));
      if (v5 == 10)
      {
        while (v5 != 11)
        {
          Token::str(v2, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            p_p = &__p;
          else
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          else
            size = __p.__r_.__value_.__l.__size_;
          std::string::append(&v32, (const std::string::value_type *)p_p, size);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          ShaderConverter::NextToken(this);
          v5 = *((_DWORD *)this + 16);
          if (!v5)
            goto LABEL_90;
        }
        Token::str(v2, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v10 = &__p;
        else
          v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v11 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v11 = __p.__r_.__value_.__l.__size_;
        std::string::append(&v32, (const std::string::value_type *)v10, v11);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        ShaderConverter::NextToken(this);
        v5 = *((_DWORD *)this + 16);
        if (v5 == 13)
        {
          ShaderConverter::NextToken(this);
          v5 = *((_DWORD *)this + 16);
        }
      }
      if (v5 == 5)
      {
        Token::str(v2, &__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          v12 = (void *)__p.__r_.__value_.__r.__words[0];
          if (__p.__r_.__value_.__l.__size_ == 1)
          {
            v13 = *__p.__r_.__value_.__l.__data_;
            operator delete(__p.__r_.__value_.__l.__data_);
            if (v13 == 61)
              goto LABEL_59;
          }
          else
          {
LABEL_78:
            operator delete(v12);
          }
        }
        else if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) == 1 && __p.__r_.__value_.__s.__data_[0] == 61)
        {
          while (1)
          {
LABEL_59:
            ShaderConverter::NextToken(this);
            Token::str(v2, &__p);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              if (__p.__r_.__value_.__l.__size_ == 1)
              {
                v12 = (void *)__p.__r_.__value_.__r.__words[0];
                if (*__p.__r_.__value_.__l.__data_ == 59)
                  goto LABEL_78;
                v14 = *((_DWORD *)this + 16);
              }
              else
              {
                v14 = *((_DWORD *)this + 16);
                v12 = (void *)__p.__r_.__value_.__r.__words[0];
              }
              operator delete(v12);
              if (!v14)
                break;
            }
            else
            {
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) == 1 && __p.__r_.__value_.__s.__data_[0] == 59)
                break;
              if (!*((_DWORD *)this + 16))
                goto LABEL_81;
            }
            Token::str(v2, &__p);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = &__p;
            else
              v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            else
              v16 = __p.__r_.__value_.__l.__size_;
            std::string::append(&v33, (const std::string::value_type *)v15, v16);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
      }
      if (*((_DWORD *)this + 16) == 13)
        ShaderConverter::NextToken(this);
LABEL_81:
      Token::str(v2, &__p);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 1 || __p.__r_.__value_.__s.__data_[0] != 59)
          goto LABEL_90;
LABEL_87:
        ShaderConverter::NextToken(this);
        Variable::Variable(&__p, (__int128 *)&v34, (__int128 *)&v35, (__int128 *)&v33, (__int128 *)&v32);
        v18 = *((_QWORD *)this + 14);
        if (v18 >= *((_QWORD *)this + 15))
        {
          v23 = std::vector<Variable>::__push_back_slow_path<Variable>((uint64_t *)this + 13, (__int128 *)&__p);
          v24 = SHIBYTE(v31);
          *((_QWORD *)this + 14) = v23;
          if (v24 < 0)
            operator delete(v30[0]);
        }
        else
        {
          v19 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(_QWORD *)(v18 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)v18 = v19;
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
          v20 = v27;
          *(_OWORD *)(v18 + 24) = *(_OWORD *)v26;
          *(_QWORD *)(v18 + 40) = v20;
          __p.__r_.__value_.__r.__words[2] = 0;
          v26[0] = 0;
          v26[1] = 0;
          v27 = 0;
          v21 = *(_OWORD *)v28;
          *(_QWORD *)(v18 + 64) = v29;
          *(_OWORD *)(v18 + 48) = v21;
          v28[0] = 0;
          v28[1] = 0;
          v22 = *(_OWORD *)v30;
          *(_QWORD *)(v18 + 88) = v31;
          *(_OWORD *)(v18 + 72) = v22;
          v29 = 0;
          v30[0] = 0;
          v30[1] = 0;
          v31 = 0;
          *((_QWORD *)this + 14) = v18 + 96;
        }
        if (SHIBYTE(v29) < 0)
          operator delete(v28[0]);
        if (SHIBYTE(v27) < 0)
          operator delete(v26[0]);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        v8 = 1;
        goto LABEL_93;
      }
      if (__p.__r_.__value_.__l.__size_ == 1)
      {
        v17 = *__p.__r_.__value_.__l.__data_;
        operator delete(__p.__r_.__value_.__l.__data_);
        if (v17 == 59)
          goto LABEL_87;
      }
      else
      {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
LABEL_90:
      Token::str(v2, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v8 = 0;
LABEL_93:
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v32.__r_.__value_.__l.__data_);
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v33.__r_.__value_.__l.__data_);
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v34.__r_.__value_.__l.__data_);
LABEL_40:
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v35.__r_.__value_.__l.__data_);
      return v8;
    }
  }
  Token::str(v2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return 0;
}

void sub_1DCD2BE60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  uint64_t v29;

  Variable::~Variable(&a9);
  if (a29 < 0)
    operator delete(__p);
  if (*(char *)(v29 - 81) < 0)
    operator delete(*(void **)(v29 - 104));
  if (*(char *)(v29 - 57) < 0)
    operator delete(*(void **)(v29 - 80));
  if (*(char *)(v29 - 33) < 0)
    operator delete(*(void **)(v29 - 56));
  _Unwind_Resume(a1);
}

void Variable::~Variable(void **this)
{
  if (*((char *)this + 95) < 0)
    operator delete(this[9]);
  if (*((char *)this + 71) < 0)
    operator delete(this[6]);
  if (*((char *)this + 47) < 0)
    operator delete(this[3]);
  if (*((char *)this + 23) < 0)
    operator delete(*this);
}

Statement *ShaderConverter::ParseFunctionArgument(ShaderConverter *this)
{
  Statement *v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  Statement *v8;
  std::string __p;

  v2 = (Statement *)operator new();
  *(_QWORD *)v2 = &off_1EA598440;
  *((_QWORD *)v2 + 1) = 0;
  *((_QWORD *)v2 + 2) = 0;
  *((_QWORD *)v2 + 3) = 0;
  v3 = *((_DWORD *)this + 16);
  if (v3 == 13)
  {
    ShaderConverter::NextToken(this);
    v3 = *((_DWORD *)this + 16);
  }
  if (v3)
  {
    v4 = 0;
    do
    {
      if (v4)
      {
        if (v3 != 1)
        {
          if (v3 == 6)
            goto LABEL_12;
          if (v3 == 7)
            --v4;
          goto LABEL_20;
        }
      }
      else
      {
        if (v3 > 5)
        {
          if (v3 == 6)
          {
LABEL_12:
            ++v4;
          }
          else if (v3 == 7 || v3 == 14)
          {
            return v2;
          }
LABEL_20:
          Statement::AddToken(v2, (ShaderConverter *)((char *)this + 40));
          ShaderConverter::NextToken(this);
          goto LABEL_21;
        }
        if (v3 != 1)
          goto LABEL_20;
      }
      v5 = ShaderConverter::mpStatics + 48;
      Token::str((ShaderConverter *)((char *)this + 40), &__p);
      v6 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v5, (const void **)&__p.__r_.__value_.__l.__data_);
      v7 = ShaderConverter::mpStatics;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (v7 + 56 == v6)
        goto LABEL_20;
      v8 = (Statement *)ShaderConverter::ParseTextureLookup(this);
      Statement::AddStatement(v2, v8);
LABEL_21:
      v3 = *((_DWORD *)this + 16);
    }
    while (v3);
  }
  return v2;
}

void sub_1DCD2C0F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *ShaderConverter::ParseTextureLookup(ShaderConverter *this)
{
  Token *v2;
  int v3;
  Statement *v4;
  uint64_t v5;
  Statement *v6;
  int v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  Statement *v17;
  unint64_t v18;
  _QWORD *v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  std::string __p;
  std::string v35;

  v2 = (ShaderConverter *)((char *)this + 40);
  Token::str((ShaderConverter *)((char *)this + 40), &v35);
  ShaderConverter::NextToken(this);
  v3 = *((_DWORD *)this + 16);
  if (v3 == 13)
  {
    ShaderConverter::NextToken(this);
    v3 = *((_DWORD *)this + 16);
  }
  if (v3 == 6)
  {
    ShaderConverter::NextToken(this);
    if (*((_DWORD *)this + 16) == 13)
      ShaderConverter::NextToken(this);
    v4 = ShaderConverter::ParseFunctionArgument(this);
    v5 = (uint64_t)v4;
    if (*((_DWORD *)this + 16) == 14)
    {
      ShaderConverter::NextToken(this);
      v6 = ShaderConverter::ParseFunctionArgument(this);
      v7 = *((_DWORD *)this + 16);
      if (v7 == 14)
      {
        ShaderConverter::NextToken(this);
        v17 = ShaderConverter::ParseFunctionArgument(this);
        if (*((_DWORD *)this + 16) == 7)
        {
          ShaderConverter::NextToken(this);
          v8 = (_QWORD *)operator new();
          TextureLookup::TextureLookup(v8, (__int128 *)&v35, v5, (uint64_t)v6, (uint64_t)v17);
          v18 = *((_QWORD *)this + 21);
          v10 = (_QWORD *)*((_QWORD *)this + 20);
          if ((unint64_t)v10 >= v18)
          {
            v21 = *((_QWORD *)this + 19);
            v22 = ((uint64_t)v10 - v21) >> 3;
            if ((unint64_t)(v22 + 1) >> 61)
              abort();
            v23 = v18 - v21;
            v24 = v23 >> 2;
            if (v23 >> 2 <= (unint64_t)(v22 + 1))
              v24 = v22 + 1;
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
              v25 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v25 = v24;
            if (v25)
              v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)this + 168, v25);
            else
              v26 = 0;
            v27 = &v26[8 * v22];
            v28 = &v26[8 * v25];
            *(_QWORD *)v27 = v8;
            v19 = v27 + 8;
            v32 = (char *)*((_QWORD *)this + 19);
            v29 = (char *)*((_QWORD *)this + 20);
            if (v29 == v32)
              goto LABEL_58;
            do
            {
              v33 = *((_QWORD *)v29 - 1);
              v29 -= 8;
              *((_QWORD *)v27 - 1) = v33;
              v27 -= 8;
            }
            while (v29 != v32);
            goto LABEL_57;
          }
LABEL_24:
          *v10 = v8;
          v19 = v10 + 1;
LABEL_60:
          *((_QWORD *)this + 20) = v19;
          goto LABEL_39;
        }
        if (v5)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
        if (v6)
          (*(void (**)(Statement *))(*(_QWORD *)v6 + 8))(v6);
        if (v17)
          (*(void (**)(Statement *))(*(_QWORD *)v17 + 8))(v17);
      }
      else
      {
        if (v7 == 7)
        {
          ShaderConverter::NextToken(this);
          v8 = (_QWORD *)operator new();
          TextureLookup::TextureLookup(v8, (__int128 *)&v35, v5, (uint64_t)v6, 0);
          v9 = *((_QWORD *)this + 21);
          v10 = (_QWORD *)*((_QWORD *)this + 20);
          if ((unint64_t)v10 >= v9)
          {
            v11 = *((_QWORD *)this + 19);
            v12 = ((uint64_t)v10 - v11) >> 3;
            if ((unint64_t)(v12 + 1) >> 61)
              abort();
            v13 = v9 - v11;
            v14 = v13 >> 2;
            if (v13 >> 2 <= (unint64_t)(v12 + 1))
              v14 = v12 + 1;
            if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
              v15 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v15 = v14;
            if (v15)
              v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)this + 168, v15);
            else
              v16 = 0;
            v27 = &v16[8 * v12];
            v28 = &v16[8 * v15];
            *(_QWORD *)v27 = v8;
            v19 = v27 + 8;
            v30 = (char *)*((_QWORD *)this + 19);
            v29 = (char *)*((_QWORD *)this + 20);
            if (v29 == v30)
              goto LABEL_58;
            do
            {
              v31 = *((_QWORD *)v29 - 1);
              v29 -= 8;
              *((_QWORD *)v27 - 1) = v31;
              v27 -= 8;
            }
            while (v29 != v30);
LABEL_57:
            v29 = (char *)*((_QWORD *)this + 19);
LABEL_58:
            *((_QWORD *)this + 19) = v27;
            *((_QWORD *)this + 20) = v19;
            *((_QWORD *)this + 21) = v28;
            if (v29)
              operator delete(v29);
            goto LABEL_60;
          }
          goto LABEL_24;
        }
        if (v5)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
        if (v6)
          (*(void (**)(Statement *))(*(_QWORD *)v6 + 8))(v6);
      }
    }
    else if (v4)
    {
      (*(void (**)(Statement *))(*(_QWORD *)v4 + 8))(v4);
    }
  }
  Token::str(v2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v8 = 0;
LABEL_39:
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  return v8;
}

void sub_1DCD2C490(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  uint64_t v17;

  MEMORY[0x1DF0D41C0](v17, 0x10B3C406D35A18FLL);
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t ShaderConverter::ParseMatrixCTOR(uint64_t **this)
{
  int v2;
  int v3;
  Statement *v4;
  Statement *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  Statement **v12;
  char *v13;
  char *v14;
  Statement *v15;
  int v16;
  Statement *v17;
  Statement *v18;
  uint64_t v19;
  uint64_t *v20;
  int v21;
  int v22;
  void *__p[2];
  char v25;
  void *v26;
  char *v27;
  char *v28;
  std::string v29;

  Token::str((Token *)(this + 5), &v29);
  v26 = 0;
  v27 = 0;
  v28 = 0;
  std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(this + 22, (const void **)&v29.__r_.__value_.__l.__data_, (uint64_t)&v29);
  ShaderConverter::NextToken((ShaderConverter *)this);
  v2 = *((_DWORD *)this + 16);
  if (v2 == 13)
  {
    ShaderConverter::NextToken((ShaderConverter *)this);
    v2 = *((_DWORD *)this + 16);
  }
  if (v2 == 6)
  {
    ShaderConverter::NextToken((ShaderConverter *)this);
    if (*((_DWORD *)this + 16) == 13)
      ShaderConverter::NextToken((ShaderConverter *)this);
    while (1)
    {
      v3 = *((_DWORD *)this + 16);
      if (!v3)
        break;
      if (v3 == 7)
      {
        ShaderConverter::NextToken((ShaderConverter *)this);
        __p[0] = &v29;
        v20 = std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)(ShaderConverter::mpStatics + 72), (const void **)&v29.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, (__int128 **)__p);
        v21 = *((_DWORD *)v20 + 14);
        v22 = *((_DWORD *)v20 + 15);
        v19 = operator new();
        MatrixCTOR::MatrixCTOR(v19, (__int128 *)&v29, (uint64_t)&v26, v21, v22);
        goto LABEL_34;
      }
      v4 = ShaderConverter::ParseFunctionArgument((ShaderConverter *)this);
      v5 = v4;
      if (v4)
      {
        v6 = v27;
        if (v27 >= v28)
        {
          v8 = (v27 - (_BYTE *)v26) >> 3;
          if ((unint64_t)(v8 + 1) >> 61)
            abort();
          v9 = (v28 - (_BYTE *)v26) >> 2;
          if (v9 <= v8 + 1)
            v9 = v8 + 1;
          if ((unint64_t)(v28 - (_BYTE *)v26) >= 0x7FFFFFFFFFFFFFF8)
            v10 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v10 = v9;
          if (v10)
            v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)&v28, v10);
          else
            v11 = 0;
          v12 = (Statement **)&v11[8 * v8];
          *v12 = v5;
          v7 = (char *)(v12 + 1);
          v14 = (char *)v26;
          v13 = v27;
          if (v27 != v26)
          {
            do
            {
              v15 = (Statement *)*((_QWORD *)v13 - 1);
              v13 -= 8;
              *--v12 = v15;
            }
            while (v13 != v14);
            v13 = (char *)v26;
          }
          v26 = v12;
          v27 = v7;
          v28 = &v11[8 * v10];
          if (v13)
            operator delete(v13);
        }
        else
        {
          *(_QWORD *)v27 = v4;
          v7 = v6 + 8;
        }
        v27 = v7;
      }
      v16 = *((_DWORD *)this + 16);
      if (v16 == 14)
      {
        ShaderConverter::NextToken((ShaderConverter *)this);
        v16 = *((_DWORD *)this + 16);
      }
      if (v16 == 13)
        ShaderConverter::NextToken((ShaderConverter *)this);
    }
    v19 = 0;
  }
  else
  {
    v17 = (Statement *)this[11];
    v18 = (Statement *)operator new();
    TokenStatement::TokenStatement((uint64_t)v18, (__int128 *)&v29, 1);
    Statement::AddStatement(v17, v18);
    v19 = operator new();
    std::string::basic_string[abi:nn180100]<0>(__p, " ");
    TokenStatement::TokenStatement(v19, (__int128 *)__p, 13);
    if (v25 < 0)
      operator delete(__p[0]);
  }
LABEL_34:
  if (v26)
  {
    v27 = (char *)v26;
    operator delete(v26);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v29.__r_.__value_.__l.__data_);
  return v19;
}

void sub_1DCD2C7B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;

  MEMORY[0x1DF0D41C0](v23, 0x1093C40CC6E360FLL);
  if (__p)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  _Unwind_Resume(a1);
}

void ShaderConverter::ParseMacro(ShaderConverter *this)
{
  Statement *v2;
  Statement *v3;
  Statement *v4;
  Statement *v5;
  int v6;
  Statement *v7;
  Statement *v8;
  _BOOL4 v11;
  Statement *v12;
  Statement *v13;
  int v14;
  Statement *v15;
  Statement *v16;
  _BOOL4 v19;
  int v20;
  uint64_t v21;
  _BOOL4 v24;
  int v25;
  Statement *v26;
  Statement *v27;
  int v28;
  std::string __p;

  v2 = (Statement *)*((_QWORD *)this + 11);
  v3 = (Statement *)operator new();
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  TokenStatement::TokenStatement((uint64_t)v3, (__int128 *)&__p, *((_DWORD *)this + 16));
  Statement::AddStatement(v2, v3);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  ShaderConverter::NextToken(this);
  v4 = (Statement *)*((_QWORD *)this + 11);
  v5 = (Statement *)operator new();
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  TokenStatement::TokenStatement((uint64_t)v5, (__int128 *)&__p, *((_DWORD *)this + 16));
  Statement::AddStatement(v4, v5);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v6 = *((_DWORD *)this + 16);
  if (v6 == 13)
  {
    ShaderConverter::NextToken(this);
    v7 = (Statement *)*((_QWORD *)this + 11);
    v8 = (Statement *)operator new();
    Token::str((ShaderConverter *)((char *)this + 40), &__p);
    TokenStatement::TokenStatement((uint64_t)v8, (__int128 *)&__p, *((_DWORD *)this + 16));
    Statement::AddStatement(v7, v8);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    v6 = *((_DWORD *)this + 16);
  }
  if (v6 != 1)
    goto LABEL_42;
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ != 6)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
LABEL_42:
      ShaderConverter::NextToken(this);
      return;
    }
    v11 = *(_DWORD *)__p.__r_.__value_.__l.__data_ != 1734439536
       || *(_WORD *)(__p.__r_.__value_.__r.__words[0] + 4) != 24941;
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v11)
      goto LABEL_42;
  }
  else
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 6)
      goto LABEL_42;
    if (LODWORD(__p.__r_.__value_.__l.__data_) != 1734439536 || WORD2(__p.__r_.__value_.__r.__words[0]) != 24941)
      goto LABEL_42;
  }
  ShaderConverter::NextToken(this);
  v12 = (Statement *)*((_QWORD *)this + 11);
  v13 = (Statement *)operator new();
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  TokenStatement::TokenStatement((uint64_t)v13, (__int128 *)&__p, *((_DWORD *)this + 16));
  Statement::AddStatement(v12, v13);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v14 = *((_DWORD *)this + 16);
  if (v14 == 13)
  {
    ShaderConverter::NextToken(this);
    v15 = (Statement *)*((_QWORD *)this + 11);
    v16 = (Statement *)operator new();
    Token::str((ShaderConverter *)((char *)this + 40), &__p);
    TokenStatement::TokenStatement((uint64_t)v16, (__int128 *)&__p, *((_DWORD *)this + 16));
    Statement::AddStatement(v15, v16);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    v14 = *((_DWORD *)this + 16);
  }
  if (v14 != 1)
    return;
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 9)
      goto LABEL_54;
    if (__p.__r_.__value_.__r.__words[0] != 0x746E656D75677261 || __p.__r_.__value_.__s.__data_[8] != 115)
      goto LABEL_54;
LABEL_52:
    v20 = 1;
LABEL_61:
    *((_DWORD *)this + 25) = v20;
    ++*((_DWORD *)this + 20);
    return;
  }
  if (__p.__r_.__value_.__l.__size_ != 9)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_54;
  }
  v19 = *(_QWORD *)__p.__r_.__value_.__l.__data_ != 0x746E656D75677261
     || *(_BYTE *)(__p.__r_.__value_.__r.__words[0] + 8) != 115;
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v19)
    goto LABEL_52;
LABEL_54:
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ != 8)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      goto LABEL_63;
    }
    v21 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v21 != 0x73676E6979726176)
      goto LABEL_63;
    goto LABEL_60;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) == 8 && __p.__r_.__value_.__r.__words[0] == 0x73676E6979726176)
  {
LABEL_60:
    v20 = 2;
    goto LABEL_61;
  }
LABEL_63:
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 11)
      goto LABEL_81;
    if (__p.__r_.__value_.__r.__words[0] != 0x746172616C636564
      || *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 3) != 0x6E6F69746172616CLL)
    {
      goto LABEL_81;
    }
    goto LABEL_79;
  }
  if (__p.__r_.__value_.__l.__size_ == 11)
  {
    v24 = *(_QWORD *)__p.__r_.__value_.__l.__data_ != 0x746172616C636564
       || *(_QWORD *)(__p.__r_.__value_.__r.__words[0] + 3) != 0x6E6F69746172616CLL;
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v24)
      goto LABEL_81;
LABEL_79:
    *((_DWORD *)this + 25) = 3;
    goto LABEL_42;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_81:
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ == 4)
    {
      v25 = *(_DWORD *)__p.__r_.__value_.__l.__data_;
      operator delete(__p.__r_.__value_.__l.__data_);
      if (v25 == 2036625250)
      {
LABEL_87:
        *((_BYTE *)this + 96) = 1;
        *((_DWORD *)this + 25) = 4;
        v26 = (Statement *)*((_QWORD *)this + 11);
        v27 = (Statement *)operator new();
        *((_QWORD *)v27 + 2) = 0;
        *((_QWORD *)v27 + 3) = 0;
        *(_QWORD *)v27 = &off_1EA5954E0;
        *((_QWORD *)v27 + 1) = 0;
        *((_QWORD *)v27 + 4) = this;
        Statement::AddStatement(v26, v27);
        goto LABEL_42;
      }
    }
    else
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) == 4 && LODWORD(__p.__r_.__value_.__l.__data_) == 2036625250)
  {
    goto LABEL_87;
  }
  while (1)
  {
    ShaderConverter::NextToken(this);
    v28 = *((_DWORD *)this + 16);
    if (!v28 || v28 == 17)
      break;
    Statement::AddToken(*((Statement **)this + 11), (ShaderConverter *)((char *)this + 40));
  }
}

void sub_1DCD2CDC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  MEMORY[0x1DF0D41C0](v15, 0x1093C40A9CC4442);
  _Unwind_Resume(a1);
}

void ShaderConverter::ParseDeclaration(ShaderConverter *this)
{
  char *v2;
  _OWORD *v3;
  uint64_t v4;
  __int128 v5;
  _BOOL4 v8;
  char *v9;
  __int128 v10;
  char *v11;
  char v12;
  char *v13;
  __int128 v14;
  char *v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  __int128 v23;
  char *v24;
  __int128 v25;
  char *v26;
  char *v27;
  __int128 v28;
  char *v29;
  Statement *v30;
  char *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  char *v42;
  char *v43;
  __int128 v44;
  char *v45;
  __int128 v46;
  char *v47;
  int v48;
  char *v49;
  __int128 v50;
  char *v51;
  char *v52;
  __int128 v53;
  char *v54;
  char *v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  char *v60;
  char *v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  char *v66;
  char *v67;
  __int128 v68;
  char *v69;
  __int128 v70;
  char *v71;
  char *v72;
  __int128 v73;
  char *v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  char *v80;
  char *v81;
  __int128 v82;
  char *v83;
  __int128 v84;
  char *v85;
  Statement *v86;
  char *v87;
  __int128 v88;
  char *v89;
  __int128 v90;
  char *v91;
  int v92;
  char *v93;
  __int128 v94;
  char *v95;
  char *v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  char *v101;
  char *v102;
  __int128 v103;
  char *v104;
  __int128 v105;
  char *v106;
  char *v107;
  __int128 v108;
  char *v109;
  __int128 v110;
  char *v111;
  int v112;
  Statement *v114;
  int v115;
  std::string *p_p;
  std::string::size_type size;
  std::string *v118;
  std::string::size_type v119;
  unint64_t v120;
  __int128 v121;
  uint64_t v122;
  __int128 v123;
  __int128 v124;
  Statement *v125;
  Statement *v126;
  Statement *v127;
  void *v128;
  int v129;
  _BOOL4 v130;
  _BOOL4 v131;
  Statement *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  Statement *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  Statement *v143;
  Statement *v144;
  std::string v145;
  std::string __p;
  void *v147[2];
  uint64_t v148;
  void *v149[2];
  uint64_t v150;
  void *v151[2];
  uint64_t v152;
  std::string v153;
  std::string v154;
  std::string v155;
  char *v156;
  char *v157;
  char *v158;

  v156 = 0;
  v157 = 0;
  v158 = 0;
  v2 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v158, 1uLL);
  v3 = (_OWORD *)((char *)this + 40);
  v5 = *(_OWORD *)((char *)this + 56);
  *(_OWORD *)v2 = *(_OWORD *)((char *)this + 40);
  *((_OWORD *)v2 + 1) = v5;
  v156 = v2;
  v158 = &v2[32 * v4];
  v157 = v2 + 32;
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ != 5)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
LABEL_20:
      v12 = 0;
      goto LABEL_21;
    }
    v8 = *(_DWORD *)__p.__r_.__value_.__l.__data_ != 1936617315
      || *(_BYTE *)(__p.__r_.__value_.__r.__words[0] + 4) != 116;
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v8)
      goto LABEL_20;
  }
  else
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 5)
      goto LABEL_20;
    if (LODWORD(__p.__r_.__value_.__l.__data_) != 1936617315 || __p.__r_.__value_.__s.__data_[4] != 116)
      goto LABEL_20;
  }
  ShaderConverter::NextToken(this);
  v9 = v157;
  if (v157 >= v158)
  {
    v37 = v156;
    v38 = (v157 - v156) >> 5;
    v39 = v38 + 1;
    if ((unint64_t)(v38 + 1) >> 59)
      goto LABEL_261;
    v40 = v158 - v156;
    if ((v158 - v156) >> 4 > v39)
      v39 = v40 >> 4;
    if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFE0)
      v41 = 0x7FFFFFFFFFFFFFFLL;
    else
      v41 = v39;
    if (v41)
    {
      v42 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v158, v41);
      v37 = v156;
      v9 = v157;
    }
    else
    {
      v42 = 0;
    }
    v67 = &v42[32 * v38];
    v68 = *(_OWORD *)((char *)this + 56);
    v69 = &v42[32 * v41];
    *(_OWORD *)v67 = *v3;
    *((_OWORD *)v67 + 1) = v68;
    v11 = v67 + 32;
    if (v9 == v37)
    {
      v71 = v67;
    }
    else
    {
      do
      {
        v70 = *((_OWORD *)v9 - 2);
        v71 = v67 - 32;
        *(_OWORD *)(v67 - 20) = *(_OWORD *)(v9 - 20);
        *((_OWORD *)v67 - 2) = v70;
        v9 -= 32;
        v67 -= 32;
      }
      while (v9 != v37);
    }
    v156 = v71;
    v157 = v11;
    v158 = v69;
    if (v37)
      operator delete(v37);
  }
  else
  {
    v10 = *(_OWORD *)((char *)this + 56);
    *(_OWORD *)v157 = *v3;
    *((_OWORD *)v9 + 1) = v10;
    v11 = v9 + 32;
  }
  v157 = v11;
  if (*((_DWORD *)this + 16) == 13)
  {
    ShaderConverter::NextToken(this);
    v72 = v157;
    if (v157 < v158)
    {
      v73 = *(_OWORD *)((char *)this + 56);
      *(_OWORD *)v157 = *v3;
      *((_OWORD *)v72 + 1) = v73;
      v74 = v72 + 32;
LABEL_154:
      v157 = v74;
      v12 = 1;
LABEL_21:
      Token::str((ShaderConverter *)((char *)this + 40), &v155);
      ShaderConverter::NextToken(this);
      v13 = v157;
      if (v157 >= v158)
      {
        v16 = v156;
        v17 = (v157 - v156) >> 5;
        v18 = v17 + 1;
        if ((unint64_t)(v17 + 1) >> 59)
          goto LABEL_260;
        v19 = v158 - v156;
        if ((v158 - v156) >> 4 > v18)
          v18 = v19 >> 4;
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFE0)
          v20 = 0x7FFFFFFFFFFFFFFLL;
        else
          v20 = v18;
        if (v20)
        {
          v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v158, v20);
          v16 = v156;
          v13 = v157;
        }
        else
        {
          v21 = 0;
        }
        v22 = &v21[32 * v17];
        v23 = *(_OWORD *)((char *)this + 56);
        v24 = &v21[32 * v20];
        *(_OWORD *)v22 = *v3;
        *((_OWORD *)v22 + 1) = v23;
        v15 = v22 + 32;
        if (v13 == v16)
        {
          v26 = v22;
        }
        else
        {
          do
          {
            v25 = *((_OWORD *)v13 - 2);
            v26 = v22 - 32;
            *(_OWORD *)(v22 - 20) = *(_OWORD *)(v13 - 20);
            *((_OWORD *)v22 - 2) = v25;
            v13 -= 32;
            v22 -= 32;
          }
          while (v13 != v16);
        }
        v156 = v26;
        v157 = v15;
        v158 = v24;
        if (v16)
          operator delete(v16);
      }
      else
      {
        v14 = *(_OWORD *)((char *)this + 56);
        *(_OWORD *)v157 = *v3;
        *((_OWORD *)v13 + 1) = v14;
        v15 = v13 + 32;
      }
      v157 = v15;
      if (*((_DWORD *)this + 16) != 13)
      {
        Statement::AddTokens(*((Statement **)this + 11), (int **)&v156);
        ShaderConverter::NextToken(this);
        *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
        LODWORD(v154.__r_.__value_.__l.__data_) = 15;
        std::__tree<Token::TokenType>::__emplace_unique_key_args<Token::TokenType,Token::TokenType>((uint64_t **)&__p, (int *)&v154, &v154);
        v30 = ShaderConverter::ParseRValue(this, (uint64_t)&__p);
        Statement::AddStatement(*((Statement **)this + 11), v30);
        if (*((_DWORD *)this + 16) != 15)
        {
LABEL_121:
          Token::str((ShaderConverter *)((char *)this + 40), &v154);
          if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v154.__r_.__value_.__l.__data_);
          goto LABEL_123;
        }
LABEL_42:
        Statement::AddToken(*((Statement **)this + 11), (ShaderConverter *)((char *)this + 40));
        ShaderConverter::NextToken(this);
LABEL_123:
        std::__tree<char>::destroy((uint64_t)&__p, (_QWORD *)__p.__r_.__value_.__l.__size_);
LABEL_124:
        if (SHIBYTE(v155.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v155.__r_.__value_.__l.__data_);
        goto LABEL_126;
      }
      ShaderConverter::NextToken(this);
      v27 = v157;
      if (v157 >= v158)
      {
        v31 = v156;
        v32 = (v157 - v156) >> 5;
        v33 = v32 + 1;
        if ((unint64_t)(v32 + 1) >> 59)
          goto LABEL_260;
        v34 = v158 - v156;
        if ((v158 - v156) >> 4 > v33)
          v33 = v34 >> 4;
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFE0)
          v35 = 0x7FFFFFFFFFFFFFFLL;
        else
          v35 = v33;
        if (v35)
        {
          v36 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v158, v35);
          v31 = v156;
          v27 = v157;
        }
        else
        {
          v36 = 0;
        }
        v43 = &v36[32 * v32];
        v44 = *(_OWORD *)((char *)this + 56);
        v45 = &v36[32 * v35];
        *(_OWORD *)v43 = *v3;
        *((_OWORD *)v43 + 1) = v44;
        v29 = v43 + 32;
        if (v27 == v31)
        {
          v47 = v43;
        }
        else
        {
          do
          {
            v46 = *((_OWORD *)v27 - 2);
            v47 = v43 - 32;
            *(_OWORD *)(v43 - 20) = *(_OWORD *)(v27 - 20);
            *((_OWORD *)v43 - 2) = v46;
            v27 -= 32;
            v43 -= 32;
          }
          while (v27 != v31);
        }
        v156 = v47;
        v157 = v29;
        v158 = v45;
        if (v31)
          operator delete(v31);
      }
      else
      {
        v28 = *(_OWORD *)((char *)this + 56);
        *(_OWORD *)v157 = *v3;
        *((_OWORD *)v27 + 1) = v28;
        v29 = v27 + 32;
      }
      v157 = v29;
      v48 = *((_DWORD *)this + 16);
      if (v48 != 1)
      {
        if (v48 != 5)
        {
          Token::str((ShaderConverter *)((char *)this + 40), &__p);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          Statement::AddTokens(*((Statement **)this + 11), (int **)&v156);
          goto LABEL_124;
        }
        *((_DWORD *)this + 25) = 4;
        ShaderConverter::NextToken(this);
        v49 = v157;
        if (v157 < v158)
        {
          v50 = *(_OWORD *)((char *)this + 56);
          *(_OWORD *)v157 = *v3;
          *((_OWORD *)v49 + 1) = v50;
          v51 = v49 + 32;
          goto LABEL_120;
        }
        v55 = v156;
        v56 = (v157 - v156) >> 5;
        v57 = v56 + 1;
        if (!((unint64_t)(v56 + 1) >> 59))
        {
          v58 = v158 - v156;
          if ((v158 - v156) >> 4 > v57)
            v57 = v58 >> 4;
          if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFE0)
            v59 = 0x7FFFFFFFFFFFFFFLL;
          else
            v59 = v57;
          if (v59)
          {
            v60 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v158, v59);
            v55 = v156;
            v49 = v157;
          }
          else
          {
            v60 = 0;
          }
          v81 = &v60[32 * v56];
          v82 = *(_OWORD *)((char *)this + 56);
          v83 = &v60[32 * v59];
          *(_OWORD *)v81 = *v3;
          *((_OWORD *)v81 + 1) = v82;
          v51 = v81 + 32;
          if (v49 == v55)
          {
            v85 = v81;
          }
          else
          {
            do
            {
              v84 = *((_OWORD *)v49 - 2);
              v85 = v81 - 32;
              *(_OWORD *)(v81 - 20) = *(_OWORD *)(v49 - 20);
              *((_OWORD *)v81 - 2) = v84;
              v49 -= 32;
              v81 -= 32;
            }
            while (v49 != v55);
          }
          v156 = v85;
          v157 = v51;
          v158 = v83;
          if (v55)
            operator delete(v55);
LABEL_120:
          v157 = v51;
          Statement::AddTokens(*((Statement **)this + 11), (int **)&v156);
          *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
          LODWORD(v154.__r_.__value_.__l.__data_) = 15;
          std::__tree<Token::TokenType>::__emplace_unique_key_args<Token::TokenType,Token::TokenType>((uint64_t **)&__p, (int *)&v154, &v154);
          v86 = ShaderConverter::ParseRValue(this, (uint64_t)&__p);
          Statement::AddStatement(*((Statement **)this + 11), v86);
          if (*((_DWORD *)this + 16) != 15)
            goto LABEL_121;
          goto LABEL_42;
        }
LABEL_260:
        abort();
      }
      Token::str((ShaderConverter *)((char *)this + 40), &v154);
      ShaderConverter::NextToken(this);
      v52 = v157;
      if (v157 >= v158)
      {
        v61 = v156;
        v62 = (v157 - v156) >> 5;
        v63 = v62 + 1;
        if ((unint64_t)(v62 + 1) >> 59)
          goto LABEL_262;
        v64 = v158 - v156;
        if ((v158 - v156) >> 4 > v63)
          v63 = v64 >> 4;
        if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFE0)
          v65 = 0x7FFFFFFFFFFFFFFLL;
        else
          v65 = v63;
        if (v65)
        {
          v66 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v158, v65);
          v61 = v156;
          v52 = v157;
        }
        else
        {
          v66 = 0;
        }
        v87 = &v66[32 * v62];
        v88 = *(_OWORD *)((char *)this + 56);
        v89 = &v66[32 * v65];
        *(_OWORD *)v87 = *v3;
        *((_OWORD *)v87 + 1) = v88;
        v54 = v87 + 32;
        if (v52 == v61)
        {
          v91 = v87;
        }
        else
        {
          do
          {
            v90 = *((_OWORD *)v52 - 2);
            v91 = v87 - 32;
            *(_OWORD *)(v87 - 20) = *(_OWORD *)(v52 - 20);
            *((_OWORD *)v87 - 2) = v90;
            v52 -= 32;
            v87 -= 32;
          }
          while (v52 != v61);
        }
        v156 = v91;
        v157 = v54;
        v158 = v89;
        if (v61)
          operator delete(v61);
      }
      else
      {
        v53 = *(_OWORD *)((char *)this + 56);
        *(_OWORD *)v157 = *v3;
        *((_OWORD *)v52 + 1) = v53;
        v54 = v52 + 32;
      }
      v157 = v54;
      v92 = *((_DWORD *)this + 16);
      if (v92 != 13)
      {
LABEL_163:
        if (v92 != 6)
        {
          memset(&v153, 0, sizeof(v153));
          if (v92 == 10)
          {
            while (v92 && v92 != 11)
            {
              Token::str((ShaderConverter *)((char *)this + 40), &__p);
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                p_p = &__p;
              else
                p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
              else
                size = __p.__r_.__value_.__l.__size_;
              std::string::append(&v153, (const std::string::value_type *)p_p, size);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__p.__r_.__value_.__l.__data_);
              ShaderConverter::NextToken(this);
              v92 = *((_DWORD *)this + 16);
              if (!v92)
              {
                Token::str((ShaderConverter *)((char *)this + 40), &__p);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p.__r_.__value_.__l.__data_);
                v92 = *((_DWORD *)this + 16);
              }
            }
            Token::str((ShaderConverter *)((char *)this + 40), &__p);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v118 = &__p;
            else
              v118 = (std::string *)__p.__r_.__value_.__r.__words[0];
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v119 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            else
              v119 = __p.__r_.__value_.__l.__size_;
            std::string::append(&v153, (const std::string::value_type *)v118, v119);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            ShaderConverter::NextToken(this);
            v92 = *((_DWORD *)this + 16);
            if (v92 == 13)
            {
              ShaderConverter::NextToken(this);
              v92 = *((_DWORD *)this + 16);
            }
          }
          if (v92 == 5)
          {
            ShaderConverter::NextToken(this);
            std::vector<Token>::push_back[abi:nn180100]((void **)&v156, (ShaderConverter *)((char *)this + 40));
            if ((v12 & 1) != 0 || *((_DWORD *)this + 25) == 3)
            {
              v125 = (Statement *)*((_QWORD *)this + 11);
              std::string::basic_string[abi:nn180100]<0>(&__p, "constant");
              Statement::AddToken(v125, (__int128 *)&__p, 1);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__p.__r_.__value_.__l.__data_);
              v126 = (Statement *)*((_QWORD *)this + 11);
              std::string::basic_string[abi:nn180100]<0>(&__p, " ");
              Statement::AddToken(v126, (__int128 *)&__p, 13);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__p.__r_.__value_.__l.__data_);
            }
            Statement::AddTokens(*((Statement **)this + 11), (int **)&v156);
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
            LODWORD(v145.__r_.__value_.__l.__data_) = 15;
            std::__tree<Token::TokenType>::__emplace_unique_key_args<Token::TokenType,Token::TokenType>((uint64_t **)&__p, (int *)&v145, &v145);
            v127 = ShaderConverter::ParseRValue(this, (uint64_t)&__p);
            Statement::AddStatement(*((Statement **)this + 11), v127);
            if (*((_DWORD *)this + 16) == 15)
            {
              Statement::AddToken(*((Statement **)this + 11), (ShaderConverter *)((char *)this + 40));
              ShaderConverter::NextToken(this);
            }
            else
            {
              Token::str((ShaderConverter *)((char *)this + 40), &v145);
              if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v145.__r_.__value_.__l.__data_);
            }
            std::__tree<char>::destroy((uint64_t)&__p, (_QWORD *)__p.__r_.__value_.__l.__size_);
          }
          else if (v92 == 15)
          {
            std::string::basic_string[abi:nn180100]<0>(&v145, "");
            Variable::Variable(&__p, (__int128 *)&v154, (__int128 *)&v155, (__int128 *)&v145, (__int128 *)&v153);
            v120 = *((_QWORD *)this + 17);
            if (v120 >= *((_QWORD *)this + 18))
            {
              v141 = std::vector<Variable>::__push_back_slow_path<Variable>((uint64_t *)this + 16, (__int128 *)&__p);
              v142 = SHIBYTE(v152);
              *((_QWORD *)this + 17) = v141;
              if (v142 < 0)
                operator delete(v151[0]);
            }
            else
            {
              v121 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
              *(_QWORD *)(v120 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
              *(_OWORD *)v120 = v121;
              *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
              v122 = v148;
              *(_OWORD *)(v120 + 24) = *(_OWORD *)v147;
              *(_QWORD *)(v120 + 40) = v122;
              __p.__r_.__value_.__r.__words[2] = 0;
              v147[0] = 0;
              v147[1] = 0;
              v148 = 0;
              v123 = *(_OWORD *)v149;
              *(_QWORD *)(v120 + 64) = v150;
              *(_OWORD *)(v120 + 48) = v123;
              v149[0] = 0;
              v149[1] = 0;
              v124 = *(_OWORD *)v151;
              *(_QWORD *)(v120 + 88) = v152;
              *(_OWORD *)(v120 + 72) = v124;
              v150 = 0;
              v151[0] = 0;
              v151[1] = 0;
              v152 = 0;
              *((_QWORD *)this + 17) = v120 + 96;
            }
            if (SHIBYTE(v150) < 0)
              operator delete(v149[0]);
            if (SHIBYTE(v148) < 0)
              operator delete(v147[0]);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v145.__r_.__value_.__l.__data_);
            v143 = (Statement *)*((_QWORD *)this + 11);
            std::string::basic_string[abi:nn180100]<0>(&__p, "constant");
            Statement::AddToken(v143, (__int128 *)&__p, 1);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            v144 = (Statement *)*((_QWORD *)this + 11);
            std::string::basic_string[abi:nn180100]<0>(&__p, " ");
            Statement::AddToken(v144, (__int128 *)&__p, 13);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            Statement::AddTokens(*((Statement **)this + 11), (int **)&v156);
            ShaderConverter::NextToken(this);
          }
          if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0)
          {
            v128 = (void *)v153.__r_.__value_.__r.__words[0];
LABEL_255:
            operator delete(v128);
          }
LABEL_258:
          if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v154.__r_.__value_.__l.__data_);
          goto LABEL_124;
        }
        if ((*((_DWORD *)this + 25) - 1) <= 1)
          *((_DWORD *)this + 25) = 3;
        Statement::AddTokens(*((Statement **)this + 11), (int **)&v156);
        ShaderConverter::NextToken(this);
        while (1)
        {
          v112 = *((_DWORD *)this + 16);
          if (!v112 || v112 == 7)
            break;
          v114 = ShaderConverter::ParseFunctionArgument(this);
          if (v114)
            Statement::AddStatement(*((Statement **)this + 11), v114);
          v115 = *((_DWORD *)this + 16);
          if (v115 == 14)
          {
            Statement::AddToken(*((Statement **)this + 11), (ShaderConverter *)((char *)this + 40));
            ShaderConverter::NextToken(this);
            v115 = *((_DWORD *)this + 16);
          }
          if (v115 == 13)
          {
            Statement::AddToken(*((Statement **)this + 11), (ShaderConverter *)((char *)this + 40));
            ShaderConverter::NextToken(this);
          }
        }
        while (2)
        {
          Statement::AddToken(*((Statement **)this + 11), (ShaderConverter *)((char *)this + 40));
          ShaderConverter::NextToken(this);
          switch(*((_DWORD *)this + 16))
          {
            case 8:
              Statement::AddToken(*((Statement **)this + 11), (ShaderConverter *)((char *)this + 40));
              ShaderConverter::NextToken(this);
              break;
            case 0xD:
            case 0x11:
              continue;
            case 0xF:
LABEL_257:
              Statement::AddToken(*((Statement **)this + 11), (ShaderConverter *)((char *)this + 40));
              ShaderConverter::NextToken(this);
              goto LABEL_258;
            default:
              Token::str((ShaderConverter *)((char *)this + 40), &__p);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_258;
              v128 = (void *)__p.__r_.__value_.__r.__words[0];
              goto LABEL_255;
          }
          break;
        }
        while (1)
        {
          v129 = *((_DWORD *)this + 16);
          switch(v129)
          {
            case 0:
            case 9:
              goto LABEL_257;
            case 1:
              Token::str((ShaderConverter *)((char *)this + 40), &__p);
              v130 = std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__p, "uniform");
              v131 = v130;
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(__p.__r_.__value_.__l.__data_);
                if (!v131)
                  goto LABEL_226;
LABEL_221:
                *((_DWORD *)this + 8) = 1;
              }
              else
              {
                if (v130)
                  goto LABEL_221;
LABEL_226:
                v133 = ShaderConverter::mpStatics;
                Token::str((ShaderConverter *)((char *)this + 40), &__p);
                v134 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v133 + 48, (const void **)&__p.__r_.__value_.__l.__data_);
                v135 = ShaderConverter::mpStatics;
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p.__r_.__value_.__l.__data_);
                if (v135 + 56 != v134)
                {
                  v132 = (Statement *)*((_QWORD *)this + 11);
                  v136 = (Statement *)ShaderConverter::ParseTextureLookup(this);
                  goto LABEL_234;
                }
                v137 = ShaderConverter::mpStatics;
                Token::str((ShaderConverter *)((char *)this + 40), &__p);
                v138 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v137 + 72, (const void **)&__p.__r_.__value_.__l.__data_);
                v139 = ShaderConverter::mpStatics;
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p.__r_.__value_.__l.__data_);
                v140 = v139 + 80;
                v132 = (Statement *)*((_QWORD *)this + 11);
                if (v140 == v138)
                {
LABEL_224:
                  Statement::AddToken(v132, (ShaderConverter *)((char *)this + 40));
                  ShaderConverter::NextToken(this);
                }
                else
                {
                  v136 = (Statement *)ShaderConverter::ParseMatrixCTOR((uint64_t **)this);
LABEL_234:
                  Statement::AddStatement(v132, v136);
                }
              }
              break;
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
              goto LABEL_223;
            case 8:
              Statement::AddToken(*((Statement **)this + 11), (ShaderConverter *)((char *)this + 40));
              ShaderConverter::NextToken(this);
              goto LABEL_257;
            default:
              if (v129 == 16)
                goto LABEL_258;
LABEL_223:
              v132 = (Statement *)*((_QWORD *)this + 11);
              goto LABEL_224;
          }
        }
      }
      ShaderConverter::NextToken(this);
      v93 = v157;
      if (v157 < v158)
      {
        v94 = *(_OWORD *)((char *)this + 56);
        *(_OWORD *)v157 = *v3;
        *((_OWORD *)v93 + 1) = v94;
        v95 = v93 + 32;
LABEL_162:
        v157 = v95;
        v92 = *((_DWORD *)this + 16);
        goto LABEL_163;
      }
      v96 = v156;
      v97 = (v157 - v156) >> 5;
      v98 = v97 + 1;
      if (!((unint64_t)(v97 + 1) >> 59))
      {
        v99 = v158 - v156;
        if ((v158 - v156) >> 4 > v98)
          v98 = v99 >> 4;
        if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFE0)
          v100 = 0x7FFFFFFFFFFFFFFLL;
        else
          v100 = v98;
        if (v100)
        {
          v101 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v158, v100);
          v96 = v156;
          v93 = v157;
        }
        else
        {
          v101 = 0;
        }
        v107 = &v101[32 * v97];
        v108 = *(_OWORD *)((char *)this + 56);
        v109 = &v101[32 * v100];
        *(_OWORD *)v107 = *v3;
        *((_OWORD *)v107 + 1) = v108;
        v95 = v107 + 32;
        if (v93 == v96)
        {
          v111 = v107;
        }
        else
        {
          do
          {
            v110 = *((_OWORD *)v93 - 2);
            v111 = v107 - 32;
            *(_OWORD *)(v107 - 20) = *(_OWORD *)(v93 - 20);
            *((_OWORD *)v107 - 2) = v110;
            v93 -= 32;
            v107 -= 32;
          }
          while (v93 != v96);
        }
        v156 = v111;
        v157 = v95;
        v158 = v109;
        if (v96)
          operator delete(v96);
        goto LABEL_162;
      }
LABEL_262:
      abort();
    }
    v75 = v156;
    v76 = (v157 - v156) >> 5;
    v77 = v76 + 1;
    if (!((unint64_t)(v76 + 1) >> 59))
    {
      v78 = v158 - v156;
      if ((v158 - v156) >> 4 > v77)
        v77 = v78 >> 4;
      if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFE0)
        v79 = 0x7FFFFFFFFFFFFFFLL;
      else
        v79 = v77;
      if (v79)
      {
        v80 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>((uint64_t)&v158, v79);
        v75 = v156;
        v72 = v157;
      }
      else
      {
        v80 = 0;
      }
      v102 = &v80[32 * v76];
      v103 = *(_OWORD *)((char *)this + 56);
      v104 = &v80[32 * v79];
      *(_OWORD *)v102 = *v3;
      *((_OWORD *)v102 + 1) = v103;
      v74 = v102 + 32;
      if (v72 == v75)
      {
        v106 = v102;
      }
      else
      {
        do
        {
          v105 = *((_OWORD *)v72 - 2);
          v106 = v102 - 32;
          *(_OWORD *)(v102 - 20) = *(_OWORD *)(v72 - 20);
          *((_OWORD *)v102 - 2) = v105;
          v72 -= 32;
          v102 -= 32;
        }
        while (v72 != v75);
      }
      v156 = v106;
      v157 = v74;
      v158 = v104;
      if (v75)
        operator delete(v75);
      goto LABEL_154;
    }
LABEL_261:
    abort();
  }
  Token::str((ShaderConverter *)((char *)this + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  Statement::AddTokens(*((Statement **)this + 11), (int **)&v156);
LABEL_126:
  if (v156)
  {
    v157 = v156;
    operator delete(v156);
  }
}

void sub_1DCD2DDCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, _QWORD *a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  uint64_t v42;
  void *v44;

  std::__tree<char>::destroy((uint64_t)&a16, a17);
  if (a36 < 0)
    operator delete(__p);
  if (a42 < 0)
    operator delete(a37);
  if (*(char *)(v42 - 105) < 0)
    operator delete(*(void **)(v42 - 128));
  v44 = *(void **)(v42 - 104);
  if (v44)
  {
    *(_QWORD *)(v42 - 96) = v44;
    operator delete(v44);
  }
  _Unwind_Resume(a1);
}

void std::vector<Token>::push_back[abi:nn180100](void **a1, _OWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _OWORD *v7;
  __int128 v8;
  _OWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  __int128 v17;
  char *v18;
  char *v19;
  __int128 v20;

  v6 = (unint64_t)a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    v10 = ((char *)v7 - (_BYTE *)*a1) >> 5;
    v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 59)
      abort();
    v12 = v5 - (_QWORD)*a1;
    if (v12 >> 4 > v11)
      v11 = v12 >> 4;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFE0)
      v13 = 0x7FFFFFFFFFFFFFFLL;
    else
      v13 = v11;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>(v4, v13);
    else
      v14 = 0;
    v15 = &v14[32 * v10];
    v16 = &v14[32 * v13];
    v17 = a2[1];
    *(_OWORD *)v15 = *a2;
    *((_OWORD *)v15 + 1) = v17;
    v9 = v15 + 32;
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *((_OWORD *)v18 - 2);
        *(_OWORD *)(v15 - 20) = *(_OWORD *)(v18 - 20);
        *((_OWORD *)v15 - 2) = v20;
        v15 -= 32;
        v18 -= 32;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v15;
    a1[1] = v9;
    a1[2] = v16;
    if (v18)
      operator delete(v18);
  }
  else
  {
    v8 = a2[1];
    *v7 = *a2;
    v7[1] = v8;
    v9 = v7 + 2;
  }
  a1[1] = v9;
}

Statement *ShaderConverter::ParseRValue(_DWORD *a1, uint64_t a2)
{
  Statement *v4;
  int v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  BOOL v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  Statement *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  std::string __p;

  v4 = (Statement *)operator new();
  *(_QWORD *)v4 = &off_1EA598440;
  *((_QWORD *)v4 + 1) = 0;
  *((_QWORD *)v4 + 2) = 0;
  *((_QWORD *)v4 + 3) = 0;
  v5 = a1[16];
  if (v5)
  {
    v6 = (_QWORD *)(a2 + 8);
    do
    {
      v7 = *v6;
      if (*v6)
      {
        v8 = v6;
        do
        {
          v9 = *(_DWORD *)(v7 + 28);
          v10 = v9 < v5;
          if (v9 >= v5)
            v11 = (uint64_t *)v7;
          else
            v11 = (uint64_t *)(v7 + 8);
          if (!v10)
            v8 = (_QWORD *)v7;
          v7 = *v11;
        }
        while (*v11);
        if (v8 != v6 && v5 >= *((_DWORD *)v8 + 7))
          return v4;
      }
      if (v5 == 1)
      {
        v12 = ShaderConverter::mpStatics + 48;
        Token::str((Token *)(a1 + 10), &__p);
        v13 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v12, (const void **)&__p.__r_.__value_.__l.__data_);
        v14 = ShaderConverter::mpStatics;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (v14 + 56 != v13)
        {
          v15 = (Statement *)ShaderConverter::ParseTextureLookup((ShaderConverter *)a1);
LABEL_24:
          Statement::AddStatement(v4, v15);
          goto LABEL_25;
        }
        v16 = ShaderConverter::mpStatics + 72;
        Token::str((Token *)(a1 + 10), &__p);
        v17 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v16, (const void **)&__p.__r_.__value_.__l.__data_);
        v18 = ShaderConverter::mpStatics;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (v18 + 80 != v17)
        {
          v15 = (Statement *)ShaderConverter::ParseMatrixCTOR((uint64_t **)a1);
          goto LABEL_24;
        }
      }
      else if (v5 == 16)
      {
        return v4;
      }
      Statement::AddToken(v4, (const Token *)(a1 + 10));
      ShaderConverter::NextToken((ShaderConverter *)a1);
LABEL_25:
      v5 = a1[16];
    }
    while (v5);
  }
  return v4;
}

void sub_1DCD2E1C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ShaderConverter::OutputCode(uint64_t a1, uint64_t a2, std::string *this)
{
  unint64_t v6;
  std::string *v7;
  std::string *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  const std::string::value_type *v12;

  if (*(char *)(a1 + 31) < 0)
    v6 = *(_QWORD *)(a1 + 16);
  else
    v6 = *(unsigned __int8 *)(a1 + 31);
  std::string::reserve(this, vcvtmd_u64_f64((double)v6 * 1.2));
  if (*(_QWORD *)(a1 + 104) != *(_QWORD *)(a1 + 112) || *(_QWORD *)(a1 + 152) != *(_QWORD *)(a1 + 160))
  {
    std::string::append(this, "#pragma arguments\n");
    v7 = *(std::string **)(a1 + 104);
    v8 = *(std::string **)(a1 + 112);
    while (v7 != v8)
    {
      Variable::Output(v7, a1, a2, this);
      v7 += 4;
    }
    v9 = *(uint64_t **)(a1 + 152);
    v10 = *(uint64_t **)(a1 + 160);
    while (v9 != v10)
    {
      v11 = *v9++;
      TextureLookup::OutputUniformDeclaration(v11, a1, a2, this);
    }
  }
  if (*(_BYTE *)(a1 + 96))
    v12 = "#pragma declaration\n";
  else
    v12 = "#pragma body\n";
  std::string::append(this, v12);
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, std::string *))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88), a1, a2, this);
}

void TextureLookup::OutputUniformDeclaration(uint64_t a1, uint64_t a2, uint64_t a3, std::string *a4)
{
  std::string *v5;
  std::string::size_type size;
  std::string v7;

  memset(&v7, 0, sizeof(v7));
  (*(void (**)(_QWORD, uint64_t, uint64_t, std::string *))(**(_QWORD **)(a1 + 56) + 16))(*(_QWORD *)(a1 + 56), a2, a3, &v7);
  if (std::string::compare(&v7, 0, 2uLL, "u_"))
  {
    std::string::append(a4, "sampler ");
    if ((v7.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v5 = &v7;
    else
      v5 = (std::string *)v7.__r_.__value_.__r.__words[0];
    if ((v7.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v7.__r_.__value_.__r.__words[2]);
    else
      size = v7.__r_.__value_.__l.__size_;
    std::string::append(a4, (const std::string::value_type *)v5, size);
    std::string::append(a4, "Sampler\n");
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
}

void sub_1DCD2E3A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFStringRef C3DConvertGLSLShaderToMetal(NSString *a1, __CFDictionary *a2)
{
  const __CFAllocator *v3;
  std::string *v4;
  CFIndex size;
  CFStringRef v6;
  __int128 *v7;
  std::string *v8;
  CFIndex v9;
  CFStringRef v10;
  void **v11;
  CFIndex v12;
  CFStringRef v13;
  __int128 *v14;
  __int128 *v15;
  BOOL v16;
  std::string v18;
  void *__p[2];
  unsigned __int8 v20;
  std::string v21;
  char *v22[25];
  __int128 *v23;
  _BYTE v24[16];

  ShaderConverter::ShaderConverter((ShaderConverter *)v22, a1);
  ShaderConverter::Parse(v22, 0);
  memset(&v21, 0, sizeof(v21));
  ShaderConverter::OutputCode((uint64_t)v22, 2, &v21);
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v4 = &v21;
  else
    v4 = (std::string *)v21.__r_.__value_.__r.__words[0];
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  else
    size = v21.__r_.__value_.__l.__size_;
  v6 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v4, size, 0x8000100u, 0);
  if (a2)
  {
    v7 = v23;
    if (v23 != (__int128 *)v24)
    {
      do
      {
        std::pair<std::string const,std::string>::pair[abi:nn180100](&v18, v7 + 2);
        if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v8 = &v18;
        else
          v8 = (std::string *)v18.__r_.__value_.__r.__words[0];
        if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v9 = HIBYTE(v18.__r_.__value_.__r.__words[2]);
        else
          v9 = v18.__r_.__value_.__l.__size_;
        v10 = CFStringCreateWithBytes(v3, (const UInt8 *)v8, v9, 0x8000100u, 0);
        if ((v20 & 0x80u) == 0)
          v11 = __p;
        else
          v11 = (void **)__p[0];
        if ((v20 & 0x80u) == 0)
          v12 = v20;
        else
          v12 = (CFIndex)__p[1];
        v13 = CFStringCreateWithBytes(v3, (const UInt8 *)v11, v12, 0x8000100u, 0);
        CFDictionarySetValue(a2, v10, v13);
        CFRelease(v10);
        CFRelease(v13);
        if ((char)v20 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v18.__r_.__value_.__l.__data_);
        v14 = (__int128 *)*((_QWORD *)v7 + 1);
        if (v14)
        {
          do
          {
            v15 = v14;
            v14 = *(__int128 **)v14;
          }
          while (v14);
        }
        else
        {
          do
          {
            v15 = (__int128 *)*((_QWORD *)v7 + 2);
            v16 = *(_QWORD *)v15 == (_QWORD)v7;
            v7 = v15;
          }
          while (!v16);
        }
        v7 = v15;
      }
      while (v15 != (__int128 *)v24);
    }
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  ShaderConverter::~ShaderConverter((ShaderConverter *)v22);
  return v6;
}

void sub_1DCD2E598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a21 < 0)
    operator delete(__p);
  ShaderConverter::~ShaderConverter((ShaderConverter *)&a22);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string const,std::string>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

std::string *TokenStatement::Output(std::string *result, uint64_t a2, int a3, std::string *this)
{
  std::string::value_type *v5;
  const std::string::value_type *v6;
  std::string::size_type size;
  int v8;
  const std::string::value_type *v9;
  std::string::size_type v10;
  const void **v11;
  int v12;

  if (LODWORD(result[2].__r_.__value_.__r.__words[1]) == 1)
  {
    if (a3 == 2)
    {
      v11 = ShaderConverter::GLSLToMetalSymbol(a2, (const void **)&result[1].__r_.__value_.__l.__size_);
    }
    else
    {
      if (a3 != 1)
      {
        if (a3)
          return result;
        goto LABEL_5;
      }
      v11 = ShaderConverter::MetalToGLSLSymbol((uint64_t)result, (const void **)&result[1].__r_.__value_.__l.__size_);
    }
    v12 = *((char *)v11 + 23);
    if (v12 >= 0)
      v9 = (const std::string::value_type *)v11;
    else
      v9 = (const std::string::value_type *)*v11;
    if (v12 >= 0)
      v10 = *((unsigned __int8 *)v11 + 23);
    else
      v10 = (std::string::size_type)v11[1];
    return std::string::append(this, v9, v10);
  }
LABEL_5:
  size = result[1].__r_.__value_.__l.__size_;
  v5 = &result[1].__r_.__value_.__s.__data_[8];
  v6 = (const std::string::value_type *)size;
  v8 = v5[23];
  if (v8 >= 0)
    v9 = v5;
  else
    v9 = v6;
  if (v8 >= 0)
    v10 = v5[23];
  else
    v10 = *((_QWORD *)v5 + 1);
  return std::string::append(this, v9, v10);
}

uint64_t Statement::Output(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v4;
  uint64_t *i;
  uint64_t v9;

  v4 = *(uint64_t **)(result + 8);
  for (i = *(uint64_t **)(result + 16);
        v4 != i;
        result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 16))(v9, a2, a3, a4))
  {
    v9 = *v4++;
  }
  return result;
}

_QWORD *TextureLookup::TextureLookup(_QWORD *a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::string *v9;
  __int128 v10;

  a1[2] = 0;
  a1[3] = 0;
  *a1 = &off_1EA5955A0;
  a1[1] = 0;
  v9 = (std::string *)(a1 + 4);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v10 = *a2;
    v9->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
  }
  a1[7] = a3;
  a1[8] = a4;
  a1[9] = a5;
  return a1;
}

void sub_1DCD2E7D8(_Unwind_Exception *a1)
{
  Statement *v1;

  Statement::~Statement(v1);
  _Unwind_Resume(a1);
}

void TextureLookup::~TextureLookup(TextureLookup *this)
{
  TextureLookup::~TextureLookup(this);
  JUMPOUT(0x1DF0D41C0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1EA5955A0;
  v2 = *((_QWORD *)this + 7);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 8);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 9);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  if (*((char *)this + 55) < 0)
    operator delete(*((void **)this + 4));
  Statement::~Statement(this);
}

std::string *TextureLookup::Output(uint64_t a1, uint64_t a2, uint64_t a3, std::string *a4)
{
  uint64_t v8;
  const std::string::value_type *v9;

  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 56) + 16))(*(_QWORD *)(a1 + 56));
  std::string::append(a4, ".sample(");
  (*(void (**)(_QWORD, uint64_t, uint64_t, std::string *))(**(_QWORD **)(a1 + 56) + 16))(*(_QWORD *)(a1 + 56), a2, a3, a4);
  std::string::append(a4, "Sampler");
  std::string::append(a4, ", ");
  (*(void (**)(_QWORD, uint64_t, uint64_t, std::string *))(**(_QWORD **)(a1 + 64) + 16))(*(_QWORD *)(a1 + 64), a2, a3, a4);
  if (*(_QWORD *)(a1 + 72))
  {
    if (*(char *)(a1 + 55) < 0)
      v8 = *(_QWORD *)(a1 + 40);
    else
      v8 = *(unsigned __int8 *)(a1 + 55);
    if (!std::string::compare((const std::string *)(a1 + 32), v8 - 3, 3uLL, "Lod"))
      v9 = ", level(";
    else
      v9 = ", bias(";
    std::string::append(a4, v9);
    (*(void (**)(_QWORD, uint64_t, uint64_t, std::string *))(**(_QWORD **)(a1 + 72) + 16))(*(_QWORD *)(a1 + 72), a2, a3, a4);
    std::string::append(a4, ")");
  }
  return std::string::append(a4, ")");
}

uint64_t MatrixCTOR::MatrixCTOR(uint64_t a1, __int128 *a2, uint64_t a3, int a4, int a5)
{
  __int128 v9;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = &off_1EA5950E0;
  *(_QWORD *)(a1 + 8) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 32), *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v9 = *a2;
    *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(a1 + 32) = v9;
  }
  std::vector<Statement *>::vector((_QWORD *)(a1 + 56), a3);
  *(_DWORD *)(a1 + 80) = a4;
  *(_DWORD *)(a1 + 84) = a5;
  return a1;
}

void sub_1DCD2EA4C(_Unwind_Exception *a1)
{
  Statement *v1;

  Statement::~Statement(v1);
  _Unwind_Resume(a1);
}

void MatrixCTOR::~MatrixCTOR(MatrixCTOR *this)
{
  MatrixCTOR::~MatrixCTOR(this);
  JUMPOUT(0x1DF0D41C0);
}

{
  _QWORD *v2;
  _QWORD *v3;

  *(_QWORD *)this = &off_1EA5950E0;
  v2 = (_QWORD *)*((_QWORD *)this + 7);
  v3 = (_QWORD *)*((_QWORD *)this + 8);
  if (v2 != v3)
  {
    do
    {
      if (*v2)
        (*(void (**)(_QWORD))(*(_QWORD *)*v2 + 8))(*v2);
      ++v2;
    }
    while (v2 != v3);
    v2 = (_QWORD *)*((_QWORD *)this + 7);
  }
  if (v2)
  {
    *((_QWORD *)this + 8) = v2;
    operator delete(v2);
  }
  if (*((char *)this + 55) < 0)
    operator delete(*((void **)this + 4));
  Statement::~Statement(this);
}

void MatrixCTOR::Output(uint64_t a1, uint64_t a2, uint64_t a3, std::string *this)
{
  std::string::value_type *v7;
  const void **v8;
  int v9;
  const std::string::value_type *v10;
  std::string::size_type v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  char v16;
  const std::string::value_type *p_p;
  std::string::size_type v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  std::string::size_type v23;
  uint64_t *v24;
  uint64_t *v25;
  char v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  char v30;
  uint64_t v31;
  void *__p;
  std::string::size_type v33;
  uint64_t v34;

  v7 = (std::string::value_type *)(a1 + 32);
  if ((_DWORD)a3 != 2)
  {
    if (*(char *)(a1 + 55) >= 0)
    {
      v23 = *(unsigned __int8 *)(a1 + 55);
    }
    else
    {
      v7 = *(std::string::value_type **)(a1 + 32);
      v23 = *(_QWORD *)(a1 + 40);
    }
    std::string::append(this, v7, v23);
    std::string::append(this, "(");
    v24 = *(uint64_t **)(a1 + 56);
    v25 = *(uint64_t **)(a1 + 64);
    if (v24 != v25)
    {
      v26 = 1;
      do
      {
        v27 = *v24;
        if ((v26 & 1) == 0)
          std::string::append(this, ", ");
        (*(void (**)(uint64_t, uint64_t, uint64_t, std::string *))(*(_QWORD *)v27 + 16))(v27, a2, a3, this);
        v26 = 0;
        ++v24;
      }
      while (v24 != v25);
    }
    goto LABEL_44;
  }
  v8 = ShaderConverter::GLSLToMetalSymbol(a2, (const void **)v7);
  v9 = *((char *)v8 + 23);
  if (v9 >= 0)
    v10 = (const std::string::value_type *)v8;
  else
    v10 = (const std::string::value_type *)*v8;
  if (v9 >= 0)
    v11 = *((unsigned __int8 *)v8 + 23);
  else
    v11 = (std::string::size_type)v8[1];
  std::string::append(this, v10, v11);
  v12 = *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56);
  v13 = *(int *)(a1 + 84) * (uint64_t)*(int *)(a1 + 80);
  std::string::append(this, "(");
  if (v13 != v12 >> 3)
  {
    v28 = *(uint64_t **)(a1 + 56);
    v29 = *(uint64_t **)(a1 + 64);
    if (v28 != v29)
    {
      v30 = 1;
      do
      {
        v31 = *v28;
        if ((v30 & 1) == 0)
          std::string::append(this, ", ");
        (*(void (**)(uint64_t, uint64_t, uint64_t, std::string *))(*(_QWORD *)v31 + 16))(v31, a2, 2, this);
        v30 = 0;
        ++v28;
      }
      while (v28 != v29);
    }
LABEL_44:
    std::string::append(this, ")");
    return;
  }
  __p = 0;
  v33 = 0;
  v34 = 0;
  v14 = *(_DWORD *)(a1 + 84) - 2;
  if (v14 < 3)
    MEMORY[0x1DF0D40B8](&__p, off_1EA59DBF8[v14]);
  if (*(int *)(a1 + 80) >= 1)
  {
    v15 = 0;
    v16 = 1;
    do
    {
      if ((v16 & 1) == 0)
        std::string::append(this, ", ");
      if (v34 >= 0)
        p_p = (const std::string::value_type *)&__p;
      else
        p_p = (const std::string::value_type *)__p;
      if (v34 >= 0)
        v18 = HIBYTE(v34);
      else
        v18 = v33;
      std::string::append(this, p_p, v18);
      if (*(int *)(a1 + 84) >= 1)
      {
        v19 = 0;
        v20 = 1;
        do
        {
          if ((v20 & 1) == 0)
            std::string::append(this, ", ");
          v21 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * (v19 + *(int *)(a1 + 80) * (uint64_t)v15));
          (*(void (**)(uint64_t, uint64_t, uint64_t, std::string *))(*(_QWORD *)v21 + 16))(v21, a2, 2, this);
          v20 = 0;
          ++v19;
        }
        while ((int)v19 < *(_DWORD *)(a1 + 84));
      }
      std::string::append(this, ")");
      v16 = 0;
      ++v15;
    }
    while (v15 < *(_DWORD *)(a1 + 80));
  }
  std::string::append(this, ")");
  if (SHIBYTE(v34) < 0)
    operator delete(__p);
}

void sub_1DCD2ED74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<Statement *>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<Statement *>::__vallocate[abi:nn180100](a1, v5 >> 3);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<Statement *>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(8 * a2);
}

void BodyStatement::~BodyStatement(BodyStatement *this)
{
  Statement::~Statement(this);
  JUMPOUT(0x1DF0D41C0);
}

std::string *BodyStatement::Output(int a1, int a2, int a3, std::string *this)
{
  return std::string::append(this, "\n");
}

std::string *std::pair<std::string const,std::string>::pair[abi:nn180100](std::string *this, __int128 *a2)
{
  __int128 v4;
  std::string *v5;
  __int128 v6;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  v5 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v6 = *(__int128 *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  return this;
}

void sub_1DCD2EFA4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void std::vector<Variable>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 96;
        std::allocator<Variable>::destroy[abi:nn180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<Variable>::destroy[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 95) < 0)
    operator delete(*(void **)(a2 + 72));
  if (*(char *)(a2 + 71) < 0)
    operator delete(*(void **)(a2 + 48));
  if (*(char *)(a2 + 47) < 0)
    operator delete(*(void **)(a2 + 24));
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::pair<int,int>>,void *>>>::operator()[abi:nn180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0)
      operator delete(__p[4]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t std::vector<Variable>::__push_back_slow_path<Variable>(uint64_t *a1, __int128 *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  void *v19[5];

  v2 = *a1;
  v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  v4 = v3 + 1;
  if (v3 + 1 > 0x2AAAAAAAAAAAAAALL)
    abort();
  v8 = a1[2];
  v7 = a1 + 2;
  v9 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v2) >> 5);
  if (2 * v9 > v4)
    v4 = 2 * v9;
  if (v9 >= 0x155555555555555)
    v10 = 0x2AAAAAAAAAAAAAALL;
  else
    v10 = v4;
  v19[4] = v7;
  if (v10)
    v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Variable>>((uint64_t)v7, v10);
  else
    v11 = 0;
  v12 = &v11[96 * v3];
  v19[0] = v11;
  v19[1] = v12;
  v19[3] = &v11[96 * v10];
  v13 = *a2;
  *((_QWORD *)v12 + 2) = *((_QWORD *)a2 + 2);
  *(_OWORD *)v12 = v13;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  v14 = *(__int128 *)((char *)a2 + 24);
  *((_QWORD *)v12 + 5) = *((_QWORD *)a2 + 5);
  *(_OWORD *)(v12 + 24) = v14;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 5) = 0;
  *((_QWORD *)a2 + 3) = 0;
  v15 = a2[3];
  *((_QWORD *)v12 + 8) = *((_QWORD *)a2 + 8);
  *((_OWORD *)v12 + 3) = v15;
  *((_QWORD *)a2 + 6) = 0;
  *((_QWORD *)a2 + 7) = 0;
  *((_QWORD *)a2 + 8) = 0;
  v16 = *(__int128 *)((char *)a2 + 72);
  *((_QWORD *)v12 + 11) = *((_QWORD *)a2 + 11);
  *(_OWORD *)(v12 + 72) = v16;
  *((_QWORD *)a2 + 9) = 0;
  *((_QWORD *)a2 + 10) = 0;
  *((_QWORD *)a2 + 11) = 0;
  v19[2] = v12 + 96;
  std::vector<Variable>::__swap_out_circular_buffer(a1, v19);
  v17 = a1[1];
  std::__split_buffer<Variable>::~__split_buffer(v19);
  return v17;
}

void sub_1DCD2F22C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Variable>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<Variable>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = *result;
  v3 = result[1];
  v4 = a2[1];
  if (v3 == *result)
  {
    v5 = a2[1];
  }
  else
  {
    do
    {
      v5 = v4 - 96;
      v6 = *(_OWORD *)(v3 - 96);
      *(_QWORD *)(v4 - 80) = *(_QWORD *)(v3 - 80);
      *(_OWORD *)(v4 - 96) = v6;
      *(_QWORD *)(v3 - 88) = 0;
      *(_QWORD *)(v3 - 80) = 0;
      *(_QWORD *)(v3 - 96) = 0;
      v7 = *(_OWORD *)(v3 - 72);
      *(_QWORD *)(v4 - 56) = *(_QWORD *)(v3 - 56);
      *(_OWORD *)(v4 - 72) = v7;
      *(_QWORD *)(v3 - 64) = 0;
      *(_QWORD *)(v3 - 56) = 0;
      *(_QWORD *)(v3 - 72) = 0;
      v8 = *(_OWORD *)(v3 - 48);
      *(_QWORD *)(v4 - 32) = *(_QWORD *)(v3 - 32);
      *(_OWORD *)(v4 - 48) = v8;
      *(_QWORD *)(v3 - 40) = 0;
      *(_QWORD *)(v3 - 32) = 0;
      *(_QWORD *)(v3 - 48) = 0;
      v9 = *(_OWORD *)(v3 - 24);
      *(_QWORD *)(v4 - 8) = *(_QWORD *)(v3 - 8);
      *(_OWORD *)(v4 - 24) = v9;
      *(_QWORD *)(v3 - 24) = 0;
      *(_QWORD *)(v3 - 16) = 0;
      *(_QWORD *)(v3 - 8) = 0;
      v3 -= 96;
      v4 -= 96;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  v10 = *result;
  *result = v5;
  a2[1] = v10;
  v11 = result[1];
  result[1] = a2[2];
  a2[2] = v11;
  v12 = result[2];
  result[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<Variable>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(96 * a2);
}

void **std::__split_buffer<Variable>::~__split_buffer(void **a1)
{
  std::__split_buffer<Variable>::clear[abi:nn180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<Variable>::clear[abi:nn180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 96;
    std::allocator<Variable>::destroy[abi:nn180100](v4, i - 96);
  }
}

uint64_t *std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *result;
  uint64_t *v7;
  uint64_t v8;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  result = *v5;
  if (!*v5)
  {
    std::__tree<std::string>::__construct_node<std::string const&>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

void std::__tree<std::string>::__construct_node<std::string const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x38uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v7->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 16);
  }
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_1DCD2F4C0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::pair<int,int>>,void *>>>::operator()[abi:nn180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v9, a2);
  result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

void std::__tree<std::__value_type<std::string,std::pair<int,int>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<int,int>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<int,int>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    *((_QWORD *)v6 + 6) = *((_QWORD *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  *((_QWORD *)v6 + 7) = 0;
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_1DCD2F5F8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::pair<int,int>>,void *>>>::operator()[abi:nn180100](v3, v2);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<Token>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(32 * a2);
}

uint64_t **std::__tree<Token::TokenType>::__emplace_unique_key_args<Token::TokenType,Token::TokenType>(uint64_t **a1, int *a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  int v7;
  uint64_t **v8;
  int v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_1DCD2F7DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1DF0D41C0](v1, 0x10E1C40F7E7E543);
  _Unwind_Resume(a1);
}

void sub_1DCD2F8F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1DF0D41C0](v1, 0x10E1C40F7E7E543);
  _Unwind_Resume(a1);
}

void SCNCActionHide::~SCNCActionHide(SCNCActionHide *this)
{
  SCNCAction::~SCNCAction((SCNCAction *)this);
  JUMPOUT(0x1DF0D41C0);
}

SCNCActionHide *SCNCActionHide::cpp_updateWithTargetForTime(SCNCActionHide *this, SCNNode *a2, double a3)
{
  SCNCActionHide *v5;

  if (!this->var10)
  {
    v5 = this;
    -[SCNNode setHidden:](a2, "setHidden:", this->var19);
    return (SCNCActionHide *)(*((uint64_t (**)(SCNCActionHide *, SCNNode *, double))v5->var0 + 14))(v5, a2, a3);
  }
  return this;
}

SCNCActionHide *SCNCActionHide::cpp_backwardUpdateWithTargetForTime(SCNCActionHide *this, SCNNode *a2, double a3)
{
  SCNCActionHide *v5;

  if (!this->var10)
  {
    v5 = this;
    -[SCNNode setHidden:](a2, "setHidden:", !this->var19);
    return (SCNCActionHide *)(*((uint64_t (**)(SCNCActionHide *, SCNNode *, double))v5->var0 + 14))(v5, a2, a3);
  }
  return this;
}

void __CopyParticles(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unsigned int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  float ParticleLifeSpan;
  uint64_t v23;
  float v24;
  void (**v25)(_OWORD *, _QWORD, uint64_t);
  _OWORD v28[76];
  uint8_t v29[4];
  _QWORD v30[3];

  *(_QWORD *)((char *)&v30[1] + 4) = *MEMORY[0x1E0C80C00];
  if (a1 == (unsigned int *)a3)
  {
    v10 = scn_default_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      __CopyParticles_cold_2(v10, v11, v12);
  }
  if (a1[244])
  {
    v13 = 0;
    do
    {
      v14 = &a1[2 * v13];
      if (*((_QWORD *)v14 + 90))
      {
        v15 = *((unsigned __int8 *)a1 + v13 + 980);
        v16 = *(unsigned int *)(a3 + 976);
        if (!(_DWORD)v16)
          goto LABEL_14;
        v17 = a1[v13 + 148];
        v18 = (unsigned __int8 *)(a3 + 980);
        while (1)
        {
          v19 = *v18++;
          if (v19 == v15)
            break;
          if (!--v16)
            goto LABEL_14;
        }
        if (*(_DWORD *)(a3 + 592 + 4 * v13) == (_DWORD)v17)
        {
          memcpy((void *)(*(_QWORD *)&a1[2 * v13] + v17 * a2), (const void *)(*(_QWORD *)(a3 + 8 * v13) + v17 * a4), v17 * a5);
        }
        else
        {
LABEL_14:
          if (v15 == 3)
          {
            v20 = *(_QWORD *)&a1[2 * v13];
            if (!v20)
            {
              v21 = scn_default_log();
              if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
                __CopyParticles_cold_1(v29, v30, v21);
            }
            ParticleLifeSpan = C3DParticleSystemGetParticleLifeSpan(*(_QWORD *)(a6 + 48));
            if (a5 >= 1)
            {
              v23 = a2;
              v24 = 1.0 / ParticleLifeSpan;
              do
                *(float *)(v20 + 4 * v23++) = v24;
              while (v23 < a5 + a2);
            }
          }
          else
          {
            v25 = (void (**)(_OWORD *, _QWORD, uint64_t))(v14 + 180);
            memset(v28, 0, 512);
            C3DParticleContextSetup((uint64_t)v28, a6, a1, 0.0, 0.0);
            (*v25)(v28, 0, a5);
          }
        }
      }
      ++v13;
    }
    while (v13 < a1[244]);
  }
}

void __DestroyParticles(uint64_t a1)
{
  unint64_t v1;
  unint64_t i;
  void *v4;

  v1 = *(unsigned int *)(a1 + 976);
  if ((_DWORD)v1)
  {
    for (i = 0; i < v1; ++i)
    {
      v4 = *(void **)(a1 + 8 * i);
      if (v4)
      {
        free(v4);
        v1 = *(unsigned int *)(a1 + 976);
      }
      *(_QWORD *)(a1 + 8 * i) = 0;
    }
  }
}

uint64_t _C3DParticleSystemInstanceAllocateParticlesData(unsigned int *a1, const void *a2, unsigned int a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t i;
  unsigned int v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int __src[256];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  bzero(__src, 0x250uLL);
  memcpy(&__src[148], a2, 0x1B0uLL);
  if (a3)
  {
    v6 = __src[244];
    if (__src[244])
    {
      v7 = 0;
      for (i = 148; i - 148 < v6; ++i)
      {
        v9 = __src[i];
        if (v9)
        {
          if (malloc_type_posix_memalign((void **)&__src[v7], 0x40uLL, v9 * a3, 0xC5C365A3uLL))
            return 0;
          v6 = __src[244];
        }
        v7 += 2;
      }
    }
  }
  v10 = 0;
  v11 = (unsigned __int8 *)&__src[250] + 1;
  do
  {
    v12 = *(v11 - 21);
    if (v12 != 255)
    {
      v13 = *(_QWORD *)&__src[2 * v12];
      *(_QWORD *)&__src[v10 + 64] = v13;
      v14 = *v11;
      if (v14 != 255)
        v13 = *(_QWORD *)&__src[2 * v14];
      *(_QWORD *)&__src[v10 + 106] = v13;
    }
    v10 += 2;
    ++v11;
  }
  while (v10 != 42);
  v15 = a1[276];
  if ((_DWORD)v15)
    __CopyParticles(__src, 0, (uint64_t)(a1 + 20), 0, v15, (uint64_t)a1);
  __DestroyParticles((uint64_t)(a1 + 20));
  memcpy(a1 + 20, __src, 0x400uLL);
  a1[278] = a3;
  a1[277] = 0;
  return 1;
}

uint64_t C3DParticleSystemInstanceGetTypeID()
{
  if (C3DParticleSystemInstanceGetTypeID_onceToken != -1)
    dispatch_once(&C3DParticleSystemInstanceGetTypeID_onceToken, &__block_literal_global_3);
  return C3DParticleSystemInstanceGetTypeID_typeID;
}

void _C3DParticleSystemInstanceCFFinalize(uint64_t a1)
{
  uint64_t EnginePipeline;
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;

  free(*(void **)(a1 + 16));
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  __DestroyParticles(a1 + 80);
  *(_DWORD *)(a1 + 1104) = 0;
  *(_DWORD *)(a1 + 1112) = 0;
  if (*(_DWORD *)(a1 + 1188))
  {
    EnginePipeline = C3DSceneGetEnginePipeline(*(_QWORD *)(a1 + 64));
    if (EnginePipeline)
    {
      v3 = EnginePipeline;
      v4 = *(_QWORD *)(EnginePipeline + 48);
      if (v4)
        __C3DRendererElementStoreDeallocateSpan(v4, *(_QWORD *)(a1 + 1184), v3);
    }
  }
  v5 = *(const void **)(a1 + 1192);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 1192) = 0;
  }
  v6 = *(const void **)(a1 + 1200);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 1200) = 0;
  }
  v7 = *(const void **)(a1 + 48);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 48) = 0;
  }
}

CFStringRef _C3DParticleSystemInstanceCFCopyFormatDescription(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<C3DParticleSystemInstanceRef>"));
}

CFStringRef _C3DParticleSystemInstanceCFCopyDebugDescription(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("<C3DParticleSystemInstanceRef>"));
}

uint64_t C3DParticleSystemInstanceCreate(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t Instance;
  uint64_t URL;
  const void *v8;
  const __CFAllocator *v9;
  const CFArrayCallBacks *v10;
  int Seed;

  if (C3DParticleSystemInstanceGetTypeID_onceToken != -1)
    dispatch_once(&C3DParticleSystemInstanceGetTypeID_onceToken, &__block_literal_global_3);
  Instance = C3DTypeCreateInstance_(C3DParticleSystemInstanceGetTypeID_typeID, 0x4B0uLL);
  URL = C3DSceneSourceGetURL(a3);
  *(_QWORD *)(Instance + 40) = a1;
  v8 = *(const void **)(Instance + 48);
  if (v8 != a2)
  {
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(Instance + 48) = 0;
    }
    if (a2)
      CFRetain(a2);
  }
  *(_QWORD *)(Instance + 48) = a2;
  *(_QWORD *)(Instance + 56) = a3;
  *(_QWORD *)(Instance + 64) = URL;
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v10 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  *(_QWORD *)(Instance + 1192) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(Instance + 1200) = CFArrayCreateMutable(v9, 1, v10);
  Seed = C3DParticleSystemGetSeed((uint64_t)a2);
  *(_DWORD *)(Instance + 1116) = Seed;
  if (!Seed)
    *(_DWORD *)(Instance + 1116) = random();
  return Instance;
}

uint64_t C3DParticleSystemInstanceGetParticlesCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1104);
}

uint64_t C3DParticleSystemInstanceSetNode(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = a2;
  return result;
}

uint64_t C3DParticleSystemInstanceGetSystem(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

__n128 C3DParticleSystemInstanceGetWorldBoundingBox(uint64_t a1)
{
  float32x4_t *v2;
  float32x4_t *WorldMatrix;
  __n128 result;

  if (C3DParticleSystemGetIsLocal(*(_QWORD *)(a1 + 48)) && (v2 = *(float32x4_t **)(a1 + 40)) != 0)
  {
    WorldMatrix = C3DNodeGetWorldMatrix(v2);
    result.n128_u64[0] = vaddq_f32(WorldMatrix[3], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(WorldMatrix[1], *(float32x2_t *)(a1 + 1152), 1), *WorldMatrix, COERCE_FLOAT(*(_OWORD *)(a1 + 1152))), WorldMatrix[2], *(float32x4_t *)(a1 + 1152), 2)).u64[0];
  }
  else
  {
    return *(__n128 *)(a1 + 1152);
  }
  return result;
}

uint64_t __C3DParticleSystemInstanceComputeDepth(uint64_t result, uint64_t a2)
{
  float *v2;
  uint64_t v3;
  float32x4_t *v4;
  float32x4_t v5;
  float v6;
  float32x4_t v7;
  float32x4_t v8;

  v2 = *(float **)(result + 632);
  if (v2)
  {
    v3 = *(unsigned int *)(result + 1104);
    if ((_DWORD)v3)
    {
      v4 = *(float32x4_t **)(result + 504);
      v5 = (float32x4_t)vuzp2q_s32(vuzp2q_s32(*(int32x4_t *)a2, *(int32x4_t *)(a2 + 16)), *(int32x4_t *)a2);
      v5.i32[2] = *(_DWORD *)(a2 + 44);
      v6 = *(float *)(a2 + 60);
      do
      {
        v7 = *v4++;
        v8 = vmulq_f32(v5, v7);
        *v2++ = v6
              + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0];
        --v3;
      }
      while (v3);
    }
  }
  return result;
}

uint64_t __C3DParticleSystemInstanceComputeDistance(uint64_t result, float32x4_t *a2)
{
  _DWORD *v2;
  uint64_t v3;
  float32x4_t v4;
  float32x4_t *v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;

  v2 = *(_DWORD **)(result + 632);
  if (v2)
  {
    v3 = *(unsigned int *)(result + 1104);
    if ((_DWORD)v3)
    {
      v4 = *a2;
      v4.i32[3] = 0;
      v5 = *(float32x4_t **)(result + 504);
      do
      {
        v6 = *v5++;
        v7 = vsubq_f32(v6, v4);
        v8 = vmulq_f32(v7, v7);
        *v2++ = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).u32[0];
        --v3;
      }
      while (v3);
    }
  }
  return result;
}

uint64_t __decreasingFloatData(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  if (*(float *)(a1 + 4 * *a2) <= *(float *)(a1 + 4 * *a3))
    return 1;
  else
    return 0xFFFFFFFFLL;
}

uint64_t __increasingFloatData(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  if (*(float *)(a1 + 4 * *a2) > *(float *)(a1 + 4 * *a3))
    return 1;
  else
    return 0xFFFFFFFFLL;
}

void _C3DParticleSystemInstanceSort(uint64_t a1, float32x4_t *a2, uint64_t a3)
{
  unsigned int SortingMode;
  unsigned int v7;
  void *v8;
  void *v9;
  _DWORD *v10;
  size_t v11;
  size_t v12;
  int (__cdecl *v13)(void *, const void *, const void *);
  void *v14;

  SortingMode = C3DParticleSystemGetSortingMode(*(_QWORD *)(a1 + 48));
  if ((C3DParticleSystemGetRenderingMode(*(_QWORD *)(a1 + 48)) & 0xFE) == 2)
    v7 = 4;
  else
    v7 = SortingMode;
  if (v7)
  {
    v8 = *(void **)(a1 + 632);
    v9 = *(void **)(a1 + 536);
    if (v7 > 2)
    {
      if (!v9)
        return;
    }
    else if (!v8)
    {
      return;
    }
    v10 = *(_DWORD **)(a1 + 544);
    if (v10)
    {
      if (*(_DWORD *)(a1 + 1104))
      {
        v11 = 0;
        do
        {
          v10[v11] = v11;
          ++v11;
          v12 = *(unsigned int *)(a1 + 1104);
        }
        while (v11 < v12);
      }
      else
      {
        v12 = 0;
      }
      switch(v7)
      {
        case 1u:
          __C3DParticleSystemInstanceComputeDepth(a1, a3);
          goto LABEL_19;
        case 2u:
          __C3DParticleSystemInstanceComputeDistance(a1, a2);
LABEL_19:
          v13 = (int (__cdecl *)(void *, const void *, const void *))__decreasingFloatData;
          v12 = *(unsigned int *)(a1 + 1104);
          v14 = v10;
          v9 = v8;
          goto LABEL_23;
        case 3u:
          v13 = (int (__cdecl *)(void *, const void *, const void *))__increasingFloatData;
          goto LABEL_22;
        case 4u:
          v13 = (int (__cdecl *)(void *, const void *, const void *))__decreasingFloatData;
LABEL_22:
          v14 = v10;
LABEL_23:
          qsort_r(v14, v12, 4uLL, v9, v13);
          break;
        default:
          return;
      }
    }
  }
}

_DWORD *__CopyParticle(_DWORD *result, uint64_t a2, uint64_t a3)
{
  _DWORD *v5;
  unint64_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  if (result[244])
  {
    v5 = result;
    v6 = 0;
    do
    {
      if (*(_QWORD *)&v5[2 * v6 + 180])
      {
        v7 = v5[v6 + 148];
        switch((_DWORD)v7)
        {
          case 4:
            *(_DWORD *)(*(_QWORD *)&v5[2 * v6] + 4 * a2) = *(_DWORD *)(*(_QWORD *)&v5[2 * v6] + 4 * a3);
            break;
          case 0xC:
            v8 = *(_QWORD *)&v5[2 * v6];
            v9 = (uint64_t *)(v8 + 12 * a3);
            v10 = *v9;
            v11 = v8 + 12 * a2;
            *(_DWORD *)(v11 + 8) = *((_DWORD *)v9 + 2);
            *(_QWORD *)v11 = v10;
            break;
          case 0x10:
            *(_OWORD *)(*(_QWORD *)&v5[2 * v6] + 16 * a2) = *(_OWORD *)(*(_QWORD *)&v5[2 * v6] + 16 * a3);
            break;
          default:
            result = memcpy((void *)(*(_QWORD *)&v5[2 * v6] + v7 * a2), (const void *)(*(_QWORD *)&v5[2 * v6] + v7 * a3), v7);
            break;
        }
      }
      ++v6;
    }
    while (v6 < v5[244]);
  }
  return result;
}

uint64_t C3DParticleSystemInstanceCheckParticlesCount(uint64_t a1, unsigned int a2)
{
  unsigned int v4;
  float BirthRate;
  float v6;
  float ParticleLifeSpan;
  unsigned int i;
  unsigned int v9;
  BOOL v11;

  v4 = *(_DWORD *)(a1 + 1112);
  if (v4 < a2)
  {
    BirthRate = C3DParticleSystemGetBirthRate(*(_QWORD *)(a1 + 48));
    v6 = BirthRate + C3DParticleSystemGetBirthRateVariation(*(_QWORD *)(a1 + 48));
    ParticleLifeSpan = C3DParticleSystemGetParticleLifeSpan(*(_QWORD *)(a1 + 48));
    for (i = (float)(v6
                                  * (float)(ParticleLifeSpan
                                          + C3DParticleSystemGetParticleLifeSpanVariation(*(_QWORD *)(a1 + 48))))
            + 8; i < a2; i += i >> 1)
      ;
LABEL_13:
    _C3DParticleSystemInstanceAllocateParticlesData((unsigned int *)a1, (const void *)(a1 + 672), i);
    return 1;
  }
  v9 = v4 >> 2;
  v11 = *(_DWORD *)(a1 + 1104) >= a2 && a2 >= 8 && v9 >= a2;
  i = a2;
  if (v11)
    goto LABEL_13;
  return 1;
}

void __C3DParticleSystemInstanceApplyControllers(uint64_t a1, double a2, double a3)
{
  uint64_t Controllers;
  uint64_t v7;
  float v8;
  double v9;
  int8x16_t v10;
  int8x16_t v11;
  unint64_t i;
  int v13;
  float32x4_t *v14;
  float32x4_t v15;
  float32x4_t v16;
  unsigned int v17;
  _OWORD v18[64];
  unsigned int v19;
  float32x4_t *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  Controllers = C3DParticleSystemGetControllers(*(_QWORD *)(a1 + 48), &v17);
  if (Controllers)
  {
    v7 = Controllers;
    v8 = a3;
    memset(v18, 0, 512);
    C3DParticleContextSetup((uint64_t)v18, a1, (const void *)(a1 + 80), a2, v8);
    if (v17)
    {
      for (i = 0; i < v17; ++i)
      {
        if (*(_BYTE *)(v7 + 48) && *(_QWORD *)(v7 + 16))
        {
          v13 = *(unsigned __int8 *)(v7 + 24);
          if (v13 == 2)
          {
            C3DParticleAnimatePropertyWithOtherProperty((uint64_t)v18, 0, v19, (float *)v7, v9, v10, v11);
          }
          else if (v13 == 1)
          {
            if (*(_QWORD *)(v7 + 40))
              v14 = *(float32x4_t **)(v7 + 40);
            else
              v14 = v20;
            if (v14)
            {
              v16.i32[2] = 0;
              v16.i64[0] = 0;
              C3DNodeGetWorldPosition(v14, (__n128 *)&v16);
              v15 = v16;
              v15.i32[3] = 0;
            }
            else
            {
              v15 = 0uLL;
            }
            C3DParticleAnimatePropertyWithDistance((uint64_t)v18, 0, v19, (float *)v7, v15, *(double *)v10.i64, v11);
          }
          else if (!*(_BYTE *)(v7 + 24))
          {
            C3DParticleAnimatePropertyWithLife(v18, 0, v19, (unsigned __int8 *)v7);
          }
        }
        v7 += 80;
      }
    }
  }
}

void __C3DParticleSystemInstanceStep(uint64_t a1, double a2, float a3, float a4)
{
  uint64_t v8;
  void (*SimulateLifeCallback)(uint64_t, float);
  uint64_t v10;
  char v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  _OWORD *v16;
  _OWORD *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  int v25;
  __int128 v26;
  float ParticleSize;
  int32x2_t v28;
  float32x4_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  void *v35;
  __int128 v36;
  __int128 v37;
  _QWORD block[4];
  _BYTE v39[1216];
  uint64_t *v40;
  uint64_t v41;
  unsigned int v42;
  _OWORD __src[76];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 48);
  if (C3DParticleSystemGetParticleLifeSpan(v8) < INFINITY)
  {
    SimulateLifeCallback = (void (*)(uint64_t, float))C3DParticleSystemGetSimulateLifeCallback(v8);
    SimulateLifeCallback(a1, a3);
  }
  v10 = *(unsigned int *)(a1 + 1104);
  if (!*(_DWORD *)(a1 + 24))
  {
    v11 = 0;
    if (!(_DWORD)v10)
      goto LABEL_11;
LABEL_14:
    memset(__src, 0, 512);
    C3DParticleContextSetup((uint64_t)__src, a1, (const void *)(a1 + 80), a2, a3);
    LODWORD(__src[64]) = v10;
    if (v10 >= 0x801 && *((_QWORD *)&__src[74] + 1))
    {
      v32 = 0;
      v33 = &v32;
      v34 = 0x4010000000;
      v35 = &unk_1DD0EA3D6;
      v36 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 48);
      v37 = xmmword_1DD0076D0;
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ____C3DParticleSystemInstanceStep_block_invoke;
      block[3] = &unk_1EA59DC18;
      memcpy(v39, __src, sizeof(v39));
      v42 = (v10 + 15) >> 4;
      v41 = a1;
      v40 = &v32;
      dispatch_apply(0x10uLL, *((dispatch_queue_t *)&__src[74] + 1), block);
      v26 = *((_OWORD *)v33 + 3);
      __src[68] = *((_OWORD *)v33 + 2);
      __src[69] = v26;
      _Block_object_dispose(&v32, 8);
    }
    else
    {
      C3DParticleSystemProcessAffectors(*(_QWORD *)(a1 + 48), (uint64_t)__src, 0, v10);
    }
    ParticleSize = C3DParticleSystemGetParticleSize(v8);
    *(float *)v28.i32 = ParticleSize + C3DParticleSystemGetParticleSizeVariation(v8);
    v29 = vaddq_f32((float32x4_t)__src[69], (float32x4_t)vdupq_lane_s32(v28, 0));
    v29.i32[3] = HIDWORD(__src[69]);
    __src[69] = v29;
    *(_OWORD *)(a1 + 1152) = __src[68];
    *(_OWORD *)(a1 + 1168) = __src[69];
    if ((v11 & 1) != 0)
      goto LABEL_12;
    goto LABEL_19;
  }
  v11 = 0;
  v12 = 0;
  do
  {
    v13 = *(_QWORD *)(a1 + 16) + 160 * v12;
    C3DParticleSystemInstanceStepEmitter(a1, v13, a2, a3, a4);
    if (*(_DWORD *)(v13 + 16) == 3)
    {
      v14 = *(_DWORD *)(a1 + 24) - 1;
      *(_DWORD *)(a1 + 24) = v14;
      if (v12 < v14)
      {
        v15 = *(_QWORD *)(a1 + 16);
        v16 = (_OWORD *)(v15 + 160 * v12);
        v17 = (_OWORD *)(v15 + 160 * v14);
        v18 = v17[1];
        *v16 = *v17;
        v16[1] = v18;
        v19 = v17[2];
        v20 = v17[3];
        v21 = v17[5];
        v16[4] = v17[4];
        v16[5] = v21;
        v16[2] = v19;
        v16[3] = v20;
        v22 = v17[6];
        v23 = v17[7];
        v24 = v17[9];
        v16[8] = v17[8];
        v16[9] = v24;
        v16[6] = v22;
        v16[7] = v23;
      }
    }
    else
    {
      ++v12;
      v11 = 1;
    }
  }
  while (v12 < *(_DWORD *)(a1 + 24));
  if (*(_DWORD *)(a1 + 1104))
    goto LABEL_14;
LABEL_11:
  if ((v11 & 1) != 0)
  {
LABEL_12:
    v25 = 0;
    goto LABEL_28;
  }
LABEL_19:
  if (C3DIsRunningInXcode()
    && ((v30 = *(_QWORD *)(a1 + 64)) != 0 || (v31 = *(_QWORD **)(a1 + 40)) != 0 && (v30 = C3DGetScene(v31)) != 0)
    && C3DSceneIsPausedForEditing(v30))
  {
    __DestroyParticles(a1 + 80);
    *(_DWORD *)(a1 + 1104) = 0;
    *(_DWORD *)(a1 + 1112) = 0;
    v25 = 2;
  }
  else if (*(_DWORD *)(a1 + 1104))
  {
    v25 = 1;
  }
  else
  {
    v25 = 2;
  }
LABEL_28:
  *(_DWORD *)(a1 + 32) = v25;
}

float32x4_t *C3DParticleSystemInstanceStepEmitter(uint64_t a1, uint64_t a2, double a3, float a4, float a5)
{
  uint64_t v9;
  float EmissionDuration;
  float EmissionDurationVariation;
  unsigned int v12;
  float IdleDuration;
  float IdleDurationVariation;
  unsigned int v15;
  void (*EmissionCallback)(uint64_t, float32x4_t *, double, float);
  float32x4_t *result;
  __int128 v18;
  __int128 v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  int v28;

  v9 = *(_QWORD *)(a1 + 48);
  if (!*(_DWORD *)(a2 + 16))
  {
    EmissionDuration = C3DParticleSystemGetEmissionDuration(*(_QWORD *)(a1 + 48));
    EmissionDurationVariation = C3DParticleSystemGetEmissionDurationVariation(v9);
    if (EmissionDurationVariation != 0.0)
    {
      v12 = 214013 * *(_DWORD *)(a1 + 1116) + 2531011;
      *(_DWORD *)(a1 + 1116) = v12;
      EmissionDuration = EmissionDuration
                       + (float)((float)((float)((float)HIWORD(v12) * 0.000015259) + -0.5) * EmissionDurationVariation);
    }
    *(float *)a2 = EmissionDuration;
    *(_DWORD *)(a2 + 4) = 0;
    IdleDuration = C3DParticleSystemGetIdleDuration(v9);
    IdleDurationVariation = C3DParticleSystemGetIdleDurationVariation(v9);
    if (IdleDurationVariation != 0.0)
    {
      v15 = 214013 * *(_DWORD *)(a1 + 1116) + 2531011;
      *(_DWORD *)(a1 + 1116) = v15;
      IdleDuration = IdleDuration
                   + (float)((float)((float)((float)HIWORD(v15) * 0.000015259) + -0.5) * IdleDurationVariation);
    }
    *(float *)(a2 + 8) = IdleDuration;
    *(_DWORD *)(a2 + 16) = 1;
  }
  EmissionCallback = C3DParticleSystemGetEmissionCallback(v9);
  result = *(float32x4_t **)(a2 + 24);
  if (result)
  {
    v18 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(a2 + 96) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a2 + 112) = v18;
    v19 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a2 + 128) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(a2 + 144) = v19;
    result = (float32x4_t *)C3DNodeIsHiddenOrIsHiddenByAncestor((uint64_t)result);
    if ((result & 1) != 0)
      return result;
    result = C3DNodeGetWorldMatrix(*(float32x4_t **)(a2 + 24));
    v20 = vmlaq_n_f32(vmulq_n_f32(result[1], a5), *(float32x4_t *)(a2 + 112), 1.0 - a5);
    v21 = vmlaq_n_f32(vmulq_n_f32(result[2], a5), *(float32x4_t *)(a2 + 128), 1.0 - a5);
    v22 = vmlaq_n_f32(vmulq_n_f32(result[3], a5), *(float32x4_t *)(a2 + 144), 1.0 - a5);
    *(float32x4_t *)(a2 + 32) = vmlaq_n_f32(vmulq_n_f32(*result, a5), *(float32x4_t *)(a2 + 96), 1.0 - a5);
    *(float32x4_t *)(a2 + 48) = v20;
    *(float32x4_t *)(a2 + 64) = v21;
    *(float32x4_t *)(a2 + 80) = v22;
  }
  v23 = *(_DWORD *)(a2 + 16);
  if (v23 != 1)
    goto LABEL_16;
  result = (float32x4_t *)((uint64_t (*)(uint64_t, uint64_t, double, float))EmissionCallback)(a1, a2, a3, a4);
  v24 = *(float *)a2;
  v25 = *(float *)(a2 + 4) + a4;
  *(float *)(a2 + 4) = v25;
  if (v25 <= v24)
  {
    v23 = *(_DWORD *)(a2 + 16);
LABEL_16:
    if (v23 != 2)
      return result;
    v26 = *(float *)(a2 + 8);
LABEL_18:
    v27 = v26 - a4;
    *(float *)(a2 + 8) = v27;
    if (v27 >= 0.0)
      return result;
    goto LABEL_19;
  }
  result = (float32x4_t *)C3DParticleSystemGetLoops(v9);
  if (!(_DWORD)result)
  {
    v28 = 3;
    goto LABEL_21;
  }
  v26 = *(float *)(a2 + 8);
  if (v26 > 0.0)
  {
    *(_DWORD *)(a2 + 16) = 2;
    a4 = *(float *)(a2 + 4) - *(float *)a2;
    goto LABEL_18;
  }
LABEL_19:
  v28 = 0;
LABEL_21:
  *(_DWORD *)(a2 + 16) = v28;
  return result;
}

void C3DParticleSystemInstanceReset(uint64_t a1)
{
  __DestroyParticles(a1 + 80);
  *(_DWORD *)(a1 + 1104) = 0;
  *(_DWORD *)(a1 + 1112) = 0;
}

void C3DParticleSystemInstanceUpdate(uint64_t a1, double a2)
{
  double v4;
  unsigned int v5;
  float WarmupDuration;
  double v7;
  BOOL v8;
  double v9;
  double SpeedFactor;
  double v11;
  _DWORD *ParticleLayout;
  const void *v13;
  double v14;
  float v15;
  unsigned int v16;
  unsigned int v17;
  float v18;
  unsigned int i;
  float v20;

  v4 = *(double *)(a1 + 1128);
  v5 = 2;
  if (v4 == 0.0)
  {
    WarmupDuration = C3DParticleSystemGetWarmupDuration(*(_QWORD *)(a1 + 48));
    v7 = fmaxf(WarmupDuration, 0.0);
    v8 = WarmupDuration == 0.0;
    if (WarmupDuration == 0.0)
      v5 = 2;
    else
      v5 = 1000;
    v9 = -0.0;
    if (!v8)
      v9 = v7;
    a2 = v9 + a2;
    v4 = *(double *)(a1 + 1128);
  }
  *(double *)(a1 + 1128) = a2 + v4;
  SpeedFactor = C3DParticleSystemGetSpeedFactor(*(_QWORD *)(a1 + 48));
  if (C3DParticleSystemGetAndClearMeshDidChange(*(_QWORD *)(a1 + 48)))
  {
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 1192));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 1200));
  }
  v11 = a2 * SpeedFactor;
  ParticleLayout = (_DWORD *)C3DParticleSystemGetParticleLayout(*(_QWORD *)(a1 + 48));
  v13 = ParticleLayout;
  if (ParticleLayout[96] != *(_DWORD *)(a1 + 1056) || memcmp(ParticleLayout, (const void *)(a1 + 672), 0x1B0uLL))
  {
    if (!_C3DParticleSystemInstanceAllocateParticlesData((unsigned int *)a1, v13, *(_DWORD *)(a1 + 1112)))
      return;
    if (v11 == 0.0)
      __C3DParticleSystemInstanceApplyControllers(a1, v4, v11);
  }
  if (v11 != 0.0 || C3DIsRunningInXcode())
  {
    v14 = SpeedFactor / 60.0;
    v15 = v11 / (SpeedFactor / 60.0);
    v16 = rintf(v15);
    if (v16 <= 1)
      v16 = 1;
    if (v16 >= v5)
      v17 = v5;
    else
      v17 = v16;
    if (v17 >= 2)
    {
      for (i = 1; i != v17; ++i)
      {
        v18 = v14;
        __C3DParticleSystemInstanceStep(a1, v4, v18, (float)i / (float)v17);
        v4 = v14 + v4;
        v11 = v11 - v14;
      }
    }
    v20 = v11;
    __C3DParticleSystemInstanceStep(a1, v4, v20, 1.0);
    __C3DParticleSystemInstanceApplyControllers(a1, v4, v11);
  }
}

uint64_t C3DParticleSystemInstanceSync(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  if (!*(_DWORD *)(result + 1188))
  {
    v3 = result;
    *(_QWORD *)(result + 1184) = C3DRendererElementStoreAllocateSpanForNode(a2, 0, *(_QWORD *)(result + 40), 4);
    result = C3DEnginePipelineGetRendererElementStore(a2);
    if (*(_DWORD *)(v3 + 1188))
    {
      v4 = result;
      v5 = 0;
      do
      {
        result = C3DRendererElementStoreGetElementInSpanAtIndex(v4, *(_QWORD *)(v3 + 1184), v5);
        *(_QWORD *)(result + 48) = v3;
        ++v5;
      }
      while (v5 < *(unsigned int *)(v3 + 1188));
    }
  }
  return result;
}

uint64_t _C3DParticleRender_Quads(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, char a6)
{
  int LightingEnabled;
  int v11;
  unsigned int v12;
  float32x4_t *v13;
  uint64_t v14;
  uint64_t result;
  _BOOL4 HasFeatures;
  int v17;
  CFIndex v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  const void *v22;
  const void *v23;
  uint64_t v24;
  int v25;
  float32x4_t v28;

  LightingEnabled = C3DParticleSystemGetLightingEnabled(*(_QWORD *)(a1 + 48));
  if (C3DParticleSystemGetOrientationMode(*(_QWORD *)(a1 + 48)) == 2)
    v11 = 0;
  else
    v11 = LightingEnabled;
  v12 = *(_DWORD *)(a1 + 1104);
  if (C3DEngineContextIsWarmUp(a3))
    v12 = 1;
  if (!v12)
    return 0;
  if (C3DParticleSystemGetSortingMode(*(_QWORD *)(a1 + 48)))
  {
    v13 = (float32x4_t *)(a2 + (a4 << 6));
    v28 = v13[172];
    _C3DParticleSystemInstanceSort(a1, &v28, (uint64_t)&v13[241]);
    v14 = *(_QWORD *)(a1 + 544);
  }
  else
  {
    v14 = 0;
  }
  HasFeatures = C3DEngineContextHasFeatures(a3, 2);
  v17 = 0;
  v18 = 0;
  if (v11)
    v19 = 13107;
  else
    v19 = 0x4000;
  do
  {
    if (v12 >= v19)
      v20 = v19;
    else
      v20 = v12;
    if (HasFeatures)
      v21 = v12;
    else
      v21 = v20;
    v22 = __meshAtIndex(a1, v18);
    v23 = __meshElementAtIndex(a1, v18);
    result = _C3DParticleRender_Quads_Batch((_QWORD *)a1, v17, v21, v14, v22, (uint64_t)v23, v24, a3, a5, a6);
    if ((_DWORD)result)
      v25 = v21;
    else
      v25 = 0;
    if (!(_DWORD)result)
      break;
    v17 += v25;
    v18 += result;
    v12 -= v25;
  }
  while (v12);
  return result;
}

const void *__meshAtIndex(uint64_t a1, CFIndex a2)
{
  const void *Volatile;

  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 1192)) > a2)
    return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1192), a2);
  Volatile = (const void *)C3DMeshCreateVolatile();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1192), Volatile);
  CFRelease(Volatile);
  return Volatile;
}

const void *__meshElementAtIndex(uint64_t a1, CFIndex a2)
{
  const void *v5;

  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 1200)) > a2)
    return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1200), a2);
  v5 = (const void *)C3DMeshElementCreate();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1200), v5);
  CFRelease(v5);
  return v5;
}

uint64_t _C3DParticleRender_Quads_Batch(_QWORD *a1, int a2, int a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, char a10)
{
  _BOOL4 HasFeatures;
  uint64_t RendererContextGL;
  uint64_t RenderContext;
  uint64_t v20;
  int LightingEnabled;
  uint64_t result;
  _BOOL4 v23;
  _BOOL4 v25;
  float ParticleIntensity;
  float v27;
  unsigned int v28;
  uint64_t v29;
  const void *SourceWithSemanticAtIndex;
  const void *Volatile;
  uint64_t v32;
  const void *v33;
  uint64_t v34;
  const void *SharedQuadStereoMeshSource;
  const void *v36;
  uint64_t v37;
  int v38;
  const void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t ResourceManager;
  int v43;
  _BOOL4 v44;
  _QWORD *Accessor;
  _QWORD *v46;
  _QWORD *v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t VolatileValuePtrAtIndex;
  uint64_t Library;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  BOOL v58;
  int v59;
  _DWORD *v60;
  float ParticleSize;
  float32x4_t *v62;
  _DWORD *v63;
  uint64_t v64;
  float v65;
  float ParticleLifeSpan;
  float v67;
  unsigned int v68;
  uint64_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t v83;
  uint32x2_t v84;
  __int32 v85;
  float v86;
  unsigned int v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  int8x16_t v92;
  __int32 v93;
  char *v94;
  float v95;
  _DWORD *v96;
  _DWORD *v97;
  _DWORD *v98;
  _DWORD *v99;
  float32x4_t *v100;
  __int32 *v101;
  __int32 *v102;
  uint64_t v103;
  unsigned int v104;
  uint64_t *v105;
  _DWORD *v106;
  uint64_t v107;
  uint64_t v108;
  float32x4_t v109;
  float32x4_t v110;
  uint64_t v111;
  _DWORD *v112;
  _BOOL4 v113;
  unsigned int v114;
  char v115;
  unsigned int v116;
  uint64_t v117;
  uint64_t PrimitiveCount;
  uint64_t v119;
  int InstanceCount;
  uint64_t v121;
  uint64_t SharedPyramidStereoMeshElement;
  uint64_t v123;
  char *SharedPyramidQuadsMeshElement;
  uint64_t SharedPyramidMeshElement;
  char v126;
  uint64_t v127;
  char *v128;
  int v129;
  char *v130;
  char Type;
  float32x4_t v132;
  uint64_t v133;
  uint64_t v134;
  float v135;
  uint64_t v136;
  _BOOL4 v137;
  uint64_t v138;
  float v139;
  char v140;
  uint64_t v141;
  int v142;
  _QWORD *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  int v147;
  uint64_t v148;
  char *v149;
  float *v150;
  uint64_t v151;
  uint64_t v152;
  float32x4_t *v153;
  float32x4_t *v154;
  uint64_t v155;
  uint64_t v156;
  _BOOL4 v157;
  int OrientationMode;
  _DWORD *v159;
  _DWORD *v160;
  uint64_t v161;
  _BOOL4 HasTextureAnimation;

  HasFeatures = C3DEngineContextHasFeatures(a8, 1);
  RendererContextGL = C3DEngineContextGetRendererContextGL(a8);
  RenderContext = C3DEngineContextGetRenderContext(a8);
  if (!(RendererContextGL | RenderContext))
    return 0;
  v20 = RenderContext;
  v138 = a8;
  v136 = RendererContextGL;
  v148 = a4;
  LightingEnabled = C3DParticleSystemGetLightingEnabled(a1[6]);
  v141 = v20;
  v142 = a3;
  v157 = C3DParticleSystemGetStretchFactor(a1[6]) != 0.0 && C3DParticleSystemGetRenderingMode(a1[6]) == 0;
  OrientationMode = C3DParticleSystemGetOrientationMode(a1[6]);
  v23 = OrientationMode != 2;
  HasTextureAnimation = C3DParticleSystemHasTextureAnimation(a1[6]);
  v25 = a9 - 1 < 2 && a10 == 1;
  v137 = v25;
  ParticleIntensity = C3DParticleSystemGetParticleIntensity(a1[6]);
  v27 = ParticleIntensity + C3DParticleSystemGetParticleIntensityVariation(a1[6]);
  if (v27 > 1.0)
    v28 = 1;
  else
    v28 = 21;
  v140 = LightingEnabled & v23;
  if ((LightingEnabled & v23) != 0)
    LODWORD(v29) = 5;
  else
    LODWORD(v29) = 4;
  if (HasFeatures)
    v29 = 1;
  else
    v29 = v29;
  v152 = v29;
  SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 0, 0, 1);
  if (!SourceWithSemanticAtIndex)
  {
    SourceWithSemanticAtIndex = (const void *)C3DMeshSourceCreateVolatile(0, 4, 1u);
    C3DMeshAddSource((uint64_t)a5, SourceWithSemanticAtIndex, 0, 0);
    CFRelease(SourceWithSemanticAtIndex);
  }
  Volatile = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 3, 0, 1);
  if (!Volatile)
  {
    if (HasTextureAnimation)
      v32 = 3;
    else
      v32 = 2;
    Volatile = (const void *)C3DMeshSourceCreateVolatile(3, v32, 1u);
    C3DMeshAddSource((uint64_t)a5, Volatile, 0, 0);
    CFRelease(Volatile);
  }
  v33 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 2, 0, 1);
  if (!v33)
  {
    v33 = (const void *)C3DMeshSourceCreateVolatile(2, 4, v28);
    C3DMeshAddSource((uint64_t)a5, v33, 0, 0);
    CFRelease(v33);
  }
  v147 = a2;
  if (HasFeatures)
  {
    v34 = a1[7];
    if (v137)
      SharedQuadStereoMeshSource = (const void *)C3DParticleManagerGetSharedQuadStereoMeshSource(v34, v140 & 1);
    else
      SharedQuadStereoMeshSource = (const void *)C3DParticleManagerGetSharedQuadMeshSource(v34, v140 & 1);
    v36 = SharedQuadStereoMeshSource;
    v37 = v141;
    if (C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 3, 1, 1) != SharedQuadStereoMeshSource)
    {
      C3DMeshRemoveSourceWithSemanticAtIndex((uint64_t)a5, 3, 1);
      C3DMeshRemoveSourceWithSemanticAtIndex((uint64_t)a5, 3, 1);
      C3DMeshAddSource((uint64_t)a5, v36, 0, 0);
    }
  }
  else
  {
    v36 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 3, 1, 1);
    v37 = v141;
    if (!v36)
    {
      v36 = (const void *)C3DMeshSourceCreateVolatile(3, 2, 1u);
      C3DMeshAddSource((uint64_t)a5, v36, 0, 0);
      CFRelease(v36);
    }
  }
  v38 = v157;
  if (OrientationMode == 2)
    v38 = 1;
  v143 = a1;
  if (v38 == 1)
  {
    v39 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)a5, 3, 2, 1);
    if (!v39)
    {
      if (OrientationMode == 2)
        v40 = 4;
      else
        v40 = 3;
      v39 = (const void *)C3DMeshSourceCreateVolatile(3, v40, 1u);
      C3DMeshAddSource((uint64_t)a5, v39, 0, 0);
      CFRelease(v39);
    }
  }
  else
  {
    v39 = 0;
  }
  v41 = (v152 * v142);
  if (HasFeatures)
  {
    C3DMeshSourceSetInstancingDivisor((uint64_t)SourceWithSemanticAtIndex, 1);
    C3DMeshSourceSetInstancingDivisor((uint64_t)Volatile, 1);
    if (v39)
      C3DMeshSourceSetInstancingDivisor((uint64_t)v39, 1);
    if (v33)
      C3DMeshSourceSetInstancingDivisor((uint64_t)v33, 1);
  }
  if (v37)
  {
    -[SCNMTLRenderContext mapVolatileMesh:verticesCount:](v37, (uint64_t)a5, v41);
  }
  else
  {
    ResourceManager = C3DEngineContextGetResourceManager(v138);
    v43 = C3DRendererContextMapVolatileMesh(v136, ResourceManager, a5, v41, 0);
    result = 0;
    if (!v43)
      return result;
  }
  v133 = (uint64_t)a5;
  v44 = HasFeatures;
  Accessor = (_QWORD *)C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex);
  v46 = (_QWORD *)C3DMeshSourceGetAccessor(Volatile);
  v47 = (_QWORD *)C3DMeshSourceGetAccessor(v33);
  v48 = (_QWORD *)C3DMeshSourceGetAccessor(v36);
  v134 = a6;
  if (v39)
    v49 = (_QWORD *)C3DMeshSourceGetAccessor(v39);
  else
    v49 = 0;
  VolatileValuePtrAtIndex = C3DSourceAccessorGetVolatileValuePtrAtIndex(Accessor, 0);
  Library = C3DSceneSourceGetLibrary((uint64_t)Accessor);
  v52 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v47, 0);
  v53 = C3DSceneSourceGetLibrary((uint64_t)v47);
  if (v44)
  {
    v155 = 0;
    v156 = 0;
  }
  else
  {
    v156 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v48, 0);
    v155 = C3DSceneSourceGetLibrary((uint64_t)v48);
  }
  v54 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v46, 0);
  v55 = C3DSceneSourceGetLibrary((uint64_t)v46);
  if (v49)
  {
    v56 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v49, 0);
    v161 = C3DSceneSourceGetLibrary((uint64_t)v49);
  }
  else
  {
    v56 = 0;
    v161 = 0;
  }
  v57 = v56;
  if (v56)
    v58 = OrientationMode == 2;
  else
    v58 = 0;
  v59 = v58;
  v150 = (float *)v143[65];
  v146 = v143[66];
  v60 = (_DWORD *)v143[63];
  v153 = (float32x4_t *)v143[64];
  v149 = (char *)v143[76];
  v159 = (_DWORD *)v143[77];
  ParticleSize = C3DParticleSystemGetParticleSize(v143[6]);
  v145 = v143[70];
  v135 = C3DParticleSystemGetParticleIntensity(v143[6]);
  v144 = v143[83];
  v132 = *(float32x4_t *)C3DParticleSystemGetParticleColor(v143[6]);
  v151 = v143[71];
  if (C3DEngineContextIsWarmUp(v138))
  {
    v60 = &_C3DParticleRender_Quads_Batch_s_vel_velAngle;
    v62 = (float32x4_t *)&_C3DParticleRender_Quads_Batch_s_vel_velAngle;
    v149 = (char *)&_C3DParticleRender_Quads_Batch_s_rotAxis;
    v150 = (float *)&_C3DParticleRender_Quads_Batch_s_frame;
    v63 = &_C3DParticleRender_Quads_Batch_s_frame;
  }
  else
  {
    v62 = v153;
    v63 = v159;
  }
  v64 = v143[5];
  v154 = v62;
  v160 = v63;
  if (v64)
  {
    C3DNodeGetWorldAlpha(v64);
    v139 = v65;
  }
  else
  {
    v139 = 1.0;
  }
  ParticleLifeSpan = C3DParticleSystemGetParticleLifeSpan(v143[6]);
  v67 = v135;
  if (v142)
  {
    v68 = 0;
    v69 = 0;
    v70 = vmulq_n_f32(v132, v139);
    v72 = vmulq_n_f32(v70, v135);
    v71 = vmulq_laneq_f32(v72, v70, 3);
    v72.i32[3] = v70.i32[3];
    v71.i32[3] = v70.i32[3];
    v73 = vmaxnmq_f32(v71, (float32x4_t)0);
    __asm { FMOV            V3.4S, #1.0 }
    v78 = vminnmq_f32(v73, _Q3);
    v79 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v80.i64[0] = 0x3F0000003F000000;
    v80.i64[1] = 0x3F0000003F000000;
    v81 = (int8x16_t)vcvtq_s32_f32(vmlaq_f32(v80, v79, v78));
    v82.i64[0] = 0xFF000000FFLL;
    v82.i64[1] = 0xFF000000FFLL;
    v83 = vandq_s8(v81, v82);
    v84 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v83, v83, 8uLL), (uint32x2_t)0x1800000010);
    v85 = v83.i32[0] | (v83.i32[1] << 8) | v84.i32[0] | v84.i32[1];
    v86 = 1.0 / ParticleLifeSpan;
    do
    {
      v87 = v69 + v147;
      if (v148)
        v87 = *(_DWORD *)(v148 + 4 * v87);
      if (v146)
        v86 = *(float *)(v146 + 4 * v87);
      if (v145)
        ParticleSize = *(float *)(v145 + 4 * v87);
      if (v144)
      {
        v67 = *(float *)(v144 + 4 * v87);
        if (v151)
          goto LABEL_88;
        v72 = vmulq_n_f32(v70, v67);
        v72.i32[3] = v70.i32[3];
      }
      else if (v151)
      {
LABEL_88:
        v88 = vmulq_n_f32(*(float32x4_t *)(v151 + 16 * v87), v139);
        v89 = vmulq_n_f32(v88, v67);
        v72 = v89;
        v72.i32[3] = v88.i32[3];
        if (v27 <= 1.0)
        {
          v90 = vmulq_laneq_f32(v89, v88, 3);
          v90.i32[3] = v72.i32[3];
          v91.i64[0] = 0x3F0000003F000000;
          v91.i64[1] = 0x3F0000003F000000;
          v92 = vandq_s8((int8x16_t)vcvtq_s32_f32(vmlaq_f32(v91, v79, vminnmq_f32(vmaxnmq_f32(v90, (float32x4_t)0), _Q3))), v82);
          v93 = v92.i32[0] | (v92.i32[1] << 8);
          *(uint32x2_t *)v92.i8 = vshl_u32((uint32x2_t)*(_OWORD *)&vextq_s8(v92, v92, 8uLL), (uint32x2_t)0x1800000010);
          v85 = v93 | v92.i32[0] | v92.i32[1];
        }
      }
      v94 = &v149[12 * v87];
      v95 = 1.0 - (float)(v86 * v150[v87]);
      v96 = &v60[4 * v87];
      v97 = v96 + 1;
      v98 = v96 + 2;
      v99 = v96 + 3;
      v100 = &v154[v87];
      v101 = &v100->i32[1];
      v102 = &v100->i32[2];
      v103 = v152;
      v104 = v68;
      v105 = &qword_1DD007680;
      do
      {
        v106 = (_DWORD *)(VolatileValuePtrAtIndex + Library * v104);
        *v106 = v60[4 * v87];
        v106[1] = *v97;
        v106[2] = *v98;
        v106[3] = *v99;
        v107 = v53 * v104;
        if (v27 > 1.0)
          *(float32x4_t *)(v52 + v107) = v72;
        else
          *(_DWORD *)(v52 + v107) = v85;
        v108 = v54 + v55 * v104;
        *(float *)v108 = v95;
        *(float *)(v108 + 4) = ParticleSize;
        if (HasTextureAnimation)
        {
          *(_DWORD *)(v108 + 8) = v160[v87];
          if (!v44)
            goto LABEL_96;
        }
        else if (!v44)
        {
LABEL_96:
          *(_QWORD *)(v156 + v155 * v104) = *v105;
          if (v59)
            goto LABEL_102;
          goto LABEL_97;
        }
        if (v59)
        {
LABEL_102:
          v112 = (_DWORD *)(v57 + v161 * v104);
          *v112 = *(_DWORD *)v94;
          v112[1] = *((_DWORD *)v94 + 1);
          v112[2] = *((_DWORD *)v94 + 2);
          v112[3] = *v99;
          goto LABEL_104;
        }
LABEL_97:
        if (v157)
        {
          v109 = v154[v87];
          v110 = vmulq_f32(v109, v109);
          v111 = v57 + v161 * v104;
          if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v110, 2), vaddq_f32(v110, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v110.f32, 1))).f32[0] <= 0.0)
          {
            *(_QWORD *)v111 = 0x3A83126F00000000;
            *(_DWORD *)(v111 + 8) = 0;
          }
          else
          {
            *(_DWORD *)v111 = v109.i32[0];
            *(_DWORD *)(v111 + 4) = *v101;
            *(_DWORD *)(v111 + 8) = *v102;
          }
        }
LABEL_104:
        ++v105;
        ++v104;
        --v103;
      }
      while (v103);
      ++v69;
      v68 += v152;
    }
    while (v69 != v142);
  }
  if (v141)
    -[SCNMTLRenderContext unmapVolatileMesh:modifiedVerticesCount:](v141, v133, -1);
  else
    C3DRendererContextUnmapVolatileMesh(v136, v133);
  v113 = v44;
  if ((v140 & 1) != 0)
    v114 = 4;
  else
    v114 = 2;
  if ((v140 & 1) != 0)
    v115 = 2;
  else
    v115 = 1;
  v116 = v142 << v115;
  if (v113)
    v117 = v114;
  else
    v117 = v116;
  PrimitiveCount = C3DMeshElementGetPrimitiveCount(v134);
  v119 = PrimitiveCount;
  if (!v113)
  {
    if (PrimitiveCount != v117)
    {
      v123 = v143[7];
      if ((v140 & 1) != 0)
        SharedPyramidQuadsMeshElement = (char *)C3DParticleManagerGetSharedPyramidQuadsMeshElement(v123, v142);
      else
        SharedPyramidQuadsMeshElement = (char *)C3DParticleManagerGetSharedQuadsMeshElement(v123, v142);
      C3DMeshElementSetSharedMeshElement(v134, SharedPyramidQuadsMeshElement, 0, v116);
    }
    return 1;
  }
  InstanceCount = C3DMeshElementGetInstanceCount(v134);
  if (v119 != v117 || InstanceCount != v142)
  {
    C3DMeshElementSetPrimitives(v134, v117, 0, 0);
    if (v137)
    {
      v121 = v143[7];
      if ((v140 & 1) != 0)
        SharedPyramidStereoMeshElement = C3DParticleManagerGetSharedPyramidStereoMeshElement(v121);
      else
        SharedPyramidStereoMeshElement = C3DParticleManagerGetSharedQuadsStereoMeshElement(v121);
      v130 = (char *)SharedPyramidStereoMeshElement;
      Type = C3DMeshElementGetType(SharedPyramidStereoMeshElement);
      C3DMeshElementSetType(v134, Type);
      v129 = 2 * v114;
      v127 = v134;
      v128 = v130;
    }
    else
    {
      if ((v140 & 1) == 0)
      {
        C3DMeshElementSetType(v134, 1);
        goto LABEL_135;
      }
      SharedPyramidMeshElement = C3DParticleManagerGetSharedPyramidMeshElement(v143[7]);
      v126 = C3DMeshElementGetType(SharedPyramidMeshElement);
      C3DMeshElementSetType(v134, v126);
      v127 = v134;
      v128 = (char *)SharedPyramidMeshElement;
      v129 = 4;
    }
    C3DMeshElementSetSharedMeshElement(v127, v128, 0, v129);
LABEL_135:
    C3DMeshElementSetInstanceCount(v134, v142);
  }
  return 1;
}

uint64_t _C3DParticleRender_Strip(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t RendererContextGL;
  const void *v10;
  const void *SourceWithSemanticAtIndex;
  const void *Volatile;
  const void *v13;
  const void *v14;
  uint64_t RenderContext;
  uint64_t ResourceManager;
  int v17;
  _QWORD *Accessor;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t VolatileValuePtrAtIndex;
  uint64_t Library;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t ParticleColorController;
  uint64_t v32;
  float ParticleSize;
  __int128 *ParticleColor;
  float ParticleLifeSpan;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float v41;
  uint64_t v42;
  float v43;
  uint64_t v44;
  int8x16_t v45;
  uint64_t v46;
  uint64_t v47;
  _DWORD *v48;
  int64x2_t v49;
  _DWORD *v50;
  _DWORD *v51;
  _DWORD *v52;
  char v53;
  uint64_t v54;
  _DWORD *v55;
  uint64_t v56;
  int v57;
  char v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  const void *v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  float32x4_t v72;
  int8x16_t v73;
  unsigned int v74;
  uint64_t v75;
  __int128 v76;

  if (a3 < 2)
    return 0;
  RendererContextGL = C3DEngineContextGetRendererContextGL(a5);
  v10 = __meshAtIndex(a1, 0);
  v64 = __meshElementAtIndex(a1, 0);
  SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v10, 0, 0, 1);
  if (!SourceWithSemanticAtIndex)
  {
    SourceWithSemanticAtIndex = (const void *)C3DMeshSourceCreateVolatile(0, 4, 1u);
    C3DMeshAddSource((uint64_t)v10, SourceWithSemanticAtIndex, 0, 0);
    CFRelease(SourceWithSemanticAtIndex);
  }
  Volatile = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v10, 3, 0, 1);
  if (!Volatile)
  {
    Volatile = (const void *)C3DMeshSourceCreateVolatile(3, 4, 1u);
    C3DMeshAddSource((uint64_t)v10, Volatile, 0, 0);
    CFRelease(Volatile);
  }
  v13 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v10, 3, 1, 1);
  if (!v13)
  {
    v13 = (const void *)C3DMeshSourceCreateVolatile(3, 4, 1u);
    C3DMeshAddSource((uint64_t)v10, v13, 0, 0);
    CFRelease(v13);
  }
  v14 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v10, 2, 0, 1);
  if (!v14)
  {
    v14 = (const void *)C3DMeshSourceCreateVolatile(2, 4, 1u);
    C3DMeshAddSource((uint64_t)v10, v14, 0, 0);
    CFRelease(v14);
  }
  RenderContext = C3DEngineContextGetRenderContext(a5);
  v63 = RenderContext;
  if (RenderContext)
  {
    -[SCNMTLRenderContext mapVolatileMesh:verticesCount:](RenderContext, (uint64_t)v10, 2 * a3);
  }
  else
  {
    ResourceManager = C3DEngineContextGetResourceManager(a5);
    v17 = C3DRendererContextMapVolatileMesh(RendererContextGL, ResourceManager, v10, 2 * a3, 0);
    result = 0;
    if (!v17)
      return result;
  }
  v61 = 2 * a3;
  v62 = (uint64_t)v10;
  v60 = RendererContextGL;
  Accessor = (_QWORD *)C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex);
  v19 = (_QWORD *)C3DMeshSourceGetAccessor(Volatile);
  v20 = (_QWORD *)C3DMeshSourceGetAccessor(v13);
  v21 = (_QWORD *)C3DMeshSourceGetAccessor(v14);
  VolatileValuePtrAtIndex = C3DSourceAccessorGetVolatileValuePtrAtIndex(Accessor, 0);
  v74 = a3;
  Library = C3DSceneSourceGetLibrary((uint64_t)Accessor);
  v24 = (uint64_t *)a1;
  v25 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v21, 0);
  v26 = C3DSceneSourceGetLibrary((uint64_t)v21);
  v27 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v19, 0);
  v28 = C3DSceneSourceGetLibrary((uint64_t)v19);
  v29 = C3DSourceAccessorGetVolatileValuePtrAtIndex(v20, 0);
  v30 = C3DSceneSourceGetLibrary((uint64_t)v20);
  _C3DParticleSystemInstanceSort((uint64_t)v24, 0, 0);
  ParticleColorController = C3DParticleSystemGetParticleColorController(v24[6]);
  v70 = v24[65];
  v71 = ParticleColorController;
  v69 = v24[66];
  v32 = v24[63];
  v67 = v24[68];
  ParticleSize = C3DParticleSystemGetParticleSize(v24[6]);
  v68 = v24[70];
  ParticleColor = (__int128 *)C3DParticleSystemGetParticleColor(v24[6]);
  v65 = v24[71];
  v76 = *ParticleColor;
  ParticleLifeSpan = C3DParticleSystemGetParticleLifeSpan(v24[6]);
  v36 = v67;
  v37 = 0;
  v38 = v74;
  v39 = 0uLL;
  v40 = 0uLL;
  v41 = 1.0 / ParticleLifeSpan;
  v66 = v74;
  do
  {
    v42 = *(unsigned int *)(v36 + 4 * v37);
    if (v69)
      v41 = *(float *)(v69 + 4 * v42);
    if (v68)
      ParticleSize = *(float *)(v68 + 4 * v42);
    v43 = 1.0 - (float)(v41 * *(float *)(v70 + 4 * v42));
    if (v71)
    {
      v75 = v37;
      v72 = v40;
      v73 = v39;
      C3DAnimationEvaluate(v71);
      v40 = v72;
      v39 = v73;
      v37 = v75;
      v38 = v66;
      v36 = v67;
    }
    else if (v65)
    {
      v76 = *(_OWORD *)(v65 + 16 * v42);
    }
    if (v37)
      v39 = (int8x16_t)vsubq_f32(*(float32x4_t *)(v32 + 16 * v42), v40);
    v44 = v37 + 1;
    v45 = v39;
    if (v37 + 1 < v38)
    {
      v40 = *(float32x4_t *)(v32 + 16 * v42);
      v45 = (int8x16_t)vsubq_f32(*(float32x4_t *)(v32 + 16 * *(unsigned int *)(v36 + 4 * v44)), v40);
    }
    v46 = 0;
    v47 = (2 * v37);
    v48 = (_DWORD *)(v32 + 16 * v42);
    v49.i64[1] = *((_QWORD *)&v76 + 1);
    v50 = v48 + 1;
    v51 = v48 + 2;
    v52 = v48 + 3;
    v53 = 1;
    do
    {
      v54 = v46 | v47;
      v55 = (_DWORD *)(VolatileValuePtrAtIndex + Library * (v46 | v47));
      *v55 = *(_DWORD *)(v32 + 16 * v42);
      v55[1] = *v50;
      v55[2] = *v51;
      v55[3] = *v52;
      v56 = v29 + v30 * (v46 | v47);
      *(_QWORD *)v56 = v45.i64[0];
      *(_DWORD *)(v56 + 8) = v45.i32[2];
      v57 = *((_DWORD *)&qword_1DD0076C8 + v46);
      v58 = v53;
      *(_DWORD *)(v56 + 12) = v57;
      v59 = v27 + v28 * (v46 | v47);
      *(float *)v59 = v43;
      *(float *)(v59 + 4) = ParticleSize;
      *(float *)(v59 + 8) = v43;
      *(_DWORD *)(v59 + 12) = v57;
      *(_OWORD *)(v25 + v26 * v54) = v76;
      v46 = 1;
      v53 = 0;
    }
    while ((v58 & 1) != 0);
    v40.i64[0] = 0;
    v49.i64[0] = v37;
    v39 = vbslq_s8((int8x16_t)vdupq_lane_s64(vceqq_s64(v49, (int64x2_t)v40).i64[0], 0), v45, v39);
    v40 = *(float32x4_t *)(v32 + 16 * v42);
    ++v37;
  }
  while (v44 != v38);
  if (v63)
    -[SCNMTLRenderContext unmapVolatileMesh:modifiedVerticesCount:](v63, v62, -1);
  else
    C3DRendererContextUnmapVolatileMesh(v60, v62);
  if (v61 - 2 != C3DMeshElementGetPrimitiveCount((uint64_t)v64))
    C3DMeshElementInit((uint64_t)v64, 1, v61 - 2, 0, 0);
  return 1;
}

__n128 C3DParticleSystemInstanceDraw(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  CFIndex Count;
  __n128 result;
  uint64_t RendererContextGL;
  uint64_t v15;
  uint64_t ResourceManager;
  uint64_t v17;
  CFIndex i;
  void *ValueAtIndex;
  const void *v20;
  NSObject *v21;
  uint64_t RenderContext;
  uint64_t v23;
  CFIndex v24;
  BOOL v26;
  const void *v27;
  _DWORD *v28;
  char v29;
  uint64_t v30;
  __n128 v31;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 1192));
  if (Count == CFArrayGetCount(*(CFArrayRef *)(a1 + 1200)))
  {
    RendererContextGL = C3DEngineContextGetRendererContextGL(a2);
    if (RendererContextGL)
    {
      v15 = RendererContextGL;
      ResourceManager = C3DEngineContextGetResourceManager(a2);
      if (Count >= 1)
      {
        v17 = ResourceManager;
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1192), i);
          C3DRendererContextBindMesh(v15, v17, ValueAtIndex);
          v20 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1200), i);
          C3DRendererContextBindMeshElement(v15, v17, v20);
          C3DRendererContextRenderResidentMeshElement(v15);
        }
      }
    }
    else
    {
      RenderContext = C3DEngineContextGetRenderContext(a2);
      v30 = *(_QWORD *)(a3 + 24);
      v31 = *(__n128 *)(a3 + 40);
      if (Count >= 1)
      {
        v23 = RenderContext;
        v24 = 0;
        v26 = (a5 - 3) < 0xFFFFFFFE || a6 != 1;
        do
        {
          v27 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1192), v24);
          v28 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1200), v24);
          if (v28)
            v29 = v26;
          else
            v29 = 1;
          if ((v29 & 1) == 0 && C3DEngineContextGetEyeCount(a2) == 2)
            v28[17] >>= 1;
          *(_QWORD *)(a3 + 24) = v27;
          *(_QWORD *)(a3 + 40) = 0;
          *(_QWORD *)(a3 + 48) = v28;
          -[SCNMTLRenderContext drawRenderElement:withPass:](v23, a3, a4);
          ++v24;
        }
        while (Count != v24);
      }
      *(_QWORD *)(a3 + 24) = v30;
      result = v31;
      *(__n128 *)(a3 + 40) = v31;
    }
  }
  else if ((C3DParticleSystemInstanceDraw_done & 1) == 0)
  {
    C3DParticleSystemInstanceDraw_done = 1;
    v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      C3DParticleSystemInstanceDraw_cold_1(v21);
  }
  return result;
}

void C3DParticleSystemInstancePushRendererElements(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, float32x4_t *a5, uint64_t a6, int a7, int a8)
{
  uint64_t v14;
  uint64_t v15;
  float FogEndDistance;
  uint64_t v17;
  uint64_t *v18;
  _DWORD *v19;
  uint64_t ElementInSpanAtIndex;
  const void *Material;
  const void *Technique;
  const void *v23;
  CFTypeRef v24;
  const void *v25;
  CFTypeRef v26;
  uint64_t v27;
  uint64_t v28;
  __int16 v29;
  uint64_t LightingSystem;
  uint64_t v31;
  uint64_t CategoryBitMask;
  NSObject *v33;
  uint64_t v34;
  _WORD *v35;
  uint64_t *v36;
  _DWORD *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _WORD *v42;
  uint64_t i;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  _DWORD *v50;
  uint64_t *v51;
  __int16 v52;
  __int16 v53;
  uint64_t v56;
  uint8_t v57[4];
  _DWORD v58[7];

  *(_QWORD *)&v58[5] = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)(a1 + 1188))
    return;
  v14 = *(_QWORD *)(a1 + 40);
  v15 = v14 ? C3DNodeGetCategoryBitMask(*(_QWORD *)(a1 + 40)) : -1;
  if (a2[589] & v15 | ((a2[588] & v15) == 0))
    return;
  if (v14)
  {
    if (*((_BYTE *)a2 + 4690) && (*(_BYTE *)(v14 + 222) & 0x40) == 0
      || *((_BYTE *)a2 + 4691) && (*(_BYTE *)(v14 + 222) & 0x40) != 0)
    {
      return;
    }
  }
  else if (*((_BYTE *)a2 + 4690))
  {
    return;
  }
  v52 = *(_WORD *)(a1 + 1186);
  v53 = *(_WORD *)(a1 + 1184);
  v56 = *(unsigned int *)(a1 + 1188);
  v51 = &a2[2 * a6 + 614];
  if (*(_DWORD *)(a1 + 1120) != a4 || *(_BYTE *)(a1 + 1124))
  {
    FogEndDistance = C3DSceneGetFogEndDistance(a2[591]);
    *(_BYTE *)(a1 + 1124) = C3DParticleSystemGetSortingMode(*(_QWORD *)(a1 + 48)) - 1 < 2;
    *(_DWORD *)(a1 + 1120) = a4;
    if (!(_DWORD)v56)
      return;
    v17 = 0;
    v49 = *((unsigned __int8 *)a2 + 4693);
    v18 = &a2[2 * a6];
    v19 = v18 + 615;
    v50 = (_DWORD *)v18 + 1231;
    while (1)
    {
      ElementInSpanAtIndex = C3DRendererElementStoreGetElementInSpanAtIndex(*(_QWORD *)(*a2 + 48), *(_QWORD *)(a1 + 1184), v17);
      Material = (const void *)C3DParticleSystemGetMaterial(*(__n128 **)(a1 + 48), *(_QWORD *)(a1 + 56), FogEndDistance > 0.0, a3, a7, a8);
      Technique = (const void *)C3DMaterialGetTechnique((uint64_t)Material);
      v23 = *(const void **)(ElementInSpanAtIndex + 32);
      if (v23 != Material)
      {
        if (v23)
        {
          CFRelease(v23);
          *(_QWORD *)(ElementInSpanAtIndex + 32) = 0;
        }
        if (Material)
          v24 = CFRetain(Material);
        else
          v24 = 0;
        *(_QWORD *)(ElementInSpanAtIndex + 32) = v24;
      }
      v25 = *(const void **)(ElementInSpanAtIndex + 40);
      if (v25 != Technique)
      {
        if (v25)
        {
          CFRelease(v25);
          *(_QWORD *)(ElementInSpanAtIndex + 40) = 0;
        }
        if (Technique)
          v26 = CFRetain(Technique);
        else
          v26 = 0;
        *(_QWORD *)(ElementInSpanAtIndex + 40) = v26;
      }
      *(_QWORD *)(ElementInSpanAtIndex + 8) = *(_QWORD *)(a1 + 40);
      *(_QWORD *)(ElementInSpanAtIndex + 48) = a1;
      if ((C3DParticleSystemGetRenderingMode(*(_QWORD *)(a1 + 48)) & 0xFE) == 2)
      {
        if ((_C3DParticleRender_Strip(a1, v27, *(_DWORD *)(a1 + 1104), v28, a3) & 1) != 0)
          goto LABEL_36;
      }
      else if (_C3DParticleRender_Quads(a1, (uint64_t)a2, a3, a6, a7, a8))
      {
LABEL_36:
        C3DEnginePipelineSyncRendererElement(*a2, ElementInSpanAtIndex, -1);
        *(_WORD *)(ElementInSpanAtIndex + 72) = *(_WORD *)(ElementInSpanAtIndex + 72) & 0xFFEF | (16
                                                                                                * (C3DParticleSystemGetBlendMode(*(_QWORD *)(a1 + 48)) == 5));
        if (C3DParticleSystemGetLightingEnabled(*(_QWORD *)(a1 + 48)))
          v29 = 64;
        else
          v29 = 0;
        *(_WORD *)(ElementInSpanAtIndex + 72) = *(_WORD *)(ElementInSpanAtIndex + 72) & 0xFFBF | v29;
        if (!C3DEngineContextIsClusteredShadingEnabled(a3)
          && v49
          && a5
          && (*(_WORD *)(ElementInSpanAtIndex + 72) & 0x40) != 0)
        {
          LightingSystem = C3DSceneGetLightingSystem(a2[591]);
          v31 = *(_QWORD *)(ElementInSpanAtIndex + 8);
          if (v31)
            CategoryBitMask = C3DNodeGetCategoryBitMask(v31);
          else
            CategoryBitMask = -1;
          C3DLightingSystemQuery(LightingSystem, a5, CategoryBitMask, (_QWORD *)(ElementInSpanAtIndex + 56));
        }
        if ((*v19 + 1) > *v50)
        {
          v33 = scn_default_log();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
            C3DParticleSystemInstancePushRendererElements_cold_2(v57, v58, v33);
        }
        v34 = *v19;
        v35 = (_WORD *)(*v51 + 4 * v34);
        *v35 = v53;
        v35[1] = v52 + v17;
        *v19 = v34 + 1;
      }
      if (v56 == ++v17)
        return;
    }
  }
  v36 = &a2[2 * a6];
  v37 = v36 + 615;
  if ((*((_DWORD *)v36 + 1230) + 1) > *((_DWORD *)v36 + 1231))
  {
    v38 = scn_default_log();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
      C3DParticleSystemInstancePushRendererElements_cold_1(v38, v39, v40);
  }
  v41 = *v37;
  v42 = (_WORD *)(*v51 + 4 * v41);
  *v42 = v53;
  v42[1] = v52;
  *v37 = v41 + 1;
  if (!C3DEngineContextIsClusteredShadingEnabled(a3) && (_DWORD)v56)
  {
    for (i = 0; i != v56; ++i)
    {
      v44 = C3DRendererElementStoreGetElementInSpanAtIndex(*(_QWORD *)(*a2 + 48), *(_QWORD *)(a1 + 1184), i);
      if (a5)
      {
        v45 = v44;
        if ((*(_WORD *)(v44 + 72) & 0x40) != 0)
        {
          v46 = C3DSceneGetLightingSystem(a2[591]);
          v47 = *(_QWORD *)(v45 + 8);
          if (v47)
            v48 = C3DNodeGetCategoryBitMask(v47);
          else
            v48 = -1;
          C3DLightingSystemQuery(v46, a5, v48, (_QWORD *)(v45 + 56));
        }
      }
    }
  }
}

_DWORD *C3DParticleSystemInstanceSimulateLife(_DWORD *result, float a2)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  float v10;

  v2 = result;
  v3 = result[276];
  if ((_DWORD)v3)
  {
    v5 = 0;
    v6 = *((_QWORD *)result + 44);
    while (1)
    {
      v7 = *(float *)(v6 + 4 * v5) - a2;
      *(float *)(v6 + 4 * v5) = v7;
      if (v7 >= 0.0)
      {
        ++v5;
      }
      else
      {
        if (v3 >= v5)
          v8 = v5;
        else
          v8 = v3;
        while (v5 < v3)
        {
          v9 = v3 - 1;
          v10 = *(float *)(v6 - 4 + 4 * v3--);
          if (v10 >= a2)
          {
            v8 = v9 + 1;
            break;
          }
        }
        if (v5 == v8)
        {
          LODWORD(v3) = v5;
          goto LABEL_17;
        }
        v3 = v8 - 1;
        result = __CopyParticle(v2 + 20, v5, v8 - 1);
      }
      if (v5 >= v3)
        goto LABEL_17;
    }
  }
  LODWORD(v3) = 0;
LABEL_17:
  v2[276] = v3;
  return result;
}

_DWORD *C3DParticleSystemInstanceSimulateLifeWithBlock(_DWORD *result, float a2)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  char *v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t EventBlock;
  uint64_t v13;
  unsigned int v14;
  float *v15;
  unsigned int v16;
  CFArrayRef theArray;
  _BYTE v18[256];
  _BYTE v19[264];
  uint64_t v20;

  v2 = result;
  v20 = *MEMORY[0x1E0C80C00];
  v3 = result[276];
  if ((_DWORD)v3)
  {
    v5 = 0;
    v6 = *((_QWORD *)result + 44);
    v7 = (char *)*((_QWORD *)result + 59);
    v8 = v7;
    do
    {
      v9 = *(float *)(v6 + 4 * v5) - a2;
      *(float *)(v6 + 4 * v5) = v9;
      if (v9 < 0.0)
      {
        *(_DWORD *)v8 = v5;
        v8 += 4;
      }
      ++v5;
    }
    while (v3 != v5);
    v10 = v8 - v7;
    v11 = (v8 - v7) >> 2;
    if (v8 != v7)
    {
      theArray = 0;
      EventBlock = C3DParticleSystemGetEventBlock(*((_QWORD *)result + 6), 1u, &theArray);
      memset(v19, 0, 256);
      C3DParticleSystemInstanceFillUserData(*((_QWORD *)v2 + 6), (uint64_t)(v2 + 20), theArray, (uint64_t)v19, (uint64_t)v18, 0);
      result = (_DWORD *)(*(uint64_t (**)(uint64_t, _BYTE *, _BYTE *, char *, uint64_t))(EventBlock + 16))(EventBlock, v19, v18, v7, v11);
    }
    if (v10 >= 1)
    {
      v13 = 0;
      v14 = v3;
      do
      {
        LODWORD(v3) = *(_DWORD *)&v7[4 * v13];
        if (v3 < v14)
        {
          v15 = (float *)(v6 + 4 * (v14 - 1));
          while (*v15 < a2)
          {
            --v11;
            --v14;
            --v15;
            if (v3 >= v14)
              goto LABEL_17;
          }
        }
        if ((_DWORD)v3 != v14)
        {
          v16 = v14 - 1;
          result = __CopyParticle(v2 + 20, *(unsigned int *)&v7[4 * v13], v14 - 1);
          LODWORD(v3) = v16;
        }
LABEL_17:
        ++v13;
        v14 = v3;
      }
      while (v13 < v11);
    }
  }
  v2[276] = v3;
  return result;
}

unint64_t C3DParticleSystemInstanceFillUserData(unint64_t result, uint64_t a2, CFArrayRef theArray, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  unint64_t v12;
  CFIndex i;
  const void *ValueAtIndex;

  if (theArray)
  {
    v11 = result;
    result = CFArrayGetCount(theArray);
    if ((uint64_t)result >= 1)
    {
      v12 = result;
      for (i = 0; i != v12; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
        result = (unint64_t)C3DParticleSystemGetPropertyIndexAndStride(v11, ValueAtIndex);
        *(_QWORD *)(a4 + 8 * i) = *(_QWORD *)(a2 + 8 * result) + HIWORD(result) + WORD2(result) * a6;
        *(_QWORD *)(a5 + 8 * i) = WORD2(result);
      }
    }
  }
  return result;
}

void C3DParticleSystemInstanceSimulateLifeAndSpawnWhenDying(uint64_t a1, float a2)
{
  uint64_t SystemSpawnedOnDying;
  uint64_t v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float v14;

  SystemSpawnedOnDying = C3DParticleSystemGetSystemSpawnedOnDying(*(_QWORD *)(a1 + 48));
  v5 = *(unsigned int *)(a1 + 1104);
  if ((_DWORD)v5)
  {
    v6 = (const void *)SystemSpawnedOnDying;
    v7 = 0;
    v9 = *(_QWORD *)(a1 + 344);
    v8 = *(_QWORD *)(a1 + 352);
    v10 = *(_QWORD *)(a1 + 336);
    while (1)
    {
      v11 = *(float *)(v8 + 4 * v7) - a2;
      *(float *)(v8 + 4 * v7) = v11;
      if (v11 >= 0.0)
      {
        ++v7;
      }
      else
      {
        __SpawnSubSystem(*(_QWORD *)(a1 + 56), v6, *(__n128 *)(v10 + 16 * v7), *(float32x4_t *)(v9 + 16 * v7));
        if (v5 >= v7)
          v12 = v7;
        else
          v12 = v5;
        while (v7 < v5)
        {
          v13 = v5 - 1;
          v14 = *(float *)(v8 - 4 + 4 * v5--);
          if (v14 >= a2)
          {
            v12 = v13 + 1;
            break;
          }
        }
        if (v7 == v12)
        {
          LODWORD(v5) = v7;
          goto LABEL_17;
        }
        v5 = v12 - 1;
        __CopyParticle((_DWORD *)(a1 + 80), v7, v12 - 1);
      }
      if (v7 >= v5)
        goto LABEL_17;
    }
  }
  LODWORD(v5) = 0;
LABEL_17:
  *(_DWORD *)(a1 + 1104) = v5;
}

__n128 C3DParticleSystemInstanceAddEmitter(uint64_t a1, __int128 *a2, float32x4_t *a3)
{
  unsigned int v6;
  unsigned int v7;
  float32x4_t *v8;
  unsigned int v9;
  _OWORD *f32;
  float32x4_t *v11;
  float32x4_t *WorldMatrix;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  _OWORD *v16;
  _OWORD *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 *Identity;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  float32x4_t *v25;
  simd_float4x4 *v26;
  float32x4_t *v27;
  float32x4_t v28;
  __n128 result;
  float32x4_t v30;
  simd_float4x4 v31;

  v6 = *(_DWORD *)(a1 + 24);
  if (v6 == *(_DWORD *)(a1 + 28))
  {
    if (v6)
      v7 = 2 * v6;
    else
      v7 = 1;
    *(_DWORD *)(a1 + 28) = v7;
    v8 = (float32x4_t *)malloc_type_realloc(*(void **)(a1 + 16), 160 * v7, 0x1020040C96D2ADFuLL);
    *(_QWORD *)(a1 + 16) = v8;
    v6 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    v8 = *(float32x4_t **)(a1 + 16);
  }
  *(_DWORD *)(a1 + 24) = v6 + 1;
  v9 = v6;
  f32 = (_OWORD *)v8[10 * v6].f32;
  f32[8] = 0u;
  f32[9] = 0u;
  f32[6] = 0u;
  f32[7] = 0u;
  f32[4] = 0u;
  f32[5] = 0u;
  f32[2] = 0u;
  f32[3] = 0u;
  *f32 = 0u;
  f32[1] = 0u;
  *((_DWORD *)f32 + 4) = 0;
  if (a3)
  {
    v11 = &v8[10 * v9];
    v11[1].i64[1] = (uint64_t)a3;
    WorldMatrix = C3DNodeGetWorldMatrix(a3);
    v13 = WorldMatrix[3];
    v15 = *WorldMatrix;
    v14 = WorldMatrix[1];
    v11[4] = WorldMatrix[2];
    v11[5] = v13;
    v11[2] = v15;
    v11[3] = v14;
  }
  else
  {
    v16 = (_OWORD *)v8[10 * v9].f32;
    v17 = v16 + 2;
    if (a2)
    {
      v18 = *a2;
      v19 = a2[1];
      v20 = a2[3];
      v16[4] = a2[2];
      v16[5] = v20;
      *v17 = v18;
      v16[3] = v19;
    }
    else
    {
      Identity = (__int128 *)C3DMatrix4x4GetIdentity();
      v22 = Identity[3];
      v24 = *Identity;
      v23 = Identity[1];
      v17[2] = Identity[2];
      v17[3] = v22;
      *v17 = v24;
      v17[1] = v23;
    }
  }
  if (*(float32x4_t **)(a1 + 40) != a3)
  {
    if (C3DParticleSystemGetIsLocal(*(_QWORD *)(a1 + 48)))
    {
      v25 = *(float32x4_t **)(a1 + 40);
      if (v25)
      {
        memset(&v31, 0, sizeof(v31));
        v26 = (simd_float4x4 *)C3DNodeGetWorldMatrix(v25);
        C3DMatrix4x4Invert(v26, &v31);
        C3DMatrix4x4Mult((uint64_t)&v31, &v8[10 * v9 + 2], (float32x4_t *)v8[10 * v9 + 2].f32);
      }
    }
  }
  v27 = &v8[10 * v9];
  v28 = v27[3];
  v27[6] = v27[2];
  v27[7] = v28;
  result = (__n128)v27[4];
  v30 = v27[5];
  v27[8] = (float32x4_t)result;
  v27[9] = v30;
  return result;
}

uint64_t C3DParticleSystemInstanceRemoveEmittersWithNode(uint64_t result, uint64_t a2)
{
  unsigned int v2;
  char v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  _OWORD *v10;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  int v19;

  v2 = *(_DWORD *)(result + 24);
  if (v2)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(result + 16);
      if (*(_QWORD *)(v5 + 160 * v4 + 24) != a2)
      {
        v6 = v4 + 1;
        v7 = v6 - 1;
        v8 = (uint64_t *)(v5 + 160 * v6 + 24);
        while (v6 < v2)
        {
          v9 = *v8;
          v8 += 20;
          ++v7;
          LODWORD(v6) = v6 + 1;
          if (v9 == a2)
          {
            v3 = 1;
            v4 = v7;
            goto LABEL_9;
          }
        }
        goto LABEL_13;
      }
      v7 = v4;
LABEL_9:
      *(_DWORD *)(result + 24) = --v2;
      if (v4 < v2)
      {
        v10 = (_OWORD *)(v5 + 160 * v7);
        v11 = (_OWORD *)(v5 + 160 * v2);
        v12 = v11[1];
        *v10 = *v11;
        v10[1] = v12;
        v13 = v11[2];
        v14 = v11[3];
        v15 = v11[5];
        v10[4] = v11[4];
        v10[5] = v15;
        v10[2] = v13;
        v10[3] = v14;
        v16 = v11[6];
        v17 = v11[7];
        v18 = v11[9];
        v10[8] = v11[8];
        v10[9] = v18;
        v10[6] = v16;
        v10[7] = v17;
        v2 = *(_DWORD *)(result + 24);
      }
    }
    while (v4 < v2);
    if ((v3 & 1) == 0)
      goto LABEL_14;
LABEL_13:
    *(_DWORD *)(result + 32) = 0;
  }
  else
  {
LABEL_14:
    if (*(_DWORD *)(result + 1104))
      v19 = 1;
    else
      v19 = 2;
    *(_DWORD *)(result + 32) = v19;
  }
  return result;
}

BOOL C3DColor4IsEqualToColor4WithThreshold(float *a1, float *a2)
{
  return vabds_f32(*a1, *a2) <= 0.001
      && vabds_f32(a1[1], a2[1]) <= 0.001
      && vabds_f32(a1[2], a2[2]) <= 0.001
      && vabds_f32(a1[3], a2[3]) <= 0.001;
}

float C3DColor4Lerp(float *a1, float *a2, float *a3, float a4)
{
  float result;

  *a3 = *a1 + (float)((float)(*a2 - *a1) * a4);
  a3[1] = a1[1] + (float)((float)(a2[1] - a1[1]) * a4);
  a3[2] = a1[2] + (float)((float)(a2[2] - a1[2]) * a4);
  result = a1[3] + (float)((float)(a2[3] - a1[3]) * a4);
  a3[3] = result;
  return result;
}

float C3DColor4Add(float *a1, float *a2, float *a3)
{
  float result;

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  a3[2] = a1[2] + a2[2];
  result = a1[3] + a2[3];
  a3[3] = result;
  return result;
}

BOOL C3DColor4InitWithPropertyList(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  _BOOL8 result;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFErrorRef MalformedDocumentError;

  if (!a1 || !a2)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      C3DColor4InitWithPropertyList_cold_2(v6, v7, v8, v9, v10, v11, v12, v13);
      if (!a4)
        return 0;
    }
    else if (!a4)
    {
      return 0;
    }
    if (!*a4)
    {
      MalformedDocumentError = C3DSceneSourceCreateMalformedDocumentError(0);
      result = 0;
      *a4 = MalformedDocumentError;
      return result;
    }
    return 0;
  }
  if ((C3DInitC3DFloatArrayWithPropertyList(a2, a1, a4) & 1) != 0)
    return 1;
  v14 = scn_default_log();
  result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  if (result)
  {
    C3DColor4InitWithPropertyList_cold_1(v14, v15, v16, v17, v18, v19, v20, v21);
    return 0;
  }
  return result;
}

uint64_t C3DColor4CopyPropertyList(uint64_t result)
{
  if (result)
    return C3DCreatePropertyListFromC3DFloatBuffer(result, 4);
  return result;
}

float C3DColor4Sub(float *a1, float *a2, float *a3)
{
  float result;

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  a3[2] = a1[2] - a2[2];
  result = a1[3] - a2[3];
  a3[3] = result;
  return result;
}

float C3DColor4Distance(float *a1, float *a2)
{
  float v2;
  float v3;
  float v4;

  v2 = a1[1] - a2[1];
  v3 = a1[2] - a2[2];
  v4 = a1[3] - a2[3];
  return sqrtf((float)((float)((float)(v2 * v2) + (float)((float)(*a1 - *a2) * (float)(*a1 - *a2))) + (float)(v3 * v3))+ (float)(v4 * v4));
}

unint64_t C3DColor4RGB2HSB(uint64_t a1, int a2)
{
  float v2;
  float v3;
  float v4;
  uint64_t v5;
  float v6;
  float v7;
  float v8;

  if (*(float *)&a1 <= *((float *)&a1 + 1))
    v2 = *((float *)&a1 + 1);
  else
    v2 = *(float *)&a1;
  if (*(float *)&a1 >= *((float *)&a1 + 1))
    v3 = *((float *)&a1 + 1);
  else
    v3 = *(float *)&a1;
  if (v2 <= *(float *)&a2)
    v2 = *(float *)&a2;
  if (v3 >= *(float *)&a2)
    v3 = *(float *)&a2;
  v4 = v2 - v3;
  if (v2 == 0.0)
    v5 = 0;
  else
    v5 = COERCE_UNSIGNED_INT(v4 / v2);
  if (v4 == 0.0)
  {
    v8 = 0.0;
  }
  else
  {
    v6 = (float)((float)(*(float *)&a1 - *((float *)&a1 + 1)) / v4) + 4.0;
    if (v2 == *((float *)&a1 + 1))
      v6 = (float)((float)(*(float *)&a2 - *(float *)&a1) / v4) + 2.0;
    if (v2 == *(float *)&a1)
      v7 = (float)(*((float *)&a1 + 1) - *(float *)&a2) / v4;
    else
      v7 = v6;
    v8 = v7 * 60.0;
    if (v8 < 0.0)
      v8 = v8 + 360.0;
  }
  return COERCE_UNSIGNED_INT(v8 / 360.0) | (unint64_t)(v5 << 32);
}

unint64_t C3DColor4HSB2RGB(uint64_t a1, int a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v8;
  float v9;
  int v10;
  float v11;
  float v12;
  float v13;
  float v14;

  if (*((float *)&a1 + 1) <= 1.0)
    v2 = *((float *)&a1 + 1);
  else
    v2 = 1.0;
  v3 = 0.0;
  if (*((float *)&a1 + 1) < 0.0)
    v2 = 0.0;
  if (*(float *)&a2 <= 1.0)
    v4 = *(float *)&a2;
  else
    v4 = 1.0;
  if (*(float *)&a2 < 0.0)
    v4 = 0.0;
  if (v2 == 0.0)
  {
    v5 = v4;
    v6 = v4;
  }
  else
  {
    v8 = *(float *)&a1 * 360.0;
    if (*(float *)&a1 > 1.0)
      v8 = 360.0;
    if (*(float *)&a1 >= 0.0)
      v9 = v8;
    else
      v9 = 0.0;
    if (v9 != 360.0)
      v3 = v9 / 60.0;
    v10 = (int)v3;
    v11 = v3 - (float)(int)v3;
    v12 = v4 * (float)(1.0 - v2);
    v13 = v4 * (float)(1.0 - (float)(v2 * v11));
    v14 = v4 * (float)(1.0 - (float)(v2 * (float)(1.0 - v11)));
    v5 = v4;
    v6 = v14;
    switch(v10)
    {
      case 0:
        return LODWORD(v5) | ((unint64_t)LODWORD(v6) << 32);
      case 1:
        v5 = v13;
        v6 = v4;
        break;
      case 2:
        v5 = v12;
        v6 = v4;
        break;
      case 3:
        v5 = v12;
        v6 = v13;
        break;
      case 4:
        v5 = v14;
        v6 = v12;
        break;
      default:
        v5 = v4;
        v6 = v12;
        break;
    }
  }
  return LODWORD(v5) | ((unint64_t)LODWORD(v6) << 32);
}

uint64_t C3DGetColorTransformToGlobalColorSpace()
{
  int IsEnabled;
  int IsUsed;
  uint64_t *v2;

  IsEnabled = C3DLinearRenderingIsEnabled();
  IsUsed = C3DWideGamutIsUsed();
  if (IsEnabled)
  {
    if (IsUsed)
    {
      if (C3DGetColorTransformToExtendedLinearSRGB_onceToken != -1)
        dispatch_once(&C3DGetColorTransformToExtendedLinearSRGB_onceToken, &__block_literal_global_28);
      v2 = &C3DGetColorTransformToExtendedLinearSRGB_colorTransform;
    }
    else
    {
      if (C3DGetColorTransformToLinearSRGB_onceToken != -1)
        dispatch_once(&C3DGetColorTransformToLinearSRGB_onceToken, &__block_literal_global_30);
      v2 = &C3DGetColorTransformToLinearSRGB_colorTransform;
    }
  }
  else if (IsUsed)
  {
    if (C3DGetColorTransformToExtendedSRGB_onceToken != -1)
      dispatch_once(&C3DGetColorTransformToExtendedSRGB_onceToken, &__block_literal_global_32);
    v2 = &C3DGetColorTransformToExtendedSRGB_colorTransform;
  }
  else
  {
    if (C3DGetColorTransformToSRGB_onceToken != -1)
      dispatch_once(&C3DGetColorTransformToSRGB_onceToken, &__block_literal_global_34);
    v2 = &C3DGetColorTransformToSRGB_colorTransform;
  }
  return *v2;
}

__n128 _C3DCGColorGetComponentsInColorSpace(CGColorRef color, CGColorSpace *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  CGColor *v7;
  CGColor *v8;
  size_t NumberOfComponents;
  float64x2_t *Components;
  __int32 v11;
  int8x16_t v12;
  __int128 v13;
  float v14;
  float v15;
  __int128 v17;

  if (!color)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      _C3DCGColorGetComponentsInColorSpace_cold_1(v4, v5, v6);
  }
  if (CGColorGetColorSpace(color) == a2)
    v7 = CGColorRetain(color);
  else
    v7 = (CGColor *)CGColorTransformConvertColor();
  v8 = v7;
  NumberOfComponents = CGColorGetNumberOfComponents(v7);
  Components = (float64x2_t *)CGColorGetComponents(v8);
  if (NumberOfComponents >= 4)
  {
    *(float *)&v11 = Components[1].f64[1];
    v12.i64[0] = 0;
    v12.i32[2] = 0;
    v12.i32[3] = v11;
LABEL_9:
    *(float32x2_t *)&v13 = vcvt_f32_f64(*Components);
    *((_QWORD *)&v13 + 1) = vextq_s8(v12, v12, 8uLL).u64[0];
    v14 = Components[1].f64[0];
LABEL_16:
    *((float *)&v13 + 2) = v14;
    goto LABEL_17;
  }
  if (NumberOfComponents == 2)
  {
    v15 = Components->f64[1];
    *((float *)&v13 + 3) = v15;
    goto LABEL_15;
  }
  if (NumberOfComponents >= 3)
  {
    v12 = (int8x16_t)xmmword_1DD007610;
    goto LABEL_9;
  }
  v13 = xmmword_1DD007610;
  if (NumberOfComponents)
  {
LABEL_15:
    v14 = Components->f64[0];
    *(float *)&v13 = v14;
    *((float *)&v13 + 1) = v14;
    goto LABEL_16;
  }
LABEL_17:
  v17 = v13;
  CGColorRelease(v8);
  return (__n128)v17;
}

double C3DCGColorGetLinearExtendedSRGBComponents(CGColorRef color)
{
  CGColorSpace *v2;
  double result;

  if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1)
    dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_11);
  v2 = (CGColorSpace *)C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB;
  if (C3DGetColorTransformToExtendedLinearSRGB_onceToken != -1)
    dispatch_once(&C3DGetColorTransformToExtendedLinearSRGB_onceToken, &__block_literal_global_28);
  *(_QWORD *)&result = _C3DCGColorGetComponentsInColorSpace(color, v2).n128_u64[0];
  return result;
}

double C3DCGColorGetITUR_709Components(CGColorRef color)
{
  CGColorSpace *v2;
  double result;

  if (C3DColorSpaceITUR_709_onceToken != -1)
    dispatch_once(&C3DColorSpaceITUR_709_onceToken, &__block_literal_global_17);
  v2 = (CGColorSpace *)C3DColorSpaceITUR_709_kC3DColorSpaceITUR_709;
  if (C3DGetColorTransformToITUR_709_onceToken != -1)
    dispatch_once(&C3DGetColorTransformToITUR_709_onceToken, &__block_literal_global_40);
  *(_QWORD *)&result = _C3DCGColorGetComponentsInColorSpace(color, v2).n128_u64[0];
  return result;
}

uint64_t C3DColorSpaceExtendedSRGB()
{
  if (C3DColorSpaceExtendedSRGB_onceToken != -1)
    dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_9);
  return C3DColorSpaceExtendedSRGB_kC3DColorSpaceExtendedSRGB;
}

CGColorRef C3DCGColorCreateExtendedLinearSRGBWithComponents(float32x4_t a1)
{
  _OWORD v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v2[0] = vcvtq_f64_f32(*(float32x2_t *)a1.f32);
  v2[1] = vcvt_hight_f64_f32(a1);
  if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1)
    dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_11);
  return CGColorCreate((CGColorSpaceRef)C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB, (const CGFloat *)v2);
}

float64_t C3DColor4ConvertToLinear(float32x4_t *a1)
{
  float64_t result;
  float64x2_t v3;

  v3.f64[0] = 0.0;
  v3.f64[1] = a1->f32[3];
  if (C3DWideGamutIsUsed())
  {
    if (C3DGetColorTransformToExtendedLinearSRGB_onceToken != -1)
      dispatch_once(&C3DGetColorTransformToExtendedLinearSRGB_onceToken, &__block_literal_global_28);
    if (C3DColorSpaceExtendedSRGB_onceToken != -1)
      dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_9);
  }
  else
  {
    if (C3DGetColorTransformToLinearSRGB_onceToken != -1)
      dispatch_once(&C3DGetColorTransformToLinearSRGB_onceToken, &__block_literal_global_30);
    if (C3DColorSpaceSRGB_onceToken != -1)
      dispatch_once(&C3DColorSpaceSRGB_onceToken, &__block_literal_global_4);
  }
  CGColorTransformConvertColorComponents();
  result = v3.f64[0];
  *a1 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)0), v3);
  return result;
}

uint64_t C3DColorSpaceGray()
{
  if (C3DColorSpaceGray_onceToken != -1)
    dispatch_once(&C3DColorSpaceGray_onceToken, &__block_literal_global_5);
  return C3DColorSpaceGray_kC3DColorSpaceGray;
}

uint64_t C3DGetGlobalColorSpace()
{
  int IsEnabled;
  int IsUsed;
  uint64_t *v2;

  IsEnabled = C3DLinearRenderingIsEnabled();
  IsUsed = C3DWideGamutIsUsed();
  if (IsEnabled)
  {
    if (IsUsed)
    {
      if (C3DColorSpaceExtendedLinearSRGB_onceToken != -1)
        dispatch_once(&C3DColorSpaceExtendedLinearSRGB_onceToken, &__block_literal_global_11);
      v2 = &C3DColorSpaceExtendedLinearSRGB_kC3DColorSpaceExtendedLinearSRGB;
    }
    else
    {
      if (C3DColorSpaceLinearSRGB_onceToken != -1)
        dispatch_once(&C3DColorSpaceLinearSRGB_onceToken, &__block_literal_global_3);
      v2 = &C3DColorSpaceLinearSRGB_kC3DColorSpaceLinearSRGB;
    }
  }
  else if (IsUsed)
  {
    if (C3DColorSpaceExtendedSRGB_onceToken != -1)
      dispatch_once(&C3DColorSpaceExtendedSRGB_onceToken, &__block_literal_global_9);
    v2 = &C3DColorSpaceExtendedSRGB_kC3DColorSpaceExtendedSRGB;
  }
  else
  {
    if (C3DColorSpaceSRGB_onceToken != -1)
      dispatch_once(&C3DColorSpaceSRGB_onceToken, &__block_literal_global_4);
    v2 = &C3DColorSpaceSRGB_kC3DColorSpaceSRGB;
  }
  return *v2;
}

void C3DGetColorMatchingComputeKernelParameters(CGColorSpaceRef a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  CGColorConversionInfoRef v4;
  CGColorConversionInfoRef v5;
  NSObject *v6;
  uint64_t *v7;
  NSObject *v8;
  uint64_t *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  v25 = &v24;
  v26 = 0xA000000000;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v20 = 0;
  v21 = &v20;
  v22 = 0x2000000000;
  v23 = -1;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = -1;
  v4 = CGColorConversionInfoCreateFromList(0, a1, kCGColorConversionTransformFromSpace, kCGRenderingIntentDefault, a2, 1, 0, 0);
  if (v4)
  {
    v5 = v4;
    if ((CGColorConversionInfoIterateFunctionsWithCallbacks() & 1) == 0)
    {
      v6 = scn_default_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        C3DGetColorMatchingComputeKernelParameters_cold_4();
      v7 = v25;
      *((_WORD *)v25 + 16) = 0;
      *((_BYTE *)v7 + 34) = 0;
    }
    CFRelease(v5);
  }
  else
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      C3DGetColorMatchingComputeKernelParameters_cold_3();
  }
  if (!*((_BYTE *)v25 + 33))
  {
    if (*((_BYTE *)v25 + 34))
    {
      if (*((_BYTE *)v25 + 32))
        goto LABEL_10;
      if (*((_DWORD *)v17 + 6) != 4)
        goto LABEL_10;
      v14 = scn_default_log();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        goto LABEL_10;
    }
    else
    {
      if (!*((_BYTE *)v25 + 32))
        goto LABEL_10;
      if (*((_DWORD *)v21 + 6) != 1)
        goto LABEL_10;
      v15 = scn_default_log();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        goto LABEL_10;
    }
    C3DGetColorMatchingComputeKernelParameters_cold_1();
  }
LABEL_10:
  v9 = v25;
  v10 = *((_OWORD *)v25 + 7);
  a3[4] = *((_OWORD *)v25 + 6);
  a3[5] = v10;
  v11 = *((_OWORD *)v9 + 9);
  a3[6] = *((_OWORD *)v9 + 8);
  a3[7] = v11;
  v12 = *((_OWORD *)v9 + 3);
  *a3 = *((_OWORD *)v9 + 2);
  a3[1] = v12;
  v13 = *((_OWORD *)v9 + 5);
  a3[2] = *((_OWORD *)v9 + 4);
  a3[3] = v13;
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
}

void OUTLINED_FUNCTION_0_1(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void OUTLINED_FUNCTION_6(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

C3D::RenderPass *C3D::DownsamplePass::DownsamplePass(C3D::DownsamplePass *this, C3D::RenderGraph *a2, C3D::Pass *a3)
{
  C3D::RenderPass *result;

  result = C3D::RenderPass::RenderPass(this, a2, a3);
  *(_QWORD *)result = off_1EA599058;
  return result;
}

const char *C3D::DownsamplePass::name(C3D::DownsamplePass *this)
{
  return "DownsamplePass";
}

double C3D::DownsamplePass::setup(C3D::DownsamplePass *this)
{
  float SuperSamplingFactor;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double result;
  __int128 v7;
  int v8;

  SuperSamplingFactor = C3DEngineContextGetSuperSamplingFactor(*((_QWORD *)this + 2));
  C3D::Pass::setInputCount(this, 1u);
  v3 = (*(uint64_t (**)(C3D::DownsamplePass *))(*(_QWORD *)this + 88))(this);
  v4 = C3D::PassDescriptor::inputAtIndex((C3D::DownsamplePass *)((char *)this + 32), 0);
  *(_QWORD *)(v4 + 8) = "COLOR";
  C3D::Pass::parentColorDesc(this, (uint64_t)&v7);
  *(_OWORD *)(v4 + 16) = v7;
  *(_DWORD *)(v4 + 32) = v8;
  *(_WORD *)(v4 + 16) = vcvtms_s32_f32(SuperSamplingFactor * *(float *)(v3 + 8));
  *(_WORD *)(v4 + 18) = vcvtms_s32_f32(SuperSamplingFactor * *(float *)(v3 + 12));
  C3D::Pass::setOutputCount(this, 1u);
  v5 = C3D::PassDescriptor::outputAtIndex((C3D::DownsamplePass *)((char *)this + 32), 0);
  *(_QWORD *)(v5 + 8) = "COLOR";
  *(_BYTE *)(v5 + 65) = 0;
  C3D::Pass::parentColorDesc(this, (uint64_t)&v7);
  result = *(double *)&v7;
  *(_OWORD *)(v5 + 16) = v7;
  *(_DWORD *)(v5 + 32) = v8;
  return result;
}

void C3D::DownsamplePass::compile(C3D::DownsamplePass *this)
{
  uint64_t RenderContext;
  void *v3;
  uint64_t v4;
  C3D::RenderGraphResourceManager *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;

  RenderContext = C3DEngineContextGetRenderContext(*((_QWORD *)this + 2));
  v3 = (void *)-[SCNMTLRenderContext resourceManager](RenderContext);
  v4 = (*(uint64_t (**)(C3D::DownsamplePass *))(*(_QWORD *)this + 88))(this);
  v5 = *(C3D::RenderGraphResourceManager **)(*((_QWORD *)this + 3) + 128);
  v6 = *(_QWORD *)(v4 + 24);
  v7 = 0xC6A4A7935BD1E995
     * ((*(uint64_t (**)(C3D::DownsamplePass *))(*(_QWORD *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))));
  v8 = (0xC6A4A7935BD1E995 * (v7 ^ (v7 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v7 ^ (v7 >> 47))) >> 47);
  v9 = C3D::RenderGraphResourceManager::get(v5, v8);
  *((_QWORD *)this + 30) = v9;
  if (!v9)
  {
    v10 = (_QWORD *)operator new();
    v10[1] = 0;
    v10[2] = 0;
    *v10 = &off_1EA59A1C8;
    *((_QWORD *)this + 30) = v10;
    C3D::RenderGraphResourceManager::set((uint64_t)v5, v8, (uint64_t)v10);
    v11 = *((_QWORD *)this + 30);
    v12 = objc_msgSend((id)-[SCNMTLResourceManager libraryManager]((uint64_t)v3), "frameworkLibrary", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0);
    v13 = *(_QWORD *)(v4 + 24);
    *((_QWORD *)&v18 + 1) = v12;
    *(_QWORD *)&v19 = v13;
    *((_QWORD *)&v20 + 1) = CFSTR("scn_supersampling_vertex");
    *(_QWORD *)&v21 = CFSTR("scn_supersampling_fragment");
    v14 = objc_msgSend(v3, "newRenderPipelineStateWithDesc:", &v17);
    v15 = *(void **)(v11 + 16);
    if (v15 != (void *)v14)
    {
      v16 = v14;
      if (v15)

      *(_QWORD *)(v11 + 16) = v16;
    }
  }
}

uint64_t C3D::DownsamplePass::execute(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3;
  _OWORD *RenderContext;
  uint64_t v5;
  void **v6;
  _OWORD v8[4];
  _OWORD v9[4];
  float SuperSamplingFactor;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  RenderContext = (_OWORD *)C3DEngineContextGetRenderContext(a1[2]);
  -[SCNMTLRenderContext screenTransform](RenderContext, v8);
  v9[0] = v8[0];
  v9[1] = v8[1];
  v9[2] = v8[2];
  v9[3] = v8[3];
  SuperSamplingFactor = C3DEngineContextGetSuperSamplingFactor(a1[2]);
  v5 = objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(a1[30] + 16), "state");
  if (*(_QWORD *)(v3 + 3376) != v5)
  {
    *(_QWORD *)(v3 + 3376) = v5;
    objc_msgSend(*(id *)(v3 + 3392), "setRenderPipelineState:", v5);
  }
  v6 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
  SCNMTLRenderCommandEncoder::setFragmentTexture(v3, v6, 0);
  SCNMTLRenderCommandEncoder::setVertexBytes((SCNMTLRenderCommandEncoder *)v3, v9, 0x50uLL, 0);
  SCNMTLRenderCommandEncoder::setFragmentBytes((SCNMTLRenderCommandEncoder *)v3, v9, 0x50uLL, 0);
  return SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v3);
}

uint64_t SCNMTLRenderCommandEncoder::setVertexBytes(SCNMTLRenderCommandEncoder *this, const void *a2, size_t a3, uint64_t a4)
{
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v7 = 0;
  v8 = 0;
  v9 = 0;
  SCNMTLBufferPool::allocateAndCopy((SCNMTLBufferPool *)this->var25[0], a2, a3, &v7);
  return SCNMTLRenderCommandEncoder::setVertexBuffer((uint64_t)this, v8, v9, a4);
}

uint64_t SCNMTLRenderCommandEncoder::setFragmentBytes(SCNMTLRenderCommandEncoder *this, const void *a2, size_t a3, uint64_t a4)
{
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v7 = 0;
  v8 = 0;
  v9 = 0;
  SCNMTLBufferPool::allocateAndCopy((SCNMTLBufferPool *)this->var25[0], a2, a3, &v7);
  return SCNMTLRenderCommandEncoder::setFragmentBuffer((uint64_t)this, v8, v9, a4);
}

void C3D::DownsamplePassResource::~DownsamplePassResource(C3D::DownsamplePassResource *this)
{
  void *v1;

  *(_QWORD *)this = &off_1EA59A1C8;
  v1 = (void *)*((_QWORD *)this + 2);
  if (v1)

}

{
  void *v1;

  *(_QWORD *)this = &off_1EA59A1C8;
  v1 = (void *)*((_QWORD *)this + 2);
  if (v1)

  JUMPOUT(0x1DF0D41C0);
}

void C3DNotifyGeometryDidChange(uint64_t a1)
{
  const __CFSet *v1;

  v1 = *(const __CFSet **)(a1 + 88);
  if (v1)
    CFSetApplyFunction(v1, (CFSetApplierFunction)__C3DNodeGeometryDidChange, 0);
}

id _C3DGeometryCFFinalize(__C3DGeometry *a1)
{
  uint64_t SharedInstance;
  const __CFSet *var4;
  NSObject *v4;
  __CFSet *v5;
  __CFArray *var3;
  __C3DMaterial *var2;
  __C3DMesh *var1;
  __CFArray *var5;
  $8EF4127CF77ECA3DDB612FCF233DC3A8 *var6;

  SharedInstance = C3DNotificationCenterGetSharedInstance();
  C3DNotificationCenterPostNotification(SharedInstance, CFSTR("kC3DNotificationGeometryWillDie"), a1, 0, 1u);
  C3DGeometryFinalizeSubdivision(a1);
  var4 = a1->var4;
  if (var4)
  {
    if (CFSetGetCount(var4))
    {
      v4 = scn_default_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
        _C3DGeometryCFFinalize_cold_1((uint64_t)a1, v4);
    }
    v5 = a1->var4;
    if (v5)
    {
      CFRelease(v5);
      a1->var4 = 0;
    }
  }
  var3 = a1->var3;
  if (var3)
  {
    CFRelease(var3);
    a1->var3 = 0;
  }
  var2 = a1->var2;
  if (var2)
  {
    CFRelease(var2);
    a1->var2 = 0;
  }
  var1 = a1->var1;
  if (var1)
  {
    CFRelease(var1);
    a1->var1 = 0;
  }
  var5 = a1->var5;
  if (var5)
  {
    CFRelease(var5);
    a1->var5 = 0;
  }
  var6 = a1->var6;
  if (var6)
    free(var6);
  a1->var6 = 0;
  return C3DEntityCFFinalize((uint64_t)a1);
}

__CFString *_C3DGeometryCFCopyDebugDescription(const void *a1)
{
  CFTypeID v2;
  CFStringRef v3;
  __CFString *Mutable;
  uint64_t Name;
  uint64_t Mesh;
  uint64_t v7;
  const __CFArray *MaterialAtIndex;

  v2 = CFGetTypeID(a1);
  v3 = CFCopyTypeIDDescription(v2);
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  Name = C3DGeometryGetName((uint64_t)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<%@:%p \"%@\"\n"), v3, a1, Name);
  Mesh = C3DGeometryGetMesh((uint64_t)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("  mesh: %@\n"), Mesh);
  if ((uint64_t)C3DGeometryGetMaterialsCount((uint64_t)a1) >= 1)
  {
    v7 = 0;
    do
    {
      MaterialAtIndex = C3DGeometryGetMaterialAtIndex((uint64_t)a1, v7);
      CFStringAppendFormat(Mutable, 0, CFSTR("  mat%d: %@\n"), v7++, MaterialAtIndex);
    }
    while (v7 < (uint64_t)C3DGeometryGetMaterialsCount((uint64_t)a1));
  }
  CFStringAppend(Mutable, CFSTR(">"));
  CFRelease(v3);
  return Mutable;
}

_QWORD *_C3DGeometryFillLibraryForSerialization(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFArray *MaterialsCount;
  const __CFArray *v15;
  uint64_t i;
  const __CFArray *MaterialAtIndex;
  _QWORD *result;
  const void *v19;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  MaterialsCount = C3DGeometryGetMaterialsCount(a1);
  if ((uint64_t)MaterialsCount >= 1)
  {
    v15 = MaterialsCount;
    for (i = 0; (const __CFArray *)i != v15; ++i)
    {
      MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1, i);
      C3DLibraryAddEntry(a2, MaterialAtIndex);
      C3DFillLibraryForSerialization(MaterialAtIndex, a2, a3);
    }
  }
  result = (_QWORD *)C3DGeometryGetMesh(a1);
  if (result)
  {
    v19 = result;
    C3DLibraryAddEntry(a2, result);
    return C3DFillLibraryForSerialization(v19, a2, a3);
  }
  return result;
}

uint64_t _C3DGeometryFinalizeDeserialization(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, CFErrorRef *a4)
{
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const __CFNumber *Value;
  uint64_t v25;
  uint64_t TypeID;
  void *v27;
  uint64_t *Entry;
  const __CFArray *v29;
  const __CFArray *v30;
  const __CFArray *v31;
  CFIndex Count;
  CFIndex v33;
  CFIndex v34;
  const __CFString *ValueAtIndex;
  SInt32 IntValue;
  uint64_t v37;
  uint64_t v38;
  const void *RemappedID;
  void *v40;
  _QWORD *v41;
  void *v42;
  const __CFDictionary *v43;
  uint64_t CommonProfile;
  uint64_t v45;
  const __CFArray *v46;
  uint64_t v47;
  unint64_t v48;
  BOOL v49;
  uint64_t UVSet;
  uint64_t v51;
  void *Copy;
  NSObject *v54;
  uint64_t result;
  NSObject *v56;
  NSObject *v57;
  NSObject *v58;
  CFErrorRef MalformedDocumentError;
  CFErrorRef *v60;
  CFIndex v61;
  const __CFArray *v62;
  const void *valuePtr;
  uint8_t buf[16];
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  uint64_t v74;
  uint64_t v75;

  v7 = a1;
  v75 = *MEMORY[0x1E0C80C00];
  if (!a1 && (v8 = scn_default_log(), os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    if (theDict)
      goto LABEL_6;
  }
  else if (theDict)
  {
    goto LABEL_6;
  }
  v16 = scn_default_log();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
    _C3DGeometryFinalizeDeserialization_cold_4(v16, v17, v18, v19, v20, v21, v22, v23);
LABEL_6:
  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("geometryID"));
  if (!Value)
    goto LABEL_10;
  if (!CFNumberGetValue(Value, kCFNumberLongType, &valuePtr))
  {
    v56 = scn_default_log();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      _C3DGeometryFinalizeDeserialization_cold_2();
    goto LABEL_41;
  }
  v25 = (uint64_t)valuePtr;
  TypeID = C3DMeshGetTypeID();
  valuePtr = (const void *)C3DLibraryGetRemappedID(a2, v25, TypeID);
  v27 = (void *)C3DMeshGetTypeID();
  Entry = C3DLibraryGetEntry(a2, v27, valuePtr);
  if (!Entry)
  {
    v57 = scn_default_log();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      _C3DGeometryFinalizeDeserialization_cold_3();
LABEL_41:
    if (!a4 || *a4)
      return 0;
    MalformedDocumentError = C3DSceneSourceCreateMalformedDocumentError(0);
    result = 0;
    *a4 = MalformedDocumentError;
    return result;
  }
  C3DGeometrySetMesh(v7, Entry);
LABEL_10:
  v29 = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("bindInfos"));
  v30 = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("materialsID"));
  if (v30)
  {
    v31 = v30;
    Count = CFArrayGetCount(v30);
    if (Count >= 1)
    {
      v33 = Count;
      v60 = a4;
      v34 = 0;
      v62 = v31;
      v61 = Count;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v31, v34);
        IntValue = CFStringGetIntValue(ValueAtIndex);
        if (!IntValue)
        {
          v54 = scn_default_log();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1DCCB8000, v54, OS_LOG_TYPE_DEFAULT, "Warning: _C3DGeometryFinalizeDeserialization - material ID of 0 is unexpected", buf, 2u);
          }
          goto LABEL_32;
        }
        v37 = IntValue;
        v38 = C3DMaterialGetTypeID();
        RemappedID = (const void *)C3DLibraryGetRemappedID(a2, v37, v38);
        v40 = (void *)C3DMaterialGetTypeID();
        v41 = C3DLibraryGetEntry(a2, v40, RemappedID);
        if (!v41)
        {
          v58 = scn_default_log();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
            _C3DGeometryFinalizeDeserialization_cold_1();
          a4 = v60;
          goto LABEL_41;
        }
        v42 = v41;
        if (v29)
        {
          v43 = (const __CFDictionary *)CFArrayGetValueAtIndex(v29, v34);
          v70 = xmmword_1DD007790;
          v71 = unk_1DD0077A0;
          v72 = xmmword_1DD0077B0;
          v73 = unk_1DD0077C0;
          v66 = xmmword_1DD007750;
          v67 = unk_1DD007760;
          v68 = xmmword_1DD007770;
          v69 = unk_1DD007780;
          *(_OWORD *)buf = xmmword_1DD007730;
          v65 = unk_1DD007740;
          v74 = 0;
          _loadBindInfos(v43, CFSTR("emissionUVSet"), 0, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("ambientUVSet"), 1, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("diffuseUVSet"), 2, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("specularUVSet"), 3, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("reflectiveUVSet"), 4, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("transparentUVSet"), 5, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("filterUVSet"), 6, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("normalUVSet"), 7, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("ambientOcclusionUVSet"), 8, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("selfIlluminationUVSet"), 9, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("metalness"), 10, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("roughness"), 11, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("displacement"), 15, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("clearCoat"), 12, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("clearCoat"), 13, (uint64_t)buf);
          _loadBindInfos(v43, CFSTR("clearCoat"), 14, (uint64_t)buf);
          CommonProfile = C3DMaterialGetCommonProfile((uint64_t)v42);
          if (CommonProfile)
          {
            v45 = CommonProfile;
            v46 = v29;
            v47 = v7;
            v48 = 0;
            v49 = 1;
            do
            {
              UVSet = C3DEffectCommonProfileGetUVSet(v45, (char)v48);
              if (C3DEffectCommonProfileUVSetIsSet(v45, (char)v48))
              {
                v51 = *(_QWORD *)&buf[8 * v48];
                if (v51 != -1 && UVSet != v51)
                  break;
              }
              v49 = v48++ < 0xF;
            }
            while (v48 != 16);
            v7 = v47;
            v29 = v46;
            v33 = v61;
            v31 = v62;
            if (v49)
            {
              Copy = (void *)C3DMaterialCreateCopy((uint64_t)v42);
              _updateUVSet((uint64_t)Copy, (uint64_t)buf);
              C3DGeometryAppendMaterial(v7, Copy);
              if (Copy)
                CFRelease(Copy);
              goto LABEL_32;
            }
          }
          _updateUVSet((uint64_t)v42, (uint64_t)buf);
        }
        C3DGeometryAppendMaterial(v7, v42);
LABEL_32:
        ++v34;
      }
      while (v34 != v33);
    }
  }
  return 1;
}

void _loadBindInfos(const __CFDictionary *a1, const void *a2, int a3, uint64_t a4)
{
  const __CFNumber *Value;
  NSObject *v9;
  uint64_t valuePtr;

  Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    valuePtr = 0;
    if (!CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr))
    {
      v9 = scn_default_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        _loadBindInfos_cold_1((uint64_t)a2, (uint64_t)a1, v9);
    }
    *(_QWORD *)(a4 + 8 * a3) = valuePtr;
  }
}

void _updateUVSet(uint64_t a1, uint64_t a2)
{
  uint64_t CommonProfile;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;

  CommonProfile = C3DMaterialGetCommonProfile(a1);
  if (CommonProfile)
  {
    v4 = CommonProfile;
    for (i = 0; i != 16; ++i)
    {
      v6 = *(_QWORD *)(a2 + 8 * i);
      if (v6 != -1)
        C3DEffectCommonProfileSetUVSet(v4, (char)i, v6);
    }
  }
}

__CFDictionary *_C3DGeometryCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __CFDictionary *v14;
  const __CFAllocator *v15;
  CFNumberRef v16;
  const __CFAllocator *v17;
  __CFArray *Mutable;
  const __CFArray *MaterialsCount;
  const __CFArray *v20;
  uint64_t i;
  const __CFArray *MaterialAtIndex;
  CFDictionaryRef *EntryID;
  const __CFAllocator *v24;
  CFStringRef v25;
  CFDictionaryRef *valuePtr;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  v14 = C3DEntityCopyPropertyList((_QWORD *)a1, a2, a3);
  if (v14)
  {
    valuePtr = C3DLibraryGetEntryID(a2, *(CFTypeRef *)(a1 + 64));
    v15 = CFGetAllocator((CFTypeRef)a1);
    v16 = CFNumberCreate(v15, kCFNumberLongType, &valuePtr);
    CFDictionarySetValue(v14, CFSTR("geometryID"), v16);
    CFRelease(v16);
    v17 = CFGetAllocator((CFTypeRef)a1);
    Mutable = CFArrayCreateMutable(v17, 0, MEMORY[0x1E0C9B378]);
    MaterialsCount = C3DGeometryGetMaterialsCount(a1);
    if ((uint64_t)MaterialsCount >= 1)
    {
      v20 = MaterialsCount;
      for (i = 0; (const __CFArray *)i != v20; ++i)
      {
        MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1, i);
        EntryID = C3DLibraryGetEntryID(a2, MaterialAtIndex);
        v24 = CFGetAllocator((CFTypeRef)a1);
        v25 = CFStringCreateWithFormat(v24, 0, CFSTR("%ld"), EntryID, valuePtr);
        CFArrayAppendValue(Mutable, v25);
        CFRelease(v25);
      }
    }
    CFDictionarySetValue(v14, CFSTR("materialsID"), Mutable);
    CFRelease(Mutable);
  }
  return v14;
}

void C3DGeometrySetBoundingBox(uint64_t a1, _OWORD *a2)
{
  _OWORD *v3;
  __int128 v5;
  const __CFSet *v6;

  v3 = *(_OWORD **)(a1 + 104);
  if (a2)
  {
    if (!v3)
    {
      v3 = malloc_type_malloc(0x20uLL, 0x1000040E0EAB150uLL);
      *(_QWORD *)(a1 + 104) = v3;
    }
    v5 = a2[1];
    *v3 = *a2;
    v3[1] = v5;
  }
  else
  {
    if (!v3)
      return;
    free(v3);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v6 = *(const __CFSet **)(a1 + 88);
  if (v6)
    CFSetApplyFunction(v6, (CFSetApplierFunction)__C3DNodeGeometryDidChange, 0);
}

__CFArray *_C3DGeometryCopyInstanceVariables(uint64_t a1)
{
  __CFArray *Mutable;
  const CFDictionaryKeyCallBacks *v3;
  const CFDictionaryValueCallBacks *v4;
  __CFDictionary *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  __CFDictionary *v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  __CFDictionary *v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  __CFDictionary *v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFNumberRef v20;
  __CFDictionary *v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  __CFDictionary *v25;
  CFNumberRef v26;
  CFNumberRef v27;
  CFNumberRef v28;
  uint64_t Name;
  int v31;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v31 = 1;
  valuePtr = 5;
  Name = C3DGeometryGetName(a1);
  v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  v8 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v5, CFSTR("name"), CFSTR("name"));
  CFDictionarySetValue(v5, CFSTR("type"), v6);
  CFDictionarySetValue(v5, CFSTR("address"), v8);
  CFDictionarySetValue(v5, CFSTR("semantic"), v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v31 = 2;
  valuePtr = 5;
  Name = a1 + 64;
  v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  v12 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v9, CFSTR("name"), CFSTR("mesh"));
  CFDictionarySetValue(v9, CFSTR("type"), v10);
  CFDictionarySetValue(v9, CFSTR("address"), v12);
  CFDictionarySetValue(v9, CFSTR("semantic"), v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  v13 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v31 = 2;
  valuePtr = 5;
  Name = a1 + 72;
  v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  v16 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v13, CFSTR("name"), CFSTR("overrideMaterial"));
  CFDictionarySetValue(v13, CFSTR("type"), v14);
  CFDictionarySetValue(v13, CFSTR("address"), v16);
  CFDictionarySetValue(v13, CFSTR("semantic"), v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v31 = 2;
  valuePtr = 5;
  Name = a1 + 80;
  v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  v20 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v17, CFSTR("name"), CFSTR("materials"));
  CFDictionarySetValue(v17, CFSTR("type"), v18);
  CFDictionarySetValue(v17, CFSTR("address"), v20);
  CFDictionarySetValue(v17, CFSTR("semantic"), v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  v21 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v31 = 2;
  valuePtr = 5;
  Name = a1 + 96;
  v22 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  v24 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v21, CFSTR("name"), CFSTR("levelsOfDetail"));
  CFDictionarySetValue(v21, CFSTR("type"), v22);
  CFDictionarySetValue(v21, CFSTR("address"), v24);
  CFDictionarySetValue(v21, CFSTR("semantic"), v23);
  CFArrayAppendValue(Mutable, v21);
  CFRelease(v23);
  CFRelease(v21);
  CFRelease(v24);
  CFRelease(v22);
  v25 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v31 = 0;
  valuePtr = 5;
  Name = a1 + 48;
  v26 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v27 = CFNumberCreate(0, kCFNumberSInt32Type, &v31);
  v28 = CFNumberCreate(0, kCFNumberLongType, &Name);
  CFDictionarySetValue(v25, CFSTR("name"), CFSTR("sceneRef"));
  CFDictionarySetValue(v25, CFSTR("type"), v26);
  CFDictionarySetValue(v25, CFSTR("address"), v28);
  CFDictionarySetValue(v25, CFSTR("semantic"), v27);
  CFArrayAppendValue(Mutable, v25);
  CFRelease(v27);
  CFRelease(v25);
  CFRelease(v28);
  CFRelease(v26);
  return Mutable;
}

double C3DGeometryInit(uint64_t a1)
{
  *(_QWORD *)(a1 + 80) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return C3DGeometryInitSubdivision(a1);
}

uint64_t C3DGeometryCreateInterleavedCopy(CFTypeRef cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Copy;
  uint64_t Mesh;
  uint64_t *CopyWithInterleavedSources;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  Copy = C3DGeometryCreateCopy(cf);
  Mesh = C3DGeometryGetMesh(Copy);
  CopyWithInterleavedSources = (uint64_t *)C3DMeshCreateCopyWithInterleavedSources(Mesh);
  C3DGeometrySetMesh(Copy, CopyWithInterleavedSources);
  CFRelease(CopyWithInterleavedSources);
  return Copy;
}

uint64_t C3DGeometryCreateRenderableCopy(CFTypeRef cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Copy;
  uint64_t Mesh;
  uint64_t *RenderableCopy;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  Copy = C3DGeometryCreateCopy(cf);
  Mesh = C3DGeometryGetMesh(Copy);
  RenderableCopy = (uint64_t *)C3DMeshCreateRenderableCopy(Mesh);
  C3DGeometrySetMesh(Copy, RenderableCopy);
  CFRelease(RenderableCopy);
  return Copy;
}

uint64_t C3DGeometryCreateMutableCopy(CFTypeRef cf)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Copy;
  uint64_t Mesh;
  uint64_t *DeepCopy;

  if (!cf)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  Copy = C3DGeometryCreateCopy(cf);
  Mesh = C3DGeometryGetMesh(Copy);
  DeepCopy = (uint64_t *)C3DMeshCreateDeepCopy(Mesh);
  C3DMeshMarkMutable((uint64_t)DeepCopy);
  C3DGeometrySetMesh(Copy, DeepCopy);
  CFRelease(DeepCopy);
  return Copy;
}

CFStringRef C3DGeometrySetName(uint64_t a1, CFStringRef theString)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return C3DEntitySetName(a1, theString);
}

void C3DGeometryRemoveMaterialAtIndex(uint64_t a1, CFIndex a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *ValueAtIndex;
  uint64_t v13;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (C3DGetSceneRef(a1))
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), a2);
    v13 = C3DGetSceneRef(a1);
    C3DRemoveSceneRef(ValueAtIndex, v13);
  }
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), a2);
  __PostGeometryMaterialDidChangeNotification((_QWORD *)a1);
}

void C3DGeometryReplaceMaterialAtIndex(uint64_t a1, void *a2, CFIndex a3)
{
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *ValueAtIndex;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  void *newValues;
  CFRange v18;

  newValues = a2;
  if (!a1)
  {
    v5 = scn_default_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
  }
  if (C3DGetSceneRef(a1))
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), a3);
    v14 = C3DGetSceneRef(a1);
    C3DRemoveSceneRef(ValueAtIndex, v14);
  }
  v18.location = a3;
  v18.length = 1;
  CFArrayReplaceValues(*(CFMutableArrayRef *)(a1 + 80), v18, (const void **)&newValues, 1);
  v15 = (uint64_t *)newValues;
  v16 = C3DGetSceneRef(a1);
  C3DAddSceneRef(v15, v16);
  __PostGeometryMaterialDidChangeNotification((_QWORD *)a1);
}

void _C3DGeometryShadingDidUpdate(_QWORD *a1)
{
  const __CFArray *MaterialsCount;
  const __CFArray *v3;
  uint64_t i;
  const __CFArray *MaterialAtIndex;

  MaterialsCount = C3DGeometryGetMaterialsCount((uint64_t)a1);
  if ((uint64_t)MaterialsCount >= 1)
  {
    v3 = MaterialsCount;
    for (i = 0; (const __CFArray *)i != v3; ++i)
    {
      MaterialAtIndex = C3DGeometryGetMaterialAtIndex((uint64_t)a1, i);
      _C3DMaterialShadingDidUpdate(MaterialAtIndex);
    }
  }
  __PostGeometryMaterialDidChangeNotification(a1);
}

void C3DGeometrySetOverrideMaterial(_QWORD *a1, void *cf)
{
  const void *v4;
  CFTypeRef v5;
  uint64_t v6;

  v4 = (const void *)a1[9];
  if (v4 != cf)
  {
    if (v4)
    {
      CFRelease(v4);
      a1[9] = 0;
    }
    if (cf)
      v5 = CFRetain(cf);
    else
      v5 = 0;
    a1[9] = v5;
  }
  if (cf)
  {
    v6 = C3DGetSceneRef((uint64_t)a1);
    C3DAddSceneRef((uint64_t *)cf, v6);
  }
  _C3DGeometryShadingDidUpdate(a1);
}

void __propagateUnTrackingOfNodesToLODs(const void *a1, uint64_t a2)
{
  C3DGeometryUntrackNode(a2, a1);
}

CFIndex __propagateTrackingOfNodesToLODs(const void *a1, uint64_t a2)
{
  return C3DGeometryTrackNode(a2, a1);
}

void C3DGeometryGeneratePoints(CFTypeRef cf, uint64_t a2, unsigned int *a3, _OWORD *a4, _OWORD *a5, int a6)
{
  int v6;
  CFTypeID v10;
  uint64_t Mesh;
  uint64_t v12;
  const void *PositionSource;
  uint64_t v14;
  uint64_t Count;
  uint64_t v16;
  const void *NormalSource;
  uint64_t v18;
  NSObject *v19;
  const __CFArray *ElementsCount;
  BOOL v21;
  int v22;
  BOOL v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  const void *ElementAtIndex;
  uint64_t PrimitiveCount;
  uint64_t v34;
  uint64_t IndexCountPerPrimitive;
  __int128 v36;
  int32x2_t v37;
  int32x2_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t Index;
  _OWORD *v42;
  unsigned int v43;
  float v44;
  unsigned int v45;
  float v46;
  unsigned int v47;
  float v48;
  float v49;
  float v50;
  float32x4_t v51;
  int32x4_t v52;
  float32x2_t v53;
  float32x2_t v54;
  float32x4_t v55;
  unsigned int v56;
  float32x4_t v57;
  int32x4_t v58;
  float32x2_t v59;
  float32x2_t v60;
  const __CFArray *v61;
  uint64_t v62;
  _OWORD *v63;
  _OWORD *v64;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  uint64_t v73;

  v6 = a6;
  v73 = *MEMORY[0x1E0C80C00];
  if (a6 != 2)
  {
    v10 = CFGetTypeID(cf);
    if (v10 == C3DParametricGeometryGetTypeID())
    {
      C3DParametricGeometryGeneratePoints((uint64_t)cf);
      return;
    }
  }
  Mesh = C3DGeometryGetMesh((uint64_t)cf);
  if (Mesh)
  {
    v12 = Mesh;
    PositionSource = C3DMeshGetPositionSource(Mesh, 1);
    if (PositionSource)
    {
      v14 = (uint64_t)PositionSource;
      Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
      if (Count)
      {
        v16 = Count;
        NormalSource = C3DMeshGetNormalSource(v12, 1);
        v18 = (uint64_t)NormalSource;
        if (!NormalSource || C3DMeshSourceGetCount((uint64_t)NormalSource) == v16)
        {
          if (v6 == 1)
          {
            if ((C3DGeometryGeneratePoints_done_42 & 1) == 0)
            {
              C3DGeometryGeneratePoints_done_42 = 1;
              v19 = scn_default_log();
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                C3DGeometryGeneratePoints_cold_1();
            }
            v6 = 0;
          }
          ElementsCount = C3DMeshGetElementsCount(v12);
          if (ElementsCount)
            v21 = 0;
          else
            v21 = v6 == 0;
          if (v21)
            v22 = 2;
          else
            v22 = v6;
          if (v22)
          {
            if (v22 == 2 && a2 >= 1)
            {
              if (a5)
                v23 = v18 == 0;
              else
                v23 = 1;
              v24 = !v23;
              do
              {
                v25 = 214013 * *a3 + 2531011;
                *a3 = v25;
                v26 = v25 % v16;
                *(double *)&v27 = C3DMeshSourceGetValueAtIndexAsVector3(v14, v25 % v16);
                *a4 = v27;
                if (v24)
                {
                  *(double *)&v28 = C3DMeshSourceGetValueAtIndexAsVector3(v18, v26);
                  *a5 = v28;
                }
                ++a5;
                ++a4;
                --a2;
              }
              while (a2);
            }
            return;
          }
          if (a2 < 1)
            return;
          v30 = 0;
          v63 = a4;
          v64 = a5;
          v61 = ElementsCount;
          v62 = v12;
          while (1)
          {
            v31 = 214013 * *a3 + 2531011;
            *a3 = v31;
            ElementAtIndex = C3DMeshGetElementAtIndex(v12, v31 % (uint64_t)ElementsCount, 1);
            PrimitiveCount = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
            v34 = 214013 * *a3 + 2531011;
            *a3 = v34;
            IndexCountPerPrimitive = C3DMeshElementGetIndexCountPerPrimitive((uint64_t)ElementAtIndex);
            if (IndexCountPerPrimitive >= 1)
            {
              v39 = 0;
              v40 = v34 % PrimitiveCount;
              do
              {
                Index = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v40, v39, 0);
                *(double *)&v36 = C3DMeshSourceGetValueAtIndexAsVector3(v14, Index);
                *((_OWORD *)&v70 + v39) = v36;
                if (v18)
                {
                  *(double *)&v36 = C3DMeshSourceGetValueAtIndexAsVector3(v18, Index);
                  *((_OWORD *)&v67 + v39) = v36;
                }
                ++v39;
              }
              while (IndexCountPerPrimitive != v39);
            }
            if (IndexCountPerPrimitive == 1)
            {
              v42 = v64;
              v63[v30] = v70;
              ElementsCount = v61;
              v12 = v62;
              if (v64)
              {
                v55 = v67;
LABEL_52:
                v42[v30] = v55;
              }
            }
            else
            {
              v42 = v64;
              ElementsCount = v61;
              v12 = v62;
              if (IndexCountPerPrimitive != 2)
              {
                if (IndexCountPerPrimitive != 3)
                  goto LABEL_53;
                v43 = 214013 * *a3 + 2531011;
                v44 = (float)HIWORD(v43) * 0.000015259;
                v45 = 214013 * v43 + 2531011;
                v46 = (float)HIWORD(v45) * 0.000015259;
                v47 = 214013 * v45 + 2531011;
                *a3 = v47;
                v48 = (float)HIWORD(v47) * 0.000015259;
                v49 = 1.0 / (float)((float)(v44 + v46) + v48);
                *(float *)v37.i32 = v44 * v49;
                v50 = v46 * v49;
                v63[v30] = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v71, v46 * v49), v70, *(float *)v37.i32), v72, v48 * v49);
                if (!v64)
                  goto LABEL_53;
                *(float *)v38.i32 = v48 * v49;
                v51 = vmlaq_f32(vmlaq_f32(vmulq_n_f32(v68, v50), v67, (float32x4_t)vdupq_lane_s32(v37, 0)), v69, (float32x4_t)vdupq_lane_s32(v38, 0));
                v52 = (int32x4_t)vmulq_f32(v51, v51);
                v52.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v52, 2), vadd_f32(*(float32x2_t *)v52.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v52.i8, 1))).u32[0];
                v53 = vrsqrte_f32((float32x2_t)v52.u32[0]);
                v54 = vmul_f32(v53, vrsqrts_f32((float32x2_t)v52.u32[0], vmul_f32(v53, v53)));
                v55 = vmulq_n_f32(v51, vmul_f32(v54, vrsqrts_f32((float32x2_t)v52.u32[0], vmul_f32(v54, v54))).f32[0]);
                goto LABEL_52;
              }
              v56 = 214013 * *a3 + 2531011;
              *a3 = v56;
              *(float *)&v36 = (float)HIWORD(v56) * 0.000015259;
              v63[v30] = vmlaq_n_f32(v70, vsubq_f32(v71, v70), *(float *)&v36);
              if (v64)
              {
                v57 = vmlaq_f32(v67, vsubq_f32(v68, v67), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v36, 0));
                v58 = (int32x4_t)vmulq_f32(v57, v57);
                v58.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v58, 2), vadd_f32(*(float32x2_t *)v58.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v58.i8, 1))).u32[0];
                v59 = vrsqrte_f32((float32x2_t)v58.u32[0]);
                v60 = vmul_f32(v59, vrsqrts_f32((float32x2_t)v58.u32[0], vmul_f32(v59, v59)));
                v55 = vmulq_n_f32(v57, vmul_f32(v60, vrsqrts_f32((float32x2_t)v58.u32[0], vmul_f32(v60, v60))).f32[0]);
                goto LABEL_52;
              }
            }
LABEL_53:
            if (++v30 == a2)
              return;
          }
        }
        if ((C3DGeometryGeneratePoints_done & 1) == 0)
        {
          C3DGeometryGeneratePoints_done = 1;
          v29 = scn_default_log();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            C3DGeometryGeneratePoints_cold_2();
        }
      }
    }
  }
}

BOOL C3DGeometryMeshElementsSupportsTessellation(uint64_t a1)
{
  char v1;
  int v2;
  const __CFArray *MeshElements;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const void *ValueAtIndex;

  v1 = *(_BYTE *)(a1 + 208);
  v2 = v1 & 3;
  if ((v1 & 3) == 0)
  {
    v2 = 1;
    MeshElements = (const __CFArray *)C3DMeshGetMeshElements(*(_QWORD *)(a1 + 64), 1);
    Count = CFArrayGetCount(MeshElements);
    if (Count >= 1)
    {
      v6 = Count;
      v7 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(MeshElements, v7);
        if (C3DMeshElementGetType((uint64_t)ValueAtIndex))
          break;
        if (v6 == ++v7)
        {
          v2 = 1;
          goto LABEL_8;
        }
      }
      v2 = 2;
    }
LABEL_8:
    *(_BYTE *)(a1 + 208) = v2 | v1 & 0xFC;
  }
  return v2 == 1;
}

__n128 C3DGeometryGetTessellator@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(__n128 *)(a1 + 184);
  *a2 = result;
  a2[1].n128_u64[0] = *(_QWORD *)(a1 + 200);
  return result;
}

BOOL C3DGeometryUsesDeformerBasedDynamicMesh(uint64_t a1)
{
  return *(_QWORD *)(a1 + 128) != 0;
}

uint64_t C3DGeometryCreatePositionSourceForDeformerBasedDynamicMesh(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 128))();
}

uint64_t C3DGeometryGetMeshElementCountForDeformerBasedDynamicMesh(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 128) + 8))();
}

uint64_t _C3DGeometryGetBoundingSphere(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t result;

  result = C3DGeometryGetMesh(a1);
  if (result)
    return C3DMeshGetBoundingSphere(result, a3);
  return result;
}

void _C3DGeometryDidTransferFromScene(uint64_t a1)
{
  uint64_t Mesh;
  uint64_t *Copy;

  Mesh = C3DGeometryGetMesh(a1);
  if (Mesh)
  {
    Copy = (uint64_t *)C3DMeshCreateCopy(Mesh);
    C3DGeometrySetMesh(a1, Copy);
    if (Copy)
      CFRelease(Copy);
  }
}

uint64_t _C3DGeometrySearchByID(uint64_t a1, const void *a2)
{
  uint64_t v3;
  const void *ID;
  const __CFArray *MaterialsCount;
  const __CFArray *v6;
  uint64_t v7;
  const __CFArray *MaterialAtIndex;
  uint64_t v9;
  const void *Mesh;

  v3 = a1;
  ID = (const void *)C3DEntityGetID(a1);
  if (!C3DEqual(ID, a2))
  {
    MaterialsCount = C3DGeometryGetMaterialsCount(v3);
    if ((uint64_t)MaterialsCount < 1)
    {
LABEL_6:
      Mesh = (const void *)C3DGeometryGetMesh(v3);
      return C3DSearchByID(Mesh, (uint64_t)a2);
    }
    v6 = MaterialsCount;
    v7 = 0;
    while (1)
    {
      MaterialAtIndex = C3DGeometryGetMaterialAtIndex(v3, v7);
      v9 = C3DSearchByID(MaterialAtIndex, (uint64_t)a2);
      if (v9)
        return v9;
      if (v6 == (const __CFArray *)++v7)
        goto LABEL_6;
    }
  }
  return v3;
}

void OUTLINED_FUNCTION_0_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

id _C3DImageToMDLTexture(__C3DImage *a1, char a2)
{
  __C3DImage *VerticalStripCubemapWithImage;
  uint64_t v4;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  CGContext *v9;
  CGContext *v10;
  void *Data;
  size_t BitsPerComponent;
  size_t BitsPerPixel;
  size_t v14;
  id v15;
  uint64_t v16;
  size_t BytesPerRow;
  void *v18;
  uint64_t v19;
  double Size;

  if ((a2 & 1) == 0 && C3DImageIsCubeMap((uint64_t)a1))
  {
    VerticalStripCubemapWithImage = (__C3DImage *)C3DImageCreateVerticalStripCubemapWithImage((uint64_t)a1);
    v4 = _C3DImageToMDLTexture(VerticalStripCubemapWithImage, 1);
    CFRelease(VerticalStripCubemapWithImage);
    return (id)v4;
  }
  if (C3DImageGetImageType((uint64_t)a1) == 2)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      _C3DImageToMDLTexture(v6, v7, v8);
  }
  else
  {
    v9 = (CGContext *)C3DImageCopyBitmap((uint64_t)a1, 1);
    if (v9)
    {
      v10 = v9;
      Data = CGBitmapContextGetData(v9);
      Size = C3DImageGetSize((uint64_t)a1);
      BitsPerComponent = CGBitmapContextGetBitsPerComponent(v10);
      BitsPerPixel = CGBitmapContextGetBitsPerPixel(v10);
      if (BitsPerComponent == 8)
      {
        v14 = BitsPerPixel >> 3;
        v15 = objc_alloc(MEMORY[0x1E0CC7808]);
        v16 = objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", Data, (unint64_t)vmuls_lane_f32((float)CGBitmapContextGetBytesPerRow(v10), *(float32x2_t *)&Size, 1));
        BytesPerRow = CGBitmapContextGetBytesPerRow(v10);
        LOBYTE(v19) = C3DImageGetImageType((uint64_t)a1) == 3;
        v18 = (void *)objc_msgSend(v15, "initWithData:topLeftOrigin:name:dimensions:rowStride:channelCount:channelEncoding:isCube:", v16, 1, 0, BytesPerRow, v14, 1, COERCE_DOUBLE(vcvt_s32_f32(*(float32x2_t *)&Size)), v19);
        CFRelease(v10);
        return v18;
      }
      CFRelease(v10);
    }
  }
  return 0;
}

id flattenObjectInMeshes(simd_float4x4 a1, MDLObject *a2, NSMutableArray *a3)
{
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  void *v10;
  id result;
  id v12;
  id v13;
  uint64_t v14;
  void *v15;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _OWORD v21[4];
  simd_float4x4 v22;
  _BYTE v23[128];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (-[MDLObject transform](a2, "transform"))
  {
    objc_msgSend(-[MDLObject transform](a2, "transform"), "matrix");
    v5 = 0;
    v21[0] = v6;
    v21[1] = v7;
    v21[2] = v8;
    v21[3] = v9;
    do
    {
      v22.columns[v5] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a1.columns[0], COERCE_FLOAT(v21[v5])), (float32x4_t)a1.columns[1], *(float32x2_t *)&v21[v5], 1), (float32x4_t)a1.columns[2], (float32x4_t)v21[v5], 2), (float32x4_t)a1.columns[3], (float32x4_t)v21[v5], 3);
      ++v5;
    }
    while (v5 != 4);
    a1 = v22;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v10 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC7818]), "initWithMatrix:", *(double *)a1.columns[0].i64, *(double *)a1.columns[1].i64, *(double *)a1.columns[2].i64, *(double *)a1.columns[3].i64);
    -[MDLObject setTransform:](a2, "setTransform:", v10);

    return (id)-[NSMutableArray addObject:](a3, "addObject:", a2);
  }
  else
  {
    result = -[MDLObject children](a2, "children");
    if (result)
    {
      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      v12 = -[MDLObject children](a2, "children");
      result = (id)objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v17, v23, 16);
      if (result)
      {
        v13 = result;
        v14 = *(_QWORD *)v18;
        do
        {
          v15 = 0;
          do
          {
            if (*(_QWORD *)v18 != v14)
              objc_enumerationMutation(v12);
            flattenObjectInMeshes(a1, *(MDLObject **)(*((_QWORD *)&v17 + 1) + 8 * (_QWORD)v15), a3);
            v15 = (char *)v15 + 1;
          }
          while (v13 != v15);
          result = (id)objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v17, v23, 16);
          v13 = result;
        }
        while (result);
      }
    }
  }
  return result;
}

NSMutableArray *FlattenedMDLMeshesFromMDLAsset(MDLAsset *a1)
{
  NSMutableArray *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  simd_float4 v8;
  simd_float4 v9;
  simd_float4 v10;
  simd_float4 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;
  simd_float4x4 v18;

  v17 = *MEMORY[0x1E0C80C00];
  v10 = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 16);
  v11 = *(simd_float4 *)MEMORY[0x1E0C83FF0];
  v8 = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 48);
  v9 = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 32);
  v2 = (NSMutableArray *)objc_opt_new();
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v3 = -[MDLAsset countByEnumeratingWithState:objects:count:](a1, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)v13;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v13 != v5)
          objc_enumerationMutation(a1);
        v18.columns[1] = v10;
        v18.columns[0] = v11;
        v18.columns[3] = v8;
        v18.columns[2] = v9;
        flattenObjectInMeshes(v18, *(MDLObject **)(*((_QWORD *)&v12 + 1) + 8 * v6++), v2);
      }
      while (v4 != v6);
      v4 = -[MDLAsset countByEnumeratingWithState:objects:count:](a1, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
    }
    while (v4);
  }
  return v2;
}

id flattenLightsInMeshes(simd_float4x4 a1, MDLObject *a2, NSMutableArray *a3)
{
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  void *v10;
  id result;
  id v12;
  id v13;
  uint64_t v14;
  void *v15;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _OWORD v21[4];
  simd_float4x4 v22;
  _BYTE v23[128];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (-[MDLObject transform](a2, "transform"))
  {
    objc_msgSend(-[MDLObject transform](a2, "transform"), "matrix");
    v5 = 0;
    v21[0] = v6;
    v21[1] = v7;
    v21[2] = v8;
    v21[3] = v9;
    do
    {
      v22.columns[v5] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a1.columns[0], COERCE_FLOAT(v21[v5])), (float32x4_t)a1.columns[1], *(float32x2_t *)&v21[v5], 1), (float32x4_t)a1.columns[2], (float32x4_t)v21[v5], 2), (float32x4_t)a1.columns[3], (float32x4_t)v21[v5], 3);
      ++v5;
    }
    while (v5 != 4);
    a1 = v22;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v10 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC7818]), "initWithMatrix:", *(double *)a1.columns[0].i64, *(double *)a1.columns[1].i64, *(double *)a1.columns[2].i64, *(double *)a1.columns[3].i64);
    -[MDLObject setTransform:](a2, "setTransform:", v10);

    return (id)-[NSMutableArray addObject:](a3, "addObject:", a2);
  }
  else
  {
    result = -[MDLObject children](a2, "children");
    if (result)
    {
      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      v12 = -[MDLObject children](a2, "children");
      result = (id)objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v17, v23, 16);
      if (result)
      {
        v13 = result;
        v14 = *(_QWORD *)v18;
        do
        {
          v15 = 0;
          do
          {
            if (*(_QWORD *)v18 != v14)
              objc_enumerationMutation(v12);
            flattenLightsInMeshes(a1, *(MDLObject **)(*((_QWORD *)&v17 + 1) + 8 * (_QWORD)v15), a3);
            v15 = (char *)v15 + 1;
          }
          while (v13 != v15);
          result = (id)objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v17, v23, 16);
          v13 = result;
        }
        while (result);
      }
    }
  }
  return result;
}

NSMutableArray *FlattenedMDLLightsFromMDLAsset(MDLAsset *a1)
{
  NSMutableArray *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  simd_float4 v8;
  simd_float4 v9;
  simd_float4 v10;
  simd_float4 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;
  simd_float4x4 v18;

  v17 = *MEMORY[0x1E0C80C00];
  v10 = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 16);
  v11 = *(simd_float4 *)MEMORY[0x1E0C83FF0];
  v8 = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 48);
  v9 = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 32);
  v2 = (NSMutableArray *)objc_opt_new();
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v3 = -[MDLAsset countByEnumeratingWithState:objects:count:](a1, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)v13;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v13 != v5)
          objc_enumerationMutation(a1);
        v18.columns[1] = v10;
        v18.columns[0] = v11;
        v18.columns[3] = v8;
        v18.columns[2] = v9;
        flattenLightsInMeshes(v18, *(MDLObject **)(*((_QWORD *)&v12 + 1) + 8 * v6++), v2);
      }
      while (v4 != v6);
      v4 = -[MDLAsset countByEnumeratingWithState:objects:count:](a1, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
    }
    while (v4);
  }
  return v2;
}

SCNScene *loadMDLAssetWithURL(void *a1, void *a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFString **v9;
  const __CFString *v10;
  void *v11;
  SCNScene *v12;
  _QWORD v14[5];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[2];
  _QWORD v22[3];

  v22[2] = *MEMORY[0x1E0C80C00];
  v4 = (void *)objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("kSceneSourcePreserveOriginalTopology"));
  if (v4)
    v5 = objc_msgSend(v4, "BOOLValue");
  else
    v5 = C3DPreserveOriginalTopologyDefaultValue();
  v6 = v5;
  if (objc_msgSend(MEMORY[0x1E0CC7780], "instancesRespondToSelector:", sel_initThroughSCNKitBridgeWithURL_options_error_))
  {
    if ((C3DWasLinkedBeforeMajorOSYear2023() & 1) != 0)
    {
      v19 = *MEMORY[0x1E0CC7710];
      v20 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", v6);
      v7 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v20, &v19, 1);
    }
    else
    {
      v15 = 0;
      v16 = &v15;
      v17 = 0x2020000000;
      v9 = (const __CFString **)getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLoc(void)::ptr;
      v18 = getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLoc(void)::ptr;
      if (!getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLoc(void)::ptr)
      {
        v14[0] = MEMORY[0x1E0C809B0];
        v14[1] = 3221225472;
        v14[2] = ___ZL53getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLocv_block_invoke;
        v14[3] = &unk_1EA59DF80;
        v14[4] = &v15;
        ___ZL53getMDLAssetLoadingOptionDefaultUSDColorSpaceSymbolLocv_block_invoke((uint64_t)v14);
        v9 = (const __CFString **)v16[3];
      }
      _Block_object_dispose(&v15, 8);
      if (!v9)
        loadMDLAssetWithURL_cold_1();
      if (*v9)
        v10 = *v9;
      else
        v10 = CFSTR("kMDLAssetDefaultUSDColorSpace");
      v21[0] = *MEMORY[0x1E0CC7710];
      v22[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", v6);
      v21[1] = v10;
      v22[1] = C3DColorSpaceLinearDisplayP3();
      v7 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v22, v21, 2);
    }
    v8 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC7780]), "initThroughSCNKitBridgeWithURL:options:error:", a1, v7, 0);
  }
  else
  {
    v8 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC7780]), "initThroughSCNKitBridgeWithURL:preserveTopology:error:", a1, v6, 0);
  }
  v11 = (void *)v8;
  if (((C3DIsRunningInXcode() & 1) != 0
     || objc_msgSend((id)objc_msgSend(a2, "valueForKey:", CFSTR("SCNSceneSourceLoadTexturesInCPUMemory")), "BOOLValue"))&& objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "pathExtension"), "lowercaseString"), "isEqualToString:", CFSTR("usdz")))
  {
    objc_msgSend(v11, "loadTextures");
  }
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3978], "currentThread"), "threadDictionary"), "setValue:forKey:", objc_msgSend(v11, "resolver"), CFSTR("SCN_MDLCurrentAssetResolver"));
  if (!v11)
    return 0;
  v12 = +[SCNScene sceneWithMDLAsset:options:](SCNScene, "sceneWithMDLAsset:options:", v11, a2);
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3978], "currentThread"), "threadDictionary"), "setValue:forKey:", 0, CFSTR("SCN_MDLCurrentAssetResolver"));

  return v12;
}

void sub_1DCD36FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id SCNNodesToMDLAsset(void *a1)
{
  id result;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _BYTE v12[128];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  result = objc_alloc_init(MEMORY[0x1E0CC7780]);
  if (result)
  {
    v3 = result;
    v10 = 0u;
    v11 = 0u;
    v8 = 0u;
    v9 = 0u;
    v4 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v8, v12, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v9;
      do
      {
        v7 = 0;
        do
        {
          if (*(_QWORD *)v9 != v6)
            objc_enumerationMutation(a1);
          objc_msgSend(v3, "addObject:", objc_msgSend(MEMORY[0x1E0CC77C8], "objectWithSCNNode:", *(_QWORD *)(*((_QWORD *)&v8 + 1) + 8 * v7++)));
        }
        while (v5 != v7);
        v5 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v8, v12, 16);
      }
      while (v5);
    }
    return v3;
  }
  return result;
}

id jointNodesFromMDLSkinDeformer(void *a1, void *a2)
{
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = (void *)objc_msgSend(a1, "jointPaths");
  v4 = (void *)objc_opt_new();
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v13;
    while (2)
    {
      for (i = 0; i != v6; ++i)
      {
        if (*(_QWORD *)v13 != v7)
          objc_enumerationMutation(v3);
        v9 = *(_QWORD *)(*((_QWORD *)&v12 + 1) + 8 * i);
        v10 = objc_msgSend(a2, "objectForKeyedSubscript:", v9);
        if (!v10)
        {
          NSLog(CFSTR("While creating SCNSkinner: Could not find SCNNode %@"), v9);
          objc_msgSend(v4, "removeAllObjects");
          return v4;
        }
        objc_msgSend(v4, "addObject:", v10);
      }
      v6 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      if (v6)
        continue;
      break;
    }
  }
  return v4;
}

id boneInverseTransformsFromMDLSkinDeformer(void *a1)
{
  void *v2;
  uint64_t v3;
  unint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _OWORD v17[4];
  _OWORD v18[4];
  _OWORD v19[4];
  simd_float4x4 v20;

  v2 = (void *)objc_opt_new();
  v3 = objc_msgSend((id)objc_msgSend(a1, "jointBindTransforms"), "bytes");
  v4 = objc_msgSend((id)objc_msgSend(a1, "jointBindTransforms"), "length");
  objc_msgSend(a1, "meshBindTransform");
  v15 = v6;
  v16 = v5;
  v13 = v8;
  v14 = v7;
  if (v4 >= 0x40)
  {
    v9 = 0;
    v10 = v4 >> 6;
    do
    {
      v20 = __invert_f4(*(simd_float4x4 *)(v3 + (v9 << 6)));
      v11 = 0;
      v18[0] = v16;
      v18[1] = v15;
      v18[2] = v14;
      v18[3] = v13;
      do
      {
        v19[v11] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v20.columns[0], COERCE_FLOAT(v18[v11])), (float32x4_t)v20.columns[1], *(float32x2_t *)&v18[v11], 1), (float32x4_t)v20.columns[2], (float32x4_t)v18[v11], 2), (float32x4_t)v20.columns[3], (float32x4_t)v18[v11], 3);
        ++v11;
      }
      while (v11 != 4);
      v17[0] = v19[0];
      v17[1] = v19[1];
      v17[2] = v19[2];
      v17[3] = v19[3];
      objc_msgSend(v2, "addObject:", objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithSCNMatrix4:", v17));
      ++v9;
    }
    while (v9 != v10);
  }
  return v2;
}

void *createFloatAnimation(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  double *v4;
  uint64_t v5;
  double v6;
  double v7;
  void *v8;
  unint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  uint64_t v19;

  v4 = *(double **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 == *(_QWORD *)a2)
    return 0;
  v6 = *v4;
  v7 = *(double *)(v3 - 8) - *v4;
  if (v7 < 2.22044605e-16)
    return 0;
  v12 = v5 >> 3;
  v13 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", v5 >> 3);
  v14 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", v12);
  v15 = 0;
  if (v12 <= 1)
    v16 = 1;
  else
    v16 = v12;
  do
  {
    v17 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", (*(double *)(*(_QWORD *)a2 + 8 * v15) - v6) / v7);
    LODWORD(v18) = *(_DWORD *)(*a3 + 4 * v15);
    v19 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v18);
    objc_msgSend(v13, "addObject:", v17);
    objc_msgSend(v14, "addObject:", v19);
    ++v15;
  }
  while (v16 != v15);
  v8 = (void *)objc_msgSend(MEMORY[0x1E0CD2798], "animationWithKeyPath:", a1);
  objc_msgSend(v8, "setValues:", v14);
  objc_msgSend(v8, "setKeyTimes:", v13);
  objc_msgSend(v8, "setDuration:", v7);
  objc_msgSend(v8, "setBeginTime:", v6);
  objc_msgSend(v8, "setAdditive:", 0);
  objc_msgSend(v8, "setRemovedOnCompletion:", 0);
  return v8;
}

id morpherFromMDLMorphDeformer(void *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  void *v7;
  SCNGeometry *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  float v16;
  NSObject *v17;
  float v18;
  void *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  double v25;
  _DWORD *v26;
  _DWORD *j;
  id v28;
  id v30;
  uint8_t buf[24];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v30 = (id)objc_opt_new();
  v2 = (void *)objc_opt_new();
  v3 = objc_msgSend((id)objc_msgSend(a1, "shapeSetTargetCounts"), "count");
  v4 = objc_msgSend((id)objc_msgSend(a1, "targetShapes"), "count");
  if (v4)
  {
    v5 = v4;
    for (i = 0; i != v5; ++i)
    {
      v7 = (void *)objc_msgSend((id)objc_msgSend(a1, "targetShapes"), "objectAtIndexedSubscript:", i);
      v8 = +[SCNGeometry geometryWithMDLMesh:](SCNGeometry, "geometryWithMDLMesh:", v7);
      -[SCNGeometry setName:](v8, "setName:", objc_msgSend(v7, "name"));
      -[SCNGeometry setEdgeCreasesSource:](v8, "setEdgeCreasesSource:", 0);
      -[SCNGeometry setEdgeCreasesElement:](v8, "setEdgeCreasesElement:", 0);
      objc_msgSend(v2, "addObject:", v8);
    }
  }
  if (v3)
  {
    v9 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 0);
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "shapeSetTargetCounts"), "objectAtIndexedSubscript:", v10), "unsignedIntegerValue");
      v13 = v12 - 1;
      if (v12 != 1)
      {
        v14 = v13 + v11;
        do
        {
          v15 = (void *)objc_msgSend((id)objc_msgSend(a1, "shapeSetTargetWeights"), "objectAtIndexedSubscript:", v11);
          objc_msgSend(v9, "addObject:", v15);
          objc_msgSend(v15, "floatValue");
          if (v16 >= 1.0)
          {
            v17 = scn_default_log();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
            {
              objc_msgSend(v15, "floatValue");
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = "influenceWeightNumber.floatValue < 1.f";
              *(_WORD *)&buf[12] = 2048;
              *(double *)&buf[14] = v18;
              _os_log_fault_impl(&dword_1DCCB8000, v17, OS_LOG_TYPE_FAULT, "Assertion '%s' failed. Found in-between morph target with influence weight of %f", buf, 0x16u);
            }
          }
          ++v11;
          --v13;
        }
        while (v13);
        v11 = v14;
      }
      ++v11;
      ++v10;
    }
    while (v10 != v3);
    objc_msgSend(v30, "setTargets:withInBetweenTargetCounts:inBetweenWeights:", v2, objc_msgSend(a1, "shapeSetTargetCounts"), v9);

  }
  else
  {
    objc_msgSend(v30, "setTargets:", v2);
  }
  v19 = (void *)objc_msgSend(a1, "weights");
  v20 = objc_msgSend(v19, "elementCount");
  memset(buf, 0, sizeof(buf));
  if (v20)
  {
    std::vector<float>::__vallocate[abi:nn180100](buf, v20);
    v21 = *(_QWORD *)&buf[8];
    bzero(*(void **)&buf[8], 4 * v20);
    *(_QWORD *)&buf[8] = v21 + 4 * v20;
  }
  if (objc_msgSend((id)objc_msgSend(v19, "keyTimes"), "count"))
  {
    v22 = *(_QWORD *)buf;
    v23 = objc_msgSend(v19, "elementCount");
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v19, "keyTimes"), "objectAtIndexedSubscript:", 0), "doubleValue");
    objc_msgSend(v19, "getFloatArray:maxCount:atTime:", v22, v23);
  }
  v24 = (void *)objc_opt_new();
  v26 = *(_DWORD **)buf;
  for (j = *(_DWORD **)&buf[8]; v26 != j; ++v26)
  {
    LODWORD(v25) = *v26;
    objc_msgSend(v24, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v25));
  }
  objc_msgSend(v30, "setWeights:", v24);

  v28 = v30;
  if (*(_QWORD *)buf)
  {
    *(_QWORD *)&buf[8] = *(_QWORD *)buf;
    operator delete(*(void **)buf);
  }
  return v28;
}

void sub_1DCD37818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void addMorphAnimation(void *a1, void *a2, void *a3)
{
  void *v4;
  unint64_t v5;
  uint64_t v6;
  char *v7;
  void *v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t i;
  _DWORD *v14;
  _DWORD *v15;
  unint64_t v16;
  void *v17;
  void *v18;
  double v19;
  void *v20;
  double v21;
  void *v22;
  int v23;
  double v24;
  double v25;
  double v26;
  double v27;
  void *__p;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t v35;
  void *v36;
  void *v37;
  uint64_t v38;

  if (objc_msgSend(a2, "morpher"))
  {
    v4 = (void *)objc_msgSend(a1, "weights");
    if (objc_msgSend(v4, "isAnimated"))
    {
      v5 = objc_msgSend(v4, "timeSampleCount");
      v6 = objc_msgSend(v4, "elementCount");
      v36 = 0;
      v37 = 0;
      v38 = 0;
      if (v5)
      {
        std::vector<Statement *>::__vallocate[abi:nn180100](&v36, v5);
        v7 = (char *)v37;
        bzero(v37, 8 * v5);
        v37 = &v7[8 * v5];
        v8 = v36;
      }
      else
      {
        v8 = 0;
      }
      objc_msgSend(v4, "getTimes:maxCount:", v8, v5);
      v9 = v6 * v5;
      v33 = 0;
      v34 = 0;
      v35 = 0;
      if (v6 * v5)
      {
        std::vector<float>::__vallocate[abi:nn180100](&v33, v6 * v5);
        v10 = (char *)v34;
        bzero(v34, 4 * v9);
        v34 = &v10[4 * v9];
      }
      if (v6)
        objc_msgSend(v4, "getFloatArray:maxCount:", v33, v6 * v5);
      __p = 0;
      v31 = 0;
      v32 = 0;
      if (v5)
      {
        std::vector<float>::__vallocate[abi:nn180100](&__p, v5);
        v11 = (char *)v31;
        bzero(v31, 4 * v5);
        v31 = &v11[4 * v5];
      }
      if (v6)
      {
        v12 = 0;
        for (i = 0; i != v6; ++i)
        {
          if (v5)
          {
            v14 = __p;
            v15 = (char *)v33 + v12;
            v16 = v5;
            do
            {
              *v14++ = *v15;
              v15 += v6;
              --v16;
            }
            while (v16);
          }
          v17 = createFloatAnimation(objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("morpher.weights[%d]"), i), (uint64_t)&v36, &__p);
          v18 = v17;
          if (v17)
          {
            objc_msgSend(v17, "duration");
            if (v19 != 0.0)
            {
              v20 = (void *)objc_msgSend(a3, "valueForKey:", CFSTR("kSceneSourceAnimationLoadingMode"));
              v22 = v20;
              if (v20)
              {
                objc_msgSend(v18, "setUsesSceneTimeBase:", objc_msgSend(v20, "isEqualToString:", CFSTR("playUsingSceneTime")));
                objc_msgSend(v18, "setRemovedOnCompletion:", objc_msgSend(v22, "isEqualToString:", CFSTR("playUsingSceneTime")) ^ 1);
                v23 = objc_msgSend(v22, "isEqualToString:", CFSTR("playRepeatedly"));
                LODWORD(v21) = 2139095040;
                if (!v23)
                  *(float *)&v21 = 0.0;
              }
              else
              {
                LODWORD(v21) = 2139095040;
              }
              objc_msgSend(v18, "setRepeatCount:", v21);
              if ((objc_msgSend(v18, "usesSceneTimeBase") & 1) == 0)
              {
                objc_msgSend(v18, "beginTime");
                if (v24 != 0.0)
                {
                  C3DTransactionGetAtomicTime();
                  v26 = v25;
                  objc_msgSend(v18, "beginTime");
                  objc_msgSend(v18, "setBeginTime:", v26 + v27);
                }
              }
              objc_msgSend(a2, "addAnimation:forKey:", v18, 0);
            }
          }
          v12 += 4;
        }
      }
      if (__p)
      {
        v31 = __p;
        operator delete(__p);
      }
      if (v33)
      {
        v34 = v33;
        operator delete(v33);
      }
      if (v36)
      {
        v37 = v36;
        operator delete(v36);
      }
    }
  }
}

void sub_1DCD37B30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p)
    operator delete(__p);
  if (a20)
    operator delete(a20);
  _Unwind_Resume(exception_object);
}

void sub_1DCD38810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,_QWORD *a61)
{
  _Unwind_Resume(a1);
}

void `anonymous namespace'::_loadAnimations(_anonymous_namespace_ *a1, void *a2, void *a3, void *a4, uint64_t **a5)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  MDLObject *v12;
  uint64_t v13;
  void *v14;
  uint64_t *BoundSkeleton;
  void *v16;
  uint64_t *v17;
  uint64_t **v18;
  uint64_t *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t j;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t k;
  MDLAnimationBindComponent *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float64x2_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t m;
  _anonymous_namespace_ *v42;
  void *v43;
  uint64_t v44;
  MDLMesh *v45;
  SCNGeometrySource *v46;
  MDLMesh *v47;
  SCNSkinner *v48;
  uint64_t v49;
  const simd_double4x4 *v50;
  void *v51;
  const simd_double4x4 *v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  _anonymous_namespace_ *v61;
  uint64_t v62;
  char v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t n;
  _anonymous_namespace_ *v68;
  MDLPackedJointAnimation *v69;
  void *RootNodeName;
  MDLPackedJointAnimation *v71;
  void *v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t **v75;
  void *v76;
  uint64_t v77;
  uint64_t v78;
  __int128 *v79;
  uint64_t ii;
  void *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  uint64_t v89;
  uint64_t **v90;
  id obj;
  id obja;
  uint64_t v93;
  void *v94;
  _anonymous_namespace_ *v95;
  uint64_t *v96;
  void *v97;
  void *v98;
  uint64_t v99;
  void *v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  _OWORD v113[4];
  _OWORD v114[4];
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  void *__p;
  void *v120;
  uint64_t v121;
  uint64_t *v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  uint64_t *v135;
  _BYTE v136[128];
  _BYTE v137[128];
  _BYTE v138[128];
  _BYTE v139[128];
  _BYTE v140[128];
  float64x2_t v141[8];
  uint64_t v142;

  v100 = a4;
  v142 = *MEMORY[0x1E0C80C00];
  v123 = 0u;
  v124 = 0u;
  v125 = 0u;
  v126 = 0u;
  v95 = a1;
  v8 = (void *)-[_anonymous_namespace_ children](a1, "children");
  v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v123, v139, 16);
  if (v9)
  {
    v10 = *(_QWORD *)v124;
    do
    {
      for (i = 0; i != v9; ++i)
      {
        if (*(_QWORD *)v124 != v10)
          objc_enumerationMutation(v8);
      }
      v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v123, v139, 16);
    }
    while (v9);
  }
  v13 = -[_anonymous_namespace_ componentConformingToProtocol:](v95, "componentConformingToProtocol:", &unk_1F0405B60);
  if (v13)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      v14 = (void *)v13;
    else
      v14 = 0;
  }
  else
  {
    v14 = 0;
  }
  v122 = BoundSkeleton;
  if (BoundSkeleton)
  {
    v16 = (void *)objc_opt_new();
    __p = 0;
    v120 = 0;
    v121 = 0;
    if (objc_msgSend(v16, "count"))
    {
      v89 = (uint64_t)a5;
      v98 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", objc_msgSend((id)objc_msgSend(BoundSkeleton, "jointPaths"), "count"));
      v17 = (uint64_t *)objc_msgSend(v14, "skeleton");
      v135 = v17;
      if (objc_msgSend(v14, "jointPaths"))
        v19 = (uint64_t *)v14;
      else
        v19 = v17;
      v20 = (void *)objc_msgSend(v19, "jointPaths");
      v133 = 0u;
      v134 = 0u;
      v131 = 0u;
      v132 = 0u;
      v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v131, v141, 16);
      obj = v16;
      v93 = (uint64_t)v14;
      v87 = (uint64_t)a3;
      v22 = 0;
      if (v21)
      {
        v23 = *(_QWORD *)v132;
        do
        {
          for (j = 0; j != v21; ++j)
          {
            if (*(_QWORD *)v132 != v23)
              objc_enumerationMutation(v20);
            v25 = *(_QWORD *)(*((_QWORD *)&v131 + 1) + 8 * j);
            v26 = objc_msgSend(*v18, "objectForKeyedSubscript:", v25);
            if (v26)
            {
              objc_msgSend(v98, "addObject:", v26);
            }
            else
            {
              if (!v22)
                v22 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", objc_msgSend(v20, "count"));
              objc_msgSend(v22, "addObject:", v25);
            }
          }
          v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v131, v141, 16);
        }
        while (v21);
        if (v22)
        {
          a3 = (void *)v87;
          v16 = obj;
          v14 = (void *)v93;
          if (objc_msgSend(v22, "count"))
          {
            v129 = 0u;
            v130 = 0u;
            v127 = 0u;
            v128 = 0u;
            v27 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v127, v140, 16);
            if (v27)
            {
              v28 = *(_QWORD *)v128;
              do
              {
                for (k = 0; k != v27; ++k)
                {
                  if (*(_QWORD *)v128 != v28)
                    objc_enumerationMutation(v22);
                  NSLog(CFSTR("Bad joint path detected for joint: %@"), *(_QWORD *)(*((_QWORD *)&v127 + 1) + 8 * k));
                }
                v27 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v127, v140, 16);
              }
              while (v27);
            }
          }
        }
        else
        {
          a3 = (void *)v87;
          v16 = obj;
          v14 = (void *)v93;
        }
      }

              v101,
              *((uint64_t *)&v101 + 1),
              v102,
              *((uint64_t *)&v102 + 1),
              v103,
              v104,
              v105,
              v106,
              v107,
              v108,
              v109,
              v110,
              v111,
              *((uint64_t *)&v111 + 1),
              v112,
              *((uint64_t *)&v112 + 1));
      v117 = 0u;
      v118 = 0u;
      v115 = 0u;
      v116 = 0u;
      v39 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v115, v138, 16);
      if (v39)
      {
        v40 = *(_QWORD *)v116;
        do
        {
          for (m = 0; m != v39; ++m)
          {
            if (*(_QWORD *)v116 != v40)
              objc_enumerationMutation(obja);
            v42 = *(_anonymous_namespace_ **)(*((_QWORD *)&v115 + 1) + 8 * m);
            v43 = (void *)objc_msgSend(a2, "objectForKeyedSubscript:", -[_anonymous_namespace_ path](v42, "path"));
            v44 = objc_msgSend(v43, "geometry");
            v49 = -[_anonymous_namespace_ componentConformingToProtocol:](v42, "componentConformingToProtocol:", &unk_1F0405B60);
            if (v42 != v95 && (v51 = (void *)v49) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
            {
              objc_msgSend(v51, "geometryBindTransform");
              v114[0] = v53;
              v114[1] = v54;
              v114[2] = v55;
              v114[3] = v56;
              -[SCNSkinner setBaseGeometryBindTransform:](v48, "setBaseGeometryBindTransform:", v114);
            }
            else
            {
              if (v94)
                objc_msgSend(v94, "geometryBindTransform");
              else
                memset(v141, 0, sizeof(v141));
              v113[0] = v57;
              v113[1] = v58;
              v113[2] = v59;
              v113[3] = v60;
              -[SCNSkinner setBaseGeometryBindTransform:](v48, "setBaseGeometryBindTransform:", v113);
            }
            -[SCNSkinner setSkeleton:](v48, "setSkeleton:", v97);
            objc_msgSend(v43, "setSkinner:", v48);
          }
          v16 = obja;
          v39 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v115, v138, 16);
        }
        while (v39);
        a3 = v88;
        a5 = v90;
        v14 = v94;
      }
      else
      {
        a5 = v90;
      }
    }
    else
    {
      v97 = 0;
    }

    if (__p)
    {
      v120 = __p;
      operator delete(__p);
    }
  }
  else
  {
    v97 = 0;
  }
  if (v14)
  {
    v61 = (_anonymous_namespace_ *)objc_msgSend(v14, "jointAnimation");
    if (v61)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        if (!v97)
          v97 = (void *)objc_msgSend(a2, "objectForKeyedSubscript:", -[_anonymous_namespace_ path](v95, "path"));
        v62 = objc_msgSend(v100, "objectForKeyedSubscript:", -[_anonymous_namespace_ name](v61, "name"));
        if (v62)
        {
          objc_msgSend(v97, "addAnimation:forKey:", v62, -[_anonymous_namespace_ name](v61, "name"));
          v63 = 1;
        }
        else
        {
          v63 = 0;
        }
        v111 = 0u;
        v112 = 0u;
        v109 = 0u;
        v110 = 0u;
        v64 = (void *)objc_msgSend(a3, "animations");
        v65 = objc_msgSend(v64, "countByEnumeratingWithState:objects:count:", &v109, v137, 16);
        if (v65)
        {
          v66 = *(_QWORD *)v110;
          do
          {
            for (n = 0; n != v65; ++n)
            {
              if (*(_QWORD *)v110 != v66)
                objc_enumerationMutation(v64);
              v68 = *(_anonymous_namespace_ **)(*((_QWORD *)&v109 + 1) + 8 * n);
              if (v68 != v61)
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  if (RootNodeName)
                  {
                    if (v72)
                    {
                      if (objc_msgSend(RootNodeName, "isEqualToString:", v72))
                      {
                        v73 = objc_msgSend(v100, "objectForKeyedSubscript:", -[_anonymous_namespace_ name](v68, "name"));
                        if (v73)
                        {
                          objc_msgSend(v97, "addAnimation:forKey:", v73, -[_anonymous_namespace_ name](v68, "name"));
                          v63 = 1;
                        }
                      }
                    }
                  }
                }
              }
            }
            v65 = objc_msgSend(v64, "countByEnumeratingWithState:objects:count:", &v109, v137, 16);
          }
          while (v65);
        }
        v74 = v122;
        if (v122)
        {
          if ((v63 & 1) != 0)
          {
            v107 = 0u;
            v108 = 0u;
            v105 = 0u;
            v106 = 0u;
            v76 = (void *)objc_msgSend(v74, "jointPaths");
            v77 = objc_msgSend(v76, "countByEnumeratingWithState:objects:count:", &v105, v136, 16);
            if (v77)
            {
              v78 = *(_QWORD *)v106;
              v79 = (__int128 *)MEMORY[0x1E0C83FF0];
              do
              {
                for (ii = 0; ii != v77; ++ii)
                {
                  if (*(_QWORD *)v106 != v78)
                    objc_enumerationMutation(v76);
                  v81 = (void *)objc_msgSend(*v75, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v105 + 1) + 8 * ii));
                  if (v81)
                  {
                    v82 = v79[1];
                    v83 = v79[2];
                    v84 = v79[3];
                    v101 = *v79;
                    v102 = v82;
                    v103 = v83;
                    v104 = v84;
                    objc_msgSend(v81, "setTransform:", &v101);
                  }
                }
                v77 = objc_msgSend(v76, "countByEnumeratingWithState:objects:count:", &v105, v136, 16);
              }
              while (v77);
            }
          }
        }
      }
    }
  }
}

void sub_1DCD39060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *__p;

  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void UniqueVertices(uint64_t a1, uint64_t *a2, char **a3, uint64_t a4, uint64_t a5, int a6, unint64_t a7, int a8, char a9)
{
  unint64_t v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  char **v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t i;
  int v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  int v43;
  int *v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  char *v49;
  int v50;
  int v51;
  int *v52;
  uint64_t v53;
  _DWORD *v54;
  int v55;
  uint64_t v56;
  int *v57;
  int *v58;
  int v59;
  int v60;
  int v61;
  char *v62;
  unint64_t v63;
  uint64_t j;
  uint64_t v65;
  char *v66;
  char *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  int v75;
  char *v76;
  char *v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  char *v82;
  char *v83;
  char *v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  int v90;
  uint64_t v91;
  int *v92;
  uint64_t v93;
  _DWORD *v95;
  uint64_t v98;
  unint64_t v99;
  int v100;
  _QWORD *v101;
  int v102;
  char **v103;

  v14 = a6;
  v15 = (_QWORD *)operator new[]();
  v98 = operator new[]();
  v16 = a6 + 1;
  v100 = a6;
  v17 = operator new[]();
  v18 = a3;
  v95 = (_DWORD *)v17;
  v99 = v14;
  v19 = a7 / v14;
  if ((int)(a7 / v14) < 1)
  {
LABEL_91:
    MEMORY[0x1DF0D41A8](v15, 0x1000C8000313F17, v18);
    MEMORY[0x1DF0D41A8](v98, 0x1000C8052888210);
    JUMPOUT(0x1DF0D41A8);
  }
  v20 = 0;
  v21 = 0;
  v22 = v16;
  v23 = (a6 - 1);
  v24 = (int)v23;
  v25 = v18 + 2;
  v26 = v23 & ~((int)v23 >> 31);
  v27 = v19;
  v28 = a6;
  v29 = v16;
  v30 = 4 * v99;
  v92 = (int *)(v17 + 4);
  v93 = v29;
  v91 = a6 - 1;
  v103 = v18;
  v101 = v18 + 2;
  v89 = v22;
  v90 = a8;
  v87 = (int)v23;
  v88 = v23;
  v86 = v26;
  while (1)
  {
    if (v100 <= 0)
    {
      v34 = *v15;
      v36 = *a2;
      v37 = *v15 * v99;
      if (*(_DWORD *)(*a2 + 4 * v37) != -1)
        goto LABEL_24;
    }
    else
    {
      for (i = 0; i != v100; ++i)
      {
        v32 = v21 + i * v19;
        if (a9)
          v32 = v20 + i;
        switch(a5)
        {
          case 1:
            v33 = *(unsigned __int8 *)(a4 + v32);
            goto LABEL_12;
          case 2:
            v33 = *(unsigned __int16 *)(a4 + 2 * v32);
            goto LABEL_12;
          case 4:
            v33 = *(unsigned int *)(a4 + 4 * v32);
            goto LABEL_12;
          case 8:
            v33 = *(_QWORD *)(a4 + 8 * v32);
LABEL_12:
            v15[i] = v33;
            break;
          default:
            break;
        }
      }
      v34 = *v15;
      v35 = (_DWORD *)v98;
      v36 = *a2;
      v37 = *v15 * v99;
      v38 = v30 * *v15;
      v39 = v100;
      do
      {
        *v35++ = *(_DWORD *)(v36 + v38);
        v38 += 4;
        --v39;
      }
      while (v39);
      if (*(_DWORD *)(v36 + 4 * v37) != -1)
      {
LABEL_24:
        v42 = (int *)v98;
        v43 = *(_DWORD *)(v98 + 4 * v24);
        v44 = (int *)(v15 + 1);
        v45 = v26;
        do
        {
          if (!v45)
            goto LABEL_85;
          v47 = *v44;
          v44 += 2;
          v46 = v47;
          v48 = *v42++;
          --v45;
        }
        while (v48 == v46);
        if (v43 < 0)
        {
          v62 = v18[1];
          v63 = ((v62 - *v18) >> 2) / v22;
        }
        else
        {
          v49 = *v18;
          v50 = *(_DWORD *)(v98 + 4 * v24);
          while (1)
          {
            v51 = v50;
            if (v100 < 0)
              break;
            v52 = (int *)&v49[4 * v50 * (int)v22];
            v53 = v93;
            v54 = v95;
            do
            {
              v55 = *v52++;
              *v54++ = v55;
              --v53;
            }
            while (v53);
            if (v100 < 2)
              break;
            v50 = v95[v99];
            v56 = v91;
            v57 = v92;
            v58 = (int *)(v15 + 1);
            while (1)
            {
              v60 = *v58;
              v58 += 2;
              v59 = v60;
              v61 = *v57++;
              if (v61 != v59)
                break;
              if (!--v56)
                goto LABEL_42;
            }
            if (v50 < 0)
              goto LABEL_43;
          }
          v51 = v43;
LABEL_42:
          LODWORD(v34) = v51 + a8;
          if (v51 + a8 != -1)
            goto LABEL_85;
LABEL_43:
          v62 = v18[1];
          v63 = ((v62 - *v18) >> 2) / v22;
          if ((v43 & 0x80000000) == 0)
          {
            *(_DWORD *)&(*v18)[4 * v100 + 4 * v51 * (int)v22] = v63;
            goto LABEL_45;
          }
        }
        *(_DWORD *)(v36 + 4 * (v99 - 1 + v37)) = v63;
LABEL_45:
        v102 = v63;
        if (v100 < 1)
        {
          v66 = v62;
        }
        else
        {
          for (j = 0; j != v100; ++j)
          {
            v65 = v15[j];
            if ((unint64_t)v62 >= *v25)
            {
              v67 = *v18;
              v68 = (v62 - *v18) >> 2;
              v69 = v68 + 1;
              if ((unint64_t)(v68 + 1) >> 62)
                goto LABEL_92;
              v70 = *v25 - (_QWORD)v67;
              if (v70 >> 1 > v69)
                v69 = v70 >> 1;
              if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFFCLL)
                v71 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v71 = v69;
              if (v71)
              {
                v72 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v25, v71);
                v18 = v103;
                v73 = v72;
                v67 = *v103;
                v62 = v103[1];
              }
              else
              {
                v73 = 0;
              }
              v74 = &v73[4 * v68];
              *(_DWORD *)v74 = v65;
              v66 = v74 + 4;
              while (v62 != v67)
              {
                v75 = *((_DWORD *)v62 - 1);
                v62 -= 4;
                *((_DWORD *)v74 - 1) = v75;
                v74 -= 4;
              }
              *v18 = v74;
              v18[1] = v66;
              v18[2] = &v73[4 * v71];
              if (v67)
              {
                operator delete(v67);
                v18 = v103;
              }
              v25 = v101;
              LODWORD(v63) = v102;
            }
            else
            {
              *(_DWORD *)v62 = v65;
              v66 = v62 + 4;
            }
            v18[1] = v66;
            v62 = v66;
          }
        }
        if ((unint64_t)v66 >= *v25)
        {
          v77 = *v18;
          v78 = (v66 - *v18) >> 2;
          v79 = v78 + 1;
          a8 = v90;
          if ((unint64_t)(v78 + 1) >> 62)
LABEL_92:
            abort();
          v80 = *v25 - (_QWORD)v77;
          if (v80 >> 1 > v79)
            v79 = v80 >> 1;
          if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFFCLL)
            v81 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v81 = v79;
          if (v81)
          {
            v82 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v25, v81);
            v18 = v103;
            v83 = v82;
            v77 = *v103;
            v66 = v103[1];
          }
          else
          {
            v83 = 0;
          }
          v84 = &v83[4 * v78];
          *(_DWORD *)v84 = -1;
          v76 = v84 + 4;
          while (v66 != v77)
          {
            v85 = *((_DWORD *)v66 - 1);
            v66 -= 4;
            *((_DWORD *)v84 - 1) = v85;
            v84 -= 4;
          }
          *v18 = v84;
          v18[1] = v76;
          v18[2] = &v83[4 * v81];
          if (v77)
          {
            operator delete(v77);
            v18 = v103;
          }
          v23 = v88;
          v22 = v89;
          v26 = v86;
          v24 = v87;
          v25 = v101;
          LODWORD(v63) = v102;
          v30 = 4 * v99;
          v27 = v19;
        }
        else
        {
          *(_DWORD *)v66 = -1;
          v76 = v66 + 4;
          v22 = v89;
          a8 = v90;
          v24 = v87;
          v23 = v88;
          v27 = v19;
          v26 = v86;
          v30 = 4 * v99;
        }
        LODWORD(v34) = v63 + a8;
        v18[1] = v76;
        goto LABEL_85;
      }
      v40 = 0;
      do
      {
        if (v40 == v23)
        {
          *(_DWORD *)(v36 + 4 * (v37 + v23)) = -1;
          ++v40;
        }
        else
        {
          v41 = v37 + v40++;
          *(_DWORD *)(v36 + 4 * v41) = v15[v40];
        }
      }
      while (v40 != v100);
    }
LABEL_85:
    switch(a5)
    {
      case 1:
        *(_BYTE *)(a1 + v21) = v34;
        break;
      case 2:
        *(_WORD *)(a1 + 2 * v21) = v34;
        break;
      case 4:
        *(_DWORD *)(a1 + 4 * v21) = v34;
        break;
      case 8:
        *(_QWORD *)(a1 + 8 * v21) = (int)v34;
        break;
      default:
        break;
    }
    ++v21;
    v20 += v28;
    if (v21 == v27)
      goto LABEL_91;
  }
}

id uniqueIndexBufferWithSCNGeometryElements(void *a1, int a2, std::vector<int> *a3, char **a4, _DWORD *a5)
{
  id v7;
  char v8;
  int v9;
  unint64_t v10;
  void *v11;
  unint64_t v12;
  unint64_t v13;
  void *v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  void *v20;
  uint64_t v21;
  unint64_t v22;
  void *v23;
  void *v24;
  std::vector<int>::value_type __u;

  *a5 = 1;
  v7 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  if (objc_msgSend(a1, "count"))
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    do
    {
      v11 = (void *)objc_msgSend(a1, "objectAtIndexedSubscript:", v10);
      if (objc_msgSend(v11, "indicesChannelCount") >= 2)
      {
        *a5 = objc_msgSend(v11, "indicesChannelCount");
        v8 = 1;
      }
      v12 = objc_msgSend((id)objc_msgSend(v11, "data"), "length");
      v9 += v12 / objc_msgSend(v11, "bytesPerIndex");
      ++v10;
    }
    while (v10 < objc_msgSend(a1, "count"));
    if ((v8 & 1) != 0)
    {
      __u = -1;
      std::vector<int>::assign(a3, v9, &__u);
      if (objc_msgSend(a1, "count"))
      {
        v13 = 0;
        do
        {
          v14 = (void *)objc_msgSend(a1, "objectAtIndexedSubscript:", v13);
          v15 = objc_msgSend(v14, "hasInterleavedIndicesChannels");
          v16 = objc_msgSend(v14, "indicesChannelCount");
          v17 = objc_msgSend(v14, "bytesPerIndex");
          v18 = objc_msgSend(v14, "primitiveCount");
          objc_msgSend((id)objc_msgSend(v14, "data"), "bytes");
          v19 = objc_msgSend((id)objc_msgSend(v14, "data"), "length");
          if (objc_msgSend(v14, "primitiveType") == 1 || objc_msgSend(v14, "primitiveType") != 4)
          {
            v21 = objc_msgSend((id)objc_msgSend(v14, "data"), "bytes");
          }
          else
          {
            v20 = (void *)objc_msgSend((id)objc_msgSend(v14, "data"), "subdataWithRange:", v18 * v17, objc_msgSend((id)objc_msgSend(v14, "data"), "length") - v18 * v17);
            v21 = objc_msgSend(v20, "bytes");
            v19 = objc_msgSend(v20, "length");
          }
          v22 = (v19 / v17);
          v23 = malloc_type_malloc(v22 / v16 * v17, 0xFF6C3F43uLL);
          UniqueVertices((uint64_t)v23, (uint64_t *)a3, a4, v21, v17, v16, v22, a2, v15);
          v24 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytesNoCopy:length:", v23, v22 / v16 * v17);
          objc_msgSend(v7, "addObject:", v24);

          ++v13;
        }
        while (v13 < objc_msgSend(a1, "count"));
      }
    }
  }
  return v7;
}

void std::vector<int>::assign(std::vector<int> *this, std::vector<int>::size_type __n, std::vector<int>::const_reference __u)
{
  uint64_t value;
  int *begin;
  std::vector<int>::size_type v8;
  unint64_t v9;
  std::vector<int>::pointer v10;
  int *v11;
  std::vector<int>::size_type v12;
  std::vector<int>::pointer end;
  std::vector<int>::size_type v14;
  std::vector<int>::size_type v15;
  int *v16;
  int *v17;
  std::vector<int>::size_type v18;

  value = (uint64_t)this->__end_cap_.__value_;
  begin = this->__begin_;
  if (__n <= (value - (uint64_t)begin) >> 2)
  {
    end = this->__end_;
    v14 = end - begin;
    if (v14 >= __n)
      v15 = __n;
    else
      v15 = end - begin;
    if (v15)
    {
      v16 = begin;
      do
      {
        *v16++ = *__u;
        --v15;
      }
      while (v15);
    }
    if (__n <= v14)
    {
      this->__end_ = &begin[__n];
    }
    else
    {
      v17 = &end[__n - v14];
      v18 = 4 * __n - 4 * v14;
      do
      {
        *end++ = *__u;
        v18 -= 4;
      }
      while (v18);
      this->__end_ = v17;
    }
  }
  else
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n >> 62)
      abort();
    v8 = value >> 1;
    if (value >> 1 <= __n)
      v8 = __n;
    if ((unint64_t)value >= 0x7FFFFFFFFFFFFFFCLL)
      v9 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v9 = v8;
    std::vector<float>::__vallocate[abi:nn180100](this, v9);
    v10 = this->__end_;
    v11 = &v10[__n];
    v12 = 4 * __n;
    do
    {
      *v10++ = *__u;
      v12 -= 4;
    }
    while (v12);
    this->__end_ = v11;
  }
}

void *remapVertexAttributeBuffer(void *a1, int a2, _QWORD *a3, _QWORD *a4, int a5, int a6, int a7, char *a8)
{
  int v11;
  void *result;
  uint64_t v13;
  uint64_t v14;
  int v15;
  char *v16;
  int v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  int v23;

  v11 = objc_msgSend(a1, "dataStride");
  result = (void *)objc_msgSend(a1, "dataOffset");
  v13 = (int)result;
  v23 = a6;
  if (a6 >= 1)
  {
    v14 = 0;
    v15 = a2 - 1;
    v16 = a8;
    do
    {
      if (a2)
        v17 = *(_DWORD *)(*a3 + 4 * v15);
      else
        v17 = v14;
      result = memcpy(v16, (const void *)(objc_msgSend((id)objc_msgSend(a1, "data"), "bytes") + v13 + (v17 * v11)), v11);
      ++v14;
      v16 += v11;
      v15 += a5;
    }
    while (v23 != v14);
  }
  if (a7 >= 1)
  {
    v18 = a7;
    v19 = &a8[v11 * (uint64_t)v23];
    v20 = 4 * a2;
    do
    {
      result = memcpy(v19, (const void *)(objc_msgSend((id)objc_msgSend(a1, "data"), "bytes")+ v13+ (*(_DWORD *)(*a4 + v20) * v11)), v11);
      v19 += v11;
      v20 += 4 * (a5 + 1);
      --v18;
    }
    while (v18);
  }
  return result;
}

void sub_1DCD3B318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1DCD3BC70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void setupMDLMaterialProperty(MDLMaterial *a1, NSString *a2, SCNMaterialProperty *a3, MDLMaterialSemantic a4)
{
  MDLMaterialProperty *v7;
  MDLMaterialProperty *v8;
  char isKindOfClass;
  id v10;
  float32x4_t v11;
  double v12;
  char v13;
  id v14;
  void *v15;
  double v16;
  double v17;
  float v18;
  double v19;
  char v20;
  id v21;
  __C3DImage *v22;
  id v23;
  int8x16_t v24;
  int64x2_t v25;
  int8x16_t v26;
  __int32 v27;
  __int32 v28;
  int8x16_t v29;
  int32x4_t v30;
  double v31;
  __C3DImage *v32;
  int8x16_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  double v37;
  double v38;
  double v39;
  double v40;
  void *v41;
  id v42;
  float32x4_t v43;
  int8x16_t v44;
  int64x2_t v45;
  int32x4_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int64x2_t v49;
  int32x4_t v50;
  int8x16_t v51;
  simd_float4x4 v52;

  v7 = -[MDLMaterial propertyNamed:](a1, "propertyNamed:", a2);
  v8 = v7;
  if (!v7)
    v8 = (MDLMaterialProperty *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC77A8]), "initWithName:semantic:", a2, a4);
  -[SCNMaterialProperty contents](a3, "contents");
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();
  v10 = -[SCNMaterialProperty contents](a3, "contents");
  if ((isKindOfClass & 1) != 0)
  {
    objc_msgSend(v10, "scn_colorComponentsForModelIO");
    v43 = v11;
    if (v11.f32[3] == 1.0)
    {
      -[MDLMaterialProperty setType:](v8, "setType:", 7);
      -[SCNMaterialProperty intensity](a3, "intensity");
      *(float *)&v12 = v12;
      -[MDLMaterialProperty setFloat3Value:](v8, "setFloat3Value:", *(double *)vmulq_n_f32(v43, *(float *)&v12).i64);
    }
    else
    {
      -[MDLMaterialProperty setType:](v8, "setType:", 8);
      -[SCNMaterialProperty intensity](a3, "intensity");
      *(float *)&v31 = v31;
      -[MDLMaterialProperty setFloat4Value:](v8, "setFloat4Value:", *(double *)vmulq_n_f32(v43, *(float *)&v31).i64);
    }
    goto LABEL_27;
  }
  objc_opt_class();
  v13 = objc_opt_isKindOfClass();
  v14 = -[SCNMaterialProperty contents](a3, "contents");
  v15 = v14;
  if ((v13 & 1) != 0)
  {
    if (v14)
    {
      -[MDLMaterialProperty setType:](v8, "setType:", 5);
      -[SCNMaterialProperty intensity](a3, "intensity");
      v17 = v16;
      objc_msgSend(v15, "floatValue");
      v19 = v17 * v18;
      *(float *)&v19 = v19;
      -[MDLMaterialProperty setFloatValue:](v8, "setFloatValue:", v19);
    }
    goto LABEL_27;
  }
  objc_opt_class();
  v20 = objc_opt_isKindOfClass();
  v21 = -[SCNMaterialProperty contents](a3, "contents");
  if ((v20 & 1) != 0)
  {
    if (!objc_msgSend((id)objc_msgSend(v21, "pathExtension"), "isEqualToString:", CFSTR("usdz")))
    {
      -[MDLMaterialProperty setType:](v8, "setType:", 2);
      -[MDLMaterialProperty setURLValue:](v8, "setURLValue:", -[SCNMaterialProperty contents](a3, "contents"));
      goto LABEL_27;
    }
    v22 = -[SCNMaterialProperty getC3DImageRef](a3, "getC3DImageRef");
    if (!v22)
      goto LABEL_27;
    v23 = _C3DImageToMDLTexture(v22, 0);
    if (a3)
    {
      -[SCNMaterialProperty contentsTransform](a3, "contentsTransform");
      v26 = v48;
      v25 = v49;
      v27 = v48.i32[3];
      v28 = v49.i32[1];
      v30 = v50;
      v29 = v51;
LABEL_21:
      v33 = vextq_s8(v29, (int8x16_t)vtrn2q_s32(v30, (int32x4_t)v29), 4uLL);
      v34 = (int8x16_t)vzip2q_s64((int64x2_t)v30, v25);
      v24 = vextq_s8(v26, v26, 8uLL);
      *(int8x8_t *)v24.i8 = vext_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v24.i8, 4uLL);
      goto LABEL_25;
    }
    v29 = 0uLL;
    v24.i64[0] = 0;
    v28 = 0;
    goto LABEL_24;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    -[MDLMaterialProperty setType:](v8, "setType:", 1);
    -[MDLMaterialProperty setStringValue:](v8, "setStringValue:", -[SCNMaterialProperty contents](a3, "contents"));
    goto LABEL_27;
  }
  v32 = -[SCNMaterialProperty getC3DImageRef](a3, "getC3DImageRef");
  if (v32)
  {
    v23 = _C3DImageToMDLTexture(v32, 0);
    if (a3)
    {
      -[SCNMaterialProperty contentsTransform](a3, "contentsTransform");
      v26 = v44;
      v25 = v45;
      v27 = v44.i32[3];
      v28 = v45.i32[1];
      v30 = v46;
      v29 = v47;
      goto LABEL_21;
    }
    v29 = 0uLL;
    v24.i64[0] = 0;
    v28 = 0;
LABEL_24:
    v30.i32[0] = 0;
    v25.i32[0] = 0;
    v27 = 0;
    v26 = 0uLL;
    v33 = 0uLL;
    v34 = 0uLL;
LABEL_25:
    v35 = vextq_s8(vextq_s8(v26, v26, 4uLL), v24, 0xCuLL);
    v35.i32[3] = v27;
    v25.i32[1] = v28;
    v25.i64[1] = v34.i64[1];
    v36 = vextq_s8(v33, v34, 8uLL);
    v36.i32[0] = v30.i32[0];
    v52.columns[0] = (simd_float4)v35;
    v52.columns[1] = (simd_float4)v25;
    v52.columns[2] = (simd_float4)v36;
    v52.columns[3] = (simd_float4)vextq_s8(vextq_s8(v29, v29, 4uLL), v33, 0xCuLL);
    v37 = convertUVTranformForModelIO(&v52);
    if (v23)
    {
      v41 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC7818]), "initWithMatrix:", v37, v38, v39, v40);
      v42 = objc_alloc_init(MEMORY[0x1E0CC7810]);
      objc_msgSend(v42, "setTransform:", v41);
      objc_msgSend(v42, "setTexture:", v23);
      -[MDLMaterialProperty setType:](v8, "setType:", 3);
      -[MDLMaterialProperty setTextureSamplerValue:](v8, "setTextureSamplerValue:", v42);

    }
  }
LABEL_27:
  if (!v7)
  {
    if (v8)

  }
}

uint64_t **`anonymous namespace'::_makeSkelNodes(void *a1, uint64_t *a2, uint64_t **a3)
{
  void *v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  void *v8;
  _OWORD *v9;
  uint64_t *v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t i;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t j;
  void *v42;
  uint64_t **result;
  uint64_t v44;
  uint64_t *v45;
  uint64_t **v46;
  void *v47;
  uint64_t *v48;
  id v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  _OWORD v58[4];
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t *v63;
  _BYTE v64[128];
  _BYTE v65[128];
  _BYTE v66[128];
  uint64_t v67;

  v46 = a3;
  v47 = a1;
  v67 = *MEMORY[0x1E0C80C00];
  v63 = a2;
  v4 = (void *)objc_opt_new();
  v5 = objc_msgSend((id)objc_msgSend(a2, "jointPaths"), "count");
  v6 = v5;
  v7 = v5;
  v8 = (void *)objc_msgSend(a2, "jointRestTransforms", MEMORY[0x1E0C80A78](v5));
  v48 = &v44 - 8 * v7;
  if (objc_msgSend(v8, "getFloat4x4Array:maxCount:", v48, v7) < (unint64_t)v6)
  {
    v9 = (_OWORD *)MEMORY[0x1E0C83FF0];
    v10 = v48;
    do
    {
      v11 = v9[1];
      *(_OWORD *)v10 = *v9;
      *((_OWORD *)v10 + 1) = v11;
      v12 = v9[3];
      *((_OWORD *)v10 + 2) = v9[2];
      *((_OWORD *)v10 + 3) = v12;
      v10 += 8;
      --v7;
    }
    while (v7);
  }
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v45 = a2;
  v49 = (id)objc_msgSend(a2, "jointPaths");
  v13 = objc_msgSend(v49, "countByEnumeratingWithState:objects:count:", &v59, v66, 16);
  if (v13)
  {
    v14 = v13;
    v15 = 0;
    v16 = *(_QWORD *)v60;
    do
    {
      for (i = 0; i != v14; ++i)
      {
        if (*(_QWORD *)v60 != v16)
          objc_enumerationMutation(v49);
        v18 = *(void **)(*((_QWORD *)&v59 + 1) + 8 * i);
        v19 = objc_msgSend(v18, "rangeOfString:options:", CFSTR("/"), 4);
        v20 = (uint64_t)v18;
        if (v19 != 0x7FFFFFFFFFFFFFFFLL)
          v20 = objc_msgSend(v18, "substringFromIndex:", v19 + 1);
        if (v20)
        {
          v21 = (void *)objc_opt_new();
          objc_msgSend(v21, "setName:", v20);
          if (v21)
          {
            objc_msgSend(v4, "setObject:forKeyedSubscript:", v21, v18);
            v22 = &v48[8 * (unint64_t)(v15 + i)];
            v23 = *((_OWORD *)v22 + 1);
            v24 = *((_OWORD *)v22 + 2);
            v25 = *((_OWORD *)v22 + 3);
            v58[0] = *(_OWORD *)v22;
            v58[1] = v23;
            v58[2] = v24;
            v58[3] = v25;
            objc_msgSend(v21, "setTransform:", v58);

          }
        }
      }
      v14 = objc_msgSend(v49, "countByEnumeratingWithState:objects:count:", &v59, v66, 16);
      v15 += i;
    }
    while (v14);
  }
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v26 = (void *)objc_msgSend(v45, "jointPaths");
  v27 = objc_msgSend(v26, "countByEnumeratingWithState:objects:count:", &v54, v65, 16);
  if (v27)
  {
    v28 = v27;
    v29 = *(_QWORD *)v55;
    do
    {
      v30 = 0;
      do
      {
        if (*(_QWORD *)v55 != v29)
          objc_enumerationMutation(v26);
        v31 = *(void **)(*((_QWORD *)&v54 + 1) + 8 * v30);
        v32 = objc_msgSend(v31, "rangeOfString:options:", CFSTR("/"), 4);
        if (v32)
          v33 = v32 == 0x7FFFFFFFFFFFFFFFLL;
        else
          v33 = 1;
        if (!v33)
        {
          v34 = objc_msgSend(v31, "substringToIndex:", v32);
          if (v34)
          {
            v35 = v34;
            if (objc_msgSend(v4, "valueForKey:", v34))
              objc_msgSend((id)objc_msgSend(v4, "objectForKeyedSubscript:", v35), "addChildNode:", objc_msgSend(v4, "objectForKeyedSubscript:", v31));
          }
        }
        ++v30;
      }
      while (v28 != v30);
      v36 = objc_msgSend(v26, "countByEnumeratingWithState:objects:count:", &v54, v65, 16);
      v28 = v36;
    }
    while (v36);
  }
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v37 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v50, v64, 16);
  v38 = v47;
  if (v37)
  {
    v39 = v37;
    v40 = *(_QWORD *)v51;
    do
    {
      for (j = 0; j != v39; ++j)
      {
        if (*(_QWORD *)v51 != v40)
          objc_enumerationMutation(v4);
        v42 = (void *)objc_msgSend(v4, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v50 + 1) + 8 * j));
        if (!objc_msgSend(v42, "parentNode"))
          objc_msgSend(v38, "addChildNode:", v42);
      }
      v39 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v50, v64, 16);
    }
    while (v39);
  }
  *result = (uint64_t *)v4;
  result[1] = (uint64_t *)v38;
  return result;
}

SCNGeometrySource *`anonymous namespace'::boneWeightsFromMDL(_anonymous_namespace_ *this, MDLMesh *a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = -[_anonymous_namespace_ vertexCount](this, "vertexCount");
  v4 = (void *)-[_anonymous_namespace_ vertexAttributeDataForAttributeNamed:](this, "vertexAttributeDataForAttributeNamed:", *MEMORY[0x1E0CC7740]);
  v5 = objc_msgSend(v4, "dataStart");
  v6 = objc_msgSend(v4, "format") & 0xFFF;
  return +[SCNGeometrySource geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:](SCNGeometrySource, "geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:", objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v5, 4 * v6 * v3), CFSTR("kGeometrySourceSemanticBoneWeights"), v3, 1, v6, 4, 0, 4 * v6);
}

SCNGeometrySource *`anonymous namespace'::boneIndicesFromMDL(_anonymous_namespace_ *this, MDLMesh *a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = -[_anonymous_namespace_ vertexCount](this, "vertexCount");
  v4 = (void *)-[_anonymous_namespace_ vertexAttributeDataForAttributeNamed:](this, "vertexAttributeDataForAttributeNamed:", *MEMORY[0x1E0CC7738]);
  v5 = objc_msgSend(v4, "dataStart");
  v6 = objc_msgSend(v4, "format") & 0xFFF;
  return +[SCNGeometrySource geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:](SCNGeometrySource, "geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:", objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v5, 2 * v6 * v3), CFSTR("kGeometrySourceSemanticBoneIndices"), v3, 0, v6, 2, 0, 2 * v6);
}

void sub_1DCD3D624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a49, 8);
  _Unwind_Resume(a1);
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void sub_1DCD3DA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, _QWORD *a12, uint64_t a13, char a14, _QWORD *a15)
{
  std::__tree<char>::destroy((uint64_t)&a11, a12);
  std::__tree<char>::destroy((uint64_t)&a14, a15);
  _Unwind_Resume(a1);
}

SCNGeometryElement *_indexedGeometryElement(MDLSubmesh *a1)
{
  unint64_t v2;

  if (!-[MDLSubmesh faceIndexing](a1, "faceIndexing")
    || -[MDLSubmesh geometryType](a1, "geometryType") != MDLGeometryTypeVariableTopology
    || !-[MDLSubmeshTopology faceTopology](-[MDLSubmesh topology](a1, "topology"), "faceTopology")
    || !objc_msgSend(-[MDLSubmesh indexBuffer](a1, "indexBuffer"), "length"))
  {
    return 0;
  }
  v2 = (unint64_t)-[MDLSubmesh indexType](a1, "indexType") >> 3;
  if (v2 == 4)
    return _createIndexedGeometryElement<unsigned int>(a1);
  if (v2 != 2)
  {
    if (v2 == 1)
      return _createIndexedGeometryElement<unsigned char>(a1);
    return 0;
  }
  return _createIndexedGeometryElement<unsigned short>(a1);
}

SCNGeometryElement *_createIndexedGeometryElement<unsigned char>(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char v10;
  char *v11;
  unint64_t v12;
  int64_t v13;
  uint64_t v14;
  unint64_t v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  int64_t v26;
  uint64_t v27;
  unint64_t v28;
  size_t v29;
  char *v30;
  char *v31;
  char *v32;
  char v33;
  SCNGeometryElement *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t i;
  uint64_t v39;
  uint64_t v40;
  void *__p;
  char *v42;
  char *v43;

  v2 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "faceTopology"), "map"), "bytes");
  if (!v2)
    return 0;
  v3 = v2;
  v4 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "map"), "bytes");
  if (!v4)
    return 0;
  v5 = v4;
  v6 = objc_msgSend((id)objc_msgSend(a1, "topology"), "faceCount");
  v7 = objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "length");
  __p = 0;
  v42 = 0;
  v43 = 0;
  std::vector<unsigned char>::reserve((unint64_t *)&__p, v7 + v6);
  v39 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = v42;
    do
    {
      v10 = *(_BYTE *)(v3 + v8);
      if (v9 >= v43)
      {
        v12 = (unint64_t)__p;
        v13 = v9 - (_BYTE *)__p;
        v14 = v9 - (_BYTE *)__p + 1;
        if (v14 < 0)
          abort();
        v15 = v43 - (_BYTE *)__p;
        if (2 * (v43 - (_BYTE *)__p) > (unint64_t)v14)
          v14 = 2 * v15;
        if (v15 >= 0x3FFFFFFFFFFFFFFFLL)
          v16 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v16 = v14;
        if (v16)
          v17 = (char *)operator new(v16);
        else
          v17 = 0;
        v18 = &v17[v13];
        v19 = &v17[v13];
        *v19 = v10;
        v11 = v19 + 1;
        if (v9 != (char *)v12)
        {
          v20 = &v9[~v12];
          do
          {
            v21 = *--v9;
            (v20--)[(_QWORD)v17] = v21;
          }
          while (v9 != (char *)v12);
          v9 = (char *)__p;
          v18 = v17;
        }
        __p = v18;
        v42 = v11;
        v43 = &v17[v16];
        if (v9)
          operator delete(v9);
        v6 = v39;
      }
      else
      {
        *v9 = v10;
        v11 = v9 + 1;
      }
      v42 = v11;
      ++v8;
      v9 = v11;
    }
    while (v8 != v6);
  }
  if (v7)
  {
    v22 = 0;
    v23 = v42;
    do
    {
      if (v23 >= v43)
      {
        v25 = (unint64_t)__p;
        v26 = v23 - (_BYTE *)__p;
        v27 = v23 - (_BYTE *)__p + 1;
        if (v27 < 0)
          abort();
        v28 = v43 - (_BYTE *)__p;
        if (2 * (v43 - (_BYTE *)__p) > (unint64_t)v27)
          v27 = 2 * v28;
        if (v28 >= 0x3FFFFFFFFFFFFFFFLL)
          v29 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v29 = v27;
        if (v29)
          v30 = (char *)operator new(v29);
        else
          v30 = 0;
        v31 = &v30[v26];
        v30[v26] = *(_BYTE *)(v5 + v22);
        v24 = (uint64_t)&v30[v26 + 1];
        if (v23 != (char *)v25)
        {
          v32 = &v23[~v25];
          do
          {
            v33 = *--v23;
            (v32--)[(_QWORD)v30] = v33;
          }
          while (v23 != (char *)v25);
          v23 = (char *)__p;
          v31 = v30;
        }
        __p = v31;
        v42 = &v30[v26 + 1];
        v43 = &v30[v29];
        if (v23)
          operator delete(v23);
      }
      else
      {
        *v23 = *(_BYTE *)(v5 + v22);
        v24 = (uint64_t)(v23 + 1);
      }
      v42 = (char *)v24;
      ++v22;
      v23 = (char *)v24;
    }
    while (v22 != v7);
  }
  else
  {
    v24 = (uint64_t)v42;
  }
  v35 = objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", __p, v24 - (_QWORD)__p, v39);
  v36 = 0;
  for (i = 0; i < objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "count"); ++i)
  {
    if (v36 < objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue"))v36 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue");
  }
  v34 = +[SCNGeometryElement geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:](SCNGeometryElement, "geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:", v35, 4, v40, v36 + 1, 1, 1);
  if (__p)
  {
    v42 = (char *)__p;
    operator delete(__p);
  }
  return v34;
}

void sub_1DCD3E2A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

SCNGeometryElement *_createIndexedGeometryElement<unsigned short>(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  __int16 v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  __int16 v18;
  char *v19;
  SCNGeometryElement *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  char *v30;
  __int16 v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t i;
  unint64_t v36;
  void *__p;
  char *v38;
  char *v39;

  v2 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "faceTopology"), "map"), "bytes");
  if (!v2)
    return 0;
  v3 = v2;
  v4 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "map"), "bytes");
  if (!v4)
    return 0;
  v5 = v4;
  v6 = objc_msgSend((id)objc_msgSend(a1, "topology"), "faceCount");
  __p = 0;
  v38 = 0;
  v39 = 0;
  v36 = objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "length");
  std::vector<unsigned short>::reserve(&__p, v6 + (v36 >> 1));
  if (v6)
  {
    v7 = 0;
    v8 = v38;
    do
    {
      v9 = *(unsigned __int8 *)(v3 + v7);
      if (v8 >= v39)
      {
        v11 = (char *)__p;
        v12 = v8 - (_BYTE *)__p;
        if (v8 - (_BYTE *)__p <= -3)
          abort();
        v13 = v12 >> 1;
        if (v39 - (_BYTE *)__p <= (unint64_t)((v12 >> 1) + 1))
          v14 = v13 + 1;
        else
          v14 = v39 - (_BYTE *)__p;
        if ((unint64_t)(v39 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFFELL)
          v15 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>((uint64_t)&v39, v15);
          v11 = (char *)__p;
          v8 = v38;
        }
        else
        {
          v16 = 0;
        }
        v17 = &v16[2 * v13];
        *(_WORD *)v17 = v9;
        v10 = v17 + 2;
        while (v8 != v11)
        {
          v18 = *((_WORD *)v8 - 1);
          v8 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p = v17;
        v38 = v10;
        v39 = &v16[2 * v15];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *(_WORD *)v8 = v9;
        v10 = v8 + 2;
      }
      v38 = v10;
      ++v7;
      v8 = v10;
    }
    while (v7 != v6);
  }
  if (v36 > 1)
  {
    v21 = 0;
    if (v36 >> 1 <= 1)
      v22 = 1;
    else
      v22 = v36 >> 1;
    v23 = v38;
    do
    {
      if (v23 >= v39)
      {
        v24 = (char *)__p;
        v25 = v23 - (_BYTE *)__p;
        if (v23 - (_BYTE *)__p <= -3)
          abort();
        v26 = v25 >> 1;
        if (v39 - (_BYTE *)__p <= (unint64_t)((v25 >> 1) + 1))
          v27 = v26 + 1;
        else
          v27 = v39 - (_BYTE *)__p;
        if ((unint64_t)(v39 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFFELL)
          v28 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v28 = v27;
        if (v28)
        {
          v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>((uint64_t)&v39, v28);
          v24 = (char *)__p;
          v23 = v38;
        }
        else
        {
          v29 = 0;
        }
        v30 = &v29[2 * v26];
        *(_WORD *)v30 = *(_WORD *)(v5 + 2 * v21);
        v19 = v30 + 2;
        while (v23 != v24)
        {
          v31 = *((_WORD *)v23 - 1);
          v23 -= 2;
          *((_WORD *)v30 - 1) = v31;
          v30 -= 2;
        }
        __p = v30;
        v38 = v19;
        v39 = &v29[2 * v28];
        if (v24)
          operator delete(v24);
      }
      else
      {
        *(_WORD *)v23 = *(_WORD *)(v5 + 2 * v21);
        v19 = v23 + 2;
      }
      v38 = v19;
      ++v21;
      v23 = v19;
    }
    while (v21 != v22);
  }
  else
  {
    v19 = v38;
  }
  v32 = objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", __p, v19 - (_BYTE *)__p, v36);
  v33 = 0;
  for (i = 0; i < objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "count"); ++i)
  {
    if (v33 < objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue"))v33 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue");
  }
  v20 = +[SCNGeometryElement geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:](SCNGeometryElement, "geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:", v32, 4, v6, v33 + 1, 1, 2);
  if (__p)
  {
    v38 = (char *)__p;
    operator delete(__p);
  }
  return v20;
}

void sub_1DCD3E5FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

SCNGeometryElement *_createIndexedGeometryElement<unsigned int>(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::vector<int>::pointer end;
  int v9;
  int *v10;
  std::vector<int>::pointer begin;
  uint64_t v12;
  unint64_t v13;
  int64_t v14;
  unint64_t v15;
  char *v16;
  int *v17;
  int v18;
  int *v19;
  SCNGeometryElement *v20;
  uint64_t v21;
  uint64_t v22;
  std::vector<int>::pointer v23;
  std::vector<int>::pointer v24;
  uint64_t v25;
  unint64_t v26;
  int64_t v27;
  unint64_t v28;
  char *v29;
  int *v30;
  int v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t i;
  unint64_t v36;
  std::vector<int> v37;

  v2 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "topology"), "faceTopology"), "map"), "bytes");
  if (!v2)
    return 0;
  v3 = v2;
  v4 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "map"), "bytes");
  if (!v4)
    return 0;
  v5 = v4;
  v6 = objc_msgSend((id)objc_msgSend(a1, "topology"), "faceCount");
  memset(&v37, 0, sizeof(v37));
  v36 = objc_msgSend((id)objc_msgSend(a1, "indexBuffer"), "length");
  std::vector<unsigned int>::reserve(&v37, v6 + (v36 >> 2));
  if (v6)
  {
    v7 = 0;
    end = v37.__end_;
    do
    {
      v9 = *(unsigned __int8 *)(v3 + v7);
      if (end >= v37.__end_cap_.__value_)
      {
        begin = v37.__begin_;
        v12 = end - v37.__begin_;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 62)
          abort();
        v14 = (char *)v37.__end_cap_.__value_ - (char *)v37.__begin_;
        if (((char *)v37.__end_cap_.__value_ - (char *)v37.__begin_) >> 1 > v13)
          v13 = v14 >> 1;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL)
          v15 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)&v37.__end_cap_, v15);
          begin = v37.__begin_;
          end = v37.__end_;
        }
        else
        {
          v16 = 0;
        }
        v17 = (int *)&v16[4 * v12];
        *v17 = v9;
        v10 = v17 + 1;
        while (end != begin)
        {
          v18 = *--end;
          *--v17 = v18;
        }
        v37.__begin_ = v17;
        v37.__end_ = v10;
        v37.__end_cap_.__value_ = (int *)&v16[4 * v15];
        if (begin)
          operator delete(begin);
      }
      else
      {
        *end = v9;
        v10 = end + 1;
      }
      v37.__end_ = v10;
      ++v7;
      end = v10;
    }
    while (v7 != v6);
  }
  if (v36 > 3)
  {
    v21 = 0;
    if (v36 >> 2 <= 1)
      v22 = 1;
    else
      v22 = v36 >> 2;
    v23 = v37.__end_;
    do
    {
      if (v23 >= v37.__end_cap_.__value_)
      {
        v24 = v37.__begin_;
        v25 = v23 - v37.__begin_;
        v26 = v25 + 1;
        if ((unint64_t)(v25 + 1) >> 62)
          abort();
        v27 = (char *)v37.__end_cap_.__value_ - (char *)v37.__begin_;
        if (((char *)v37.__end_cap_.__value_ - (char *)v37.__begin_) >> 1 > v26)
          v26 = v27 >> 1;
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFFCLL)
          v28 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v28 = v26;
        if (v28)
        {
          v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)&v37.__end_cap_, v28);
          v24 = v37.__begin_;
          v23 = v37.__end_;
        }
        else
        {
          v29 = 0;
        }
        v30 = (int *)&v29[4 * v25];
        *v30 = *(_DWORD *)(v5 + 4 * v21);
        v19 = v30 + 1;
        while (v23 != v24)
        {
          v31 = *--v23;
          *--v30 = v31;
        }
        v37.__begin_ = v30;
        v37.__end_ = v19;
        v37.__end_cap_.__value_ = (int *)&v29[4 * v28];
        if (v24)
          operator delete(v24);
      }
      else
      {
        *v23 = *(_DWORD *)(v5 + 4 * v21);
        v19 = v23 + 1;
      }
      v37.__end_ = v19;
      ++v21;
      v23 = v19;
    }
    while (v21 != v22);
  }
  else
  {
    v19 = v37.__end_;
  }
  v32 = objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v37.__begin_, (char *)v19 - (char *)v37.__begin_, v36);
  v33 = 0;
  for (i = 0; i < objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "count"); ++i)
  {
    if (v33 < objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue"))v33 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "faceIndexing"), "objectAtIndexedSubscript:", i), "unsignedIntValue");
  }
  v20 = +[SCNGeometryElement geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:](SCNGeometryElement, "geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:", v32, 4, v6, v33 + 1, 1, 4);
  if (v37.__begin_)
  {
    v37.__end_ = v37.__begin_;
    operator delete(v37.__begin_);
  }
  return v20;
}

void sub_1DCD3E958(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *`anonymous namespace'::_normalizedKeyTimes(void *a1, double a2, double a3)
{
  void *v6;
  unint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[128];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v6 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", objc_msgSend(a1, "count"));
  v7 = objc_msgSend(a1, "count");
  if (a3 != 0.0 && v7 > 1)
  {
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v9 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
    if (v9)
    {
      v10 = v9;
      v11 = *(_QWORD *)v16;
      do
      {
        v12 = 0;
        do
        {
          if (*(_QWORD *)v16 != v11)
            objc_enumerationMutation(a1);
          objc_msgSend(*(id *)(*((_QWORD *)&v15 + 1) + 8 * v12), "doubleValue");
          objc_msgSend(v6, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", (v13 - a2) / a3));
          ++v12;
        }
        while (v10 != v12);
        v10 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
      }
      while (v10);
    }
  }
  else
  {
    objc_msgSend(v6, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", 0.0));
  }
  return v6;
}

void *`anonymous namespace'::_valuesWithMDLAnimatedVector3Array(uint64_t a1, int a2, int a3, int a4)
{
  int v6;
  void *v8;
  double v9;
  double v10;
  double v11;
  _DWORD *v12;
  uint64_t v13;

  v6 = a2;
  v8 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", a2);
  if (v6 >= 1)
  {
    v12 = (_DWORD *)(a1 + 16 * a4 + 8);
    v13 = 16 * a3;
    do
    {
      LODWORD(v9) = *(v12 - 2);
      LODWORD(v10) = *(v12 - 1);
      LODWORD(v11) = *v12;
      objc_msgSend(v8, "addObject:", objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithSCNVector3:", v9, v10, v11));
      v12 = (_DWORD *)((char *)v12 + v13);
      --v6;
    }
    while (v6);
  }
  return v8;
}

uint64_t `anonymous namespace'::_getBoundSkeleton(_anonymous_namespace_ *this, MDLObject *a2)
{
  uint64_t v2;
  void *v3;

  v2 = -[_anonymous_namespace_ componentConformingToProtocol:](this, "componentConformingToProtocol:", &unk_1F0405B60);
  if (v2 && (v3 = (void *)v2, objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    return objc_msgSend(v3, "skeleton");
  else
    return 0;
}

uint64_t `anonymous namespace'::_findMeshes(void *a1, float32x4_t *a2, void *a3, void **a4)
{
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  float32x4_t v13;
  float32x4_t v14;
  unint64_t v15;
  float32x4_t *v16;
  float32x4_t v17;
  float32x4_t v18;
  _OWORD *f32;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  float32x4_t *v25;
  char *v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t *v29;
  char *v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  void *v34;
  uint64_t result;
  MDLObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _anonymous_namespace_ *v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _OWORD v49[4];
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  _BYTE v54[128];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(a1, "transform"))
  {
    v43 = *a2;
    v44 = a2[1];
    v41 = a2[3];
    v42 = a2[2];
    objc_msgSend((id)objc_msgSend(a1, "transform"), "matrix");
    v8 = 0;
    v49[0] = v9;
    v49[1] = v10;
    v49[2] = v11;
    v49[3] = v12;
    do
    {
      *(float32x4_t *)((char *)&v50 + v8 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v43, COERCE_FLOAT(v49[v8])), v44, *(float32x2_t *)&v49[v8], 1), v42, (float32x4_t)v49[v8], 2), v41, (float32x4_t)v49[v8], 3);
      ++v8;
    }
    while (v8 != 4);
  }
  else
  {
    v13 = a2[1];
    v50 = *a2;
    v51 = v13;
    v14 = a2[3];
    v52 = a2[2];
    v53 = v14;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(a3, "addObject:", a1);
    v15 = (unint64_t)a4[2];
    v16 = (float32x4_t *)a4[1];
    if ((unint64_t)v16 >= v15)
    {
      v20 = ((char *)v16 - (_BYTE *)*a4) >> 6;
      v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 58)
        abort();
      v22 = v15 - (_QWORD)*a4;
      if (v22 >> 5 > v21)
        v21 = v22 >> 5;
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFC0)
        v23 = 0x3FFFFFFFFFFFFFFLL;
      else
        v23 = v21;
      if (v23)
        v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<simd_float4x4>>((uint64_t)(a4 + 2), v23);
      else
        v24 = 0;
      v25 = (float32x4_t *)&v24[64 * v20];
      v26 = &v24[64 * v23];
      v27 = v51;
      *v25 = v50;
      v25[1] = v27;
      v28 = v53;
      v25[2] = v52;
      v25[3] = v28;
      f32 = (_OWORD *)v25[4].f32;
      v30 = (char *)*a4;
      v29 = (float32x4_t *)a4[1];
      if (v29 != *a4)
      {
        do
        {
          v31 = v29[-4];
          v32 = v29[-3];
          v33 = v29[-1];
          v25[-2] = v29[-2];
          v25[-1] = v33;
          v25[-4] = v31;
          v25[-3] = v32;
          v25 -= 4;
          v29 -= 4;
        }
        while (v29 != (float32x4_t *)v30);
        v29 = (float32x4_t *)*a4;
      }
      *a4 = v25;
      a4[1] = f32;
      a4[2] = v26;
      if (v29)
        operator delete(v29);
    }
    else
    {
      v17 = v51;
      *v16 = v50;
      v16[1] = v17;
      v18 = v53;
      v16[2] = v52;
      v16[3] = v18;
      f32 = (_OWORD *)v16[4].f32;
    }
    a4[1] = f32;
  }
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v34 = (void *)objc_msgSend(a1, "children");
  result = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v45, v54, 16);
  v37 = result;
  if (result)
  {
    v38 = *(_QWORD *)v46;
    do
    {
      v39 = 0;
      do
      {
        if (*(_QWORD *)v46 != v38)
          objc_enumerationMutation(v34);
        v40 = *(_anonymous_namespace_ **)(*((_QWORD *)&v45 + 1) + 8 * v39);
        ++v39;
      }
      while (v37 != v39);
      result = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v45, v54, 16);
      v37 = result;
    }
    while (result);
  }
  return result;
}

uint64_t **std::map<MDLSkeleton *,`anonymous namespace'::SkelNodes>::operator[](uint64_t **a1, uint64_t **a2)
{
  uint64_t *v3;
  uint64_t **v4;
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;

  v4 = a1 + 1;
  v3 = a1[1];
  v5 = *a2;
  if (v3)
  {
    while (1)
    {
      while (1)
      {
        v6 = (uint64_t **)v3;
        v7 = v3[4];
        if ((unint64_t)v5 >= v7)
          break;
        v3 = *v6;
        v4 = v6;
        if (!*v6)
          goto LABEL_9;
      }
      if (v7 >= (unint64_t)v5)
        break;
      v3 = v6[1];
      if (!v3)
      {
        v4 = v6 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v6 = a1 + 1;
LABEL_9:
    v8 = (uint64_t *)v6;
    v6 = (uint64_t **)operator new(0x38uLL);
    v6[5] = 0;
    v6[6] = 0;
    v6[4] = v5;
    *v6 = 0;
    v6[1] = 0;
    v6[2] = v8;
    *v4 = (uint64_t *)v6;
    v9 = (uint64_t *)**a1;
    v10 = (uint64_t *)v6;
    if (v9)
    {
      *a1 = v9;
      v10 = *v4;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6 + 5;
}

void *`anonymous namespace'::boneInverseTransformsFromMDL(_anonymous_namespace_ *this, MDLAnimationBindComponent *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float64x2_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,__int128 a24,__int128 a25,__int128 a26,__int128 a27,__int128 a28,__int128 a29,__int128 a30,__int128 a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t i;
  unint64_t v42;
  void *v43;
  uint64_t j;
  uint64_t v45;
  __int128 *v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  void *v51;
  const simd_double4x4 *v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  _OWORD var30[4];

  a35 = *MEMORY[0x1E0C80C00];
  v36 = (void *)-[_anonymous_namespace_ skeleton](this, "skeleton");
  v37 = objc_msgSend((id)objc_msgSend(v36, "jointBindTransforms"), "elementCount");
  v38 = -[_anonymous_namespace_ jointPaths](this, "jointPaths");
  v39 = v38;
  if (v38)
  {
    v38 = objc_opt_new();
    v40 = (void *)v38;
    if (v37)
    {
      for (i = 0; i != v37; ++i)
        v38 = objc_msgSend(v40, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", i), objc_msgSend((id)objc_msgSend(v36, "jointPaths"), "objectAtIndexedSubscript:", i));
    }
  }
  else
  {
    v40 = 0;
  }
  v42 = (unint64_t)(var30 - 8 * v37 + 1) & 0xFFFFFFFFFFFFFFE0;
  objc_msgSend((id)objc_msgSend(v36, "jointBindTransforms", MEMORY[0x1E0C80A78](v38)), "getDouble4x4Array:maxCount:", v42, v37);
  if (v39)
    v37 = objc_msgSend((id)-[_anonymous_namespace_ jointPaths](this, "jointPaths"), "count");
  v43 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", v37);
  if (v37)
  {
    for (j = 0; j != v37; ++j)
    {
      v45 = j;
      if (v39)
        v45 = objc_msgSend((id)objc_msgSend(v40, "objectForKeyedSubscript:", objc_msgSend((id)-[_anonymous_namespace_ jointPaths](this, "jointPaths"), "objectAtIndexedSubscript:", j)), "unsignedLongValue");
      v46 = (__int128 *)(v42 + (v45 << 7));
      v47 = v46[5];
      a28 = v46[4];
      a29 = v47;
      v48 = v46[7];
      a30 = v46[6];
      a31 = v48;
      v49 = v46[1];
      a24 = *v46;
      a25 = v49;
      v50 = v46[3];
      a26 = v46[2];
      a27 = v50;
      __invert_d4();
      v51 = (void *)MEMORY[0x1E0CB3B18];
      var30[0] = v53;
      var30[1] = v54;
      var30[2] = v55;
      var30[3] = v56;
      objc_msgSend(v43, "addObject:", objc_msgSend(v51, "valueWithSCNMatrix4:", var30));
    }
  }
  if (v40)

  return v43;
}

double `anonymous namespace'::_convertDouble2Float(float64x2_t *this, const simd_double4x4 *a2)
{
  double result;

  *(_QWORD *)&result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*this), this[1]).u64[0];
  return result;
}

void *`anonymous namespace'::_getRootNodeName(_anonymous_namespace_ *this, MDLPackedJointAnimation *a2)
{
  void *v3;
  void *v4;
  uint64_t v5;

  if (!objc_msgSend((id)-[_anonymous_namespace_ jointPaths](this, "jointPaths"), "count"))
    return 0;
  v3 = (void *)objc_msgSend((id)-[_anonymous_namespace_ jointPaths](this, "jointPaths"), "objectAtIndexedSubscript:", 0);
  v4 = v3;
  if (!v3)
    return v4;
  if (!objc_msgSend(v3, "length"))
    return 0;
  if (objc_msgSend((id)objc_msgSend(v4, "substringToIndex:", 1), "isEqualToString:", CFSTR("/")))
    v4 = (void *)objc_msgSend(v4, "substringFromIndex:", 1);
  v5 = objc_msgSend(v4, "rangeOfString:", CFSTR("/"));
  if (v5 != 0x7FFFFFFFFFFFFFFFLL)
    return (void *)objc_msgSend(v4, "substringToIndex:", v5);
  return v4;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<simd_float4x4>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(a2 << 6);
}

void std::__tree<std::__value_type<MDLSkeleton *,`anonymous namespace'::SkelNodes>,std::__map_value_compare<MDLSkeleton *,std::__value_type<MDLSkeleton *,`anonymous namespace'::SkelNodes>,std::less<MDLSkeleton *>,true>,std::allocator<std::__value_type<MDLSkeleton *,`anonymous namespace'::SkelNodes>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    operator delete(a1);
  }
}

double convertUVTranformForModelIO(const simd_float4x4 *a1)
{
  uint64_t v1;
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  int8x16_t v5;
  int8x16_t v6;
  int32x2_t v7;
  float32x4_t v8;
  simd_float4 v9;
  float32x4_t v10;
  float32x2_t v11;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int32x4_t v20;
  float32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  uint64_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  uint64_t v34;
  float32x4_t v35;
  uint64_t v36;
  float32x4_t v37;
  __int128 v39;
  __int128 v40;
  float32x4_t v41;
  simd_float4 v42;
  __int128 v43;
  __int128 v44;
  float32x4_t v45;
  simd_float4 v46;

  v1 = 0;
  v2 = *(float32x4_t *)MEMORY[0x1E0C83FF0];
  v3 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 16);
  v4 = (float32x4_t)a1->columns[1];
  v5 = (int8x16_t)vmulq_f32((float32x4_t)a1->columns[0], (float32x4_t)a1->columns[0]);
  *(float32x2_t *)v5.i8 = vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL));
  v6 = (int8x16_t)vmulq_f32(v4, v4);
  *(float32x2_t *)v6.i8 = vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  v7 = (int32x2_t)vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v5.i8, *(int32x2_t *)v6.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v5.i8, *(int32x2_t *)v6.i8)));
  v8 = (float32x4_t)a1->columns[2];
  v9 = a1->columns[3];
  v10 = vmulq_f32(v8, v8);
  v11 = (float32x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v10, 8uLL).u64[0];
  v11.f32[0] = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v10.f32, v11)));
  *(int32x2_t *)v10.f32 = v7;
  v10.i64[1] = __PAIR64__(1.0, v11.u32[0]);
  __asm { FMOV            V5.4S, #1.0 }
  v17 = vdivq_f32(_Q5, v10);
  v18.i64[0] = 0;
  v18.i64[1] = v17.u32[2];
  v19 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 32);
  v20 = *(int32x4_t *)(MEMORY[0x1E0C83FF0] + 48);
  v21 = vdivq_f32((float32x4_t)a1->columns[0], (float32x4_t)vdupq_lane_s32(v7, 0));
  v22 = (int32x4_t)vdivq_f32(v4, (float32x4_t)vdupq_lane_s32(v7, 1));
  v23 = (int32x4_t)vdivq_f32(v8, (float32x4_t)vdupq_lane_s32((int32x2_t)v11, 0));
  v24 = vzip1q_s32((int32x4_t)v21, v23);
  v25 = vzip2q_s32((int32x4_t)v21, v23);
  v26 = vzip1q_s32(v22, v20);
  v27 = vzip2q_s32(v22, v20);
  v28 = (float32x4_t)vzip1q_s32(v24, v26);
  v29 = (float32x4_t)vzip1q_s32(v25, v27);
  v41 = v8;
  v42 = v9;
  do
  {
    *(__int128 *)((char *)&v43 + v1) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v2, COERCE_FLOAT(*(__int128 *)((char *)&v39 + v1))), v3, *(float32x2_t *)((char *)&v39 + v1), 1), v19, *(float32x4_t *)((char *)&v39 + v1), 2), (float32x4_t)xmmword_1DD007890, *(float32x4_t *)((char *)&v39 + v1), 3);
    v1 += 16;
  }
  while (v1 != 64);
  v30 = 0;
  v32.i64[0] = 0;
  v32.i32[2] = 0;
  v31.i32[0] = 0;
  v31.i64[1] = 0;
  v31.i32[1] = v17.i32[1];
  v32.i32[3] = v17.i32[3];
  v33 = (float32x4_t)vzip2q_s32(v24, v26);
  v39 = v43;
  v40 = v44;
  v41 = v45;
  v42 = v46;
  do
  {
    *(__int128 *)((char *)&v43 + v30) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v17.u32[0], COERCE_FLOAT(*(__int128 *)((char *)&v39 + v30))), v31, *(float32x2_t *)((char *)&v39 + v30), 1), v18, *(float32x4_t *)((char *)&v39 + v30), 2), v32, *(float32x4_t *)((char *)&v39 + v30), 3);
    v30 += 16;
  }
  while (v30 != 64);
  v34 = 0;
  v35 = (float32x4_t)vzip2q_s32(v25, v27);
  v39 = v43;
  v40 = v44;
  v41 = v45;
  v42 = v46;
  do
  {
    *(__int128 *)((char *)&v43 + v34) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v28, COERCE_FLOAT(*(__int128 *)((char *)&v39 + v34))), v33, *(float32x2_t *)((char *)&v39 + v34), 1), v29, *(float32x4_t *)((char *)&v39 + v34), 2), v35, *(float32x4_t *)((char *)&v39 + v34), 3);
    v34 += 16;
  }
  while (v34 != 64);
  v36 = 0;
  v39 = v43;
  v40 = v44;
  v41 = v45;
  v42 = v46;
  do
  {
    *(__int128 *)((char *)&v43 + v36) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v2, COERCE_FLOAT(*(__int128 *)((char *)&v39 + v36))), v3, *(float32x2_t *)((char *)&v39 + v36), 1), v19, *(float32x4_t *)((char *)&v39 + v36), 2), (float32x4_t)xmmword_1DD0078A0, *(float32x4_t *)((char *)&v39 + v36), 3);
    v36 += 16;
  }
  while (v36 != 64);
  v37 = vmulq_n_f32(v21, *(float *)v7.i32);
  v37.i32[1] = vnegq_f32(v37).i32[1];
  return *(double *)v37.i64;
}

uint64_t **std::__tree<std::__value_type<unsigned long long,float>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,float>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,float>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  _QWORD *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = operator new(0x30uLL);
    v11[4] = **a4;
    *((_DWORD *)v11 + 10) = 0;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *std::__tree<std::__value_type<unsigned int,float>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,float>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int *a2, uint64_t a3, unsigned int **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unsigned int v8;
  uint64_t **v9;
  unsigned int v10;
  uint64_t *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v11 + 28) = **a4;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

char *std::vector<float>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(4 * a2);
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  v5 = (char *)a1[1];
  v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    v6 = *a1;
    v7 = &v5[-*a1];
    v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0)
      abort();
    v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (unint64_t)operator new(v10);
    else
      v11 = 0;
    v12 = &v7[v11];
    v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      v11 = (unint64_t)v12;
    }
    else
    {
      v14 = &v5[~v6];
      do
      {
        v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
      operator delete(v5);
  }
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  int v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 2);
    if (v10 >> 62)
      abort();
    v11 = v9 >> 2;
    v12 = v5 - v8;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void std::vector<unsigned char>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2;
  char *v5;
  _BYTE *v6;
  char *v7;
  _BYTE *v8;
  char *v9;
  char v10;

  v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0)
      abort();
    v5 = (char *)a1[1];
    v6 = operator new(__sz);
    v7 = &v5[(_QWORD)v6 - v2];
    v8 = v7;
    if (v5 != (char *)v2)
    {
      v9 = &v5[~v2];
      do
      {
        v10 = *--v5;
        (v9--)[(_QWORD)v6] = v10;
      }
      while (v5 != (char *)v2);
      v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
      operator delete((void *)v2);
  }
}

void std::vector<unsigned short>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int16 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFELL];
    v9 = &v6[2 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_WORD *)v11 - 1);
        v11 -= 2;
        *((_WORD *)v12 - 1) = v13;
        v12 -= 2;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(2 * a2);
}

void std::vector<unsigned int>::reserve(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::__compressed_pair<int *> *p_end_cap;
  int *value;
  int64_t v5;
  char *v6;
  int *v7;
  uint64_t v8;
  int *v9;
  std::vector<int>::pointer begin;
  int *end;
  int *v12;
  int v13;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62)
      abort();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)p_end_cap, __n);
    v7 = (int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = (int *)&v6[4 * v8];
    begin = this->__begin_;
    end = this->__end_;
    v12 = v7;
    if (end != this->__begin_)
    {
      v12 = v7;
      do
      {
        v13 = *--end;
        *--v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
      operator delete(begin);
  }
}

void OUTLINED_FUNCTION_0_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

C3D::RenderPass *C3D::SSAORaytracePass::SSAORaytracePass(C3D::RenderPass *a1, C3D::RenderGraph *a2, C3D::Pass *a3, uint64_t a4)
{
  C3D::RenderPass *result;

  result = C3D::RenderPass::RenderPass(a1, a2, a3);
  *(_QWORD *)result = off_1EA599738;
  *((_QWORD *)result + 31) = a4;
  return result;
}

const char *C3D::SSAORaytracePass::name(C3D::SSAORaytracePass *this)
{
  return "SSAORaytracePass";
}

float32x4_t C3D::SSAORaytracePass::setup(C3D::SSAORaytracePass *this)
{
  uint64_t v2;
  C3D::PassDescriptor *v3;
  C3D::PassDescriptor *v4;
  float32x4_t result;
  int EyeCount;
  unint64_t v7;
  __n128 ViewportAtIndex;
  int32x2_t v9;
  __int128 v10;
  int v11;

  C3D::Pass::setInputCount(this, 2u);
  C3D::Pass::setOutputCount(this, 1u);
  *(_QWORD *)(C3D::PassDescriptor::inputAtIndex((C3D::SSAORaytracePass *)((char *)this + 32), 0) + 8) = "SSAO-DepthNormal";
  *(_QWORD *)(C3D::PassDescriptor::inputAtIndex((C3D::SSAORaytracePass *)((char *)this + 32), 1u) + 8) = "SSAO-MinMaxOffset";
  v2 = C3D::PassDescriptor::outputAtIndex((C3D::SSAORaytracePass *)((char *)this + 32), 0);
  *(_BYTE *)(v2 + 65) = 0;
  C3D::Pass::parentColorDesc(this, (uint64_t)&v10);
  *(_OWORD *)(v2 + 16) = v10;
  *(_DWORD *)(v2 + 32) = v11;
  *(_WORD *)(v2 + 28) = 115;
  v3 = (C3D::PassDescriptor *)C3D::Pass::descriptor(**((C3D::Pass ***)this + 31));
  *(_WORD *)(v2 + 16) = (unint64_t)*(unsigned __int16 *)(C3D::PassDescriptor::outputAtIndex(v3, 0) + 16)
                      / *(_QWORD *)(*((_QWORD *)this + 31) + 16);
  v4 = (C3D::PassDescriptor *)C3D::Pass::descriptor(**((C3D::Pass ***)this + 31));
  *(_WORD *)(v2 + 18) = (unint64_t)*(unsigned __int16 *)(C3D::PassDescriptor::outputAtIndex(v4, 0) + 18)
                      / *(_QWORD *)(*((_QWORD *)this + 31) + 16);
  *(_WORD *)(v2 + 66) &= 0xFFFCu;
  if (*(_BYTE *)(v2 + 24) == 5)
  {
    *((_WORD *)this + 19) = 6;
  }
  else if (C3DEngineContextGetEyeCount(*((_QWORD *)this + 2)) >= 2)
  {
    EyeCount = C3DEngineContextGetEyeCount(*((_QWORD *)this + 2));
    *((_WORD *)this + 19) = EyeCount;
    *((_BYTE *)this + 121) = 1;
    if (EyeCount)
    {
      v7 = 0;
      do
      {
        ViewportAtIndex = C3DEngineContextGetViewportAtIndex(*((_QWORD *)this + 2), v7);
        *(float *)v9.i32 = (float)*(unint64_t *)(*((_QWORD *)this + 31) + 16);
        result = vdivq_f32((float32x4_t)ViewportAtIndex, (float32x4_t)vdupq_lane_s32(v9, 0));
        *((float32x4_t *)this + v7++ + 8) = result;
      }
      while (v7 < *((unsigned __int16 *)this + 19));
    }
  }
  return result;
}

void C3D::SSAORaytracePass::compile(C3D::SSAORaytracePass *this)
{
  uint64_t RenderContext;
  void *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  C3D::RenderGraphResourceManager *v7;
  uint64_t v8;
  _QWORD *v9;
  id v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  RenderContext = C3DEngineContextGetRenderContext(*((_QWORD *)this + 2));
  v3 = (void *)-[SCNMTLRenderContext resourceManager](RenderContext);
  v4 = *(unsigned __int8 *)(*((_QWORD *)this + 31) + 24) | (2 * *(unsigned __int8 *)(*((_QWORD *)this + 31) + 25)) | (4 * *(_QWORD *)(*((_QWORD *)this + 31) + 16)) | (*(_QWORD *)(*((_QWORD *)this + 31) + 8) << 6);
  v5 = 0xC6A4A7935BD1E995
     * ((*(uint64_t (**)(C3D::SSAORaytracePass *))(*(_QWORD *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v4) ^ ((0xC6A4A7935BD1E995 * v4) >> 47))));
  v6 = (0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v5 ^ (v5 >> 47))) >> 47);
  v7 = *(C3D::RenderGraphResourceManager **)(*((_QWORD *)this + 3) + 128);
  v8 = C3D::RenderGraphResourceManager::get(v7, v6);
  *((_QWORD *)this + 30) = v8;
  if (!v8)
  {
    v9 = (_QWORD *)operator new();
    *v9 = &off_1EA59A378;
    v9[1] = 0;
    v9[2] = 0;
    v9[3] = 0;
    *((_QWORD *)this + 30) = v9;
    C3D::RenderGraphResourceManager::set((uint64_t)v7, v6, (uint64_t)v9);
    v10 = objc_alloc_init(MEMORY[0x1E0CC6AA0]);
    v11 = *((_QWORD *)this + 30);
    v12 = *(void **)(v11 + 24);
    *(_QWORD *)(v11 + 24) = v10;
    if (v12)

    objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", *((_QWORD *)this + 31) + 8, 29, CFSTR("SSAOSampleCount"));
    objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", *((_QWORD *)this + 31) + 16, 29, CFSTR("SSAODownSample"));
    objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", *((_QWORD *)this + 31) + 24, 53, CFSTR("SSAOCameraOrtho"));
    objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", *((_QWORD *)this + 31) + 25, 53, CFSTR("SSAOVRRendering"));
    v13 = *((_QWORD *)this + 30);
    *((_QWORD *)&v18 + 1) = objc_msgSend((id)-[SCNMTLResourceManager libraryManager]((uint64_t)v3), "frameworkLibrary", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0);
    *(_QWORD *)&v19 = 115;
    *((_QWORD *)&v20 + 1) = C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24);
    *((_QWORD *)&v21 + 1) = CFSTR("scn_draw_fullscreen_triangle_vertex");
    *(_QWORD *)&v22 = CFSTR("scn_ssao_compute");
    v14 = objc_msgSend(v3, "newRenderPipelineStateWithDesc:", &v17);
    v15 = *(void **)(v13 + 16);
    if (v15 != (void *)v14)
    {
      v16 = v14;
      if (v15)

      *(_QWORD *)(v13 + 16) = v16;
    }
  }
}

void C3D::SSAORaytracePass::execute(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  float32x4_t *PointOfView;
  const __CFDictionary *Camera;
  uint64_t v7;
  float v8;
  double v9;
  float v10;
  uint64_t v11;
  int32x2_t v12;
  float32x4_t v13;
  float32x4_t v14;
  unint64_t v15;
  uint64_t v16;
  float32x4_t v17;
  uint64_t v18;
  void **v19;
  void **v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float32x2_t v37;
  __n128 ViewportAtIndex;
  float32x4_t v39;
  _OWORD v40[2];
  int v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;

  v4 = *(_QWORD *)a2;
  PointOfView = C3DEngineContextGetPointOfView(a1[2]);
  if (PointOfView)
  {
    Camera = C3DNodeGetCamera((uint64_t)PointOfView);
    if (Camera)
    {
      v7 = (uint64_t)Camera;
      ViewportAtIndex = C3DEngineContextGetViewportAtIndex(a1[2], *(unsigned __int16 *)(a2 + 16));
      v39 = vmulq_n_f32((float32x4_t)ViewportAtIndex, C3DEngineContextGetSuperSamplingFactor(a1[2]));
      v8 = fmax(C3DCameraGetScreenSpaceAmbientOcclusionRadius(v7) * 1000.0, 0.001);
      v42 = v8;
      v43 = v8 * v8;
      v9 = fmax(C3DCameraGetScreenSpaceAmbientOcclusionIntensity(v7), 0.0);
      v10 = v9 / powf(v8, 6.0);
      v45 = v10;
      v46 = fmaxf(C3DCameraGetScreenSpaceAmbientOcclusionDepthThreshold(v7), 0.0);
      v47 = fmaxf(C3DCameraGetScreenSpaceAmbientOcclusionNormalThreshold(v7), 0.0);
      v44 = fmaxf(C3DCameraGetScreenSpaceAmbientOcclusionBias(v7), 0.0);
      v41 = 1140457472;
      v11 = a1[31];
      *(float *)v12.i32 = (float)*(unint64_t *)(v11 + 16);
      v13 = (float32x4_t)vdupq_lane_s32(v12, 0);
      v37 = (float32x2_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 8uLL).u64[0];
      *(float32x2_t *)v14.f32 = vdiv_f32(v37, *(float32x2_t *)v13.f32);
      v14.i64[1] = v14.i64[0];
      v13.i64[0] = vdivq_f32(v39, v13).u64[0];
      v13.i64[1] = vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v39, 0), v14).i64[1];
      v40[1] = v13;
      v15 = C3D::DrawNodesPass::getCullingContext(*(C3D::DrawNodesPass **)v11)
          + ((unint64_t)*(unsigned __int16 *)(a2 + 16) << 6);
      LODWORD(v16) = *(_DWORD *)(v15 + 1360);
      *(float32x2_t *)v17.f32 = vdiv_f32((float32x2_t)0xC000000040000000, v37);
      v17.i64[1] = 0x3F800000BF800000;
      HIDWORD(v16) = *(_DWORD *)(v15 + 1380);
      v40[0] = vdivq_f32(v17, (float32x4_t)vdupq_lane_s64(v16, 0));
      v18 = objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(a1[30] + 16), "state");
      if (*(_QWORD *)(v4 + 3376) != v18)
      {
        *(_QWORD *)(v4 + 3376) = v18;
        objc_msgSend(*(id *)(v4 + 3392), "setRenderPipelineState:", v18);
      }
      SCNMTLRenderCommandEncoder::setFragmentBytes((SCNMTLRenderCommandEncoder *)v4, v40, 0x40uLL, 0);
      v19 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 0);
      SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v19, 0);
      v20 = C3D::Pass::inputTextureAtIndex((C3D::Pass *)a1, 1u);
      SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v20, 1uLL);
      SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v4);
    }
    else if ((C3D::SSAORaytracePass::execute(C3D::RenderArgs const&)::done & 1) == 0)
    {
      C3D::SSAORaytracePass::execute(C3D::RenderArgs const&)::done = 1;
      v29 = scn_default_log();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        C3D::SSAORaytracePass::execute(v29, v30, v31, v32, v33, v34, v35, v36);
    }
  }
  else if ((C3D::SSAORaytracePass::execute(C3D::RenderArgs const&)::done & 1) == 0)
  {
    C3D::SSAORaytracePass::execute(C3D::RenderArgs const&)::done = 1;
    v21 = scn_default_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      C3D::SSAORaytracePass::execute(v21, v22, v23, v24, v25, v26, v27, v28);
  }
}

void C3D::SSAORaytracePassResource::~SSAORaytracePassResource(C3D::SSAORaytracePassResource *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1EA59A378;
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)

  v3 = (void *)*((_QWORD *)this + 2);
  if (v3)

}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1EA59A378;
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)

  v3 = (void *)*((_QWORD *)this + 2);
  if (v3)

  JUMPOUT(0x1DF0D41C0);
}

uint64_t C3DMeshElementGetEmptyElement()
{
  if (C3DMeshElementGetEmptyElement_onceToken != -1)
    dispatch_once(&C3DMeshElementGetEmptyElement_onceToken, &__block_literal_global_3_0);
  return emptyMeshElement;
}

CFTypeRef C3DMeshElementInitIndexedWithMTLBuffer(uint64_t a1, char a2, int a3, char a4, char a5, const void *a6, char a7)
{
  CFTypeRef result;

  C3DMeshElementSetType(a1, a2);
  *(_BYTE *)(a1 + 130) = a4;
  *(_BYTE *)(a1 + 131) = a5;
  *(_DWORD *)(a1 + 104) = a3;
  __SetIndexes(a1, 0, a7);
  free(*(void **)(a1 + 120));
  *(_QWORD *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 128) = 0;
  result = CFRetain(a6);
  *(_QWORD *)(a1 + 136) = result;
  return result;
}

void C3DMeshElementInit(uint64_t a1, char a2, int a3, const void *a4, char a5)
{
  C3DMeshElementInitIndexed(a1, a2, a3, 1, 1, a4, a5);
}

uint64_t C3DMeshElementCreateCopy(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = C3DMeshElementCreate();
  __C3DMeshElementCopy(a1, v10, 0);
  return v10;
}

void __C3DMeshElementCopy(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFData *v22;
  CFDataRef Copy;
  CFDataRef v24;
  CFTypeRef v25;
  const __CFData *v26;
  CFTypeRef v27;
  size_t v28;
  void *v29;
  size_t v30;
  void *v31;

  if (!a1 && (v6 = scn_default_log(), os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)))
  {
    C3DGeometryCopy_cold_4(v6, v7, v8, v9, v10, v11, v12, v13);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v14 = scn_default_log();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    C3DGeometryCopy_cold_3(v14, v15, v16, v17, v18, v19, v20, v21);
LABEL_6:
  *(_WORD *)(a2 + 80) = *(_WORD *)(a1 + 80);
  *(_BYTE *)(a2 + 88) = *(_BYTE *)(a1 + 88);
  v22 = *(const __CFData **)(a1 + 96);
  if (a3 && v22)
  {
    Copy = CFDataCreateCopy(0, v22);
    v24 = *(CFDataRef *)(a2 + 96);
    if (v24 != Copy)
    {
      if (v24)
      {
        CFRelease(v24);
        *(_QWORD *)(a2 + 96) = 0;
      }
      if (Copy)
        v25 = CFRetain(Copy);
      else
        v25 = 0;
      *(_QWORD *)(a2 + 96) = v25;
    }
    CFRelease(Copy);
  }
  else
  {
    v26 = *(const __CFData **)(a2 + 96);
    if (v26 != v22)
    {
      if (v26)
      {
        CFRelease(v26);
        *(_QWORD *)(a2 + 96) = 0;
        v22 = *(const __CFData **)(a1 + 96);
      }
      if (v22)
        v27 = CFRetain(v22);
      else
        v27 = 0;
      *(_QWORD *)(a2 + 96) = v27;
    }
  }
  *(_DWORD *)(a2 + 104) = *(_DWORD *)(a1 + 104);
  free(*(void **)(a2 + 112));
  *(_QWORD *)(a2 + 112) = 0;
  if (*(_QWORD *)(a1 + 112))
  {
    v28 = 4 * *(unsigned int *)(a1 + 104);
    v29 = malloc_type_malloc(v28, 0x4F8682EFuLL);
    *(_QWORD *)(a2 + 112) = v29;
    memcpy(v29, *(const void **)(a1 + 112), v28);
  }
  free(*(void **)(a2 + 120));
  *(_QWORD *)(a2 + 120) = 0;
  if (*(_QWORD *)(a1 + 120))
  {
    v30 = 2 * *(unsigned __int16 *)(a1 + 128);
    v31 = malloc_type_malloc(v30, 0xECD56CC0uLL);
    *(_QWORD *)(a2 + 120) = v31;
    memcpy(v31, *(const void **)(a1 + 120), v30);
  }
  *(_DWORD *)(a2 + 128) = *(_DWORD *)(a1 + 128);
  C3DEntityCopyTo(a1, (CFTypeRef *)a2);
}

uint64_t C3DMeshElementCreateDeepCopy(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryCreateCopy_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = C3DMeshElementCreate();
  __C3DMeshElementCopy(a1, v10, 1);
  return v10;
}

CFTypeRef C3DMeshElementSetPrimitiveNormals(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(CFTypeRef *)(a1 + 168);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 168) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 168) = result;
  }
  return result;
}

uint64_t C3DMeshElementGetPrimitiveNormals(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 168);
}

uint64_t C3DMeshElementCreateByMergingElements(CFArrayRef theArray)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFIndex Count;
  uint64_t v11;
  CFIndex v12;
  unsigned __int8 *ValueAtIndex;
  char DoubleSided;
  uint64_t IndexCount;
  int Type;
  char v17;
  uint64_t v18;
  NSObject *v19;
  CFIndex i;
  unsigned __int8 *v21;
  uint64_t v22;
  uint64_t v23;
  const void *PrimitiveNormals;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  UInt8 *v27;
  CFIndex j;
  CFDataRef *v29;
  CFIndex Length;
  const UInt8 *BytePtr;
  unint64_t IndexCountPerPrimitive;
  uint64_t v33;
  NSObject *v34;

  if (!theArray)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreateByMergingElements_cold_3(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  Count = CFArrayGetCount(theArray);
  if (!Count)
    return 0;
  v11 = Count;
  if (Count < 1)
  {
LABEL_9:
    LODWORD(v12) = 0;
    ValueAtIndex = 0;
  }
  else
  {
    v12 = 0;
    while (1)
    {
      ValueAtIndex = (unsigned __int8 *)CFArrayGetValueAtIndex(theArray, v12);
      if (C3DMeshElementGetType((uint64_t)ValueAtIndex) < 6)
        break;
      if (v11 == ++v12)
        goto LABEL_9;
    }
  }
  DoubleSided = C3DMeshElementGetDoubleSided((uint64_t)ValueAtIndex);
  IndexCount = C3DMeshElementGetIndexCount((uint64_t)ValueAtIndex);
  Type = C3DMeshElementGetType((uint64_t)ValueAtIndex);
  v17 = Type;
  v18 = ValueAtIndex[80];
  if (Type == 1)
  {
    v19 = scn_default_log();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      C3DMeshElementCreateByMergingElements_cold_2();
  }
  for (i = (v12 + 1); v11 > i; ++i)
  {
    v21 = (unsigned __int8 *)CFArrayGetValueAtIndex(theArray, i);
    if (C3DMeshElementGetType((uint64_t)v21) <= 5)
    {
      v22 = C3DMeshElementGetIndexCount((uint64_t)v21);
      if ((_DWORD)v18 != v21[80])
      {
        v34 = scn_default_log();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          C3DMeshElementCreateByMergingElements_cold_1();
        return 0;
      }
      IndexCount += v22;
    }
  }
  v23 = C3DMeshElementCreate();
  PrimitiveNormals = (const void *)C3DMeshElementGetPrimitiveNormals((uint64_t)ValueAtIndex);
  C3DMeshElementSetPrimitiveNormals(v23, PrimitiveNormals);
  C3DMeshElementSetDoubleSided(v23, DoubleSided);
  C3DMeshElementSetType(v23, v17);
  Mutable = CFDataCreateMutable(0, IndexCount * v18);
  CFDataSetLength(Mutable, IndexCount * v18);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (v11 >= 1)
  {
    v27 = MutableBytePtr;
    for (j = 0; j != v11; ++j)
    {
      v29 = (CFDataRef *)CFArrayGetValueAtIndex(theArray, j);
      if (C3DMeshElementGetType((uint64_t)v29) <= 5)
      {
        Length = CFDataGetLength(v29[12]);
        BytePtr = CFDataGetBytePtr(v29[12]);
        memcpy(v27, BytePtr, Length);
        v27 += Length;
      }
    }
  }
  IndexCountPerPrimitive = C3DMeshElementGetIndexCountPerPrimitive(v23);
  if (IndexCountPerPrimitive <= 1)
    v33 = 1;
  else
    v33 = IndexCountPerPrimitive;
  *(_DWORD *)(v23 + 104) = IndexCount / v33;
  __SetIndexes(v23, Mutable, v18);
  free(*(void **)(v23 + 120));
  *(_QWORD *)(v23 + 120) = 0;
  *(_WORD *)(v23 + 128) = 0;
  CFRelease(Mutable);
  return v23;
}

BOOL C3DMeshElementTypeDefinesTopology(unsigned int a1)
{
  return a1 < 6;
}

BOOL C3DMeshElementGetDoubleSided(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_BYTE *)(a1 + 81) != 0;
}

void C3DMeshElementSetDoubleSided(uint64_t a1, char a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_BYTE *)(a1 + 81) = a2;
}

uint64_t C3DMeshElementGetIndexCountPerPrimitive(uint64_t a1)
{
  unint64_t v1;
  NSObject *v3;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = *(char *)(a1 + 88);
  if (v1 < 4)
    return qword_1DD0078F0[v1];
  v3 = scn_default_log();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 136315138;
    v5 = "C3DMeshElementGetIndexCountPerPrimitive";
    _os_log_impl(&dword_1DCCB8000, v3, OS_LOG_TYPE_DEFAULT, "Warning: %s does not support non-renderable topologies.", (uint8_t *)&v4, 0xCu);
  }
  return 0;
}

void C3DMeshElementSetPrimitives(uint64_t a1, int a2, CFTypeRef cf, char a4)
{
  *(_DWORD *)(a1 + 104) = a2;
  __SetIndexes(a1, cf, a4);
  free(*(void **)(a1 + 120));
  *(_QWORD *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 128) = 0;
}

BOOL C3DMeshElementTypeDefinesSurface(char a1)
{
  return (a1 & 0xFA) == 0;
}

_QWORD *C3DMeshElementSetPrimitiveRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  _QWORD *result;

  v6 = *(unsigned __int16 *)(a1 + 128);
  result = *(_QWORD **)(a1 + 120);
  if (!v6)
  {
    result = malloc_type_realloc(result, 0x10uLL, 0x1000040451B5BE8uLL);
    *(_QWORD *)(a1 + 120) = result;
  }
  *result = a2;
  result[1] = a3;
  *(_WORD *)(a1 + 128) = 1;
  return result;
}

uint64_t C3DMeshElementGetPrimitiveRanges(uint64_t a1, _WORD *a2)
{
  if (a2)
    *a2 = *(_WORD *)(a1 + 128);
  return *(_QWORD *)(a1 + 120);
}

uint64_t C3DMeshElementEnumeratePrimitiveRanges(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  unint64_t v5;

  if (*(_QWORD *)(result + 120))
  {
    v2 = result;
    if (*(_WORD *)(result + 128))
    {
      v4 = 0;
      v5 = 0;
      do
      {
        result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a2 + 16))(a2, *(_QWORD *)(*(_QWORD *)(v2 + 120) + v4), *(_QWORD *)(*(_QWORD *)(v2 + 120) + v4 + 8));
        ++v5;
        v4 += 16;
      }
      while (v5 < *(unsigned __int16 *)(v2 + 128));
    }
  }
  return result;
}

uint64_t C3DMeshElementGetPrimitiveCountByEvaluatingPrimitiveRanges(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  uint64_t *v4;
  uint64_t v5;

  v1 = *(_QWORD *)(a1 + 120);
  if (!v1)
    return *(unsigned int *)(a1 + 104);
  v2 = *(unsigned __int16 *)(a1 + 128);
  if (!*(_WORD *)(a1 + 128))
    return 0;
  result = 0;
  v4 = (uint64_t *)(v1 + 8);
  do
  {
    v5 = *v4;
    v4 += 2;
    result += v5;
    --v2;
  }
  while (v2);
  return result;
}

uint64_t C3DMeshElementEnumeratePrimitiveIndicesByEvaluatingPrimitiveRanges(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  unint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = result;
  if (*(_QWORD *)(result + 120))
  {
    v4 = *(unsigned __int16 *)(result + 128);
    if (*(_WORD *)(result + 128))
    {
      v5 = 0;
      do
      {
        v6 = (unsigned int *)(*(_QWORD *)(v3 + 120) + 16 * v5);
        v7 = *v6;
        v8 = *((_QWORD *)v6 + 1);
        if (v7 < (int)v8 + (int)v7)
        {
          do
          {
            result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v7);
            v7 = (v7 + 1);
            LODWORD(v8) = v8 - 1;
          }
          while ((_DWORD)v8);
          v4 = *(unsigned __int16 *)(v3 + 128);
        }
        ++v5;
      }
      while (v5 < v4);
    }
  }
  else if (*(_DWORD *)(result + 104))
  {
    v9 = 0;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v9);
      v9 = (v9 + 1);
    }
    while (v9 < *(_DWORD *)(v3 + 104));
  }
  return result;
}

uint64_t C3DMeshElementGetUsesInterleavedIndicesChannels(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 131);
}

float C3DMeshElementGetPointSize(uint64_t a1)
{
  return *(float *)(a1 + 144);
}

uint64_t C3DMeshElementSetPointSize(uint64_t result, float a2)
{
  *(float *)(result + 144) = a2;
  return result;
}

float C3DMeshElementGetMinimumPointScreenRadius(uint64_t a1)
{
  return *(float *)(a1 + 148);
}

uint64_t C3DMeshElementSetMinimumPointScreenRadius(uint64_t result, float a2)
{
  *(float *)(result + 148) = a2;
  return result;
}

float C3DMeshElementGetMaximumPointScreenRadius(uint64_t a1)
{
  return *(float *)(a1 + 152);
}

uint64_t C3DMeshElementSetMaximumPointScreenRadius(uint64_t result, float a2)
{
  *(float *)(result + 152) = a2;
  return result;
}

uint64_t C3DMeshElementGetVertexCountForPrimitiveAtIndex(uint64_t a1, unsigned int a2)
{
  CFIndex Length;
  const UInt8 *BytePtr;

  if (*(_BYTE *)(a1 + 88) != 4)
    return C3DMeshElementGetIndexCountPerPrimitive(a1);
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
  return __readIndexInBuffer((uint64_t)BytePtr, a2, *(unsigned __int8 *)(a1 + 80), Length);
}

uint64_t __readIndexInBuffer(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4)
{
  NSObject *v7;
  uint64_t result;
  NSObject *v9;
  _DWORD v10[2];
  __int16 v11;
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if ((a2 + 1) * a3 <= a4)
  {
    switch(a3)
    {
      case 4uLL:
        return *(unsigned int *)(a1 + 4 * a2);
      case 2uLL:
        return *(unsigned __int16 *)(a1 + 2 * a2);
      case 1uLL:
        return *(unsigned __int8 *)(a1 + a2);
      default:
        v9 = scn_default_log();
        result = os_log_type_enabled(v9, OS_LOG_TYPE_FAULT);
        if ((_DWORD)result)
        {
          __readIndexInBuffer_cold_1(a3, v9);
          return 0;
        }
        break;
    }
  }
  else
  {
    v7 = scn_default_log();
    result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      v10[0] = 67109376;
      v10[1] = a2;
      v11 = 2048;
      v12 = a4 / a3;
      _os_log_error_impl(&dword_1DCCB8000, v7, OS_LOG_TYPE_ERROR, "Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", (uint8_t *)v10, 0x12u);
      return 0;
    }
  }
  return result;
}

uint64_t C3DMeshElementGetIndex(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _DWORD *v17;
  int v18;
  int v19;
  unsigned int v20;
  const __CFData *v21;
  unint64_t v22;
  CFIndex v23;
  const UInt8 *v24;
  unint64_t v26;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;

  if (!a1)
  {
    v8 = scn_default_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
  }
  if (*(_BYTE *)(a1 + 88) == 4)
  {
    v16 = *(_DWORD *)(a1 + 104);
    v17 = *(_DWORD **)(a1 + 112);
    if (!v17)
    {
      v26 = *(unsigned __int8 *)(a1 + 80);
      Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
      if (BytePtr)
      {
        v29 = (uint64_t)BytePtr;
        v30 = *(unsigned int *)(a1 + 104);
        v17 = malloc_type_malloc(4 * v30, 0x100004052888210uLL);
        *(_QWORD *)(a1 + 112) = v17;
        if ((_DWORD)v30)
        {
          v33 = a3;
          v31 = 0;
          v32 = 0;
          do
          {
            v32 += __readIndexInBuffer(v29, v31, v26, Length);
            v17 = *(_DWORD **)(a1 + 112);
            v17[v31++] = v32;
          }
          while (v30 != v31);
          a3 = v33;
        }
      }
      else
      {
        v17 = *(_DWORD **)(a1 + 112);
      }
    }
    v18 = 0;
    if (a2 >= 1 && v17)
      v18 = v17[a2 - 1];
  }
  else
  {
    v16 = 0;
    v18 = C3DMeshElementGetIndexCountPerPrimitive(a1) * a2;
  }
  if (*(_BYTE *)(a1 + 131))
  {
    v19 = *(unsigned __int8 *)(a1 + 130);
  }
  else
  {
    a4 *= C3DMeshElementGetIndexCount(a1);
    v19 = 1;
  }
  v20 = a4 + v16 + v19 * (a3 + v18);
  v21 = *(const __CFData **)(a1 + 96);
  if (!v21)
    return v20;
  v22 = *(unsigned __int8 *)(a1 + 80);
  v23 = CFDataGetLength(v21);
  v24 = CFDataGetBytePtr(v21);
  return __readIndexInBuffer((uint64_t)v24, v20, v22, v23);
}

uint64_t C3DMeshElementGetChannelsDefineSameTopology(uint64_t a1, int a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int IndexCount;
  unint64_t v15;
  unint64_t Length;
  const UInt8 *BytePtr;
  uint64_t v18;
  unint64_t v19;
  BOOL v20;
  int v21;
  int IndexInBuffer;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  IndexCount = C3DMeshElementGetIndexCount(a1);
  v15 = *(unsigned __int8 *)(a1 + 80);
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
  v18 = (uint64_t)BytePtr;
  if (*(_BYTE *)(a1 + 88) == 4)
  {
    v19 = *(unsigned int *)(a1 + 104) * (unint64_t)v15;
    v20 = Length > v19;
    Length -= v19;
    if (!v20)
      C3DMeshElementGetChannelsDefineSameTopology_cold_1();
    v18 = (uint64_t)&BytePtr[v19];
  }
  if (*(_BYTE *)(a1 + 131))
  {
    if (IndexCount)
    {
      v21 = 0;
      while (1)
      {
        IndexInBuffer = __readIndexInBuffer(v18, a2 + v21 * *(unsigned __int8 *)(a1 + 130), v15, Length);
        if (IndexInBuffer != __readIndexInBuffer(v18, a3 + v21 * *(unsigned __int8 *)(a1 + 130), v15, Length))break;
        if (IndexCount == ++v21)
          return 1;
      }
      return 0;
    }
  }
  else if (memcmp((const void *)(v18 + v15 * (unint64_t)(IndexCount * a2)), (const void *)(v18 + v15 * (unint64_t)(IndexCount * a3)), IndexCount * (unint64_t)v15))
  {
    return 0;
  }
  return 1;
}

uint64_t C3DMeshElementGetAllChannelsDefineSameTopology(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t result;
  unsigned __int8 i;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(unsigned __int8 *)(a1 + 130);
  if (v10 < 2)
    return 1;
  for (i = 1; i < v10; ++i)
  {
    result = C3DMeshElementGetChannelsDefineSameTopology(a1, 0, i);
    if (!(_DWORD)result)
      break;
  }
  return result;
}

void C3DMeshElementSetSharedMeshElement(uint64_t a1, char *cf, int a3, int a4)
{
  char *v8;
  CFTypeRef v9;
  char v10;
  const void *v11;

  v8 = *(char **)(a1 + 72);
  if (v8 != cf)
  {
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(a1 + 72) = 0;
    }
    if (cf)
      v9 = CFRetain(cf);
    else
      v9 = 0;
    *(_QWORD *)(a1 + 72) = v9;
  }
  v10 = cf[80];
  v11 = (const void *)*((_QWORD *)cf + 12);
  *(_DWORD *)(a1 + 104) = a4;
  *(_DWORD *)(a1 + 64) = a3;
  __SetIndexes(a1, v11, v10);
}

uint64_t C3DMeshElementGetSharedIndexBufferOffset(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned int *)(a1 + 64);
}

void C3DMeshElementSetInstanceCount(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_DWORD *)(a1 + 68) = a2;
}

uint64_t C3DMeshElementCreateVolatile()
{
  uint64_t result;

  result = C3DMeshElementCreate();
  *(_BYTE *)(result + 82) = 1;
  return result;
}

void C3DMeshElementSetVolatileDataPtr(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_QWORD *)(a1 + 160) = a2;
}

uint64_t C3DMeshElementGetVolatileDataPtr(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 160);
}

uint64_t C3DMeshElementGetBytesPerIndex(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 80);
}

void C3DIndicesContentEnumeratePrimitives(uint64_t *a1, uint64_t a2, __n128 a3)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  a3.n128_u64[0] = 0x40000000;
  v3[1] = 0x40000000;
  v3[2] = __C3DIndicesContentEnumeratePrimitives_block_invoke;
  v3[3] = &unk_1EA59E020;
  v3[4] = a2;
  C3DIndicesContentArrayEnumeratePrimitives(a1, 1u, (uint64_t)v3, a3);
}

void C3DIndicesContentArrayEnumeratePrimitives(uint64_t *a1, unsigned int a2, uint64_t a3, __n128 a4)
{
  int v4;
  uint64_t v5;
  int v6;
  __int128 v10;
  uint64_t i;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  __int128 v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  _DWORD *v46;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  _OWORD *v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  int v59;
  unsigned int v60;
  _DWORD *v61;
  unsigned int v62;
  _DWORD *v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  int v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  int v79;
  uint64_t v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  uint64_t v103;
  _QWORD *v104;
  uint64_t v105;
  char *v106;
  _QWORD *v107;
  uint64_t v108;
  char *v109;
  _QWORD *v110;
  uint64_t v111;
  char *v112;
  _QWORD *v113;
  _OWORD v114[2];
  _BYTE *v115;
  _OWORD *v116;
  uint64_t v117;
  uint64_t v118;
  _OWORD v119[3];
  uint64_t v120;
  char v121;
  uint8_t buf[16];
  __int128 v123;
  __int128 v124;
  uint64_t v125;
  int v126;
  int v127;
  int v128;
  uint64_t v129;

  v129 = *MEMORY[0x1E0C80C00];
  v4 = *((unsigned __int8 *)a1 + 26);
  v5 = *((unsigned int *)a1 + 2);
  v6 = *((unsigned __int8 *)a1 + 27);
  v118 = a1[4];
  v121 = 0;
  switch(v4)
  {
    case 0:
    case 1:
    case 5:
      if (a2 == 1)
      {
        v10 = *((_OWORD *)a1 + 1);
        *(_OWORD *)buf = *(_OWORD *)a1;
        v123 = v10;
        v124 = *((_OWORD *)a1 + 2);
        v125 = a1[6];
        if ((_DWORD)v5)
        {
          for (i = 0; i != v5; ++i)
          {
            v119[0] = *(_OWORD *)buf;
            v119[1] = v123;
            v119[2] = v124;
            v120 = v125;
            C3DIndicesContentGetTriangleIndex((uint64_t *)v119, i, &v126, &v127, &v128);
            (*(void (**)(uint64_t, uint64_t, int *, uint64_t, char *))(a3 + 16))(a3, i, &v126, 3, &v121);
            if (v121)
              break;
          }
        }
      }
      else
      {
        v118 = a3;
        v116 = v114;
        MEMORY[0x1E0C80A78](a1);
        v13 = (char *)v114 - v12;
        if ((_DWORD)v5)
        {
          v14 = 0;
          do
          {
            v15 = v5;
            if (a2)
            {
              v16 = 0;
              v17 = a1;
              do
              {
                v18 = *((_OWORD *)v17 + 1);
                *(_OWORD *)buf = *(_OWORD *)v17;
                v123 = v18;
                v124 = *((_OWORD *)v17 + 2);
                v125 = v17[6];
                C3DIndicesContentGetTriangleIndex((uint64_t *)buf, v14, &v13[v16], &v13[4 * a2 + v16], &v13[8 * a2 + v16]);
                v16 += 4;
                v17 += 7;
              }
              while (4 * a2 != v16);
            }
            (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *))(v118 + 16))(v118, v14, v13, 3, &v121);
            if (v121)
              break;
            ++v14;
            v5 = v15;
          }
          while (v14 != v15);
        }
      }
      return;
    case 2:
      if (a2 == 1)
      {
        if ((_DWORD)v5)
        {
          v26 = 0;
          v27 = *a1;
          v28 = 1;
          v30 = a1[5];
          v29 = a1[6];
          while (1)
          {
            switch(v6)
            {
              case 1:
                *(_DWORD *)buf = *(unsigned __int8 *)(v27 + v30 + v29 * (v28 - 1));
                v31 = *(unsigned __int8 *)(v27 + v30 + v29 * v28);
                break;
              case 2:
                *(_DWORD *)buf = *(unsigned __int16 *)(v27 + 2 * (v30 + v29 * (v28 - 1)));
                v31 = *(unsigned __int16 *)(v27 + 2 * (v30 + v29 * v28));
                break;
              case 4:
                *(_DWORD *)buf = *(_DWORD *)(v27 + 4 * (v30 + v29 * (v28 - 1)));
                v31 = *(_DWORD *)(v27 + 4 * (v30 + v29 * v28));
                break;
              default:
                goto LABEL_28;
            }
            *(_DWORD *)&buf[4] = v31;
LABEL_28:
            (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, char *))(a3 + 16))(a3, v26, buf, 2, &v121);
            if (!v121)
            {
              ++v26;
              v28 += 2;
              if (v5 != v26)
                continue;
            }
            return;
          }
        }
      }
      else
      {
        MEMORY[0x1E0C80A78](a1);
        v81 = (char *)v114 - v80;
        if ((_DWORD)v5)
        {
          v82 = 0;
          v83 = 4 * a2;
          v84 = &v81[v83];
          v85 = a1 + 6;
          do
          {
            if (v6 == 1)
            {
              if (a2)
              {
                v91 = 0;
                v92 = v85;
                do
                {
                  v93 = *(v92 - 6);
                  v94 = *(v92 - 1);
                  v95 = *v92;
                  *(_DWORD *)&v81[v91] = *(unsigned __int8 *)(v93 + v94 + *v92 * (2 * v82));
                  *(_DWORD *)&v84[v91] = *(unsigned __int8 *)(v93 + v94 + v95 * ((2 * (_DWORD)v82) | 1u));
                  v91 += 4;
                  v92 += 7;
                }
                while (v83 != v91);
              }
            }
            else if (v6 == 2)
            {
              if (a2)
              {
                v96 = 0;
                v97 = v85;
                do
                {
                  v98 = *(v97 - 6);
                  v99 = *(v97 - 1);
                  v100 = *v97;
                  *(_DWORD *)&v81[v96] = *(unsigned __int16 *)(v98 + 2 * (v99 + *v97 * (2 * v82)));
                  *(_DWORD *)&v84[v96] = *(unsigned __int16 *)(v98 + 2 * (v99 + v100 * ((2 * (_DWORD)v82) | 1u)));
                  v96 += 4;
                  v97 += 7;
                }
                while (v83 != v96);
              }
            }
            else if (v6 == 4 && a2)
            {
              v86 = 0;
              v87 = v85;
              do
              {
                v88 = *(v87 - 6);
                v89 = *(v87 - 1);
                v90 = *v87;
                *(_DWORD *)&v81[v86] = *(_DWORD *)(v88 + 4 * (v89 + *v87 * (2 * v82)));
                *(_DWORD *)&v84[v86] = *(_DWORD *)(v88 + 4 * (v89 + v90 * ((2 * (_DWORD)v82) | 1u)));
                v86 += 4;
                v87 += 7;
              }
              while (v83 != v86);
            }
            (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *))(a3 + 16))(a3, v82, v81, 2, &v121);
            if (v121)
              break;
            ++v82;
          }
          while (v82 != v5);
        }
      }
      return;
    case 3:
      if (a2 == 1)
      {
        v32 = *a1;
        v33 = a1[5];
        v34 = a1[6];
        *(_DWORD *)buf = 0;
        if (!(_DWORD)v5)
          return;
        v35 = 0;
        while (1)
        {
          switch(v6)
          {
            case 4:
              v36 = *(_DWORD *)(v32 + 4 * v33);
              break;
            case 2:
              v36 = *(unsigned __int16 *)(v32 + 2 * v33);
              break;
            case 1:
              v36 = *(unsigned __int8 *)(v32 + v33);
              break;
            default:
              goto LABEL_41;
          }
          *(_DWORD *)buf = v36;
LABEL_41:
          (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, char *))(a3 + 16))(a3, v35, buf, 1, &v121);
          if (!v121)
          {
            ++v35;
            v33 += v34;
            if (v5 != v35)
              continue;
          }
          return;
        }
      }
      MEMORY[0x1E0C80A78](a1);
      v102 = (char *)v114 - v101;
      if ((_DWORD)v5)
      {
        v103 = 0;
        v104 = a1 + 6;
        do
        {
          switch(v6)
          {
            case 1:
              if (a2)
              {
                v108 = a2;
                v109 = v102;
                v110 = v104;
                do
                {
                  *(_DWORD *)v109 = *(unsigned __int8 *)(*(v110 - 6) + *(v110 - 1) + *v110 * v103);
                  v109 += 4;
                  v110 += 7;
                  --v108;
                }
                while (v108);
              }
              break;
            case 2:
              v111 = a2;
              v112 = v102;
              v113 = v104;
              if (a2)
              {
                do
                {
                  *(_DWORD *)v112 = *(unsigned __int16 *)(*(v113 - 6) + 2 * (*(v113 - 1) + *v113 * v103));
                  v112 += 4;
                  v113 += 7;
                  --v111;
                }
                while (v111);
              }
              break;
            case 4:
              v105 = a2;
              v106 = v102;
              v107 = v104;
              if (a2)
              {
                do
                {
                  *(_DWORD *)v106 = *(_DWORD *)(*(v107 - 6) + 4 * (*(v107 - 1) + *v107 * v103));
                  v106 += 4;
                  v107 += 7;
                  --v105;
                }
                while (v105);
              }
              break;
          }
          (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *))(a3 + 16))(a3, v103, v102, 1, &v121);
          if (v121)
            break;
          ++v103;
        }
        while (v103 != v5);
      }
      return;
    case 4:
      if (!(_DWORD)v5)
        return;
      v37 = 0;
      v38 = 0;
      v115 = (char *)v119 + 1;
      a4.n128_u64[0] = 67109120;
      v114[0] = a4;
      v117 = v5;
      while (2)
      {
        switch(v6)
        {
          case 4:
            v39 = *(unsigned int *)(v118 + 4 * v37);
            break;
          case 2:
            v39 = *(unsigned __int16 *)(v118 + 2 * v37);
            break;
          case 1:
            v39 = *(unsigned __int8 *)(v118 + v37);
            break;
          default:
            LODWORD(v39) = 0;
LABEL_60:
            v47 = scn_default_log();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
              C3DIndicesContentArrayEnumeratePrimitives_cold_2((uint8_t *)v119, v115, v47);
            goto LABEL_90;
        }
        if (v39 <= 2)
          goto LABEL_60;
        if (a2 == 1)
        {
          MEMORY[0x1E0C80A78](*((unsigned __int8 *)a1 + 27));
          if (v6 == 1)
          {
            v60 = v38;
            v61 = (_DWORD *)((char *)v114 - v44);
            do
            {
              *v61++ = *(unsigned __int8 *)(v40 + v41 + v43 * v60++);
              --v42;
            }
            while (v42);
          }
          else if (v6 == 2)
          {
            v62 = v38;
            v63 = (_DWORD *)((char *)v114 - v44);
            do
            {
              *v63++ = *(unsigned __int16 *)(v40 + 2 * (v41 + v43 * v62++));
              --v42;
            }
            while (v42);
          }
          else
          {
            v45 = v38;
            v46 = (_DWORD *)((char *)v114 - v44);
            do
            {
              *v46++ = *(_DWORD *)(v40 + 4 * (v41 + v43 * v45++));
              --v42;
            }
            while (v42);
          }
          (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *))(a3 + 16))(a3, v37, (char *)v114 - v44, v39, &v121);
          v5 = v117;
          if (v121)
            return;
LABEL_90:
          v38 += v39;
          if (++v37 == v5)
            return;
          continue;
        }
        break;
      }
      v48 = MEMORY[0x1E0C80A78](56);
      v50 = (char *)v114 - v49;
      v116 = v51;
      if (v6 == 1)
      {
        if (a2)
        {
          v64 = 0;
          do
          {
            v65 = (uint64_t *)((char *)a1 + v64 * v48);
            v66 = *v65;
            v67 = v65[5];
            v68 = v65[6];
            v69 = v39;
            v70 = v38;
            v71 = v64;
            do
            {
              *(_DWORD *)&v50[4 * v71] = *(unsigned __int8 *)(v66 + v67 + v68 * v70);
              v71 += a2;
              ++v70;
              --v69;
            }
            while (v69);
            ++v64;
          }
          while (v64 != a2);
        }
      }
      else if (v6 == 2)
      {
        if (a2)
        {
          v72 = 0;
          do
          {
            v73 = (uint64_t *)((char *)a1 + v72 * v48);
            v74 = *v73;
            v75 = v73[5];
            v76 = v73[6];
            v77 = v39;
            v78 = v38;
            v79 = v72;
            do
            {
              *(_DWORD *)&v50[4 * v79] = *(unsigned __int16 *)(v74 + 2 * (v75 + v76 * v78));
              v79 += a2;
              ++v78;
              --v77;
            }
            while (v77);
            ++v72;
          }
          while (v72 != a2);
        }
      }
      else if (a2)
      {
        v52 = 0;
        do
        {
          v53 = (uint64_t *)((char *)a1 + v52 * v48);
          v54 = *v53;
          v55 = v53[5];
          v56 = v53[6];
          v57 = v39;
          v58 = v38;
          v59 = v52;
          do
          {
            *(_DWORD *)&v50[4 * v59] = *(_DWORD *)(v54 + 4 * (v55 + v56 * v58));
            v59 += a2;
            ++v58;
            --v57;
          }
          while (v57);
          ++v52;
        }
        while (v52 != a2);
      }
      (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *))(a3 + 16))(a3, v37, v50, v39, &v121);
      v5 = v117;
      if (!v121)
        goto LABEL_90;
      return;
    default:
      v19 = scn_default_log();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        C3DIndicesContentArrayEnumeratePrimitives_cold_1((char)v4, v19, v20, v21, v22, v23, v24, v25);
      return;
  }
}

void C3DIndicesContentEnumerateTriangulatedPrimitives(uint64_t *a1, uint64_t a2, __n128 a3)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  a3.n128_u64[0] = 0x40000000;
  v3[1] = 0x40000000;
  v3[2] = __C3DIndicesContentEnumerateTriangulatedPrimitives_block_invoke;
  v3[3] = &unk_1EA59E048;
  v3[4] = a2;
  C3DIndicesContentArrayEnumeratePrimitives(a1, 1u, (uint64_t)v3, a3);
}

void C3DIndicesContentGetTriangleIndex(uint64_t *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v5 = *((unsigned __int8 *)a1 + 26);
  v6 = 3;
  if ((a2 & 1) != 0)
    v7 = 1;
  else
    v7 = 2;
  if ((a2 & 1) != 0)
    v8 = 2;
  else
    v8 = 1;
  v9 = v5 == 1 || v5 != 5;
  if (v5 != 1)
  {
    v7 = 2;
    v8 = 1;
  }
  v10 = v5 == 0;
  if (*((_BYTE *)a1 + 26))
    v11 = v9;
  else
    v11 = 3;
  if (*((_BYTE *)a1 + 26))
  {
    v6 = 1;
    v12 = v7;
  }
  else
  {
    v12 = 2;
  }
  if (v10)
    v13 = 1;
  else
    v13 = v8;
  v14 = *a1;
  if (!*a1)
  {
    *a3 = v11 * a2;
    *a4 = v13 + v6 * a2;
    v20 = v6 * a2 + v12;
    goto LABEL_29;
  }
  v16 = (uint64_t)a1 + 27;
  v15 = *((unsigned __int8 *)a1 + 27);
  switch(v15)
  {
    case 4:
      v21 = a1[5];
      v22 = a1[6];
      *a3 = *(_DWORD *)(v14 + 4 * (v21 + v11 * a2 * v22));
      v23 = v6 * a2;
      *a4 = *(_DWORD *)(v14 + 4 * (v21 + v22 * (v13 + v23)));
      v20 = *(_DWORD *)(v14 + 4 * (v21 + v22 * (v23 + v12)));
      goto LABEL_29;
    case 2:
      v24 = a1[5];
      v25 = a1[6];
      *a3 = *(unsigned __int16 *)(v14 + 2 * (v24 + v11 * a2 * v25));
      v26 = v6 * a2;
      *a4 = *(unsigned __int16 *)(v14 + 2 * (v24 + v25 * (v13 + v26)));
      v20 = *(unsigned __int16 *)(v14 + 2 * (v24 + v25 * (v26 + v12)));
      goto LABEL_29;
    case 1:
      v17 = a1[5];
      v18 = a1[6];
      *a3 = *(unsigned __int8 *)(v14 + v17 + v11 * a2 * v18);
      v19 = v6 * a2;
      *a4 = *(unsigned __int8 *)(v14 + v17 + v18 * (v13 + v19));
      v20 = *(unsigned __int8 *)(v14 + v17 + v18 * (v19 + v12));
LABEL_29:
      *a5 = v20;
      return;
  }
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  v27 = scn_default_log();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    C3DIndicesContentGetTriangleIndex_cold_1(v16, v27, v28, v29, v30, v31, v32, v33);
}

void C3DIndicesContentEnumeratePrimitivesByEvaluatingPrimitiveRanges(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __n128 v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  int v64;
  uint64_t v65;
  unsigned int v66;
  __n128 *v67;
  uint64_t v68;
  uint64_t v69;
  NSObject *v70;
  uint64_t v71;
  unsigned int v72;
  __n128 *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int v77;
  __n128 *v78;
  uint64_t v79;
  uint64_t v80;
  NSObject *v81;
  int v82;
  __n128 v83;
  _BYTE *v84;
  char v85;
  uint8_t buf[16];
  __int128 v87;
  __int128 v88;
  uint64_t v89;
  uint64_t v90;
  _QWORD v91[5];

  v4 = a1;
  v91[4] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 16))
  {
    v11 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)buf = *(_OWORD *)a1;
    v87 = v11;
    v88 = *(_OWORD *)(a1 + 32);
    v12.n128_u64[1] = *((_QWORD *)&v88 + 1);
    v89 = *(_QWORD *)(a1 + 48);
    v90 = MEMORY[0x1E0C809B0];
    v12.n128_u64[0] = 0x40000000;
    v91[0] = 0x40000000;
    v91[1] = __C3DIndicesContentEnumeratePrimitives_block_invoke;
    v91[2] = &unk_1EA59E020;
    v91[3] = a2;
    C3DIndicesContentArrayEnumeratePrimitives((uint64_t *)buf, 1u, (uint64_t)&v90, v12);
    return;
  }
  v85 = 0;
  switch(*(_BYTE *)(a1 + 26))
  {
    case 0:
    case 1:
    case 5:
      LODWORD(v91[0]) = 0;
      v90 = 0;
      v5 = *(unsigned __int16 *)(a1 + 24);
      if (*(_WORD *)(a1 + 24))
      {
        v6 = 0;
        while (1)
        {
          v7 = (_QWORD *)(*(_QWORD *)(v4 + 16) + 16 * v6);
          v8 = v7[1];
          if (*v7 < v8 + *v7)
            break;
LABEL_10:
          if (++v6 >= (unint64_t)v5)
            return;
        }
        v9 = *v7;
        while (1)
        {
          v10 = *(_OWORD *)(v4 + 16);
          *(_OWORD *)buf = *(_OWORD *)v4;
          v87 = v10;
          v88 = *(_OWORD *)(v4 + 32);
          v89 = *(_QWORD *)(v4 + 48);
          C3DIndicesContentGetTriangleIndex((uint64_t *)buf, v9, &v90, (_DWORD *)&v90 + 1, v91);
          (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, char *))(a2 + 16))(a2, v9, &v90, 3, &v85);
          if (v85)
            break;
          ++v9;
          LODWORD(v8) = v8 - 1;
          if (!(_DWORD)v8)
          {
            v5 = *(unsigned __int16 *)(v4 + 24);
            goto LABEL_10;
          }
        }
      }
      return;
    case 2:
      *(_QWORD *)buf = 0;
      v20 = *(unsigned __int16 *)(a1 + 24);
      if (!*(_WORD *)(a1 + 24))
        return;
      v21 = 0;
      do
      {
        v22 = (uint64_t *)(*(_QWORD *)(v4 + 16) + 16 * v21);
        v23 = *v22;
        v24 = v22[1] + *v22;
        if (v23 >= v24)
          goto LABEL_30;
        v25 = v23;
        v26 = 2 * v23;
        v27 = v24 - (unint64_t)v23;
        do
        {
          v28 = *(unsigned __int8 *)(v4 + 27);
          switch(v28)
          {
            case 1:
              v33 = *(_QWORD *)v4;
              v34 = *(_QWORD *)(v4 + 40);
              v35 = *(_QWORD *)(v4 + 48);
              *(_DWORD *)buf = *(unsigned __int8 *)(*(_QWORD *)v4 + v34 + v35 * v26);
              v32 = *(unsigned __int8 *)(v33 + v34 + v35 * (v26 + 1));
              break;
            case 2:
              v36 = *(_QWORD *)v4;
              v37 = *(_QWORD *)(v4 + 40);
              v38 = *(_QWORD *)(v4 + 48);
              *(_DWORD *)buf = *(unsigned __int16 *)(*(_QWORD *)v4 + 2 * (v37 + v38 * v26));
              v32 = *(unsigned __int16 *)(v36 + 2 * (v37 + v38 * (v26 + 1)));
              break;
            case 4:
              v29 = *(_QWORD *)v4;
              v30 = *(_QWORD *)(v4 + 40);
              v31 = *(_QWORD *)(v4 + 48);
              *(_DWORD *)buf = *(_DWORD *)(*(_QWORD *)v4 + 4 * (v30 + v31 * v26));
              v32 = *(_DWORD *)(v29 + 4 * (v30 + v31 * (v26 + 1)));
              break;
            default:
              goto LABEL_27;
          }
          *(_DWORD *)&buf[4] = v32;
LABEL_27:
          (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, char *))(a2 + 16))(a2, v25, buf, 2, &v85);
          if (v85)
            return;
          ++v25;
          v26 += 2;
          --v27;
        }
        while (v27);
        v20 = *(unsigned __int16 *)(v4 + 24);
LABEL_30:
        ++v21;
      }
      while (v21 < v20);
      return;
    case 3:
      *(_DWORD *)buf = 0;
      v39 = *(unsigned __int16 *)(a1 + 24);
      if (!*(_WORD *)(a1 + 24))
        return;
      v40 = 0;
      while (1)
      {
        v41 = (uint64_t *)(*(_QWORD *)(v4 + 16) + 16 * v40);
        v42 = *v41;
        v43 = v41[1] + *v41;
        if (v42 < v43)
          break;
LABEL_46:
        if (++v40 >= (unint64_t)v39)
          return;
      }
      v44 = v42;
      v45 = v43;
      while (1)
      {
        v46 = *(unsigned __int8 *)(v4 + 27);
        if (v46 == 4)
          break;
        if (v46 == 2)
        {
          v47 = *(unsigned __int16 *)(*(_QWORD *)v4 + 2 * (*(_QWORD *)(v4 + 40) + *(_QWORD *)(v4 + 48) * v44));
          goto LABEL_42;
        }
        if (v46 == 1)
        {
          v47 = *(unsigned __int8 *)(*(_QWORD *)v4 + *(_QWORD *)(v4 + 40) + *(_QWORD *)(v4 + 48) * v44);
LABEL_42:
          *(_DWORD *)buf = v47;
        }
        (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, char *))(a2 + 16))(a2, v44, buf, 1, &v85);
        if (v85)
          return;
        if (v45 == ++v44)
        {
          v39 = *(unsigned __int16 *)(v4 + 24);
          goto LABEL_46;
        }
      }
      v47 = *(_DWORD *)(*(_QWORD *)v4 + 4 * (*(_QWORD *)(v4 + 40) + *(_QWORD *)(v4 + 48) * v44));
      goto LABEL_42;
    case 4:
      v48 = *(unsigned __int16 *)(a1 + 24);
      if (!*(_WORD *)(a1 + 24))
        return;
      v49 = 0;
      v84 = (char *)&v90 + 1;
      a3.n128_u64[0] = 67109120;
      v83 = a3;
      while (2)
      {
        v50 = (uint64_t *)(*(_QWORD *)(v4 + 16) + 16 * v49);
        v51 = *v50;
        if (*v50)
        {
          v52 = 0;
          v53 = 0;
          v54 = *(unsigned __int8 *)(v4 + 27);
          do
          {
            switch(v54)
            {
              case 4:
                v55 = *(_DWORD *)(*(_QWORD *)(v4 + 32) + 4 * v52);
                break;
              case 2:
                v55 = *(unsigned __int16 *)(*(_QWORD *)(v4 + 32) + 2 * v52);
                break;
              case 1:
                v55 = *(unsigned __int8 *)(*(_QWORD *)(v4 + 32) + v52);
                break;
              default:
                v55 = 0;
                break;
            }
            v53 += v55;
            ++v52;
          }
          while (*v50 != v52);
        }
        else
        {
          v53 = 0;
        }
        v56 = v50[1] + v51;
        if (v51 >= v56)
          goto LABEL_91;
        v57 = v51;
        v58 = v56;
LABEL_64:
        v59 = *(unsigned __int8 *)(v4 + 27);
        switch(v59)
        {
          case 4:
            v60 = *(unsigned int *)(*(_QWORD *)(v4 + 32) + 4 * v57);
            break;
          case 2:
            v60 = *(unsigned __int16 *)(*(_QWORD *)(v4 + 32) + 2 * v57);
            break;
          case 1:
            v60 = *(unsigned __int8 *)(*(_QWORD *)(v4 + 32) + v57);
            break;
          default:
            LODWORD(v60) = 0;
            goto LABEL_78;
        }
        if (v60 > 2)
        {
          MEMORY[0x1E0C80A78](a1);
          v63 = (char *)&v83 - v62;
          v64 = *(unsigned __int8 *)(v4 + 27);
          switch(v64)
          {
            case 4:
              v71 = *(_QWORD *)v4;
              v72 = v53;
              v73 = (__n128 *)((char *)&v83 - v62);
              v74 = *(_QWORD *)(v4 + 40);
              v75 = *(_QWORD *)(v4 + 48);
              do
              {
                v73->n128_u32[0] = *(_DWORD *)(v71 + 4 * (v74 + v75 * v72));
                v73 = (__n128 *)((char *)v73 + 4);
                ++v72;
                --v61;
              }
              while (v61);
              break;
            case 2:
              v76 = *(_QWORD *)v4;
              v77 = v53;
              v78 = (__n128 *)((char *)&v83 - v62);
              v79 = *(_QWORD *)(v4 + 40);
              v80 = *(_QWORD *)(v4 + 48);
              do
              {
                v78->n128_u32[0] = *(unsigned __int16 *)(v76 + 2 * (v79 + v80 * v77));
                v78 = (__n128 *)((char *)v78 + 4);
                ++v77;
                --v61;
              }
              while (v61);
              break;
            case 1:
              v65 = *(_QWORD *)v4;
              v66 = v53;
              v67 = (__n128 *)((char *)&v83 - v62);
              v68 = *(_QWORD *)(v4 + 40);
              v69 = *(_QWORD *)(v4 + 48);
              do
              {
                v67->n128_u32[0] = *(unsigned __int8 *)(v65 + v68 + v69 * v66);
                v67 = (__n128 *)((char *)v67 + 4);
                ++v66;
                --v61;
              }
              while (v61);
              break;
            default:
              bzero((char *)&v83 - v62, 4 * v61);
              v81 = scn_default_log();
              if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
              {
                v82 = *(unsigned __int8 *)(v4 + 27);
                *(_DWORD *)buf = v83.n128_u32[0];
                *(_DWORD *)&buf[4] = v82;
                _os_log_error_impl(&dword_1DCCB8000, v81, OS_LOG_TYPE_ERROR, "Unreachable code: Invalid bytes per index (%d)", buf, 8u);
              }
              break;
          }
          a1 = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t, char *))(a2 + 16))(a2, v57, v63, v60, &v85);
          if (v85)
            return;
LABEL_89:
          v53 += v60;
          if (++v57 == v58)
          {
            v48 = *(unsigned __int16 *)(v4 + 24);
LABEL_91:
            if (++v49 >= (unint64_t)v48)
              return;
            continue;
          }
          goto LABEL_64;
        }
        break;
      }
LABEL_78:
      v70 = scn_default_log();
      a1 = os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
      if ((_DWORD)a1)
        C3DIndicesContentArrayEnumeratePrimitives_cold_2((uint8_t *)&v90, v84, v70);
      goto LABEL_89;
    default:
      v13 = scn_default_log();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        C3DIndicesContentEnumeratePrimitivesByEvaluatingPrimitiveRanges_cold_1(v4 + 26, v13, v14, v15, v16, v17, v18, v19);
      return;
  }
}

void C3DMeshElementPrintData(uint64_t a1)
{
  char Type;
  uint64_t v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  _OWORD v7[3];
  uint64_t v8;
  _QWORD v9[5];
  char v10;
  _QWORD v11[3];
  int v12;
  __int128 v13;
  __int128 v14;
  __n128 v15;
  uint64_t v16;
  _QWORD v17[6];

  Type = C3DMeshElementGetType(a1);
  v3 = *(unsigned __int8 *)(a1 + 130);
  if (*(_BYTE *)(a1 + 130))
  {
    v4 = Type;
    v5 = 0;
    v6 = MEMORY[0x1E0C809B0];
    do
    {
      fprintf((FILE *)*MEMORY[0x1E0C80C20], "CHANNEL %ld/%ld\n", v5 + 1, v3);
      v16 = 0;
      v14 = 0u;
      v15 = 0u;
      v13 = 0u;
      C3DMeshElementGetContent(a1, v5, (uint64_t)&v13);
      v11[0] = 0;
      v11[1] = v11;
      v11[2] = 0x2000000000;
      v12 = 0;
      v9[0] = v6;
      v9[1] = 0x40000000;
      v9[2] = __C3DMeshElementPrintData_block_invoke;
      v9[3] = &unk_1EA59E070;
      v10 = v4;
      v9[4] = v11;
      v7[0] = v13;
      v7[1] = v14;
      v7[2] = v15;
      v8 = v16;
      v17[0] = v6;
      v17[1] = 0x40000000;
      v17[2] = __C3DIndicesContentEnumeratePrimitives_block_invoke;
      v17[3] = &unk_1EA59E020;
      v17[4] = v9;
      C3DIndicesContentArrayEnumeratePrimitives((uint64_t *)v7, 1u, (uint64_t)v17, v15);
      _Block_object_dispose(v11, 8);
      ++v5;
    }
    while (v3 != v5);
  }
}

id _C3DMeshElementCFFinalize(uint64_t a1)
{
  uint64_t v2;
  CFNumberRef v3;
  __CFNotificationCenter *LocalCenter;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  uint64_t valuePtr;

  valuePtr = a1;
  v2 = a1;
  if (!*(_QWORD *)(a1 + 72))
  {
    v3 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterPostNotification(LocalCenter, CFSTR("kC3DNotificationMeshElementWillDie"), v3, 0, 1u);
    CFRelease(v3);
    v2 = valuePtr;
  }
  v5 = *(const void **)(v2 + 96);
  if (v5)
  {
    CFRelease(v5);
    v2 = valuePtr;
    *(_QWORD *)(valuePtr + 96) = 0;
  }
  v6 = *(const void **)(v2 + 168);
  if (v6)
  {
    CFRelease(v6);
    v2 = valuePtr;
    *(_QWORD *)(valuePtr + 168) = 0;
  }
  v7 = *(const void **)(v2 + 72);
  if (v7)
  {
    CFRelease(v7);
    v2 = valuePtr;
    *(_QWORD *)(valuePtr + 72) = 0;
  }
  v8 = *(const void **)(v2 + 136);
  if (v8)
  {
    CFRelease(v8);
    v2 = valuePtr;
    *(_QWORD *)(valuePtr + 136) = 0;
  }
  free(*(void **)(v2 + 112));
  free(*(void **)(valuePtr + 120));
  free(*(void **)(valuePtr + 208));
  return C3DEntityCFFinalize(a1);
}

__CFString *_C3DMeshElementCFCopyDebugDescription(uint64_t a1)
{
  __CFString *Mutable;
  unint64_t v3;
  const __CFString *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  float v9;
  uint64_t v10;
  const __CFData *Length;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v3 = *(char *)(a1 + 88);
  if (v3 > 5)
    v4 = CFSTR("invalid");
  else
    v4 = off_1EA59E090[v3];
  v5 = *(unsigned int *)(a1 + 104);
  v6 = *(unsigned __int8 *)(a1 + 130);
  v7 = *(unsigned __int8 *)(a1 + 80);
  v8 = *(unsigned int *)(a1 + 64);
  v9 = C3DMeshElementComputeACMR(a1, 32);
  v10 = *(unsigned int *)(a1 + 68);
  Length = *(const __CFData **)(a1 + 96);
  if (Length)
    Length = (const __CFData *)CFDataGetLength(Length);
  CFStringAppendFormat(Mutable, 0, CFSTR("<C3DMeshElement %p type:%@ primCount:%d channels:%d indexBytes:%d offset:%d acmr:%f inst:%d dataSize:%d shared:%p>"), a1, v4, v5, v6, v7, v8, v9, v10, Length, *(_QWORD *)(a1 + 72));
  return Mutable;
}

BOOL _C3DMeshElementInitWithPropertyList(char *a1, const __CFDictionary *a2, uint64_t a3, CFErrorRef *a4)
{
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFNumber *Value;
  const __CFNumber *v24;
  const __CFNumber *v25;
  CFTypeID v26;
  char v27;
  NSObject *v28;
  _BOOL8 result;
  NSObject *v30;
  CFTypeID v31;
  NSObject *v32;
  NSObject *v33;
  _BOOL4 v34;
  const __CFData *v35;
  const __CFData *v36;
  const __CFNumber *v37;
  int v38;
  NSObject *v39;
  CFIndex v40;
  uint64_t v41;
  uint64_t v42;
  CFDataRef v43;
  CFDataRef v44;
  const __CFBoolean *v45;
  char v46;
  NSObject *v47;
  NSObject *v48;
  CFErrorRef MalformedDocumentError;
  int valuePtr;
  uint8_t buf[4];
  const __CFNumber *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (!a1 && (v7 = scn_default_log(), os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)))
  {
    _C3DGeometryFillLibraryForSerialization_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    if (!a2)
    {
LABEL_4:
      v15 = scn_default_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
        _C3DGeometryFinalizeDeserialization_cold_4(v15, v16, v17, v18, v19, v20, v21, v22);
    }
  }
  else if (!a2)
  {
    goto LABEL_4;
  }
  if ((C3DEntityInitWithPropertyList((uint64_t)a1, a2) & 1) == 0)
  {
    v28 = scn_default_log();
    result = os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    _C3DMeshElementInitWithPropertyList_cold_6(v28);
    return 0;
  }
  *((_DWORD *)a1 + 26) = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("facesCount"));
  if (!Value || !CFNumberGetValue(Value, kCFNumberIntType, a1 + 104))
  {
    v30 = scn_default_log();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_61;
    _C3DMeshElementInitWithPropertyList_cold_1();
    if (!a4)
      return 0;
    goto LABEL_62;
  }
  v24 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("geometryElement"));
  if (!v24)
    goto LABEL_21;
  v25 = v24;
  valuePtr = 0;
  v26 = CFGetTypeID(v24);
  if (v26 == CFNumberGetTypeID() && CFNumberGetValue(v25, kCFNumberIntType, &valuePtr))
  {
    v27 = valuePtr;
    goto LABEL_36;
  }
  v31 = CFGetTypeID(v25);
  if (v31 != CFStringGetTypeID())
  {
LABEL_21:
    v32 = scn_default_log();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      goto LABEL_61;
    _C3DMeshElementInitWithPropertyList_cold_2();
    if (!a4)
      return 0;
    goto LABEL_62;
  }
  if (CFEqual(v25, CFSTR("linesArray")))
  {
    v27 = 2;
    goto LABEL_36;
  }
  if (CFEqual(v25, CFSTR("trianglesArray")))
    goto LABEL_27;
  if (CFEqual(v25, CFSTR("pointsArray")))
  {
    v27 = 3;
  }
  else if (CFEqual(v25, CFSTR("trianglesStrip")))
  {
    v27 = 1;
  }
  else if (CFEqual(v25, CFSTR("polygonsArray")))
  {
    v27 = 4;
  }
  else
  {
    v33 = scn_default_log();
    v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
    v27 = 0;
    if (v34)
    {
      *(_DWORD *)buf = 138412290;
      v52 = v25;
      _os_log_impl(&dword_1DCCB8000, v33, OS_LOG_TYPE_DEFAULT, "Warning: Unknown mesh element type %@, assuming triangles array.", buf, 0xCu);
LABEL_27:
      v27 = 0;
    }
  }
LABEL_36:
  a1[88] = v27;
  v35 = (const __CFData *)CFDictionaryGetValue(a2, CFSTR("indexes"));
  if (!v35)
  {
    v39 = scn_default_log();
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      goto LABEL_61;
    _C3DMeshElementInitWithPropertyList_cold_3();
    if (!a4)
      return 0;
    goto LABEL_62;
  }
  v36 = v35;
  a1[80] = 4;
  v37 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("bytesPerIndex"));
  if (v37)
  {
    *(_DWORD *)buf = 0;
    if (!CFNumberGetValue(v37, kCFNumberIntType, buf))
    {
      v47 = scn_default_log();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        _C3DMeshElementInitWithPropertyList_cold_5();
        if (!a4)
          return 0;
      }
      else if (!a4)
      {
        return 0;
      }
      if (!*a4)
        *a4 = C3DSceneSourceCreateMalformedDocumentError(0);
      return 0;
    }
    v38 = buf[0];
    a1[80] = buf[0];
  }
  else
  {
    v38 = a1[80];
  }
  v40 = CFDataGetLength(v36) / a1[80];
  if (v40 >= 1)
  {
    v41 = 9;
    if (v38 == 1)
      v41 = 7;
    if (v38 == 2)
      v42 = 8;
    else
      v42 = v41;
    v43 = C3DCopyLittleEndianToHostRepresentationOfData(v36, v42, v40);
    if (v43)
    {
      v44 = v43;
      __SetIndexes((uint64_t)a1, v43, a1[80]);
      CFRelease(v44);
      goto LABEL_52;
    }
    v48 = scn_default_log();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
LABEL_61:
      if (!a4)
        return 0;
      goto LABEL_62;
    }
    _C3DMeshElementInitWithPropertyList_cold_4();
    if (!a4)
      return 0;
LABEL_62:
    if (!*a4)
    {
      MalformedDocumentError = C3DSceneSourceCreateMalformedDocumentError(0);
      result = 0;
      *a4 = MalformedDocumentError;
      return result;
    }
    return 0;
  }
LABEL_52:
  v45 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("doubleSided"));
  if (v45)
    v46 = CFBooleanGetValue(v45) != 0;
  else
    v46 = 0;
  C3DMeshElementSetDoubleSided((uint64_t)a1, v46);
  C3DMeshElementConvertStripToTriangleList((uint64_t)a1);
  return 1;
}

__CFDictionary *_C3DMeshElementCopyPropertyList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __CFDictionary *v14;
  const __CFAllocator *v15;
  CFNumberRef v16;
  unint64_t v17;
  __CFString *v18;
  CFNumberRef v19;
  const __CFData *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  CFIndex Length;
  CFDataRef v25;
  CFDataRef v26;
  const void **v27;
  int valuePtr;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      _C3DGeometryFillLibraryForSerialization_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  v14 = C3DEntityCopyPropertyList((_QWORD *)a1, a2, a3);
  if (v14)
  {
    v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v16 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (const void *)(a1 + 104));
    CFDictionarySetValue(v14, CFSTR("facesCount"), v16);
    CFRelease(v16);
    v17 = *(char *)(a1 + 88);
    if (v17 > 4)
      v18 = 0;
    else
      v18 = off_1EA59E0C0[v17];
    CFDictionarySetValue(v14, CFSTR("geometryElement"), v18);
    valuePtr = *(unsigned __int8 *)(a1 + 80);
    v19 = CFNumberCreate(v15, kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(v14, CFSTR("bytesPerIndex"), v19);
    CFRelease(v19);
    v20 = *(const __CFData **)(a1 + 96);
    v21 = *(unsigned __int8 *)(a1 + 80);
    v22 = 7;
    if (v21 != 1)
      v22 = 9;
    if (v21 == 2)
      v23 = 8;
    else
      v23 = v22;
    Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
    v25 = C3DCopyHostToLittleEndianRepresentationOfData(v20, v23, Length / *(unsigned __int8 *)(a1 + 80));
    if (v25)
    {
      v26 = v25;
      CFDictionarySetValue(v14, CFSTR("indexes"), v25);
      CFRelease(v26);
    }
    v27 = (const void **)MEMORY[0x1E0C9AE50];
    if (!*(_BYTE *)(a1 + 81))
      v27 = (const void **)MEMORY[0x1E0C9AE40];
    CFDictionarySetValue(v14, CFSTR("doubleSided"), *v27);
  }
  return v14;
}

uint64_t _C3DMeshElementFinalizeDeserialization()
{
  return 1;
}

__CFArray *_C3DMeshElementCopyInstanceVariables(uint64_t a1)
{
  __CFArray *Mutable;
  const CFDictionaryKeyCallBacks *v3;
  const CFDictionaryValueCallBacks *v4;
  __CFDictionary *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  __CFDictionary *v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  const CFDictionaryValueCallBacks *v13;
  __CFDictionary *v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  const CFDictionaryKeyCallBacks *v18;
  __CFDictionary *v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  __CFDictionary *v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  __CFDictionary *v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFNumberRef v30;
  __CFDictionary *v31;
  CFNumberRef v32;
  CFNumberRef v33;
  CFNumberRef v34;
  __CFDictionary *v35;
  CFNumberRef v36;
  CFNumberRef v37;
  CFNumberRef v38;
  uint64_t v40;
  int v41;
  int valuePtr;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v41 = 1;
  valuePtr = 5;
  v40 = *(_QWORD *)(a1 + 96);
  v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v8 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v5, CFSTR("name"), CFSTR("indexes"));
  CFDictionarySetValue(v5, CFSTR("type"), v6);
  CFDictionarySetValue(v5, CFSTR("address"), v8);
  CFDictionarySetValue(v5, CFSTR("semantic"), v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v41 = 0;
  valuePtr = 2;
  v40 = a1 + 104;
  v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v12 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v9, CFSTR("name"), CFSTR("subElementsCount"));
  CFDictionarySetValue(v9, CFSTR("type"), v10);
  CFDictionarySetValue(v9, CFSTR("address"), v12);
  CFDictionarySetValue(v9, CFSTR("semantic"), v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  v13 = v4;
  v14 = CFDictionaryCreateMutable(0, 4, v3, v4);
  v41 = 0;
  valuePtr = 2;
  v40 = a1 + 88;
  v15 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v16 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v17 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v14, CFSTR("name"), CFSTR("type"));
  CFDictionarySetValue(v14, CFSTR("type"), v15);
  CFDictionarySetValue(v14, CFSTR("address"), v17);
  CFDictionarySetValue(v14, CFSTR("semantic"), v16);
  CFArrayAppendValue(Mutable, v14);
  CFRelease(v16);
  CFRelease(v14);
  CFRelease(v17);
  CFRelease(v15);
  v18 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v19 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], v13);
  v41 = 0;
  valuePtr = 2;
  v40 = a1 + 80;
  v20 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v21 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v22 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v19, CFSTR("name"), CFSTR("bytesPerIndex"));
  CFDictionarySetValue(v19, CFSTR("type"), v20);
  CFDictionarySetValue(v19, CFSTR("address"), v22);
  CFDictionarySetValue(v19, CFSTR("semantic"), v21);
  CFArrayAppendValue(Mutable, v19);
  CFRelease(v21);
  CFRelease(v19);
  CFRelease(v22);
  CFRelease(v20);
  v23 = CFDictionaryCreateMutable(0, 4, v18, MEMORY[0x1E0C9B3A0]);
  v41 = 0;
  valuePtr = 3;
  v40 = a1 + 81;
  v24 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v25 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v26 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v23, CFSTR("name"), CFSTR("doubleSided"));
  CFDictionarySetValue(v23, CFSTR("type"), v24);
  CFDictionarySetValue(v23, CFSTR("address"), v26);
  CFDictionarySetValue(v23, CFSTR("semantic"), v25);
  CFArrayAppendValue(Mutable, v23);
  CFRelease(v25);
  CFRelease(v23);
  CFRelease(v26);
  CFRelease(v24);
  v27 = CFDictionaryCreateMutable(0, 4, v18, MEMORY[0x1E0C9B3A0]);
  v41 = 1;
  valuePtr = 5;
  v40 = *(_QWORD *)(a1 + 168);
  v28 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v29 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v30 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v27, CFSTR("name"), CFSTR("primitiveNormals"));
  CFDictionarySetValue(v27, CFSTR("type"), v28);
  CFDictionarySetValue(v27, CFSTR("address"), v30);
  CFDictionarySetValue(v27, CFSTR("semantic"), v29);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v29);
  CFRelease(v27);
  CFRelease(v30);
  CFRelease(v28);
  v31 = CFDictionaryCreateMutable(0, 4, v18, MEMORY[0x1E0C9B3A0]);
  v41 = 0;
  valuePtr = 9;
  v40 = a1 + 176;
  v32 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v33 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v34 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v31, CFSTR("name"), CFSTR("bbox[0]"));
  CFDictionarySetValue(v31, CFSTR("type"), v32);
  CFDictionarySetValue(v31, CFSTR("address"), v34);
  CFDictionarySetValue(v31, CFSTR("semantic"), v33);
  CFArrayAppendValue(Mutable, v31);
  CFRelease(v33);
  CFRelease(v31);
  CFRelease(v34);
  CFRelease(v32);
  v35 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v41 = 0;
  valuePtr = 9;
  v40 = a1 + 192;
  v36 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v37 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  v38 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v35, CFSTR("name"), CFSTR("bbox[1]"));
  CFDictionarySetValue(v35, CFSTR("type"), v36);
  CFDictionarySetValue(v35, CFSTR("address"), v38);
  CFDictionarySetValue(v35, CFSTR("semantic"), v37);
  CFArrayAppendValue(Mutable, v35);
  CFRelease(v37);
  CFRelease(v35);
  CFRelease(v38);
  CFRelease(v36);
  return Mutable;
}

void C3DMaterialSetTextureSampler(uint64_t a1, int a2, const void *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t CommonProfile;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DGeometryAppendMaterial_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  CommonProfile = C3DMaterialGetCommonProfile(a1);
  C3DEffectCommonProfileSetTextureSampler(CommonProfile, a2, a3);
}

__n128 C3DTransformBoundingSphere(float32x4_t *a1, float32x4_t *a2, __n128 *a3, __n128 a4)
{
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  __n128 result;
  float32x2_t v27;
  float v28;
  float32x4_t v30[4];

  if (!a1 && (v7 = scn_default_log(), os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)))
  {
    C3DTransformBoundingSphere_cold_2(v7, v8, v9, v10, v11, v12, v13, v14);
    if (a3)
      goto LABEL_6;
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  v15 = scn_default_log();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
    C3DTransformBoundingSphere_cold_1(v15, v16, v17, v18, v19, v20, v21, v22);
LABEL_6:
  v23 = *a1;
  v24 = a2[1];
  v30[0] = *a2;
  v30[1] = v24;
  v25 = a2[3];
  v30[2] = a2[2];
  v30[3] = v25;
  result.n128_f64[0] = C3DVector3MultMatrix4x4(v30, v23);
  result.n128_u32[3] = a3->n128_u32[3];
  *a3 = result;
  v27 = vabs_f32((float32x2_t)a4.n128_u64[0]);
  if (v27.f32[0] < v27.f32[1])
    v27.f32[0] = v27.f32[1];
  v28 = fabsf(a4.n128_f32[2]);
  if (v27.f32[0] < v28)
    v27.f32[0] = v28;
  result.n128_f32[3] = v27.f32[0] * a1->f32[3];
  *a3 = result;
  return result;
}

uint64_t C3DMeshElementConvertStripToTriangleList(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Indexes;
  const __CFData *v11;
  __CFData *Mutable;
  uint64_t PrimitiveCount;
  UInt8 *v14;
  const UInt8 *BytePtr;
  uint64_t v16;
  int v17;
  _WORD *v18;
  UInt8 *v19;
  _WORD *v20;
  int v21;
  int v22;
  int v23;
  int v26;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DMeshElementCreate_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (C3DMeshElementGetType(a1) == 1)
  {
    v26 = 0;
    Indexes = C3DMeshElementGetIndexes(a1, &v26);
    if (v26 == 2)
    {
      v11 = (const __CFData *)Indexes;
      Mutable = CFDataCreateMutable(0, 0);
      PrimitiveCount = C3DMeshElementGetPrimitiveCount(a1);
      v14 = (UInt8 *)C3DMalloc(6 * PrimitiveCount);
      BytePtr = CFDataGetBytePtr(v11);
      if (PrimitiveCount < 1)
      {
        v17 = 0;
      }
      else
      {
        v16 = 0;
        v17 = 0;
        v18 = BytePtr + 4;
        v19 = v14;
        do
        {
          v20 = v18 - 2;
          v21 = (unsigned __int16)*(v18 - 2);
          v22 = (unsigned __int16)*(v18 - 1);
          if (v21 != v22)
          {
            v23 = (unsigned __int16)*v18;
            if (v22 != v23 && v21 != v23)
            {
              if ((v16 & 1) != 0)
                LOWORD(v21) = *v18;
              else
                v20 = v18;
              *(_WORD *)v19 = v21;
              *((_WORD *)v19 + 1) = *(v18 - 1);
              *((_WORD *)v19 + 2) = *v20;
              ++v17;
              v19 += 6;
            }
          }
          ++v16;
          ++v18;
        }
        while (PrimitiveCount != v16);
      }
      CFDataAppendBytes(Mutable, v14, 6 * PrimitiveCount);
      C3DMeshElementInit(a1, 0, v17, Mutable, 2);
      CFRelease(Mutable);
      if (v14)
        free(v14);
    }
  }
  return 1;
}

void __MakeNormalMatrix(__n128 *a1, _OWORD *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    __MakeNormalMatrix_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    __MakeNormalMatrix_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  C3DMatrix4x4ComputeNormalMatrix(a1, a2);
}

void __DestroyMaterialMeshElementCouple(const void **a1)
{
  const void *v2;
  const void *v3;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      CFRelease(v2);
      *a1 = 0;
    }
    v3 = a1[1];
    if (v3)
      CFRelease(v3);
    free(a1);
  }
}

CFComparisonResult __CompareMaterials(uint64_t *a1, uint64_t *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFString *Name;
  const __CFString *v21;
  CFComparisonResult result;
  uint64_t v23;
  uint64_t v24;
  uint64_t PrimitiveCount;
  uint64_t v26;
  uint64_t v27;

  if (!a1 && (v4 = scn_default_log(), os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)))
  {
    __CompareMaterials_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
    if (a2)
      goto LABEL_6;
  }
  else if (a2)
  {
    goto LABEL_6;
  }
  v12 = scn_default_log();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
    __CompareMaterials_cold_1(v12, v13, v14, v15, v16, v17, v18, v19);
LABEL_6:
  if (C3DMaterialGetName(*a1))
    Name = (const __CFString *)C3DMaterialGetName(*a1);
  else
    Name = &stru_1EA5A6480;
  if (C3DMaterialGetName(*a2))
    v21 = (const __CFString *)C3DMaterialGetName(*a2);
  else
    v21 = &stru_1EA5A6480;
  result = CFStringCompare(Name, v21, 0);
  if (result)
    return result;
  v23 = a1[1];
  v24 = a2[1];
  if (!v23)
  {
    PrimitiveCount = 0;
    if (v24)
      goto LABEL_15;
LABEL_17:
    v26 = 0;
    goto LABEL_18;
  }
  PrimitiveCount = C3DMeshElementGetPrimitiveCount(v23);
  if (!v24)
    goto LABEL_17;
LABEL_15:
  v26 = C3DMeshElementGetPrimitiveCount(v24);
LABEL_18:
  v27 = -1;
  if (PrimitiveCount >= v26)
    v27 = 1;
  if (PrimitiveCount == v26)
    return 0;
  else
    return v27;
}

void __ReorderRendererElements(uint64_t a1)
{
  __CFArray *Mutable;
  uint64_t Mesh;
  CFIndex MaterialsCount;
  CFIndex v5;
  uint64_t i;
  _QWORD *v7;
  const void *MaterialAtIndex;
  const void *ElementAtIndex;
  CFIndex j;
  const void **ValueAtIndex;
  CFRange v12;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  Mesh = C3DGeometryGetMesh(a1);
  MaterialsCount = (CFIndex)C3DGeometryGetMaterialsCount(a1);
  if (MaterialsCount >= 1)
  {
    v5 = MaterialsCount;
    if (C3DMeshGetElementsCount(Mesh) == (const __CFArray *)MaterialsCount)
    {
      for (i = 0; i != v5; ++i)
      {
        v7 = C3DMalloc(0x10uLL);
        *v7 = 0;
        v7[1] = 0;
        MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1, i);
        if (MaterialAtIndex)
          MaterialAtIndex = CFRetain(MaterialAtIndex);
        *v7 = MaterialAtIndex;
        if ((uint64_t)C3DMeshGetElementsCount(Mesh) >= 1)
        {
          ElementAtIndex = C3DMeshGetElementAtIndex(Mesh, i, 0);
          if (ElementAtIndex)
            ElementAtIndex = CFRetain(ElementAtIndex);
          v7[1] = ElementAtIndex;
        }
        CFArrayAppendValue(Mutable, v7);
      }
      if (v5 >= 2)
      {
        v12.location = 0;
        v12.length = v5;
        CFArraySortValues(Mutable, v12, (CFComparatorFunction)__CompareMaterials, 0);
      }
      C3DGeometryRemoveAllMaterials(a1);
      C3DMeshRemoveAllElements(Mesh);
      for (j = 0; j != v5; ++j)
      {
        ValueAtIndex = (const void **)CFArrayGetValueAtIndex(Mutable, j);
        C3DMeshAppendElement(Mesh, ValueAtIndex[1]);
        C3DGeometryAppendMaterial(a1, (void *)*ValueAtIndex);
        __DestroyMaterialMeshElementCouple(ValueAtIndex);
      }
    }
  }
  CFRelease(Mutable);
}

uint64_t _C3DCreateFlattenedGeometryFromNodeHierarchy(float32x4_t *a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t Identity;
  __int128 *PivotMatrix;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 *v11;
  const __CFAllocator *v12;
  const __CFDictionary *Mutable;
  const __CFArray *v14;
  CFMutableArrayRef v15;
  CFMutableDictionaryRef v16;
  uint64_t v17;
  uint64_t *v18;
  CFIndex v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  const UInt8 *v34;
  CFDataRef v35;
  const void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t i;
  const __CFArray *v40;
  CFIndex v41;
  uint64_t v42;
  uint64_t v43;
  const void *ValueAtIndex;
  uint64_t v45;
  float32x4_t *v46;
  uint64_t j;
  uint64_t v48;
  uint64_t v49;
  const void *SourceWithSemanticAtIndex;
  const void *v51;
  uint64_t v52;
  uint64_t v53;
  float32x4_t *v54;
  NSObject *v55;
  CFMutableDictionaryRef v57;
  CFMutableArrayRef v58;
  uint64_t v59;
  const __CFDictionary *cf;
  _BOOL4 HasPivot;
  float32x4_t *v62;
  const __CFArray *v63;
  CFIndex Count;
  const __CFAllocator *bytesDeallocator;
  float32x4_t v66;
  CFIndex v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  _OWORD v72[4];
  _OWORD v73[4];
  uint64_t v74;
  int64x2_t v75;
  __int128 v76;
  uint64_t v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  uint64_t (*v81[3])(uint64_t, uint64_t);
  uint8_t buf[16];
  __int128 v83;
  __int128 v84;
  __int128 v85;
  float32x4_t v86[4];
  _QWORD v87[5];
  uint64_t context;
  const __CFArray *v89;
  _OWORD *v90;
  uint64_t v91;
  CFMutableArrayRef v92;
  CFMutableDictionaryRef v93;
  uint8_t v94[4];
  _QWORD v95[5];

  *(_QWORD *)((char *)&v95[2] + 4) = *MEMORY[0x1E0C80C00];
  v91 = 0;
  v79 = 0u;
  v80 = 0u;
  v78 = 0u;
  memset(v72, 0, sizeof(v72));
  C3DNodeGetLocalNoPivotMatrix((uint64_t)a1, (uint64_t)v72);
  Identity = C3DMatrix4x4GetIdentity();
  C3DNodeSetMatrix(a1, Identity);
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  HasPivot = C3DNodeGetHasPivot((uint64_t)a1);
  if (HasPivot)
  {
    PivotMatrix = (__int128 *)C3DNodeGetPivotMatrix((uint64_t)a1);
    v8 = PivotMatrix[3];
    v10 = *PivotMatrix;
    v9 = PivotMatrix[1];
    v70 = PivotMatrix[2];
    v71 = v8;
    v68 = v10;
    v69 = v9;
    v11 = (__int128 *)C3DMatrix4x4GetIdentity();
    C3DNodeSetPivotMatrix(a1, v11);
  }
  v75 = vdupq_n_s64(3uLL);
  v76 = xmmword_1DD007910;
  *(_QWORD *)&v80 = 0;
  memset(v73, 0, sizeof(v73));
  v77 = 4;
  v74 = 0;
  BYTE8(v80) = a4;
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  v14 = CFArrayCreateMutable(v12, 0, 0);
  v15 = CFArrayCreateMutable(v12, 0, MEMORY[0x1E0C9B378]);
  bytesDeallocator = v12;
  v16 = CFDictionaryCreateMutable(v12, 0, 0, 0);
  context = (uint64_t)Mutable;
  v89 = v14;
  v90 = v73;
  v58 = v15;
  v92 = v15;
  v93 = v16;
  v81[0] = 0;
  v81[1] = (uint64_t (*)(uint64_t, uint64_t))__CreateAndDispatchRendererElements;
  v81[2] = 0;
  v62 = a1;
  C3DNodeIterateTree((uint64_t)a1, v81, 0, (uint64_t)&context);
  v17 = C3DGeometryCreate();
  v18 = (uint64_t *)C3DMeshCreate();
  C3DGeometrySetMesh(v17, v18);
  CFRelease(v18);
  v59 = v17;
  cf = Mutable;
  context = v17;
  v89 = (const __CFArray *)v73;
  v57 = v16;
  v90 = v16;
  CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__MergeRendererElements, &context);
  Count = CFArrayGetCount(v14);
  if (Count >= 1)
  {
    v19 = 0;
    v20 = MEMORY[0x1E0C809B0];
    do
    {
      v21 = *((_QWORD *)CFArrayGetValueAtIndex(v14, v19) + 1);
      v87[0] = v20;
      v87[1] = 3221225472;
      v87[2] = ____MergeMeshSources_block_invoke;
      v87[3] = &__block_descriptor_40_e201_v32__0____C3DMeshSource____C3DGenericSource____C3DEntity____CFRuntimeBase_QAQ__v____CFString_____CFString_____CFDictionary_____C3DScene_q_____C3DSourceAccessor________CFData__v_v_qb1b1b1_SCC_8c16q20C28l;
      v87[4] = v73;
      C3DMeshApplySources(v21, 1, (uint64_t)v87);
      if ((_QWORD)v76 == 4 && v75.i64[0] == 4)
        break;
      ++v19;
    }
    while (v19 < Count);
  }
  v22 = 0;
  v63 = v14;
  __asm { FMOV            V0.4S, #1.0 }
  v66 = _Q0;
  do
  {
    if (*((uint64_t *)v73 + v22) >= 1)
    {
      v28 = 0;
      v29 = &v75.i64[v22];
      do
      {
        v30 = v80;
        v31 = *v29;
        if (!*v29)
        {
          v32 = scn_default_log();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
            _C3DCreateFlattenedGeometryFromNodeHierarchy_cold_1(v94, v95, v32);
        }
        if (v30 <= (0x7FFFFFFF / v31) && v30 * v31 <= 0x1FFFFFFF)
        {
          v34 = (const UInt8 *)malloc_type_calloc(4 * v30 * v31, 1uLL, 0xF6541223uLL);
          v35 = CFDataCreateWithBytesNoCopy(bytesDeallocator, v34, 4 * v30 * v31, bytesDeallocator);
          v36 = (const void *)C3DMeshSourceCreate(v35, (char)v22, v30, v31, 1);
          CFRelease(v35);
          if (v36)
          {
            if (v22 == 2)
            {
              v37 = C3DMeshSourceGetCount((uint64_t)v36);
              if (v37 >= 1)
              {
                v38 = v37;
                for (i = 0; i != v38; ++i)
                  C3DMeshSourceSetValueAtIndexAsVector4((uint64_t)v36, i, v66);
              }
            }
            C3DMeshAddSource((uint64_t)v18, v36, 0, 0);
            CFRelease(v36);
          }
        }
        ++v28;
      }
      while (v28 < *((_QWORD *)v73 + v22));
    }
    ++v22;
  }
  while (v22 != 9);
  v40 = v14;
  if (Count >= 1)
  {
    v41 = 0;
    v42 = 0;
    v43 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v40, v41);
      v45 = *((_QWORD *)ValueAtIndex + 1);
      v46 = (float32x4_t *)*((_QWORD *)ValueAtIndex + 3);
      memset(v86, 0, sizeof(v86));
      v67 = v41;
      if (v46)
        C3DNodeComputeWorldMatrix(v46, (uint64_t)v86);
      else
        C3DMatrix4x4MakeIdentity((uint64_t)v86);
      for (j = 0; j != 9; ++j)
      {
        if (*((uint64_t *)v73 + j) >= 1)
        {
          v48 = 0;
          v49 = v42;
          while (1)
          {
            SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v18, (char)j, v48, 0);
            v51 = C3DMeshGetSourceWithSemanticAtIndex(v45, (char)j, v48, 1);
            if (!v51)
              goto LABEL_43;
            v42 = (uint64_t)v51;
            if ((unint64_t)(j - 2) < 3)
              break;
            if (j == 1)
            {
              v84 = 0u;
              v85 = 0u;
              *(_OWORD *)buf = 0u;
              v83 = 0u;
              C3DMatrix4x4ComputeNormalMatrix((__n128 *)v86, buf);
              v54 = (float32x4_t *)buf;
              v52 = (uint64_t)SourceWithSemanticAtIndex;
              v53 = v42;
              goto LABEL_42;
            }
            if (j)
            {
              v55 = scn_default_log();
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_1DCCB8000, v55, OS_LOG_TYPE_DEFAULT, "Warning: __MergeMeshSources unknown source type\n", buf, 2u);
              }
              goto LABEL_43;
            }
            __TransformAndAppendMeshSource((uint64_t)SourceWithSemanticAtIndex, (uint64_t)v51, v86, v43);
LABEL_44:
            ++v48;
            v49 = v42;
            if (v48 >= *((_QWORD *)v73 + j))
              goto LABEL_48;
          }
          v52 = (uint64_t)SourceWithSemanticAtIndex;
          v53 = v42;
          v54 = 0;
LABEL_42:
          __TransformAndAppendMeshSource(v52, v53, v54, v43);
LABEL_43:
          v42 = v49;
          goto LABEL_44;
        }
LABEL_48:
        ;
      }
      if (v42)
        v43 += C3DMeshSourceGetCount(v42);
      v40 = v63;
      v41 = v67 + 1;
    }
    while (v67 + 1 != Count);
  }
  __ReorderRendererElements(v59);
  CFRelease(cf);
  __DestroyFlattenElementsArray(v40);
  CFRelease(v58);
  CFRelease(v57);
  CFRelease(v40);
  C3DNodeSetMatrix(v62, (uint64_t)v72);
  if (HasPivot)
    C3DNodeSetPivotMatrix(v62, &v68);
  return v59;
}

uint64_t __CreateAndDispatchRendererElements(const void *a1, uint64_t a2)
{
  const __CFDictionary *v4;
  __CFArray *v5;
  uint64_t Geometry;
  uint64_t v7;
  __CFArray *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFArray *ElementsCount;
  uint64_t v22;
  __CFArray *Mutable;
  CFIndex i;
  _QWORD *v25;
  CFIndex Count;
  CFIndex v27;
  uint64_t v28;
  __CFDictionary *v29;
  const CFDictionaryValueCallBacks *v30;
  uint64_t *ValueAtIndex;
  NSObject *v32;
  float v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int Type;
  uint64_t v38;
  const void *v39;
  void *Value;
  void *v41;
  const void *PositionSource;
  uint64_t v43;
  uint64_t SourcesCountForSemantic;
  _OWORD *v45;
  _OWORD *v46;
  __int128 v47;
  __CFArray *theArray;
  const __CFAllocator *allocator;
  uint64_t Mesh;
  uint8_t v52[4];
  _DWORD v53[7];

  *(_QWORD *)&v53[5] = *MEMORY[0x1E0C80C00];
  v4 = *(const __CFDictionary **)a2;
  v5 = *(__CFArray **)(a2 + 32);
  Geometry = C3DNodeGetGeometry((uint64_t)a1);
  if (Geometry)
  {
    v7 = Geometry;
    if ((C3DNodeIsGizmo((uint64_t)a1) & 1) == 0)
    {
      v8 = *(__CFArray **)(a2 + 8);
      Mesh = C3DGeometryGetMesh(v7);
      if (Mesh)
      {
        if (C3DMeshGetPositionSource(Mesh, 1))
        {
          if (!a1)
          {
            v9 = scn_default_log();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
              C3DGeometryTrackNode_cold_2(v9, v10, v11, v12, v13, v14, v15, v16);
          }
          v17 = C3DNodeGetGeometry((uint64_t)a1);
          if (v17)
          {
            v18 = v17;
            v19 = C3DGeometryGetMesh(v17);
            if (v19)
            {
              v20 = v19;
              ElementsCount = C3DMeshGetElementsCount(v19);
              if (ElementsCount)
              {
                v22 = (uint64_t)ElementsCount;
                theArray = v8;
                allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFIndex)ElementsCount, 0);
                if (v22 >= 1)
                {
                  for (i = 0; i != v22; ++i)
                  {
                    v25 = malloc_type_malloc(0x20uLL, 0x20040DC1BFBCFuLL);
                    v25[1] = v20;
                    *v25 = C3DMeshGetElementAtIndex(v20, i, 1);
                    v25[2] = C3DGeometryGetMaterialAtIndex(v18, i);
                    v25[3] = a1;
                    CFArrayAppendValue(Mutable, v25);
                  }
                }
                if (Mutable)
                {
                  Count = CFArrayGetCount(Mutable);
                  CFArrayAppendValue(v5, a1);
                  if (Count >= 1)
                  {
                    v27 = 0;
                    v28 = *(_QWORD *)(a2 + 16);
                    v29 = *(__CFDictionary **)(a2 + 40);
                    v30 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
                    do
                    {
                      ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(Mutable, v27);
                      if (!ValueAtIndex)
                      {
                        v32 = scn_default_log();
                        if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
                          __CreateAndDispatchRendererElements_cold_1(v52, v53, v32);
                      }
                      C3DNodeGetWorldAlpha(ValueAtIndex[3]);
                      v35 = 0;
                      if (v33 >= 1.0)
                      {
                        v34 = ValueAtIndex[2];
                        if (!v34 || C3DMaterialIsOpaque(v34))
                          v35 = 1;
                      }
                      v36 = ValueAtIndex[2];
                      if (v36 && C3DMaterialIsDoubleSided(v36))
                        v35 |= 2uLL;
                      Type = C3DMeshElementGetType(*ValueAtIndex);
                      if (Type == 2)
                      {
                        v39 = (const void *)(v35 | 0x10);
                      }
                      else
                      {
                        v38 = v35 | 4;
                        if (Type)
                          v38 = v35;
                        if (Type == 1)
                          v39 = (const void *)(v35 | 8);
                        else
                          v39 = (const void *)v38;
                      }
                      Value = (void *)CFDictionaryGetValue(v4, v39);
                      if (!Value)
                      {
                        Value = CFDictionaryCreateMutable(allocator, 0, 0, v30);
                        CFDictionarySetValue(v4, v39, Value);
                        CFRelease(Value);
                      }
                      CFDictionarySetValue(v29, ValueAtIndex, *(const void **)(v28 + 144));
                      v41 = (void *)CFDictionaryGetValue((CFDictionaryRef)Value, (const void *)ValueAtIndex[2]);
                      if (!v41)
                      {
                        v41 = CFArrayCreateMutable(allocator, 0, 0);
                        CFDictionarySetValue((CFMutableDictionaryRef)Value, (const void *)ValueAtIndex[2], v41);
                        CFRelease(v41);
                      }
                      CFArrayAppendValue((CFMutableArrayRef)v41, ValueAtIndex);
                      ++v27;
                    }
                    while (Count != v27);
                    PositionSource = C3DMeshGetPositionSource(Mesh, 1);
                    if (PositionSource)
                    {
                      v43 = 0;
                      *(_QWORD *)(v28 + 144) += C3DMeshSourceGetCount((uint64_t)PositionSource);
                      do
                      {
                        SourcesCountForSemantic = C3DMeshGetSourcesCountForSemantic(Mesh, (char)v43);
                        if (SourcesCountForSemantic > *(_QWORD *)(v28 + 8 * v43))
                          *(_QWORD *)(v28 + 8 * v43) = SourcesCountForSemantic;
                        ++v43;
                      }
                      while (v43 != 9);
                    }
                    v45 = malloc_type_malloc(0x20uLL, 0x20040DC1BFBCFuLL);
                    v46 = CFArrayGetValueAtIndex(Mutable, 0);
                    v47 = v46[1];
                    *v45 = *v46;
                    v45[1] = v47;
                    CFArrayAppendValue(theArray, v45);
                  }
                  CFRelease(Mutable);
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

void __MergeRendererElements(char a1, CFDictionaryRef theDict, uint64_t *a3)
{
  uint64_t v3;
  int v4;
  uint64_t context;
  uint64_t v6;
  uint64_t v7;

  v3 = a3[1];
  context = *a3;
  v6 = 0;
  if (*(uint64_t *)(v3 + 144) < 0x10000)
    v4 = 2;
  else
    v4 = 4;
  HIDWORD(v6) = v4;
  LOBYTE(v6) = a1 & 1 | (*(_BYTE *)(v3 + 152) != 0);
  v7 = a3[2];
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)__MergeRendererElementsSharingSameMaterial, &context);
}

void __DestroyFlattenElementsArray(const __CFArray *a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex i;
  void *ValueAtIndex;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v3 = Count;
    for (i = 0; i != v3; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      free(ValueAtIndex);
    }
  }
  CFArrayRemoveAllValues(a1);
}

float32x4_t *C3DSplitMeshIfNeeded(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t *v11;
  uint64_t Mesh;
  uint64_t v14;
  const void *PositionSource;
  uint64_t v16;
  uint64_t Name;
  const __CFString *v18;
  size_t v19;
  void *v20;
  const __CFArray *MaterialsCount;
  uint64_t v22;
  uint64_t v23;
  CFIndex v24;
  const void *ElementAtIndex;
  uint64_t v26;
  int Type;
  char v28;
  char DoubleSided;
  uint64_t PrimitiveCount;
  uint64_t IndexCountPerPrimitive;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t Index;
  const __CFArray *MaterialAtIndex;
  int v39;
  char v40;
  char v41;
  BOOL v42;
  const __CFAllocator *v43;
  const __CFArray *v44;
  uint64_t v45;
  const __CFArray *ElementsCount;
  uint64_t v47;
  uint64_t v48;
  CFIndex v49;
  uint64_t Geometry;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  size_t v54;
  const __CFArray *v55;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  __C3DGeometry *v60;
  uint64_t *v61;

  if (!a1)
  {
    v3 = scn_default_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v3, v4, v5, v6, v7, v8, v9, v10);
  }
  Geometry = C3DNodeGetGeometry(a1);
  if (!Geometry)
    return 0;
  if (C3DNodeGetSkinner(a1))
    return 0;
  if (C3DNodeGetMorpher(a1))
    return 0;
  Mesh = C3DGeometryGetMesh(Geometry);
  if (!Mesh)
    return 0;
  v14 = Mesh;
  PositionSource = C3DMeshGetPositionSource(Mesh, 1);
  v16 = PositionSource ? C3DMeshSourceGetCount((uint64_t)PositionSource) : 0;
  if (v16 <= a2)
    return 0;
  v11 = (float32x4_t *)C3DNodeCreate();
  Name = C3DNodeGetName(a1);
  if (Name)
  {
    v18 = CFStringCreateWithFormat(0, 0, CFSTR("%@-splitContainer"), Name);
    C3DNodeSetName((uint64_t)v11, v18);
    CFRelease(v18);
  }
  else
  {
    C3DNodeSetName((uint64_t)v11, CFSTR("splitContainer"));
  }
  v45 = a1;
  C3DNodeAddChildNode(a1, v11);
  CFRelease(v11);
  v19 = 8 * v16;
  v57 = (uint64_t *)malloc_type_malloc(v19, 0x100004000313F17uLL);
  v54 = v19;
  v20 = malloc_type_malloc(v19, 0x100004000313F17uLL);
  MaterialsCount = C3DGeometryGetMaterialsCount(Geometry);
  ElementsCount = C3DMeshGetElementsCount(v14);
  v22 = a2;
  if ((uint64_t)ElementsCount >= 1)
  {
    v23 = 0;
    v24 = 0;
    v60 = 0;
    v61 = 0;
    v59 = 0;
    v52 = (uint64_t)v11;
    v53 = v14;
    v55 = MaterialsCount;
    do
    {
      ElementAtIndex = C3DMeshGetElementAtIndex(v14, v24, 1);
      v58 = v23 + 1;
      _createSubNodeForSplittedMesh((uint64_t)v11, v23, &v61, &v59, &v60);
      v26 = v59;
      Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
      if (Type == 3)
        v28 = 3;
      else
        v28 = 2 * (Type == 2);
      C3DMeshElementSetType(v26, v28);
      DoubleSided = C3DMeshElementGetDoubleSided((uint64_t)ElementAtIndex);
      C3DMeshElementSetDoubleSided(v26, DoubleSided);
      PrimitiveCount = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
      IndexCountPerPrimitive = C3DMeshElementGetIndexCountPerPrimitive((uint64_t)ElementAtIndex);
      bzero(v20, v54);
      v48 = v24 / (uint64_t)MaterialsCount;
      v49 = v24;
      if (PrimitiveCount < 1)
      {
        v34 = 0;
        v36 = 0;
      }
      else
      {
        v32 = 0;
        v33 = 0;
        v34 = 0;
        v51 = IndexCountPerPrimitive - 1;
        v47 = PrimitiveCount;
        do
        {
          if (IndexCountPerPrimitive < 1)
          {
            v36 = v32;
          }
          else
          {
            v35 = 0;
            v36 = v32;
            do
            {
              Index = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v33, v35, 0);
              if (!*((_QWORD *)v20 + Index))
              {
                v57[v36++] = Index;
                *((_QWORD *)v20 + Index) = v36;
                if (v36 == v22)
                {
                  if (v35 == v51)
                    v32 = v22;
                  v33 -= v35 != v51;
                  _finalizeSplit(v34, (const __CFAllocator *)(v33 + 1), (uint64_t)v20, v57, v32, (uint64_t)ElementAtIndex, v26, (uint64_t)v61, v53);
                  if (v55)
                  {
                    MaterialAtIndex = C3DGeometryGetMaterialAtIndex(Geometry, v49 - v48 * (_QWORD)v55);
                    C3DGeometryInsertMaterialAtIndex((uint64_t)v60, MaterialAtIndex, 0);
                  }
                  _createSubNodeForSplittedMesh(v52, v58, &v61, &v59, &v60);
                  v26 = v59;
                  v39 = C3DMeshElementGetType((uint64_t)ElementAtIndex);
                  if (v39 == 3)
                    v40 = 3;
                  else
                    v40 = 2 * (v39 == 2);
                  C3DMeshElementSetType(v26, v40);
                  v41 = C3DMeshElementGetDoubleSided((uint64_t)ElementAtIndex);
                  C3DMeshElementSetDoubleSided(v26, v41);
                  bzero(v20, v54);
                  v36 = 0;
                  v34 = v33 + 1;
                  v35 = IndexCountPerPrimitive;
                  ++v58;
                  v22 = a2;
                }
              }
              ++v35;
            }
            while (v35 < IndexCountPerPrimitive);
          }
          ++v33;
          v32 = v36;
          PrimitiveCount = v47;
        }
        while (v33 < v47);
      }
      v42 = v34 < PrimitiveCount;
      v43 = (const __CFAllocator *)PrimitiveCount;
      v14 = v53;
      if (v42)
      {
        _finalizeSplit(v34, v43, (uint64_t)v20, v57, v36, (uint64_t)ElementAtIndex, v26, (uint64_t)v61, v53);
        if (v55)
        {
          v44 = C3DGeometryGetMaterialAtIndex(Geometry, v49 - v48 * (_QWORD)v55);
          C3DGeometryInsertMaterialAtIndex((uint64_t)v60, v44, 0);
        }
      }
      v24 = v49 + 1;
      v11 = (float32x4_t *)v52;
      MaterialsCount = v55;
      v23 = v58;
    }
    while ((const __CFArray *)(v49 + 1) != ElementsCount);
  }
  free(v20);
  free(v57);
  C3DNodeSetGeometry(v45, 0);
  return v11;
}

void _createSubNodeForSplittedMesh(uint64_t a1, uint64_t a2, uint64_t **a3, _QWORD *a4, __C3DGeometry **a5)
{
  float32x4_t *v10;
  uint64_t Name;
  const __CFString *v12;
  __C3DGeometry *v13;
  uint64_t *v14;
  const void *v15;

  v10 = (float32x4_t *)C3DNodeCreate();
  C3DNodeAddChildNode(a1, v10);
  Name = C3DNodeGetName(a1);
  if (Name)
  {
    v12 = CFStringCreateWithFormat(0, 0, CFSTR("%@-split%d"), Name, a2);
    C3DNodeSetName((uint64_t)v10, v12);
    CFRelease(v12);
  }
  v13 = (__C3DGeometry *)C3DGeometryCreate();
  v14 = (uint64_t *)C3DMeshCreate();
  C3DNodeSetGeometry((uint64_t)v10, v13);
  C3DGeometrySetMesh((uint64_t)v13, v14);
  v15 = (const void *)C3DMeshElementCreate();
  C3DMeshAppendElement((uint64_t)v14, v15);
  CFRelease(v15);
  CFRelease(v14);
  CFRelease(v13);
  CFRelease(v10);
  *a4 = v15;
  *a3 = v14;
  *a5 = v13;
}

void _finalizeSplit(uint64_t a1, const __CFAllocator *a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v13;
  char *v14;
  BOOL v15;
  unsigned int v16;
  uint64_t IndexCountPerPrimitive;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  char v21;
  const __CFArray *v22;
  uint64_t v23;
  UInt8 *v24;
  UInt8 *v25;
  uint64_t Index;
  NSObject *v27;
  int v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  CFDataRef v37;
  uint64_t v38;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t ComponentsCountPerValue;
  int ValueType;
  _QWORD *Accessor;
  size_t v44;
  CFIndex v45;
  const UInt8 *v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  const UInt8 *ValuePtrAtIndex;
  NSObject *v51;
  CFDataRef v52;
  __int16 Semantic;
  const void *v54;
  char *v55;
  CFIndex length;
  UInt8 *bytes;
  CFIndex bytesa;
  CFAllocatorRef bytesDeallocator;
  const __CFAllocator *bytesDeallocatora;
  CFArrayRef theArray;
  const __CFArray *theArraya;
  uint64_t v66;
  UInt8 *v67;
  uint64_t v68;
  uint8_t v69[4];
  uint64_t v70;
  uint8_t v71[4];
  _DWORD v72[7];

  v13 = a1;
  *(_QWORD *)&v72[5] = *MEMORY[0x1E0C80C00];
  v14 = (char *)a2 - a1;
  v15 = a5 > 255;
  if (a5 <= 255)
    v16 = 1;
  else
    v16 = 2;
  IndexCountPerPrimitive = C3DMeshElementGetIndexCountPerPrimitive(a6);
  v18 = IndexCountPerPrimitive;
  v66 = a5;
  v19 = a5 < 0x10000;
  if (a5 < 0x10000)
    v20 = v16;
  else
    v20 = 4;
  v21 = 2;
  if (v19)
    v21 = v15;
  length = (IndexCountPerPrimitive << v21) * (_QWORD)v14;
  bytes = (UInt8 *)malloc_type_malloc(length, 0x6FA693C6uLL);
  bytesDeallocator = a2;
  v55 = (char *)a2 - v13;
  v22 = 0;
  if ((uint64_t)a2 > v13)
  {
    do
    {
      if (v18 >= 1)
      {
        v23 = 0;
        v67 = &bytes[2 * (_QWORD)v22];
        v24 = (UInt8 *)v22 + (_QWORD)bytes;
        theArray = v22;
        v25 = &bytes[4 * (_QWORD)v22];
        do
        {
          Index = C3DMeshElementGetIndex(a6, v13, v23, 0);
          if (!*(_QWORD *)(a3 + 8 * Index))
          {
            v27 = scn_default_log();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
              _finalizeSplit_cold_3(v69, &v70, v27);
          }
          v28 = *(_DWORD *)(a3 + 8 * Index) - 1;
          if (v20 == 2)
          {
            *(_WORD *)&v67[2 * v23] = v28;
          }
          else if (v20 == 1)
          {
            v24[v23] = v28;
          }
          else
          {
            *(_DWORD *)&v25[4 * v23] = v28;
          }
          ++v23;
        }
        while (v18 != v23);
        v22 = (CFArrayRef)((char *)theArray + v23);
      }
      ++v13;
    }
    while ((CFAllocatorRef)v13 != bytesDeallocator);
  }
  if (v22 != (const __CFArray *)(v18 * (_QWORD)v55))
  {
    v29 = scn_default_log();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
      _finalizeSplit_cold_2(v29, v30, v31, v32, v33, v34, v35, v36);
  }
  bytesDeallocatora = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v37 = CFDataCreateWithBytesNoCopy(0, bytes, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  C3DMeshElementSetPrimitives(a7, (int)v55, v37, v20);
  CFRelease(v37);
  theArraya = C3DMeshCopyAllSources(a9, 1);
  bytesa = CFArrayGetCount(theArraya);
  v38 = v66;
  if (bytesa >= 1)
  {
    for (i = 0; i != bytesa; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArraya, i);
      ComponentsCountPerValue = C3DMeshSourceGetComponentsCountPerValue((uint64_t)ValueAtIndex);
      ValueType = C3DMeshSourceGetValueType((uint64_t)ValueAtIndex);
      Accessor = (_QWORD *)C3DMeshSourceGetAccessor(ValueAtIndex);
      v68 = ComponentsCountPerValue;
      v44 = C3DSizeOfBaseType(ValueType) * ComponentsCountPerValue;
      v45 = v44 * v38;
      v46 = (const UInt8 *)malloc_type_malloc(v44 * v38, 0x84E99E34uLL);
      if (v38 < 1)
      {
        v47 = 0;
      }
      else
      {
        v47 = 0;
        v48 = a4;
        do
        {
          v49 = *v48++;
          ValuePtrAtIndex = C3DSourceAccessorGetValuePtrAtIndex(Accessor, v49);
          memcpy((void *)&v46[v47], ValuePtrAtIndex, v44);
          v47 += v44;
          --v38;
        }
        while (v38);
      }
      if (v47 != v45)
      {
        v51 = scn_default_log();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT))
          _finalizeSplit_cold_1(v71, v72, v51);
      }
      v52 = CFDataCreateWithBytesNoCopy(0, v46, v45, bytesDeallocatora);
      Semantic = C3DMeshSourceGetSemantic((uint64_t)ValueAtIndex);
      v38 = v66;
      v54 = (const void *)C3DMeshSourceCreate(v52, Semantic, v66, v68, ValueType);
      CFRelease(v52);
      C3DMeshAddSource(a8, v54, 0, 0);
      CFRelease(v54);
    }
  }
  CFRelease(theArraya);
}

void C3DSplitMeshesIfNeededInNodeTree(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12[3])(uint64_t, uint64_t);
  uint64_t v13;
  CFTypeRef cf;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryTrackNode_cold_2(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  v13 = a2;
  cf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], 0);
  v12[0] = 0;
  v12[1] = (uint64_t (*)(uint64_t, uint64_t))_C3DSplitMeshesIfNeededInNodeTree;
  v12[2] = 0;
  C3DNodeIterateTree(a1, v12, 1, (uint64_t)&v13);
  CFRelease(cf);
}

uint64_t _C3DSplitMeshesIfNeededInNodeTree(uint64_t a1, uint64_t *a2)
{
  float32x4_t *Geometry;
  float32x4_t *Copy;
  const __CFDictionary *v6;
  const void *Value;
  uint64_t v8;
  float32x4_t *v9;

  Geometry = (float32x4_t *)C3DNodeGetGeometry(a1);
  if (Geometry)
  {
    Copy = Geometry;
    v6 = (const __CFDictionary *)a2[1];
    Value = CFDictionaryGetValue(v6, Geometry);
    if (Value)
    {
      Copy = (float32x4_t *)C3DNodeCreateCopy((uint64_t)Value, 1);
      C3DNodeAddChildNode(a1, Copy);
      C3DNodeSetGeometry(a1, 0);
    }
    else
    {
      v8 = *a2;
      CFRetain(Copy);
      v9 = C3DSplitMeshIfNeeded(a1, v8);
      if (v9)
        CFDictionarySetValue(v6, Copy, v9);
    }
    CFRelease(Copy);
  }
  return 0;
}

uint64_t C3DVRAMResourceGetID(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DVRAMResourceGetID_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 48);
}

void C3DVRAMResourceSetID(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DVRAMResourceSetID_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  *(_QWORD *)(a1 + 48) = a2;
}

uint64_t C3DVRAMResourceIsAttachment(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DVRAMResourceSetID_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(unsigned __int8 *)(a1 + 60);
}

uint64_t C3DVRAMResourceLockCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t C3DVRAMResourceLock(uint64_t a1)
{
  uint64_t v1;

  v1 = (*(_DWORD *)(a1 + 56) + 1);
  *(_DWORD *)(a1 + 56) = v1;
  return v1;
}

uint64_t C3DVRAMResourceUnlock(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  uint8_t v13[16];

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DVRAMResourceSetID_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = *(_DWORD *)(a1 + 56);
  if (v10)
  {
    *(_DWORD *)(a1 + 56) = v10 - 1;
  }
  else
  {
    v11 = scn_default_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v13 = 0;
      _os_log_impl(&dword_1DCCB8000, v11, OS_LOG_TYPE_DEFAULT, "Warning: unlock not locked ressource\n", v13, 2u);
    }
  }
  return *(unsigned int *)(a1 + 56);
}

uint64_t C3DMeshCreateByMergingMeshes(const __CFArray *a1)
{
  CFIndex Count;
  uint64_t v2;
  const void *ValueAtIndex;
  const void *Mutable;
  const void *v6;
  uint64_t v7;
  const void *v8;
  CFIndex v9;
  uint64_t v10;
  const void *v11;
  const void *SourceWithSemanticAtIndex;
  const void *v13;
  const void *v14;
  uint64_t v15;
  uint64_t i;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  CFIndex v20;
  const void *ElementAtIndex;
  int Type;
  CFMutableDataRef v23;
  uint64_t PrimitiveCount;
  uint64_t v25;
  uint64_t j;
  __CFData *v27;
  CFIndex v28;
  NSObject *v29;
  uint64_t v30;
  __CFData *v31;
  CFIndex v32;
  NSObject *v33;
  char v34;
  const void *v35;
  const void *v36;
  uint64_t v37;
  const void *v38;
  const void *v39;
  CFIndex v41;
  const __CFAllocator *allocator;
  uint64_t v43;
  double ValueAtIndexAsVector2;
  __int128 v45;
  uint8_t v46[4];
  uint64_t v47;
  uint8_t v48[4];
  uint64_t v49;
  UInt8 bytes[16];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  Count = CFArrayGetCount(a1);
  if (!Count)
    return 0;
  v2 = Count;
  if (Count == 1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
    return C3DMeshCreateCopy((uint64_t)ValueAtIndex);
  }
  v43 = C3DMeshCreate();
  Mutable = (const void *)C3DMeshSourceCreateMutable(0, 0, 0, 3, 1);
  v6 = (const void *)C3DMeshSourceCreateMutable(0, 1, 0, 3, 1);
  v7 = C3DMeshSourceCreateMutable(0, 3, 0, 2, 1);
  v8 = (const void *)v7;
  if (v2 >= 1)
  {
    v9 = 0;
    v10 = 0;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v38 = v6;
    v39 = Mutable;
    v36 = (const void *)v7;
    v37 = v2;
    while (1)
    {
      v41 = v9;
      v11 = CFArrayGetValueAtIndex(a1, v9);
      SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v11, 0, 0, 1);
      v13 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v11, 1, 0, 1);
      v14 = C3DMeshGetSourceWithSemanticAtIndex((uint64_t)v11, 3, 0, 1);
      v15 = C3DMeshSourceGetCount((uint64_t)SourceWithSemanticAtIndex);
      if (v15 >= 1)
      {
        for (i = 0; i != v15; ++i)
        {
          *(_DWORD *)&bytes[8] = 0;
          *(_QWORD *)bytes = 0;
          *(double *)&v17 = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)SourceWithSemanticAtIndex, i);
          *(_OWORD *)bytes = v17;
          C3DMeshSourceAppendVector3((uint64_t)Mutable, (uint64_t)bytes, 1);
          DWORD2(v45) = 0;
          *(_QWORD *)&v45 = 0;
          *(double *)&v18 = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)v13, i);
          v45 = v18;
          C3DMeshSourceAppendVector3((uint64_t)v6, (uint64_t)&v45, 1);
          ValueAtIndexAsVector2 = 0.0;
          ValueAtIndexAsVector2 = C3DMeshSourceGetValueAtIndexAsVector2((uint64_t)v14, i);
          C3DMeshSourceAppendVector2((uint64_t)v8, (uint64_t)&ValueAtIndexAsVector2, 1);
        }
      }
      v19 = v15 + v10;
      if ((uint64_t)C3DMeshGetElementsCount((uint64_t)v11) >= 1)
        break;
LABEL_44:
      v9 = v41 + 1;
      v10 = v19;
      v6 = v38;
      Mutable = v39;
      v8 = v36;
      if (v41 + 1 == v37)
        goto LABEL_45;
    }
    v20 = 0;
    while (1)
    {
      ElementAtIndex = C3DMeshGetElementAtIndex((uint64_t)v11, v20, 1);
      Type = C3DMeshElementGetType((uint64_t)ElementAtIndex);
      v23 = CFDataCreateMutable(allocator, 0);
      PrimitiveCount = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
      v25 = PrimitiveCount;
      if (v19 >= 0x10000)
        break;
      if (PrimitiveCount >= 1)
      {
        for (j = 0; v25 != j; ++j)
        {
          if (Type == 3)
          {
            *(_WORD *)bytes = 0;
            *(_WORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 0, 0) + v10;
            v27 = v23;
            v28 = 2;
          }
          else if (Type == 2)
          {
            *(_WORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 0, 0) + v10;
            *(_WORD *)&bytes[2] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 1, 0) + v10;
            v27 = v23;
            v28 = 4;
          }
          else
          {
            if ((_BYTE)Type)
            {
              v29 = scn_default_log();
              if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
                C3DMeshCreateByMergingMeshes_cold_1(v48, &v49, v29);
              continue;
            }
            *(_WORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 0, 0) + v10;
            *(_WORD *)&bytes[2] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 1, 0) + v10;
            *(_WORD *)&bytes[4] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, j, 2, 0) + v10;
            v27 = v23;
            v28 = 6;
          }
          CFDataAppendBytes(v27, bytes, v28);
        }
      }
      v34 = 2;
LABEL_41:
      v35 = (const void *)C3DMeshElementCreate();
      C3DMeshElementInit((uint64_t)v35, Type, v25, v23, v34);
      C3DMeshAppendElement(v43, v35);
      if (v35)
        CFRelease(v35);
      CFRelease(v23);
      if (++v20 >= (uint64_t)C3DMeshGetElementsCount((uint64_t)v11))
        goto LABEL_44;
    }
    if (PrimitiveCount < 1)
    {
LABEL_40:
      v34 = 4;
      goto LABEL_41;
    }
    v30 = 0;
    while (1)
    {
      if (Type == 3)
      {
        *(_DWORD *)bytes = 0;
        *(_DWORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 0, 0) + v10;
        v31 = v23;
        v32 = 4;
      }
      else if (Type == 2)
      {
        *(_DWORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 0, 0) + v10;
        *(_DWORD *)&bytes[4] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 1, 0) + v10;
        v31 = v23;
        v32 = 8;
      }
      else
      {
        if ((_BYTE)Type)
        {
          v33 = scn_default_log();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
            C3DMeshCreateByMergingMeshes_cold_1(v46, &v47, v33);
          goto LABEL_37;
        }
        *(_DWORD *)bytes = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 0, 0) + v10;
        *(_DWORD *)&bytes[4] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 1, 0) + v10;
        *(_DWORD *)&bytes[8] = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, v30, 2, 0) + v10;
        v31 = v23;
        v32 = 12;
      }
      CFDataAppendBytes(v31, bytes, v32);
LABEL_37:
      if (v25 == ++v30)
        goto LABEL_40;
    }
  }
LABEL_45:
  C3DMeshSourceMakeImmutable(Mutable);
  C3DMeshSourceMakeImmutable(v6);
  C3DMeshSourceMakeImmutable(v8);
  C3DMeshAddSource(v43, Mutable, 0, 0);
  C3DMeshAddSource(v43, v6, 0, 0);
  C3DMeshAddSource(v43, v8, 0, 0);
  CFRelease(Mutable);
  CFRelease(v6);
  CFRelease(v8);
  return v43;
}

const void *C3DMeshSubdivide(uint64_t a1, CFIndex a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t PrimitiveCount;
  const void *MeshElement;
  _QWORD *v16;
  uint64_t v17;
  float32x4_t *v18;
  float32x2_t *v19;
  _BOOL4 v20;
  uint64_t i;
  uint64_t *EdgeAtIndex;
  uint64_t *v23;
  __int128 v24;
  float32x4_t v25;
  float32x4_t v26;
  int32x4_t v27;
  float32x2_t v28;
  float32x2_t v29;
  double ValueAtIndexAsVector2;
  uint64_t j;
  uint64_t *v32;
  __int128 v33;
  float32x4_t v34;
  float32x4_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  float32x4_t v40;
  float32x4_t v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  float32x4_t v45;
  float32x4_t v46;
  uint64_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  char v53;
  char v54;
  float32x4_t v55;
  int32x4_t v56;
  float32x2_t v57;
  float32x2_t v58;
  float v59;
  float v60;
  float v61;
  NSObject *v62;
  float v63;
  float v64;
  float v65;
  uint64_t k;
  uint64_t *EdgesAtFaceIndex;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t *v71;
  _QWORD *v72;
  uint64_t *v73;
  uint64_t Index;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  BOOL v84;
  BOOL v85;
  uint64_t v86;
  uint64_t v87;
  BOOL v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  BOOL v96;
  uint64_t v97;
  NSObject *v100;
  uint64_t v102;
  float32x4_t *v103;
  float32x4_t v104;
  const void *v105;
  uint64_t v106;
  uint64_t Count;
  float32x4_t v108;
  int v109;
  float32x4_t v110;
  float32x4_t v111;
  CFTypeRef cfb[2];
  CFTypeRef cfc[2];
  CFTypeRef cf[2];
  _QWORD *cfa;
  uint8_t v116;
  char v117[7];
  _DWORD v118[2];
  _OWORD v119[2];
  _OWORD v120[2];
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  PrimitiveCount = C3DMeshElementGetPrimitiveCount((uint64_t)a3);
  if (C3DMeshElementGetType((uint64_t)a3) == 2)
    return 0;
  v109 = a7;
  v106 = PrimitiveCount;
  v102 = (uint64_t)a3;
  v105 = (const void *)C3DMeshElementEditorCreateWithMeshElementAndCapacity(a3, 4 * PrimitiveCount);
  Count = C3DMeshSourceGetCount(a4);
  v16 = C3DEdgeArrayCreateFromMeshElement(a1, a2);
  v17 = C3DEdgeArrayGetCount((uint64_t)v16);
  v18 = (float32x4_t *)malloc_type_malloc(16 * v17, 0x1000040451B5BE8uLL);
  if (a6)
  {
    v19 = (float32x2_t *)malloc_type_malloc(8 * v17, 0x100004000313F17uLL);
    v20 = a5 != 0;
LABEL_7:
    if (v17 >= 1)
    {
      for (i = 0; i != v17; ++i)
      {
        EdgeAtIndex = (uint64_t *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, i);
        v23 = EdgeAtIndex;
        if (v20)
        {
          *(double *)&v24 = C3DMeshSourceGetValueAtIndexAsVector3(a5, *EdgeAtIndex);
          *(_OWORD *)cfb = v24;
          *(double *)v25.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a5, v23[1]);
          *(double *)v26.i64 = C3DVector3MidVector(*(float32x4_t *)cfb, v25);
          v27 = (int32x4_t)vmulq_f32(v26, v26);
          v27.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v27, 2), vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1))).u32[0];
          v28 = vrsqrte_f32((float32x2_t)v27.u32[0]);
          v29 = vmul_f32(v28, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v28, v28)));
          v18[i] = vmulq_n_f32(v26, vmul_f32(v29, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v29, v29))).f32[0]);
        }
        if (a6)
        {
          ValueAtIndexAsVector2 = C3DMeshSourceGetValueAtIndexAsVector2(a6, *v23);
          v19[i] = vmul_f32(vadd_f32(*(float32x2_t *)&ValueAtIndexAsVector2, COERCE_FLOAT32X2_T(C3DMeshSourceGetValueAtIndexAsVector2(a6, v23[1]))), (float32x2_t)0x3F0000003F000000);
        }
      }
    }
    if (v20)
      C3DMeshSourceAppendVector3(a5, (uint64_t)v18, v17);
    if (a6)
      C3DMeshSourceAppendVector2(a6, (uint64_t)v19, v17);
    if (v19)
      free(v19);
    goto LABEL_20;
  }
  v20 = a5 != 0;
  if (a5)
  {
    v19 = 0;
    goto LABEL_7;
  }
LABEL_20:
  if (v17 >= 1)
  {
    for (j = 0; j != v17; ++j)
    {
      v32 = (uint64_t *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, j);
      *(double *)&v33 = C3DMeshSourceGetValueAtIndexAsVector3(a4, *v32);
      *(_OWORD *)cfc = v33;
      *(double *)v34.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a4, v32[1]);
      *(double *)v35.i64 = C3DVector3MidVector(*(float32x4_t *)cfc, v34);
      v18[j] = v35;
    }
    if ((v20 & v109) == 1)
    {
      v36 = 0;
      v103 = v18;
      do
      {
        v37 = (uint64_t *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, v36);
        v38 = *v37;
        v39 = v37[1];
        *(double *)v40.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a4, *v37);
        v104 = v40;
        v120[0] = v40;
        *(double *)v41.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a4, v39);
        v110 = v41;
        v120[1] = v41;
        *(double *)&v42 = C3DMeshSourceGetValueAtIndexAsVector3(a5, v38);
        v119[0] = v42;
        *(double *)&v43 = C3DMeshSourceGetValueAtIndexAsVector3(a5, v39);
        v119[1] = v43;
        v108 = v18[v36];
        v44 = a5;
        *(double *)v45.i64 = C3DMeshSourceGetValueAtIndexAsVector3(a5, v36 + Count);
        v46 = v45;
        v47 = 0;
        v48 = vsubq_f32(v104, v108);
        v49 = vmulq_f32(v48, v48);
        v50 = vsubq_f32(v110, v108);
        v51 = vmulq_f32(v50, v50);
        v118[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2), vaddq_f32(v49, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v49.f32, 1))).f32[0]);
        v118[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).f32[0]);
        v52 = 0uLL;
        v53 = 1;
        *(float32x4_t *)cf = v46;
        do
        {
          v111 = v52;
          v54 = v53;
          v55 = vsubq_f32((float32x4_t)v120[v47], v108);
          v56 = (int32x4_t)vmulq_f32(v55, v55);
          v56.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v56, 2), vadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v56.i8, 1))).u32[0];
          v57 = vrsqrte_f32((float32x2_t)v56.u32[0]);
          v58 = vmul_f32(v57, vrsqrts_f32((float32x2_t)v56.u32[0], vmul_f32(v57, v57)));
          v59 = C3DVector3Angle(vmulq_n_f32(v55, vmul_f32(v58, vrsqrts_f32((float32x2_t)v56.u32[0], vmul_f32(v58, v58))).f32[0]), v46);
          v60 = C3DVector3Angle(*(float32x4_t *)cf, (float32x4_t)v119[v47]) * 0.5;
          v61 = cosf(v60);
          if (v61 == 0.0)
          {
            v62 = scn_default_log();
            v63 = 1.0;
            if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
              C3DMeshSubdivide_cold_2(&v116, v117, v62);
          }
          else
          {
            v63 = v61;
          }
          v64 = *(float *)&v118[v47];
          v65 = cosf(v59 - v60);
          v53 = 0;
          v46 = *(float32x4_t *)cf;
          v52 = vaddq_f32(v111, vmulq_n_f32(*(float32x4_t *)cf, (float)((float)(v65 * v64) / v63) * 0.5));
          v47 = 1;
        }
        while ((v54 & 1) != 0);
        v103[v36++] = vaddq_f32(v108, v52);
        a5 = v44;
        v18 = v103;
      }
      while (v36 != v17);
    }
  }
  C3DMeshSourceAppendVector3(a4, (uint64_t)v18, v17);
  free(v18);
  cfa = C3DTriangulationInfoCreateFromMeshElement(v102, a4, (uint64_t)v16);
  if (v106 >= 1)
  {
    for (k = 0; k != v106; ++k)
    {
      EdgesAtFaceIndex = (uint64_t *)C3DTriangulationInfoGetEdgesAtFaceIndex((uint64_t)cfa, k);
      v69 = *EdgesAtFaceIndex;
      v68 = EdgesAtFaceIndex[1];
      v70 = EdgesAtFaceIndex[2];
      v71 = (uint64_t *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, *EdgesAtFaceIndex);
      v72 = (_QWORD *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, v68);
      v73 = (uint64_t *)C3DEdgeArrayGetEdgeAtIndex((uint64_t)v16, v70);
      Index = C3DMeshElementGetIndex(v102, k, 0, 0);
      v75 = C3DMeshElementGetIndex(v102, k, 2, 0);
      v76 = *v71;
      if (*v71 == Index)
      {
        v77 = v71[1];
        v78 = Count;
        v79 = v69 + Count;
        v80 = v77 == v75;
        if (v77 == v75)
          v81 = v69 + Count;
        else
          v81 = -1;
        if (v80)
          v79 = -1;
        v82 = -1;
      }
      else
      {
        v83 = v71[1];
        v78 = Count;
        v84 = v83 == Index;
        if (v83 == Index)
          v79 = v69 + Count;
        else
          v79 = -1;
        if (v84)
          v82 = -1;
        else
          v82 = v69 + Count;
        v85 = v76 == v75;
        if (v76 == v75)
          v81 = v79;
        else
          v81 = -1;
        if (v85)
          v79 = -1;
      }
      if (*v72 == Index)
      {
        if (v72[1] == v75)
          v81 = v68 + v78;
        else
          v79 = v68 + v78;
      }
      else
      {
        v86 = v72[1];
        v87 = v68 + v78;
        v88 = v86 == Index;
        if (v86 == Index)
        {
          v89 = v68 + v78;
        }
        else
        {
          v82 = v68 + v78;
          v89 = v79;
        }
        if (!v88)
          v87 = v81;
        if (*v72 == v75)
          v81 = v87;
        else
          v79 = v89;
      }
      v90 = *v73;
      if (*v73 == Index)
      {
        v91 = v73[1];
        if (v91 == v75)
          v92 = v70 + v78;
        else
          v92 = v81;
        if (v91 == v75)
          v93 = v79;
        else
          v93 = v70 + v78;
      }
      else
      {
        v94 = v73[1];
        v95 = v70 + v78;
        v96 = v94 == Index;
        if (v94 == Index)
        {
          v97 = v70 + v78;
        }
        else
        {
          v82 = v70 + v78;
          v97 = v79;
        }
        if (!v96)
          v95 = v81;
        if (v90 == v75)
          v92 = v95;
        else
          v92 = v81;
        if (v90 == v75)
          v93 = v79;
        else
          v93 = v97;
      }
      if (v92 == -1 || v93 == -1 || v82 == -1)
      {
        v100 = scn_default_log();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT))
          C3DMeshSubdivide_cold_1((uint8_t *)v120, (_OWORD *)((char *)v120 + 4), v100);
      }
      C3DMeshElementEditorSubdivideTriangleAtIndex((uint64_t)v105, k, v92, v93, v82);
    }
  }
  MeshElement = (const void *)C3DMeshElementEditorGenerateMeshElement((uint64_t)v105);
  CFRetain(MeshElement);
  CFRelease(v105);
  CFRelease(v16);
  CFRelease(cfa);
  return MeshElement;
}

uint64_t C3DMeshCopyWithTransform(uint64_t a1, float32x4_t *a2)
{
  uint64_t Copy;
  const void *PositionSource;
  const void *DeepCopy;
  _QWORD *Accessor;
  uint64_t Count;
  unsigned __int8 ChannelForSourceWithSemanticAtIndex;
  const void *NormalSource;
  uint64_t v11;
  const void *v12;
  unsigned __int8 v13;
  float32x4_t v15[4];

  memset(v15, 0, sizeof(v15));
  Copy = C3DMeshCreateCopy(a1);
  PositionSource = C3DMeshGetPositionSource(Copy, 0);
  DeepCopy = (const void *)C3DMeshSourceCreateDeepCopy((uint64_t)PositionSource);
  Accessor = (_QWORD *)C3DGenericSourceGetAccessor((uint64_t)DeepCopy);
  Count = C3DMeshSourceGetCount((uint64_t)DeepCopy);
  __C3DTransformFloatsInAccessor(Accessor, 0, Count, a2, 0);
  ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 0, 0);
  C3DMeshSetSourceWithInputSet(Copy, DeepCopy, 0, ChannelForSourceWithSemanticAtIndex);
  NormalSource = C3DMeshGetNormalSource(Copy, 0);
  if (NormalSource)
  {
    v11 = (uint64_t)NormalSource;
    v12 = (const void *)C3DMeshSourceCreateDeepCopy((uint64_t)NormalSource);
    __MakeNormalMatrix((__n128 *)a2, v15);
    __TransformAndAppendMeshSource((uint64_t)v12, v11, v15, 0);
    v13 = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 1, 0);
    C3DMeshSetSourceWithInputSet(Copy, v12, 0, v13);
    CFRelease(v12);
  }
  CFRelease(DeepCopy);
  return Copy;
}

void __C3DTransformFloatsInAccessor(_QWORD *a1, uint64_t a2, uint64_t a3, float32x4_t *a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  __CFData *MutableValuePtrAtIndex;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  double v16;
  int v17;
  float32x4_t v18[4];
  uint64_t v19;
  uint64_t v20;

  if (a3 >= 1)
  {
    v19 = v5;
    v20 = v6;
    v9 = a3;
    do
    {
      MutableValuePtrAtIndex = C3DSourceAccessorGetMutableValuePtrAtIndex(a1, a2);
      v13.i64[0] = *(_QWORD *)MutableValuePtrAtIndex;
      v13.i32[2] = *((_DWORD *)MutableValuePtrAtIndex + 2);
      v14 = a4[1];
      v18[0] = *a4;
      v18[1] = v14;
      v15 = a4[3];
      v18[2] = a4[2];
      v18[3] = v15;
      if (a5)
        v16 = C3DVector3Rotate((float32x2_t *)v18, v13);
      else
        v16 = C3DVector3MultMatrix4x4(v18, v13);
      *(double *)MutableValuePtrAtIndex = v16;
      *((_DWORD *)MutableValuePtrAtIndex + 2) = v17;
      ++a2;
      --v9;
    }
    while (v9);
  }
}

void __TransformAndAppendMeshSource(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  _QWORD *Accessor;
  uint64_t v9;
  uint64_t Count;
  __CFData *MutableValuePtrAtIndex;
  uint64_t v12;
  uint64_t ComponentsCountPerValue;
  _BOOL4 v14;
  NSObject *v15;

  Accessor = (_QWORD *)C3DGenericSourceGetAccessor(a1);
  v9 = C3DGenericSourceGetAccessor(a2);
  Count = C3DSourceAccessorGetCount(v9);
  if (C3DSourceAccessorCopyDataToAccessor(v9, (uint64_t)Accessor, a4))
  {
    MutableValuePtrAtIndex = C3DSourceAccessorGetMutableValuePtrAtIndex(Accessor, 0);
    v12 = C3DSourceAccessorGetCount((uint64_t)Accessor);
    ComponentsCountPerValue = C3DSourceAccessorGetComponentsCountPerValue(v9);
    _C3DMeshSourceSetupNonInitializedComponents(a1, (uint64_t)MutableValuePtrAtIndex, v12, ComponentsCountPerValue);
    if (a3)
    {
      v14 = C3DMeshSourceGetSemantic(a1) == 1;
      __C3DTransformFloatsInAccessor(Accessor, a4, Count, a3, v14);
    }
  }
  else
  {
    v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      __TransformAndAppendMeshSource_cold_1();
  }
}

uint64_t C3DWarmupMaterialVRAMResourcesForEngineContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t CommonProfile;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[7];
  _QWORD v15[7];

  CommonProfile = C3DMaterialGetCommonProfile(a1);
  if (!CommonProfile)
    return 1;
  v14[6] = a2;
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v15[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke;
  v15[3] = &unk_1EA59E0F0;
  v15[5] = CommonProfile;
  v15[6] = a2;
  v15[4] = a3;
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3221225472;
  v14[2] = __C3DWarmupMaterialVRAMResourcesForEngineContext_block_invoke_2;
  v14[3] = &unk_1EA59E0F0;
  v14[4] = a3;
  v14[5] = CommonProfile;
  return C3DExecuteProgressBlocks((uint64_t)v15, v6, v7, v8, v9, v10, v11, v12, (uint64_t)v14);
}

uint64_t C3DWarmupGeometryVRAMResourcesForEngineContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t RendererContextGL;
  uint64_t ResourceManager;
  uint64_t RenderContext;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v18[9];
  _QWORD v19[7];

  RendererContextGL = C3DEngineContextGetRendererContextGL(a2);
  ResourceManager = C3DEngineContextGetResourceManager(a2);
  RenderContext = C3DEngineContextGetRenderContext(a2);
  v9 = -[SCNMTLRenderContext resourceManager](RenderContext);
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 3221225472;
  v19[2] = __C3DWarmupGeometryVRAMResourcesForEngineContext_block_invoke;
  v19[3] = &unk_1EA59E0F0;
  v19[5] = a1;
  v19[6] = a2;
  v19[4] = a3;
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3221225472;
  v18[2] = __C3DWarmupGeometryVRAMResourcesForEngineContext_block_invoke_2;
  v18[3] = &unk_1EA59E118;
  v18[6] = a1;
  v18[7] = ResourceManager;
  v18[8] = RendererContextGL;
  v18[4] = v9;
  v18[5] = a3;
  return C3DExecuteProgressBlocks((uint64_t)v19, v10, v11, v12, v13, v14, v15, v16, (uint64_t)v18);
}

uint64_t C3DWarmupNodeTreeVRAMResourcesForEngineContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD v10[7];
  _QWORD v11[5];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v6 = MEMORY[0x1E0C809B0];
  v15 = 0;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = __C3DWarmupNodeTreeVRAMResourcesForEngineContext_block_invoke;
  v11[3] = &unk_1EA59E140;
  v11[4] = &v12;
  C3DNodeApplyHierarchy(a1, (uint64_t)v11);
  v7 = *((_DWORD *)v13 + 6);
  v10[0] = v6;
  v10[1] = 3221225472;
  v10[2] = __C3DWarmupNodeTreeVRAMResourcesForEngineContext_block_invoke_2;
  v10[3] = &unk_1EA59E190;
  v10[5] = a1;
  v10[6] = a2;
  v10[4] = a3;
  v8 = C3DExecuteIncrementalProgressBlock(v7, (uint64_t)v10);
  _Block_object_dispose(&v12, 8);
  return v8;
}

void sub_1DCD485AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1DCD48680(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t C3DCreateTangentsWithGeometry(uint64_t a1, int a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *PositionSource;
  const void *NormalSource;
  const void *SourceWithSemanticAtIndex;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  size_t Count;
  const __CFArray *ElementsCount;
  UInt8 *v41;
  _DWORD *v42;
  __int16 v43;
  __int16 v44;
  unsigned __int8 v45;
  unsigned __int8 v46;
  CFIndex v47;
  char v48;
  const void *ElementAtIndex;
  uint64_t i;
  uint64_t Index;
  uint64_t v52;
  uint64_t v53;
  float32x4_t v54;
  float v55;
  float v56;
  float32x4_t v57;
  float v58;
  float v59;
  float32x4_t v60;
  float v61;
  float v62;
  float32x4_t v63;
  float v64;
  float v65;
  float32x4_t v66;
  float v67;
  float v68;
  float32x4_t v69;
  float v70;
  float v71;
  float32x4_t v72;
  float32x2_t v73;
  unint64_t v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float32x4_t v79;
  float32x4_t v80;
  float v81;
  float v82;
  float v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  float32x2_t v88;
  uint64_t v89;
  uint64_t v90;
  float32x2_t v91;
  uint64_t v92;
  unsigned __int8 v93;
  unsigned __int8 v94;
  float32x4_t v95;
  float32x4_t v96;
  int32x4_t v97;
  float *v98;
  int v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  float32x4_t v103;
  uint64_t v104;
  __int32 *v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  int32x4_t v110;
  float32x2_t v111;
  float32x2_t v112;
  float32x4_t v113;
  float32x4_t v114;
  CFDataRef v115;
  uint64_t v116;
  CFIndex length;
  uint64_t v119;
  uint64_t v120;
  const __CFArray *v121;
  uint64_t v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  int v126;
  uint64_t v127;
  uint64_t Content;
  uint64_t PrimitiveCount;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;

  v3 = a1;
  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  PositionSource = C3DMeshGetPositionSource(v3, a2);
  NormalSource = C3DMeshGetNormalSource(v3, a2);
  SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex(v3, 3, 0, a2);
  if (!PositionSource && (v15 = scn_default_log(), os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)))
  {
    C3DCreateTangentsWithGeometryOptimized_cold_7(v15, v16, v17, v18, v19, v20, v21, v22);
    if (NormalSource)
      goto LABEL_9;
  }
  else if (NormalSource)
  {
    goto LABEL_9;
  }
  v23 = scn_default_log();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
    C3DCreateTangentsWithGeometryOptimized_cold_6(v23, v24, v25, v26, v27, v28, v29, v30);
LABEL_9:
  v119 = (uint64_t)NormalSource;
  if (!SourceWithSemanticAtIndex)
  {
    v31 = scn_default_log();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_5(v31, v32, v33, v34, v35, v36, v37, v38);
  }
  Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
  ElementsCount = C3DMeshGetElementsCount(v3);
  v120 = Count;
  Count *= 16;
  v41 = (UInt8 *)malloc_type_calloc(Count, 1uLL, 0x57458A05uLL);
  length = Count;
  v42 = malloc_type_calloc(Count, 1uLL, 0xFCBF8311uLL);
  Content = C3DMeshSourceGetContent((uint64_t)PositionSource);
  v44 = v43;
  v127 = C3DMeshSourceGetContent((uint64_t)SourceWithSemanticAtIndex);
  if ((uint64_t)ElementsCount < 1)
  {
    v48 = 0;
  }
  else
  {
    v47 = 0;
    v48 = 0;
    v125 = HIBYTE(v44);
    v126 = v44;
    v123 = v46;
    v124 = v45;
    v121 = ElementsCount;
    v122 = v3;
    do
    {
      ElementAtIndex = C3DMeshGetElementAtIndex(v3, v47, 1);
      if (!C3DMeshElementGetType((uint64_t)ElementAtIndex)
        || C3DMeshElementGetType((uint64_t)ElementAtIndex) == 1)
      {
        PrimitiveCount = C3DMeshElementGetPrimitiveCount((uint64_t)ElementAtIndex);
        if (PrimitiveCount < 1)
        {
          v48 = 0;
        }
        else
        {
          for (i = 0; i != PrimitiveCount; ++i)
          {
            Index = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, i, 0, 0);
            v52 = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, i, 1, 0);
            v53 = C3DMeshElementGetIndex((uint64_t)ElementAtIndex, i, 2, 0);
            *(double *)v57.i64 = C3DConvertFloatingTypeToFloat4(v126, (float *)(Content + Index * v125), v54, v55, v56);
            v134 = v57;
            *(double *)v60.i64 = C3DConvertFloatingTypeToFloat4(v126, (float *)(Content + v52 * v125), v57, v58, v59);
            v133 = v60;
            *(double *)v63.i64 = C3DConvertFloatingTypeToFloat4(v126, (float *)(Content + v53 * v125), v60, v61, v62);
            v132 = v63;
            *(double *)v66.i64 = C3DConvertFloatingTypeToFloat4(v124, (float *)(v127 + Index * v123), v63, v64, v65);
            v131 = v66;
            *(double *)v69.i64 = C3DConvertFloatingTypeToFloat4(v124, (float *)(v127 + v52 * v123), v66, v67, v68);
            v130 = v69;
            *(double *)v72.i64 = C3DConvertFloatingTypeToFloat4(v124, (float *)(v127 + v53 * v123), v69, v70, v71);
            v73 = (float32x2_t)vsubq_f32(v130, v131).u64[0];
            v74 = vsubq_f32(v72, v131).u64[0];
            v75 = v73.f32[1];
            v76 = *((float *)&v74 + 1);
            v77 = -*(float *)&v74;
            v78 = vmlas_n_f32(vmuls_lane_f32(-*(float *)&v74, v73, 1), *((float *)&v74 + 1), v73.f32[0]);
            if (v78 == 0.0)
            {
              v75 = v73.f32[1] + 0.00000011921;
              v76 = *((float *)&v74 + 1) + -0.00000011921;
              v73.f32[0] = v73.f32[0] + -0.00000011921;
              v77 = -(float)(*(float *)&v74 + -0.00000011921);
              v78 = (float)(v73.f32[0] * (float)(*((float *)&v74 + 1) + -0.00000011921))
                  - (float)((float)(*(float *)&v74 + -0.00000011921) * (float)(v73.f32[1] + 0.00000011921));
            }
            v79 = vsubq_f32(v133, v134);
            v80 = vsubq_f32(v132, v134);
            v81 = 1.0 / v78;
            v82 = -v75;
            v83 = (float)((float)(v76 * v79.f32[2]) - (float)(v75 * v80.f32[2])) * v81;
            v84 = 4 * Index;
            v85 = (16 * Index) | 8;
            *(float *)&v41[v85] = v83 + *(float *)&v41[v85];
            v86 = (16 * v52) | 8;
            v87 = 4 * v52;
            *(float *)&v41[v86] = v83 + *(float *)&v41[v86];
            v88 = vmul_n_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)v80.f32, v82), *(float32x2_t *)v79.f32, v76), v81);
            *(float32x2_t *)&v41[v84 * 4] = vadd_f32(*(float32x2_t *)&v41[16 * Index], v88);
            v89 = 4 * v53;
            *(float32x2_t *)&v41[v87 * 4] = vadd_f32(v88, *(float32x2_t *)&v41[16 * v52]);
            *(float32x2_t *)&v41[v89 * 4] = vadd_f32(v88, *(float32x2_t *)&v41[16 * v53]);
            v90 = (16 * v53) | 8;
            *(float *)&v41[v90] = v83 + *(float *)&v41[v90];
            v88.f32[0] = (float)((float)(v79.f32[2] * v77) + (float)(v73.f32[0] * v80.f32[2])) * v81;
            *(float *)((char *)v42 + v85) = v88.f32[0] + *(float *)((char *)v42 + v85);
            *(float *)((char *)v42 + v86) = v88.f32[0] + *(float *)((char *)v42 + v86);
            v91 = vmul_n_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)v79.f32, v77), *(float32x2_t *)v80.f32, v73.f32[0]), v81);
            *(float32x2_t *)&v42[v84] = vadd_f32(v91, *(float32x2_t *)&v42[4 * Index]);
            *(float32x2_t *)&v42[v87] = vadd_f32(v91, *(float32x2_t *)&v42[4 * v52]);
            *(float32x2_t *)&v42[v89] = vadd_f32(v91, *(float32x2_t *)&v42[4 * v53]);
            *(float *)((char *)v42 + v90) = v88.f32[0] + *(float *)((char *)v42 + v90);
          }
          v48 = 1;
          ElementsCount = v121;
          v3 = v122;
        }
      }
      ++v47;
    }
    while ((const __CFArray *)v47 != ElementsCount);
  }
  v92 = C3DMeshSourceGetContent(v119);
  if (v120 >= 1)
  {
    v98 = (float *)v92;
    v99 = 0;
    v100 = v93;
    v101 = v94;
    v102 = v120;
    do
    {
      *(double *)v103.i64 = C3DConvertFloatingTypeToFloat4(v100, v98, v95, v96.f32[0], *(float *)v97.i32);
      v104 = 4 * v99;
      v105 = (__int32 *)&v41[4 * v99 + 8];
      v106.i64[0] = *(_QWORD *)&v41[v104];
      v107 = v106;
      v106.i32[2] = *v105;
      v107.i32[2] = *v105;
      v108 = vmulq_f32(v103, v106);
      v109 = vmlsq_lane_f32(v107, v103, (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 2), vaddq_f32(v108, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v108.f32, 1))), 0);
      v110 = (int32x4_t)vmulq_f32(v109, v109);
      v110.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v110, 2), vadd_f32(*(float32x2_t *)v110.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v110.i8, 1))).u32[0];
      v111 = vrsqrte_f32((float32x2_t)v110.u32[0]);
      v112 = vmul_f32(v111, vrsqrts_f32((float32x2_t)v110.u32[0], vmul_f32(v111, v111)));
      v113 = vmulq_n_f32(v109, vmul_f32(v112, vrsqrts_f32((float32x2_t)v110.u32[0], vmul_f32(v112, v112))).f32[0]);
      *(_QWORD *)&v41[v104] = v113.i64[0];
      *v105 = v113.i32[2];
      v113.i64[0] = *(_QWORD *)&v42[(unint64_t)v104 / 4];
      v113.i32[2] = v42[v99 + 2];
      v97 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v107, (int32x4_t)v107), (int8x16_t)v107, 0xCuLL), vnegq_f32(v103)), v107, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v103, (int32x4_t)v103), (int8x16_t)v103, 0xCuLL));
      v114 = vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v97, v97), (int8x16_t)v97, 0xCuLL), v113);
      v96 = vaddq_f32(v114, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 1));
      v95 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v114, 2), v96);
      if (v95.f32[0] < 0.0)
        v95.f32[0] = -1.0;
      else
        v95.f32[0] = 1.0;
      *(_DWORD *)&v41[4 * v99 + 12] = v95.i32[0];
      v99 += 4;
      v98 = (float *)((char *)v98 + v101);
      --v102;
    }
    while (v102);
  }
  free(v42);
  if ((v48 & 1) != 0)
  {
    v115 = CFDataCreateWithBytesNoCopy(0, v41, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
    v116 = C3DMeshSourceCreate(v115, 4, v120, 4, 1);
    CFRelease(v115);
  }
  else
  {
    free(v41);
    return 0;
  }
  return v116;
}

uint64_t C3DCreateNormalsWithMesh(uint64_t a1, int a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const void *PositionSource;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t Count;
  uint64_t Mutable;

  if (!a1)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  PositionSource = C3DMeshGetPositionSource(a1, a2);
  if (!PositionSource)
  {
    v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_7(v15, v16, v17, v18, v19, v20, v21, v22);
  }
  if (!C3DMeshGetElementsCount(a1))
    return 0;
  Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
  Mutable = C3DMeshSourceCreateMutable(0, 1, Count, 3, 1);
  _unifyNormalsOptimized(a1, (uint64_t)PositionSource, Mutable, a2, a3);
  C3DMeshSourceMakeImmutable(Mutable);
  return Mutable;
}

void _unifyNormalsOptimized(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t Content;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  _DWORD *WeldRemappingTable;
  const __CFArray *ElementsCount;
  unsigned int Count;
  float32x4_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  char *v24;
  CFIndex v25;
  const void *ElementAtIndex;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  const char *v30;
  NSObject *v31;
  int v32;
  uint64_t i;
  uint64_t v34;
  char *v35;
  int v36;
  uint64_t v37;
  char *v38;
  unint64_t v39;
  uint64_t v40;
  float *v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int v47;
  unint64_t v48;
  char *v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int32x4_t v59;
  unsigned int v60;
  uint64_t v61;
  uint8_t buf[16];
  __int128 v63;
  __n128 v64;
  uint64_t v65;
  _QWORD v66[9];
  int v67;
  __int128 __pattern4;
  __int128 v69;
  __n128 v70;
  uint64_t v71;
  float32x4x3_t v72;

  Content = C3DMeshSourceGetContent(a2);
  if ((v11 & 0xFF00000000) == 0x900000000
    && (v12 = Content, v13 = v11, v14 = C3DMeshSourceGetContent(a3), v61 = v15, (v15 & 0xFF00000000) == 0x900000000))
  {
    if ((_DWORD)v13)
    {
      v16 = (char *)v14;
      if (a5)
        WeldRemappingTable = C3DMeshSourceCreateWeldRemappingTable(a2);
      else
        WeldRemappingTable = 0;
      ElementsCount = C3DMeshGetElementsCount(a1);
      Count = C3DMeshSourceGetCount(a3);
      v21 = Count;
      if (BYTE5(v61) == 12)
      {
        LODWORD(__pattern4) = 0;
        memset_pattern4(v16, &__pattern4, 12 * Count);
      }
      else if (Count)
      {
        v22 = 0;
        v23 = Count;
        do
        {
          v24 = &v16[v22];
          *(_QWORD *)v24 = 0;
          *((_DWORD *)v24 + 2) = 0;
          v22 += BYTE5(v61);
          --v23;
        }
        while (v23);
      }
      v60 = v21;
      if ((uint64_t)ElementsCount >= 1)
      {
        v25 = 0;
        while (1)
        {
          ElementAtIndex = C3DMeshGetElementAtIndex(a1, v25, a4);
          v27 = a4 ? 0 : C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 0, 0);
          v71 = 0;
          v69 = 0u;
          v70 = 0u;
          __pattern4 = 0u;
          C3DMeshElementGetContent((uint64_t)ElementAtIndex, v27, (uint64_t)&__pattern4);
          if ((BYTE10(v69) & 0xFA) == 0)
            break;
          v28 = scn_default_log();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            v29 = v28;
            v30 = "Warning: C3DUnifyNormalsFromGeometry can only process triangles and polygons";
LABEL_22:
            _os_log_impl(&dword_1DCCB8000, v29, OS_LOG_TYPE_DEFAULT, v30, buf, 2u);
          }
LABEL_27:
          if (ElementsCount == (const __CFArray *)++v25)
            goto LABEL_28;
        }
        if ((_QWORD)__pattern4)
        {
          v66[0] = MEMORY[0x1E0C809B0];
          v66[1] = 3221225472;
          v66[2] = ___unifyNormalsOptimized_block_invoke;
          v66[3] = &__block_descriptor_76_e19_v32__0I8_I12I20_B24l;
          v66[4] = v12;
          v66[5] = v13;
          v67 = v13 - 1;
          v66[6] = WeldRemappingTable;
          v66[7] = v16;
          v66[8] = v61;
          *(_OWORD *)buf = __pattern4;
          v63 = v69;
          v64 = v70;
          v65 = v71;
          C3DIndicesContentEnumeratePrimitives((uint64_t *)buf, (uint64_t)v66, v70);
          goto LABEL_27;
        }
        v31 = scn_default_log();
        if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          goto LABEL_27;
        *(_WORD *)buf = 0;
        v29 = v31;
        v30 = "Warning: C3DUnifyNormalsFromGeometry empty indices";
        goto LABEL_22;
      }
LABEL_28:
      if (WeldRemappingTable && v60)
      {
        v32 = 0;
        for (i = 0; i != v60; ++i)
        {
          v34 = WeldRemappingTable[i];
          if (i != v34)
          {
            v35 = &v16[v34 * BYTE5(v61)];
            v36 = *((_DWORD *)v35 + 2);
            v37 = *(_QWORD *)v35;
            v38 = &v16[v32];
            *(_QWORD *)v38 = v37;
            *((_DWORD *)v38 + 2) = v36;
          }
          v32 += BYTE5(v61);
        }
      }
      LODWORD(v39) = 0;
      if (BYTE5(v61) == 12 && v60 >= 4)
      {
        v40 = 0;
        v39 = 0;
        do
        {
          v41 = (float *)&v16[v40 & 0xFFFFFFF0];
          *(float32x4x3_t *)(&v20 - 1) = vld3q_f32(v41);
          v44 = vaddq_f32(vmulq_f32(v43, v43), vaddq_f32(vmulq_f32(v42, v42), vmulq_f32(v20, v20)));
          v45 = vrsqrteq_f32(v44);
          v46 = vmulq_f32(v45, vrsqrtsq_f32(v44, vmulq_f32(v45, v45)));
          v72.val[0] = vmulq_f32(v42, v46);
          v72.val[1] = vmulq_f32(v20, v46);
          v72.val[2] = vmulq_f32(v43, v46);
          vst3q_f32(v41, v72);
          v39 += 4;
          v40 += 48;
        }
        while (v39 < (v60 & 0xFFFFFFFC));
      }
      if (v39 < v60)
      {
        v47 = v39 * BYTE5(v61);
        v48 = v60 - (unint64_t)v39;
        __asm { FMOV            V0.4S, #1.0 }
        do
        {
          v54 = &v16[v47];
          v20.i64[0] = *(_QWORD *)v54;
          v20.i32[2] = *((_DWORD *)v54 + 2);
          v55 = vmulq_f32(v20, v20);
          v55.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 2), vaddq_f32(v55, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 1))).u64[0];
          v56 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0);
          v57 = vrsqrteq_f32(v56);
          v58 = vmulq_f32(v57, vrsqrtsq_f32(v56, vmulq_f32(v57, v57)));
          v59 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v55.f32[0] != 0.0)), 0x1FuLL));
          v59.i32[3] = 0;
          v20 = vmulq_f32(v20, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v59), (int8x16_t)vmulq_f32(v58, vrsqrtsq_f32(v56, vmulq_f32(v58, v58))), _Q0));
          *(_QWORD *)v54 = v20.i64[0];
          *((_DWORD *)v54 + 2) = v20.i32[2];
          v47 += BYTE5(v61);
          --v48;
        }
        while (v48);
      }
      free(WeldRemappingTable);
    }
  }
  else
  {
    _unifyNormals(a1, a2, a3, a4, a5);
  }
}

uint64_t C3DCreateNormalsForMorphTargetWithBaseMesh(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const void *PositionSource;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t Count;
  uint64_t Mutable;

  if (!a2)
  {
    v6 = scn_default_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_8(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  PositionSource = C3DMeshGetPositionSource(a1, a3);
  if (!PositionSource)
  {
    v15 = scn_default_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      C3DCreateTangentsWithGeometryOptimized_cold_7(v15, v16, v17, v18, v19, v20, v21, v22);
  }
  if (!C3DMeshGetElementsCount(a2))
    return 0;
  Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
  Mutable = C3DMeshSourceCreateMutable(0, 1, Count, 3, 1);
  _unifyNormalsOptimized(a2, (uint64_t)PositionSource, Mutable, a3, 0);
  C3DMeshSourceMakeImmutable(Mutable);
  return Mutable;
}

void C3DMeshUnifyNormals(uint64_t a1, uint64_t a2, int a3, int a4)
{
  const void *PositionSource;
  uint64_t v9;
  uint64_t Count;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  const void *NormalSource;
  int v15;
  NSObject *v16;
  const void *MutableCopy;

  if (C3DMeshGetElementsCount(a2))
  {
    PositionSource = C3DMeshGetPositionSource(a1, 1);
    if (PositionSource)
    {
      v9 = (uint64_t)PositionSource;
      Count = C3DMeshSourceGetCount((uint64_t)PositionSource);
      if (Count)
      {
        v11 = Count;
        v12 = C3DMeshGetPositionSource(a2, 1);
        if (v12)
        {
          v13 = C3DMeshSourceGetCount((uint64_t)v12);
          if (v11 == v13)
          {
            NormalSource = C3DMeshGetNormalSource(a1, 1);
            if (!NormalSource && a3)
            {
              NormalSource = (const void *)C3DMeshSourceCreateMutable(0, 1, v11, 3, 1);
              __C3DMeshSetRenderableSourceWithInputSetAndPositionChannel(a1, NormalSource, 0);
              CFRelease(NormalSource);
            }
            if (NormalSource)
            {
              if (C3DMeshSourceIsMutable(NormalSource))
              {
                _unifyNormalsOptimized(a2, v9, (uint64_t)NormalSource, 1, a4);
              }
              else
              {
                MutableCopy = (const void *)C3DMeshSourceCreateMutableCopy((uint64_t)NormalSource);
                __C3DMeshSetRenderableSourceWithInputSetAndPositionChannel(a1, MutableCopy, 0);
                CFRelease(MutableCopy);
                _unifyNormalsOptimized(a2, v9, (uint64_t)MutableCopy, 1, a4);
                C3DMeshSourceMakeImmutable(MutableCopy);
              }
            }
          }
          else
          {
            v15 = v13;
            v16 = scn_default_log();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
              C3DMeshUnifyNormals_cold_1(v11, v15, v16);
          }
        }
      }
    }
  }
}

void C3DApplyScaleFactorOnScene(uint64_t a1, float a2)
{
  __n128 *RootNode;
  double v4;

  RootNode = (__n128 *)C3DSceneGetRootNode(a1);
  *(float *)&v4 = a2;
  C3DApplyScaleFactorOnNode(RootNode, 1, v4);
}

void C3DApplyScaleFactorOnNode(__n128 *a1, int a2, double a3)
{
  float32x4_t v5;
  float32x4_t v6;
  uint32x4_t v7;
  uint64_t Geometry;
  uint64_t Mesh;
  const __CFDictionary *Light;
  const __CFDictionary *Camera;
  _QWORD v13[4];
  int v14;

  if (a1)
  {
    *(double *)v5.i64 = C3DNodeGetPosition(a1);
    C3DNodeSetPosition((uint64_t)a1, (__n128)vmulq_n_f32(v5, *(float *)&a3));
    if (C3DNodeGetHasPivot((uint64_t)a1))
    {
      *(double *)v6.i64 = C3DNodeGetPivotPosition((uint64_t)a1);
      v7 = (uint32x4_t)vceqzq_f32(v6);
      v7.i32[3] = v7.i32[2];
      if ((vminvq_u32(v7) & 0x80000000) == 0)
        C3DNodeSetPivotPosition((float32x4_t *)a1, (__n128)vmulq_n_f32(v6, *(float *)&a3));
    }
    Geometry = C3DNodeGetGeometry((uint64_t)a1);
    if (Geometry)
    {
      Mesh = C3DGeometryGetMesh(Geometry);
      if (Mesh)
        C3DApplyScaleFactorOnMesh(Mesh, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0));
    }
    Light = C3DNodeGetLight((uint64_t)a1);
    if (Light)
      C3DApplyScaleFactorOnLight((uint64_t)Light, *(float *)&a3);
    Camera = C3DNodeGetCamera((uint64_t)a1);
    if (Camera)
      C3DApplyScaleFactorOnCamera((uint64_t)Camera, *(float *)&a3);
    if (a2)
    {
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 3221225472;
      v13[2] = __C3DApplyScaleFactorOnNode_block_invoke;
      v13[3] = &__block_descriptor_36_e318_v24__0____C3DNode____C3DEntity____CFRuntimeBase_QAQ__v____CFString_____CFString_____CFDictionary_____C3DScene_q_____C3DNode_____C3DNode_____C3DNode_i____C3DMatrix4x4__16f__4_____4__________C3DMatrix4x4_BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3b1______SS_I_________C3DGeometry_____C3DDeformerStack_f_____8q16l;
      v14 = LODWORD(a3);
      C3DNodeApplyChildren((uint64_t)a1, (uint64_t)v13);
    }
  }
}

void C3DApplyScaleFactorOnLight(uint64_t a1, float a2)
{
  double ZNear;
  double v5;
  double v6;

  ZNear = C3DLightGetZNear(a1);
  v5 = a2;
  C3DLightSetZNear(a1, ZNear * v5);
  v6 = C3DLightGetZFar(a1) * v5;
  C3DLightSetZFar(a1, v6);
}

float64x2_t C3DApplyScaleFactorOnCamera(uint64_t a1, float a2)
{
  float FocusDistance;
  uint64_t ProjectionInfosPtr;
  float64x2_t result;

  FocusDistance = C3DCameraGetFocusDistance(a1);
  C3DCameraSetFocusDistance(a1, FocusDistance * a2);
  ProjectionInfosPtr = C3DCameraGetProjectionInfosPtr(a1);
  result = vmulq_n_f64(*(float64x2_t *)(ProjectionInfosPtr + 8), a2);
  *(float64x2_t *)(ProjectionInfosPtr + 8) = result;
  return result;
}

void C3DApplyScaleFactorOnMesh(uint64_t a1, float32x4_t a2)
{
  const void *PositionSource;
  uint64_t v4;
  unsigned __int8 ChannelForSourceWithSemanticAtIndex;
  const void *MutableCopy;
  uint64_t Count;
  uint64_t v8;
  uint64_t i;
  float32x4_t v10;
  BOOL v11;
  BOOL v12;
  const void *NormalSource;
  uint64_t v14;
  unsigned __int8 v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float32x4_t v25;
  float32x4_t v27;

  PositionSource = C3DMeshGetPositionSource(a1, 0);
  if (PositionSource)
  {
    v4 = (uint64_t)PositionSource;
    ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 0, 0);
    MutableCopy = (const void *)C3DMeshSourceCreateMutableCopy(v4);
    Count = C3DMeshSourceGetCount((uint64_t)MutableCopy);
    if (Count >= 1)
    {
      v8 = Count;
      for (i = 0; i != v8; ++i)
      {
        *(double *)v10.i64 = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)MutableCopy, i);
        C3DMeshSourceSetValueAtIndexAsVector3((uint64_t)MutableCopy, i, (__n128)vmulq_f32(a2, v10));
      }
    }
    C3DMeshSourceMakeImmutable(MutableCopy);
    C3DMeshSetSourceWithInputSet(a1, MutableCopy, 0, ChannelForSourceWithSemanticAtIndex);
    CFRelease(MutableCopy);
  }
  v11 = a2.f32[1] != a2.f32[2];
  if (a2.f32[0] != a2.f32[2])
    v11 = 0;
  v12 = a2.f32[0] == a2.f32[1] && v11;
  NormalSource = C3DMeshGetNormalSource(a1, 0);
  if (!v12)
  {
    v14 = (uint64_t)NormalSource;
    if (NormalSource)
    {
      v15 = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 1, 0);
      v16 = (const void *)C3DMeshSourceCreateMutableCopy(v14);
      v17 = C3DMeshSourceGetCount((uint64_t)v16);
      if (v17 >= 1)
      {
        v18 = v17;
        v19 = 0;
        __asm { FMOV            V0.4S, #1.0 }
        v27 = vdivq_f32(_Q0, a2);
        do
        {
          *(double *)v25.i64 = C3DMeshSourceGetValueAtIndexAsVector3((uint64_t)v16, v19);
          C3DMeshSourceSetValueAtIndexAsVector3((uint64_t)v16, v19++, (__n128)vmulq_f32(v27, v25));
        }
        while (v18 != v19);
      }
      C3DMeshSourceMakeImmutable(v16);
      C3DMeshSetSourceWithInputSet(a1, v16, 0, v15);
      CFRelease(v16);
    }
  }
}

BOOL C3DGeometryNeedsTexTangent(uint64_t a1, uint64_t *a2)
{
  const __CFArray *MaterialsCount;
  const __CFArray *v5;
  uint64_t v6;
  BOOL v7;
  const __CFArray *MaterialAtIndex;
  uint64_t CommonProfile;
  uint64_t EffectSlot;

  MaterialsCount = C3DGeometryGetMaterialsCount(a1);
  if ((uint64_t)MaterialsCount < 1)
  {
    return 0;
  }
  else
  {
    v5 = MaterialsCount;
    v6 = 0;
    v7 = 1;
    while (1)
    {
      MaterialAtIndex = C3DGeometryGetMaterialAtIndex(a1, v6);
      CommonProfile = C3DMaterialGetCommonProfile((uint64_t)MaterialAtIndex);
      if (CommonProfile)
      {
        EffectSlot = C3DEffectCommonProfileGetEffectSlot(CommonProfile, 7, 0);
        if (EffectSlot)
        {
          if (C3DEffectSlotHasImageOrTexture(EffectSlot))
            break;
        }
      }
      v7 = ++v6 < (uint64_t)v5;
      if (v5 == (const __CFArray *)v6)
        return v7;
    }
    if (a2)
      *a2 = v6;
  }
  return v7;
}

uint64_t C3DGeometryCreateTangentsIfNeeded(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;

  v13 = 0;
  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = C3DGeometryNeedsTexTangent(a1, &v13);
  if ((_DWORD)result)
  {
    result = C3DGeometryGetMesh(a1);
    if (result)
      return C3DMeshCreateTangentsIfNeeded(result, a2);
  }
  return result;
}

BOOL C3DMeshIsInterleaved(uint64_t a1)
{
  const void *SourceWithSemanticAtIndex;
  uint64_t Accessor;

  SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex(a1, 0, 0, 0);
  return SourceWithSemanticAtIndex
      && (Accessor = C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex)) != 0
      && C3DSourceAccessorIsInterleaved(Accessor);
}

uint64_t C3DMeshCreateCopyWithDeinterleavedSources(uint64_t a1)
{
  uint64_t Copy;
  unsigned __int8 v3;
  int SourcesCountForSemantic;
  uint64_t v5;
  uint64_t v6;
  const void *SourceWithSemanticAtIndex;
  const void *DeepCopy;
  unsigned int v9;

  Copy = C3DMeshCreateCopy(a1);
  v3 = 0;
  do
  {
    SourcesCountForSemantic = C3DMeshGetSourcesCountForSemantic(a1, (char)v3);
    if (SourcesCountForSemantic >= 1)
    {
      v5 = 0;
      v6 = SourcesCountForSemantic;
      do
      {
        SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex(a1, (char)v3, v5, 0);
        if (SourceWithSemanticAtIndex)
        {
          DeepCopy = (const void *)C3DMeshSourceCreateDeepCopy((uint64_t)SourceWithSemanticAtIndex);
          C3DMeshSetSourceWithInputSet(Copy, DeepCopy, v5, 255);
          CFRelease(DeepCopy);
        }
        ++v5;
      }
      while (v6 != v5);
    }
    v9 = v3++;
  }
  while (v9 < 8);
  return Copy;
}

uint64_t C3DMeshCreateCopyWithInterleavedSources(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const UInt8 *v4;
  CFDataRef v5;
  uint64_t v6;
  const void *MeshElements;
  _QWORD v9[10];
  _QWORD v10[4];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[6];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;

  v20 = 0;
  v21 = &v20;
  v22 = 0x2020000000;
  v23 = 0;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v19 = 0;
  v2 = MEMORY[0x1E0C809B0];
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v15[2] = __C3DMeshCreateCopyWithInterleavedSources_block_invoke;
  v15[3] = &unk_1EA59E1D8;
  v15[4] = &v20;
  v15[5] = &v16;
  C3DMeshApplySources(a1, 0, (uint64_t)v15);
  v3 = v21[3];
  if (v3)
  {
    v4 = (const UInt8 *)C3DMalloc(v17[3] * v3);
    v5 = CFDataCreateWithBytesNoCopy(0, v4, v21[3] * v17[3], (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
    v11 = 0;
    v12 = &v11;
    v13 = 0x2020000000;
    v14 = 0;
    v6 = C3DMeshCreate();
    MeshElements = (const void *)C3DMeshGetMeshElements(a1, 0);
    C3DMeshSetMeshElements(v6, MeshElements);
    v10[0] = 0;
    v10[1] = v10;
    v10[2] = 0x2020000000;
    v10[3] = 0;
    v9[0] = v2;
    v9[1] = 3221225472;
    v9[2] = __C3DMeshCreateCopyWithInterleavedSources_block_invoke_34;
    v9[3] = &unk_1EA59E200;
    v9[4] = &v11;
    v9[5] = &v16;
    v9[6] = &v20;
    v9[7] = v10;
    v9[8] = v5;
    v9[9] = v6;
    C3DMeshApplySources(a1, 0, (uint64_t)v9);
    CFRelease((CFTypeRef)v12[3]);
    CFRelease(v5);
    _Block_object_dispose(v10, 8);
    _Block_object_dispose(&v11, 8);
  }
  else
  {
    v6 = 0;
  }
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  return v6;
}

void sub_1DCD49BC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void C3DGeometryMakeSourcesCheaperWhenRelevant(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Mesh;
  uint64_t SourcesCountForSemantic;
  uint64_t v12;
  uint64_t i;
  const void *SourceWithSemanticAtIndex;
  unsigned __int8 ChannelForSourceWithSemanticAtIndex;
  uint64_t Accessor;
  const void *CopyWithComponentsBaseType;
  const void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t j;
  const void *v22;
  unsigned __int8 v23;
  uint64_t v24;
  const void *v25;
  const void *v26;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DGeometryGetName_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  Mesh = C3DGeometryGetMesh(a1);
  SourcesCountForSemantic = C3DMeshGetSourcesCountForSemantic(Mesh, 1);
  if (SourcesCountForSemantic >= 1)
  {
    v12 = SourcesCountForSemantic;
    for (i = 0; i != v12; ++i)
    {
      SourceWithSemanticAtIndex = C3DMeshGetSourceWithSemanticAtIndex(Mesh, 1, i, 0);
      ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(Mesh, 1, i);
      Accessor = C3DMeshSourceGetAccessor(SourceWithSemanticAtIndex);
      if (C3DSourceAccessorGetComponentsValueType(Accessor) != 4)
      {
        CopyWithComponentsBaseType = (const void *)C3DMeshSourceCreateCopyWithComponentsBaseType((uint64_t)SourceWithSemanticAtIndex, 4);
        if (CopyWithComponentsBaseType)
        {
          v18 = CopyWithComponentsBaseType;
          C3DMeshSetSourceWithInputSet(Mesh, CopyWithComponentsBaseType, i, ChannelForSourceWithSemanticAtIndex);
          CFRelease(v18);
        }
      }
    }
  }
  v19 = C3DMeshGetSourcesCountForSemantic(Mesh, 2);
  if (v19 >= 1)
  {
    v20 = v19;
    for (j = 0; j != v20; ++j)
    {
      v22 = C3DMeshGetSourceWithSemanticAtIndex(Mesh, 2, j, 0);
      v23 = C3DMeshGetChannelForSourceWithSemanticAtIndex(Mesh, 2, j);
      v24 = C3DMeshSourceGetAccessor(v22);
      if (C3DSourceAccessorGetComponentsValueType(v24) != 16)
      {
        v25 = (const void *)C3DMeshSourceCreateCopyWithComponentsBaseType((uint64_t)v22, 16);
        if (v25)
        {
          v26 = v25;
          C3DMeshSetSourceWithInputSet(Mesh, v25, j, v23);
          CFRelease(v26);
        }
      }
    }
  }
}

float32x4_t *C3DCreateDefaultCameraNode(__n128 *a1, int a2)
{
  uint64_t RootNode;
  float32x4_t *v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  const __CFDictionary *v9;
  uint64_t ProjectionInfosPtr;
  float32x4_t v11;
  __int128 v12;
  uint32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  __int128 v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float v21;
  float32x4_t v22;
  float32x4_t v23;
  float v24;
  float v25;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30[4];
  _OWORD v31[4];
  float32x4_t v32[4];
  float32x4_t v33[4];
  __int128 v34;
  float32x4_t v35;
  simd_float4x4 v36;
  float32x4_t v37;
  float32x4_t v38;
  simd_float4x4 v39;
  simd_float4x4 v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;

  *(uint64_t *)((char *)v41.i64 + 4) = 0;
  v41.i32[0] = 0;
  memset(&v40, 0, sizeof(v40));
  memset(&v39, 0, sizeof(v39));
  v37 = 0u;
  v38 = 0u;
  RootNode = C3DSceneGetRootNode((uint64_t)a1);
  v5 = 0;
  if (C3DNodeGetBoundingBoxOmittingFloor(RootNode, &v37, 0))
  {
    v6 = vsubq_f32(v37, v38);
    v7 = vaddq_f32(v37, v38);
    if (a2)
    {
      v8 = vmulq_f32(vsubq_f32(v7, v6), (float32x4_t)vdupq_n_s32(0x3DCCCCCDu));
      v6 = vsubq_f32(v6, v8);
      v7 = vaddq_f32(v7, v8);
    }
    v28 = v6;
    v29 = v7;
    memset(&v36, 0, sizeof(v36));
    C3DNodeGetMatrix(RootNode, (uint64_t)&v36);
    C3DMatrix4x4Invert(&v36, &v39);
    v5 = (float32x4_t *)C3DNodeCreate();
    v9 = (const __CFDictionary *)C3DCameraCreate();
    C3DNodeSetCamera((uint64_t)v5, v9);
    C3DEntitySetName((uint64_t)v5, CFSTR("default camera"));
    CFRelease(v9);
    ProjectionInfosPtr = C3DCameraGetProjectionInfosPtr((uint64_t)v9);
    C3DCameraSetFov((uint64_t)v9, 45.0);
    *(double *)v11.i64 = C3DVector3MidVector(v28, v29);
    v27 = v11;
    v42 = v11;
    C3DSceneGetUpAxis(a1, (__n128 *)&v41);
    v12 = (__int128)v41;
    v13 = (uint32x4_t)vceqzq_f32(v41);
    v13.i32[3] = v13.i32[2];
    if ((vminvq_u32(v13) & 0x80000000) != 0)
    {
      v12 = xmmword_1DD007920;
      v41 = (float32x4_t)xmmword_1DD007920;
    }
    v43 = v27;
    v14.i64[0] = 0x3F0000003F000000;
    v14.i64[1] = 0x3F0000003F000000;
    v15 = vmulq_f32(vsubq_f32(v29, v28), v14);
    v16 = vmulq_f32(v15, (float32x4_t)vdupq_n_s32(0x401A827Au));
    if (*((float *)&v12 + 1) == 0.0 && *(float *)&v12 == 0.0)
    {
      if (*((float *)&v12 + 2) != 0.0)
      {
        if (v16.f32[0] < v16.f32[2])
          v16.f32[0] = v16.f32[2];
        v43.f32[1] = v27.f32[1] - (float)(v15.f32[1] + v16.f32[0]);
      }
    }
    else
    {
      if (v16.f32[0] < v16.f32[1])
        v16.f32[0] = v16.f32[1];
      v43.f32[2] = (float)(v15.f32[2] + v16.f32[0]) + v27.f32[2];
    }
    C3DMatrix4x4MakeLookAt((int32x4_t *)&v40, &v43, &v42, &v41);
    C3DMatrix4x4Invert(&v40, &v40);
    if (a2)
    {
      memset(v33, 0, sizeof(v33));
      memset(v32, 0, sizeof(v32));
      memset(v31, 0, sizeof(v31));
      memset(v30, 0, sizeof(v30));
      v35 = vnegq_f32(v42);
      if (v41.f32[1] != 0.0 || v41.f32[2] == 0.0)
        v17 = xmmword_1DD007930;
      else
        v17 = xmmword_1DD007940;
      v34 = v17;
      C3DMatrix4x4MakeTranslation((uint64_t)v33, (__n128 *)&v42);
      C3DMatrix4x4MakeEulerRotation(v32, &v34);
      C3DMatrix4x4MakeTranslation((uint64_t)v31, (__n128 *)&v35);
      C3DMatrix4x4Mult((uint64_t)v31, v32, v30);
      C3DMatrix4x4Mult((uint64_t)v30, v33, v30);
      C3DMatrix4x4Mult((uint64_t)&v40, v30, &v40);
    }
    C3DMatrix4x4Mult((uint64_t)&v40, (float32x4_t *)&v39, &v40);
    C3DNodeSetMatrix(v5, (uint64_t)&v40);
    v18 = v42;
    if (v41.f32[1] == 0.0 && v41.f32[0] == 0.0)
      v18.i32[1] = v28.i32[1];
    else
      v18.i32[2] = v28.i32[2];
    v19 = vsubq_f32(v43, v18);
    v20 = vmulq_f32(v19, v19);
    v21 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0]);
    v22 = vsubq_f32(v43, v29);
    v23 = vmulq_f32(v22, v22);
    v24 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0]);
    if (v21 != 0.0 && v24 != 0.0 && (float)(v24 / v21) < 250.0)
    {
      v25 = sqrt((float)(v24 / v21) / 250.0);
      v21 = v21 * v25;
      v24 = v24 / v25;
    }
    C3DProjectionInfosSetZFar(ProjectionInfosPtr, v24);
    C3DProjectionInfosSetZNear(ProjectionInfosPtr, v21);
  }
  return v5;
}

uint64_t C3DComputeFrustumPlanesFromNode(float32x4_t *a1, float32x4_t *a2, __n128 a3)
{
  uint64_t ProjectionInfos;
  float32x4_t *Matrix;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float32x4_t v12;
  float v13;
  float v14;
  float v15;
  float32x4_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x4_t v19;
  int32x4_t v20;
  float32x2_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float v24;
  float v25;
  float v26;
  int32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int32x4_t v31;
  float32x4_t v32;
  int32x4_t v33;
  float32x2_t v34;
  float32x2_t v35;
  simd_float4x4 v37;
  _OWORD v38[14];
  __n128 v39;

  v39 = a3;
  memset(v38, 0, sizeof(v38));
  ProjectionInfos = C3DNodeGetProjectionInfos((uint64_t)a1, (uint64_t)v38);
  if ((_DWORD)ProjectionInfos)
  {
    memset(&v37, 0, sizeof(v37));
    C3DNodeComputeWorldMatrix(a1, (uint64_t)&v37);
    C3DMatrix4x4Invert(&v37, &v37);
    Matrix = (float32x4_t *)C3DProjectionInfosGetMatrix((char *)v38, (uint64_t)&v39, 0);
    C3DMatrix4x4Mult((uint64_t)&v37, Matrix, &v37);
    v8 = v37.columns[0].f32[2];
    v7 = v37.columns[1].f32[2];
    v10 = v37.columns[2].f32[2];
    v9 = v37.columns[3].f32[2];
    v11 = v37.columns[0].f32[3];
    v12.f32[0] = v37.columns[0].f32[3] - v37.columns[0].f32[0];
    v13 = v37.columns[1].f32[3];
    v14 = v37.columns[2].f32[3];
    v15 = v37.columns[3].f32[3];
    v12.f32[1] = v37.columns[1].f32[3] - v37.columns[1].f32[0];
    v12.f32[2] = v37.columns[2].f32[3] - v37.columns[2].f32[0];
    v12.f32[3] = v37.columns[3].f32[3] - v37.columns[3].f32[0];
    v16 = vmulq_f32(v12, v12);
    v16.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v16, 2), vadd_f32(*(float32x2_t *)v16.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v16.f32, 1))).u32[0];
    v17 = vrsqrte_f32((float32x2_t)v16.u32[0]);
    v18 = vmul_f32(v17, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v17, v17)));
    v19 = vmulq_n_f32(v12, vmul_f32(v18, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v18, v18))).f32[0]);
    v16.f32[0] = v37.columns[0].f32[3] + v37.columns[0].f32[0];
    v16.f32[1] = v37.columns[1].f32[3] + v37.columns[1].f32[0];
    v16.f32[2] = v37.columns[2].f32[3] + v37.columns[2].f32[0];
    v16.f32[3] = v37.columns[3].f32[3] + v37.columns[3].f32[0];
    v20 = (int32x4_t)vmulq_f32(v16, v16);
    v20.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v20, 2), vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v20.i8, 1))).u32[0];
    v21 = vrsqrte_f32((float32x2_t)v20.u32[0]);
    *(float32x2_t *)v22.f32 = vmul_f32(v21, vrsqrts_f32((float32x2_t)v20.u32[0], vmul_f32(v21, v21)));
    v23 = vmulq_n_f32(v16, vmul_f32(*(float32x2_t *)v22.f32, vrsqrts_f32((float32x2_t)v20.u32[0], vmul_f32(*(float32x2_t *)v22.f32, *(float32x2_t *)v22.f32))).f32[0]);
    v20.i32[0] = v37.columns[0].i32[1];
    v22.f32[0] = v37.columns[0].f32[3] + v37.columns[0].f32[1];
    v24 = v37.columns[1].f32[1];
    v25 = v37.columns[2].f32[1];
    v26 = v37.columns[3].f32[1];
    v22.f32[1] = v37.columns[1].f32[3] + v37.columns[1].f32[1];
    v22.f32[2] = v37.columns[2].f32[3] + v37.columns[2].f32[1];
    v22.f32[3] = v37.columns[3].f32[3] + v37.columns[3].f32[1];
    v27 = (int32x4_t)vmulq_f32(v22, v22);
    *a2 = v19;
    a2[1] = v23;
    v19.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v27, 2), vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1))).u32[0];
    *(float32x2_t *)v23.f32 = vrsqrte_f32((float32x2_t)v19.u32[0]);
    *(float32x2_t *)v23.f32 = vmul_f32(*(float32x2_t *)v23.f32, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v23.f32)));
    v28 = vmulq_n_f32(v22, vmul_f32(*(float32x2_t *)v23.f32, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v23.f32))).f32[0]);
    v23.f32[0] = v11 - *(float *)v20.i32;
    v23.f32[1] = v13 - v24;
    v23.f32[2] = v14 - v25;
    v23.f32[3] = v15 - v26;
    v29 = vmulq_f32(v23, v23);
    v29.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v29, 2), vadd_f32(*(float32x2_t *)v29.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v29.f32, 1))).u32[0];
    *(float32x2_t *)v22.f32 = vrsqrte_f32((float32x2_t)v29.u32[0]);
    *(float32x2_t *)v22.f32 = vmul_f32(*(float32x2_t *)v22.f32, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(*(float32x2_t *)v22.f32, *(float32x2_t *)v22.f32)));
    v30 = vmulq_n_f32(v23, vmul_f32(*(float32x2_t *)v22.f32, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(*(float32x2_t *)v22.f32, *(float32x2_t *)v22.f32))).f32[0]);
    v29.f32[0] = v11 - v8;
    v29.f32[1] = v13 - v7;
    v29.f32[2] = v14 - v10;
    v29.f32[3] = v15 - v9;
    v31 = (int32x4_t)vmulq_f32(v29, v29);
    a2[2] = v28;
    a2[3] = v30;
    v28.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v31, 2), vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v31.i8, 1))).u32[0];
    *(float32x2_t *)v30.f32 = vrsqrte_f32((float32x2_t)v28.u32[0]);
    *(float32x2_t *)v30.f32 = vmul_f32(*(float32x2_t *)v30.f32, vrsqrts_f32((float32x2_t)v28.u32[0], vmul_f32(*(float32x2_t *)v30.f32, *(float32x2_t *)v30.f32)));
    v32.f32[0] = v11 + v8;
    v32.f32[1] = v13 + v7;
    v32.f32[2] = v14 + v10;
    v32.f32[3] = v15 + v9;
    v33 = (int32x4_t)vmulq_f32(v32, v32);
    v33.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v33, 2), vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.i8, 1))).u32[0];
    v34 = vrsqrte_f32((float32x2_t)v33.u32[0]);
    v35 = vmul_f32(v34, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(v34, v34)));
    a2[4] = vmulq_n_f32(v29, vmul_f32(*(float32x2_t *)v30.f32, vrsqrts_f32((float32x2_t)v28.u32[0], vmul_f32(*(float32x2_t *)v30.f32, *(float32x2_t *)v30.f32))).f32[0]);
    a2[5] = vmulq_n_f32(v32, vmul_f32(v35, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(v35, v35))).f32[0]);
  }
  return ProjectionInfos;
}

void C3DAdjustZRangeOfProjectionInfos(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t RootNode;
  float32x4_t *WorldMatrix;
  float32x4_t *v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float v17;
  float v18;
  float32x4_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  float32x4_t v24;
  float v25;
  float v26;
  int8x16_t v27;
  float v28;
  float v29;
  float v30;
  double v31;
  float v32;
  float v33;
  double v34;
  double v35;
  float v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  float32x4_t v41;
  char v42;
  __int128 v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (a2 && a4)
  {
    RootNode = C3DSceneGetRootNode(a4);
    if (RootNode)
    {
      v43 = 0u;
      v44 = 0u;
      v42 = 0;
      if (C3DNodeGetBoundingBoxOmittingFloor(RootNode, &v43, (uint64_t)&v42))
      {
        v41.i32[2] = 0;
        v41.i64[0] = 0;
        WorldMatrix = C3DNodeGetWorldMatrix(a2);
        if (WorldMatrix)
        {
          v8 = WorldMatrix;
          C3DMatrix4x4GetAffineTransforms((uint64_t)WorldMatrix, &v41, 0, 0);
          v9 = *v8;
          v10 = v8[1];
          v11 = v8[3];
          v47 = v8[2];
          v48 = v11;
          v45 = v9;
          v46 = v10;
          *(double *)v12.i64 = C3DVector3Rotate((float32x2_t *)&v45, (float32x4_t)xmmword_1DD007960);
          v13 = 0;
          v14.f32[0] = *(float *)&v43 - v44.f32[0];
          v15 = v14;
          v15.f32[1] = *((float *)&v43 + 1) - v44.f32[1];
          v16 = v15;
          v16.f32[2] = *((float *)&v43 + 2) - v44.f32[2];
          v17 = 3.4028e38;
          v18 = -3.4028e38;
          v15.f32[2] = *((float *)&v43 + 2) + v44.f32[2];
          v14.f32[1] = *((float *)&v43 + 1) + v44.f32[1];
          v19 = v14;
          v19.f32[2] = *((float *)&v43 + 2) - v44.f32[2];
          v14.f32[2] = *((float *)&v43 + 2) + v44.f32[2];
          v45 = v16;
          v46 = v15;
          *(float *)&v20 = *(float *)&v43 + v44.f32[0];
          v21 = v20;
          *((float *)&v21 + 1) = *((float *)&v43 + 1) - v44.f32[1];
          v47 = v19;
          v48 = v14;
          v22 = v21;
          *((float *)&v22 + 2) = *((float *)&v43 + 2) - v44.f32[2];
          *((float *)&v21 + 2) = *((float *)&v43 + 2) + v44.f32[2];
          *((float *)&v20 + 1) = *((float *)&v43 + 1) + v44.f32[1];
          v23 = v20;
          *((float *)&v23 + 2) = *((float *)&v43 + 2) - v44.f32[2];
          v49 = v22;
          v50 = v21;
          *((float *)&v20 + 2) = *((float *)&v43 + 2) + v44.f32[2];
          v51 = v23;
          v52 = v20;
          do
          {
            v24 = vmulq_f32(v12, vsubq_f32(*(float32x4_t *)((char *)&v45 + v13), v41));
            v25 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0];
            if (v25 < v17)
              v17 = v25;
            v26 = fabsf(v25);
            if (v26 >= v18)
              v18 = v26;
            v13 += 16;
          }
          while (v13 != 128);
          v27 = (int8x16_t)vmulq_f32(v44, v44);
          *(float *)v27.i32 = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL))));
          v28 = *(float *)v27.i32 + *(float *)v27.i32;
          v29 = v17 + v17 * -0.05;
          v30 = v18 + v18 * 0.05;
          if (v28 <= v30)
            v28 = v18 + v18 * 0.05;
          v31 = fmax(v28 * 0.0001, 0.001);
          if (v31 > 1.0)
            v31 = 1.0;
          v32 = v31;
          if (v32 < v29)
            v32 = v29;
          if (v32 <= v30)
            v33 = v18 + v18 * 0.05;
          else
            v33 = v32;
          if (v42)
            v33 = v33 + v33;
          v34 = v33;
          v35 = v33 * 0.01;
          if (v35 <= v32)
            v36 = v35;
          else
            v36 = v32;
          if (v36 > v33)
          {
            v37 = scn_default_log();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
              C3DAdjustZRangeOfProjectionInfos_cold_3(v37, v36, v34);
          }
          *(double *)(a1 + 8) = v36;
          *(double *)(a1 + 16) = v34;
        }
        else
        {
          v40 = scn_default_log();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            C3DAdjustZRangeOfProjectionInfos_cold_2();
        }
      }
      else if ((*(_BYTE *)a1 & 4) != 0)
      {
        *(_OWORD *)(a1 + 8) = xmmword_1DD007950;
      }
    }
    else
    {
      v39 = scn_default_log();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        C3DAdjustZRangeOfProjectionInfos_cold_1();
    }
  }
  else
  {
    v38 = scn_default_log();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      C3DAdjustZRangeOfProjectionInfos_cold_4();
  }
}

float32x4_t C3DComputeMirrorPlane(float32x4_t *a1, float32x4_t *a2, __n128 *a3)
{
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  int32x4_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x4_t v11;
  float32x4_t result;
  float32x4_t v13;
  float32x4_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  float32x4_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;

  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  C3DNodeComputeWorldMatrix(a1, (uint64_t)&v18);
  v14 = v18;
  v15 = v19;
  v16 = v20;
  v17 = v21;
  *(double *)v5.i64 = C3DVector3MultMatrix4x4(&v14, (float32x4_t)0);
  v13 = v5;
  v6 = *a2;
  v14 = v18;
  v15 = v19;
  v16 = v20;
  v17 = v21;
  *(float32x2_t *)v7.f32 = C3DVector3RotateAndScale((float32x2_t *)&v14, v6);
  v8 = (int32x4_t)vmulq_f32(v7, v7);
  v8.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v8, 2), vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1))).u32[0];
  v9 = vrsqrte_f32((float32x2_t)v8.u32[0]);
  v10 = vmul_f32(v9, vrsqrts_f32((float32x2_t)v8.u32[0], vmul_f32(v9, v9)));
  result = vmulq_n_f32(v7, vmul_f32(v10, vrsqrts_f32((float32x2_t)v8.u32[0], vmul_f32(v10, v10))).f32[0]);
  v11 = vmulq_f32(v13, result);
  result.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0];
  *a3 = (__n128)result;
  return result;
}

__n128 C3DComputeMirrorMatrix(__n128 *a1, float32x4_t *a2, uint64_t a3)
{
  float32x4_t v6;
  __int128 v15;
  __int128 v18;
  __n128 result;
  float32x4_t v20;
  __n128 v21;

  v21.n128_u32[2] = 0;
  v21.n128_u64[0] = 0;
  C3DSceneGetUpAxis(a1, &v21);
  v20 = 0uLL;
  C3DComputeMirrorPlane(a2, (float32x4_t *)&v21, (__n128 *)&v20);
  _Q0 = v20;
  v6 = vnegq_f32(v20);
  _S2 = vmuls_lane_f32(-2.0, v6, 2);
  _D5 = vmul_f32(*(float32x2_t *)v6.f32, (float32x2_t)0xC0000000C0000000);
  __asm { FMLS            S6, S5, V0.S[0] }
  _S7 = _D5.i32[1];
  HIDWORD(v15) = 0;
  *(_QWORD *)&v15 = __PAIR64__(COERCE_UNSIGNED_INT(vmuls_lane_f32(v6.f32[0], _D5, 1)), _S6);
  *((float *)&v15 + 2) = _S2 * v6.f32[0];
  __asm { FMLS            S16, S7, V0.S[1] }
  *(_QWORD *)&_Q6 = __PAIR64__(_S16, COERCE_UNSIGNED_INT(vmuls_lane_f32(_D5.f32[0], *(float32x2_t *)v6.f32, 1)));
  *((_QWORD *)&_Q6 + 1) = COERCE_UNSIGNED_INT(vmuls_lane_f32(_S2, *(float32x2_t *)v6.f32, 1));
  *(_OWORD *)a3 = v15;
  *(_OWORD *)(a3 + 16) = _Q6;
  *(float32x2_t *)&v18 = vmul_laneq_f32(_D5, v6, 2);
  __asm { FMLS            S6, S2, V0.S[2] }
  *((_QWORD *)&v18 + 1) = _Q6;
  result.n128_u64[0] = (unint64_t)vmul_laneq_f32(_D5, v6, 3);
  result.n128_u64[1] = __PAIR64__(1.0, COERCE_UNSIGNED_INT(vmuls_lane_f32(_S2, v6, 3)));
  *(_OWORD *)(a3 + 32) = v18;
  *(__n128 *)(a3 + 48) = result;
  return result;
}

char *C3DSizeForScreenSpaceSizeAndTransform(__n128 *a1)
{
  uint64_t RendererContextGL;
  uint64_t RenderContext;
  float32x4_t *PointOfView;
  char CoordinatesSystemOptions;
  char v6;
  __int128 v7;
  float32x4_t *WorldMatrix;
  __n128 Viewport;
  __int128 v11;
  _OWORD v12[14];
  simd_float4x4 v13;

  RendererContextGL = C3DEngineContextGetRendererContextGL((uint64_t)a1);
  if (RendererContextGL)
    C3DRendererContextGetContentScaleFactor(RendererContextGL);
  RenderContext = C3DEngineContextGetRenderContext((uint64_t)a1);
  if (RenderContext)
    -[SCNMTLRenderContext contentScaleFactor](RenderContext);
  Viewport = C3DEngineContextGetViewport(a1);
  memset(v12, 0, sizeof(v12));
  PointOfView = C3DEngineContextGetPointOfView((uint64_t)a1);
  CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions((uint64_t)a1);
  if (PointOfView
    && (v6 = CoordinatesSystemOptions, C3DNodeGetProjectionInfos((uint64_t)PointOfView, (uint64_t)v12)))
  {
    *(_QWORD *)&v7 = 0;
    *((_QWORD *)&v7 + 1) = vextq_s8((int8x16_t)Viewport, (int8x16_t)Viewport, 8uLL).u64[0];
    v11 = v7;
    WorldMatrix = C3DNodeGetWorldMatrix(PointOfView);
    v13.columns[0] = (simd_float4)*WorldMatrix;
    v13.columns[1] = (simd_float4)WorldMatrix[1];
    v13.columns[2] = (simd_float4)WorldMatrix[2];
    v13.columns[3] = (simd_float4)WorldMatrix[3];
    __invert_f4(v13);
    return C3DProjectionInfosGetMatrix((char *)v12, (uint64_t)&v11, v6);
  }
  else
  {
    C3DEngineContextGetMatrix4x4((uint64_t)a1, 1);
    return (char *)C3DEngineContextGetMatrix4x4((uint64_t)a1, 0);
  }
}

float32x4_t *C3DSetupHaltonFilterKernelConic(float32x4_t *result, int a2, float a3, float a4, float a5)
{
  uint64_t i;
  float v6;
  float v7;
  unsigned int v8;
  float v9;
  BOOL v10;
  float v11;
  int v12;
  float v13;
  unsigned int v14;
  float32_t v15;
  float32x4_t v16;

  if (a2 >= 1)
  {
    for (i = 0; i != a2; result[i++] = v16)
    {
      if (i)
      {
        v6 = 0.5;
        v7 = 0.0;
        v8 = i;
        do
        {
          if ((v8 & 1) != 0)
            v9 = v6;
          else
            v9 = -0.0;
          v7 = v7 + v9;
          v6 = v6 * 0.5;
          v10 = v8 > 1;
          v8 >>= 1;
        }
        while (v10);
        v11 = 0.0;
        v12 = i;
        v13 = 0.33333;
        do
        {
          if (v12 != 3 * (v12 / 3))
            v11 = v11 + (float)((float)(v12 % 3) * v13);
          v13 = v13 * 0.33333;
          v14 = v12 + 2;
          v12 /= 3;
        }
        while (v14 >= 5);
        v15 = (float)((float)(v7 * 2.0) + -1.0) * a3;
        v16 = result[i];
        v16.f32[0] = v15;
        v16.f32[1] = (float)((float)(v11 * 2.0) + -1.0) * a4;
      }
      else
      {
        v16.i64[0] = 0;
        v16.i64[1] = result->i64[1];
        *result = v16;
      }
      v16.i64[1] = COERCE_UNSIGNED_INT(sqrtf(vmlas_n_f32(COERCE_FLOAT(vmulq_f32(v16, v16).i32[1]), v16.f32[0], v16.f32[0])) * a5);
    }
  }
  return result;
}

__C3DFXProgram *C3DEngineContextEvaluateProgram(uint64_t a1, _QWORD *a2, __C3DGeometry *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *FXContext;
  unsigned __int8 *CurrentPassInstance;
  uint64_t v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  const void *ElementAtIndex;
  const void *v16;
  uint64_t CommonProfile;
  __C3DFXProgram *v18;

  FXContext = (_QWORD *)C3DEngineContextGetFXContext(a1);
  CurrentPassInstance = (unsigned __int8 *)C3DFXContextGetCurrentPassInstance(FXContext);
  v12 = CurrentPassInstance[24];
  v13 = CurrentPassInstance[27];
  v14 = CurrentPassInstance[28];
  if (C3DMeshGetElementsCount(a4))
    ElementAtIndex = C3DMeshGetElementAtIndex(a4, 0, 1);
  else
    ElementAtIndex = 0;
  v16 = (const void *)C3DProgramHashCodeCreate(a2, a3, a4, (uint64_t)ElementAtIndex, 0, a5, ((unint64_t)((8 * (v13 & 3)) & 0x9F | (32 * (v14 & 3u))) << 24) | (v12 << 16));
  CommonProfile = C3DMaterialGetCommonProfile(a5);
  v18 = C3DEngineContextEvaluateProgramWithHashCode(a1, (uint64_t)v16, CommonProfile, 0);
  CFRelease(v16);
  return v18;
}

uint64_t C3DMeshElementCreateIntervalList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned __int8 *v18;
  char v19;
  uint64_t v20;
  unsigned __int8 *v21;
  float32x4_t v22;
  int v23;
  char v24;
  size_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  unsigned __int8 *v34;
  float32x4_t v35;
  NSObject *v36;
  uint64_t v38;
  char v40;
  CFIndex v41;
  uint64_t v42;
  UInt8 *v43;
  CFDataRef v44;
  uint64_t v45;
  CFIndex v46;
  int v47;
  UInt8 *v48;
  unsigned __int8 *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v7 = &v45 - 2 * v6;
  if (v6 < 1)
    return 0;
  v8 = 0;
  v9 = 0;
  v10 = v7 + 1;
  do
  {
    *(v10 - 1) = C3DMeshSourceGetContent(*(_QWORD *)(a1 + 8 * v9));
    *v10 = v11;
    if (v8)
    {
      if (v8 != (_DWORD)v11)
      {
        v36 = scn_default_log();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          C3DMeshElementCreateIntervalList_cold_1();
        return 0;
      }
    }
    else
    {
      v8 = v11;
    }
    ++v9;
    v10 += 2;
  }
  while (a2 != v9);
  if (!v8)
    return 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v49 = (unsigned __int8 *)v7;
  v18 = (unsigned __int8 *)v7 + 13;
  v19 = 1;
  do
  {
    if (a2 < 1)
    {
      v20 = 0;
    }
    else
    {
      v20 = 0;
      v21 = v18;
      while (1)
      {
        v22.i64[0] = COERCE_UNSIGNED_INT64(C3DConvertFloatingTypeToFloat4(*(v21 - 1), (float *)(*(_QWORD *)(v21 - 13) + v17 * *v21), v12, v13.f32[0], v14)) & 0x7FFFFFFF7FFFFFFFLL;
        v22.i64[1] &= 0x7FFFFFFF7FFFFFFFuLL;
        v13.i64[0] = 0x3400000034000000;
        v13.i64[1] = 0x3400000034000000;
        v12 = (float32x4_t)vcgeq_f32(v22, v13);
        v12.i32[0] = vmaxvq_u32((uint32x4_t)v12);
        if (v12.i32[0] < 0)
          break;
        ++v20;
        v21 += 16;
        if (a2 == v20)
          goto LABEL_17;
      }
    }
    if (v20 == a2)
    {
LABEL_17:
      v19 |= v15++ > a3;
    }
    else
    {
      v15 = 0;
      v16 += v19 & 1;
      v19 = 0;
    }
    ++v17;
  }
  while (v17 != v8);
  if (!v16)
    return 0;
  if (v8 >= 0xFFFF)
    v23 = 4;
  else
    v23 = 2;
  v24 = 1;
  if (v8 >= 0xFFFF)
    v24 = 2;
  v25 = 2 * (v16 << v24);
  v48 = (UInt8 *)malloc_type_malloc(v25, 0xDEA434A2uLL);
  v46 = v25;
  v47 = v23;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v49 += 13;
  v32 = 1;
  do
  {
    if (a2 < 1)
    {
      v33 = 0;
    }
    else
    {
      v33 = 0;
      v34 = v49;
      while (1)
      {
        v35.i64[0] = COERCE_UNSIGNED_INT64(C3DConvertFloatingTypeToFloat4(*(v34 - 1), (float *)(*(_QWORD *)(v34 - 13) + v29 * *v34), v26, v27.f32[0], v28)) & 0x7FFFFFFF7FFFFFFFLL;
        v35.i64[1] &= 0x7FFFFFFF7FFFFFFFuLL;
        v27.i64[0] = 0x3400000034000000;
        v27.i64[1] = 0x3400000034000000;
        v26 = (float32x4_t)vcgeq_f32(v35, v27);
        v26.i32[0] = vmaxvq_u32((uint32x4_t)v26);
        if (v26.i32[0] < 0)
          break;
        ++v33;
        v34 += 16;
        if (a2 == v33)
          goto LABEL_34;
      }
    }
    if (v33 == a2)
    {
LABEL_34:
      if (!(v32 & 1 | (v30 <= a3)))
      {
        if (v8 > 0xFFFE)
          *(_DWORD *)&v48[8 * v31 + 4] = v29 - v30;
        else
          *(_WORD *)&v48[4 * v31 + 2] = v29 - v30;
        ++v31;
        v32 = 1;
      }
      ++v30;
    }
    else if ((v32 & 1) != 0)
    {
      v30 = 0;
      v32 = 0;
      if (v8 > 0xFFFE)
        *(_DWORD *)&v48[8 * v31] = v29;
      else
        *(_WORD *)&v48[4 * v31] = v29;
    }
    else
    {
      v30 = 0;
      v32 = 0;
    }
    ++v29;
  }
  while (v29 != v8);
  if ((v32 & 1) != 0)
  {
    v40 = v47;
    v41 = v46;
  }
  else
  {
    v42 = (2 * v31) | 1;
    if (v8 > 0xFFFE)
      *(_DWORD *)&v48[4 * v42] = v8 - v30;
    else
      *(_WORD *)&v48[2 * v42] = v8 - v30;
    v40 = v47;
    v41 = v46;
    LODWORD(v31) = v31 + 1;
  }
  v43 = v48;
  v44 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v48, v41);
  free(v43);
  v38 = C3DMeshElementCreate();
  C3DMeshElementSetType(v38, 2);
  C3DMeshElementSetPrimitives(v38, v31, v44, v40);
  CFRelease(v44);
  return v38;
}

void C3DMeshSourceContentClassifyRay(uint64_t a1, uint64_t a2, _BYTE *a3, float32x4_t a4, __n128 a5, double a6, int8x16_t a7, int8x16_t a8)
{
  float32x4_t v8;
  float32x4_t v9;
  int8x16_t v12;
  float v13;
  float v14;
  float32x4_t v15;
  float32_t v16;
  float32x4_t v17;
  float v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float v22;
  float32x4_t v23;
  float32x4_t v24;
  uint64_t v25;
  uint64_t v26;
  float32x4_t v27;
  int8x16_t v28;
  int8x8_t v29;
  unsigned int v30;
  int v31;
  int v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;

  a7.i32[0] = a5.n128_i32[2];
  a8.i32[0] = 1.0;
  v12.i64[0] = 0x8000000080000000;
  v12.i64[1] = 0x8000000080000000;
  v12.i32[0] = vbslq_s8(v12, a8, a7).i32[0];
  v13 = a5.n128_f32[1] / (float)(fabsf(a5.n128_f32[2]) + 1.0);
  v14 = vmuls_lane_f32(v13, (float32x2_t)a5.n128_u64[0], 1);
  v8.f32[0] = -(float)(a5.n128_f32[0] * v13);
  v9.f32[0] = a5.n128_f32[2] + (float)(*(float *)v12.i32 * v14);
  v21.f32[0] = *(float *)v12.i32 * v8.f32[0];
  v15 = v9;
  v15.f32[1] = *(float *)v12.i32 * v8.f32[0];
  v23.f32[0] = -a5.n128_f32[0];
  v15.f32[2] = -a5.n128_f32[0];
  v16 = 1.0 - v14;
  v20.f32[1] = -v9.f32[0];
  v20.f32[2] = v8.f32[0];
  v8.f32[1] = 1.0 - v14;
  v8.i32[2] = vmuls_lane_f32(-*(float *)v12.i32, (float32x2_t)a5.n128_u64[0], 1);
  v17 = vmulq_f32(a4, v15);
  v18 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0];
  v24.f32[0] = -v18;
  v19 = vmulq_f32(a4, v8);
  v19.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).f32[0];
  v20.f32[3] = -(float)(v13 * (float)-a5.n128_f32[0]);
  v21.f32[1] = -(float)(*(float *)v12.i32 * v8.f32[0]);
  v21.f32[2] = v16;
  v21.f32[3] = -v16;
  v22 = -(float)(a5.n128_f32[1] * (float)-*(float *)v12.i32);
  v23.i32[1] = a5.n128_u32[0];
  v23.i32[2] = v8.i32[2];
  v23.f32[3] = v22;
  v24.f32[1] = v18;
  v24.f32[2] = -v19.f32[0];
  v24.i32[3] = v19.i32[0];
  v25 = a2;
  if ((a2 & 0xFF000000000000) == 0x1000000000000)
  {
    if ((_DWORD)a2)
    {
      v26 = 0;
      v27 = vnegq_f32(v24);
      do
      {
        v28 = (int8x16_t)vcgtq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v21, *(float *)(a1 + v26 + 4)), v20, *(float *)(a1 + v26)), v23, *(float *)(a1 + v26 + 8)), v27);
        v29 = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), (int8x8_t)0x800000004);
        *a3++ = v28.i8[4] & 2 | (v28.i32[0] < 0) | v29.i8[0] | v29.i8[4];
        v26 += BYTE5(a2);
        --v25;
      }
      while (v25);
    }
  }
  else if ((_DWORD)a2)
  {
    v30 = 0;
    v31 = BYTE4(a2);
    v32 = BYTE5(a2);
    v33 = vnegq_f32(v24);
    v35 = v33;
    v37 = v21;
    v38 = v20;
    v36 = v23;
    do
    {
      *(double *)v34.i64 = C3DConvertFloatingTypeToFloat4(v31, (float *)(a1 + v30), v33, a5.n128_f32[0], v22);
      v33 = (float32x4_t)vcgtq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v37, *(float32x2_t *)v34.f32, 1), v38, v34.f32[0]), v36, v34, 2), v35);
      a5.n128_u64[0] = (unint64_t)vand_s8((int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v33, (int8x16_t)v33, 8uLL), (int8x8_t)0x800000004);
      *a3++ = v33.i8[4] & 2 | (v33.i32[0] < 0) | a5.n128_u8[0] | a5.n128_u8[4];
      v30 += v32;
      --v25;
    }
    while (v25);
  }
}

void __MergeRendererElementsSharingSameMaterial(void *a1, CFArrayRef theArray, uint64_t a3)
{
  CFIndex Count;
  uint64_t v7;
  uint64_t v8;
  BOOL DoubleSided;
  int Type;
  uint64_t v11;
  uint64_t v12;
  CFIndex v13;
  uint64_t v14;
  uint64_t *ValueAtIndex;
  NSObject *v16;
  uint64_t v17;
  uint64_t PrimitiveCount;
  CFIndex v19;
  const __CFAllocator *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  const UInt8 *v24;
  int v25;
  const void *Copy;
  CFDataRef v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  CFIndex v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  int Value;
  char *appended;
  _WORD *v38;
  uint64_t *v39;
  uint64_t v40;
  unsigned int v41;
  int v42;
  CFDataRef v43;
  const void *v44;
  uint64_t Mesh;
  CFIndex length;
  int v47;
  char v48;
  uint64_t bytes;
  UInt8 *bytesa;
  int v51;
  uint8_t v52[4];
  _DWORD v53[7];

  *(_QWORD *)&v53[5] = *MEMORY[0x1E0C80C00];
  Count = CFArrayGetCount(theArray);
  if (Count)
  {
    v7 = Count;
    v8 = *(_QWORD *)CFArrayGetValueAtIndex(theArray, 0);
    DoubleSided = C3DMeshElementGetDoubleSided(v8);
    Type = C3DMeshElementGetType(v8);
    if (Type == 2)
      v11 = 2;
    else
      v11 = 3;
    bytes = v11;
    if (*(_BYTE *)(a3 + 8))
    {
      v48 = DoubleSided;
      v51 = Type;
      if (v7 < 1)
      {
        v14 = 0;
        v12 = 0;
      }
      else
      {
        v12 = 0;
        v13 = 0;
        v14 = 0;
        do
        {
          ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(theArray, v13);
          if ((void *)ValueAtIndex[2] != a1)
          {
            v16 = scn_default_log();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
              __MergeRendererElementsSharingSameMaterial_cold_1(v52, v53, v16);
          }
          v17 = *ValueAtIndex;
          PrimitiveCount = C3DMeshElementGetPrimitiveCount(*ValueAtIndex);
          if (v13 < v7 - 1 && v51 == 1)
          {
            if ((C3DMeshElementGetPrimitiveCount(v17) & 1) != 0)
              v14 += 3;
            else
              v14 += 2;
          }
          v12 += PrimitiveCount;
          ++v13;
        }
        while (v7 != v13);
      }
      v30 = v14 + 2 * v7 + v12;
      if (v51 == 1)
      {
        v31 = v30 - 2;
      }
      else
      {
        v30 = v12 * bytes;
        v31 = v12;
      }
      length = v30 * *(unsigned int *)(a3 + 12);
      v47 = v31;
      bytesa = (UInt8 *)C3DMalloc(length);
      if (v7 >= 1)
      {
        v32 = 0;
        v33 = (uint64_t)bytesa;
        do
        {
          v34 = (uint64_t *)CFArrayGetValueAtIndex(theArray, v32);
          v35 = *v34;
          Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), v34);
          appended = (char *)__AppendIndexes(v33, v35, Value, *(_DWORD *)(a3 + 12));
          v33 = (uint64_t)appended;
          if (v51 == 1 && v32 < v7 - 1)
          {
            memcpy(appended, &appended[-*(unsigned int *)(a3 + 12)], *(unsigned int *)(a3 + 12));
            v38 = (_WORD *)(v33 + *(unsigned int *)(a3 + 12));
            if ((C3DMeshElementGetPrimitiveCount(v35) & 1) != 0)
            {
              memcpy(v38, (char *)v38 - *(unsigned int *)(a3 + 12), *(unsigned int *)(a3 + 12));
              v38 = (_WORD *)((char *)v38 + *(unsigned int *)(a3 + 12));
            }
            v39 = (uint64_t *)CFArrayGetValueAtIndex(theArray, ++v32);
            v40 = *v39;
            v41 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), v39);
            v42 = *(_DWORD *)(a3 + 12);
            if (v42 == 2)
            {
              *v38 = C3DMeshElementGetIndex(v40, 0, 0, 0) + v41;
            }
            else if (v42 == 4)
            {
              *(_DWORD *)v38 = C3DMeshElementGetIndex(v40, 0, 0, 0) + v41;
            }
            else
            {
              *(_BYTE *)v38 = C3DMeshElementGetIndex(v40, 0, 0, 0) + v41;
            }
            v33 = (uint64_t)v38 + *(unsigned int *)(a3 + 12);
          }
          else
          {
            ++v32;
          }
        }
        while (v32 != v7);
      }
      v43 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytesa, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
      v44 = (const void *)C3DMeshElementCreate();
      C3DMeshElementSetDoubleSided((uint64_t)v44, v48);
      C3DMeshElementInit((uint64_t)v44, v51, v47, v43, *(_DWORD *)(a3 + 12));
      CFRelease(v43);
      Mesh = C3DGeometryGetMesh(*(_QWORD *)a3);
      C3DMeshAppendElement(Mesh, v44);
      CFRelease(v44);
      if (a1)
        C3DGeometryAppendMaterial(*(_QWORD *)a3, a1);
    }
    else if (v7 >= 1)
    {
      v19 = 0;
      v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      do
      {
        v21 = (uint64_t *)CFArrayGetValueAtIndex(theArray, v19);
        v22 = *v21;
        v23 = C3DMeshElementGetPrimitiveCount(*v21) * bytes * *(unsigned int *)(a3 + 12);
        v24 = (const UInt8 *)C3DMalloc(v23);
        v25 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), v21);
        __AppendIndexes((uint64_t)v24, v22, v25, *(_DWORD *)(a3 + 12));
        Copy = (const void *)C3DMeshElementCreateCopy(v22);
        v27 = CFDataCreateWithBytesNoCopy(v20, v24, v23, v20);
        v28 = C3DMeshElementGetPrimitiveCount((uint64_t)Copy);
        C3DMeshElementSetPrimitives((uint64_t)Copy, v28, v27, *(_DWORD *)(a3 + 12));
        CFRelease(v27);
        v29 = C3DGeometryGetMesh(*(_QWORD *)a3);
        C3DMeshAppendElement(v29, Copy);
        CFRelease(Copy);
        if (a1)
          C3DGeometryAppendMaterial(*(_QWORD *)a3, a1);
        ++v19;
      }
      while (v7 != v19);
    }
    __DestroyFlattenElementsArray(theArray);
  }
}

uint64_t __AppendIndexes(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t PrimitiveCount;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t k;
  uint64_t m;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t i;
  uint64_t j;
  uint64_t v22;
  uint64_t n;
  uint64_t ii;
  int v26;

  v26 = 0;
  PrimitiveCount = C3DMeshElementGetPrimitiveCount(a2);
  if (C3DMeshElementGetType(a2) == 2)
    v9 = 2;
  else
    v9 = 3;
  C3DMeshElementGetIndexes(a2, &v26);
  if (C3DMeshElementGetType(a2) == 1)
  {
    if (a4 == 2)
    {
      if (PrimitiveCount < -1)
      {
        v16 = 0;
      }
      else
      {
        v15 = 0;
        v16 = PrimitiveCount + 2;
        do
        {
          *(_WORD *)(a1 + 2 * v15) = C3DMeshElementGetIndex(a2, 3 * (v15 / 3), v15 % 3, 0) + a3;
          ++v15;
        }
        while (v16 != v15);
      }
      return a1 + 2 * v16;
    }
    else if (a4 == 1)
    {
      if (PrimitiveCount < -1)
      {
        v11 = 0;
      }
      else
      {
        v10 = 0;
        v11 = PrimitiveCount + 2;
        do
        {
          *(_BYTE *)(a1 + v10) = C3DMeshElementGetIndex(a2, 3 * (v10 / 3), v10 % 3, 0) + a3;
          ++v10;
        }
        while (v11 != v10);
      }
      return a1 + v11;
    }
    else
    {
      if (PrimitiveCount < -1)
      {
        v18 = 0;
      }
      else
      {
        v17 = 0;
        v18 = PrimitiveCount + 2;
        do
        {
          *(_DWORD *)(a1 + 4 * v17) = C3DMeshElementGetIndex(a2, 3 * (v17 / 3), v17 % 3, 0) + a3;
          ++v17;
        }
        while (v18 != v17);
      }
      return a1 + 4 * v18;
    }
  }
  else if (a4 == 1)
  {
    if (PrimitiveCount < 1)
    {
      v19 = 0;
    }
    else
    {
      v19 = 0;
      for (i = 0; i != PrimitiveCount; ++i)
      {
        for (j = 0; j != v9; ++j)
          *(_BYTE *)(a1 + v19 + j) = C3DMeshElementGetIndex(a2, i, j, 0) + a3;
        v19 += j;
      }
    }
    return a1 + v19;
  }
  else if (a4 == 2)
  {
    if (PrimitiveCount < 1)
    {
      v12 = 0;
    }
    else
    {
      v12 = 0;
      for (k = 0; k != PrimitiveCount; ++k)
      {
        for (m = 0; m != v9; ++m)
          *(_WORD *)(a1 + 2 * v12 + 2 * m) = C3DMeshElementGetIndex(a2, k, m, 0) + a3;
        v12 += m;
      }
    }
    return a1 + 2 * v12;
  }
  else
  {
    if (PrimitiveCount < 1)
    {
      v22 = 0;
    }
    else
    {
      v22 = 0;
      for (n = 0; n != PrimitiveCount; ++n)
      {
        for (ii = 0; ii != v9; ++ii)
          *(_DWORD *)(a1 + 4 * v22 + 4 * ii) = C3DMeshElementGetIndex(a2, n, ii, 0) + a3;
        v22 += ii;
      }
    }
    return a1 + 4 * v22;
  }
}

void _unifyNormals(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  const __CFArray *ElementsCount;
  unsigned int Count;
  uint64_t Content;
  uint64_t v13;
  uint64_t v14;
  float32x4_t v15;
  float v16;
  float v17;
  uint64_t v18;
  _DWORD *WeldRemappingTable;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  CFIndex i;
  const void *ElementAtIndex;
  uint64_t ChannelForSourceWithSemanticAtIndex;
  NSObject *v27;
  unsigned int v28;
  uint64_t j;
  uint64_t v30;
  float32x4_t v31;
  unsigned int v32;
  uint64_t v33;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int32x4_t v44;
  float32x4_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int8x16_t v49;
  uint8_t buf[16];
  __int128 v51;
  __n128 v52;
  uint64_t v53;
  _QWORD v54[9];
  __int128 v55;
  __int128 v56;
  __n128 v57;
  uint64_t v58;

  ElementsCount = C3DMeshGetElementsCount(a1);
  Count = C3DMeshSourceGetCount(a3);
  Content = C3DMeshSourceGetContent(a2);
  v46 = v13;
  v47 = Content;
  v14 = C3DMeshSourceGetContent(a3);
  v48 = v18;
  if (a5)
    WeldRemappingTable = C3DMeshSourceCreateWeldRemappingTable(a2);
  else
    WeldRemappingTable = 0;
  v20 = BYTE4(v48);
  v21 = BYTE5(v48);
  if (Count)
  {
    v22 = 0;
    v23 = Count;
    do
    {
      C3DConvertFloatingTypeFromFloat4(BYTE4(v48), v14 + v22, (float32x4_t)0);
      v22 += BYTE5(v48);
      --v23;
    }
    while (v23);
  }
  if ((uint64_t)ElementsCount >= 1)
  {
    for (i = 0; (const __CFArray *)i != ElementsCount; ++i)
    {
      ElementAtIndex = C3DMeshGetElementAtIndex(a1, i, a4);
      if (a4)
        ChannelForSourceWithSemanticAtIndex = 0;
      else
        ChannelForSourceWithSemanticAtIndex = C3DMeshGetChannelForSourceWithSemanticAtIndex(a1, 0, 0);
      v58 = 0;
      v56 = 0u;
      v57 = 0u;
      v55 = 0u;
      C3DMeshElementGetContent((uint64_t)ElementAtIndex, ChannelForSourceWithSemanticAtIndex, (uint64_t)&v55);
      if ((BYTE10(v56) & 0xFA) != 0)
      {
        v27 = scn_default_log();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1DCCB8000, v27, OS_LOG_TYPE_DEFAULT, "Warning: C3DUnifyNormalsFromGeometry can only process triangles and polygons", buf, 2u);
        }
      }
      else
      {
        v54[0] = MEMORY[0x1E0C809B0];
        v54[1] = 3221225472;
        v54[2] = ___unifyNormals_block_invoke;
        v54[3] = &__block_descriptor_72_e19_v32__0I8_I12I20_B24l;
        v54[4] = v47;
        v54[5] = v46;
        v54[6] = WeldRemappingTable;
        v54[7] = v14;
        v54[8] = v48;
        *(_OWORD *)buf = v55;
        v51 = v56;
        v52 = v57;
        v53 = v58;
        C3DIndicesContentEnumeratePrimitives((uint64_t *)buf, (uint64_t)v54, v57);
      }
    }
  }
  if (WeldRemappingTable && Count)
  {
    v28 = 0;
    for (j = 0; j != Count; ++j)
    {
      v30 = WeldRemappingTable[j];
      if (j != v30)
      {
        *(double *)v31.i64 = C3DConvertFloatingTypeToFloat4(BYTE4(v48), (float *)(v14 + v30 * BYTE5(v48)), v15, v16, v17);
        C3DConvertFloatingTypeFromFloat4(BYTE4(v48), v14 + v28, v31);
      }
      v28 += BYTE5(v48);
    }
  }
  if (Count)
  {
    v32 = 0;
    v33 = Count;
    __asm { FMOV            V0.4S, #1.0 }
    v49 = (int8x16_t)_Q0;
    do
    {
      *(double *)v39.i64 = C3DConvertFloatingTypeToFloat4(v20, (float *)(v14 + v32), _Q0, v16, v17);
      v40 = vmulq_f32(v39, v39);
      v40.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).u64[0];
      v41 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 0);
      v42 = vrsqrteq_f32(v41);
      v43 = vmulq_f32(v42, vrsqrtsq_f32(v41, vmulq_f32(v42, v42)));
      v44 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v40.f32[0] != 0.0)), 0x1FuLL));
      v44.i32[3] = 0;
      v45 = vmulq_f32(v39, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v44), (int8x16_t)vmulq_f32(v43, vrsqrtsq_f32(v41, vmulq_f32(v43, v43))), v49));
      v45.i32[3] = v39.i32[3];
      C3DConvertFloatingTypeFromFloat4(v20, v14 + v32, v45);
      v32 += v21;
      --v33;
    }
    while (v33);
  }
  free(WeldRemappingTable);
}

float32x4_t ___unifyNormalsOptimized_block_invoke(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, uint64_t a5, unsigned int *a6, unsigned int a7)
{
  unsigned int *v8;
  uint64_t v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t result;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  float32x4_t v47;
  float32x4_t v48;
  unsigned int *v49;
  uint64_t v50;
  float32x4_t v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  float32x4_t v55;
  int32x4_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  unsigned int v61;
  unsigned int v62;
  uint64_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;

  v8 = a6;
  if (a7 <= 2)
  {
    v33 = scn_default_log();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
      ___unifyNormalsOptimized_block_invoke_cold_1(v33, v34, v35, v36, v37, v38, v39, v40);
  }
  else if (a7 == 3)
  {
    v10 = *(_QWORD *)(a1 + 32);
    v11 = *(unsigned __int8 *)(a1 + 45);
    v12 = *(_DWORD *)(a1 + 72);
    v13 = *a6;
    if (v12 < *a6)
      v13 = *(_DWORD *)(a1 + 72);
    v14 = v10 + v13 * v11;
    a2.i64[0] = *(_QWORD *)v14;
    a2.i32[2] = *(_DWORD *)(v14 + 8);
    if (v12 >= a6[1])
      v15 = a6[1];
    else
      v15 = *(_DWORD *)(a1 + 72);
    v16 = v10 + v15 * v11;
    a3.i64[0] = *(_QWORD *)v16;
    a3.i32[2] = *(_DWORD *)(v16 + 8);
    v17 = a6[2];
    if (v12 < v17)
      v17 = *(_DWORD *)(a1 + 72);
    v18 = v10 + v17 * v11;
    a4.i64[0] = *(_QWORD *)v18;
    a4.i32[2] = *(_DWORD *)(v18 + 8);
    v19 = vsubq_f32(a3, a2);
    v20 = vsubq_f32(a4, a2);
    v21 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), vnegq_f32(v19)), v20, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL));
    v22 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v21, v21), (int8x16_t)v21, 0xCuLL);
    v22.i32[3] = 0;
    v23 = (int8x16_t)vmulq_f32(v22, v22);
    *(float32x2_t *)v23.i8 = vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
    v24 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.i8, 1)), 0);
    v25 = vrsqrteq_f32(v24);
    v26 = vmulq_f32(v25, vrsqrtsq_f32(v24, vmulq_f32(v25, v25)));
    __asm { FMOV            V3.4S, #1.0 }
    a3 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v24), _Q3, (int8x16_t)vmulq_f32(v26, vrsqrtsq_f32(v24, vmulq_f32(v26, v26))));
    result = vmulq_f32(v22, a3);
    goto LABEL_25;
  }
  v12 = *(_DWORD *)(a1 + 72);
  if (v12 >= *v8)
    v41 = *v8;
  else
    v41 = *(_DWORD *)(a1 + 72);
  result = 0uLL;
  if (a7 < 3)
  {
LABEL_24:
    if (!a7)
      return result;
  }
  else
  {
    v42 = *(_QWORD *)(a1 + 32);
    v43 = *(unsigned __int8 *)(a1 + 45);
    v44 = v42 + v41 * v43;
    a3.i64[0] = *(_QWORD *)v44;
    a3.i32[2] = *(_DWORD *)(v44 + 8);
    v45 = v8[1];
    if (v12 < v45)
      v45 = *(_DWORD *)(a1 + 72);
    v46 = v42 + v45 * v43;
    result.i64[0] = *(_QWORD *)v46;
    result.i32[2] = *(_DWORD *)(v46 + 8);
    result = vsubq_f32(result, a3);
    v47 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)result, (int32x4_t)result), (int8x16_t)result, 0xCuLL);
    v48 = vnegq_f32(result);
    v49 = v8 + 2;
    v50 = a7 - 2;
    v51.i64[0] = 0x3400000034000000;
    v51.i64[1] = 0x3400000034000000;
    while (1)
    {
      v53 = *v49++;
      v52 = v53;
      if (v12 < v53)
        v52 = *(_DWORD *)(a1 + 72);
      v54 = v42 + v52 * v43;
      result.i64[0] = *(_QWORD *)v54;
      result.i32[2] = *(_DWORD *)(v54 + 8);
      v55 = vsubq_f32(result, a3);
      v56 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v55, (int32x4_t)v55), (int8x16_t)v55, 0xCuLL), v48), v55, v47);
      result = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v56, v56), (int8x16_t)v56, 0xCuLL);
      result.i32[3] = 0;
      if ((vminvq_u32((uint32x4_t)vcgtq_f32(v51, result)) & 0x80000000) == 0)
        break;
      if (!--v50)
        goto LABEL_24;
    }
    v64 = (int8x16_t)vmulq_f32(result, result);
    *(float32x2_t *)v64.i8 = vadd_f32(*(float32x2_t *)v64.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v64, v64, 8uLL));
    v65 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v64.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v64.i8, 1)), 0);
    v66 = vrsqrteq_f32(v65);
    v67 = vmulq_f32(v66, vrsqrtsq_f32(v65, vmulq_f32(v66, v66)));
    __asm { FMOV            V3.4S, #1.0 }
    a3 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v65), _Q3, (int8x16_t)vmulq_f32(v67, vrsqrtsq_f32(v65, vmulq_f32(v67, v67))));
    result = vmulq_f32(result, a3);
  }
LABEL_25:
  v57 = *(_QWORD *)(a1 + 48);
  v58 = *(_QWORD *)(a1 + 56);
  v59 = a7;
  v60 = *(unsigned __int8 *)(a1 + 69);
  do
  {
    v62 = *v8++;
    v61 = v62;
    if (v12 < v62)
      v61 = v12;
    if (v57)
      v61 = *(_DWORD *)(v57 + 4 * v61);
    v63 = v58 + v61 * v60;
    a3.i64[0] = *(_QWORD *)v63;
    a3.i32[2] = *(_DWORD *)(v63 + 8);
    a3 = vaddq_f32(result, a3);
    *(_QWORD *)v63 = a3.i64[0];
    *(_DWORD *)(v63 + 8) = a3.i32[2];
    --v59;
  }
  while (v59);
  return result;
}

void ___unifyNormals_block_invoke(uint64_t a1, float32x4_t a2, float a3, float a4, uint64_t a5, unsigned int *a6, unsigned int a7)
{
  unsigned int *v8;
  float32x4_t v10;
  float v11;
  float v12;
  float32x4_t v13;
  float v14;
  float v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v31;
  float32x4_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  float *v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;

  v8 = a6;
  *(double *)v10.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 44), (float *)(*(_QWORD *)(a1 + 32) + *a6 * *(unsigned __int8 *)(a1 + 45)), a2, a3, a4);
  v39 = v10;
  *(double *)v13.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 44), (float *)(*(_QWORD *)(a1 + 32) + v8[1] * *(unsigned __int8 *)(a1 + 45)), v10, v11, v12);
  v38 = v13;
  *(double *)v16.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 44), (float *)(*(_QWORD *)(a1 + 32) + v8[2] * *(unsigned __int8 *)(a1 + 45)), v13, v14, v15);
  if (a7)
  {
    v17 = vsubq_f32(v38, v39);
    v18 = vsubq_f32(v16, v39);
    v19 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL), vnegq_f32(v17)), v18, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), (int8x16_t)v17, 0xCuLL));
    v20 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v19, v19), (int8x16_t)v19, 0xCuLL);
    v20.i32[3] = 0;
    v21 = (int8x16_t)vmulq_f32(v20, v20);
    *(float32x2_t *)v21.i8 = vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
    v22 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v21.i8, 1)), 0);
    v23 = vrsqrteq_f32(v22);
    v24 = vmulq_f32(v23, vrsqrtsq_f32(v22, vmulq_f32(v23, v23)));
    v25 = (int8x16_t)vmulq_f32(v24, vrsqrtsq_f32(v22, vmulq_f32(v24, v24)));
    __asm { FMOV            V3.4S, #1.0 }
    v31 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v22), _Q3, v25);
    v32 = vmulq_f32(v20, v31);
    v40 = v32;
    v33 = a7;
    do
    {
      v34 = *(_QWORD *)(a1 + 48);
      v35 = v8;
      if (v34)
        v35 = (_DWORD *)(v34 + 4 * *v8);
      v36 = (float *)(*(_QWORD *)(a1 + 56) + *v35 * *(unsigned __int8 *)(a1 + 69));
      *(double *)v37.i64 = C3DConvertFloatingTypeToFloat4(*(unsigned __int8 *)(a1 + 68), v36, v32, v31.f32[0], *(float *)v25.i32);
      C3DConvertFloatingTypeFromFloat4(*(unsigned __int8 *)(a1 + 68), (uint64_t)v36, vaddq_f32(v40, v37));
      ++v8;
      --v33;
    }
    while (v33);
  }
}

C3D::RenderPass *C3D::DeferredShadowPass::DeferredShadowPass(C3D::DeferredShadowPass *this, C3D::RenderGraph *a2, C3D::Pass *a3, __C3DNode *a4, C3D::DrawNodesPass *a5)
{
  C3D::RenderPass *result;

  result = C3D::RenderPass::RenderPass(this, a2, a3);
  *(_QWORD *)result = off_1EA599968;
  *((_QWORD *)result + 31) = a4;
  *((_QWORD *)result + 32) = a5;
  *((_BYTE *)result + 264) = 0;
  return result;
}

const char *C3D::DeferredShadowPass::name(C3D::DeferredShadowPass *this)
{
  return "DeferredShadowPass";
}

uint64_t C3D::DeferredShadowPass::setup(C3D::DeferredShadowPass *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  __int128 v7;
  int v8;

  C3D::Pass::setInputCount(this, 3u);
  C3D::Pass::setOutputCount(this, 1u);
  v2 = C3D::PassDescriptor::inputAtIndex((C3D::DeferredShadowPass *)((char *)this + 32), 0);
  *(_QWORD *)(v2 + 8) = "COLOR";
  C3D::Pass::parentColorDesc(this, (uint64_t)&v7);
  *(_OWORD *)(v2 + 16) = v7;
  *(_DWORD *)(v2 + 32) = v8;
  *(_BYTE *)(v2 + 64) = 1;
  *(_WORD *)(v2 + 66) |= 4u;
  v3 = C3D::PassDescriptor::inputAtIndex((C3D::DeferredShadowPass *)((char *)this + 32), 1u);
  *(_QWORD *)(v3 + 8) = "DEPTH";
  *(_BYTE *)(v3 + 64) = 2;
  v4 = C3D::PassDescriptor::inputAtIndex((C3D::DeferredShadowPass *)((char *)this + 32), 2u);
  *(_QWORD *)(v4 + 8) = C3D::Pass::nameWithPrefixAndPointer(this, "SceneKit-spotShadowDepth-", *((void **)this + 31));
  *(_BYTE *)(v4 + 64) = 2;
  *(_BYTE *)(v4 + 24) = 0;
  v5 = C3D::PassDescriptor::outputAtIndex((C3D::DeferredShadowPass *)((char *)this + 32), 0);
  *(_QWORD *)(v5 + 8) = "COLOR";
  *(_BYTE *)(v5 + 65) = 0;
  result = C3DEngineContextGetEyeCount(*((_QWORD *)this + 2));
  if (result >= 2)
  {
    result = C3DEngineContextGetEyeCount(*((_QWORD *)this + 2));
    *((_WORD *)this + 19) = result;
    *((_BYTE *)this + 120) = 1;
    *((_BYTE *)this + 264) = 1;
  }
  return result;
}

void C3D::DeferredShadowPass::compile(C3D::DeferredShadowPass *this)
{
  uint64_t RenderContext;
  void *v3;
  const __CFDictionary *Light;
  uint64_t v5;
  int ShadowCascadeCount;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int EffectiveShadowSampleCount;
  float ShadowCascadeDebugFactor;
  int Type;
  int v18;
  _BOOL4 v19;
  unsigned int CoordinatesSystemOptions;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  C3D::RenderGraphResourceManager *v26;
  uint64_t v27;
  _QWORD *v28;
  id v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  const __CFString *v33;
  uint64_t v34;
  const __CFString *v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  BOOL v45;
  char v46;
  char v47;
  BOOL v48;
  BOOL v49;
  int v50;
  int v51;

  RenderContext = C3DEngineContextGetRenderContext(*((_QWORD *)this + 2));
  v3 = (void *)-[SCNMTLRenderContext resourceManager](RenderContext);
  Light = C3DNodeGetLight(*((_QWORD *)this + 31));
  if (Light)
  {
    v5 = (uint64_t)Light;
    if (C3DLightSupportsShadowCascades((uint64_t)Light))
      ShadowCascadeCount = C3DLightGetShadowCascadeCount(v5);
    else
      ShadowCascadeCount = 1;
    v51 = ShadowCascadeCount;
    EffectiveShadowSampleCount = C3DLightGetEffectiveShadowSampleCount(v5);
    v50 = EffectiveShadowSampleCount;
    ShadowCascadeDebugFactor = C3DLightGetShadowCascadeDebugFactor(v5);
    v49 = ShadowCascadeDebugFactor > 0.0;
    Type = C3DLightGetType(v5);
    v48 = Type == 3;
    if ((-[SCNMTLRenderContext enableARMode](RenderContext) & 1) != 0)
      v18 = 1;
    else
      v18 = -[SCNMTLRenderContext shouldDelegateARCompositing](RenderContext);
    v19 = Type == 3;
    v47 = v18;
    v46 = 0;
    CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(*((_QWORD *)this + 2));
    v45 = (CoordinatesSystemOptions & 8) != 0;
    v21 = *(unsigned __int16 *)(C3D::PassDescriptor::outputAtIndex((C3D::DeferredShadowPass *)((char *)this + 32), 0)
                              + 28);
    v22 = 0x2000000;
    if (!v18)
      v22 = 0;
    v23 = ((unint64_t)*((unsigned __int8 *)this + 264) << 24) | (v21 << 19) | v22 | (int)((4
                                                                                                * (ShadowCascadeDebugFactor > 0.0)) | (2 * v19) | (CoordinatesSystemOptions >> 3) & 1 | (8 * EffectiveShadowSampleCount) | (ShadowCascadeCount << 11));
    v24 = 0xC6A4A7935BD1E995
        * ((*(uint64_t (**)(C3D::DeferredShadowPass *))(*(_QWORD *)this + 64))(this) ^ 0x35253C9ADE8F4CA8 ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v23) ^ ((0xC6A4A7935BD1E995 * v23) >> 47))));
    v25 = (0xC6A4A7935BD1E995 * (v24 ^ (v24 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v24 ^ (v24 >> 47))) >> 47);
    v26 = *(C3D::RenderGraphResourceManager **)(*((_QWORD *)this + 3) + 128);
    v27 = C3D::RenderGraphResourceManager::get(v26, v25);
    *((_QWORD *)this + 30) = v27;
    if (!v27)
    {
      v28 = (_QWORD *)operator new();
      *v28 = &off_1EA59A3F8;
      v28[1] = 0;
      v28[2] = 0;
      v28[3] = 0;
      *((_QWORD *)this + 30) = v28;
      C3D::RenderGraphResourceManager::set((uint64_t)v26, v25, (uint64_t)v28);
      v29 = objc_alloc_init(MEMORY[0x1E0CC6AA0]);
      v30 = *((_QWORD *)this + 30);
      v31 = *(void **)(v30 + 24);
      *(_QWORD *)(v30 + 24) = v29;
      if (v31)

      objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", &v51, 29, CFSTR("cascadeCount"));
      objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", &v50, 29, CFSTR("sampleCount"));
      objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", &v49, 53, CFSTR("debugCascades"));
      objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", &v46, 53, CFSTR("cascadeBlending"));
      objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", &v48, 53, CFSTR("isSpotLight"));
      objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", &v45, 53, CFSTR("reverseZ"));
      objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24), "setConstantValue:type:withName:", &v47, 53, CFSTR("enableARMode"));
      v32 = *((_QWORD *)this + 30);
      if (v51 <= 1)
        v33 = CFSTR("deferredShadow_frag");
      else
        v33 = CFSTR("deferredShadowCascades_frag");
      *((_QWORD *)&v40 + 1) = objc_msgSend((id)-[SCNMTLResourceManager libraryManager]((uint64_t)v3), "frameworkLibrary", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0);
      *(_QWORD *)&v41 = v21;
      v34 = C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)this + 30) + 24);
      v35 = CFSTR("deferredShadow_VR_vert");
      if (!*((_BYTE *)this + 264))
        v35 = CFSTR("deferredShadow_vert");
      *((_QWORD *)&v42 + 1) = v34;
      *((_QWORD *)&v43 + 1) = v35;
      *(_QWORD *)&v44 = v33;
      v36 = objc_msgSend(v3, "newRenderPipelineStateWithDesc:", &v39);
      v37 = *(void **)(v32 + 16);
      if (v37 != (void *)v36)
      {
        v38 = v36;
        if (v37)

        *(_QWORD *)(v32 + 16) = v38;
      }
    }
  }
  else
  {
    v7 = scn_default_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      C3D::DeferredShadowPass::compile(v7, v8, v9, v10, v11, v12, v13, v14);
  }
}

void C3D::DeferredShadowPass::execute(C3D::Pass *a1, uint64_t a2)
{
  uint64_t v4;
  const __CFDictionary *Light;
  uint64_t v6;
  int EffectiveShadowSampleCount;
  uint64_t Scene;
  uint64_t LightingSystem;
  float32x4_t *v10;
  char CoordinatesSystemOptions;
  uint64_t CullingContext;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  __int128 v16;
  float ShadowRadius;
  __int32 v18;
  uint64_t ShadowColor;
  uint64_t v20;
  int v21;
  uint64_t v22;
  float32x4_t *v23;
  unint64_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  unint64_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  simd_float4x4 v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __n128 ViewportAtIndex;
  int32x4_t v45;
  int32x4_t v46;
  void **v47;
  void **v48;
  void **v49;
  simd_float4 v50;
  simd_float4 v51;
  simd_float4 v52;
  simd_float4 v53;
  simd_float4 v54;
  simd_float4 v55;
  int32x2_t v56;
  float32x4_t v57;
  simd_float4 v58;
  int32x4_t v59;
  float32x4_t v60;
  int8x8_t RealShadowMapSize;
  simd_float4 v62;
  int8x16_t v63;
  float32x4_t v64[68];
  simd_float4 v65;
  simd_float4 v66;
  simd_float4 v67;
  simd_float4 v68;
  uint64_t v69;
  _DWORD v70[20];
  float32x4_t v71;
  float32x4_t v72;
  __int128 v73;
  float v74;
  uint64_t v75;
  uint64_t v76;
  simd_float4 v77;
  simd_float4 v78;
  simd_float4 v79;
  simd_float4 v80;
  simd_float4x4 v81;
  simd_float4 v82[16];
  _BYTE v83[32];
  float32x4_t v84;
  float32x4_t v85;
  uint64_t v86;
  simd_float4x4 v87;
  simd_float4x4 v88;
  simd_float4x4 v89;

  v86 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a2;
  Light = C3DNodeGetLight(*((_QWORD *)a1 + 31));
  if (Light)
  {
    v6 = (uint64_t)Light;
    v68 = 0u;
    v67 = 0u;
    v66 = 0u;
    v65 = 0u;
    memset(&v64[64], 0, 64);
    EffectiveShadowSampleCount = C3DLightGetEffectiveShadowSampleCount((uint64_t)Light);
    if (EffectiveShadowSampleCount >= 2)
      C3DLightComputeShadowKernel(v6, v64, EffectiveShadowSampleCount, *((_QWORD *)a1 + 2));
    Scene = C3DEngineContextGetScene(*((_QWORD *)a1 + 2));
    LightingSystem = C3DSceneGetLightingSystem(Scene);
    v10 = (float32x4_t *)*((_QWORD *)a1 + 31);
    CoordinatesSystemOptions = C3DEngineContextGetCoordinatesSystemOptions(*((_QWORD *)a1 + 2));
    C3DLightingSystemComputeShadowMatrices(LightingSystem, v10, (uint64_t)v83, 0, v82, (uint64_t)&v69, (uint64_t)v70, CoordinatesSystemOptions);
    v65 = v82[0];
    v66 = v82[1];
    v67 = v82[2];
    v68 = v82[3];
    v57 = v85;
    v60 = v84;
    CullingContext = C3D::DrawNodesPass::getCullingContext(*((C3D::DrawNodesPass **)a1 + 32));
    v13 = *(float32x4_t *)(CullingContext + 3088);
    v14 = *(float32x4_t *)(CullingContext + 3104);
    v15 = *(float32x4_t *)(CullingContext + 3120);
    v71 = vaddq_f32(*(float32x4_t *)(CullingContext + 3136), vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v14, *(float32x2_t *)v57.f32, 1), v13, v57.f32[0]), v15, v57, 2));
    v72 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v14, *(float32x2_t *)v60.f32, 1), v13, v60.f32[0]), v15, v60, 2);
    C3DLightComputeSpotAttenuations(v6);
    v73 = v16;
    v70[16] = C3DLightGetShadowCascadeDebugFactor(v6);
    RealShadowMapSize = C3DLightGetRealShadowMapSize(v6);
    ShadowRadius = C3DLightGetShadowRadius(v6);
    v18 = RealShadowMapSize.i32[1];
    if (*(float *)RealShadowMapSize.i32 >= *(float *)&RealShadowMapSize.i32[1])
      v18 = RealShadowMapSize.i32[0];
    v74 = ShadowRadius / fmaxf(*(float *)&v18, 1.0);
    ShadowColor = C3DLightGetShadowColor(v6);
    v76 = v20;
    v75 = ShadowColor;
    v21 = *(unsigned __int16 *)(a2 + 16);
    v22 = C3D::DrawNodesPass::getCullingContext(*((C3D::DrawNodesPass **)a1 + 32));
    if (v21)
    {
      v87 = __invert_f4(*(simd_float4x4 *)(v22 + ((unint64_t)*(unsigned __int16 *)(a2 + 16) << 6) + 3472));
      v54 = v87.columns[1];
      v55 = v87.columns[0];
      v58 = v87.columns[3];
      v62 = v87.columns[2];
      v88 = *(simd_float4x4 *)(C3D::DrawNodesPass::getCullingContext(*((C3D::DrawNodesPass **)a1 + 32))
                             + ((unint64_t)*(unsigned __int16 *)(a2 + 16) << 6)
                             + 3088);
      v89 = __invert_f4(v88);
      v50 = v89.columns[1];
      v51 = v89.columns[0];
      v52 = v89.columns[3];
      v53 = v89.columns[2];
      v23 = (float32x4_t *)C3D::DrawNodesPass::getCullingContext(*((C3D::DrawNodesPass **)a1 + 32));
      v24 = 0;
      v25 = v23[193];
      v26 = v23[194];
      v27 = v23[195];
      v28 = v23[196];
      v77 = v51;
      v78 = v50;
      v79 = v53;
      v80 = v52;
      do
      {
        v81.columns[v24 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v25, COERCE_FLOAT(*(_OWORD *)((char *)&v77 + v24 * 4))), v26, *(float32x2_t *)&v77.f32[v24], 1), v27, *(float32x4_t *)((char *)&v77 + v24 * 4), 2), v28, *(float32x4_t *)((char *)&v77 + v24 * 4), 3);
        v24 += 4;
      }
      while (v24 != 16);
      v29 = 0;
      v30 = (float32x4_t)v81.columns[0];
      v31 = (float32x4_t)v81.columns[1];
      v32 = (float32x4_t)v81.columns[2];
      v33 = (float32x4_t)v81.columns[3];
      v77 = v55;
      v78 = v54;
      v79 = v62;
      v80 = v58;
      do
      {
        v81.columns[v29 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v30, COERCE_FLOAT(*(_OWORD *)((char *)&v77 + v29 * 4))), v31, *(float32x2_t *)&v77.f32[v29], 1), v32, *(float32x4_t *)((char *)&v77 + v29 * 4), 2), v33, *(float32x4_t *)((char *)&v77 + v29 * 4), 3);
        v29 += 4;
      }
      while (v29 != 16);
      v34 = v81;
    }
    else
    {
      v34 = __invert_f4(*(simd_float4x4 *)(v22 + 3472));
    }
    *(simd_float4x4 *)v64[64].f32 = v34;
    v43 = objc_msgSend((id)C3D::SmartPtr<SCNMTLRenderPipeline *,C3D::detail::NSRetainFct,C3D::detail::NSReleaseFct>::operator SCNMTLRenderPipeline *(*((_QWORD *)a1 + 30) + 16), "state");
    if (*(_QWORD *)(v4 + 3376) != v43)
    {
      *(_QWORD *)(v4 + 3376) = v43;
      objc_msgSend(*(id *)(v4 + 3392), "setRenderPipelineState:", v43);
    }
    if (*((_BYTE *)a1 + 264))
    {
      ViewportAtIndex = C3DEngineContextGetViewportAtIndex(*((_QWORD *)a1 + 2), *(unsigned __int16 *)(a2 + 16));
      v63 = vextq_s8((int8x16_t)ViewportAtIndex, (int8x16_t)ViewportAtIndex, 8uLL);
      v45 = *(int32x4_t *)(*(uint64_t (**)(C3D::Pass *))(*(_QWORD *)a1 + 88))(a1);
      v56 = (int32x2_t)vextq_s8(v63, v63, 8uLL).u64[0];
      *(float32x2_t *)v45.i8 = vdiv_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v63.i8, v56), (float32x2_t)vdup_laneq_s32(v45, 2));
      v59 = v45;
      v46 = *(int32x4_t *)(*(uint64_t (**)(C3D::Pass *))(*(_QWORD *)a1 + 88))(a1);
      *(float32x2_t *)v46.i8 = vdiv_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v63.i8, v56), (float32x2_t)vdup_laneq_s32(v46, 3));
      v81.columns[0] = (simd_float4)vzip1q_s32(v59, v46);
      SCNMTLRenderCommandEncoder::setVertexBytes((SCNMTLRenderCommandEncoder *)v4, &v81, 0x10uLL, 0);
    }
    v47 = C3D::Pass::inputTextureAtIndex(a1, 0);
    SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v47, 0);
    v48 = C3D::Pass::inputTextureAtIndex(a1, 1u);
    SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v48, 1uLL);
    v49 = C3D::Pass::inputTextureAtIndex(a1, 2u);
    SCNMTLRenderCommandEncoder::setFragmentTexture(v4, v49, 2uLL);
    SCNMTLRenderCommandEncoder::setFragmentBytes((SCNMTLRenderCommandEncoder *)v4, v64, 0x560uLL, 0);
    SCNMTLRenderCommandEncoder::drawFullScreenTriangle((SCNMTLRenderCommandEncoder *)v4);
  }
  else
  {
    v35 = scn_default_log();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      C3D::DeferredShadowPass::execute(v35, v36, v37, v38, v39, v40, v41, v42);
  }
}

void C3D::DeferredShadowPassResource::~DeferredShadowPassResource(C3D::DeferredShadowPassResource *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1EA59A3F8;
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)

  v3 = (void *)*((_QWORD *)this + 2);
  if (v3)

}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1EA59A3F8;
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)

  v3 = (void *)*((_QWORD *)this + 2);
  if (v3)

  JUMPOUT(0x1DF0D41C0);
}

BOOL c3dPhysicsField::contains(float32x4_t *a1, float32x2_t *a2)
{
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float v6;
  float v7;
  float v8;
  float32x4_t v9;
  float v10;
  int v11;
  uint32x4_t v12;
  unsigned int v13;

  v3 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *a2, 1), a1[5], COERCE_FLOAT(*(_OWORD *)a2->f32)), a1[7], *(float32x4_t *)a2->f32, 2));
  if (a1[12].i8[15])
  {
    v4 = vdivq_f32(v3, a1[11]);
    v5 = vmulq_f32(v4, v4);
    v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0];
    v7 = 1.0;
    if (v6 < 1.0)
      goto LABEL_3;
LABEL_8:
    v11 = 0;
    goto LABEL_9;
  }
  v12 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v3));
  v12.i32[3] = v12.i32[2];
  v13 = vminvq_u32(v12);
  v7 = 1.0;
  if ((v13 & 0x80000000) == 0)
    goto LABEL_8;
LABEL_3:
  v8 = a1[12].f32[0];
  if (v8 > 0.0)
  {
    v9 = vmulq_f32(v3, v3);
    v10 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0])- a1[12].f32[1];
    if (v10 >= 0.0)
      v7 = powf(v10, -v8);
  }
  v11 = 1;
LABEL_9:
  a1[13].f32[0] = v7 * a1[10].f32[0];
  return a1[12].u8[13] != v11;
}

void c3dPhysicsFieldLinearGravity::c3dPhysicsFieldLinearGravity(c3dPhysicsFieldLinearGravity *this)
{
  _OWORD *v1;
  __int128 v2;
  __int128 v3;

  v1 = (_OWORD *)MEMORY[0x1E0C83FF0];
  *(_QWORD *)this = off_1EA596220;
  v2 = v1[1];
  *((_OWORD *)this + 5) = *v1;
  *((_OWORD *)this + 6) = v2;
  v3 = v1[3];
  *((_OWORD *)this + 7) = v1[2];
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(_QWORD *)this = &off_1EA597E68;
  *((_OWORD *)this + 15) = 0u;
}

float32x4_t c3dPhysicsFieldLinearGravity::_transformHasChanged(c3dPhysicsFieldLinearGravity *this)
{
  float32x4_t result;

  result = *((float32x4_t *)this + 1);
  *((float32x4_t *)this + 16) = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(*((float32x4_t *)this + 2), *(float32x2_t *)((char *)this + 240), 1), result, COERCE_FLOAT(*((_OWORD *)this + 15))), *((float32x4_t *)this + 3), *((float32x4_t *)this + 15), 2);
  return result;
}

double c3dPhysicsFieldLinearGravity::evalForce(float32x4_t *a1, double a2, double a3, float a4)
{
  double result;

  *(_QWORD *)&result = vmulq_n_f32(a1[16], a1[13].f32[0] * a4).u64[0];
  return result;
}

void c3dPhysicsFieldLinearGravity::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4, double a5, double a6, double a7, double a8, double a9, __n128 a10)
{
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float v17;
  float32x4_t v18;
  float v19;
  float v20;
  int v21;
  uint32x4_t v22;
  uint64_t v23;
  float32x4_t v24;
  __n128 v25;

  if (a3 < a4)
  {
    v12 = a3;
    v13 = a4;
    do
    {
      a10.n128_f32[0] = *(float *)(a2 + 56) * a1[10].f32[0];
      v14 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)(*(_QWORD *)a2 + 16 * v12), 1), a1[5], COERCE_FLOAT(*(_OWORD *)(*(_QWORD *)a2 + 16 * v12))), a1[7], *(float32x4_t *)(*(_QWORD *)a2 + 16 * v12), 2));
      if (a1[12].i8[15])
      {
        v15 = vmulq_f32(v14, a1[11]);
        v16 = vmulq_f32(v15, v15);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0] < 1.0)goto LABEL_5;
      }
      else
      {
        v22 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v14));
        v22.i32[3] = v22.i32[2];
        if ((vminvq_u32(v22) & 0x80000000) != 0)
        {
LABEL_5:
          v17 = a1[12].f32[0];
          if (v17 > 0.0)
          {
            v18 = vmulq_f32(v14, v14);
            v19 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0])- a1[12].f32[1];
            v20 = 1.0;
            if (v19 >= 0.0)
            {
              v25 = a10;
              v20 = powf(v19, -v17);
              a10 = v25;
            }
            a10.n128_f32[0] = a10.n128_f32[0] * v20;
          }
          v21 = 1;
          goto LABEL_12;
        }
      }
      v21 = 0;
LABEL_12:
      if (a1[12].u8[13] != v21)
      {
        v23 = *(_QWORD *)(a2 + 8);
        v24 = vmlaq_n_f32(*(float32x4_t *)(v23 + 16 * v12), a1[16], a10.n128_f32[0]);
        v24.i32[3] = HIDWORD(*(_OWORD *)(v23 + 16 * v12));
        *(float32x4_t *)(v23 + 16 * v12) = v24;
      }
      ++v12;
    }
    while (v13 != v12);
  }
}

uint64_t c3dPhysicsFieldLinearGravity::setGravity(_OWORD *a1, _OWORD *a2)
{
  a1[15] = *a2;
  return (*(uint64_t (**)(_OWORD *))(*(_QWORD *)a1 + 40))(a1);
}

void c3dPhysicsFieldRadialGravity::c3dPhysicsFieldRadialGravity(c3dPhysicsFieldRadialGravity *this)
{
  uint64_t v1;
  __int128 v2;
  __int128 v3;

  *(_QWORD *)this = off_1EA596220;
  v1 = MEMORY[0x1E0C83FF0];
  v2 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x1E0C83FF0];
  *((_OWORD *)this + 6) = v2;
  v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(_QWORD *)this = &off_1EA597EA8;
}

double c3dPhysicsFieldRadialGravity::evalForce(float32x4_t *a1, float32x4_t a2, double a3, float a4)
{
  float32x4_t v4;
  float32x4_t v5;
  float v6;
  double result;

  v4 = vsubq_f32(a2, a1[14]);
  v5 = vmulq_f32(v4, v4);
  v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0];
  if (v6 < (float)(a1[12].f32[1] * a1[12].f32[1]))
    v6 = a1[12].f32[1] * a1[12].f32[1];
  *(_QWORD *)&result = vmulq_n_f32(vnegq_f32(v4), (float)(a1[13].f32[0] * a4) / (float)(v6 * sqrtf(v6))).u64[0];
  return result;
}

void c3dPhysicsFieldRadialGravity::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v6;
  uint64_t v7;
  float32x4_t v8;
  float v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float v13;
  float32x4_t v14;
  float v15;
  float v16;
  int v17;
  uint32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;

  if (a3 < a4)
  {
    v6 = a3;
    v7 = a4;
    do
    {
      v8 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6);
      v9 = *(float *)(a2 + 56) * a1[10].f32[0];
      v10 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v8.f32, 1), a1[5], v8.f32[0]), a1[7], v8, 2));
      if (a1[12].i8[15])
      {
        v11 = vmulq_f32(v10, a1[11]);
        v12 = vmulq_f32(v11, v11);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0] < 1.0)goto LABEL_5;
      }
      else
      {
        v18 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v10));
        v18.i32[3] = v18.i32[2];
        if ((vminvq_u32(v18) & 0x80000000) != 0)
        {
LABEL_5:
          v13 = a1[12].f32[0];
          if (v13 > 0.0)
          {
            v14 = vmulq_f32(v10, v10);
            v15 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0])- a1[12].f32[1];
            v16 = 1.0;
            if (v15 >= 0.0)
            {
              v24 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6);
              v16 = powf(v15, -v13);
              v8 = v24;
            }
            v9 = v9 * v16;
          }
          v17 = 1;
          goto LABEL_12;
        }
      }
      v17 = 0;
LABEL_12:
      if (a1[12].u8[13] != v17)
      {
        v19 = vsubq_f32(v8, a1[14]);
        v20 = vmulq_f32(v19, v19);
        v21 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0];
        if (v21 < (float)(a1[12].f32[1] * a1[12].f32[1]))
          v21 = a1[12].f32[1] * a1[12].f32[1];
        v22 = *(_QWORD *)(a2 + 8);
        v23 = vsubq_f32(*(float32x4_t *)(v22 + 16 * v6), vmulq_n_f32(v19, v9 / (float)(v21 * sqrtf(v21))));
        v23.i32[3] = HIDWORD(*(_OWORD *)(v22 + 16 * v6));
        *(float32x4_t *)(v22 + 16 * v6) = v23;
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void c3dPhysicsFieldSpring::c3dPhysicsFieldSpring(c3dPhysicsFieldSpring *this)
{
  uint64_t v1;
  __int128 v2;
  __int128 v3;

  *(_QWORD *)this = off_1EA596220;
  v1 = MEMORY[0x1E0C83FF0];
  v2 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x1E0C83FF0];
  *((_OWORD *)this + 6) = v2;
  v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(_QWORD *)this = &off_1EA597180;
}

double c3dPhysicsFieldSpring::evalForce(float32x4_t *a1, float32x4_t a2, double a3, float a4)
{
  float32x4_t v4;
  float32x4_t v5;
  float v6;
  double result;

  v4 = vsubq_f32(a2, a1[14]);
  v5 = vmulq_f32(v4, v4);
  v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0];
  if (v6 < (float)(a1[12].f32[1] * a1[12].f32[1]))
    v6 = a1[12].f32[1] * a1[12].f32[1];
  *(_QWORD *)&result = vmulq_n_f32(vnegq_f32(v4), (float)(a1[13].f32[0] * sqrtf(v6)) * a4).u64[0];
  return result;
}

void c3dPhysicsFieldSpring::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v6;
  uint64_t v7;
  float32x4_t v8;
  float v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float v13;
  float32x4_t v14;
  float v15;
  float v16;
  int v17;
  uint32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float v21;
  uint64_t v22;
  float32x4_t v23;
  float32x4_t v24;

  if (a3 < a4)
  {
    v6 = a3;
    v7 = a4;
    do
    {
      v8 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6);
      v9 = *(float *)(a2 + 56) * a1[10].f32[0];
      v10 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v8.f32, 1), a1[5], v8.f32[0]), a1[7], v8, 2));
      if (a1[12].i8[15])
      {
        v11 = vmulq_f32(v10, a1[11]);
        v12 = vmulq_f32(v11, v11);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0] < 1.0)goto LABEL_5;
      }
      else
      {
        v18 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v10));
        v18.i32[3] = v18.i32[2];
        if ((vminvq_u32(v18) & 0x80000000) != 0)
        {
LABEL_5:
          v13 = a1[12].f32[0];
          if (v13 > 0.0)
          {
            v14 = vmulq_f32(v10, v10);
            v15 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0])- a1[12].f32[1];
            v16 = 1.0;
            if (v15 >= 0.0)
            {
              v24 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6);
              v16 = powf(v15, -v13);
              v8 = v24;
            }
            v9 = v9 * v16;
          }
          v17 = 1;
          goto LABEL_12;
        }
      }
      v17 = 0;
LABEL_12:
      if (a1[12].u8[13] != v17)
      {
        v19 = vsubq_f32(v8, a1[14]);
        v20 = vmulq_f32(v19, v19);
        v21 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0]);
        if (v21 < a1[12].f32[1])
          v21 = a1[12].f32[1];
        v22 = *(_QWORD *)(a2 + 8);
        v23 = vsubq_f32(*(float32x4_t *)(v22 + 16 * v6), vmulq_n_f32(v19, v9 * v21));
        v23.i32[3] = HIDWORD(*(_OWORD *)(v22 + 16 * v6));
        *(float32x4_t *)(v22 + 16 * v6) = v23;
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void c3dPhysicsFieldElectric::c3dPhysicsFieldElectric(c3dPhysicsFieldElectric *this)
{
  uint64_t v1;
  __int128 v2;
  __int128 v3;

  *(_QWORD *)this = off_1EA596220;
  v1 = MEMORY[0x1E0C83FF0];
  v2 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x1E0C83FF0];
  *((_OWORD *)this + 6) = v2;
  v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(_QWORD *)this = &off_1EA5977E0;
}

double c3dPhysicsFieldElectric::evalForce(float32x4_t *a1, float32x4_t a2, double a3, double a4, float a5)
{
  float32x4_t v5;
  float32x4_t v6;
  int32x2_t v7;
  double result;

  v5 = vsubq_f32(a2, a1[14]);
  v6 = vmulq_f32(v5, v5);
  v7 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).u64[0];
  if (*(float *)v7.i32 < (float)(a1[12].f32[1] * a1[12].f32[1]))
    *(float *)v7.i32 = a1[12].f32[1] * a1[12].f32[1];
  *(float *)v7.i32 = sqrtf(*(float *)v7.i32);
  *(_QWORD *)&result = vmulq_n_f32(vdivq_f32(v5, (float32x4_t)vdupq_lane_s32(v7, 0)), (float)(a1[13].f32[0] * a5) / *(float *)v7.i32).u64[0];
  return result;
}

void c3dPhysicsFieldElectric::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v6;
  uint64_t v7;
  float32x4_t v8;
  float v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float v13;
  float32x4_t v14;
  float v15;
  float v16;
  int v17;
  uint32x4_t v18;
  uint64_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float v22;
  float v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x4_t v26;
  float32x4_t v27;

  if (a3 < a4)
  {
    v6 = a3;
    v7 = a4;
    do
    {
      v8 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6);
      v9 = *(float *)(a2 + 56) * a1[10].f32[0];
      v10 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v8.f32, 1), a1[5], v8.f32[0]), a1[7], v8, 2));
      if (a1[12].i8[15])
      {
        v11 = vmulq_f32(v10, a1[11]);
        v12 = vmulq_f32(v11, v11);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0] < 1.0)goto LABEL_5;
      }
      else
      {
        v18 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v10));
        v18.i32[3] = v18.i32[2];
        if ((vminvq_u32(v18) & 0x80000000) != 0)
        {
LABEL_5:
          v13 = a1[12].f32[0];
          if (v13 > 0.0)
          {
            v14 = vmulq_f32(v10, v10);
            v15 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0])- a1[12].f32[1];
            v16 = 1.0;
            if (v15 >= 0.0)
            {
              v27 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6);
              v16 = powf(v15, -v13);
              v8 = v27;
            }
            v9 = v9 * v16;
          }
          v17 = 1;
          goto LABEL_12;
        }
      }
      v17 = 0;
LABEL_12:
      if (a1[12].u8[13] != v17)
      {
        v19 = *(_QWORD *)(a2 + 8);
        v20 = vsubq_f32(v8, a1[14]);
        v21 = vmulq_f32(v20, v20);
        v22 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0];
        if (v22 < (float)(a1[12].f32[1] * a1[12].f32[1]))
          v22 = a1[12].f32[1] * a1[12].f32[1];
        v23 = v22;
        v24 = vrecpe_f32((float32x2_t)LODWORD(v22));
        v25 = vmul_f32(v24, vrecps_f32((float32x2_t)LODWORD(v23), v24));
        v26 = vaddq_f32(*(float32x4_t *)(v19 + 16 * v6), vmulq_n_f32(v20, (float)(*(float *)(*(_QWORD *)(a2 + 16) + (*(_DWORD *)(a2 + 24) * v6))* (float)(v9 * *(float *)(*(_QWORD *)(a2 + 32) + (*(_DWORD *)(a2 + 40) * v6))))* vmul_f32(v25, vrecps_f32((float32x2_t)LODWORD(v23), v25)).f32[0]));
        v26.i32[3] = HIDWORD(*(_OWORD *)(v19 + 16 * v6));
        *(float32x4_t *)(v19 + 16 * v6) = v26;
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void c3dPhysicsFieldMagnetic::c3dPhysicsFieldMagnetic(c3dPhysicsFieldMagnetic *this)
{
  uint64_t v1;
  __int128 v2;
  __int128 v3;

  *(_QWORD *)this = off_1EA596220;
  v1 = MEMORY[0x1E0C83FF0];
  v2 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x1E0C83FF0];
  *((_OWORD *)this + 6) = v2;
  v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(_QWORD *)this = &off_1EA597820;
  *((_OWORD *)this + 16) = xmmword_1DD007A00;
}

float32x4_t c3dPhysicsFieldMagnetic::_transformHasChanged(c3dPhysicsFieldMagnetic *this)
{
  float32x4_t result;
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;

  result = *((float32x4_t *)this + 1);
  v2 = *((float32x4_t *)this + 2);
  v3 = *((float32x4_t *)this + 3);
  v4 = vaddq_f32(*((float32x4_t *)this + 4), vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v2, *(float32x2_t *)((char *)this + 144), 1), result, COERCE_FLOAT(*((_OWORD *)this + 9))), v3, *((float32x4_t *)this + 9), 2));
  v5 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v2, *(float32x2_t *)((char *)this + 256), 1), result, COERCE_FLOAT(*((_OWORD *)this + 16))), v3, *((float32x4_t *)this + 16), 2);
  *((float32x4_t *)this + 14) = v4;
  *((float32x4_t *)this + 15) = v5;
  return result;
}

float32x4_t c3dPhysicsField::_transformHasChanged(c3dPhysicsField *this)
{
  float32x4_t result;

  result = vaddq_f32(*(float32x4_t *)&this[2].var0, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(*(float32x4_t *)&this[1].var0, *(float32x2_t *)&this[4].var5, 1), *(float32x4_t *)&this->var5, COERCE_FLOAT(*(_OWORD *)&this[4].var5)), *(float32x4_t *)&this[1].var5, *(float32x4_t *)&this[4].var5, 2));
  *(float32x4_t *)&this[7].var0 = result;
  return result;
}

double c3dPhysicsFieldMagnetic::evalForce(uint64_t a1, float32x4_t a2, float32x4_t a3, double a4, float a5)
{
  float32x4_t v5;
  int32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float v9;
  double result;

  v5 = vsubq_f32(a2, *(float32x4_t *)(a1 + 224));
  v6 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*(int32x4_t *)(a1 + 240), *(int32x4_t *)(a1 + 240)), *(int8x16_t *)(a1 + 240), 0xCuLL), vnegq_f32(a3)), *(float32x4_t *)(a1 + 240), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a3, (int32x4_t)a3), (int8x16_t)a3, 0xCuLL));
  v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v6, v6), (int8x16_t)v6, 0xCuLL);
  v8 = vmulq_f32(v5, v5);
  v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0];
  if (v9 < (float)(*(float *)(a1 + 196) * *(float *)(a1 + 196)))
    v9 = *(float *)(a1 + 196) * *(float *)(a1 + 196);
  *(_QWORD *)&result = vmulq_n_f32(v7, (float)(*(float *)(a1 + 208) * a5) / sqrtf(v9)).u64[0];
  return result;
}

void c3dPhysicsFieldMagnetic::evalForceBatch(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v6;
  uint64_t v7;
  float32x4_t v8;
  float v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float v13;
  float32x4_t v14;
  float v15;
  float v16;
  int v17;
  uint32x4_t v18;
  uint64_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float v25;
  float v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x4_t v29;
  float32x4_t v30;

  if (a3 < a4)
  {
    v6 = a3;
    v7 = a4;
    do
    {
      v8 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6);
      v9 = *(float *)(a2 + 56) * *(float *)(a1 + 160);
      v10 = vaddq_f32(*(float32x4_t *)(a1 + 128), vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(*(float32x4_t *)(a1 + 96), *(float32x2_t *)v8.f32, 1), *(float32x4_t *)(a1 + 80), v8.f32[0]), *(float32x4_t *)(a1 + 112), v8, 2));
      if (*(_BYTE *)(a1 + 207))
      {
        v11 = vmulq_f32(v10, *(float32x4_t *)(a1 + 176));
        v12 = vmulq_f32(v11, v11);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0] < 1.0)goto LABEL_5;
      }
      else
      {
        v18 = (uint32x4_t)vcgtq_f32(*(float32x4_t *)(a1 + 176), vabsq_f32(v10));
        v18.i32[3] = v18.i32[2];
        if ((vminvq_u32(v18) & 0x80000000) != 0)
        {
LABEL_5:
          v13 = *(float *)(a1 + 192);
          if (v13 > 0.0)
          {
            v14 = vmulq_f32(v10, v10);
            v15 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0])- *(float *)(a1 + 196);
            v16 = 1.0;
            if (v15 >= 0.0)
            {
              v30 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6);
              v16 = powf(v15, -v13);
              v8 = v30;
            }
            v9 = v9 * v16;
          }
          v17 = 1;
          goto LABEL_12;
        }
      }
      v17 = 0;
LABEL_12:
      if (*(unsigned __int8 *)(a1 + 205) != v17)
      {
        v19 = *(_QWORD *)(a2 + 8);
        v20 = vsubq_f32(v8, *(float32x4_t *)(a1 + 224));
        v21 = *(float32x4_t *)(v19 + 16 * v6);
        v22 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*(int32x4_t *)(a1 + 240), *(int32x4_t *)(a1 + 240)), *(int8x16_t *)(a1 + 240), 0xCuLL), vnegq_f32(v21)), *(float32x4_t *)(a1 + 240), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), (int8x16_t)v21, 0xCuLL));
        v23 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), v22, 0xCuLL);
        v24 = vmulq_f32(v20, v20);
        v25 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0];
        if (v25 < (float)(*(float *)(a1 + 196) * *(float *)(a1 + 196)))
          v25 = *(float *)(a1 + 196) * *(float *)(a1 + 196);
        v26 = v25;
        v27 = vrsqrte_f32((float32x2_t)LODWORD(v25));
        v28 = vmul_f32(v27, vrsqrts_f32((float32x2_t)LODWORD(v26), vmul_f32(v27, v27)));
        v29 = vaddq_f32(v21, vmulq_n_f32(v23, *(float *)(*(_QWORD *)(a2 + 16) + (*(_DWORD *)(a2 + 24) * v6))* (float)((float)(v9 * *(float *)(*(_QWORD *)(a2 + 32) + (*(_DWORD *)(a2 + 40) * v6)))* vmul_f32(v28, vrsqrts_f32((float32x2_t)LODWORD(v26), vmul_f32(v28, v28))).f32[0])));
        v29.i32[3] = HIDWORD(*(_OWORD *)(v19 + 16 * v6));
        *(float32x4_t *)(v19 + 16 * v6) = v29;
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void c3dPhysicsFieldDrag::c3dPhysicsFieldDrag(c3dPhysicsFieldDrag *this)
{
  uint64_t v1;
  __int128 v2;
  __int128 v3;

  *(_QWORD *)this = off_1EA596220;
  v1 = MEMORY[0x1E0C83FF0];
  v2 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x1E0C83FF0];
  *((_OWORD *)this + 6) = v2;
  v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(_QWORD *)this = &off_1EA596D60;
}

double c3dPhysicsFieldDrag::evalForce(uint64_t a1, double a2, float32x4_t a3)
{
  double result;

  *(_QWORD *)&result = vmulq_n_f32(vnegq_f32(a3), *(float *)(a1 + 208)).u64[0];
  return result;
}

void c3dPhysicsFieldDrag::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v6;
  uint64_t v7;
  float v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float v12;
  float32x4_t v13;
  float v14;
  float v15;
  int v16;
  uint32x4_t v17;
  uint64_t v18;
  float32x4_t v19;

  if (a3 < a4)
  {
    v6 = a3;
    v7 = a4;
    do
    {
      v8 = *(float *)(a2 + 56) * a1[10].f32[0];
      v9 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)(*(_QWORD *)a2 + 16 * v6), 1), a1[5], COERCE_FLOAT(*(_OWORD *)(*(_QWORD *)a2 + 16 * v6))), a1[7], *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6), 2));
      if (a1[12].i8[15])
      {
        v10 = vmulq_f32(v9, a1[11]);
        v11 = vmulq_f32(v10, v10);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0] < 1.0)goto LABEL_5;
      }
      else
      {
        v17 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v9));
        v17.i32[3] = v17.i32[2];
        if ((vminvq_u32(v17) & 0x80000000) != 0)
        {
LABEL_5:
          v12 = a1[12].f32[0];
          if (v12 > 0.0)
          {
            v13 = vmulq_f32(v9, v9);
            v14 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0])- a1[12].f32[1];
            v15 = 1.0;
            if (v14 >= 0.0)
              v15 = powf(v14, -v12);
            v8 = v8 * v15;
          }
          v16 = 1;
          goto LABEL_12;
        }
      }
      v16 = 0;
LABEL_12:
      if (a1[12].u8[13] != v16)
      {
        v18 = *(_QWORD *)(a2 + 8);
        v19 = vmlaq_n_f32(*(float32x4_t *)(v18 + 16 * v6), *(float32x4_t *)(v18 + 16 * v6), -(float)(v8 * *(float *)(*(_QWORD *)(a2 + 16) + (*(_DWORD *)(a2 + 24) * v6))));
        v19.i32[3] = HIDWORD(*(_OWORD *)(v18 + 16 * v6));
        *(float32x4_t *)(v18 + 16 * v6) = v19;
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void c3dPhysicsFieldCustom::c3dPhysicsFieldCustom(c3dPhysicsFieldCustom *this)
{
  _OWORD *v1;
  __int128 v2;
  __int128 v3;

  v1 = (_OWORD *)MEMORY[0x1E0C83FF0];
  *(_QWORD *)this = off_1EA596220;
  v2 = v1[1];
  *((_OWORD *)this + 5) = *v1;
  *((_OWORD *)this + 6) = v2;
  v3 = v1[3];
  *((_OWORD *)this + 7) = v1[2];
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(_QWORD *)this = &off_1EA597140;
  *((_QWORD *)this + 30) = 0;
}

double c3dPhysicsFieldCustom::evalForce(uint64_t a1, __n128 a2)
{
  unsigned __int32 v2;
  uint64_t v3;

  v2 = a2.n128_u32[1];
  v3 = *(_QWORD *)(a1 + 240);
  if (v3)
    (*(void (**)(__n128, float, float))(v3 + 16))(a2, a2.n128_f32[1], a2.n128_f32[2]);
  a2.n128_u32[1] = v2;
  return a2.n128_f64[0];
}

void c3dPhysicsFieldCustom::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4;
  BOOL v5;
  unsigned int v7;
  uint64_t v10;
  __n128 v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  unsigned int v15;
  uint32x4_t v16;
  float32x4_t v17;
  unsigned __int32 v18;
  unsigned __int32 v19;
  uint64_t v20;
  float32x4_t v21;

  v4 = a1[15].i64[0];
  if (v4)
    v5 = a3 >= a4;
  else
    v5 = 1;
  if (!v5)
  {
    v7 = a3;
    v10 = 16 * a3;
    do
    {
      v11 = *(__n128 *)(*(_QWORD *)a2 + v10);
      v12 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], (float32x2_t)v11.n128_u64[0], 1), a1[5], v11.n128_f32[0]), a1[7], (float32x4_t)v11, 2));
      if (a1[12].i8[15])
      {
        v13 = vmulq_f32(v12, a1[11]);
        v14 = vmulq_f32(v13, v13);
        v15 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0] < 1.0;
      }
      else
      {
        v16 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v12));
        v16.i32[3] = v16.i32[2];
        v15 = vminvq_u32(v16) >> 31;
      }
      if (a1[12].u8[13] != v15)
      {
        v17 = (float32x4_t)((__n128 (*)(uint64_t, __n128, float, float, float, float, float, float, float, double))*(_QWORD *)(v4 + 16))(v4, v11, v11.n128_f32[1], v11.n128_f32[2], *(float *)(*(_QWORD *)(a2 + 8) + v10), *(float *)(*(_QWORD *)(a2 + 8) + v10 + 4), *(float *)(*(_QWORD *)(a2 + 8) + v10 + 8), 1.0 / *(float *)(*(_QWORD *)(a2 + 16) + *(_DWORD *)(a2 + 24) * v7), *(float *)(*(_QWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40) * v7), *(float *)(a2 + 60));
        v17.i32[1] = v18;
        v17.i32[2] = v19;
        v20 = *(_QWORD *)(a2 + 8);
        v21 = vaddq_f32(*(float32x4_t *)(v20 + v10), vmulq_n_f32(v17, *(float *)(a2 + 56)));
        v21.i32[3] = HIDWORD(*(_OWORD *)(v20 + v10));
        *(float32x4_t *)(v20 + v10) = v21;
      }
      v10 += 16;
      ++v7;
    }
    while (a4 != v7);
  }
}

void c3dPhysicsFieldVortex::c3dPhysicsFieldVortex(c3dPhysicsFieldVortex *this)
{
  uint64_t v1;
  __int128 v2;
  __int128 v3;

  *(_QWORD *)this = off_1EA596220;
  v1 = MEMORY[0x1E0C83FF0];
  v2 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x1E0C83FF0];
  *((_OWORD *)this + 6) = v2;
  v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(_QWORD *)this = &off_1EA5971C0;
  *((_OWORD *)this + 15) = xmmword_1DD007600;
}

double c3dPhysicsFieldVortex::evalForce(float32x4_t *a1, float32x4_t a2, double a3, float a4)
{
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  int8x16_t v12;
  int32x4_t v13;
  double result;

  v4 = vsubq_f32(a2, a1[14]);
  v5 = vmulq_f32(v4, v4);
  v6 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v4, (int32x4_t)v4), (int8x16_t)v4, 0xCuLL), vnegq_f32(a1[16])), v4, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a1[16], (int32x4_t)a1[16]), (int8x16_t)a1[16], 0xCuLL));
  v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL);
  v8 = vmulq_f32(v6, v6);
  v8.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), v8)).u64[0];
  v9 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 0);
  v10 = vrsqrteq_f32(v9);
  v11 = vmulq_f32(v10, vrsqrtsq_f32(v9, vmulq_f32(v10, v10)));
  v12 = (int8x16_t)vmulq_f32(v11, vrsqrtsq_f32(v9, vmulq_f32(v11, v11)));
  v13 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v8.f32[0] != 0.0)), 0x1FuLL));
  v13.i32[3] = 0;
  __asm { FMOV            V5.4S, #1.0 }
  *(_QWORD *)&result = vmulq_n_f32(vmulq_f32(v7, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v13), v12, _Q5)), (float)(a1[13].f32[0] * a4)* sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0])).u64[0];
  return result;
}

void c3dPhysicsFieldVortex::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v6;
  uint64_t v12;
  float32x4_t v13;
  float v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float v18;
  float32x4_t v19;
  float v20;
  float v21;
  int v22;
  uint32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int32x4_t v31;
  float32x4_t v32;
  uint64_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;

  if (a3 < a4)
  {
    v6 = a3;
    __asm { FMOV            V6.4S, #1.0 }
    v12 = a4;
    v35 = _Q6;
    do
    {
      v13 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6);
      v14 = *(float *)(a2 + 56) * a1[10].f32[0];
      v15 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v13.f32, 1), a1[5], v13.f32[0]), a1[7], v13, 2));
      if (a1[12].i8[15])
      {
        v16 = vmulq_f32(v15, a1[11]);
        v17 = vmulq_f32(v16, v16);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0] < 1.0)goto LABEL_5;
      }
      else
      {
        v23 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v15));
        v23.i32[3] = v23.i32[2];
        if ((vminvq_u32(v23) & 0x80000000) != 0)
        {
LABEL_5:
          v18 = a1[12].f32[0];
          if (v18 > 0.0)
          {
            v19 = vmulq_f32(v15, v15);
            v20 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).f32[0])- a1[12].f32[1];
            v21 = 1.0;
            if (v20 >= 0.0)
            {
              v36 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v6);
              v21 = powf(v20, -v18);
              _Q6 = v35;
              v13 = v36;
            }
            v14 = v14 * v21;
          }
          v22 = 1;
          goto LABEL_12;
        }
      }
      v22 = 0;
LABEL_12:
      if (a1[12].u8[13] != v22)
      {
        v24 = vsubq_f32(v13, a1[14]);
        v25 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), (int8x16_t)v24, 0xCuLL), vnegq_f32(a1[16])), v24, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a1[16], (int32x4_t)a1[16]), (int8x16_t)a1[16], 0xCuLL));
        v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL);
        v27 = vmulq_f32(v25, v25);
        v27.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), v27)).u64[0];
        v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0);
        v29 = vrsqrteq_f32(v28);
        v30 = vmulq_f32(v29, vrsqrtsq_f32(v28, vmulq_f32(v29, v29)));
        v31 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v27.f32[0] != 0.0)), 0x1FuLL));
        v31.i32[3] = 0;
        v32 = vmulq_f32(v24, v24);
        v33 = *(_QWORD *)(a2 + 8);
        v34 = vaddq_f32(*(float32x4_t *)(v33 + 16 * v6), vmulq_n_f32(vmulq_f32(v26, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v31), (int8x16_t)vmulq_f32(v30, vrsqrtsq_f32(v28, vmulq_f32(v30, v30))), _Q6)), v14* sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).f32[0])));
        v34.i32[3] = HIDWORD(*(_OWORD *)(v33 + 16 * v6));
        *(float32x4_t *)(v33 + 16 * v6) = v34;
      }
      ++v6;
    }
    while (v12 != v6);
  }
}

float32x4_t c3dPhysicsFieldVortex::_transformHasChanged(c3dPhysicsFieldVortex *this)
{
  float32x4_t result;
  float32x4_t v2;
  float32x4_t v3;

  result = *((float32x4_t *)this + 1);
  v2 = *((float32x4_t *)this + 2);
  v3 = *((float32x4_t *)this + 3);
  *((float32x4_t *)this + 14) = vaddq_f32(*((float32x4_t *)this + 4), vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v2, *(float32x2_t *)((char *)this + 144), 1), result, COERCE_FLOAT(*((_OWORD *)this + 9))), v3, *((float32x4_t *)this + 9), 2));
  *((float32x4_t *)this + 16) = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v2, *(float32x2_t *)((char *)this + 240), 1), result, COERCE_FLOAT(*((_OWORD *)this + 15))), v3, *((float32x4_t *)this + 15), 2);
  return result;
}

void c3dPhysicsFieldNoise::c3dPhysicsFieldNoise(c3dPhysicsFieldNoise *this)
{
  uint64_t v1;
  __int128 v2;
  __int128 v3;

  *(_QWORD *)this = off_1EA596220;
  v1 = MEMORY[0x1E0C83FF0];
  v2 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x1E0C83FF0];
  *((_OWORD *)this + 6) = v2;
  v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *(_QWORD *)this = &off_1EA596EE8;
  *((_QWORD *)this + 30) = 1056964608;
}

double c3dPhysicsFieldNoise::evalForce(float *a1, float32x4_t a2, double a3, double a4, double a5, float a6)
{
  float v7;
  float v8;
  BOOL v9;
  float v10;
  float v11;
  float v12;
  float32x4_t v13;
  double result;
  __int32 v15;
  uint64_t v16;

  v7 = a1[60];
  v8 = (float)(1.25 / (float)(v7 + 0.083333)) + -1.0;
  v9 = v7 <= 0.0;
  v10 = 14.0;
  if (!v9)
    v10 = v8;
  v11 = a1[61] * a6;
  v16 = 0;
  v15 = 0;
  v12 = srdnoise3((float *)&v16 + 1, (float *)&v16, (float *)&v15, v10 * a2.f32[0], vmuls_lane_f32(v10, *(float32x2_t *)a2.f32, 1), vmuls_lane_f32(v10, a2, 2), v11);
  v13.i64[0] = __PAIR64__(v16, HIDWORD(v16));
  v13.i32[2] = v15;
  *(_QWORD *)&result = vmulq_n_f32(vmulq_n_f32(v13, v12), a1[52]).u64[0];
  return result;
}

void c3dPhysicsFieldNoise::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  float v4;
  float v5;
  unsigned int v6;
  float v9;
  uint64_t v10;
  float32x4_t v11;
  float v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float v16;
  float32x4_t v17;
  float v18;
  float v19;
  int v20;
  uint32x4_t v21;
  float v22;
  float v23;
  float32x4_t v24;
  uint64_t v25;
  float32x4_t v26;
  float32x4_t v27;
  __int32 v28;
  uint64_t v29;

  v4 = a1[15].f32[0];
  if (v4 <= 0.0)
    v5 = 14.0;
  else
    v5 = (float)(1.25 / (float)(v4 + 0.083333)) + -1.0;
  v6 = a4 - a3;
  if (a4 > a3)
  {
    v9 = a1[15].f32[1] * *(float *)(a2 + 60);
    v10 = a3;
    do
    {
      v11 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v10);
      v12 = *(float *)(a2 + 56) * a1[10].f32[0];
      v13 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v11.f32, 1), a1[5], v11.f32[0]), a1[7], v11, 2));
      if (a1[12].i8[15])
      {
        v14 = vmulq_f32(v13, a1[11]);
        v15 = vmulq_f32(v14, v14);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0] < 1.0)goto LABEL_8;
      }
      else
      {
        v21 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v13));
        v21.i32[3] = v21.i32[2];
        if ((vminvq_u32(v21) & 0x80000000) != 0)
        {
LABEL_8:
          v16 = a1[12].f32[0];
          if (v16 > 0.0)
          {
            v17 = vmulq_f32(v13, v13);
            v18 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0])- a1[12].f32[1];
            v19 = 1.0;
            if (v18 >= 0.0)
            {
              v27 = *(float32x4_t *)(*(_QWORD *)a2 + 16 * v10);
              v19 = powf(v18, -v16);
              v11 = v27;
            }
            v12 = v12 * v19;
          }
          v20 = 1;
          goto LABEL_15;
        }
      }
      v20 = 0;
LABEL_15:
      if (a1[12].u8[13] != v20)
      {
        v22 = *(float *)(*(_QWORD *)(a2 + 16) + (*(_DWORD *)(a2 + 24) * v10));
        v29 = 0;
        v28 = 0;
        v23 = srdnoise3((float *)&v29 + 1, (float *)&v29, (float *)&v28, v5 * v11.f32[0], vmuls_lane_f32(v5, *(float32x2_t *)v11.f32, 1), vmuls_lane_f32(v5, v11, 2), v9);
        v24.i64[0] = __PAIR64__(v29, HIDWORD(v29));
        v24.i32[2] = v28;
        v25 = *(_QWORD *)(a2 + 8);
        v26 = vmlaq_n_f32(*(float32x4_t *)(v25 + 16 * v10), v24, v22 * (float)(v12 * v23));
        v26.i32[3] = HIDWORD(*(_OWORD *)(v25 + 16 * v10));
        *(float32x4_t *)(v25 + 16 * v10) = v26;
      }
      ++v10;
      --v6;
    }
    while (v6);
  }
}

void c3dPhysicsFieldTurbulence::c3dPhysicsFieldTurbulence(c3dPhysicsFieldTurbulence *this)
{
  uint64_t v1;
  __int128 v2;
  __int128 v3;

  *(_QWORD *)this = off_1EA596220;
  v1 = MEMORY[0x1E0C83FF0];
  v2 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 16);
  *((_OWORD *)this + 5) = *MEMORY[0x1E0C83FF0];
  *((_OWORD *)this + 6) = v2;
  v3 = *(_OWORD *)(v1 + 48);
  *((_OWORD *)this + 7) = *(_OWORD *)(v1 + 32);
  *((_OWORD *)this + 8) = v3;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 1065353216;
  *((int32x4_t *)this + 11) = vdupq_n_s32(0x7F7FFFFFu);
  *((_QWORD *)this + 24) = 0x3800000000000000;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 51) = 16777217;
  *((_QWORD *)this + 30) = 1056964608;
  *(_QWORD *)this = &off_1EA597BC0;
}

double c3dPhysicsFieldTurbulence::evalForce(float *a1, float32x4_t a2, float32x4_t a3, double a4, double a5, float a6)
{
  float32x4_t v6;
  float32x4_t v7;
  double result;
  float v9;

  v9 = *(float *)&a4;
  *(double *)v6.i64 = c3dPhysicsFieldNoise::evalForce(a1, a2, *(double *)a3.i64, a4, a5, a6);
  v7 = vmulq_f32(a3, a3);
  *(_QWORD *)&result = vmulq_n_f32(vmulq_n_f32(v6, v9), sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0])).u64[0];
  return result;
}

void c3dPhysicsFieldTurbulence::evalForceBatch(float32x4_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  float v4;
  float v5;
  unsigned int v6;
  float v9;
  uint64_t v10;
  float32x4_t v11;
  float v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float v16;
  float32x4_t v17;
  float v18;
  float v19;
  int v20;
  uint32x4_t v21;
  float v22;
  float32x4_t v23;
  float32x4_t v24;
  uint64_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  __int32 v29;
  uint64_t v30;

  v4 = a1[15].f32[0];
  if (v4 <= 0.0)
    v5 = 14.0;
  else
    v5 = (float)(1.25 / (float)(v4 + 0.083333)) + -1.0;
  v6 = a4 - a3;
  if (a4 > a3)
  {
    v9 = a1[15].f32[1] * *(float *)(a2 + 60);
    v10 = 16 * a3;
    do
    {
      v11 = *(float32x4_t *)(*(_QWORD *)a2 + v10);
      v12 = *(float *)(a2 + 56) * a1[10].f32[0];
      v13 = vaddq_f32(a1[8], vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a1[6], *(float32x2_t *)v11.f32, 1), a1[5], v11.f32[0]), a1[7], v11, 2));
      if (a1[12].i8[15])
      {
        v14 = vmulq_f32(v13, a1[11]);
        v15 = vmulq_f32(v14, v14);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0] < 1.0)goto LABEL_8;
      }
      else
      {
        v21 = (uint32x4_t)vcgtq_f32(a1[11], vabsq_f32(v13));
        v21.i32[3] = v21.i32[2];
        if ((vminvq_u32(v21) & 0x80000000) != 0)
        {
LABEL_8:
          v16 = a1[12].f32[0];
          if (v16 > 0.0)
          {
            v17 = vmulq_f32(v13, v13);
            v18 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0])- a1[12].f32[1];
            v19 = 1.0;
            if (v18 >= 0.0)
            {
              v27 = *(float32x4_t *)(*(_QWORD *)a2 + v10);
              v19 = powf(v18, -v16);
              v11 = v27;
            }
            v12 = v12 * v19;
          }
          v20 = 1;
          goto LABEL_15;
        }
      }
      v20 = 0;
LABEL_15:
      if (a1[12].u8[13] != v20)
      {
        v28 = *(float32x4_t *)(*(_QWORD *)(a2 + 8) + v10);
        v30 = 0;
        v29 = 0;
        v22 = srdnoise3((float *)&v30 + 1, (float *)&v30, (float *)&v29, v5 * v11.f32[0], vmuls_lane_f32(v5, *(float32x2_t *)v11.f32, 1), vmuls_lane_f32(v5, v11, 2), v9);
        v23.i64[0] = __PAIR64__(v30, HIDWORD(v30));
        v23.i32[2] = v29;
        v24 = vmulq_f32(v28, v28);
        v25 = *(_QWORD *)(a2 + 8);
        v26 = vmlaq_n_f32(*(float32x4_t *)(v25 + v10), v23, sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0])* (float)(v12 * v22));
        v26.i32[3] = HIDWORD(*(_OWORD *)(v25 + v10));
        *(float32x4_t *)(v25 + v10) = v26;
      }
      v10 += 16;
      --v6;
    }
    while (v6);
  }
}

void c3dAether::c3dAether(c3dAether *this)
{
  this->_lastOverrideIndex = 0;
  *(_OWORD *)&this->_fields.__end_cap_.__value_ = 0u;
  *(_OWORD *)&this->_activeFields.__end_ = 0u;
  *(_OWORD *)&this->_fields.__begin_ = 0u;
}

void c3dAether::~c3dAether(c3dAether *this)
{
  c3dPhysicsField **end;
  c3dPhysicsField **begin;
  c3dPhysicsField **v4;
  c3dPhysicsField **v5;

  begin = this->_fields.__begin_;
  end = this->_fields.__end_;
  while (begin != end)
  {
    if (*begin)
    {
      (*((void (**)(c3dPhysicsField *))(*begin)->var0 + 1))(*begin);
      end = this->_fields.__end_;
    }
    ++begin;
  }
  v4 = this->_activeFields.__begin_;
  if (v4)
  {
    this->_activeFields.__end_ = v4;
    operator delete(v4);
  }
  v5 = this->_fields.__begin_;
  if (this->_fields.__begin_)
  {
    this->_fields.__end_ = v5;
    operator delete(v5);
  }
}

void c3dAether::evalForce(uint64_t a1, int a2, __n128 a3, __n128 a4, float a5, float a6, float a7)
{
  uint64_t v12;
  float32x4_t *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  float32x4_t *v17;
  float32x4_t v18;
  float32x4_t v21;
  __n128 v22;

  v22 = a3;
  if (*(_DWORD *)(a1 + 48))
  {
    v12 = 0;
    while (1)
    {
      v13 = *(float32x4_t **)(*(_QWORD *)(a1 + 24) + 8 * v12);
      if (c3dPhysicsField::contains(v13, (float32x2_t *)&v22) && (v13[12].i32[2] & a2) != 0)
        break;
      if (++v12 >= (unint64_t)*(unsigned int *)(a1 + 48))
        goto LABEL_8;
    }
    (*(void (**)(float32x4_t *, __n128, __n128, float, float, float))(v13->i64[0] + 16))(v13, a3, a4, a5, a6, a7);
  }
  else
  {
    LODWORD(v12) = 0;
LABEL_8:
    v14 = (*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 3;
    v15 = v14 - v12;
    if (v14 > v12)
    {
      v16 = 8 * v12;
      v21 = 0uLL;
      do
      {
        v17 = *(float32x4_t **)(*(_QWORD *)(a1 + 24) + v16);
        if (c3dPhysicsField::contains(v17, (float32x2_t *)&v22) && (v17[12].i32[2] & a2) != 0)
        {
          *(double *)v18.i64 = (*(double (**)(float32x4_t *, __n128, __n128, float, float, float))(v17->i64[0] + 16))(v17, a3, a4, a5, a6, a7);
          v21 = vaddq_f32(v21, v18);
        }
        v16 += 8;
        --v15;
      }
      while (v15);
    }
  }
}

void c3dAether::evalForcesBatch(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  float32x2_t v10;
  float32x2_t v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  uint64_t *v15;
  uint64_t *v16;
  float32x4_t v17;
  float v18;
  uint64_t v19;
  int32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  uint32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float v30;
  _OWORD v31[6];

  if (*(_DWORD *)(a1 + 48))
  {
    v8 = a4 - a3;
    if (a4 > a3)
    {
      v9 = a3;
      do
      {
        v30 = *(float *)(a2[1].i64[0] + (a2[1].i32[2] * v9));
        v10 = vrecpe_f32((float32x2_t)LODWORD(v30));
        v11 = vmul_f32(v10, vrecps_f32((float32x2_t)LODWORD(v30), v10));
        c3dAether::evalForce(a1, a2[3].i64[0], *(__n128 *)(a2->i64[0] + 16 * v9), *(__n128 *)(a2->i64[1] + 16 * v9), vmul_f32(v11, vrecps_f32((float32x2_t)LODWORD(v30), v11)).f32[0], *(float *)(a2[2].i64[0] + (a2[2].i32[2] * v9)), a2[3].f32[3]);
        v12 = a2->i64[1];
        v14 = vmlaq_n_f32(*(float32x4_t *)(v12 + 16 * v9), v13, v30 * a2[3].f32[2]);
        v14.i32[3] = HIDWORD(*(_OWORD *)(v12 + 16 * v9));
        *(float32x4_t *)(v12 + 16 * v9++) = v14;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    v16 = *(uint64_t **)(a1 + 24);
    v15 = *(uint64_t **)(a1 + 32);
    if (v16 != v15)
    {
      v17 = 0uLL;
      v18 = 1.0;
      do
      {
        v19 = *v16;
        if ((a2[3].i64[0] & *(unsigned int *)(*v16 + 200)) != 0)
        {
          v20 = *(int32x4_t *)(v19 + 176);
          v20.i32[3] = 0;
          v21 = *(float32x4_t *)(v19 + 16);
          v22 = *(float32x4_t *)(v19 + 32);
          v23 = *(float32x4_t *)(v19 + 48);
          v24 = vaddq_f32(*(float32x4_t *)(v19 + 64), vmlaq_f32(vmlaq_f32(vmulq_f32(v22, v17), v17, v21), v17, v23));
          v25 = (float32x4_t)v20;
          v25.i32[1] = *(_OWORD *)(v19 + 176);
          v25.i32[2] = v25.i32[1];
          v24.f32[3] = v18;
          v26 = (uint32x4_t)vcgeq_f32(vaddq_f32(a2[5], vaddq_f32(vaddq_f32(vabsq_f32(vmulq_f32(v21, v25)), vabsq_f32(vmulq_f32(v22, (float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v20.i8, 1), v20)))), vabsq_f32(vmulq_f32((float32x4_t)vzip2q_s32(vtrn1q_s32(v20, v20), v20), v23)))), vabdq_f32(a2[4], v24));
          v26.i32[3] = v26.i32[2];
          if ((vminvq_u32(v26) & 0x80000000) != 0)
          {
            v27 = a2[1];
            v31[0] = *a2;
            v31[1] = v27;
            v28 = a2[5];
            v31[4] = a2[4];
            v31[5] = v28;
            v29 = a2[3];
            v31[2] = a2[2];
            v31[3] = v29;
            (*(void (**)(uint64_t, _OWORD *, uint64_t, uint64_t))(*(_QWORD *)v19 + 24))(v19, v31, a3, a4);
            v18 = 1.0;
            v17 = 0uLL;
            v15 = *(uint64_t **)(a1 + 32);
          }
        }
        ++v16;
      }
      while (v16 != v15);
    }
  }
}

void c3dAether::fieldsModeHaveChanged(c3dAether *this)
{
  c3dPhysicsField **begin;
  c3dPhysicsField **end;
  c3dPhysicsField **v4;
  __compressed_pair<c3dPhysicsField **, std::allocator<c3dPhysicsField *>> *p_end_cap;
  c3dPhysicsField *v6;
  c3dPhysicsField **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  c3dPhysicsField **v13;
  c3dPhysicsField **v14;
  c3dPhysicsField **v15;
  c3dPhysicsField *v16;
  c3dPhysicsField **v17;
  int v18;
  int v19;
  c3dPhysicsField **v20;
  c3dPhysicsField *v21;

  begin = this->_activeFields.__begin_;
  this->_activeFields.__end_ = begin;
  v4 = this->_fields.__begin_;
  end = this->_fields.__end_;
  if (this->_fields.__begin_ == end)
  {
    this->_lastOverrideIndex = 0;
  }
  else
  {
    p_end_cap = &this->_activeFields.__end_cap_;
    do
    {
      v6 = *v4;
      if (LOBYTE((*v4)[6].var4))
      {
        if (begin >= p_end_cap->__value_)
        {
          v7 = this->_activeFields.__begin_;
          v8 = begin - v7;
          if ((unint64_t)(v8 + 1) >> 61)
            abort();
          v9 = (char *)p_end_cap->__value_ - (char *)v7;
          v10 = v9 >> 2;
          if (v9 >> 2 <= (unint64_t)(v8 + 1))
            v10 = v8 + 1;
          if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
            v11 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v11 = v10;
          if (v11)
          {
            v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)&this->_activeFields.__end_cap_, v11);
            v6 = *v4;
          }
          else
          {
            v12 = 0;
          }
          v13 = (c3dPhysicsField **)&v12[8 * v8];
          *v13 = v6;
          begin = v13 + 1;
          v15 = this->_activeFields.__begin_;
          v14 = this->_activeFields.__end_;
          if (v14 != v15)
          {
            do
            {
              v16 = *--v14;
              *--v13 = v16;
            }
            while (v14 != v15);
            v14 = this->_activeFields.__begin_;
          }
          this->_activeFields.__begin_ = v13;
          this->_activeFields.__end_ = begin;
          this->_activeFields.__end_cap_.__value_ = (c3dPhysicsField **)&v12[8 * v11];
          if (v14)
            operator delete(v14);
        }
        else
        {
          *begin++ = v6;
        }
        this->_activeFields.__end_ = begin;
        end = this->_fields.__end_;
      }
      ++v4;
    }
    while (v4 != end);
    v17 = this->_activeFields.__begin_;
    this->_lastOverrideIndex = 0;
    if (v17 != begin)
    {
      v18 = 0;
      v19 = 0;
      do
      {
        if (BYTE2((*v17)[6].var4))
        {
          if (v19 != v18)
          {
            v20 = this->_activeFields.__begin_;
            v21 = v20[v19];
            v20[v19] = v20[v18];
            v20[v18] = v21;
            begin = this->_activeFields.__end_;
          }
          this->_lastOverrideIndex = ++v18;
        }
        ++v17;
        ++v19;
      }
      while (v17 != begin);
    }
  }
}

void c3dAether::addField(c3dAether *this, c3dPhysicsField *a2)
{
  __compressed_pair<c3dPhysicsField **, std::allocator<c3dPhysicsField *>> *p_end_cap;
  c3dPhysicsField **v5;
  c3dPhysicsField **value;
  c3dPhysicsField **v7;
  c3dPhysicsField **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  c3dPhysicsField **v14;
  c3dPhysicsField **v15;
  c3dPhysicsField **end;
  c3dPhysicsField **begin;
  c3dPhysicsField *v18;

  value = this->_fields.__end_cap_.__value_;
  p_end_cap = &this->_fields.__end_cap_;
  v5 = value;
  v7 = p_end_cap[-1].__value_;
  if (v7 >= value)
  {
    v9 = v7 - this->_fields.__begin_;
    if ((unint64_t)(v9 + 1) >> 61)
      abort();
    v10 = (char *)v5 - (char *)this->_fields.__begin_;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<Statement *>>((uint64_t)p_end_cap, v12);
    else
      v13 = 0;
    v14 = (c3dPhysicsField **)&v13[8 * v9];
    v15 = (c3dPhysicsField **)&v13[8 * v12];
    *v14 = a2;
    v8 = v14 + 1;
    begin = this->_fields.__begin_;
    end = this->_fields.__end_;
    if (end != this->_fields.__begin_)
    {
      do
      {
        v18 = *--end;
        *--v14 = v18;
      }
      while (end != begin);
      end = this->_fields.__begin_;
    }
    this->_fields.__begin_ = v14;
    this->_fields.__end_ = v8;
    this->_fields.__end_cap_.__value_ = v15;
    if (end)
      operator delete(end);
  }
  else
  {
    *v7 = a2;
    v8 = v7 + 1;
  }
  this->_fields.__end_ = v8;
  c3dAether::fieldsModeHaveChanged(this);
}

void c3dAether::removeField(c3dAether *this, c3dPhysicsField *a2)
{
  c3dPhysicsField **end;
  c3dPhysicsField **begin;
  uint64_t v5;
  c3dPhysicsField **v6;
  c3dPhysicsField **v7;
  int64_t v8;

  begin = this->_fields.__begin_;
  end = this->_fields.__end_;
  if (this->_fields.__begin_ != end)
  {
    v5 = 0;
    while (begin[v5] != a2)
    {
      if (&begin[++v5] == end)
        goto LABEL_9;
    }
    v6 = &begin[v5];
    v7 = &begin[v5 + 1];
    v8 = (char *)end - (char *)v7;
    if (end != v7)
      memmove(&begin[v5], v7, (char *)end - (char *)v7);
    this->_fields.__end_ = (c3dPhysicsField **)((char *)v6 + v8);
  }
LABEL_9:
  c3dAether::fieldsModeHaveChanged(this);
}

void c3dPhysicsFieldLinearGravity::~c3dPhysicsFieldLinearGravity(c3dPhysicsFieldLinearGravity *this)
{
  JUMPOUT(0x1DF0D41C0);
}

uint64_t c3dPhysicsFieldLinearGravity::type(c3dPhysicsFieldLinearGravity *this)
{
  return 1;
}

void c3dPhysicsFieldRadialGravity::~c3dPhysicsFieldRadialGravity(c3dPhysicsFieldRadialGravity *this)
{
  JUMPOUT(0x1DF0D41C0);
}

uint64_t c3dPhysicsFieldRadialGravity::type(c3dPhysicsFieldRadialGravity *this)
{
  return 2;
}

void c3dPhysicsFieldSpring::~c3dPhysicsFieldSpring(c3dPhysicsFieldSpring *this)
{
  JUMPOUT(0x1DF0D41C0);
}

uint64_t c3dPhysicsFieldSpring::type(c3dPhysicsFieldSpring *this)
{
  return 3;
}

void c3dPhysicsFieldElectric::~c3dPhysicsFieldElectric(c3dPhysicsFieldElectric *this)
{
  JUMPOUT(0x1DF0D41C0);
}

uint64_t c3dPhysicsFieldElectric::type(c3dPhysicsFieldElectric *this)
{
  return 5;
}

void c3dPhysicsFieldMagnetic::~c3dPhysicsFieldMagnetic(c3dPhysicsFieldMagnetic *this)
{
  JUMPOUT(0x1DF0D41C0);
}

uint64_t c3dPhysicsFieldMagnetic::type(c3dPhysicsFieldMagnetic *this)
{
  return 4;
}

void c3dPhysicsFieldDrag::~c3dPhysicsFieldDrag(c3dPhysicsFieldDrag *this)
{
  JUMPOUT(0x1DF0D41C0);
}

uint64_t c3dPhysicsFieldDrag::type(c3dPhysicsFieldDrag *this)
{
  return 6;
}

void c3dPhysicsFieldCustom::~c3dPhysicsFieldCustom(c3dPhysicsFieldCustom *this)
{
  JUMPOUT(0x1DF0D41C0);
}

uint64_t c3dPhysicsFieldCustom::type(c3dPhysicsFieldCustom *this)
{
  return 10;
}

void c3dPhysicsFieldVortex::~c3dPhysicsFieldVortex(c3dPhysicsFieldVortex *this)
{
  JUMPOUT(0x1DF0D41C0);
}

uint64_t c3dPhysicsFieldVortex::type(c3dPhysicsFieldVortex *this)
{
  return 7;
}

void c3dPhysicsFieldNoise::~c3dPhysicsFieldNoise(c3dPhysicsFieldNoise *this)
{
  JUMPOUT(0x1DF0D41C0);
}

uint64_t c3dPhysicsFieldNoise::type(c3dPhysicsFieldNoise *this)
{
  return 8;
}

void c3dPhysicsFieldTurbulence::~c3dPhysicsFieldTurbulence(c3dPhysicsFieldTurbulence *this)
{
  JUMPOUT(0x1DF0D41C0);
}

uint64_t c3dPhysicsFieldTurbulence::type(c3dPhysicsFieldTurbulence *this)
{
  return 9;
}

uint64_t SCNAudioPlayerWasRemovedFromNode(uint64_t result)
{
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 40) = 0;
  return result;
}

void sub_1DCD4FA48(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_0_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

void _C3DHitTestResultCFFinalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

CFStringRef _C3DHitTestResultCFCopyDebugDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  uint64_t Name;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Name = *(_QWORD *)(a1 + 16);
  if (Name)
    Name = C3DNodeGetName(Name);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<C3DHitTestResult %@ %f,%f,%f>"), Name, *(float *)(a1 + 96), *(float *)(a1 + 100), *(float *)(a1 + 104));
}

uint64_t C3DHitTestResultCreate()
{
  if (C3DHitTestResultGetTypeID_onceToken != -1)
    dispatch_once(&C3DHitTestResultGetTypeID_onceToken, &__block_literal_global_9);
  return C3DTypeCreateInstance_(C3DHitTestResultGetTypeID_typeID, 0xD0uLL);
}

uint64_t C3DHitTestResultGetNode(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 16);
}

uint64_t C3DHitTestResultGetJoint(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 24);
}

CFTypeRef C3DHitTestResultSetNode(uint64_t a1, CFTypeRef cf)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef result;

  if (!a1)
  {
    v4 = scn_default_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      C3DHitTestResultGetNode_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  result = *(CFTypeRef *)(a1 + 16);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(_QWORD *)(a1 + 16) = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    *(_QWORD *)(a1 + 16) = result;
  }
  return result;
}

uint64_t C3DHitTestResultGetGeometryElementIndex(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 32);
}

uint64_t C3DHitTestResultGetPrimitiveIndex(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!a1)
  {
    v2 = scn_default_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      C3DHitTestResultGetNode_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return *(_QWORD *)(a1 + 40);
}

